  1
#define NDIS51                  1

#include <ndis.h>

#include "univ.h"
#include "load.h"
#include "util.h"
#include "wlbsip.h"
#include "wlbsparm.h"
#include "params.h"
#include "wlbsiocl.h"
#include "diplist.h"

#if defined (NLB_HOOK_ENABLE)
#include <ntddnlb.h>
#endif

/* NOTE: This assumes that we're on a little endian architecture, like x86 or IA64. */
#define HTONS(x) ((USHORT)((((x) & 0x000000ff) << 8) | (((x) & 0x0000ff00) >> 8)))
#define NTOHS(x) ((USHORT)((((x) & 0x000000ff) << 8) | (((x) & 0x0000ff00) >> 8)))

/* CONSTANTS */


/* type codes for main datastructures */

#define MAIN_CTXT_CODE              0xc0dedead
#define MAIN_ACTION_CODE            0xc0deac10
#define MAIN_BUFFER_CODE            0xc0deb4fe
#define MAIN_ADAPTER_CODE           0xc0deadbe

/* protocol specific constants */

#define MAIN_FRAME_SIG              0x886f          /* new and approved 802.3 ping frame signature */
#define MAIN_FRAME_SIG_OLD          0xbf01          /* old convoy 802.3 ping frame signature */
#define MAIN_FRAME_CODE             0xc0de01bf      /* ping frame code */
#define MAIN_FRAME_EX_CODE          0xc0de01c0      /* code for identity heartbeats*/
#define MAIN_IP_SIG                 0x0800          /* IP code for IGMP messages */

/* reset states */

#define MAIN_RESET_NONE             0
#define MAIN_RESET_START            1
#define MAIN_RESET_START_DONE       2
#define MAIN_RESET_END              3

/* post-filtering operation types */

#define MAIN_FILTER_OP_NONE          0       /* not operation */
#define MAIN_FILTER_OP_NBT           1       /* netbios spoofing */
#define MAIN_FILTER_OP_CTRL_REQUEST  2       /* remote control requests */
#define MAIN_FILTER_OP_CTRL_RESPONSE 3       /* remote control responses */

/* extended heartbeat type */
#define MAIN_PING_EX_TYPE_NONE       0       /* invalid number */
#define MAIN_PING_EX_TYPE_IDENTITY   1       /* identity heartbeat */

/* packet type */

#define MAIN_PACKET_TYPE_NONE       0       /* invalid number */
#define MAIN_PACKET_TYPE_PING       1       /* ping packet */
#define MAIN_PACKET_TYPE_PASS       3       /* pass-through packet */
#define MAIN_PACKET_TYPE_CTRL       4       /* remote control packet */
#define MAIN_PACKET_TYPE_TRANSFER   6       /* protocol layer initiated transfer packet */
#define MAIN_PACKET_TYPE_IGMP       7       /* igmp message packet */
#define MAIN_PACKET_TYPE_IDHB       8       /* identity heartbeat message packet */

/* frame type */

#define MAIN_FRAME_UNKNOWN          0
#define MAIN_FRAME_DIRECTED         1
#define MAIN_FRAME_MULTICAST        2
#define MAIN_FRAME_BROADCAST        3

/* adapter constants */
#define MAIN_ADAPTER_NOT_FOUND      -1

/* identity heartbeat constants */
#define WLBS_MAX_ID_HB_BODY_SIZE    0xFF /* Maxumum size of a TLV structure in 8-byte units */
#define WLBS_ID_HB_TOLERANCE        3    /* Number of identity heartbeats that can be missed before we age out the cached entry */

/* TYPES */


/* actions are used for passing parameter info between Nic and Prot modules,
   and ensure that if miniport syncronization requires queueing we do not
   loose parameters and context */
#pragma pack(1)

typedef struct
{
    LIST_ENTRY          link;
    PVOID               ctxtp;              /* pointer to main context */
    ULONG               code;               /* type-checking code */
    NDIS_STATUS         status;             /* general status */

    /* per-operation type data */

    union
    {
        struct
        {
            PULONG              xferred;
            PULONG              needed;
            ULONG               external;
            ULONG               buffer_len;
            PVOID               buffer;
            NDIS_EVENT          event;
            NDIS_REQUEST        req;
        } request;
    } op;
}
MAIN_ACTION, * PMAIN_ACTION;

#pragma pack()

/* V2.0.6 per-packet protocol reserved information. this structure has to be at
   most 16 bytes in length */

#pragma pack(1)

typedef struct
{
    PVOID               miscp;      /* dscrp for ping frame,
                                       bufp for recv_indicate frame,
                                       external packet for pass through frames */
    USHORT              type;       /* packet type */
    USHORT              group;      /* if the frame direct, multicast or
                                       broadcast */
    LONG                data;       /* used for keeping expected xfer len on
                                       recv_indicate until transfer_complete
                                       occurs and for doing locking on
                                       send/receive paths */
    ULONG               len;        /* packet length for stats */
}
MAIN_PROTOCOL_RESERVED, * PMAIN_PROTOCOL_RESERVED;

#pragma pack()

/* per receive buffer wrapper structure */

typedef struct
{
    LIST_ENTRY          link;
    ULONG               code;       /* type-checking code */
    PNDIS_BUFFER        full_bufp;  /* describes enture buffer */
    PNDIS_BUFFER        frame_bufp; /* describes payload only */
    PUCHAR              framep;     /* pointer to payload */
    UCHAR               data [1];   /* beginning of buffer */
}
MAIN_BUFFER, * PMAIN_BUFFER;

/* convoy ping message header */

#pragma pack(1)

typedef struct
{
    ULONG                   code;               /* distinguishes Convoy frames */
    ULONG                   version;            /* software version */
    ULONG                   host;               /* source host id */
    ULONG                   cl_ip_addr;         /* cluster IP address */
    ULONG                   ded_ip_addr;        /* dedicated IP address V2.0.6 */
}
MAIN_FRAME_HDR, * PMAIN_FRAME_HDR;

/* Identity heartbeat payload */

typedef struct {
    UCHAR       type;                   /* Type defining this structure */
    UCHAR       length8;                /* Size of the data in this struct in units of 8-bytes */
    USHORT      flags;                  /* Reserved; for 8 byte alignment */
    ULONG       flags2;                 /* Reserved; for 8 byte alignment */
} TLV_HEADER, * PTLV_HEADER;

typedef struct {
    TLV_HEADER  header;                     /* Self-describing header structure */
    WCHAR       fqdn[CVY_MAX_FQDN + 1];     /* Fully qualified host name or netbt name */
} PING_MSG_EX, * PPING_MSG_EX;

#pragma pack()

/* per ping message wrapper structure */

typedef struct
{
    LIST_ENTRY              link;
    CVY_MEDIA_HDR           media_hdr;          /* filled-out media header */
    MAIN_FRAME_HDR          frame_hdr;          /* frame header */
    PING_MSG                msg;                /* ping msg V1.1.4 */
    ULONG                   recv_len;           /* used on receive path */
    PNDIS_BUFFER            media_hdr_bufp;     /* describes media header */
    PNDIS_BUFFER            frame_hdr_bufp;     /* describes frame header */
    PNDIS_BUFFER            send_data_bufp;     /* describes payload source for
                                                   outgoing frames */
    PNDIS_BUFFER            recv_data_bufp;     /* describes payload destination
                                                   for incoming frames */
}
MAIN_FRAME_DSCR, * PMAIN_FRAME_DSCR;

#pragma pack(1)

typedef struct
{
    UCHAR                   igmp_vertype;          /* Version and Type */
    UCHAR                   igmp_unused;           /* Unused */
    USHORT                  igmp_xsum;             /* Checksum */
    ULONG                   igmp_address;          /* Multicast Group Address */
}
MAIN_IGMP_DATA, * PMAIN_IGMP_DATA;

typedef struct
{
    UCHAR                   iph_verlen;             /* Version and length */
    UCHAR                   iph_tos;                /* Type of service */
    USHORT                  iph_length;             /* Total length of datagram */
    USHORT                  iph_id;                 /* Identification */
    USHORT                  iph_offset;             /* Flags and fragment offset */
    UCHAR                   iph_ttl;                /* Time to live */
    UCHAR                   iph_protocol;           /* Protocol */
    USHORT                  iph_xsum;               /* Header checksum */
    ULONG                   iph_src;                /* Source address */
    ULONG                   iph_dest;               /* Destination address */
}
MAIN_IP_HEADER, * PMAIN_IP_HEADER;

typedef struct
{
    MAIN_IP_HEADER          ip_data;
    MAIN_IGMP_DATA          igmp_data;
}
MAIN_IGMP_FRAME, * PMAIN_IGMP_FRAME;

#pragma pack()

#if defined (NLB_HOOK_ENABLE)

/* State indications to protect the register/de-register process. */
enum _HOOK_OPERATION {
    HOOK_OPERATION_NONE = 0,                        /* Ready for register/de-register. */
    HOOK_OPERATION_REGISTERING,                     /* Register operation in progress. */
    HOOK_OPERATION_DEREGISTERING                    /* De-register operation in progress. */
};

/* This union of function pointers contains all available 
   hook types in all hook interfaces.  Its used to avoid
   the need to cast function pointers stored in the generic
   hook structure below. */
typedef union {
    NLBSendFilterHook    SendHookFunction;          /* The send packet filter hook. */
    NLBQueryFilterHook   QueryHookFunction;         /* The query packet filter hook. */
    NLBReceiveFilterHook ReceiveHookFunction;       /* The receive packet filter hook. */
} HOOK_FUNCTION, * PHOOK_FUNCTION;

/* This structure contains all information and state for a
   single hook that is part of a hook interface.  This 
   includes whether or not the hook has been registered and
   the function pointer to invoke. */
typedef struct {
    BOOLEAN              Registered;                 /* Has this hook been specified? */
    HOOK_FUNCTION        Hook;                       /* The function pointer. */
} HOOK, * PHOOK;

/* This structure contains all information and state for a
   hook interface, which is a related group of hooks.  This
   information includes whether or not the interface is 
   currently "owned", who the owner is, the current number
   of references on this interface, which prevents the interface
   from being de-registered while its in use, and the callback
   function to invoke whenever the interface is de-registered,
   either gracefully or forcefully. */
typedef struct {
    BOOLEAN              Registered;                 /* Has this interface been registered? */
    ULONG                References;                 /* Number of references on the interface - must be zero to de-register. */
    HANDLE               Owner;                      /* Who owns this interface? */
    NLBHookDeregister    Deregister;                 /* A function to call when the interface is de-registered. */
} HOOK_INTERFACE, * PHOOK_INTERFACE;

/* This structure contains all of the related filter hook
   information, including the interface configuration and
   state as well as that of all hooks that are part of this
   interface.  It also includes a spin lock, which is used
   to serialize access to the interface. */
typedef struct {
    NDIS_SPIN_LOCK       Lock;                       /* A spin lock to control access to the filter interface and hooks. */
    ULONG                Operation;                  /* The current operation under way on this interface, if any. */
    HOOK_INTERFACE       Interface;                  /* The interface/registration information. */
    HOOK                 SendHook;                   /* Send hook state and function pointer. */
    HOOK                 QueryHook;                  /* Query hook state and function pointer. */
    HOOK                 ReceiveHook;                /* Receive hook state and function pointer. */
} FILTER_HOOK_TABLE, * PFILTER_HOOK_TABLE;

/* This structure contains all supported NLB hooks. */
typedef struct {
    FILTER_HOOK_TABLE FilterHook;
} HOOK_TABLE, * PHOOK_TABLE;

/* The global table of NLB hooks. */
extern HOOK_TABLE        univ_hooks; 

#endif

#define CVY_BDA_MAXIMUM_MEMBER_ID (CVY_MAX_ADAPTERS - 1)
#define CVY_BDA_INVALID_MEMBER_ID CVY_MAX_ADAPTERS

enum _BDA_TEAMING_OPERATION {
    BDA_TEAMING_OPERATION_NONE = 0,  /* Ready for create/delete. */
    BDA_TEAMING_OPERATION_CREATING,  /* Create operation in progress. */
    BDA_TEAMING_OPERATION_DELETING   /* Delete operation in progress. */
};

/* This structure holds the configuration of a BDA team.  Each 
   member holds a pointer to this structure, which its uses to 
   update state and acquire references to and utilize the master 
   load context for packet handling. */
typedef struct _BDA_TEAM {
    struct _BDA_TEAM * prev;                             /* Pointer to the previous team in this doubly-linked list. */
    struct _BDA_TEAM * next;                             /* Pointer to the next team in this doubly-linked list. */
    PLOAD_CTXT         load;                             /* Pointer to the "shared" load module for this team. This
                                                            is the load module of the master.  If there is no master
                                                            in the team, this pointer is NULL. */ 
    PNDIS_SPIN_LOCK    load_lock;                        /* Pointer to the load lock for the "shared" load module. */
    ULONG              active;                           /* Is this team active.  Teams become inactive under two 
                                                            conditions; (1) inconsistent teaming detected via heart-
                                                            beats or (2) the team has no master. */
    ULONG              membership_count;                 /* This is the number of members in the team.  This acts as
                                                            a reference count on the team state. */
    ULONG              membership_fingerprint;           /* This is an XOR of the least significant 16 bits of each
                                                            member's primary cluster IP address.  This is used as a 
                                                            sort of signature on the team membership. */
    ULONG              membership_map;                   /* This is a bit map of the team membership.  Each member is
                                                            assigned a member ID, which is its index in this bit map. */
    ULONG              consistency_map;                  /* This is a bit map of the member consistency.  Each mamber
                                                            is assigned a member ID, which is its index in this bit map.
                                                            When a member detects bad configuration via its heartbeats,
                                                            it resets its bit in this map. */  
    WCHAR              team_id[CVY_MAX_BDA_TEAM_ID + 1]; /* This is the team ID - a GUID - which is used to match 
                                                            adapters to the correct team. */
} BDA_TEAM, * PBDA_TEAM;

/* This structure holds the teaming configuration for a single
   adapter and is a member of the MAIN_CTXT structure. */
typedef struct _BDA_MEMBER {
    ULONG              operation;                        /* Used for synchronization of creating/deleting BDA teaming. */
    ULONG              active;                           /* Is this adapter part of a BDA team. */
    ULONG              master;                           /* Is this adapter the master of its team. */
    ULONG              reverse_hash;                     /* Is this adapter using reverse hashing (reverse source and 
                                                            destination IP addresses and ports before hashing). */
    ULONG              member_id;                        /* The member ID - a unique (per-team) ID between 0 and 15. 
                                                            Used as the index in several team bit arrays. */
    PBDA_TEAM          bda_team;                         /* Pointer to a BDA_TEAM structure, which contains the 
                                                            ocnfiguration and state of my team. */
} BDA_MEMBER, * PBDA_MEMBER;

/* 802.3. */
typedef struct _MAIN_PACKET_ETHERNET_INFO {
    PCVY_ETHERNET_HDR pHeader;       /* A pointer to the 802.3 media header, if the medium is NdisMedium802_3. */
    ULONG             Length;        /* The length of contiguous packet memory accessible from pHeader, 
                                        guaranteed to be AT LEAST the size of a 802.3 media header (14 bytes). */
} MAIN_PACKET_ETHERNET_INFO, * PMAIN_PACKET_ETHERNET_INFO;

/* ARP. */
typedef struct _MAIN_PACKET_ARP_INFO {
    PARP_HDR pHeader;                /* A pointer to the ARP header, if the packet Type is TCPIP_ARP_SIG. */
    ULONG    Length;                 /* The length of contiguous packet memory accessible from pHeader, 
                                        guaranteed to be AT LEAST the size of an ARP header (28 bytes). */
} MAIN_PACKET_ARP_INFO, * PMAIN_PACKET_ARP_INFO;

/* TCP payload. */
typedef struct _MAIN_PACKET_TCP_PAYLOAD_INFO {
    PUCHAR pPayload;                 /* A pointer to the TCP payload, if the IP Protocol is TCPIP_PROTOCOL_TCP. */
    ULONG  Length;                   /* The length of contiguous packet memory accessible from pPayload, 
                                        with no guarantees on the minimum length, except in the case of NetBT. */  

    PNDIS_BUFFER pPayloadBuffer;     /* The NDIS buffer in which the UDP payload resides.  In cases where a payload
                                        stretches across more than one buffer, this pointer can be used to get a 
                                        pointer to the next buffer, and so on, by calling NdisGetNextBuffer and 
                                        NdisQueryBuffer. */
} MAIN_PACKET_TCP_PAYLOAD_INFO, * PMAIN_PACKET_TCP_PAYLOAD_INFO;

/* TCP. */
typedef struct _MAIN_PACKET_TCP_INFO {
    PTCP_HDR pHeader;                /* A pointer to the TCP header, if the IP Protocol is TCPIP_PROTOCOL_TCP. */
    ULONG    Length;                 /* The length of contiguous packet memory accessible from pHeader, 
                                        guaranteed to be AT LEAST as long as indicated the indicated 
                                        header length in the TCP header itself (20 bytes minimum). */
    
    MAIN_PACKET_TCP_PAYLOAD_INFO Payload; /* The payload information.  Note, this information is not guaranteed to 
                                             be filled in for every packet; i.e., not every TCP packet even HAS a
                                             payload.  Users must check the payload pointer to be sure its not NULL, 
                                             and ensure that the length indication is greater than zero before 
                                             accessing the payload. */
} MAIN_PACKET_TCP_INFO, * PMAIN_PACKET_TCP_INFO;

/* UDP payload. */
typedef struct _MAIN_PACKET_UDP_PAYLOAD_INFO {
    PUCHAR pPayload;                 /* A pointer to the UDP payload, if the IP Protocol is TCPIP_PROTOCOL_UDP. */
    ULONG  Length;                   /* The length of contiguous packet memory accessible from pHeader, 
                                        with no guarantees on the minimum length, except in the case of remote control. */

    PNDIS_BUFFER pPayloadBuffer;     /* The NDIS buffer in which the UDP payload resides.  In cases where a payload
                                        stretches across more than one buffer, this pointer can be used to get a 
                                        pointer to the next buffer, and so on, by calling NdisGetNextBuffer and 
                                        NdisQueryBuffer. */
} MAIN_PACKET_UDP_PAYLOAD_INFO, * PMAIN_PACKET_UDP_PAYLOAD_INFO;

/* UDP. */
typedef struct _MAIN_PACKET_UDP_INFO {
    PUDP_HDR pHeader;                /* A pointer to the UDP header, if the IP Protocol is TCPIP_PROTOCOL_UDP. */
    ULONG    Length;                 /* The length of contiguous packet memory accessible from pHeader, 
                                        guaranteed to be AT LEAST the size of a UDP header (8 bytes). */
    
    MAIN_PACKET_UDP_PAYLOAD_INFO Payload; /* The payload information.  Note, this information is not guaranteed to 
                                             be filled in for every packet; i.e., not every UDP packet even HAS a
                                             payload.  Users must check the payload pointer to be sure its not NULL, 
                                             and ensure that the length indication is greater than zero before 
                                             accessing the payload. */
} MAIN_PACKET_UDP_INFO, * PMAIN_PACKET_UDP_INFO;

/* IP. */
typedef struct _MAIN_PACKET_IP_INFO {
    PIP_HDR pHeader;                 /* A pointer to the IP header, if the packet Type is TCPIP_IP_SIG. */
    ULONG   Length;                  /* The length of contiguous packet memory accessible from pHeader, 
                                        guaranteed to be AT LEAST as long as indicated the indicated 
                                        header length in the IP header itself (20 bytes minimum). */
    ULONG   Protocol;                /* The IP protocol (TCP, UDP, ICMP, etc.). */
    BOOLEAN bFragment;               /* If TRUE, then this IP packet is a [subsequent] IP fragment that does
                                        NOT contain a protocol header.  Therefore, the TCP and UDP information
                                        below is NOT populated. */
    
    union {
        /* TCP. */
        MAIN_PACKET_TCP_INFO TCP;    /* If Protocol == TCP, the TCP packet information. */

        /* UDP. */
        MAIN_PACKET_UDP_INFO UDP;    /* If protocol == UDP, the UDP packet information. */
    };
} MAIN_PACKET_IP_INFO, * PMAIN_PACKET_IP_INFO;

/* NLB Heartbeat payload. */
typedef struct MAIN_PACKET_HEARTBEAT_PAYLOAD_INFO {
    union {
        PPING_MSG    pPayload;       /* A pointer to the NLB heartbeat payload, if the packet Type is MAIN_FRAME_SIG[_OLD]. */
        PTLV_HEADER  pPayloadEx;     /* A pointer to the NLB heartbeat payload for new heartbeat types, including identity heartbeats */
    };
    ULONG     Length;                /* The length of contiguous packet memory accessible from pHeader, 
                                        guaranteed to be AT LEAST the size of a PING message. */
} MAIN_PACKET_HEARTBEAT_PAYLOAD_INFO, * PMAIN_PACKET_HEARTBEAT_PAYLOAD_INFO;

/* NLB Heartbeat. */
typedef struct _MAIN_PACKET_HEARTBEAT_INFO {
    PMAIN_FRAME_HDR pHeader;         /* A pointer to the NLB heartbeat header, if the packet Type is MAIN_FRAME_SIG[_OLD]. */
    ULONG           Length;          /* The length of contiguous packet memory accessible from pHeader, 
                                        guaranteed to be AT LEAST the size of an NLB heartbeat header (20 bytes). */

    MAIN_PACKET_HEARTBEAT_PAYLOAD_INFO Payload; /* The PING paylod, which is passed to the load module. */
} MAIN_PACKET_HEARTBEAT_INFO, * PMAIN_PACKET_HEARTBEAT_INFO;

/* Unknown. */
typedef struct _MAIN_PACKET_UNKNOWN_INFO {
    PUCHAR pHeader;                  /* A pointer to the frame of unkonwn type, if the packet Type is not known. */
    ULONG  Length;                   /* The length of contiguous packet memory accessible from pHeader, 
                                        with no guarantees on the minimum length. */  
} MAIN_PACKET_UNKNOWN_INFO, * PMAIN_PACKET_UNKNOWN_INFO;

typedef struct {
    ULONG       ded_ip_addr;                /* Dedicated IP address */
    ULONG       ttl;                        /* Time-to-live for this cached identity entry */
    USHORT      host_id;                    /* Host ID of the member. Range: [0-31] */
    WCHAR       fqdn[CVY_MAX_FQDN + 1];     /* Fully qualified domain name */
} MAIN_IDENTITY, * PMAIN_IDENTITY;

/* Represents the information parsed from a given network packet.
   All information in the packet is trusted, but the information
   to which it points is NOT trusted (i.e., the actual contents
   of the packet).
   
   Note: We could parse out IPs, flags, ports, etc such that nobody 
   but Main_frame_parse should have to operate on the packet itself, 
   unless it parses/modifies the payload, such as UDP 500 (IKE), 
   remote control or NetBT. */
typedef struct _MAIN_PACKET_INFO {
    PNDIS_PACKET pPacket;                     /* Storage for a pointer to the original NDIS packet. */
    NDIS_MEDIUM  Medium;                      /* The network medium - should always be NdisMedium802_3. */
    ULONG        Length;                      /* The total packet length, not including the MAC header. */
    USHORT       Group;                       /* Whether the packet is unicast, multicast or broadcast. */
    USHORT       Type;                        /* The packet type (ARP, IP, Heartbeat, etc.). */
    USHORT       Operation;                   /* A packet-type specific operation (Remote control, NetBT, etc.). */

    /* The MAC header, as determined by the Medium. */
    union { 
        /* 802.3. */
        MAIN_PACKET_ETHERNET_INFO  Ethernet;  /* If Medium == 802.3, the ethernet MAC header information. */
    };

    /* The frame type, as determined by the Type. */
    union {
        /* ARP. */
        MAIN_PACKET_ARP_INFO       ARP;       /* If Type == ARP, the ARP packet information. */

        /* IP. */
        MAIN_PACKET_IP_INFO        IP;        /* If Type == IP, the IP packet information. */ 

        /* NLB Heartbeat. */
        MAIN_PACKET_HEARTBEAT_INFO Heartbeat; /* If Type == PING, the heartbeat packet information. */

        /* Unknown. */
        MAIN_PACKET_UNKNOWN_INFO   Unknown;   /* If Type == otherwise, the unknown packet information. */
    };

} MAIN_PACKET_INFO, * PMAIN_PACKET_INFO;

/* main context type */

typedef struct
{
    ULONG               ref_count;              /* The reference count on this load module. */
    ULONG               code;                   /* type checking code */

    DIPLIST             dip_list;               /* A list of all DIPs on all hosts in this cluster. */

    NDIS_STATUS         completion_status;      /* open/close completion status */
    NDIS_EVENT          completion_event;       /* open/close completion trigger */
    NDIS_HANDLE         bind_handle;            /* bind context handle */
    NDIS_HANDLE         unbind_handle;          /* unbind context handle */
    NDIS_HANDLE         mac_handle;             /* underlying adapter handle */
    NDIS_HANDLE         prot_handle;            /* overlying protocol handle */
    NDIS_MEDIUM         medium;                 /* adapter medium */
    ULONG               curr_tout;              /* current heartbeat period */
    ULONG               igmp_sent;              /* time elapsed since the last
						   igmp message was sent */
    ULONG               conn_purge;             /* time elapsed since the last
                                                   descriptor cleanup */
    ULONG               num_purged;             /* number of connections purged */
    ULONG               idhb_sent;              /* time elapsed (ms) since the last identity HB was sent*/
    ULONG               packets_exhausted;      /* out of send packets */
    ULONG               mac_options;            /* adapter options V1.3.1b */
    ULONG               media_connected;        /* media plugged in V1.3.2b */

    ULONG               max_frame_size;         /* MTU of the medium V1.3.2b */
    ULONG               max_mcast_list_size;

    ULONG               reverse_hash;           /* Whether or not to reverse the source
                                                   and destination information in hashing. */

    BDA_MEMBER          bda_teaming;            /* BDA membership information. */

    ULONG               cached_state;           /* Cached initial state. */

    PVOID               timer;                  /* points to Nic module allocated
                                                   ping time V1.2.3b */
    ULONG               num_packets;            /* number of packets per alloc */
    ULONG               num_actions;            /* number of actions per alloc */
    ULONG               num_send_msgs;          /* number of heartbeats to alloc */

    /* states */

    ULONG               reset_state;            /* current reset state V1.1.2 */
    ULONG               recv_indicated;         /* first receive trigger after
                                                   reset V1.1.2 */
    ULONG               draining;               /* draining mode */
    ULONG               stopping;               /* draining->stop mode */
    ULONG               suspended;              /* cluster control suspended */
    ULONG               convoy_enabled;         /* cluster mode active */

    ULONG               ctrl_op_in_progress;    /* Critical section flag for Main_ctrl.
                                                   Only one control operation can be in
                                                   progress at a given time. */

    /* PnP */

    NDIS_DEVICE_POWER_STATE  prot_pnp_state;    /* PNP state */
    NDIS_DEVICE_POWER_STATE  nic_pnp_state;     /* PNP state */
    PMAIN_ACTION        out_request;            /* outstanding request */
    ULONG               requests_pending;       /* set or query requests pending */
    ULONG               standby_state;          /* entering standby state */

    /* IP and MAC addresses */

    ULONG               ded_ip_addr;            /* dedicated IP */
    ULONG               ded_net_mask;           /* dedicated mask */
    ULONG               ded_bcast_addr;         /* dedicated broadcast IP */
    ULONG               cl_ip_addr;             /* cluster IP */
    ULONG               cl_net_mask;            /* cluster mask */
    ULONG               cl_bcast_addr;          /* cluster broadcast IP */
    ULONG               cl_igmp_addr;           /* IGMP address for join messages */
    CVY_MAC_ADR         ded_mac_addr;           /* dedicated MAC V1.3.0b */
    CVY_MAC_ADR         cl_mac_addr;            /* cluster MAC V1.3.0b */

    /* event logging - prevent event log from filling with error messages */

    ULONG               actions_warned;
    ULONG               packets_warned;
    ULONG               bad_host_warned;
    ULONG               send_msgs_warned;
    ULONG               dup_ded_ip_warned;      /* duplicate dedicated IP address */
    ULONG               recv_indicate_warned;   /* NIC does not indicate NDIS packets. */

    /* actions */

    LIST_ENTRY          act_list;               /* list of allocated actions */
    NDIS_SPIN_LOCK      act_lock;               /* corresponding lock */
    PMAIN_ACTION        act_buf [CVY_MAX_ALLOCS];
                                                /* array of allocated sets of
                                                   actions */
    ULONG               num_action_allocs;      /* number of allocated action
                                                   sets */
    ULONG               act_size;

    /* packet stacking */

    NPAGED_LOOKASIDE_LIST resp_list;            /* list for main protocol field
                                                   to be allocated for ps */

    /* packets */

    NDIS_SPIN_LOCK      send_lock;              /* send packet lock */
    NDIS_HANDLE         send_pool_handle [CVY_MAX_ALLOCS];
                                                /* array of allocated sets of
                                                   send packet pools V1.1.2 */
    ULONG               num_send_packet_allocs; /* number of allocated send
                                                   packet pools */
    ULONG               cur_send_packet_pool;   /* current send pool to draw
                                                   packets from V1.3.2b */
    ULONG               num_sends_alloced;      /* number of send packets allocated */
    ULONG               num_sends_out;          /* number of send packets out */
    ULONG               send_allocing;          /* TRUE if some thread is allocing a send packet pool */
    NDIS_SPIN_LOCK      recv_lock;              /* receive packet lock */
    NDIS_HANDLE         recv_pool_handle [CVY_MAX_ALLOCS];
                                                /* array of allocated sets of
                                                   recv packet pools V1.1.2 */
    ULONG               num_recv_packet_allocs; /* number of allocated recv
                                                   packet pools */
    ULONG               cur_recv_packet_pool;   /* current recv pool to draw
                                                   packets from V1.3.2b */
    ULONG               num_recvs_alloced;      /* number of recv packets allocated */
    ULONG               num_recvs_out;          /* number of recv packets out */
    ULONG               recv_allocing;          /* TRUE if some thread is allocing a recv packet pool */

    /* buffers */

    NDIS_HANDLE         buf_pool_handle [CVY_MAX_ALLOCS];
                                                /* array of buffer descriptor
                                                   sets V1.3.2b */
    PUCHAR              buf_array [CVY_MAX_ALLOCS];
                                                /* array of buffer pools V1.3.2b */
    ULONG               buf_size;               /* buffer + descriptor size
                                                   V1.3.2b */
    ULONG               buf_mac_hdr_len;        /* length of full media header
                                                   V1.3.2b */
    LIST_ENTRY          buf_list;               /* list of buffers V1.3.2b */
    NDIS_SPIN_LOCK      buf_lock;               /* corresponding lock V1.3.2b */
    ULONG               num_buf_allocs;         /* number of allocated buffer
                                                   pools V1.3.2b */
    ULONG               num_bufs_alloced;       /* number of buffers allocated */
    ULONG               num_bufs_out;           /* number of buffers out */

    /* heartbeats */

    CVY_MEDIA_HDR       media_hdr;              /* filled-out media master header
                                                   for heartbeat messages */
    CVY_MEDIA_HDR       media_hdr_igmp;         /* filled-out media master header
                                                   for igmp messages. Need a separate one
						   since the EtherType will be different */
    MAIN_IGMP_FRAME     igmp_frame;             /* IGMP message */

    ULONG               etype_old;              /* ethernet type was set to
                                                   convoy compatibility value */
    LIST_ENTRY          frame_list;             /* list of heartbeat frames */
    NDIS_SPIN_LOCK      frame_lock;             /* corresponding lock */
    PMAIN_FRAME_DSCR    frame_dscrp;            /* heartbeat frame descriptors */
    NDIS_HANDLE         frame_pool_handle;      /* packet pool for heartbeats */
    NDIS_HANDLE         frame_buf_pool_handle;  /* buffer pool for heartbeats */

    /* remote control */
    ULONG               rct_last_addr;          /* source of last request */
    ULONG               rct_last_id;            /* last request epoch */

    ULONG               cntr_recv_tcp_resets;   /* The number of TCP resets received. */
    ULONG               cntr_xmit_tcp_resets;   /* The number of TCP resets transmitted. */

    /* V2.0.6 performance counters */

    ULONG               cntr_xmit_ok;
    ULONG               cntr_recv_ok;
    ULONG               cntr_xmit_err;
    ULONG               cntr_recv_err;
    ULONG               cntr_recv_no_buf;
    ULONGLONG           cntr_xmit_bytes_dir;
    ULONG               cntr_xmit_frames_dir;
    ULONGLONG           cntr_xmit_bytes_mcast;
    ULONG               cntr_xmit_frames_mcast;
    ULONGLONG           cntr_xmit_bytes_bcast;
    ULONG               cntr_xmit_frames_bcast;
    ULONGLONG           cntr_recv_bytes_dir;
    ULONG               cntr_recv_frames_dir;
    ULONGLONG           cntr_recv_bytes_mcast;
    ULONG               cntr_recv_frames_mcast;
    ULONGLONG           cntr_recv_bytes_bcast;
    ULONG               cntr_recv_frames_bcast;
    ULONG               cntr_recv_crc_err;
    ULONG               cntr_xmit_queue_len;

    ULONG               cntr_frame_no_buf;
    ULONG               num_frames_out;

    /* sub-module contexts */

    TCPIP_CTXT          tcpip;                  /* TCP/IP handling context V1.1.1 */
    NDIS_SPIN_LOCK      load_lock;              /* load context lock */
    LOAD_CTXT           load;                   /* load processing context */
    PPING_MSG           load_msgp;              /* load ping message to send
                                                   out as heartbeat */

    /* Parameter contexts */
    CVY_PARAMS          params;
    ULONG               params_valid;

#if defined (OPTIMIZE_FRAGMENTS)
    ULONG               optimized_frags;
#endif

    // Name of the nic.  Used by Nic_announce and Nic_unannounce
    WCHAR       virtual_nic_name [CVY_MAX_VIRTUAL_NIC + 1];

#if 0
    /* for tracking send filtering */
    ULONG               sends_in;
    ULONG               sends_filtered;
    ULONG               sends_completed;
    ULONG               arps_filtered;
    ULONG               mac_modified;
    ULONG               uninited_return;
#endif

    ULONG               adapter_id;

    WCHAR               log_msg_str [80];           /* This was added for log messages for multi nic support */

    /* Identity cache */
    MAIN_IDENTITY       identity_cache[CVY_MAX_HOSTS];
    PING_MSG_EX         idhb_msg;                   /* Identity heartbeat transmitted by this host */
    ULONG               idhb_size;                  /* Size (in bytes) of the identity heartbeat */
}
MAIN_CTXT, * PMAIN_CTXT;

#if defined (NLB_TCP_NOTIFICATION)
enum _IF_INDEX_OPERATION {
    IF_INDEX_OPERATION_NONE = 0,
    IF_INDEX_OPERATION_UPDATE
};
#endif

/* adapter context */
typedef struct
{
    ULONG               code;                   /* type checking code */
#if defined (NLB_TCP_NOTIFICATION)
    ULONG               if_index;               /* tcpip interface index for this adapter */
    ULONG               if_index_operation;     /* whether or not an if_index update is in progress */
#endif
    BOOLEAN             used;                   /* whether this element is in use or not */
    BOOLEAN             inited;                 /* context has been initialized */
    BOOLEAN             bound;                  /* convoy has been bound to the stack */
    BOOLEAN             announced;              /* tcpip has been bound to convoy */
    PMAIN_CTXT          ctxtp;                  /* pointer to the context that is used */
    ULONG               device_name_len;        /* length of the string allocated for the device name */
    PWSTR               device_name;            /* name of the device to which this context is bound */
}
MAIN_ADAPTER, * PMAIN_ADAPTER;


/* MACROS */


/* compute offset to protocol reserved space in the packet */

/* Set/retrieve the pointer to our private buffer, which we store in the 
   MiniportReserved field of an NDIS packet. */
#define MAIN_MINIPORT_FIELD(p) (*(PMAIN_PROTOCOL_RESERVED *) ((p) -> MiniportReserved))
#define MAIN_PROTOCOL_FIELD(p) ((PMAIN_PROTOCOL_RESERVED) ((p) -> ProtocolReserved))
#define MAIN_IMRESERVED_FIELD(p) ((PMAIN_PROTOCOL_RESERVED) ((p) -> IMReserved [0]))

/* If the current packet stack exists, then get the IMReserved pointer and return it if
   it is non-NULL - this is where we have stored / are storing our private data.   If it 
   NULL, or if the current packet stack is NULL, then we are either using ProtocolReserved
   or MiniportReserved, depending on whether this is in the send or receive path.  We 
   also make sure that there is a non-NULL pointer in MiniportReserved before returning
   it because CTRL packets, although they are allocated on the receive path, use Protocol
   Reserved. */
#define MAIN_RESP_FIELD(pkt, left, ps, rsp, send)   \
{                                                   \
(ps) = NdisIMGetCurrentPacketStack((pkt), &(left)); \
if ((ps))                                           \
{                                                   \
    if (MAIN_IMRESERVED_FIELD((ps)))                \
        (rsp) = MAIN_IMRESERVED_FIELD((ps));        \
    else if ((send))                                \
        (rsp) = MAIN_PROTOCOL_FIELD((pkt));         \
    else if (MAIN_MINIPORT_FIELD((pkt)))            \
        (rsp) = MAIN_MINIPORT_FIELD((pkt));         \
    else                                            \
        (rsp) = MAIN_PROTOCOL_FIELD((pkt));         \
}                                                   \
else                                                \
{                                                   \
    if ((send))                                     \
        (rsp) = MAIN_PROTOCOL_FIELD((pkt));         \
    else if (MAIN_MINIPORT_FIELD((pkt)))            \
        (rsp) = MAIN_MINIPORT_FIELD((pkt));         \
    else                                            \
        (rsp) = MAIN_PROTOCOL_FIELD((pkt));         \
}                                                   \
}

#define MAIN_PNP_DEV_ON(c)		((c)->nic_pnp_state == NdisDeviceStateD0 && (c)->prot_pnp_state == NdisDeviceStateD0 )


/* Global variables that are exported */
extern MAIN_ADAPTER            univ_adapters [CVY_MAX_ADAPTERS]; // ###### ramkrish
extern ULONG                   univ_adapters_count;

/* PROCEDURES */


extern NDIS_STATUS Main_init (
    PMAIN_CTXT          ctxtp);
/*
  Initialize context

  returns NDIS_STATUS:

  function:
*/


extern VOID Main_cleanup (
    PMAIN_CTXT          ctxtp);
/*
  Cleanup context

  returns VOID:

  function:
*/


extern ULONG   Main_arp_handle (
    PMAIN_CTXT          ctxtp,
    PMAIN_PACKET_INFO   pPacketInfo,
    ULONG               send);
/*
  Process ARP packets

  returns ULONG  :
    TRUE  => accept
    FALSE => drop

  function:
*/

extern ULONG   Main_recv_ping (
    PMAIN_CTXT                  ctxtp,
    PMAIN_PACKET_HEARTBEAT_INFO heartbeatp);
/*
  Process heartbeat packets

  returns ULONG  :
    TRUE  => accept
    FALSE => drop

  function:
*/


extern PNDIS_PACKET Main_send (
    PMAIN_CTXT          ctxtp,
    PNDIS_PACKET        packetp,
    PULONG              exhausted);
/*
  Process outgoing packets

  returns PNDIS_PACKET:

  function:
*/


extern PNDIS_PACKET Main_recv (
    PMAIN_CTXT          ctxtp,
    PNDIS_PACKET        packetp);
/*
  Process incoming packets

  returns PNDIS_PACKET:

  function:
*/

extern ULONG   Main_actions_alloc (
    PMAIN_CTXT              ctxtp);
/*
  Allocate additional actions

  returns ULONG  :
    TRUE  => success
    FALSE => failure

  function:
*/


extern ULONG   Main_bufs_alloc (
    PMAIN_CTXT              ctxtp);
/*
  Allocate additional buffers

  returns ULONG  :
    TRUE  => success
    FALSE => failure

  function:
*/


extern PNDIS_PACKET Main_frame_get (
    PMAIN_CTXT              ctxtp,
    PULONG                  len,
    USHORT                  frame_type);
/*
  Get a fresh heartbeat/igmp frame from the list

  returns PNDIS_PACKET:

  function:
*/


extern VOID Main_frame_put (
    PMAIN_CTXT              ctxtp,
    PNDIS_PACKET            packet,
    PMAIN_FRAME_DSCR        dscrp);
/*
  Return heartbeat frame to the list

  returns VOID:

  function:
*/


extern PMAIN_ACTION Main_action_get (
    PMAIN_CTXT              ctxtp);
/*
  Get a fresh action from the list

  returns PMAIN_ACTION:

  function:
*/


extern VOID Main_action_put (
    PMAIN_CTXT              ctxtp,
    PMAIN_ACTION            reqp);
/*
  Return action to the list

  returns VOID:

  function:
*/


extern VOID Main_action_slow_put (
    PMAIN_CTXT              ctxtp,
    PMAIN_ACTION            reqp);
/*
  Return action to the list using slow (non-DPC) locking

  returns VOID:

  function:
*/


extern PNDIS_PACKET Main_packet_alloc (
    PMAIN_CTXT              ctxtp,
    ULONG                   send,
    PULONG                  low);
/*
  Allocate a fresh packet from the pool

  returns PNDIS_PACKET:

  function:
*/


extern PNDIS_PACKET Main_packet_get (
    PMAIN_CTXT              ctxtp,
    PNDIS_PACKET            packet,
    ULONG                   send,
    USHORT                  group,
    ULONG                   len);
/*
  Get a fresh packet

  returns PNDIS_PACKET:

  function:
*/


extern PNDIS_PACKET Main_packet_put (
    PMAIN_CTXT              ctxtp,
    PNDIS_PACKET            packet,
    ULONG                   send,
    NDIS_STATUS             status);
/*
  Return packet to the pool

  returns PNDIS_PACKET:
    <linked packet>

  function:
*/



extern VOID Main_send_done (
    PVOID                   ctxtp,
    PNDIS_PACKET            packetp,
    NDIS_STATUS             status);
/*
  Heartbeat send completion routine

  returns VOID:

  function:
*/


extern VOID Main_ping (
    PMAIN_CTXT              ctxtp,
    PULONG                  tout);
/*
  Handle ping timeout

  returns VOID:

  function:
*/

extern ULONG   Main_ip_addr_init (
    PMAIN_CTXT          ctxtp);
/*
  Convert IP strings in dotted notation to ulongs

  returns ULONG  :
    TRUE  => success
    FALSE => failure

  function:
*/


extern ULONG   Main_mac_addr_init (
    PMAIN_CTXT          ctxtp);
/*
  Convert MAC string in dashed notation to array of bytes

  returns ULONG  :
    TRUE  => success
    FALSE => failure

  function:
*/


extern ULONG   Main_igmp_init (
    PMAIN_CTXT          ctxtp,
    BOOLEAN             join);
/*
  Initialize the Ethernet frame and IP Packet to send out IGMP joins or leaves
  
  returns ULONG  :
    TRUE  => success
    FALSE => failure

  function:
*/

NDIS_STATUS Main_dispatch(
    PVOID                   DeviceObject,
    PVOID                   Irp);
/*
  Handle all requests
  
  returns NDIS_STATUS:
  
  function:
*/


extern NDIS_STATUS Main_ioctl (
    PVOID                   device, 
    PVOID                   irp_irp);
/*
  Handle IOCTL request

  returns NDIS_STATUS:

  function:
*/

extern NDIS_STATUS Main_ctrl_recv (
    PMAIN_CTXT              ctxtp,
    PMAIN_PACKET_INFO       pPacketInfo);
/*
  Handle remote control requests

  returns VOID:

  function:
*/

// code added for multiple nic support for looking up the array of elements

extern INT Main_adapter_alloc (
    PNDIS_STRING            device_name);
/*
  Returns the first available adapter element.
  This function is called at bind time, when context is to be allocated for a
  new binding

  returns INT:
    -1                   : falied to allocate a new context for this binding
    0 - CVY_MAX_ADAPTERS : success

  function:
*/


extern INT Main_adapter_get (
    PWSTR                   device_name);
/*
  Look up an adapter that is bound to this device.

  returns:
    -1                   : adapter not found
    0 - CVY_MAX_ADAPTERS : success

  function:
*/


extern INT Main_adapter_put (
    PMAIN_ADAPTER           adapterp);
/*
  Look up an adapter that is bound to this device.

  returns:
    -1                   : adapter not found
    0 - CVY_MAX_ADAPTERS : success

  function:
*/


extern INT Main_adapter_selfbind (
    PWSTR                   device_name);
/*
  Finds if a ProtocolBind call is being made to ourself

  returns;
    -1                   : adapter not found
    0 - CVY_MAX_ADAPTERS : success

  function:
*/

/*
 * Function: Main_spoof_mac
 * Description: This function spoofs the source/destination MAC address(es) of incoming
 *              and/or outgoing packets.  Incoming packets in multicast mode must change
 *              the cluster multicast MAC to the NIC's permanent MAC address before sending
 *              the packet up the protocol stack.  Outgoing packets in unicast mode must
 *              mask the source MAC address to prevent switches from learning the cluster
 *              MAC address and associating it with a particular switch port.
 * Parameters: ctxtp - pointer the the main NLB context structure for this adapter.
 *             pPacketInfo - the previously parse packet information structure, which, 
 *                           among other things, contains a pointer to the MAC header.
 *             send - boolean indication of send v. receive.
 * Returns: Nothing.
 * Author: shouse, 3.4.02
 * Notes: 
 */
VOID Main_spoof_mac (
    PMAIN_CTXT ctxtp, 
    PMAIN_PACKET_INFO pPacketInfo, 
    ULONG send);

/*
 * Function: Main_recv_frame_parse
 * Description: This function parses an NDIS_PACKET and carefully extracts the information 
 *              necessary to handle the packet.  The information extracted includes pointers 
 *              to all relevant headers and payloads as well as the packet type (EType), IP 
 *              protocol (if appropriate), etc.  This function does all necessary validation 
 *              to ensure that all pointers are accessible for at least the specified number 
 *              of bytes; i.e., if this function returns successfully, the pointer to the IP 
 *              header is guaranteed to be accessible for at LEAST the length of the IP header.  
 *              No contents inside headers or payloads is validated, except for header lengths, 
 *              and special cases, such as NLB heartbeats or remote control packets.  If this
 *              function returns unsuccessfully, the contents of MAIN_PACKET_INFO cannot be 
 *              trusted and the packet should be discarded.  See the definition of MAIN_PACKET_INFO 
 *              in main.h for more specific indications of what fields are filled in and under 
 *              what circumstances.
 * Parameters: ctxtp - pointer to the main NLB context structure for this adapter.
 *             pPacket - pointer to the received NDIS_PACKET.
 *             pPacketInfo - pointer to a MAIN_PACKET_INFO structure to hold the information
 *                           parsed from the packet.
 * Returns: BOOLEAN - TRUE if successful, FALSE if not.
 * Author: shouse, 3.4.02
 * Notes: 
 */
BOOLEAN Main_recv_frame_parse (
    PMAIN_CTXT            ctxtp,        
    IN PNDIS_PACKET       pPacket,      
    OUT PMAIN_PACKET_INFO pPacketInfo); 

/*
 * Function: Main_send_frame_parse
 * Description: This function parses an NDIS_PACKET and carefully extracts the information 
 *              necessary to handle the packet.  The information extracted includes pointers 
 *              to all relevant headers and payloads as well as the packet type (EType), IP 
 *              protocol (if appropriate), etc.  This function does all necessary validation 
 *              to ensure that all pointers are accessible for at least the specified number 
 *              of bytes; i.e., if this function returns successfully, the pointer to the IP 
 *              header is guaranteed to be accessible for at LEAST the length of the IP header.  
 *              No contents inside headers or payloads is validated, except for header lengths, 
 *              and special cases, such as NLB heartbeats or remote control packets.  If this
 *              function returns unsuccessfully, the contents of MAIN_PACKET_INFO cannot be 
 *              trusted and the packet should be discarded.  See the definition of MAIN_PACKET_INFO 
 *              in main.h for more specific indications of what fields are filled in and under 
 *              what circumstances.
 * Parameters: ctxtp - pointer to the main NLB context structure for this adapter.
 *             pPacket - pointer to the sent NDIS_PACKET.
 *             pPacketInfo - pointer to a MAIN_PACKET_INFO structure to hold the information
 *                           parsed from the packet.
 * Returns: BOOLEAN - TRUE if successful, FALSE if not.
 * Author: shouse, 3.4.02
 * Notes: 
 */
BOOLEAN Main_send_frame_parse (
    PMAIN_CTXT            ctxtp,        
    IN PNDIS_PACKET       pPacket,      
    OUT PMAIN_PACKET_INFO pPacketInfo); 

/*
 * Function: Main_ip_recv_filter
 * Description: This function filters incoming IP traffic, often by querying the load
 *              module for load-balancing decisions.  Packets addressed to the dedicated
 *              address are always allowed to pass, as are protocols that are not
 *              specifically filtered by NLB.  
 * Parameters: ctxtp - a pointer to the NLB main context structure for this adapter.
 *             pPacketInfo - a pointer to the MAIN_PACKET_INFO structure parsed by Main_recv_frame_parse
 *                           which contains pointers to the IP and TCP/UDP headers.
#if defined (NLB_HOOK_ENABLE)
 *             filter - the filtering directive returned by the filtering hook, if registered.
#endif
 * Returns: BOOLEAN - if TRUE, accept the packet, otherwise, reject it.
 * Author: kyrilf, shouse 3.4.02
 * Notes: 
 */
BOOLEAN   Main_ip_recv_filter(
    PMAIN_CTXT                ctxtp,
#if defined (NLB_HOOK_ENABLE)
    PMAIN_PACKET_INFO         pPacketInfo,
    NLB_FILTER_HOOK_DIRECTIVE filter
#else
    PMAIN_PACKET_INFO         pPacketInfo
#endif
    );

/*
 * Function: Main_ip_send_filter
 * Description: This function filters outgoing IP traffic, often by querying the load
 *              module for load-balancing decisions.  Packets addressed to the dedicated
 *              address are always allowed to pass, as are protocols that are not
 *              specifically filtered by NLB.  Generally, all outgoing traffic is allowed
 *              to pass.
 * Parameters: ctxtp - a pointer to the NLB main context structure for this adapter.
 *             pPacketInfo - a pointer to the MAIN_PACKET_INFO structure parsed by Main_send_frame_parse
 *                           which contains pointers to the IP and TCP/UDP headers.
#if defined (NLB_HOOK_ENABLE)
 *             filter - the filtering directive returned by the filtering hook, if registered.
#endif
 * Returns: BOOLEAN - if TRUE, accept the packet, otherwise, reject it.
 * Author: kyrilf, shouse 3.4.02
 * Notes: 
 */
BOOLEAN   Main_ip_send_filter(
    PMAIN_CTXT                ctxtp,
#if defined (NLB_HOOK_ENABLE)
    PMAIN_PACKET_INFO         pPacketInfo,
    NLB_FILTER_HOOK_DIRECTIVE filter
#else
    PMAIN_PACKET_INFO         pPacketInfo
#endif
    );

/*
 * Function: Main_ctrl
 * Description: This function performs a control function on a given NLB instance, such as
 *              RELOAD, STOP, START, etc.  
 * Parameters: ctxtp - a pointer to the adapter context for the operation.
 *             ioctl - the operation to be performed.
 *             pBuf - the (legacy) control buffer (input and output in some cases).
 *             pCommon - the input/output buffer for operations common to both local and remote control.
 *             pLocal - the input/output buffer for operations that can be executed locally only.
 *             pRemote - the input/output buffer for operations that can be executed remotely only.
 * Returns: NDIS_STATUS - the status of the operation; NDIS_STATUS_SUCCESS if successful.
 * Author: shouse, 3.29.01
 * Notes: 
 */
extern NDIS_STATUS Main_ctrl (PMAIN_CTXT ctxtp, ULONG ioctl, PIOCTL_CVY_BUF pBuf, PIOCTL_COMMON_OPTIONS pCommon, PIOCTL_LOCAL_OPTIONS pLocal, PIOCTL_REMOTE_OPTIONS pRemote);

/*
 * Function: Main_add_reference
 * Description: This function adds a reference to the context of a given adapter.
 * Parameters: ctxtp - a pointer to the context to reference.
 * Returns: ULONG - The incremented value.
 * Author: shouse, 3.29.01
 * Notes: 
 */
ULONG Main_add_reference (IN PMAIN_CTXT ctxtp);

/*
 * Function: Main_release_reference
 * Description: This function releases a reference on the context of a given adapter.
 * Parameters: ctxtp - a pointer to the context to dereference.
 * Returns: ULONG - The decremented value.
 * Author: shouse, 3.29.01
 * Notes: 
 */
ULONG Main_release_reference (IN PMAIN_CTXT ctxtp);

/*
 * Function: Main_get_reference_count
 * Description: This function returns the current context reference count on a given adapter.
 * Parameters: ctxtp - a pointer to the context to check.
 * Returns: ULONG - The current reference count.
 * Author: shouse, 3.29.01
 * Notes: 
 */
ULONG Main_get_reference_count (IN PMAIN_CTXT ctxtp);

/* 
 * Function: Main_set_host_state
 * Desctription: This function queues a work item to set the current host
 *               state registry key, HostState.  This MUST be done in a work
 *               item, rather than inline because if the state of the host
 *               changes as a result of the reception of a remote control
 *               request, that code will be running at DISPATCH_LEVEL; 
 *               registry manipulation MUST be done at PASSIVE_LEVEL.  Work
 *               items are completed at PASSIVE_LEVEL.
 * Parameters: ctxtp - a pointer to the main context structure for this adapter.
 *             state - the new host state; one of started, stopped, suspended.
 * Returns: Nothing
 * Author: shouse, 7.13.01
 */
VOID Main_set_host_state (PMAIN_CTXT ctxtp, ULONG state);

/*
 * Function: Main_ctrl_process
 * Description: This function processes a remote control request and replies if
 *              the request is proper and the cluster is configured to handle
 *              remote control.  If not, the packet is released HERE.  If the 
 *              reply succeeds and the packet send is not pending, the packet
 *              is released HERE.  If the send is pending, the packet will be
 *              released in Prot_send_complete.
 * Parameters: ctxtp - a pointer to the context structure for thie NLB instance.
 *             packetp - a pointer to the NDIS packet on the send path.
 * Returns: NDIS_STATUS - the status of the remote control request.
 * Author: shouse, 10.15.01
 * Notes: 
 */
NDIS_STATUS Main_ctrl_process (PMAIN_CTXT ctxtp, PNDIS_PACKET packetp) ;

#if defined (NLB_HOOK_ENABLE)
/*
 * Function: Main_hook_interface_init
 * Description: This function initializes a hook interface by marking it unregistered.
 * Parameters: pInterface - a pointer to the hook interface.
 * Returns: Nothing.
 * Author: shouse, 12.14.01
 * Notes: 
 */
VOID Main_hook_interface_init (PHOOK_INTERFACE pInterface);

/*
 * Function: Main_hook_init
 * Description: This function initializes a hook by marking it unused and unreferenced.
 * Parameters: pHook - a pointer to the hook.
 * Returns: Nothing.
 * Author: shouse, 12.14.01
 * Notes: 
 */
VOID Main_hook_init (PHOOK pHook);
#endif

/*
 * Function: Main_schedule_work_item
 * Description: This function schedules the given procedure to be invoked as part of a
 *              deferred NDIS work item, which will be scheduled to run at PASSIVE_LEVEL.
 *              This function will refernce the adapter context to keep it from being
 *              destroyed before the work item executed.  The given procedure is required
 *              to both free the memory in the work item pointer passed to it and to 
 *              dereference the adapter context before returning.
 * Parameters: ctxtp - the adapter context.
 *             funcp - the procedure to invoke when the work item fires.
 * Returns: NTSTATUS - the status of the operation; STATUS_SUCCESS if successful.
 * Author: shouse, 4.15.02
 * Notes: 
 */
NTSTATUS Main_schedule_work_item (PMAIN_CTXT ctxtp, NDIS_PROC funcp);

#if defined (NLB_TCP_NOTIFICATION)
/*
 * Function: Main_tcp_callback
 * Description: This function is invoked by TCP/IP as the state of TCP connections change.
 *              We register for this callback when the first NLB instance goes up and de-
 *              register when the last instance of NLB goes away.  When SYNs are received
 *              and TCP creates state, they use this callback to notify NLB so that it can
 *              create state to track the connection.  Likewise, when the connection is 
 *              closed, TCP notifies NLB so that it may destroy the associated state for
 *              that connection.
 * Parameters: Context - NULL, unused.
 *             Argument1 - pointer to a TCPCcbInfo structure (See net\published\inc\tcpinfo.w).
 *             Argument2 - NULL, unused.
 * Returns: Nothing.
 * Author: shouse, 4.15.02
 * Notes: 
 */
extern VOID Main_tcp_callback (PVOID Context, PVOID Argument1, PVOID Argument2);

/*
 * Function: Main_alternate_callback
 * Description: This function is invoked by external components as the state of connections 
 *              change.  We register for this callback when the first NLB instance goes up 
 *              and de-register when the last instance of NLB goes away.  When connections
 *              are created and a protocol creates state, they use this callback to notify
 *              NLB so that it can create state to track the connection.  Likewise, when the 
 *              connection is closed, the protocol notifies NLB so that it may destroy the 
 *              associated state for that connection.
 * Parameters: Context - NULL, unused.
 *             Argument1 - pointer to a NLBConnectionInfo structure (See net\published\inc\ntddnlb.w).
 *             Argument2 - NULL, unused.
 * Returns: Nothing.
 * Author: shouse, 8.1.02
 * Notes: 
 */
extern VOID Main_alternate_callback (PVOID Context, PVOID Argument1, PVOID Argument2);

/*
 * Function: Main_set_interface_index
 * Description: This function is called as a result of either the IP address table being
 *              modified (triggers a OID_GEN_NETWORK_LAYER_ADDRESSES NDIS request), or 
 *              when the NLB instance is reloaded (IOCTL_CVY_RELOAD).  This function 
 *              retrieves the IP address table from IP and searches for its primary
 *              cluster IP address in the table.  If it finds it, it notes the IP interface
 *              index on which the primary cluster IP address is configured; this infor-
 *              mation is required in order to process TCP connection notifcation callbacks.
 *              If NLB cannot find its primary cluster IP address in the IP table, or 
 *              if the cluster is misconfigured (primary cluster IP address configured on
 *              the wrong NIC, perhaps), NLB will be unable to properly handle notifications.
 *              Because this function performs IOCTLs on other drivers, it MUST run at 
 *              PASSIVE_LEVEL, in which case NDIS work items might be required to invoke it.
 * Parameters: pWorkItem - the work item pointer, which must be freed if non-NULL.
 *             nlbctxt - the adapter context.
 * Returns: Nothing.
 * Author: shouse, 4.15.02
 * Notes: 
 */
VOID Main_set_interface_index (PNDIS_WORK_ITEM pWorkItem, PVOID nlbctxt);

/*
 * Function: Main_conn_up
 * Description: This function is used to notify NLB that a new connection has been established
 *              on the given NLB instance.  This function performs a few house-keeping duties
 *              such as BDA state lookup, hook filter feedback processing, etc. before calling
 *              the load module to create state to track this connection.
 * Parameters: ctxtp - the adapter context for the NLB instance on which the connection was established.
 *             svr_addr - the server IP address of the connection, in network byte order.
 *             svr_port - the server port of the connection, in host byte order.
 *             clt_addr - the client IP address of the connection, in network byte order.
 *             clt_port - the client port of the connection, in host byte order.
 *             protocol - the protocol of the connection.
#if defined (NLB_HOOK_ENABLE)
 *             filter - the feedback from the query hook, if one was registered.
#endif
 * Returns: BOOLEAN - whether or not state was successfully created to track this connection.
 * Author: shouse, 4.15.02
 * Notes: DO NOT ACQUIRE ANY LOAD LOCKS IN THIS FUNCTION.
 */
__inline BOOLEAN Main_conn_up (
    PMAIN_CTXT                ctxtp, 
    ULONG                     svr_addr, 
    ULONG                     svr_port, 
    ULONG                     clt_addr, 
    ULONG                     clt_port,
#if defined (NLB_HOOK_ENABLE)
    USHORT                    protocol,
    NLB_FILTER_HOOK_DIRECTIVE filter
#else
    USHORT                    protocol
#endif
);

/*
 * Function: Main_conn_establish
 * Description: This function is used to notify NLB that a new OUTGOING connection has been 
 *              established on the given NLB adapter.  Note that the context CAN BE NULL if 
 *              the connection was established on a non-NLB adapter.  In that case, we don't
 *              want to create state to track the connection, but we need to remove our state
 *              that was tracking this pending outgoing connection.  If the context is non-
 *              NULL, then in addition, we need to create the state to track this new connection.
 *              This function performs a few house-keeping duties such as BDA state lookup, hook 
 *              filter feedback processing, etc. before calling the load module to modify the
 *              state for this connection.
 * Parameters: ctxtp - the adapter context for the NLB instance on which the connection was established.
 *             svr_addr - the server IP address of the connection, in network byte order.
 *             svr_port - the server port of the connection, in host byte order.
 *             clt_addr - the client IP address of the connection, in network byte order.
 *             clt_port - the client port of the connection, in host byte order.
 *             protocol - the protocol of the connection.
#if defined (NLB_HOOK_ENABLE)
 *             filter - the feedback from the query hook, if one was registered.
#endif
 * Returns: BOOLEAN - whether or not state was successfully updated for this connection.
 * Author: shouse, 4.15.02
 * Notes: ctxtp CAN BE NULL if the outgoing connection was established on a non-NLB NIC.
 *        DO NOT ACQUIRE ANY LOAD LOCKS IN THIS FUNCTION.
 */
__inline BOOLEAN Main_conn_establish (
    PMAIN_CTXT                ctxtp, 
    ULONG                     svr_addr, 
    ULONG                     svr_port, 
    ULONG                     clt_addr, 
    ULONG                     clt_port,
#if defined (NLB_HOOK_ENABLE)
    USHORT                    protocol,
    NLB_FILTER_HOOK_DIRECTIVE filter
#else
    USHORT                    protocol
#endif
);

/*
 * Function: Main_conn_down
 * Description: This function is used to notify NLB that a protocol is removing state for an exisiting 
 *              (but not necessarily established) connection.  This function calls into the load module
 *              to find and destroy and state associated with this connection, which may or may not
 *              exist; if the connection was established on a non-NLB adapter, then NLB has no state
 *              associated with the connection.
 * Parameters: svr_addr - the server IP address of the connection, in network byte order.
 *             svr_port - the server port of the connection, in host byte order.
 *             clt_addr - the client IP address of the connection, in network byte order.
 *             clt_port - the client port of the connection, in host byte order.
 *             protocol - the protocol of the connection.
 *             conn_status - whether the connection is being torn-down or reset.
 * Returns: BOOLEAN - whether or not NLB found and destroyed the state for this connection.
 * Author: shouse, 4.15.02
 * Notes: DO NOT ACQUIRE ANY LOAD LOCKS IN THIS FUNCTION.
 */
__inline BOOLEAN Main_conn_down (ULONG svr_addr, ULONG svr_port, ULONG clt_addr, ULONG clt_port, USHORT protocol, ULONG conn_status); 

/*
 * Function: Main_conn_pending
 * Description: This function is used to notify NLB that an OUTGOING connection is being established.
 *              Because it is unknown on which adapter the connection will return and ultimately be
 *              established, NLB creates state to track this connection globally and when the connection
 *              is finally established, the protocol informs NLB on which adapter the connection was
 *              completed (via Main_conn_established).  This function merely creates some global state
 *              to ensure that if the connection DOES come back on an NLB adapter, we'll be sure to 
 *              pass the packet(s) up to the protocol.
 * Parameters: svr_addr - the server IP address of the connection, in network byte order.
 *             svr_port - the server port of the connection, in host byte order.
 *             clt_addr - the client IP address of the connection, in network byte order.
 *             clt_port - the client port of the connection, in host byte order.
 *             protocol - the protocol of the connection.
 * Returns: BOOLEAN - whether or not NLB was able to create state to track this pending connection.
 * Author: shouse, 4.15.02
 * Notes: DO NOT ACQUIRE ANY LOAD LOCKS IN THIS FUNCTION.
 */
__inline BOOLEAN Main_conn_pending (ULONG svr_addr, ULONG svr_port, ULONG clt_addr, ULONG clt_port, USHORT protocol); 
#endif

#endif /* _Main_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\driver\nlbwmi.h ===
#include <guiddef.h>

#define NLB_EVENT_NO_DIP_STRING L"0.0.0.0"

typedef struct _NLB_WMI_EVENT
{
    GUID   *pGuid;
    BOOL    Enable;
}NLB_WMI_EVENT;

extern NLB_WMI_EVENT NlbWmiEvents[];

typedef enum 
{
    NodeControlEvent = 0,  // DO NOT change this value. It is used as an index into the NlbWmiEvents array
    PortRuleControlEvent,
    ConvergingEvent,
    ConvergedEvent,
    StartupEvent,
    ShutdownEvent
}NlbWmiEventId;

typedef enum
{
    NLB_EVENT_NODE_STARTED = 1, 
    NLB_EVENT_NODE_STOPPED, 
    NLB_EVENT_NODE_DRAINING, 
    NLB_EVENT_NODE_SUSPENDED, 
    NLB_EVENT_NODE_RESUMED, 
    NLB_EVENT_NODE_RELOADED,
    NLB_EVENT_NODE_BOUND_AND_STARTED,
    NLB_EVENT_NODE_BOUND_AND_STOPPED,
    NLB_EVENT_NODE_BOUND_AND_SUSPENDED,
    NLB_EVENT_NODE_UNBOUND
} NodeControlEventId;

typedef enum
{
    NLB_EVENT_PORT_ENABLED = 1, 
    NLB_EVENT_PORT_DISABLED, 
    NLB_EVENT_PORT_DRAINING
} PortControlEventId;

typedef enum
{
    NLB_EVENT_CONVERGING_BAD_CONFIG = 1, 
    NLB_EVENT_CONVERGING_NEW_MEMBER, 
    NLB_EVENT_CONVERGING_UNKNOWN, 
    NLB_EVENT_CONVERGING_DUPLICATE_HOST_ID,  
    NLB_EVENT_CONVERGING_NUM_RULES, 
    NLB_EVENT_CONVERGING_MODIFIED_RULES, 
    NLB_EVENT_CONVERGING_MEMBER_LOST,  
    NLB_EVENT_CONVERGING_MODIFIED_PARAMS,
    NLB_EVENT_CONVERGING_INVALID_VALUE   // Add new events above this value
} ConvergingEventId;

NTSTATUS NlbWmi_Initialize();
VOID     NlbWmi_Shutdown();
NTSTATUS NlbWmi_System_Control (PVOID DeviceObject, PIRP pIrp);
NTSTATUS NlbWmi_Fire_Event(NlbWmiEventId Event, PVOID pvInEventData, ULONG ulInEventDataSize);
void     NlbWmi_Fire_NodeControlEvent(PMAIN_CTXT ctxtp, NodeControlEventId Id);
void     NlbWmi_Fire_PortControlEvent(PMAIN_CTXT ctxtp, PortControlEventId Id, WCHAR *pwcVip, ULONG ulPort);
void     NlbWmi_Fire_ConvergingEvent( PMAIN_CTXT ctxtp, ConvergingEventId Cause, WCHAR *pwcInitiatorDip, ULONG ulInitiatorHostPriority);
void     NlbWmi_Fire_ConvergedEvent(PMAIN_CTXT ctxtp, ULONG ulHostMap);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\driver\nlbwmi.c ===
/*++

Copyright(c) 2001  Microsoft Corporation

Module Name:

    nlbwmi.c

Abstract:

    Network Load Balancing (NLB)
    Driver - WMI event generation

Author:

    karthicn

--*/


#include "wlbsparm.h"
#include <wmistr.h>
#include <wmiguid.h>
#include <wmilib.h>
#include "main.h"
#include "univ.h"
#include "nlbwmimof.h"
#include "nlbwmi.h"
#include "nlbwmi.tmh"

//
// MOF Resource Name
//
WCHAR NLBMofResourceName[]  = L"NLBMofResource";

//
// Base Instance Name
//
WCHAR NLBBaseInstanceName[] = L"NLB_Block";


// NLB Event Guids - the MicrosoftNLB* variables are autogenerated (in nlbwmimof.h)
GUID NodeControlEventGuid     = MicrosoftNLB_NodeControlEventGuid;
GUID PortRuleControlEventGuid = MicrosoftNLB_PortControlEventGuid;
GUID ConvergingEventGuid      = MicrosoftNLB_ConvergingEventGuid;
GUID ConvergedEventGuid       = MicrosoftNLB_ConvergedEventGuid;
GUID StartupEventGuid         = MicrosoftNLB_StartupEventGuid;
GUID ShutdownEventGuid        = MicrosoftNLB_ShutdownEventGuid;

// NLB Event Guid Registration Information
WMIGUIDREGINFO NlbWmiGuidList[] = 
{
    {
        &NodeControlEventGuid,
        1,
        WMIREG_FLAG_EVENT_ONLY_GUID
    },
    {
        &PortRuleControlEventGuid,
        1,
        WMIREG_FLAG_EVENT_ONLY_GUID
    },
    {
        &ConvergingEventGuid,
        1,
        WMIREG_FLAG_EVENT_ONLY_GUID
    },
    {
        &ConvergedEventGuid,
        1,
        WMIREG_FLAG_EVENT_ONLY_GUID
    },
    {
        &StartupEventGuid,
        1,
        WMIREG_FLAG_EVENT_ONLY_GUID
    },
    {
        &ShutdownEventGuid,
        1,
        WMIREG_FLAG_EVENT_ONLY_GUID
    },
    // Add new event info here
};

#define NlbWmiGuidCount  (ULONG)(sizeof(NlbWmiGuidList)/sizeof(WMIGUIDREGINFO))


// NLB Event Information
NLB_WMI_EVENT NlbWmiEvents[] =
{
    {
        &NodeControlEventGuid,
        FALSE
    },
    {
        &PortRuleControlEventGuid,
        FALSE
    },
    {
        &ConvergingEventGuid,
        FALSE
    },
    {
        &ConvergedEventGuid,
        FALSE
    },
    {
        &StartupEventGuid,
        FALSE
    },
    {
        &ShutdownEventGuid,
        FALSE
    },
    // Add new event info here as well
};

//
// Prototype declarations
//

NTSTATUS
NlbWmi_Query_RegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
);


NTSTATUS
NlbWmi_Query_DataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
);

NTSTATUS
NlbWmi_Function_Control(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN WMIENABLEDISABLECONTROL Function,
    IN BOOLEAN Enable
);

//
// WMI Helper Library context
//
WMILIB_CONTEXT NlbWmiLibContext = 
{
   NlbWmiGuidCount,
   NlbWmiGuidList,
   NlbWmi_Query_RegInfo,
   NlbWmi_Query_DataBlock,
   NULL,
   NULL,
   NULL,
   NlbWmi_Function_Control
};

/*
Name        : NlbWmi_Initialize
Description : This function initializes the data structures and registers the supported guids with the wmi system
Arguments   : None
Return Value: status
*/

NTSTATUS NlbWmi_Initialize()
{
    ULONG idx;
    NTSTATUS status;

    TRACE_VERB("->%!FUNC!");

    /* Disable event generation for all events */
    for (idx = 0 ; idx < NlbWmiGuidCount ; idx++) 
    {
        NlbWmiEvents[idx].Enable = FALSE;
    }

    if (univ_device_object != NULL) 
    {
        /* Register with WMI */
        status = IoWMIRegistrationControl(univ_device_object, WMIREG_ACTION_REGISTER);
        if (status != STATUS_SUCCESS) 
        {
            TRACE_CRIT("%!FUNC! IoWMIRegistrationControl(DeviceObject : %p, REGISTER) returned Error : 0x%x",univ_device_object, status);
        }
    }
    else // Device Object is NULL
    {
        status = STATUS_INVALID_DEVICE_OBJECT_PARAMETER;
        TRACE_CRIT("%!FUNC! Device Object is NULL, Could not call IoWMIRegistrationControl() to register with WMI");
    }

    TRACE_VERB("<-%!FUNC! return : 0x%x", status);
    return status;
}

/*
Name        : NlbWmi_Shutdown
Description : This function de-registers with the wmi system
Arguments   : None
Return Value: void
*/

VOID NlbWmi_Shutdown()
{
    NTSTATUS ntStatus;

    TRACE_VERB("->%!FUNC!");

    if (univ_device_object != NULL) 
    {
        /* DeRegister with WMI */
        ntStatus = IoWMIRegistrationControl(univ_device_object, WMIREG_ACTION_DEREGISTER);
        if (ntStatus != STATUS_SUCCESS) 
        {
            TRACE_CRIT("%!FUNC! IoWMIRegistrationControl(DeviceObject : %p, DEREGISTER) returned Error : 0x%x",univ_device_object, ntStatus);
        }
    }
    else
    {
        TRACE_CRIT("%!FUNC! Device Object is NULL, Could not call IoWMIRegistrationControl() to deregister with WMI");
    }

    TRACE_VERB("<-%!FUNC!");
    return;
}

/*
Name        : NlbWmi_System_Control
Description : This function is responsible for handling the IRP_MJ_SYSTEM_CONTROL irps. It uses the wmi helper
              library function to crack the irp to have the appropriate call back functions called
Arguments   : Device Object, Irp
Return Value: status
*/

NTSTATUS NlbWmi_System_Control (PVOID DeviceObject, PIRP pIrp)
{
    NTSTATUS status;
    SYSCTL_IRP_DISPOSITION disposition;

    TRACE_VERB("->%!FUNC!");

    //
    // Call Wmilib helper function to crack the irp. If this is a wmi irp
    // that is targetted for the supported guids, then WmiSystemControl will callback
    // at the appropriate callback routine.
    //
    status = WmiSystemControl(
                &NlbWmiLibContext,
                DeviceObject,
                pIrp,
                &disposition
                );

    switch(disposition)
    {
        case IrpProcessed:
            //
            // This irp has been processed and may be completed or pending.
            //
            break;

        case IrpNotCompleted:
            //
            // This irp has not been completed, but has been fully processed.
            // so we need to complete it
            // (Must be a IRP_MN_REG_INFO)
            //
            IoCompleteRequest(pIrp, IO_NO_INCREMENT);        
            break;

        default:
        case IrpNotWmi:
        case IrpForward:
        {
            TRACE_CRIT("%!FUNC! WmiSystemControl returned disposition : 0x%x, Unexpected", disposition);
            pIrp->IoStatus.Status = status;
            IoCompleteRequest(pIrp, IO_NO_INCREMENT);        
            break;
        }

    }

    if( !NT_SUCCESS( status ))
    {
        TRACE_CRIT("%!FUNC! WmiSystemControl returned error : 0x%x", status);
    }

    TRACE_VERB("<-%!FUNC! return : 0x%x", status);
    return status;
} //  NlbWmi_System_Control

/*
Name        : NlbWmi_Query_RegInfo
Description : This function is called back by the Wmi helper library to process a IRP_MN_REG_INFO irp. It 
              registers the Instance name, registry path & Mof resource name with wmi. For more information
              about this function, please look in the DDK under "WMI library Callback Routines"->"DpWmiQueryReginfo"
Return Value: status
*/

NTSTATUS
NlbWmi_Query_RegInfo(
    IN PDEVICE_OBJECT    DeviceObject,
    OUT ULONG           *RegFlags,
    OUT PUNICODE_STRING  InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING  MofResourceName,
    OUT PDEVICE_OBJECT  *Pdo
    )
{    
    PAGED_CODE();

    TRACE_VERB("->%!FUNC!");
    
    //
    // Tell WMI to generate instance names off of a static base name
    //
    *RegFlags = WMIREG_FLAG_INSTANCE_BASENAME;

    //
    // Set our base instance name. WmiLib will call ExFreePool on the buffer
    // of the string, so we need to allocate it from paged pool.
    //
    InstanceName->Length = wcslen( NLBBaseInstanceName ) * sizeof( WCHAR );
    InstanceName->MaximumLength = InstanceName->Length + sizeof( UNICODE_NULL );
    InstanceName->Buffer = ExAllocatePoolWithTag(
                            PagedPool,
                            InstanceName->MaximumLength,
                            UNIV_POOL_TAG
                            );
    if( NULL != InstanceName->Buffer )
    {
        RtlCopyMemory(
            InstanceName->Buffer,
            NLBBaseInstanceName,
            InstanceName->Length
            );
        InstanceName->Buffer[InstanceName->Length / sizeof(WCHAR)] = UNICODE_NULL;
    }
    else
    {
        TRACE_CRIT("%!FUNC! Error allocating memory");
        TRACE_VERB("<-%!FUNC! return status = STATUS_INSUFFICIENT_RESOURCES");
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Return the registry path for this driver. This is required so WMI
    // can find your driver image and can attribute any eventlog messages to
    // your driver.
    //
    *RegistryPath = &DriverEntryRegistryPath;

    //
    // Return the name specified in the .rc file of the resource which
    // contains the binary mof data. 
    //
    RtlInitUnicodeString(MofResourceName, NLBMofResourceName);

    TRACE_VERB("<-%!FUNC! return=0x%x", STATUS_SUCCESS);
    return STATUS_SUCCESS;
} // NlbWmi_Query_RegInfo

/*
Name        : NlbWmi_Query_DataBlock
Description : This function is called back by the Wmi helper library to process IRP_MN_QUERY_ALL_DATA 
              & IRP_MN_QUERY_SINGLE_INSTANCE irps. We DO NOT SUPPORT these irps. However, this is a 
              required callback and hence we implement it. We DO NOT EXPECT THIS FUNCTION TO BE CALLED. 
              For more information about this function, please look in the DDK under 
              "WMI library Callback Routines"->"DpWmiQueryDataBlock"
Return Value: status
*/

NTSTATUS
NlbWmi_Query_DataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    )
    
{
    NTSTATUS status;

    PAGED_CODE();

    TRACE_VERB("->%!FUNC!");
    
    status = WmiCompleteRequest(
                DeviceObject,
                Irp,
                STATUS_WMI_GUID_NOT_FOUND,
                0,
                IO_NO_INCREMENT
                );

    TRACE_VERB("<-%!FUNC! return=0x%x", status);
    return status;
} // NlbWmi_Query_DataBlock


/*
Name        : NlbWmi_Function_Control
Description : This function is called back by the Wmi helper library to process IRP_MN_ENABLE_EVENTS, 
              IRP_MN_DISABLE_EVENTS, IRP_MN_ENABLE_COLLECTION & IRP_MN_DISABLE_COLLECTION irps. We only 
              support IRP_MN_ENABLE_EVENTS & IRP_MN_DISABLE_EVENTS irps. The function enables/disables
              events generation. For more information about this function, please look in the DDK under 
              "WMI library Callback Routines"->"DpWmiQueryReginfo"
Return Value: status
*/

NTSTATUS
NlbWmi_Function_Control(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN WMIENABLEDISABLECONTROL Function,
    IN BOOLEAN Enable
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    TRACE_VERB("->%!FUNC! %ls Event Index : %d", Enable ? L"ENABLE" : L"DISABLE", GuidIndex);

    if( WmiEventControl == Function )
    {
        // Verify that the guid index is in the range 0 - (NlbWmiGuidCount - 1)
        // Also, verify that the guid has not been flagged as removed. Although 
        // we never flag a guid as being removed, do this check as part of 
        // following "best practices".
        if( (GuidIndex < NlbWmiGuidCount) 
        && !(NlbWmiGuidList[GuidIndex].Flags & WMIREG_FLAG_REMOVE_GUID))
        {
            NlbWmiEvents[GuidIndex].Enable = Enable;
        }
        else
        {
            //
            // Invalid guid index.
            //
            
            status = STATUS_WMI_GUID_NOT_FOUND;

            TRACE_CRIT("%!FUNC! Invalid WMI guid or guid flagged as removed, guid index: %d", GuidIndex);
        }
    }
    else
    {
        //
        // We currently don't have any (expensive) data blocks
        //
        
        status = STATUS_INVALID_DEVICE_REQUEST;
        TRACE_CRIT("%!FUNC! Invalid Device Request");
    }

    status = WmiCompleteRequest(
                DeviceObject,
                Irp,
                status,
                0,
                IO_NO_INCREMENT
                );
                
    TRACE_VERB("<-%!FUNC! return status = 0x%x", status);
    return status;
} // NlbWmi_Function_Control

/*
Name        : NlbWmi_Fire_Event
Description : This function fires wmi events. It allocates memory, fills it in with the 
              incoming event data and calls WmiFireEvent to fire the event.
Arguments   : Event Id, Event Data (statically allocated)
Return Value: status
*/

NTSTATUS NlbWmi_Fire_Event(NlbWmiEventId EventId, PVOID pvInEventData, ULONG ulInEventDataSize)
{
    NTSTATUS status;
    PVOID    pvOutEventData;

    TRACE_VERB("->%!FUNC! Event : %d", EventId);

    if (ulInEventDataSize > 0) 
    {
        pvOutEventData = ExAllocatePoolWithTag(NonPagedPool, ulInEventDataSize, UNIV_POOL_TAG);
        if (pvOutEventData == NULL) 
        {
            TRACE_CRIT("%!FUNC! Error allocating memory");
            TRACE_VERB("<-%!FUNC! return status = STATUS_INSUFFICIENT_RESOURCES");
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory(pvOutEventData, pvInEventData, ulInEventDataSize);
    }
    else
    {
        pvOutEventData = NULL;
    }

    status = WmiFireEvent(univ_device_object, NlbWmiEvents[EventId].pGuid, 0, ulInEventDataSize, pvOutEventData);
    if( !NT_SUCCESS( status ))
    {
        TRACE_CRIT("%!FUNC! WmiFireEvent returned error : 0x%x", status);
    }

    TRACE_VERB("<-%!FUNC! return status = 0x%x", status);
    return status;
} // NlbWmi_Fire_Event


// This macro fills in the common properties(Adapter Guid, IP Address, Host priority) of all events
#define FillCommonProperties()                                                                                                 \
{                                                                                                                              \
    Event.AdapterGuid[0] = sizeof(Event.AdapterGuid) - sizeof(Event.AdapterGuid[0]);                                           \
    wcsncpy(&(Event.AdapterGuid[1]), univ_adapters[ctxtp->adapter_id].device_name + 8, Event.AdapterGuid[0]/sizeof(WCHAR));    \
    Event.ClusterIPAddress[0] = sizeof(Event.ClusterIPAddress) - sizeof(Event.ClusterIPAddress[0]);                            \
    wcsncpy(&(Event.ClusterIPAddress[1]), ctxtp->params.cl_ip_addr, Event.ClusterIPAddress[0]/sizeof(WCHAR));                  \
    Event.HostPriority = ctxtp->params.host_priority;                                                                          \
}

/*
Name        : NlbWmi_Fire_NodeControlEvent
Description : This function fires Node Control events. It extracts the common event properties 
              (out of the given pointer to the MAIN_CTXT structure) and fills in a local
              structure. It also fills in Node Control Event specific fields from the arguments
              passed to it. It then fires the actual event by calling NlbWmi_Fire_Event.
Arguments   : Pointer to MAIN_CTXT, NodeControlEventId
Return Value: void
*/

void NlbWmi_Fire_NodeControlEvent(PMAIN_CTXT ctxtp, NodeControlEventId Id)
{
    MicrosoftNLB_NodeControlEvent Event;

    TRACE_VERB("->%!FUNC! Event : %d", Id);

    NdisZeroMemory(&Event, MicrosoftNLB_NodeControlEvent_SIZE);

    // Fill in common properties - Adapter Guid, Cluster IP Address & Host Priority
    FillCommonProperties()

    // Fill event specific properties
    Event.Id = Id;

    // Fire the event
    NlbWmi_Fire_Event(NodeControlEvent, &Event, MicrosoftNLB_NodeControlEvent_SIZE);

    TRACE_VERB("<-%!FUNC!");
    return;
}

/*
Name        : NlbWmi_Fire_PortControlEvent
Description : This function fires Port Control events. It extracts the common event properties 
              (out of the given pointer to the MAIN_CTXT structure) and fills in a local
              structure. It also fills in Port Control Event specific fields (id, vip, port) from the arguments
              passed to it. It then fires the actual event by calling NlbWmi_Fire_Event.
Arguments   : Pointer to MAIN_CTXT, PortControlEventId, Vip, Port
Return Value: void
*/

void NlbWmi_Fire_PortControlEvent(PMAIN_CTXT ctxtp, PortControlEventId Id, WCHAR *pwcVip, ULONG ulPort)
{
    MicrosoftNLB_PortControlEvent Event;

    TRACE_VERB("->%!FUNC! Event : %d, Vip : %ls, Start Port : %d", Id, pwcVip, ulPort);

    NdisZeroMemory(&Event, MicrosoftNLB_PortControlEvent_SIZE);

    // Fill in common properties - Adapter Guid, Cluster IP Address & Host Priority
    FillCommonProperties()

    // Fill event specific properties
    Event.Id = Id;
    Event.VirtualIPAddress[0] = sizeof(Event.VirtualIPAddress) - sizeof(Event.VirtualIPAddress[0]); 
    wcsncpy(&(Event.VirtualIPAddress[1]), pwcVip, Event.VirtualIPAddress[0]/sizeof(WCHAR));
    Event.Port = ulPort;

    // Fire the event
    NlbWmi_Fire_Event(PortRuleControlEvent, &Event, MicrosoftNLB_PortControlEvent_SIZE);

    TRACE_VERB("<-%!FUNC!");
    return;
}

/*
Name        : NlbWmi_Fire_ConvergingEvent
Description : This function fires Converging events. It extracts the common event properties 
              (out of the given pointer to the MAIN_CTXT structure) and fills in a local
              structure. It also fills in Converging Event specific fields from the arguments
              passed to it. It then fires the actual event by calling NlbWmi_Fire_Event.
Arguments   : Pointer to MAIN_CTXT, NodeControlEventId, Initiator DIP, Initiator Host Priority
Return Value: void
*/

void NlbWmi_Fire_ConvergingEvent(
     PMAIN_CTXT         ctxtp, 
     ConvergingEventId  Cause, 
     WCHAR             *pwcInitiatorDip, 
     ULONG              ulInitiatorHostPriority)
{
    MicrosoftNLB_ConvergingEvent Event;

    TRACE_VERB("->%!FUNC! Cause : %d, Initiator DIP : %ls, Initiator Host Priority : %d", Cause, pwcInitiatorDip, ulInitiatorHostPriority);

    NdisZeroMemory(&Event, MicrosoftNLB_ConvergingEvent_SIZE);

    // Fill in common properties - Adapter Guid, Cluster IP Address & Host Priority
    FillCommonProperties()

    // Fill event specific properties
    Event.Cause = Cause;
    Event.InitiatorDedicatedIP[0] = sizeof(Event.InitiatorDedicatedIP) - sizeof(Event.InitiatorDedicatedIP[0]);
    wcsncpy(&(Event.InitiatorDedicatedIP[1]), pwcInitiatorDip, Event.InitiatorDedicatedIP[0]/sizeof(WCHAR));
    Event.InitiatorHostPriority = ulInitiatorHostPriority;

    // Fire the event
    NlbWmi_Fire_Event(ConvergingEvent, &Event, MicrosoftNLB_ConvergingEvent_SIZE);

    TRACE_VERB("<-%!FUNC!");
    return;
}

/*
Name        : NlbWmi_Fire_ConvergedEvent
Description : This function fires Converged events. It extracts the common event properties 
              (out of the given pointer to the MAIN_CTXT structure) and fills in a local
              structure. It also fills in Converged Event specific fields from the arguments
              passed to it. It then fires the actual event by calling NlbWmi_Fire_Event.
Arguments   : Pointer to MAIN_CTXT, HostMap
Return Value: void
*/

void NlbWmi_Fire_ConvergedEvent(PMAIN_CTXT ctxtp, ULONG ulHostMap)
{
    MicrosoftNLB_ConvergedEvent Event;

    TRACE_VERB("->%!FUNC! Host Map : %d", ulHostMap);

    NdisZeroMemory(&Event, MicrosoftNLB_ConvergedEvent_SIZE);

    // Fill in common properties - Adapter Guid, Cluster IP Address & Host Priority
    FillCommonProperties()

    // Fill event specific properties
    Event.HostMap = ulHostMap;

    // Fire the event
    NlbWmi_Fire_Event(ConvergedEvent, &Event, MicrosoftNLB_ConvergedEvent_SIZE);

    TRACE_VERB("<-%!FUNC!");
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\driver\nic.h ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    nic.h

Abstract:

    Windows Load Balancing Service (WLBS)
    Driver - upper-level (NIC) layer of intermediate miniport

Author:

    kyrilf

--*/


#ifndef _Nic_h_
#define _Nic_h_

#include <ndis.h>

#include "main.h"


/* PROCEDURES */


/* miniport handlers */

extern NDIS_STATUS Nic_init (
    PNDIS_STATUS        open_status,
    PUINT               medium_index,
    PNDIS_MEDIUM        medium_array,
    UINT                medium_size,
    NDIS_HANDLE         adapter_handle,
    NDIS_HANDLE         wrapper_handle);
/*
  Responds to protocol open request

  returns NDIS_STATUS:

  function:
*/


extern VOID Nic_halt (
    NDIS_HANDLE         adapter_handle);
/*
  Responds to protocol halt request

  returns VOID:

  function:
*/


extern NDIS_STATUS Nic_info_query (
    NDIS_HANDLE         adapter_handle,
    NDIS_OID            Oid,
    PVOID               info_buf,
    ULONG               info_len,
    PULONG              written,
    PULONG              needed);
/*
  Responds to protocol OID query request

  returns NDIS_STATUS:

  function:
*/


extern NDIS_STATUS Nic_info_set (
    NDIS_HANDLE         adapter_handle,
    NDIS_OID            oid,
    PVOID               info_buf,
    ULONG               info_len,
    PULONG              read,
    PULONG              needed);
/*
  Responds to protocol OID set request

  returns NDIS_STATUS:

  function:
*/


extern NDIS_STATUS Nic_reset (
    PBOOLEAN            addr_reset,
    NDIS_HANDLE         adapter_handle);
/*
  Responds to protocol reset request

  returns NDIS_STATUS:

  function:
*/


extern VOID Nic_packets_send (
    NDIS_HANDLE         adapter_handle,
    PNDIS_PACKET *      packets,
    UINT                num_packets);
/*
  Responds to protocol send packets request

  returns VOID:

  function:
*/


extern VOID Nic_return (
    NDIS_HANDLE         adapter_handle,
    PNDIS_PACKET        packet);
/*
  Responds to protocol return packet request

  returns NDIS_STATUS:

  function:
*/


/* These 3 functions have been added for NDIS51 support. */

extern VOID Nic_cancel_send_packets (
    NDIS_HANDLE         adapter_handle,
    PVOID               cancel_id);
/*
  Responds to CancelSendPackets request

  returns None:

  function:
*/

#if 0
extern VOID Nic_pnpevent_notify (
    NDIS_HANDLE              adapter_handle,
    NDIS_DEVICE_PNP_EVENT    pnp_event,
    PVOID                    info_buf,
    ULONG                    info_len);

/*
  Responds to PnPEventNotify request

  returns None:

  function:
*/
#endif

extern VOID Nic_adapter_shutdown (
    NDIS_HANDLE         adapter_handle);
/*
  Responds to AdapterShutdown request

  returns None:

  function:
*/


/* helpers for protocol layer */

extern NDIS_STATUS Nic_announce (
    PMAIN_CTXT          ctxtp);
/*
  Announces us to the protocol layer during binding to the lower adapter

  returns NDIS_STATUS:

  function:
*/


extern NDIS_STATUS Nic_unannounce (
    PMAIN_CTXT          ctxtp);
/*
  Unannounces us from the protocol layer during unbinding from the lower adapter

  returns NDIS_STATUS:

  function:
*/

extern VOID Nic_timer (
    PVOID                   dpc,
    PVOID                   ctxtp,
    PVOID                   arg1,
    PVOID                   arg2);
/*
  Heartbeat timer handler

  returns VOID:

  function:
*/


extern VOID Nic_sleep (
    ULONG                   msecs);
/*
  Sleep helper

  returns VOID:

  function:
*/



/* routines that can be used with Nic_sync */

extern VOID Nic_reset_complete (
    PMAIN_CTXT          ctxtp,
    NDIS_STATUS         status);
/*
  Propagate reset completion to protocol

  returns VOID:

  function:
*/


extern VOID Nic_request_complete (
    NDIS_HANDLE         handle,
    PVOID               actp);
/*
  Propagate request completion to protocol

  returns VOID:

  function:
*/


extern VOID Nic_send_complete (
    PMAIN_CTXT          ctxtp,
    NDIS_STATUS         status,
    PNDIS_PACKET        packet);
/*
  Propagate packet send completion to protocol

  returns VOID:

  function:
*/


extern VOID Nic_recv_complete (
    PMAIN_CTXT          ctxtp);
/*
  Propagate post-receive completion to protocol

  returns VOID:

  function:
*/


extern NDIS_STATUS Nic_PNP_handle (
    PMAIN_CTXT          ctxtp,
    PNET_PNP_EVENT      pnp_event);
/*
  Propagate PNP Events to protocol
  
  returns NDIS_STATUS:

  function:
*/


extern VOID Nic_status (
    PMAIN_CTXT          ctxtp,
    NDIS_STATUS         status,
    PVOID               buf,
    UINT                len);
/*
  Propagate status indication to protocol

  returns VOID:

  function:
*/


extern VOID Nic_status_complete (
    PMAIN_CTXT          ctxtp);
/*
  Propagate status indication completion to protocol

  returns VOID:

  function:
*/


extern VOID Nic_send_resources_signal (
    PMAIN_CTXT          ctxtp);
/*
  Send resource availability message to protocol

  returns VOID:

  function:
*/


extern VOID Nic_recv_packet (
    PMAIN_CTXT          ctxtp,
    PNDIS_PACKET        packet);
/*
  Propagate received packet to protocol

  returns VOID:

  function:
*/

/* Added from old code for NT 5.1 - ramkrish */
extern VOID Nic_recv_indicate (
    PMAIN_CTXT          ctxtp,
    NDIS_HANDLE         recv_handle,
    PVOID               head_buf,
    UINT                head_len,
    PVOID               look_buf,
    UINT                look_len,
    UINT                packet_len);
/*
  Propagates receive indication to protocol

  returns VOID:

  function:
*/


extern NDIS_STATUS Nic_transfer (
    PNDIS_PACKET        packet,
    PUINT               xferred,
    NDIS_HANDLE         adapter_handle,
    NDIS_HANDLE         receive_handle,
    UINT                offset,
    UINT                len);
/*
  Responds to protocol data transfer request

  returns NDIS_STATUS:

  function:
*/



extern VOID Nic_transfer_complete (
    PMAIN_CTXT          ctxtp,
    NDIS_STATUS         status,
    PNDIS_PACKET        packet,
    UINT                xferred);

/*
  Propagates data transfer completion to protocol

  returns VOID:

  function:
*/


/* old code */

#if 0
extern NDIS_STATUS Nic_send (
    NDIS_HANDLE         adapter_handle,
    PNDIS_PACKET        packet,
    UINT                flags);
/*
  Responds to protocol packet send request

  returns NDIS_STATUS:

  function:
*/

#endif

#endif /* _Nic_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\driver\nic.c ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    nic.c

Abstract:

    Windows Load Balancing Service (WLBS)
    Driver - upper-level (NIC) layer of intermediate miniport

Author:

    kyrilf

--*/


#define NDIS_MINIPORT_DRIVER    1
//#define NDIS50_MINIPORT         1
#define NDIS51_MINIPORT         1

#include <ndis.h>

#include "nic.h"
#include "prot.h"
#include "main.h"
#include "util.h"
#include "wlbsparm.h"
#include "univ.h"
#include "log.h"
#include "nic.tmh"

/* define this routine here since the necessary portion of ndis.h was not
   imported due to NDIS_... flags */

extern NTKERNELAPI VOID KeBugCheckEx (ULONG code, ULONG_PTR p1, ULONG_PTR p2, ULONG_PTR p3, ULONG_PTR p4);

NTHALAPI KIRQL KeGetCurrentIrql();

/* GLOBALS */

static ULONG log_module_id = LOG_MODULE_NIC;


/* PROCEDURES */


/* miniport handlers */

NDIS_STATUS Nic_init (      /* PASSIVE_IRQL */
    PNDIS_STATUS        open_status,
    PUINT               medium_index,
    PNDIS_MEDIUM        medium_array,
    UINT                medium_size,
    NDIS_HANDLE         adapter_handle,
    NDIS_HANDLE         wrapper_handle)
{
    PMAIN_CTXT          ctxtp;
    UINT                i;
    NDIS_STATUS         status;
    PMAIN_ADAPTER       adapterp;


    /* verify that we have the context setup (Prot_bind was called) */

    UNIV_PRINT_INFO(("Nic_init: Initializing, adapter_handle=0x%p", adapter_handle));

    ctxtp = (PMAIN_CTXT) NdisIMGetDeviceContext (adapter_handle);

    if (ctxtp == NULL)
    {
        UNIV_PRINT_INFO(("Nic_init: return=NDIS_STATUS_ADAPTER_NOT_FOUND"));
        TRACE_INFO("%!FUNC! return=NDIS_STATUS_ADAPTER_NOT_FOUND");
        return NDIS_STATUS_ADAPTER_NOT_FOUND;
    }

    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    adapterp = & (univ_adapters [ctxtp -> adapter_id]);
    UNIV_ASSERT (adapterp -> ctxtp == ctxtp);

    /* return supported mediums */

    for (i = 0; i < medium_size; i ++)
    {
        if (medium_array [i] == ctxtp -> medium)
        {
            * medium_index = i;
            break;
        }
    }

    if (i >= medium_size)
    {
        UNIV_PRINT_CRIT(("Nic_init: Unsupported media requested %d, %d, %x", i, medium_size, ctxtp -> medium));
        UNIV_PRINT_INFO(("Nic_init: return=NDIS_STATUS_UNSUPPORTED_MEDIA"));
        LOG_MSG2 (MSG_ERROR_MEDIA, MSG_NONE, i, ctxtp -> medium);
        TRACE_CRIT("%!FUNC! Unsupported media requested i=%d, size=%d, medium=0x%x", i, medium_size, ctxtp -> medium);
        TRACE_INFO("<-%!FUNC! return=NDIS_STATUS_UNSUPPORTED_MEDIA");
        return NDIS_STATUS_UNSUPPORTED_MEDIA;
    }

    ctxtp -> prot_handle = adapter_handle;

    NdisMSetAttributesEx (adapter_handle, ctxtp, 0,
                          NDIS_ATTRIBUTE_INTERMEDIATE_DRIVER |   /* V1.1.2 */  /* v2.07 */
                          NDIS_ATTRIBUTE_DESERIALIZE |
                          NDIS_ATTRIBUTE_IGNORE_PACKET_TIMEOUT |
                          NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT |
                          NDIS_ATTRIBUTE_NO_HALT_ON_SUSPEND, 0);

    /* Setting up the default value for the Device State Flag as PM capable
       initialize the PM Variable, (for both NIC and the PROT)
       Device is ON by default. */
    
    ctxtp->prot_pnp_state = NdisDeviceStateD0;
    ctxtp->nic_pnp_state  = NdisDeviceStateD0;
    
    /* Allocate memory for our pseudo-periodic NDIS timer. */
    status = NdisAllocateMemoryWithTag(&ctxtp->timer, sizeof(NDIS_MINIPORT_TIMER), UNIV_POOL_TAG);

    if (status != NDIS_STATUS_SUCCESS) {
        UNIV_PRINT_CRIT(("Nic_init: Error allocating timer; status=0x%x", status));
        UNIV_PRINT_INFO(("Nic_init: return=NDIS_STATUS_RESOURCES"));
        LOG_MSG2(MSG_ERROR_MEMORY, MSG_NONE, sizeof(NDIS_MINIPORT_TIMER), status);
        TRACE_CRIT("%!FUNC! Error allocating timer; status=0x%x", status);
        TRACE_INFO("<-%!FUNC! return=NDIS_STATUS_RESOURCES");
        return NDIS_STATUS_RESOURCES;
    }

    /* Initialize the timer structure; here we set the timer routine (Nic_timer) and the 
       context that will be a parameter to that function, the adapter MAIN_CTXT. */
    NdisMInitializeTimer((PNDIS_MINIPORT_TIMER)ctxtp->timer, ctxtp->prot_handle, Nic_timer, ctxtp);

    /* Set the initial timeout value to the default heartbeat period from the registry. */
    ctxtp->curr_tout = ctxtp->params.alive_period;

    {
        PNDIS_REQUEST request;
        MAIN_ACTION   act;
        ULONG         xferred;
        ULONG         needed;
        ULONG         result;

        act.code = MAIN_ACTION_CODE;
        act.ctxtp = ctxtp;
        
        act.op.request.xferred = &xferred;
        act.op.request.needed = &needed;
        act.op.request.external = FALSE;
        act.op.request.buffer_len = 0;
        act.op.request.buffer = NULL;
        
        NdisInitializeEvent(&act.op.request.event);
        NdisResetEvent(&act.op.request.event);
        
        NdisZeroMemory(&act.op.request.req, sizeof(NDIS_REQUEST));
        
        request = &act.op.request.req;

        /* Check to see if the media is connected.  Some cards do not register disconnection, so use this as a hint. */
        request->RequestType                                    = NdisRequestQueryInformation;
        request->DATA.QUERY_INFORMATION.Oid                     = OID_GEN_MEDIA_CONNECT_STATUS;
        request->DATA.QUERY_INFORMATION.InformationBuffer       = &result;
        request->DATA.QUERY_INFORMATION.InformationBufferLength = sizeof(ULONG);
        
        act.status = NDIS_STATUS_FAILURE;
        status = Prot_request(ctxtp, &act, FALSE);
        
        if (status != NDIS_STATUS_SUCCESS)
        {
            UNIV_PRINT_CRIT(("Prot_bind: Error %x requesting media connection status %d %d", status, xferred, needed));
            TRACE_CRIT("%!FUNC! Error 0x%x requesting media connection status %d %d", status, xferred, needed);
            ctxtp->media_connected = TRUE;
        }
        else
        {
            UNIV_PRINT_INFO(("Prot_bind: Media state - %s", result == NdisMediaStateConnected ? "CONNECTED" : "DISCONNECTED"));
            TRACE_INFO("%!FUNC! Media state - %s", result == NdisMediaStateConnected ? "CONNECTED" : "DISCONNECTED");
            ctxtp->media_connected = (result == NdisMediaStateConnected);
        }
    }

    NdisAcquireSpinLock(& univ_bind_lock);
    UNIV_ASSERT (adapterp -> code == MAIN_ADAPTER_CODE);
    adapterp -> announced = TRUE;
    NdisReleaseSpinLock(& univ_bind_lock);

    /* Set the first heartbeat timeout. */
    NdisMSetTimer((PNDIS_MINIPORT_TIMER)ctxtp->timer, ctxtp->curr_tout);

    UNIV_PRINT_INFO(("Nic_init: return=NDIS_STATUS_SUCCESS"));
    TRACE_INFO("<-%!FUNC! return=NDIS_STATUS_SUCCESS");
    return NDIS_STATUS_SUCCESS;

} /* end Nic_init */


VOID Nic_halt ( /* PASSIVE_IRQL */
    NDIS_HANDLE         adapter_handle)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;
    BOOLEAN             done;
    NDIS_STATUS         status;
    PMAIN_ADAPTER       adapterp;

    UNIV_PRINT_INFO(("Nic_halt: Halting, adapter_id=0x%x", ctxtp -> adapter_id));
    TRACE_INFO("->%!FUNC! Halting, adapter_id=0x%x", ctxtp -> adapter_id);

    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    adapterp = & (univ_adapters [ctxtp -> adapter_id]);
    UNIV_ASSERT (adapterp -> code == MAIN_ADAPTER_CODE);
    UNIV_ASSERT (adapterp -> ctxtp == ctxtp);

    NdisAcquireSpinLock(& univ_bind_lock);

    if (! adapterp -> announced)
    {
        NdisReleaseSpinLock(& univ_bind_lock);
        UNIV_PRINT_CRIT(("Nic_halt: Adapter not announced, adapter id = 0x%x", ctxtp -> adapter_id));
        UNIV_PRINT_INFO(("Nic_halt: return"));
        TRACE_CRIT("%!FUNC! Adapter not announced, adapter id = 0x%x", ctxtp -> adapter_id);
        TRACE_INFO("<-%!FUNC! return");
        return;
    }

    adapterp -> announced = FALSE;
    NdisReleaseSpinLock(& univ_bind_lock);

    /* Cancel the heartbeat timer. */
    NdisMCancelTimer((PNDIS_MINIPORT_TIMER)ctxtp->timer, &done);

    /* If canceling the timer fails, this means that the timer was not in the timer queue.  
       This indicates that either the timer function is currently running, or was about to
       be run when we canceled it.  However, we can't be SURE whether or not the timer 
       routine will run, so we can't count on it - the DPC may or may not have been canceled
       if NdisMCancelTimer returns false.  Since we have set adapterp->announced to FALSE, 
       this will prevent the timer routine from re-setting the timer before it exits.
       To make sure that we don't free any memory that may be used by the timer routine,
       we'll just wait here for at least one heartbeat period before we delete the timer
       memory and move on to delete the adapter context, just in case. */
    if (!done) Nic_sleep(ctxtp->curr_tout);

    /* Free the timer memory. */
    NdisFreeMemory(ctxtp->timer, sizeof(NDIS_MINIPORT_TIMER), 0);

    /* ctxtp->prot_handle = NULL;

       This is commented out to resolve a timing issue.
       During unbind, a packet could go through but the flags
       announced and bound are reset and prot_handle is set to NULL
       So, this should be set after CloseAdapter. */

    status = Prot_close (adapterp);

    if (status != NDIS_STATUS_SUCCESS)
    {
        /* Don't do an early exit. This check was added for tracing only */
        TRACE_CRIT("%!FUNC! Prot_close failed with 0x%x", status);
    }

    /* ctxtp might be gone at this point! */

    UNIV_PRINT_INFO(("Nic_halt: return"));
    TRACE_INFO("<-%!FUNC! return");

} /* end Nic_halt */


//#define TRACE_OID
NDIS_STATUS Nic_info_query (
    NDIS_HANDLE         adapter_handle,
    NDIS_OID            oid,
    PVOID               info_buf,
    ULONG               info_len,
    PULONG              written,
    PULONG              needed)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;
    NDIS_STATUS         status;
    PMAIN_ACTION        actp;
    PNDIS_REQUEST       request;
    ULONG               size;
    PMAIN_ADAPTER       adapterp;

    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

#if defined(TRACE_OID)
    DbgPrint("Nic_info_query: called for %x, %x %d\n", oid, info_buf, info_len);
#endif

    adapterp = & (univ_adapters [ctxtp -> adapter_id]);
    UNIV_ASSERT (adapterp -> code == MAIN_ADAPTER_CODE);
    UNIV_ASSERT (adapterp -> ctxtp == ctxtp);

    // reference counting in unbinding

    if (! adapterp -> inited)
    {
        TRACE_CRIT("%!FUNC! adapter not initialized, adapter_id = 0x%x", ctxtp -> adapter_id);
        TRACE_VERB("<-%!FUNC! return=NDIS_STATUS_FAILURE");
        return NDIS_STATUS_FAILURE;
    }

    if (oid == OID_PNP_QUERY_POWER)
    {
#if defined(TRACE_OID)
        DbgPrint("Nic_info_query: OID_PNP_QUERY_POWER\n");
#endif
        TRACE_VERB("<-%!FUNC! return=NDIS_STATUS_SUCCESS for oid=OID_PNP_QUERY_POWER");
        return NDIS_STATUS_SUCCESS;
    }

    if (ctxtp -> reset_state != MAIN_RESET_NONE ||
        ctxtp->nic_pnp_state > NdisDeviceStateD0 ||
        ctxtp->standby_state)
    {
        TRACE_CRIT("%!FUNC! adapter reset or in standby, adapter id = 0x%x", ctxtp -> adapter_id);
        TRACE_VERB("<-%!FUNC! return=NDIS_STATUS_FAILURE");
        return NDIS_STATUS_FAILURE;
    }

    switch (oid)
    {
        case OID_GEN_SUPPORTED_LIST:

#if defined(TRACE_OID)
            DbgPrint("Nic_info_query: OID_GEN_SUPPORTED_LIST\n");
#endif
            TRACE_VERB("%!FUNC! case: OID_GEN_SUPPORTED_LIST");
            break;
#if 0
            size = sizeof(univ_oids);

            if (size > info_len)
            {
                * needed = size;
                return NDIS_STATUS_INVALID_LENGTH;
            }

            NdisMoveMemory (info_buf, univ_oids, size);
            * written = size;
            return NDIS_STATUS_SUCCESS;
#endif

        case OID_GEN_XMIT_OK:

            if (info_len < sizeof (ULONG))
            {
                * needed = sizeof (ULONG);
                TRACE_CRIT("%!FUNC! case: OID_GEN_XMIT_OK adapter id = 0x%x,  info_buf too small", ctxtp -> adapter_id);
                TRACE_VERB("<-%!FUNC! return=NDIS_STATUS_INVALID_LENGTH");
                return NDIS_STATUS_INVALID_LENGTH;
            }

            * ((PULONG) info_buf) = ctxtp -> cntr_xmit_ok;
            * written = sizeof (ULONG);

#if defined(TRACE_OID)
            DbgPrint("Nic_info_query: OID_GEN_XMIT_OK %d\n", *(PULONG) info_buf);
#endif
            return NDIS_STATUS_SUCCESS;

        case OID_GEN_RCV_OK:

            if (info_len < sizeof (ULONG))
            {
                * needed = sizeof (ULONG);
                TRACE_CRIT("%!FUNC! case: OID_GEN_RCV_OK adapter id = 0x%x,  info_buf too small", ctxtp -> adapter_id);
                TRACE_VERB("<-%!FUNC! return=NDIS_STATUS_INVALID_LENGTH");
                return NDIS_STATUS_INVALID_LENGTH;
            }

            * ((PULONG) info_buf) = ctxtp -> cntr_recv_ok;
            * written = sizeof (ULONG);

#if defined(TRACE_OID)
            DbgPrint("Nic_info_query: OID_GEN_RCV_OK %d\n", *(PULONG) info_buf);
#endif
            return NDIS_STATUS_SUCCESS;

        case OID_GEN_XMIT_ERROR:

            if (info_len < sizeof (ULONG))
            {
                * needed = sizeof (ULONG);
                TRACE_CRIT("%!FUNC! case: OID_GEN_XMIT_ERROR adapter id = 0x%x,  info_buf too small", ctxtp -> adapter_id);
                TRACE_VERB("<-%!FUNC! return=NDIS_STATUS_INVALID_LENGTH");
                return NDIS_STATUS_INVALID_LENGTH;
            }

            * ((PULONG) info_buf) = ctxtp -> cntr_xmit_err;
            * written = sizeof (ULONG);

#if defined(TRACE_OID)
            DbgPrint("Nic_info_query: OID_GEN_XMIT_ERROR %d\n", *(PULONG) info_buf);
#endif
            return NDIS_STATUS_SUCCESS;

        case OID_GEN_RCV_ERROR:

            if (info_len < sizeof (ULONG))
            {
                * needed = sizeof (ULONG);
                TRACE_CRIT("%!FUNC! case: OID_GEN_RCV_ERROR adapter id = 0x%x,  info_buf too small", ctxtp -> adapter_id);
                TRACE_VERB("<-%!FUNC! return=NDIS_STATUS_INVALID_LENGTH");
                return NDIS_STATUS_INVALID_LENGTH;
            }

            * ((PULONG) info_buf) = ctxtp -> cntr_recv_err;
            * written = sizeof (ULONG);

#if defined(TRACE_OID)
            DbgPrint("Nic_info_query: OID_GEN_RCV_ERROR %d\n", *(PULONG) info_buf);
#endif
            return NDIS_STATUS_SUCCESS;

        case OID_GEN_RCV_NO_BUFFER:

            if (info_len < sizeof (ULONG))
            {
                * needed = sizeof (ULONG);
                TRACE_CRIT("%!FUNC! case: OID_GEN_RCV_NO_BUFFER adapter id = 0x%x,  info_buf too small", ctxtp -> adapter_id);
                TRACE_VERB("<-%!FUNC! return=NDIS_STATUS_INVALID_LENGTH");
                return NDIS_STATUS_INVALID_LENGTH;
            }

            * ((PULONG) info_buf) = ctxtp -> cntr_recv_no_buf;
            * written = sizeof (ULONG);

#if defined(TRACE_OID)
            DbgPrint("Nic_info_query: OID_GEN_RCV_NO_BUFFER %d\n", *(PULONG) info_buf);
#endif
            return NDIS_STATUS_SUCCESS;

        case OID_GEN_DIRECTED_BYTES_XMIT:

            if (info_len < sizeof (ULONGLONG))
            {
                * needed = sizeof (ULONGLONG);
                TRACE_CRIT("%!FUNC! case: OID_GEN_DIRECTED_BYTES_XMIT adapter id = 0x%x,  info_buf too small", ctxtp -> adapter_id);
                TRACE_VERB("<-%!FUNC! return=NDIS_STATUS_INVALID_LENGTH");
                return NDIS_STATUS_INVALID_LENGTH;
            }

            * ((PULONGLONG) info_buf) = ctxtp -> cntr_xmit_bytes_dir;
            * written = sizeof (ULONGLONG);

#if defined(TRACE_OID)
            DbgPrint("Nic_info_query: OID_GEN_DIRECTED_BYTES_XMIT %.0f\n", *(PULONGLONG) info_buf);
#endif
            return NDIS_STATUS_SUCCESS;

        case OID_GEN_DIRECTED_FRAMES_XMIT:

            if (info_len < sizeof (ULONG))
            {
                * needed = sizeof (ULONG);
                TRACE_CRIT("%!FUNC! case: OID_GEN_DIRECTED_FRAMES_XMIT adapter id = 0x%x,  info_buf too small", ctxtp -> adapter_id);
                TRACE_VERB("<-%!FUNC! return=NDIS_STATUS_INVALID_LENGTH");
                return NDIS_STATUS_INVALID_LENGTH;
            }

            * ((PULONG) info_buf) = ctxtp -> cntr_xmit_frames_dir;
            * written = sizeof (ULONG);

#if defined(TRACE_OID)
            DbgPrint("Nic_info_query: OID_GEN_DIRECTED_FRAMES_XMIT %d\n", *(PULONG) info_buf);
#endif
            return NDIS_STATUS_SUCCESS;

        case OID_GEN_MULTICAST_BYTES_XMIT:

            if (info_len < sizeof (ULONGLONG))
            {
                * needed = sizeof (ULONGLONG);
                TRACE_CRIT("%!FUNC! case: OID_GEN_MULTICAST_BYTES_XMIT adapter id = 0x%x,  info_buf too small", ctxtp -> adapter_id);
                TRACE_VERB("<-%!FUNC! return=NDIS_STATUS_INVALID_LENGTH");
                return NDIS_STATUS_INVALID_LENGTH;
            }

            * ((PULONGLONG) info_buf) = ctxtp -> cntr_xmit_bytes_mcast;
            * written = sizeof (ULONGLONG);

#if defined(TRACE_OID)
            DbgPrint("Nic_info_query: OID_GEN_MULTICAST_BYTES_XMIT %.0f\n", *(PULONGLONG) info_buf);
#endif
            return NDIS_STATUS_SUCCESS;

        case OID_GEN_MULTICAST_FRAMES_XMIT:

            if (info_len < sizeof (ULONG))
            {
                * needed = sizeof (ULONG);
                TRACE_CRIT("%!FUNC! case: OID_GEN_MULTICAST_FRAMES_XMIT adapter id = 0x%x,  info_buf too small", ctxtp -> adapter_id);
                TRACE_VERB("<-%!FUNC! return=NDIS_STATUS_INVALID_LENGTH");
                return NDIS_STATUS_INVALID_LENGTH;
            }

            * ((PULONG) info_buf) = ctxtp -> cntr_xmit_frames_mcast;
            * written = sizeof (ULONG);

#if defined(TRACE_OID)
            DbgPrint("Nic_info_query: OID_GEN_MULTICAST_FRAMES_XMIT %d\n", *(PULONG) info_buf);
#endif
            return NDIS_STATUS_SUCCESS;

        case OID_GEN_BROADCAST_BYTES_XMIT:

            if (info_len < sizeof (ULONGLONG))
            {
                * needed = sizeof (ULONGLONG);
                TRACE_CRIT("%!FUNC! case: OID_GEN_BROADCAST_BYTES_XMIT adapter id = 0x%x,  info_buf too small", ctxtp -> adapter_id);
                TRACE_VERB("<-%!FUNC! return=NDIS_STATUS_INVALID_LENGTH");
                return NDIS_STATUS_INVALID_LENGTH;
            }

            * ((PULONGLONG) info_buf) = ctxtp -> cntr_xmit_bytes_bcast;
            * written = sizeof (ULONGLONG);

#if defined(TRACE_OID)
            DbgPrint("Nic_info_query: OID_GEN_BROADCAST_BYTES_XMIT %.0f\n", *(PULONGLONG) info_buf);
#endif
            return NDIS_STATUS_SUCCESS;

        case OID_GEN_BROADCAST_FRAMES_XMIT:

            if (info_len < sizeof (ULONG))
            {
                * needed = sizeof (ULONG);
                TRACE_CRIT("%!FUNC! case: OID_GEN_BROADCAST_FRAMES_XMIT adapter id = 0x%x,  info_buf too small", ctxtp -> adapter_id);
                TRACE_VERB("<-%!FUNC! return=NDIS_STATUS_INVALID_LENGTH");
                return NDIS_STATUS_INVALID_LENGTH;
            }

            * ((PULONG) info_buf) = ctxtp -> cntr_xmit_frames_bcast;
            * written = sizeof (ULONG);

#if defined(TRACE_OID)
            DbgPrint("Nic_info_query: OID_GEN_BROADCAST_FRAMES_XMIT %d\n", *(PULONG) info_buf);
#endif
            return NDIS_STATUS_SUCCESS;

        case OID_GEN_DIRECTED_BYTES_RCV:

            if (info_len < sizeof (ULONGLONG))
            {
                * needed = sizeof (ULONGLONG);
                TRACE_CRIT("%!FUNC! case: OID_GEN_DIRECTED_BYTES_RCV adapter id = 0x%x,  info_buf too small", ctxtp -> adapter_id);
                TRACE_VERB("<-%!FUNC! return=NDIS_STATUS_INVALID_LENGTH");
                return NDIS_STATUS_INVALID_LENGTH;
            }

            * ((PULONGLONG) info_buf) = ctxtp -> cntr_recv_bytes_dir;
            * written = sizeof (ULONGLONG);

#if defined(TRACE_OID)
            DbgPrint("Nic_info_query: OID_GEN_DIRECTED_BYTES_RCV %.0f\n", *(PULONGLONG) info_buf);
#endif
            return NDIS_STATUS_SUCCESS;

        case OID_GEN_DIRECTED_FRAMES_RCV:

            if (info_len < sizeof (ULONG))
            {
                * needed = sizeof (ULONG);
                TRACE_CRIT("%!FUNC! case: OID_GEN_DIRECTED_FRAMES_RCV adapter id = 0x%x,  info_buf too small", ctxtp -> adapter_id);
                TRACE_VERB("<-%!FUNC! return=NDIS_STATUS_INVALID_LENGTH");
                return NDIS_STATUS_INVALID_LENGTH;
            }

            * ((PULONG) info_buf) = ctxtp -> cntr_recv_frames_dir;
            * written = sizeof (ULONG);

#if defined(TRACE_OID)
            DbgPrint("Nic_info_query: OID_GEN_DIRECTED_FRAMES_RCV %d\n", *(PULONG) info_buf);
#endif
            return NDIS_STATUS_SUCCESS;

        case OID_GEN_MULTICAST_BYTES_RCV:

            if (info_len < sizeof (ULONGLONG))
            {
                * needed = sizeof (ULONGLONG);
                TRACE_CRIT("%!FUNC! case: OID_GEN_MULTICAST_BYTES_RCV adapter id = 0x%x,  info_buf too small", ctxtp -> adapter_id);
                TRACE_VERB("<-%!FUNC! return=NDIS_STATUS_INVALID_LENGTH");
                return NDIS_STATUS_INVALID_LENGTH;
            }

            * ((PULONGLONG) info_buf) = ctxtp -> cntr_recv_bytes_mcast;
            * written = sizeof (ULONGLONG);

#if defined(TRACE_OID)
            DbgPrint("Nic_info_query: OID_GEN_MULTICAST_BYTES_RCV %.0f\n", *(PULONGLONG) info_buf);
#endif
            return NDIS_STATUS_SUCCESS;

        case OID_GEN_MULTICAST_FRAMES_RCV:

            if (info_len < sizeof (ULONG))
            {
                * needed = sizeof (ULONG);
                TRACE_CRIT("%!FUNC! case: OID_GEN_MULTICAST_FRAMES_RCV adapter id = 0x%x,  info_buf too small", ctxtp -> adapter_id);
                TRACE_VERB("<-%!FUNC! return=NDIS_STATUS_INVALID_LENGTH");
                return NDIS_STATUS_INVALID_LENGTH;
            }

            * ((PULONG) info_buf) = ctxtp -> cntr_recv_frames_mcast;
            * written = sizeof (ULONG);

#if defined(TRACE_OID)
            DbgPrint("Nic_info_query: OID_GEN_MULTICAST_FRAMES_RCV %d\n", *(PULONG) info_buf);
#endif
            return NDIS_STATUS_SUCCESS;

        case OID_GEN_BROADCAST_BYTES_RCV:

            if (info_len < sizeof (ULONGLONG))
            {
                * needed = sizeof (ULONGLONG);
                TRACE_CRIT("%!FUNC! case: OID_GEN_BROADCAST_BYTES_RCV adapter id = 0x%x,  info_buf too small", ctxtp -> adapter_id);
                TRACE_VERB("<-%!FUNC! return=NDIS_STATUS_INVALID_LENGTH");
                return NDIS_STATUS_INVALID_LENGTH;
            }

            * ((PULONGLONG) info_buf) = ctxtp -> cntr_recv_bytes_bcast;
            * written = sizeof (ULONGLONG);

#if defined(TRACE_OID)
            DbgPrint("Nic_info_query: OID_GEN_DIRECTED_BROADCAST_RCV %.0f\n", *(PULONGLONG) info_buf);
#endif
            return NDIS_STATUS_SUCCESS;

        case OID_GEN_BROADCAST_FRAMES_RCV:

            if (info_len < sizeof (ULONG))
            {
                * needed = sizeof (ULONG);
                TRACE_CRIT("%!FUNC! case: OID_GEN_BROADCAST_FRAMES_RCV adapter id = 0x%x,  info_buf too small", ctxtp -> adapter_id);
                TRACE_VERB("<-%!FUNC! return=NDIS_STATUS_INVALID_LENGTH");
                return NDIS_STATUS_INVALID_LENGTH;
            }

            * ((PULONG) info_buf) = ctxtp -> cntr_recv_frames_bcast;
            * written = sizeof (ULONG);

#if defined(TRACE_OID)
            DbgPrint("Nic_info_query: OID_GEN_BROADCAST_FRAMES_RCV %d\n", *(PULONG) info_buf);
#endif
            return NDIS_STATUS_SUCCESS;

        case OID_GEN_RCV_CRC_ERROR:

            if (info_len < sizeof (ULONG))
            {
                * needed = sizeof (ULONG);
                TRACE_CRIT("%!FUNC! case: OID_GEN_RCV_CRC_ERROR adapter id = 0x%x,  info_buf too small", ctxtp -> adapter_id);
                TRACE_VERB("<-%!FUNC! return=NDIS_STATUS_INVALID_LENGTH");
                return NDIS_STATUS_INVALID_LENGTH;
            }

            * ((PULONG) info_buf) = ctxtp -> cntr_recv_crc_err;
            * written = sizeof (ULONG);

#if defined(TRACE_OID)
            DbgPrint("Nic_info_query: OID_GEN_RCV_CRC_ERROR %d\n", *(PULONG) info_buf);
#endif
            return NDIS_STATUS_SUCCESS;

        case OID_GEN_TRANSMIT_QUEUE_LENGTH:

            if (info_len < sizeof (ULONG))
            {
                * needed = sizeof (ULONG);
                TRACE_CRIT("%!FUNC! case: OID_GEN_TRANSMIT_QUEUE_LENGTH adapter id = 0x%x,  info_buf too small", ctxtp -> adapter_id);
                TRACE_VERB("<-%!FUNC! return=NDIS_STATUS_INVALID_LENGTH");
                return NDIS_STATUS_INVALID_LENGTH;
            }

            * ((PULONG) info_buf) = ctxtp -> cntr_xmit_queue_len;
            * written = sizeof (ULONG);

#if defined(TRACE_OID)
            DbgPrint("Nic_info_query: OID_GEN_TRANSMIT_QUEUE_LENGTH %d\n", *(PULONG) info_buf);
#endif
            return NDIS_STATUS_SUCCESS;

        default:
            break;
    }

    actp = Main_action_get (ctxtp);

    if (actp == NULL)
    {
        UNIV_PRINT_CRIT(("Nic_info_query: Error allocating action"));
        TRACE_CRIT("%!FUNC! Error allocating action");
        TRACE_VERB("<-%!FUNC! return=NDIS_STATUS_FAILURE");
        return NDIS_STATUS_FAILURE;
    }

    request = & actp -> op . request . req;

    request -> RequestType = NdisRequestQueryInformation;

    request -> DATA . QUERY_INFORMATION . Oid                     = oid;
    request -> DATA . QUERY_INFORMATION . InformationBuffer       = info_buf;
    request -> DATA . QUERY_INFORMATION . InformationBufferLength = info_len;

    actp -> op . request . xferred = written;
    actp -> op . request . needed  = needed;

    /* pass request down */

    status = Prot_request (ctxtp, actp, TRUE);

    if (status != NDIS_STATUS_PENDING)
    {
        * written = request -> DATA . QUERY_INFORMATION . BytesWritten;
        * needed  = request -> DATA . QUERY_INFORMATION . BytesNeeded;

#if defined(TRACE_OID)
        DbgPrint("Nic_info_query: done %x, %d %d, %x\n", status, * written, * needed, * ((PULONG) (request -> DATA . QUERY_INFORMATION . InformationBuffer)));
#endif

        /* override return values of some oids */

        if (oid == OID_GEN_MAXIMUM_SEND_PACKETS && info_len >= sizeof (ULONG))
        {
            * ((PULONG) info_buf) = CVY_MAX_SEND_PACKETS;
            * written = sizeof (ULONG);
            status = NDIS_STATUS_SUCCESS;
        }
        else if (oid == OID_802_3_CURRENT_ADDRESS && status == NDIS_STATUS_SUCCESS)
        {
            if (info_len >= sizeof(CVY_MAC_ADR)) {
                if (!ctxtp->params.mcast_support && ctxtp->cl_ip_addr != 0)
                    NdisMoveMemory(info_buf, &ctxtp->cl_mac_addr, sizeof(CVY_MAC_ADR));
                else
                    NdisMoveMemory(info_buf, &ctxtp->ded_mac_addr, sizeof(CVY_MAC_ADR));
                
                *written = sizeof(CVY_MAC_ADR);
            } else {
                UNIV_PRINT_CRIT(("Nic_info_query: MAC address buffer too small (%u) - not spoofing", info_len));
            }
        }
        else if (oid == OID_GEN_MAC_OPTIONS && status == NDIS_STATUS_SUCCESS)
        {
            * ((PULONG) info_buf) |= NDIS_MAC_OPTION_TRANSFERS_NOT_PEND |
                                     NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA;
            * ((PULONG) info_buf) &= ~NDIS_MAC_OPTION_NO_LOOPBACK;
        }
        else if (oid == OID_PNP_CAPABILITIES && status == NDIS_STATUS_SUCCESS)
        {
            PNDIS_PNP_CAPABILITIES          pnp_capabilities;
            PNDIS_PM_WAKE_UP_CAPABILITIES   pm_struct;

            if (info_len >= sizeof (NDIS_PNP_CAPABILITIES))
            {
                pnp_capabilities = (PNDIS_PNP_CAPABILITIES) info_buf;
                pm_struct = & pnp_capabilities -> WakeUpCapabilities;

                pm_struct -> MinMagicPacketWakeUp = NdisDeviceStateUnspecified;
                pm_struct -> MinPatternWakeUp     = NdisDeviceStateUnspecified;
                pm_struct -> MinLinkChangeWakeUp  = NdisDeviceStateUnspecified;

                ctxtp -> prot_pnp_state = NdisDeviceStateD0;
                ctxtp -> nic_pnp_state  = NdisDeviceStateD0;

                * written = sizeof (NDIS_PNP_CAPABILITIES);
                * needed = 0;
                status = NDIS_STATUS_SUCCESS;
            }
            else
            {
                * needed = sizeof (NDIS_PNP_CAPABILITIES);
                status = NDIS_STATUS_RESOURCES;
            }
        }

        Main_action_put (ctxtp, actp);
    }

    return status;

} /* end Nic_info_query */


NDIS_STATUS Nic_info_set (
    NDIS_HANDLE         adapter_handle,
    NDIS_OID            oid,
    PVOID               info_buf,
    ULONG               info_len,
    PULONG              read,
    PULONG              needed)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;
    NDIS_STATUS         status;
    PMAIN_ACTION        actp;
    PNDIS_REQUEST       request;
    PMAIN_ADAPTER       adapterp;


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    adapterp = & (univ_adapters [ctxtp -> adapter_id]);
    UNIV_ASSERT (adapterp -> code == MAIN_ADAPTER_CODE);
    UNIV_ASSERT (adapterp -> ctxtp == ctxtp);

#if defined(TRACE_OID)
    DbgPrint("Nic_info_set: called for %x, %x %d\n", oid, info_buf, info_len);
#endif

    if (! adapterp -> inited)
    {
        TRACE_CRIT("%!FUNC! adapter not initialized, adapter id = 0x%x", ctxtp -> adapter_id);
        TRACE_INFO("<-%!FUNC! return=NDIS_STATUS_FAILURE");
        return NDIS_STATUS_FAILURE;
    }

    /* the Set Power should not be sent to the miniport below the Passthru,
       but is handled internally */

    if (oid == OID_PNP_SET_POWER)
    {
        NDIS_DEVICE_POWER_STATE new_pnp_state;

#if defined(TRACE_OID)
        DbgPrint("Nic_info_set: OID_PNP_SET_POWER\n");
#endif
        TRACE_VERB("%!FUNC! OID_PNP_SET_POWER");

        if (info_len >= sizeof (NDIS_DEVICE_POWER_STATE))
        {
            new_pnp_state = (* (PNDIS_DEVICE_POWER_STATE) info_buf);

            /* If WLBS is transitioning from an Off to On state, it must wait
               for all underlying miniports to be turned On */

            if (ctxtp->nic_pnp_state > NdisDeviceStateD0 &&
                new_pnp_state != NdisDeviceStateD0)
            {
                // If the miniport is in a non-D0 state, the miniport can only
                // receive a Set Power to D0

                TRACE_CRIT("%!FUNC! miniport is in a non-D0 state");
                TRACE_INFO("<-%!FUNC! return=NDIS_STATUS_FAILURE");
                return NDIS_STATUS_FAILURE;
            }
            
            //
            // Is the miniport transitioning from an On (D0) state to an Low Power State (>D0)
            // If so, then set the standby_state Flag - (Block all incoming requests)
            //
            if (ctxtp->nic_pnp_state == NdisDeviceStateD0 &&
                new_pnp_state > NdisDeviceStateD0)
            {
                ctxtp->standby_state = TRUE;
            }
            
            
            // Note: lock these *_pnp_state variables
            
            //
            // If the miniport is transitioning from a low power state to ON (D0), then clear the standby_state flag
            // All incoming requests will be pended until the physical miniport turns ON.
            //
            if (ctxtp->nic_pnp_state > NdisDeviceStateD0 &&
                new_pnp_state == NdisDeviceStateD0)
            {
                ctxtp->standby_state = FALSE;
            }
            
            ctxtp->nic_pnp_state = new_pnp_state;

            // Note: We should be waiting here, as we do in prot_pnp_handle
            // Note: Also wait for indicated packets to "return"

            * read   = sizeof (NDIS_DEVICE_POWER_STATE);
            * needed = 0;

            TRACE_INFO("<-%!FUNC! return=NDIS_STATUS_SUCCESS");
            return NDIS_STATUS_SUCCESS;
        }
        else
        {
            * read   = 0;
            * needed = sizeof (NDIS_DEVICE_POWER_STATE);

            TRACE_CRIT("%!FUNC! info_buf too small");
            TRACE_INFO("<-%!FUNC! return=NDIS_STATUS_INVALID_LENGTH");
            return NDIS_STATUS_INVALID_LENGTH;
        }
    }

    if (ctxtp -> reset_state != MAIN_RESET_NONE ||
        ctxtp->nic_pnp_state > NdisDeviceStateD0 ||
        ctxtp->standby_state)
    {
        TRACE_CRIT("%!FUNC! adapter reset or in standby, adapter id = 0x%x", ctxtp -> adapter_id);
        TRACE_INFO("<-%!FUNC! return=NDIS_STATUS_FAILURE");
        return NDIS_STATUS_FAILURE;
    }

    actp = Main_action_get (ctxtp);

    if (actp == NULL)
    {
        UNIV_PRINT_CRIT(("Nic_info_set: Error allocating action"));
        TRACE_CRIT("%!FUNC! Error allocating action");
        TRACE_INFO("<-%!FUNC! return=NDIS_STATUS_FAILURE");
        return NDIS_STATUS_FAILURE;
    }

    request = & actp -> op . request . req;

    request -> RequestType = NdisRequestSetInformation;

    request -> DATA . SET_INFORMATION . Oid = oid;

    /* V1.3.0b Multicast support.  If protocol is setting multicast list, make sure we always 
       add our multicast address on at the end.  If the cluster IP address 0.0.0.0, then we don't
       want to add the multicast MAC address to the NIC  - we retain the current MAC address. */
    if (oid == OID_802_3_MULTICAST_LIST && ctxtp -> params . mcast_support && ctxtp -> params . cl_ip_addr != 0)
    {
        ULONG       size, i, len;
        PUCHAR      ptr;

        UNIV_PRINT_VERB(("Nic_info_set: OID_802_3_MULTICAST_LIST"));

        /* search and see if our multicast address is alrady in the list */

        len = CVY_MAC_ADDR_LEN (ctxtp -> medium);

        for (i = 0; i < info_len; i += len)
        {
            if (CVY_MAC_ADDR_COMP (ctxtp -> medium, (PUCHAR) info_buf + i, & ctxtp -> cl_mac_addr))
            {
                UNIV_PRINT_VERB(("Nic_info_set: Cluster MAC matched - no need to add it"));
                CVY_MAC_ADDR_PRINT (ctxtp -> medium, "", & ctxtp -> cl_mac_addr);
                break;
            }
            else
                CVY_MAC_ADDR_PRINT (ctxtp -> medium, "", (PUCHAR) info_buf + i);

        }

        /* if cluster mac not found, add it to the list */

        if (i >= info_len)
        {
            UNIV_PRINT_VERB(("Nic_info_set: Cluster MAC not found - adding it"));
            CVY_MAC_ADDR_PRINT (ctxtp -> medium, "", & ctxtp -> cl_mac_addr);

            size = info_len + len;

            status = NdisAllocateMemoryWithTag (& ptr, size, UNIV_POOL_TAG);
            
            if (status != NDIS_STATUS_SUCCESS)
            {
                UNIV_PRINT_CRIT(("Nic_info_set: Error allocating space %d %x", size, status));
                LOG_MSG2 (MSG_ERROR_MEMORY, MSG_NONE, size, status);
                Main_action_put (ctxtp, actp);
                TRACE_CRIT("%!FUNC! Error allocating size=%d, status=0x%x", size, status);
                TRACE_INFO("<-%!FUNC! return=NDIS_STATUS_FAILURE");
                return NDIS_STATUS_FAILURE;
            }
            
            /* If we have allocated a new buffer to hold the multicast MAC list, 
               note that we need to free it later when the request completes. 
               Main_action_get initializes the buffer to NULL, so a buffer will
               only be freed if we explicitly store its address here. */
            actp->op.request.buffer = ptr;
            actp->op.request.buffer_len = size;
            
            CVY_MAC_ADDR_COPY (ctxtp -> medium, ptr, & ctxtp -> cl_mac_addr);
            NdisMoveMemory (ptr + len, info_buf, info_len);
            
            request -> DATA . SET_INFORMATION . InformationBuffer       = ptr;
            request -> DATA . SET_INFORMATION . InformationBufferLength = size;
        }
        else
        {
            request -> DATA . SET_INFORMATION . InformationBuffer       = info_buf;
            request -> DATA . SET_INFORMATION . InformationBufferLength = info_len;
        }
    }
    else
    {
        request -> DATA . SET_INFORMATION . InformationBuffer       = info_buf;
        request -> DATA . SET_INFORMATION . InformationBufferLength = info_len;
    }

    actp -> op . request . xferred = read;
    actp -> op . request . needed  = needed;

    status = Prot_request (ctxtp, actp, TRUE);

    if (status != NDIS_STATUS_PENDING)
    {
        /* V1.3.0b multicast support - clean up array used for storing list
           of multicast addresses */

        * read   = request -> DATA . SET_INFORMATION . BytesRead;
        * needed = request -> DATA . SET_INFORMATION . BytesNeeded;

        if (request -> DATA . SET_INFORMATION . Oid == OID_802_3_MULTICAST_LIST)
        {
            /* If the request buffer is non-NULL, then we were forced to allocate a new buffer
               large enough to hold the entire multicast MAC address list, plus our multicast
               MAC address, which was missing from the list sent down by the protocol.  To mask
               this from the protocol, free the buffer and decrease the number of bytes read 
               by the miniport by the length of a MAC address before returning the request to
               the protocol. */
            if (actp->op.request.buffer != NULL) {
                NdisFreeMemory(actp->op.request.buffer, actp->op.request.buffer_len, 0);

                * read -= CVY_MAC_ADDR_LEN (ctxtp -> medium);
            }
        }
#if defined (NLB_TCP_NOTIFICATION) 
        else if (request->DATA.SET_INFORMATION.Oid == OID_GEN_NETWORK_LAYER_ADDRESSES)
        {
            /* Schedule an NDIS work item to get the interface index of this NLB 
               instance from TCP/IP by querying the IP address table. */
            (VOID)Main_schedule_work_item(ctxtp, Main_set_interface_index);

            /* Overwrite the status from the request.  We will ALWAYS succeed this OID, 
               lest the protocol decide to stop sending it down to us.  See the DDK. */
            status = NDIS_STATUS_SUCCESS;
        }
#endif

#if defined(TRACE_OID)
        DbgPrint("Nic_info_set: done %x, %d %d\n", status, * read, * needed);
#endif

        Main_action_put (ctxtp, actp);
    }

    TRACE_INFO("<-%!FUNC! return=0x%x", status);
    return status;

} /* end Nic_info_set */


NDIS_STATUS Nic_reset (
    PBOOLEAN            addr_reset,
    NDIS_HANDLE         adapter_handle)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;
    NDIS_STATUS         status;
    PMAIN_ADAPTER       adapterp;


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    adapterp = & (univ_adapters [ctxtp -> adapter_id]);
    UNIV_ASSERT (adapterp -> code == MAIN_ADAPTER_CODE);

    if (! adapterp -> inited)
    {
        TRACE_CRIT("%!FUNC! adapter not initialized");
        TRACE_INFO("<-%!FUNC! return=NDIS_STATUS_FAILURE");
        return NDIS_STATUS_FAILURE;
    }

    UNIV_PRINT_VERB(("Nic_reset: Called"));

    /* since no information needs to be passed to Prot_reset,
       action is not allocated. Prot_reset_complete will get
       one and pass it to Nic_reset_complete */

    status = Prot_reset (ctxtp);

    if (status != NDIS_STATUS_SUCCESS && status != NDIS_STATUS_PENDING)
    {
        UNIV_PRINT_CRIT(("Nic_reset: Error resetting adapter, status=0x%x", status));
        TRACE_CRIT("%!FUNC! Error resetting adapter, status=0x%x", status);
    }

    TRACE_INFO("<-%!FUNC! return=0x%x", status);
    return status;

} /* end Nic_reset */


VOID Nic_cancel_send_packets (
    NDIS_HANDLE         adapter_handle,
    PVOID               cancel_id)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;
    PMAIN_ADAPTER       adapterp;


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    adapterp = & (univ_adapters [ctxtp -> adapter_id]);
    UNIV_ASSERT (adapterp -> code == MAIN_ADAPTER_CODE);

    /* Since no internal queues are maintained,
     * can simply pass the cancel call to the miniport
     */
    Prot_cancel_send_packets (ctxtp, cancel_id);

    TRACE_INFO("<-%!FUNC! return");
    return;
} /* Nic_cancel_send_packets */


VOID Nic_pnpevent_notify (
    NDIS_HANDLE              adapter_handle,
    NDIS_DEVICE_PNP_EVENT    pnp_event,
    PVOID                    info_buf,
    ULONG                    info_len)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    return;
} /* Nic_pnpevent_notify */


VOID Nic_adapter_shutdown (
    NDIS_HANDLE         adapter_handle)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;

    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    return;
} /* Nic_adapter_shutdown */


/* helpers for protocol layer */


NDIS_STATUS Nic_announce (
    PMAIN_CTXT          ctxtp)
{
    NDIS_STATUS         status;
    NDIS_STRING         nic_name;

    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    /* create the name to expose to TCP/IP protocol and call NDIS to force
       TCP/IP to bind to us */

    NdisInitUnicodeString (& nic_name, ctxtp -> virtual_nic_name);

    /* Called from Prot_bind at PASSIVE_LEVEL - %ls is OK. */
    UNIV_PRINT_INFO(("Nic_announce: Exposing %ls, %ls", nic_name . Buffer, ctxtp -> virtual_nic_name));

    status = NdisIMInitializeDeviceInstanceEx (univ_driver_handle, & nic_name, (NDIS_HANDLE) ctxtp);

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT_CRIT(("Nic_announce: Error announcing driver %x", status));
        __LOG_MSG1 (MSG_ERROR_ANNOUNCE, nic_name . Buffer + (wcslen(L"\\DEVICE\\") * sizeof(WCHAR)), status);
    }

    UNIV_PRINT_INFO(("Nic_announce: return=0x%x", status));

    return status;

} /* end Nic_announce */


NDIS_STATUS Nic_unannounce (
    PMAIN_CTXT          ctxtp)
{
    NDIS_STATUS         status;
    NDIS_STRING         nic_name;
    PMAIN_ADAPTER       adapterp;

    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    adapterp = & (univ_adapters [ctxtp -> adapter_id]);
    UNIV_ASSERT (adapterp -> code == MAIN_ADAPTER_CODE);
    UNIV_ASSERT (adapterp -> ctxtp == ctxtp);

    NdisAcquireSpinLock(& univ_bind_lock);

    if (! adapterp -> announced || ctxtp -> prot_handle == NULL)
    {
        adapterp -> announced = FALSE;
        ctxtp->prot_handle = NULL;
        NdisReleaseSpinLock(& univ_bind_lock);

        NdisInitUnicodeString (& nic_name, ctxtp -> virtual_nic_name);

        /* Called from Prot_unbind at PASSIVE_LEVEL - %ls is OK. */
        UNIV_PRINT_INFO(("Nic_unannounce: Cancelling %ls, %ls", nic_name . Buffer, ctxtp -> virtual_nic_name));

        status = NdisIMCancelInitializeDeviceInstance (univ_driver_handle, & nic_name);

        if (status != NDIS_STATUS_SUCCESS)
        {
            UNIV_PRINT_CRIT(("Nic_unannounce: Error cancelling driver %x", status));
            __LOG_MSG1 (MSG_ERROR_ANNOUNCE, nic_name . Buffer + (wcslen(L"\\DEVICE\\") * sizeof(WCHAR)), status);
            TRACE_CRIT("%!FUNC! Error cancelling driver status=0x%x", status);
        }

        UNIV_PRINT_INFO(("Nic_unannounce: return=NDIS_STATUS_SUCCESS"));
        TRACE_INFO("<-%!FUNC! return=NDIS_STATUS_SUCCESS");
        return NDIS_STATUS_SUCCESS;
    }

    NdisReleaseSpinLock(& univ_bind_lock);

    UNIV_PRINT_INFO(("Nic_unannounce: Calling DeinitializeDeviceInstance"));
    TRACE_INFO("%!FUNC! Calling DeinitializeDeviceInstance");

    status = NdisIMDeInitializeDeviceInstance (ctxtp -> prot_handle);

    UNIV_PRINT_INFO(("Nic_unannounce: return=0x%x", status));
    TRACE_INFO("<-%!FUNC! return=0x%x", status);
    return status;

} /* end Nic_unannounce */


/* routines that can be used with Nic_sync */


VOID Nic_request_complete (
    NDIS_HANDLE         handle,
    PVOID               cookie)
{
    PMAIN_ACTION        actp    = (PMAIN_ACTION) cookie;
    PMAIN_CTXT          ctxtp   = actp -> ctxtp;
    NDIS_STATUS         status  = actp -> status;
    PNDIS_REQUEST       request = & actp -> op . request . req;
    PULONG              ptr;
    ULONG               oid;

    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    if (request -> RequestType == NdisRequestSetInformation)
    {
        UNIV_ASSERT (request -> DATA . SET_INFORMATION . Oid != OID_PNP_SET_POWER);

        * actp -> op . request . xferred =
                            request -> DATA . SET_INFORMATION . BytesRead;
        * actp -> op . request . needed  =
                            request -> DATA . SET_INFORMATION . BytesNeeded;

#if defined(TRACE_OID)
        DbgPrint("Nic_request_complete: set done %x, %d %d\n", status, * actp -> op . request . xferred, * actp -> op . request . needed);
#endif
        TRACE_VERB("%!FUNC! set done status=0x%x, xferred=%d, needed=%d", status, * actp -> op . request . xferred, * actp -> op . request . needed);

        /* V1.3.0b multicast support - free multicast list array */

        if (request -> DATA . SET_INFORMATION . Oid == OID_802_3_MULTICAST_LIST)
        {
            /* If the request buffer is non-NULL, then we were forced to allocate a new buffer
               large enough to hold the entire multicast MAC address list, plus our multicast
               MAC address, which was missing from the list sent down by the protocol.  To mask
               this from the protocol, free the buffer and decrease the number of bytes read 
               by the miniport by the length of a MAC address before returning the request to
               the protocol. */
            if (actp->op.request.buffer != NULL) {
                if (status != NDIS_STATUS_SUCCESS)
                {
                    UNIV_PRINT_CRIT(("Nic_request_complete: Error setting multicast list, status=0x%x", status));
                    TRACE_CRIT("%!FUNC! Error setting multicast list, status=0x%x", status);
                }

                NdisFreeMemory(actp->op.request.buffer, actp->op.request.buffer_len, 0);

                * actp -> op . request . xferred -= CVY_MAC_ADDR_LEN (ctxtp -> medium);
            }
        }
#if defined (NLB_TCP_NOTIFICATION) 
        else if (request->DATA.SET_INFORMATION.Oid == OID_GEN_NETWORK_LAYER_ADDRESSES)
        {
            /* Schedule an NDIS work item to get the interface index of this NLB 
               instance from TCP/IP by querying the IP address table. */
            (VOID)Main_schedule_work_item(ctxtp, Main_set_interface_index);

            /* Overwrite the status from the request.  We will ALWAYS succeed this OID, 
               lest the protocol decide to stop sending it down to us.  See the DDK. */
            status = NDIS_STATUS_SUCCESS;
        }
#endif

        NdisMSetInformationComplete (ctxtp -> prot_handle, status);
    }
    else if (request -> RequestType == NdisRequestQueryInformation)
    {
        * actp -> op . request . xferred =
                        request -> DATA . QUERY_INFORMATION . BytesWritten;
        * actp -> op . request . needed  =
                        request -> DATA . QUERY_INFORMATION . BytesNeeded;

#if defined(TRACE_OID)
        DbgPrint("Nic_request_complete: query done %x, %d %d\n", status, * actp -> op . request . xferred, * actp -> op . request . needed);
#endif

        oid = request -> DATA . QUERY_INFORMATION . Oid;
        ptr = ((PULONG) request -> DATA . QUERY_INFORMATION . InformationBuffer);

        /* override certain oid values with our own */

        if (oid == OID_GEN_MAXIMUM_SEND_PACKETS &&
            request -> DATA . QUERY_INFORMATION . InformationBufferLength >=
            sizeof (ULONG))
        {
            * ptr = CVY_MAX_SEND_PACKETS;
            * actp -> op . request . xferred = sizeof (ULONG);
            status = NDIS_STATUS_SUCCESS;
        }
        else if (oid == OID_802_3_CURRENT_ADDRESS && status == NDIS_STATUS_SUCCESS)
        {
            if (request->DATA.QUERY_INFORMATION.InformationBufferLength >= sizeof(CVY_MAC_ADR)) {
                if (!ctxtp->params.mcast_support && ctxtp->cl_ip_addr != 0)
                    NdisMoveMemory(ptr, &ctxtp->cl_mac_addr, sizeof(CVY_MAC_ADR));
                else
                    NdisMoveMemory(ptr, &ctxtp->ded_mac_addr, sizeof(CVY_MAC_ADR));
                
                *actp->op.request.xferred = sizeof(CVY_MAC_ADR);
            } else {
                UNIV_PRINT_CRIT(("Nic_request_complete: MAC address buffer too small (%u) - not spoofing", request->DATA.QUERY_INFORMATION.InformationBufferLength));
           }
        }
        else if (oid == OID_GEN_MAC_OPTIONS && status == NDIS_STATUS_SUCCESS)
        {
            * ptr |= NDIS_MAC_OPTION_TRANSFERS_NOT_PEND |
                     NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA;
            * ptr &= ~NDIS_MAC_OPTION_NO_LOOPBACK;
        }
        else if (oid == OID_PNP_CAPABILITIES && status == NDIS_STATUS_SUCCESS)
        {
            PNDIS_PNP_CAPABILITIES          pnp_capabilities;
            PNDIS_PM_WAKE_UP_CAPABILITIES   pm_struct;

            if (request -> DATA . QUERY_INFORMATION . InformationBufferLength >=
                sizeof (NDIS_PNP_CAPABILITIES))
            {
                pnp_capabilities = (PNDIS_PNP_CAPABILITIES) ptr;
                pm_struct = & pnp_capabilities -> WakeUpCapabilities;

                pm_struct -> MinMagicPacketWakeUp = NdisDeviceStateUnspecified;
                pm_struct -> MinPatternWakeUp     = NdisDeviceStateUnspecified;
                pm_struct -> MinLinkChangeWakeUp  = NdisDeviceStateUnspecified;

                ctxtp -> prot_pnp_state = NdisDeviceStateD0;
                ctxtp -> nic_pnp_state  = NdisDeviceStateD0;

                * actp -> op . request . xferred = sizeof (NDIS_PNP_CAPABILITIES);
                * actp -> op . request . needed  = 0;
                status = NDIS_STATUS_SUCCESS;
            }
            else
            {
                * actp -> op . request . needed = sizeof (NDIS_PNP_CAPABILITIES);
                status = NDIS_STATUS_RESOURCES;
            }
        }

        NdisMQueryInformationComplete (ctxtp -> prot_handle, status);
    }
    else
    {
        UNIV_PRINT_CRIT(("Nic_request_complete: Strange request completion %x\n", request -> RequestType));
        TRACE_CRIT("%!FUNC! Strange request completion 0x%x", request -> RequestType);
    }

    Main_action_put (ctxtp, actp);

} /* end Nic_request_complete */


VOID Nic_reset_complete (
    PMAIN_CTXT          ctxtp,
    NDIS_STATUS         status)
{
    TRACE_INFO("->%!FUNC!");

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT_CRIT(("Nic_reset_complete: Error resetting adapter %x", status));
        TRACE_CRIT("%!FUNC! Error resetting adapter 0x%x", status);
    }

    NdisMResetComplete (ctxtp -> prot_handle, status, TRUE);

    TRACE_INFO("<-%!FUNC! return");

} /* end Nic_reset_complete */


VOID Nic_send_complete (
    PMAIN_CTXT          ctxtp,
    NDIS_STATUS         status,
    PNDIS_PACKET        packet)
{
    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT_CRIT(("Nic_send_complete: Error sending to adapter %x", status));
        TRACE_CRIT("%!FUNC! Error sending to adapter 0x%x", status);
    }

//  ctxtp -> sends_completed ++;

    NdisMSendComplete (ctxtp -> prot_handle, packet, status);

} /* end Nic_send_complete */


VOID Nic_recv_complete (    /* PASSIVE_IRQL */
    PMAIN_CTXT          ctxtp)
{
    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    UNIV_ASSERT (ctxtp -> medium == NdisMedium802_3);

    NdisMEthIndicateReceiveComplete (ctxtp -> prot_handle);

} /* end Nic_recv_complete */


VOID Nic_send_resources_signal (
    PMAIN_CTXT          ctxtp)
{
    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    UNIV_PRINT_VERB(("Nic_send_resources_signal: Signalling send resources available"));
    NdisMSendResourcesAvailable (ctxtp -> prot_handle);

} /* end Nic_send_resources_signal */


NDIS_STATUS Nic_PNP_handle (
    PMAIN_CTXT          ctxtp,
    PNET_PNP_EVENT      pnp_event)
{
    NDIS_STATUS         status;

    TRACE_INFO("->%!FUNC!");
    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    if (ctxtp -> prot_handle != NULL)
    {
        status = NdisIMNotifyPnPEvent (ctxtp -> prot_handle, pnp_event);
    }
    else
    {
        status = NDIS_STATUS_SUCCESS;
    }

    UNIV_PRINT_VERB(("Nic_PNP_handle: status 0x%x", status));
    TRACE_INFO("<-%!FUNC! return=0x%x", status);

    return status;
}


VOID Nic_status (
    PMAIN_CTXT          ctxtp,
    NDIS_STATUS         status,
    PVOID               buf,
    UINT                len)
{
    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    UNIV_PRINT_VERB(("Nic_status: Status indicated %x", status));

    NdisMIndicateStatus (ctxtp -> prot_handle, status, buf, len);

} /* end Nic_status */


VOID Nic_status_complete (
    PMAIN_CTXT          ctxtp)
{
    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    NdisMIndicateStatusComplete (ctxtp -> prot_handle);

} /* end Nic_status_complete */



VOID Nic_packets_send (
    NDIS_HANDLE         adapter_handle,
    PPNDIS_PACKET       packets,
    UINT                num_packets)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;
    NDIS_STATUS         status;
    PMAIN_ADAPTER       adapterp;

    /* V1.1.4 */

    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    adapterp = & (univ_adapters [ctxtp -> adapter_id]);
    UNIV_ASSERT (adapterp -> code == MAIN_ADAPTER_CODE);
    UNIV_ASSERT (adapterp -> ctxtp == ctxtp);

    if (! adapterp -> inited)
    {
//      ctxtp -> uninited_return += num_packets;
        TRACE_CRIT("%!FUNC! adapter not initialized");
        return;
    }

//  ctxtp -> sends_in ++;

    Prot_packets_send (ctxtp, packets, num_packets);

} /* end Nic_packets_send */


VOID Nic_return (
    NDIS_HANDLE         adapter_handle,
    PNDIS_PACKET        packet)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;
    PMAIN_ADAPTER       adapterp;

    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    adapterp = & (univ_adapters [ctxtp -> adapter_id]);
    UNIV_ASSERT (adapterp -> code == MAIN_ADAPTER_CODE);
    UNIV_ASSERT (adapterp -> ctxtp == ctxtp);

    Prot_return (ctxtp, packet);

} /* end Nic_return */


/* would be called by Prot_packet_recv */

VOID Nic_recv_packet (
    PMAIN_CTXT          ctxtp,
    PNDIS_PACKET        packet)
{
    NDIS_STATUS         status;

    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    status = NDIS_GET_PACKET_STATUS (packet);
    NdisMIndicateReceivePacket (ctxtp -> prot_handle, & packet, 1);

    if (status == NDIS_STATUS_RESOURCES)
        Prot_return (ctxtp, packet);

} /* end Nic_recv_packet */


VOID Nic_timer (
    PVOID                   dpc,
    PVOID                   cp,
    PVOID                   arg1,
    PVOID                   arg2)
{
    PMAIN_CTXT              ctxtp = cp;
    PMAIN_ADAPTER           adapterp;
    ULONG                   tout;

    UNIV_ASSERT(ctxtp->code == MAIN_CTXT_CODE);

    adapterp = &(univ_adapters[ctxtp->adapter_id]);

    UNIV_ASSERT(adapterp->code == MAIN_ADAPTER_CODE);
    UNIV_ASSERT(adapterp->ctxtp == ctxtp);

    /* If the adapter is not initialized at this point, then we can't process
       the timeout, so just reset the timer and bail out.  Note: this should 
       NEVER happen, as the context is always initialized BEFORE the timer is
       set and the timer is always cancelled BEFORE the context is de-initialized. */
    if (!adapterp->inited) {
        UNIV_PRINT_CRIT(("Nic_timer: Adapter not initialized.  Bailing out without resetting the heartbeat timer."));
        TRACE_CRIT("%!FUNC! Adapter not initialized.  Bailing out without resetting the heartbeat timer.");
        return;
    }

    /* Initialize tout to the current heartbeat timeout. */
    tout = ctxtp->curr_tout;

    /* Handle the heartbeat timer. */
    Main_ping(ctxtp, &tout);

    NdisAcquireSpinLock(&univ_bind_lock);

    /* If the adapter is not announced anymore, then we don't want to reset the timer. */
    if (!adapterp->announced) {
        UNIV_PRINT_CRIT(("Nic_timer: Adapter not announced.  Bailing out without resetting the heartbeat timer."));
        TRACE_CRIT("%!FUNC! Adapter not announced.  Bailing out without resetting the heartbeat timer.");
        NdisReleaseSpinLock(&univ_bind_lock);
        return;
    }

    /* Cache the next timeout value specified by the load module and use it to
       reset the timer for the next heartbeat timeout. */
    ctxtp->curr_tout = tout;
    NdisMSetTimer((PNDIS_MINIPORT_TIMER)ctxtp->timer, tout);

    NdisReleaseSpinLock(&univ_bind_lock);
}

VOID Nic_sleep (
    ULONG                   msecs)
{
    NdisMSleep(msecs);

} /* end Nic_sleep */


/* Added from old code for NT 5.1 - ramkrish */
VOID Nic_recv_indicate (
    PMAIN_CTXT          ctxtp,
    NDIS_HANDLE         recv_handle,
    PVOID               head_buf,
    UINT                head_len,
    PVOID               look_buf,
    UINT                look_len,
    UINT                packet_len)
{
    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    /* V1.1.2 do not accept frames if the card below is resetting */

    if (ctxtp -> reset_state != MAIN_RESET_NONE)
    {
        TRACE_CRIT("%!FUNC! adapter was reset");
        return;
    }

    UNIV_ASSERT (ctxtp -> medium == NdisMedium802_3);

    NdisMEthIndicateReceive (ctxtp -> prot_handle,
                             recv_handle,
                             head_buf,
                             head_len,
                             look_buf,
                             look_len,
                             packet_len);

} /* end Nic_recv_indicate */


NDIS_STATUS Nic_transfer (
    PNDIS_PACKET        packet,
    PUINT               xferred,
    NDIS_HANDLE         adapter_handle,
    NDIS_HANDLE         receive_handle,
    UINT                offset,
    UINT                len)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;
    NDIS_STATUS         status;

    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    status = Prot_transfer (ctxtp, receive_handle, packet, offset, len, xferred);

    if (status != NDIS_STATUS_PENDING && status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT_CRIT(("Nic_transfer: Error transferring from adapter %x", status));
        TRACE_CRIT("%!FUNC! error transferring from adapter 0x%x", status);
    }

    return status;

} /* end Nic_transfer */


VOID Nic_transfer_complete (
    PMAIN_CTXT          ctxtp,
    NDIS_STATUS         status,
    PNDIS_PACKET        packet,
    UINT                xferred)
{
    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT_CRIT(("Nic_transfer: Error transferring from adapter %x", status));
        TRACE_CRIT("%!FUNC! error transferring from adapter 0x%x", status);
    }

    NdisMTransferDataComplete (ctxtp -> prot_handle, packet, status, xferred);

} /* end Nic_transfer_complete */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\driver\params.c ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    params.c

Abstract:

    Windows Load Balancing Service (WLBS)
    Driver - registry parameter support

Author:

    kyrilf

--*/

#include <ntddk.h>
#include <strsafe.h>

#include "wlbsparm.h"
#include "params.h"
#include "univ.h"
#include "log.h"
#include "main.h"
#include "params.tmh"

#if defined (NLB_TCP_NOTIFICATION)
#include <ntddnlb.h>
#endif

/* CONSTANTS */


#define PARAMS_INFO_BUF_SIZE    ((CVY_MAX_PARAM_STR + 1) * sizeof (WCHAR) + \
                                  CVY_MAX_RULES * sizeof (CVY_RULE) + \
                                  sizeof (KEY_VALUE_PARTIAL_INFORMATION) + 4)

/* The maximum length of a registry path string, in characters (WCHAR). */
#define CVY_MAX_REG_PATH        512

/* The maximum length of a port rule number (which will actually be no more
   than 3 (2 digits + NUL), but make it 8 for good measure. */
#define CVY_MAX_PORTRULE_DIGITS 8

#define NLB_GLOBAL_REG_PATH     L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Services\\WLBS\\Parameters\\Global"
#define HOST_REG_PATH           L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters"

/* GLOBALS */


static ULONG log_module_id = LOG_MODULE_PARAMS;


static UCHAR infop [PARAMS_INFO_BUF_SIZE];


/* PROCEDURES */

/* return codes from Params_verify call */
/* in user mode returns object ID of the dialog control that needs to be fixed */

#define CVY_VERIFY_OK           0
#define CVY_VERIFY_EXIT         1

ULONG Params_verify (
    PVOID           nlbctxt,
    PCVY_PARAMS     paramp,
    BOOL            complain)
{
    ULONG           j, i, code;
    PCVY_RULE       rp, rulep;
    PSTR            prot;
    PCHAR           aff;
    ULONG           ret;
    ANSI_STRING     domain, key, ip;
    PMAIN_CTXT      ctxtp = (PMAIN_CTXT)nlbctxt;

    TRACE_VERB("->%!FUNC! nlbctxt=0x%p, paramp=0x%p", nlbctxt, paramp);

    /* ensure sane values for all parameters */

    CVY_CHECK_MIN (paramp -> alive_period, CVY_MIN_ALIVE_PERIOD);
    CVY_CHECK_MAX (paramp -> alive_period, CVY_MAX_ALIVE_PERIOD);

    CVY_CHECK_MIN (paramp -> alive_tolerance, CVY_MIN_ALIVE_TOLER);
    CVY_CHECK_MAX (paramp -> alive_tolerance, CVY_MAX_ALIVE_TOLER);

    CVY_CHECK_MIN (paramp -> num_actions, CVY_MIN_NUM_ACTIONS);
    CVY_CHECK_MAX (paramp -> num_actions, CVY_MAX_NUM_ACTIONS);

    CVY_CHECK_MIN (paramp -> num_packets, CVY_MIN_NUM_PACKETS);
    CVY_CHECK_MAX (paramp -> num_packets, CVY_MAX_NUM_PACKETS);

    CVY_CHECK_MIN (paramp -> dscr_per_alloc, CVY_MIN_DSCR_PER_ALLOC);
    CVY_CHECK_MAX (paramp -> dscr_per_alloc, CVY_MAX_DSCR_PER_ALLOC);

    CVY_CHECK_MIN (paramp -> max_dscr_allocs, CVY_MIN_MAX_DSCR_ALLOCS);
    CVY_CHECK_MAX (paramp -> max_dscr_allocs, CVY_MAX_MAX_DSCR_ALLOCS);

    CVY_CHECK_MAX (paramp -> cleanup_delay, CVY_MAX_CLEANUP_DELAY);

    CVY_CHECK_MAX (paramp -> ip_chg_delay, CVY_MAX_IP_CHG_DELAY);

    CVY_CHECK_MIN (paramp -> num_send_msgs, (CVY_MAX_HOSTS + 1) * 2);
    CVY_CHECK_MAX (paramp -> num_send_msgs, (CVY_MAX_HOSTS + 1) * 10);

    CVY_CHECK_MAX (paramp -> tcp_dscr_timeout, CVY_MAX_TCP_TIMEOUT);

    CVY_CHECK_MAX (paramp -> ipsec_dscr_timeout, CVY_MAX_IPSEC_TIMEOUT);

    CVY_CHECK_MIN (paramp -> identity_period, CVY_MIN_ID_HB_PERIOD);
    CVY_CHECK_MAX (paramp -> identity_period, CVY_MAX_ID_HB_PERIOD);

    CVY_CHECK_MAX (paramp -> identity_enabled, CVY_MAX_ID_HB_ENABLED);

    /* verify that parameters are correct */

    if (paramp -> parms_ver != CVY_PARAMS_VERSION)
    {
        UNIV_PRINT_CRIT(("Params_verify: Bad parameters version %d, expected %d", paramp -> parms_ver, CVY_PARAMS_VERSION));
        LOG_MSG (MSG_WARN_VERSION, MSG_NONE);
        TRACE_CRIT("%!FUNC! Bad parameters version %d, expected %d", paramp -> parms_ver, CVY_PARAMS_VERSION);
        TRACE_VERB("<-%!FUNC! return=CVY_VERIFY_EXIT bad parameters version");
        return CVY_VERIFY_EXIT;
    }

    if (paramp -> rct_port < CVY_MIN_RCT_PORT ||
        paramp -> rct_port > CVY_MAX_RCT_PORT)
    {
        /* All registry operations occur at PASSIVE_LEVEL - %ls is OK. */
        UNIV_PRINT_CRIT(("Params_verify: Bad value for parameter %ls, %d <= %d <= %d", CVY_NAME_NUM_RULES, CVY_MIN_CLEANUP_DELAY, paramp -> cleanup_delay, CVY_MAX_CLEANUP_DELAY));
        TRACE_CRIT("%!FUNC! Bad value for parameter %ls, %d <= %d <= %d", CVY_NAME_RCT_PORT, CVY_MIN_RCT_PORT, paramp -> rct_port, CVY_MIN_RCT_PORT);
        TRACE_VERB("<-%!FUNC! return=CVY_VERIFY_EXIT bad value for %ls", CVY_NAME_RCT_PORT);
        return CVY_VERIFY_EXIT;
    }

    if (paramp -> host_priority < CVY_MIN_HOST_PRIORITY ||
        paramp -> host_priority > CVY_MAX_HOSTS)
    {
        /* All registry operations occur at PASSIVE_LEVEL - %ls is OK. */
        UNIV_PRINT_CRIT(("Params_verify: Bad value for parameter %ls, %d <= %d <= %d", CVY_NAME_HOST_PRIORITY, CVY_MIN_HOST_PRIORITY, paramp -> host_priority, CVY_MAX_HOSTS));
        TRACE_CRIT("%!FUNC! Bad value for parameter %ls, %d <= %d <= %d", CVY_NAME_HOST_PRIORITY, CVY_MIN_HOST_PRIORITY, paramp -> host_priority, CVY_MAX_HOSTS);
        TRACE_VERB("<-%!FUNC! return=CVY_VERIFY_EXIT bad value for %ls", CVY_NAME_HOST_PRIORITY);
        return CVY_VERIFY_EXIT;
    }

    if (paramp -> num_rules > CVY_MAX_NUM_RULES)
    {
        /* All registry operations occur at PASSIVE_LEVEL - %ls is OK. */
        UNIV_PRINT_CRIT(("Params_verify: Bad value for parameter %ls, %d <= %d <= %d", CVY_NAME_NUM_RULES, CVY_MIN_NUM_RULES, paramp -> num_rules, CVY_MAX_NUM_RULES));
        TRACE_CRIT("%!FUNC! Bad value for parameter %ls, %d <= %d <= %d", CVY_NAME_NUM_RULES, CVY_MIN_NUM_RULES, paramp -> num_rules, CVY_MAX_NUM_RULES);
        TRACE_VERB("<-%!FUNC! return=CVY_VERIFY_EXIT bad value for %ls", CVY_NAME_NUM_RULES);
        return CVY_VERIFY_EXIT;
    }

    if (paramp -> num_rules > CVY_MAX_USABLE_RULES)
    {
        /* All registry operations occur at PASSIVE_LEVEL - %ls is OK. */
        UNIV_PRINT_CRIT(("Params_verify: Bad value for parameter %ls, %d <= %d <= %d", CVY_NAME_NUM_RULES, CVY_MIN_NUM_RULES, paramp -> num_rules, CVY_MAX_USABLE_RULES));
        LOG_MSG2 (MSG_WARN_TOO_MANY_RULES, MSG_NONE, paramp -> num_rules, CVY_MAX_USABLE_RULES);
        TRACE_CRIT("%!FUNC! Bad value for parameter %ls, %d <= %d <= %d", CVY_NAME_NUM_RULES, CVY_MIN_NUM_RULES, paramp -> num_rules, CVY_MAX_USABLE_RULES);
        paramp -> num_rules = CVY_MAX_USABLE_RULES;
    }

    CVY_CHECK_MAX (paramp -> num_rules, CVY_MAX_NUM_RULES);

    CVY_CHECK_MIN (paramp -> host_priority, CVY_MIN_HOST_PRIORITY);
    CVY_CHECK_MAX (paramp -> host_priority, CVY_MAX_HOST_PRIORITY);

#ifdef TRACE_PARAMS
    /* All registry operations occur at PASSIVE_LEVEL - %ls is OK. */
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_HOST_PRIORITY, paramp -> host_priority);
    DbgPrint ("Parameter: %-25ls = %ls\n", CVY_NAME_DED_IP_ADDR,   paramp -> ded_ip_addr);
    DbgPrint ("Parameter: %-25ls = %ls\n", CVY_NAME_DED_NET_MASK,  paramp -> ded_net_mask);
    DbgPrint ("Parameter: %-25ls = %ls\n", CVY_NAME_NETWORK_ADDR,  paramp -> cl_mac_addr);
    DbgPrint ("Parameter: %-25ls = %ls\n", CVY_NAME_CL_IP_ADDR,    paramp -> cl_ip_addr);
    DbgPrint ("Parameter: %-25ls = %ls\n", CVY_NAME_CL_NET_MASK,   paramp -> cl_net_mask);
    DbgPrint ("Parameter: %-25ls = %ls\n", CVY_NAME_DOMAIN_NAME,   paramp -> domain_name);
    DbgPrint ("Parameter: %-25ls = %ls\n", CVY_NAME_MCAST_IP_ADDR, paramp -> cl_igmp_addr);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_ALIVE_PERIOD,  paramp -> alive_period);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_ALIVE_TOLER,   paramp -> alive_tolerance);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_NUM_ACTIONS,   paramp -> num_actions);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_NUM_PACKETS,   paramp -> num_packets);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_NUM_SEND_MSGS, paramp -> num_send_msgs);
    DbgPrint ("Parameter: %-25ls = %x\n",  CVY_NAME_INSTALL_DATE,  paramp -> install_date);
    DbgPrint ("Parameter: %-25ls = %x\n",  CVY_NAME_RMT_PASSWORD,  paramp -> rmt_password);
    DbgPrint ("Parameter: %-25ls = %x\n",  CVY_NAME_RCT_PASSWORD,  paramp -> rct_password);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_RCT_PORT,      paramp -> rct_port);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_RCT_ENABLED,   paramp -> rct_enabled);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_NUM_RULES,     paramp -> num_rules);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_DSCR_PER_ALLOC,paramp -> dscr_per_alloc);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_MAX_DSCR_ALLOCS, paramp -> max_dscr_allocs);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_TCP_TIMEOUT,   paramp -> tcp_dscr_timeout);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_IPSEC_TIMEOUT, paramp -> ipsec_dscr_timeout);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_FILTER_ICMP,   paramp -> filter_icmp);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_SCALE_CLIENT,  paramp -> scale_client);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_CLEANUP_DELAY, paramp -> cleanup_delay);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_NBT_SUPPORT,   paramp -> nbt_support);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_MCAST_SUPPORT, paramp -> mcast_support);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_MCAST_SPOOF,   paramp -> mcast_spoof);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_IGMP_SUPPORT, paramp -> igmp_support);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_MASK_SRC_MAC,  paramp -> mask_src_mac);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_NETMON_ALIVE,  paramp -> netmon_alive);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_IP_CHG_DELAY,  paramp -> ip_chg_delay);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_CONVERT_MAC,   paramp -> convert_mac);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_ID_HB_PERIOD,  paramp -> identity_period);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_ID_HB_ENABLED,  paramp -> identity_enabled);

    /* All registry operations occur at PASSIVE_LEVEL - %ls is OK. */
    DbgPrint ("\n");
    DbgPrint ("Bi-directional affinity teaming:\n");
    DbgPrint ("Active:       %ls\n", (paramp->bda_teaming.active) ? L"Yes" : L"No");
    DbgPrint ("Team ID:      %ls\n", (paramp->bda_teaming.team_id));
    DbgPrint ("Master:       %ls\n", (paramp->bda_teaming.master) ? L"Yes" : L"No");
    DbgPrint ("Reverse hash: %ls\n", (paramp->bda_teaming.reverse_hash) ? L"Yes" : L"No");
    DbgPrint ("\n");

    TRACE_INFO("%!FUNC! Parameter: %-25ls = %d",  CVY_NAME_HOST_PRIORITY, paramp -> host_priority);
    TRACE_INFO("%!FUNC! Parameter: %-25ls = %ls", CVY_NAME_DED_IP_ADDR,   paramp -> ded_ip_addr);
    TRACE_INFO("%!FUNC! Parameter: %-25ls = %ls", CVY_NAME_DED_NET_MASK,  paramp -> ded_net_mask);
    TRACE_INFO("%!FUNC! Parameter: %-25ls = %ls", CVY_NAME_NETWORK_ADDR,  paramp -> cl_mac_addr);
    TRACE_INFO("%!FUNC! Parameter: %-25ls = %ls", CVY_NAME_CL_IP_ADDR,    paramp -> cl_ip_addr);
    TRACE_INFO("%!FUNC! Parameter: %-25ls = %ls", CVY_NAME_CL_NET_MASK,   paramp -> cl_net_mask);
    TRACE_INFO("%!FUNC! Parameter: %-25ls = %ls", CVY_NAME_DOMAIN_NAME,   paramp -> domain_name);
    TRACE_INFO("%!FUNC! Parameter: %-25ls = %ls", CVY_NAME_MCAST_IP_ADDR, paramp -> cl_igmp_addr);
    TRACE_INFO("%!FUNC! Parameter: %-25ls = %d",  CVY_NAME_ALIVE_PERIOD,  paramp -> alive_period);
    TRACE_INFO("%!FUNC! Parameter: %-25ls = %d",  CVY_NAME_ALIVE_TOLER,   paramp -> alive_tolerance);
    TRACE_INFO("%!FUNC! Parameter: %-25ls = %d",  CVY_NAME_NUM_ACTIONS,   paramp -> num_actions);
    TRACE_INFO("%!FUNC! Parameter: %-25ls = %d",  CVY_NAME_NUM_PACKETS,   paramp -> num_packets);
    TRACE_INFO("%!FUNC! Parameter: %-25ls = %d",  CVY_NAME_NUM_SEND_MSGS, paramp -> num_send_msgs);
    TRACE_INFO("%!FUNC! Parameter: %-25ls = 0x%x",  CVY_NAME_INSTALL_DATE,  paramp -> install_date);
    TRACE_INFO("%!FUNC! Parameter: %-25ls = 0x%x",  CVY_NAME_RMT_PASSWORD,  paramp -> rmt_password);
    TRACE_INFO("%!FUNC! Parameter: %-25ls = 0x%x",  CVY_NAME_RCT_PASSWORD,  paramp -> rct_password);
    TRACE_INFO("%!FUNC! Parameter: %-25ls = %d",  CVY_NAME_RCT_PORT,      paramp -> rct_port);
    TRACE_INFO("%!FUNC! Parameter: %-25ls = %d",  CVY_NAME_RCT_ENABLED,   paramp -> rct_enabled);
    TRACE_INFO("%!FUNC! Parameter: %-25ls = %d",  CVY_NAME_NUM_RULES,     paramp -> num_rules);
    TRACE_INFO("%!FUNC! Parameter: %-25ls = %d",  CVY_NAME_DSCR_PER_ALLOC,paramp -> dscr_per_alloc);
    TRACE_INFO("%!FUNC! Parameter: %-25ls = %d",  CVY_NAME_MAX_DSCR_ALLOCS, paramp -> max_dscr_allocs);
    TRACE_INFO("%!FUNC! Parameter: %-25ls = %d",  CVY_NAME_TCP_TIMEOUT,   paramp -> tcp_dscr_timeout);
    TRACE_INFO("%!FUNC! Parameter: %-25ls = %d",  CVY_NAME_IPSEC_TIMEOUT, paramp -> ipsec_dscr_timeout);
    TRACE_INFO("%!FUNC! Parameter: %-25ls = %d",  CVY_NAME_FILTER_ICMP,   paramp -> filter_icmp);
    TRACE_INFO("%!FUNC! Parameter: %-25ls = %d",  CVY_NAME_SCALE_CLIENT,  paramp -> scale_client);
    TRACE_INFO("%!FUNC! Parameter: %-25ls = %d",  CVY_NAME_CLEANUP_DELAY, paramp -> cleanup_delay);
    TRACE_INFO("%!FUNC! Parameter: %-25ls = %d",  CVY_NAME_NBT_SUPPORT,   paramp -> nbt_support);
    TRACE_INFO("%!FUNC! Parameter: %-25ls = %d",  CVY_NAME_MCAST_SUPPORT, paramp -> mcast_support);
    TRACE_INFO("%!FUNC! Parameter: %-25ls = %d",  CVY_NAME_MCAST_SPOOF,   paramp -> mcast_spoof);
    TRACE_INFO("%!FUNC! Parameter: %-25ls = %d",  CVY_NAME_IGMP_SUPPORT, paramp -> igmp_support);
    TRACE_INFO("%!FUNC! Parameter: %-25ls = %d",  CVY_NAME_MASK_SRC_MAC,  paramp -> mask_src_mac);
    TRACE_INFO("%!FUNC! Parameter: %-25ls = %d",  CVY_NAME_NETMON_ALIVE,  paramp -> netmon_alive);
    TRACE_INFO("%!FUNC! Parameter: %-25ls = %d",  CVY_NAME_IP_CHG_DELAY,  paramp -> ip_chg_delay);
    TRACE_INFO("%!FUNC! Parameter: %-25ls = %d",  CVY_NAME_CONVERT_MAC,   paramp -> convert_mac);

    TRACE_INFO("%!FUNC! Bi-directional affinity teaming:");
    TRACE_INFO("%!FUNC! Active:       %ls", (paramp->bda_teaming.active) ? L"Yes" : L"No");
    TRACE_INFO("%!FUNC! Team ID:      %ls", (paramp->bda_teaming.team_id));
    TRACE_INFO("%!FUNC! Master:       %ls", (paramp->bda_teaming.master) ? L"Yes" : L"No");
    TRACE_INFO("%!FUNC! Reverse hash: %ls", (paramp->bda_teaming.reverse_hash) ? L"Yes" : L"No");

    DbgPrint ("Rules:\n");
    TRACE_INFO("%!FUNC! Rules");

    for (i = 0; i < paramp -> num_rules * sizeof (CVY_RULE) / sizeof (ULONG); i ++)
    {
        if (i != 0 && i % 9 == 0)
            DbgPrint ("\n");

        DbgPrint ("%08X ", * ((PULONG) paramp -> port_rules + i));
        TRACE_INFO("%!FUNC! 0x%08X ", * ((PULONG) paramp -> port_rules + i));
    }

    DbgPrint ("\n   VIP   Start  End  Prot   Mode   Pri Load Affinity\n");
    TRACE_INFO("%!FUNC!    VIP   Start  End  Prot   Mode   Pri Load Affinity");
#endif

    for (i = 0; i < paramp -> num_rules; i ++)
    {
        rp = paramp -> port_rules + i;

        code = CVY_DRIVER_RULE_CODE_GET (rp);

        CVY_DRIVER_RULE_CODE_SET (rp);

        if (code != CVY_DRIVER_RULE_CODE_GET (rp))
        {
            UNIV_PRINT_CRIT(("Params_verify: Bad rule code: %x vs %x", code, rp -> code));
            TRACE_CRIT("%!FUNC! Bad rule code: %x vs %x", code, rp -> code);
            TRACE_VERB("<-%!FUNC! return=CVY_VERIFY_EXIT bad rule code");
            return CVY_VERIFY_EXIT;
        }

        if (rp -> start_port > CVY_MAX_PORT)
        {
            UNIV_PRINT_CRIT(("Params_verify: Bad value for rule parameter %s, %d <= %d <= %d", "StartPort", CVY_MIN_PORT, rp -> start_port, CVY_MAX_PORT));
            TRACE_CRIT("%!FUNC! Bad value for rule parameter %s, %d <= %d <= %d", "StartPort", CVY_MIN_PORT, rp -> start_port, CVY_MAX_PORT);
            TRACE_VERB("<-%!FUNC! return=CVY_VERIFY_EXIT a port rule has an out of range start_port");
            return CVY_VERIFY_EXIT;
        }

        if (rp -> end_port > CVY_MAX_PORT)
        {
            UNIV_PRINT_CRIT(("Params_verify: Bad value for rule parameter %s, %d <= %d <= %d", "EndPort", CVY_MIN_PORT, rp -> end_port, CVY_MAX_PORT));
            TRACE_CRIT("%!FUNC! Bad value for rule parameter %s, %d <= %d <= %d", "EndPort", CVY_MIN_PORT, rp -> end_port, CVY_MAX_PORT);
            TRACE_VERB("<-%!FUNC! return=CVY_VERIFY_EXIT a port rule has an out of range end_port");
            return CVY_VERIFY_EXIT;
        }

        if (rp -> protocol < CVY_MIN_PROTOCOL ||
            rp -> protocol > CVY_MAX_PROTOCOL)
        {
            UNIV_PRINT_CRIT(("Params_verify: Bad value for rule parameter %s, %d <= %d <= %d", "Protocol", CVY_MIN_PROTOCOL, rp -> protocol, CVY_MAX_PROTOCOL));
            TRACE_CRIT("%!FUNC! Bad value for rule parameter %s, %d <= %d <= %d", "Protocol", CVY_MIN_PROTOCOL, rp -> protocol, CVY_MAX_PROTOCOL);
            TRACE_VERB("<-%!FUNC! return=CVY_VERIFY_EXIT a port rule has an illegal protocol value");
            return CVY_VERIFY_EXIT;
        }

        if (rp -> mode < CVY_MIN_MODE ||
            rp -> mode > CVY_MAX_MODE)
        {
            UNIV_PRINT_CRIT(("Params_verify: Bad value for parameter %s, %d <= %d <= %d", "Mode", CVY_MIN_MODE, rp -> mode, CVY_MAX_MODE));
            TRACE_CRIT("%!FUNC! Bad value for parameter %s, %d <= %d <= %d", "Mode", CVY_MIN_MODE, rp -> mode, CVY_MAX_MODE);
            TRACE_VERB("<-%!FUNC! return=CVY_VERIFY_EXIT a port rule has an illegal mode value");
            return CVY_VERIFY_EXIT;
        }

#ifdef TRACE_PARAMS
        switch (rp -> protocol)
        {
            case CVY_TCP:
                prot = "TCP";
                break;

            case CVY_UDP:
                prot = "UDP";
                break;

            default:
                prot = "Both";
                break;
        }

        DbgPrint ("%08x %5d %5d %4s ", rp -> virtual_ip_addr, rp -> start_port, rp -> end_port, prot);
        TRACE_INFO("%!FUNC! 0x%08x %5d %5d %4s ", rp -> virtual_ip_addr, rp -> start_port, rp -> end_port, prot);
#endif

        switch (rp -> mode)
        {
            case CVY_SINGLE:

                if (rp -> mode_data . single . priority < CVY_MIN_PRIORITY ||
                    rp -> mode_data . single . priority > CVY_MAX_PRIORITY)
                {
                    UNIV_PRINT_CRIT(("Params_verify: Bad value for parameter %s, %d <= %d <= %d", "Priority", CVY_MIN_PRIORITY, rp -> mode_data . single . priority, CVY_MAX_PRIORITY));
                    TRACE_CRIT("%!FUNC! Bad value for parameter %s, %d <= %d <= %d", "Priority", CVY_MIN_PRIORITY, rp -> mode_data . single . priority, CVY_MAX_PRIORITY);
                    TRACE_VERB("<-%!FUNC! return=CVY_VERIFY_EXIT a single mode port rule has an illegal priority");
                    return CVY_VERIFY_EXIT;
                }

#ifdef TRACE_PARAMS
                DbgPrint ("%8s %3d\n", "Single", rp -> mode_data . single . priority);
                TRACE_INFO("%!FUNC! %8s %3d", "Single", rp -> mode_data . single . priority);
#endif
                break;

            case CVY_MULTI:

                if (rp -> mode_data . multi . affinity < CVY_MIN_AFFINITY ||
                    rp -> mode_data . multi . affinity > CVY_MAX_AFFINITY)
                {
                    UNIV_PRINT_CRIT(("Params_verify: Bad value for parameter %s, %d <= %d <= %d", "Affinity", CVY_MIN_AFFINITY, rp -> mode_data.multi.affinity, CVY_MAX_AFFINITY));
                    TRACE_CRIT("%!FUNC! Bad value for parameter %s, %d <= %d <= %d", "Affinity", CVY_MIN_AFFINITY, rp -> mode_data.multi.affinity, CVY_MAX_AFFINITY);
                    TRACE_VERB("<-%!FUNC! return=CVY_VERIFY_EXIT a multi mode port rule has an illegal affinity");
                    return CVY_VERIFY_EXIT;
                }

                if (rp -> mode_data . multi . affinity == CVY_AFFINITY_NONE)
                    aff = "None";
                else if (rp -> mode_data . multi . affinity == CVY_AFFINITY_SINGLE)
                    aff = "Single";
                else
                    aff = "Class C";

                if (rp -> mode_data . multi . equal_load)
                {
#ifdef TRACE_PARAMS
                    DbgPrint ("%8s %3s %4s %s\n", "Multiple", "", "Eql", aff);
                    TRACE_INFO("%!FUNC! %8s %3s %4s %s", "Multiple", "", "Eql", aff);
#endif
                }
                else
                {
                    if (rp -> mode_data . multi . load > CVY_MAX_LOAD)
                    {
                        UNIV_PRINT_CRIT(("Params_verify: Bad value for parameter %s, %d <= %d <= %d", "Load", CVY_MIN_LOAD, rp -> mode_data . multi . load, CVY_MAX_LOAD));
                        TRACE_CRIT("%!FUNC! Bad value for parameter %s, %d <= %d <= %d", "Load", CVY_MIN_LOAD, rp -> mode_data . multi . load, CVY_MAX_LOAD);
                        TRACE_VERB("<-%!FUNC! return=CVY_VERIFY_EXIT a multi mode port rule has an illegal load");
                        return CVY_VERIFY_EXIT;
                    }

#ifdef TRACE_PARAMS
                    DbgPrint ("%8s %3s %4d %s\n", "Multiple", "", rp -> mode_data . multi . load, aff);
                    TRACE_INFO("%!FUNC! %8s %3s %4d %s", "Multiple", "", rp -> mode_data . multi . load, aff);
#endif
                }

                break;

            default:

#ifdef TRACE_PARAMS
                DbgPrint ("%8s\n", "Disabled");
                TRACE_INFO("%!FUNC! %8s", "Disabled");
#endif
                break;
        }

        if (rp -> start_port > rp -> end_port)
        {
            UNIV_PRINT_CRIT(("Params_verify: Bad port range %d - %d", rp -> start_port, rp -> end_port));
            TRACE_CRIT("%!FUNC! Bad port range %d - %d", rp -> start_port, rp -> end_port);
            TRACE_VERB("<-%!FUNC! return=CVY_VERIFY_EXIT rule's start port is greater than its end port");
            return CVY_VERIFY_EXIT;
        }

        for (j = 0; j < i; j ++)
        {
            rulep = paramp -> port_rules + j;

            if ((rulep -> virtual_ip_addr == rp -> virtual_ip_addr) &&
                ((rulep -> start_port < rp -> start_port && rulep -> end_port >= rp -> start_port) ||
                 (rulep -> start_port >= rp -> start_port && rulep -> start_port <= rp -> end_port)))
            {
                UNIV_PRINT_CRIT(("Params_verify: Requested port range in rule %d VIP: %08x (%d - %d) overlaps with the range in an existing rule %d VIP: %08x (%d - %d)", 
                             i, rp -> virtual_ip_addr, rp -> start_port, rp -> end_port, j, rulep -> virtual_ip_addr, rulep -> start_port, rulep -> end_port));
                TRACE_CRIT("%!FUNC! Requested port range in rule %d VIP: %08x (%d - %d) overlaps with the range in an existing rule %d VIP: %08x (%d - %d)", 
                           i, rp -> virtual_ip_addr, rp -> start_port, rp -> end_port, j, rulep -> virtual_ip_addr, rulep -> start_port, rulep -> end_port);
                TRACE_VERB("<-%!FUNC! return=CVY_VERIFY_EXIT port rules overlap");
                return CVY_VERIFY_EXIT;
            }
        }
    }

    /* If teaming is active, check some required configuration. */
    if (paramp->bda_teaming.active) {
        /* If there is no team ID, bail out.  User-level stuff should ensure 
           that it is a GUID.  We'll just check for an empty string here. */
        if (paramp->bda_teaming.team_id[0] == L'\0') {
            UNIV_PRINT_CRIT(("Params_verify: BDA Teaming: Invalid Team ID (Empty)"));
            LOG_MSG(MSG_ERROR_BDA_PARAMS_TEAM_ID, MSG_NONE);
            paramp->bda_teaming.active = FALSE;
            TRACE_CRIT("%!FUNC! BDA Teaming: Invalid Team ID (Empty)");
            TRACE_VERB("<-%!FUNC! return=CVY_VERIFY_EXIT teaming active but no teaming GUID");
            return CVY_VERIFY_EXIT;
        }

        /* If there is more than one port rule, bail out.  None is fine. */
        if (paramp->num_rules > 1) {
            UNIV_PRINT_CRIT(("Params_verify: BDA Teaming: Invalid number of port rules specified (%d)", paramp->num_rules));
            LOG_MSG(MSG_ERROR_BDA_PARAMS_PORT_RULES, MSG_NONE);
            paramp->bda_teaming.active = FALSE;
            TRACE_CRIT("%!FUNC! BDA Teaming: Invalid number of port rules specified (%d)", paramp->num_rules);
            TRACE_VERB("<-%!FUNC! return=CVY_VERIFY_EXIT invalid number of port rules for teaming");
            return CVY_VERIFY_EXIT;
        }

        /* Since we are asserting that there are only 0 or 1 rules, we know that the only rule we need 
           to check (if there even is a rule), is at the beginning of the array, so we can simply set 
           a pointer to the beginning of the port rules array in the params structure. */
        rp = paramp->port_rules;

        /* If there is one rule and its multiple host filtering, the affinity must be single
           or class C.  If its not (that is, if its set to no affinity), bail out. */
        if ((paramp->num_rules == 1) && (rp->mode == CVY_MULTI)  && (rp->mode_data.multi.affinity == CVY_AFFINITY_NONE)) {
            UNIV_PRINT_CRIT(("Params_verify: BDA Teaming: Invalid affinity for multiple host filtering (None)"));
            LOG_MSG(MSG_ERROR_BDA_PARAMS_PORT_RULES, MSG_NONE);
            paramp->bda_teaming.active = FALSE;
            TRACE_CRIT("%!FUNC! BDA Teaming: Invalid affinity for multiple host filtering (None)");
            TRACE_VERB("<-%!FUNC! return=CVY_VERIFY_EXIT invalid affinity for multiple host filtering (None)");
            return CVY_VERIFY_EXIT;
        }
    }

#if defined (OPTIMIZE_FRAGMENTS)
    rulep = &(paramp->port_rules[0]);

    /* in optimized mode - if we have no rules, or a single rule that will
       not look at anything or only source IP address (the only exception to this
       is multiple handling mode with no affinity that also uses source port
       for its decision making) then we can just rely on normal mechanism to
       handle every fragmented packet - since algorithm will not attempt to
       look past the IP header.

       for multiple rules, or single rule with no affinity, apply algorithm only
       to the first packet that has UDP/TCP header and then let fragmented
       packets up on all of the systems. TCP will then do the right thing and
       throw away the fragments on all of the systems other than the one that
       handled the first fragment. */

    if (paramp->num_rules == 0 || (paramp->num_rules == 1 &&
        rulep->start_port == CVY_MIN_PORT &&
        rulep->end_port == CVY_MAX_PORT &&
        ! (rulep->mode == CVY_MULTI &&
           rulep->mode_data.multi.affinity == CVY_AFFINITY_NONE)))
    {
        ctxtp -> optimized_frags = TRUE;
#ifdef TRACE_PARAMS
        DbgPrint("IP fragmentation mode - OPTIMIZED\n");
        TRACE_INFO("%!FUNC! IP fragmentation mode - OPTIMIZED");
#endif
    }
    else
    {
        ctxtp -> optimized_frags = FALSE;
#ifdef TRACE_PARAMS
        DbgPrint("IP fragmentation mode - UNOPTIMIZED\n");
        TRACE_INFO("%!FUNC! IP fragmentation mode - UNOPTIMIZED");
#endif
    }
#endif

    TRACE_VERB("<-%!FUNC! return=CVY_VERIFY_OK");
    return CVY_VERIFY_OK;

} /* end Params_verify */

static NTSTATUS Params_query_registry (
    PVOID               nlbctxt,
    HANDLE              hdl,
    PWCHAR              name,
    PVOID               datap,
    ULONG               len)
{
    UNICODE_STRING      str;
    ULONG               actual;
    NTSTATUS            status;
    PUCHAR              buffer;
    PKEY_VALUE_PARTIAL_INFORMATION   valp = (PKEY_VALUE_PARTIAL_INFORMATION) infop;
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT)nlbctxt;

    TRACE_VERB("->%!FUNC! nlbctxt=0x%p, hdl=0x%p, name=0x%p, len=%u", nlbctxt, hdl, name, len);

    RtlInitUnicodeString (& str, name);

    status = ZwQueryValueKey (hdl, & str, KeyValuePartialInformation, infop,
                              PARAMS_INFO_BUF_SIZE, & actual);

    if (status != STATUS_SUCCESS)
    {
        if (status == STATUS_OBJECT_NAME_NOT_FOUND)
        {
            /* All registry operations occur at PASSIVE_LEVEL - %ls is OK. */
            UNIV_PRINT_INFO(("Params_query_registry: Error %x querying value %ls", status, name));
            TRACE_INFO("%!FUNC! Error 0x%x querying value %ls", status, name);
        }
        else
        {
            /* All registry operations occur at PASSIVE_LEVEL - %ls is OK. */
            UNIV_PRINT_CRIT(("Params_query_registry: Error %x querying value %ls", status, name));
            TRACE_CRIT("%!FUNC! Error 0x%x querying value %ls", status, name);
        }
        TRACE_VERB("<-%!FUNC! return=0x%x querying value", status);
        return status;
    }

    if (valp -> Type == REG_DWORD)
    {
        if (valp -> DataLength != sizeof (ULONG))
        {
            UNIV_PRINT_CRIT(("Params_query_registry: Bad DWORD length %d", valp -> DataLength));
            TRACE_CRIT("%!FUNC! Bad DWORD length %d", valp -> DataLength);
            TRACE_VERB("<-%!FUNC! return=STATUS_OBJECT_NAME_NOT_FOUND dword");
            return STATUS_OBJECT_NAME_NOT_FOUND;
        }

        * ((PULONG) datap) = * ((PULONG) valp -> Data);
    }
    else if (valp -> Type == REG_BINARY)
    {
        /* since we know that only port rules are of binary type - check
           the size here */

        if (valp -> DataLength > len)
        {
            UNIV_PRINT_CRIT(("Params_query_registry: Bad BINARY length %d", valp -> DataLength));

#if defined (NLB_TCP_NOTIFICATION)
            /* The context pointer may be NULL, so only use LOG_MSG2 if its non-NULL. */
            if (!ctxtp)
                __LOG_MSG2(MSG_ERROR_INTERNAL, MSG_NONE, valp -> DataLength, sizeof (CVY_RULE) * (CVY_MAX_RULES - 1));
            else
#endif
                LOG_MSG2(MSG_ERROR_INTERNAL, MSG_NONE, valp -> DataLength, sizeof (CVY_RULE) * (CVY_MAX_RULES - 1));

            TRACE_CRIT("%!FUNC! Bad BINARY length %d", valp -> DataLength);
            TRACE_VERB("<-%!FUNC! return=STATUS_OBJECT_NAME_NOT_FOUND binary");
            return STATUS_OBJECT_NAME_NOT_FOUND;
        }

        RtlCopyMemory (datap, valp -> Data, valp -> DataLength);
    }
    else
    {
        if (valp -> DataLength == 0)
        {
            /* simulate an empty string */

            valp -> DataLength = 2;
            valp -> Data [0] = 0;
            valp -> Data [1] = 0;
        }

        if (valp -> DataLength > len)
        {
            /* All registry operations occur at PASSIVE_LEVEL - %ls is OK. */
            UNIV_PRINT_CRIT(("Params_query_registry: String too big for %ls %d %d\n", name, valp -> DataLength, len));
            TRACE_CRIT("%!FUNC! String too big for %ls %d %d", name, valp -> DataLength, len);
        }

        RtlCopyMemory (datap, valp -> Data,
                       valp -> DataLength <= len ?
                       valp -> DataLength : len);
    }

    TRACE_VERB("<-%!FUNC! return=0x%x", status);
    return status;

} /* end Params_query_registry */

/* 
 * Function: Params_set_registry
 * Desctription: Sets the value of a registry entry in the given key, specified
 *               by the input HANDLE.
 * Parameters: 
 * Returns: Nothing
 * Author: shouse, 7.13.01
 * Notes: 
 */
static NTSTATUS Params_set_registry (
    PVOID               nlbctxt,
    HANDLE              hdl,
    PWCHAR              name,
    PVOID               datap,
    ULONG               type,
    ULONG               len)
{
    NTSTATUS            status;
    UNICODE_STRING      value;
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT)nlbctxt;

    RtlInitUnicodeString(&value, name);
    
    /* Set the InitialState registry key to the new value. */
    status = ZwSetValueKey(hdl, &value, 0, type, datap, len);
    
    /* If it fails, there's not much we can do - bail out. */
    if (status != STATUS_SUCCESS) {
        UNIV_PRINT_CRIT(("Params_set_registry: Error 0x%08x -> Unable to set registry value... Exiting...", status));
    } else {
        UNIV_PRINT_VERB(("Params_set_registry: Registry value updated... Exiting..."));
    }

    return status;
}

#if defined (NLB_TCP_NOTIFICATION)
#define ISA_INSTALLATION_REG_PATH L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Services\\W3Proxy"
#define ISA_INSTALLATION_KEY      L"ImagePath"

/* 
 * Function: Params_read_isa_installation
 * Desctription: Looks for a set of registry keys and values attempting to 
 *               determine whether or not ISA (not Stingray) is currently 
 *               installed.  If so, we'll end up turning off TCP notifications 
 *               to circumvent the NAT problems.  If Stingray is installed,
 *               they will notify us, through a registry key, to start using
 *               the NLB public connection notifications to maintain state.
 * Parameters: None.
 * Returns: BOOLEAN - if TRUE, ISA 2000 is installed.
 * Author: shouse, 7.29.02
 * Notes: 
 */
BOOLEAN Params_read_isa_installation (VOID)
{
    UNICODE_STRING    reg_path;
    OBJECT_ATTRIBUTES reg_obj;
    HANDLE            reg_hdl = NULL;
    WCHAR             szValue[CVY_MAX_REG_PATH];
    BOOLEAN           bInstalled = FALSE;
    NTSTATUS          status = STATUS_SUCCESS;

    TRACE_VERB("->%!FUNC!");

    /* All registry operations occur at PASSIVE_LEVEL - %ls is OK. */
    UNIV_PRINT_VERB(("Params_read_isa_installation: ISA installation registry path: %ls", ISA_INSTALLATION_REG_PATH));
    TRACE_VERB("%!FUNC! ISA installation registry path: %ls", ISA_INSTALLATION_REG_PATH);

    RtlInitUnicodeString(&reg_path, (PWSTR)ISA_INSTALLATION_REG_PATH);
    InitializeObjectAttributes(&reg_obj, &reg_path, 0, NULL, NULL);
    
    /* Open the key.  Failure is acceptable; assume that ISA is not installed. */
    status = ZwOpenKey(&reg_hdl, KEY_READ, &reg_obj);
    
    /* If we can't open this key, return here. */
    if (status != STATUS_SUCCESS)
        goto exit;

    /* If we were able to open this registry key, then either ISA 2000 or ISA Stingray
       is installed; Try to get the ImagePath registry value. */
    status = Params_query_registry(NULL, reg_hdl, ISA_INSTALLATION_KEY, szValue, sizeof(szValue));

    /* If we couldn't read this value, ISA 2000 is NOT installed; must be Stingray. */
    if (status != STATUS_SUCCESS)
    {
        /* Close the ISA installation registry key. */
        status = ZwClose(reg_hdl);
        goto exit;
    }

    /* Close the ISA installation registry key. */
    status = ZwClose(reg_hdl);

    /* ISA 2000 is installed. */
    bInstalled = TRUE;

 exit:

    /* All registry operations occur at PASSIVE_LEVEL - %ls is OK. */
    UNIV_PRINT_INFO(("Params_read_isa_installation: ISA is %ls", (bInstalled) ? L"installed" : L"not installed"));
    TRACE_INFO("%!FUNC! ISA is %ls", (bInstalled) ? L"installed" : L"not installed");

    return bInstalled;
}

/* 
 * Function: Params_read_tcp_notification
 * Desctription: Looks for a global NLB registry to turn TCP notification on or
 *               off.  By default the key does NOT EVEN EXIST, so this is only
 *               a method by which to alter the hard-coded default (ON).
 * Parameters: None.
 * Returns: NTSTATUS - the status of the registry operations.
 * Author: shouse, 4.29.02
 * Notes: Keep in mind that the registry key setting will over-ride the detection of ISA
 *        2000.  The only real consequence of this is that in RC1, we told customers to
 *        set this registry key manually (to zero) as a workaround.  So, when they upgrade
 *        to RC2 and beyond, the registry key will presumably still exist.  So long as ISA
 *        is still installed, this will operate just fine; we'll turn off TCP notification 
 *        and cleanup as a result of BOTH detecting ISA and reading the registry key.  How-
 *        ever, if ISA is uninstalled and the server is intended to be used for normal IIS
 *        load-balancing, for example, the registry key will still be telling NLB to use the
 *        "less good" way to track TCP connections.  In this case we will at least be querying
 *        TCP for connection cleanup, which should help alleviate SOME of the problems with 
 *        the conventional TCP connection tracking that will be used in this case.  Just FYI.
 */
NTSTATUS Params_read_notification (VOID)
{
    UNICODE_STRING    reg_path;
    OBJECT_ATTRIBUTES reg_obj;
    HANDLE            reg_hdl = NULL;
    NTSTATUS          status = STATUS_SUCCESS;

    TRACE_VERB("->%!FUNC!");

    /* In case the registry key does not exist, make the preferred state of 
       connection notifications the default value. */
    univ_notification = NLB_CONNECTION_CALLBACK_TCP;

    /* By default, we will query TCP in order to clean out stale TCP connection state. */
    univ_tcp_cleanup = TRUE;

    /* Check to see whether or not ISA is installed.  If so, then turn off both 
       TCP notifications and TCP cleanup, as TCP will probably NOT have the same
       state as NLB for most connections, due to ISA NAT'ing the traffic. */
    if (Params_read_isa_installation())
    {
        UNIV_PRINT_INFO(("Params_read_tcp_notification: NLB has determined that ISA is installed on this server.  TCP notifications and cleanup will be disabled."));
        TRACE_INFO("%!FUNC! NLB has determined that ISA is installed on this server.  TCP notifications and cleanup will be disabled.");

        /* Turn off TCP notifications and cleanup. */
        univ_notification = NLB_CONNECTION_CALLBACK_NONE;
        univ_tcp_cleanup = FALSE;
    }

    /* All registry operations occur at PASSIVE_LEVEL - %ls is OK. */
    UNIV_PRINT_VERB(("Params_read_tcp_notification: NLB global parameters registry path: %ls", NLB_GLOBAL_REG_PATH));
    TRACE_VERB("%!FUNC! NLB global parameters registry path: %ls", NLB_GLOBAL_REG_PATH);

    RtlInitUnicodeString(&reg_path, (PWSTR)NLB_GLOBAL_REG_PATH);
    InitializeObjectAttributes(&reg_obj, &reg_path, 0, NULL, NULL);
    
    /* Open the key - failure is acceptable (just return the default value we've already set). 
       In reality, if we're being loaded but the Services\WLBS registry key is missing, something
       is wrong, but we don't need to gripe here (we're called from DriverEntry); let out exisiting
       registry checks complain later. */
    status = ZwOpenKey(&reg_hdl, KEY_READ, &reg_obj);
    
    /* If we can't open this key, return here. */
    if (status != STATUS_SUCCESS)
    {
        /* All registry operations occur at PASSIVE_LEVEL - %ls is OK. */
        UNIV_PRINT_VERB(("Params_read_tcp_notification: Error 0x%08x -> Unable to open the NLB global parameters registry key", status));
        TRACE_VERB("%!FUNC! Error 0x%08x -> Unable to open the NLB global paramters registry key", status);

        goto exit;
    }

    /* Get the TCP notification enabled value from the registry.  Failure is acceptable. */
    status = Params_query_registry(NULL, reg_hdl, NLB_CONNECTION_CALLBACK_KEY, &univ_notification, sizeof(ULONG));

    /* If we couldn't read the value, just move on and use the value we've determined thusfar. */
    if (status != STATUS_SUCCESS)
    {
        UNIV_PRINT_VERB(("Params_read_tcp_notification: Error 0x%08x -> Unable to read %ls", status, NLB_CONNECTION_CALLBACK_KEY));
        TRACE_VERB("%!FUNC! Error 0x%08x -> Unable to read %ls", status, NLB_CONNECTION_CALLBACK_KEY);

        /* Close the key for WLBS global parameters. */
        status = ZwClose(reg_hdl);
        goto exit;
    }

    /* Close the key for WLBS global parameters. */
    status = ZwClose(reg_hdl);

    /* Make sure the value is within the range by the time we leave. If 
       the key contains garbage, revert to the default setting. */
    if (univ_notification > NLB_CONNECTION_CALLBACK_ALTERNATE)
    {
        UNIV_PRINT_INFO(("Params_read_tcp_notification: Invalid notification setting; NLB will revert to the default setting"));
        TRACE_INFO("%!FUNC! Invalid notification setting; NLB will revert to the default setting");

        univ_notification = NLB_CONNECTION_CALLBACK_TCP;
    }

    /* If TCP notifications are on, TCP cleanup should/can also be on. 
       This may have been turned off if we detected ISA.  Since the 
       registry key over-rides the ISA 2000 detection, we may end up
       turning TCP connection notification and cleanup back on even
       though ISA is there; if connections are NAT'd, we won't be 
       able to properly track the TCP connections.  However, turning
       cleanup back on in this case doesn't make the situation any 
       WORSE, and it simplifies the logic herein. */
    if (univ_notification == NLB_CONNECTION_CALLBACK_TCP)
        univ_tcp_cleanup = TRUE;
    /* Otherwise, if we're specifically using non-TCP notifications for
       connection maintenance, then we don't want to poll TCP for 
       connection cleanup purposes.  The reason that we cannot poll TCP
       for TCP connection cleanup is because TCP may or may not even 
       have state for this connection.  For example, in an ISA/Stingray
       IP forwarding setup, IP packets are forwarded in the IP layer, 
       never reaching TCP at all.  However, ISA needs NLB to track these
       connections, so we get connection notifications for these forwarded
       TCP connections.  If we were to poll TCP for an "update", it would
       tell us that no such connection exists, and we'd end up prematurely
       destroying the state to track these connections. */
    else if (univ_notification == NLB_CONNECTION_CALLBACK_ALTERNATE)
        univ_tcp_cleanup = FALSE;

 exit:

    /* All registry operations occur at PASSIVE_LEVEL - %ls is OK. */
    UNIV_PRINT_INFO(("Params_read_tcp_notification: Connection notification = %ls", 
                     (univ_notification == NLB_CONNECTION_CALLBACK_TCP) ? L"TCP" : (univ_notification == NLB_CONNECTION_CALLBACK_ALTERNATE) ? L"NLB public" : L"OFF"));
    TRACE_INFO("%!FUNC! TCP connection notification is %ls",
               (univ_notification == NLB_CONNECTION_CALLBACK_TCP) ? L"TCP" : (univ_notification == NLB_CONNECTION_CALLBACK_ALTERNATE) ? L"NLB public" : L"OFF");

    /* All registry operations occur at PASSIVE_LEVEL - %ls is OK. */
    UNIV_PRINT_INFO(("Params_read_tcp_notification: TCP connection cleanup = %ls", (univ_tcp_cleanup) ? L"ON" : L"OFF"));
    TRACE_INFO("%!FUNC! TCP connection cleanup is %ls", (univ_tcp_cleanup) ? L"ON" : L"OFF");

    TRACE_VERB("<-%!FUNC! return=STATUS_SUCCESS");
    return STATUS_SUCCESS;
}
#endif

/* 
 * Function: Params_set_host_state
 * Desctription: This function is called as the result of a work item callback and
 *               is used to set the current state of the host in the HostState
 *               registry key.  This is necessary because registry manipulation
 *               MUST occur at <= PASSIVE_LEVEL, so we can't do this inline, where
 *               much of our code runs at DISPATCH_LEVEL.
 * Parameters: pWorkItem - the NDIS work item pointer
 *             nlbctxt - the context for the callbecak; this is our MAIN_CTXT pointer
 * Returns: Nothing
 * Author: shouse, 7.13.01
 * Notes: Note that the code that sets up this work item MUST increment the reference
 *        count on the adapter context BEFORE adding the work item to the queue.  This
 *        ensures that when this callback is executed, the context will stiil be valid,
 *        even if an unbind operation is pending.  This function must free the work
 *        item memory and decrement the reference count - both, whether this function
 *        can successfully complete its task OR NOT.
 */
VOID Params_set_host_state (PNDIS_WORK_ITEM pWorkItem, PVOID nlbctxt) {
    WCHAR              reg_path[CVY_MAX_REG_PATH];
    NTSTATUS           status;
    UNICODE_STRING     key;
    UNICODE_STRING     path;
    OBJECT_ATTRIBUTES  obj;
    KIRQL              irql;
    HANDLE             hdl = NULL;
    PMAIN_ADAPTER      adapterp;
    PMAIN_CTXT         ctxtp = (PMAIN_CTXT)nlbctxt;

    /* Do some sanity checking on the context - make sure that the MAIN_CTXT code 
       is correct and that its properly attached to an adapter, etc. */
    UNIV_ASSERT(ctxtp->code == MAIN_CTXT_CODE);

    adapterp = &(univ_adapters[ctxtp->adapter_id]);

    UNIV_ASSERT(adapterp->code == MAIN_ADAPTER_CODE);
    UNIV_ASSERT(adapterp->ctxtp == ctxtp);

    /* Might as well free the work item now - we don't need it. */
    if (pWorkItem)
        NdisFreeMemory(pWorkItem, sizeof(NDIS_WORK_ITEM), 0);

    /* This shouldn't happen, but protect against it anyway - we cannot manipulate
       the registry if we are at an IRQL > PASSIVE_LEVEL, so bail out. */
    if ((irql = KeGetCurrentIrql()) > PASSIVE_LEVEL) {
        UNIV_PRINT_CRIT(("Params_set_host_state: Error -> IRQL (%u) > PASSIVE_LEVEL (%u) ... Exiting...", irql, PASSIVE_LEVEL));
        LOG_MSG(MSG_WARN_HOST_STATE_UPDATE, CVY_NAME_HOST_STATE);
        goto exit;
    }

    /* Make sure that our buffer is sufficiently large to hold the registry path. */
    UNIV_ASSERT(wcslen((PWSTR)univ_reg_path) + wcslen((PWSTR)(adapterp->device_name + 8)) + 1 <= CVY_MAX_REG_PATH);

    /* Build the registry path - "...\Services\WLBS\Interface\". */
    status = StringCchCopy(reg_path, CVY_MAX_REG_PATH, (PWSTR)univ_reg_path);

    if (FAILED(status)) {
        UNIV_PRINT_CRIT(("Params_set_host_state: Error 0x%08x -> Unable to copy NLB registry path... Exiting...", status));
        LOG_MSG(MSG_WARN_HOST_STATE_UPDATE, CVY_NAME_HOST_STATE);
        goto exit;
    }

    /* Append the adapter GUID to the registry path - "...\Services\WLBS\Interface\{GUID}". */
    status = StringCchCat(reg_path, CVY_MAX_REG_PATH, (PWSTR)(adapterp->device_name + 8));

    if (FAILED(status)) {
        UNIV_PRINT_CRIT(("Params_set_host_state: Error 0x%08x -> Unable to cat the adapter GUID onto the registry path... Exiting...", status));
        LOG_MSG(MSG_WARN_HOST_STATE_UPDATE, CVY_NAME_HOST_STATE);
        goto exit;
    }

    RtlInitUnicodeString(&path, reg_path);
    
    InitializeObjectAttributes(&obj, &path, 0, NULL, NULL);
    
    /* Open the parameters key for this adapter. */
    status = ZwOpenKey(&hdl, KEY_WRITE, &obj);
    
    /* If opening the key fails, just bail out. */
    if (status != STATUS_SUCCESS) {
        UNIV_PRINT_CRIT(("Params_set_host_state: Error 0x%08x -> Unable to open registry key... Exiting...", status));
        LOG_MSG(MSG_WARN_HOST_STATE_UPDATE, CVY_NAME_HOST_STATE);
        goto exit;
    }
    
    status = Params_set_registry(nlbctxt, hdl, CVY_NAME_HOST_STATE, &ctxtp->cached_state, REG_DWORD, sizeof(ULONG));
    
    /* If it fails, there's not much we can do - bail out. */
    if (status != STATUS_SUCCESS) {
        UNIV_PRINT_CRIT(("Params_set_host_state: Error 0x%08x -> Unable to set initial state value... Exiting...", status));
        LOG_MSG(MSG_WARN_HOST_STATE_UPDATE, CVY_NAME_HOST_STATE);
        ZwClose(hdl);
        goto exit;
    }

    /* Close the key. */
    ZwClose(hdl);

    /* Set the initial state to the cached value. */
    ctxtp->params.init_state = ctxtp->cached_state;

    UNIV_PRINT_VERB(("Params_set_host_state: Initial state updated... Exiting..."));
    LOG_MSG(MSG_INFO_HOST_STATE_UPDATED, MSG_NONE);

 exit:

    /* If the work item pointer is non-NULL, then we were called as the result of 
       scheduling an NDIS work item.  In that case, the reference count on the 
       context was incremented to ensure that the context did not disappear before
       this work item was completed; therefore, we need to decrement the reference
       count here.  If the work item pointer is NULL, then this function was called
       internally directly.  In that case, the reference count was not incremented 
       and therefore there is no need to decrement it here.

       Note that if the function is called internally, but without setting the work
       item parameter to NULL, the reference count will be skewed and may cause 
       either invalid memory references later or block unbinds from completing. */
    if (pWorkItem)
        Main_release_reference(ctxtp);

    return;
}

LONG Params_read_portrules (PVOID nlbctxt, PWCHAR reg_path, PCVY_PARAMS paramp) {
    ULONG             dwTemp;
    ULONG             pr_index;
    ULONG             pr_reg_path_length;
    WCHAR             pr_reg_path[CVY_MAX_REG_PATH];
    WCHAR             pr_number[CVY_MAX_PORTRULE_DIGITS];
    UNICODE_STRING    pr_path;
    OBJECT_ATTRIBUTES pr_obj;
    HANDLE            pr_hdl = NULL;
    NTSTATUS          status = STATUS_SUCCESS;
    NTSTATUS          final_status = STATUS_SUCCESS;
    PMAIN_CTXT        ctxtp = (PMAIN_CTXT)nlbctxt;

    TRACE_VERB("->%!FUNC! nlbctxt=0x%p, reg_path=0x%p, paramp=0x%p", nlbctxt, reg_path, paramp);

    /* Make sure that we have AT LEAST 12 WCHARs left for the port rule path information (\ + PortRules + \ + NUL). */
    UNIV_ASSERT(wcslen(reg_path) < (CVY_MAX_REG_PATH - wcslen(CVY_NAME_PORT_RULES) - 3));

    /* Create the "static" portion of the registry, which begins "...\Services\WLBS\Interface\{GUID}". */
    status = StringCchCopy(pr_reg_path, CVY_MAX_REG_PATH, (PWSTR)reg_path);

    if (FAILED(status)) {
        UNIV_PRINT_CRIT(("Params_read_portrules: Error 0x%08x -> Unable to copy NLB settings registry path... Exiting...", status));
        final_status = status;
        goto exit;
    }

    /* Add a backslash to the port rule registry path. */
    status = StringCchCat(pr_reg_path, CVY_MAX_REG_PATH, (PWSTR)L"\\");

    if (FAILED(status)) {
        UNIV_PRINT_CRIT(("Params_read_portrules: Error 0x%08x -> Unable to cat \\ onto the registry path... Exiting...", status));
        final_status = status;
        goto exit;
    }

    /* Add "PortRules" subkey to the registry path. */
    status = StringCchCat(pr_reg_path, CVY_MAX_REG_PATH, (PWSTR)CVY_NAME_PORT_RULES);

    if (FAILED(status)) {
        UNIV_PRINT_CRIT(("Params_read_portrules: Error 0x%08x -> Unable to cat PortRules onto the registry path... Exiting...", status));
        final_status = status;
        goto exit;
    }

    /* Add a backslash to the port rule registry path. */
    status = StringCchCat(pr_reg_path, CVY_MAX_REG_PATH, (PWSTR)L"\\");

    if (FAILED(status)) {
        UNIV_PRINT_CRIT(("Params_read_portrules: Error 0x%08x -> Unable to cat \\ onto the registry path... Exiting...", status));
        final_status = status;
        goto exit;
    }
    
    /* Get the length of this string - this is the placeholder where we will sprintf in the rule numbers each time. */
    pr_reg_path_length = wcslen(pr_reg_path);
    
    /* Make sure that we have AT LEAST 3 WCHARs left for the port rule number and the NUL character (XX + NUL). */
    UNIV_ASSERT(pr_reg_path_length < (CVY_MAX_REG_PATH - 3));

    /* Loop through each port rule in the port rules tree. */
    for (pr_index = 0; pr_index < paramp->num_rules; pr_index++) {
        /* Sprintf the port rule number (+1) into the registry path key after the "PortRules\". */
        status = StringCchPrintf(pr_number, CVY_MAX_PORTRULE_DIGITS, L"%d", pr_index + 1);

        if (FAILED(status)) {
            UNIV_PRINT_CRIT(("Params_read_portrules: Error 0x%08x -> Unable to construct port rule number string (%u)... Exiting...", status, pr_index + 1));
            final_status = status;
            continue;
        }

        /* Overwrite the port rule number, "...\{GUID}\PortRules\N" each time through the loop. */
        status = StringCchCopy(pr_reg_path + pr_reg_path_length, CVY_MAX_REG_PATH - pr_reg_path_length, (PWSTR)pr_number);
        
        if (FAILED(status)) {
            UNIV_PRINT_CRIT(("Params_read_portrules: Error 0x%08x -> Unable to complete the specific port rule registry path (%u)... Exiting...", status, pr_index + 1));
            final_status = status;
            continue;
        }
        
        /* All registry operations occur at PASSIVE_LEVEL - %ls is OK. */
        UNIV_PRINT_VERB(("Params_read_portrules: Port rule registry path: %ls", pr_reg_path));
        TRACE_VERB("%!FUNC! Port rule registry path: %ls", pr_reg_path);
        
        RtlInitUnicodeString(&pr_path, pr_reg_path);
        InitializeObjectAttributes(&pr_obj, &pr_path, 0, NULL, NULL);
        
        /* Open the key - upon failure, bail out below. */
        status = ZwOpenKey(&pr_hdl, KEY_READ, &pr_obj);
         
        /* If we can't open this key, note FAILURE and continue to the next rule. */
        if (status != STATUS_SUCCESS) {
            UNIV_PRINT_CRIT(("Params_read_portrules: Error 0x%08x -> Unable to open the specific port rule registry key (%u)... Exiting...", status, pr_index + 1));
            final_status = status;
            continue;
        }

        /* Read the rule (error checking) code for the port rule. */
        status = Params_query_registry(nlbctxt, pr_hdl, CVY_NAME_CODE, &paramp->port_rules[pr_index].code, sizeof(paramp->port_rules[pr_index].code));
            
        if (status != STATUS_SUCCESS)
            final_status = status;

        {
            WCHAR szTemp[CVY_MAX_VIRTUAL_IP_ADDR + 1];
            PWCHAR pTemp = szTemp;
            ULONG dwOctets[4];
            ULONG cIndex;

            /* Read the virtual IP address to which this rule applies. */
            status = Params_query_registry(nlbctxt, pr_hdl, CVY_NAME_VIP, szTemp, sizeof(szTemp));
            
            if (status != STATUS_SUCCESS) {
                final_status = status;
            } else {
                for (cIndex = 0; cIndex < 4; cIndex++, pTemp++) {
                    if (!Univ_str_to_ulong(dwOctets + cIndex, pTemp, &pTemp, 3, 10) || (cIndex < 3 && *pTemp != L'.')) {
                        UNIV_PRINT_CRIT(("Params_read_portrules: Bad virtual IP address"));
                        TRACE_CRIT("%!FUNC! Bad virtual IP address");
                        final_status = STATUS_INVALID_PARAMETER;
                        break;
                    }
                }
            }
            
            IP_SET_ADDR(&paramp->port_rules[pr_index].virtual_ip_addr, dwOctets[0], dwOctets[1], dwOctets[2], dwOctets[3]);
        }

        /* Read the start port. */
        status = Params_query_registry(nlbctxt, pr_hdl, CVY_NAME_START_PORT, &paramp->port_rules[pr_index].start_port, sizeof(paramp->port_rules[pr_index].start_port));
            
        if (status != STATUS_SUCCESS)
            final_status = status;

        /* Read the end port. */
        status = Params_query_registry(nlbctxt, pr_hdl, CVY_NAME_END_PORT, &paramp->port_rules[pr_index].end_port, sizeof(paramp->port_rules[pr_index].end_port));
            
        if (status != STATUS_SUCCESS)
            final_status = status;

        /* Read the protocol(s) to which this rule applies. */
        status = Params_query_registry(nlbctxt, pr_hdl, CVY_NAME_PROTOCOL, &paramp->port_rules[pr_index].protocol, sizeof(paramp->port_rules[pr_index].protocol));
            
        if (status != STATUS_SUCCESS)
            final_status = status;

        /* Read the filtering mode - single host, multiple host or disabled. */
        status = Params_query_registry(nlbctxt, pr_hdl, CVY_NAME_MODE, &paramp->port_rules[pr_index].mode, sizeof(paramp->port_rules[pr_index].mode));
            
        if (status != STATUS_SUCCESS)
            final_status = status;

        /* Based on the mode, get the rest of the parameters. */
        switch (paramp->port_rules[pr_index].mode) {
        case CVY_SINGLE:
            /* Read the single host filtering priority. */
            status = Params_query_registry(nlbctxt, pr_hdl, CVY_NAME_PRIORITY, &paramp->port_rules[pr_index].mode_data.single.priority, sizeof(paramp->port_rules[pr_index].mode_data.single.priority));
                
            if (status != STATUS_SUCCESS)
                final_status = status;

            break;
        case CVY_MULTI:
            /* Read the equal load flag for the multiple host filtering rule.  Because this parameter is a DWORD in the registry and
               a USHORT in our parameters structure, we read it into a temporary variable and then copy to our parameters upon success. */ 
            status = Params_query_registry(nlbctxt, pr_hdl, CVY_NAME_EQUAL_LOAD, &dwTemp, sizeof(dwTemp));
                
            if (status != STATUS_SUCCESS)
                final_status = status;
            else 
                paramp->port_rules[pr_index].mode_data.multi.equal_load = (USHORT)dwTemp;

            /* Read the explicit load distribution for multiple host filtering. */
            status = Params_query_registry(nlbctxt, pr_hdl, CVY_NAME_LOAD, &paramp->port_rules[pr_index].mode_data.multi.load, sizeof(paramp->port_rules[pr_index].mode_data.multi.load));
                
            if (status != STATUS_SUCCESS)
                final_status = status;

            /* Read the affinity setting for multiple host filtering. Because this parameter is a DWORD in the registry and
               a USHORT in our parameters structure, we read it into a temporary variable and then copy to our parameters upon success. */ 
            status = Params_query_registry(nlbctxt, pr_hdl, CVY_NAME_AFFINITY, &dwTemp, sizeof(dwTemp));
                
            if (status != STATUS_SUCCESS)
                final_status = status;
            else 
                paramp->port_rules[pr_index].mode_data.multi.affinity = (USHORT)dwTemp;

            break;
        }            

        /* Close the key for this rule. */
        status = ZwClose(pr_hdl);
            
        if (status != STATUS_SUCCESS)
            final_status = status;
    }

 exit:

    TRACE_VERB("<-%!FUNC! return=0x%x", final_status);
    return final_status;
}

LONG Params_read_teaming (PVOID nlbctxt, PWCHAR reg_path, PCVY_PARAMS paramp) {
    WCHAR             bda_reg_path[CVY_MAX_REG_PATH];
    UNICODE_STRING    bda_path;
    OBJECT_ATTRIBUTES bda_obj;
    HANDLE            bda_hdl = NULL;
    NTSTATUS          status = STATUS_SUCCESS;
    NTSTATUS          final_status = STATUS_SUCCESS;
    PMAIN_CTXT        ctxtp = (PMAIN_CTXT)nlbctxt;

    TRACE_VERB("->%!FUNC! nlbctxt=0x%p, reg_path=0x%p, paramp=0x%p", nlbctxt, reg_path, paramp);

    /* Make sure that we have AT LEAST 12 WCHARs left for the BDA teaming path information (\ + BDATeaming + NUL). */
    UNIV_ASSERT(wcslen(reg_path) < (CVY_MAX_REG_PATH - wcslen(CVY_NAME_BDA_TEAMING) - 2));

    /* Create the "static" portion of the registry path, which begins "...\Services\WLBS\Interface\{GUID}". */
    status = StringCchCopy(bda_reg_path, CVY_MAX_REG_PATH, (PWSTR)reg_path);

    if (FAILED(status)) {
        UNIV_PRINT_CRIT(("Params_read_teaming: Error 0x%08x -> Unable to copy NLB settings registry path... Exiting...", status));
        final_status = status;
        goto exit;
    }

    /* Add a backslash to the port rule registry path. */
    status = StringCchCat(bda_reg_path, CVY_MAX_REG_PATH, (PWSTR)L"\\");

    if (FAILED(status)) {
        UNIV_PRINT_CRIT(("Params_read_teaming: Error 0x%08x -> Unable to cat \\ onto the registry path... Exiting...", status));
        final_status = status;
        goto exit;
    }

    /* Add "BDATeaming" subkey to the registry path. */
    status = StringCchCat(bda_reg_path, CVY_MAX_REG_PATH, (PWSTR)CVY_NAME_BDA_TEAMING);

    if (FAILED(status)) {
        UNIV_PRINT_CRIT(("Params_read_teaming: Error 0x%08x -> Unable to cat BDATeaming onto the registry path... Exiting...", status));
        final_status = status;
        goto exit;
    }

    /* All registry operations occur at PASSIVE_LEVEL - %ls is OK. */
    UNIV_PRINT_VERB(("Params_read_teaming: BDA teaming registry path: %ls", bda_reg_path));
    TRACE_VERB("%!FUNC! BDA teaming registry path: %ls", bda_reg_path);
        
    RtlInitUnicodeString(&bda_path, bda_reg_path);
    InitializeObjectAttributes(&bda_obj, &bda_path, 0, NULL, NULL);
    
    /* Open the key - failure is acceptable and means that this adapter is not part of a BDA team. */
    status = ZwOpenKey(&bda_hdl, KEY_READ, &bda_obj);
    
    /* If we can't open this key, return here. */
    if (status != STATUS_SUCCESS) {
        /* If we couldn't find the key, that's fine - it might not exist. */
        if (status == STATUS_OBJECT_NAME_NOT_FOUND)
        {
            TRACE_VERB("<-%!FUNC! return=STATUS_SUCCESS (optional) key not found");
            return STATUS_SUCCESS;
        }
        /* Otherwise, there was a legitimate error. */
        else
        {
            /* All registry operations occur at PASSIVE_LEVEL - %ls is OK. */
            UNIV_PRINT_CRIT(("Params_read_teaming: Error 0x%08x -> Unable to open the BDA teaming registry key... Exiting...", status));
            TRACE_CRIT("%!FUNC! Error 0x%08x -> Unable to open the BDA teaming registry key... Exiting...", status);

            final_status = status; 
            goto exit;
        }
    }

    /* If we were able to open the registry key, then this adapter is part of a BDA team. */
    paramp->bda_teaming.active = TRUE;

    /* Read the team ID from the registry - this is a GUID. */
    status = Params_query_registry (nlbctxt, bda_hdl, CVY_NAME_BDA_TEAM_ID, &paramp->bda_teaming.team_id, sizeof(paramp->bda_teaming.team_id));

    if (status != STATUS_SUCCESS)
        final_status = status;

    /* Get the boolean indication of whether or not this adapter is the master for the team. */
    status = Params_query_registry (nlbctxt, bda_hdl, CVY_NAME_BDA_MASTER, &paramp->bda_teaming.master, sizeof(paramp->bda_teaming.master));

    if (status != STATUS_SUCCESS)
        final_status = status;

    /* Get the boolean indication of forward (conventional) or reverse hashing. */
    status = Params_query_registry (nlbctxt, bda_hdl, CVY_NAME_BDA_REVERSE_HASH, &paramp->bda_teaming.reverse_hash, sizeof(paramp->bda_teaming.reverse_hash));

    if (status != STATUS_SUCCESS)
        final_status = status;
    
    /* Close the key for BDA teaming. */
    status = ZwClose(bda_hdl);
    
    if (status != STATUS_SUCCESS)
        final_status = status;

 exit:

    TRACE_VERB("<-%!FUNC! return=0x%x", final_status);
    return final_status;
}

LONG Params_read_hostname (PVOID nlbctxt, PCVY_PARAMS paramp) {
    UNICODE_STRING    host_path;
    OBJECT_ATTRIBUTES host_obj;
    HANDLE            host_hdl = NULL;
    NTSTATUS          status = STATUS_SUCCESS;
    PMAIN_CTXT        ctxtp = (PMAIN_CTXT)nlbctxt;
    size_t            hostname_len = 0;

    TRACE_VERB("->%!FUNC! nlbctxt=0x%p, paramp=0x%p", nlbctxt, paramp);

    /* Set the hostname.domain to empty string. Also set the last byte of the buffer to NULL.
       We use a non-NULL value here to signify that a truncated value was copied from the
       registry. We do this because Params_query_registry will truncate without telling us, and
       truncation is an error condition that we need to compensate for. */
    paramp->hostname[0] = UNICODE_NULL;
    paramp->hostname[ASIZECCH(paramp->hostname) - 1] = UNICODE_NULL;

    /* All registry operations occur at PASSIVE_LEVEL - %ls is OK. */
    UNIV_PRINT_VERB(("Params_read_hostname: TCP/IP parameters registry path: %ls", HOST_REG_PATH));
    TRACE_VERB("%!FUNC! TCP/IP parameters registry path: %ls", HOST_REG_PATH);

    RtlInitUnicodeString(&host_path, (PWSTR)HOST_REG_PATH);
    InitializeObjectAttributes(&host_obj, &host_path, 0, NULL, NULL);
    
    /* Open the key - failure is acceptable. */
    status = ZwOpenKey(&host_hdl, KEY_READ, &host_obj);
    
    /* If we can't open this key, return here. */
    if (status != STATUS_SUCCESS)
    {
        /* All registry operations occur at PASSIVE_LEVEL - %ls is OK. */
        UNIV_PRINT_CRIT(("Params_read_hostname: Error 0x%08x -> Unable to open the TCP/IP parameters registry key... Exiting...", status));
        TRACE_CRIT("%!FUNC! Error 0x%08x -> Unable to open the TCP/IP paramters registry key... Exiting...", status);

        goto exit;
    }

    /* Get the hostname from the registry.  Failure is acceptable. */
    status = Params_query_registry (nlbctxt, host_hdl, L"Hostname", paramp->hostname, sizeof(paramp->hostname));

    /* Buffer is the max size allowed for the fully qualified domain name, so truncation is an error */
    UNIV_ASSERT(paramp->hostname[ASIZECCH(paramp->hostname) - 1] == UNICODE_NULL);

    if ((status != STATUS_SUCCESS) || (paramp->hostname[ASIZECCH(paramp->hostname) - 1] != UNICODE_NULL))
    {
        paramp->hostname[0] = UNICODE_NULL;
        if (status != STATUS_SUCCESS)
        {
            UNIV_PRINT_CRIT(("Params_read_hostname: Error 0x%08x -> Unable to copy hostname... Exiting...", status));
        }
        else
        {
            UNIV_PRINT_CRIT(("Params_read_hostname: Hostname was too large to fit into buffer... Exiting..."));
        }
        goto host_end;
    }

    /* There is no host name */
    if (paramp->hostname[0] == UNICODE_NULL)
    {
        UNIV_PRINT_INFO(("Params_read_hostname: There is no host name in registry. Exiting..."));
        goto host_end;
    }

    /* Save the size of the host name in case the append of the "." + domain fails */
    status = StringCchLength(paramp->hostname, ASIZECCH(paramp->hostname), &hostname_len);

    if (status != S_OK)
    {
        paramp->hostname[0] = UNICODE_NULL;
        UNIV_PRINT_CRIT(("Params_read_hostname: Error 0x%08x -> Unable to get length of copied hostname... Exiting...", status));
        goto host_end;
    }

    UNIV_ASSERT(hostname_len < ASIZECCH(paramp->hostname));

    /* Add a "." (dot) to the end of the hostname. */
    status = StringCbCat(paramp->hostname, sizeof(paramp->hostname), (PWSTR)L".");
    
    /* Don't need to check for buffer overrun here. Stringsafe.h functions do that for you. */
    if (status != S_OK)
    {
        paramp->hostname[hostname_len] = UNICODE_NULL;
        UNIV_PRINT_CRIT(("Params_read_hostname: Error 0x%08x -> Unable to cat . onto the hostname... Exiting...", status));
        goto host_end;
    }

    /* Read the domain from the registry.  Failure is acceptable. */
    status = Params_query_registry (nlbctxt, host_hdl, L"Domain", &paramp->hostname[hostname_len+1], sizeof(paramp->hostname) - ((hostname_len + 1) * sizeof(WCHAR)));

    /* Buffer is the max size allowed for fully qualified domain name, so truncation is an error */
    UNIV_ASSERT(paramp->hostname[ASIZECCH(paramp->hostname) - 1] == UNICODE_NULL);

    if ((status != STATUS_SUCCESS) || (paramp->hostname[ASIZECCH(paramp->hostname) - 1] != UNICODE_NULL) || (paramp->hostname[hostname_len+1] == UNICODE_NULL))
    {
        paramp->hostname[hostname_len] = UNICODE_NULL;
        if (status != STATUS_SUCCESS)
        {
            UNIV_PRINT_CRIT(("Params_read_hostname: Error 0x%08x -> Unable to cat the domain onto the hostname... Exiting...", status));
        }
        else
        {
            UNIV_PRINT_CRIT(("Params_read_hostname: Domain was truncated when copied into buffer... Exiting..."));
        }
        goto host_end;
    }

 host_end:

    /* Close the key for TCP/IP parameters. */
    status = ZwClose(host_hdl);

 exit:

    TRACE_VERB("<-%!FUNC! return=STATUS_SUCCESS");
    return STATUS_SUCCESS;
}

LONG Params_init (
    PVOID           nlbctxt,
    PVOID           rp,
    PVOID           adapter_guid,
    PCVY_PARAMS     paramp)
{
    NTSTATUS                    status;
    WCHAR                       reg_path [CVY_MAX_REG_PATH];
    UNICODE_STRING              path;
    OBJECT_ATTRIBUTES           obj;
    HANDLE                      hdl = NULL;
    NTSTATUS                    final_status = STATUS_SUCCESS;
    PMAIN_CTXT                  ctxtp = (PMAIN_CTXT)nlbctxt;

    TRACE_VERB("->%!FUNC! nlbctxt=0x%p, rp=0x%p, adapter_guid=0x%p, paramp=0x%p", nlbctxt, rp, adapter_guid, paramp);

    RtlZeroMemory (paramp, sizeof (CVY_PARAMS));

    paramp -> cl_mac_addr      [0] = 0;
    paramp -> cl_ip_addr       [0] = 0;
    paramp -> cl_net_mask      [0] = 0;
    paramp -> ded_ip_addr      [0] = 0;
    paramp -> ded_net_mask     [0] = 0;
    paramp -> cl_igmp_addr     [0] = 0;
    paramp -> domain_name      [0] = 0;

    /* Setup defaults that we HAVE to have. */
    paramp->num_actions   = CVY_DEF_NUM_ACTIONS;
    paramp->num_packets   = CVY_DEF_NUM_PACKETS;
    paramp->num_send_msgs = CVY_DEF_NUM_SEND_MSGS;
    paramp->alive_period  = CVY_DEF_ALIVE_PERIOD;

    /* Make sure that the registry path fits in out buffer. */
    UNIV_ASSERT(wcslen((PWSTR) rp) + wcslen((PWSTR) adapter_guid) + 1 <= CVY_MAX_REG_PATH);

    /* Copy the NLB parameters registry path into the buffer, which begins "...\Services\WLBS\Interface\". */
    status = StringCchCopy(reg_path, CVY_MAX_REG_PATH, (PWSTR)rp);
    
    if (FAILED(status)) {
        UNIV_PRINT_CRIT(("Params_init: Error 0x%08x -> Unable to copy NLB registry path... Exiting...", status));
        goto error;
    }

    /* Add the specified adapter GUID to complete the registry path - "...\Services\WLBS\Interface\{GUID}". */
    status = StringCchCat(reg_path, CVY_MAX_REG_PATH, (PWSTR)adapter_guid);
    
    if (FAILED(status)) {
        UNIV_PRINT_CRIT(("Params_init: Error 0x%08x -> Unable to cat adapter GUID onto the registry path... Exiting...", status));
        goto error;
    }
    
    RtlInitUnicodeString (& path, reg_path);

    InitializeObjectAttributes (& obj, & path, 0, NULL, NULL);

    status = ZwOpenKey (& hdl, KEY_READ, & obj);

    if (status != STATUS_SUCCESS)
        goto error;

    status = Params_query_registry (nlbctxt, hdl, CVY_NAME_VERSION, & paramp -> parms_ver, sizeof (paramp -> parms_ver));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, hdl, CVY_NAME_EFFECTIVE_VERSION, & paramp -> effective_ver, sizeof (paramp -> effective_ver));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, hdl, CVY_NAME_HOST_PRIORITY, & paramp -> host_priority, sizeof (paramp -> host_priority));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, hdl, CVY_NAME_NETWORK_ADDR, & paramp -> cl_mac_addr, sizeof (paramp -> cl_mac_addr));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, hdl, CVY_NAME_CL_IP_ADDR, & paramp -> cl_ip_addr, sizeof (paramp -> cl_ip_addr));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, hdl, CVY_NAME_MCAST_IP_ADDR, & paramp -> cl_igmp_addr, sizeof (paramp -> cl_igmp_addr));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, hdl, CVY_NAME_CL_NET_MASK, & paramp -> cl_net_mask, sizeof (paramp -> cl_net_mask));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, hdl, CVY_NAME_ALIVE_PERIOD, & paramp -> alive_period, sizeof (paramp -> alive_period));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, hdl, CVY_NAME_ALIVE_TOLER, & paramp -> alive_tolerance, sizeof (paramp -> alive_tolerance));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, hdl, CVY_NAME_DOMAIN_NAME, & paramp -> domain_name, sizeof (paramp -> domain_name));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, hdl, CVY_NAME_RMT_PASSWORD, & paramp -> rmt_password, sizeof (paramp -> rmt_password));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, hdl, CVY_NAME_RCT_PASSWORD, & paramp -> rct_password, sizeof (paramp -> rct_password));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, hdl, CVY_NAME_RCT_PORT, & paramp -> rct_port, sizeof (paramp -> rct_port));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, hdl, CVY_NAME_RCT_ENABLED, & paramp -> rct_enabled, sizeof (paramp -> rct_enabled));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, hdl, CVY_NAME_NUM_ACTIONS, & paramp -> num_actions, sizeof (paramp -> num_actions));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, hdl, CVY_NAME_NUM_PACKETS, & paramp -> num_packets, sizeof (paramp -> num_packets));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, hdl, CVY_NAME_NUM_SEND_MSGS, & paramp -> num_send_msgs, sizeof (paramp -> num_send_msgs));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, hdl, CVY_NAME_INSTALL_DATE, & paramp -> install_date, sizeof (paramp -> install_date));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, hdl, CVY_NAME_CLUSTER_MODE, & paramp -> cluster_mode, sizeof (paramp -> cluster_mode));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, hdl, CVY_NAME_PERSISTED_STATES, & paramp -> persisted_states, sizeof (paramp -> persisted_states));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, hdl, CVY_NAME_HOST_STATE, & paramp -> init_state, sizeof (paramp -> init_state));

    /* If we can't get the host state key, which is supposed to be created by netcfg 
       on a bind operation, just go without it and try to create it ourselves here. */
    if (status != STATUS_SUCCESS) {
        /* All registry operations occur at PASSIVE_LEVEL - %ls is OK. */
        UNIV_PRINT_CRIT(("Params_init: Unable to read %ls from the registry.  Using %ls instead.", CVY_NAME_HOST_STATE, CVY_NAME_CLUSTER_MODE));
        LOG_MSG(MSG_WARN_HOST_STATE_NOT_FOUND, MSG_NONE);
        paramp->init_state = paramp->cluster_mode;
        Params_set_registry(nlbctxt, hdl, CVY_NAME_HOST_STATE, &paramp->init_state, REG_DWORD, sizeof(paramp->init_state));
    }

    status = Params_query_registry (nlbctxt, hdl, CVY_NAME_DED_IP_ADDR, & paramp -> ded_ip_addr, sizeof (paramp -> ded_ip_addr));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, hdl, CVY_NAME_DED_NET_MASK, & paramp -> ded_net_mask, sizeof (paramp -> ded_net_mask));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, hdl, CVY_NAME_DSCR_PER_ALLOC, & paramp -> dscr_per_alloc, sizeof (paramp -> dscr_per_alloc));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, hdl, CVY_NAME_TCP_TIMEOUT, & paramp -> tcp_dscr_timeout, sizeof (paramp -> tcp_dscr_timeout));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, hdl, CVY_NAME_IPSEC_TIMEOUT, & paramp -> ipsec_dscr_timeout, sizeof (paramp -> ipsec_dscr_timeout));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, hdl, CVY_NAME_FILTER_ICMP, & paramp -> filter_icmp, sizeof (paramp -> filter_icmp));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, hdl, CVY_NAME_MAX_DSCR_ALLOCS, & paramp -> max_dscr_allocs, sizeof (paramp -> max_dscr_allocs));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, hdl, CVY_NAME_SCALE_CLIENT, & paramp -> scale_client, sizeof (paramp -> scale_client));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, hdl, CVY_NAME_CLEANUP_DELAY, & paramp -> cleanup_delay, sizeof (paramp -> cleanup_delay));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, hdl, CVY_NAME_NBT_SUPPORT, & paramp -> nbt_support, sizeof (paramp -> nbt_support));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, hdl, CVY_NAME_MCAST_SUPPORT, & paramp -> mcast_support, sizeof (paramp -> mcast_support));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, hdl, CVY_NAME_MCAST_SPOOF, & paramp -> mcast_spoof, sizeof (paramp -> mcast_spoof));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, hdl, CVY_NAME_IGMP_SUPPORT, & paramp -> igmp_support, sizeof (paramp -> igmp_support));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, hdl, CVY_NAME_MASK_SRC_MAC, & paramp -> mask_src_mac, sizeof (paramp -> mask_src_mac));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, hdl, CVY_NAME_NETMON_ALIVE, & paramp -> netmon_alive, sizeof (paramp -> netmon_alive));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, hdl, CVY_NAME_IP_CHG_DELAY, & paramp -> ip_chg_delay, sizeof (paramp -> ip_chg_delay));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, hdl, CVY_NAME_CONVERT_MAC, & paramp -> convert_mac, sizeof (paramp -> convert_mac));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, hdl, CVY_NAME_ID_HB_PERIOD, & paramp -> identity_period, sizeof (paramp -> identity_period));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, hdl, CVY_NAME_ID_HB_ENABLED, & paramp -> identity_enabled, sizeof (paramp -> identity_enabled));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, hdl, CVY_NAME_NUM_RULES, & paramp -> num_rules, sizeof (paramp -> num_rules));
    
    /* Get the port rules only if we were able to successfully grab the number of port rules, which is necessary
       in order to generate the registry keys for the new port rule format for virtual cluster support. */
    if (status != STATUS_SUCCESS) {
        final_status = status;        
    } else {
        /* First try to open the port rules in their old format. */
        status = Params_query_registry (nlbctxt, hdl, CVY_NAME_OLD_PORT_RULES, & paramp -> port_rules, sizeof (paramp -> port_rules));

        if (status == STATUS_SUCCESS) {
            /* If we were succussful in reading the rules from the old settings, then FAIL - this shouldn't happen. */
            final_status = STATUS_INVALID_PARAMETER;

            UNIV_PRINT_CRIT(("Params_init: Port rules found in old binary format"));
            TRACE_CRIT("%!FUNC! Port rules found in old binary format");
        } else {
            /* Look up the port rules, which we are now expecting to be in tact in the new location. */
            status = Params_read_portrules(nlbctxt, reg_path, paramp);
            
            if (status != STATUS_SUCCESS)
                final_status = status;
        }
    }

    /* Look up the BDA teaming parameters, if they exist. */
    status = Params_read_teaming(nlbctxt, reg_path, paramp);
    
    if (status != STATUS_SUCCESS)
        final_status = status;

    /* Attempt to retrieve the hostname from the TCP/IP registry settings. */
    status = Params_read_hostname(nlbctxt, paramp);

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = ZwClose (hdl);

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = final_status;

 error:

    if (status != STATUS_SUCCESS)
    {
        UNIV_PRINT_CRIT(("Params_init: Error querying registry %x", status));
        TRACE_CRIT("%!FUNC! Error querying registry %x", status);
        LOG_MSG1 (MSG_ERROR_REGISTRY, (PWSTR)adapter_guid, status);
    }

    /* Verify registry parameter settings. */
    if (Params_verify (nlbctxt, paramp, TRUE) != CVY_VERIFY_OK)
    {
        UNIV_PRINT_CRIT(("Params_init: Bad parameter value(s)"));
        LOG_MSG (MSG_ERROR_REGISTRY, (PWSTR)adapter_guid);
        TRACE_CRIT("%!FUNC! Bad parameter values");
        TRACE_VERB("<-%!FUNC! return=STATUS_UNSUCCESSFUL bad parameter values");
        return STATUS_UNSUCCESSFUL;
    }

    TRACE_VERB("<-%!FUNC! return=0x%x", status);
    return status;

} /* end Params_init */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\driver\params.h ===
#pragma once

#define CVY_MAX_ALLOCS                 50       /* maximum number of allocations
                                                   we can perform for packets
                                                   and actions */

#define CVY_MAX_SEND_PACKETS           50      /*  maximum number of packets
                                                   Prot_packets_send can send
                                                   down at one time */

#define CVY_MAX_RCT_PACKETS            10      /*  maximum number of RCTL packets
                                                   Prot_recv_complete can service
                                                   at one time */

/* Structure to hold the bi-directional affinity registry settings. */
typedef struct _CVY_BDA {
    WCHAR       team_id[CVY_MAX_BDA_TEAM_ID + 1];  /* The team ID - user-level support should enforce that it is a GUID. */
    ULONG       active;                            /* Is this adapter part of a BDA team? */
    ULONG       master;                            /* Boolean indication of master status (Slave=0). */
    ULONG       reverse_hash;                      /* Sets direction of hashing - forward (normal) or reverse. */
} CVY_BDA, PCVY_BDA;

/* port group rule - keep it 64bit in size for encryption */

typedef struct
{
    ULONG       start_port,         /* starting port number */
                end_port;           /* ending port number */
    ULONG       virtual_ip_addr;    /* Virtual clusters - the VIP to which the rule applies.
                                       All VIPs is represented by 0xffffffff. */
    ULONG       code;               /* unique rule code */
    ULONG       mode;               /* filtering mode */
    ULONG       protocol;           /* CVY_TCP, CVY_UDP or CVY_TCP_UDP */
    ULONG       valid;              /* for rule management in user mode */
    union
    {
        struct
        {
            ULONG       priority;   /* mastership priority: 1->N or 0 for
                                       not-specified */
        }           single;         /* data for single server mode */
        struct
        {
            USHORT      equal_load; /* TRUE => even load distribution */
            USHORT      affinity;   /* TRUE - map all client connections to one server */
            ULONG       load;       /* percentage of load to handle locally */
        }           multi;          /* data for multi-server mode */
    }           mode_data;          /* data for appropriate port group mode */
}
CVY_RULE, * PCVY_RULE;

/* host parameters */

typedef struct
{

    /* obtained from the registry */

    ULONG       parms_ver;          /* parameter structure version */
    ULONG       effective_ver;      /* what WLBS version we are effectively operating in. */

    ULONG       host_priority;      /* host's priority for single-server mastership */
    ULONG       alive_period;       /* period for sending "I am alive" messages
                                       in milliseconds */
    ULONG       alive_tolerance;    /* how many "I am alive" messages can be
                                       missed from other servers before assuming
                                       that the host is dead */
    ULONG       num_actions;        /* number of actions to allocate */
    ULONG       num_packets;        /* number of packets to allocate */
    ULONG       num_send_msgs;      /* number of send packets to allocate */
    ULONG       install_date;       /* install time stamp */
    ULONG       rmt_password;       /* remote maintenance password */
    ULONG       rct_password;       /* remote control password */
    ULONG       rct_port;           /* remote control UDP port */
    ULONG       rct_enabled;        /* TRUE - remote control enabled */
    ULONG       num_rules;          /* # active port group rules */
    ULONG       cleanup_delay;      /* dirty connection cleanup delay in
                                       milliseconds, 0 - delay */
    ULONG       cluster_mode;       /* TRUE - enabled on startup */

    ULONG       persisted_states;   /* which states should be persisted across reboots. */
    ULONG       init_state;         /* 0 = stopped, 1 = started, 2 = suspended */

    ULONG       dscr_per_alloc;     /* number of connection tracking
                                       descriptor per allocation */
    ULONG       max_dscr_allocs;    /* maximum number of connection tracking
                                       descriptor allocations */
    ULONG       scale_client;       /* TRUE - load balance connections from a
                                       given client across cluster servers */
    ULONG       nbt_support;        /* TRUE - NBT cluster name support enabled */
    ULONG       mcast_support;      /* TRUE - enable multicast MAC address support
                                       for switched V1.3.0b */
    ULONG       mcast_spoof;        /* TRUE - if mcast_support is TRUE - enable
                                       TCP/IP spoofing so that remote hosts can
                                       resolve cluster IP address to multicast
                                       address via ARPs V1.3.0b */
    ULONG       igmp_support;       /* TRUE - if IGMP support is enabled */
    ULONG       mask_src_mac;       /* TRUE - spoof source MAC when sending
                                       frames in unicast mode to prevent
                                       switches from getting confused V 2.0.6 */
    ULONG       netmon_alive;       /* TRUE - pass heartbeat frames to the
                                       protocols */
    ULONG       convert_mac;        /* TRUE - automatically match MAC address
                                       to primary cluster IP address */
    ULONG       ip_chg_delay;       /* delay in milliseconds to block outgoing
                                       ARPs while IP address change is in
                                       process */

    ULONG       tcp_dscr_timeout;   /* The timeout for expired TCP connection descriptors. */
    ULONG       ipsec_dscr_timeout; /* The timeout for expired IPSec connection descriptors. */

    ULONG       filter_icmp;        /* Whether or not ICMP traffic is filtered or accepted by all hosts. */

    CVY_BDA     bda_teaming;        /* the bi-directional affinity teaming config. */

    ULONG       identity_period;    /* Period for transmitting identity heartbeats (in ms) */
    ULONG       identity_enabled;   /* TRUE - identity heartbeats are transmitted */

    /* strings */

    WCHAR       cl_mac_addr [CVY_MAX_NETWORK_ADDR + 1];
                                    /* cluster MAC address */
    WCHAR       cl_ip_addr [CVY_MAX_CL_IP_ADDR + 1];
                                    /* cluster IP address */
    WCHAR       cl_net_mask [CVY_MAX_CL_NET_MASK + 1];
                                    /* netmask for cluster IP address or "" for none */
    WCHAR       ded_ip_addr [CVY_MAX_DED_IP_ADDR + 1];
                                    /* dedicated IP address or "" for none */
    WCHAR       ded_net_mask [CVY_MAX_DED_NET_MASK + 1];
                                    /* netmask for dedicated IP address or "" for none */
    WCHAR       domain_name [CVY_MAX_DOMAIN_NAME + 1];
                                    /* client's domain name */
    WCHAR       cl_igmp_addr [CVY_MAX_CL_IGMP_ADDR + 1];
                                    /* dedicated IP address or "" for none */
    CVY_RULE    port_rules[CVY_MAX_RULES - 1];
                                    /* port rules (account for internal default) */
    WCHAR       hostname[CVY_MAX_FQDN + 1]; 
                                    /* hostname.domain for this host if available. */
}
CVY_PARAMS, * PCVY_PARAMS;

#define CVY_DRIVER_RULE_CODE_GET(rulep) ((rulep) -> code)

#define CVY_DRIVER_RULE_CODE_SET(rulep) ((rulep) -> code =                          \
                                         ((ULONG) (((rulep) -> start_port) <<  0) | \
                                          (ULONG) (((rulep) -> end_port)   << 12) | \
                                          (ULONG) (((rulep) -> protocol)   << 24) | \
                                          (ULONG) (((rulep) -> mode)       << 28) | \
                                          (ULONG) (((rulep) -> mode == CVY_MULTI ? (rulep) -> mode_data . multi . affinity : 0) << 30)) \
                                         ^ ~((rulep) -> virtual_ip_addr))

extern LONG Params_init (
    PVOID           nlbctxt,
    PVOID           reg_path,
    PVOID           adapter_guid, /* GUID of the adapter for multiple nics*/
    PCVY_PARAMS     paramp);

/* Update the host state registry key.  This is called as a result of a local or remote
   control operation changing the current state of the host.  This state will be persisted
   across reboots, adapter disable/enables, etc. */
VOID Params_set_host_state (PNDIS_WORK_ITEM pWorkItem, PVOID nlbctxt);

#if defined (NLB_TCP_NOTIFICATION)
/* 
 * Function: Params_read_notification
 * Desctription: Looks for a global NLB registry to turn notifications on or
 *               off.  By default the key does NOT EVEN EXIST, so this is only
 *               a method by which to alter the hard-coded default.
 * Parameters: None.
 * Returns: NTSTATUS - the status of the registry operations.
 * Author: shouse, 4.29.02
 * Notes: 
 */
NTSTATUS Params_read_notification (VOID);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\driver\prot.c ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    prot.c

Abstract:

    Windows Load Balancing Service (WLBS)
    Driver - lower-level (protocol) layer of intermediate miniport

Author:

    kyrilf

--*/

#define NDIS50                  1
#define NDIS51                  1

#include <ndis.h>
#include <strsafe.h>

#include "prot.h"
#include "nic.h"
#include "main.h"
#include "util.h"
#include "univ.h"
#include "log.h"
#include "nlbwmi.h"
#include "init.h"
#include "prot.tmh"

/* GLOBALS */

NTHALAPI KIRQL KeGetCurrentIrql();

static ULONG log_module_id = LOG_MODULE_PROT;


/* PROCEDURES */


VOID Prot_bind (        /* PASSIVE_IRQL */
    PNDIS_STATUS        statusp,
    NDIS_HANDLE         bind_handle,
    PNDIS_STRING        device_name,
    PVOID               reg_path,
    PVOID               reserved)
{
    NDIS_STATUS         status;
    NDIS_STATUS         error_status;
    PMAIN_CTXT          ctxtp;
    ULONG               ret;
    UINT                medium_index;
    ULONG               i;
    ULONG               peek_size;
    ULONG               tmp;
    ULONG               xferred;
    ULONG               needed;
    ULONG               result;
    PNDIS_REQUEST       request;
    MAIN_ACTION         act;
    INT                 adapter_index; 
    PMAIN_ADAPTER       adapterp = NULL;

    NDIS_HANDLE         ctxt_handle;
    NDIS_HANDLE         config_handle;
    PNDIS_CONFIGURATION_PARAMETER   param;
    NDIS_STRING         device_str = NDIS_STRING_CONST ("UpperBindings");
    BOOL                bFirstMiniport = FALSE;

    /* make sure we are not attempting to bind to ourselves */

    /* PASSIVE_LEVEL - %ls is OK. */
    UNIV_PRINT_INFO(("Prot_bind: Binding to %ls", device_name -> Buffer));

    adapter_index = Main_adapter_get (device_name -> Buffer);
    if (adapter_index != MAIN_ADAPTER_NOT_FOUND)
    {
        UNIV_PRINT_CRIT(("Prot_bind: Already bound to this device 0x%x", adapter_index));
        TRACE_CRIT("%!FUNC! Already bound to this device 0x%x", adapter_index);
        *statusp = NDIS_STATUS_FAILURE;
        UNIV_PRINT_INFO(("Prot_bind: return=NDIS_STATUS_FAILURE"));
        TRACE_INFO("%!FUNC! return=NDIS_STATUS_FAILURE");
        return;
    }

    adapter_index = Main_adapter_selfbind (device_name -> Buffer);
    if (adapter_index != MAIN_ADAPTER_NOT_FOUND)
    {
        UNIV_PRINT_CRIT(("Prot_bind: Attempting to bind to ourselves 0x%x", adapter_index));
        TRACE_CRIT("%!FUNC! Attempting to bind to ourselves 0x%x", adapter_index);
        *statusp = NDIS_STATUS_FAILURE;
        UNIV_PRINT_INFO(("Prot_bind: return=NDIS_STATUS_FAILURE"));
        TRACE_INFO("%!FUNC! return=NDIS_STATUS_FAILURE");
        return;
    }

    adapter_index = Main_adapter_alloc (device_name);
    if (adapter_index == MAIN_ADAPTER_NOT_FOUND)
    {
        UNIV_PRINT_CRIT(("Prot_bind: Unable to allocate memory for adapter 0x%x", univ_adapters_count));
        TRACE_CRIT("%!FUNC! Unable to allocate memory for adapter 0x%x", univ_adapters_count);
        *statusp = NDIS_STATUS_FAILURE;
        UNIV_PRINT_INFO(("Prot_bind: return=NDIS_STATUS_FAILURE"));
        TRACE_INFO("%!FUNC! return=NDIS_STATUS_FAILURE");
        return;
    }

    adapterp = &(univ_adapters [adapter_index]);

    UNIV_ASSERT (adapterp -> code == MAIN_ADAPTER_CODE);

    NdisAcquireSpinLock(& univ_bind_lock);
    adapterp -> bound = TRUE;
    NdisReleaseSpinLock(& univ_bind_lock);

    UNIV_PRINT_VERB(("Prot_bind: Devicename length %d max length %d",
                 device_name -> Length, device_name -> MaximumLength));
    TRACE_VERB("%!FUNC! Devicename length %d max length %d",
                 device_name -> Length, device_name -> MaximumLength);

    /* This memory is allocated by Main_adapter_alloc(). */
    UNIV_ASSERT(adapterp->device_name);

    NdisMoveMemory (adapterp -> device_name,
                    device_name -> Buffer,
                    device_name -> Length);
    adapterp -> device_name_len = device_name -> MaximumLength;
    adapterp -> device_name [(device_name -> Length)/sizeof (WCHAR)] = UNICODE_NULL;

    /* This memory is allocated by Main_adapter_alloc(). */
    UNIV_ASSERT(adapterp->ctxtp);

    /* initialize context */
    ctxtp = adapterp -> ctxtp;

    NdisZeroMemory (ctxtp, sizeof (MAIN_CTXT));

    NdisAcquireSpinLock (& univ_bind_lock);

    ctxtp -> code = MAIN_CTXT_CODE;
    ctxtp -> bind_handle = bind_handle;
    ctxtp -> adapter_id = adapter_index;
    ctxtp -> requests_pending = 0;

    NdisReleaseSpinLock (& univ_bind_lock);

    /* karthicn, 11.28.01 - If it is the first nic that we are binding to, Create the IOCTL interface.  
       This was previously done in Nic_init. It is moved here just to maintain consistency with the
       removal of the IOCTL interface. The IOCTL interface is now removed from Prot_unbind (used
       to be in Nic_halt).
       DO NOT call this function with the univ_bind_lock acquired. */
    Init_register_device(&bFirstMiniport);

    NdisInitializeEvent (& ctxtp -> completion_event);

    NdisResetEvent (& ctxtp -> completion_event);

    /* bind to specified adapter */

    ctxt_handle = (NDIS_HANDLE) ctxtp;
    NdisOpenAdapter (& status, & error_status, & ctxtp -> mac_handle,
                     & medium_index, univ_medium_array, UNIV_NUM_MEDIUMS,
                     univ_prot_handle, ctxtp, device_name, 0, NULL);


    /* if pending - wait for Prot_open_complete to set the completion event */

    if (status == NDIS_STATUS_PENDING)
    {
        /* We can't wait at DISPATCH_LEVEL. */
        UNIV_ASSERT(KeGetCurrentIrql() <= PASSIVE_LEVEL);

        ret = NdisWaitEvent(& ctxtp -> completion_event, UNIV_WAIT_TIME);

        if (! ret)
        {
            UNIV_PRINT_CRIT(("Prot_bind: Error waiting for event"));
            TRACE_CRIT("%!FUNC! Error waiting for event");
            __LOG_MSG1 (MSG_ERROR_INTERNAL, MSG_NONE, status);
            * statusp = status;

            NdisAcquireSpinLock(& univ_bind_lock);
            adapterp -> bound = FALSE;
            NdisReleaseSpinLock(& univ_bind_lock);
            Main_adapter_put (adapterp);

            UNIV_PRINT_INFO(("Prot_bind: return=0x%x", status));
            TRACE_INFO("%!FUNC! return=0x%x", status);

            return;
        }

        status = ctxtp -> completion_status;
    }

    /* check binding status */

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT_CRIT(("Prot_bind: Error openning adapter %x", status));
        TRACE_CRIT("%!FUNC! Error openning adapter 0x%x", status);
        __LOG_MSG1 (MSG_ERROR_OPEN, device_name -> Buffer + (wcslen(L"\\DEVICE\\") * sizeof(WCHAR)), status);

        /* If the failure was because the medium was not supported, log this. */
        if (status == NDIS_STATUS_UNSUPPORTED_MEDIA) {
            UNIV_PRINT_CRIT(("Prot_bind: Unsupported medium"));
            TRACE_CRIT("%!FUNC! Unsupported medium");
            __LOG_MSG (MSG_ERROR_MEDIA, MSG_NONE);
        }

        * statusp = status;

        NdisAcquireSpinLock(& univ_bind_lock);
        adapterp -> bound = FALSE;
        NdisReleaseSpinLock(& univ_bind_lock);

        Main_adapter_put (adapterp);

        UNIV_PRINT_INFO(("Prot_bind: return=0x%x", status));
        TRACE_INFO("%!FUNC! return=0x%x", status);

        return;
    }

    ctxtp -> medium = univ_medium_array [medium_index];

    /* V1.3.1b make sure that underlying adapter is of the supported medium */

    if (ctxtp -> medium != NdisMedium802_3)
    {
        /* This should never happen because this error should be caught earlier
           by NdisOpenAdapter, but we'll put another check here just in case. */
        UNIV_PRINT_CRIT(("Prot_bind: Unsupported medium %d", ctxtp -> medium));
        TRACE_CRIT("%!FUNC! Unsupported medium %d", ctxtp -> medium);
        __LOG_MSG1 (MSG_ERROR_MEDIA, MSG_NONE, ctxtp -> medium);
        goto error;
    }

    /* V1.3.0b extract current MAC address from the NIC - note that main is not
       inited yet so we have to create a local action */

    act.code = MAIN_ACTION_CODE;
    act.ctxtp = ctxtp;

    act.op.request.xferred = &xferred;
    act.op.request.needed = &needed;
    act.op.request.external = FALSE;
    act.op.request.buffer_len = 0;
    act.op.request.buffer = NULL;

    NdisInitializeEvent(&act.op.request.event);

    NdisResetEvent(&act.op.request.event);

    NdisZeroMemory(&act.op.request.req, sizeof(NDIS_REQUEST));

    request = &act.op.request.req;

    request -> RequestType = NdisRequestQueryInformation;

    request -> DATA . QUERY_INFORMATION . Oid = OID_802_3_CURRENT_ADDRESS;

    request -> DATA . QUERY_INFORMATION . InformationBuffer       = & ctxtp -> ded_mac_addr;
    request -> DATA . QUERY_INFORMATION . InformationBufferLength = sizeof (CVY_MAC_ADR);

    act.status = NDIS_STATUS_FAILURE;
    status = Prot_request (ctxtp, & act, FALSE);

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT_CRIT(("Prot_bind: Error %x requesting station address %d %d", status, xferred, needed));
        TRACE_CRIT("%!FUNC! Error 0x%x requesting station address %d %d", status, xferred, needed);
        goto error;
    }

    /* V1.3.1b get MAC options */

    request -> RequestType = NdisRequestQueryInformation;

    request -> DATA . QUERY_INFORMATION . Oid = OID_GEN_MAC_OPTIONS;

    request -> DATA . QUERY_INFORMATION . InformationBuffer       = & result;
    request -> DATA . QUERY_INFORMATION . InformationBufferLength = sizeof (ULONG);

    act.status = NDIS_STATUS_FAILURE;
    status = Prot_request (ctxtp, & act, FALSE);

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT_CRIT(("Prot_bind: Error %x requesting MAC options %d %d", status, xferred, needed));
        TRACE_CRIT("%!FUNC! Error 0x%x requesting MAC options %d %d", status, xferred, needed);
        goto error;
    }
    
    ctxtp -> mac_options = result;

    /* Make sure the 802.3 adapter supports dynamically changing the MAC address of the NIC. */
    if (!(ctxtp -> mac_options & NDIS_MAC_OPTION_SUPPORTS_MAC_ADDRESS_OVERWRITE)) {
        UNIV_PRINT_CRIT(("Prot_bind: Unsupported network adapter MAC options %x", ctxtp -> mac_options));
        __LOG_MSG (MSG_ERROR_DYNAMIC_MAC, MSG_NONE);
        TRACE_CRIT("%!FUNC! Unsupported network adapter MAC options 0x%x", ctxtp -> mac_options);
        goto error;
    }

    status = Params_init (ctxtp, univ_reg_path, adapterp -> device_name + 8, & (ctxtp -> params));

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT_CRIT(("Prot_bind: Error retrieving registry parameters %x", status));
        TRACE_CRIT("%!FUNC! Error retrieving registry parameters 0x%x", status);
        ctxtp -> convoy_enabled = ctxtp -> params_valid = FALSE;
    }
    else
    {
        ctxtp -> convoy_enabled = ctxtp -> params_valid = TRUE;
    }

    /* Now, cat the cluster IP address onto the log message string to complete it. */
    status = StringCbCat(ctxtp->log_msg_str, sizeof(ctxtp->log_msg_str), (PWSTR)ctxtp->params.cl_ip_addr);

    if (FAILED(status)) {
        UNIV_PRINT_INFO(("Prot_bind: Error 0x%08x -> Unable to cat the cluster IP address onto the log message string...", status));
        TRACE_INFO("%!FUNC! Error 0x%08x -> Unable to cat the cluster IP address onto the log message string...", status);
    }
    
    /* Reset status, regardless of whether or not concatenating the string succeeded or failed. */
    status = NDIS_STATUS_SUCCESS;
        
    /* V1.3.2b figure out MTU of the medium */

    request -> RequestType = NdisRequestQueryInformation;

    request -> DATA . QUERY_INFORMATION . Oid = OID_GEN_MAXIMUM_TOTAL_SIZE;

    request -> DATA . QUERY_INFORMATION . InformationBuffer       = & result;
    request -> DATA . QUERY_INFORMATION . InformationBufferLength = sizeof (ULONG);

    act.status = NDIS_STATUS_FAILURE;
    status = Prot_request (ctxtp, & act, FALSE);

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT_CRIT(("Prot_bind: Error %x requesting max frame size %d %d", status, xferred, needed));
        TRACE_CRIT("%!FUNC! Error 0x%x requesting max frame size %d %d", status, xferred, needed);
        ctxtp -> max_frame_size = CVY_MAX_FRAME_SIZE;
    }
    else
    {
        ctxtp -> max_frame_size = result;
    }

    /* figure out maximum multicast list size */

    request -> RequestType = NdisRequestQueryInformation;

    request -> DATA . QUERY_INFORMATION . Oid = OID_802_3_MAXIMUM_LIST_SIZE;

    request -> DATA . QUERY_INFORMATION . InformationBufferLength = sizeof (ULONG);
    request -> DATA . QUERY_INFORMATION . InformationBuffer = & ctxtp->max_mcast_list_size;

    act.status = NDIS_STATUS_FAILURE;
    status = Prot_request (ctxtp, & act, FALSE);

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT_CRIT(("Prot_bind: Error %x setting multicast address %d %d", status, xferred, needed));
        TRACE_CRIT("%!FUNC! Error 0x%x setting multicast address %d %d", status, xferred, needed);
        goto error;
    }

    /* initialize main context now */

    status = Main_init (ctxtp);

    /* Note: if Main_init fails, it calls Main_cleanup itself in order to un-do 
       any allocation it had successfully completed before the failure. */
    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT_CRIT(("Prot_bind: Error initializing main module %x", status));
        TRACE_CRIT("%!FUNC! Error initializing main module 0x%x", status);
        goto error;
    }

    NdisAcquireSpinLock(& univ_bind_lock);

    adapterp -> inited = TRUE;

    /* Mark the operation in progress flag.  This MUST be re-set upon exit from this bind 
       function.  We set this flag to prevent IOCTL control operations from proceeding 
       before we're done binding.  Once we set the inited flag above, IOCTLs will be allowed
       to proceed (i.e., Main_ioctl and Main_ctrl will let them pass).  Because we have not
       yet quite finished initializing and setting cluster state, etc., we don't want IOCTLs
       to go through.  Marking the control operation in progress flag will ensure that any 
       incoming IOCTLs (and remote control, although at this point, remote control packets
       cannot be received) fail until we're done binding and we re-set the flag. */
    ctxtp->ctrl_op_in_progress = TRUE;

    NdisReleaseSpinLock(& univ_bind_lock);

    /* WLBS 2.3 start off by opening the config section and reading our instance
       which we want to export for this binding */

    NdisOpenProtocolConfiguration (& status, & config_handle, reg_path);

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT_CRIT(("Prot_bind: Error openning protocol configuration %x", status));
        TRACE_CRIT("%!FUNC! Error openning protocol configuration 0x%x", status);
        goto error;
    }

    NdisReadConfiguration (& status, & param, config_handle, & device_str,
                           NdisParameterString);

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT_CRIT(("Prot_bind: Error reading binding configuration %x", status));
        TRACE_CRIT("%!FUNC! Error reading binding configuration 0x%x", status);
        goto error;
    }

    /* free up whatever params allocated and get a new string to fit the
       device name */

    if (param -> ParameterData . StringData . Length >=
        sizeof (ctxtp -> virtual_nic_name) - sizeof (WCHAR))
    {
        UNIV_PRINT_CRIT(("Prot_bind: Nic name string too big %d %d\n", param -> ParameterData . StringData . Length, sizeof (ctxtp -> virtual_nic_name) - sizeof (WCHAR)));
        TRACE_CRIT("%!FUNC! Nic name string too big %d %d", param -> ParameterData . StringData . Length, sizeof (ctxtp -> virtual_nic_name) - sizeof (WCHAR));
    }

    NdisMoveMemory (ctxtp -> virtual_nic_name,
                    param -> ParameterData . StringData . Buffer,
                    param -> ParameterData . StringData . Length <
                    sizeof (ctxtp -> virtual_nic_name) - sizeof (WCHAR) ?
                    param -> ParameterData . StringData . Length :
                    sizeof (ctxtp -> virtual_nic_name) - sizeof (WCHAR));

    * (PWSTR) ((PCHAR) ctxtp -> virtual_nic_name +
               param -> ParameterData . StringData . Length) = UNICODE_NULL;

    /* PASSIVE_LEVEL - %ls is OK. */
    UNIV_PRINT_VERB(("Prot_bind: Read binding name %ls\n", ctxtp -> virtual_nic_name));
    TRACE_VERB("%!FUNC! Read binding name %ls", ctxtp -> virtual_nic_name);

    /* By default, we assume that the NIC is connected.  This will be changed by
       Nic_init and/or Prot_status later by querying the NIC miniport. */
    ctxtp->media_connected = TRUE;

    /* we should be all inited at this point! during announcement, Nic_init
       will be called and it will start ping timer */

    /* announce ourselves to the protocol above */
    UNIV_PRINT_VERB(("Prot_bind: Calling nic_announce"));
    TRACE_VERB("%!FUNC! Calling nic_announce");

    status = Nic_announce (ctxtp);

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT_CRIT(("Prot_bind: Error announcing driver %x", status));
        TRACE_CRIT("%!FUNC! Error announcing driver 0x%x", status);
        goto error;
    }

    /* PASSIVE_LEVEL - %ls is OK. */
    UNIV_PRINT_INFO(("Prot_bind: Bound to %ls with mac_handle=0x%p", device_name -> Buffer, ctxtp -> mac_handle));
    TRACE_INFO("%!FUNC! Bound to %ls with mac_handle=0x%p", device_name -> Buffer, ctxtp -> mac_handle);

    //
    // If it is the first miniport that NLB is binding to, fire "Startup" wmi event.
    // Ideally, this event should be fired from Init_register_device(), where the
    // determination of, if it is the first miniport that NLB is binding to, is made.
    // It is not being fired from Init_register_device() for the following reason:
    // The request for registration with WMI happens in Init_register_device(). 
    // WMI, in response to our request, sends down Ioctls to help us register with WMI, 
    // tell us of the events that any subscriber may be interested in.
    // Only after these Ioctls are sent down, can we start firing the events.
    // I have observed that the delay between our request for registration and the reception
    // of Ioctls from WMI could sometimes be big. Ie. big enough to preclude us 
    // from firing this event from Init_register_device().
    //
    // Why did I choose this point in the function to fire the event ?
    // This is logically the furthest point (thereby giving us the best possible chance that the Ioctls
    // have come down and we are ready to fire events) in the function that we could fire this event from. 
    // Now, it is possible that even at this point, we have not yet received the Ioctls. We can not do 
    // much about that.
    //
    // Are there any side-effects of firing the Startup event from here instead of Init_register_device( ) ?
    // There is one side-effect. If we encountered an error in the steps (above) after the call to 
    // Init_register_device(), we do a "goto error" whic calls Prot_unbind(). Prot_unbind() will 
    // fire a "Shutdown" event (if subscribed, ofcourse). So, in this case, a "Shutdown" event will 
    // have been fired without a preceding "Startup" event. This could confuse the subscriber. 
    // I have decided to live this side-effect for the following reasons:
    // 1. Chances of encountering error in the steps after the call to Init_register_device() is quite rare.
    // 2. A "Shutdown" event without a "Startup" event does NOT necessarily have to be confusing. It could
    //    be construed as "Attempted to start, but had problems, so shutting down". Yeah, that may be a
    //    bit of a copout.
    //
    // --KarthicN, 03-06-02
    //
    if (bFirstMiniport)
    {
        if(NlbWmiEvents[StartupEvent].Enable)
        {
            NlbWmi_Fire_Event(StartupEvent, NULL, 0);
        }
        else 
        {
            TRACE_VERB("%!FUNC! NOT generating Startup event 'cos its generation is disabled");
        }
    }

    /* at this point TCP/IP should have bound to us after we announced ourselves
       to it and we are all done binding to NDIS below - all set! */

    if (! ctxtp -> convoy_enabled)
    {
        LOG_MSG (MSG_ERROR_DISABLED, MSG_NONE);
        TRACE_INFO("%!FUNC! Cluster mode cannot be enabled due to NLB parameters not being set, or set to incorrect values");

        // If enabled, fire wmi event indicating binding & stopping of nlb
        if (NlbWmiEvents[NodeControlEvent].Enable)
        {
            NlbWmi_Fire_NodeControlEvent(ctxtp, NLB_EVENT_NODE_BOUND_AND_STOPPED);
        }
        else 
        {
            TRACE_VERB("%!FUNC! NOT generating NLB_EVENT_NODE_BOUND_AND_STOPPED 'cos NodeControlEvent generation disabled");
        }
    }
    else
    {
        switch (ctxtp->params.init_state) {
        case CVY_HOST_STATE_STARTED:
        {
            WCHAR num[20];

            Univ_ulong_to_str(ctxtp->params.host_priority, num, 10);

            LOG_MSG(MSG_INFO_STARTED, num);
            TRACE_INFO("%!FUNC! Cluster mode started");            

            // If enabled, fire wmi event indicating binding & starting of nlb
            if (NlbWmiEvents[NodeControlEvent].Enable)
            {
                NlbWmi_Fire_NodeControlEvent(ctxtp, NLB_EVENT_NODE_BOUND_AND_STARTED);
            }
            else 
            {
                TRACE_VERB("%!FUNC! NOT generating NLB_EVENT_NODE_BOUND_AND_STARTED 'cos NodeControlEvent generation disabled");
            }

            // Assuming start of convergence
            if (NlbWmiEvents[ConvergingEvent].Enable)
            {
                NlbWmi_Fire_ConvergingEvent(ctxtp, 
                                            NLB_EVENT_CONVERGING_NEW_MEMBER, 
                                            ctxtp->params.ded_ip_addr,
                                            ctxtp->params.host_priority);
            }
            else 
            {
                TRACE_VERB("%!FUNC! NOT generating NLB_EVENT_CONVERGING_NEW_MEMBER, Convergnce NOT Initiated by Load_start() OR ConvergingEvent generation disabled");
            }

            ctxtp->convoy_enabled = TRUE;

            break;
        }
        case CVY_HOST_STATE_STOPPED:
        {
            LOG_MSG(MSG_INFO_STOPPED, MSG_NONE);
            TRACE_INFO("%!FUNC! Cluster mode stopped");            

            ctxtp->convoy_enabled = FALSE;

            // If enabled, fire wmi event indicating binding & stopping of nlb
            if (NlbWmiEvents[NodeControlEvent].Enable)
            {
                NlbWmi_Fire_NodeControlEvent(ctxtp, NLB_EVENT_NODE_BOUND_AND_STOPPED);
            }
            else 
            {
                TRACE_VERB("%!FUNC! NOT generating NLB_EVENT_NODE_BOUND_AND_STOPPED 'cos NodeControlEvent generation disabled");
            }
            break;
        }
        case CVY_HOST_STATE_SUSPENDED:
        {
            LOG_MSG(MSG_INFO_SUSPENDED, MSG_NONE);
            TRACE_INFO("%!FUNC! Cluster mode suspended");            

            ctxtp->convoy_enabled = FALSE;

            // If enabled, fire wmi event indicating binding & suspending of nlb
            if (NlbWmiEvents[NodeControlEvent].Enable)
            {
                NlbWmi_Fire_NodeControlEvent(ctxtp, NLB_EVENT_NODE_BOUND_AND_SUSPENDED);
            }
            else 
            {
                TRACE_VERB("%!FUNC! NOT generating NLB_EVENT_NODE_BOUND_AND_SUSPENDED 'cos NodeControlEvent generation disabled");
            }

            break;
        }
        default:
            LOG_MSG(MSG_INFO_STOPPED, MSG_NONE);
            TRACE_CRIT("%!FUNC! Cluster mode invalid - cluster has been stopped");
            ctxtp->convoy_enabled = FALSE;

            // If enabled, fire wmi event indicating binding & stopping of nlb
            if (NlbWmiEvents[NodeControlEvent].Enable)
            {
                NlbWmi_Fire_NodeControlEvent(ctxtp, NLB_EVENT_NODE_BOUND_AND_STOPPED);
            }
            else 
            {
                TRACE_VERB("%!FUNC! NOT generating NLB_EVENT_NODE_BOUND_AND_STOPPED 'cos NodeControlEvent generation disabled");
            }
            break;
        }
    }

    /* Re-set the operation in progress flag to begin allowing IOCTLs to proceed. 
       Note that it is not strictly necessary to hold the lock while resetting the
       flag, but a condition may arise that an IOCTL that could have proceeded into
       the critical section may fail unnecessarily.  To prevent that possibility,
       hold the univ_bind_lock while resetting the flag.  Note that in "error" cases
       (goto error;), it is  not necessary to re-set the flag, as it will result in
       a call to Prot_unbind and a failure of the bind anyway. */
    ctxtp->ctrl_op_in_progress = FALSE;

    UNIV_PRINT_INFO(("Prot_bind: return=0x%x", status));
    TRACE_INFO("%!FUNC! return=0x%x", status);

    * statusp = status;

    return;

error:

    * statusp = status;

    Prot_unbind (& status, ctxtp, ctxtp);

    UNIV_PRINT_INFO(("Prot_bind: return=0x%x", status));
    TRACE_INFO("%!FUNC! return=0x%x", status);

    return;

} /* end Prot_bind */


VOID Prot_unbind (      /* PASSIVE_IRQL */
    PNDIS_STATUS        statusp,
    NDIS_HANDLE         adapter_handle,
    NDIS_HANDLE         unbind_handle)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;
    NDIS_STATUS         status = NDIS_STATUS_SUCCESS;
    PMAIN_ACTION        actp;
    PMAIN_ADAPTER       adapterp;
    INT                 adapter_index;

    UNIV_PRINT_INFO(("Prot_unbind: Unbinding, adapter_handle=0x%p", adapter_handle));

    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    adapter_index = ctxtp -> adapter_id;

    adapterp = & (univ_adapters [adapter_index]);
    UNIV_ASSERT (adapterp -> code == MAIN_ADAPTER_CODE);
    UNIV_ASSERT (adapterp -> ctxtp == ctxtp);

    ctxtp -> unbind_handle = unbind_handle;

    if (ctxtp->out_request != NULL)
    {
        actp = ctxtp->out_request;
        ctxtp->out_request = NULL;

        Prot_request_complete(ctxtp, & actp->op.request.req, NDIS_STATUS_FAILURE);

        /* Note: No need to decrement the pending request counter for the second
           time here, because we only ended up incrementing it once (in the initial
           call to Prot_request).  Prot_request_complete will effectively cancel
           the request and decrement the counter appropriately. */
    }

    /* unannounce the nic now if it was announced before */
    status = Nic_unannounce (ctxtp);

    UNIV_PRINT_INFO(("Prot_unbind: Unannounced, status=0x%x", status));
    TRACE_INFO("%!FUNC! Unannounced, status=0x%x", status);

    /* if still bound (Prot_close was not called from Nic_halt) then close now */

    status = Prot_close (adapterp);

    UNIV_PRINT_INFO(("Prot_unbind: Closed, status=0x%x", status));
    TRACE_INFO("%!FUNC! Closed, status=0x%x", status);

    /* karthicn, 11.28.01 - If it is the last nic that we are unbinding from, remove the IOCTL interface.  
       This was previously done at the beginning of Nic_halt, which prevented firing of wmi events after 
       Nic_halt was called. This move allows us to fire events from Prot_close() (which is called at the 
       end of Nic_halt() & after as well)
       DO NOT call this function with the univ_bind_lock acquired. */
    Init_deregister_device();

    Main_adapter_put (adapterp);

    * statusp = status;

    UNIV_PRINT_INFO(("Prot_unbind: return=0x%x", status));
    TRACE_INFO("%!FUNC! return=0x%x", status);

    return;

} /* end Prot_unbind */


VOID Prot_open_complete (       /* PASSIVE_IRQL */
    NDIS_HANDLE         adapter_handle,
    NDIS_STATUS         open_status,
    NDIS_STATUS         error_status)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;

    UNIV_PRINT_VERB(("Prot_open_complete: Called %x", ctxtp));

    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    ctxtp -> completion_status = open_status;
    NdisSetEvent (& ctxtp -> completion_event);

} /* end Prot_open_complete */


VOID Prot_close_complete (      /* PASSIVE_IRQL */
    NDIS_HANDLE         adapter_handle,
    NDIS_STATUS         status)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;

    UNIV_PRINT_VERB(("Prot_close_complete: Called %x %x", ctxtp, status));

    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    ctxtp -> completion_status = status;
    NdisSetEvent (& ctxtp -> completion_event);

} /* end Prot_close_complete */


VOID Prot_request_complete (
    NDIS_HANDLE         adapter_handle,
    PNDIS_REQUEST       request,
    NDIS_STATUS         status)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;
    PMAIN_ACTION        actp;

    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    actp = CONTAINING_RECORD (request, MAIN_ACTION, op . request . req);
    UNIV_ASSERT (actp -> code == MAIN_ACTION_CODE);

    /* if request came from above - pass completion up */

    if (actp -> op . request . external)
    {
        actp -> status = status;
        Nic_request_complete (ctxtp -> prot_handle, actp);
    }

    /* handle internal request completion */

    else
    {
        if (request -> RequestType == NdisRequestSetInformation)
        {
            * actp -> op . request . xferred =
                                request -> DATA . SET_INFORMATION . BytesRead;
            * actp -> op . request . needed  =
                                request -> DATA . SET_INFORMATION . BytesNeeded;
        }
        else
        {
            * actp -> op . request . xferred =
                            request -> DATA . QUERY_INFORMATION . BytesWritten;
            * actp -> op . request . needed  =
                            request -> DATA . QUERY_INFORMATION . BytesNeeded;
        }

        actp->status = status;
        NdisSetEvent(&actp->op.request.event);
    }

    NdisInterlockedDecrement(&ctxtp->requests_pending);

} /* end Prot_request_complete */


#ifdef PERIODIC_RESET
extern ULONG   resetting;
#endif

VOID Prot_reset_complete (
    NDIS_HANDLE         adapter_handle,
    NDIS_STATUS         status)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;
    PMAIN_ADAPTER       adapterp;


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    adapterp = & (univ_adapters [ctxtp -> adapter_id]);
    UNIV_ASSERT (adapterp -> code == MAIN_ADAPTER_CODE);
    UNIV_ASSERT (adapterp -> ctxtp == ctxtp);

    if (! adapterp -> inited)
    {
        TRACE_CRIT("%!FUNC! adapter not initialized");
        return;
    }

#ifdef PERIODIC_RESET
    if (resetting)
    {
        resetting = FALSE;
        TRACE_INFO("%!FUNC! resetting");
        return;
    }
#endif

    Nic_reset_complete (ctxtp, status);

} /* end Prot_reset_complete */


VOID Prot_send_complete (
    NDIS_HANDLE         adapter_handle,
    PNDIS_PACKET        packet,
    NDIS_STATUS         status)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;
    PNDIS_PACKET        oldp;
    PNDIS_PACKET_STACK  pktstk;
    BOOLEAN             stack_left;
    PMAIN_PROTOCOL_RESERVED resp;
    LONG                lock_value;
    PMAIN_ADAPTER       adapterp;
    BOOLEAN             set = FALSE;


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    adapterp = & (univ_adapters [ctxtp -> adapter_id]);
    UNIV_ASSERT (adapterp -> code == MAIN_ADAPTER_CODE);
    UNIV_ASSERT (adapterp -> ctxtp == ctxtp);

    if (! adapterp -> inited)
    {
        TRACE_CRIT("%!FUNC! adapter not initialized");
        return;
    }

    MAIN_RESP_FIELD(packet, stack_left, pktstk, resp, TRUE);

    if (resp -> type == MAIN_PACKET_TYPE_PING ||
        resp -> type == MAIN_PACKET_TYPE_IGMP ||
        resp -> type == MAIN_PACKET_TYPE_IDHB)
    {
        Main_send_done (ctxtp, packet, status);
        return;
    }

    if (resp -> type == MAIN_PACKET_TYPE_CTRL)
    {
        UNIV_PRINT_VERB(("Prot_send_complete: Control packet send complete\n"));
        Main_packet_put (ctxtp, packet, TRUE, status);
        return;
    }

    UNIV_ASSERT_VAL (resp -> type == MAIN_PACKET_TYPE_PASS, resp -> type);

    oldp = Main_packet_put (ctxtp, packet, TRUE, status);

    if (ctxtp -> packets_exhausted)
    {
        ctxtp -> packets_exhausted = FALSE;
    }

    Nic_send_complete (ctxtp, status, oldp);

} /* end Prot_send_complete */


NDIS_STATUS Prot_recv_indicate (
    NDIS_HANDLE         adapter_handle,
    NDIS_HANDLE         recv_handle,
    PVOID               head_buf,
    UINT                head_len,
    PVOID               look_buf,
    UINT                look_len,
    UINT                packet_len)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT)adapter_handle;
    PMAIN_ADAPTER       adapterp;
    PNDIS_PACKET        packet;

    UNIV_ASSERT(ctxtp->code == MAIN_CTXT_CODE);

    adapterp = &(univ_adapters[ctxtp->adapter_id]);

    UNIV_ASSERT(adapterp->code == MAIN_ADAPTER_CODE);
    UNIV_ASSERT(adapterp->ctxtp == ctxtp);

    /* Check whether the driver has been announced to tcpip before processing any packets. */
    if (!adapterp->inited || !adapterp->announced)
    {
        TRACE_CRIT("%!FUNC! Adapter not initialized or not announced");
        return NDIS_STATUS_NOT_ACCEPTED;
    }

    /* Do not accept frames if the card below is resetting. */
    if (ctxtp->reset_state != MAIN_RESET_NONE)
    {
        TRACE_CRIT("%!FUNC! Adapter is resetting");
        return NDIS_STATUS_NOT_ACCEPTED;
    }

    /* Get the received packet from NDIS, if there is one. */
    packet = NdisGetReceivedPacket(ctxtp->mac_handle, recv_handle);

    /* If we successfully got a packet from NDIS, process the packet. */
    if (packet != NULL)
    {
        INT references = 0;

        /* Get the status from the received packet. */
        NDIS_STATUS original_status = NDIS_GET_PACKET_STATUS(packet);
        
        /* Set the status to be STATUS_RESOURCES to make sure the packet is
           processed synchonrously within the context of this function call. */
        NDIS_SET_PACKET_STATUS(packet, NDIS_STATUS_RESOURCES);
        
        /* Call our packet receive handler. */
        references = Prot_packet_recv(ctxtp, packet);

        /* The remaining references on the packet MUST be zero, as enforced
           by setting the packet status to STATUS_RESOURCES. */
        UNIV_ASSERT(references == 0);
        
        /* Restore the original packet status. */
        NDIS_SET_PACKET_STATUS(packet, original_status);
    }
    /* If there was no associated packet, drop it - we don't handle this case anymore. */
    else
    {
        UNIV_ASSERT(0);

        /* Only warn the user if we haven't done so already. */
        if (!ctxtp->recv_indicate_warned)
        {
            TRACE_CRIT("%!FUNC! Indicated receives with no corresponding packet are NOT supported");

            /* Log an event to warn the user that this NIC is not supported by NLB. */
            LOG_MSG(MSG_ERROR_RECEIVE_INDICATE, MSG_NONE);

            /* Note that we have warned the user about this so we don't log an event 
               every time we receive a packet via this code path. */
            ctxtp->recv_indicate_warned = TRUE;
        }

        return NDIS_STATUS_NOT_ACCEPTED;
    }

    /* Always return success, whether we accepted or dropped the packet
       in the call to Prot_packet_recv. */
    return NDIS_STATUS_SUCCESS;
}

VOID Prot_recv_complete (
    NDIS_HANDLE         adapter_handle)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;

    UNIV_ASSERT(ctxtp->code == MAIN_CTXT_CODE);

    Nic_recv_complete(ctxtp);
}

VOID Prot_transfer_complete (
    NDIS_HANDLE         adapter_handle,
    PNDIS_PACKET        packet,
    NDIS_STATUS         status,
    UINT                xferred)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;
    PNDIS_PACKET        oldp;
    PNDIS_PACKET_STACK  pktstk;
    BOOLEAN             stack_left;
    PMAIN_PROTOCOL_RESERVED resp;
    LONG                lock_value;
    PNDIS_BUFFER        bufp;
    PMAIN_ADAPTER       adapterp;

    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    adapterp = & (univ_adapters [ctxtp -> adapter_id]);
    UNIV_ASSERT (adapterp -> code == MAIN_ADAPTER_CODE);
    UNIV_ASSERT (adapterp -> ctxtp == ctxtp);

    if (! adapterp -> inited)
    {
        TRACE_CRIT("%!FUNC! adapter not initialized");
        return;
    }

    MAIN_RESP_FIELD (packet, stack_left, pktstk, resp, FALSE);

    UNIV_ASSERT_VAL (resp -> type == MAIN_PACKET_TYPE_TRANSFER, resp -> type);

    if (status == NDIS_STATUS_SUCCESS)
    {
        MAIN_PACKET_INFO PacketInfo;
        
        /* Call Main_recv_frame_parse merely to extract the packet length and "group". */
        if (Main_recv_frame_parse(ctxtp, packet, &PacketInfo))
        {
            resp->len = PacketInfo.Length;
            resp->group = PacketInfo.Group;
        }
        /* If we fail to fill in the group and length, just populate these 
           parameters with values that will not affect the statistics that
           are updated in Main_packet_put. */
        else
        {
            resp->len = 0;
            resp->group = MAIN_FRAME_DIRECTED;
        }
    }

    oldp = Main_packet_put (ctxtp, packet, FALSE, status);
    Nic_transfer_complete (ctxtp, status, packet, xferred);

} /* end Prot_transfer_complete */


NDIS_STATUS Prot_PNP_handle (
    NDIS_HANDLE         adapter_handle,
    PNET_PNP_EVENT      pnp_event)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;
    PNDIS_DEVICE_POWER_STATE  device_state;
    NDIS_STATUS         status = NDIS_STATUS_SUCCESS;
    IOCTL_CVY_BUF       ioctl_buf;
    PMAIN_ACTION        actp;

    /* can happen when first initializing */

    switch (pnp_event -> NetEvent)
    {
        case NetEventSetPower:

            if (adapter_handle == NULL)
            {
                return NDIS_STATUS_SUCCESS;
            }

            UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

            device_state = (PNDIS_DEVICE_POWER_STATE) (pnp_event -> Buffer);

            UNIV_PRINT_VERB(("Prot_PNP_handle: NetEventSetPower %x", * device_state));
            TRACE_VERB("%!FUNC! NetEventSetPower 0x%x", * device_state);

        // If the specified device state is D0, then handle it first,
        // else notify the protocols first and then handle it.

        if (*device_state != NdisDeviceStateD0)
        {
            status = Nic_PNP_handle (ctxtp, pnp_event);
        }

        //
        // Is the protocol transitioning from an On (D0) state to an Low Power State (>D0)
        // If so, then set the standby_state Flag - (Block all incoming requests)
        //
        if (ctxtp->prot_pnp_state == NdisDeviceStateD0 &&
            *device_state > NdisDeviceStateD0)
        {
            ctxtp->standby_state = TRUE;
        }

        //
        // If the protocol is transitioning from a low power state to ON (D0), then clear the standby_state flag
        // All incoming requests will be pended until the physical miniport turns ON.
        //
        if (ctxtp->prot_pnp_state > NdisDeviceStateD0 &&
            *device_state == NdisDeviceStateD0)
        {
            ctxtp->standby_state = FALSE;
        }

        ctxtp -> prot_pnp_state = *device_state;

        /* if we are being sent to standby, block outstanding requests and
           sends */

        if (*device_state > NdisDeviceStateD0)
            {
               /* sleep till outstanding sends complete */

               while (1)
               {
                   ULONG        i;


                   /* #ps# -- ramkrish */
                   while (1)
                   {
                       NDIS_STATUS hide_status;
                       ULONG       count;

                       hide_status = NdisQueryPendingIOCount (ctxtp -> mac_handle, & count);
                       if (hide_status != NDIS_STATUS_SUCCESS || count == 0)
                           break;

                       Nic_sleep (10);
                   }

                   // ASSERT - NdisQueryPendingIOCount should handle this
                   for (i = 0; i < ctxtp->num_send_packet_allocs; i++)
                   {
                       if (NdisPacketPoolUsage(ctxtp->send_pool_handle[i]) != 0)
                           break;
                   }

                   if (i >= ctxtp->num_send_packet_allocs)
                       break;

                   Nic_sleep(10);
               }

               /* sleep till outstanding requests complete */

               while (ctxtp->requests_pending > 0)
               {
                   Nic_sleep(10);
               }

            }
            else
            {
                if (ctxtp->out_request != NULL)
                {
                    NDIS_STATUS      hide_status;

                    actp = ctxtp->out_request;
                    ctxtp->out_request = NULL;

                    hide_status = Prot_request(ctxtp, actp, actp->op.request.external);

                    if (hide_status != NDIS_STATUS_PENDING)
                        Prot_request_complete(ctxtp, & actp->op.request.req, hide_status);

                    /* Upon pending this request initially, we incremented the request pending
                       counter.  Now that we have processed it, and in the process incremented
                       the pending request counter for the second time, we need to decrement it
                       here once.  The second decrement is done in Prot_request_complete, which
                       either we just called explicitly, or will be called subsequently when 
                       NDIS completes the request asynchronously. */
                    NdisInterlockedDecrement(&ctxtp->requests_pending);
                }
            }

            if (*device_state == NdisDeviceStateD0)
            {
                status = Nic_PNP_handle (ctxtp, pnp_event);
            }

            break;

        case NetEventReconfigure:

            UNIV_PRINT_VERB(("Prot_PNP_handle: NetEventReconfigure"));
            TRACE_VERB("%!FUNC! NetEventReconfigure");

            if (adapter_handle == NULL) // This happens if the device is being enabled through the device manager.
            {
                UNIV_PRINT_VERB(("Prot_PNP_handle: Enumerate protocol bindings"));
                NdisReEnumerateProtocolBindings (univ_prot_handle);
                TRACE_VERB("%!FUNC! Enumerate protocol bindings");
                return NDIS_STATUS_SUCCESS;
            }
            /* gets called when something changes in our setup from notify
               object */

            UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

            Main_ctrl (ctxtp, IOCTL_CVY_RELOAD, &ioctl_buf, NULL, NULL, NULL);

            status = Nic_PNP_handle (ctxtp, pnp_event);

            UNIV_PRINT_VERB(("Prot_PNP_handle: NetEventReconfigure done %d %x", ioctl_buf . ret_code, status));
            TRACE_VERB("%!FUNC! NetEventReconfigure done %d 0x%x", ioctl_buf . ret_code, status);

            break;

        case NetEventQueryPower:
            UNIV_PRINT_VERB(("Prot_PNP_handle: NetEventQueryPower"));
            TRACE_VERB("%!FUNC! NetEventQueryPower");

            if (adapter_handle == NULL)
            {
                return NDIS_STATUS_SUCCESS;
            }

            UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

            status = Nic_PNP_handle (ctxtp, pnp_event);
            break;

        case NetEventQueryRemoveDevice:
            UNIV_PRINT_VERB(("Prot_PNP_handle: NetEventQueryRemoveDevice"));
            TRACE_VERB("%!FUNC! NetEventQueryRemoveDevice");

            if (adapter_handle == NULL)
            {
                return NDIS_STATUS_SUCCESS;
            }

            UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

            status = Nic_PNP_handle (ctxtp, pnp_event);
            break;

        case NetEventCancelRemoveDevice:
            UNIV_PRINT_VERB(("Prot_PNP_handle: NetEventCancelRemoveDevice"));
            TRACE_VERB("%!FUNC! NetEventCancelRemoveDevice");

            if (adapter_handle == NULL)
            {
                return NDIS_STATUS_SUCCESS;
            }

            UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

            status = Nic_PNP_handle (ctxtp, pnp_event);
            break;

        case NetEventBindList:
            UNIV_PRINT_VERB(("Prot_PNP_handle: NetEventBindList"));
            TRACE_VERB("%!FUNC! NetEventBindList");

            if (adapter_handle == NULL)
            {
                return NDIS_STATUS_SUCCESS;
            }

            UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

            status = Nic_PNP_handle (ctxtp, pnp_event);
            break;

        case NetEventBindsComplete:
            UNIV_PRINT_VERB(("Prot_PNP_handle: NetEventBindComplete"));
            TRACE_VERB("%!FUNC! NetEventBindComplete");

            if (adapter_handle == NULL)
            {
                return NDIS_STATUS_SUCCESS;
            }

            UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

            status = Nic_PNP_handle (ctxtp, pnp_event);
            break;

        default:
            UNIV_PRINT_VERB(("Prot_PNP_handle: New event"));
            TRACE_VERB("%!FUNC! New event");

            if (adapter_handle == NULL)
            {
                return NDIS_STATUS_SUCCESS;
            }

            UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

            status = Nic_PNP_handle (ctxtp, pnp_event);
            break;
    }

    return status; /* Always return NDIS_STATUS_SUCCESS or
              the return value of NdisIMNotifyPnPEvent */

} /* end Nic_PNP_handle */


VOID Prot_status (
    NDIS_HANDLE         adapter_handle,
    NDIS_STATUS         status,
    PVOID               stat_buf,
    UINT                stat_len)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;
    KIRQL               irql;
    PMAIN_ADAPTER       adapterp;

    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    adapterp = & (univ_adapters [ctxtp -> adapter_id]);
    UNIV_ASSERT (adapterp -> code == MAIN_ADAPTER_CODE);
    UNIV_ASSERT (adapterp -> ctxtp == ctxtp);

    UNIV_PRINT_VERB(("Prot_status: Called for adapter %d for notification %d: inited=%d, announced=%d", ctxtp -> adapter_id, status, adapterp->inited, adapterp->announced));
    TRACE_VERB("%!FUNC! Adapter %d for notification %d: inited=%d, announced=%d", ctxtp -> adapter_id, status, adapterp->inited, adapterp->announced);

    if (! adapterp -> inited || ! adapterp -> announced)
    {
        TRACE_CRIT("%!FUNC! adapter not initialized or not announced");
        return;
    }

    switch (status)
    {
        case NDIS_STATUS_WAN_LINE_UP:
            UNIV_PRINT_VERB(("Prot_status: NDIS_STATUS_WAN_LINE_UP"));
            break;

        case NDIS_STATUS_WAN_LINE_DOWN:
            UNIV_PRINT_VERB(("Prot_status: NDIS_STATUS_WAN_LINE_DOWN"));
            break;

        case NDIS_STATUS_MEDIA_CONNECT:
            UNIV_PRINT_VERB(("Prot_status: NDIS_STATUS_MEDIA_CONNECT"));

            /* V1.3.2b */
            ctxtp -> media_connected = TRUE;
            break;

        case NDIS_STATUS_MEDIA_DISCONNECT:
            UNIV_PRINT_VERB(("Prot_status: NDIS_STATUS_MEDIA_DISCONNECT"));

            /* V1.3.2b */
            ctxtp -> media_connected = FALSE;
            break;

        case NDIS_STATUS_HARDWARE_LINE_UP:
            UNIV_PRINT_VERB(("Prot_status: NDIS_STATUS_HARDWARE_LINE_UP"));
            break;

        case NDIS_STATUS_HARDWARE_LINE_DOWN:
            UNIV_PRINT_VERB(("Prot_status: NDIS_STATUS_HARDWARE_LINE_DOWN"));
            break;

        case NDIS_STATUS_INTERFACE_UP:
            UNIV_PRINT_VERB(("Prot_status: NDIS_STATUS_INTERFACE_UP"));
            break;

        case NDIS_STATUS_INTERFACE_DOWN:
            UNIV_PRINT_VERB(("Prot_status: NDIS_STATUS_INTERFACE_DOWN"));
            break;

        /* V1.1.2 */

        case NDIS_STATUS_RESET_START:
            UNIV_PRINT_VERB(("Prot_status: NDIS_STATUS_RESET_START"));
            ctxtp -> reset_state = MAIN_RESET_START;
            ctxtp -> recv_indicated = FALSE;
            break;

        case NDIS_STATUS_RESET_END:
            UNIV_PRINT_VERB(("Prot_status: NDIS_STATUS_RESET_END"));
            // apparently alteon adapter does not call status complete function,
            // so need to transition to none state here in order to prevent hangs
            //ctxtp -> reset_state = MAIN_RESET_END;
            ctxtp -> reset_state = MAIN_RESET_NONE;
            break;

        default:
            break;
    }

    if (! MAIN_PNP_DEV_ON(ctxtp))
    {
        TRACE_CRIT("%!FUNC! return pnp device not on");
        return;
    }

    Nic_status (ctxtp, status, stat_buf, stat_len);

} /* end Prot_status */


VOID Prot_status_complete (
    NDIS_HANDLE         adapter_handle)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;
    PMAIN_ADAPTER       adapterp;

    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    adapterp = & (univ_adapters [ctxtp -> adapter_id]);
    UNIV_ASSERT (adapterp -> code == MAIN_ADAPTER_CODE);
    UNIV_ASSERT (adapterp -> ctxtp == ctxtp);

    if (! adapterp -> inited)
    {
        TRACE_CRIT("%!FUNC! adapter not initialized");
        return;
    }

    /* V1.1.2 */

    if (ctxtp -> reset_state == MAIN_RESET_END)
    {
        ctxtp -> reset_state = MAIN_RESET_NONE;
        UNIV_PRINT_VERB(("Prot_status_complete: NDIS_STATUS_RESET_END completed"));
    }
    else if (ctxtp -> reset_state == MAIN_RESET_START)
    {
        ctxtp -> reset_state = MAIN_RESET_START_DONE;
        UNIV_PRINT_VERB(("Prot_status_complete: NDIS_STATUS_RESET_START completed"));
    }

    if (! MAIN_PNP_DEV_ON(ctxtp))
    {
        TRACE_CRIT("%!FUNC! return pnp device not on");
        return;
    }

    Nic_status_complete (ctxtp);

} /* end Prot_status_complete */


/* helpers for nic layer */


NDIS_STATUS Prot_close (       /* PASSIVE_IRQL */
    PMAIN_ADAPTER       adapterp
)
{
    NDIS_STATUS         status;
    ULONG               ret;
    PMAIN_CTXT          ctxtp;

    UNIV_ASSERT (adapterp -> code == MAIN_ADAPTER_CODE);

    ctxtp = adapterp -> ctxtp;

    /* close binding */

    NdisAcquireSpinLock(& univ_bind_lock);

    if ( ! adapterp -> bound || ctxtp->mac_handle == NULL)
    {
        /* cleanup only on the second time we are entering Prot_close, which
           is called by both Nic_halt and Prot_unbind. the last one to be
           called will cleanup the context since they both use it. if both
           do not get called, then it will be cleaned up by Prot_bind before
           allocating a new one of Init_unload before unloading the driver. */

        if (adapterp -> inited)
        {
            UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

            adapterp -> inited    = FALSE;

            NdisReleaseSpinLock(& univ_bind_lock);

            Main_cleanup (ctxtp);
        }
        else
            NdisReleaseSpinLock(& univ_bind_lock);

        Main_adapter_put (adapterp);
        return NDIS_STATUS_SUCCESS;
    }

    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    adapterp -> bound = FALSE;
    ctxtp -> convoy_enabled = FALSE;

    NdisReleaseSpinLock(& univ_bind_lock);

    LOG_MSG (MSG_INFO_STOPPED, MSG_NONE);

    // If enabled, fire wmi event indicating unbinding of nlb
    if (NlbWmiEvents[NodeControlEvent].Enable)
    {
        NlbWmi_Fire_NodeControlEvent(ctxtp, NLB_EVENT_NODE_UNBOUND);
    }
    else 
    {
        TRACE_VERB("%!FUNC! NOT generating NLB_EVENT_NODE_UNBOUND 'cos NodeControlEvent generation disabled");
    }

    NdisResetEvent (& ctxtp -> completion_event);

    NdisCloseAdapter (& status, ctxtp -> mac_handle);

    /* if pending - wait for Prot_close_complete to set the completion event */

    if (status == NDIS_STATUS_PENDING)
    {
        /* We can't wait at DISPATCH_LEVEL. */
        UNIV_ASSERT(KeGetCurrentIrql() <= PASSIVE_LEVEL);

        ret = NdisWaitEvent(& ctxtp -> completion_event, UNIV_WAIT_TIME);

        if (! ret)
        {
            UNIV_PRINT_CRIT(("Prot_close: Error waiting for event"));
            LOG_MSG1 (MSG_ERROR_INTERNAL, MSG_NONE, status);
            TRACE_CRIT("%!FUNC! Error waiting for event");
            return NDIS_STATUS_FAILURE;
        }

        status = ctxtp -> completion_status;
    }

    /* At this point,wait for all pending recvs to be completed and then return */

    ctxtp -> mac_handle  = NULL;
    ctxtp -> prot_handle = NULL;

    /* check binding status */

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT_CRIT(("Prot_close: Error closing adapter %x", status));
        LOG_MSG1 (MSG_ERROR_INTERNAL, MSG_NONE, status);
        TRACE_CRIT("%!FUNC! Error closing adapter 0x%x", status);
    }

    /* if nic level is not announced anymore - safe to remove context now */

    NdisAcquireSpinLock(& univ_bind_lock);

    if (! adapterp -> announced || ctxtp -> prot_handle == NULL)
    {
        if (adapterp -> inited)
        {
            adapterp -> inited = FALSE;
            NdisReleaseSpinLock(& univ_bind_lock);

            Main_cleanup (ctxtp);
        }
        else
            NdisReleaseSpinLock(& univ_bind_lock);

        Main_adapter_put (adapterp);
    }
    else
        NdisReleaseSpinLock(& univ_bind_lock);

    return status;

} /* end Prot_close */

NDIS_STATUS Prot_request (
    PMAIN_CTXT          ctxtp,
    PMAIN_ACTION        actp,
    ULONG               external)
{
    NDIS_STATUS         status;
    PNDIS_REQUEST       request = &actp->op.request.req;
    ULONG               ret;

    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    actp->op.request.external = external;

    if (ctxtp -> unbind_handle) // Prot_unbind was called
    {
        return NDIS_STATUS_FAILURE;
    }

    // if the Protocol device state is OFF, then the IM driver cannot send the
    // request below and must pend it

    if (ctxtp->prot_pnp_state > NdisDeviceStateD0)
    {
        if (external) {
            /* If the request was external (from the protocol bound to our miniport,
               then pend the request.  Ndis serializes requests such that only one
               request can ever be outstanding at a given time.  Therefore, a queue
               is not necessary. */
            UNIV_ASSERT (ctxtp->out_request == NULL);

            if (ctxtp->out_request == NULL)
            {
                /* If there are no outstanding requests as of yet, store a pointer
                   to the request so that we can complete it later. */
                ctxtp->out_request = actp;
            }
            else 
            {
                /* Otherwise, if a request is already pending, fail this new one.
                   This should never happen, as NDIS serializes miniport requests. */
                return NDIS_STATUS_FAILURE;
            }

            /* Note: this counter will also be incremented when we call Prot_request 
               again later to continue processing the request.  We have to ensure,
               then, that it is likewise decremented twice whenever serviced. */
            NdisInterlockedIncrement(&ctxtp->requests_pending);

            return NDIS_STATUS_PENDING;
        } else {
            /* If the request was internal, then fail it - if we return PENDING, it
               will fail anyway, as it expects us to wait for the request to complete
               before returning. */
            return NDIS_STATUS_FAILURE;
        }
    }

    NdisResetEvent(&actp->op.request.event);

    NdisInterlockedIncrement(&ctxtp->requests_pending);

    NdisRequest(&status, ctxtp->mac_handle, request);

    /* if pending - wait for Prot_request_complete to set the completion event */

    if (status != NDIS_STATUS_PENDING)
    {
        NdisInterlockedDecrement(&ctxtp->requests_pending);

        if (request -> RequestType == NdisRequestSetInformation)
        {
            * actp -> op . request . xferred =
                                request -> DATA . SET_INFORMATION . BytesRead;
            * actp -> op . request . needed  =
                                request -> DATA . SET_INFORMATION . BytesNeeded;
        }
        else
        {
            * actp -> op . request . xferred =
                            request -> DATA . QUERY_INFORMATION . BytesWritten;
            * actp -> op . request . needed  =
                            request -> DATA . QUERY_INFORMATION . BytesNeeded;
        }
    }
    else if (! external)
    {
        /* We can't wait at DISPATCH_LEVEL. */
        UNIV_ASSERT(KeGetCurrentIrql() <= PASSIVE_LEVEL);
        
        ret = NdisWaitEvent(&actp->op.request.event, UNIV_WAIT_TIME);

        if (! ret)
        {
            UNIV_PRINT_CRIT(("Prot_request: Error waiting for event"));
            TRACE_CRIT("%!FUNC! Error=0x%x waiting for event", status);
            LOG_MSG1 (MSG_ERROR_INTERNAL, MSG_NONE, status);
            status = NDIS_STATUS_FAILURE;
            return status;
        }

        status = actp->status;
    }

    return status;

} /* end Prot_request */


NDIS_STATUS Prot_reset (
    PMAIN_CTXT          ctxtp)
{
    NDIS_STATUS         status;


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    NdisReset (& status, ctxtp -> mac_handle);

    return status;

} /* end Prot_reset */


VOID Prot_packets_send (
    PMAIN_CTXT          ctxtp,
    PPNDIS_PACKET       packets,
    UINT                num_packets)
{
    PNDIS_PACKET        array[CVY_MAX_SEND_PACKETS];
    PNDIS_PACKET        filtered_array[CVY_MAX_SEND_PACKETS];
    UINT                count = 0, filtered_count = 0, i;
    NDIS_STATUS         status;
    PNDIS_PACKET        newp;
    LONG                lock_value;
    PMAIN_ACTION        actp;
    ULONG               exhausted;
    PNDIS_PACKET_STACK  pktstk;
    BOOLEAN             stack_left;

    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    /* Do not accept frames if the card below is resetting. */
    if (ctxtp->reset_state != MAIN_RESET_NONE || ! MAIN_PNP_DEV_ON(ctxtp))
    {
        TRACE_CRIT("%!FUNC! card is resetting");
        ctxtp->cntr_xmit_err++;
        status = NDIS_STATUS_FAILURE;
        goto fail;
    }

    for (count = i = 0;
         count < (num_packets > CVY_MAX_SEND_PACKETS ? CVY_MAX_SEND_PACKETS : num_packets);
         count ++)
    {
        /* Figure out if we need to handle this packet. */
        newp = Main_send(ctxtp, packets[count], &exhausted);

        if (newp == NULL)
        {
            /* If we ran out of packets, get out of the loop. */
            if (exhausted)
            {
                UNIV_PRINT_CRIT(("Prot_packets_send: Error xlating packet"));
                TRACE_CRIT("%!FUNC! Error xlating packet");
                ctxtp->packets_exhausted = TRUE;
                break;
            }
            /* If the packet was filtered out, set status to success 
               to calm TCP/IP down and go on to the next one. */
            else
            {
                /* Mark the packet as success. */
                NDIS_SET_PACKET_STATUS(packets[count], NDIS_STATUS_SUCCESS);

                /* Store a pointer to the filtered packet in the filtered
                   packet array. */
                filtered_array[filtered_count] = packets[count];

                /* Increment the array index. */
                filtered_count++;

//              ctxtp->sends_filtered ++;
                continue;
            }
        }

        /* Mark the packet as pending send. */
        NDIS_SET_PACKET_STATUS(packets[count], NDIS_STATUS_PENDING);

        /* Store a pointer to this packet in the array of packets to send. */
        array[i] = newp;

        /* Increment the array index. */
        i++;
    }

    /* If there are packets to send, send them. */
    if (i > 0) 
        NdisSendPackets(ctxtp->mac_handle, array, i);

    /* For those packets we've filtered out, notify the protocol that 
       the send is "complete". */
    for (i = 0; i < filtered_count; i++)
        Nic_send_complete(ctxtp, NDIS_STATUS_SUCCESS, filtered_array[i]);

fail:

    /* Any remaining packets cannot be handled; there is no space in the 
       pending queue, which is limited to CVY_MAX_SEND_PACKETS packets. */
    for (i = count; i < num_packets; i++)
    {
        /* Mark the packet as failed. */
        NDIS_SET_PACKET_STATUS(packets[i], NDIS_STATUS_FAILURE);

        /* Notify the protocol that the send is "complete". */
        Nic_send_complete(ctxtp, NDIS_STATUS_FAILURE, packets[i]);
    }

}

INT Prot_packet_recv (
    NDIS_HANDLE             adapter_handle,
    PNDIS_PACKET            packet)
{
    PMAIN_CTXT              ctxtp = (PMAIN_CTXT) adapter_handle;
    PMAIN_ADAPTER           adapterp;
    PNDIS_PACKET            newp;
    NDIS_STATUS             status;
    PMAIN_PROTOCOL_RESERVED resp;
    LONG                    lock_value;
    PNDIS_PACKET_STACK      pktstk;
    BOOLEAN                 stack_left;

    UNIV_ASSERT(ctxtp->code == MAIN_CTXT_CODE);

    adapterp = &(univ_adapters[ctxtp->adapter_id]);

    UNIV_ASSERT(adapterp->code == MAIN_ADAPTER_CODE);
    UNIV_ASSERT(adapterp->ctxtp == ctxtp);

    /* Check whether the driver has been announced to tcpip before processing any packets. */
    if (!adapterp->inited || !adapterp->announced)
    {
        TRACE_CRIT("%!FUNC! Adapter not initialized or not announced");
        return 0;
    }

    /* Do not accept frames if the card below is resetting. */
    if (ctxtp->reset_state != MAIN_RESET_NONE)
    {
        TRACE_CRIT("%!FUNC! Adapter is resetting");
        return 0;
    }

    /* Figure out if we need to handle this packet. */
    newp = Main_recv(ctxtp, packet);

    /* A return value of NULL indicates rejection of the packet - return zero to 
       indicate that no references remain on the packet (it can be dropped). */
    if (newp == NULL)
    {
        return 0;
    }

    MAIN_RESP_FIELD(newp, stack_left, pktstk, resp, FALSE);

    /* Process remote control. */
    if (resp->type == MAIN_PACKET_TYPE_CTRL)
    {
        /* Handle remote control request now. */
        (VOID)Main_ctrl_process(ctxtp, newp);

        /* Packet has been copied into our own packet; return zero to
           indicate that no references remain on the original packet. */
        return 0;
    }

    UNIV_ASSERT_VAL(resp->type == MAIN_PACKET_TYPE_PASS, resp->type);

    /* Pass packet up.  Note reference counting to determine who will 
       be disposing of the packet. */
    resp->data = 2;

    Nic_recv_packet(ctxtp, newp);

    lock_value = InterlockedDecrement(&resp->data);

    UNIV_ASSERT_VAL(lock_value == 0 || lock_value == 1, lock_value);

    if (lock_value == 0)
    {
        /* If we're done with the packet, reverse any changes we've made
           to it and return zero to indication no lingering references. */
        Main_packet_put(ctxtp, newp, FALSE, NDIS_STATUS_SUCCESS);

        return 0;
    }

    /* Otherwise, the packet is still being processed, so return 1 to make
       sure that the packet is not immediately released. */
    return 1;
}

VOID Prot_return (
    PMAIN_CTXT              ctxtp,
    PNDIS_PACKET            packet)
{
    PNDIS_PACKET            oldp;
    PMAIN_PROTOCOL_RESERVED resp;
    LONG                    lock_value;
    ULONG                   type;
    PNDIS_PACKET_STACK      pktstk;
    BOOLEAN                 stack_left;

    UNIV_ASSERT(ctxtp->code == MAIN_CTXT_CODE);

    MAIN_RESP_FIELD(packet, stack_left, pktstk, resp, FALSE);

    /* Check to see if we need to be disposing of this packet. */
    lock_value = InterlockedDecrement(&resp->data);

    UNIV_ASSERT_VAL(lock_value == 0 || lock_value == 1, lock_value);

    if (lock_value == 1)
    {
        return;
    }

    /* Resp will become invalid after the call to Main_packet_put. 
       Save type for assertion below. */
    type = resp->type;

    oldp = Main_packet_put(ctxtp, packet, FALSE, NDIS_STATUS_SUCCESS);

    /* If oldp is NULL, this is our internal packet. */
    if (oldp != NULL)
    {
        UNIV_ASSERT_VAL(type == MAIN_PACKET_TYPE_PASS, type);

        NdisReturnPackets(&oldp, 1);
    }

}

NDIS_STATUS Prot_transfer (
    PMAIN_CTXT          ctxtp,
    NDIS_HANDLE         recv_handle,
    PNDIS_PACKET        packet,
    UINT                offset,
    UINT                len,
    PUINT               xferred)
{
    NDIS_STATUS         status;
    PNDIS_PACKET        newp;
    PMAIN_PROTOCOL_RESERVED resp;
    PNDIS_PACKET_STACK  pktstk;
    BOOLEAN             stack_left;

    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    /* V1.1.2 do not accept frames if the card below is resetting */

    if (ctxtp -> reset_state != MAIN_RESET_NONE)
    {
        TRACE_CRIT("%!FUNC! adapter is resetting");
        return NDIS_STATUS_FAILURE;
    }

    /* we are trying to prevent transfer requests from stale receive indicates
       that have been made to the protocol layer prior to the reset operation.
       we do not know what is the old inbound frame state and cannot expect
       to be able to carry out any transfers. */

    if (! ctxtp -> recv_indicated)
    {
        UNIV_PRINT_CRIT(("Prot_transfer: stale receive indicate after reset"));
        TRACE_CRIT("%!FUNC! stale receive indicate after reset");
        return NDIS_STATUS_FAILURE;
    }

    newp = Main_packet_get (ctxtp, packet, FALSE, 0, 0);
    if (newp == NULL)
    {
        UNIV_PRINT_CRIT(("Prot_transfer: Error xlating packet"));
        TRACE_CRIT("%!FUNC! Error translating packet");
        return NDIS_STATUS_RESOURCES;
    }

    MAIN_RESP_FIELD (newp, stack_left, pktstk, resp, FALSE);

    resp -> type = MAIN_PACKET_TYPE_TRANSFER;

    NdisTransferData (& status, ctxtp -> mac_handle, recv_handle, offset, len,
                      newp, xferred);   /* V1.1.2 */

    if (status != NDIS_STATUS_PENDING)
    {
        if (status == NDIS_STATUS_SUCCESS)
        {
            MAIN_PACKET_INFO PacketInfo;
            
            /* Call Main_recv_frame_parse merely to extract the packet length and "group". */
            if (Main_recv_frame_parse(ctxtp, newp, &PacketInfo))
            {
                resp->len = PacketInfo.Length;
                resp->group = PacketInfo.Group;
            }
            /* If we fail to fill in the group and length, just populate these 
               parameters with values that will not affect the statistics that 
               are updated in Main_packet_put. */
            else
            {
                resp->len = 0;
                resp->group = MAIN_FRAME_DIRECTED;
            }
        }

        Main_packet_put (ctxtp, newp, FALSE, status);
    }

    return status;

} /* end Prot_transfer */


VOID Prot_cancel_send_packets (
    PMAIN_CTXT        ctxtp,
    PVOID             cancel_id)
{
    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    NdisCancelSendPackets (ctxtp -> mac_handle, cancel_id);

    return;

} /* Prot_cancel_send_packets */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\driver\tcpip.h ===
#ifndef _tcpip_h_
#define _tcpip_h_

#include "wlbsip.h"
#include "main.h"

/* PROCEDURES */


extern BOOLEAN Tcpip_init (
    PTCPIP_CTXT     ctxtp,
    PVOID           params);
/*
  Initialize module

  returns BOOLEAN:
    TRUE  => success
    FALSE => failure

  function:
*/

extern VOID Tcpip_nbt_handle (
    PTCPIP_CTXT       ctxtp, 
    PMAIN_PACKET_INFO pPacketInfo);
/*
  Process NBT header and mask cluster name with shadow name

  returns VOID:

  function:
*/

extern USHORT Tcpip_chksum (
    PTCPIP_CTXT       ctxtp,
    PMAIN_PACKET_INFO pPacketInfo,
    ULONG             prot);
/*
  Produce IP, TCP or UDL checksums for specified protocol header

  returns USHORT:
    <checksum>

  function:
*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\driver\trace.c ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

	trace.c

Abstract:

	Windows Load Balancing Service (WLBS)
    Driver - support for WMI event tracing

History:

    4/01/01 JosephJ Created

--*/

#define  NLB_TRACING_ENABLED 1

#include <ntddk.h>
#include <wmistr.h>
#include <wlbsparm.h>
#include "trace.h"
#include "trace.tmh"


UINT            Trace_Skip_Initialization = 0;
PDRIVER_OBJECT  Trace_Saved_Driver_Object = NULL;

VOID
Trace_Initialize(
    PVOID                         driver_obj,
    PVOID                         registry_path
    )
{
    if (!Trace_Skip_Initialization)
    {
        PDRIVER_OBJECT DriverObject =  (PDRIVER_OBJECT) driver_obj;
        PUNICODE_STRING RegistryPath  = (PUNICODE_STRING) registry_path;
    
        Trace_Saved_Driver_Object = DriverObject;

        WPP_INIT_TRACING(DriverObject, RegistryPath);
    }
}

VOID
Trace_Deinitialize(VOID)
{
    if (Trace_Saved_Driver_Object != NULL)
    {
        WPP_CLEANUP(Trace_Saved_Driver_Object);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\driver\tcpip.c ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    tcpip.c

Abstract:

    Windows Load Balancing Service (WLBS)
    Driver - IP/TCP/UDP support


Author:

    kyrilf

--*/

#include <ndis.h>

#include "tcpip.h"
#include "wlbsip.h"
#include "univ.h"
#include "wlbsparm.h"
#include "params.h"
#include "main.h"
#include "log.h"
#include "tcpip.tmh"

/* GLOBALS */


static ULONG log_module_id = LOG_MODULE_TCPIP;
static UCHAR nbt_encoded_shadow_name [NBT_ENCODED_NAME_LEN];

/* PROCEDURES */


BOOLEAN Tcpip_init (
    PTCPIP_CTXT         ctxtp,
    PVOID               parameters)
{
    ULONG               i, j;
    PCVY_PARAMS         params = (PCVY_PARAMS) parameters;
    UNICODE_STRING      UnicodeMachineName;
    ANSI_STRING         AnsiMachineName;
    WCHAR               pwcMachineName[NBT_NAME_LEN];
    UCHAR               pucMachineName[NBT_NAME_LEN];

    /* extract cluster computer name from full internet name */

    j = 0;

    while ((params -> domain_name [j] != 0)
        && (params -> domain_name [j] != L'.'))
    {
        // Get only 15 characters since the maximum length of a Netbios machine name is 15. 
        // It must be padded with a ' ', hence the definition on NBT_NAME_LEN to 16.
        if (j < (NBT_NAME_LEN - 1)) 
        {
            j ++;
        }
        else
        {
            TRACE_CRIT("%!FUNC! Cluster name in %ls longer than 15 characters. Truncating it to 15 characters.", params->domain_name);
            break;
        }
    }

    /* build encoded cluster computer name for checking against arriving NBT
       session requests */

    for (i = 0; i < NBT_NAME_LEN; i ++)
    {
        if (i >= j)
        {
            ctxtp -> nbt_encoded_cluster_name [2 * i]     =
                     NBT_ENCODE_FIRST (' ');
            ctxtp -> nbt_encoded_cluster_name [2 * i + 1] =
                     NBT_ENCODE_SECOND (' ');
        }
        else
        {
            ctxtp -> nbt_encoded_cluster_name [2 * i]     =
                     NBT_ENCODE_FIRST (toupper ((UCHAR) (params -> domain_name [i])));
            ctxtp -> nbt_encoded_cluster_name [2 * i + 1] =
                     NBT_ENCODE_SECOND (toupper ((UCHAR) (params -> domain_name [i])));
        }
    }

    /* Save away the machine name in Netbios format.
       Tcpip_nbt_handle overwrites NetBT Session request packets destined for the cluster name 
       with this saved machine name.
     */

    nbt_encoded_shadow_name[0] = 0;

    if (params -> hostname[0] != 0) 
    {
        /* extract computer name from FQDN */
        j = 0;

        while ((params -> hostname [j] != 0)
            && (params -> hostname [j] != L'.'))
        {
            // Get only 15 characters since the maximum length of a Netbios machine name is 15. 
            // It must be padded with a ' ', hence the definition on NBT_NAME_LEN to 16.
            if (j < (NBT_NAME_LEN - 1)) 
            {
                pwcMachineName[j] = params -> hostname[j];
                j ++;
            }
            else
            {
                TRACE_CRIT("%!FUNC! Host name in %ls longer than 15 characters. Truncating it to 15 characters.", params->hostname);
                break;
            }
        }

        pwcMachineName[j] = 0;

        /* Convert unicode string to ansi string */
        UnicodeMachineName.Buffer = pwcMachineName;
        UnicodeMachineName.Length = (USHORT) (j * sizeof(WCHAR));
        UnicodeMachineName.MaximumLength = NBT_NAME_LEN * sizeof(WCHAR);

        pucMachineName[0] = 0;
        AnsiMachineName.Buffer = pucMachineName;
        AnsiMachineName.Length = 0;
        AnsiMachineName.MaximumLength = NBT_NAME_LEN;

        if (RtlUnicodeStringToAnsiString(&AnsiMachineName, &UnicodeMachineName, FALSE) == STATUS_SUCCESS)
        {
            for (i = 0; i < NBT_NAME_LEN; i ++)
            {
                if (i >= j)
                {
                    nbt_encoded_shadow_name [2 * i]     =
                             NBT_ENCODE_FIRST (' ');
                    nbt_encoded_shadow_name [2 * i + 1] =
                             NBT_ENCODE_SECOND (' ');
                }
                else
                {
                    nbt_encoded_shadow_name [2 * i]     =
                             NBT_ENCODE_FIRST (toupper (pucMachineName[i]));
                    nbt_encoded_shadow_name [2 * i + 1] =
                             NBT_ENCODE_SECOND (toupper (pucMachineName[i]));
                }
            }
        }
        else
        {
            TRACE_CRIT("%!FUNC! RtlUnicodeStringToAnsiString failed to convert %ls to Ansi", pwcMachineName);
        }
    }
    else // We donot have the machine's name, so, there will be no name to overwrite the NetBT packets with.
    {
        TRACE_CRIT("%!FUNC! Host name is not present. Unable to encode Netbios name.");
    }

    return TRUE;

} /* Tcpip_init */


VOID Tcpip_nbt_handle (
    PTCPIP_CTXT       ctxtp, 
    PMAIN_PACKET_INFO pPacketInfo
)
{
    PUCHAR                  called_name;
    ULONG                   i;
    PNBT_HDR                nbt_hdrp = (PNBT_HDR)pPacketInfo->IP.TCP.Payload.pPayload;

    /* if this is an NBT session request packet, check to see if it's calling
       the cluster machine name, which should be replaced with the shadow name */

    // Do we have the machine name ?
    if (nbt_encoded_shadow_name[0] == 0) 
    {
        TRACE_CRIT("%!FUNC! No host name present to replace the cluster name with");
        return;
    }

    if (NBT_GET_PKT_TYPE (nbt_hdrp) == NBT_SESSION_REQUEST)
    {
        /* pass the field length byte - assume all names are
           NBT_ENCODED_NAME_LEN bytes long */

        called_name = NBT_GET_CALLED_NAME (nbt_hdrp) + 1;

        /* match called name to cluster name */

        for (i = 0; i < NBT_ENCODED_NAME_LEN; i ++)
        {
            if (called_name [i] != ctxtp -> nbt_encoded_cluster_name [i])
                break;
        }

        /* replace cluster computer name with the shadom name */

        if (i >= NBT_ENCODED_NAME_LEN)
        {
            USHORT      checksum;

            for (i = 0; i < NBT_ENCODED_NAME_LEN; i ++)
                called_name [i] = nbt_encoded_shadow_name [i];

            /* re-compute checksum */
            checksum = Tcpip_chksum(ctxtp, pPacketInfo, TCPIP_PROTOCOL_TCP);

            TCP_SET_CHKSUM (pPacketInfo->IP.TCP.pHeader, checksum);
        }
    }

} /* end Tcpip_nbt_handle */

USHORT Tcpip_chksum (
    PTCPIP_CTXT         ctxtp,
    PMAIN_PACKET_INFO   pPacketInfo,
    ULONG               prot)
{
    ULONG               checksum = 0, i, len;
    PUCHAR              ptr;
    USHORT              original;
    USHORT              usRet;

    /* Preserve original checksum.  Note that Main_{send/recv}_frame_parse ensures
       that we can safely touch all of the protocol headers (not options, however). */
    if (prot == TCPIP_PROTOCOL_TCP)
    {
        /* Grab the checksum and zero out the checksum in the header; checksums 
           over headers MUST be performed with zero in the checksum field. */
        original = TCP_GET_CHKSUM(pPacketInfo->IP.TCP.pHeader);
        TCP_SET_CHKSUM(pPacketInfo->IP.TCP.pHeader, 0);
    }
    else if (prot == TCPIP_PROTOCOL_UDP)
    {
        /* Grab the checksum and zero out the checksum in the header; checksums 
           over headers MUST be performed with zero in the checksum field. */
        original = UDP_GET_CHKSUM(pPacketInfo->IP.UDP.pHeader);
        UDP_SET_CHKSUM(pPacketInfo->IP.UDP.pHeader, 0);
    }
    else
    {
        /* Grab the checksum and zero out the checksum in the header; checksums 
           over headers MUST be performed with zero in the checksum field. */
        original = IP_GET_CHKSUM(pPacketInfo->IP.pHeader);
        IP_SET_CHKSUM(pPacketInfo->IP.pHeader, 0);
    }

    /* Computer appropriate checksum for specified protocol. */
    if (prot != TCPIP_PROTOCOL_IP)
    {
        /* Checksum is computed over the source IP address, destination IP address,
           protocol (6 for TCP), TCP segment length value and entire TCP segment.
           (setting checksum field within TCP header to 0).  Code is taken from page
           185 of "Internetworking with TCP/IP: Volume II" by Comer/Stevens, 1991. */

        ptr = (PUCHAR)IP_GET_SRC_ADDR_PTR(pPacketInfo->IP.pHeader);

        /* 2*IP_ADDR_LEN bytes = IP_ADDR_LEN shorts. */
        for (i = 0; i < IP_ADDR_LEN; i ++, ptr += 2)
            checksum += (ULONG)((ptr[0] << 8) | ptr[1]);
    }

    if (prot == TCPIP_PROTOCOL_TCP)
    {
        /* Calculate the IP datagram length (packet length minus the IP header). */
        len = IP_GET_PLEN(pPacketInfo->IP.pHeader) - IP_GET_HLEN(pPacketInfo->IP.pHeader) * sizeof(ULONG);

        /* Since we only have the indicated number of bytes that we can safely look
           at, if the calculated length happens to be larger, we cannot perform 
           this checksum, so bail out now. */
        if (len > pPacketInfo->IP.TCP.Length)
        {
            UNIV_PRINT_CRIT(("Tcpip_chksum: Length of the TCP buffer (%u) is less than the calculated packet size (%u)", pPacketInfo->IP.TCP.Length, len));
            TRACE_CRIT("%!FUNC! Length of the TCP buffer (%u) is less than the calculated packet size (%u)", pPacketInfo->IP.TCP.Length, len);

            /* Return an invalid checksum. */
            return 0xffff;
        }

        checksum += TCPIP_PROTOCOL_TCP + len;
        ptr = (PUCHAR)pPacketInfo->IP.TCP.pHeader;
    }
    else if (prot == TCPIP_PROTOCOL_UDP)
    {
        /* Calculate the IP datagram length (packet length minus the IP header). */
        len = IP_GET_PLEN(pPacketInfo->IP.pHeader) - IP_GET_HLEN(pPacketInfo->IP.pHeader) * sizeof(ULONG);

        /* Since we only have the indicated number of bytes that we can safely look
           at, if the calculated length happens to be larger, we cannot perform 
           this checksum, so bail out now. */
        if (len > pPacketInfo->IP.UDP.Length)
        {
            UNIV_PRINT_CRIT(("Tcpip_chksum: Length of the UDP buffer (%u) is less than the calculated packet size (%u)", pPacketInfo->IP.UDP.Length, len));
            TRACE_CRIT("%!FUNC! Length of the UDP buffer (%u) is less than the calculated packet size (%u)", pPacketInfo->IP.UDP.Length, len);

            /* Return an invalid checksum. */
            return 0xffff;
        }

        checksum += TCPIP_PROTOCOL_UDP + UDP_GET_LEN(pPacketInfo->IP.UDP.pHeader);
        ptr = (PUCHAR)pPacketInfo->IP.UDP.pHeader;
    }
    else
    {
        /* Calculate the IP header length. */
        len = IP_GET_HLEN(pPacketInfo->IP.pHeader) * sizeof(ULONG);

        /* Since we only have the indicated number of bytes that we can safely look
           at, if the calculated length happens to be larger, we cannot perform 
           this checksum, so bail out now. */
        if (len > pPacketInfo->IP.Length)
        {
            UNIV_PRINT_CRIT(("Tcpip_chksum: Length of the IP buffer (%u) is less than the calculated packet size (%u)", pPacketInfo->IP.Length, len));
            TRACE_CRIT("%!FUNC! Length of the IP buffer (%u) is less than the calculated packet size (%u)", pPacketInfo->IP.Length, len);

            /* Return an invalid checksum. */
            return 0xffff;
        }

        ptr = (PUCHAR)pPacketInfo->IP.pHeader;
    }

    /* Loop through the entire packet by USHORTs and calculate the checksum. */
    for (i = 0; i < len / 2; i ++, ptr += 2)
        checksum += (ULONG)((ptr[0] << 8) | ptr[1]);

    /* If the length is odd, handle the last byte.  Note that no current cases exist
       to test this odd-byte code.  IP, TCP and UDP headers are ALWAYS a multiple of 
       four bytes.  Therefore, this will only execute when the UDP/TCP payload is an 
       odd number of bytes.  NLB calls this function to calculate checksums for NetBT,
       remote control and our outgoing IGMP messages.  For NetBT, the payload of the
       packets we care about is ALWAYS 72 bytes.  NLB remote control messages are 
       ALWAYS 300 byte (in .Net, or 44 bytes in Win2k/NT) payloads.  Only the IP header
       checksum is calculated for an IGMP message.  Therefore, no case currently exists
       to test an odd length, but this is not magic we're doing here. */
    if (len % 2)
        checksum += (ULONG)(ptr[0] << 8);

    /* Add the two USHORTs the comprise the checksum together. */
    checksum = (checksum >> 16) + (checksum & 0xffff);

    /* Add the upper USHORT to the checksum. */
    checksum += (checksum >> 16);

    /* Restore original checksum. */
    if (prot == TCPIP_PROTOCOL_TCP)
    {
        TCP_SET_CHKSUM(pPacketInfo->IP.TCP.pHeader, original);
    }
    else if (prot == TCPIP_PROTOCOL_UDP)
    {
        UDP_SET_CHKSUM(pPacketInfo->IP.UDP.pHeader, original);
    }
    else
    {
        IP_SET_CHKSUM(pPacketInfo->IP.pHeader, original);
    }

    /* The final checksum is the two's compliment of the checksum. */
    usRet = (USHORT)(~checksum & 0xffff);

    return usRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\driver\trace.h ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    trace.h

Abstract:

    Windows Load Balancing Service (WLBS)
    Driver - Support for Windows Event Tracing

    Since currently NDIS and WPP event tracing don't mix well, WPP event
    tracing is accessed through a separate C file, trace.c, which doesn't
    include ndis.h.

    To keep the low foot print of Event Tracing, the following specialized
    macros should be used for tracing, as well as specialized tracing
    routines written for each thing traced.

Author:

    josephj

--*/


#ifndef _trace_h_
#define _trace_h_

VOID
Trace_Initialize(
    PVOID                         driver_obj,
    PVOID                         registry_path
    );

VOID
Trace_Deinitialize(VOID);

#endif // _trace_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\driver\prot.h ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    prot.h

Abstract:

    Windows Load Balancing Service (WLBS)
    Driver - lower-level (protocol) layer of intermediate miniport

Author:

    kyrilf

--*/


#ifndef _Prot_h_
#define _Prot_h_

#include <ndis.h>

#include "main.h"
#include "util.h"


/* PROCEDURES */


/* required NDIS protocol handlers */

extern VOID Prot_bind (
    PNDIS_STATUS        statusp,
    NDIS_HANDLE         bind_handle,
    PNDIS_STRING        device_name,
    PVOID               reg_path,
    PVOID               reserved);
/*
  Bind to underlying adapter

  returns VOID:

  function:
*/


extern VOID Prot_unbind (
    PNDIS_STATUS        statusp,
    NDIS_HANDLE         bind_handle,
    NDIS_HANDLE         unbind_handle);
/*
  Unbind from underlying adapter

  returns VOID:

  function:
*/


extern VOID Prot_close_complete (
    NDIS_HANDLE         bind_handle,
    NDIS_STATUS         statusp);
/*
  Completion handler for NdisCloseAdapter call

  returns VOID:

  function:
*/


extern VOID Prot_open_complete (
    NDIS_HANDLE         bind_handle,
    NDIS_STATUS         statusp,
    NDIS_STATUS         errorp);
/*
  Completion handler for NdisOpenAdapter call

  returns VOID:

  function:
*/


extern NDIS_STATUS Prot_recv_indicate (
    NDIS_HANDLE         bind_handle,
    NDIS_HANDLE         recv_handle,
    PVOID               head_buf,
    UINT                head_len,
    PVOID               look_buf,
    UINT                look_len,
    UINT                packet_len);
/*
  Process lookahead of a new packet

  returns NDIS_STATUS:

  function:
*/


extern VOID Prot_recv_complete (
    NDIS_HANDLE         bind_handle);
/*
  Handle post-receive operations when timing is relaxed

  returns VOID:

  function:
*/


extern INT Prot_packet_recv (
    NDIS_HANDLE         bind_handle,
    PNDIS_PACKET        packet);
/*
  Receive entire new packet

  returns INT:
    <number of clients using the packet>

  function:
*/


extern VOID Prot_request_complete (
    NDIS_HANDLE         bind_handle,
    PNDIS_REQUEST       request,
    NDIS_STATUS         status);
/*
  Completion handler for NdisRequest call

  returns VOID:

  function:
*/


extern VOID Prot_reset_complete (
    NDIS_HANDLE         bind_handle,
    NDIS_STATUS         status);
/*
  Completion handler for NdisReset call

  returns VOID:

  function:
*/


extern VOID Prot_send_complete (
    NDIS_HANDLE         bind_handle,
    PNDIS_PACKET        packet,
    NDIS_STATUS         status);
/*
  Completion handler for NdiSendPackets or NdisSend calls

  returns VOID:

  function:
*/


extern NDIS_STATUS Prot_PNP_handle (
    NDIS_HANDLE             ctxtp,
    PNET_PNP_EVENT          pnp_event);
/*
  PNP handler

  returns NDIS_STATUS:

  function:
*/


extern VOID Prot_status (
    NDIS_HANDLE         bind_handle,
    NDIS_STATUS         get_status,
    PVOID               stat_buf,
    UINT                stat_len);
/*
  Status indication from adapter handler

  returns VOID:

  function:
*/


extern VOID Prot_status_complete (
    NDIS_HANDLE         bind_handle);
/*
  Status indication from adapter completion handler

  returns VOID:

  function:
*/


extern VOID Prot_transfer_complete (
    NDIS_HANDLE         bind_handle,
    PNDIS_PACKET        packet,
    NDIS_STATUS         status,
    UINT                xferred);
/*
  Completion handler for NdiTransferDate calls

  returns VOID:

  function:
*/


/* helpers for nic layer */


extern NDIS_STATUS Prot_close (
    PMAIN_ADAPTER       adapterp);
/*
  Close underlying connection and free context

  returns NDIS_STATUS:

  function:
*/


extern NDIS_STATUS Prot_request (
    PMAIN_CTXT          ctxtp,
    PMAIN_ACTION        actp,
    ULONG               slave);
/*
  NdisRequest wrapper

  returns NDIS_STATUS:

  function:
*/


extern NDIS_STATUS Prot_reset (
    PMAIN_CTXT          ctxtp);
/*
  NdisRequest wrapper

  returns NDIS_STATUS:

  function:
*/


extern VOID Prot_packets_send (
    PMAIN_CTXT          ctxtp,
    PPNDIS_PACKET       packets,
    UINT                num);
/*
  NdisSendPackets wrapper

  returns NDIS_STATUS:

  function:
*/


extern VOID Prot_return (
    PMAIN_CTXT          ctxtp,
    PNDIS_PACKET        packet);
/*
  NdisReturnPackets wrapper

  returns NDIS_STATUS:

  function:
*/

/* Added from old code for NT 5.1 - ramkrish */
extern NDIS_STATUS Prot_transfer (
    PMAIN_CTXT          ctxtp,
    NDIS_HANDLE         recv_handle,
    PNDIS_PACKET        packet,
    UINT                offset,
    UINT                len,
    PUINT               xferred);
/*
  NdisTransferData wrapper

  returns NDIS_STATUS:

  function:
*/


/* This helper function added for using NDIS51 flag */
extern VOID Prot_cancel_send_packets (
    PMAIN_CTXT          ctxtp,
    PVOID               cancel_id);
/*
  NdisCancelSendPackets wrapper

  returns:

  function:
*/


#if 0 /* old code */

extern NDIS_STATUS Prot_send (
    PMAIN_CTXT          ctxtp,
    PNDIS_PACKET        packet,
    UINT                flags);
/*
  NdisSend wrapper

  returns NDIS_STATUS:

  function:
*/

#endif

#endif /* _Prot_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\driver\univ.c ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    univ.c

Abstract:

    Windows Load Balancing Service (WLBS)
    Driver - global variables

Author:

    kyrilf

--*/


#include <stdlib.h>
#include <ndis.h>

#include "univ.h"
#include "wlbsparm.h"

#if defined (NLB_TCP_NOTIFICATION)
#include <ntddnlb.h>
#endif

/* GLOBALS */

/* The global teaming list spin lock. */
NDIS_SPIN_LOCK          univ_bda_teaming_lock;
WCHAR                   empty_str [] = L"";
UNIV_IOCTL_HDLR         univ_ioctl_hdlr = NULL;
PVOID                   univ_driver_ptr = NULL;
NDIS_HANDLE             univ_driver_handle = NULL;
NDIS_HANDLE             univ_wrapper_handle = NULL;
NDIS_HANDLE             univ_prot_handle = NULL;
NDIS_HANDLE             univ_ctxt_handle = NULL;
NDIS_SPIN_LOCK          univ_bind_lock;
ULONG                   univ_changing_ip = 0;
NDIS_HANDLE             univ_device_handle = NULL;
PDEVICE_OBJECT          univ_device_object = NULL;
ULONG                   univ_tcp_cleanup = TRUE;
#if defined (NLB_TCP_NOTIFICATION)
ULONG                   univ_notification = NLB_CONNECTION_CALLBACK_TCP;
PCALLBACK_OBJECT        univ_tcp_callback_object = NULL;
PVOID                   univ_tcp_callback_function = NULL;
PCALLBACK_OBJECT        univ_alternate_callback_object = NULL;
PVOID                   univ_alternate_callback_function = NULL;
#endif
NDIS_PHYSICAL_ADDRESS   univ_max_addr = NDIS_PHYSICAL_ADDRESS_CONST (-1,-1);
NDIS_MEDIUM             univ_medium_array [UNIV_NUM_MEDIUMS] = UNIV_MEDIUMS;
UNICODE_STRING          DriverEntryRegistryPath;
PWCHAR                  univ_reg_path = NULL;
ULONG                   univ_reg_path_len = 0;
NDIS_OID                univ_oids [UNIV_NUM_OIDS] =
                                       { OID_GEN_SUPPORTED_LIST,
                                         OID_GEN_HARDWARE_STATUS,
                                         OID_GEN_MEDIA_SUPPORTED,
                                         OID_GEN_MEDIA_IN_USE,
                                         OID_GEN_MAXIMUM_LOOKAHEAD,
                                         OID_GEN_MAXIMUM_FRAME_SIZE,
                                         OID_GEN_LINK_SPEED,
                                         OID_GEN_TRANSMIT_BUFFER_SPACE,
                                         OID_GEN_RECEIVE_BUFFER_SPACE,
                                         OID_GEN_TRANSMIT_BLOCK_SIZE,
                                         OID_GEN_RECEIVE_BLOCK_SIZE,
                                         OID_GEN_VENDOR_ID,
                                         OID_GEN_VENDOR_DESCRIPTION,
                                         OID_GEN_CURRENT_PACKET_FILTER,
                                         OID_GEN_CURRENT_LOOKAHEAD,
                                         OID_GEN_DRIVER_VERSION,
                                         OID_GEN_MAXIMUM_TOTAL_SIZE,
                                         OID_GEN_PROTOCOL_OPTIONS,
                                         OID_GEN_MAC_OPTIONS,
                                         OID_GEN_MEDIA_CONNECT_STATUS,
                                         OID_GEN_MAXIMUM_SEND_PACKETS,
                                         OID_GEN_VENDOR_DRIVER_VERSION,
                                         OID_GEN_XMIT_OK,
                                         OID_GEN_RCV_OK,
                                         OID_GEN_XMIT_ERROR,
                                         OID_GEN_RCV_ERROR,
                                         OID_GEN_RCV_NO_BUFFER,
                                         OID_GEN_DIRECTED_BYTES_XMIT,
                                         OID_GEN_DIRECTED_FRAMES_XMIT,
                                         OID_GEN_MULTICAST_BYTES_XMIT,
                                         OID_GEN_MULTICAST_FRAMES_XMIT,
                                         OID_GEN_BROADCAST_BYTES_XMIT,
                                         OID_GEN_BROADCAST_FRAMES_XMIT,
                                         OID_GEN_DIRECTED_BYTES_RCV,
                                         OID_GEN_DIRECTED_FRAMES_RCV,
                                         OID_GEN_MULTICAST_BYTES_RCV,
                                         OID_GEN_MULTICAST_FRAMES_RCV,
                                         OID_GEN_BROADCAST_BYTES_RCV,
                                         OID_GEN_BROADCAST_FRAMES_RCV,
                                         OID_GEN_RCV_CRC_ERROR,
                                         OID_GEN_TRANSMIT_QUEUE_LENGTH,
                                         OID_802_3_PERMANENT_ADDRESS,
                                         OID_802_3_CURRENT_ADDRESS,
                                         OID_802_3_MULTICAST_LIST,
                                         OID_802_3_MAXIMUM_LIST_SIZE,
                                         OID_802_3_MAC_OPTIONS,
                                         OID_802_3_RCV_ERROR_ALIGNMENT,
                                         OID_802_3_XMIT_ONE_COLLISION,
                                         OID_802_3_XMIT_MORE_COLLISIONS,
                                         OID_802_3_XMIT_DEFERRED,
                                         OID_802_3_XMIT_MAX_COLLISIONS,
                                         OID_802_3_RCV_OVERRUN,
                                         OID_802_3_XMIT_UNDERRUN,
                                         OID_802_3_XMIT_HEARTBEAT_FAILURE,
                                         OID_802_3_XMIT_TIMES_CRS_LOST,
                                         OID_802_3_XMIT_LATE_COLLISIONS };


/* PROCEDURES */


VOID Univ_ndis_string_alloc (
    PNDIS_STRING            string,
    PCHAR                   src)
{
    PWCHAR                  tmp;


    /* allocate enough space for the string */

    string -> Length = strlen (src) * sizeof (WCHAR);
    string -> MaximumLength = string -> Length + sizeof (WCHAR);

    NdisAllocateMemoryWithTag (& (string -> Buffer), string -> MaximumLength,
                               UNIV_POOL_TAG);

    if (string -> Buffer == NULL)
    {
        string -> Length = 0;
        string -> MaximumLength = 0;
        return;
    }

    /* copy characters */

    tmp = string -> Buffer;

    while (* src != '\0')
    {
        * tmp = (WCHAR) (* src);
        src ++;
        tmp ++;
    }

    * tmp = UNICODE_NULL;

} /* end Univ_ndis_string_free */


VOID Univ_ndis_string_free (
    PNDIS_STRING            string)
{
    if (string -> Buffer == NULL)
        return;

    /* free memory */

    NdisFreeMemory (string -> Buffer, string -> MaximumLength, 0);
    string -> Length = 0;
    string -> MaximumLength = 0;

} /* end Univ_ndis_string_free */


VOID Univ_ansi_string_alloc (
    PANSI_STRING            string,
    PWCHAR                  src)
{
    PCHAR                   tmp;
    PWCHAR                  wtmp;
    USHORT                  len;


    /* compute length of the string in characters */

    wtmp = src;
    len = 0;

    while (* wtmp != UNICODE_NULL)
    {
        len ++;
        wtmp ++;
    }

    /* allocate enough space for the string */

    string -> Length = len;
    string -> MaximumLength = len + sizeof (CHAR);

    NdisAllocateMemoryWithTag (& (string -> Buffer), string -> MaximumLength,
                               UNIV_POOL_TAG);

    if (string -> Buffer == NULL)
    {
        string -> Length = 0;
        string -> MaximumLength = 0;
        return;
    }

    /* copy characters */

    tmp = string -> Buffer;

    while (* src != '\0')
    {
        * tmp = (CHAR) (* src);
        src ++;
        tmp ++;
    }

    * tmp = 0;

} /* end Univ_ansi_string_free */


VOID Univ_ansi_string_free (
    PANSI_STRING        string)
{
    if (string == NULL)
        return;

    /* free memory */

    NdisFreeMemory (string -> Buffer, string -> MaximumLength, 0);
    string -> Length = 0;
    string -> MaximumLength = 0;

} /* end Univ_ansi_string_free */


ULONG   Univ_str_to_ulong (
    PULONG          retp,
    PWCHAR          start_ptr,
    PWCHAR *        end_ptr,
    ULONG           width,
    ULONG           base)
{
    PWCHAR          ptr;
    WCHAR           c;
    ULONG           number = 0;
    ULONG           val, pos = 0;


    /* check base */

    if (base != 2 && base != 8 && base != 10 && base != 16)
    {
        if (end_ptr != NULL)
            * end_ptr = start_ptr;

        return FALSE;
    }

    /* skip space */

    ptr = start_ptr;
    number = 0;

    while (* ptr == 0x20)
        ptr ++;

    /* extract digits and build the number */

    while (pos < width)
    {
        c = * ptr;

        if (0x30 <= c && c <= 0x39)
            val = c - 0x30;
        else if (0x41 <= c && c <= 0x46)
            val = c - 0x41 + 0xa;
        else if (0x61 <= c && c <= 0x66)
            val = c - 0x61 + 0xa;
        else
            break;

        if (val >= base)
            break;

        number = number * base + val;

        ptr ++;
        pos ++;
    }

    /* makre sure we extracted something */

    if (pos == 0)
    {
        ptr = start_ptr;
        * retp = 0;
        return FALSE;
    }

    /* return resulting number */

    if (end_ptr != NULL)
        * end_ptr = ptr;

    * retp = number;
    return TRUE;

} /* end Univ_str_to_ulong */


PWCHAR Univ_ulong_to_str (
    ULONG           val,
    PWCHAR          buf,
    ULONG           base)
{
    ULONG           dig;
    PWCHAR          p, sav;
    WCHAR           tmp;


    /* check base */

    if (base != 2 && base != 8 && base != 10 && base != 16)
    {
        buf [0] = 0;
        return buf;
    }

    /* extract digits from the number and output to string */

    p = buf;

    do
    {
        /* get next digit */

        dig = (ULONG) (val % base);
        val /= base;

        /* convert to ascii and store */

        if (dig > 9)
            * p = (CHAR) (dig - 10 + L'a');
        else
            * p = (CHAR) (dig + L'0');

        p ++;
    }
    while (val > 0);

    * p = 0;
    sav = p;

    /* swap the characters, since operation above creates inverted string */

    p --;

    do
    {
        tmp = * p;
        * p = * buf;
        * buf = tmp;
        p --; buf ++;
    }
    while (buf < p);       /* repeat until halfway */

    return sav;

} /* end Univ_ulong_to_str */

void Univ_ip_addr_ulong_to_str (
    ULONG           val,
    PWCHAR          buf)
{
    int             idx;
    PWCHAR          str_begin, str_end, cur_str;
    PUCHAR          ptr;
    WCHAR           tmp;
    UCHAR           cur_val;

    // Access the ip address in the dword as an array of bytes
    ptr = (PUCHAR)&val;

    cur_str = str_begin = buf;
    
    for (idx = 0 ; idx < 4 ; idx++) 
    {
        // Get current byte
        cur_val = *ptr++;

        // Convert current byte to string
        do
        {
            *cur_str = (cur_val % 10) + L'0';
            cur_val /= 10;
            cur_str++;
        }
        while (cur_val > 0);

        // Swap the characters, since operation above creates inverted string. 
        // There could atmost be three characters ("255" is the highest), 
        // so, it is enough if we swap once. In other words, a "if" will do 
        // in the place of a "while" in the below loop.
        str_end = cur_str - 1;
        if (str_begin < str_end)       
        {
            tmp        = *str_end;
            *str_end   = *str_begin;
            *str_begin = tmp;
        }

        *cur_str = L'.';

        // Position the destination string to fill in the next byte as a string
        str_begin = ++cur_str;
    }

    // Overwrite the last '.' with the Null terminator
    *(cur_str - 1) = UNICODE_NULL;

    return; 

} /* end Univ_ip_addr_ulong_to_str */

BOOL Univ_equal_unicode_string (PWSTR string1, PWSTR string2, ULONG length)
{
    /* Loop until "length" characters have been compared. */
    while (length > 0) {
        /* If the two characters are not equal, then check to see if they only
           differ by case - if so, its ok, if not, the strings are not equal. */
        if (*string1 != *string2) {
            /* Convert uppercase letters to a lowercase comparison: A - Z */
            if ((*string1 >= 65) && (*string1 <= 90)) {
                if (*string2 != (*string1 + 32)) return FALSE;
            /* Convert lowercase letters to an uppercase comparison: a - z */
            } else if ((*string1 >= 97) && (*string1 <= 122)) {
                if (*string2 != (*string1 - 32)) return FALSE;
            /* If the character is not a letter, then it must match exactly - fail. */
            } else {
                return FALSE;
            }
        }
        
        /* Increment the string pointers and decrement the 
           number of characters left to check. */
        string1++;
        string2++;
        length--;
    }
    
    /* If we got this far, the strings match. */
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\driver\test\tdiplist.c ===
#include "twlbssys.h"
#include "diplist.h"


BOOL test_diplist(void)
{
    BOOL fRet;
    DIPLIST dl;
    int TestNo=0;

    DipListInitialize(&dl);

    DipListClear(&dl);

    DipListSetItem(&dl, 0, 1);

    TestNo=0;
    fRet = DipListCheckItem(&dl, 1);
    if (!fRet) goto end_fail;   // Couldn't find item 1

    TestNo=1;
    fRet = DipListCheckItem(&dl, 2);
    if (fRet) goto end_fail; // we found item "2", but we shouldn't

    DipListSetItem(&dl, 0, 0);

    TestNo=2;
    fRet = DipListCheckItem(&dl, 1);
    if (fRet) goto end_fail; // we found item 1, but we shouldn't

    DipListDeinitialize(&dl);

    wprintf(L"test_diplist: SUCCEEDED!\n");

    return TRUE;

end_fail:

    wprintf(L"DIPLIST Test#%lu failed!\n", TestNo);

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\driver\univ.h ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    univ.h

Abstract:

    Windows Load Balancing Service (WLBS)
    Driver - global definitions

Author:

    kyrilf

--*/

#ifndef _Univ_h_
#define _Univ_h_

#include <ndis.h>

#include "wlbsparm.h"

/* CONSTANTS */

/* debugging constants and macros */

#undef  ASSERT
#define ASSERT(v)

#define CVY_ASSERT_CODE             0xbfc0a55e

#if DBG

#define UNIV_PRINT_INFO(msg)        {                                                              \
                                      DbgPrint ("NLB (Information) [%s:%d] ", __FILE__, __LINE__); \
                                      DbgPrint msg;                                                \
                                      DbgPrint ("\n");                                             \
                                    }

#define UNIV_PRINT_CRIT(msg)        {                                                        \
                                      DbgPrint ("NLB (Error) [%s:%d] ", __FILE__, __LINE__); \
                                      DbgPrint msg;                                          \
                                      DbgPrint ("\n");                                       \
                                    }

#if 0 /* Turn off these debug prints by default. */

#define UNIV_PRINT_VERB(msg)        {                                                          \
                                      DbgPrint ("NLB (Verbose) [%s:%d] ", __FILE__, __LINE__); \
                                      DbgPrint msg;                                            \
                                      DbgPrint ("\n");                                         \
                                    }

#else

#define UNIV_PRINT_VERB(msg)

#endif

#define UNIV_ASSERT(c)              if (!(c)) KeBugCheckEx (CVY_ASSERT_CODE, log_module_id, __LINE__, 0, 0);

#define UNIV_ASSERT_VAL(c,v)        if (!(c)) KeBugCheckEx (CVY_ASSERT_CODE, log_module_id, __LINE__, v, 0);

#define UNIV_ASSERT_VAL2(c,v1,v2)   if (!(c)) KeBugCheckEx (CVY_ASSERT_CODE, log_module_id, __LINE__, v1, v2);

/* TRACE_... defines below toggle emmition of particular types of debug output */
#if 0
#define TRACE_PARAMS        /* registry parameter initialization (params.c) */
#define TRACE_RCT           /* remote control request processing (main.c) */
#define TRACE_RCVRY         /* packet filtering (load.c) */
#define TRACE_FRAGS         /* IP packet fragmentation (main.c) */
#define TRACE_ARP           /* ARP packet processing (main.c) */
#define TRACE_OID           /* OID info/set requests (nic.c) */
#define TRACE_DSCR          /* descriptor timeout and removal (load.c) */
#define TRACE_CVY           /* Convoy packet processing (main.c) */
#define PERIODIC_RESET      /* reset underlying NIC periodically for testing see main.c, prot.c for usage */
#define NO_CLEANUP          /* do not cleanup host map (load.c) */
#endif

#else /* DBG */

#define UNIV_PRINT_INFO(msg)
#define UNIV_PRINT_VERB(msg)
#define UNIV_PRINT_CRIT(msg)
#define UNIV_ASSERT(c)
#define UNIV_ASSERT_VAL(c,v)
#define UNIV_ASSERT_VAL2(c,v1,v2)

#endif /* DBG */

#define UNIV_POOL_TAG               'SBLW'

/* constants for some NDIS routines */

#define UNIV_WAIT_TIME              0
#define UNIV_NDIS_MAJOR_VERSION_OLD 4
#define UNIV_NDIS_MAJOR_VERSION     5 /* #ps# */
#define UNIV_NDIS_MINOR_VERSION     1 /* NT 5.1 */

/* Convoy protocol name to be reported to NDIS during binding */

#define UNIV_NDIS_PROTOCOL_NAME     NDIS_STRING_CONST ("WLBS")

/* supported medium types */

#define UNIV_NUM_MEDIUMS            1
#define UNIV_MEDIUMS                { NdisMedium802_3 }

/* number of supported OIDs (some are supported by Convoy directly and some
   are passed down to the underlying drivers) */

#define UNIV_NUM_OIDS               56


/* TYPES */

/* some procedure types */

typedef NDIS_STATUS (* UNIV_IOCTL_HDLR) (PVOID, PVOID);


/* GLOBALS */

/* The global teaming list spin lock. */
extern NDIS_SPIN_LOCK      univ_bda_teaming_lock;
extern UNIV_IOCTL_HDLR     univ_ioctl_hdlr;     /* preserved NDIS IOCTL handler */
extern PVOID               univ_driver_ptr;     /* driver pointer passed during
                                                   initialization */
extern NDIS_HANDLE         univ_driver_handle;  /* driver handle */
extern NDIS_HANDLE         univ_wrapper_handle; /* NDIS wrapper handle */
extern NDIS_HANDLE         univ_prot_handle;    /* NDIS protocol handle */
extern NDIS_HANDLE         univ_ctxt_handle;    /* Convoy context handle */
extern UNICODE_STRING      DriverEntryRegistryPath;  /* registry path name passed during initialization
                                                        (i.e. DriverEntry()) */

extern PWSTR               univ_reg_path;       /* registry path name passed during initialization 
                                                   (i.e. DriverEntry()) + "\\Parameters\\Interface" */
extern ULONG               univ_reg_path_len;
extern NDIS_SPIN_LOCK      univ_bind_lock;      /* protects access to univ_bound
                                                    and univ_announced */
extern ULONG               univ_changing_ip;    /* IP address change in process */
extern NDIS_PHYSICAL_ADDRESS univ_max_addr;     /* maximum physical address
                                                   constant to be passed to
                                                   NDIS memory allocation calls */
extern NDIS_MEDIUM         univ_medium_array [];/* supported medium types */
extern NDIS_OID            univ_oids [];        /* list of supported OIDs */
extern WCHAR               empty_str [];
extern NDIS_HANDLE         univ_device_handle;
extern PDEVICE_OBJECT      univ_device_object;

extern ULONG               univ_tcp_cleanup;                    /* Whether or not TCP cleanup polling should be performed. */

/* Use this macro to determine whether or not TCP connection state purging is enabled. 
   This cleanup is always on unless IPNAT.sys is detected, in which case querying TCP
   is unreliable; this is not configurable via the registry or an IOCTL. */
#define NLB_TCP_CLEANUP_ON() (univ_tcp_cleanup)

#if defined (NLB_TCP_NOTIFICATION)
extern ULONG               univ_notification;                   /* What notification scheme is in use, if any. 
                                                                 0 = NLB_CONNECTION_CALLBACK_NONE
                                                                 1 = NLB_CONNECTION_CALLBACK_TCP
                                                                 2 = NLB_CONNECTION_CALLBACK_ALTERNATE */
extern PCALLBACK_OBJECT    univ_tcp_callback_object;            /* The TCP connection notification callback object. */
extern PVOID               univ_tcp_callback_function;          /* The TCP connection notification callback function.
                                                                   Needed to de-register the callback function later. */
extern PCALLBACK_OBJECT    univ_alternate_callback_object;      /* The NLB public connection notification callback object. */
extern PVOID               univ_alternate_callback_function;    /* The NLB public connection notification callback function.
                                                                   Needed to de-register the callback function later. */

/* Use this macro to determine whether or not connection notifications have been enabled. */
#define NLB_NOTIFICATIONS_ON()          ((univ_notification == NLB_CONNECTION_CALLBACK_TCP) || (univ_notification == NLB_CONNECTION_CALLBACK_ALTERNATE))
#define NLB_TCP_NOTIFICATION_ON()       (univ_notification == NLB_CONNECTION_CALLBACK_TCP)
#define NLB_ALTERNATE_NOTIFICATION_ON() (univ_notification == NLB_CONNECTION_CALLBACK_ALTERNATE)

#endif

/* PROCEDURES */


extern VOID Univ_ndis_string_alloc (
    PNDIS_STRING            string,
    PCHAR                   src);
/*
  Allocates NDIS string and copies contents of character string to it

  returns VOID:

  function:
*/


extern VOID Univ_ndis_string_free (
    PNDIS_STRING            string);
/*
  Frees memory previously allocated for the NDIS string

  returns VOID:

  function:
*/


extern VOID Univ_ansi_string_alloc (
    PANSI_STRING            string,
    PWCHAR                  src);
/*
  Allocates NDIS string and copies contents of character string to it

  returns VOID:

  function:
*/


extern VOID Univ_ansi_string_free (
    PANSI_STRING            string);
/*
  Frees memory previously allocated for the NDIS string

  returns VOID:

  function:
*/


extern ULONG   Univ_str_to_ulong (
    PULONG                  retp,
    PWCHAR                  start_ptr,
    PWCHAR *                end_ptr,
    ULONG                   width,
    ULONG                   base);
/*
  Converts string representaion of a number to a ULONG value

  returns ULONG  :
    TRUE  => success
    FALSE => failure

  function:
*/


extern PWCHAR Univ_ulong_to_str (
    ULONG                   val,
    PWCHAR                  buf,
    ULONG                   base);
/*
  Converts ULONG value to a string representation in specified base

  returns PWCHAR:
    <pointer to the symbol in the string following the converted number>

  function:
*/

/* Compare "length" characters of two unicode strings - case insensitive. */
extern BOOL Univ_equal_unicode_string (PWSTR string1, PWSTR string2, ULONG length);


/* Converts an ip address of integer type to string(with '.'s) */
extern void Univ_ip_addr_ulong_to_str (
    ULONG           val,
    PWCHAR          buf);


#endif /* _Univ_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\driver\test\twlbssys.c ===
/*++ Copyright(c) 2001  Microsoft Corporation

Module Name:

    NLB Manager

File Name:

    twlbssys.cpp

Abstract:

    Sub-component test harness for NLB Driver (wlbs.sys)

History:

04/24/2002  JosephJ Created

--*/
#include "twlbssys.h"
#include "twlbssys.tmh"


int __cdecl wmain(int argc, WCHAR* argv[], WCHAR* envp[])
{
    BOOL fRet = FALSE;

    //
    // Enable tracing
    //
    WPP_INIT_TRACING(L"Microsoft\\NLB\\TPROV");


    //
    // Call subcomponent tests, bail if any fail.
    //

    if (!test_diplist()) goto end;

    fRet = TRUE;

end:
    //
    // Disable tracing
    //
    WPP_CLEANUP();

    return fRet ? 0 : 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\driver\util.h ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    util.h

Abstract:

    Windows Load Balancing Service (WLBS)
    Driver - media support definitions

Author:

    kyrilf

--*/


#ifndef _Util_h_
#define _Util_h_

#include <ndis.h>
#include <xfilter.h>

#include "wlbsparm.h"


/* CONSTANTS */


/* media-specific constants */

#define ETHERNET_DESTINATION_FIELD_OFFSET   0
#define ETHERNET_SOURCE_FIELD_OFFSET        6
#define ETHERNET_LENGTH_FIELD_OFFSET        12
#define ETHERNET_LENGTH_FIELD_SIZE          2
#define ETHERNET_ADDRESS_FIELD_SIZE         6
#define ETHERNET_HEADER_SIZE                14

/* flags are in byte 0 of ethernet address */

#define ETHERNET_GROUP_FLAG                 0x1
#define ETHERNET_LAA_FLAG                   0x2

/* max frame size we expect to generate */

#define CVY_MAX_FRAME_SIZE                  1500


/* TYPES */


#pragma pack(1)

/* ethernet media header type */

typedef struct
{
    UCHAR            data [ETHERNET_ADDRESS_FIELD_SIZE];
}
CVY_ETHERNET_ADR, * PCVY_ETHERNET_ADR;

typedef struct
{
    UCHAR            data [ETHERNET_LENGTH_FIELD_SIZE];
}
CVY_ETHERNET_LEN, * PCVY_ETHERNET_LEN;

typedef struct
{
    CVY_ETHERNET_ADR        dst;
    CVY_ETHERNET_ADR        src;
    CVY_ETHERNET_LEN        len;
}
CVY_ETHERNET_HDR, * PCVY_ETHERNET_HDR;

typedef union
{
    CVY_ETHERNET_HDR   ethernet;
}
CVY_MEDIA_HDR, * PCVY_MEDIA_HDR;

typedef union
{
    CVY_ETHERNET_ADR   ethernet;
}
CVY_MAC_ADR, * PCVY_MAC_ADR;

/* V1.3.1b medium independent MAC address manipulation routines - note that these 
   are optimized for speed and assume that all mediums have the same size addresses.
   NOTE: The seemingly silly format of these macros is simply to leave fenceposts
   for the future additions of other supported mediums. */
#define CVY_MAC_SRC_OFF(m)             (ETHERNET_SOURCE_FIELD_OFFSET)
#define CVY_MAC_DST_OFF(m)             (ETHERNET_DESTINATION_FIELD_OFFSET)
#define CVY_MAC_HDR_LEN(m)             (sizeof (CVY_ETHERNET_HDR))
#define CVY_MAC_ADDR_LEN(m)            (ETHERNET_ADDRESS_FIELD_SIZE)

#define CVY_MAC_ADDR_BCAST(m,a)        (((PUCHAR)(a))[0] == 0xff)
#define CVY_MAC_ADDR_MCAST(m,a)        (((PUCHAR)(a))[0] & 0x1)
#define CVY_MAC_ADDR_GROUP_SET(m,a)    ((((PUCHAR)(a))[0]) |= 0x1)
#define CVY_MAC_ADDR_GROUP_TOGGLE(m,a) ((((PUCHAR)(a))[0]) ^= 0x1)
#define CVY_MAC_ADDR_LAA_SET(m,a)      ((((PUCHAR)(a))[0]) |= 0x2)
#define CVY_MAC_ADDR_LAA_TOGGLE(m,a)   ((((PUCHAR)(a))[0]) ^= 0x2)
#define CVY_MAC_ADDR_COMP(m,a,b)       ((* (ULONG UNALIGNED *)(a) == * (ULONG UNALIGNED *)(b)) && \
                                        (* (USHORT UNALIGNED *)((PUCHAR)(a) + sizeof (ULONG)) ==    \
                                         * (USHORT UNALIGNED *)((PUCHAR)(b) + sizeof (ULONG))))
#define CVY_MAC_ADDR_COPY(m,d,s)       ((* (ULONG UNALIGNED *)(d) = * (ULONG UNALIGNED *)(s)), \
                                        (* (USHORT UNALIGNED *)((PUCHAR)(d) + sizeof (ULONG)) = \
                                         * (USHORT UNALIGNED *)((PUCHAR)(s) + sizeof (ULONG))))
#if DBG
#define CVY_MAC_ADDR_PRINT(m,s,a)      UNIV_PRINT_VERB(("%s %02X-%02X-%02X-%02X-%02X-%02X\n", s, ((PUCHAR)(a))[0], ((PUCHAR)(a))[1], ((PUCHAR)(a))[2], ((PUCHAR)(a))[3], ((PUCHAR)(a))[4], ((PUCHAR)(a))[5]))
#else
#define CVY_MAC_ADDR_PRINT(m,s,a)
#endif

/* Medium type field manipulation routines */
#define CVY_ETHERNET_ETYPE_SET(p,l)    ((PUCHAR) (p)) [ETHERNET_LENGTH_FIELD_OFFSET] = (UCHAR) ((l) >> 8); \
                                       ((PUCHAR) (p)) [ETHERNET_LENGTH_FIELD_OFFSET + 1] = (UCHAR) (l)
#define CVY_ETHERNET_ETYPE_GET(p)      (((USHORT) ((PUCHAR) (p)) [ETHERNET_LENGTH_FIELD_OFFSET]) << 8) | \
                                       ((USHORT) ((PUCHAR) (p)) [ETHERNET_LENGTH_FIELD_OFFSET + 1])

#pragma pack()

#define ASIZECCH(_array) (sizeof(_array)/sizeof((_array)[0]))

#endif /* _Util_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\driver\test\twlbssys.h ===
#include <wlbsparm.h>
#include <stdio.h>
#include <assert.h>
// #include <windows.h>
// #include <ntdef.h>
// #include <nturtl.h>

BOOL test_diplist(void);

#define ASSERT  assert
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\inc\nlb_portrule.h ===
/*
 * Filename: NLB_PortRule.h
 * Description: 
 * Author: shouse, 04.10.01
 */
#ifndef __NLB_PORTRULE_H__
#define __NLB_PORTRULE_H__

#include "NLB_Common.h"

#include <vector>
#include <string>
#include <map>
using namespace std;

class NLB_PortRule {
public:
    NLB_PortRule();
    ~NLB_PortRule();

    bool IsValid ();

    void Clear ();

    bool SetName (PWCHAR pName);
    bool GetName (PWCHAR pName, ULONG length);
    
    bool SetLabel (PWCHAR pLabel);
    bool GetLabel (PWCHAR pLabel, ULONG length);

    bool SetPortRange (ULONG start, ULONG end);
    bool GetPortRange (ULONG & start, ULONG & end);

    bool SetVirtualIPAddress (NLB_IPAddress address);
    bool GetVirtualIPAddress (NLB_IPAddress & address);

    bool SetState (NLB_PortRuleState::NLB_PortRuleStateType eState);
    bool GetState (NLB_PortRuleState::NLB_PortRuleStateType & eState);

    bool SetProtocol (NLB_PortRuleProtocol::NLB_PortRuleProtocolType eProtocol);
    bool GetProtocol (NLB_PortRuleProtocol::NLB_PortRuleProtocolType & eProtocol);

    bool SetFilteringMode (NLB_PortRuleFilteringMode::NLB_PortRuleFilteringModeType eMode);
    bool GetFilteringMode (NLB_PortRuleFilteringMode::NLB_PortRuleFilteringModeType & eMode);

    bool SetAffinity (NLB_PortRuleAffinity::NLB_PortRuleAffinityType eAffinity);
    bool GetAffinity (NLB_PortRuleAffinity::NLB_PortRuleAffinityType & eAffinity);

    bool AddSingleHostFilteringPriority (PWCHAR pHost, ULONG priority);
    bool ChangeSingleHostFilteringPriority (PWCHAR pHost, ULONG priority);
    bool GetSingleHostFilteringPriority (PWCHAR pHost, ULONG & priority);
    bool RemoveSingleHostFilteringPriority (PWCHAR pHost);

    ULONG SetSingleHostFilteringPriorityList (vector<NLB_PortRulePriority> pList);
    ULONG GetSingleHostFilteringPriorityList (vector<NLB_PortRulePriority> * pList);

    bool AddMultipleHostFilteringLoadWeight (PWCHAR pHost, ULONG weight);
    bool ChangeMultipleHostFilteringLoadWeight (PWCHAR pHost, ULONG weight);
    bool GetMultipleHostFilteringLoadWeight (PWCHAR pHost, ULONG & weight);
    bool RemoveMultipleHostFilteringLoadWeight (PWCHAR pHost);

    ULONG SetMultipleHostFilteringLoadWeightList (vector<NLB_PortRuleLoadWeight> pList);
    ULONG GetMultipleHostFilteringLoadWeightList (vector<NLB_PortRuleLoadWeight> * pList);

private:

    NLB_Name                                Name;
    NLB_Label                               Label;
    NLB_PortRuleState                       State;

    NLB_IPAddress                           VirtualIPAddress;
    NLB_PortRulePortRange                   Range;
    NLB_PortRuleProtocol                    Protocol;

    NLB_PortRuleFilteringMode               FilteringMode;
    NLB_PortRuleAffinity                    Affinity;
    NLB_SingleHostFilteringPriorityList     PriorityList;
    NLB_MultipleHostFilteringLoadWeightList LoadWeightList;
};

typedef map<wstring, NLB_PortRule, less<wstring> > NLB_PortRuleList;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\driver\test\map\main.cpp ===
#include <windows.h>
#include <stdio.h>

#if 0
UCHAR key[] = { 0x67, 0xdf, 0x40, 0xd3, 0x4d, 0xd2, 0x34, 0x6e, 0x98, 0x2e, 0xca, 0x8c, 0x01, 0x81, 0xb4, 0x88 };

/* Old code. */
ULONG Map (ULONG v1, ULONG v2) {
    ULONG y = v1;
    ULONG z = v2;
    ULONG sum = 0;

    ULONG a = key [0];
    ULONG b = key [1];
    ULONG c = key [2];
    ULONG d = key [3];

    ULONG delta = 0x9E3779B9;

    ULONG n = 8;
    ULONG value;

    while (n-- > 0) {
        sum += delta;
        y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
        z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;
    }

    value = y ^ z;

    return value;
}
#endif

/* New code with unrolled loop. */
ULONG Map (ULONG v1, ULONG v2) {
    ULONG y = v1;
    ULONG z = v2;
    ULONG sum = 0;

    const ULONG a = 0x67; //key [0];
    const ULONG b = 0xdf; //key [1];
    const ULONG c = 0x40; //key [2];
    const ULONG d = 0xd3; //key [3];

    const ULONG delta = 0x9E3779B9;

    sum += delta;
    y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
    z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;

    sum += delta;
    y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
    z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;

    sum += delta;
    y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
    z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;

    sum += delta;
    y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
    z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;

    sum += delta;
    y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
    z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;

    sum += delta;
    y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
    z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;

    sum += delta;
    y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
    z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;

    sum += delta;
    y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
    z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;

    return y ^ z;
}

int __cdecl wmain (int argc, char ** argv) {
    ULONG id = 0;
    ULONG bin = 0;
    ULONG hash = 0;
    ULONG client_ipaddr = 0x65040c0c;
    USHORT svr_port = 0x844;
    USHORT client_port = 0x8b;
    
    id = Map(client_ipaddr, ((svr_port << 16) + client_port));
    
    bin = id % 60;
    hash = id % 4096;
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\inc\debug.h ===
#ifndef DEBUG_H
#define DEBUG_H

#ifdef __cplusplus
extern "C" {
#endif

#include <windows.h>

//
// Macros for debugging support.
//
// ASSERT(exp)   Popup a dialogbox, if exp is FALSE
// ASSERTMSG(exp, msg)  Similar to ASSERT.  Except the msg is displayed instead of the expression
//
// USE VERIFY for expressions executed for both debug and release version
//

#undef ASSERT
#undef ASSERTMSG

/*
//
// Used by atl
//
#ifdef _ATL_NO_DEBUG_CRT
#define _ASSERTE ASSERT
#define _ASSERT ASSERT
#endif
*/

#ifdef DBG
#define DEBUG
#endif

#if ( defined(DEBUG) || defined(_DEBUG))

#define AssertMessage AssertMessageW

void AssertMessage(const TCHAR *pszFile, unsigned nLine, const TCHAR *pszMsg);

#define ASSERT(x)       (void)((x) || (AssertMessage(TEXT(__FILE__),__LINE__,TEXT(#x)),0))
#define ASSERTMSG(exp, msg)   (void)((exp) || (AssertMessage(TEXT(__FILE__),__LINE__,msg),0))

#define VERIFY(x)           ASSERT(x)

#define ASSERT_VALID(pObj) ((ASSERT(pObj),1) && ((pObj)->AssertValid(),1))

#else // DEBUG

#define ASSERT_VALID(pObj) 
#define ASSERT(x)           ((void)0)
#define ASSERTMSG(exp, msg) ((void)0)
#define VERIFY(x)           (x)       
#endif

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\inc\nlb_xmldocument.h ===
/*
 * Filename: NLB_XMLDocument.h
 * Description: 
 * Author: shouse, 04.10.01
 */
#ifndef __NLB_XMLDOCUMENT_H__
#define __NLB_XMLDOCUMENT_H__

#include <windows.h>

#include "NLB_Common.h"
#include "NLB_Cluster.h"
#include "NLB_Host.h"
#include "NLB_PortRule.h"

typedef struct _NLB_XMLError {
    LONG  code;
    LONG  line;
    LONG  character;
    WCHAR wszURL[MAX_PATH];
    WCHAR wszReason[MAX_PATH];
} NLB_XMLError;

#define FACILITY_NLB 49

#define NLB_ERROR_CLUSTER_NAME_MISSING   1

#define NLB_DESCR_CLUSTER_NAME_MISSING   L"The required cluster attribute \"Name\" was not found."

class NLB_XMLDocument {
public:
    NLB_XMLDocument ();
    NLB_XMLDocument (bool bSilent);

    ~NLB_XMLDocument ();

    HRESULT Validate (const WCHAR * wszFileName);

    HRESULT Parse (const WCHAR * wszFileName, vector<NLB_Cluster> & Clusters);
    
    HRESULT Save (const WCHAR * wszFileName, vector<NLB_Cluster> Clusters);

    void Print (vector<NLB_Cluster> Clusters);

    void GetParseError (NLB_XMLError & Error);

private:
    BSTR AsciiToBSTR (const char * pszName);
    CHAR * BSTRToAscii (const WCHAR * pwszName);

    NLB_ClusterMode::NLB_ClusterModeType StringToClusterMode (const PWCHAR pwszType);
    PWCHAR ClusterModeToString (const NLB_ClusterMode::NLB_ClusterModeType Type);

    NLB_HostState::NLB_HostStateType StringToHostState (const PWCHAR pwszType);
    PWCHAR HostStateToString (const NLB_HostState::NLB_HostStateType Type);

    NLB_PortRuleState::NLB_PortRuleStateType StringToPortRuleState (const PWCHAR pwszType);
    PWCHAR PortRuleStateToString (const NLB_PortRuleState::NLB_PortRuleStateType Type);

    NLB_PortRuleProtocol::NLB_PortRuleProtocolType StringToPortRuleProtocol (const PWCHAR pwszType);
    PWCHAR PortRuleProtocolToString (const NLB_PortRuleProtocol::NLB_PortRuleProtocolType Type);

    NLB_PortRuleFilteringMode::NLB_PortRuleFilteringModeType StringToPortRuleFilteringMode (const PWCHAR pwszType);
    PWCHAR PortRuleFilteringModeToString (const NLB_PortRuleFilteringMode::NLB_PortRuleFilteringModeType Type);

    NLB_PortRuleAffinity::NLB_PortRuleAffinityType StringToPortRuleAffinity (const PWCHAR pwszType);
    PWCHAR PortRuleAffinityToString (const NLB_PortRuleAffinity::NLB_PortRuleAffinityType Type);

    HRESULT LoadDocument (BSTR pBURL);
    HRESULT CheckDocumentLoad ();
    HRESULT BeautifyDocument (MSXML2::IXMLDOMNode * pNode, ULONG depth);
    HRESULT InsertFormatting (PWCHAR Text, MSXML2::IXMLDOMNode * pUnder, MSXML2::IXMLDOMNode * pBefore);

    void SetParseError (HRESULT hrCode, PWSTR pwszReason);

    HRESULT ParseCluster (MSXML2::IXMLDOMNode * pNode, NLB_Cluster * pCluster);
    HRESULT ParseClusterProperties (MSXML2::IXMLDOMNode * pNode, NLB_Cluster * pCluster);
    HRESULT ParseIPAddress (MSXML2::IXMLDOMNode * pNode, NLB_IPAddress * pIPAddress);
    HRESULT ParseAdapter (MSXML2::IXMLDOMNode * pNode, NLB_Adapter * pAdapter);
    HRESULT ParseRemoteControl (MSXML2::IXMLDOMNode * pNode, NLB_Cluster * pCluster);
    HRESULT ParseHostState (MSXML2::IXMLDOMNode * pNode, NLB_Host * pHost);
    HRESULT ParseBidirectionalAffinity (MSXML2::IXMLDOMNode * pNode, NLB_ClusterBDASupport * pBDA);
    HRESULT ParseClusterHosts (MSXML2::IXMLDOMNode * pNode, NLB_Cluster * pCluster);
    HRESULT ParseClusterPortRules (MSXML2::IXMLDOMNode * pNode, NLB_Cluster * pCluster);
    HRESULT ParseHost (MSXML2::IXMLDOMNode * pNode, NLB_Host * pHost);
    HRESULT ParsePortRule (MSXML2::IXMLDOMNode * pNode, NLB_PortRule * pRule);
    HRESULT ParseFiltering (MSXML2::IXMLDOMNode * pNode, NLB_PortRule * pRule);
    HRESULT ParsePriorities (MSXML2::IXMLDOMNode * pNode, NLB_PortRule * pRule);
    HRESULT ParseLoadWeights (MSXML2::IXMLDOMNode * pNode, NLB_PortRule * pRule);

    HRESULT SaveCluster (MSXML2::IXMLDOMNode * pRoot, NLB_Cluster * pCluster);
    HRESULT SaveClusterProperties (MSXML2::IXMLDOMNode * pRoot, NLB_Cluster * pCluster);
    HRESULT SaveIPAddress (MSXML2::IXMLDOMNode * pRoot, NLB_IPAddress * pAddress);
    HRESULT SaveAdapter (MSXML2::IXMLDOMNode * pRoot, NLB_Adapter * pAdapter);
    HRESULT SaveRemoteControl (MSXML2::IXMLDOMNode * pRoot, NLB_Cluster * pCluster);
    HRESULT SaveHostState (MSXML2::IXMLDOMNode * pNode, NLB_Host * pHost);
    HRESULT SaveBidirectionalAffinity (MSXML2::IXMLDOMNode * pNode, NLB_ClusterBDASupport * pBDA);
    HRESULT SaveClusterHosts (MSXML2::IXMLDOMNode * pNode, NLB_Cluster * pCluster);
    HRESULT SaveClusterPortRules (MSXML2::IXMLDOMNode * pNode, NLB_Cluster * pCluster);
    HRESULT SaveHost (MSXML2::IXMLDOMNode * pNode, NLB_Host * pHost);
    HRESULT SavePortRule (MSXML2::IXMLDOMNode * pNode, NLB_PortRule * pRule);
    HRESULT SaveFiltering (MSXML2::IXMLDOMNode * pNode, NLB_PortRule * pRule);
    HRESULT SavePriorities (MSXML2::IXMLDOMNode * pNode, NLB_PortRule * pRule);
    HRESULT SaveLoadWeights (MSXML2::IXMLDOMNode * pNode, NLB_PortRule * pRule);

    MSXML2::IXMLDOMNode * CreateNode(MSXML2::IXMLDOMDocument* pDoc, int type, PWCHAR pName);
    MSXML2::IXMLDOMNode * CreateNode(MSXML2::IXMLDOMDocument* pDoc, int type, PWCHAR pName, PWCHAR pValue);

    HRESULT SetIntegerAttribute(MSXML2::IXMLDOMNode * pNode, PWCHAR pAttribute, ULONG value);
    HRESULT GetIntegerAttribute(MSXML2::IXMLDOMNode * pNode, PWCHAR pAttribute, PULONG value);

    HRESULT SetBooleanAttribute(MSXML2::IXMLDOMNode * pNode, PWCHAR pAttribute, bool value);
    HRESULT GetBooleanAttribute(MSXML2::IXMLDOMNode * pNode, PWCHAR pAttribute, bool * value);

    HRESULT SetStringAttribute(MSXML2::IXMLDOMNode * pNode, PWCHAR pAttribute, PWCHAR pValue);
    HRESULT GetStringAttribute(MSXML2::IXMLDOMNode * pNode, PWCHAR pAttribute, PWCHAR pValue, ULONG length);

    HRESULT SetNodeValue(MSXML2::IXMLDOMNode * pNode, PWCHAR value);
    HRESULT GetNodeValue(MSXML2::IXMLDOMNode * pNode, PWCHAR value, ULONG length);

private:
    MSXML2::IXMLDOMDocument2 * pDoc;
    MSXML2::IXMLDOMSchemaCollection * pSchema;
	
    NLB_XMLError ParseError;
	
    bool bShowErrorPopups;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\inc\nlb_cluster.h ===
/*
 * Filename: NLB_Cluster.h
 * Description: 
 * Author: shouse, 04.10.01
 */
#ifndef __NLB_CLUSTER_H__
#define __NLB_CLUSTER_H__

#include "NLB_Common.h"
#include "NLB_Host.h"
#include "NLB_PortRule.h"

#include <vector>
#include <string>
#include <map>
using namespace std;

class NLB_Cluster {
public:
    NLB_Cluster();
    ~NLB_Cluster();

    bool IsValid ();

    void Clear ();

    bool SetName (PWCHAR pName);
    bool GetName (PWCHAR pName, ULONG length);
    
    bool SetLabel (PWCHAR pLabel);
    bool GetLabel (PWCHAR pLabel, ULONG length);

    bool SetClusterMode (NLB_ClusterMode::NLB_ClusterModeType eMode);
    bool GetClusterMode (NLB_ClusterMode::NLB_ClusterModeType & eMode);

    bool SetDomainName (PWCHAR pDomain);
    bool GetDomainName (PWCHAR pDomain, ULONG length);

    bool SetMACAddress (PWCHAR pMAC);
    bool GetMACAddress (PWCHAR pMAC, ULONG length);

    bool SetRemoteControlSupport (bool bEnabled);
    bool GetRemoteControlSupport (bool & bEnabled);

    bool SetRemoteControlPassword (PWCHAR pPassword);
    bool GetRemoteControlPassword (PWCHAR pPassword, ULONG length);

    bool SetBidirectionalAffinitySupport (NLB_ClusterBDASupport bda);
    bool GetBidirectionalAffinitySupport (NLB_ClusterBDASupport & bda);

    bool SetPrimaryClusterIPAddress (NLB_IPAddress address);
    bool GetPrimaryClusterIPAddress (NLB_IPAddress & address);

    bool SetIGMPMulticastIPAddress (NLB_IPAddress address);
    bool GetIGMPMulticastIPAddress (NLB_IPAddress & address);

    bool AddSecondaryClusterIPAddress (NLB_IPAddress address);
    bool RemoveSecondaryClusterIPAddress (PWCHAR pAddress);

    ULONG SetSecondaryClusterIPAddressList (vector<NLB_IPAddress> pList);
    ULONG GetSecondaryClusterIPAddressList (vector<NLB_IPAddress> * pList);

    bool AddHost (NLB_Host host);
    bool GetHost (PWCHAR pName, NLB_Host & host);
    bool RemoveHost (PWCHAR pName);

    ULONG SetHostList (vector<NLB_Host> pList);
    ULONG GetHostList (vector<NLB_Host> * pList);

    bool AddPortRule (NLB_PortRule rule);
    bool GetPortRule (PWCHAR pName, NLB_PortRule & rule);
    bool RemovePortRule (PWCHAR pName);

    ULONG SetPortRuleList (vector<NLB_PortRule> pList);
    ULONG GetPortRuleList (vector<NLB_PortRule> * pList);

private:

    NLB_Name                  Name;
    NLB_Label                 Label;
    NLB_ClusterMode           Mode;
    NLB_ClusterDomainName     DomainName;
    NLB_ClusterNetworkAddress NetworkAddress;
    NLB_ClusterRemoteControl  RemoteControl;
    NLB_ClusterBDASupport     BDASupport;

    NLB_IPAddress             PrimaryIPAddress;
    NLB_IPAddress             IGMPMulticastIPAddress;
    NLB_IPAddressList         SecondaryIPAddressList;

    NLB_HostList              HostList;
    NLB_PortRuleList          PortRuleList;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\inc\nlb_common.h ===
/*
 * Filename: NLB_Common.h
 * Description: 
 * Author: shouse, 04.10.01
 */
#ifndef __NLB_COMMON_H__
#define __NLB_COMMON_H__

#include <windows.h>

#include <vector>
#include <string>
#include <map>
using namespace std;

#define NLB_MAX_NAME                100
#define NLB_MAX_HOST_NAME           100
#define NLB_MAX_DOMAIN_NAME         100
#define NLB_MAX_IPADDRESS           15
#define NLB_MAX_SUBNETMASK          15
#define NLB_MAX_NETWORK_ADDRESS     17
#define NLB_MAX_ADAPTER_IDENTIFIER  100
#define NLB_MAX_LABEL               100
#define NLB_MAX_PASSWORD            16
#define NLB_MAX_BDA_TEAMID          40

#define NLB_MIN_HOST_ID             0
#define NLB_MAX_HOST_ID             32
#define NLB_MIN_PORT                0
#define NLB_MAX_PORT                65535
#define NLB_MIN_PRIORITY            1
#define NLB_MAX_PRIORITY            32
#define NLB_MIN_LOADWEIGHT          0
#define NLB_MAX_LOADWEIGHT          100
#define NLB_MAX_NUM_PORT_RULES      32

#define NLB_ASSERT(expression) {                                                                         \
    if (!(expression)) {                                                                                 \
        WCHAR message[MAX_PATH];                                                                         \
                                                                                                         \
        wsprintf(message, TEXT("%ls\r\n\r\n%ls, line %d"), TEXT(#expression), TEXT(__FILE__), __LINE__); \
                                                                                                         \
        MessageBox(NULL, message, L"Assertion failure", MB_APPLMODAL | MB_ICONSTOP | MB_OK);             \
    }                                                                                                    \
}

/*************************************************
 * Common to cluster/host/portrule               *
 *************************************************/

class NLB_Name {
public:
    NLB_Name ();
    ~NLB_Name ();
    
    bool IsValid ();

    void Clear ();

    bool SetName (PWCHAR pName);
    bool GetName (PWCHAR pName, ULONG length);

private:
    WCHAR Name[NLB_MAX_NAME + 1];
};

class NLB_Label {
public:
    NLB_Label ();
    ~NLB_Label ();
    
    bool IsValid ();

    void Clear ();

    bool SetText (PWCHAR pText);
    bool GetText (PWCHAR pText, ULONG length);

private:
    WCHAR Text[NLB_MAX_LABEL + 1];
};

class NLB_Adapter {
public:
    typedef enum {
        Invalid = -1,
        ByGUID,
        ByName
    } NLB_AdapterIdentifier;

    NLB_Adapter ();
    ~NLB_Adapter ();

    NLB_Adapter & operator= (const NLB_Adapter & adapter);

    bool IsValid ();

    void Clear ();

    bool SetName (PWCHAR pName);
    bool GetName (PWCHAR pName, ULONG length);

    bool SetGUID (PWCHAR pGUID);
    bool GetGUID (PWCHAR pGUID, ULONG length);

private:        
    NLB_AdapterIdentifier IdentifiedBy;
    WCHAR                 Identifier[NLB_MAX_ADAPTER_IDENTIFIER + 1];
};

class NLB_IPAddress {
public:
    typedef enum {
        Invalid = -1,
        Primary,
        Secondary,
        Virtual,
        Dedicated,
        Connection,
        IGMP
    } NLB_IPAddressType;

    NLB_IPAddress ();
    NLB_IPAddress (NLB_IPAddressType eType);
    ~NLB_IPAddress ();

    NLB_IPAddress & operator= (const NLB_IPAddress & address);

    bool operator== (NLB_IPAddress & address);

    bool IsValid ();

    void Clear ();

    bool SetIPAddressType (NLB_IPAddressType eType);
    bool GetIPAddressType (NLB_IPAddressType & eType);

    bool SetIPAddress (PWCHAR pIPAddress);
    bool GetIPAddress (PWCHAR pIPAddress, ULONG length);

    bool SetSubnetMask (PWCHAR pSubnetMask);
    bool GetSubnetMask (PWCHAR pSubnetMask, ULONG length);

    bool SetAdapterName (PWCHAR pName);
    bool GetAdapterName (PWCHAR pName, ULONG length);

    bool SetAdapterGUID (PWCHAR pGUID);
    bool GetAdapterGUID (PWCHAR pGUID, ULONG length);
    
private:
    NLB_IPAddressType Type;
    NLB_Adapter       Adapter;
    WCHAR             IPAddress[NLB_MAX_IPADDRESS + 1];
    WCHAR             SubnetMask[NLB_MAX_SUBNETMASK + 1];
};

typedef map<wstring, NLB_IPAddress, less<wstring> > NLB_IPAddressList;

/*************************************************
 * Cluster classes                               *
 *************************************************/

class NLB_ClusterMode {
public:
    typedef enum {
        Invalid = -1,
        Unicast,
        Multicast,
        IGMP
    } NLB_ClusterModeType;

    NLB_ClusterMode ();
    ~NLB_ClusterMode ();

    bool IsValid ();

    void Clear ();

    bool SetMode (NLB_ClusterModeType eMode);
    bool GetMode (NLB_ClusterModeType & eMode);

private:
    NLB_ClusterModeType Mode;
};

class NLB_ClusterDomainName {
public:
    NLB_ClusterDomainName ();
    ~NLB_ClusterDomainName ();
    
    bool IsValid ();

    void Clear ();

    bool SetDomain (PWCHAR pDomain);
    bool GetDomain (PWCHAR pDomain, ULONG length);

private:
    WCHAR Domain[NLB_MAX_DOMAIN_NAME + 1];
};

class NLB_ClusterNetworkAddress {
public:
    NLB_ClusterNetworkAddress ();
    ~NLB_ClusterNetworkAddress ();
    
    bool IsValid ();

    void Clear ();

    bool SetAddress (PWCHAR pAddress);
    bool GetAddress (PWCHAR pAddress, ULONG length);

private:
    WCHAR Address[NLB_MAX_NETWORK_ADDRESS + 1];
};

class NLB_ClusterRemoteControl {
public:
    NLB_ClusterRemoteControl ();
    ~NLB_ClusterRemoteControl ();
    
    bool IsValid ();

    void Clear ();

    bool SetPassword (PWCHAR pPassword);
    bool GetPassword (PWCHAR pPassword, ULONG length);

    bool SetEnabled (bool bEnabled);
    bool GetEnabled (bool & bEnabled);

private:
    bool  Valid;
    bool  Enabled;
    WCHAR Password[NLB_MAX_PASSWORD + 1];
};

class NLB_ClusterBDASupport {
public:
    NLB_ClusterBDASupport();
    ~NLB_ClusterBDASupport();

    NLB_ClusterBDASupport & operator= (const NLB_ClusterBDASupport & bda);

    bool IsValid ();

    void Clear ();

    bool SetTeamID (PWCHAR pTeam);
    bool GetTeamID (PWCHAR pTeam, ULONG length);

    bool SetMaster (bool bMaster);
    bool GetMaster (bool & bMaster);

    bool SetReverseHashing (bool bReverse);
    bool GetReverseHashing (bool & bReverse);

private:
    bool  Master;
    bool  ReverseHash;
    WCHAR TeamID[NLB_MAX_BDA_TEAMID];
};

/*************************************************
 * Host classes                                  *
 *************************************************/

class NLB_HostName {
public:
    NLB_HostName ();
    ~NLB_HostName ();
    
    bool IsValid ();

    void Clear ();

    bool SetName (PWCHAR pName);
    bool GetName (PWCHAR pName, ULONG length);

private:
    WCHAR Name[NLB_MAX_HOST_NAME + 1];
};

class NLB_HostID {
public:
    NLB_HostID ();
    ~NLB_HostID ();
    
    bool IsValid ();

    void Clear ();

    bool SetID (ULONG ID);
    bool GetID (ULONG & ID);

private:
    ULONG HostID;
};

class NLB_HostState {
public:
    typedef enum {
        Invalid = -1,
        Started,
        Stopped,
        Suspended
    } NLB_HostStateType;

    NLB_HostState ();
    ~NLB_HostState ();

    bool IsValid ();

    void Clear ();

    bool SetState (NLB_HostStateType eState);
    bool GetState (NLB_HostStateType & eState);

    bool SetPersistence (NLB_HostStateType eState, bool bPersist);
    bool GetPersistence (NLB_HostStateType eState, bool & bPersist);

private:
    NLB_HostStateType State;
    bool              PersistStarted;
    bool              PersistStopped;
    bool              PersistSuspended;
    bool              PersistStartedValid;
    bool              PersistStoppedValid;
    bool              PersistSuspendedValid;
};

/*************************************************
 * Portrule classes                              *
 *************************************************/

class NLB_PortRulePortRange {
public:
    NLB_PortRulePortRange ();
    ~NLB_PortRulePortRange ();
    
    bool IsValid ();

    void Clear ();

    bool SetPortRange (ULONG start, ULONG end);
    bool GetPortRange (ULONG & start, ULONG & end);

private:
    ULONG Start;
    ULONG End;
};

class NLB_PortRuleState {
public:
    typedef enum {
        Invalid = -1,
        Enabled,
        Disabled,
        Draining
    } NLB_PortRuleStateType;

    NLB_PortRuleState ();
    ~NLB_PortRuleState ();

    bool IsValid ();

    void Clear ();

    bool SetState (NLB_PortRuleStateType eState);
    bool GetState (NLB_PortRuleStateType & eState);

private:
    NLB_PortRuleStateType State;
};

class NLB_PortRuleProtocol {
public:
    typedef enum {
        Invalid = -1,
        TCP,
        UDP,
        Both
    } NLB_PortRuleProtocolType;

    NLB_PortRuleProtocol ();
    ~NLB_PortRuleProtocol ();

    bool IsValid ();

    void Clear ();

    bool SetProtocol (NLB_PortRuleProtocolType eProtocol);
    bool GetProtocol (NLB_PortRuleProtocolType & eProtocol);

private:
    NLB_PortRuleProtocolType Protocol;
};

class NLB_PortRuleAffinity {
public:
    typedef enum {
        Invalid = -1,
        None,
        Single,
        ClassC
    } NLB_PortRuleAffinityType;

    NLB_PortRuleAffinity ();
    ~NLB_PortRuleAffinity ();

    bool IsValid ();

    void Clear ();

    bool SetAffinity (NLB_PortRuleAffinityType eAffinity);
    bool GetAffinity (NLB_PortRuleAffinityType & eAffinity);

private:
    NLB_PortRuleAffinityType Affinity;
};

class NLB_PortRuleFilteringMode {
public:
    typedef enum {
        Invalid = -1,
        Single,
        Multiple,
        Disabled
    } NLB_PortRuleFilteringModeType;

    NLB_PortRuleFilteringMode ();
    ~NLB_PortRuleFilteringMode ();

    bool IsValid ();

    void Clear ();

    bool SetMode (NLB_PortRuleFilteringModeType eMode);
    bool GetMode (NLB_PortRuleFilteringModeType & eMode);

private:
    NLB_PortRuleFilteringModeType Mode;
};

class NLB_PortRulePriority {
public:
    NLB_PortRulePriority ();
    ~NLB_PortRulePriority ();
    
    bool IsValid ();

    void Clear ();

    bool SetHost (PWCHAR pName);
    bool GetHost (PWCHAR pName, ULONG length);

    bool SetPriority (ULONG priority);
    bool GetPriority (ULONG & priority);

private:
    NLB_Name Host;
    ULONG    Priority;
};

typedef map<wstring, NLB_PortRulePriority, less<wstring> > NLB_SingleHostFilteringPriorityList;

class NLB_PortRuleLoadWeight {
public:
    NLB_PortRuleLoadWeight ();
    ~NLB_PortRuleLoadWeight ();
    
    bool IsValid ();

    void Clear ();

    bool SetHost (PWCHAR pName);
    bool GetHost (PWCHAR pName, ULONG length);

    bool SetWeight (ULONG weight);
    bool GetWeight (ULONG & weight);

private:
    NLB_Name Host;
    ULONG    Weight;
};

typedef map<wstring, NLB_PortRuleLoadWeight, less<wstring> > NLB_MultipleHostFilteringLoadWeightList;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\inc\nlb_host.h ===
/*
 * Filename: NLB_Host.h
 * Description: 
 * Author: shouse, 04.10.01
 */
#ifndef __NLB_HOST_H__
#define __NLB_HOST_H__

#include "NLB_Common.h"

#include <vector>
#include <string>
#include <map>
using namespace std;

class NLB_Host {
public:
    NLB_Host();
    ~NLB_Host();

    bool IsValid ();

    void Clear ();

    bool SetName (PWCHAR pName);
    bool GetName (PWCHAR pName, ULONG length);
    
    bool SetLabel (PWCHAR pLabel);
    bool GetLabel (PWCHAR pLabel, ULONG length);

    bool SetDNSHostname (PWCHAR pName);
    bool GetDNSHostname (PWCHAR pName, ULONG length);

    bool SetHostID (ULONG ID);
    bool GetHostID (ULONG & ID);

    bool SetState (NLB_HostState::NLB_HostStateType eState);
    bool GetState (NLB_HostState::NLB_HostStateType & eState);

    bool SetStatePersistence (NLB_HostState::NLB_HostStateType eState, bool bPersist);
    bool GetStatePersistence (NLB_HostState::NLB_HostStateType eState, bool & bPersist);

    bool SetDedicatedIPAddress (NLB_IPAddress address);
    bool GetDedicatedIPAddress (NLB_IPAddress & address);

    bool SetConnectionIPAddress (NLB_IPAddress address);
    bool GetConnectionIPAddress (NLB_IPAddress & address);

    bool SetAdapterName (PWCHAR pName);
    bool GetAdapterName (PWCHAR pName, ULONG length);

    bool SetAdapterGUID (PWCHAR pGUID);
    bool GetAdapterGUID (PWCHAR pGUID, ULONG length);    

private:

    NLB_Name      Name;
    NLB_Label     Label;
    NLB_HostName  HostName;
    NLB_HostID    HostID;
    NLB_HostState State;

    NLB_IPAddress DedicatedIPAddress;
    NLB_IPAddress ConnectionIPAddress;

    NLB_Adapter   Adapter;
};

typedef map<wstring, NLB_Host, less<wstring> > NLB_HostList;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\inc\wlbsiocl.h ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

	wlbsiocl.h

Abstract:

	Windows Load Balancing Service (WLBS)
    IOCTL and remote control specifications

Author:

    kyrilf

Environment:


Revision History:


--*/

#ifndef _Wlbsiocl_h_
#define _Wlbsiocl_h_

#ifdef KERNEL_MODE

#include <ndis.h>
#include <ntddndis.h>
#include <devioctl.h>

typedef BOOLEAN BOOL;

#else

#include <windows.h>
#include <winioctl.h>

#endif

#include "wlbsctrl.h" /* Included for shared user/kernel mode IOCTL data structures. */
#include "wlbsparm.h"

/* Microsoft says that this value should be in the range 32768-65536 */
#define CVY_DEVICE_TYPE                      0xc0c0

#define IOCTL_CVY_CLUSTER_ON                 CTL_CODE(CVY_DEVICE_TYPE, 1, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_CVY_CLUSTER_OFF                CTL_CODE(CVY_DEVICE_TYPE, 2, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_CVY_PORT_ON                    CTL_CODE(CVY_DEVICE_TYPE, 3, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_CVY_PORT_OFF                   CTL_CODE(CVY_DEVICE_TYPE, 4, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_CVY_QUERY                      CTL_CODE(CVY_DEVICE_TYPE, 5, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_CVY_RELOAD                     CTL_CODE(CVY_DEVICE_TYPE, 6, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_CVY_PORT_SET                   CTL_CODE(CVY_DEVICE_TYPE, 7, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_CVY_PORT_DRAIN                 CTL_CODE(CVY_DEVICE_TYPE, 8, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_CVY_CLUSTER_DRAIN              CTL_CODE(CVY_DEVICE_TYPE, 9, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_CVY_CLUSTER_PLUG               CTL_CODE(CVY_DEVICE_TYPE, 10, METHOD_BUFFERED, FILE_WRITE_ACCESS) /* Internal only - passed from main.c to load.c when a start interrupts a drain. */
#define IOCTL_CVY_CLUSTER_SUSPEND            CTL_CODE(CVY_DEVICE_TYPE, 11, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_CVY_CLUSTER_RESUME             CTL_CODE(CVY_DEVICE_TYPE, 12, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_CVY_QUERY_FILTER               CTL_CODE(CVY_DEVICE_TYPE, 13, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_CVY_QUERY_PORT_STATE           CTL_CODE(CVY_DEVICE_TYPE, 14, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_CVY_QUERY_PARAMS               CTL_CODE(CVY_DEVICE_TYPE, 15, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_CVY_QUERY_BDA_TEAMING          CTL_CODE(CVY_DEVICE_TYPE, 16, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_CVY_CONNECTION_NOTIFY          CTL_CODE(CVY_DEVICE_TYPE, 17, METHOD_BUFFERED, FILE_WRITE_ACCESS)
// Defined in net\published\inc\ntddnlb.h
// #define NLB_IOCTL_REGISTER_HOOK           CTL_CODE(CVY_DEVICE_TYPE, 18, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_CVY_QUERY_MEMBER_IDENTITY     CTL_CODE(CVY_DEVICE_TYPE, 19, METHOD_BUFFERED, FILE_WRITE_ACCESS)


/* Security fix: To elevate the access requirement, the "access" bits in IOCTL codes have been changed 
                 from FILE_ANY_ACCESS to FILE_WRITE_ACCESS. IOCTL codes are not only passed from user 
                 mode to kernel mode, but also in remote control requests and replies. In the case of 
                 remote control, this change breaks backward compatibility with NT 4.0 & Win 2k clients 
                 since they use FILE_ANY_ACCESS. To overcome this problem, we decided 
                 that the IOCTL codes in remote control packets will continue to use FILE_ANY_ACCESS. 
                 This means that we will have two formats for IOCTL codes: a local (user mode <-> kernel mode) 
                 format that uses FILE_WRITE_ACCESS and a remote control format that uses FILE_ANY_ACCESS.
                 The following macros perform the conversion from one format to another. 
                 They are used
                 1. Just before sending out remote control requests in apis (wlbsctrl.dll)
                 2. Immediately after receiving remote control requests in driver (wlbs.sys)
                 3. Just before sending out remote control replies in driver (wlbs.sys)
                 4. Immediately after receiving remote control replies in apis (wlbsctrl.dll)

   Note: If, in the future, the "access" bits of IOCTLs are changed again, it is also necessary to modify the
         SET_IOCTL_ACCESS_BITS_TO_LOCAL( ) macro.
*/
#define SET_IOCTL_ACCESS_BITS_TO_REMOTE(ioctrl)  { (ioctrl) &= ~(0x00000003 << 14); (ioctrl) |= (FILE_ANY_ACCESS   << 14); }
#define SET_IOCTL_ACCESS_BITS_TO_LOCAL(ioctrl)   { (ioctrl) &= ~(0x00000003 << 14); (ioctrl) |= (FILE_WRITE_ACCESS << 14); }

#define IOCTL_CVY_OK                         0
#define IOCTL_CVY_ALREADY                    1
#define IOCTL_CVY_BAD_PARAMS                 2
#define IOCTL_CVY_NOT_FOUND                  3
#define IOCTL_CVY_STOPPED                    4
#define IOCTL_CVY_CONVERGING                 5
#define IOCTL_CVY_SLAVE                      6
#define IOCTL_CVY_MASTER                     7
#define IOCTL_CVY_BAD_PASSWORD               8
#define IOCTL_CVY_DRAINING                   9
#define IOCTL_CVY_DRAINING_STOPPED           10
#define IOCTL_CVY_SUSPENDED                  11
#define IOCTL_CVY_DISCONNECTED               12
#define IOCTL_CVY_GENERIC_FAILURE            13
#define IOCTL_CVY_REQUEST_REFUSED            14

#define IOCTL_REMOTE_CODE                    0xb055c0de
#define IOCTL_REMOTE_VR_PASSWORD             L"b055c0de"
#define IOCTL_REMOTE_VR_CODE                 0x9CD8906E
#define IOCTL_REMOTE_SEND_RETRIES            5
#define IOCTL_REMOTE_RECV_DELAY              100
#define IOCTL_REMOTE_RECV_RETRIES            20

#define IOCTL_MASTER_HOST                    0                /* MASTER_HOST host id */
#define IOCTL_ALL_HOSTS                      0xffffffff       /* ALL_HOSTS host id */
#define IOCTL_ALL_PORTS                      0xffffffff       /* Apply to all port rules. */
#define IOCTL_ALL_VIPS                       0x00000000       /* For virtual clusters, this is the ALL VIP specification for disable/enable/drain 
                                                                 (including both specific VIP and "ALL VIP" port rules). */
#define IOCTL_FIRST_HOST                     0xfffffffe       /* Input from user when querying identity cache. Indicates to driver to return cache information for the host with the smallest host priority */
#define IOCTL_NO_SUCH_HOST                   0xfffffffd       /* Output from driver when querying identity cache. Indicates that there is no information on the requested host. */

#define CVY_MAX_DEVNAME_LEN                  48               /* The actual length of \device\guid is 46, but 48 was chosen for word alignment. */

#pragma pack(1)

/* This structure is used by most of the existing IOCTL and remote control operations,
   including queries, cluster control and port rule control. */
typedef union {
    ULONG          ret_code;                    /* The return code - success, failure, etc. */

    union {
        struct {
            USHORT state;                       /* The cluster state - started, stopped, draining, etc. */
            USHORT host_id;                     /* The ID of this host. */
            ULONG  host_map;                    /* The bit map of the cluster's participating hosts. */
        } query;

        struct {
            ULONG  load;                        /* The load weight to set on port rule operations. */
            ULONG  num;                         /* The port number on which to operate. */
        } port;
    } data;
} IOCTL_CVY_BUF, * PIOCTL_CVY_BUF;

/* This structure contains the options that are common to both local and 
   remote control.  Note that this is extensible so long as the size of 
   this union does not exceed 256 bytes - if it becomes necessary to do 
   so, then the remote control version number should be incremented to 
   reflect the new packet format. */
typedef union {
    struct {
        ULONG flags;                            /* These flags indicate which options fields have been specified. */
        ULONG vip;                              /* For virtual clusters, the VIP, which can be 0x00000000, 0xffffffff or a specific VIP. */
    } port;
    
    struct {
        ULONG                     flags;        /* These flags indicate which options fields have been specified. */
        ULONG                     reserved;         /* Keeps 8-byte alignment */
        union {
            NLB_OPTIONS_PORT_RULE_STATE port;   /* This is the output buffer for querying the state of a port rule. */
            NLB_OPTIONS_PACKET_FILTER   filter; /* This is the output buffer for querying the filtering algorithm. */
        };
    } state;
} IOCTL_COMMON_OPTIONS, * PIOCTL_COMMON_OPTIONS;

/* This structure is used by remote control operations to provide extended 
   functionality beyond the legacy remote control protocol, which MUST remain 
   backward compatible with NT 4.0 and Windows 2000.  Note that additions to
   this union or the common options union should not cause this union to
   exceed the size of the reserved field, or the remote control version number
   should be incremented to reflect this. */
typedef union {
    UCHAR reserved[256];                           /* Bite the bullet and reserve 256 bytes to allow for future expansion. */

    union {
        IOCTL_COMMON_OPTIONS common;               /* These are the options common to both local and remote control. */

        struct {
            ULONG flags;                           /* These flags indicate which options fields have been specified. */
            WCHAR hostname[CVY_MAX_HOST_NAME + 1]; /* Host name filled in by NLB on remote control reply. */
        } query;
    };
} IOCTL_REMOTE_OPTIONS, * PIOCTL_REMOTE_OPTIONS;

/* These macros define the remote control packets lengths based on Windows and NLB versions,
   so that error checking can be done upon the reception of a remote control packet. */
#define NLB_MIN_RCTL_PAYLOAD_LEN  (sizeof(IOCTL_REMOTE_HDR) - sizeof(IOCTL_REMOTE_OPTIONS))
#define NLB_MIN_RCTL_PACKET_LEN   (sizeof(UDP_HDR) + sizeof(IOCTL_REMOTE_HDR) - sizeof(IOCTL_REMOTE_OPTIONS))
#define NLB_NT40_RCTL_PACKET_LEN  (sizeof(UDP_HDR) + sizeof(IOCTL_REMOTE_HDR) - sizeof(IOCTL_REMOTE_OPTIONS))
#define NLB_WIN2K_RCTL_PACKET_LEN (sizeof(UDP_HDR) + sizeof(IOCTL_REMOTE_HDR) - sizeof(IOCTL_REMOTE_OPTIONS))
#define NLB_WINXP_RCTL_PACKET_LEN (sizeof(UDP_HDR) + sizeof(IOCTL_REMOTE_HDR))

/* This structure is the UDP data for NLB remote control messages.  New support is present
   in the options buffer, which MUST be placed at the end of the buffer to retain backward
   compatability with NT4.0 and Win2K in mixed clusters. */
typedef struct {
    ULONG                code;                             /* Distinguishes remote packets. */
    ULONG                version;                          /* Software version. */
    ULONG                host;                             /* Destination host (0 or cluster IP address for master). */
    ULONG                cluster;                          /* Primary cluster IP address. */
    ULONG                addr;                             /* Dedicated IP address on the way back, client IP address on the way in. */
    ULONG                id;                               /* Message ID. */
    ULONG                ioctrl;                           /* IOCTRL code. */
    IOCTL_CVY_BUF        ctrl;                             /* Control buffer. */
    ULONG                password;                         /* Encoded password. */
    IOCTL_REMOTE_OPTIONS options;                          /* Optionally specified parameters. */
} IOCTL_REMOTE_HDR, * PIOCTL_REMOTE_HDR;

#pragma pack()

/* The following IOCTL_LOCAL_XXX structures are used only locally, and hence don't need to be packed */

typedef struct {
    ULONG             host;                   /* source host id */
    ULONG             ded_ip_addr;            /* dedicated IP address */
    WCHAR             fqdn[CVY_MAX_FQDN + 1]; /* fully qualified host name or netbt name */
} NLB_OPTIONS_IDENTITY, * PNLB_OPTIONS_IDENTITY;

/* This structure is used by IOCTLs to provide extended functionality beyond the legacy IOCTLs. */
typedef union {
    IOCTL_COMMON_OPTIONS common;                /* These are the options common to both local and remote control. */
    
    struct {
        ULONG flags;                            /* These flags indicate which options fields have been specified. */
        
        union {
            NLB_OPTIONS_PARAMS      params;     /* This is the output buffer for querying the driver parameters & state. */
            NLB_OPTIONS_BDA_TEAMING bda;        /* This is the output buffer for querying the BDA teaming state. */
        };
    } state;
    
    struct {
        ULONG flags;                            /* These flags indicate which options fields have been specified. */
        ULONG NumConvergences;                  /* The number of convergences since this host joined the cluster. */
        ULONG LastConvergence;                  /* The amount of time since the last convergence, in seconds. */
    } query;

    struct {
        ULONG                         flags;    /* These flags indicate which options fields have been specified. */
        NLB_OPTIONS_CONN_NOTIFICATION conn;     /* The input/output buffer for connection notifications from upper-layer protocols. */
    } notification;

    struct {
        ULONG                  host_id;         /* In:  Host id [0,31] stating the host for which identity information is requested. Use IOCTL_FIRST_HOST to get the host with the smallest host id. */
        ULONG                  host_map ;       /* Out: Bitmap of hosts in the cache */
        NLB_OPTIONS_IDENTITY   cached_entry;    /* Out: Cached identity information on the requested host. If the requested host's information is not available, the "host" property will contain IOCTL_NO_SUCH_HOST. */
    } identity;
} IOCTL_LOCAL_OPTIONS, * PIOCTL_LOCAL_OPTIONS;


/* This structure is the buffer used for ALL NLB local IOCTLs.  The device_name is used to 
   associate the request with the correct NLB instance, the ctrl buffer is the legacy IOCTL
   state buffer and options is the extended support buffer. */
typedef struct {
    WCHAR                device_name[CVY_MAX_DEVNAME_LEN]; /* Identifies the adapter. */
    IOCTL_CVY_BUF        ctrl;                             /* The IOCTL information. */
    IOCTL_LOCAL_OPTIONS  options;                          /* Optionally specified parameters. */
} IOCTL_LOCAL_HDR, * PIOCTL_LOCAL_HDR;


#endif /* _Wlbsiocl_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\inc\wlbsutil.h ===
#include <time.h>

DWORD WINAPI IpAddressFromAbcdWsz (IN const WCHAR*  wszIpAddress);

VOID WINAPI AbcdWszFromIpAddress (IN DWORD IpAddress, OUT WCHAR* wszIpAddress, IN  const DWORD dwBufSize);

VOID GetIPAddressOctets (PCWSTR pszIpAddress, DWORD ardw[4]);

BOOL IsValidIPAddressSubnetMaskPair (PCWSTR szIp, PCWSTR szSubnet);

BOOL IsValidMulticastIPAddress (PCWSTR szIp);

BOOL IsContiguousSubnetMask (PCWSTR pszSubnet);

//
// Arguments: PWSTR ip                  - Input dotted decimal IP address string
//            PWSTR sub                 - Output dotted decimal subnet mask for input IP address
//            const DWORD dwMaskBufSize - Size of sub output buffer in characters
//
BOOL ParamsGenerateSubnetMask (PWSTR ip, PWSTR sub, IN const DWORD dwMaskBufSize);

void ParamsGenerateMAC (const WCHAR * szClusterIP, 
                        OUT WCHAR * szClusterMAC, 
                        IN  const DWORD dwMACBufSize,
                        OUT WCHAR * szMulticastIP, 
                        IN  const DWORD dwIPBufSize,
                        BOOL fConvertMAC, 
                        BOOL fMulticast, 
                        BOOL fIGMP, 
                        BOOL fUseClusterIP);

#define ASIZECCH(_array) (sizeof(_array)/sizeof((_array)[0]))
#define ASIZECB(_array) (sizeof(_array))

VOID
InitUserLocale();

VOID
FormatTheTime(IN SYSTEMTIME *pSysTime, OUT WCHAR *TimeStr, IN int TimeStrLen);

VOID
ConvertTimeToSystemTime(IN time_t Ttime, OUT WCHAR *TimeStr, IN int TimeStrLen);

//+----------------------------------------------------------------------------
//
// Function:  ConvertTimeToTimeAndDateStrings
//
// Description: Uses the specified locale to build strings for time-of-day and
//              date (short format)
//
// Arguments: time_t Ttime        - IN time to be converted
//            WCHAR *TimeOfDayStr - OUT buffer for the time-of-day string
//            int TimeOfDayStrLen - IN size of time-of-day buffer in characters
//            WCHAR *DateStr      - OUT buffer for the date string
//            int DateStrLen      - IN size of date buffer in characters
//
// Returns:   VOID
//
//+----------------------------------------------------------------------------
VOID
ConvertTimeToTimeAndDateStrings(IN time_t Ttime, OUT WCHAR *TimeOfDayStr, IN int TimeOfDayStrLen, OUT WCHAR *DateStr, IN int DateStrLen);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\installpack\error.h ===
/*
 * File: error.h
 * Description: This file contains the definitions of the NLB install pack
 *              HRESULT error codes.
 * Author: shouse 12.5.00
 */

#define FACILITY_NLB           35

#define NLB_E_INVALID_OS        1
#define NLB_E_ALREADY_INSTALLED 2
#define NLB_E_FILES_MISSING     3
#define NLB_E_INF_FAILURE       4
#define NLB_E_REGISTER_DLL      5
#define NLB_E_COMPILE_MOF       6
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\installpack\implinc.cpp ===
#include "pch.h"
#pragma hdrstop
#include "idls_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\inc\wlbsip.h ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

	wlbsip.h

Abstract:

	Windows Load Balancing Service (WLBS)
    IP/TCP/UDP support

Author:

    kyrilf

Environment:


Revision History:


--*/

#ifndef _Tcpip_h_
#define _Tcpip_h_

#ifdef KERNEL_MODE
#include <ndis.h>
#endif


#pragma pack(1)

/* type structures for basic protocols */

typedef struct
{
    UCHAR               byte [20];
}
IP_HDR, * PIP_HDR;

typedef struct
{
    UCHAR               byte [20];
}
TCP_HDR, * PTCP_HDR;

typedef struct
{
    UCHAR               byte [8];
}
UDP_HDR, * PUDP_HDR;

typedef struct
{
    UCHAR               byte [28];
}
ARP_HDR, * PARP_HDR;

#define TCPIP_BCAST_ADDR        0xffffffff  /* IP broadcast address */
#define TCPIP_CLASSC_MASK       0x00ffffff  /* IP address Class C mask */

/* protocol type signatures carried in the length field of Ethernet frame */

#define TCPIP_IP_SIG            0x0800      /* IP protocol */
#define TCPIP_ARP_SIG           0x0806      /* ARP/RARP protocol */

/* supported IP version */

#define TCPIP_VERSION           4           /* current IP version */

/* protocol types as encoded in IP header */

#define TCPIP_PROTOCOL_IP       0           /* Internet protocol id */
#define TCPIP_PROTOCOL_ICMP     1           /* Internet control message protocol id */
#define TCPIP_PROTOCOL_IGMP     2           /* Internet gateway message protocol id */
#define TCPIP_PROTOCOL_GGP      3           /* Gateway-gateway protocol id */
#define TCPIP_PROTOCOL_TCP      6           /* Transmission control protocol id */
#define TCPIP_PROTOCOL_EGP      8           /* Exterior gateway protocol id */
#define TCPIP_PROTOCOL_PUP      12          /* PARC universal packet protocol id */
#define TCPIP_PROTOCOL_UDP      17          /* user datagram protocol id */
#define TCPIP_PROTOCOL_HMP      20          /* Host monitoring protocol id */
#define TCPIP_PROTOCOL_XNS_IDP  22          /* Xerox NS IDP protocol id */
#define TCPIP_PROTOCOL_RDP      27          /* Reliable datagram protocol id */
#define TCPIP_PROTOCOL_RVD      66          /* MIT remote virtual disk protocol id */
#define TCPIP_PROTOCOL_RAW_IP   255         /* raw IP protocol id */
#define TCPIP_PROTOCOL_GRE      47          /* PPTP's GRE stream */
#define TCPIP_PROTOCOL_IPSEC1   50          /* IPSEC's data stream */
#define TCPIP_PROTOCOL_IPSEC2   51          /* IPSEC's data stream */
#define TCPIP_PROTOCOL_PPTP     99          /* This is a bogus protocol ID used by descriptor tracking in the load module. */
#define TCPIP_PROTOCOL_IPSEC_UDP 217        /* Bogus protocol ID used to track UDP subsequent
                                               fragments within the IPSEC protocol in load.c */

#define IP_ADDR_LEN             4           /* in bytes */

/* Stolen from net\ipsec\oakley\ikedef.h and net\ipsec\oakley\isakmp.h for reference. */
#if 0
#define COOKIE_LEN 8

typedef struct isakmp_hdr_ {
    unsigned char init_cookie[COOKIE_LEN];
    unsigned char resp_cookie[COOKIE_LEN];
    unsigned char next_payload;
#ifdef ISAKMP_i386
    unsigned char minver:4,
        majver:4;
#else
    unsigned char majver:4,
        minver:4;
#endif
    unsigned char exch;
    unsigned char flags;
    unsigned long mess_id;
    unsigned long len;
} isakmp_hdr;

typedef struct generic_payload_ {
    unsigned char next_payload;
    unsigned char reserved;
    unsigned short payload_len;
} generic_payload;

typedef struct vendor_payload_ {
    unsigned char next_payload;
    unsigned char reserved;
    unsigned short payload_len;
    unsigned char vendor_id[1];
} generic_payload;

typedef struct notify_payload_ {
    unsigned char next_payload;
    unsigned char reserved;
    unsigned short payload_len;
    unsigned long doi;
    unsigned char protocol_id;
    unsigned char spi_size;
    unsigned short notify_message;
}
#endif

/* IPSec/IKE header macros. */
typedef enum {
    NLB_IPSEC_OTHER = 1,
    NLB_IPSEC_INITIAL_CONTACT,
    NLB_IPSEC_IDENTIFICATION
} NLB_IPSEC_PACKET_TYPE;

#define IPSEC_ISAKMP_SA                                1
#define IPSEC_ISAKMP_ID                                5
#define IPSEC_ISAKMP_VENDOR_ID                         13
#define IPSEC_ISAKMP_NOTIFY                            11

#define IPSEC_ISAKMP_NAT_DELIMITER_LENGTH              4
#define IPSEC_ISAKMP_NAT_DELIMITER                     {0x00, 0x00, 0x00, 0x00}

#define IPSEC_ISAKMP_MAIN_MODE_RCOOKIE                 {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}

#define IPSEC_ISAKMP_HEADER_LENGTH                     28
#define IPSEC_ISAKMP_HEADER_RCOOKIE_OFFSET             8
#define IPSEC_ISAKMP_HEADER_RCOOKIE_LENGTH             8
#define IPSEC_ISAKMP_HEADER_NEXT_PAYLOAD_OFFSET        16
#define IPSEC_ISAKMP_HEADER_PACKET_LENGTH_OFFSET       24

typedef struct {
    UCHAR byte[IPSEC_ISAKMP_HEADER_LENGTH];
} IPSEC_ISAKMP_HDR, * PIPSEC_ISAKMP_HDR;

#define IPSEC_ISAKMP_GET_RCOOKIE_POINTER(isakmp_hdrp)  ((PUCHAR)isakmp_hdrp + IPSEC_ISAKMP_HEADER_RCOOKIE_OFFSET)
#define IPSEC_ISAKMP_GET_NEXT_PAYLOAD(isakmp_hdrp)     ((UCHAR)((isakmp_hdrp)->byte[IPSEC_ISAKMP_HEADER_NEXT_PAYLOAD_OFFSET]))
#define IPSEC_ISAKMP_GET_PACKET_LENGTH(isakmp_hdrp)    ((ULONG)(((isakmp_hdrp)->byte[IPSEC_ISAKMP_HEADER_PACKET_LENGTH_OFFSET]     << 24) | \
                                                                ((isakmp_hdrp)->byte[IPSEC_ISAKMP_HEADER_PACKET_LENGTH_OFFSET + 1] << 16) | \
                                                                ((isakmp_hdrp)->byte[IPSEC_ISAKMP_HEADER_PACKET_LENGTH_OFFSET + 2] << 8)  | \
                                                                ((isakmp_hdrp)->byte[IPSEC_ISAKMP_HEADER_PACKET_LENGTH_OFFSET + 3] << 0)))

#define IPSEC_GENERIC_HEADER_LENGTH                    4
#define IPSEC_GENERIC_HEADER_NEXT_PAYLOAD_OFFSET       0
#define IPSEC_GENERIC_HEADER_PAYLOAD_LENGTH_OFFSET     2

typedef struct {
    UCHAR byte[IPSEC_GENERIC_HEADER_LENGTH];
} IPSEC_GENERIC_HDR, * PIPSEC_GENERIC_HDR;

#define IPSEC_GENERIC_GET_NEXT_PAYLOAD(generic_hdrp)   ((UCHAR)((generic_hdrp)->byte[IPSEC_GENERIC_HEADER_NEXT_PAYLOAD_OFFSET]))
#define IPSEC_GENERIC_GET_PAYLOAD_LENGTH(generic_hdrp) ((USHORT)(((generic_hdrp)->byte[IPSEC_GENERIC_HEADER_PAYLOAD_LENGTH_OFFSET]     << 8) | \
                                                                 ((generic_hdrp)->byte[IPSEC_GENERIC_HEADER_PAYLOAD_LENGTH_OFFSET + 1] << 0)))

#define IPSEC_VENDOR_ID_INITIAL_CONTACT                {0x26, 0x24, 0x4D, 0x38, 0xED, 0xDB, 0x61, 0xB3, 0x17, 0x2A, 0x36, 0xE3, 0xD0, 0xCF, 0xB8, 0x19}
#define IPSEC_VENDOR_ID_INITIAL_CONTACT_SUPPORT        {0xA7, 0x72, 0xD1, 0x78, 0x08, 0x40, 0x9E, 0xDC, 0xCD, 0xAB, 0x92, 0x9A, 0x0F, 0x96, 0x91, 0xD0}
#define IPSEC_VENDOR_ID_MICROSOFT                      {0x1E, 0x2B, 0x51, 0x69, 0x05, 0x99, 0x1C, 0x7D, 0x7C, 0x96, 0xFC, 0xBF, 0xB5, 0x87, 0xE4, 0x61}
#define IPSEC_VENDOR_ID_MICROSOFT_MIN_VERSION          0x00000004

#define IPSEC_VENDOR_ID_PAYLOAD_LENGTH                 20
#define IPSEC_VENDOR_HEADER_VENDOR_ID_OFFSET           4
#define IPSEC_VENDOR_HEADER_VENDOR_ID_LENGTH           16
#define IPSEC_VENDOR_HEADER_VENDOR_VERSION_OFFSET      20
#define IPSEC_VENDOR_HEADER_VENDOR_VERSION_LENGTH      4

typedef struct {
    UCHAR byte[IPSEC_GENERIC_HEADER_LENGTH + IPSEC_VENDOR_ID_PAYLOAD_LENGTH];
} IPSEC_VENDOR_HDR, * PIPSEC_VENDOR_HDR;

#define IPSEC_VENDOR_ID_GET_ID_POINTER(vendor_hdrp)    ((PUCHAR)vendor_hdrp + IPSEC_VENDOR_HEADER_VENDOR_ID_OFFSET)
#define IPSEC_VENDOR_ID_GET_VERSION(vendor_hdrp)       ((ULONG)(((vendor_hdrp)->byte[IPSEC_VENDOR_HEADER_VENDOR_VERSION_OFFSET]     << 24) | \
                                                                ((vendor_hdrp)->byte[IPSEC_VENDOR_HEADER_VENDOR_VERSION_OFFSET + 1] << 16) | \
                                                                ((vendor_hdrp)->byte[IPSEC_VENDOR_HEADER_VENDOR_VERSION_OFFSET + 2] << 8)  | \
                                                                ((vendor_hdrp)->byte[IPSEC_VENDOR_HEADER_VENDOR_VERSION_OFFSET + 3] << 0)))

#define IPSEC_NOTIFY_INITIAL_CONTACT                   24578

#define IPSEC_NOTIFY_PAYLOAD_LENGTH                    8
#define IPSEC_NOTIFY_HEADER_NOTIFY_MESSAGE_OFFSET      10

typedef struct {
    UCHAR byte[IPSEC_GENERIC_HEADER_LENGTH + IPSEC_NOTIFY_PAYLOAD_LENGTH];
} IPSEC_NOTIFY_HDR, * PIPSEC_NOTIFY_HDR;

#define IPSEC_NOTIFY_GET_NOTIFY_MESSAGE(notify_hdrp)   ((USHORT)(((notify_hdrp)->byte[IPSEC_NOTIFY_HEADER_NOTIFY_MESSAGE_OFFSET]     << 8) | \
                                                                 ((notify_hdrp)->byte[IPSEC_NOTIFY_HEADER_NOTIFY_MESSAGE_OFFSET + 1] << 0)))

/* ARP header macros - note address locations assume 6 byte MAC (Ethernet)
   and 4 byte protocol (IP) sizes */

/* type of hardware address */
#define ARP_GET_MAC_TYPE(p)     (((ULONG) ((p) -> byte[0]) << 8) | (ULONG) ((p) -> byte[1]))

/* higher layer addressing protocol */
#define ARP_GET_PROT_TYPE(p)    (((ULONG) ((p) -> byte[2]) << 8) | (ULONG) ((p) -> byte[3]))

/* length of hardware address */
#define ARP_GET_MAC_LEN(p)      ((ULONG) ((p) -> byte[4]))

/* length of higher layer address */
#define ARP_GET_PROT_LEN(p)     ((ULONG) ((p) -> byte[5]))

/* type of message */
#define ARP_GET_MSG_TYPE(p)     (((ULONG) ((p) -> byte[6]) << 8) | (ULONG) ((p) -> byte[7]))

/* source hardware address */
#define ARP_GET_SRC_MAC_PTR(p)  (&((p) -> byte[8]))
#define ARP_GET_SRC_MAC(p,n)    ((ULONG) ((p) -> byte[8 + (n)]))

/* source higher layer address */
#define ARP_GET_SRC_PROT(p,n)   ((ULONG) ((p) -> byte[14 + (n)]))
#define ARP_GET_SRC_FPROT(p)    (* ((PULONG) &((p) -> byte[14])))
/* 64-bit -- ramkrish */
#define ARP_GET_SRC_PROT_64(p)  ((ULONG) (((p) -> byte[14] << 0)   | ((p) -> byte[15] << 8) | \
                                          ((p) -> byte[16] << 16)  | ((p) -> byte[17] << 24)))


/* destination hardware address */
#define ARP_GET_DST_MAC_PTR(p)  (&((p) -> byte[18]))
#define ARP_GET_DST_MAC(p,n)    ((ULONG) ((p) -> byte[18 + (n)]))

/* destination higher layer address */
#define ARP_GET_DST_PROT(p,n)   ((ULONG) ((p) -> byte[24 + (n)]))
#define ARP_GET_DST_FPROT(p)    (* ((PULONG) &((p) -> byte[24])))
/* 64-bit -- ramkrish */
#define ARP_GET_DST_PROT_64(p)  ((ULONG) (((p) -> byte[18] << 0)   | ((p) -> byte[19] << 8) | \
                                          ((p) -> byte[20] << 16)  | ((p) -> byte[21] << 24)))


#define ARP_MAC_TYPE_ETH        0x0001
#define ARP_PROT_TYPE_IP        0x0800
#define ARP_MAC_LEN_ETH         6
#define ARP_PROT_LEN_IP         4
#define ARP_MSG_TYPE_REQ        0x1
#define ARP_MSG_TYPE_RSP        0x2


/* IP datagram header macros */


/* IP version number */
#define IP_GET_VERS(p)          ((ULONG) ((((p) -> byte[0]) >> 4) & 0xf))

/* header length in 32-bit words */
#define IP_GET_HLEN(p)          ((ULONG) (((p) -> byte[0]) & 0xf))

/* service type */
#define IP_GET_SRVC(p)          ((ULONG) ((p) -> byte[1]))

/* total datagram packet length in bytes */
#define IP_GET_PLEN(p)          (((ULONG) ((p) -> byte[2]) << 8) | (ULONG) ((p) -> byte[3]))

/* fragmentation identification - this one seems to have bytes swaped within
   the short word ??? */
#define IP_GET_FRAG_ID(p)       (((ULONG) ((p) -> byte[5]) << 8) | (ULONG) ((p) -> byte[4]))

/* fragmentation flags */
#define IP_GET_FRAG_FLGS(p)     ((ULONG) ((((p) -> byte[6]) >> 5) & 0x7))

/* fragmentation offset */
#define IP_GET_FRAG_OFF(p)      (((ULONG) ((p) -> byte[6] & 0x1f) << 8) | (ULONG) ((p) -> byte[7]))

/* Time To Live in seconds */
#define IP_GET_TTL(p)           ((ULONG) ((p) -> byte[8]))

/* higher level protocol id */
#define IP_GET_PROT(p)          ((ULONG) ((p) -> byte[9]))

/* header checksum - this one seems to have bytes swaped within
   the short word ??? */
#define IP_GET_CHKSUM(p)        (((USHORT) ((p) -> byte[10]) << 8) | (USHORT) ((p) -> byte[11]))
#define IP_SET_CHKSUM(p,c)      (((p) -> byte[10] = (c) >> 8), ((p) -> byte[11] = (c) & 0xff))

/* source IP address */
#define IP_GET_SRC_ADDR(p,n)    ((ULONG) ((p) -> byte[12 + (n)]))
#define IP_GET_SRC_ADDR_PTR(p)  (&((p) -> byte[12]))
#define IP_GET_SRC_FADDR(p)     (* ((PULONG) &((p) -> byte[12]))) /* 64-bit -- ramkrish */


#ifdef _WIN64 
    #define IP_GET_SRC_ADDR_64(p)   ((ULONG) (((p) -> byte[12] << 0) | ((p) -> byte[13] << 8) | \
                                          ((p) -> byte[14] << 16)  | ((p) -> byte[15] << 24)))
#else                                          
    //  This is faster than the one above.  This function is called in critical receiving path
    #define IP_GET_SRC_ADDR_64(p)     (* ((PULONG) &((p) -> byte[12])))
#endif

/* destination IP address */
#define IP_GET_DST_ADDR(p,n)    ((ULONG) ((p) -> byte[16 + (n)]))

#ifdef _WIN64 
    #define IP_GET_DST_ADDR_64(p)   ((ULONG) (((p) -> byte[16] << 0)   | ((p) -> byte[17] << 8) | \
                                          ((p) -> byte[18] << 16)  | ((p) -> byte[19] << 24)))
#else                                          
    //  This is faster than the one above.  This function is called in critical receiving path
    #define IP_GET_DST_ADDR_64(p)     (* ((PULONG) &((p) -> byte[16])))
#endif


/* 64-bit -- ramkrish */

#define IP_SET_SRC_ADDR_64(p,c)    { \
                                     PUCHAR tmp = (PUCHAR) (&(c)); \
                                     (p) -> byte[12] = tmp[0]; (p) -> byte[13] = tmp[1]; \
                                     (p) -> byte[14] = tmp[2]; (p) -> byte[15] = tmp[3]; \
                                   }

#define IP_SET_DST_ADDR_64(p,c)    { \
                                     PUCHAR tmp = (PUCHAR) (&(c)); \
                                     (p) -> byte[16] = tmp[0]; (p) -> byte[17] = tmp[1]; \
                                     (p) -> byte[18] = tmp[2]; (p) -> byte[19] = tmp[3]; \
                                   }

/* get IP address octets. */
#define IP_GET_ADDR(p,b0,b1,b2,b3) {                                 \
                                     *(b3) = ((p) & 0xff000000) >> 24; \
                                     *(b2) = ((p) & 0x00ff0000) >> 16; \
                                     *(b1) = ((p) & 0x0000ff00) >> 8;  \
                                     *(b0) = ((p) & 0x000000ff) >> 0;  \
                                   }

/* Get the Nth octect of an IP address DWORD.  The zeroeth octect is the least significant byte of the DWORD. */
#define IP_GET_OCTET(p,n) (((p) & (0x000000ff << (8*(n)))) >> (8*(n)))

/* create IP address from 4 bytes */
#define IP_SET_ADDR(p,b0,b1,b2,b3) (* (p) = (((b0) << 0) | ((b1) << 8) | ((b2) << 16) | ((b3) << 24)))

/* compute broadcast address from IP address and netmask */
#define IP_SET_BCAST(p,a,m)     (* (p) = ((a) & (m)) | (~(m)))


/* TCP header macros */


/* pointer to TCP header from IP header pointer */
#define TCP_PTR(p)              ((PTCP_HDR)(((ULONG *)(p)) + ((ULONG)IP_GET_HLEN(p))))

/* source port */
#define TCP_GET_SRC_PORT(p)     (((ULONG) ((p) -> byte[0]) << 8) | (ULONG) ((p) -> byte[1]))
#define TCP_GET_SRC_PORT_PTR(p) (& ((p) -> byte[0])) /* 64-bit -- ramkrish */

/* destination port */
#define TCP_GET_DST_PORT(p)     (((ULONG) ((p) -> byte[2]) << 8) | (ULONG) ((p) -> byte[3]))
#define TCP_GET_DST_PORT_PTR(p) (& ((p) -> byte[2]))  /* 64-bit -- ramkrish */

/* sequence number */
#define TCP_GET_SEQ_NO(p)       (((ULONG) ((p) -> byte[4]) << 24) | ((ULONG) ((p) -> byte[5]) << 16) | \
                                 ((ULONG) ((p) -> byte[6]) << 8)  |  (ULONG) ((p) -> byte[7]))

/* acknowledgement number */
#define TCP_GET_ACK_NO(p)       (((ULONG) ((p) -> byte[8])  << 24) | ((ULONG) ((p) -> byte[9]) << 16) | \
                                 ((ULONG) ((p) -> byte[10]) << 8)  |  (ULONG) ((p) -> byte[11]))

/* flags */
#define TCP_GET_FLAGS(p)        (((ULONG) ((p) -> byte[13])) & 0x3f)

/* header length in 32-bit words */
#define TCP_GET_HLEN(p)         ((ULONG) (((p) -> byte[12]) >> 4))

/* datagram length */
#define TCP_GET_DGRAM_LEN(i,t)  (IP_GET_PLEN (i) - ((IP_GET_HLEN (i) + TCP_GET_HLEN (t)) * sizeof (ULONG)))

/* pointer to datagram */
#define TCP_GET_DGRAM_PTR(p)    ((PUCHAR)(((ULONG *)(p)) + ((ULONG) TCP_GET_HLEN(p))))

/* checksum field */
#define TCP_GET_CHKSUM(p)       ((((USHORT)((p) -> byte[16])) << 8) | (USHORT)((p) -> byte[17]))
#define TCP_SET_CHKSUM(p,c)     (((p) -> byte[16] = (c) >> 8), ((p) -> byte[17] = (c) & 0xff))

#define TCP_FLAG_URG            0x20
#define TCP_FLAG_ACK            0x10
#define TCP_FLAG_PSH            0x8
#define TCP_FLAG_RST            0x4
#define TCP_FLAG_SYN            0x2
#define TCP_FLAG_FIN            0x1


/* UDP header macros */


/* pointer to TCP header from IP header pointer */
#define UDP_PTR(p)              ((PUDP_HDR)(((ULONG *)(p)) + ((ULONG)IP_GET_HLEN(p))))

/* source port */
#define UDP_GET_SRC_PORT(p)     (((ULONG) ((p) -> byte[0]) << 8) | (ULONG) ((p) -> byte[1]))
#define UDP_GET_SRC_PORT_PTR(p) (& ((p) -> byte[0]))
#define UDP_GET_SRC_FPORT(p)    (* ((PUSHORT) &((p) -> byte[0])))

/* 64-bit -- ramkrish */
#define UDP_SET_SRC_PORT_64(p,v) (((p) -> byte[0] = v >> 8), ((p) -> byte[1] = v & 0xff))

/* destination port */
#define UDP_GET_DST_PORT(p)     (((ULONG) ((p) -> byte[2]) << 8) | (ULONG) ((p) -> byte[3]))
#define UDP_GET_DST_PORT_PTR(p) (& ((p) -> byte[2]))
#define UDP_GET_DST_FPORT(p)    (* ((PUSHORT) &((p) -> byte[2])))

/* 64-bit -- ramkrish */
#define UDP_SET_DST_PORT_64(p,v) (((p) -> byte[2] = v >> 8), ((p) -> byte[3] = v & 0xff))

/* packet length */
#define UDP_GET_LEN(p)          (((ULONG) ((p) -> byte[4]) << 8) | (ULONG) ((p) -> byte[5]))

/* packet length */
#define UDP_GET_CHKSUM(p)       (((USHORT) ((p) -> byte[6]) << 8) | (USHORT) ((p) -> byte[7]))
#define UDP_SET_CHKSUM(p,c)     (((p) -> byte[6] = (c) >> 8), ((p) -> byte[7] = (c) & 0xff))

/* pointer to datagram */
#define UDP_GET_DGRAM_PTR(p)    ((PUCHAR)(p) + sizeof (UDP_HDR))


/* V1.11 NetBIOS name cluster name support */


#define NBT_NAME_LEN            16
#define NBT_ENCODED_NAME_LEN    (2 * NBT_NAME_LEN) /* multiplier HAS to be 2 */

#define NBT_ENCODED_NAME_BASE   'A'

#define NBT_NAME_SHADOW         "*SMBSERVER      "

#define NBT_ENCODED_NAME_SHADOW \
{ \
    'C', 'K', 'F', 'D', 'E', 'N', 'E', 'C', 'F', 'D', 'E', 'F', 'F', 'C', 'F', 'G', \
    'E', 'F', 'F', 'C', 'C', 'A', 'C', 'A', 'C', 'A', 'C', 'A', 'C', 'A', 'C', 'A'  \
}

#define NBT_ENCODE_FIRST(c)     (((c) >> 4)  + NBT_ENCODED_NAME_BASE)
#define NBT_ENCODE_SECOND(c)    (((c) & 0xf) + NBT_ENCODED_NAME_BASE)

#define NBT_SESSION_PORT        139
#define NBT_SESSION_REQUEST     0x81        /* packet type */

typedef struct
{
    UCHAR               byte[72];  /* only the session request packet */
}
NBT_HDR, * PNBT_HDR;

/* pointer to NBT header from TCP header */
#define NBT_PTR(p)              ((PNBT_HDR)(((ULONG *)(p)) + ((ULONG) TCP_GET_HLEN(p))))

/* packet type */
#define NBT_GET_PKT_TYPE(p)     ((ULONG) ((p) -> byte[0]))

/* packet length */
#define NBT_GET_PKT_LEN(p)      ((ULONG) ((p) -> byte[3]))

/* called name */
#define NBT_GET_CALLED_NAME(p)  ((PUCHAR) & ((p) -> byte[4]))       /* server's name */

/* calling name */
#define NBT_GET_CALLING_NAME(p) ((PUCHAR) & ((p) -> byte[36]))      /* client's name */


/* PPTP/IPSEC support */

#define PPTP_CTRL_PORT          1723
#define IPSEC_NAT_PORT          4500
#define IPSEC_CTRL_PORT         500
#define TCP_HTTP_PORT           80

/* TCPIP module context */

typedef struct
{
    UCHAR               nbt_encoded_cluster_name [NBT_ENCODED_NAME_LEN]; /* V1.2 */
}
TCPIP_CTXT, * PTCPIP_CTXT;
#pragma pack()
#endif /* _Tcpip_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\installpack\pch.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       P C H . H
//
//  Contents:   Pre-compiled header file
//
//  Notes:
//
//  Author:     kumarp 28-September-98
//
//----------------------------------------------------------------------------

#pragma once

// Turns off "string too long - truncated to 255 characters in the debug
// information, debugger cannot evaluate symbol."
//
#pragma warning (disable: 4786)

#include <windows.h>
#include <netcfgx.h>
#include <netcfgn.h>

#include <setupapi.h>
#include <devguid.h>
#include <tchar.h>
#include <stdio.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\installpack\snetcfg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S N E T C F G . H
//
//  Contents:   Sample code that demonstrates how to:
//              - find out if a component is installed
//              - install a net component
//              - install an OEM net component
//              - uninstall a net component
//              - enumerate net components
//              - enumerate net adapters using Setup API
//              - enumerate binding paths of a component
//
//  Notes:
//
//  Author:     kumarp 26-March-98
//
//----------------------------------------------------------------------------

#pragma once

enum NetClass
{
    NC_NetAdapter=0,
    NC_NetProtocol,
    NC_NetService,
    NC_NetClient,
    NC_Unknown
};

HRESULT FindIfComponentInstalled(IN PCWSTR szComponentId);

HRESULT HrInstallNetComponent(IN PCWSTR szComponentId,
                              IN enum NetClass nc,
                              IN PCWSTR szSrcDir);

HRESULT HrUninstallNetComponent(IN PCWSTR szComponentId);


HRESULT HrShowNetAdapters();
HRESULT HrShowNetComponents();
HRESULT HrShowBindingPathsOfComponent(IN PCWSTR szComponentId);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\installpack\snetcfg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S N E T C F G . C P P
//
//  Contents:   Sample code that demonstrates how to:
//              - find out if a component is installed
//              - install a net component
//              - install an OEM net component
//              - uninstall a net component
//              - enumerate net components
//              - enumerate net adapters using Setup API
//              - enumerate binding paths of a component
//
//  Notes:
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "snetcfg.h"


//----------------------------------------------------------------------------
// Globals
//
static const GUID* c_aguidClass[] =
{
    &GUID_DEVCLASS_NET,
    &GUID_DEVCLASS_NETTRANS,
    &GUID_DEVCLASS_NETSERVICE,
    &GUID_DEVCLASS_NETCLIENT
};

//----------------------------------------------------------------------------
// Prototypes of helper functions
//
HRESULT HrInstallNetComponent(IN INetCfg* pnc, IN PCWSTR szComponentId,
                              IN const GUID* pguidClass);
HRESULT HrUninstallNetComponent(IN INetCfg* pnc, IN PCWSTR szComponentId);
HRESULT HrGetINetCfg(IN BOOL fGetWriteLock, INetCfg** ppnc);
HRESULT HrReleaseINetCfg(BOOL fHasWriteLock, INetCfg* pnc);
void ShowMessage(IN PCWSTR szMsg, ...);
void ShowHrMessage(IN HRESULT hr);
inline ULONG ReleaseObj(IUnknown* punk)
{
    return (punk) ? punk->Release () : 0;
}


//+---------------------------------------------------------------------------
//
// Function:  HrIsComponentInstalled
//
// Purpose:   Find out if a component is installed
//
// Arguments:
//    szComponentId [in]  id of component to search
//
// Returns:   S_OK    if installed,
//            S_FALSE if not installed,
//            otherwise an error code
//
// Author:    kumarp 11-February-99
//
// Notes:
//
HRESULT HrIsComponentInstalled(IN PCWSTR szComponentId)
{
    HRESULT hr=S_OK;
    INetCfg* pnc;
    INetCfgComponent* pncc;

    hr = HrGetINetCfg(FALSE, &pnc);
    if (S_OK == hr)
    {
        hr = pnc->FindComponent(szComponentId, &pncc);
        if (S_OK == hr)
        {
            ReleaseObj(pncc);
        }
        (void) HrReleaseINetCfg(FALSE, pnc);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  FindIfComponentInstalled
//
// Purpose:   Find out if a component is installed
//
// Arguments:
//    szComponentId [in]  id of component to locate
//
// Returns:   None
//
// Author:    kumarp 11-February-99
//
// Notes:
//
HRESULT FindIfComponentInstalled(IN PCWSTR szComponentId)
{
    HRESULT hr=S_OK;

    hr = HrIsComponentInstalled(szComponentId);
    if (S_OK == hr)
    {
        _tprintf(L"'%s' is installed\n", szComponentId);
    }
    else if (S_FALSE == hr)
    {
        _tprintf(L"'%s' is not installed\n", szComponentId);
    }
    else
    {
        _tprintf(L"Could not find if '%s' is installed. error code: 0x%x\n",
                 szComponentId, hr);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrInstallNetComponent
//
// Purpose:   Install the specified net component
//
// Arguments:
//    szComponentId [in]  component to install
//    nc            [in]  class of the component
//    szInfFullPath [in]  full path to primary INF file
//                        required if the primary INF and other
//                        associated files are not pre-copied to
//                        the right destination dirs.
//                        Not required when installing MS components
//                        since the files are pre-copied by
//                        Windows NT Setup.
//
// Returns:   S_OK or NETCFG_S_REBOOT on success, otherwise an error code
//
// Notes:
//
HRESULT HrInstallNetComponent(IN PCWSTR szComponentId,
                              IN enum NetClass nc,
                              IN PCWSTR szInfFullPath)
{
    HRESULT hr=S_OK;
    INetCfg* pnc;

    // cannot install net adapters this way. they have to be
    // enumerated/detected and installed by PnP

    if ((nc == NC_NetProtocol) ||
        (nc == NC_NetService) ||
        (nc == NC_NetClient))
    {
        ShowMessage(L"Trying to install '%s'...", szComponentId);

        // if full path to INF has been specified, the INF
        // needs to be copied using Setup API to ensure that any other files
        // that the primary INF copies will be correctly found by Setup API
        //
        if (szInfFullPath && wcslen(szInfFullPath))
        {
            WCHAR szInfNameAfterCopy[MAX_PATH+1];
            if (SetupCopyOEMInf(
                    szInfFullPath,
                    NULL,               // other files are in the
                                        // same dir. as primary INF
                    SPOST_PATH,         // first param. contains path to INF
                    0,                  // default copy style
                    szInfNameAfterCopy, // receives the name of the INF
                                        // after it is copied to %windir%\inf
                    MAX_PATH,           // max buf. size for the above
                    NULL,               // receives required size if non-null
                    NULL))              // optionally retrieves filename
                                        // component of szInfNameAfterCopy
            {
                ShowMessage(L"...%s was copied to %s",
                            szInfFullPath,
                            szInfNameAfterCopy);
            }
            else
            {
                DWORD dwError = GetLastError();
                hr = HRESULT_FROM_WIN32(dwError);
            }
        }

        if (S_OK == hr)
        {
            // get INetCfg interface
            hr = HrGetINetCfg(TRUE, &pnc);

            if (SUCCEEDED(hr))
            {
                // install szComponentId
                hr = HrInstallNetComponent(pnc, szComponentId,
                                           c_aguidClass[nc]);
                if (SUCCEEDED(hr))
                {
                    // Apply the changes
                    hr = pnc->Apply();
                }

                // release INetCfg
                (void) HrReleaseINetCfg(TRUE, pnc);
            }
        }
        // show success/failure message
        ShowHrMessage(hr);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrInstallNetComponent
//
// Purpose:   Install the specified net component
//
// Arguments:
//    pnc           [in]  pointer to INetCfg object
//    szComponentId [in]  component to install
//    pguidClass    [in]  class guid of the component
//
// Returns:   S_OK or NETCFG_S_REBOOT on success, otherwise an error code
//
// Notes:
//
HRESULT HrInstallNetComponent(IN INetCfg* pnc,
                              IN PCWSTR szComponentId,
                              IN const GUID* pguidClass)
{
    HRESULT hr=S_OK;
    OBO_TOKEN OboToken;
    INetCfgClassSetup* pncClassSetup;
    INetCfgComponent* pncc;

    // OBO_TOKEN specifies the entity on whose behalf this
    // component is being installed

    // set it to OBO_USER so that szComponentId will be installed
    // On-Behalf-Of "user"
    ZeroMemory (&OboToken, sizeof(OboToken));
    OboToken.Type = OBO_USER;

    hr = pnc->QueryNetCfgClass (pguidClass, IID_INetCfgClassSetup,
                                (void**)&pncClassSetup);
    if (SUCCEEDED(hr))
    {
        hr = pncClassSetup->Install(szComponentId,
                                    &OboToken,
                                    NSF_POSTSYSINSTALL,
                                    0,       // <upgrade-from-build-num>
                                    NULL,    // answerfile name
                                    NULL,    // answerfile section name
                                    &pncc);
        if (S_OK == hr)
        {
            // we dont want to use pncc (INetCfgComponent), release it
            ReleaseObj(pncc);
        }

        ReleaseObj(pncClassSetup);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrUninstallNetComponent
//
// Purpose:   Initialize INetCfg and uninstall a component
//
// Arguments:
//    szComponentId [in]  InfId of component to uninstall (e.g. MS_TCPIP)
//
// Returns:   S_OK or NETCFG_S_REBOOT on success, otherwise an error code
//
// Notes:
//
HRESULT HrUninstallNetComponent(IN PCWSTR szComponentId)
{
    HRESULT hr=S_OK;
    INetCfg* pnc;

    ShowMessage(L"Trying to uninstall '%s'...", szComponentId);

    // get INetCfg interface
    hr = HrGetINetCfg(TRUE, &pnc);

    if (SUCCEEDED(hr))
    {
        // uninstall szComponentId
        hr = HrUninstallNetComponent(pnc, szComponentId);

        if (S_OK == hr)
        {
            // Apply the changes
            hr = pnc->Apply();
        }
        else if (S_FALSE == hr)
        {
            ShowMessage(L"...'%s' is not installed", szComponentId);
        }

        // release INetCfg
        (void) HrReleaseINetCfg(TRUE, pnc);
    }

    // show success/failure message
    ShowHrMessage(hr);

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrUninstallNetComponent
//
// Purpose:   Uninstall the specified component.
//
// Arguments:
//    pnc           [in]  pointer to INetCfg object
//    szComponentId [in]  component to uninstall
//
// Returns:   S_OK or NETCFG_S_REBOOT on success, otherwise an error code
//
// Notes:
//
HRESULT HrUninstallNetComponent(IN INetCfg* pnc, IN PCWSTR szComponentId)
{
    HRESULT hr=S_OK;
    OBO_TOKEN OboToken;
    INetCfgComponent* pncc;
    GUID guidClass;
    INetCfgClass* pncClass;
    INetCfgClassSetup* pncClassSetup;

    // OBO_TOKEN specifies the entity on whose behalf this
    // component is being uninstalld

    // set it to OBO_USER so that szComponentId will be uninstalld
    // On-Behalf-Of "user"
    ZeroMemory (&OboToken, sizeof(OboToken));
    OboToken.Type = OBO_USER;

    // see if the component is really installed
    hr = pnc->FindComponent(szComponentId, &pncc);

    if (S_OK == hr)
    {
        // yes, it is installed. obtain INetCfgClassSetup and DeInstall

        hr = pncc->GetClassGuid(&guidClass);

        if (S_OK == hr)
        {
            hr = pnc->QueryNetCfgClass(&guidClass, IID_INetCfgClass,
                                       (void**)&pncClass);
            if (SUCCEEDED(hr))
            {
                hr = pncClass->QueryInterface(IID_INetCfgClassSetup,
                                              (void**)&pncClassSetup);
                    if (SUCCEEDED(hr))
                    {
                        hr = pncClassSetup->DeInstall (pncc, &OboToken, NULL);

                        ReleaseObj (pncClassSetup);
                    }
                ReleaseObj(pncClass);
            }
        }
        ReleaseObj(pncc);
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
// Function:  HrShowNetAdapters
//
// Purpose:   Display all installed net class devices using Setup API
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
HRESULT HrShowNetAdapters()
{
#define MAX_COMP_INSTID 4096
#define MAX_COMP_DESC   4096

    HRESULT hr=S_OK;
    HDEVINFO hdi;
    DWORD dwIndex=0;
    SP_DEVINFO_DATA deid;
    BOOL fSuccess=FALSE;
    DWORD   cchRequiredSize;
    WCHAR szCompInstanceId[MAX_COMP_INSTID];
    WCHAR szCompDescription[MAX_COMP_DESC];
    DWORD dwRegType;
    BOOL fFound=FALSE;

    // get a list of all devices of class 'GUID_DEVCLASS_NET'
    hdi = SetupDiGetClassDevs(&GUID_DEVCLASS_NET, NULL, NULL, DIGCF_PRESENT);

    if (INVALID_HANDLE_VALUE != hdi)
    {
        // enumerate over each device
        while (deid.cbSize = sizeof(SP_DEVINFO_DATA),
               SetupDiEnumDeviceInfo(hdi, dwIndex, &deid))
        {
            dwIndex++;

            // the right thing to do here would be to call this function
            // to get the size required to hold the instance ID and then
            // to call it second time with a buffer large enough for that size.
            // However, that would tend to obscure the control flow in
            // the sample code. Lets keep things simple by keeping the
            // buffer large enough.

            // get the device instance ID
            fSuccess = SetupDiGetDeviceInstanceId(hdi, &deid,
                                                  szCompInstanceId,
                                                  MAX_COMP_INSTID, NULL);
            if (fSuccess)
            {
                // get the description for this instance
                fSuccess =
                    SetupDiGetDeviceRegistryProperty(hdi, &deid,
                                                     SPDRP_DEVICEDESC,
                                                     &dwRegType,
                                                     (BYTE*) szCompDescription,
                                                     MAX_COMP_DESC,
                                                     NULL);
                if (fSuccess)
                {
                    if (!fFound)
                    {
                        fFound = TRUE;
                        _tprintf(L"Instance ID\tDescription\n");
                        _tprintf(L"-----------\t-----------\n");
                    }
                    _tprintf(L"%s\t%s\n",
                             szCompInstanceId, szCompDescription);
                }
            }
        }

        // release the device info list
        SetupDiDestroyDeviceInfoList(hdi);
    }

    if (!fSuccess)
    {
        DWORD dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrShowNetComponents
//
// Purpose:   Display the list of installed components of the
//            specified class.
//
// Arguments:
//    pnc        [in]  pointer to INetCfg object
//    pguidClass [in]  pointer to class GUID
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
HRESULT HrShowNetComponents(IN INetCfg* pnc,
                            IN const GUID* pguidClass)
{
    HRESULT hr=S_OK;
    PWSTR szInfId;
    PWSTR szDisplayName;
    DWORD dwcc;
    INetCfgComponent* pncc;
    INetCfgClass* pncclass;
    IEnumNetCfgComponent* pencc;
    ULONG celtFetched;

    hr = pnc->QueryNetCfgClass(pguidClass, IID_INetCfgClass,
                               (void**)&pncclass);
    if (SUCCEEDED(hr))
    {
        // get IEnumNetCfgComponent so that we can enumerate
        hr = pncclass->EnumComponents(&pencc);

        ReleaseObj(pncclass);

        while (SUCCEEDED(hr) &&
               (S_OK == (hr = pencc->Next(1, &pncc, &celtFetched))))
        {
            if (pguidClass == &GUID_DEVCLASS_NET)
            {
                // we are interested only in physical netcards
                //
                hr = pncc->GetCharacteristics(&dwcc);

                if (FAILED(hr) || !(dwcc & NCF_PHYSICAL))
                {
                    hr = S_OK;
                    ReleaseObj(pncc);
                    continue;
                }
            }

            hr = pncc->GetId(&szInfId);

            if (S_OK == hr)
            {
                hr = pncc->GetDisplayName(&szDisplayName);
                if (SUCCEEDED(hr))
                {
                    _tprintf(L"%-26s %s\n", szInfId, szDisplayName);

                    CoTaskMemFree(szDisplayName);
                }
                CoTaskMemFree(szInfId);
            }
            // we dont want to stop enumeration just because 1 component
            // failed either GetId or GetDisplayName, therefore reset hr to S_OK
            hr = S_OK;

            ReleaseObj(pncc);
        }
        ReleaseObj(pencc);
    }


    if (S_FALSE == hr)
    {
        hr = S_OK;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
// Function:  HrShowNetComponents
//
// Purpose:   Display installed net components.
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
HRESULT HrShowNetComponents()
{
    HRESULT hr=S_OK;
    PCWSTR szClassName;

    static const PCWSTR c_aszClassNames[] =
    {
        L"Network Adapters",
        L"Network Protocols",
        L"Network Services",
        L"Network Clients"
    };

    INetCfg* pnc;

    // get INetCfg interface
    hr = HrGetINetCfg(FALSE, &pnc);

    if (SUCCEEDED(hr))
    {
        for (int i=0; i<4; i++)
        {
            _tprintf(L"\n%s\n-----------------\n", c_aszClassNames[i]);

            (void) HrShowNetComponents(pnc, c_aguidClass[i]);
        }

        // release INetCfg
        hr = HrReleaseINetCfg(FALSE, pnc);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrGetNextBindingInterface
//
// Purpose:   Enumerate over binding interfaces that constitute
//            the given binding path
//
// Arguments:
//    pncbp  [in]  pointer to INetCfgBindingPath object
//    ppncbi [out] pointer to pointer to INetCfgBindingInterface object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
HRESULT HrGetNextBindingInterface(IN  INetCfgBindingPath* pncbp,
                                  OUT INetCfgBindingInterface** ppncbi)
{
    HRESULT hr=S_OK;
    INetCfgBindingInterface* pncbi=NULL;

    static IEnumNetCfgBindingInterface* pencbi=NULL;

    *ppncbi = NULL;

    // if this is the first call in the enumeration, obtain
    // the IEnumNetCfgBindingInterface interface
    //
    if (!pencbi)
    {
        hr = pncbp->EnumBindingInterfaces(&pencbi);
    }

    if (S_OK == hr)
    {
        ULONG celtFetched;

        // get next binding interface
        hr = pencbi->Next(1, &pncbi, &celtFetched);
    }

    // on the last call (hr == S_FALSE) or on error, release resources

    if (S_OK == hr)
    {
        *ppncbi = pncbi;
    }
    else
    {
        ReleaseObj(pencbi);
        pencbi = NULL;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrGetNextBindingPath
//
// Purpose:   Enumerate over binding paths that start with
//            the specified component
//
// Arguments:
//    pncc              [in]  pointer to INetCfgComponent object
//    dwBindingPathType [in]  type of binding path to retrieve
//    ppncbp            [out] pointer to INetCfgBindingPath interface
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
HRESULT HrGetNextBindingPath(IN  INetCfgComponent* pncc,
                             IN  DWORD  dwBindingPathType,
                             OUT INetCfgBindingPath** ppncbp)
{
    HRESULT hr=S_OK;
    INetCfgBindingPath* pncbp=NULL;

    static IEnumNetCfgBindingPath* pebp=NULL;

    *ppncbp = NULL;

    // if this is the first call in the enumeration, obtain
    // the IEnumNetCfgBindingPath interface
    if (!pebp)
    {
        INetCfgComponentBindings* pnccb=NULL;

        hr = pncc->QueryInterface(IID_INetCfgComponentBindings,
                                  (void**) &pnccb);
        if (S_OK == hr)
        {
            hr = pnccb->EnumBindingPaths(dwBindingPathType, &pebp);
            ReleaseObj(pnccb);
        }
    }

    if (S_OK == hr)
    {
        ULONG celtFetched;

        // get next binding path
        hr = pebp->Next(1, &pncbp, &celtFetched);
    }

    // on the last call (hr == S_FALSE) or on error, release resources

    if (S_OK == hr)
    {
        *ppncbp = pncbp;
    }
    else
    {
        ReleaseObj(pebp);
        pebp = NULL;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrShowBindingPath
//
// Purpose:   Display components of a binding path in the format:
//            foo -> bar -> adapter
//
// Arguments:
//    pncbp [in]  pointer to INetCfgBindingPath object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
HRESULT HrShowBindingPath(IN INetCfgBindingPath* pncbp)
{
    HRESULT hr=S_OK;
    INetCfgBindingInterface* pncbi;
    INetCfgComponent* pncc = NULL;
    BOOL fFirstInterface=TRUE;
    PWSTR szComponentId;

    while (SUCCEEDED(hr) &&
           (S_OK == (hr = HrGetNextBindingInterface(pncbp, &pncbi))))
    {
        // for the first (top) interface we need to get the upper as well as
        // the lower component. for other interfaces we need to get
        // only the lower component.

        if (fFirstInterface)
        {
            fFirstInterface = FALSE;
            hr = pncbi->GetUpperComponent(&pncc);
            if (SUCCEEDED(hr))
            {
                // get id so that we can display it
                //
                // for readability of the output, we have used the GetId
                // function. For non net class components, this
                // does not pose a problem. In case of net class components,
                // there may be more than one net adapters of the same type
                // in which case, GetId will return the same string. This will
                // make it impossible to distinguish between two binding
                // paths that end in two distinct identical cards. In such case,
                // it may be better to use the GetInstanceGuid function because
                // it will return unique GUID for each instance of an adapter.
                //
                hr = pncc->GetId(&szComponentId);
                ReleaseObj(pncc);
                if (SUCCEEDED(hr))
                {
                    _tprintf(szComponentId);
                    CoTaskMemFree(szComponentId);
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = pncbi->GetLowerComponent(&pncc);
            if (SUCCEEDED(hr))
            {
                hr = pncc->GetId(&szComponentId);
                if (SUCCEEDED(hr))
                {
                    _tprintf(L" -> %s", szComponentId);
                    CoTaskMemFree(szComponentId);
                }
                ReleaseObj(pncc);
            }
        }
        ReleaseObj(pncbi);
    }

    _tprintf(L"\n");

    if (hr == S_FALSE)
    {
        hr = S_OK;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrShowBindingPathsBelowComponent
//
// Purpose:   Display all binding paths that start with
//            the specified component
//
// Arguments:
//    szComponentId [in]  id of given component (e.g. MS_TCPIP)
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
HRESULT HrShowBindingPathsOfComponent(IN PCWSTR szComponentId)
{
    HRESULT hr=S_OK;
    INetCfg* pnc=NULL;
    INetCfgComponent* pncc=NULL;
    INetCfgBindingPath* pncbp=NULL;

    // get INetCfg interface
    hr = HrGetINetCfg(FALSE, &pnc);

    if (SUCCEEDED(hr))
    {
        // get INetCfgComponent for szComponentId
        hr = pnc->FindComponent(szComponentId, &pncc);
        if (S_OK == hr)
        {
            _tprintf(L"Binding paths starting with '%s'\n\n",
                     szComponentId);

            while (S_OK == (hr = HrGetNextBindingPath(pncc, EBP_BELOW,
                                                      &pncbp)))
            {
                // display the binding path
                hr = HrShowBindingPath(pncbp);
                ReleaseObj(pncbp);
            }

            _tprintf(L"Binding paths ending with '%s'\n\n",
                     szComponentId);

            while (S_OK == (hr = HrGetNextBindingPath(pncc, EBP_ABOVE,
                                                      &pncbp)))
            {
                // display the binding path
                hr = HrShowBindingPath(pncbp);
                ReleaseObj(pncbp);
            }

            ReleaseObj(pncc);
        }
        // release INetCfg
        hr = HrReleaseINetCfg(FALSE, pnc);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrGetINetCfg
//
// Purpose:   Initialize COM, create and initialize INetCfg.
//            Obtain write lock if indicated.
//
// Arguments:
//    fGetWriteLock [in]  whether to get write lock
//    ppnc          [in]  pointer to pointer to INetCfg object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
HRESULT HrGetINetCfg(IN BOOL fGetWriteLock,
                     INetCfg** ppnc)
{
    HRESULT hr=S_OK;

    // Initialize the output parameters.
    *ppnc = NULL;

    // initialize COM
    hr = CoInitializeEx(NULL,
                        COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED );

    if (SUCCEEDED(hr))
    {
        // Create the object implementing INetCfg.
        //
        INetCfg* pnc;
        hr = CoCreateInstance(CLSID_CNetCfg, NULL, CLSCTX_INPROC_SERVER,
                              IID_INetCfg, (void**)&pnc);
        if (SUCCEEDED(hr))
        {
            INetCfgLock * pncLock = NULL;
            if (fGetWriteLock)
            {
                // Get the locking interface
                hr = pnc->QueryInterface(IID_INetCfgLock,
                                         (LPVOID *)&pncLock);
                if (SUCCEEDED(hr))
                {
                    // Attempt to lock the INetCfg for read/write
                    static const ULONG c_cmsTimeout = 15000;
                    static const WCHAR c_szSampleNetcfgApp[] =
                        L"Sample Netcfg Application (netcfg.exe)";
                    PWSTR szLockedBy;

                    hr = pncLock->AcquireWriteLock(c_cmsTimeout,
                                                   c_szSampleNetcfgApp,
                                                   &szLockedBy);
                    if (S_FALSE == hr)
                    {
                        hr = NETCFG_E_NO_WRITE_LOCK;
                        _tprintf(L"Could not lock INetcfg, it is already locked by '%s'", szLockedBy);
                    }
                }
            }

            if (SUCCEEDED(hr))
            {
                // Initialize the INetCfg object.
                //
                hr = pnc->Initialize(NULL);
                if (SUCCEEDED(hr))
                {
                    *ppnc = pnc;
                    pnc->AddRef();
                }
                else
                {
                    // initialize failed, if obtained lock, release it
                    if (pncLock)
                    {
                        pncLock->ReleaseWriteLock();
                    }
                }
            }
            ReleaseObj(pncLock);
            ReleaseObj(pnc);
        }

        if (FAILED(hr))
        {
            CoUninitialize();
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrReleaseINetCfg
//
// Purpose:   Uninitialize INetCfg, release write lock (if present)
//            and uninitialize COM.
//
// Arguments:
//    fHasWriteLock [in]  whether write lock needs to be released.
//    pnc           [in]  pointer to INetCfg object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
HRESULT HrReleaseINetCfg(BOOL fHasWriteLock, INetCfg* pnc)
{
    HRESULT hr = S_OK;

    // uninitialize INetCfg
    hr = pnc->Uninitialize();

    // if write lock is present, unlock it
    if (SUCCEEDED(hr) && fHasWriteLock)
    {
        INetCfgLock* pncLock;

        // Get the locking interface
        hr = pnc->QueryInterface(IID_INetCfgLock,
                                 (LPVOID *)&pncLock);
        if (SUCCEEDED(hr))
        {
            hr = pncLock->ReleaseWriteLock();
            ReleaseObj(pncLock);
        }
    }

    ReleaseObj(pnc);

    CoUninitialize();

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  ShowMessage
//
// Purpose:   Helper function to display a message in verbose mode.
//            If not in verbose mode, do nothing.
//
// Arguments:
//    szMsg [in]  message to display
//
// Returns:   None
//
// Notes:
//
void ShowMessage(IN PCWSTR szMsg, ...)
{
    extern BOOL g_fVerbose;

    if (g_fVerbose)
    {
        va_list arglist;

        va_start(arglist, szMsg);
        _vtprintf(szMsg, arglist);
        _tprintf(L"\n");
        fflush(stdout);
        va_end(arglist);
    }
}

//+---------------------------------------------------------------------------
//
// Function:  ShowHrMessage
//
// Purpose:   Helper function to display the status of the last action
//            as indicated by the given HRESULT
//
// Arguments:
//    hr [in]  status code
//
// Returns:   None
//
// Notes:
//
void ShowHrMessage(IN HRESULT hr)
{
    if (SUCCEEDED(hr))
    {
        ShowMessage(L"...done");
        if (NETCFG_S_REBOOT == hr)
        {
            ShowMessage(L"*** You need to reboot your computer for this change to take effect ***");
        }
    }
    else
    {
        ShowMessage(L"..failed. Error code: 0x%lx", hr);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\installpack\install.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       M A I N . C P P
//
//  Contents:   Code to provide a simple cmdline interface to
//              the sample code functions
//
//  Notes:      The code in this file is not required to access any
//              netcfg functionality. It merely provides a simple cmdline
//              interface to the sample code functions provided in
//              file snetcfg.cpp.
//
//  Author:     kumarp    28-September-98
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "snetcfg.h"
#include "error.h"
#include <wbemcli.h>
#include <winnls.h>
#include "tracelog.h"

BOOL g_fVerbose = FALSE;

BOOL WlbsCheckSystemVersion ();
BOOL WlbsCheckFiles ();
HRESULT WlbsRegisterDlls ();
HRESULT WlbsCompileMof ();

// ----------------------------------------------------------------------
//
// Function:  wmain
//
// Purpose:   This is the main function for NLBWizard, which is for W2K
//            installations of NLB. Making this application compatible
//            with post-W2K releases will require changes, e.g., in
//            functions WlbsCheckFiles and WlbsCheckSystemVersion.
//
// Arguments: standard main args
//
// Returns:   0 on success, non-zero otherwise
//
// Author:    kumarp 25-December-97
//
// Notes:
//
EXTERN_C int __cdecl wmain (int argc, WCHAR * argv[]) {
    HRESULT hr = S_OK;
    WCHAR ch;
    enum NetClass nc = NC_Unknown;
    WCHAR szFileFullPath[MAX_PATH+1];
    WCHAR szFileFullPathDest[MAX_PATH+1];
    PWCHAR pwc;
    PWSTR szFileComponent;

    TRACELogRegister(L"wlbs");

    LOG_INFO("Checking Windows version information.");

    if (!WlbsCheckSystemVersion()) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_NLB, NLB_E_INVALID_OS);
        LOG_ERROR("The NLB install pack can only be used on Windows 2000 Server Service Pack 1 or higher.");
        goto error;
    }

    LOG_INFO("Checking for previous NLB installations.");

    hr = FindIfComponentInstalled(_TEXT("ms_wlbs"));

    if (hr == S_OK) {
        /* AppCenter request on 1.9.01 to revert to S_FALSE in this case due to RTM proximity. */
        /* hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_NLB, NLB_E_ALREADY_INSTALLED); */
        hr = S_FALSE;
        LOG_ERROR("Network Load Balancing Service is already installed.");
        goto error;
    }

    if (FAILED(hr)) {
        LOG_ERROR("Warning: Error querying for Network Load Balancing Service. There may be errors in this installtion.");
    }

    LOG_INFO("Checking for necessary files.");

    if (!WlbsCheckFiles()) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_NLB, NLB_E_FILES_MISSING);
        LOG_ERROR1("Please install the NLB hotfix before running %ls", argv[0]);
        goto error;
    }

    GetModuleFileName(NULL, szFileFullPath, MAX_PATH + 1);

    pwc = wcsrchr(szFileFullPath, L'\\');
    * (pwc + 1) = L'\0';
    wcscat(szFileFullPath, L"netwlbs.inf");

    LOG_INFO("Checking language version.");

    switch (GetSystemDefaultLangID()) {
    case 0x0409: case 0x0809: case 0x0c09: case 0x1009: case 0x1409: case 0x1809: case 0x1c09:
    case 0x2009: case 0x2409: case 0x2809: case 0x2c09:
        LOG_INFO1("English version detected 0x%x.", GetSystemDefaultLangID());
        wcscat (szFileFullPath, L".eng");
        break;
    case 0x0411:
        LOG_INFO1("Japanese version detected 0x%x.", GetSystemDefaultLangID());
        wcscat (szFileFullPath, L".jpn");
        break;
    case 0x0407: case 0x0807: case 0x0c07: case 0x1007: case 0x1407:
        LOG_INFO1("German version detected 0x%x.", GetSystemDefaultLangID());
        wcscat (szFileFullPath, L".ger");
        break;
    case 0x040c: case 0x080c: case 0x0c0c: case 0x100c: case 0x140c:
        LOG_INFO1("French version detected 0x%x.", GetSystemDefaultLangID());
        wcscat (szFileFullPath, L".fr");
        break;
    default:
        LOG_INFO1("Unsupported Language.Please contact PSS for a new %ls.", argv[0]);
        wcscat (szFileFullPath, L".eng");
        break;
    }

    /* First copy the .inf file. */
    if (GetWindowsDirectory(szFileFullPathDest, MAX_PATH + 1) == 0)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto error;
    }
    wcscat(szFileFullPathDest, L"\\INF\\netwlbs.inf");

    LOG_INFO("Copying the NLB .inf file.");

    if (!CopyFile(szFileFullPath, szFileFullPathDest, FALSE)) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_NLB, NLB_E_INF_FAILURE);
        LOG_ERROR2("Warning: Unable to copy the inf file %ls %ls.", szFileFullPath, szFileFullPathDest);
        goto error;
    }

    /* Now install the service. */
    hr = HrInstallNetComponent(L"ms_wlbs", NC_NetService, szFileFullPathDest);

    if (!SUCCEEDED(hr)) {
        LOG_ERROR("Error installing Network Load Balancing.");
        goto error;
    } else {
        LOG_INFO("Installation of Network Load Balancing done.");
    }

    /* Change working directory to %TEMP%. Needed because of a IMofCopiler::CompileFile error on Win2K. */
    WCHAR * szTempDir = _wgetenv(L"TEMP");
    _wchdir(szTempDir);

    LOG_INFO("Registering NLB Dlls.");

    /* Register the provider .dll here. */
    hr = WlbsRegisterDlls();

    if (!SUCCEEDED(hr)) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_NLB, NLB_E_REGISTER_DLL);
        LOG_ERROR("Error registering NLB Dlls.");
        goto error;
    }

    LOG_INFO("Compiling the NLB MOF.");

    /* Compile wlbsprov.mof here */
    hr = WlbsCompileMof();

    if (!SUCCEEDED(hr)) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_NLB, NLB_E_COMPILE_MOF);
        LOG_ERROR("Error compiling the NLB MOF.");
        goto error;
    } 

    LOG_INFO("WLBS Setup successful.");

    return hr;

error:
    LOG_ERROR1("WLBS Setup failed 0x%x", hr);

    return hr;
}

/* This checks whether the system on which NLB is being installed is a W2K Server or not. */
BOOL WlbsCheckSystemVersion () {
    OSVERSIONINFOEX osinfo;

    osinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

    if (!GetVersionEx((LPOSVERSIONINFO)&osinfo)) return FALSE;
    
    /* For install, we return TRUE only if its Windows 2000 Server. */
    if ((osinfo.dwMajorVersion == 5) && 
        (osinfo.dwMinorVersion == 0) && 
        (osinfo.wProductType == VER_NT_SERVER) && 
        !(osinfo.wSuiteMask & VER_SUITE_ENTERPRISE) &&
        !(osinfo.wSuiteMask & VER_SUITE_DATACENTER))
        return TRUE;
    
    return FALSE;
}

BOOL WlbsCheckFiles () {
    WCHAR * FileList [] = {
        L"\\system32\\drivers\\wlbs.sys",
        L"\\system32\\wlbs.exe",
        L"\\help\\wlbs.chm",
        L"\\help\\wlbs.hlp",
        L"\\system32\\wlbsctrl.dll",
        L"\\system32\\wbem\\wlbsprov.dll",
        L"\\system32\\wbem\\wlbsprov.mof",
        L"\\system32\\wbem\\wlbsprov.mfl",
        L"\\inf\\netwlbsm.inf",
        NULL
    };

    WCHAR wszPath [MAX_PATH + 1];
    PWCHAR pwc;
    INT i = 0;
    BOOL first = FALSE;
    WIN32_FIND_DATA FileFind;
    HANDLE hdl;

    while (FileList [i] != NULL) {
        if (GetWindowsDirectory(wszPath, MAX_PATH + 1) == 0)
        {
            //
            // This function returns the inverse of "first" as the status. Since we have a failure here, we set first = TRUE. 
            //
            first = TRUE;
            break;
        }
        wcscat(wszPath, FileList [i]);

        hdl = FindFirstFile(wszPath, & FileFind);

        if (hdl == INVALID_HANDLE_VALUE) {
            if (!first) {
                first = TRUE;
                LOG_ERROR("Error: The following files were not found:");
            }

            LOG_ERROR1("%\tls",wszPath);
        }

        if (hdl != INVALID_HANDLE_VALUE)
            FindClose(hdl);

        i++;
    }

    return !first;
}

HRESULT WlbsRegisterDlls () {
    WCHAR * DllList [] = { 
        L"\\wbem\\wlbsprov.dll",
        NULL
    };
    
    INT i = 0;
    WCHAR pszDllPath [MAX_PATH + 1];
    HINSTANCE hLib;
    CHAR * pszDllEntryPoint = "DllRegisterServer";
    HRESULT (STDAPICALLTYPE * lpDllEntryPoint)(void);
    HRESULT hr = S_OK;

    if (!GetSystemDirectory(pszDllPath, MAX_PATH + 1)) {
        hr = E_UNEXPECTED;
        LOG_ERROR("GetSystemDirectoryFailed.");
        return hr;
    }

    wcscat(pszDllPath, DllList [0]);

    if (FAILED(hr = OleInitialize(NULL))) {
        LOG_ERROR("OleInitialize Failed.");
        return hr;
    }

    hLib = LoadLibrary(pszDllPath);

    if (hLib == NULL) {
        hr = E_UNEXPECTED;
        LOG_ERROR("LoadLibrary for wlbsprov.dll Failed.");
        goto CleanOle;
    }

    (FARPROC &)lpDllEntryPoint = GetProcAddress(hLib, pszDllEntryPoint);

    if (lpDllEntryPoint == NULL) {
        hr = E_UNEXPECTED;
        LOG_ERROR("DllRegisterServer was not found.");
        goto CleanLib;
    }

    if (FAILED(hr = (*lpDllEntryPoint)())) {
        LOG_ERROR("DllRegisterServer failed.");
        goto CleanLib;
    }

    LOG_INFO("Dll Registration Succeeded.");

CleanLib:
    FreeLibrary(hLib);

CleanOle:
    OleUninitialize();

    return hr;
}

HRESULT WlbsCompileMof () {
      WCHAR * MofList [] = {
          L"\\wbem\\wlbsprov.mof",
          NULL
      };

      IMofCompiler * pMofComp = NULL;
      WBEM_COMPILE_STATUS_INFO Info;
      HRESULT hr = S_OK;
      WCHAR pszMofPath [MAX_PATH + 1];

      if (!GetSystemDirectory(pszMofPath, MAX_PATH + 1)) {
          hr = E_UNEXPECTED;
          LOG_ERROR("GetSystemDirectoryFailed.");
          return hr;
      }

      wcscat(pszMofPath, MofList [0]);

      hr = CoInitialize(NULL);

      if (FAILED(hr)) {
          LOG_ERROR("CoInitialize failed.");
          return hr;
      }

      hr = CoCreateInstance(CLSID_MofCompiler, NULL, CLSCTX_INPROC_SERVER, IID_IMofCompiler, (LPVOID *)&pMofComp);

      if (FAILED(hr)) {
          LOG_ERROR("CoCreateInstance Failed.");

          switch (hr) {
          case REGDB_E_CLASSNOTREG:
              LOG_ERROR("Not registered.");
              break;
          case CLASS_E_NOAGGREGATION:
              LOG_ERROR("No aggregration.");
              break;
          default:
              LOG_ERROR1("Error ox%x.", hr);
              break;
          }

          CoUninitialize();

          return hr;
      }

      hr = pMofComp->CompileFile(pszMofPath, NULL, NULL, NULL, NULL, 0, 0, 0, &Info);

      if (hr != WBEM_S_NO_ERROR)
          LOG_ERROR("Compile Failed.");

      pMofComp->Release();

      CoUninitialize();

      return Info.hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\installpack\tracelog.cpp ===
#include <stdio.h>
#include <stdarg.h>
#include "tracelog.h"

static DWORD  sg_dwTraceID = INVALID_TRACEID;
static char    sg_szTraceName[100];   // Used for OutputDebugString

#ifdef DBG
DWORD   sg_dwTracingToDebugger = 1;  // Enable OutputDebugString for debug version by default
#else
DWORD   sg_dwTracingToDebugger = 0;  
#endif

DWORD   sg_dwDebuggerMask      = 0;


inline const char *TraceLevel(DWORD dwDbgLevel)
{
    switch(dwDbgLevel)
    {
        case TL_ERROR: return "ERROR";
        case TL_WARN:  return "WARN ";
        case TL_INFO:  return "INFO ";
        default:       return " ??? ";
    }
}

BOOL TRACELogRegister(LPCTSTR szName)
{
    HKEY       hTracingKey;

    char       szTracingKey[100];
    const char szDebuggerTracingEnableValue[] = "EnableDebuggerTracing";
    const char szTracingMaskValue[]   = "FileTracingMask";

    sg_dwTracingToDebugger = 0;

    sg_dwTraceID = TraceRegister(szName);
    TraceDeregister(sg_dwTraceID);

#ifdef UNICODE
    wsprintfA(szTracingKey, "Software\\Microsoft\\Tracing\\%ls", szName);
#else
    wsprintfA(szTracingKey, "Software\\Microsoft\\Tracing\\%s", szName);
#endif

    if ( ERROR_SUCCESS == RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                        szTracingKey,
                                        0,
                                        KEY_READ|KEY_SET_VALUE,
                                        &hTracingKey) )
    {
        DWORD      dwDataSize = sizeof (DWORD);
        DWORD      dwDataType;

#ifdef DBG
        //
        //  Always Enable file tracing for debug version
        //
        DWORD dwEnableFileTracing = 1;
        RegSetValueExA(hTracingKey,
                         "EnableFileTracing",
                         0,
                         REG_DWORD,
                         (LPBYTE) &dwEnableFileTracing,
                         sizeof (DWORD));
#endif

        dwDataSize = sizeof (DWORD);
        RegQueryValueExA(hTracingKey,
                         szDebuggerTracingEnableValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwTracingToDebugger,
                         &dwDataSize);

        dwDataSize = sizeof (DWORD);
        RegQueryValueExA(hTracingKey,
                         szTracingMaskValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwDebuggerMask,
                         &dwDataSize);

        RegCloseKey (hTracingKey);
    }

#ifdef UNICODE
    wsprintfA(sg_szTraceName, "%ls", szName);
#else
    wsprintfA(sg_szTraceName, "%s", szName);
#endif

    sg_dwTraceID = TraceRegister(szName);
    return (sg_dwTraceID != INVALID_TRACEID);
}


void TRACELogDeRegister()
{
    sg_dwTracingToDebugger = 0;

    if (sg_dwTraceID != INVALID_TRACEID)
    {
        TraceDeregister(sg_dwTraceID);
        sg_dwTraceID = INVALID_TRACEID;
    }
}


void TRACELogPrint(IN DWORD dwDbgLevel, IN LPCSTR lpszFormat, IN ...)
{
    #define MAXDEBUGSTRINGLENGTH 1024
    char    szTraceBuf[MAXDEBUGSTRINGLENGTH + 1];
    va_list arglist;

    if ( ( sg_dwTracingToDebugger > 0 ) &&
         ( dwDbgLevel & sg_dwDebuggerMask ) )
    {

        // retrieve local time
        SYSTEMTIME SystemTime;
        GetLocalTime(&SystemTime);

        wsprintfA(szTraceBuf,
                  "%s:[%02u:%02u:%02u.%03u:] [%s] ",
                  sg_szTraceName,
                  SystemTime.wHour,
                  SystemTime.wMinute,
                  SystemTime.wSecond,
                  SystemTime.wMilliseconds,
                  TraceLevel(dwDbgLevel));

        va_list ap;
        va_start(ap, lpszFormat);

        _vsnprintf(&szTraceBuf[lstrlenA(szTraceBuf)], 
            MAXDEBUGSTRINGLENGTH - lstrlenA(szTraceBuf), 
            lpszFormat, 
            ap
            );

        lstrcatA (szTraceBuf, "\n");

        OutputDebugStringA (szTraceBuf);

        va_end(ap);
		
    }
    
	if (sg_dwTraceID != INVALID_TRACEID && ( dwDbgLevel & sg_dwDebuggerMask ))
    {
		wsprintfA(szTraceBuf, "[%s] %s", TraceLevel(dwDbgLevel), lpszFormat);

		va_start(arglist, lpszFormat);
		TraceVprintfExA(sg_dwTraceID, dwDbgLevel | TRACE_USE_MSEC, szTraceBuf, arglist);
		va_end(arglist);
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\installpack\tracelog.h ===
#pragma once

#ifdef __cplusplus
extern "C" {
#endif


#include <windows.h>
#include <winbase.h>
#include <rtutils.h>

#define TL_ERROR ((DWORD)0x00010000 | TRACE_USE_MASK)
#define TL_WARN  ((DWORD)0x00020000 | TRACE_USE_MASK)
#define TL_INFO  ((DWORD)0x00040000 | TRACE_USE_MASK)
//    #define TL_TRACE ((DWORD)0x00080000 | TRACE_USE_MASK)
//    #define TL_EVENT ((DWORD)0x00100000 | TRACE_USE_MASK)

BOOL  TRACELogRegister(LPCTSTR szName);
void  TRACELogDeRegister();
void  TRACELogPrint(IN DWORD dwDbgLevel, IN LPCSTR DbgMessage, IN ...);


#define LOG_ERROR(pszFmt)                    TRACELogPrint(TL_ERROR, pszFmt)
#define LOG_ERROR1(pszFmt, arg1)             TRACELogPrint(TL_ERROR, pszFmt, arg1)
#define LOG_ERROR2(pszFmt, arg1, arg2)       TRACELogPrint(TL_ERROR, pszFmt, arg1, arg2)
#define LOG_ERROR3(pszFmt, arg1, arg2, arg3) TRACELogPrint(TL_ERROR, pszFmt, arg1, arg2, arg3)

#define LOG_WARN(pszFmt)                    TRACELogPrint(TL_WARN, pszFmt)
#define LOG_WARN1(pszFmt, arg1)             TRACELogPrint(TL_WARN, pszFmt, arg1)
#define LOG_WARN2(pszFmt, arg1, arg2)       TRACELogPrint(TL_WARN, pszFmt, arg1, arg2)
#define LOG_WARN3(pszFmt, arg1, arg2, arg3) TRACELogPrint(TL_WARN, pszFmt, arg1, arg2, arg3)

#define LOG_INFO(pszFmt)                    TRACELogPrint(TL_INFO, pszFmt)
#define LOG_INFO1(pszFmt, arg1)             TRACELogPrint(TL_INFO, pszFmt, arg1)
#define LOG_INFO2(pszFmt, arg1, arg2)       TRACELogPrint(TL_INFO, pszFmt, arg1, arg2)
#define LOG_INFO3(pszFmt, arg1, arg2, arg3) TRACELogPrint(TL_INFO, pszFmt, arg1, arg2, arg3)


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbkd\load.c ===
/*
 * File: nlbkd.c
 * Description: This file contains the implementation of the utility functions
 *              to handle load module packet filtering queries.
 *              
 * Author: Created by shouse, 1.11.02
 */

#include "nlbkd.h"
#include "utils.h"
#include "print.h"
#include "packet.h"
#include "load.h"

typedef ULONGLONG MAP_T, * PMAP_T;

#define IS_TCP_PKT(protocol)     (((protocol) == TCPIP_PROTOCOL_TCP) || ((protocol) == TCPIP_PROTOCOL_GRE) || ((protocol) == TCPIP_PROTOCOL_PPTP))
#define IS_SESSION_PKT(protocol) (IS_TCP_PKT(protocol) || ((protocol) == TCPIP_PROTOCOL_IPSEC1))

/*
 * Function: LoadFilter
 * Description: This function retrieves all necessary state from the load module in order to 
 *              determine whether a given packet would be accepted by the load module in its
 *              current state and why or why not.
 * Author: Created by shouse, 1.11.02
 */
void LoadFilter (ULONG64 pLoad, ULONG dwServerIPAddress, ULONG dwServerPort, ULONG dwClientIPAddress, ULONG dwClientPort, USHORT wProtocol, UCHAR cFlags, BOOL bLimitMap, BOOL bReverse) {
    ULONG dwNumConnections;
    ULONGLONG ddwCurrentMap;
    ULONGLONG ddwAllIdleMap;
    BOOL bTCPNotificationOn;
    BOOL bCleanupWaiting;
    BOOL bIsDefault = FALSE;
    BOOL bBinIsDirty;
    ULONG64 pAddr;
    ULONG64 pRule;
    ULONG dwValue;
    ULONG dwHostID;
    ULONG dwAffinity;
    ULONG bin;
    ULONG index;
    ULONG hash;
    
    /* This variable is used for port rule lookup and since the port rules only cover
       UDP and TCP, we categorize as TCP and non-TCP, meaning that any protocol that's 
       not TCP will be treated like UDP for the sake of port rule lookup. */
    BOOL bIsTCPPacket = IS_TCP_PKT(wProtocol);
    
    /* Further, some protocols are treated with "session" semantics, while others are
       not.  For TCP, this "session" is currently a single TCP connection, which is 
       tracked from SYN to FIN using a connection descriptor.  IPSec "sessions" are
       also tracked using descriptors, so even though its treated like UDP for port
       rule lookup, its treated with the session semantics resembling TCP.  Therefore,
       by default the determination of a session packet is initially the same as the
       determination of a TCP packet. */       
    BOOL bIsSessionPacket = IS_SESSION_PKT(wProtocol);

    /* Get the LOAD_CTXT_CODE from the structure to make sure that this address
       indeed points to a valid NLB load block. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_CODE, dwValue);
    
    if (dwValue != LOAD_CTXT_CODE) {
        dprintf("  Error: Invalid NLB load block.  Wrong code found (0x%08x).\n", dwValue);
        return;
    } 

    /* Get my host ID. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_HOST_ID, dwHostID);

    /* Check to see whether or not the load module is currently active. */
    {
        BOOL bActive;

        /* Determine whether or not the load context is active. */
        GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_ACTIVE, bActive);

        /* If the load module has been "turned off", then we drop the packet. */
        if (!bActive) {
            dprintf("Reject:  The load module is currently inactive.\n");
            return;
        }
    }

    /* Lookup the appropriate port rule for this packet. */
    pRule = LoadPortRuleLookup(pLoad, dwServerIPAddress, dwServerPort, bIsTCPPacket, &bIsDefault);

    dprintf("Applicable port rule:\n");

    /* Print the information for the retrieved port rule. */
    PrintPortRuleState(pRule, dwHostID, bIsDefault);

    dprintf("\n");

    /* Filter out traffic for disabled port rules. */
    {
        ULONG dwFilteringMode;

        /* Get the filtering mode for this port rule. */
        GetFieldValue(pRule, BIN_STATE, BIN_STATE_FIELD_MODE, dwFilteringMode);

        /* If the matching port rule is configured as "disabled", which means to drop any
           packets that match the rule, then we drop the packet. */
        if (dwFilteringMode == CVY_NEVER) {
            dprintf("Reject:  The applicable port rule is disabled.\n");
            return;
        }        
    }

    /* Get the filtering mode for this port rule. */
    GetFieldValue(pRule, BIN_STATE, BIN_STATE_FIELD_AFFINITY, dwAffinity);

    /* If the applicable port rule is configured in "No" affinity mode, make sure enough
       information has been specified in the query to faithfully determine packet ownership. */
    if (dwAffinity == CVY_AFFINITY_NONE) {
        /* VPN protocols REQUIRE either "Single" or "Class C" affinity; reject the request. */
        if ((wProtocol == TCPIP_PROTOCOL_GRE) || (wProtocol == TCPIP_PROTOCOL_PPTP) || (wProtocol == TCPIP_PROTOCOL_IPSEC1)) {
            dprintf("Unknown:  The applicable port rule is configured with Affinity=None.\n");
            dprintf("          VPN protocols require Single or Class C affinity.\n");
            return;
        /* Hasing in "No" affinity requires the client port; if it wasn't specified, reject
           the request.  We check for a non-zero server port to special case ICMP filtering,
           which sets BOTH ports to zero legally. */
        } else if ((dwClientPort == 0) && (dwServerPort != 0)) {
            dprintf("Unknown:  The applicable port rule is configured with Affinity=None.\n");
            dprintf("          To properly hash this request, a client port is required.\n");
            return;
        }
    }

    /* Compute a simple and inexpensive hash on all parts of the IP tuple except the protocol. */
    hash = LoadSimpleHash(dwServerIPAddress, dwServerPort, dwClientIPAddress, dwClientPort);

    index = hash % CVY_MAX_CHASH;

    /* Compute the hash. */
    hash = LoadComplexHash(dwServerIPAddress, dwServerPort, dwClientIPAddress, dwClientPort, dwAffinity, bReverse, bLimitMap);

    bin = hash % CVY_MAXBINS;

    dprintf("Map() returned %u; Index = %u, Bucket ID = %u\n", hash, index, bin);

    dprintf("\n");

    /* Get the cleanup waiting flag. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_CLEANUP_WAITING, bCleanupWaiting);

    /* Get the current bucket map for this port rule. */
    GetFieldValue(pRule, BIN_STATE, BIN_STATE_FIELD_CURRENT_MAP, ddwCurrentMap);

    /* Get the current all idle bucket map for this port rule. */
    GetFieldValue(pRule, BIN_STATE, BIN_STATE_FIELD_ALL_IDLE_MAP, ddwAllIdleMap);

    /* Get the offset of the bin connection count array. */
    if (GetFieldOffset(BIN_STATE, BIN_STATE_FIELD_NUM_CONNECTIONS, &dwValue)) {
        dprintf("Can't get offset of %s in %s\n", BIN_STATE_FIELD_NUM_CONNECTIONS, BIN_STATE);
        return;
    } 

    /* Calculate a pointer to the base of the array. */
    pAddr = pRule + dwValue;

    /* Find out the size of a LONG. */
    dwValue = GetTypeSize(LONG_T);

    /* Calculate the location of the appropriate connection count by indexing the array. */
    pAddr += (bin * dwValue);

    /* Retrieve the number of connections on this port rule and bucket. */
    dwNumConnections = GetUlongFromAddress(pAddr);

    /* Get the offset of the dirty bin array. */
    if (GetFieldOffset(LOAD_CTXT, LOAD_CTXT_FIELD_DIRTY_BINS, &dwValue)) {
        dprintf("Can't get offset of %s in %s\n", LOAD_CTXT_FIELD_DIRTY_BINS, LOAD_CTXT);
        return;
    } 

    /* Calculate a pointer to the base of the array. */
    pAddr = pLoad + dwValue;

    /* Find out the size of a ULONG. */
    dwValue = GetTypeSize(ULONG_T);

    /* Calculate the location of the appropriate dirty count by indexing the array. */
    pAddr += (bin * dwValue);

    /* Retrieve the dirty flag for this bin. */
    bBinIsDirty = (GetUlongFromAddress(pAddr) != 0);

    /* Get the address of the global variable containing the notification state. */
    pAddr = GetExpression(UNIV_NOTIFICATION);

    if (!pAddr) {
        ErrorCheckSymbols(UNIV_NOTIFICATION);
        return;
    }

    /* Get the number of adapters from the address. */
    bTCPNotificationOn = (GetUlongFromAddress(pAddr) != 0);

    /* If the packet is a connection control packet (TCP SYN/FIN/RST or IPSec MMSA, etc),
       then we treat it differently than normal connection data.  Mimics Load_conn_advise(). */
    if (bIsSessionPacket && ((cFlags & NLB_FILTER_FLAGS_CONN_UP) || (((cFlags & NLB_FILTER_FLAGS_CONN_DOWN) || (cFlags & NLB_FILTER_FLAGS_CONN_RESET)) && !bTCPNotificationOn))) {
        ULONG64 pDescriptor;
        
        /* If this host does not own the bucket and the packet is not a connection
           down or connection reset for a non-idle bin, then we don't own the packet. */
        if (((ddwCurrentMap & (((MAP_T) 1) << bin)) == 0) && (!(((cFlags & NLB_FILTER_FLAGS_CONN_DOWN) || (cFlags & NLB_FILTER_FLAGS_CONN_RESET)) && (dwNumConnections > 0)))) {
            dprintf("Reject:  This SYN/FIN/RST packet is not owned by this host.\n");            
            return;
        }

        /* At this point, we _might_ own the packet - if its a connection up, then 
           we definately do, because we own the bucket it maps to. */
        if (cFlags & NLB_FILTER_FLAGS_CONN_UP) {
            dprintf("Accept:  This SYN packet is owned by this host.\n");
            return;
        }

        /* Look for a matching connection descriptor. */
        pDescriptor = LoadFindDescriptor(pLoad, index, dwServerIPAddress, dwServerPort, dwClientIPAddress, dwClientPort, wProtocol);

        dprintf("Connection state found:\n");

        if (pDescriptor) {
            /* Print the contents of the retrieved descriptor. */
            PrintConnectionDescriptor(pDescriptor);
        } else {
            /* Otherwise, if we haven't found a matching connection descriptor, 
               then this host certainly does not own this packet. */
            dprintf("None.\n");
            dprintf("\n");
            dprintf("Reject:  This FIN/RST packet is not owned by this host.\n");
            return;
        }

        dprintf("\n");

        /* Check the connection entry code. */
        GetFieldValue(pDescriptor, CONN_ENTRY, CONN_ENTRY_FIELD_CODE, dwValue);
        
        if (dwValue != CVY_ENTRCODE) {
            dprintf("Invalid NLB connection descriptor pointer.\n");
            return;
        }

        /* If the descriptor is dirty, we do NOT take the packet. */
        { 
            USHORT wFlags;
            
            /* Check to see whether the descriptor is dirty. */
            GetFieldValue(pDescriptor, CONN_ENTRY, CONN_ENTRY_FIELD_FLAGS, wFlags);
            
            /* If the connection is dirty, we do not take the packet because TCP may
               have stale information for this descriptor. */
            if (wFlags & NLB_CONN_ENTRY_FLAGS_DIRTY) {
                dprintf("Reject:  This connection has been marked dirty.\n");
                return;
            }
        }

        dprintf("Accept:  Matching connection descriptor found for FIN/RST.\n");
        return;

    } else {
        /* If we currently own the "bucket" to which this connection maps and either NLB provides
           no session support for this protocol, or all other hosts have no exisitng connections
           on this "bucket" and we have no dirty connections, then we can safely take the packet
           with no regard to the connection (session) descriptors. */
        if (((ddwCurrentMap & (((MAP_T) 1) << bin)) != 0) && (!bIsSessionPacket || (((ddwAllIdleMap & (((MAP_T) 1) << bin)) != 0) && (!bCleanupWaiting)))) {
            dprintf("Accept:  This packet is unconditionally owned by this host.\n");
            return;
            
        /* Otherwise, if there are active connections on this "bucket" or if we own the 
           "bucket" and there are dirty connections on it, then we'll walk our descriptor
           lists to determine whether or not we should take the packet or not. */
        } else if ((dwNumConnections > 0) || (bCleanupWaiting && bBinIsDirty && ((ddwCurrentMap & (((MAP_T) 1) << bin)) != 0))) {
            ULONG64 pDescriptor;         

            /* Look for a matching connection descriptor. */
            pDescriptor = LoadFindDescriptor(pLoad, index, dwServerIPAddress, dwServerPort, dwClientIPAddress, dwClientPort, wProtocol);

            dprintf("Connection state found:\n");
            
            if (pDescriptor) {
                /* Print the contents of the retrieved descriptor. */
                PrintConnectionDescriptor(pDescriptor);
            } else {
                /* Otherwise, if we haven't found a matching connection descriptor, 
                   then this host certainly does not own this packet. */
                dprintf("None.\n");
                dprintf("\n");
                dprintf("Reject:  This packet is not owned by this host.\n");
                return;
            }

            dprintf("\n");
            
            /* Check the connection entry code. */
            GetFieldValue(pDescriptor, CONN_ENTRY, CONN_ENTRY_FIELD_CODE, dwValue);
            
            if (dwValue != CVY_ENTRCODE) {
                dprintf("Invalid NLB connection descriptor pointer.\n");
                return;
            }
            
            /* If the descriptor is dirty, we do NOT take the packet. */
            { 
                USHORT wFlags;
                
                /* Check to see whether the descriptor is dirty. */
                GetFieldValue(pDescriptor, CONN_ENTRY, CONN_ENTRY_FIELD_FLAGS, wFlags);
                
                /* If the connection is dirty, we do not take the packet because TCP may
                   have stale information for this descriptor. */
                if (wFlags & NLB_CONN_ENTRY_FLAGS_DIRTY) {
                    dprintf("Reject:  This connection has been marked dirty.\n");
                    return;
                }
            }
            
            dprintf("Accept:  Matching connection descriptor found.\n");
            return;
        }        
    }

    dprintf("Reject:  This packet is not owned by this host.\n");
    return;
}

/*
 * Function: LoadPortRuleLookup
 * Description: This function retrieves the appropriate port rule given the server 
 *              side parameters of the connection.
 * Author: Created by shouse, 1.11.02
 */
ULONG64 LoadPortRuleLookup (ULONG64 pLoad, ULONG dwServerIPAddress, ULONG dwServerPort, BOOL bIsTCP, BOOL * bIsDefault) {
    ULONG64 pParams;
    ULONG64 pRule;
    ULONG64 pPortRules;
    ULONG dwValue;
    ULONG dwNumRules;
    ULONG dwRuleSize;
    ULONG index;

    /* Get the LOAD_CTXT_CODE from the structure to make sure that this address
       indeed points to a valid NLB load block. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_CODE, dwValue);
    
    if (dwValue != LOAD_CTXT_CODE) {
        dprintf("  Error: Invalid NLB load block.  Wrong code found (0x%08x).\n", dwValue);
        return 0;
    } 

    /* Get the pointer to the NLB parameter block. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_PARAMS, pParams);

    /* Get the off set of the port rules in the parameters block. */
    if (GetFieldOffset(CVY_PARAMS, CVY_PARAMS_FIELD_PORT_RULES, &dwValue)) {
        dprintf("Can't get offset of %s in %s\n", CVY_PARAMS_FIELD_PORT_RULES, CVY_PARAMS);
        return 0;
    }

    /* Calculate the pointer to the port rules. */
    pRule = pParams + dwValue;
    
    /* Get the number of port rules. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_NUM_RULES, dwNumRules);

    /* Get the size of a port rule. */
    dwRuleSize = GetTypeSize(CVY_RULE);

    /* Loop through all configured rules looking for the applicable port rule.  If a 
       configured port rule match is not found, the DEFAULT port rule will be returned. */
    for (index = 0; index < dwNumRules; index++) {
        ULONG dwRuleVIP;
        ULONG dwRuleStartPort;
        ULONG dwRuleEndPort;
        ULONG dwRuleProtocol;

        /* Get the VIP for this port rule. */
        GetFieldValue(pRule, CVY_RULE, CVY_RULE_FIELD_VIP, dwRuleVIP);

        /* Get the start port for this port rule range. */
        GetFieldValue(pRule, CVY_RULE, CVY_RULE_FIELD_START_PORT, dwRuleStartPort);

        /* Get the end port for this port rule range. */
        GetFieldValue(pRule, CVY_RULE, CVY_RULE_FIELD_END_PORT, dwRuleEndPort);

        /* Get the protocol for this port rule. */
        GetFieldValue(pRule, CVY_RULE, CVY_RULE_FIELD_PROTOCOL, dwRuleProtocol);

        /* For virtual clusters: If the server IP address matches the VIP for the port rule,
           or if the VIP for the port rule is "ALL VIPs", and if the port lies in the range
           for this rule, and if the protocol matches, this is the rule.  Notice that this
           give priority to rules for specific VIPs over those for "ALL VIPs", which means
           that this code RELIES on the port rules being sorted by VIP/port where the "ALL
           VIP" ports rules are at the end of the port rule list. */
        if (((dwServerIPAddress == dwRuleVIP) || (CVY_ALL_VIP == dwRuleVIP)) &&
            ((dwServerPort >= dwRuleStartPort) && (dwServerPort <= dwRuleEndPort)) &&
            ((bIsTCP && (dwRuleProtocol != CVY_UDP)) || (!bIsTCP && (dwRuleProtocol != CVY_TCP))))
            /* Break out of the loop - this is the rule we want. */
            break;
        else
            /* Otherwise, move to the next rule and check it. */
            pRule += dwRuleSize;
    }
        
    /* Get the pointer to the NLB parameters. */
    if (GetFieldOffset(LOAD_CTXT, LOAD_CTXT_FIELD_PORT_RULE_STATE, &dwValue)) {
        dprintf("Can't get offset of %s in %s\n", LOAD_CTXT_FIELD_PORT_RULE_STATE, LOAD_CTXT);
        return 0;
    }

    /* Calculate the pointer to the port rule state array. */
    pPortRules = pLoad + dwValue;

    /* Get the size of a port rule state block. */
    dwRuleSize = GetTypeSize(BIN_STATE);

    /* Calculate a pointer to the appropriate port rule state block by indexing
       the array using the index found for the matching port rule. */
    pRule = pPortRules + (index * dwRuleSize);

    /* Get the BIN_STATE_CODE from the structure to make sure that this address
       indeed points to a valid NLB port rule state block. */
    GetFieldValue(pRule, BIN_STATE, BIN_STATE_FIELD_CODE, dwValue);
    
    if (dwValue != BIN_STATE_CODE) {
        dprintf("  Error: Invalid NLB port rule state block.  Wrong code found (0x%08x).\n", dwValue);
        return 0;
    } 

    /* Determine whether or not the port rule we found was the default port
       rule, which is always located at the end of the port rule array. */
    if (index == dwNumRules)
        *bIsDefault = TRUE;
    else 
        *bIsDefault = FALSE;

    return pRule;
}

/*
 * Function: LoadFindDescriptor
 * Description: This function searches for and returns any existing descriptor matching 
 *              the given IP tuple; otherwise, it returns NULL (0).
 * Author: Created by shouse, 1.11.02
 */
ULONG64 LoadFindDescriptor (ULONG64 pLoad, ULONG index, ULONG dwServerIPAddress, ULONG dwServerPort, ULONG dwClientIPAddress, ULONG dwClientPort, USHORT wProtocol) {
    ULONG64 pDescriptor;
    ULONG64 pAddr;
    ULONG64 pNext;
    ULONG64 pQueue;
    ULONG dwValue;
    BOOL match = FALSE;

    /* Get the LOAD_CTXT_CODE from the structure to make sure that this address
       indeed points to a valid NLB load block. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_CODE, dwValue);
    
    if (dwValue != LOAD_CTXT_CODE) {
        dprintf("  Error: Invalid NLB load block.  Wrong code found (0x%08x).\n", dwValue);
        return 0;
    } 
    
    /* Get the offset of the hashed connection entry array. */
    if (GetFieldOffset(LOAD_CTXT, LOAD_CTXT_FIELD_HASHED_CONN, &dwValue)) {
        dprintf("Can't get offset of %s in %s\n", LOAD_CTXT_FIELD_HASHED_CONN, LOAD_CTXT);
        return 0;
    } 

    /* Calculate a pointer to the base of the array. */
    pAddr = pLoad + dwValue;

    /* Find out the size of a CONN_ENTRY. */
    dwValue = GetTypeSize(CONN_ENTRY);

    /* Calculate the location of the appropriate connection descriptor by indexing the array. */
    pDescriptor = pAddr + (index * dwValue);
    
    /* Check the connection entry code. */
    GetFieldValue(pDescriptor, CONN_ENTRY, CONN_ENTRY_FIELD_CODE, dwValue);
    
    if (dwValue != CVY_ENTRCODE) {
        dprintf("Invalid NLB connection descriptor pointer.\n");
        return 0;
    }

    /* Get the offset of the connection queue array. */
    if (GetFieldOffset(LOAD_CTXT, LOAD_CTXT_FIELD_CONN_QUEUE, &dwValue)) {
        dprintf("Can't get offset of %s in %s\n", LOAD_CTXT_FIELD_CONN_QUEUE, LOAD_CTXT);
        return 0;
    } 

    /* Calculate a pointer to the base of the array. */
    pAddr = pLoad + dwValue;

    /* Find out the size of a LIST_ENTRY. */
    dwValue = GetTypeSize(LIST_ENTRY);

    /* Calculate the location of the appropriate connection queue by indexing the array. */
    pQueue = pAddr + (index * dwValue);

    if (LoadConnectionMatch(pDescriptor, dwServerIPAddress, dwServerPort, dwClientIPAddress, dwClientPort, wProtocol)) {
        /* Note that we found a match for this tuple. */
        match = TRUE;
    } else {
        ULONG dwEntryOffset;

        /* Get the Next pointer from the list entry. */
        GetFieldValue(pQueue, LIST_ENTRY, LIST_ENTRY_FIELD_NEXT, pNext);   

        /* Get the field offset of the ENTRY, which is a member of the DESCR. */
        if (GetFieldOffset(CONN_DESCR, CONN_DESCR_FIELD_ENTRY, &dwEntryOffset))
            dprintf("Can't get offset of %s in %s\n", CONN_DESCR_FIELD_ENTRY, CONN_DESCR);
        else {                
            /* The first descriptor to check is the ENTRY member of the DESCR. */
            pDescriptor = pNext + dwEntryOffset;

            /* Loop through the connection queue until we find a match, or hit the end of the queue. */
            while ((pNext != pQueue) && !CheckControlC()) {
                /* Check this descriptor for a match. */
                if (LoadConnectionMatch(pDescriptor, dwServerIPAddress, dwServerPort, dwClientIPAddress, dwClientPort, wProtocol)) {
                    /* Note that we found a match for this tuple. */
                    match = TRUE;

                    /* Check the connection entry code. */
                    GetFieldValue(pDescriptor, CONN_ENTRY, CONN_ENTRY_FIELD_CODE, dwValue);
                    
                    if (dwValue != CVY_ENTRCODE) {
                        dprintf("Invalid NLB connection descriptor pointer.\n");
                        return 0;
                    }
                    
                    break;
                }

                /* Get the Next pointer from the list entry. */
                GetFieldValue(pNext, LIST_ENTRY, LIST_ENTRY_FIELD_NEXT, pAddr);
                
                /* Save the next pointer for "end of list" comparison. */
                pNext = pAddr;
                
                /* Find the next descriptor pointer. */
                pDescriptor = pNext + dwEntryOffset;
            }
        }
    }

    /* If we found a match, return it, otherwise return NULL. */
    if (match)
        return pDescriptor;
    else 
        return 0;
}

/*
 * Function: LoadConnectionMatch
 * Description: This function determines whether a given IP tuple matches a 
 *              given connection descriptor.
 * Author: Created by shouse, 1.11.02
 */
BOOL LoadConnectionMatch (ULONG64 pDescriptor, ULONG dwServerIPAddress, ULONG dwServerPort, ULONG dwClientIPAddress, ULONG dwClientPort, USHORT wProtocol) {
    ULONG dwValue;
    USHORT wValue;
    BOOL bValue;
    
    /* Check the connection entry code. */
    GetFieldValue(pDescriptor, CONN_ENTRY, CONN_ENTRY_FIELD_CODE, dwValue);
    
    if (dwValue != CVY_ENTRCODE) {
        dprintf("Invalid NLB connection descriptor pointer.\n");
        return FALSE;
    }

    /* Get the "used" flag from the descriptor. */
    GetFieldValue(pDescriptor, CONN_ENTRY, CONN_ENTRY_FIELD_FLAGS, wValue);
    
    /* If the descriptor is unused, return FALSE. */
    if (!(wValue & NLB_CONN_ENTRY_FLAGS_USED)) return FALSE;

    /* Get the client IP address from the descriptor. */
    GetFieldValue(pDescriptor, CONN_ENTRY, CONN_ENTRY_FIELD_CLIENT_IP_ADDRESS, dwValue);
    
    /* If the client IP addresses do not match, return FALSE. */
    if (dwClientIPAddress != dwValue) return FALSE;

    /* Get the client port from the descriptor. */
    GetFieldValue(pDescriptor, CONN_ENTRY, CONN_ENTRY_FIELD_CLIENT_PORT, wValue);
    
    /* If the client ports do not match, return FALSE. */
    if (dwClientPort != (ULONG)wValue) return FALSE;

    /* Get the server IP address from the descriptor. */
    GetFieldValue(pDescriptor, CONN_ENTRY, CONN_ENTRY_FIELD_SERVER_IP_ADDRESS, dwValue);
    
    /* If the server IP addresses do not match, return FALSE. */
    if (dwServerIPAddress != dwValue) return FALSE;

    /* Get the server port from the descriptor. */
    GetFieldValue(pDescriptor, CONN_ENTRY, CONN_ENTRY_FIELD_SERVER_PORT, wValue);
    
    /* If the server ports do not match, return FALSE. */
    if (dwServerPort != (ULONG)wValue) return FALSE;

    /* Get the protocol from the descriptor. */
    GetFieldValue(pDescriptor, CONN_ENTRY, CONN_ENTRY_FIELD_PROTOCOL, wValue);
    
    /* If the protocols do not match, return FALSE. */
    if (wProtocol != wValue) return FALSE;

    /* Otherwise, if all parameters match, return TRUE. */
    return TRUE;
}

/*
 * Function: AcquireLoad
 * Description: This function determines whether or not a given NLB instance is configured for 
 *              BDA teaming and returns the load module pointer that should be used. 
 * Author: Created by shouse, 1.11.02
 */
BOOL AcquireLoad (ULONG64 pContext, PULONG64 ppLoad, BOOL * pbRefused) {
    ULONG dwValue;
    ULONG64 pAddr;
    ULONG64 pTeam;
    ULONG64 pMember;

    /* By default, assume we're not refusing the packet. */
    *pbRefused = FALSE;

    /* Get the offset of the BDA teaming information for this context. */
    if (GetFieldOffset(MAIN_CTXT, MAIN_CTXT_FIELD_BDA_TEAMING, &dwValue))
        dprintf("Can't get offset of %s in %s\n", MAIN_CTXT_FIELD_BDA_TEAMING, MAIN_CTXT);
    else {
        pMember = pContext + dwValue;

        /* Get the team-assigned member ID. */
        GetFieldValue(pMember, BDA_MEMBER, BDA_MEMBER_FIELD_OPERATION, dwValue);
        
        switch (dwValue) {
        case BDA_TEAMING_OPERATION_CREATING:
            dprintf("Note:  A operation is currently underway to join this NLB instance to a BDA team.\n");
            break;
        case BDA_TEAMING_OPERATION_DELETING:
            dprintf("Note:  A operation is currently underway to remove this NLB instance from a BDA team.\n");
            break;
        }

        /* Find out whether or not teaming is active on this adapter. */
        GetFieldValue(pMember, BDA_MEMBER, BDA_MEMBER_FIELD_ACTIVE, dwValue);        

        /* If BDA teaming is active on this instance of NLB, fill in the load
           context, teaming flag and reverse-hashing flag. */
        if (dwValue) {
            /* Get the pointer to the BDA team. */
            GetFieldValue(pMember, BDA_MEMBER, BDA_MEMBER_FIELD_TEAM, pTeam);

            /* Find out whether or not the team is active. */
            GetFieldValue(pTeam, BDA_TEAM, BDA_TEAM_FIELD_ACTIVE, dwValue);

            /* If the team has been marked invalid, refuse the packet. */
            if (!dwValue) {
                *pbRefused = TRUE;
                return FALSE;
            }

            /* Get the pointer to the master's load module. */
            GetFieldValue(pTeam, BDA_TEAM, BDA_TEAM_FIELD_LOAD, pAddr);

            /* Set the load module pointer to the master's load module. */
            *ppLoad = pAddr;

            /* Indicate that teaming is indeed active. */
            return TRUE;
        }
    }

    /* Teaming is inactive. */
    return FALSE;
}

/*
 * Function: LoadSimpleHash
 * Description: This function is a simple hash based on the IP 4-tuple used to locate 
 *              state for the connection.  That is, this hash is used to determine the
 *              queue index in which this connection should store, and can later find, 
 *              its state.
 * Author: Created by shouse, 8.26.02
 */
ULONG LoadSimpleHash (ULONG dwServerIPAddress, ULONG dwServerPort, ULONG dwClientIPAddress, ULONG dwClientPort) {

    return (ULONG)(dwServerIPAddress + dwClientIPAddress + (dwServerPort << 16) + (dwClientPort << 0));
}

/*
 * Function: LoadComplexHash
 * Description: This is the conventional NLB hashing algorithm, which ends up invoking a 
 *              light-weight encryption algorithm to calculate a hash that is ultimately
 *              used to map this connection to a bin, or "bucket".  If reverse hashing
 *              is set, then server side parameters are used instead of client side.  If
 *              limiting is set, then client and server side paramters should NOT be mixed
 *              when hashing; i.e. use ONLY server OR client, depending on reverse hashing.
 * Author: Created by shouse, 8.26.02
 */
ULONG LoadComplexHash (ULONG dwServerIPAddress, ULONG dwServerPort, ULONG dwClientIPAddress, ULONG dwClientPort, ULONG dwAffinity, BOOL bReverse, BOOL bLimitMap)
{
    /* If we're not reverse-hashing, this is our conventional hash using primarily
       the client information.  If the map limit flag is set, then we are sure NOT
       to use ANY server-side information in the hash.  This is most common in BDA. */
    if (!bReverse)
    {
        if (!bLimitMap) 
        {
            if (dwAffinity == CVY_AFFINITY_NONE)
                return Map(dwClientIPAddress, ((dwServerPort << 16) + dwClientPort));
            else if (dwAffinity == CVY_AFFINITY_SINGLE)
                return Map(dwClientIPAddress, dwServerIPAddress);
            else
                return Map(dwClientIPAddress & TCPIP_CLASSC_MASK, dwServerIPAddress);
        } 
        else 
        {
            if (dwAffinity == CVY_AFFINITY_NONE)
                return Map(dwClientIPAddress, dwClientPort);
            else if (dwAffinity == CVY_AFFINITY_SINGLE)
                return Map(dwClientIPAddress, MAP_FN_PARAMETER);
            else
                return Map(dwClientIPAddress & TCPIP_CLASSC_MASK, MAP_FN_PARAMETER);
        }
    }
    /* Otherwise, reverse the client and server information as we hash.  Again, if 
       the map limit flag is set, use NO client-side information in the hash. */
    else
    {
        if (!bLimitMap) 
        {
            if (dwAffinity == CVY_AFFINITY_NONE)
                return Map(dwServerIPAddress, ((dwClientPort << 16) + dwServerPort));
            else if (dwAffinity == CVY_AFFINITY_SINGLE)
                return Map(dwServerIPAddress, dwClientIPAddress);
            else
                return Map(dwServerIPAddress & TCPIP_CLASSC_MASK, dwClientIPAddress);
        } 
        else 
        {
            if (dwAffinity == CVY_AFFINITY_NONE)
                return Map(dwServerIPAddress, dwServerPort);
            else if (dwAffinity == CVY_AFFINITY_SINGLE)
                return Map(dwServerIPAddress, MAP_FN_PARAMETER);
            else
                return Map(dwServerIPAddress & TCPIP_CLASSC_MASK, MAP_FN_PARAMETER);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\installpack\uninstall.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       M A I N . C P P
//
//  Contents:   Code to provide a simple cmdline interface to
//              the sample code functions
//
//  Notes:      The code in this file is not required to access any
//              netcfg functionality. It merely provides a simple cmdline
//              interface to the sample code functions provided in
//              file snetcfg.cpp.
//
//  Author:     kumarp    28-September-98
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "snetcfg.h"
#include <wbemcli.h>
#include <winnls.h>
#include "tracelog.h"

BOOL g_fVerbose=FALSE;

BOOL WlbsCheckSystemVersion ();
BOOL WlbsCheckFiles ();
HRESULT WlbsRegisterDlls ();
HRESULT WlbsCompileMof ();

// ----------------------------------------------------------------------
//
// Function:  wmain
//
// Purpose:   This is the main function for NLBUninst, which is for removing
//            W2K installations of NLB. Making this application compatible
//            with post-W2K releases may require changes, e.g., in
//            function WlbsCheckSystemVersion.
//
// Arguments: standard main args
//
// Returns:   0 on success, non-zero otherwise
//
// Author:    kumarp 25-December-97
//
// Notes:
//
EXTERN_C int __cdecl wmain (int argc, WCHAR * argv[]) {
    HRESULT hr=S_FALSE;
    WCHAR szFileFullPath[MAX_PATH+1];
    WCHAR szFileFullPathDest[MAX_PATH+1];

    if (!WlbsCheckSystemVersion()) {
    LOG_ERROR("The NLB install pack can only be used on Windows 2000 Server Service Pack 1 or higher.");
    return S_OK;
    }

    /* Check to see if the service is already installed. */
    hr = FindIfComponentInstalled(_TEXT("ms_wlbs"));

    if (hr == S_OK) {
    LOG_INFO("Network Load Balancing Service is installed.  Proceeding with uninstall...");
    } else {
    LOG_ERROR("Network Load Balancing Service is not installed.");
        return S_OK;
    }

    /* Now uninstall the service. */
    hr = HrUninstallNetComponent(L"ms_wlbs");

    if (!SUCCEEDED(hr))
    LOG_ERROR("Error uninstalling Network Load Balancing.");
    else
    LOG_INFO("Uninstallation of Network Load Balancing succeeded.");

    /* Remove the .inf and the .pnf files. */
    if (GetWindowsDirectory(szFileFullPathDest, MAX_PATH + 1) == 0)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }
    wcscat(szFileFullPathDest, L"\\INF\\netwlbs.inf");
    DeleteFile(szFileFullPathDest);

    if (GetWindowsDirectory(szFileFullPathDest, MAX_PATH + 1) == 0)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }
    wcscat(szFileFullPathDest, L"\\INF\\netwlbs.pnf");
    DeleteFile(szFileFullPathDest);

    return hr;
}

/* This checks whether the system on which NLB is being installed is a W2K Server or not. */
BOOL WlbsCheckSystemVersion () {
    OSVERSIONINFOEX osinfo;

    osinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

    if (!GetVersionEx((LPOSVERSIONINFO)&osinfo)) return FALSE;

    /* For uninstalls, we return TRUE only if its Windows 2000 Server. */
    if ((osinfo.dwMajorVersion == 5) && 
        (osinfo.dwMinorVersion == 0) && 
        (osinfo.wProductType == VER_NT_SERVER) && 
        !(osinfo.wSuiteMask & VER_SUITE_ENTERPRISE) &&
        !(osinfo.wSuiteMask & VER_SUITE_DATACENTER))
        return TRUE;

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbkd\nlbkd.h ===
/*
 * File: nlbkd.h
 * Description: This file contains definitions and function prototypes
 *              for the NLB KD extensions, nlbkd.dll.
 * History: Created by shouse, 1.4.01
 */

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntverp.h>
#include <windef.h>
#include <winbase.h>
#include <ntosp.h>
#include <wdmguid.h>
#include <wmistr.h>
#include <winsock2.h>
#include <wdbgexts.h>
#include <stdlib.h>
#include <ndis.h>

extern USHORT SavedMajorVersion;
extern USHORT SavedMinorVersion;
extern BOOL ChkTarget;

/* Define the different types of TCP packets. */
typedef enum _TCP_PACKET_TYPE {
    SYN = 0,
    DATA,
    FIN,
    RST
} TCP_PACKET_TYPE;

/* Define the levels of verbosity. */
#define VERBOSITY_LOW                             0
#define VERBOSITY_MEDIUM                          1
#define VERBOSITY_HIGH                            2

/* Define the packet directions. */
#define DIRECTION_RECEIVE                         0
#define DIRECTION_SEND                            1

/* Define the IDs for usage informations. */
#define USAGE_ADAPTERS                            0
#define USAGE_ADAPTER                             1
#define USAGE_CONTEXT                             2
#define USAGE_LOAD                                3
#define USAGE_PARAMS                              4
#define USAGE_RESP                                5
#define USAGE_PKT                                 6
#define USAGE_ETHER                               7
#define USAGE_IP                                  8
#define USAGE_TEAMS                               9
#define USAGE_HOOKS                               10
#define USAGE_MAC                                 11
#define USAGE_DSCR                                12
#define USAGE_CONNQ                               13
#define USAGE_HASH                                14
#define USAGE_FILTER                              15
#define USAGE_GLOBALQ                             16

/* Copy some common NLB defines from various sources. */
#define CVY_MAX_ADAPTERS                          16
#define CVY_MAX_HOSTS                             32
#define CVY_MAX_RULES                             33
#define CVY_MAX_BINS                              60
#define CVY_MAX_VIRTUAL_NIC                       256
#define CVY_MAX_CL_IP_ADDR                        17
#define CVY_MAX_CL_NET_MASK                       17
#define CVY_MAX_DED_IP_ADDR                       17
#define CVY_MAX_DED_NET_MASK                      17
#define CVY_MAX_CL_IGMP_ADDR                      17
#define CVY_MAX_NETWORK_ADDR                      17
#define CVY_MAX_DOMAIN_NAME                       100
#define CVY_MAX_BDA_TEAM_ID                       40
#define CVY_MAX_HOST_NAME                         100
#define CVY_BDA_INVALID_MEMBER_ID                 CVY_MAX_ADAPTERS
#define CVY_MAX_PORT                              65535
#define CVY_TCP                                   1
#define CVY_UDP                                   2
#define CVY_TCP_UDP                               3
#define CVY_SINGLE                                1
#define CVY_MULTI                                 2
#define CVY_NEVER                                 3
#define CVY_AFFINITY_NONE                         0
#define CVY_AFFINITY_SINGLE                       1
#define CVY_AFFINITY_CLASSC                       2
#define HST_NORMAL                                1
#define HST_STABLE                                2
#define HST_CVG                                   3
#define MAIN_PACKET_TYPE_NONE                     0
#define MAIN_PACKET_TYPE_PING                     1
#define MAIN_PACKET_TYPE_INDICATE                 2
#define MAIN_PACKET_TYPE_PASS                     3
#define MAIN_PACKET_TYPE_CTRL                     4
#define MAIN_PACKET_TYPE_TRANSFER                 6
#define MAIN_PACKET_TYPE_IGMP                     7
#define MAIN_FRAME_UNKNOWN                        0
#define MAIN_FRAME_DIRECTED                       1
#define MAIN_FRAME_MULTICAST                      2
#define MAIN_FRAME_BROADCAST                      3
#define CVY_ALL_VIP                               0xffffffff
#define CVY_HOST_STATE_STOPPED                    0
#define CVY_HOST_STATE_STARTED                    1
#define CVY_HOST_STATE_SUSPENDED                  2
#define CVY_PERSIST_STATE_STOPPED                 0x00000001
#define CVY_PERSIST_STATE_STARTED                 0x00000002
#define CVY_PERSIST_STATE_SUSPENDED               0x00000004
#define ETH_LENGTH_OF_ADDRESS                     6
#define NLB_FILTER_FLAGS_CONN_DATA                0x0
#define NLB_FILTER_FLAGS_CONN_UP                  0x1
#define NLB_FILTER_FLAGS_CONN_DOWN                0x2
#define NLB_FILTER_FLAGS_CONN_RESET               0x4
#define TCPIP_CLASSC_MASK                         0x00ffffff
#define TCPIP_BCAST_ADDR                          0xffffffff
#define TCP_FLAG_URG                              0x20
#define TCP_FLAG_ACK                              0x10
#define TCP_FLAG_PSH                              0x8
#define TCP_FLAG_RST                              0x4
#define TCP_FLAG_SYN                              0x2
#define TCP_FLAG_FIN                              0x1
#define CVY_MAXBINS                               60
#define CVY_MAX_CHASH                             4096
#define PPTP_CTRL_PORT                            1723
#define IPSEC_NAT_PORT                            4500
#define IPSEC_CTRL_PORT                           500
#define NLB_CONN_ENTRY_FLAGS_USED                 0x00000001
#define NLB_CONN_ENTRY_FLAGS_DIRTY                0x00000002
#define NLB_CONN_ENTRY_FLAGS_ALLOCATED            0x00000004
#define NLB_CONN_ENTRY_FLAGS_VIRTUAL              0x00000008
#define MAX_ITEMS                                 CVY_MAX_HOSTS
#define NULL_VALUE                                0

/* This is the hardcoded second paramter to Map() when map function limiting is needed. */
#define MAP_FN_PARAMETER 0x00000000

/* Copy the code check IDs from various sources. */
#define MAIN_ADAPTER_CODE                         0xc0deadbe
#define MAIN_CTXT_CODE                            0xc0dedead
#define LOAD_CTXT_CODE                            0xc0deba1c
#define BIN_STATE_CODE                            0xc0debabc
#define CVY_ENTRCODE                              0xc0debaa5
#define CVY_DESCCODE                              0xc0deba5a
#define CVY_PENDINGCODE                           0xc0deba55

/* Other miscellaneous types we might need. */
#define LONG_T                                    "LONG"
#define ULONG_T                                   "ULONG"
#define BOOLEAN_T                                 "BOOLEAN"
#define BOOL_T                                    "BOOLEAN"

/* Unicode string definition. */
#define UNICODE_STRING                            "UNICODE_STRING"
#define UNICODE_STRING_FIELD_LENGTH               "Length"
#define UNICODE_STRING_FIELD_MAX_LENGTH           "MaximumLength"
#define UNICODE_STRING_FIELD_BUFFER               "Buffer"

/* List entry definition. */
#define LIST_ENTRY                                "_LIST_ENTRY"
#define LIST_ENTRY_FIELD_NEXT                     "Flink"
#define LIST_ENTRY_FIELD_PREVIOUS                 "Blink"

/* Some NDIS defines and global variables we need. */
#define NDIS_PACKET_STACK_SIZE                    "ndis!ndisPacketStackSize"
#define STACK_INDEX                               "ndis!STACK_INDEX"
#define NDIS_PACKET_STACK                         "ndis!NDIS_PACKET_STACK"
#define NDIS_PACKET_STACK_FIELD_IMRESERVED        "IMReserved"
#define NDIS_PACKET_WRAPPER                       "ndis!NDIS_PACKET_WRAPPER"
#define NDIS_PACKET_WRAPPER_FIELD_STACK_INDEX     "StackIndex.Index"
#define NDIS_PACKET                               "ndis!NDIS_PACKET"
#define NDIS_PACKET_FIELD_MPRESERVED              "MiniportReserved"
#define NDIS_PACKET_FIELD_PROTRESERVED            "ProtocolReserved" 
#define NDIS_BUFFER                               "ndis!_MDL"
#define NDIS_OPEN_BLOCK                           "ndis!NDIS_OPEN_BLOCK"
#define NDIS_OPEN_BLOCK_FIELD_MINIPORT_HANDLE     "MiniportHandle"
#define NDIS_MINIPORT_BLOCK                       "ndis!NDIS_MINIPORT_BLOCK"
#define NDIS_MINIPORT_BLOCK_FIELD_ADAPTER_NAME    "pAdapterInstanceName"
#define NDIS_MINIPORT_BLOCK_FIELD_ETHDB           "EthDB"
#define _X_FILTER                                 "_X_FILTER"
#define _X_FILTER_FIELD_ADAPTER_ADDRESS           "AdapterAddress"
#define _X_FILTER_FIELD_NUM_ADDRESSES             "NumAddresses"
#define _X_FILTER_FIELD_MCAST_ADDRESS_BUF         "MCastAddressBuf"

/* Global NLB variables that we're accessing. */
#define UNIV_ADAPTERS_COUNT                       "wlbs!univ_adapters_count"
#define UNIV_ADAPTERS                             "wlbs!univ_adapters"
#define UNIV_BDA_TEAMS                            "wlbs!univ_bda_teaming_list"
#define UNIV_HOOKS                                "wlbs!univ_hooks"
#define UNIV_NOTIFICATION                         "wlbs!univ_notification"
#define CONN_ESTABQ                               "wlbs!g_conn_estabq"
#define CONN_PENDINGQ                             "wlbs!g_conn_pendingq"
#define PENDING_CONN_POOL                         "wlbs!g_pending_conn_pool"

/* Members of global NLB connection queues. */
#define GLOBAL_CONN_QUEUE                         "wlbs!GLOBAL_CONN_QUEUE"
#define GLOBAL_CONN_QUEUE_FIELD_LENGTH            "length"
#define GLOBAL_CONN_QUEUE_FIELD_QUEUE             "queue"

/* Member of the DIPLIST structure. */
#define DIPLIST                                   "wlbs!DIPLIST"
#define DIPLIST_FIELD_ITEMS                       "Items"
#define DIPLIST_FIELD_NUM_CHECKS                  "stats.NumChecks"
#define DIPLIST_FIELD_NUM_FAST_CHECKS             "stats.NumFastChecks"
#define DIPLIST_FIELD_NUM_ARRAY_LOOKUPS           "stats.NumArrayLookups"

/* Members of MAIN_FRAME_HDR. */
#define MAIN_FRAME_HDR                            "wlbs!MAIN_FRAME_HDR"
#define MAIN_FRAME_HDR_FIELD_CODE                 "code"
#define MAIN_FRAME_HDR_FIELD_VERSION              "version"
#define MAIN_FRAME_HDR_FIELD_HOST                 "host"
#define MAIN_FRAME_HDR_FIELD_CLIP                 "cl_ip_addr"
#define MAIN_FRAME_HDR_FIELD_DIP                  "ded_ip_addr"

/* Members of MAIN_PROTOCOL_RESERVED. */
#define MAIN_PROTOCOL_RESERVED                    "wlbs!MAIN_PROTOCOL_RESERVED"
#define MAIN_PROTOCOL_RESERVED_FIELD_MISCP        "miscp"
#define MAIN_PROTOCOL_RESERVED_FIELD_TYPE         "type"
#define MAIN_PROTOCOL_RESERVED_FIELD_GROUP        "group"
#define MAIN_PROTOCOL_RESERVED_FIELD_DATA         "data"
#define MAIN_PROTOCOL_RESERVED_FIELD_LENGTH       "len"

/* Members of CONN_DESCR. */
#define CONN_DESCR                                "wlbs!CONN_DESCR"
#define CONN_DESCR_FIELD_CODE                     "code"
#define CONN_DESCR_FIELD_ENTRY                    "entry"

/* Members of CONN_ENTRY. */
#define CONN_ENTRY                                "wlbs!CONN_ENTRY"
#define CONN_ENTRY_FIELD_CODE                     "code"
#define CONN_ENTRY_FIELD_CLIENT_IP_ADDRESS        "client_ipaddr"
#define CONN_ENTRY_FIELD_SERVER_IP_ADDRESS        "svr_ipaddr"
#define CONN_ENTRY_FIELD_CLIENT_PORT              "client_port"
#define CONN_ENTRY_FIELD_SERVER_PORT              "svr_port"
#define CONN_ENTRY_FIELD_PROTOCOL                 "protocol"
#define CONN_ENTRY_FIELD_FLAGS                    "flags"
#define CONN_ENTRY_FIELD_LOAD                     "load"
#define CONN_ENTRY_FIELD_INDEX                    "index"
#define CONN_ENTRY_FIELD_BIN                      "bin"
#define CONN_ENTRY_FIELD_REF_COUNT                "ref_count"
#define CONN_ENTRY_FIELD_TIMEOUT                  "timeout"

/* Members of PENDING_ENTRY. */
#define PENDING_ENTRY                             "wlbs!CONN_ENTRY"
#define PENDING_ENTRY_FIELD_CODE                  "code"
#define PENDING_ENTRY_FIELD_CLIENT_IP_ADDRESS     "client_ipaddr"
#define PENDING_ENTRY_FIELD_SERVER_IP_ADDRESS     "svr_ipaddr"
#define PENDING_ENTRY_FIELD_CLIENT_PORT           "client_port"
#define PENDING_ENTRY_FIELD_SERVER_PORT           "svr_port"
#define PENDING_ENTRY_FIELD_PROTOCOL              "protocol"

/* The current if_index operation in progress. */
enum _IF_INDEX_OPERATION {
    IF_INDEX_OPERATION_NONE = 0,
    IF_INDEX_OPERATION_UPDATE
};

/* Members of MAIN_ADAPTER. */
#define MAIN_ADAPTER                              "wlbs!MAIN_ADAPTER"
#define MAIN_ADAPTER_FIELD_CODE                   "code"
#define MAIN_ADAPTER_FIELD_USED                   "used"
#define MAIN_ADAPTER_FIELD_INITED                 "inited"
#define MAIN_ADAPTER_FIELD_BOUND                  "bound"
#define MAIN_ADAPTER_FIELD_ANNOUNCED              "announced"
#define MAIN_ADAPTER_FIELD_CONTEXT                "ctxtp"
#define MAIN_ADAPTER_FIELD_IF_INDEX               "if_index"
#define MAIN_ADAPTER_FIELD_IF_INDEX_OPERATION     "if_index_operation"
#define MAIN_ADAPTER_FIELD_NAME_LENGTH            "device_name_len"
#define MAIN_ADAPTER_FIELD_NAME                   "device_name"

/* Members of MAIN_CTXT. */
#define MAIN_CTXT                                 "wlbs!MAIN_CTXT"
#define MAIN_CTXT_FIELD_CODE                      "code"
#define MAIN_CTXT_FIELD_ADAPTER_ID                "adapter_id"
#define MAIN_CTXT_FIELD_VIRTUAL_NIC               "virtual_nic_name"
#define MAIN_CTXT_FIELD_CL_IP_ADDR                "cl_ip_addr"
#define MAIN_CTXT_FIELD_CL_NET_MASK               "cl_net_mask"
#define MAIN_CTXT_FIELD_CL_BROADCAST              "cl_bcast_addr"
#define MAIN_CTXT_FIELD_CL_MAC_ADDR               "cl_mac_addr"
#define MAIN_CTXT_FIELD_DED_IP_ADDR               "ded_ip_addr"
#define MAIN_CTXT_FIELD_DED_NET_MASK              "ded_net_mask"
#define MAIN_CTXT_FIELD_DED_BROADCAST             "ded_bcast_addr"
#define MAIN_CTXT_FIELD_DED_MAC_ADDR              "ded_mac_addr"
#define MAIN_CTXT_FIELD_IGMP_MCAST_IP             "cl_igmp_addr"
#define MAIN_CTXT_FIELD_MEDIUM                    "medium"
#define MAIN_CTXT_FIELD_MEDIA_CONNECT             "media_connected"
#define MAIN_CTXT_FIELD_MAC_OPTIONS               "mac_options"
#define MAIN_CTXT_FIELD_FRAME_SIZE                "max_frame_size"
#define MAIN_CTXT_FIELD_MCAST_LIST_SIZE           "max_mcast_list_size"
#define MAIN_CTXT_FIELD_PARAMS                    "params"
#define MAIN_CTXT_FIELD_PARAMS_VALID              "params_valid"
#define MAIN_CTXT_FIELD_LOAD                      "load"
#define MAIN_CTXT_FIELD_ENABLED                   "convoy_enabled"
#define MAIN_CTXT_FIELD_DRAINING                  "draining"
#define MAIN_CTXT_FIELD_SUSPENDED                 "suspended"
#define MAIN_CTXT_FIELD_STOPPING                  "stopping"
#define MAIN_CTXT_FIELD_EXHAUSTED                 "packets_exhausted"
#define MAIN_CTXT_FIELD_PING_TIMEOUT              "curr_tout"
#define MAIN_CTXT_FIELD_IGMP_TIMEOUT              "igmp_sent"
#define MAIN_CTXT_FIELD_DSCR_PURGE_TIMEOUT        "conn_purge"
#define MAIN_CTXT_FIELD_NUM_DSCRS_PURGED          "num_purged"
#define MAIN_CTXT_FIELD_BIND_HANDLE               "bind_handle"
#define MAIN_CTXT_FIELD_UNBIND_HANDLE             "unbind_handle"
#define MAIN_CTXT_FIELD_MAC_HANDLE                "mac_handle"
#define MAIN_CTXT_FIELD_PROT_HANDLE               "prot_handle"
#define MAIN_CTXT_FIELD_CNTR_RECV_NO_BUF          "cntr_recv_no_buf"
#define MAIN_CTXT_FIELD_CNTR_XMIT_OK              "cntr_xmit_ok"
#define MAIN_CTXT_FIELD_CNTR_RECV_OK              "cntr_recv_ok"
#define MAIN_CTXT_FIELD_CNTR_XMIT_ERROR           "cntr_xmit_err"
#define MAIN_CTXT_FIELD_CNTR_RECV_ERROR           "cntr_recv_err"
#define MAIN_CTXT_FIELD_CNTR_XMIT_FRAMES_DIR      "cntr_xmit_frames_dir"
#define MAIN_CTXT_FIELD_CNTR_XMIT_BYTES_DIR       "cntr_xmit_bytes_dir"
#define MAIN_CTXT_FIELD_CNTR_XMIT_FRAMES_MCAST    "cntr_xmit_frames_mcast"
#define MAIN_CTXT_FIELD_CNTR_XMIT_BYTES_MCAST     "cntr_xmit_bytes_mcast"
#define MAIN_CTXT_FIELD_CNTR_XMIT_FRAMES_BCAST    "cntr_xmit_frames_bcast"
#define MAIN_CTXT_FIELD_CNTR_XMIT_BYTES_BCAST     "cntr_xmit_bytes_bcast"
#define MAIN_CTXT_FIELD_CNTR_XMIT_TCP_RESETS      "cntr_xmit_tcp_resets"
#define MAIN_CTXT_FIELD_CNTR_RECV_FRAMES_DIR      "cntr_recv_frames_dir"
#define MAIN_CTXT_FIELD_CNTR_RECV_BYTES_DIR       "cntr_recv_bytes_dir"
#define MAIN_CTXT_FIELD_CNTR_RECV_FRAMES_MCAST    "cntr_recv_frames_mcast"
#define MAIN_CTXT_FIELD_CNTR_RECV_BYTES_MCAST     "cntr_recv_bytes_mcast"
#define MAIN_CTXT_FIELD_CNTR_RECV_FRAMES_BCAST    "cntr_recv_frames_bcast"
#define MAIN_CTXT_FIELD_CNTR_RECV_BYTES_BCAST     "cntr_recv_bytes_bcast"
#define MAIN_CTXT_FIELD_CNTR_RECV_TCP_RESETS      "cntr_recv_tcp_resets"
#define MAIN_CTXT_FIELD_SEND_POOLS_ALLOCATED      "num_send_packet_allocs"
#define MAIN_CTXT_FIELD_SEND_PACKETS_ALLOCATED    "num_sends_alloced"
#define MAIN_CTXT_FIELD_SEND_POOL_CURRENT         "cur_send_packet_pool"
#define MAIN_CTXT_FIELD_SEND_OUTSTANDING          "num_sends_out"
#define MAIN_CTXT_FIELD_RECV_POOLS_ALLOCATED      "num_recv_packet_allocs"
#define MAIN_CTXT_FIELD_RECV_PACKETS_ALLOCATED    "num_recvs_alloced"
#define MAIN_CTXT_FIELD_RECV_POOL_CURRENT         "cur_recv_packet_pool"
#define MAIN_CTXT_FIELD_RECV_OUTSTANDING          "num_recvs_out"
#define MAIN_CTXT_FIELD_BUF_POOLS_ALLOCATED       "num_buf_allocs"
#define MAIN_CTXT_FIELD_BUFS_ALLOCATED            "num_bufs_alloced"
#define MAIN_CTXT_FIELD_BUFS_OUTSTANDING          "num_bufs_out"
#define MAIN_CTXT_FIELD_CNTR_PING_NO_BUF          "cntr_frame_no_buf"
#define MAIN_CTXT_FIELD_PING_PACKETS_ALLOCATED    "num_send_msgs"
#define MAIN_CTXT_FIELD_PING_OUTSTANDING          "num_frames_out"
#define MAIN_CTXT_FIELD_BDA_TEAMING               "bda_teaming"
#define MAIN_CTXT_FIELD_DIP_LIST                  "dip_list"
#define MAIN_CTXT_FIELD_REVERSE_HASH              "reverse_hash"

/* The current BDA teaming configuration operation in progress. */
enum _BDA_TEAMING_OPERATION {
    BDA_TEAMING_OPERATION_NONE = 0,
    BDA_TEAMING_OPERATION_CREATING,
    BDA_TEAMING_OPERATION_DELETING
};

/* BDA participant members. */
#define BDA_MEMBER                                "wlbs!_BDA_MEMBER"
#define BDA_MEMBER_FIELD_OPERATION                "operation"
#define BDA_MEMBER_FIELD_ACTIVE                   "active"
#define BDA_MEMBER_FIELD_MEMBER_ID                "member_id"
#define BDA_MEMBER_FIELD_MASTER                   "master"
#define BDA_MEMBER_FIELD_REVERSE_HASH             "reverse_hash"
#define BDA_MEMBER_FIELD_TEAM                     "bda_team"

/* BDA team members. */
#define BDA_TEAM                                  "wlbs!_BDA_TEAM"
#define BDA_TEAM_FIELD_ACTIVE                     "active"
#define BDA_TEAM_FIELD_PREV                       "prev"
#define BDA_TEAM_FIELD_NEXT                       "next"
#define BDA_TEAM_FIELD_LOAD                       "load"
#define BDA_TEAM_FIELD_LOAD_LOCK                  "load_lock"
#define BDA_TEAM_FIELD_MEMBERSHIP_COUNT           "membership_count"
#define BDA_TEAM_FIELD_MEMBERSHIP_FINGERPRINT     "membership_fingerprint"
#define BDA_TEAM_FIELD_MEMBERSHIP_MAP             "membership_map"
#define BDA_TEAM_FIELD_CONSISTENCY_MAP            "consistency_map"
#define BDA_TEAM_FIELD_TEAM_ID                    "team_id"

/* Hook table members. */
#define HOOK_TABLE                                "wlbs!HOOK_TABLE"
#define HOOK_TABLE_FIELD_FILTER_HOOK              "FilterHook"

/* The current hook (de)register operation in progress. */
enum _HOOK_OPERATION {
    HOOK_OPERATION_NONE = 0,
    HOOK_OPERATION_REGISTERING,
    HOOK_OPERATION_DEREGISTERING
};

/* Filter hook table members. */
#define FILTER_HOOK_TABLE                         "wlbs!FILTER_HOOK_TABLE"
#define FILTER_HOOK_TABLE_FIELD_OPERATION         "Operation"
#define FILTER_HOOK_TABLE_FIELD_INTERFACE         "Interface"
#define FILTER_HOOK_TABLE_FIELD_SEND_HOOK         "SendHook"
#define FILTER_HOOK_TABLE_FIELD_RECEIVE_HOOK      "ReceiveHook"

/* Hook interface members. */
#define HOOK_INTERFACE                            "wlbs!HOOK_INTERFACE"
#define HOOK_INTERFACE_FIELD_REGISTERED           "Registered"
#define HOOK_INTERFACE_FIELD_OWNER                "Owner"
#define HOOK_INTERFACE_FIELD_DEREGISTER           "Deregister"

/* Hook members. */
#define HOOK                                      "wlbs!HOOK"
#define HOOK_FIELD_REGISTERED                     "Registered"
#define HOOK_FIELD_REFERENCES                     "References"
#define HOOK_FIELD_HOOK                           "Hook"

/* Hook function members. */
#define HOOK_FUNCTION                             "wlbs!HOOK_FUNCTION"
#define HOOK_FUNCTION_FIELD_SEND_HOOK             "SendHookFunction"
#define HOOK_FUNCTION_FIELD_RECEIVE_HOOK          "ReceiveHookFunction"

/* Members of CVY_PARAMS. */
#define CVY_PARAMS                                "wlbs!CVY_PARAMS"
#define CVY_PARAMS_FIELD_VERSION                  "parms_ver"
#define CVY_PARAMS_FIELD_HOST_PRIORITY            "host_priority"
#define CVY_PARAMS_FIELD_MULTICAST_SUPPORT        "mcast_support"
#define CVY_PARAMS_FIELD_IGMP_SUPPORT             "igmp_support"
#define CVY_PARAMS_FIELD_INITIAL_STATE            "cluster_mode"
#define CVY_PARAMS_FIELD_HOST_STATE               "init_state"
#define CVY_PARAMS_FIELD_PERSISTED_STATES         "persisted_states"
#define CVY_PARAMS_FIELD_REMOTE_CONTROL_ENABLED   "rct_enabled"
#define CVY_PARAMS_FIELD_REMOTE_CONTROL_PORT      "rct_port"
#define CVY_PARAMS_FIELD_REMOTE_CONTROL_PASSWD    "rct_password"
#define CVY_PARAMS_FIELD_CL_IP_ADDR               "cl_ip_addr"
#define CVY_PARAMS_FIELD_CL_NET_MASK              "cl_net_mask"
#define CVY_PARAMS_FIELD_CL_MAC_ADDR              "cl_mac_addr"
#define CVY_PARAMS_FIELD_CL_IGMP_ADDR             "cl_igmp_addr"
#define CVY_PARAMS_FIELD_CL_NAME                  "domain_name"
#define CVY_PARAMS_FIELD_DED_IP_ADDR              "ded_ip_addr"
#define CVY_PARAMS_FIELD_DED_NET_MASK             "ded_net_mask"
#define CVY_PARAMS_FIELD_NUM_RULES                "num_rules"
#define CVY_PARAMS_FIELD_PORT_RULES               "port_rules"
#define CVY_PARAMS_FIELD_ALIVE_PERIOD             "alive_period"
#define CVY_PARAMS_FIELD_ALIVE_TOLERANCE          "alive_tolerance"
#define CVY_PARAMS_FIELD_NUM_ACTIONS              "num_actions"
#define CVY_PARAMS_FIELD_NUM_PACKETS              "num_packets"
#define CVY_PARAMS_FIELD_NUM_PINGS                "num_send_msgs"
#define CVY_PARAMS_FIELD_NUM_DESCR                "dscr_per_alloc"
#define CVY_PARAMS_FIELD_MAX_DESCR                "max_dscr_allocs"
#define CVY_PARAMS_FIELD_TCP_TIMEOUT              "tcp_dscr_timeout"
#define CVY_PARAMS_FIELD_IPSEC_TIMEOUT            "ipsec_dscr_timeout"
#define CVY_PARAMS_FIELD_FILTER_ICMP              "filter_icmp"
#define CVY_PARAMS_FIELD_NBT_SUPPORT              "nbt_support"
#define CVY_PARAMS_FIELD_MCAST_SPOOF              "mcast_spoof"
#define CVY_PARAMS_FIELD_NETMON_PING              "netmon_alive"
#define CVY_PARAMS_FIELD_MASK_SRC_MAC             "mask_src_mac"
#define CVY_PARAMS_FIELD_CONVERT_MAC              "convert_mac"
#define CVY_PARAMS_FIELD_IP_CHANGE_DELAY          "ip_chg_delay"
#define CVY_PARAMS_FIELD_CLEANUP_DELAY            "cleanup_delay"
#define CVY_PARAMS_FIELD_BDA_TEAMING              "bda_teaming"
#define CVY_PARAMS_FIELD_HOSTNAME                 "hostname"

/* Members of BDA teaming. */
#define CVY_BDA                                   "wlbs!_CVY_BDA"
#define CVY_BDA_FIELD_ACTIVE                      "active"
#define CVY_BDA_FIELD_MASTER                      "master"
#define CVY_BDA_FIELD_REVERSE_HASH                "reverse_hash"
#define CVY_BDA_FIELD_TEAM_ID                     "team_id"

/* Members of CVY_RULE. */
#define CVY_RULE                                  "wlbs!CVY_RULE"
#define CVY_RULE_FIELD_VIP                        "virtual_ip_addr"
#define CVY_RULE_FIELD_START_PORT                 "start_port"
#define CVY_RULE_FIELD_END_PORT                   "end_port"
#define CVY_RULE_FIELD_PROTOCOL                   "protocol"
#define CVY_RULE_FIELD_MODE                       "mode"
#define CVY_RULE_FIELD_PRIORITY                   "mode_data.single.priority"
#define CVY_RULE_FIELD_EQUAL_LOAD                 "mode_data.multi.equal_load"
#define CVY_RULE_FIELD_LOAD_WEIGHT                "mode_data.multi.load"
#define CVY_RULE_FIELD_AFFINITY                   "mode_data.multi.affinity"

/* Members of LOAD_CTXT. */
#define LOAD_CTXT                                 "wlbs!LOAD_CTXT"
#define LOAD_CTXT_FIELD_CODE                      "code"
#define LOAD_CTXT_FIELD_CLOCK_SECONDS             "clock_sec"
#define LOAD_CTXT_FIELD_CLOCK_MILISECONDS         "clock_msec"
#define LOAD_CTXT_FIELD_HOST_ID                   "my_host_id"
#define LOAD_CTXT_FIELD_REF_COUNT                 "ref_count"
#define LOAD_CTXT_FIELD_INIT                      "initialized"
#define LOAD_CTXT_FIELD_ACTIVE                    "active"
#define LOAD_CTXT_FIELD_PACKET_COUNT              "pkt_count"
#define LOAD_CTXT_FIELD_CONNECTIONS               "nconn"
#define LOAD_CTXT_FIELD_CONSISTENT                "consistent"
#define LOAD_CTXT_FIELD_DUP_HOST_ID               "dup_hosts"
#define LOAD_CTXT_FIELD_LEGACY_HOSTS              "legacy_hosts"
#define LOAD_CTXT_FIELD_DUP_PRIORITY              "dup_sspri"
#define LOAD_CTXT_FIELD_BAD_TEAM_CONFIG           "bad_team_config"
#define LOAD_CTXT_FIELD_BAD_NUM_RULES             "bad_num_rules"
#define LOAD_CTXT_FIELD_BAD_NEW_MAP               "bad_map"
#define LOAD_CTXT_FIELD_OVERLAPPING_MAP           "overlap_maps"
#define LOAD_CTXT_FIELD_RECEIVING_BINS            "err_rcving_bins"
#define LOAD_CTXT_FIELD_ORPHANED_BINS             "err_orphans"
#define LOAD_CTXT_FIELD_HOST_MAP                  "host_map"
#define LOAD_CTXT_FIELD_PING_MAP                  "ping_map"
#define LOAD_CTXT_FIELD_LAST_MAP                  "last_hmap"
#define LOAD_CTXT_FIELD_STABLE_MAP                "stable_map"
#define LOAD_CTXT_FIELD_MIN_STABLE                "min_stable_ct"
#define LOAD_CTXT_FIELD_LOCAL_STABLE              "my_stable_ct"
#define LOAD_CTXT_FIELD_ALL_STABLE                "all_stable_ct"
#define LOAD_CTXT_FIELD_DEFAULT_TIMEOUT           "def_timeout"
#define LOAD_CTXT_FIELD_CURRENT_TIMEOUT           "cur_timeout"
#define LOAD_CTXT_FIELD_PING_TOLERANCE            "min_missed_pings"
#define LOAD_CTXT_FIELD_PING_MISSED               "nmissed_pings"
#define LOAD_CTXT_FIELD_CLEANUP_WAITING           "cln_waiting"
#define LOAD_CTXT_FIELD_CLEANUP_TIMEOUT           "cln_timeout"
#define LOAD_CTXT_FIELD_CLEANUP_CURRENT           "cur_time"
#define LOAD_CTXT_FIELD_INHIBITED_ALLOC           "alloc_inhibited"
#define LOAD_CTXT_FIELD_FAILED_ALLOC              "alloc_failed"
#define LOAD_CTXT_FIELD_DIRTY_BINS                "dirty_bin"
#define LOAD_CTXT_FIELD_NUM_DIRTY                 "num_dirty"
#define LOAD_CTXT_FIELD_PING                      "send_msg"
#define LOAD_CTXT_FIELD_PORT_RULE_STATE           "pg_state"
#define LOAD_CTXT_FIELD_PARAMS                    "params"
#define LOAD_CTXT_FIELD_NUM_CONVERGENCES          "num_convergences"
#define LOAD_CTXT_FIELD_LAST_CONVERGENCE          "last_convergence"
#define LOAD_CTXT_FIELD_NUM_DSCR_OUT              "num_dscr_out"
#define LOAD_CTXT_FIELD_MAX_DSCR_OUT              "max_dscr_out"
#define LOAD_CTXT_FIELD_FREE_POOL                 "free_dscr_pool"
#define LOAD_CTXT_FIELD_CONN_QUEUE                "connq"
#define LOAD_CTXT_FIELD_HASHED_CONN               "hashed_conn"
#define LOAD_CTXT_FIELD_DIRTY_QUEUE               "conn_dirtyq"
#define LOAD_CTXT_FIELD_RECOVERY_QUEUE            "conn_rcvryq"
#define LOAD_CTXT_FIELD_TCP_TIMEOUT_QUEUE         "tcp_expiredq"
#define LOAD_CTXT_FIELD_IPSEC_TIMEOUT_QUEUE       "ipsec_expiredq"

/* Members of PING_MSG. */
#define PING_MSG                                  "wlbs!PING_MSG"
#define PING_MSG_FIELD_HOST_ID                    "host_id"
#define PING_MSG_FIELD_DEFAULT_HOST_ID            "master_id"
#define PING_MSG_FIELD_STATE                      "state"
#define PING_MSG_FIELD_NUM_RULES                  "nrules"
#define PING_MSG_FIELD_HOST_CODE                  "hcode"
#define PING_MSG_FIELD_TEAMING_CODE               "teaming"
#define PING_MSG_FIELD_PACKET_COUNT               "pkt_count"
#define PING_MSG_FIELD_RULE_CODE                  "rcode"
#define PING_MSG_FIELD_CURRENT_MAP                "cur_map"
#define PING_MSG_FIELD_NEW_MAP                    "new_map"
#define PING_MSG_FIELD_IDLE_MAP                   "idle_map"
#define PING_MSG_FIELD_READY_BINS                 "rdy_bins"
#define PING_MSG_FIELD_LOAD_AMOUNT                "load_amt"

/* Members of BIN_STATE. */
#define BIN_STATE                                 "wlbs!BIN_STATE"
#define BIN_STATE_FIELD_CODE                      "code"
#define BIN_STATE_FIELD_INDEX                     "index"
#define BIN_STATE_FIELD_INITIALIZED               "initialized"
#define BIN_STATE_FIELD_COMPATIBLE                "compatible"
#define BIN_STATE_FIELD_EQUAL                     "equal_bal"
#define BIN_STATE_FIELD_MODE                      "mode"
#define BIN_STATE_FIELD_AFFINITY                  "affinity"
#define BIN_STATE_FIELD_PROTOCOL                  "prot"
#define BIN_STATE_FIELD_ORIGINAL_LOAD             "orig_load_amt"
#define BIN_STATE_FIELD_CURRENT_LOAD              "load_amt"
#define BIN_STATE_FIELD_TOTAL_LOAD                "tot_load"
#define BIN_STATE_FIELD_TOTAL_CONNECTIONS         "tconn"
#define BIN_STATE_FIELD_NUM_CONNECTIONS           "nconn"
#define BIN_STATE_FIELD_CURRENT_MAP               "cmap"
#define BIN_STATE_FIELD_ALL_IDLE_MAP              "all_idle_map"
#define BIN_STATE_FIELD_IDLE_BINS                 "idle_bins"
#define BIN_STATE_FIELD_PACKETS_ACCEPTED          "packets_accepted"
#define BIN_STATE_FIELD_PACKETS_DROPPED           "packets_dropped"
#define BIN_STATE_FIELD_CONN_QUEUE                "connq"

/* Members of IOCTL_REMOTE_HDR */
#define IOCTL_REMOTE_HDR                          "wlbs!IOCTL_REMOTE_HDR"
#define IOCTL_REMOTE_HDR_CODE                     "code"
#define IOCTL_REMOTE_HDR_VERSION                  "version"
#define IOCTL_REMOTE_HDR_HOST                     "host"
#define IOCTL_REMOTE_HDR_CLUSTER                  "cluster"
#define IOCTL_REMOTE_HDR_ADDR                     "addr"
#define IOCTL_REMOTE_HDR_ID                       "id"
#define IOCTL_REMOTE_HDR_IOCTRL                   "ioctrl"
#define IOCTL_REMOTE_HDR_CTRL                     "ctrl"
#define IOCTL_REMOTE_HDR_PASSWORD                 "password"
#define IOCTL_REMOTE_HDR_OPTIONS                  "options"

#define CVY_MAX_FRAME_SIZE                        1500

/* protocol type signatures carried in the length field of Ethernet frame */
#define TCPIP_IP_SIG                              0x0800      /* IP protocol */
#define TCPIP_ARP_SIG                             0x0806      /* ARP/RARP protocol */
#define MAIN_FRAME_SIG                            0x886f      /* new and approved 802.3 ping frame signature */
#define MAIN_FRAME_SIG_OLD                        0xbf01      /* old convoy 802.3 ping frame signature */
#define MAIN_FRAME_CODE                           0xc0de01bf  /* ping frame code */

#define ETHER_HEADER_SIZE                         0x0e        /* Size of an ethernet header */
#define ARP_HEADER_AND_PAYLOAD_SIZE               0x1c        /* Size of an ARP header and payload (included since it is fixed) */
#define IP_MIN_HEADER_SIZE                        0x14        /* Minimum size of an IP header */
#define TCP_MIN_HEADER_SIZE                       0x14        /* Minimum size of a TCP header */
#define IGMP_HEADER_AND_PAYLOAD_SIZE              0x08        /* Size of an IGMP header and payload (included since it is fixed) */
#define UDP_HEADER_SIZE                           0x08        /* Size of a UDP header */
#define NLB_REMOTE_CONTROL_MIN_NEEDED_SIZE        0x08        /* Minimum size of the NLB remote control data needed to extract the required info for printing */

/* protocol types as encoded in IP header */
#define TCPIP_PROTOCOL_IP                         0           /* Internet protocol id */
#define TCPIP_PROTOCOL_ICMP                       1           /* Internet control message protocol id */
#define TCPIP_PROTOCOL_IGMP                       2           /* Internet gateway message protocol id */
#define TCPIP_PROTOCOL_GGP                        3           /* Gateway-gateway protocol id */
#define TCPIP_PROTOCOL_TCP                        6           /* Transmission control protocol id */
#define TCPIP_PROTOCOL_EGP                        8           /* Exterior gateway protocol id */
#define TCPIP_PROTOCOL_PUP                        12          /* PARC universal packet protocol id */
#define TCPIP_PROTOCOL_UDP                        17          /* user datagram protocol id */
#define TCPIP_PROTOCOL_HMP                        20          /* Host monitoring protocol id */
#define TCPIP_PROTOCOL_XNS_IDP                    22          /* Xerox NS IDP protocol id */
#define TCPIP_PROTOCOL_RDP                        27          /* Reliable datagram protocol id */
#define TCPIP_PROTOCOL_RVD                        66          /* MIT remote virtual disk protocol id */
#define TCPIP_PROTOCOL_RAW_IP                     255         /* raw IP protocol id */
#define TCPIP_PROTOCOL_GRE                        47          /* PPTP's GRE stream */
#define TCPIP_PROTOCOL_IPSEC1                     50          /* IPSEC's data stream */
#define TCPIP_PROTOCOL_IPSEC2                     51          /* IPSEC's data stream */
#define TCPIP_PROTOCOL_PPTP                       99          /* Not a real protocol ID - this is arbitrarily concocted
                                                                 and is only used internally in NLB. */
#define TCPIP_PROTOCOL_IPSEC_UDP                  217         /* Bogus protocol ID used to track UDP subsequent
                                                                 fragments within the IPSEC protocol in load.c */

/* Convoy default remote control port */
#define CVY_DEF_RCT_PORT                          2504
#define CVY_DEF_RCT_PORT_OLD                      1717

#define IOCTL_REMOTE_CODE                         0xb055c0de

#define CVY_VERSION                               L"V2.4"
#define CVY_VERSION_MAJOR                         2
#define CVY_VERSION_MINOR                         4
#define CVY_VERSION_FULL                          (CVY_VERSION_MINOR | (CVY_VERSION_MAJOR << 8))

#define CVY_WIN2K_VERSION                         L"V2.3"
#define CVY_WIN2K_VERSION_FULL                    0x00000203

#define CVY_NT40_VERSION                          L"V2.1"
#define CVY_NT40_VERSION_FULL                     0x00000201

#define CVY_DEVICE_TYPE                           0xc0c0

#define IOCTL_CVY_CLUSTER_ON                      CTL_CODE(CVY_DEVICE_TYPE, 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_CVY_CLUSTER_OFF                     CTL_CODE(CVY_DEVICE_TYPE, 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_CVY_PORT_ON                         CTL_CODE(CVY_DEVICE_TYPE, 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_CVY_PORT_OFF                        CTL_CODE(CVY_DEVICE_TYPE, 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_CVY_QUERY                           CTL_CODE(CVY_DEVICE_TYPE, 5, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_CVY_RELOAD                          CTL_CODE(CVY_DEVICE_TYPE, 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_CVY_PORT_SET                        CTL_CODE(CVY_DEVICE_TYPE, 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_CVY_PORT_DRAIN                      CTL_CODE(CVY_DEVICE_TYPE, 8, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_CVY_CLUSTER_DRAIN                   CTL_CODE(CVY_DEVICE_TYPE, 9, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_CVY_CLUSTER_PLUG                    CTL_CODE(CVY_DEVICE_TYPE, 10, METHOD_BUFFERED, FILE_ANY_ACCESS) /* Internal only - passed from main.c to load.c when a start interrupts a drain. */
#define IOCTL_CVY_CLUSTER_SUSPEND                 CTL_CODE(CVY_DEVICE_TYPE, 11, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_CVY_CLUSTER_RESUME                  CTL_CODE(CVY_DEVICE_TYPE, 12, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_CVY_QUERY_FILTER                    CTL_CODE(CVY_DEVICE_TYPE, 13, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_CVY_QUERY_PORT_STATE                CTL_CODE(CVY_DEVICE_TYPE, 14, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_CVY_QUERY_PARAMS                    CTL_CODE(CVY_DEVICE_TYPE, 15, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_CVY_QUERY_BDA_TEAMING               CTL_CODE(CVY_DEVICE_TYPE, 16, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define STR_IOCTL_CVY_CLUSTER_ON                 "IOCTL_CVY_CLUSTER_ON"
#define STR_IOCTL_CVY_CLUSTER_OFF                "IOCTL_CVY_CLUSTER_OFF"
#define STR_IOCTL_CVY_PORT_ON                    "IOCTL_CVY_PORT_ON"
#define STR_IOCTL_CVY_PORT_OFF                   "IOCTL_CVY_PORT_OFF"
#define STR_IOCTL_CVY_QUERY                      "IOCTL_CVY_QUERY"
#define STR_IOCTL_CVY_RELOAD                     "IOCTL_CVY_RELOAD"
#define STR_IOCTL_CVY_PORT_SET                   "IOCTL_CVY_PORT_SET"
#define STR_IOCTL_CVY_PORT_DRAIN                 "IOCTL_CVY_PORT_DRAIN"
#define STR_IOCTL_CVY_CLUSTER_DRAIN              "IOCTL_CVY_CLUSTER_DRAIN"
#define STR_IOCTL_CVY_CLUSTER_PLUG               "IOCTL_CVY_CLUSTER_PLUG"
#define STR_IOCTL_CVY_CLUSTER_SUSPEND            "IOCTL_CVY_CLUSTER_SUSPEND"
#define STR_IOCTL_CVY_CLUSTER_RESUME             "IOCTL_CVY_CLUSTER_RESUME"
#define STR_IOCTL_CVY_QUERY_FILTER               "IOCTL_CVY_QUERY_FILTER"
#define STR_IOCTL_CVY_QUERY_PORT_STATE           "IOCTL_CVY_QUERY_PORT_STATE"
#define STR_IOCTL_CVY_QUERY_PARAMS               "IOCTL_CVY_QUERY_PARAMS"
#define STR_IOCTL_CVY_QUERY_BDA_TEAMING          "IOCTL_CVY_QUERY_BDA_TEAMING"

/* Offset for quantities in the Ethernet header relative to the start of the header */
#define ETHER_OFFSET_DEST_MAC                    0
#define ETHER_OFFSET_SOURCE_MAC                  6
#define ETHER_OFFSET_FRAME_TYPE_START            12

/* Offset for quantities in the ARP header relative to the start of the header */
#define ARP_OFFSET_SENDER_MAC                    8
#define ARP_OFFSET_SENDER_IP                     14
#define ARP_OFFSET_TARGET_MAC                    18
#define ARP_OFFSET_TARGET_IP                     24

/* Offset for quantities in the IP header relative to the start of the header */
#define IP_OFFSET_HEADER_LEN                     0
#define IP_OFFSET_TOTAL_LEN                      2
#define IP_OFFSET_PROTOCOL                       9
#define IP_OFFSET_SOURCE_IP                      12
#define IP_OFFSET_DEST_IP                        16

/* Offset for quantities in the UDP header relative to the start of the header */
#define UDP_OFFSET_SOURCE_PORT_START             0
#define UDP_OFFSET_DEST_PORT_START               2
#define UDP_OFFSET_PAYLOAD_START                 8

/* Offset for quantities in the TCP header relative to the start of the header */
#define TCP_OFFSET_SOURCE_PORT_START             0
#define TCP_OFFSET_DEST_PORT_START               2
#define TCP_OFFSET_SEQUENCE_NUM_START            4
#define TCP_OFFSET_ACK_NUM_START                 8
#define TCP_OFFSET_FLAGS                         13

/* Offset for quantities in the IGMP header relative to the start of the header */
#define IGMP_OFFSET_VERSION_AND_TYPE             0
#define IGMP_OFFSET_GROUP_IP_ADDR                4

#define NLB_RC_PACKET_NO                         0
#define NLB_RC_PACKET_AMBIGUOUS                  1
#define NLB_RC_PACKET_REQUEST                    2
#define NLB_RC_PACKET_REPLY                      3

#define STR_NLB_RC_PACKET_NO                     "Not remote control"
#define STR_NLB_RC_PACKET_AMBIGUOUS              "Ambiguous"
#define STR_NLB_RC_PACKET_REQUEST                "Request"
#define STR_NLB_RC_PACKET_REPLY                  "Reply"

/* IPSec/IKE header macros. */
#define IPSEC_ISAKMP_SA                                1
#define IPSEC_ISAKMP_VENDOR_ID                         13
#define IPSEC_ISAKMP_NOTIFY                            11

#define IPSEC_ISAKMP_MAIN_MODE_RCOOKIE                 {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
#define IPSEC_ISAKMP_ENCAPSULATED_IPSEC_ICOOKIE        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}

#define IPSEC_ISAKMP_HEADER_LENGTH                     28
#define IPSEC_ISAKMP_HEADER_ICOOKIE_OFFSET             0
#define IPSEC_ISAKMP_HEADER_ICOOKIE_LENGTH             8
#define IPSEC_ISAKMP_HEADER_RCOOKIE_OFFSET             8
#define IPSEC_ISAKMP_HEADER_RCOOKIE_LENGTH             8
#define IPSEC_ISAKMP_HEADER_NEXT_PAYLOAD_OFFSET        16
#define IPSEC_ISAKMP_HEADER_PACKET_LENGTH_OFFSET       24

typedef struct {
    UCHAR byte[IPSEC_ISAKMP_HEADER_LENGTH];
} IPSEC_ISAKMP_HDR, * PIPSEC_ISAKMP_HDR;

#define IPSEC_ISAKMP_GET_ICOOKIE_POINTER(isakmp_hdrp)  ((PUCHAR)isakmp_hdrp + IPSEC_ISAKMP_HEADER_ICOOKIE_OFFSET)
#define IPSEC_ISAKMP_GET_RCOOKIE_POINTER(isakmp_hdrp)  ((PUCHAR)isakmp_hdrp + IPSEC_ISAKMP_HEADER_RCOOKIE_OFFSET)
#define IPSEC_ISAKMP_GET_NEXT_PAYLOAD(isakmp_hdrp)     ((UCHAR)((isakmp_hdrp)->byte[IPSEC_ISAKMP_HEADER_NEXT_PAYLOAD_OFFSET]))
#define IPSEC_ISAKMP_GET_PACKET_LENGTH(isakmp_hdrp)    ((ULONG)(((isakmp_hdrp)->byte[IPSEC_ISAKMP_HEADER_PACKET_LENGTH_OFFSET]     << 24) | \
                                                                ((isakmp_hdrp)->byte[IPSEC_ISAKMP_HEADER_PACKET_LENGTH_OFFSET + 1] << 16) | \
                                                                ((isakmp_hdrp)->byte[IPSEC_ISAKMP_HEADER_PACKET_LENGTH_OFFSET + 2] << 8)  | \
                                                                ((isakmp_hdrp)->byte[IPSEC_ISAKMP_HEADER_PACKET_LENGTH_OFFSET + 3] << 0)))

#define IPSEC_GENERIC_HEADER_LENGTH                    4
#define IPSEC_GENERIC_HEADER_NEXT_PAYLOAD_OFFSET       0
#define IPSEC_GENERIC_HEADER_PAYLOAD_LENGTH_OFFSET     2

typedef struct {
    UCHAR byte[IPSEC_GENERIC_HEADER_LENGTH];
} IPSEC_GENERIC_HDR, * PIPSEC_GENERIC_HDR;

#define IPSEC_GENERIC_GET_NEXT_PAYLOAD(generic_hdrp)   ((UCHAR)((generic_hdrp)->byte[IPSEC_GENERIC_HEADER_NEXT_PAYLOAD_OFFSET]))
#define IPSEC_GENERIC_GET_PAYLOAD_LENGTH(generic_hdrp) ((USHORT)(((generic_hdrp)->byte[IPSEC_GENERIC_HEADER_PAYLOAD_LENGTH_OFFSET]     << 8) | \
                                                                 ((generic_hdrp)->byte[IPSEC_GENERIC_HEADER_PAYLOAD_LENGTH_OFFSET + 1] << 0)))

#define IPSEC_VENDOR_ID_MICROSOFT                      {0x1E, 0x2B, 0x51, 0x69, 0x05, 0x99, 0x1C, 0x7D, 0x7C, 0x96, 0xFC, 0xBF, 0xB5, 0x87, 0xE4, 0x61}
#define IPSEC_VENDOR_ID_MICROSOFT_MIN_VERSION          0x00000004

#define IPSEC_VENDOR_ID_PAYLOAD_LENGTH                 20
#define IPSEC_VENDOR_HEADER_VENDOR_ID_OFFSET           4
#define IPSEC_VENDOR_HEADER_VENDOR_ID_LENGTH           16
#define IPSEC_VENDOR_HEADER_VENDOR_VERSION_OFFSET      20
#define IPSEC_VENDOR_HEADER_VENDOR_VERSION_LENGTH      4

typedef struct {
    UCHAR byte[IPSEC_GENERIC_HEADER_LENGTH + IPSEC_VENDOR_ID_PAYLOAD_LENGTH];
} IPSEC_VENDOR_HDR, * PIPSEC_VENDOR_HDR;

#define IPSEC_VENDOR_ID_GET_ID_POINTER(vendor_hdrp)    ((PUCHAR)vendor_hdrp + IPSEC_VENDOR_HEADER_VENDOR_ID_OFFSET)
#define IPSEC_VENDOR_ID_GET_VERSION(vendor_hdrp)       ((ULONG)(((vendor_hdrp)->byte[IPSEC_VENDOR_HEADER_VENDOR_VERSION_OFFSET]     << 24) | \
                                                                ((vendor_hdrp)->byte[IPSEC_VENDOR_HEADER_VENDOR_VERSION_OFFSET + 1] << 16) | \
                                                                ((vendor_hdrp)->byte[IPSEC_VENDOR_HEADER_VENDOR_VERSION_OFFSET + 2] << 8)  | \
                                                                ((vendor_hdrp)->byte[IPSEC_VENDOR_HEADER_VENDOR_VERSION_OFFSET + 3] << 0)))

#define IPSEC_NOTIFY_INITIAL_CONTACT                   24578

#define IPSEC_NOTIFY_PAYLOAD_LENGTH                    8
#define IPSEC_NOTIFY_HEADER_NOTIFY_MESSAGE_OFFSET      10

typedef struct {
    UCHAR byte[IPSEC_GENERIC_HEADER_LENGTH + IPSEC_NOTIFY_PAYLOAD_LENGTH];
} IPSEC_NOTIFY_HDR, * PIPSEC_NOTIFY_HDR;

#define IPSEC_NOTIFY_GET_NOTIFY_MESSAGE(notify_hdrp)   ((USHORT)(((notify_hdrp)->byte[IPSEC_NOTIFY_HEADER_NOTIFY_MESSAGE_OFFSET]     << 8) | \
                                                                 ((notify_hdrp)->byte[IPSEC_NOTIFY_HEADER_NOTIFY_MESSAGE_OFFSET + 1] << 0)))

typedef struct _NETWORK_DATA
{
    // Ethernet 
    UCHAR   SourceMACAddr[6];
    UCHAR   DestMACAddr[6];
    USHORT  EtherFrameType;

    // IP
    ULONG   SourceIPAddr;
    ULONG   DestIPAddr;
    UCHAR   Protocol;
    USHORT  HeadLen;
    USHORT  TotLen;

    // For TCP and UDP
    USHORT  SourcePort;
    USHORT  DestPort;

    // TCP only
    ULONG   TCPSeqNum;
    ULONG   TCPAckNum;
    UCHAR   TCPFlags;

    // ARP
    UCHAR   ARPSenderMAC[6];
    ULONG   ARPSenderIP;
    UCHAR   ARPTargetMAC[6];
    ULONG   ARPTargetIP;

    // IGMP
    UCHAR   IGMPVersion;
    UCHAR   IGMPType;
    ULONG   IGMPGroupIPAddr;

    // ICMP?
    // GRE?

    // IPSec
    BOOL    IPSecInitialContact;

    // NLB Heartbeat
    ULONG64 HBPtr;              /* Since SHouse already has PrintHeartbeat, set up a pointer to pass to his function */
    ULONG   HBCode;
    ULONG   HBVersion;
    ULONG   HBHost;
    ULONG   HBCluster;
    ULONG   HBDip;

    // NLB Remote control packet
    USHORT  RemoteControl;      /* Flags whether this is a remote control packet and request/reply variant */
    ULONG   RCCode;             /* Distinguishes remote packets. */
    ULONG   RCVersion;          /* Software version. */
    ULONG   RCHost;             /* Destination host (0 or cluster IP address for master). */
    ULONG   RCCluster;          /* Primary cluster IP address. */
    ULONG   RCAddr;             /* Dedicated IP address on the way back, client IP address on the way in. */
    ULONG   RCId;               /* Message ID. */
    ULONG   RCIoctrl;           /* IOCTRL code. */

    // Track user inputs here
    ULONG   UserRCPort;

    // Whether or not the packet parsed in order to fill this structure 
    // are believed to be valid.  Packets can be marked invalid, for 
    // instance, if headers are incomplete, or NLB "magic numbers" do
    // not match, etc.
    BOOL    bValid;         

} NETWORK_DATA, *PNETWORK_DATA;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbkd\nlbkd.c ===
/*
 * File: nlbkd.c
 * Description: This file contains the implementation of the NLB KD
 *              debugging extensions.  Use '!load nlbkd.dll' to load
 *              the extensions and '!nlbkd.help' to see the supported
 *              extensions.
 * Author: Created by shouse, 1.4.01
 */

#include "nlbkd.h"
#include "utils.h"
#include "print.h"
#include "packet.h"
#include "load.h"

WINDBG_EXTENSION_APIS ExtensionApis;
EXT_API_VERSION ApiVersion = { 1, 0, EXT_API_VERSION_NUMBER64, 0 };

#define NL      1
#define NONL    0

USHORT SavedMajorVersion;
USHORT SavedMinorVersion;
BOOL ChkTarget;

/*
 * Function: WinDbgExtensionDllInit
 * Description: Initializes the KD extension DLL.
 * Author: Created by shouse, 1.4.01 - copied largely from ndiskd.dll
 */
VOID WinDbgExtensionDllInit (PWINDBG_EXTENSION_APIS64 lpExtensionApis, USHORT MajorVersion, USHORT MinorVersion) {

    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    ChkTarget = (SavedMajorVersion == 0x0c) ? TRUE : FALSE;
}

/*
 * Function: CheckVersion
 * Description: Checks the extension DLL version against the target version.
 * Author: Created by shouse, 1.4.01 - copied largely from ndiskd.dll
 */
VOID CheckVersion (VOID) {

    /* For now, do nothing. */
    return;

#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

/*
 * Function: ExtensionApiVersion
 * Description: Returns the API version information. 
 * Author: Created by shouse, 1.4.01 - copied largely from ndiskd.dll
 */
LPEXT_API_VERSION ExtensionApiVersion (VOID) {

    return &ApiVersion;
}

/*
 * Function: help
 * Description: Prints the usage of the NLB KD debugger extensions.
 * Author: Created by shouse, 1.4.01
 */
DECLARE_API (help) {
    dprintf("Network Load Balancing debugger extensions:\n");
    
    dprintf("   version                                  print nlbkd version\n");
    dprintf("   nlbadapters [Verbosity]                  show all NLB adapter blocks\n");
    dprintf("   nlbadapter  <Adapter Block> [Verbosity]  dump an NLB adapter block\n");
    dprintf("   nlbctxt     <Context Block> [Verbosity]  dump an NLB context block\n");
    dprintf("   nlbload     <Load Block> [Verbosity]     dump an NLB load block\n");
    dprintf("   nlbparams   <Params Block> [Verbosity]   dump an NLB parameters block\n");
    dprintf("   nlbresp     <Packet> [Direction]         dump the NLB private data for the specified packet\n");
    dprintf("   nlbpkt      <Packet> [RC Port]           dump an NDIS packet whose content is determined\n");
    dprintf("                                              on the fly (IP, UDP, TCP, heartbeat, IGMP, remote-control, etc)\n");
    dprintf("   nlbether    <Ether Frame> [RC Port]      dump an ethernet frame. Uses same technique as nlbpkt\n");
    dprintf("   nlbip       <IP Packet> [RC Port]        dump an IP packet. Uses same technique as nlbpkt\n");
    dprintf("   nlbteams                                 dump the linked list of NLB BDA teams\n");
    dprintf("   nlbhooks                                 dump the global NLB hook information\n");
    dprintf("   nlbmac      <Context Block>              dump the MAC address lists (unicast and multicast) for the physical\n");
    dprintf("                                              adapter to which this NLB instance is bound\n");
    dprintf("   nlbdscr     <Descriptor>                 dump the contents of a connection descriptor\n");
    dprintf("   nlbconnq    <Queue>[Index] [MaxEntries]  dump the contents of a connection descriptor queue\n");
    dprintf("   nlbglobalq  <Queue>[Index] [MaxEntries]  dump the contents of a global connection descriptor queue\n");
    dprintf("   nlbfilter <pointer to context block> <protocol> <client IP>[:<client port>] <server IP>[:<server port>] [flags]\n");
    dprintf("                                            query map function and retrieve any existing state for this tuple\n");
    dprintf("   nlbhash     <Context Block> <Packet>     determine whether or not NLB will accept this packet\n");
    dprintf("\n");
    dprintf("  [Verbosity] is an optional integer from 0 to 2 that determines the level of detail displayed.\n");
    dprintf("  [Direction] is an optional integer that specifies the direction of the packet (RCV=0, SND=1).\n");
    dprintf("  [RC Port] is an optional UDP port used to identify whether a UDP packet might be for remote-control.\n");
    dprintf("  [Flags] is an optional TCP-like packet type specification; SYN, FIN or RST.\n");
    dprintf("  [MaxEntries] is an optional maximum number of entries to print (default is 10)\n");
    dprintf("  [Index] is an optional queue index which can be used if the queue pointer points to an array of queues.\n");
    dprintf("    The index should be specified in Addr[index], Addr{index} or Addr(index) form.\n");
    dprintf("\n");
    dprintf("  IP addresses can be in dotted notation or network byte order DWORDs.\n");
    dprintf("    I.e., 169.128.0.101 = 0x650080a9 (in x86 memory = A9 80 00 65)\n");
    dprintf("  Valid protocols include TCP, UDP, IPSec and GRE.\n");
}

/*
 * Function: version
 * Description: Prints the NLB KD debugger extension version information.
 * Author: Created by shouse, 1.4.01 - copied largely from ndiskd.dll
 */
DECLARE_API (version) {
#if DBG
    PCSTR kind = "Checked";
#else
    PCSTR kind = "Free";
#endif

    dprintf("%s NLB Extension DLL for Build %d debugging %s kernel for Build %d\n", kind,
            VER_PRODUCTBUILD, SavedMajorVersion == 0x0c ? "Checked" : "Free", SavedMinorVersion);
}

/*
 * Function: nlbadapters
 * Description: Prints all NLB adapter strucutres in use.  Verbosity is always LOW.
 * Author: Created by shouse, 1.5.01
 */
DECLARE_API (nlbadapters) {
    ULONG dwVerbosity = VERBOSITY_LOW;
    CHAR szArgList[10][MAX_PATH];
    CHAR szArgBuffer[MAX_PATH];
    ULONG64 pNumAdapters;
    DWORD dwAdapterSize;
    ULONG dwNumAdapters;
    ULONG64 pAdapter;
    ULONG dwIndex;
    INT index = 0;
    CHAR * p;

    if (args && (*args)) {   
        /* Copy the argument list into a temporary buffer. */
        strcpy(szArgBuffer, args);

        /* Peel out all of the tokenized strings. */
        for (p = mystrtok(szArgBuffer, " \t,"); p && *p; p = mystrtok(NULL, " \t,"))
            strcpy(&szArgList[index++][0], p);
        
        /* If a verbosity was specified, get it. */
        if (index == 1) dwVerbosity = atoi(&szArgList[0][0]);
        
        /* If too many arguments were given, or the verbosity was out of range, complain. */
        if ((index > 1) || (dwVerbosity > VERBOSITY_HIGH)) {
            PrintUsage(USAGE_ADAPTERS);
            return;
        }
    }

    /* Get the address of the global variable containing the number of NLB adapters in use. */
    pNumAdapters = GetExpression(UNIV_ADAPTERS_COUNT);

    if (!pNumAdapters) {
        ErrorCheckSymbols(UNIV_ADAPTERS_COUNT);
        return;
    }

    /* Get the number of adapters from the address. */
    dwNumAdapters = GetUlongFromAddress(pNumAdapters);

    dprintf("Network Load Balancing is currently bound to %u adapter(s).\n", dwNumAdapters);

    /* Get the base address of the global array of NLB adapter structures. */
    pAdapter = GetExpression(UNIV_ADAPTERS);

    if (!pAdapter) {
        ErrorCheckSymbols(UNIV_ADAPTERS);
        return;
    }

    /* Find out the size of a MAIN_ADAPTER structure. */
    dwAdapterSize = GetTypeSize(MAIN_ADAPTER);

    /* Loop through all adapters in use and print some information about them. */
    for (dwIndex = 0; dwIndex < CVY_MAX_ADAPTERS; dwIndex++) {
        ULONG dwValue;

        /* Retrieve the used/unused state of the adapter. */
        GetFieldValue(pAdapter, MAIN_ADAPTER, MAIN_ADAPTER_FIELD_USED, dwValue);
        
        /* If the adapter is in use, or the user specified HIGH verbosity, print the adapter. */
        if (dwValue || (dwVerbosity == VERBOSITY_HIGH)) {
            /* Print the adapter index. */
            dprintf("\n[%u] ", dwIndex);
            
            /* Print the adapter contents.  If verbosity is high, change it to 
               medium - we don't want to recurse into context from here. */
            PrintAdapter(pAdapter, (dwVerbosity == VERBOSITY_HIGH) ? VERBOSITY_MEDIUM : dwVerbosity);
        }

        /* Advance the pointer to the next index in the array of structures. */
        pAdapter += dwAdapterSize;
    }
}

/*
 * Function: nlbadapter
 * Description: Prints NLB adapter information.  Takes an adapter pointer and an
 *              optional verbosity as arguments.  Default verbosity is MEDIUM. 
 * Author: Created by shouse, 1.5.01
 */
DECLARE_API (nlbadapter) {
    ULONG dwVerbosity = VERBOSITY_LOW;
    CHAR szArgList[10][MAX_PATH];
    CHAR szArgBuffer[MAX_PATH];
    ULONG64 pAdapter;
    INT index = 0;
    CHAR * p;
   
    /* Make sure at least one argument, the adapter pointer, is there. */
    if (!args || !(*args)) {
        PrintUsage(USAGE_ADAPTER);
        return;
    }

    /* Get the address of the NLB adapter block from the command line. */
    pAdapter = (ULONG64)GetExpression(args);

    /* Copy the argument list into a temporary buffer. */
    strcpy(szArgBuffer, args);

    /* Peel out all of the tokenized strings. */
    for (p = mystrtok(szArgBuffer, " \t,"); p && *p; p = mystrtok(NULL, " \t,"))
        strcpy(&szArgList[index++][0], p);

    /* If a verbosity was specified, get it. */
    if (index == 2) dwVerbosity = atoi(&szArgList[1][0]);

    /* If too many arguments were given, or the verbosity was out of range, complain. */
    if ((index > 2) || (dwVerbosity > VERBOSITY_HIGH)) {
        PrintUsage(USAGE_ADAPTER);
        return;
    }

    /* Print the adapter contents. */
    PrintAdapter(pAdapter, dwVerbosity);
}

/*
 * Function: nlbctxt 
 * Description: Prints NLB context information.  Takes a context pointer and an
 *              optional verbosity as arguments.  Default verbosity is LOW.
 * Author: Created by shouse, 1.21.01
 */
DECLARE_API (nlbctxt) {
    ULONG dwVerbosity = VERBOSITY_LOW;
    CHAR szArgList[10][MAX_PATH];
    CHAR szArgBuffer[MAX_PATH];
    ULONG64 pContext;
    INT index = 0;
    CHAR * p;
   
    /* Make sure at least one argument, the context pointer, is there. */
    if (!args || !(*args)) {
        PrintUsage(USAGE_CONTEXT);
        return;
    }

    /* Get the address of the NLB context block from the command line. */
    pContext = (ULONG64)GetExpression(args);

    /* Copy the argument list into a temporary buffer. */
    strcpy(szArgBuffer, args);

    /* Peel out all of the tokenized strings. */
    for (p = mystrtok(szArgBuffer, " \t,"); p && *p; p = mystrtok(NULL, " \t,"))
        strcpy(&szArgList[index++][0], p);

    /* If a verbosity was specified, get it. */
    if (index == 2) dwVerbosity = atoi(&szArgList[1][0]);

    /* If too many arguments were given, or the verbosity was out of range, complain. */
    if ((index > 2) || (dwVerbosity > VERBOSITY_HIGH)) {
        PrintUsage(USAGE_CONTEXT);
        return;
    }

    /* Print the context contents. */
    PrintContext(pContext, dwVerbosity);
}

/*
 * Function: nlbload
 * Description: Prints NLB load information.  Takes a load pointer and an optional
 *              verbosity as arguments.  Default verbosity is LOW. 
 * Author: Created by shouse, 2.1.01
 */
DECLARE_API (nlbload) {
    ULONG dwVerbosity = VERBOSITY_LOW;
    CHAR szArgList[10][MAX_PATH];
    CHAR szArgBuffer[MAX_PATH];
    ULONG64 pLoad;
    INT index = 0;
    CHAR * p;
   
    /* Make sure at least one argument, the load pointer, is there. */
    if (!args || !(*args)) {
        PrintUsage(USAGE_LOAD);
        return;
    }

    /* Get the address of the NLB load block from the command line. */
    pLoad = (ULONG64)GetExpression(args);

    /* Copy the argument list into a temporary buffer. */
    strcpy(szArgBuffer, args);

    /* Peel out all of the tokenized strings. */
    for (p = mystrtok(szArgBuffer, " \t,"); p && *p; p = mystrtok(NULL, " \t,"))
        strcpy(&szArgList[index++][0], p);

    /* If a verbosity was specified, get it. */
    if (index == 2) dwVerbosity = atoi(&szArgList[1][0]);

    /* If too many arguments were given, or the verbosity was out of range, complain. */
    if ((index > 2) || (dwVerbosity > VERBOSITY_HIGH)) {
        PrintUsage(USAGE_LOAD);
        return;
    }

    /* Print the load contents. */
    PrintLoad(pLoad, dwVerbosity);
}

/*
 * Function: nlbparams
 * Description: Prints NLB parameter information.  Takes a parameter pointer and an
 *              optional verbosity as arguments.  Default verbosity is LOW.
 * Author: Created by shouse, 1.21.01
 */
DECLARE_API (nlbparams) {
    ULONG dwVerbosity = VERBOSITY_LOW;
    CHAR szArgList[10][MAX_PATH];
    CHAR szArgBuffer[MAX_PATH];
    ULONG64 pParams;
    INT index = 0;
    CHAR * p;
   
    /* Make sure at least one argument, the params pointer, is there. */
    if (!args || !(*args)) {
        PrintUsage(USAGE_PARAMS);
        return;
    }

    /* Get the address of the NLB params block from the command line. */
    pParams = (ULONG64)GetExpression(args);

    /* Copy the argument list into a temporary buffer. */
    strcpy(szArgBuffer, args);

    /* Peel out all of the tokenized strings. */
    for (p = mystrtok(szArgBuffer, " \t,"); p && *p; p = mystrtok(NULL, " \t,"))
        strcpy(&szArgList[index++][0], p);

    /* If a verbosity was specified, get it. */
    if (index == 2) dwVerbosity = atoi(&szArgList[1][0]);

    /* If too many arguments were given, or the verbosity was out of range, complain. */
    if ((index > 2) || (dwVerbosity > VERBOSITY_HIGH)) {
        PrintUsage(USAGE_PARAMS);
        return;
    }

    /* Print the parameter contents. */
    PrintParams(pParams, dwVerbosity);
}

/*
 * Function: nlbresp
 * Description: Prints out the NLB private packet data for a given packet.  Takes a
 *              packet pointer and an optional direction as arguments.  If not specified, 
 *              the packet is presumed to be on the receive path.
 * Author: Created by shouse, 1.31.01
 */
DECLARE_API (nlbresp) {
    ULONG dwDirection = DIRECTION_RECEIVE;
    CHAR szArgList[10][MAX_PATH];
    CHAR szArgBuffer[MAX_PATH];
    ULONG64 pPacket;
    INT index = 0;
    CHAR * p;
   
    /* Make sure at least one argument, the packet pointer, is there. */
    if (!args || !(*args)) {
        PrintUsage(USAGE_RESP);
        return;
    }

    /* Get the address of the NDIS packet from the command line. */
    pPacket = (ULONG64)GetExpression(args);

    /* Copy the argument list into a temporary buffer. */
    strcpy(szArgBuffer, args);

    /* Peel out all of the tokenized strings. */
    for (p = mystrtok(szArgBuffer, " \t,"); p && *p; p = mystrtok(NULL, " \t,"))
        strcpy(&szArgList[index++][0], p);

    /* If a direction was specified, get it. */
    if (index == 2) dwDirection = atoi(&szArgList[1][0]);

    /* If too many arguments were given, or the direction was out of range, complain. */
    if ((index > 2) || (dwDirection > DIRECTION_SEND)) {
        PrintUsage(USAGE_RESP);
        return;
    }

    /* Print the NLB private data buffer contents. */
    PrintResp(pPacket, dwDirection);
}

/*
 * Function: nlbpkt
 * Description: Prints out the contents of an NDIS packet.  Takes a packet
 *              pointer as an argument.
 * Author: Created by chrisdar  2001.10.11
 */
DECLARE_API (nlbpkt) {
    CHAR            szArgList[10][MAX_PATH];
    CHAR            szArgBuffer[MAX_PATH];
    ULONG64         pPkt;
    INT             index = 0;
    CHAR            * p;
    NETWORK_DATA    nd;

    /* Make sure at least one argument, the queue pointer, is there. */
    if (!args || !(*args)) {
        PrintUsage(USAGE_PKT);
        return;
    }

    /* Get the address of the queue from the command line. */
    pPkt = (ULONG64)GetExpression(args);

    /* Copy the argument list into a temporary buffer. */
    strcpy(szArgBuffer, args);

    /* Peel out all of the tokenized strings. */
    for (p = mystrtok(szArgBuffer, " \t,"); p && *p; p = mystrtok(NULL, " \t,"))
        strcpy(&szArgList[index++][0], p);

    /* If the wrong number of arguments were given, complain. */
    if (index > 2 || index < 1) {
        PrintUsage(USAGE_PKT);
        return;
    }

    /* Clear out the network data structure. */
    ZeroMemory(&nd, sizeof(nd));

    nd.UserRCPort = CVY_DEF_RCT_PORT;

    if (index > 1) 
    {
        nd.UserRCPort = atoi(&szArgList[1][0]);
    }

    if (nd.UserRCPort > CVY_MAX_PORT)
    {
        dprintf("Invalid port: %s\n", nd.UserRCPort);
        return;
    }

    /* Parse through the NDIS packet and retrieve the packet contents. */
    {
        UCHAR RawData[CVY_MAX_FRAME_SIZE + ETHER_HEADER_SIZE];
        ULONG BytesRead = 0;
        ULONG64 pHBData;
    
        /* Parse the buffers in the NDIS packet and get the raw packet data out.  We get
           a pointer to the heartbeat data in machine memory, not debugger process memory
           because for all other packets, we read from temporary stack space in the debugger
           - RawData - but for heartbeats, we read directly from kernel memory space (only
           because a function to do so already exits - no need to write another). */
        BytesRead = ParseNDISPacket(pPkt, RawData, CVY_MAX_FRAME_SIZE + ETHER_HEADER_SIZE, &pHBData);

        /* If some packet contents was successfully read, continue to process the packet. */
        if (BytesRead != 0) {
            /* Parse the Ethernet packet and store the information parsed in the NETWORK_DATA
               structure.  Note that this function recurses to also fill in IP, TCP/UDP, 
               heartbeat, remote control, etc. information as well. */
            PopulateEthernet(pHBData, RawData, BytesRead, &nd);
            
            /* Print the packet, including IP and TCP data (if present), or heartbeat 
               or remote control information, etc. */
            dprintf("NDIS Packet 0x%p\n", pPkt);
            PrintPacket(&nd);
        }
    }
}

/*
 * Function: nlbether
 * Description: Prints out the contents of an ethernet packet.  Takes a packet
 *              pointer as an argument.
 * Author: Created by chrisdar  2001.10.11
 */
DECLARE_API (nlbether){
    CHAR            szArgList[10][MAX_PATH];
    CHAR            szArgBuffer[MAX_PATH];
    ULONG64         pPkt;
    INT             index = 0;
    CHAR            * p;
    ULONG           BytesRead;
    UCHAR           RawData[CVY_MAX_FRAME_SIZE];
    BOOL            b;
    NETWORK_DATA    nd;
   
    /* Make sure at least one argument, the queue pointer, is there. */
    if (!args || !(*args)) {
        PrintUsage(USAGE_ETHER);
        return;
    }

    /* Get the address of the queue from the command line. */
    pPkt = (ULONG64)GetExpression(args);

    /* Copy the argument list into a temporary buffer. */
    strcpy(szArgBuffer, args);

    /* Peel out all of the tokenized strings. */
    for (p = mystrtok(szArgBuffer, " \t,"); p && *p; p = mystrtok(NULL, " \t,"))
        strcpy(&szArgList[index++][0], p);

    /* If the wrong number of arguments were given, complain. */
    if (index > 2 || index < 1) {
        PrintUsage(USAGE_ETHER);
        return;
    }

    ZeroMemory(&nd, sizeof(nd));
    nd.UserRCPort = CVY_DEF_RCT_PORT;

    if (index > 1) 
    {
        nd.UserRCPort = atoi(&szArgList[1][0]);
    }

    if (nd.UserRCPort > CVY_MAX_PORT)
    {
        dprintf("Invalid port: %s\n", nd.UserRCPort);
        return;
    }

    b = ReadMemory(pPkt, RawData, CVY_MAX_FRAME_SIZE, &BytesRead);

    if (!b || BytesRead != CVY_MAX_FRAME_SIZE)
    {
        dprintf("Unable to read %u bytes at address %p\n", CVY_MAX_FRAME_SIZE, pPkt);
    }
    else
    {
        PopulateEthernet(pPkt + ETHER_HEADER_SIZE + GetTypeSize(MAIN_FRAME_HDR),
                         RawData,
                         CVY_MAX_FRAME_SIZE,
                         &nd
                        );

        /* Print the NLB private data buffer contents. */
        dprintf("Ethernet Packet 0x%p\n", pPkt);
        PrintPacket(&nd);
    }
}

/*
 * Function: nlbip
 * Description: Prints out the contents of an ip packet.  Takes a packet
 *              pointer as an argument.
 * Author: Created by chrisdar  2001.10.11
 */
DECLARE_API (nlbip){
    CHAR            szArgList[10][MAX_PATH];
    CHAR            szArgBuffer[MAX_PATH];
    INT             index = 0;
    CHAR            * p;
    ULONG64         pPkt;
    ULONG           BytesRead;
    UCHAR           RawData[CVY_MAX_FRAME_SIZE];
    BOOL            b;
    NETWORK_DATA    nd;
   
    /* Make sure at least one argument, the queue pointer, is there. */
    if (!args || !(*args)) {
        PrintUsage(USAGE_IP);
        return;
    }

    /* Get the address of the queue from the command line. */
    pPkt = (ULONG64)GetExpression(args);

    /* Copy the argument list into a temporary buffer. */
    strcpy(szArgBuffer, args);

    /* Peel out all of the tokenized strings. */
    for (p = mystrtok(szArgBuffer, " \t,"); p && *p; p = mystrtok(NULL, " \t,"))
        strcpy(&szArgList[index++][0], p);

    /* If the wrong number of arguments were given, complain. */
    if (index > 2 || index < 1) {
        PrintUsage(USAGE_IP);
        return;
    }

    ZeroMemory(&nd, sizeof(nd));
    nd.UserRCPort = CVY_DEF_RCT_PORT;

    if (index > 1) 
    {
        nd.UserRCPort = atoi(&szArgList[1][0]);
    }

    if (nd.UserRCPort > CVY_MAX_PORT)
    {
        dprintf("Invalid port: %s\n", nd.UserRCPort);
        return;
    }

    b = ReadMemory(pPkt, RawData, CVY_MAX_FRAME_SIZE, &BytesRead);

    if (!b || BytesRead != CVY_MAX_FRAME_SIZE)
    {
        dprintf("Unable to read %u bytes at address %p\n", CVY_MAX_FRAME_SIZE, pPkt);
    }
    else
    {
        PopulateIP(RawData, CVY_MAX_FRAME_SIZE, 0, &nd);

        /* Print the NLB private data buffer contents. */
        dprintf("IP Packet 0x%p\n", pPkt);
        PrintIP(&nd);
    }
}

/*
 * Function: nlbteams
 * Description: Prints all configured Bi-directional Affintiy (BDA) teams.
 * Author: Created by shouse, 1.5.01
 */
DECLARE_API (nlbteams) {
    ULONG64 pTeam;
    ULONG64 pAddr;
    ULONG dwNumTeams = 0;
    ULONG dwValue;

    /* No command line arguments should be given. */
    if (args && (*args)) {   
        PrintUsage(USAGE_TEAMS);
        return;
    }

    /* Get the base address of the global linked list of BDA teams. */
    pAddr = GetExpression(UNIV_BDA_TEAMS);

    if (!pAddr) {
        ErrorCheckSymbols(UNIV_BDA_TEAMS);
        return;
    }

    /* Get the pointer to the first team. */
    pTeam = GetPointerFromAddress(pAddr);

    dprintf("NLB bi-directional affinity teams:\n");

    /* Loop through all teams in the list and print them out. */
    while (pTeam) {
        /* Increment the number of teams found - only used if none are found. */
        dwNumTeams++;

        dprintf("\n");

        /* Print out the team. */
        PrintBDATeam(pTeam);
        
       /* Get the offset of the params pointer. */
        if (GetFieldOffset(BDA_TEAM, BDA_TEAM_FIELD_NEXT, &dwValue))
            dprintf("Can't get offset of %s in %s\n", BDA_TEAM_FIELD_NEXT, BDA_TEAM);
        else {
            pAddr = pTeam + dwValue;
            
            /* Retrieve the pointer. */
            pTeam = GetPointerFromAddress(pAddr);
        }
    }

    if (!dwNumTeams) dprintf("\nNone.\n");
}

/*
 * Function: nlbhooks
 * Description: Prints the global NLB hook function information.
 * Author: Created by shouse, 12.20.01
 */
DECLARE_API (nlbhooks) {
    ULONG64 pAddr;

    /* No command line arguments should be given. */
    if (args && (*args)) {   
        PrintUsage(USAGE_HOOKS);
        return;
    }

    /* Get the base address of the global linked list of BDA teams. */
    pAddr = GetExpression(UNIV_HOOKS);

    if (!pAddr) {
        ErrorCheckSymbols(UNIV_HOOKS);
        return;
    }

    dprintf("NLB kernel-mode hooks:\n");

    /* Print the global NLB hook configuration and state. */
    PrintHooks(pAddr);
}

/*
 * Function: nlbmac
 * Description: Prints the unicast MAC address and all multicast MAC addresses
 *              configured on the adapter to which this instance of NLB is bound.
 * Author: Created by shouse, 1.8.02
 */
DECLARE_API (nlbmac) {
    CHAR szArgList[10][MAX_PATH];
    CHAR szArgBuffer[MAX_PATH];
    ULONG64 pContext;
    INT index = 0;
    CHAR * p;
   
    /* Make sure at least one argument, the context pointer, is there. */
    if (!args || !(*args)) {
        PrintUsage(USAGE_MAC);
        return;
    }

    /* Get the address of the NLB context block from the command line. */
    pContext = (ULONG64)GetExpression(args);

    /* Copy the argument list into a temporary buffer. */
    strcpy(szArgBuffer, args);

    /* Peel out all of the tokenized strings. */
    for (p = mystrtok(szArgBuffer, " \t,"); p && *p; p = mystrtok(NULL, " \t,"))
        strcpy(&szArgList[index++][0], p);

    /* If too many arguments were given, complain. */
    if (index > 1) {
        PrintUsage(USAGE_MAC);
        return;
    }

    /* Print the context contents. */
    PrintNetworkAddresses(pContext);
}

/*
 * Function: nlbdscr
 * Description: Prints the contents of an NLB connection descriptor.
 * Author: Created by shouse, 1.8.02
 */
DECLARE_API (nlbdscr) {
    CHAR szArgList[10][MAX_PATH];
    CHAR szArgBuffer[MAX_PATH];
    ULONG64 pDescriptor;
    INT index = 0;
    CHAR * p;
   
    /* Make sure at least one argument, the descriptor pointer, is there. */
    if (!args || !(*args)) {
        PrintUsage(USAGE_DSCR);
        return;
    }

    /* Get the address of the connection descriptor from the command line. */
    pDescriptor = (ULONG64)GetExpression(args);

    /* Copy the argument list into a temporary buffer. */
    strcpy(szArgBuffer, args);

    /* Peel out all of the tokenized strings. */
    for (p = mystrtok(szArgBuffer, " \t,"); p && *p; p = mystrtok(NULL, " \t,"))
        strcpy(&szArgList[index++][0], p);

    /* If too many arguments were given, complain. */
    if (index > 1) {
        PrintUsage(USAGE_DSCR);
        return;
    }

    /* Print the context contents. */
    PrintConnectionDescriptor(pDescriptor);
}

/*
 * Function: nlbconnq
 * Description: This function prints out all connection descriptors in a given
 *              queue of descriptors.
 * Author: Created by shouse, 4.15.01
 */
DECLARE_API (nlbconnq) {
    ULONG dwMaxEntries = 10;
    ULONG dwIndex = 0;
    CHAR szArgList[10][MAX_PATH];
    CHAR szArgBuffer[MAX_PATH];
    ULONG64 pQueue;
    INT index = 0;
    CHAR * p;
   
    /* Make sure at least one argument, the queue pointer, is there. */
    if (!args || !(*args)) {
        PrintUsage(USAGE_CONNQ);
        return;
    }

    /* Copy the argument list into a temporary buffer. */
    strcpy(szArgBuffer, args);

    /* Peel out all of the tokenized strings. */
    for (p = mystrtok(szArgBuffer, " \t,"); p && *p; p = mystrtok(NULL, " \t,"))
        strcpy(&szArgList[index++][0], p);

    /* Tokenize the queue address looking for an index.  This will return 
       a pointer to the address whether an index exists or not. */
    p = mystrtok(szArgList[0], "[({");

    /* Get the address of the queue. */
    pQueue = (ULONG64)GetExpression(p);

    /* Look for the end of the address index.  If no index existed, this will return
       NULL.  If an index was given, this returns a string containing the index. */
    p = mystrtok(NULL, "])}");

    if (p) dwIndex = atoi(p);

    /* If a maximum number of entries to print was specified, get it. */
    if (index == 2) dwMaxEntries = atoi(&szArgList[1][0]);

    /* If too many arguments were given, complain. */
    if (index > 2) {
        PrintUsage(USAGE_CONNQ);
        return;
    }

    /* Print the NLB connection queue. */
    PrintQueue(pQueue, dwIndex, dwMaxEntries);
}

/*
 * Function: nlbglobalq
 * Description: This function prints out all connection descriptors in a given
 *              global (GLOBAL_CONN_QUEUE) queue of descriptors.
 * Author: Created by shouse, 4.15.01
 */
DECLARE_API (nlbglobalq) {
    ULONG dwMaxEntries = 10;
    ULONG dwIndex = 0;
    CHAR szArgList[10][MAX_PATH];
    CHAR szArgBuffer[MAX_PATH];
    ULONG64 pQueue;
    INT index = 0;
    CHAR * p;
   
    /* Make sure at least one argument, the queue pointer, is there. */
    if (!args || !(*args)) {
        PrintUsage(USAGE_CONNQ);
        return;
    }

    /* Copy the argument list into a temporary buffer. */
    strcpy(szArgBuffer, args);

    /* Peel out all of the tokenized strings. */
    for (p = mystrtok(szArgBuffer, " \t,"); p && *p; p = mystrtok(NULL, " \t,"))
        strcpy(&szArgList[index++][0], p);

    /* Tokenize the queue address looking for an index.  This will return 
       a pointer to the address whether an index exists or not. */
    p = mystrtok(szArgList[0], "[({");

    /* Get the address of the queue. */
    pQueue = (ULONG64)GetExpression(p);

    /* Look for the end of the address index.  If no index existed, this will return
       NULL.  If an index was given, this returns a string containing the index. */
    p = mystrtok(NULL, "])}");

    if (p) dwIndex = atoi(p);

    /* If a maximum number of entries to print was specified, get it. */
    if (index == 2) dwMaxEntries = atoi(&szArgList[1][0]);

    /* If too many arguments were given, complain. */
    if (index > 2) {
        PrintUsage(USAGE_GLOBALQ);
        return;
    }

    /* Print the NLB global connection queue. */
    PrintGlobalQueue(pQueue, dwIndex, dwMaxEntries);
}

/*
 * Function: nlbhash
 * Description: 
 * Author: Created by shouse, 4.15.01
 */
DECLARE_API (nlbhash) {
    CHAR szArgList[10][MAX_PATH];
    CHAR szArgBuffer[MAX_PATH];
    ULONG64 pContext;
    ULONG64 pPkt;
    INT index = 0;
    CHAR * p;
    ULONG dwValue;
    ULONG64 pParams;
   
    /* Make sure at least one argument, the queue pointer, is there. */
    if (!args || !(*args)) {
        PrintUsage(USAGE_HASH);
        return;
    }

    /* Get the address of the queue from the command line. */
    pContext = (ULONG64)GetExpression(args);

    /* Copy the argument list into a temporary buffer. */
    strcpy(szArgBuffer, args);

    /* Peel out all of the tokenized strings. */
    for (p = mystrtok(szArgBuffer, " \t,"); p && *p; p = mystrtok(NULL, " \t,"))
        strcpy(&szArgList[index++][0], p);

    /* If the wrong number of arguments were given, complain. */
    if (index != 2) {
        PrintUsage(USAGE_HASH);
        return;
    }

    /* Get the pointer to the NDIS packet from the second argument. */
    pPkt = (ULONG64)GetExpression(&szArgList[1][0]);

    /* Get the MAIN_CTXT_CODE from the structure to make sure that this address
       indeed points to a valid NLB context block. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CODE, dwValue);
    
    if (dwValue != MAIN_CTXT_CODE) {
        dprintf("  Error: Invalid NLB context block.  Wrong code found (0x%08x).\n", dwValue);
        return;
    } 

    /* Parse through the NDIS packet and retrieve the packet contents. */
    {
        UCHAR RawData[CVY_MAX_FRAME_SIZE + ETHER_HEADER_SIZE];
        ULONG BytesRead = 0;
        ULONG64 pHBData;
    
        /* Parse the buffers in the NDIS packet and get the raw packet data out.  We get
           a pointer to the heartbeat data in machine memory, not debugger process memory
           because for all other packets, we read from temporary stack space in the debugger
           - RawData - but for heartbeats, we read directly from kernel memory space (only
           because a function to do so already exits - no need to write another). */
        BytesRead = ParseNDISPacket(pPkt, RawData, CVY_MAX_FRAME_SIZE + ETHER_HEADER_SIZE, &pHBData);

        /* If some packet contents was successfully read, continue to process the packet. */
        if (BytesRead != 0) {
            NETWORK_DATA nd;

            /* Clear out the network data structure. */
            ZeroMemory(&nd, sizeof(nd));

            /* Get the pointer to the NLB parameters. */
            GetFieldOffset(MAIN_CTXT, MAIN_CTXT_FIELD_PARAMS, &dwValue);
            
            pParams = pContext + dwValue;
            
            /* Get the remote control port. */
            GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_REMOTE_CONTROL_PORT, dwValue);

            /* Set the remote control port in the network data block. */
            nd.UserRCPort = dwValue;

            /* Parse the Ethernet packet and store the information parsed in the NETWORK_DATA
               structure.  Note that this function recurses to also fill in IP, TCP/UDP, 
               heartbeat, remote control, etc. information as well. */
            PopulateEthernet(pHBData, RawData, BytesRead, &nd);
            
            /* Print the packet, including IP and TCP data (if present), or heartbeat 
               or remote control information, etc. */
            dprintf("NDIS Packet 0x%p\n", pPkt);
            PrintPacket(&nd);
            
            /* Now call into the filtering extension to determine the fate of this packet. */
            dprintf("\n");
            PrintHash(pContext, &nd);
        }
    }
}

/*
 * Function: nlbfilter
 * Description: This function will perform the NLB hashing algorithm to determine
 *              whether a given packet - identified by a (Src IP, Src port, Dst IP,
 *              Dst port) tuple would be handled by this host or another host.
 *              Further, if the connection is a known TCP connection, the associated
 *              descriptor and state information are displayed.
 * Author: Created by shouse, 1.11.02
 */
DECLARE_API (nlbfilter) {
    CHAR szArgList[10][MAX_PATH];
    CHAR szArgBuffer[MAX_PATH];
    UCHAR cFlags = NLB_FILTER_FLAGS_CONN_DATA;
    ULONG64 pLoad;
    ULONG dwClientIPAddress;
    ULONG dwClientPort;
    ULONG dwServerIPAddress;
    ULONG dwServerPort;
    USHORT wProtocol;
    INT index = 0;
    CHAR * p;
   
    /* Make sure that the load pointer is there. */
    if (!args || !(*args)) {
        PrintUsage(USAGE_FILTER);
        return;
    }

    /* Get the address of the load module from the command line. */
    pLoad = (ULONG64)GetExpression(args);

    /* Copy the argument list into a temporary buffer. */
    strcpy(szArgBuffer, args);

    /* Peel out all of the tokenized strings. */
    for (p = mystrtok(szArgBuffer, " \t,"); p && *p; p = mystrtok(NULL, " \t,"))
        strcpy(&szArgList[index++][0], p);

    /* If too many arguments were given, complain. */
    if ((index > 5) || (index < 4)) {
        PrintUsage(USAGE_FILTER);
        return;
    }

    /* Find the protocol specification. */
    if (!_stricmp(szArgList[1], "TCP")) {
        wProtocol = TCPIP_PROTOCOL_TCP;
    } else if (!_stricmp(szArgList[1], "UDP")) {
        wProtocol = TCPIP_PROTOCOL_UDP;
    } else if (!_stricmp(szArgList[1], "IPSec")) {
        wProtocol = TCPIP_PROTOCOL_IPSEC1;
    } else if (!_stricmp(szArgList[1], "PPTP")) {
        wProtocol = TCPIP_PROTOCOL_PPTP;
    } else if (!_stricmp(szArgList[1], "GRE")) {
        wProtocol = TCPIP_PROTOCOL_GRE;
    } else if (!_stricmp(szArgList[1], "ICMP")) {
        wProtocol = TCPIP_PROTOCOL_ICMP;
    } else {
        dprintf("Invalid protocol: %s\n", szArgList[1]);
        return;
    }

    /* The client port defaults to unspecified. */
    dwClientPort = 0;

    /* If we find a colon in the client specification, then we expect that
       its an IP:port specification. */
    p = strchr(szArgList[2], ':');

    /* If we found the port string, separate the IP from the string with 
       a NUL character and extract the port value. */
    if (p != NULL) {
        *p = UNICODE_NULL;
        p++;            

        dwClientPort = atoi(p);

        /* Make sure the port is between 1 and 65535. */
        if ((dwClientPort == 0) || (dwClientPort > CVY_MAX_PORT)) {
            dprintf("Invalid port: %s\n", dwClientPort);
            return;
        }        
    }

    /* If we find a '.' in the IP address, then we need to convert it using inet_addr.  
       If there is no '.', then we assume its already a DWORD in network byte order. */
    if (strchr(szArgList[2], '.'))
        dwClientIPAddress = inet_addr(szArgList[2]);
    else
        dwClientIPAddress = (ULONG)GetExpression(&szArgList[2][0]);

    /* The server port defaults to unspecified. */
    dwServerPort = 0;

    /* If we find a colon in the server specification, then we expect that
       its an IP:port specification. */
    p = strchr(szArgList[3], ':');

    /* If we found the port string, separate the IP from the string with 
       a NUL character and extract the port value. */
    if (p != NULL) {
        *p = UNICODE_NULL;
        p++;            

        dwServerPort = atoi(p);

        /* Make sure the port is between 1 and 65535. */
        if ((dwServerPort == 0) || (dwServerPort > CVY_MAX_PORT)) {
            dprintf("Invalid port: %s\n", dwServerPort);
            return;
        }
    }

    /* If we find a '.' in the IP address, then we need to convert it using inet_addr.  
       If there is no '.', then we assume its already a DWORD in network byte order. */
    if (strchr(szArgList[3], '.'))
        dwServerIPAddress = inet_addr(szArgList[3]);
    else
        dwServerIPAddress = (ULONG)GetExpression(&szArgList[3][0]);

    cFlags = NLB_FILTER_FLAGS_CONN_DATA;

    /* If an seventh argument has been specified, it is TCP packet type, which should be SYN, DATA, FIN or RST. */
    if (index >= 5) {
        if (!_stricmp(szArgList[4], "SYN")) {
            cFlags |= NLB_FILTER_FLAGS_CONN_UP;
        } else if (!_stricmp(szArgList[4], "FIN")) {
            cFlags |= NLB_FILTER_FLAGS_CONN_DOWN;
        } else if (!_stricmp(szArgList[4], "RST")) {
            cFlags |= NLB_FILTER_FLAGS_CONN_RESET;
        } else {
            dprintf("Invalid connection flags: %s\n", szArgList[4]);
            return;
        }
    }

    switch (wProtocol) {
    case TCPIP_PROTOCOL_TCP:

        if (dwServerPort == 0) {
            dprintf("A server port is required\n");
            return;
        }

        if (dwClientPort == 0)
        {
            if ((cFlags == NLB_FILTER_FLAGS_CONN_DOWN) || 
                (cFlags == NLB_FILTER_FLAGS_CONN_RESET))
            {
                dprintf("RST/FIN filtering requires a client port\n");
                return;
            }       
            else
            {
                cFlags = NLB_FILTER_FLAGS_CONN_UP;
            }
        }

        if (dwServerPort != PPTP_CTRL_PORT)
        {
            break;
        }

        wProtocol = TCPIP_PROTOCOL_PPTP;

        /* This fall-through is INTENTIONAL.  In this case, we're verified the TCP
           parameters, but discovered that because the server port was 1723, this
           is actually PPTP, so force it through the PPTP verification as well. */
    case TCPIP_PROTOCOL_PPTP:

        dwServerPort = PPTP_CTRL_PORT;

        if (dwClientPort == 0)
        {
            if ((cFlags == NLB_FILTER_FLAGS_CONN_DOWN) || 
                (cFlags == NLB_FILTER_FLAGS_CONN_RESET))
            {
                dprintf("RST/FIN filtering requires a client port\n");
                return;
            }       
            else
            {
                cFlags = NLB_FILTER_FLAGS_CONN_UP;
            }
        }

        break;
    case TCPIP_PROTOCOL_UDP:

        if (dwServerPort == 0)
        {
            dprintf("A server port is required\n");
            return;
        }

        if ((dwServerPort != IPSEC_CTRL_PORT) && (dwServerPort != IPSEC_NAT_PORT))
        {
            if (cFlags != NLB_FILTER_FLAGS_CONN_DATA)
            {
                dprintf("Connection flags are not valid for UDP packets\n");
                return;
            }

            break;
        }

        wProtocol = TCPIP_PROTOCOL_IPSEC1;

        /* This fall-through is INTENTIONAL.  In this case, we're verified the TCP
           parameters, but discovered that because the server port was 1723, this
           is actually PPTP, so force it through the PPTP verification as well. */
    case TCPIP_PROTOCOL_IPSEC1:
            
        if (dwServerPort == 0)
        {
            dwServerPort = IPSEC_CTRL_PORT;
        }

        if (dwServerPort == IPSEC_CTRL_PORT)
        {
            if (dwClientPort == 0)
            {
                dwClientPort = IPSEC_CTRL_PORT;
            }

            if (dwClientPort != IPSEC_CTRL_PORT)
            {
                dprintf("IPSec packets destined for server port 500 must originate from client port 500\n");
                return;
            }
        }
        else if (dwServerPort == IPSEC_NAT_PORT)
        {
            if (dwClientPort == 0)
            {
                dprintf("A client port is required\n");
                return;
            }
        }
        else
        {
            dprintf("IPSec packets are always destined for either port 500 or 4500\n");
            return;
        }

        break;
    case TCPIP_PROTOCOL_GRE:

        if (cFlags != NLB_FILTER_FLAGS_CONN_DATA)
        {
            dprintf("Connection flags are not valid for GRE packets\n");
            return;
        }

        dwServerPort = PPTP_CTRL_PORT;
        dwClientPort = PPTP_CTRL_PORT;

        break;
    case TCPIP_PROTOCOL_ICMP:

        if (cFlags != NLB_FILTER_FLAGS_CONN_DATA)
        {
            dprintf("Connection flags are not valid for ICMP packets\n");
            return;
        }

        dwServerPort = 0;
        dwClientPort = 0;

        break;
    default:
        return;
    }

    /* Hash on this tuple and print the results. */
    PrintFilter(pLoad, dwClientIPAddress, dwClientPort, dwServerIPAddress, dwServerPort, wProtocol, cFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbkd\packet.c ===
/*
 * File: nlbkd.c
 * Description: This file contains the implementation of the utility functions
 *              to populate the NLB KD network packet structures used to print
 *              out the contents of a given network packet.
 *              
 * Author: Created by shouse, 12.20.01
 */

#include "nlbkd.h"
#include "utils.h"
#include "print.h"
#include "packet.h"
#include "load.h"

/*
 * Function: PopulateRemoteControl
 * Description: Stores properties of a remote control packet for subsequent printing.
 * Args: PUCHAR        RawData    - pointer to a byte array that we will read from
 *       ULONG         ulBufLen   - size of the data array in bytes
 *       ULONG         ulStartUDP - location in data array where the UDP header begins
 *       PNETWORK_DATA pnd        - data structure where extracted properties are stored
 * Author: Created by chrisdar  2001.11.02
 */
VOID PopulateRemoteControl(PUCHAR RawData, ULONG ulBufLen, ULONG ulStartRC, PNETWORK_DATA pnd)
{
    ULONG   ulValue   = 0;
    PCHAR   pszStruct = NULL;
    PCHAR   pszMember = NULL;

    if (ulBufLen < ulStartRC + NLB_REMOTE_CONTROL_MIN_NEEDED_SIZE)
    {
        /* Mark the packet invalid. */
        pnd->bValid = FALSE;

        dprintf("Remote control packet is not the minimum required length.\n");
        return;
    }

    //
    // Get the relative positions of quantities in IOCTL_REMOTE_HDR
    //
    pszStruct = IOCTL_REMOTE_HDR;

    pszMember = IOCTL_REMOTE_HDR_CODE;
    if (!GetFieldOffset(pszStruct, pszMember, &ulValue))
    {
        ulValue += ulStartRC;
        CopyMemory(&(pnd->RCCode), &(RawData[ulValue]), sizeof(pnd->RCCode));
    }
    else
    {
        dprintf("Error reading field offset of %s in structure %s\n", pszMember, pszStruct);
    }

    pszMember = IOCTL_REMOTE_HDR_VERSION;
    if (!GetFieldOffset(pszStruct, pszMember, &ulValue))
    {
        ulValue += ulStartRC;
        CopyMemory(&(pnd->RCVersion), &(RawData[ulValue]), sizeof(pnd->RCVersion));
    }
    else
    {
        dprintf("Error reading field offset of %s in structure %s\n", pszMember, pszStruct);
    }

    pszMember = IOCTL_REMOTE_HDR_HOST;
    if (!GetFieldOffset(pszStruct, pszMember, &ulValue))
    {
        ulValue += ulStartRC;
        CopyMemory(&(pnd->RCHost), &(RawData[ulValue]), sizeof(pnd->RCHost));
    }
    else
    {
        dprintf("Error reading field offset of %s in structure %s\n", pszMember, pszStruct);
    }

    pszMember = IOCTL_REMOTE_HDR_CLUSTER;
    if (!GetFieldOffset(pszStruct, pszMember, &ulValue))
    {
        ulValue += ulStartRC;
        CopyMemory(&(pnd->RCCluster), &(RawData[ulValue]), sizeof(pnd->RCCluster));
    }
    else
    {
        dprintf("Error reading field offset of %s in structure %s\n", pszMember, pszStruct);
    }

    pszMember = IOCTL_REMOTE_HDR_ADDR;
    if (!GetFieldOffset(pszStruct, pszMember, &ulValue))
    {
        ulValue += ulStartRC;
        CopyMemory(&(pnd->RCAddr), &(RawData[ulValue]), sizeof(pnd->RCAddr));
    }
    else
    {
        dprintf("Error reading field offset of %s in structure %s\n", pszMember, pszStruct);
    }

    pszMember = IOCTL_REMOTE_HDR_ID;
    if (!GetFieldOffset(pszStruct, pszMember, &ulValue))
    {
        ulValue += ulStartRC;
        CopyMemory(&(pnd->RCId), &(RawData[ulValue]), sizeof(pnd->RCId));
    }
    else
    {
        dprintf("Error reading field offset of %s in structure %s\n", pszMember, pszStruct);
    }

    pszMember = IOCTL_REMOTE_HDR_IOCTRL;
    if (!GetFieldOffset(pszStruct, pszMember, &ulValue))
    {
        ulValue += ulStartRC;
        CopyMemory(&(pnd->RCIoctrl), &(RawData[ulValue]), sizeof(pnd->RCIoctrl));
    }
    else
    {
        dprintf("Error reading field offset of %s in structure %s\n", pszMember, pszStruct);
    }

    return;
}

/*
 * Function: PopulateICMP
 * Description: Stores properties of a remote control packet for subsequent printing.
 * Args: PUCHAR        RawData     - pointer to a byte array that we will read from
 *       ULONG         ulBufLen    - size of the data array in bytes
 *       ULONG         ulStartICMP - location in data array where the ICMP header begins
 *       PNETWORK_DATA pnd         - data structure where extracted properties are stored
 * Author: Created by chrisdar  2001.11.02
 */
VOID PopulateICMP(PUCHAR RawData, ULONG ulBufLen, ULONG ulStartICMP, PNETWORK_DATA pnd)
{
//
// Just a stub for now. There is nothing in the payload that we are currently interested in.
//
}

/*
 * Function: PopulateIGMP
 * Description: Stores properties of a remote control packet for subsequent printing.
 * Args: PUCHAR        RawData     - pointer to a byte array that we will read from
 *       ULONG         ulBufLen    - size of the data array in bytes
 *       ULONG         ulStartIGMP - location in data array where the IGMP header begins
 *       PNETWORK_DATA pnd         - data structure where extracted properties are stored
 * Author: Created by chrisdar  2001.11.02
 */
VOID PopulateIGMP(PUCHAR RawData, ULONG ulBufLen, ULONG ulStartIGMP, PNETWORK_DATA pnd)
{
    if (ulBufLen < ulStartIGMP + IGMP_HEADER_AND_PAYLOAD_SIZE)
    {
        /* Mark the packet invalid. */
        pnd->bValid = FALSE;

        dprintf("IGMP packet is not the minimum required length.\n");
        return;
    }

    pnd->IGMPVersion = (RawData[ulStartIGMP + IGMP_OFFSET_VERSION_AND_TYPE] & 0xF0) >> 4; // Shift down 4 bits since we want the value in the upper byte.
    pnd->IGMPType    =  RawData[ulStartIGMP + IGMP_OFFSET_VERSION_AND_TYPE] & 0x0F;

    CopyMemory(&(pnd->IGMPGroupIPAddr), &(RawData[ulStartIGMP + IGMP_OFFSET_GROUP_IP_ADDR]), sizeof(pnd->IGMPGroupIPAddr));
}

/*
 * Function: PopulateTCP
 * Description: Stores properties of a remote control packet for subsequent printing.
 * Args: PUCHAR        RawData    - pointer to a byte array that we will read from
 *       ULONG         ulBufLen   - size of the data array in bytes
 *       ULONG         ulStartTCP - location in data array where the TCP header begins
 *       PNETWORK_DATA pnd        - data structure where extracted properties are stored
 * Author: Created by chrisdar  2001.11.02
 */
VOID PopulateTCP(PUCHAR RawData, ULONG ulBufLen, ULONG ulStartTCP, PNETWORK_DATA pnd)
{
    if (ulBufLen < ulStartTCP + TCP_MIN_HEADER_SIZE)
    {
        /* Mark the packet invalid. */
        pnd->bValid = FALSE;

        dprintf("TCP header is not the minimum required length.\n");
        return;
    }

    pnd->SourcePort = (RawData[ulStartTCP + TCP_OFFSET_SOURCE_PORT_START] << 8) +
                       RawData[ulStartTCP + TCP_OFFSET_SOURCE_PORT_START + 1];

    pnd->DestPort   = (RawData[ulStartTCP + TCP_OFFSET_DEST_PORT_START] << 8) +
                       RawData[ulStartTCP + TCP_OFFSET_DEST_PORT_START + 1];

    pnd->TCPSeqNum  = (RawData[ulStartTCP + TCP_OFFSET_SEQUENCE_NUM_START]     << 24) +
                      (RawData[ulStartTCP + TCP_OFFSET_SEQUENCE_NUM_START + 1] << 16) +
                      (RawData[ulStartTCP + TCP_OFFSET_SEQUENCE_NUM_START + 2] << 8) +
                       RawData[ulStartTCP + TCP_OFFSET_SEQUENCE_NUM_START + 3];

    pnd->TCPAckNum  = (RawData[ulStartTCP + TCP_OFFSET_ACK_NUM_START]     << 24) +
                      (RawData[ulStartTCP + TCP_OFFSET_ACK_NUM_START + 1] << 16) +
                      (RawData[ulStartTCP + TCP_OFFSET_ACK_NUM_START + 2] << 8) +
                       RawData[ulStartTCP + TCP_OFFSET_ACK_NUM_START + 3];

    pnd->TCPFlags   =  RawData[ulStartTCP + TCP_OFFSET_FLAGS] & 0x3F; // Masked with 3F because only the first 6 bits in the word correspond to the TCP flags
}

/*
 * Function: PopulateUDP
 * Description: Stores properties of a remote control packet for subsequent printing.
 * Args: PUCHAR        RawData    - pointer to a byte array that we will read from
 *       ULONG         ulBufLen   - size of the data array in bytes
 *       ULONG         ulStartUDP - location in data array where the UDP header begins
 *       PNETWORK_DATA pnd        - data structure where extracted properties are stored
 * Author: Created by chrisdar  2001.11.02
 */
VOID PopulateUDP(PUCHAR RawData, ULONG ulBufLen, ULONG ulStartUDP, PNETWORK_DATA pnd)
{
    ULONG   ulRCCode;
    BOOL    bIsRCSource;
    BOOL    bIsRCDest;

    if (ulBufLen < ulStartUDP + UDP_HEADER_SIZE)
    {
        /* Mark the packet invalid. */
        pnd->bValid = FALSE;

        dprintf("UDP header is not the minimum required length.\n");
        return;
    }

    pnd->SourcePort = (RawData[ulStartUDP + UDP_OFFSET_SOURCE_PORT_START] << 8) +
                       RawData[ulStartUDP + UDP_OFFSET_SOURCE_PORT_START + 1];
    pnd->DestPort   = (RawData[ulStartUDP + UDP_OFFSET_DEST_PORT_START] << 8) +
                       RawData[ulStartUDP + UDP_OFFSET_DEST_PORT_START + 1];

    //
    // Is this a remote control packet?
    //
    pnd->RemoteControl = NLB_RC_PACKET_NO;
    bIsRCSource = (CVY_DEF_RCT_PORT_OLD == pnd->SourcePort) || (pnd->UserRCPort == pnd->SourcePort);
    bIsRCDest   = (CVY_DEF_RCT_PORT_OLD == pnd->DestPort)   || (pnd->UserRCPort == pnd->DestPort);
    if (bIsRCSource || bIsRCDest)
    {
//    if (CVY_DEF_RCT_PORT_OLD == pnd->SourcePort || CVY_DEF_RCT_PORT_OLD == pnd->DestPort ||
//        pnd->UserRCPort      == pnd->SourcePort || pnd->UserRCPort      == pnd->DestPort)
//    {
        //
        // Read first 4 bytes of UDP payload, which is where the remote control
        // code will be if this is a remote control packet
        //
        CopyMemory(&ulRCCode, &(RawData[ulStartUDP + UDP_OFFSET_PAYLOAD_START]), sizeof(ulRCCode));

        if (IOCTL_REMOTE_CODE == ulRCCode)
        {
            //
            // Yes, it is remote control.
            //
//            pnd->IsRemoteControl = TRUE;

            //
            // Is it a request or a reply?
            //
            if (bIsRCSource && bIsRCDest)
            {
                // Ambiguous
                pnd->RemoteControl = NLB_RC_PACKET_AMBIGUOUS;
            }
            else if (bIsRCSource)
            {
                // Request
                pnd->RemoteControl = NLB_RC_PACKET_REPLY;
            }
            else if (bIsRCDest)
            {
                // Reply
                pnd->RemoteControl = NLB_RC_PACKET_REQUEST;
            }

            PopulateRemoteControl(RawData, ulBufLen, ulStartUDP + UDP_HEADER_SIZE, pnd);
        }
    } else if (pnd->DestPort == IPSEC_CTRL_PORT) {
        /* Look for IPSec SYN equivalents - Initial Contact Main Mode Security Associations. */
        PopulateIPSecControl(RawData, ulBufLen, ulStartUDP + UDP_HEADER_SIZE, pnd);
    }
}

/*
 * Function: PopulateGRE
 * Description: Stores properties of a remote control packet for subsequent printing.
 * Args: PUCHAR        RawData    - pointer to a byte array that we will read from
 *       ULONG         ulBufLen   - size of the data array in bytes
 *       ULONG         ulStartGRE - location in data array where the GRE header begins
 *       PNETWORK_DATA pnd        - data structure where extracted properties are stored
 * Author: Created by chrisdar  2001.11.02
 */
VOID PopulateGRE(PUCHAR RawData, ULONG ulBufLen, ULONG ulStartGRE, PNETWORK_DATA pnd)
{
//
// Just a stub for now. There is nothing in the payload that we are currently interested in.
//
}

/*
 * Function: PopulateIPSec
 * Description: Stores properties of a remote control packet for subsequent printing.
 * Args: PUCHAR        RawData      - pointer to a byte array that we will read from
 *       ULONG         ulBufLen     - size of the data array in bytes
 *       ULONG         ulStartIPSec - location in data array where the IPSec header begins
 *       PNETWORK_DATA pnd          - data structure where extracted properties are stored
 * Author: Created by chrisdar  2001.11.02
 */
VOID PopulateIPSec(PUCHAR RawData, ULONG ulBufLen, ULONG ulStartIPSec, PNETWORK_DATA pnd)
{
//
// Just a stub for now. There is nothing in the payload that we are currently interested in.
//
}

/*
 * Function: PopulateIPSecControl
 * Description: Stores properties of a remote control packet for subsequent printing.
 * Args: PUCHAR        RawData      - pointer to a byte array that we will read from
 *       ULONG         ulBufLen     - size of the data array in bytes
 *       ULONG         ulStartIPSec - location in data array where the IPSec header begins
 *       PNETWORK_DATA pnd          - data structure where extracted properties are stored
 * Author: Created by shouse, 1.13.02
 */
VOID PopulateIPSecControl(PUCHAR RawData, ULONG ulBufLen, ULONG ulStartIPSec, PNETWORK_DATA pnd)
{
    /* Pointer to the IKE header. */
    PIPSEC_ISAKMP_HDR  pISAKMPHeader = (PIPSEC_ISAKMP_HDR)&RawData[ulStartIPSec];
    /* Pointer to the subsequent generic payloads in the IKE packet. */
    PIPSEC_GENERIC_HDR pGenericHeader;                   

    /* The initiator cookie - should be non-zero if this is really an IKE packet. */
    UCHAR              EncapsulatedIPSecICookie[IPSEC_ISAKMP_HEADER_ICOOKIE_LENGTH] = IPSEC_ISAKMP_ENCAPSULATED_IPSEC_ICOOKIE;    
    /* The Microsoft client vendor ID - used to determine whether or not the client supports initial contact notification. */
    UCHAR              VIDMicrosoftClient[IPSEC_VENDOR_HEADER_VENDOR_ID_LENGTH] = IPSEC_VENDOR_ID_MICROSOFT;      

    /* Whether or not we've determined the client to be compatible. */                                                                                                                      
    BOOLEAN            bInitialContactEnabled = FALSE;
    /* Whether or not this is indeed an initial contact. */
    BOOLEAN            bInitialContact = FALSE;

    /* The length of the IKE packet. */            
    ULONG              cISAKMPPacketLength;
    /* The next payload code in the IKE payload chain. */  
    UCHAR              NextPayload;
    /* The number of bytes from the beginning of the IKE header to the end of the available buffer. */
    ULONG              cUDPDataLength;
    /* A re-usable length parameter. */
    ULONG              cLength;

    /* Assume its not an initial contact for now. */
    pnd->IPSecInitialContact = FALSE;

    /* The number of bytes left is the length of the buffer, minus the beginning of the IKE header. */
    cUDPDataLength = ulBufLen - ulStartIPSec;

    /* The UDP data should be at least as long as the initiator cookie.  If the packet is 
       UDP encapsulated IPSec, then the I cookie will be 0 to indicate such. */
    if (cUDPDataLength < IPSEC_ISAKMP_HEADER_ICOOKIE_LENGTH)
        return;

    /* Calculate the size of the ICookie. */
    cLength = sizeof(UCHAR) * IPSEC_ISAKMP_HEADER_ICOOKIE_LENGTH;

    /* Need to check the init cookie, which will distinguish clients behind a NAT, 
       which also send their IPSec (ESP) traffic to UDP port 500.  If the I cookie
       is zero, then this is NOT an IKE packet. */
    if (cLength == RtlCompareMemory((PVOID)IPSEC_ISAKMP_GET_ICOOKIE_POINTER(pISAKMPHeader), (PVOID)&EncapsulatedIPSecICookie[0], cLength))
        return;

    /* At this point, this packet should be IKE, so the UDP data should be at least 
       as long as an ISAKMP header. */
    if (cUDPDataLength < IPSEC_ISAKMP_HEADER_LENGTH)
        return;

    /* Get the total length of the IKE packet from the ISAKMP header. */
    cISAKMPPacketLength = IPSEC_ISAKMP_GET_PACKET_LENGTH(pISAKMPHeader);

    /* The IKE packet should be at least as long as an ISAKMP header (a whole lot longer, actually). */
    if (cISAKMPPacketLength < IPSEC_ISAKMP_HEADER_LENGTH)
        return;

    /* Sanity check - the UDP data length and IKE packet length SHOULD be the same, unless the packet 
       is fragmented.  If it is, then we can only look into the packet as far as the UDP data length. 
       If that's not far enough for us to find what we need, then we might miss an initial contact 
       main mode SA; the consequence of which is that we might not accept this connection if we are
       in non-optimized mode, because we'll treat this like data, which requires a descriptor lookup -
       if this is an initial contact, chances are great that no descriptor will exist and all hosts 
       in the cluster will drop the packet. */
    if (cUDPDataLength < cISAKMPPacketLength)
        /* Only look as far as the end of the UDP packet. */
        cISAKMPPacketLength = cUDPDataLength;

    /* Get the first payload type out of the ISAKMP header. */
    NextPayload = IPSEC_ISAKMP_GET_NEXT_PAYLOAD(pISAKMPHeader);

    /* IKE security associations are identified by a payload type byte in the header.
       Check that first - this does not ensure that this is what we are looking for 
       because this check will not exclude, for instance, main mode re-keys. */
    if (NextPayload != IPSEC_ISAKMP_SA)
        return;

    /* Calculate a pointer to the fist generic payload, which is directly after the ISAKMP header. */
    pGenericHeader = (PIPSEC_GENERIC_HDR)((PUCHAR)pISAKMPHeader + IPSEC_ISAKMP_HEADER_LENGTH);

    /* We are looping through the generic payloads looking for the vendor ID and/or notify information. */
    while ((PUCHAR)pGenericHeader <= ((PUCHAR)pISAKMPHeader + cISAKMPPacketLength - IPSEC_GENERIC_HEADER_LENGTH)) {
        /* Extract the payload length from the generic header. */
        USHORT cPayloadLength = IPSEC_GENERIC_GET_PAYLOAD_LENGTH(pGenericHeader);

        /* Not all clients are going to support this (in fact, only the Microsoft client
           will support it, so we need to first see what the vendor ID of the client is.
           if it is a Microsoft client that supports the initial contact vendor ID, then
           we'll look for the initial contact, which provides better stickiness for IPSec
           connections.  If either the client is non-MS, or if it is not a version that
           supports initial contact, then we can revert to the "second-best" solution, 
           which is to provide stickiness _between_ Main Mode SAs.  This means that if a
           client re-keys their Main Mode session, they _may_ be rebalanced to another
           server.  This is still better than the old UDP implementation, but the only
           way to provide full session support for IPSec (without the distributed session
           table nightmare) is to be able to distinguish initial Main Mode SAs from sub-
           sequent Main Mode SAs (re-keys). */
        if (NextPayload == IPSEC_ISAKMP_VENDOR_ID) {
            PIPSEC_VENDOR_HDR pVendorHeader = (PIPSEC_VENDOR_HDR)pGenericHeader;

            /* Make sure that the vendor ID payload is at least as long as a vendor ID. */
            if (cPayloadLength < (IPSEC_GENERIC_HEADER_LENGTH + IPSEC_VENDOR_HEADER_VENDOR_ID_LENGTH))
                return;

            /* Calculate the size of the Vendor ID. */
            cLength = sizeof(UCHAR) * IPSEC_VENDOR_HEADER_VENDOR_ID_LENGTH;

            /* Look for the Microsoft client vendor ID.  If it is the right version, then we know that 
               the client is going to appropriately set the initial contact information, allowing NLB
               to provide the best possible support for session stickiness. */
            if (cLength == RtlCompareMemory((PVOID)IPSEC_VENDOR_ID_GET_ID_POINTER(pVendorHeader), (PVOID)&VIDMicrosoftClient[0], cLength)) {
                /* Make sure that their is a version number attached to the Microsoft Vendor ID.  Not 
                   all vendor IDs have versions attached, but the Microsoft vendor ID should. */
                if (cPayloadLength < (IPSEC_GENERIC_HEADER_LENGTH + IPSEC_VENDOR_ID_PAYLOAD_LENGTH))
                    return;

                if (IPSEC_VENDOR_ID_GET_VERSION(pVendorHeader) >= IPSEC_VENDOR_ID_MICROSOFT_MIN_VERSION) {
                    /* Microsoft clients whose version is greater than or equal to 4 will support
                       initial contact.  Non-MS clients, or old MS clients will not, so they 
                       receive decent, but not guaranteed sitckines, based solely on MM SAs. */
                    bInitialContactEnabled = TRUE;
                }
            }
        } else if (NextPayload == IPSEC_ISAKMP_NOTIFY) {
            PIPSEC_NOTIFY_HDR pNotifyHeader = (PIPSEC_NOTIFY_HDR)pGenericHeader;

            /* Make sure that the notify payload is the correct length. */
            if (cPayloadLength < (IPSEC_GENERIC_HEADER_LENGTH + IPSEC_NOTIFY_PAYLOAD_LENGTH))
                return;

            if (IPSEC_NOTIFY_GET_NOTIFY_MESSAGE(pNotifyHeader) == IPSEC_NOTIFY_INITIAL_CONTACT) {
                /* This is an initial contact notification from the client, which means that this is
                   the first time that the client has contacted this server; more precisely, the client
                   currently has no state associated with this peer.  NLB will "re-balance" on initial 
                   contact notifications, but not other Main Mode key exchanges as long as it can 
                   determine that the client will comply with initial contact notification. */
                bInitialContact = TRUE;
            }
        }

        /* Get the next payload type out of the generic header. */
        NextPayload = IPSEC_GENERIC_GET_NEXT_PAYLOAD(pGenericHeader);
        
        /* Calculate a pointer to the next generic payload. */
        pGenericHeader = (PIPSEC_GENERIC_HDR)((PUCHAR)pGenericHeader + cPayloadLength);
    }

    /* If the vendor ID did not indicate that this client supports initial contact notification,
       then mark this as an IC MMSA, and we go with the less-than-optimal solution of treating Main 
       Mode SAs as the connection boundaries, which potentially breaks sessions on MM SA re-keys. */
    if (!bInitialContactEnabled) {
        pnd->IPSecInitialContact = TRUE;
        return;
    }

    /* If this was a Main Mode SA from a client that supports initial contact, but did not
       specify the initial contact vendor ID, then this is a re-key for an existing session. */
    if (!bInitialContact)
        return;

    /* We have found an Initial Contact Main Mode Security Association. */
    pnd->IPSecInitialContact = TRUE;
}

/*
 * Function: PopulateIP
 * Description: Stores properties of a remote control packet for subsequent printing.
 * Args: PUCHAR        RawData   - pointer to a byte array that we will read from
 *       ULONG         ulBufLen  - size of the data array in bytes
 *       ULONG         ulStartIP - location in data array where the IP header begins
 *       PNETWORK_DATA pnd       - data structure where extracted properties are stored
 * Author: Created by chrisdar  2001.11.02
 */
VOID PopulateIP(PUCHAR RawData, ULONG ulBufLen, ULONG ulStart, PNETWORK_DATA pnd)
{
    if (ulBufLen < ulStart + IP_MIN_HEADER_SIZE)
    {
        /* Mark the packet invalid. */
        pnd->bValid = FALSE;

        dprintf("IP header is not the minimum required length.\n");
        return;
    }

    pnd->HeadLen = (RawData[ulStart + IP_OFFSET_HEADER_LEN] & 0xF)*4;  // *4 because the header stores the number of 32-bit words

    pnd->TotLen = (RawData[ulStart + IP_OFFSET_TOTAL_LEN] << 8) + 
                   RawData[ulStart + IP_OFFSET_TOTAL_LEN + 1];
//    CopyMemory(&(pnd->TotLen), &(RawData[ulStart + IP_OFFSET_TOTAL_LEN]), sizeof(pnd->TotLen));

    pnd->Protocol = RawData[ulStart + IP_OFFSET_PROTOCOL];

    CopyMemory(&(pnd->SourceIPAddr), &(RawData[ulStart + IP_OFFSET_SOURCE_IP]), sizeof(pnd->SourceIPAddr));
    
    CopyMemory(&(pnd->DestIPAddr), &(RawData[ulStart + IP_OFFSET_DEST_IP]), sizeof(pnd->DestIPAddr));
    
    switch((int) pnd->Protocol)
    {
    case TCPIP_PROTOCOL_ICMP:
        PopulateICMP(RawData, ulBufLen, ulStart + pnd->HeadLen, pnd);
        break;
    case TCPIP_PROTOCOL_IGMP:
        PopulateIGMP(RawData, ulBufLen, ulStart + pnd->HeadLen, pnd);
        break;
    case TCPIP_PROTOCOL_TCP:
        PopulateTCP(RawData, ulBufLen, ulStart + pnd->HeadLen, pnd);
        break;
    case TCPIP_PROTOCOL_UDP:
        PopulateUDP(RawData, ulBufLen, ulStart + pnd->HeadLen, pnd);
        break;
    case TCPIP_PROTOCOL_GRE:
        PopulateGRE(RawData, ulBufLen, ulStart + pnd->HeadLen, pnd);
        break;
    case TCPIP_PROTOCOL_IPSEC1:
    case TCPIP_PROTOCOL_IPSEC2:
        PopulateIPSec(RawData, ulBufLen, ulStart + pnd->HeadLen, pnd);
        break;
    }
}

/*
 * Function: PopulateARP
 * Description: Stores properties of a remote control packet for subsequent printing.
 * Args: PUCHAR        RawData    - pointer to a byte array that we will read from
 *       ULONG         ulBufLen   - size of the data array in bytes
 *       ULONG         ulStartARP - location in data array where the ARP header begins
 *       PNETWORK_DATA pnd        - data structure where extracted properties are stored
 * Author: Created by chrisdar  2001.11.02
 */
VOID PopulateARP(PUCHAR RawData, ULONG ulBufLen, ULONG ulStart, PNETWORK_DATA pnd)
{
    if (ulBufLen < ulStart + ARP_HEADER_AND_PAYLOAD_SIZE)
    {
        /* Mark the packet invalid. */
        pnd->bValid = FALSE;

        dprintf("ARP packet is not the minimum required length.\n");
        return;
    }

    CopyMemory(&(pnd->ARPSenderMAC), &(RawData[ulStart + ARP_OFFSET_SENDER_MAC]) , sizeof(pnd->ARPSenderMAC));
    CopyMemory(&(pnd->ARPSenderIP) , &(RawData[ulStart + ARP_OFFSET_SENDER_IP]), sizeof(pnd->ARPSenderIP));
    CopyMemory(&(pnd->ARPTargetMAC), &(RawData[ulStart + ARP_OFFSET_TARGET_MAC]), sizeof(pnd->ARPTargetMAC));
    CopyMemory(&(pnd->ARPTargetIP) , &(RawData[ulStart + ARP_OFFSET_TARGET_IP]), sizeof(pnd->ARPTargetIP));
}

/*
 * Function: PopulateNLBHeartbeat
 * Description: Stores properties of a remote control packet for subsequent printing.
 * Args: ULONG64       pPkt     - pointer to the original data structure in memory of the host being debugged.
 *       PUCHAR        RawData  - pointer to a byte array that we will read from
 *       ULONG         ulBufLen - size of the data array in bytes
 *       ULONG         ulStart  - location in data array where the heartbeat data begins
 *       PNETWORK_DATA pnd      - data structure where extracted properties are stored
 * Author: Created by chrisdar  2001.11.02
 */
VOID PopulateNLBHeartbeat(ULONG64 pPkt, PUCHAR RawData, ULONG ulBufLen, ULONG ulStart, PNETWORK_DATA pnd)
{
    ULONG   ulValue   = 0;
    PCHAR   pszStruct = NULL;
    PCHAR   pszMember = NULL;

    //
    // Use this to print out heartbeat details by calling PrintHeartbeat written by SHouse.
    //
    pnd->HBPtr = pPkt;

    if (ulBufLen < ulStart + sizeof(MAIN_FRAME_HDR))
    {
        /* Mark the packet invalid. */
        pnd->bValid = FALSE;

        dprintf("NLB heartbeat header is not the minimum required length.\n");
        return;
    }

    //
    // Get the relative positions of quantities in MAIN_FRAME_HDR
    //
    pszStruct = MAIN_FRAME_HDR;

    pszMember = MAIN_FRAME_HDR_FIELD_CODE;
    if (!GetFieldOffset(pszStruct, pszMember, &ulValue))
    {
        ulValue += ulStart;
        CopyMemory(&(pnd->HBCode), &(RawData[ulValue]), sizeof(pnd->HBCode));
    }
    else
    {
        /* Mark the packet invalid. */
        pnd->bValid = FALSE;

        dprintf("Error reading field offset of %s in structure %s\n", pszMember, pszStruct);
    }

    if (pnd->HBCode != MAIN_FRAME_CODE) {
        /* Mark the packet invalid. */
        pnd->bValid = FALSE;

        dprintf("NLB heartbeat magic numbers do not match.\n");
    }

    pszMember = MAIN_FRAME_HDR_FIELD_VERSION;
    if (!GetFieldOffset(pszStruct, pszMember, &ulValue))
    {
        ulValue += ulStart;
        CopyMemory(&(pnd->HBVersion), &(RawData[ulValue]), sizeof(pnd->HBVersion));
    }
    else
    {
        dprintf("Error reading field offset of %s in structure %s\n", pszMember, pszStruct);
    }

    pszMember = MAIN_FRAME_HDR_FIELD_HOST;
    if (!GetFieldOffset(pszStruct, pszMember, &ulValue))
    {
        ulValue += ulStart;
        CopyMemory(&(pnd->HBHost), &(RawData[ulValue]), sizeof(pnd->HBHost));
    }
    else
    {
        dprintf("Error reading field offset of %s in structure %s\n", pszMember, pszStruct);
    }

    pszMember = MAIN_FRAME_HDR_FIELD_CLIP;
    if (!GetFieldOffset(pszStruct, pszMember, &ulValue))
    {
        ulValue += ulStart;
        CopyMemory(&(pnd->HBCluster), &(RawData[ulValue]), sizeof(pnd->HBCluster));
    }
    else
    {
        dprintf("Error reading field offset of %s in structure %s\n", pszMember, pszStruct);
    }

    pszMember = MAIN_FRAME_HDR_FIELD_DIP;
    if (!GetFieldOffset(pszStruct, pszMember, &ulValue))
    {
        ulValue += ulStart;
        CopyMemory(&(pnd->HBDip), &(RawData[ulValue]), sizeof(pnd->HBDip));
    }
    else
    {
        dprintf("Error reading field offset of %s in structure %s\n", pszMember, pszStruct);
    }
}

/*
 * Function: PopulateConvoyHeartbeat
 * Description: Stores properties of a remote control packet for subsequent printing.
 * Args: ULONG64       pPkt     - pointer to the original data structure in memory of the host being debugged.
 *       PUCHAR        RawData  - pointer to a byte array that we will read from
 *       ULONG         ulBufLen - size of the data array in bytes
 *       ULONG         ulStart  - location in data array where the heartbeat data begins
 *       PNETWORK_DATA pnd      - data structure where extracted properties are stored
 * Author: Created by chrisdar  2001.11.02
 */
VOID PopulateConvoyHeartbeat(ULONG64 pPkt, PUCHAR RawData, ULONG ulBufLen, ULONG ulStart, PNETWORK_DATA pnd)
{
//
// Just a stub for now. We won't deal with Convoy hosts.
//
}

/*
 * Function: PopulateEthernet
 * Description: Determines what type of data is in ethernet frame and calls function
 *              store properties for printing as appropriate.
 * Args: ULONG64       pPkt     - pointer to the original data structure in memory of the host being debugged.
 *       PUCHAR        RawData  - pointer to a byte array that we will read from
 *       ULONG         ulBufLen - size of the data array in bytes
 *       PNETWORK_DATA pnd      - data structure where extracted properties are stored
 * Author: Created by chrisdar  2001.11.02
 */
VOID PopulateEthernet(ULONG64 pPkt, PUCHAR RawData, ULONG ulBufLen, PNETWORK_DATA pnd)
{
    /* Initially assume what we parse will be valid. */
    pnd->bValid = TRUE;

    CopyMemory(&(pnd->DestMACAddr)  , &(RawData[ETHER_OFFSET_DEST_MAC]), sizeof(pnd->DestMACAddr));
    CopyMemory(&(pnd->SourceMACAddr), &(RawData[ETHER_OFFSET_SOURCE_MAC]), sizeof(pnd->SourceMACAddr));

    pnd->EtherFrameType = (RawData[ETHER_OFFSET_FRAME_TYPE_START] << 8) +
                           RawData[ETHER_OFFSET_FRAME_TYPE_START + 1];

    //
    // Determine payload type and fill accordingly
    //
    switch(pnd->EtherFrameType)
    {
    case TCPIP_IP_SIG:
        PopulateIP(RawData, ulBufLen, ETHER_HEADER_SIZE, pnd);
        break;
    case TCPIP_ARP_SIG:
        PopulateARP(RawData, ulBufLen, ETHER_HEADER_SIZE, pnd);
        break;
    case MAIN_FRAME_SIG:
        PopulateNLBHeartbeat(pPkt, RawData, ulBufLen, ETHER_HEADER_SIZE, pnd);
        break;
    case MAIN_FRAME_SIG_OLD:
        PopulateConvoyHeartbeat(pPkt, RawData, ulBufLen, ETHER_HEADER_SIZE, pnd);
        break;
    }
}

/*
 * Function: ParseNDISPacket
 * Description: This function walks the list of NDIS buffers in a packet and 
 *              copies the packet data into a buffer supplied by the caller.
 * Author: Created by chrisdar, 1.13.02
 */
ULONG ParseNDISPacket (ULONG64 pPkt, PUCHAR pRawData, ULONG BufferSize, PULONG64 ppHBData) {
    ULONG64         BufAddr;
    ULONG64         TailAddr;
    ULONG64         MappedSystemVAAddr;
    USHORT          usBufCount = 0;
    ULONG           BufferByteCount;
    ULONG           BytesRemaining;
    ULONG           TotalBytesRead = 0;
    ULONG           BytesRead;
    BOOL            bSuccess = FALSE;
    BOOL            b;

    BytesRemaining = BufferSize;
    *ppHBData = 0;

    GetFieldValue(pPkt, NDIS_PACKET, "Private.Head", BufAddr);
    GetFieldValue(pPkt, NDIS_PACKET, "Private.Tail", TailAddr);

    while (BufAddr != 0)
    {
        usBufCount++;

        if (CheckControlC())
        {
            return TotalBytesRead;
        }

        //
        // Note we could test BytesRemaining in the while clause instead of here. But we need the
        // number of chained buffers for the packet when we call PopulateEthernet later, so we 
        // branch around the extract code as required.
        //
        if (BytesRemaining > 0)
        {
            GetFieldValue(BufAddr, NDIS_BUFFER, "MappedSystemVa", MappedSystemVAAddr);
            GetFieldValue(BufAddr, NDIS_BUFFER, "ByteCount", BufferByteCount);
        
            if (BufferByteCount > BytesRemaining)
            {
                dprintf("\nNeed %u bytes of temp buffer space to read in buffer %u, but have room for only %u. Read what we can then process the data.\n",
                        BufferByteCount,
                        usBufCount,
                        BytesRemaining
                       );
                BufferByteCount = BytesRemaining;
            }

            b = ReadMemory(MappedSystemVAAddr, &pRawData[BufferSize - BytesRemaining], BufferByteCount, &BytesRead);

            if (!b || BytesRead != BufferByteCount)
            {
                //
                // No sense in continuing since we need a continuous subset of the data to make sense of
                // the contents.
                //
                dprintf("\nUnable to read %u bytes at address %p. Aborting...\n", BufferByteCount, MappedSystemVAAddr);
                return TotalBytesRead;
            }
            else
            {
                bSuccess = TRUE;
                TotalBytesRead += BytesRead;
                BytesRemaining -= BytesRead;
            }
        }

        if (BufAddr == TailAddr)
        {
            break;
        }

        GetFieldValue(BufAddr, NDIS_BUFFER, "Next", BufAddr);
    }

    dprintf("\nNumber of NDIS buffers associated with packet = %d\n\n", usBufCount);

    if (bSuccess)
    {
        //
        // The first argument to the PopulateEthernet function is a pointer to the
        // heartbeat data (whether or not the packet is a heartbeat will be sorted
        // out by PopulateEthernet and PrintPacket, and the pointer is ignored if the
        // packet isn't a heartbeat). The pointer is used by SHouse's PrintHeartbeat.
        //
        // We assert that the last buffer in the chain will always contain the heartbeat.
        // In other words, a heartbeat isn't followed by another buffer, and a heartbeat
        // is never fragmented across multiple buffers. With this assertion, the last
        // value of MappedSystemVAAddr points to the heartbeat's buffer.
        //
        // When the number of chained buffers is 1, the buffer is a simple ethernet frame
        // and we can calculate the beginning of the heartbeat.
        //
        // When the chain has more than one buffer, the address of the last buffer is the
        // beginning of the heartbeat, so we can use this location (MappedSystemVAAddr)
        // unmodified.
        //
        *ppHBData = MappedSystemVAAddr;

        if (usBufCount == 1)
        {
            *ppHBData = MappedSystemVAAddr + ETHER_HEADER_SIZE + GetTypeSize(MAIN_FRAME_HDR);
        }
    }

    return TotalBytesRead;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbkd\load.h ===
/*
 * File: load.h
 * Description: This file contains function prototypes for the load
 *              module packet filtering extensions.
 * History: Created by shouse, 1.11.02
 */

/* This function retrieves all necessary state from the load module in order to determine whether 
   a given packet would be accepted by the load module in its current state and why or why not. */
void LoadFilter (ULONG64 pLoad, ULONG dwClientIPAddress, ULONG dwClientPort, ULONG dwServerIPAddress, ULONG dwServerPort, USHORT wProtocol, UCHAR cFlags, BOOL bLimitMap, BOOL bReverse);

/* This function retrieves the appropriate port rule given the server side parameters of the connection. */
ULONG64 LoadPortRuleLookup (ULONG64 pLoad, ULONG dwServerIPAddress, ULONG dwServerPort, BOOL bIsTCP, BOOL * bIsDefault);

/* This function searches for and returns any existing descriptor matching the given IP tuple; otherwise, it returns NULL (0). */
ULONG64 LoadFindDescriptor (ULONG64 pLoad, ULONG index, ULONG dwServerIPAddress, ULONG dwServerPort, ULONG dwClientIPAddress, ULONG dwClientPort, USHORT wProtocol);

/* This function determines whether a given IP tuple matches a given connection descriptor. */
BOOL LoadConnectionMatch (ULONG64 pDescriptor, ULONG dwServerIPAddress, ULONG dwServerPort, ULONG dwClientIPAddress, ULONG dwClientPort, USHORT wProtocol);

/* This function determines whether or not a given NLB instance is configured for BDA teaming and returns the
   load module pointer that should be used. */
BOOL AcquireLoad (ULONG64 pContext, PULONG64 pLoad, BOOL * pbRefused);

/* This function is a simple hash based on the IP 4-tuple used to locate state for the connection. */
ULONG LoadSimpleHash (ULONG dwServerIPAddress, ULONG dwServerPort, ULONG dwClientIPAddress, ULONG dwClientPort);

/* This is the conventional NLB hashing algorithm, which ends up invoking a light-weight encryption algorithm to calculate a hash. */
ULONG LoadComplexHash (ULONG dwServerIPAddress, ULONG dwServerPort, ULONG dwClientIPAddress, ULONG dwClientPort, ULONG dwAffinity, BOOL bReverse, BOOL bLimitMap);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbkd\packet.h ===
/*
 * File: packet.h
 * Description: This file contains function prototypes for the packet
 *              population utility functions for the NLB KD extensions.
 * History: Created by shouse, 12.20.01
 */

/* Stores properties of a remote control packet for subsequent printing. */
VOID PopulateRemoteControl(PUCHAR RawData, ULONG ulBufLen, ULONG ulStartRC, PNETWORK_DATA pnd);

/* Stores properties of a remote control packet for subsequent printing. */
VOID PopulateICMP(PUCHAR RawData, ULONG ulBufLen, ULONG ulStartICMP, PNETWORK_DATA pnd);

/* Stores properties of a remote control packet for subsequent printing. */
VOID PopulateIGMP(PUCHAR RawData, ULONG ulBufLen, ULONG ulStartIGMP, PNETWORK_DATA pnd);

/* Description: Stores properties of a remote control packet for subsequent printing. */
VOID PopulateTCP(PUCHAR RawData, ULONG ulBufLen, ULONG ulStartTCP, PNETWORK_DATA pnd);

/* Description: Stores properties of a remote control packet for subsequent printing. */
VOID PopulateUDP(PUCHAR RawData, ULONG ulBufLen, ULONG ulStartUDP, PNETWORK_DATA pnd);

/* Description: Stores properties of a remote control packet for subsequent printing. */
VOID PopulateGRE(PUCHAR RawData, ULONG ulBufLen, ULONG ulStartGRE, PNETWORK_DATA pnd);

/* Description: Stores properties of a remote control packet for subsequent printing. */
VOID PopulateIPSec(PUCHAR RawData, ULONG ulBufLen, ULONG ulStartIPSec, PNETWORK_DATA pnd);

/* Description: Stores properties of a remote control packet for subsequent printing. */
VOID PopulateIPSecControl(PUCHAR RawData, ULONG ulBufLen, ULONG ulStartIPSec, PNETWORK_DATA pnd);

/* Description: Stores properties of a remote control packet for subsequent printing. */
VOID PopulateIP(PUCHAR RawData, ULONG ulBufLen, ULONG ulStart, PNETWORK_DATA pnd);

/* Description: Stores properties of a remote control packet for subsequent printing. */
VOID PopulateARP(PUCHAR RawData, ULONG ulBufLen, ULONG ulStart, PNETWORK_DATA pnd);

/* Description: Stores properties of a remote control packet for subsequent printing. */
VOID PopulateNLBHeartbeat(ULONG64 pPkt, PUCHAR RawData, ULONG ulBufLen, ULONG ulStart, PNETWORK_DATA pnd);

/* Description: Stores properties of a remote control packet for subsequent printing. */
VOID PopulateConvoyHeartbeat(ULONG64 pPkt, PUCHAR RawData, ULONG ulBufLen, ULONG ulStart, PNETWORK_DATA pnd);

/* Description: Determines what type of data is in ethernet frame and calls function. */
VOID PopulateEthernet(ULONG64 pPkt, PUCHAR RawData, ULONG ulBufLen, PNETWORK_DATA pnd);

/* This function walks the list of NDIS buffers in a packet and copies the packet data into a buffer supplied by the caller. */
ULONG ParseNDISPacket (ULONG64 pPkt, PUCHAR pRawData, ULONG pBytesRemaining, PULONG64 ppHBData);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbkd\print.h ===
/*
 * File: print.h
 * Description: This file contains function prototypes for the print
 *              utilities for the NLB KD extensions.
 * History: Created by shouse, 1.4.01
 */

/* Prints usage information for the specified context. */
void PrintUsage (ULONG dwContext);

/* Prints the contents of the MAIN_ADAPTER structure at the specified verbosity. */
void PrintAdapter (ULONG64 pAdapter, ULONG dwVerbosity);

/* Prints the contents of the MAIN_CTXT structure at the specified verbosity. */
void PrintContext (ULONG64 pContext, ULONG dwVerbosity);

/* Prints the contents of the CVY_PARAMS structure at the specified verbosity. */
void PrintParams (ULONG64 pParams, ULONG dwVerbosity);

/* Prints the NLB port rules. */
void PrintPortRules (ULONG dwNumRules, ULONG64 pRules);

/* Prints the contents of the CVY_LOAD structure at the specified verbosity. */
void PrintLoad (ULONG64 pLoad, ULONG dwVerbosity);

/* Prints the NLB private data associated with the given packet. */
void PrintResp (ULONG64 pPacket, ULONG dwDirection);
/* Prints a list of hosts in a host map. */
void PrintHostList (ULONG dwHostMap);

/* Prints a list hosts from which we are missing pings. */
void PrintMissedPings (ULONG dwMissedPings[]);

/* Prints a list of bins with dirty connections. */
void PrintDirtyBins (ULONG dwDirtyBins[]);

/* Prints the contents of the NLB heartbeat structure. */
void PrintHeartbeat (ULONG64 pHeartbeat);

/* Prints the state information for the port rule. */
void PrintPortRuleState (ULONG64 pPortRule, ULONG dwHostID, BOOL bDefault);

/* Retrieves the current packet stack for the specified packet. */
ULONG64 PrintCurrentPacketStack (ULONG64 pPacket, ULONG * bStackLeft);

/* Prints the BDA member configuration and state. */
void PrintBDAMember (ULONG64 pMember);

/* Prints the BDA team configuration and state. */
void PrintBDATeam (ULONG64 pMember);

/* Prints a list of members in a BDA membership or consistency map. */
void PrintBDAMemberList (ULONG dwMemberMap);

/* Prints MaxEntries entries in a connection descriptor queue. */
void PrintQueue (ULONG64 pQueue, ULONG dwIndex, ULONG dwMaxEntries);

/* Prints MaxEntries entries in a global connection descriptor queue. */
void PrintGlobalQueue (ULONG64 pQueue, ULONG dwIndex, ULONG dwMaxEntries);

/* Searches the given load module to determine whether NLB will accept this packet.  If state for this packet already exists, it is printed. */
void PrintFilter (ULONG64 pContext, ULONG dwClientIPAddress, ULONG dwClientPort, ULONG dwServerIPAddress, ULONG dwServerPort, USHORT wProtocol, UCHAR cFlags);

/* Extracts the network data previously parsed from an NDIS_PACKET and calls PrintFilter to determine whether NLB will accept this packet. */
void PrintHash (ULONG64 pContext, PNETWORK_DATA pnd);

/* Prints the contents of an NDIS packet, including known content such as IP, UDP, remote control data */
void PrintPacket (PNETWORK_DATA nd);

/* Prints the contents of an IP packet, including known content such as UDP, remote control data */
void PrintIP (PNETWORK_DATA nd);

/* Print the state of the global NLB kernel-mode hooks. */
void PrintHooks (ULONG64 pHooks);

/* Print the configuration and state of a hook interface. */
void PrintHookInterface (ULONG64 pInterface);

/* Print the configuration and state of a single hook. */
void PrintHook (ULONG64 pHook);

/* Print the symbol value and name for a given symbol. */
VOID PrintSymbol (ULONG64 Pointer, PCHAR EndOfLine);

/* Prints the unicast and multicast MAC addresses configured on an NLB adapter. */
void PrintNetworkAddresses (ULONG64 pContext);

/* Prints a connection descriptor (CONN_ENTRY). */
void PrintConnectionDescriptor (ULONG64 pDescriptor);

/* Prints a pending connection entry (PENDING_ENTRY). */
void PrintPendingConnection (ULONG64 pPending);

/* Prints the list of known dedicated IP addresses in the cluster. */
void PrintDIPList (ULONG64 pList);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbkd\print.c ===
/*
 * File: print.c
 * Description: This file contains the implementation of the print
 *              utilities for the NLB KD extensions.
 * Author: Created by shouse, 1.4.01
 */

#include "nlbkd.h"
#include "utils.h"
#include "print.h"
#include "packet.h"
#include "load.h"

/*
 * Function: PrintUsage
 * Description: Prints usage information for the specified context.
 * Author: Created by shouse, 1.5.01
 */
void PrintUsage (ULONG dwContext) {

    /* Display the appropriate help. */
    switch (dwContext) {
    case USAGE_ADAPTERS:
        dprintf("Usage: nlbadapters [verbosity]\n");
        dprintf("  [verbosity]:   0 (LOW)     Prints minimal detail for adapters in use (default)\n");
        dprintf("                 1 (MEDIUM)  Prints adapter state for adapters in use\n");
        dprintf("                 2 (HIGH)    Prints adapter state for ALL NLB adapter blocks\n");
        break;
    case USAGE_ADAPTER:
        dprintf("Usage: nlbadapter <pointer to adapter block> [verbosity]\n");
        dprintf("  [verbosity]:   0 (LOW)     Prints minimal detail for the specified adapter\n");
        dprintf("                 1 (MEDIUM)  Prints adapter state for the specified adapter (default)\n");
        dprintf("                 2 (HIGH)    Recurses into NLB context with LOW verbosity\n");
        break;
    case USAGE_CONTEXT:
        dprintf("Usage: nlbctxt <pointer to context block> [verbosity]\n");
        dprintf("  [verbosity]:   0 (LOW)     Prints fundamental NLB configuration and state (default)\n");
        dprintf("                 1 (MEDIUM)  Prints resource state and packet statistics\n");
        dprintf("                 2 (HIGH)    Recurses into parameters and load with LOW verbosity\n");
        break;
    case USAGE_LOAD:
        dprintf("Usage: nlbload <pointer to load block> [verbosity]\n");
        dprintf("  [verbosity]:   0 (LOW)     Prints fundamental load state and configuration\n");
        dprintf("                 1 (MEDIUM)  Prints the state of all port rules and bins\n");
        dprintf("                 2 (HIGH)    Prints the NLB heartbeat information\n");
        break;
    case USAGE_PARAMS:
        dprintf("Usage: nlbparams <pointer to params block> [verbosity]\n");
        dprintf("  [verbosity]:   0 (LOW)     Prints fundamental NLB configuration parameters (default)\n");
        dprintf("                 1 (MEDIUM)  Prints all configured port rules\n");
        dprintf("                 2 (HIGH)    Prints extra miscellaneous configuration\n");
        break;
    case USAGE_RESP:
        dprintf("Usage: nlbresp <pointer to packet> [direction]\n");
        dprintf("  [direction]:   0 (RECEIVE) Packet is on the receive path (default)\n");
        dprintf("                 1 (SEND)    Packet is on the send path\n");
        break;
    case USAGE_PKT:
        dprintf("Usage: nlbpkt <Packet> [RC Port]\n");
        dprintf("  [RC port]:     Remote control port assuming the packet is a remote control packet\n");
        break;
    case USAGE_ETHER:
        dprintf("Usage: nlbether <Ether Frame> [RC Port]\n");
        dprintf("  [RC port]:     Remote control port assuming the packet is a remote control packet\n");
        break;
    case USAGE_IP:
        dprintf("Usage: nlbip <IP Packet> [RC Port]\n");
        dprintf("  [RC port]:     Remote control port assuming the packet is a remote control packet\n");
        break;
    case USAGE_TEAMS:
        dprintf("Usage: nlbteams\n");
        break;
    case USAGE_HOOKS:
        dprintf("Usage: nlbhooks\n");
        break;
    case USAGE_MAC:
        dprintf("Usage: nlbmac <pointer to context block>\n");
        break;
    case USAGE_DSCR:
        dprintf("Usage: nlbdscr <pointer to connection descriptor>\n");
        break;
    case USAGE_CONNQ:
        dprintf("Usage: nlbconnq <pointer to queue>[index] [max entries]\n");
        dprintf("  [max entries]: Maximum number of entries to print (default is 10)\n");
        dprintf("  [index]:       If queue pointer points to an array of queues, this is the index of the\n");
        dprintf("                 queue to be traversed, provided in [index], {index} or (index) form.\n");
        break;
    case USAGE_GLOBALQ:
        dprintf("Usage: nlbglobalq <pointer to queue>[index] [max entries]\n");
        dprintf("  [max entries]: Maximum number of entries to print (default is 10)\n");
        dprintf("  [index]:       If queue pointer points to an array of queues, this is the index of the\n");
        dprintf("                 queue to be traversed, provided in [index], {index} or (index) form.\n");
        break;
    case USAGE_FILTER:
        dprintf("Usage: nlbfilter <pointer to context block> <protocol> <client IP>[:<client port>] <server IP>[:<server port>] [flags]\n");
        dprintf("  <protocol>:    TCP, PPTP, GRE, UDP, IPSec or ICMP\n");
        dprintf("  [flags]:       One of SYN, FIN or RST (default is DATA)\n");
        dprintf("\n");
        dprintf("  IP addresses can be in dotted notation or network byte order DWORDs.\n");
        dprintf("    I.e., 169.128.0.101 = 0x650080a9 (in x86 memory = A9 80 00 65)\n");
        break;
    case USAGE_HASH:
        dprintf("Usage: nlbhash <pointer to context block> <pointer to packet>\n");
        break;
    default:
        dprintf("No usage information available.\n");
        break;
    }
}

/*
 * Function: PrintAdapter
 * Description: Prints the contents of the MAIN_ADAPTER structure at the specified verbosity.
 *              LOW (0) prints only the adapter address and device name.
 *              MEDIUM (1) additionally prints the status flags (init, bound, annouce, etc.).
 *              HIGH (2) recurses into the context structure and prints it at MEDIUM verbosity.
 * Author: Created by shouse, 1.5.01
 */
void PrintAdapter (ULONG64 pAdapter, ULONG dwVerbosity) {
    WCHAR szString[256];
    ULONG dwValue;
    UCHAR cValue;
    ULONG64 pAddr = 0;
    ULONG64 pContext = 0;
    ULONG64 pOpen;
    ULONG64 pMiniport;
    ULONG64 pName;

    /* Make sure the address is non-NULL. */
    if (!pAdapter) {
        dprintf("Error: NLB adapter block is NULL.\n");
        return;
    }
    
    dprintf("NLB Adapter Block 0x%p\n", pAdapter);

    /* Get the MAIN_ADAPTER_CODE from the structure to make sure that this address
       indeed points to a valid NLB adapter block. */
    GetFieldValue(pAdapter, MAIN_ADAPTER, MAIN_ADAPTER_FIELD_CODE, dwValue);
    
    if (dwValue != MAIN_ADAPTER_CODE) {
        dprintf("  Error: Invalid NLB adapter block.  Wrong code found (0x%08x).\n", dwValue);
        return;
    }
    
    /* Retrieve the used/unused state of the adapter. */
    GetFieldValue(pAdapter, MAIN_ADAPTER, MAIN_ADAPTER_FIELD_USED, cValue);
    
    if (!cValue) 
        dprintf("  This adapter is unused.\n");
    else {
        /* Get the offset of the NLB context pointer. */
        if (GetFieldOffset(MAIN_ADAPTER, MAIN_ADAPTER_FIELD_CONTEXT, &dwValue))
            dprintf("Can't get offset of %s in %s\n", MAIN_ADAPTER_FIELD_CONTEXT, MAIN_ADAPTER);
        else {
            pAddr = pAdapter + dwValue;
            
            /* Retrieve the pointer. */
            pContext = GetPointerFromAddress(pAddr);
       
            /* Get the MAC handle from the context block; this is a NDIS_OPEN_BLOCK pointer. */
            GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_MAC_HANDLE, pOpen);
            
            /* Get the miniport handle from the open block; this is a NDIS_MINIPORT_BLOCK pointer. */
            GetFieldValue(pOpen, NDIS_OPEN_BLOCK, NDIS_OPEN_BLOCK_FIELD_MINIPORT_HANDLE, pMiniport);
            
            /* Get a pointer to the adapter name from the miniport block. */
            GetFieldValue(pMiniport, NDIS_MINIPORT_BLOCK, NDIS_MINIPORT_BLOCK_FIELD_ADAPTER_NAME, pName);
            
            /* Get the length of the unicode string. */
            GetFieldValue(pName, UNICODE_STRING, UNICODE_STRING_FIELD_LENGTH, dwValue);
            
            /* Get the maximum length of the unicode string. */
            GetFieldValue(pName, UNICODE_STRING, UNICODE_STRING_FIELD_BUFFER, pAddr);
            
            /* Retrieve the contexts of the string and store it in a buffer. */
            GetString(pAddr, szString, dwValue);
            
            dprintf("  Physical device name:               %ls\n", szString);     
        }

        /* Get the pointer to and length of the device to which NLB is bound. */
        GetFieldValue(pAdapter, MAIN_ADAPTER, MAIN_ADAPTER_FIELD_NAME_LENGTH, dwValue);
        GetFieldValue(pAdapter, MAIN_ADAPTER, MAIN_ADAPTER_FIELD_NAME, pAddr);
        
        /* Retrieve the contexts of the string and store it in a buffer. */
        GetString(pAddr, szString, dwValue);
        
        dprintf("  Physical device GUID:               %ls\n", szString);
    }

    /* Get the IP interface index. */
    GetFieldValue(pAdapter, MAIN_ADAPTER, MAIN_ADAPTER_FIELD_IF_INDEX, dwValue);
    
    dprintf("  IP interface index:                 %u\n", dwValue);

    /* If we're printing at low verbosity, bail out here. */
    if (dwVerbosity == VERBOSITY_LOW) goto end;

    /* Get the IP interface index operation. */
    GetFieldValue(pAdapter, MAIN_ADAPTER, MAIN_ADAPTER_FIELD_IF_INDEX_OPERATION, dwValue);
    
    dprintf("  IP interface operation in progress: ");

    switch (dwValue) {
    case IF_INDEX_OPERATION_UPDATE:
        dprintf("Deleting\n");
        break;
    case IF_INDEX_OPERATION_NONE:
        dprintf("None\n");
        break;
    default:
        dprintf("Unkonwn\n");
        break;
    }

    /* Determine whether or not the adapter has been initialized. */
    GetFieldValue(pAdapter, MAIN_ADAPTER, MAIN_ADAPTER_FIELD_INITED, cValue);
    
    dprintf("  Context state initialized:          %s\n", (cValue) ? "Yes" : "No");
    
    /* Determine whether or not NLB has been bound to the stack yet. */
    GetFieldValue(pAdapter, MAIN_ADAPTER, MAIN_ADAPTER_FIELD_BOUND, cValue);
    
    dprintf("  NLB bound to adapter:               %s\n", (cValue) ? "Yes" : "No");
    
    /* Determine whether or not TCP/IP has been bound to the NLB virtual adapter or not. */
    GetFieldValue(pAdapter, MAIN_ADAPTER, MAIN_ADAPTER_FIELD_ANNOUNCED, cValue);
    
    dprintf("  NLB miniport announced:             %s\n", (cValue) ? "Yes" : "No");
    
 end:

    dprintf(" %sNLB context:                        0x%p\n", 
            (pContext && (dwVerbosity == VERBOSITY_HIGH)) ? "-" : (pContext) ? "+" : " ", pContext);    

    /* If we're printing at medium verbosity, bail out here. */
    if ((dwVerbosity == VERBOSITY_LOW) || (dwVerbosity == VERBOSITY_MEDIUM)) return;

    /* Print the context information (always with LOW verbosity during recursion. */
    if (pContext) {
        dprintf("\n");
        PrintContext(pContext, VERBOSITY_LOW);
    }
}

/*
 * Function: PrintContext
 * Description: Prints the contents of the MAIN_CTXT structure at the specified verbosity.
 *              LOW (0) prints fundamental NLB configuration and state.
 *              MEDIUM (1) additionally prints the resource state (pools, allocations, etc).
 *              HIGH (2) further prints other miscelaneous information.
 * Author: Created by shouse, 1.5.01
 */
void PrintContext (ULONG64 pContext, ULONG dwVerbosity) {
    WCHAR szNICName[CVY_MAX_VIRTUAL_NIC];
    ULONGLONG dwwValue;
    IN_ADDR dwIPAddr;
    CHAR * szString;
    UCHAR szMAC[6];
    ULONG64 pAddr;
    ULONG dwValue;

    /* Make sure the address is non-NULL. */
    if (!pContext) {
        dprintf("Error: NLB context block is NULL.\n");
        return;
    }

    dprintf("NLB Context Block 0x%p\n", pContext);

    /* Get the MAIN_CTXT_CODE from the structure to make sure that this address
       indeed points to a valid NLB context block. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CODE, dwValue);
    
    if (dwValue != MAIN_CTXT_CODE) {
        dprintf("  Error: Invalid NLB context block.  Wrong code found (0x%08x).\n", dwValue);
        return;
    } 

    /* Get the offset of the NLB virtual NIC name. */
    if (GetFieldOffset(MAIN_CTXT, MAIN_CTXT_FIELD_VIRTUAL_NIC, &dwValue))
        dprintf("Can't get offset of %s in %s\n", MAIN_CTXT_FIELD_VIRTUAL_NIC, MAIN_CTXT);
    else {
        pAddr = pContext + dwValue;
    
        /* Retrieve the contexts of the string and store it in a buffer. */
        GetString(pAddr, szNICName, CVY_MAX_VIRTUAL_NIC);
        
        dprintf("  NLB virtual NIC name:               %ls\n", szNICName);
    }

    /* Get the convoy enabled status. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_ENABLED, dwValue);

    dprintf("  NLB enabled:                        %s ", (dwValue) ? "Yes" : "No");

    /* Get the draining status. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_DRAINING, dwValue);

    if (dwValue) dprintf("(Draining) ");

    /* Get the suspended status. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_SUSPENDED, dwValue);

    if (dwValue) dprintf("(Suspended) ");

    /* Get the stopping status. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_STOPPING, dwValue);

    if (dwValue) dprintf("(Stopping) ");

    dprintf("\n");

    /* Get the adapter index. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_ADAPTER_ID, dwValue);

    dprintf("  NLB adapter ID:                     %u\n", dwValue);

    dprintf("\n");

    /* Get the adapter medium. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_MEDIUM, dwValue);

    dprintf("  Network medium:                     %s\n", (dwValue == NdisMedium802_3) ? "802.3" : "Invalid");

    /* Get the media connect status. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_MEDIA_CONNECT, dwValue);

    dprintf("  Network connect status:             %s\n", (dwValue) ? "Connected" : "Disconnected");

    /* Get the media connect status. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_FRAME_SIZE, dwValue);

    dprintf("  Frame size (MTU):                   %u\n", dwValue);

    /* Get the media connect status. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_MCAST_LIST_SIZE, dwValue);

    dprintf("  Multicast MAC list size:            %u\n", dwValue);

    /* Determine dynamic MAC address support. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_MAC_OPTIONS, dwValue);

    dprintf("  Dynamic MAC address support:        %s\n", 
            (dwValue & NDIS_MAC_OPTION_SUPPORTS_MAC_ADDRESS_OVERWRITE) ? "Yes" : "No");

    dprintf("\n");

    dprintf("  NDIS handles\n");

    /* Get the NDIS bind handle. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_BIND_HANDLE, pAddr);

    dprintf("      Bind handle:                    0x%p\n", pAddr);

    /* Get the NDIS unbind handle. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_UNBIND_HANDLE, pAddr);

    dprintf("      Unbind handle:                  0x%p\n", pAddr);

    /* Get the NDIS MAC handle. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_MAC_HANDLE, pAddr);

    dprintf("      MAC handle:                     0x%p\n", pAddr);

    /* Get the NDIS protocol handle. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_PROT_HANDLE, pAddr);

    dprintf("      Protocol handle:                0x%p\n", pAddr);

    dprintf("\n");

    dprintf("  Cluster IP settings\n");

    /* Get the cluster IP address, which is a DWORD, and convert it to a string. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CL_IP_ADDR, dwValue);

    dwIPAddr.S_un.S_addr = dwValue;
    szString = inet_ntoa(dwIPAddr);

    dprintf("      IP address:                     %s\n", szString);

    /* Get the cluster net mask, which is a DWORD, and convert it to a string. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CL_NET_MASK, dwValue);

    dwIPAddr.S_un.S_addr = dwValue;
    szString = inet_ntoa(dwIPAddr);

    dprintf("      Netmask:                        %s\n", szString);

    /* Get the offset of the cluster MAC address and retrieve the MAC from that address. */
    if (GetFieldOffset(MAIN_CTXT, MAIN_CTXT_FIELD_CL_MAC_ADDR, &dwValue))
        dprintf("Can't get offset of %s in %s\n", MAIN_CTXT_FIELD_CL_MAC_ADDR, MAIN_CTXT);
    else {
        pAddr = pContext + dwValue;

        GetMAC(pAddr, szMAC, ETH_LENGTH_OF_ADDRESS);

        dprintf("      MAC address:                    %02X-%02X-%02X-%02X-%02X-%02X\n", 
                ((PUCHAR)(szMAC))[0], ((PUCHAR)(szMAC))[1], ((PUCHAR)(szMAC))[2], 
                ((PUCHAR)(szMAC))[3], ((PUCHAR)(szMAC))[4], ((PUCHAR)(szMAC))[5]);
    }

    /* Get the cluster broadcast address, which is a DWORD, and convert it to a string. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CL_BROADCAST, dwValue);

    dwIPAddr.S_un.S_addr = dwValue;
    szString = inet_ntoa(dwIPAddr);

    dprintf("      Broadcast address:              %s\n", szString);

    /* Get the IGMP multicast IP address, which is a DWORD, and convert it to a string. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_IGMP_MCAST_IP, dwValue);

    dwIPAddr.S_un.S_addr = dwValue;
    szString = inet_ntoa(dwIPAddr);

    dprintf("      IGMP multicast IP address:      %s\n", szString);

    dprintf("\n");

    dprintf("  Dedicated IP settings\n");

    /* Get the dedicated IP address, which is a DWORD, and convert it to a string. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_DED_IP_ADDR, dwValue);

    dwIPAddr.S_un.S_addr = dwValue;
    szString = inet_ntoa(dwIPAddr);

    dprintf("      IP address:                     %s\n", szString);

    /* Get the dedicated net mask, which is a DWORD, and convert it to a string. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_DED_NET_MASK, dwValue);

    dwIPAddr.S_un.S_addr = dwValue;
    szString = inet_ntoa(dwIPAddr);

    dprintf("      Netmask:                        %s\n", szString);

    /* Get the dedicated broadcast address, which is a DWORD, and convert it to a string. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_DED_BROADCAST, dwValue);

    dwIPAddr.S_un.S_addr = dwValue;
    szString = inet_ntoa(dwIPAddr);

    dprintf("      Broadcast address:              %s\n", szString);

    /* Get the offset of the dedicated MAC address and retrieve the MAC from that address. */
    if (GetFieldOffset(MAIN_CTXT, MAIN_CTXT_FIELD_DED_MAC_ADDR, &dwValue))
        dprintf("Can't get offset of %s in %s\n", MAIN_CTXT_FIELD_DED_MAC_ADDR, MAIN_CTXT);
    else {
        pAddr = pContext + dwValue;

        GetMAC(pAddr, szMAC, ETH_LENGTH_OF_ADDRESS);

        dprintf("      MAC address:                    %02X-%02X-%02X-%02X-%02X-%02X\n", 
                ((PUCHAR)(szMAC))[0], ((PUCHAR)(szMAC))[1], ((PUCHAR)(szMAC))[2], 
                ((PUCHAR)(szMAC))[3], ((PUCHAR)(szMAC))[4], ((PUCHAR)(szMAC))[5]);
    }

    dprintf("\n");

    /* Get the offset of the BDA teaming information for this context. */
    if (GetFieldOffset(MAIN_CTXT, MAIN_CTXT_FIELD_BDA_TEAMING, &dwValue))
        dprintf("Can't get offset of %s in %s\n", MAIN_CTXT_FIELD_BDA_TEAMING, MAIN_CTXT);
    else {
        pAddr = pContext + dwValue;

        /* Print the bi-directional affinity teaming state. */
        PrintBDAMember(pAddr);
    }

    dprintf("\n");

    dprintf("  Cluster dedicated IP addresses\n");

    /* Get the offset of the dedicated IP address list for this context. */
    if (GetFieldOffset(MAIN_CTXT, MAIN_CTXT_FIELD_DIP_LIST, &dwValue))
        dprintf("Can't get offset of %s in %s\n", MAIN_CTXT_FIELD_DIP_LIST, MAIN_CTXT);
    else {
        pAddr = pContext + dwValue;

        /* Print the known dedicated IP addresses of other cluster members. */
        PrintDIPList(pAddr);
    }

    dprintf("\n");

    /* Get the current heartbeat period. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_PING_TIMEOUT, dwValue);

    dprintf("  Current heartbeat period:           %u millisecond(s)\n", dwValue);

    /* Get the current IGMP join counter. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_IGMP_TIMEOUT, dwValue);

    dprintf("  Time since last IGMP join:          %.1f second(s)\n", (float)(dwValue/1000.0));

    /* Get the current descriptor purge counter. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_DSCR_PURGE_TIMEOUT, dwValue);

    dprintf("  Time since last descriptor purge:   %.1f second(s)\n", (float)(dwValue/1000.0));

    /* Get the total number of connections purged. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_NUM_DSCRS_PURGED, dwValue);

    dprintf("  Number of connections purged:       %u\n", dwValue);

    /* If we're printing at low verbosity, go to the end and print the load and params pointers. */
    if (dwVerbosity == VERBOSITY_LOW) goto end;

    dprintf("\n");

    dprintf("  Send packet pools\n");

    /* Get the state of the send packet pool. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_EXHAUSTED, dwValue);

    dprintf("      Pool exhausted:                 %s\n", (dwValue) ? "Yes" : "No");    

    /* Get the number of send packet pools allocated. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_SEND_POOLS_ALLOCATED, dwValue);

    dprintf("      Pools allocated:                %u\n", dwValue);    

    /* Get the number of send packets allocated. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_SEND_PACKETS_ALLOCATED, dwValue);

    dprintf("      Packets allocated:              %u\n", dwValue);

    /* Get the current send packet pool. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_SEND_POOL_CURRENT, dwValue);

    dprintf("      Current pool:                   %u\n", dwValue);    

    /* Get the number of pending send packets (outstanding). */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_SEND_OUTSTANDING, dwValue);

    dprintf("      Packets outstanding:            %u\n", dwValue);    

    dprintf("\n");

    dprintf("  Receive packet pools\n");

    /* Get the receive "out of resoures" counter. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CNTR_RECV_NO_BUF, dwValue);

    dprintf("      Allocation failures:            %u\n", dwValue);

    /* Get the number of receive packet pools allocated. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_RECV_POOLS_ALLOCATED, dwValue);

    dprintf("      Pools allocated:                %u\n", dwValue);    

    /* Get the number of receive packets allocated. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_RECV_PACKETS_ALLOCATED, dwValue);

    dprintf("      Packets allocated:              %u\n", dwValue);

    /* Get the current receive packet pool. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_RECV_POOL_CURRENT, dwValue);

    dprintf("      Current pool:                   %u\n", dwValue);    

    /* Get the number of pending receive packets (outstanding). */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_RECV_OUTSTANDING, dwValue);

    dprintf("      Packets outstanding:            %u\n", dwValue);    

    dprintf("\n");

    dprintf("  Ping/IGMP packet pool\n");

    /* Get the receive "out of resoures" counter. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CNTR_PING_NO_BUF, dwValue);

    dprintf("      Allocation failures:            %u\n", dwValue);

    /* Get the number of ping/igmp packets allocated. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_PING_PACKETS_ALLOCATED, dwValue);

    dprintf("      Packets allocated:              %u\n", dwValue);

    /* Get the number of pending ping/igmp packets (outstanding). */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_PING_OUTSTANDING, dwValue);

    dprintf("      Packets outstanding:            %u\n", dwValue);    

    dprintf("\n");

    dprintf("  Receive buffer pools\n");

    /* Get the number of receive buffer pools allocated. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_BUF_POOLS_ALLOCATED, dwValue);

    dprintf("      Pools allocated:                %u\n", dwValue);    

    /* Get the number of receive buffers allocated. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_BUFS_ALLOCATED, dwValue);

    dprintf("      Buffers allocated:              %u\n", dwValue);

    /* Get the number of pending receive buffers (outstanding). */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_BUFS_OUTSTANDING, dwValue);

    dprintf("      Buffers outstanding:            %u\n", dwValue);    

    dprintf("\n");

    dprintf("                                         Sent      Received\n");
    dprintf("  Statistics                          ----------  ----------\n");

    /* Get the number of successful sends. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CNTR_XMIT_OK, dwValue);

    dprintf("      Successful:                     %10u", dwValue);

    /* Get the number of successful receives. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CNTR_RECV_OK, dwValue);

    dprintf("  %10u\n", dwValue);

    /* Get the number of unsuccessful sends. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CNTR_XMIT_ERROR, dwValue);

    dprintf("      Unsuccessful:                   %10u", dwValue);

    /* Get the number of unsuccessful receives. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CNTR_RECV_ERROR, dwValue);

    dprintf("  %10u\n", dwValue);

    /* Get the number of directed frames transmitted. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CNTR_XMIT_FRAMES_DIR, dwValue);

    dprintf("      Directed packets:               %10u", dwValue);
    /* Get the number of directed frames received. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CNTR_RECV_FRAMES_DIR, dwValue);

    dprintf("  %10u\n", dwValue);

    /* Get the number of directed bytes transmitted. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CNTR_XMIT_BYTES_DIR, dwwValue);

    dprintf("      Directed bytes:                 %10u", dwwValue);

    /* Get the number of directed bytes received. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CNTR_RECV_BYTES_DIR, dwwValue);

    dprintf("  %10u\n", dwwValue);

    /* Get the number of multicast frames transmitted. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CNTR_XMIT_FRAMES_MCAST, dwValue);

    dprintf("      Multicast packets:              %10u", dwValue);

    /* Get the number of multicast frames received. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CNTR_RECV_FRAMES_MCAST, dwValue);

    dprintf("  %10u\n", dwValue);

    /* Get the number of multicast bytes transmitted. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CNTR_XMIT_BYTES_MCAST, dwwValue);

    dprintf("      Multicast bytes:                %10u", dwwValue);

    /* Get the number of multicast bytes received. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CNTR_RECV_BYTES_MCAST, dwwValue);

    dprintf("  %10u\n", dwwValue);

    /* Get the number of broadcast frames transmitted. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CNTR_XMIT_FRAMES_BCAST, dwValue);

    dprintf("      Broadcast packets:              %10u", dwValue);

    /* Get the number of broadcast frames received. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CNTR_RECV_FRAMES_BCAST, dwValue);

    dprintf("  %10u\n", dwValue);

    /* Get the number of broadcast bytes transmitted. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CNTR_XMIT_BYTES_BCAST, dwwValue);

    dprintf("      Broadcast bytes:                %10u", dwwValue);

    /* Get the number of broadcast bytes received. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CNTR_RECV_BYTES_BCAST, dwwValue);

    dprintf("  %10u\n", dwwValue);

    /* Get the number of TCP resets transmitted. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CNTR_XMIT_TCP_RESETS, dwValue);

    dprintf("      TCP resets:                     %10u", dwValue);

    /* Get the number of TCP resets received. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CNTR_RECV_TCP_RESETS, dwValue);

    dprintf("  %10u\n", dwValue);

 end:

    dprintf("\n");

    /* Get the pointer to the NLB load. */
    GetFieldOffset(MAIN_CTXT, MAIN_CTXT_FIELD_LOAD, &dwValue);
    
    pAddr = pContext + dwValue;

    dprintf(" %sNLB load:                           0x%p\n",    
            (pAddr && (dwVerbosity == VERBOSITY_HIGH)) ? "-" : (pAddr) ? "+" : " ", pAddr);    

    /* Print the load information if verbosity is high. */
    if (pAddr && (dwVerbosity == VERBOSITY_HIGH)) {
        dprintf("\n");
        PrintLoad(pAddr, VERBOSITY_LOW);
        dprintf("\n");
    }

    /* Get the pointer to the NLB parameters. */
    GetFieldOffset(MAIN_CTXT, MAIN_CTXT_FIELD_PARAMS, &dwValue);
    
    pAddr = pContext + dwValue;

    dprintf(" %sNLB parameters:                     0x%p ",
            (pAddr && (dwVerbosity == VERBOSITY_HIGH)) ? "-" : (pAddr) ? "+" : " ", pAddr);    

    /* Get the validity of the NLB parameter block. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_PARAMS_VALID, dwValue);

    dprintf("(%s)\n", (dwValue) ? "Valid" : "Invalid");

    /* Print the parameter information if verbosity is high. */
    if (pAddr && (dwVerbosity == VERBOSITY_HIGH)) {
        dprintf("\n");
        PrintParams(pAddr, VERBOSITY_LOW);
    }
}

/*
 * Function: PrintParams
 * Description: Prints the contents of the CVY_PARAMS structure at the specified verbosity.
 *              LOW (0) prints fundamental configuration parameters.
 *              MEDIUM (1) prints all configured port rules.
 *              HIGH (2) prints other miscellaneous configuration.
 * Author: Created by shouse, 1.21.01
 */
void PrintParams (ULONG64 pParams, ULONG dwVerbosity) {
    WCHAR szString[256];
    ULONG64 pAddr;
    ULONG dwValue;

    /* Make sure the address is non-NULL. */
    if (!pParams) {
        dprintf("Error: NLB parameter block is NULL.\n");
        return;
    }

    /* Get the parameter version number. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_VERSION, dwValue);

    dprintf("NLB Parameters Block 0x%p (Version %d)\n", pParams, dwValue);

    /* Get the offset of the hostname and retrieve the string from that address. */
    if (GetFieldOffset(CVY_PARAMS, CVY_PARAMS_FIELD_HOSTNAME, &dwValue))
        dprintf("Can't get offset of %s in %s\n", CVY_PARAMS_FIELD_HOSTNAME, CVY_PARAMS);
    else {
        pAddr = pParams + dwValue;

        /* Retrieve the contexts of the string and store it in a buffer. */
        GetString(pAddr, szString, CVY_MAX_HOST_NAME + 1);

        dprintf("  Hostname:                           %ls\n", szString);
    }

    /* Get the host priority. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_HOST_PRIORITY, dwValue);

    dprintf("  Host priority:                      %u\n", dwValue);

    /* Get the initial cluster state flag. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_INITIAL_STATE, dwValue);

    dprintf("  Preferred initial host state:       %s\n", 
            (dwValue == CVY_HOST_STATE_STARTED) ? "Started" :
            (dwValue == CVY_HOST_STATE_STOPPED) ? "Stopped" :
            (dwValue == CVY_HOST_STATE_SUSPENDED) ? "Suspended" : "Unknown");

    /* Get the current host state. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_HOST_STATE, dwValue);

    dprintf("  Current host state:                 %s\n", 
            (dwValue == CVY_HOST_STATE_STARTED) ? "Started" :
            (dwValue == CVY_HOST_STATE_STOPPED) ? "Stopped" :
            (dwValue == CVY_HOST_STATE_SUSPENDED) ? "Suspended" : "Unknown");

    /* Get the persisted states flags. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_PERSISTED_STATES, dwValue);

    dprintf("  Persisted host states:              ");

    if (!dwValue)
        dprintf("None");

    if (dwValue & CVY_PERSIST_STATE_STARTED) {
        dprintf("Started");

        if ((dwValue &= ~CVY_PERSIST_STATE_STARTED))
            dprintf(", ");
    }

    if (dwValue & CVY_PERSIST_STATE_STOPPED) {
        dprintf("Stopped");

        if ((dwValue &= ~CVY_PERSIST_STATE_STOPPED))
            dprintf(", ");
    }

    if (dwValue & CVY_PERSIST_STATE_SUSPENDED) {
        dprintf("Suspended");

        if ((dwValue &= ~CVY_PERSIST_STATE_SUSPENDED))
            dprintf(", ");
    }

    dprintf("\n");

    dprintf("\n");

    /* Get the multicast support flag. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_MULTICAST_SUPPORT, dwValue);

    dprintf("  Multicast support enabled:          %s\n", (dwValue) ? "Yes" : "No");

    /* Get the IGMP support flag. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_IGMP_SUPPORT, dwValue);

    dprintf("  IGMP multicast support enabled:     %s\n", (dwValue) ? "Yes" : "No");

    /* Get the ICMP filter flag. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_FILTER_ICMP, dwValue);

    dprintf("  ICMP receive filtering enabled:     %s\n", (dwValue) ? "Yes" : "No");

    dprintf("\n");

    dprintf("  Remote control settings\n");

    /* Get the remote control support flag. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_REMOTE_CONTROL_ENABLED, dwValue);

    dprintf("      Enabled:                        %s\n", (dwValue) ? "Yes" : "No");

    /* Get the remote control port. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_REMOTE_CONTROL_PORT, dwValue);

    dprintf("      Port number:                    %u\n", dwValue);

    /* Get the host priority. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_REMOTE_CONTROL_PASSWD, dwValue);

    dprintf("      Password:                       0x%08x\n", dwValue);

    dprintf("\n");

    dprintf("  Cluster IP settings\n");

    /* Get the offset of the cluster IP address and retrieve the string from that address. */
    if (GetFieldOffset(CVY_PARAMS, CVY_PARAMS_FIELD_CL_IP_ADDR, &dwValue))
        dprintf("Can't get offset of %s in %s\n", CVY_PARAMS_FIELD_CL_IP_ADDR, CVY_PARAMS);
    else {
        pAddr = pParams + dwValue;

        /* Retrieve the contexts of the string and store it in a buffer. */
        GetString(pAddr, szString, CVY_MAX_CL_IP_ADDR + 1);

        dprintf("      IP address:                     %ls\n", szString);
    }

    /* Get the offset of the cluster netmask and retrieve the string from that address. */
    if (GetFieldOffset(CVY_PARAMS, CVY_PARAMS_FIELD_CL_NET_MASK, &dwValue))
        dprintf("Can't get offset of %s in %s\n", CVY_PARAMS_FIELD_CL_NET_MASK, CVY_PARAMS);
    else {
        pAddr = pParams + dwValue;

        /* Retrieve the contexts of the string and store it in a buffer. */
        GetString(pAddr, szString, CVY_MAX_CL_NET_MASK + 1);

        dprintf("      Netmask:                        %ls\n", szString);
    }

    /* Get the offset of the cluster MAC address and retrieve the MAC from that address. */
    if (GetFieldOffset(CVY_PARAMS, CVY_PARAMS_FIELD_CL_MAC_ADDR, &dwValue))
        dprintf("Can't get offset of %s in %s\n", CVY_PARAMS_FIELD_CL_MAC_ADDR, CVY_PARAMS);
    else {
        pAddr = pParams + dwValue;

        /* Retrieve the contexts of the string and store it in a buffer. */
        GetString(pAddr, szString, CVY_MAX_NETWORK_ADDR + 1);

        dprintf("      MAC address:                    %ls\n", szString);
    }

    /* Get the offset of the cluster IGMP multicast address and retrieve the string from that address. */
    if (GetFieldOffset(CVY_PARAMS, CVY_PARAMS_FIELD_CL_IGMP_ADDR, &dwValue))
        dprintf("Can't get offset of %s in %s\n", CVY_PARAMS_FIELD_CL_IGMP_ADDR, CVY_PARAMS);
    else {
        pAddr = pParams + dwValue;

        /* Retrieve the contexts of the string and store it in a buffer. */
        GetString(pAddr, szString, CVY_MAX_CL_IGMP_ADDR + 1);

        dprintf("      IGMP multicast IP address:      %ls\n", szString);
    }

    /* Get the offset of the cluster name and retrieve the string from that address. */
    if (GetFieldOffset(CVY_PARAMS, CVY_PARAMS_FIELD_CL_NAME, &dwValue))
        dprintf("Can't get offset of %s in %s\n", CVY_PARAMS_FIELD_CL_NAME, CVY_PARAMS);
    else {
        pAddr = pParams + dwValue;

        /* Retrieve the contexts of the string and store it in a buffer. */
        GetString(pAddr, szString, CVY_MAX_DOMAIN_NAME + 1);

        dprintf("      Domain name:                    %ls\n", szString);
    }

    dprintf("\n");

    dprintf("  Dedicated IP settings\n");

    /* Get the offset of the dedicated IP address and retrieve the string from that address. */
    if (GetFieldOffset(CVY_PARAMS, CVY_PARAMS_FIELD_DED_IP_ADDR, &dwValue))
        dprintf("Can't get offset of %s in %s\n", CVY_PARAMS_FIELD_DED_IP_ADDR, CVY_PARAMS);
    else {
        pAddr = pParams + dwValue;

        /* Retrieve the contexts of the string and store it in a buffer. */
        GetString(pAddr, szString, CVY_MAX_DED_IP_ADDR + 1);

        dprintf("      IP address:                     %ls\n", szString);
    }

    /* Get the offset of the dedicated netmask and retrieve the string from that address. */
    if (GetFieldOffset(CVY_PARAMS, CVY_PARAMS_FIELD_DED_NET_MASK, &dwValue))
        dprintf("Can't get offset of %s in %s\n", CVY_PARAMS_FIELD_DED_NET_MASK, CVY_PARAMS);
    else {
        pAddr = pParams + dwValue;

        /* Retrieve the contexts of the string and store it in a buffer. */
        GetString(pAddr, szString, CVY_MAX_DED_NET_MASK + 1);

        dprintf("      Netmask:                        %ls\n", szString);
    }

    dprintf("\n");
    
    /* Get the offset of the BDA teaming parameters structure. */
    if (GetFieldOffset(CVY_PARAMS, CVY_PARAMS_FIELD_BDA_TEAMING, &dwValue))
        dprintf("Can't get offset of %s in %s\n", CVY_PARAMS_FIELD_BDA_TEAMING, CVY_PARAMS);
    else {
        ULONG64 pBDA = pParams + dwValue;

        /* Find out whether or not teaming is active on this adapter. */
        GetFieldValue(pBDA, CVY_BDA, CVY_BDA_FIELD_ACTIVE, dwValue);
        
        dprintf("  Bi-directional affinity teaming:    %s\n", (dwValue) ? "Active" : "Inactive");

        /* Get the offset of the team ID and retrieve the string from that address. */
        if (GetFieldOffset(CVY_BDA, CVY_BDA_FIELD_TEAM_ID, &dwValue))
            dprintf("Can't get offset of %s in %s\n", CVY_BDA_FIELD_TEAM_ID, CVY_BDA);
        else {
            pAddr = pBDA + dwValue;
            
            /* Retrieve the contexts of the string and store it in a buffer. */
            GetString(pAddr, szString, CVY_MAX_BDA_TEAM_ID + 1);
            
            dprintf("      Team ID:                        %ls\n", szString);
        }

        /* Get the master flag. */
        GetFieldValue(pBDA, CVY_BDA, CVY_BDA_FIELD_MASTER, dwValue);
        
        dprintf("      Master:                         %s\n", (dwValue) ? "Yes" : "No");

        /* Get the reverse hashing flag. */
        GetFieldValue(pBDA, CVY_BDA, CVY_BDA_FIELD_REVERSE_HASH, dwValue);
        
        dprintf("      Reverse hashing:                %s\n", (dwValue) ? "Yes" : "No");
    }

    /* If we're printing at low verbosity, bail out here. */
    if (dwVerbosity == VERBOSITY_LOW) return;

    dprintf("\n");

    /* Get the offset of the port rules and pass it to PrintPortRules. */
    if (GetFieldOffset(CVY_PARAMS, CVY_PARAMS_FIELD_PORT_RULES, &dwValue))
        dprintf("Can't get offset of %s in %s\n", CVY_PARAMS_FIELD_PORT_RULES, CVY_PARAMS);
    else {
        pAddr = pParams + dwValue;
        
        /* Get the number of port rules. */
        GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_NUM_RULES, dwValue);

        PrintPortRules(dwValue, pAddr);
    }

    /* If we're printing at medium verbosity, bail out here. */
    if (dwVerbosity == VERBOSITY_MEDIUM) return;

    dprintf("\n");

    /* Get the heartbeat period. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_ALIVE_PERIOD, dwValue);

    dprintf("  Heartbeat period:                   %u millisecond(s)\n", dwValue);

    /* Get the heartbeat loss tolerance. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_ALIVE_TOLERANCE, dwValue);

    dprintf("  Heartbeat loss tolerance:           %u\n", dwValue);

    dprintf("\n");

    /* Get the number of remote control actions to allocate. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_NUM_ACTIONS, dwValue);

    dprintf("  Number of actions to allocate:      %u\n", dwValue);

    /* Get the number of packets to allocate. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_NUM_PACKETS, dwValue);

    dprintf("  Number of packets to allocate:      %u\n", dwValue);

    /* Get the number of heartbeats to allocate. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_NUM_PINGS, dwValue);

    dprintf("  Number of heartbeats to allocate:   %u\n", dwValue);

    /* Get the number of descriptors per allocation. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_NUM_DESCR, dwValue);

    dprintf("  Descriptors per allocation:         %u\n", dwValue);

    /* Get the maximum number of descriptor allocations. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_MAX_DESCR, dwValue);

    dprintf("  Maximum Descriptors allocations:    %u\n", dwValue);

    dprintf("\n");

    /* Get the TCP connection descriptor timeout. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_TCP_TIMEOUT, dwValue);

    dprintf("  TCP descriptor timeout:             %u second(s)\n", dwValue);

    /* Get the IPSec connection descriptor timeout. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_IPSEC_TIMEOUT, dwValue);

    dprintf("  IPSec descriptor timeout:           %u second(s)\n", dwValue);

    dprintf("\n");

    /* Get the NetBT support flag. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_NBT_SUPPORT, dwValue);

    dprintf("  NetBT support enabled:              %s\n", (dwValue) ? "Yes" : "No");

    /* Get the multicast spoof flag. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_MCAST_SPOOF, dwValue);

    dprintf("  Multicast spoofing enabled:         %s\n", (dwValue) ? "Yes" : "No");
    
    /* Get the netmon passthru flag. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_NETMON_PING, dwValue);

    dprintf("  Netmon heartbeat passthru enabled:  %s\n", (dwValue) ? "Yes" : "No");

    /* Get the mask source MAC flag. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_MASK_SRC_MAC, dwValue);

    dprintf("  Mask source MAC enabled:            %s\n", (dwValue) ? "Yes" : "No");

    /* Get the convert MAC flag. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_CONVERT_MAC, dwValue);

    dprintf("  IP to MAC conversion enabled:       %s\n", (dwValue) ? "Yes" : "No");

    dprintf("\n");

    /* Get the IP change delay value. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_IP_CHANGE_DELAY, dwValue);

    dprintf("  IP change delay:                    %u millisecond(s)\n", dwValue);

    /* Get the dirty descriptor cleanup delay value. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_CLEANUP_DELAY, dwValue);

    dprintf("  Dirty connection cleanup delay:     %u millisecond(s)\n", dwValue);
}

/*
 * Function: PrintPortRules
 * Description: Prints the NLB port rules.
 * Author: Created by shouse, 1.21.01
 */
void PrintPortRules (ULONG dwNumRules, ULONG64 pRules) {
    ULONG dwRuleSize;
    ULONG dwIndex;
    ULONG64 pAddr;

    /* Make sure the address is non-NULL. */
    if (!pRules) {
        dprintf("Error: NLB port rule block is NULL.\n");
        return;
    }

    dprintf("  Configured port rules (%u)\n", dwNumRules);

    /* If no port rules are present, print a notification. */
    if (!dwNumRules) {
        dprintf("      There are no port rules configured on this cluster.\n");
        return;
    } 

    /* Print the column headers. */
    dprintf("         Virtual IP   Start   End   Protocol    Mode    Priority   Load Weight  Affinity\n");
    dprintf("      --------------- -----  -----  --------  --------  --------   -----------  --------\n");

    /* Find out the size of a CVY_RULE structure. */
    dwRuleSize = GetTypeSize(CVY_RULE);

    /* Loop through all port rules and print the configuration. Note: The print statements
       are full of seemingly non-sensicle format strings, but trust me, they're right. */
    for (dwIndex = 0; dwIndex < dwNumRules; dwIndex++) {
        IN_ADDR dwIPAddr;
        CHAR * szString;
        ULONG dwValue;
        USHORT wValue;

        /* Get the VIP.  Convert from a DWORD to a string. */
        GetFieldValue(pRules, CVY_RULE, CVY_RULE_FIELD_VIP, dwValue);

        if (dwValue != CVY_ALL_VIP) {
            dwIPAddr.S_un.S_addr = dwValue;
            szString = inet_ntoa(dwIPAddr);
            
            dprintf("      %-15s", szString);
        } else
            dprintf("      %-15s", "ALL VIPs");

        /* Get the start port. */
        GetFieldValue(pRules, CVY_RULE, CVY_RULE_FIELD_START_PORT, dwValue);

        dprintf(" %5u", dwValue);

        /* Get the end port. */
        GetFieldValue(pRules, CVY_RULE, CVY_RULE_FIELD_END_PORT, dwValue);

        dprintf("  %5u", dwValue);

        /* Figure out the protocol. */
        GetFieldValue(pRules, CVY_RULE, CVY_RULE_FIELD_PROTOCOL, dwValue);

        switch (dwValue) {
            case CVY_TCP:
                dprintf("     %s  ", "TCP");
                break;
            case CVY_UDP:
                dprintf("     %s  ", "UDP");
                break;
            case CVY_TCP_UDP:
                dprintf("    %s  ", "Both");
                break;
            default:
                dprintf("   %s", "Unknown");
                break;
        }

        /* Find the rule mode. */
        GetFieldValue(pRules, CVY_RULE, CVY_RULE_FIELD_MODE, dwValue);

        switch (dwValue) {
        case CVY_SINGLE: 
            /* Print mode and priority. */
            dprintf("   %s ", "Single");

            /* Get the handling priority. */
            GetFieldValue(pRules, CVY_RULE, CVY_RULE_FIELD_PRIORITY, dwValue);
            
            dprintf("     %2u   ", dwValue);
            break;
        case CVY_MULTI: 
            /* Print mode, weight and affinity. */
            dprintf("  %s", "Multiple");

            dprintf("  %8s", "");
            
            /* Get the equal load flag. */
            GetFieldValue(pRules, CVY_RULE, CVY_RULE_FIELD_EQUAL_LOAD, wValue);

            if (wValue) {
                dprintf("      %5s   ", "Equal");
            } else {
                /* If distribution is unequal, get the load weight. */
                GetFieldValue(pRules, CVY_RULE, CVY_RULE_FIELD_LOAD_WEIGHT, dwValue);

                dprintf("       %3u    ", dwValue);
            }

            /* Get the affinity for this rule. */
            GetFieldValue(pRules, CVY_RULE, CVY_RULE_FIELD_AFFINITY, wValue);

            switch (wValue) {
            case CVY_AFFINITY_NONE:
                dprintf("    %s", "None");
                break;
            case CVY_AFFINITY_SINGLE:
                dprintf("   %s", "Single");
                break;
            case CVY_AFFINITY_CLASSC:
                dprintf("   %s", "Class C");
                break;
            default:
                dprintf("   %s", "Unknown");
                break;
            }

            break;
        case CVY_NEVER: 
            /* Print the mode. */
            dprintf("  %s", "Disabled");
            break;
        default:

            break;
        }

        dprintf("\n");

        /* Advance the pointer to the next index in the array of structures. */
        pRules += dwRuleSize;
    }
}

/*
 * Function: PrintLoad
 * Description: Prints the contents of the CVY_LOAD structure at the specified verbosity.
 *              LOW (0) 
 *              MEDIUM (1) 
 *              HIGH (2) 
 * Author: Created by shouse, 1.21.01
 */
void PrintLoad (ULONG64 pLoad, ULONG dwVerbosity) {
    WCHAR szString[256];
    ULONG dwMissedPings[CVY_MAX_HOSTS];
    ULONG dwDirtyBins[CVY_MAX_BINS];
    ULONG64 pQueue;
    ULONG64 pAddr;
    ULONG dwValue;
    ULONG dwHostID;
    BOOL bActive;
    BOOL bValue;

    /* Make sure the address is non-NULL. */
    if (!pLoad) {
        dprintf("Error: NLB load block is NULL.\n");
        return;
    }

    dprintf("NLB Load Block 0x%p\n", pLoad);

    /* Get the LOAD_CTXT_CODE from the structure to make sure that this address
       indeed points to a valid NLB load block. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_CODE, dwValue);
    
    if (dwValue != LOAD_CTXT_CODE) {
        dprintf("  Error: Invalid NLB load block.  Wrong code found (0x%08x).\n", dwValue);
        return;
    } 

    /* Get my host ID. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_HOST_ID, dwHostID);

    /* Determine whether or not the load context has been initialized. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_REF_COUNT, dwValue);

    dprintf("  Reference count:                    %u\n", dwValue);

    /* Determine whether or not the load context has been initialized. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_INIT, bValue);

    dprintf("  Load initialized:                   %s\n", (bValue) ? "Yes" : "No");

    /* Determine whether or not the load context is active. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_ACTIVE, bActive);

    dprintf("  Load active:                        %s\n", (bActive) ? "Yes" : "No");

    /* Get the number of total packets handled since last convergence. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_PACKET_COUNT, dwValue);

    dprintf("  Packets handled since convergence:  %u\n", dwValue);

    /* Get the number of currently active connections. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_CONNECTIONS, dwValue);

    dprintf("  Current active connections:         %u\n", dwValue);

    dprintf("\n");

    /* Find out the level of consistency from incoming heartbeats. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_CONSISTENT, bValue);

    dprintf("  Consistent heartbeats detected:     %s\n", (bValue) ? "Yes" : "No");

    /* Have we seen duplicate host IDs? */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_DUP_HOST_ID, bValue);

    dprintf("      Duplicate host IDs:             %s\n", (bValue) ? "Yes" : "No");

    /* Have we seen duplicate handling priorities? */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_DUP_PRIORITY, bValue);

    dprintf("      Duplicate handling priorities:  %s\n", (bValue) ? "Yes" : "No");

    /* Have we seen inconsistent BDA teaming configuration? */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_BAD_TEAM_CONFIG, bValue);

    dprintf("      Inconsistent BDA teaming:       %s\n", (bValue) ? "Yes" : "No");

    /* Have we seen inconsistent BDA teaming configuration? */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_LEGACY_HOSTS, dwValue);

    dprintf("      Mixed cluster detected:         %s\n", (dwValue) ? "Yes" : "No");

    /* Have we seen a different number of port rules? */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_BAD_NUM_RULES, bValue);

    dprintf("      Different number of port rules: %s\n", (bValue) ? "Yes" : "No");

    /* Is the new host map bad? */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_BAD_NEW_MAP, bValue);

    dprintf("      Invalid new host map:           %s\n", (bValue) ? "Yes" : "No");

    /* Do the maps overlap? */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_OVERLAPPING_MAP, bValue);

    dprintf("      Overlapping maps:               %s\n", (bValue) ? "Yes" : "No");

    /* Was there an error in updating bins? */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_RECEIVING_BINS, bValue);

    dprintf("      Received bins already owned:    %s\n", (bValue) ? "Yes" : "No");

    /* Were there orphaned bins after an update? */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_ORPHANED_BINS, bValue);

    dprintf("      Orphaned bins:                  %s\n", (bValue) ? "Yes" : "No");

    dprintf("\n");

    /* Get the current host map. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_HOST_MAP, dwValue);

    dprintf("  Current host map:                   0x%08x ", dwValue);

    /* If there are hosts in the map, print them. */
    if (dwValue) {
        dprintf("(");
        PrintHostList(dwValue);
        dprintf(")");
    }

    dprintf("\n");

    /* Get the current map of pinged hosts. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_PING_MAP, dwValue);

    dprintf("  Ping'd host map:                    0x%08x ", dwValue);

    /* If there are hosts in the map, print them. */
    if (dwValue) {
        dprintf("(");
        PrintHostList(dwValue);
        dprintf(")");
    }

    dprintf("\n");

    /* Get the map from the last convergence. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_LAST_MAP, dwValue);

    dprintf("  Host map after last convergence:    0x%08x ", dwValue);

    /* If there are hosts in the map, print them. */
    if (dwValue) {
        dprintf("(");
        PrintHostList(dwValue);
        dprintf(")");
    }

    dprintf("\n");

    dprintf("\n");
    
    /* Get the stable host map. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_STABLE_MAP, dwValue);

    dprintf("  Stable host map:                    0x%08x ", dwValue);

    /* If there are hosts in the map, print them. */
    if (dwValue) {
        dprintf("(");
        PrintHostList(dwValue);
        dprintf(")");
    }

    dprintf("\n");

    /* Get the minimum number of timeouts with stable condition. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_MIN_STABLE, dwValue);

    dprintf("  Stable timeouts necessary:          %u\n", dwValue);

    /* Get the number of local stable timeouts. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_LOCAL_STABLE, dwValue);

    dprintf("  Local stable timeouts:              %u\n", dwValue);

    /* Get the number of global stable timeouts. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_ALL_STABLE, dwValue);

    dprintf("  Global stable timeouts:             %u\n", dwValue);

    dprintf("\n");

    /* Get the default timeout period. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_DEFAULT_TIMEOUT, dwValue);

    dprintf("  Default timeout interval:           %u millisecond(s)\n", dwValue);

    /* Get the current timeout period. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_CURRENT_TIMEOUT, dwValue);

    dprintf("  Current timeout interval:           %u millisecond(s)\n", dwValue);

    /* Get the ping miss tolerance. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_PING_TOLERANCE, dwValue);

    dprintf("  Missed ping tolerance:              %u\n", dwValue);

    /* Get the missed ping array. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_PING_MISSED, dwMissedPings);

    dprintf("  Missed pings:                       ");

    PrintMissedPings(dwMissedPings);

    dprintf("\n");

    /* Are we waiting for a cleanup? */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_CLEANUP_WAITING, bValue);

    dprintf("  Cleanup waiting:                    %s\n", (bValue) ? "Yes" : "No");

    /* Get the cleanup timeout. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_CLEANUP_TIMEOUT, dwValue);

    dprintf("  Cleanup timeout:                    %.1f second(s)\n", (float)(dwValue/1000.0));

    /* Get the current cleanup wait time. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_CLEANUP_CURRENT, dwValue);

    dprintf("  Current cleanup wait time:          %.1f second(s)\n", (float)(dwValue/1000.0));

    /* Get the number of dirty connection descriptors. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_NUM_DIRTY, dwValue);

    dprintf("  Number of dirty connections:        %u\n", dwValue);

    dprintf("\n");

    /* Get the TCP connection descriptor timeout. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_CLOCK_SECONDS, dwValue);

    dprintf("  Internal clock time:                %u.", dwValue);

    /* Get the TCP connection descriptor timeout. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_CLOCK_MILISECONDS, dwValue);

    dprintf("%03u second(s)\n", dwValue);

    /* Get the number of convergences since we joined the cluster. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_NUM_CONVERGENCES, dwValue);

    dprintf("  Total number of convergences:       %u\n", dwValue);

    /* Get the time since the last convergence completed. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_LAST_CONVERGENCE, dwValue);

    dprintf("  Time of last completed convergence: %u.0 second(s)\n", dwValue);

    dprintf("\n");

    /* Get the maximum number of allocations allowed. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_MAX_DSCR_OUT, dwValue);

    dprintf("  Maximum descriptor allocations:     %u\n", dwValue);

    /* Get the number of allocations thusfar. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_NUM_DSCR_OUT, dwValue);

    dprintf("  Number of descriptor allocations:   %u\n", dwValue);

    /* Get the inhibited allocations flag. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_INHIBITED_ALLOC, bValue);

    dprintf("  Allocations inhibited:              %s\n", (bValue) ? "Yes" : "No");

    /* Get the failed allocations flag. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_FAILED_ALLOC, bValue);

    dprintf("  Allocations failed:                 %s\n", (bValue) ? "Yes" : "No");

    /* If wer're printing at low verbosity, bail out here. */
    if (dwVerbosity == VERBOSITY_LOW) return;

    dprintf("\n");
    
    /* Get the address of the global established connection queue. */
    pAddr = GetExpression(CONN_ESTABQ);

    if (!pAddr) 
        /* If this global variable is NULL, check the symbols. */
        ErrorCheckSymbols(CONN_ESTABQ);
    else
        dprintf("  Global established connections[0]:  0x%p\n", pAddr);

    /* Get the address of the global established connection queue. */
    pAddr = GetExpression(CONN_PENDINGQ);

    if (!pAddr) 
        /* If this global variable is NULL, check the symbols. */
        ErrorCheckSymbols(CONN_PENDINGQ);
    else
        dprintf("  Global pending connections[0]:      0x%p\n", pAddr);

    /* Get the address of the global established connection queue. */
    pAddr = GetExpression(PENDING_CONN_POOL);

    if (!pAddr) 
        /* If this global variable is NULL, check the symbols. */
        ErrorCheckSymbols(PENDING_CONN_POOL);
    else {
        /* Get the address of the global pending connection state pool. */
        pAddr = GetPointerFromAddress(pAddr);

        dprintf("  Global pending connection pool:     0x%p\n", pAddr);
    }

    dprintf("\n");

    /* Get the number of allocations thusfar. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_FREE_POOL, pAddr);

    dprintf("  Free descriptor pool:               0x%p\n", pAddr);

    /* Get the offset of the connection descriptor queue hash array. */
    if (GetFieldOffset(LOAD_CTXT, LOAD_CTXT_FIELD_CONN_QUEUE, &dwValue))
        dprintf("Can't get offset of %s in %s\n", LOAD_CTXT_FIELD_CONN_QUEUE, LOAD_CTXT);
    else {
        pAddr = pLoad + dwValue;

        dprintf("  Connection descriptor queue[0]:     0x%p\n", pAddr);
    }

    /* Get the offset of the dirty descriptor queue. */
    if (GetFieldOffset(LOAD_CTXT, LOAD_CTXT_FIELD_DIRTY_QUEUE, &dwValue))
        dprintf("Can't get offset of %s in %s\n", LOAD_CTXT_FIELD_DIRTY_QUEUE, LOAD_CTXT);
    else {
        pAddr = pLoad + dwValue;

        dprintf("  Dirty descriptor queue:             0x%p\n", pAddr);
    }

    /* Get the offset of the recovery queue. */
    if (GetFieldOffset(LOAD_CTXT, LOAD_CTXT_FIELD_RECOVERY_QUEUE, &dwValue))
        dprintf("Can't get offset of %s in %s\n", LOAD_CTXT_FIELD_RECOVERY_QUEUE, LOAD_CTXT);
    else {
        pAddr = pLoad + dwValue;

        dprintf("  Recovery descriptor queue:          0x%p\n", pAddr);
    }

    /* Get the offset of the TCP descriptor timeout queue. */
    if (GetFieldOffset(LOAD_CTXT, LOAD_CTXT_FIELD_TCP_TIMEOUT_QUEUE, &dwValue))
        dprintf("Can't get offset of %s in %s\n", LOAD_CTXT_FIELD_TCP_TIMEOUT_QUEUE, LOAD_CTXT);
    else {
        pAddr = pLoad + dwValue;

        dprintf("  TCP descriptor timeout queue:       0x%p\n", pAddr);
    }

    /* Get the offset of the IPSec descriptor timeout queue. */
    if (GetFieldOffset(LOAD_CTXT, LOAD_CTXT_FIELD_IPSEC_TIMEOUT_QUEUE, &dwValue))
        dprintf("Can't get offset of %s in %s\n", LOAD_CTXT_FIELD_IPSEC_TIMEOUT_QUEUE, LOAD_CTXT);
    else {
        pAddr = pLoad + dwValue;

        dprintf("  IPSec descriptor timeout queue:     0x%p\n", pAddr);
    }

    dprintf("\n");

    /* Get the dirty bin array. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_DIRTY_BINS, dwDirtyBins);

    dprintf("  Dirty bins:                         ");

    /* Print the bins which have dirty connections. */
    PrintDirtyBins(dwDirtyBins);

    dprintf("\n");

    /* Print load module state for all of the configured NLB port rules. */
    {
        ULONG dwPortRuleStateSize;
        ULONG dwNumRules = 0;
        ULONG dwIndex;
        ULONG dwTemp;

        /* Get the offset of the port rule state structures and use PrintPortRuleState to print them. */
        if (GetFieldOffset(LOAD_CTXT, LOAD_CTXT_FIELD_PORT_RULE_STATE, &dwValue))
            dprintf("Can't get offset of %s in %s\n", LOAD_CTXT_FIELD_PORT_RULE_STATE, LOAD_CTXT);
        else {
            /* If the load module is not currently active, then we really can't trust the
               number of rules listed in the CVY_PARAMS structure, as a reload may have 
               occurred while the load module was stopped.  Get the number of rules from
               the heartbeat instead, which should be consistent with the state of the 
               load module the last time it was active. */
            if (!bActive) {
                USHORT wValue;

                dprintf("Warning:  The load module is inactive and therefore the information in the NLB parameters\n");
                dprintf("          structure is potentially out-of-sync with the current state of the load module.\n");
                dprintf("          The number of port rules will be extracted from the heartbeat message rather than\n");
                dprintf("          from the NLB parameters structure; the number of port rules indicated in the heart-\n");
                dprintf("          beat is consistent with the number of port rules configured in the load module at\n");
                dprintf("          the last instant the load module was active.\n");
                dprintf("\n");
                
                /* Get the offset of the heartbeat structure and use PrintHeartbeat to print it. */
                if (GetFieldOffset(LOAD_CTXT, LOAD_CTXT_FIELD_PING, &dwTemp))
                    dprintf("Can't get offset of %s in %s\n", LOAD_CTXT_FIELD_PING, LOAD_CTXT);
                else {
                    pAddr = pLoad + dwTemp;
                    
                    /* Get the number of port rules. */
                    GetFieldValue(pAddr, PING_MSG, PING_MSG_FIELD_NUM_RULES, wValue);

                    /* Cast the USHORT to a ULONG.  Subtract one for the DEFAULT port rule, 
                       which is accounted for in the structure of the loop below - do NOT
                       count it here. */
                    dwNumRules = (ULONG)(wValue - 1);
                }
            } else {
                /* Get the offset of the params pointer. */
                if (GetFieldOffset(LOAD_CTXT, LOAD_CTXT_FIELD_PARAMS, &dwTemp))
                    dprintf("Can't get offset of %s in %s\n", LOAD_CTXT_FIELD_PARAMS, LOAD_CTXT);
                else {
                    pAddr = pLoad + dwTemp;
                    
                    /* Retrieve the pointer. */
                    pAddr = GetPointerFromAddress(pAddr);
                    
                    /* Get the number of port rules from the params block. */
                    GetFieldValue(pAddr, CVY_PARAMS, CVY_PARAMS_FIELD_NUM_RULES, dwNumRules);
                }
            }

            /* Set the address of the port rule state array. */
            pAddr = pLoad + dwValue;
        }
        
        /* Find out the size of a BIN_STATE structure. */
        dwPortRuleStateSize = GetTypeSize(BIN_STATE);
        
        /* NOTE: its "less than or equal" as opposed to "less than" because we need to include 
           the DEFAULT port rule, which is always at index "num rules" (i.e. the last rule). */
        for (dwIndex = 0; dwIndex <= dwNumRules; dwIndex++) {
            /* Print the state information for the port rule. */
            PrintPortRuleState(pAddr, dwHostID, (dwIndex == dwNumRules) ? TRUE : FALSE);
        
            if (dwIndex < dwNumRules) dprintf("\n");
        
            /* Advance the pointer to the next port rule. */
            pAddr += dwPortRuleStateSize;
        }
    }

    /* If wer're printing at medium verbosity, bail out here. */
    if (dwVerbosity == VERBOSITY_MEDIUM) return;

    dprintf("\n");

    dprintf("  Heartbeat message\n");

    /* Get the offset of the heartbeat structure and use PrintHeartbeat to print it. */
    if (GetFieldOffset(LOAD_CTXT, LOAD_CTXT_FIELD_PING, &dwValue))
        dprintf("Can't get offset of %s in %s\n", LOAD_CTXT_FIELD_PING, LOAD_CTXT);
    else {
        pAddr = pLoad + dwValue;
     
        /* Print the NLB heartbeat contents. */
        PrintHeartbeat(pAddr);
    }
}

/*
 * Function: PrintResp
 * Description: Prints the NLB private data associated with the given packet.
 * Author: Created by shouse, 1.31.01
 */
void PrintResp (ULONG64 pPacket, ULONG dwDirection) {
    ULONG64 pPacketStack;
    ULONG bStackLeft;
    ULONG64 pProtReserved = 0;
    ULONG64 pIMReserved = 0;
    ULONG64 pMPReserved = 0;
    ULONG64 pResp;
    ULONG64 pAddr;
    ULONG dwValue;
    USHORT wValue;

    /* Make sure the address is non-NULL. */
    if (!pPacket) {
        dprintf("Error: Packet is NULL.\n");
        return;
    }

    /* Print a warning concerning the importance of knowing whether its a send or receive. */
    dprintf("Assuming packet 0x%p is on the %s packet path.  If this is\n", pPacket, 
            (dwDirection == DIRECTION_RECEIVE) ? "RECEIVE" : "SEND");
    dprintf("  incorrect, the information displayed below MAY be incorrect.\n");

    dprintf("\n");

    /* Get the current NDIS packet stack. */
    pPacketStack = PrintCurrentPacketStack(pPacket, &bStackLeft);

    dprintf("\n");

    if (pPacketStack) {
        /* Get the offset of the IMReserved field in the packet stack. */
        if (GetFieldOffset(NDIS_PACKET_STACK, NDIS_PACKET_STACK_FIELD_IMRESERVED, &dwValue))
            dprintf("Can't get offset of %s in %s\n", NDIS_PACKET_STACK_FIELD_IMRESERVED, NDIS_PACKET_STACK);
        else {
            pAddr = pPacketStack + dwValue;
            
            /* Get the resp pointer from the IMReserved field. */
            pIMReserved = GetPointerFromAddress(pAddr);
        }
    }
    
    /* Get the offset of the MiniportReserved field in the packet. */
    if (GetFieldOffset(NDIS_PACKET, NDIS_PACKET_FIELD_MPRESERVED, &dwValue))
        dprintf("Can't get offset of %s in %s\n", NDIS_PACKET_FIELD_MPRESERVED, NDIS_PACKET);
    else {
        pAddr = pPacket + dwValue;
        
        /* Get the resp pointer from the MPReserved field. */
        pMPReserved = GetPointerFromAddress(pAddr);
    }
    
    /* Get the offset of the ProtocolReserved field in the packet. */
    if (GetFieldOffset(NDIS_PACKET, NDIS_PACKET_FIELD_PROTRESERVED, &dwValue))
        dprintf("Can't get offset of %s in %s\n", NDIS_PACKET_FIELD_PROTRESERVED, NDIS_PACKET);
    else {
        pProtReserved = pPacket + dwValue;
    }

    /* Mimic #define MAIN_RESP_FIELD(pkt, left, ps, rsp, send) (from wlbs\driver\main.h). */
    if (pPacketStack) {
        if (pIMReserved) 
            pResp = pIMReserved;
        else if (dwDirection == DIRECTION_SEND) 
            pResp = pProtReserved;
        else if (pMPReserved) 
            pResp = pMPReserved;
        else 
            pResp = pProtReserved;
    } else {
        if (dwDirection == DIRECTION_SEND) 
            pResp = pProtReserved;
        else if (pMPReserved) 
            pResp = pMPReserved;
        else 
            pResp = pProtReserved;
    }

    dprintf("NLB Main Protocol Reserved Block 0x%p\n");
    
    /* Get the offset of the miscellaneous pointer. */
    if (GetFieldOffset(MAIN_PROTOCOL_RESERVED, MAIN_PROTOCOL_RESERVED_FIELD_MISCP, &dwValue))
        dprintf("Can't get offset of %s in %s\n", MAIN_PROTOCOL_RESERVED_FIELD_MISCP, MAIN_PROTOCOL_RESERVED);
    else {
        pAddr = pResp + dwValue;
        
        /* Retrieve the pointer. */
        pAddr = GetPointerFromAddress(pAddr);

        dprintf("  Miscellaneous pointer:              0x%p\n", pAddr);
    }

    /* Retrieve the packet type from the NLB private data. */
    GetFieldValue(pResp, MAIN_PROTOCOL_RESERVED, MAIN_PROTOCOL_RESERVED_FIELD_TYPE, wValue);
    
    switch (wValue) {
    case MAIN_PACKET_TYPE_NONE:
        dprintf("  Packet type:                        %u (None)\n", wValue);
        break;
    case MAIN_PACKET_TYPE_PING:
        dprintf("  Packet type:                        %u (Heartbeat)\n", wValue);
        break;
    case MAIN_PACKET_TYPE_INDICATE:
        dprintf("  Packet type:                        %u (Indicate)\n", wValue);
        break;
    case MAIN_PACKET_TYPE_PASS:
        dprintf("  Packet type:                        %u (Passthrough)\n", wValue);
        break;
    case MAIN_PACKET_TYPE_CTRL:
        dprintf("  Packet type:                        %u (Remote Control)\n", wValue);
        break;
    case MAIN_PACKET_TYPE_TRANSFER:
        dprintf("  Packet type:                        %u (Transfer)\n", wValue);
        break;
    case MAIN_PACKET_TYPE_IGMP:
        dprintf("  Packet type:                        %u (IGMP)\n", wValue);
        break;
    default:
        dprintf("  Packet type:                        %u (Invalid)\n", wValue);
        break;
    }

    /* Retrieve the group from the NLB private data. */
    GetFieldValue(pResp, MAIN_PROTOCOL_RESERVED, MAIN_PROTOCOL_RESERVED_FIELD_GROUP, wValue);
    
    switch (wValue) {
    case MAIN_FRAME_UNKNOWN:
        dprintf("  Packet type:                        %u (Unknown)\n", wValue);
        break;
    case MAIN_FRAME_DIRECTED:
        dprintf("  Packet type:                        %u (Directed)\n", wValue);
        break;
    case MAIN_FRAME_MULTICAST:
        dprintf("  Packet type:                        %u (Multicast)\n", wValue);
        break;
    case MAIN_FRAME_BROADCAST:
        dprintf("  Packet type:                        %u (Broadcast)\n", wValue);
        break;
    default:
        dprintf("  Packet type:                        %u (Invalid)\n", wValue);
        break;
    }

    /* Retrieve the data field from the NLB private data. */
    GetFieldValue(pResp, MAIN_PROTOCOL_RESERVED, MAIN_PROTOCOL_RESERVED_FIELD_DATA, dwValue);
    
    dprintf("  Data:                               %u\n", dwValue);

    /* Retrieve the length field from the NLB private data. */
    GetFieldValue(pResp, MAIN_PROTOCOL_RESERVED, MAIN_PROTOCOL_RESERVED_FIELD_LENGTH, dwValue);
    
    dprintf("  Length:                             %u\n", dwValue);
}

/*
 * Function: PrintCurrentPacketStack
 * Description: Retrieves the current packet stack for the specified packet.  Note: this
 *              is heavily dependent on the current NDIS packet stacking mechanics - any
 *              changes to NDIS packet stacking could easily (will) break this.  This 
 *              entire function mimics NdisIMGetCurrentPacketStack().
 * Author: Created by shouse, 1.31.01
 */
ULONG64 PrintCurrentPacketStack (ULONG64 pPacket, ULONG * bStackLeft) {
    ULONG64 pNumPacketStacks;
    ULONG64 pPacketWrapper;
    ULONG64 pPacketStack;
    ULONG dwNumPacketStacks;
    ULONG dwStackIndexSize;
    ULONG dwPacketStackSize;
    ULONG dwCurrentIndex;

    /* Make sure the address is non-NULL. */
    if (!pPacket) {
        dprintf("Error: Packet is NULL.\n");
        *bStackLeft = 0;
        return 0;
    }

    /* Get the address of the global variable containing the number of packet stacks. */
    pNumPacketStacks = GetExpression(NDIS_PACKET_STACK_SIZE);

    if (!pNumPacketStacks) {
        ErrorCheckSymbols(NDIS_PACKET_STACK_SIZE);
        *bStackLeft = 0;
        return 0;
    }

    /* Get the number of packet stacks from the address. */
    dwNumPacketStacks = GetUlongFromAddress(pNumPacketStacks);

    /* Find out the size of a STACK_INDEX structure. */
    dwStackIndexSize = GetTypeSize(STACK_INDEX);

    /* Find out the size of a NDIS_PACKET_STACK structure. */
    dwPacketStackSize = GetTypeSize(NDIS_PACKET_STACK);

    /* This is the calculation we're doing (from ndis\sys\wrapper.h):
       #define SIZE_PACKET_STACKS (sizeof(STACK_INDEX) + (sizeof(NDIS_PACKET_STACK) * ndisPacketStackSize)) */
    pPacketStack = pPacket - (dwStackIndexSize + (dwPacketStackSize * dwNumPacketStacks));

    /* The wrapper is the packet address minus the size of the stack index.  
       See ndis\sys\wrapper.h.  We need this to get the current stack index. */
    pPacketWrapper = pPacket - dwStackIndexSize;

    dprintf("NDIS Packet Stack: 0x%p\n", pPacketStack);

    /* Retrieve the current stack index. */
    GetFieldValue(pPacketWrapper, NDIS_PACKET_WRAPPER, NDIS_PACKET_WRAPPER_FIELD_STACK_INDEX, dwCurrentIndex);

    dprintf("  Current stack index:                %d\n", dwCurrentIndex);

    if (dwCurrentIndex < dwNumPacketStacks) {
        /* If the current index is less than the number of stacks, then point the stack to 
           the right address and determine whether or not there is stack room left. */
        pPacketStack += dwCurrentIndex * dwPacketStackSize;
        *bStackLeft = (dwNumPacketStacks - dwCurrentIndex - 1) > 0;
    } else {
       /* If not, then we're out of stack space. */
        pPacketStack = 0;
        *bStackLeft = 0;
    }

    dprintf("  Current packet stack:               0x%p\n", pPacketStack);
    dprintf("  Stack remaining:                    %s\n", (*bStackLeft) ? "Yes" : "No");

    return pPacketStack;
}

/*
 * Function: PrintHostList
 * Description: Prints a list of hosts in a host map.
 * Author: Created by shouse, 2.1.01
 */
void PrintHostList (ULONG dwHostMap) {
    BOOL bFirst = TRUE;
    ULONG dwHostNum = 1;
    
    /* As long as there are hosts still in the map, print them. */
    while (dwHostMap) {
        /* If the least significant bit is set, print the host number. */
        if (dwHostMap & 0x00000001) {
            /* If this is the first host printed, just print the number. */
            if (bFirst) {
                dprintf("%u", dwHostNum);
                bFirst = FALSE;
            } else
                /* Otherwise, we need to print a comma first. */
                dprintf(", %u", dwHostNum);
        }
        
        /* Increment the host number and shift the map to the right one bit. */
        dwHostNum++;
        dwHostMap >>= 1;
    }
}

/*
 * Function: PrintMissedPings
 * Description: Prints a list hosts from which we are missing pings.
 * Author: Created by shouse, 2.1.01
 */
void PrintMissedPings (ULONG dwMissedPings[]) {
    BOOL bMissing = FALSE;
    ULONG dwIndex;

    /* Loop through the entire array of missed pings. */
    for (dwIndex = 0; dwIndex < CVY_MAX_HOSTS; dwIndex++) {
        /* If we're missing pings from this host, print the number missed and 
           the host priority, which is the index (host ID) plus one. */
        if (dwMissedPings[dwIndex]) {
            dprintf("\n      Missing %u ping(s) from Host %u", dwMissedPings[dwIndex], dwIndex + 1);
            
            /* Not the fact that we found at least one host with missing pings. */
            bMissing = TRUE;
        }
    }

    /* If we're missing no pings, print "None". */
    if (!bMissing) dprintf("None");

    dprintf("\n");
}

/*
 * Function: PrintDirtyBins
 * Description: Prints a list of bins with dirty connections.
 * Author: Created by shouse, 2.1.01
 */
void PrintDirtyBins (ULONG dwDirtyBins[]) {
    BOOL bFirst = TRUE;
    ULONG dwIndex;

    /* Loop through the entire array of dirty bins. */
    for (dwIndex = 0; dwIndex < CVY_MAX_BINS; dwIndex++) {
        if (dwDirtyBins[dwIndex]) {
            /* If this is the first bin printed, just print the number. */
            if (bFirst) {
                dprintf("%u", dwIndex);
                bFirst = FALSE;
            } else
                /* Otherwise, we need to print a comma first. */
                dprintf(", %u", dwIndex);
        }
    }

    /* If there are no dirty bins, print "None". */
    if (bFirst) dprintf("None");

    dprintf("\n");
}

/*
 * Function: PrintHeartbeat
 * Description: Prints the contents of the NLB heartbeat structure.
 * Author: Created by shouse, 2.1.01
 */
void PrintHeartbeat (ULONG64 pHeartbeat) {
    ULONG dwValue;
    USHORT wValue;
    ULONG dwIndex;
    ULONG dwRuleCode[CVY_MAX_RULES];
    ULONGLONG ddwCurrentMap[CVY_MAX_RULES];
    ULONGLONG ddwNewMap[CVY_MAX_RULES];
    ULONGLONG ddwIdleMap[CVY_MAX_RULES];
    ULONGLONG ddwReadyBins[CVY_MAX_RULES];
    ULONG dwLoadAmount[CVY_MAX_RULES];
    
    /* Make sure the address is non-NULL. */
    if (!pHeartbeat) {
        dprintf("Error: Heartbeat is NULL.\n");
        return;
    }

    /* Get the default host ID. */
    GetFieldValue(pHeartbeat, PING_MSG, PING_MSG_FIELD_DEFAULT_HOST_ID, wValue);
    
    dprintf("      DEFAULT host ID:                %u (%u)\n", wValue, wValue + 1);

    /* Get my host ID. */
    GetFieldValue(pHeartbeat, PING_MSG, PING_MSG_FIELD_HOST_ID, wValue);
    
    dprintf("      My host ID:                     %u (%u)\n", wValue, wValue + 1);

    /* Get my host code. */
    GetFieldValue(pHeartbeat, PING_MSG, PING_MSG_FIELD_HOST_CODE, dwValue);
    
    dprintf("      Unique host code:               0x%08x\n", dwValue);
    
    /* Get the host state. */
    GetFieldValue(pHeartbeat, PING_MSG, PING_MSG_FIELD_STATE, wValue);
    
    dprintf("      Host state:                     ");

    switch (wValue) {
    case HST_CVG:
        dprintf("Converging\n");
        break;
    case HST_STABLE:
        dprintf("Stable\n");
        break;
    case HST_NORMAL:
        dprintf("Normal\n");
        break;
    default:
        dprintf("Unknown\n");
        break;
    }

    /* Get the teaming configuration code. */
    GetFieldValue(pHeartbeat, PING_MSG, PING_MSG_FIELD_TEAMING_CODE, dwValue);
    
    dprintf("      BDA teaming configuration:      0x%08x\n", dwValue);

    /* Get the packet count. */
    GetFieldValue(pHeartbeat, PING_MSG, PING_MSG_FIELD_PACKET_COUNT, dwValue);
    
    dprintf("      Packets handled:                %u\n", dwValue);

    /* Get the number of port rules. */
    GetFieldValue(pHeartbeat, PING_MSG, PING_MSG_FIELD_NUM_RULES, wValue);
    
    dprintf("      Number of port rules:           %u\n", wValue);

    /* Get the rule codes. */
    GetFieldValue(pHeartbeat, PING_MSG, PING_MSG_FIELD_RULE_CODE, dwRuleCode);

    /* Get the current bin map. */
    GetFieldValue(pHeartbeat, PING_MSG, PING_MSG_FIELD_CURRENT_MAP, ddwCurrentMap);

    /* Get the new bin map. */
    GetFieldValue(pHeartbeat, PING_MSG, PING_MSG_FIELD_NEW_MAP, ddwNewMap);

    /* Get the idle bin map. */
    GetFieldValue(pHeartbeat, PING_MSG, PING_MSG_FIELD_IDLE_MAP, ddwIdleMap);

    /* Get the ready bins map. */
    GetFieldValue(pHeartbeat, PING_MSG, PING_MSG_FIELD_READY_BINS, ddwReadyBins);

    /* Get the load amount for each rule. */
    GetFieldValue(pHeartbeat, PING_MSG, PING_MSG_FIELD_LOAD_AMOUNT, dwLoadAmount);
    
    /* Loop through all port rules and spit out some information. */
    for (dwIndex = 0; dwIndex < wValue; dwIndex++) {
        /* Decode the rule.  See CVY_RULE_CODE_SET() in net\inc\wlbsparams.h. */
        ULONG dwStartPort = dwRuleCode[dwIndex] & 0x00000fff;
        ULONG dwEndPort = (dwRuleCode[dwIndex] & 0x00fff000) >> 12;
        ULONG dwProtocol = (dwRuleCode[dwIndex] & 0x0f000000) >> 24;
        ULONG dwMode = (dwRuleCode[dwIndex] & 0x30000000) >> 28;
        ULONG dwAffinity = (dwRuleCode[dwIndex] & 0xc0000000) >> 30;

        dprintf("      Port rule %u\n", dwIndex + 1);
           
        /* Print out the bin maps and load weight. */
        dprintf("          Rule code:                  0x%08x ", dwRuleCode[dwIndex]);
        
        /* If this is the last port rule, then its the default port rule. */
        if (dwIndex == (wValue - 1))
            dprintf("(DEFAULT port rule)\n");
        else {
#if 0 /* Because rule codes are overlapped logical ORs, we can't necessarily get back the
         information that was put in, so we won't spit it out until we can guarantee that. */

            /* Print out the port range - keep in mind that 16 bit port ranges are 
               encoded in 12 bit numbers, so this may not be 100% accurate. */
            dprintf("(%u - %u, ", dwStartPort, dwEndPort);
            
            /* Print the protocol. */
            switch (dwProtocol) {
            case CVY_TCP:
                dprintf("TCP, ");
                break;
            case CVY_UDP:
                dprintf("UDP, ");
                break;
            case CVY_TCP_UDP:
                dprintf("TCP/UDP, ");
                break;
            default:
                dprintf("Unknown protocol, ");
                break;
            }
            
            /* Print the filtering mode. */
            switch (dwMode) {
            case CVY_SINGLE:
                dprintf("Single host)\n");
                break;
            case CVY_MULTI:
                dprintf("Multiple host, ");
                
                /* If this rule uses multiple host, then we also print the affinity. */
                switch (dwAffinity) {
                case CVY_AFFINITY_NONE:
                    dprintf("No affinity)\n");
                    break;
                case CVY_AFFINITY_SINGLE:
                    dprintf("Single affinity)\n");
                    break;
                case CVY_AFFINITY_CLASSC:
                    dprintf("Class C affinity)\n");
                    break;
                default:
                    dprintf("Unknown affinity)\n");
                    break;
                }
                
                break;
            case CVY_NEVER:
                dprintf("Disabled)\n");
                break;
            default:
                dprintf("Unknown filtering mode)\n");
                break;
            }
#else
            dprintf("\n");
#endif
            /* Print the load weight. */
            dprintf("          Load weight:                %u\n", dwLoadAmount[dwIndex]);        
        }

        /* Print the bin maps for all rules, default or not. */
        dprintf("          Current map:                0x%015I64x\n", ddwCurrentMap[dwIndex]);        
        dprintf("          New map:                    0x%015I64x\n", ddwNewMap[dwIndex]);        
        dprintf("          Idle map:                   0x%015I64x\n", ddwIdleMap[dwIndex]);        
        dprintf("          Ready bins:                 0x%015I64x\n", ddwReadyBins[dwIndex]);        
    }
}

/*
 * Function: PrintPortRuleState
 * Description: Prints the state information for the port rule.
 * Author: Created by shouse, 2.5.01
 */
void PrintPortRuleState (ULONG64 pPortRule, ULONG dwHostID, BOOL bDefault) {
    ULONG dwValue;
    ULONG dwMode;
    USHORT wValue;
    BOOL bValue;
    ULONG64 pAddr;
    ULONGLONG ddwValue;

    /* Make sure the address is non-NULL. */
    if (!pPortRule) {
        dprintf("Error: Port rule is NULL.\n");
        return;
    }

    /* Get the BIN_STATE_CODE from the structure to make sure that this address
       indeed points to a valid NLB port rule state block. */
    GetFieldValue(pPortRule, BIN_STATE, BIN_STATE_FIELD_CODE, dwValue);
    
    if (dwValue != BIN_STATE_CODE) {
        dprintf("  Error: Invalid NLB port rule state block.  Wrong code found (0x%08x).\n", dwValue);
        return;
    } 

    /* Get the index of the rule - the "rule number". */
    GetFieldValue(pPortRule, BIN_STATE, BIN_STATE_FIELD_INDEX, dwValue);

    dprintf("  Port rule %u\n", dwValue + 1);

    /* Is the port rule state initialized? */
    GetFieldValue(pPortRule, BIN_STATE, BIN_STATE_FIELD_INITIALIZED, bValue);

    dprintf("      State initialized:              %s\n", (bValue) ? "Yes" : "No");

    /* Are the codes compatible? */
    GetFieldValue(pPortRule, BIN_STATE, BIN_STATE_FIELD_COMPATIBLE, bValue);

    dprintf("      Compatibility detected:         %s\n", (bValue) ? "Yes" : "No");

    /* Is the port rule state initialized? */
    GetFieldValue(pPortRule, BIN_STATE, BIN_STATE_FIELD_EQUAL, bValue);

    dprintf("      Equal load balancing:           %s\n", (bValue) ? "Yes" : "No");

    /* Get the filtering mode for this port rule. */
    GetFieldValue(pPortRule, BIN_STATE, BIN_STATE_FIELD_MODE, dwMode);

    dprintf("      Filtering mode:                 "); 

    /* If this is the DEFAULT port rule, then jump to the bottom. */
    if (bDefault) {
        dprintf("DEFAULT\n");
        goto end;
    }

    switch (dwMode) {
    case CVY_SINGLE:
        dprintf("Single host\n");
        break;
    case CVY_MULTI:
        dprintf("Multiple host\n");
        break;
    case CVY_NEVER:
        dprintf("Disabled\n");
        break;
    default:
        dprintf("Unknown\n");
        break;
    }

    if (dwMode == CVY_MULTI) {
        /* Get the affinity for this port rule. */
        GetFieldValue(pPortRule, BIN_STATE, BIN_STATE_FIELD_AFFINITY, wValue);
        
        dprintf("      Affinity:                       ");
        
        switch (wValue) {
        case CVY_AFFINITY_NONE:
            dprintf("None\n");
            break;
        case CVY_AFFINITY_SINGLE:
            dprintf("Single\n");
            break;
        case CVY_AFFINITY_CLASSC:
            dprintf("Class C\n");
            break;
        default:
            dprintf("Unknown\n");
            break;
        }
    }
    
    /* Get the protocol(s) for this port rule. */
    GetFieldValue(pPortRule, BIN_STATE, BIN_STATE_FIELD_PROTOCOL, dwValue);

    dprintf("      Protocol(s):                    ");

    /* Print the protocol. */
    switch (dwValue) {
    case CVY_TCP:
        dprintf("TCP\n");
        break;
    case CVY_UDP:
        dprintf("UDP\n");
        break;
    case CVY_TCP_UDP:
        dprintf("TCP/UDP\n");
        break;
    default:
        dprintf("Unknown\n");
        break;
    }

    /* In multiple host filtering, print the load information.  For single host 
       filtering, print the host priority information. */
    if (dwMode == CVY_MULTI) {
        ULONG dwCurrentLoad[CVY_MAX_HOSTS];

        /* Get the original load for this rule on this host. */
        GetFieldValue(pPortRule, BIN_STATE, BIN_STATE_FIELD_ORIGINAL_LOAD, dwValue);
        
        dprintf("      Configured load weight:         %u\n", dwValue);    
        
        /* Get the original load for this rule on this host. */
        GetFieldValue(pPortRule, BIN_STATE, BIN_STATE_FIELD_CURRENT_LOAD, dwCurrentLoad);
        
        dprintf("      Current load weight:            %u/", dwCurrentLoad[dwHostID]);    
        
        /* Get the total load for this rule on all hosts. */
        GetFieldValue(pPortRule, BIN_STATE, BIN_STATE_FIELD_TOTAL_LOAD, dwValue);

        dprintf("%u\n", dwValue);    
    } else if (dwMode == CVY_SINGLE) {
        /* Get the host priority. */
        GetFieldValue(pPortRule, BIN_STATE, BIN_STATE_FIELD_ORIGINAL_LOAD, dwValue);
        
        dprintf("      Host priority:                  %u\n", dwValue);    
    }

 end:

    /* Get the total number of active connections. */
    GetFieldValue(pPortRule, BIN_STATE, BIN_STATE_FIELD_TOTAL_CONNECTIONS, dwValue);
    
    dprintf("      Total active connections:       %u\n", dwValue);    

    /* Get the number of packets accepted. */
    GetFieldValue(pPortRule, BIN_STATE, BIN_STATE_FIELD_PACKETS_ACCEPTED, ddwValue);
    
    dprintf("      Packets accepted:               %u\n", ddwValue);

    /* Get the number of packets dropped. */
    GetFieldValue(pPortRule, BIN_STATE, BIN_STATE_FIELD_PACKETS_DROPPED, ddwValue);
    
    dprintf("      Packets dropped:                %u\n", ddwValue);

    /* Get the current map. */
    GetFieldValue(pPortRule, BIN_STATE, BIN_STATE_FIELD_CURRENT_MAP, ddwValue);
    
    dprintf("      Current map:                    0x%015I64x\n", ddwValue);

    /* Get the all idle map. */
    GetFieldValue(pPortRule, BIN_STATE, BIN_STATE_FIELD_ALL_IDLE_MAP, ddwValue);
    
    dprintf("      All idle map:                   0x%015I64x\n", ddwValue);

    /* Get the idle bins map. */
    GetFieldValue(pPortRule, BIN_STATE, BIN_STATE_FIELD_IDLE_BINS, ddwValue);
    
    dprintf("      My idle map:                    0x%015I64x\n", ddwValue);

    /* Get the offset of the IPSec descriptor timeout queue. */
    if (GetFieldOffset(BIN_STATE, BIN_STATE_FIELD_CONN_QUEUE, &dwValue))
        dprintf("Can't get offset of %s in %s\n", BIN_STATE_FIELD_CONN_QUEUE, BIN_STATE);
    else {
        pAddr = pPortRule + dwValue;

        dprintf("      Connection descriptor queue:    0x%p\n", pAddr);
    }

}

/*
 * Function: PrintBDAMember
 * Description: Prints the BDA teaming configuration and state of a member.
 * Author: Created by shouse, 4.8.01
 */
void PrintBDAMember (ULONG64 pMember) {
    ULONG64 pAddr;
    ULONG dwValue;

    /* Make sure the address is non-NULL. */
    if (!pMember) {
        dprintf("Error: Member is NULL.\n");
        return;
    }

    /* Find out whether or not teaming is active on this adapter. */
    GetFieldValue(pMember, BDA_MEMBER, BDA_MEMBER_FIELD_ACTIVE, dwValue);
    
    dprintf("  Bi-directional affinity teaming:    %s\n", (dwValue) ? "Active" : "Inactive");
    
    /* Get the current BDA operation in progress. */
    GetFieldValue(pMember, BDA_MEMBER, BDA_MEMBER_FIELD_OPERATION, dwValue);

    dprintf("      Operation in progress:          ");

    switch (dwValue) {
    case BDA_TEAMING_OPERATION_CREATING:
        dprintf("Creating\n");
        break;
    case BDA_TEAMING_OPERATION_DELETING:
        dprintf("Deleting\n");
        break;
    case BDA_TEAMING_OPERATION_NONE:
        dprintf("None\n");
        break;
    default:
        dprintf("Unkonwn\n");
        break;
    }

    /* Get the team-assigned member ID. */
    GetFieldValue(pMember, BDA_MEMBER, BDA_MEMBER_FIELD_MEMBER_ID, dwValue);
    
    if (dwValue == CVY_BDA_INVALID_MEMBER_ID) 
        dprintf("      Member ID:                      %s\n", "Invalid");
    else 
        dprintf("      Member ID:                      %u\n", dwValue);

    /* Get the master status flag. */
    GetFieldValue(pMember, BDA_MEMBER, BDA_MEMBER_FIELD_MASTER, dwValue);
    
    dprintf("      Master:                         %s\n", (dwValue) ? "Yes" : "No");
    
    /* Get the reverse hashing flag. */
    GetFieldValue(pMember, BDA_MEMBER, BDA_MEMBER_FIELD_REVERSE_HASH, dwValue);
    
    dprintf("      Reverse hashing:                %s\n", (dwValue) ? "Yes" : "No");

    /* Get the pointer to the BDA team. */
    GetFieldValue(pMember, BDA_MEMBER, BDA_MEMBER_FIELD_TEAM, pAddr);

    dprintf("     %sBDA team:                       0x%p\n", (pAddr) ? "-" : "+", pAddr);    
    
    /* If this adapter is part of a team, print out the team configuration and state. */
    if (pAddr) {
        dprintf("\n");
        PrintBDATeam(pAddr);
    }
}

/*
 * Function: PrintBDAMember
 * Description: Prints the BDA teaming configuration and state of a member.
 * Author: Created by shouse, 4.8.01
 */
void PrintBDATeam (ULONG64 pTeam) {
    WCHAR szString[256];
    ULONG64 pAddr;
    ULONG dwValue;

    /* Make sure the address is non-NULL. */
    if (!pTeam) {
        dprintf("Error: Team is NULL.\n");
        return;
    }

    dprintf("  BDA Team 0x%p\n", pTeam);

    /* Find out whether or not the team is active. */
    GetFieldValue(pTeam, BDA_TEAM, BDA_TEAM_FIELD_ACTIVE, dwValue);

    dprintf("      Active:                         %s\n", (dwValue) ? "Yes" : "No");

    /* Get the offset of the team ID and retrieve the string from that address. */
    if (GetFieldOffset(BDA_TEAM, BDA_TEAM_FIELD_TEAM_ID, &dwValue))
        dprintf("Can't get offset of %s in %s\n", BDA_TEAM_FIELD_TEAM_ID, BDA_TEAM);
    else {
        pAddr = pTeam + dwValue;
        
        /* Retrieve the contexts of the string and store it in a buffer. */
        GetString(pAddr, szString, CVY_MAX_BDA_TEAM_ID + 1);
        
        dprintf("      Team ID:                        %ls\n", szString);
    }

    /* Get the current membership count. */
    GetFieldValue(pTeam, BDA_TEAM, BDA_TEAM_FIELD_MEMBERSHIP_COUNT, dwValue);

    dprintf("      Number of members:              %u\n", dwValue);

    /* Get the current membership list. */
    GetFieldValue(pTeam, BDA_TEAM, BDA_TEAM_FIELD_MEMBERSHIP_FINGERPRINT, dwValue);

    dprintf("      Membership fingerprint:         0x%08x\n", dwValue);
    
    /* Get the current membership map. */
    GetFieldValue(pTeam, BDA_TEAM, BDA_TEAM_FIELD_MEMBERSHIP_MAP, dwValue);

    dprintf("      Members:                        0x%08x ", dwValue);

    /* If there are members in the map, print them. */
    if (dwValue) {
        dprintf("(");
        PrintBDAMemberList(dwValue);
        dprintf(")");
    }

    dprintf("\n");

    /* Get the current consistency map. */
    GetFieldValue(pTeam, BDA_TEAM, BDA_TEAM_FIELD_CONSISTENCY_MAP, dwValue);

    dprintf("      Consistent members:             0x%08x ", dwValue);

    /* If there are members in the map, print them. */
    if (dwValue) {
        dprintf("(");
        PrintBDAMemberList(dwValue);
        dprintf(")");
    }

    dprintf("\n");

    /* Get the offset of the load module pointer. */
    if (GetFieldOffset(BDA_TEAM, BDA_TEAM_FIELD_LOAD, &dwValue))
        dprintf("Can't get offset of %s in %s\n", BDA_TEAM_FIELD_LOAD, BDA_TEAM);
    else {
        pAddr = pTeam + dwValue;

        /* Retrieve the pointer. */
        pAddr = GetPointerFromAddress(pAddr);

        dprintf("      Load:                           0x%p\n", pAddr);    
    }

    /* Get the offset of the load lock pointer. */
    if (GetFieldOffset(BDA_TEAM, BDA_TEAM_FIELD_LOAD_LOCK, &dwValue))
        dprintf("Can't get offset of %s in %s\n", BDA_TEAM_FIELD_LOAD_LOCK, BDA_TEAM);
    else {
        pAddr = pTeam + dwValue;

        /* Retrieve the pointer. */
        pAddr = GetPointerFromAddress(pAddr);

        dprintf("      Load lock:                      0x%p\n", pAddr);
    }

    /* Get the offset of the previous pointer. */
    if (GetFieldOffset(BDA_TEAM, BDA_TEAM_FIELD_PREV, &dwValue))
        dprintf("Can't get offset of %s in %s\n", BDA_TEAM_FIELD_PREV, BDA_TEAM);
    else {
        pAddr = pTeam + dwValue;

        /* Retrieve the pointer. */
        pAddr = GetPointerFromAddress(pAddr);

        dprintf("      Previous BDA Team:              0x%p\n", pAddr);    
    }

    /* Get the offset of the next pointer. */
    if (GetFieldOffset(BDA_TEAM, BDA_TEAM_FIELD_NEXT, &dwValue))
        dprintf("Can't get offset of %s in %s\n", BDA_TEAM_FIELD_NEXT, BDA_TEAM);
    else {
        pAddr = pTeam + dwValue;

        /* Retrieve the pointer. */
        pAddr = GetPointerFromAddress(pAddr);

        dprintf("      Next BDA Team:                  0x%p\n", pAddr);
    }    
}

/*
 * Function: PrintBDAMemberList
 * Description: Prints a list of members in a BDA membership or consistency map. 
 * Author: Created by shouse, 4.8.01
 */
void PrintBDAMemberList (ULONG dwMemberMap) {
    BOOL bFirst = TRUE;
    ULONG dwMemberNum = 0;
    
    /* As long as there are hosts still in the map, print them. */
    while (dwMemberMap) {
        /* If the least significant bit is set, print the host number. */
        if (dwMemberMap & 0x00000001) {
            /* If this is the first host printed, just print the number. */
            if (bFirst) {
                dprintf("%u", dwMemberNum);
                bFirst = FALSE;
            } else
                /* Otherwise, we need to print a comma first. */
                dprintf(", %u", dwMemberNum);
        }
        
        /* Increment the host number and shift the map to the right one bit. */
        dwMemberNum++;
        dwMemberMap >>= 1;
    }
}

/*
 * Function: PrintConnectionDescriptor
 * Description: Prints a connection descriptor (CONN_ENTRY).
 * Author: Created by shouse, 1.9.02
 */
void PrintConnectionDescriptor (ULONG64 pDescriptor) {
    IN_ADDR dwIPAddr;
    CHAR * szString;
    ULONG64 pAddr;
    USHORT wValue;
    ULONG dwValue;
    BOOL bValue;
    UCHAR cValue;
    
    /* Make sure the address is non-NULL. */
    if (!pDescriptor) {
        dprintf("Error: Connection descriptor is NULL.\n");
        return;
    }

    dprintf("  Connection descriptor 0x%p\n", pDescriptor);

    /* Check the connection entry code. */
    GetFieldValue(pDescriptor, CONN_ENTRY, CONN_ENTRY_FIELD_CODE, dwValue);
    
    if (dwValue != CVY_ENTRCODE) {
        dprintf("Invalid NLB connection descriptor pointer.\n");
        return;
    }

    /* Get load module pointer. */
    GetFieldValue(pDescriptor, CONN_ENTRY, CONN_ENTRY_FIELD_LOAD, pAddr);

    dprintf("      Load pointer:                   0x%p\n", pAddr);

    /* Get the flags register. */
    GetFieldValue(pDescriptor, CONN_ENTRY, CONN_ENTRY_FIELD_FLAGS, wValue);

    dprintf("      Used:                           %s\n", (wValue & NLB_CONN_ENTRY_FLAGS_USED) ? "Yes" : "No");

    dprintf("      Dirty:                          %s\n", (wValue & NLB_CONN_ENTRY_FLAGS_DIRTY) ? "Yes" : "No");

    dprintf("      Allocated:                      %s\n", (wValue & NLB_CONN_ENTRY_FLAGS_ALLOCATED) ? "Yes" : "No");

    dprintf("      Virtual:                        %s\n", (wValue & NLB_CONN_ENTRY_FLAGS_VIRTUAL) ? "Yes" : "No");

    /* Get the connection queue index. */
    GetFieldValue(pDescriptor, CONN_ENTRY, CONN_ENTRY_FIELD_INDEX, wValue);

    dprintf("      Index:                          %u\n", wValue);

    /* Get the bin number. */
    GetFieldValue(pDescriptor, CONN_ENTRY, CONN_ENTRY_FIELD_BIN, cValue);

    dprintf("      Bin:                            %u\n", cValue);

    /* Get the reference count. */
    GetFieldValue(pDescriptor, CONN_ENTRY, CONN_ENTRY_FIELD_REF_COUNT, wValue);

    dprintf("      Reference count:                %u\n", wValue);

    /* Get the descriptor timeout value. */
    GetFieldValue(pDescriptor, CONN_ENTRY, CONN_ENTRY_FIELD_TIMEOUT, dwValue);

    dprintf("      Timeout (clock time):           %u.000\n", dwValue);

    /* Get the client IP address, which is a DWORD, and convert it to a string. */
    GetFieldValue(pDescriptor, CONN_ENTRY, CONN_ENTRY_FIELD_CLIENT_IP_ADDRESS, dwValue);

    dwIPAddr.S_un.S_addr = dwValue;
    szString = inet_ntoa(dwIPAddr);

    dprintf("      Client IP address:              %s\n", szString);

    /* Get the client port. */
    GetFieldValue(pDescriptor, CONN_ENTRY, CONN_ENTRY_FIELD_CLIENT_PORT, wValue);

    dprintf("      Client port:                    %u\n", wValue);

    /* Get the server IP address, which is a DWORD, and convert it to a string. */
    GetFieldValue(pDescriptor, CONN_ENTRY, CONN_ENTRY_FIELD_SERVER_IP_ADDRESS, dwValue);

    dwIPAddr.S_un.S_addr = dwValue;
    szString = inet_ntoa(dwIPAddr);

    dprintf("      Server IP address:              %s\n", szString);

    /* Get the client port. */
    GetFieldValue(pDescriptor, CONN_ENTRY, CONN_ENTRY_FIELD_SERVER_PORT, wValue);

    dprintf("      Server port:                    %u\n", wValue);

    /* Get the connection protocol. */
    GetFieldValue(pDescriptor, CONN_ENTRY, CONN_ENTRY_FIELD_PROTOCOL, cValue);

    switch(cValue)
    {
    case TCPIP_PROTOCOL_TCP:
        dprintf("      Protocol:                       0x%02x (%s)\n", cValue, "TCP");
        break;
    case TCPIP_PROTOCOL_PPTP:
        dprintf("      Protocol:                       0x%02x (%s)\n", cValue, "PPTP");
        break;
    case TCPIP_PROTOCOL_UDP:
        dprintf("      Protocol:                       0x%02x (%s)\n", cValue, "UDP");
        break;
    case TCPIP_PROTOCOL_IPSEC_UDP:
        dprintf("      Protocol:                       0x%02x (%s)\n", wValue, "IPSec/UDP Fragment");
        break;
    case TCPIP_PROTOCOL_GRE:
        dprintf("      Protocol:                       0x%02x (%s)\n", cValue, "GRE");
        break;
    case TCPIP_PROTOCOL_IPSEC1:
        dprintf("      Protocol:                       0x%02x (%s)\n", cValue, "IPSec");
        break;
    default:
        dprintf("      Protocol:                       0x%02x (%s)\n", cValue, "Unknown");
    }
}

/*
 * Function: PrintPendingConnection
 * Description: Prints a pending connection entry (PENDING_ENTRY).
 * Author: Created by shouse, 4.15.02
 */
void PrintPendingConnection (ULONG64 pPending) {
    IN_ADDR dwIPAddr;
    CHAR * szString;
    ULONG64 pAddr;
    USHORT wValue;
    ULONG dwValue;
    UCHAR cValue;
    
    /* Make sure the address is non-NULL. */
    if (!pPending) {
        dprintf("Error: Pending connection is NULL.\n");
        return;
    }

    dprintf("  Pending connection 0x%p\n", pPending);

    /* Check the connection entry code. */
    GetFieldValue(pPending, PENDING_ENTRY, PENDING_ENTRY_FIELD_CODE, dwValue);
    
    if (dwValue != CVY_PENDINGCODE) {
        dprintf("Invalid NLB pending connection pointer.\n");
        return;
    }

    /* Get the client IP address, which is a DWORD, and convert it to a string. */
    GetFieldValue(pPending, PENDING_ENTRY, PENDING_ENTRY_FIELD_CLIENT_IP_ADDRESS, dwValue);

    dwIPAddr.S_un.S_addr = dwValue;
    szString = inet_ntoa(dwIPAddr);

    dprintf("      Client IP address:              %s\n", szString);

    /* Get the client port. */
    GetFieldValue(pPending, PENDING_ENTRY, PENDING_ENTRY_FIELD_CLIENT_PORT, wValue);

    dprintf("      Client port:                    %u\n", wValue);

    /* Get the server IP address, which is a DWORD, and convert it to a string. */
    GetFieldValue(pPending, PENDING_ENTRY, PENDING_ENTRY_FIELD_SERVER_IP_ADDRESS, dwValue);

    dwIPAddr.S_un.S_addr = dwValue;
    szString = inet_ntoa(dwIPAddr);

    dprintf("      Server IP address:              %s\n", szString);

    /* Get the client port. */
    GetFieldValue(pPending, PENDING_ENTRY, PENDING_ENTRY_FIELD_SERVER_PORT, wValue);

    dprintf("      Server port:                    %u\n", wValue);

    /* Get the connection protocol. */
    GetFieldValue(pPending, PENDING_ENTRY, PENDING_ENTRY_FIELD_PROTOCOL, cValue);

    switch(wValue)
    {
    case TCPIP_PROTOCOL_TCP:
        dprintf("      Protocol:                       0x%02x (%s)\n", wValue, "TCP");
        break;
    case TCPIP_PROTOCOL_PPTP:
        dprintf("      Protocol:                       0x%02x (%s)\n", wValue, "PPTP");
        break;
    case TCPIP_PROTOCOL_UDP:
        dprintf("      Protocol:                       0x%02x (%s)\n", wValue, "UDP");
        break;
    case TCPIP_PROTOCOL_IPSEC_UDP:
        dprintf("      Protocol:                       0x%02x (%s)\n", wValue, "IPSec/UDP Fragment");
        break;
    case TCPIP_PROTOCOL_GRE:
        dprintf("      Protocol:                       0x%02x (%s)\n", wValue, "GRE");
        break;
    case TCPIP_PROTOCOL_IPSEC1:
        dprintf("      Protocol:                       0x%02x (%s)\n", wValue, "IPSec");
        break;
    default:
        dprintf("      Protocol:                       0x%02x (%s)\n", wValue, "Unknown");
    }
}

/*
 * Function: PrintQueue
 * Description: Prints MaxEntries entries in a connection descriptor queue.
 * Author: Created by shouse, 4.15.01
 */
void PrintQueue (ULONG64 pQueue, ULONG dwIndex, ULONG dwMaxEntries) {
    ULONG64 pAddr;
    ULONG64 pNext;
    ULONG dwEntryOffset;
    ULONG dwLinkSize;
    ULONG dwValue;

    /* Make sure the address is non-NULL. */
    if (!pQueue) {
        dprintf("Error: Queue is NULL.\n");
        return;
    }

    /* Get the size of a queue link. */
    dwLinkSize = GetTypeSize(LIST_ENTRY);
                
    /* Use the index and the size of a LIST_ENTRY to move to the 
       indicated index in an array of queues.  If no index was 
       provided, dwIndex is zero so the queue pointer is unchanged. */
    pQueue += (dwLinkSize * dwIndex);

    /* Get the Next pointer from the list entry. */
    GetFieldValue(pQueue, LIST_ENTRY, LIST_ENTRY_FIELD_NEXT, pNext);

    if (pNext != pQueue) {
        
        /* Assume this is a DESCR (not an ENTRY) and look for the code. */
        GetFieldValue(pNext, CONN_DESCR, CONN_DESCR_FIELD_CODE, dwValue);
        
        if (dwValue != CVY_DESCCODE) {
            
            /* Assume this points to an ENTRY and look for the code. */
            GetFieldValue(pNext, CONN_ENTRY, CONN_ENTRY_FIELD_CODE, dwValue);
            
            if (dwValue != CVY_ENTRCODE) {
                
                /* Adjust for the size of a LIST_ENTRY and see if we get an ENTRY. */
                pAddr = pNext - dwLinkSize;
                
                /* Assume this points to an entry and look for the code. */
                GetFieldValue(pAddr, CONN_ENTRY, CONN_ENTRY_FIELD_CODE, dwValue);

                if (dwValue != CVY_ENTRCODE) {
                    
                    dprintf("Invalid NLB connection queue pointer.\n");
                        
                } else {
                   
                    dprintf("Traversing a connection entry queue (Recovery/Timeout).\n");
                    
                    while ((pNext != pQueue) && dwMaxEntries && !CheckControlC()) {
                        
                        dprintf("\nQueue entry 0x%p\n", pNext);
                        
                        /* Print the connection descriptor. */
                        PrintConnectionDescriptor(pAddr);
                        
                        /* Get the Next pointer from the list entry. */
                        GetFieldValue(pNext, LIST_ENTRY, LIST_ENTRY_FIELD_NEXT, pAddr);
                        
                        /* Save the next pointer for "end of list" comparison. */
                        pNext = pAddr;
                        
                        /* Adjust for the size of a LIST_ENTRY to get a pointer to the ENTRY. */
                        pAddr = pNext - dwLinkSize;
                        
                        /* Decrement the number of entries we're still permitted to print. */
                        dwMaxEntries--;
                    }
                    
                    if (pNext == pQueue)
                        dprintf("\nNote: End of queue.\n");
                    else 
                        dprintf("\nNote: Entries remaining.\n"); 
                }
                
            } else {
                
                dprintf("Traversing a connection entry queue (Bin/Dirty).\n");
                
                /* The first descriptor to print is the one the next pointer points to. */
                pAddr = pNext;

                while ((pNext != pQueue) && dwMaxEntries && !CheckControlC()) {

                    dprintf("\nQueue entry 0x%p\n", pAddr);
                    
                    /* Print the connection descriptor. */
                    PrintConnectionDescriptor(pAddr);
                    
                    /* Get the Next pointer from the list entry. */
                    GetFieldValue(pNext, LIST_ENTRY, LIST_ENTRY_FIELD_NEXT, pAddr);
                    
                    /* Save the next pointer for "end of list" comparison. */
                    pNext = pAddr;
                    
                    /* Decrement the number of entries we're still permitted to print. */
                    dwMaxEntries--;
                }
                
                if (pNext == pQueue)
                    dprintf("\nNote: End of queue.\n");
                else 
                    dprintf("\nNote: Entries remaining.\n");

            }
            
        } else {
            
            dprintf("Traversing a connection descriptor queue (Free/Conn).\n");
            
            /* Get the field offset of the ENTRY, which is a member of the DESCR. */
            if (GetFieldOffset(CONN_DESCR, CONN_DESCR_FIELD_ENTRY, &dwEntryOffset))
                dprintf("Can't get offset of %s in %s\n", CONN_DESCR_FIELD_ENTRY, CONN_DESCR);
            else {                

                /* The first descriptor to print is the ENTRY member of the DESCR. */
                pAddr = pNext + dwEntryOffset;
                
                while ((pNext != pQueue) && dwMaxEntries && !CheckControlC()) {
                    
                    dprintf("\nQueue entry 0x%p\n", pNext);
                    
                    /* Print the connection descriptor. */
                    PrintConnectionDescriptor(pAddr);
                    
                    /* Get the Next pointer from the list entry. */
                    GetFieldValue(pNext, LIST_ENTRY, LIST_ENTRY_FIELD_NEXT, pAddr);
                    
                    /* Save the next pointer for "end of list" comparison. */
                    pNext = pAddr;

                    /* Find the next descriptor pointer. */
                    pAddr = pNext + dwEntryOffset;
                    
                    /* Decrement the number of entries we're still permitted to print. */
                    dwMaxEntries--;
                }
                
                if (pNext == pQueue)
                    dprintf("\nNote: End of queue.\n");
                else 
                    dprintf("\nNote: Entries remaining.\n");

            }            
        }
    } else {

        dprintf("Queue is empty.\n");

    }
}

/*
 * Function: PrintGlobalQueue
 * Description: Prints MaxEntries entries in a global connection descriptor queue.
 * Author: Created by shouse, 4.15.02
 */
void PrintGlobalQueue (ULONG64 pQueue, ULONG dwIndex, ULONG dwMaxEntries) {
    ULONG64 pAddr;
    ULONG64 pNext;
    ULONG dwLinkSize;
    ULONG dwQueueSize;
    ULONG dwValue;

    /* Make sure the address is non-NULL. */
    if (!pQueue) {
        dprintf("Error: Queue is NULL.\n");
        return;
    }

    /* Get the size of a queue link. */
    dwLinkSize = GetTypeSize(LIST_ENTRY);
                
    /* Get the size of a global connection queue. */
    dwQueueSize = GetTypeSize(GLOBAL_CONN_QUEUE);

    /* Use the index and the size of a GLOBAL_CONN_QUEUE to move to the 
       indicated index in an array of queues.  If no index was provided, 
       dwIndex is zero so the queue pointer is unchanged. */
    pQueue += (dwQueueSize * dwIndex);
    
    /* Get the Next pointer from the list entry. */
    GetFieldValue(pQueue, GLOBAL_CONN_QUEUE, GLOBAL_CONN_QUEUE_FIELD_LENGTH, dwValue);
    
    dprintf("Queue has %u entry(ies).\n", dwValue);
    
    /* Get the field offset of the QUEUE and add it to the queue pointer. */
    if (GetFieldOffset(GLOBAL_CONN_QUEUE, GLOBAL_CONN_QUEUE_FIELD_QUEUE, &dwValue))
        dprintf("Can't get offset of %s in %s\n", GLOBAL_CONN_QUEUE_FIELD_QUEUE, GLOBAL_CONN_QUEUE);
    else
        pQueue += dwValue;

    dprintf("\n");

    /* Get the Next pointer from the list entry. */
    GetFieldValue(pQueue, LIST_ENTRY, LIST_ENTRY_FIELD_NEXT, pNext);

    if (pNext != pQueue) {
        
        /* Assume this is a PENDING_ENTRY (not a CONN_ENTRY) and look for the code. */
        GetFieldValue(pNext, PENDING_ENTRY, PENDING_ENTRY_FIELD_CODE, dwValue);

        if (dwValue != CVY_PENDINGCODE) {
            
            /* Adjust for the size of two LIST_ENTRYs and see if we get an CONN_ENTRY. */
            pAddr = pNext - (2 * dwLinkSize);

            /* Assume this points to a CONN_ENTRY and look for the code. */
            GetFieldValue(pAddr, CONN_ENTRY, CONN_ENTRY_FIELD_CODE, dwValue);
            
            if (dwValue != CVY_ENTRCODE) {
                
                dprintf("Invalid NLB connection queue pointer.\n");
                        
            } else {
                
                dprintf("Traversing an established connection entry queue.\n");
                
                while ((pNext != pQueue) && dwMaxEntries && !CheckControlC()) {
                    
                    dprintf("\nQueue entry 0x%p\n", pNext);
                    
                    /* Print the connection descriptor. */
                    PrintConnectionDescriptor(pAddr);
                    
                    /* Get the Next pointer from the list entry. */
                    GetFieldValue(pNext, LIST_ENTRY, LIST_ENTRY_FIELD_NEXT, pAddr);
                            
                    /* Save the next pointer for "end of list" comparison. */
                    pNext = pAddr;
                    
                    /* Adjust for the size of a LIST_ENTRY to get a pointer to the ENTRY. */
                    pAddr = pNext - (2 * dwLinkSize);
                    
                    /* Decrement the number of entries we're still permitted to print. */
                    dwMaxEntries--;
                }
                
                if (pNext == pQueue)
                    dprintf("\nNote: End of queue.\n");
                else 
                    dprintf("\nNote: Entries remaining.\n");
            }
            
        } else {
                   
            dprintf("Traversing a pending connection entry queue.\n");
            
            while ((pNext != pQueue) && dwMaxEntries && !CheckControlC()) {
                
                dprintf("\nQueue entry 0x%p\n", pNext);
                
                /* Print the pending connection descriptor. */
                PrintPendingConnection(pNext);
                
                /* Get the Next pointer from the list entry. */
                GetFieldValue(pNext, LIST_ENTRY, LIST_ENTRY_FIELD_NEXT, pAddr);
                
                /* Decrement the number of entries we're still permitted to print. */
                dwMaxEntries--;
            }
            
            if (pNext == pQueue)
                dprintf("\nNote: End of queue.\n");
            else 
                dprintf("\nNote: Entries remaining.\n"); 
        }

    } else {

        dprintf("Queue is empty.\n");

    }
}

/*
 * Function: PrintHash
 * Description: Extracts the network data previously parsed from an NDIS_PACKET and calls PrintFilter 
 *              to determine whether NLB will accept this packet. 
 * Author: Created by shouse, 4.15.01
*/
void PrintHash (ULONG64 pContext, PNETWORK_DATA pnd) {
    ULONG dwValue;

    /* Make sure the load address is non-NULL. */
    if (!pContext) {
        dprintf("Error: NLB context block is NULL.\n");
        return;
    }

    /* Get the MAIN_CTXT_CODE from the structure to make sure that this address
       indeed points to a valid NLB context block. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CODE, dwValue);
    
    if (dwValue != MAIN_CTXT_CODE) {
        dprintf("  Error: Invalid NLB context block.  Wrong code found (0x%08x).\n", dwValue);
        return;
    } 

    /* If the packet is marked invalid by the parsing implementation, then we don't want 
       to even bother to try and filter it, as the parsed information may not be correct. */
    if (!pnd->bValid) {
        dprintf("This packet was marked INVALID during parsing and therefore cannot be reliably filtered.\n");
        return;
    }

    switch(pnd->EtherFrameType) {
    case TCPIP_IP_SIG:
    {
        /* Grab the client and server IP addresses from the network data. */
        ULONG dwClientIPAddress = pnd->SourceIPAddr;
        ULONG dwServerIPAddress = pnd->DestIPAddr;
        
        switch((int)pnd->Protocol) {
        case TCPIP_PROTOCOL_ICMP:
            /* ICMP may be filtered if the registry key for ICMP filtering is set. */
            PrintFilter(pContext, dwClientIPAddress, 0, dwServerIPAddress, 0, TCPIP_PROTOCOL_ICMP, NLB_FILTER_FLAGS_CONN_DATA);
            break;
        case TCPIP_PROTOCOL_IGMP:
            /* IGMP packets are never filtered by NLB. */
            dprintf("Accept:  IGMP traffic is not filtered by NLB.\n");
            break;
        case TCPIP_PROTOCOL_TCP:
        {
            /* Extract the client and server ports. */
            ULONG dwClientPort = pnd->SourcePort;
            ULONG dwServerPort = pnd->DestPort;
            
            /* By default, assume this is a data packet. */
            UCHAR cFlags = NLB_FILTER_FLAGS_CONN_DATA;

            /* Convert the actual TCP flags to values the load module understands 
               (generic - not specific to TCP necessarily). */
            if (pnd->TCPFlags & TCP_FLAG_SYN)
                cFlags |= NLB_FILTER_FLAGS_CONN_UP;
            else if (pnd->TCPFlags & TCP_FLAG_FIN)
                cFlags |= NLB_FILTER_FLAGS_CONN_DOWN;
            else if (pnd->TCPFlags & TCP_FLAG_RST)
                cFlags |= NLB_FILTER_FLAGS_CONN_RESET;
            
            /* Translate TCP 1723 to PPTP. */
            if (dwServerPort == PPTP_CTRL_PORT)
                /* Call the filter function with the collected parameters. */
                PrintFilter(pContext, dwClientIPAddress, dwClientPort, dwServerIPAddress, dwServerPort, TCPIP_PROTOCOL_PPTP, cFlags);
            else
                /* Call the filter function with the collected parameters. */
                PrintFilter(pContext, dwClientIPAddress, dwClientPort, dwServerIPAddress, dwServerPort, TCPIP_PROTOCOL_TCP, cFlags);

            break;
        }
        case TCPIP_PROTOCOL_UDP:
        {
            /* Extract the client and server ports. */
            ULONG dwClientPort = pnd->SourcePort;
            ULONG dwServerPort = pnd->DestPort;

            /* By default, assume this is a data packet. */
            UCHAR cFlags = NLB_FILTER_FLAGS_CONN_DATA;

            /* If this is an IKE initial contact packet, set the CONN_UP flag.  The parsing functions
               should special case UDP 500 as IPSec control traffic and set the initial contact flag
               appropriately. */
            if ((dwServerPort == IPSEC_CTRL_PORT) && (pnd->IPSecInitialContact))
                cFlags |= NLB_FILTER_FLAGS_CONN_UP;



            // Re-do IPSec IC MMSA parsing
            


            /* Translate UDP 500/4500 to IPSec. */
            if ((dwServerPort == IPSEC_CTRL_PORT) || (dwServerPort == IPSEC_NAT_PORT))
                /* Call the filter function with the collected parameters. */
                PrintFilter(pContext, dwClientIPAddress, dwClientPort, dwServerIPAddress, dwServerPort, TCPIP_PROTOCOL_IPSEC1, cFlags);
            else
                /* Call the filter function with the collected parameters. */
                PrintFilter(pContext, dwClientIPAddress, dwClientPort, dwServerIPAddress, dwServerPort, TCPIP_PROTOCOL_UDP, cFlags);

            break;
        }
        case TCPIP_PROTOCOL_GRE:
            /* GRE packets do not have ports and instead arbitrarily use 0 and 0 as the client and server ports, 
               respectively.  Further, GRE packets are always data, as they are always part of a previously
               established PPTP tunnel, so the flags are always DATA. */
            PrintFilter(pContext, dwClientIPAddress, PPTP_CTRL_PORT, dwServerIPAddress, PPTP_CTRL_PORT, TCPIP_PROTOCOL_GRE, NLB_FILTER_FLAGS_CONN_DATA);
            break;
        case TCPIP_PROTOCOL_IPSEC1:
        case TCPIP_PROTOCOL_IPSEC2:
            /* IPSec (AH/ESP) packets are always treated as data - establishment of IPSec connections is done
               via UDP packet, so any traffic actually utilizing the IPSec protocol(s) are DATA packets.
               Further, both ports are hard-coded to 500 because the only data traffic that will traverse this
               protocol is traffic for clients NOT behind a NAT, in which case the source port is also always
               500.  For clients behind a NAT, the data traffic is encapsulated in UDP with an arbitrary source
               port and a destination port of 500.  So, here we can always assume server and client ports of 500. */
            PrintFilter(pContext, dwClientIPAddress, IPSEC_CTRL_PORT, dwServerIPAddress, IPSEC_CTRL_PORT, TCPIP_PROTOCOL_IPSEC1, NLB_FILTER_FLAGS_CONN_DATA);
            break;
        default:
            /* NLB is essentially a TCP/IP filter, so unknown protocols are NOT filtered. */
            dprintf("Accept:  Unknown protocol.\n");
        }
        
        return;
    }
    case TCPIP_ARP_SIG:
        dprintf("Accept:  Received ARPs are never filtered by NLB.\n");
        return;
    case MAIN_FRAME_SIG:
    case MAIN_FRAME_SIG_OLD:
    {
        /* Check to see whether this host is started or not. */
        {
            ULONG dwEnabled;
            
            /* Get the convoy enabled status. */
            GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_ENABLED, dwEnabled);   
            
            /* If the cluster is not operational, which can happen, for example as a result of a wlbs.exe
               command such as "wlbs stop", or as a result of bad parameter settings, then drop all traffic 
               that does not meet the above conditions. */
            if (!dwEnabled) {
                dprintf("Reject:  This host is currently stopped.\n");
                return;
            }
        }
        
        /* Check to see whether this heartbeat is intended for this cluster. */
        {
            ULONG dwClusterIP;
            
            /* Get the cluster IP address. */
            GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CL_IP_ADDR, dwClusterIP);

            /* If the cluster IP address in the heartbeat is zero, or if it is for a cluster other than
               this one, then reject it. */
            if (!pnd->HBCluster || (pnd->HBCluster != dwClusterIP)) {
                dprintf("Reject:  This is not a heartbeat for this NLB cluster.\n");
                return;
            }
        }

        /* If the recipient host ID is invalid, then reject the heartbeat. */
        if (!pnd->HBHost || (pnd->HBHost > CVY_MAX_HOSTS)) {
            dprintf("Reject:  The host ID specified in the heartbeat is invalid.\n");
            return;
        }

        dprintf("Accept:  Heartbeat directed to this NLB cluster.\n");
        return;
    }
    default:
        dprintf("Accept:  Unknown frame type.\n");
        return;
    }
}

/*
 * Function: PrintFilter
 * Description: Searches the given load module to determine whether NLB will accept this packet.  
 *              If state for this packet already exists, it is printed. 
 * Author: Created by shouse, 4.15.01
 */
void PrintFilter (ULONG64 pContext, ULONG dwClientIPAddress, ULONG dwClientPort, ULONG dwServerIPAddress, ULONG dwServerPort, USHORT wProtocol, UCHAR cFlags) {
    ULONG64 pLoad;
    ULONG64 pParams;
    ULONG64 pHooks;
    ULONG64 pFilter;
    ULONG64 pAddr;
    ULONG dwValue;
    ULONG dwReverse = FALSE;
    BOOL bRefused = FALSE;
    BOOL bTeaming = FALSE;

    /* Make sure the load address is non-NULL. */
    if (!pContext) {
        dprintf("Error: NLB context block is NULL.\n");
        return;
    }

    dprintf("Note:  All filtering conclusions derived herein assume RECEIVE packet semantics.\n");
    dprintf("\n");
    dprintf("Hashing connection tuple (0x%08x, %u, 0x%08x, %u, ", dwClientIPAddress, dwClientPort, dwServerIPAddress, dwServerPort);

    switch (wProtocol) {
    case TCPIP_PROTOCOL_TCP:
        dprintf("%s, %s)\n\n", "TCP", ConnectionFlagsToString(cFlags));
        break;
    case TCPIP_PROTOCOL_UDP:
        dprintf("%s)\n\n", "UDP");
        cFlags = NLB_FILTER_FLAGS_CONN_DATA;
        break;
    case TCPIP_PROTOCOL_IPSEC1:
        dprintf("%s, %s)\n\n", "IPSec", ConnectionFlagsToString(cFlags));
        break;
    case TCPIP_PROTOCOL_GRE:
        dprintf("%s)\n\n", "GRE");
        cFlags = NLB_FILTER_FLAGS_CONN_DATA;
        break;
    case TCPIP_PROTOCOL_PPTP:
        dprintf("%s, %s)\n\n", "PPTP", ConnectionFlagsToString(cFlags));
        break;
    case TCPIP_PROTOCOL_ICMP:
        dprintf("%s)\n\n", "ICMP");
        break;
    default:
        dprintf("%s)\n\n", "Unknown");
        break;
    }

    /* Get the MAIN_CTXT_CODE from the structure to make sure that this address
       indeed points to a valid NLB context block. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CODE, dwValue);
    
    if (dwValue != MAIN_CTXT_CODE) {
        dprintf("  Error: Invalid NLB context block.  Wrong code found (0x%08x).\n", dwValue);
        return;
    } 

    /* Get the address of the global variable containing hook table. */
    pHooks = GetExpression(UNIV_HOOKS);

    if (!pHooks) {
        ErrorCheckSymbols(UNIV_HOOKS);
        return;
    }

    /* Get the offset of the filter hook sub-structure. */
    if (GetFieldOffset(HOOK_TABLE, HOOK_TABLE_FIELD_FILTER_HOOK, &dwValue))
        dprintf("Can't get offset of %s in %s\n", HOOK_TABLE_FIELD_FILTER_HOOK, HOOK_TABLE);
    else {
        pFilter = pHooks + dwValue;

        /* Find out whether or not there is an operation in progress. */
        GetFieldValue(pFilter, FILTER_HOOK_TABLE, FILTER_HOOK_TABLE_FIELD_OPERATION, dwValue);

        switch (dwValue) {
        case HOOK_OPERATION_REGISTERING:
            dprintf("Note:  A register operation is currently underway for the NLB filter hook interface.\n");
            break;
        case HOOK_OPERATION_DEREGISTERING:
            dprintf("Note:  A de-register operation is currently underway for the NLB filter hook interface.\n");
            break;
        }

        /* Get the offset of the receive filter hook. */
        if (GetFieldOffset(FILTER_HOOK_TABLE, FILTER_HOOK_TABLE_FIELD_RECEIVE_HOOK, &dwValue))
            dprintf("Can't get offset of %s in %s\n", FILTER_HOOK_TABLE_FIELD_RECEIVE_HOOK, FILTER_HOOK_TABLE);
        else {
            pAddr = pFilter + dwValue;

            /* Find out whether or not this hook is registered. */
            GetFieldValue(pAddr, HOOK, HOOK_FIELD_REGISTERED, dwValue);

            /* If a receive hook is registered, print a warning that our results here
               _might_ not be accurate, depending on the result of invoking the hook. */
            if (dwValue) {
                dprintf("Note:  A receive filter hook is currently registered.  The filtering conclusions derived herein may or may not\n");
                dprintf("       be accurate, as the filtering directive returned by the registered hook function cannot be anticipated.\n");
                dprintf("\n");
            }
        }
    }

    /* Get the pointer to the NLB load. */
    if (GetFieldOffset(MAIN_CTXT, MAIN_CTXT_FIELD_LOAD, &dwValue))
        dprintf("Can't get offset of %s in %s\n", MAIN_CTXT_FIELD_LOAD, MAIN_CTXT);
    else {    
        pLoad = pContext + dwValue;

        /* Get the LOAD_CTXT_CODE from the structure to make sure that this address
           indeed points to a valid NLB load block. */
        GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_CODE, dwValue);
        
        if (dwValue != LOAD_CTXT_CODE) {
            dprintf("  Error: Invalid NLB load block.  Wrong code found (0x%08x).\n", dwValue);
            return;
        } 
    }

    /* Get the pointer to the NLB parameters. */
    if (GetFieldOffset(MAIN_CTXT, MAIN_CTXT_FIELD_PARAMS, &dwValue))
        dprintf("Can't get offset of %s in %s\n", MAIN_CTXT_FIELD_PARAMS, MAIN_CTXT);
    else {    
        pParams = pContext + dwValue;    
        
        /* Get the validity of the NLB parameter block. */
        GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_PARAMS_VALID, dwValue);

        if (!dwValue)
            dprintf("Warning: Parameters block is marked invalid.  Results may be skewed.\n");
    }

    /* Check for remote control packets. */
    {
        ULONG dwRemoteControlEnabled;
        ULONG dwRemoteControlPort;
        ULONG dwClusterIPAddress;
        
        /* Get the remote control enabled flag. */
        GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_REMOTE_CONTROL_ENABLED, dwRemoteControlEnabled);
        
        /* Get the remote control port. */
        GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_REMOTE_CONTROL_PORT, dwRemoteControlPort);

        /* Get the cluster IP address. */
        GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CL_IP_ADDR, dwClusterIPAddress);

        /* First check for remote control packets, which are always UDP and are always allowed to pass.  
           However, if we are supposed to ignore remote control traffic and load balance instead, then
           we let the load module tell us whether or not to take the packet. */
        if (wProtocol == TCPIP_PROTOCOL_UDP) {
            /* If the client UDP port is the remote control port, then this is a remote control 
               response from another NLB cluster host.  These are always allowed to pass. */
            if (dwClientPort == dwRemoteControlPort || dwClientPort == CVY_DEF_RCT_PORT_OLD) {
                dprintf("Accept:  This packet is an NLB remote control response.\n");
                return; 
            /* Otherwise, if the server UDP port is the remote control port, then this is an incoming
               remote control request from another NLB cluster host.  These are always allowed to pass. */
            } else if (dwRemoteControlEnabled &&
                       (dwServerPort == dwRemoteControlPort     || dwServerPort == CVY_DEF_RCT_PORT_OLD) &&
                       (dwServerIPAddress == dwClusterIPAddress || dwServerIPAddress == TCPIP_BCAST_ADDR)) {
                dprintf("Accept:  This packet is an NLB remote control request.\n");
                return;            
            }
        }
    }

    /* Check for specialized IP address conditions. */
    {
        ULONG dwClusterIP;
        ULONG dwClusterBcastIP;
        ULONG dwDedicatedIP;
        ULONG dwDedicatedBcastIP;
        
        /* Get the cluster IP address. */
        GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CL_IP_ADDR, dwClusterIP);

        /* Get the dedicated IP address. */
        GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_DED_IP_ADDR, dwDedicatedIP);

        /* Get the cluster broadcast IP address. */
        GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CL_BROADCAST, dwClusterBcastIP);

        /* Get the dedicated broadcast IP address. */
        GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_DED_BROADCAST, dwDedicatedBcastIP);

        /* Check for traffic destined for the dedicated IP address of this host.  
           These packets are always allowed to pass. */
        if (dwServerIPAddress == dwDedicatedIP) {
            dprintf("Accept:  This packet is directed to this host's dedicated IP address.\n");
            return;
        }
        
        /* Check for traffic destined for the cluster or dedicated broadcast IP addresses.  
           These packets are always allowed to pass. */
        if (dwServerIPAddress == dwDedicatedBcastIP || dwServerIPAddress == dwClusterBcastIP) {
            dprintf("Accept:  This packet is directed to the cluster or dedicated broadcast IP address.\n");
            return;
        }
        
        /* Check for passthru packets.  When the cluster IP address has not been specified, the
           cluster moves into passthru mode, in which it passes up ALL packets received. */
        if (dwClusterIP == 0) {
            dprintf("Accept:  This host is misconfigured and therefore operating in pass-through mode.\n");
            return;
        }  
        
        /* Get the pointer to the DIP list. */
        if (GetFieldOffset(MAIN_CTXT, MAIN_CTXT_FIELD_DIP_LIST, &dwValue))
            dprintf("Can't get offset of %s in %s\n", MAIN_CTXT_FIELD_DIP_LIST, MAIN_CTXT);
        else {
            pAddr = pContext + dwValue;
            
            /* Before we load-balance this packet, check to see whether or not its destined for
               the dedicated IP address of another NLB host in our cluster.  If it is, drop it. */
            if (DipListCheckItem(pAddr, dwServerIPAddress)) {
                dprintf("Drop:  This packet is directed to the dedicated IP address of another NLB host.\n");
                return;
            }
        }
    }

    /* Check to see whether this host is started or not. */
    {
        ULONG dwEnabled;

        /* Get the convoy enabled status. */
        GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_ENABLED, dwEnabled);   

        /* If the cluster is not operational, which can happen, for example as a result of a wlbs.exe
           command such as "wlbs stop", or as a result of bad parameter settings, then drop all traffic 
           that does not meet the above conditions. */
        if (!dwEnabled) {
            dprintf("Reject:  This host is currently stopped.\n");
            return;
        }
    }

    /* If this is an ICMP filter request, whether or not its filtered at all depends on the FilterICMP
       registry setting.  If we're not filtering ICMP, return ACCEPT now; otherwise, ICMP is filtered
       like UDP with no port information - fall through and consult the load module. */
    if (wProtocol == TCPIP_PROTOCOL_ICMP)    
    {
        ULONG dwFilterICMP;

        /* Get the convoy enabled status. */
        GetFieldValue(pParams, MAIN_CTXT, CVY_PARAMS_FIELD_FILTER_ICMP, dwFilterICMP);   

        /* If we are filtering ICMP, change the protocol to UDP and the ports to 0, 0 before continuing. */
        if (dwFilterICMP) {
            wProtocol = TCPIP_PROTOCOL_UDP;
            dwClientPort = 0;
            dwServerPort = 0;
        /* Otherwise, return ACCEPT now and bail out. */
        } else {
            dprintf("Accept:  ICMP traffic is not being filtered by NLB.\n");
            return;
        }
    }

    /* Get the reverse hashing flag. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_REVERSE_HASH, dwReverse);    

    /* Get the appropriate load module by checking for BDA teaming. */
    bTeaming = AcquireLoad(pContext, &pLoad, &bRefused);

    /* If BDA teaming has refused the packet, drop it. */
    if (bRefused) {
        dprintf("Reject:  BDA teaming has refused acceptance of this packet.\n");
        return;        
    }

    /* If teaming is configured, let the user know what's going on. */
    if (bTeaming) {
        dprintf("Note:  BDA teaming is configured on this instance of NLB.  The filtering conclusions derived herein will utilize the\n");
        dprintf("       load module state of the BDA team master and may not be accurate if a BDA teaming operation(s) are in progress.\n");
        dprintf("\n");
    }

    /* Consult the load module. */
    LoadFilter(pLoad, dwServerIPAddress, dwServerPort, dwClientIPAddress, dwClientPort, wProtocol, cFlags, bTeaming, (BOOL)dwReverse);
}

/*
 * Function: PrintRemoteControl
 * Description: Print the properties associated with a remote control packet.
 * Args: PNETWORK_DATA pnd - data structure where the extracted properties have been stored,
 *                           populated by the function PopulateRemoteControl.
 * Author: Created by chrisdar  2001.11.02
 */
void PrintRemoteControl (PNETWORK_DATA pnd)
{
    char*           pszIOCTL = NULL;
    struct in_addr  in;
    char            *pszIPAddr = NULL;
    char            *pszRCDirection = NULL;

    switch(pnd->RCIoctrl)
    {
    case IOCTL_CVY_CLUSTER_ON:
        pszIOCTL = STR_IOCTL_CVY_CLUSTER_ON;
        break;
    case IOCTL_CVY_CLUSTER_OFF:
        pszIOCTL = STR_IOCTL_CVY_CLUSTER_OFF;
        break;
    case IOCTL_CVY_PORT_ON:
        pszIOCTL = STR_IOCTL_CVY_PORT_ON;
        break;
    case IOCTL_CVY_PORT_OFF:
        pszIOCTL = STR_IOCTL_CVY_PORT_OFF;
            break;
    case IOCTL_CVY_QUERY:
        pszIOCTL = STR_IOCTL_CVY_QUERY;
        break;
    case IOCTL_CVY_RELOAD:
        pszIOCTL = STR_IOCTL_CVY_RELOAD;
        break;
    case IOCTL_CVY_PORT_SET:
        pszIOCTL = STR_IOCTL_CVY_PORT_SET;
        break;
    case IOCTL_CVY_PORT_DRAIN:
        pszIOCTL = STR_IOCTL_CVY_PORT_DRAIN;
        break;
    case IOCTL_CVY_CLUSTER_DRAIN:
        pszIOCTL = STR_IOCTL_CVY_CLUSTER_DRAIN;
        break;
    case IOCTL_CVY_CLUSTER_PLUG:
        pszIOCTL = STR_IOCTL_CVY_CLUSTER_PLUG;
        break;
    case IOCTL_CVY_CLUSTER_SUSPEND:
        pszIOCTL = STR_IOCTL_CVY_CLUSTER_SUSPEND;
        break;
    case IOCTL_CVY_CLUSTER_RESUME:
        pszIOCTL = STR_IOCTL_CVY_CLUSTER_RESUME;
        break;
    case IOCTL_CVY_QUERY_FILTER:
        pszIOCTL = STR_IOCTL_CVY_QUERY_FILTER;
        break;
    case IOCTL_CVY_QUERY_PORT_STATE:
        pszIOCTL = STR_IOCTL_CVY_QUERY_PORT_STATE;
        break;
    case IOCTL_CVY_QUERY_PARAMS:
        pszIOCTL = STR_IOCTL_CVY_QUERY_PARAMS;
        break;
    case IOCTL_CVY_QUERY_BDA_TEAMING:
        pszIOCTL = STR_IOCTL_CVY_QUERY_BDA_TEAMING;
        break;
    default:
        pszIOCTL = "Unknown";
    }

    switch(pnd->RemoteControl)
    {
    case NLB_RC_PACKET_NO:
        pszRCDirection = STR_NLB_RC_PACKET_NO;
        break;
    case NLB_RC_PACKET_AMBIGUOUS:
        pszRCDirection = STR_NLB_RC_PACKET_AMBIGUOUS;
        break;
    case NLB_RC_PACKET_REQUEST:
        pszRCDirection = STR_NLB_RC_PACKET_REQUEST;
        break;
    case NLB_RC_PACKET_REPLY:
        pszRCDirection = STR_NLB_RC_PACKET_REPLY;
    }


    dprintf("   Remote Control information\n");
    dprintf("      Direction:                      %s\n"     , pszRCDirection ? pszRCDirection : "");
    dprintf("      Code:                           0x%08x\n" , pnd->RCCode);
    dprintf("      Version:                        0x%08x\n" , pnd->RCVersion);

    //
    // Treat pnd->RCHost as an IP (even though it is optionally a host ID too)
    // How could we distinguish one from the other without knowing the DIPs?
    //
    in.S_un.S_addr = pnd->RCHost;
    pszIPAddr = inet_ntoa(in);
    dprintf("      Host:                           0x%08x (%s)\n", pnd->RCHost   , pszIPAddr    ? pszIPAddr    : "");

    in.S_un.S_addr = pnd->RCCluster;
    pszIPAddr = inet_ntoa(in);
    dprintf("      Cluster:                        0x%08x (%s)\n", pnd->RCCluster, pszIPAddr ? pszIPAddr : "");

    in.S_un.S_addr = pnd->RCAddr;
    pszIPAddr = inet_ntoa(in);
    dprintf("      Address:                        0x%08x (%s)\n", pnd->RCAddr   , pszIPAddr ? pszIPAddr : "");

    dprintf("      ID:                             0x%08x\n"     , pnd->RCId);
    dprintf("      IOCTL:                          0x%08x (%s)\n", pnd->RCIoctrl , pszIOCTL);
}

/*
 * Function: PrintICMP
 * Description: Print the properties associated with an ICMP packet.
 * Args: PNETWORK_DATA pnd - data structure where the extracted properties have been stored,
 *                           populated by the function PopulateICMP.
 * Author: Created by chrisdar  2001.11.02
 */
void PrintICMP (PNETWORK_DATA pnd)
{
//
// Just a stub for now. There is nothing in the payload that we are currently interested in.
//
}

/*
 * Function: PrintIGMP
 * Description: Print the properties associated with an IGMP packet.
 * Args: PNETWORK_DATA pnd - data structure where the extracted properties have been stored,
 *                           populated by the function PopulateIGMP.
 * Author: Created by chrisdar  2001.11.02
 */
void PrintIGMP (PNETWORK_DATA pnd)
{
    struct in_addr  in;
    char            *pszIPaddress = NULL;

    in.S_un.S_addr = pnd->IGMPGroupIPAddr;
    pszIPaddress   = inet_ntoa(in);

    dprintf("   IGMP information\n");
    dprintf("      Version:                        0x%01x\n"            , pnd->IGMPVersion);
    dprintf("      Type:                           0x%01x        (%s)\n", pnd->IGMPType       , (1 == pnd->IGMPType) ? "query" : "report");
    dprintf("      Group IP address:               0x%08x (%s)\n"       , pnd->IGMPGroupIPAddr, pszIPaddress ? pszIPaddress : "");
}

/*
 * Function: PrintTCP
 * Description: Print the properties associated with an TCP packet.
 * Args: PNETWORK_DATA pnd - data structure where the extracted properties have been stored,
 *                           populated by the function PopulateTCP.
 * Author: Created by chrisdar  2001.11.02
 */
void PrintTCP (PNETWORK_DATA pnd)
{
    UCHAR   ucFlags[7];
    PUCHAR  pucFlags = ucFlags;
    int     iIdx, iMask;

    //
    // To print out the flags, set up a string with every possible flag "on".
    // Then "turn off" the flag if in the output string if the flag isn't on.
    // Do this by setting its char to '.'
    //
    strcpy(ucFlags, "UAPRSF");
    iMask = 0x20;

    // Bound the number of iterations by the mask value as a sanity check that we don't try to divide by 0
    while (*pucFlags && iMask >= 1)
    {
        if (!(pnd->TCPFlags & iMask))
        {
            *pucFlags = '.';
        }
        iMask /= 2;
        pucFlags++;
    }

    dprintf("   TCP information\n");
    dprintf("      Source port:                    0x%04x     (%u)\n", pnd->SourcePort, pnd->SourcePort);
    dprintf("      Destination port:               0x%04x     (%u)\n", pnd->DestPort  , pnd->DestPort);
    dprintf("      Sequence number:                0x%08x (%u)\n", pnd->TCPSeqNum , pnd->TCPSeqNum);
    dprintf("      Ack number:                     0x%08x (%u)\n", pnd->TCPAckNum , pnd->TCPAckNum);
    dprintf("      Flags:                          %s\n"    , ucFlags);
}

/*
 * Function: PrintUDP
 * Description: Print the properties associated with an UDP packet.
 * Args: PNETWORK_DATA pnd - data structure where the extracted properties have been stored,
 *                           populated by the function PopulateUDP.
 * Author: Created by chrisdar  2001.11.02
 */
void PrintUDP (PNETWORK_DATA pnd)
{
    dprintf("   UDP information\n");
    dprintf("      Source port:                    0x%04x (%u)\n", pnd->SourcePort, pnd->SourcePort);
    dprintf("      Destination port:               0x%04x (%u)\n", pnd->DestPort  , pnd->DestPort);

    //
    // Is this a remote control packet?
    //
    if (NLB_RC_PACKET_NO != pnd->RemoteControl)
    {
        dprintf("\n");
        PrintRemoteControl(pnd);
    }
}

/*
 * Function: PrintGRE
 * Description: Print the properties associated with an GRE packet.
 * Args: PNETWORK_DATA pnd - data structure where the extracted properties have been stored,
 *                           populated by the function PopulateGRE.
 * Author: Created by chrisdar  2001.11.02
 */
void PrintGRE (PNETWORK_DATA pnd)
{
//
// Just a stub for now. There is nothing in the payload that we are currently interested in.
//
}

/*
 * Function: PrintIPSec
 * Description: Print the properties associated with an IPSec packet.
 * Args: PNETWORK_DATA pnd - data structure where the extracted properties have been stored,
 *                           populated by the function PopulateIPSec.
 * Author: Created by chrisdar  2001.11.02
 */
void PrintIPSec (PNETWORK_DATA pnd)
{
//
// Just a stub for now. There is nothing in the payload that we are currently interested in.
//
}

/*
 * Function: PrintIP
 * Description: Print the properties associated with an IP packet.
 * Args: PNETWORK_DATA pnd - data structure where the extracted properties have been stored,
 *                           populated by the function PopulateIP.
 * Author: Created by chrisdar  2001.11.02
 */
void PrintIP (PNETWORK_DATA pnd)
{
    struct in_addr  in;
    char            *pszIPaddress = NULL;

    dprintf("   IP information\n");
    dprintf("      Header length (bytes):          0x%02x       (%u)\n", pnd->HeadLen, pnd->HeadLen);
    dprintf("      Total length (bytes):           0x%04x     (%u)\n", pnd->TotLen, pnd->TotLen);

    in.S_un.S_addr = pnd->SourceIPAddr;
    pszIPaddress = inet_ntoa(in);

    dprintf("      Source IP address:              0x%08x (%s)\n", pnd->SourceIPAddr, pszIPaddress ? pszIPaddress : "");

    in.S_un.S_addr = pnd->DestIPAddr;
    pszIPaddress = inet_ntoa(in);

    dprintf("      Destination IP address:         0x%08x (%s)\n", pnd->DestIPAddr, pszIPaddress ? pszIPaddress : "");

    switch((int) pnd->Protocol)
    {
    case TCPIP_PROTOCOL_ICMP:
        dprintf("      Protocol:                       0x%02x       (%s)\n", pnd->Protocol, "ICMP");
        PrintICMP(pnd);
        break;
    case TCPIP_PROTOCOL_IGMP:
        dprintf("      Protocol:                       0x%02x       (%s)\n\n", pnd->Protocol, "IGMP");
        PrintIGMP(pnd);
        break;
    case TCPIP_PROTOCOL_TCP:
        dprintf("      Protocol:                       0x%02x       (%s)\n\n", pnd->Protocol, "TCP");
        PrintTCP(pnd);
        break;
    case TCPIP_PROTOCOL_UDP:
        dprintf("      Protocol:                       0x%02x       (%s)\n\n", pnd->Protocol, "UDP");
        PrintUDP(pnd);
        break;
    case TCPIP_PROTOCOL_GRE:
        dprintf("      Protocol:                       0x%02x       (%s)\n", pnd->Protocol, "GRE");
        PrintGRE(pnd);
        break;
    case TCPIP_PROTOCOL_IPSEC1:
    case TCPIP_PROTOCOL_IPSEC2:
        dprintf("      Protocol:                       0x%02x       (%s)\n", pnd->Protocol, "IPSec");
        PrintIPSec(pnd);
        break;
    default:
        dprintf("      Protocol:                       0x%02x       (%s)\n", pnd->Protocol, "Unknown");
    }
}

/*
 * Function: PrintARP
 * Description: Print the properties associated with an ARP packet.
 * Args: PNETWORK_DATA pnd - data structure where the extracted properties have been stored,
 *                           populated by the function PopulateARP.
 * Author: Created by chrisdar  2001.11.02
 */
void PrintARP (PNETWORK_DATA pnd)
{
    struct in_addr  in;
    char            *pszIPAddr = NULL;

    dprintf("   ARP information\n");
    dprintf("      Sender MAC address:             %02x-%02x-%02x-%02x-%02x-%02x\n",
            pnd->ARPSenderMAC[0],
            pnd->ARPSenderMAC[1],
            pnd->ARPSenderMAC[2],
            pnd->ARPSenderMAC[3],
            pnd->ARPSenderMAC[4],
            pnd->ARPSenderMAC[5]
           );

    in.S_un.S_addr = pnd->ARPSenderIP;
    pszIPAddr = inet_ntoa(in);
    dprintf("      Sender IP address:              0x%08x (%s)\n", pnd->ARPSenderIP, pszIPAddr ? pszIPAddr : "");

    dprintf("      Target MAC address:             %02x-%02x-%02x-%02x-%02x-%02x\n",
            pnd->ARPTargetMAC[0],
            pnd->ARPTargetMAC[1],
            pnd->ARPTargetMAC[2],
            pnd->ARPTargetMAC[3],
            pnd->ARPTargetMAC[4],
            pnd->ARPTargetMAC[5]
           );

    in.S_un.S_addr = pnd->ARPTargetIP;
    pszIPAddr = inet_ntoa(in);
    dprintf("      Target IP address:              0x%08x (%s)\n", pnd->ARPTargetIP, pszIPAddr ? pszIPAddr : "");
}

/*
 * Function: PrintNLBHeartbeat
 * Description: Print the properties associated with an PrintNLBHeartbeat.
 * Args: PNETWORK_DATA pnd - data structure where the extracted properties have been stored,
 *                           populated by the function PopulateNLBHeartbeat.
 * Author: Created by chrisdar  2001.11.02
 */
void PrintNLBHeartbeat(PNETWORK_DATA pnd)
{
    struct in_addr  in;
    char            *pszIPAddr = NULL;

    dprintf("   NLB heartbeat information\n");
    dprintf("      Code:                           0x%08x\n"  , pnd->HBCode);
    dprintf("      Version:                        0x%08x\n"  , pnd->HBVersion);
    dprintf("      Host:                           0x%08x\n"  , pnd->HBHost);

    in.S_un.S_addr = pnd->HBCluster;
    pszIPAddr = inet_ntoa(in);
    dprintf("      Cluster IP address:             0x%08x (%s)\n"  , pnd->HBCluster, pszIPAddr ? pszIPAddr : "");

    in.S_un.S_addr = pnd->HBDip;
    pszIPAddr = inet_ntoa(in);
    dprintf("      Dedicated IP address:           0x%08x (%s)\n\n", pnd->HBDip    , pszIPAddr ? pszIPAddr : "");

    PrintHeartbeat(pnd->HBPtr);
}

/*
 * Function: PrintConvoyHeartbeat
 * Description: Print the properties associated with an PrintConvoyHeartbeat.
 * Args: PNETWORK_DATA pnd - data structure where the extracted properties have been stored,
 *                           populated by the function PopulateConvoyHeartbeat.
 * Author: Created by chrisdar  2001.11.02
 */
void PrintConvoyHeartbeat(PNETWORK_DATA pnd)
{
//
// Just a stub for now. We won't deal with Convoy hosts.
//
}

/*
 * Function: PrintPacket
 * Description: Print the properties associated with an ethernet packet.
 * Args: PNETWORK_DATA pnd - data structure where the extracted properties have been stored,
 *                           populated by the function PopulatePacket.
 * Author: Created by chrisdar  2001.11.02
 */
void PrintPacket (PNETWORK_DATA pnd)
{
    dprintf("   Ethernet information\n");
    dprintf("      Destination address:            %02x-%02x-%02x-%02x-%02x-%02x\n",
            pnd->DestMACAddr[0],
            pnd->DestMACAddr[1],
            pnd->DestMACAddr[2],
            pnd->DestMACAddr[3],
            pnd->DestMACAddr[4],
            pnd->DestMACAddr[5]
           );
    dprintf("      Source address:                 %02x-%02x-%02x-%02x-%02x-%02x\n",
            pnd->SourceMACAddr[0],
            pnd->SourceMACAddr[1],
            pnd->SourceMACAddr[2],
            pnd->SourceMACAddr[3],
            pnd->SourceMACAddr[4],
            pnd->SourceMACAddr[5]
           );

    //
    // Determine payload type and print accordingly
    //
    switch(pnd->EtherFrameType)
    {
    case TCPIP_IP_SIG:
        dprintf("      Frame type:                     0x%04x (%s)\n\n", pnd->EtherFrameType, "IP");
        PrintIP(pnd);
        break;
    case TCPIP_ARP_SIG:
        dprintf("      Frame type:                     0x%04x (%s)\n\n", pnd->EtherFrameType, "ARP");
        PrintARP(pnd);
        break;
    case MAIN_FRAME_SIG:
        dprintf("      Frame type:                     0x%04x (%s)\n\n", pnd->EtherFrameType, "NLB Heartbeat");
        PrintNLBHeartbeat(pnd);
        break;
    case MAIN_FRAME_SIG_OLD:
        dprintf("      Frame type:                     0x%04x (%s)\n\n", pnd->EtherFrameType, "Convoy Heartbeat");
        PrintConvoyHeartbeat(pnd);
        break;
    default:
        dprintf("      Frame type:                     0x%04x (%s)\n", pnd->EtherFrameType, "Unknown");
    }
}

/* 
 * Function: PrintSymbol
 * Description: Print the symbol value and name for a given symbol.
 * Author: Created by shouse, 12.20.01
 */
VOID PrintSymbol (ULONG64 Pointer, PCHAR EndOfLine) {
    UCHAR SymbolName[128];
    ULONG64 Displacement;

    if (Pointer) {
        /* Print the symbol value first. */
        dprintf("%p ", Pointer);
        
        /* Query the debugger for the symbol name and offset. */
        GetSymbol(Pointer, SymbolName, &Displacement);
        
        if (Displacement == 0)
            /* If the displacement is zero, print just the symbol name. */
            dprintf("(%s)%s", SymbolName, EndOfLine);
        else
            /* Otherwise, also print the offset from that symbol. */
            dprintf("(%s + 0x%X)%s", SymbolName, Displacement, EndOfLine);
    } else {
        dprintf("None%s", EndOfLine);
    }
}

/*
 * Function: PrintHookInterface
 * Description: Print the configuration and state of a hook interface.
 * Author: Created by shouse, 12.20.01
 */
void PrintHookInterface (ULONG64 pInterface) {
    ULONG dwValue;
    ULONG64 pAddr;
    ULONG64 pTemp;

    /* Make sure the address is non-NULL. */
    if (!pInterface) {
        dprintf("Error: Interface is NULL.\n");
        return;
    }

    /* Find out whether or not this interface is registered. */
    GetFieldValue(pInterface, HOOK_INTERFACE, HOOK_INTERFACE_FIELD_REGISTERED, dwValue);
    
    dprintf("          Registered:                 %s\n", (dwValue) ? "Yes" : "No");

    /* Get the offset of the registering entity (owner). */
    if (GetFieldOffset(HOOK_INTERFACE, HOOK_INTERFACE_FIELD_OWNER, &dwValue))
        dprintf("Can't get offset of %s in %s\n", HOOK_INTERFACE_FIELD_OWNER, HOOK_INTERFACE);
    else {
        pAddr = pInterface + dwValue;
        
        /* Get the pointer to the first team. */
        pTemp = GetPointerFromAddress(pAddr);
        
        dprintf("          Owner:                      0x%p\n", pTemp);
    }

    /* Get the offset of the deregister callback function. */
    if (GetFieldOffset(HOOK_INTERFACE, HOOK_INTERFACE_FIELD_DEREGISTER, &dwValue))
        dprintf("Can't get offset of %s in %s\n", HOOK_INTERFACE_FIELD_DEREGISTER, HOOK_INTERFACE);
    else {
        pAddr = pInterface + dwValue;
        
        /* Get the pointer to the first team. */
        pTemp = GetPointerFromAddress(pAddr);
        
        dprintf("          De-register callback:       ");

        PrintSymbol(pTemp, "\n");
    }
}

/*
 * Function: PrintHook
 * Description: Print the configuration and state of a single hook.
 * Author: Created by shouse, 12.20.01
 */
void PrintHook (ULONG64 pHook) {
    ULONG dwValue;
    ULONG64 pAddr;
    ULONG64 pTemp;

    /* Make sure the address is non-NULL. */
    if (!pHook) {
        dprintf("Error: Hook is NULL.\n");
        return;
    }

    /* Find out whether or not this hook is registered. */
    GetFieldValue(pHook, HOOK, HOOK_FIELD_REGISTERED, dwValue);
    
    dprintf("          Registered:                 %s\n", (dwValue) ? "Yes" : "No");

    /* Find out how many references exist on this hook. */
    GetFieldValue(pHook, HOOK, HOOK_FIELD_REFERENCES, dwValue);
    
    dprintf("          References:                 %u\n", dwValue);

    /* Get the offset of the hook function table. */
    if (GetFieldOffset(HOOK, HOOK_FIELD_HOOK, &dwValue))
        dprintf("Can't get offset of %s in %s\n", HOOK_FIELD_HOOK, HOOK);
    else {
        pAddr = pHook + dwValue;
        
        /* Get the pointer to the first team. */
        pTemp = GetPointerFromAddress(pAddr);
        
        dprintf("          Function callback:          ");

        PrintSymbol(pTemp, "\n");
    }

}

/*
 * Function: PrintHooks
 * Description: Print the state of the global NLB kernel-mode hooks.
 * Author: Created by shouse, 12.20.01
 */
void PrintHooks (ULONG64 pHooks) {
    ULONG dwValue;
    ULONG64 pFilter;
    ULONG64 pAddr;

    /* Make sure the address is non-NULL. */
    if (!pHooks) {
        dprintf("Error: Hook table is NULL.\n");
        return;
    }

    dprintf("  Filter Hooks:\n");

    /* Get the offset of the filter hook sub-structure. */
    if (GetFieldOffset(HOOK_TABLE, HOOK_TABLE_FIELD_FILTER_HOOK, &dwValue))
        dprintf("Can't get offset of %s in %s\n", HOOK_TABLE_FIELD_FILTER_HOOK, HOOK_TABLE);
    else {
        pFilter = pHooks + dwValue;
        
        /* Find out whether or not there is an operation in progress. */
        GetFieldValue(pFilter, FILTER_HOOK_TABLE, FILTER_HOOK_TABLE_FIELD_OPERATION, dwValue);
        
        dprintf("      Operation in progress:          ");

        switch (dwValue) {
        case HOOK_OPERATION_REGISTERING:
            dprintf("Register\n");
            break;
        case HOOK_OPERATION_DEREGISTERING:
            dprintf("De-register\n");
            break;
        case HOOK_OPERATION_NONE:
            dprintf("None\n");
            break;
        default:
            dprintf("Unknown\n");
            break;
        }

        dprintf("\n");

        /* Get the offset of the filter hook interface. */
        if (GetFieldOffset(FILTER_HOOK_TABLE, FILTER_HOOK_TABLE_FIELD_INTERFACE, &dwValue))
            dprintf("Can't get offset of %s in %s\n", FILTER_HOOK_TABLE_FIELD_INTERFACE, FILTER_HOOK_TABLE);
        else {
            pAddr = pFilter + dwValue;

            dprintf("      Interface:\n");

            /* Print the send hook interface state and configuration. */
            PrintHookInterface(pAddr);
        }

        dprintf("\n");

        /* Get the offset of the send filter hook. */
        if (GetFieldOffset(FILTER_HOOK_TABLE, FILTER_HOOK_TABLE_FIELD_SEND_HOOK, &dwValue))
            dprintf("Can't get offset of %s in %s\n", FILTER_HOOK_TABLE_FIELD_SEND_HOOK, FILTER_HOOK_TABLE);
        else {
            pAddr = pFilter + dwValue;

            dprintf("      Send Hook:\n");

            /* Print the send hook state and configuration. */
            PrintHook(pAddr);
        }

        dprintf("\n");

        /* Get the offset of the receive filter hook. */
        if (GetFieldOffset(FILTER_HOOK_TABLE, FILTER_HOOK_TABLE_FIELD_RECEIVE_HOOK, &dwValue))
            dprintf("Can't get offset of %s in %s\n", FILTER_HOOK_TABLE_FIELD_RECEIVE_HOOK, FILTER_HOOK_TABLE);
        else {
            pAddr = pFilter + dwValue;

            dprintf("      Receive Hook:\n");

            /* Print the send hook state and configuration. */
            PrintHook(pAddr);
        }
    }
}

/*
 * Function: PrintNetworkAddresses
 * Description: Prints the unicast and multicast MAC addresses configured on an NLB adapter.
 * Author: Created by shouse, 1.8.02
 */
void PrintNetworkAddresses (ULONG64 pContext) {
    WCHAR szString[256];
    UCHAR szMAC[256];
    ULONG dwValue;
    ULONG64 pOpen;
    ULONG64 pMiniport;
    ULONG64 pName;
    ULONG64 pAddr;
    ULONG64 pFilter;

    /* Make sure the address is non-NULL. */
    if (!pContext) {
        dprintf("Error: NLB context block is NULL.\n");
        return;
    }

    /* Get the MAIN_CTXT_CODE from the structure to make sure that this address
       indeed points to a valid NLB context block. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CODE, dwValue);
    
    if (dwValue != MAIN_CTXT_CODE) {
        dprintf("  Error: Invalid NLB context block.  Wrong code found (0x%08x).\n", dwValue);
        return;
    } 

    /* Get the MAC handle from the context block; this is a NDIS_OPEN_BLOCK pointer. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_MAC_HANDLE, pOpen);

    /* Get the miniport handle from the open block; this is a NDIS_MINIPORT_BLOCK pointer. */
    GetFieldValue(pOpen, NDIS_OPEN_BLOCK, NDIS_OPEN_BLOCK_FIELD_MINIPORT_HANDLE, pMiniport);
    
    /* Get a pointer to the adapter name from the miniport block. */
    GetFieldValue(pMiniport, NDIS_MINIPORT_BLOCK, NDIS_MINIPORT_BLOCK_FIELD_ADAPTER_NAME, pName);
    
    /* Get the length of the unicode string. */
    GetFieldValue(pName, UNICODE_STRING, UNICODE_STRING_FIELD_LENGTH, dwValue);

    /* Get the maximum length of the unicode string. */
    GetFieldValue(pName, UNICODE_STRING, UNICODE_STRING_FIELD_BUFFER, pAddr);

    /* Retrieve the contexts of the string and store it in a buffer. */
    GetString(pAddr, szString, dwValue);

    dprintf("%ls\n", szString);

    /* Get the maximum length of the unicode string. */
    GetFieldValue(pMiniport, NDIS_MINIPORT_BLOCK, NDIS_MINIPORT_BLOCK_FIELD_ETHDB, pFilter);
    
    /* Get the offset of the network address. */
    if (GetFieldOffset(_X_FILTER, _X_FILTER_FIELD_ADAPTER_ADDRESS, &dwValue))
        dprintf("Can't get offset of %s in %s\n", _X_FILTER_FIELD_ADAPTER_ADDRESS, _X_FILTER);
    else {
        pAddr = pFilter + dwValue;
        
        /* Retrieve the MAC addressand store it in a buffer. */
        GetMAC(pAddr, szMAC, ETH_LENGTH_OF_ADDRESS);
        
        dprintf("  Network address:                    %02X-%02X-%02X-%02X-%02X-%02X\n", 
                ((PUCHAR)(szMAC))[0], ((PUCHAR)(szMAC))[1], ((PUCHAR)(szMAC))[2], 
                ((PUCHAR)(szMAC))[3], ((PUCHAR)(szMAC))[4], ((PUCHAR)(szMAC))[5]);
    }

    /* Get the number of MAC addresses in the multicast list. */
    GetFieldValue(pFilter, _X_FILTER, _X_FILTER_FIELD_NUM_ADDRESSES, dwValue);

    dprintf("  Multicast MAC addresses (%u):        ", dwValue);

    /* Get the number of MAC addresses in the multicast list. */
    GetFieldValue(pFilter, _X_FILTER, _X_FILTER_FIELD_MCAST_ADDRESS_BUF, pAddr);

    for ( ; dwValue > 0; dwValue--, pAddr += ETH_LENGTH_OF_ADDRESS) {
        
        /* Retrieve the MAC addressand store it in a buffer. */
        GetMAC(pAddr, szMAC, ETH_LENGTH_OF_ADDRESS);
        
        dprintf("%02X-%02X-%02X-%02X-%02X-%02X\n", 
                ((PUCHAR)(szMAC))[0], ((PUCHAR)(szMAC))[1], ((PUCHAR)(szMAC))[2], 
                ((PUCHAR)(szMAC))[3], ((PUCHAR)(szMAC))[4], ((PUCHAR)(szMAC))[5]);

        if (dwValue != 1)
            dprintf("                                      ");
    }
}

/*
 * Function: PrintDIPList
 * Description: Prints the list of known dedicated IP addresses in the cluster.
 * Author: Created by shouse, 4.8.02
 */
void PrintDIPList (ULONG64 pList) {
    IN_ADDR dwIPAddr;
    CHAR * szString;
    ULONG dwValue;
    ULONG dwSize;
    ULONG64 pAddr = 0;
    BOOLEAN bFound = FALSE;
    INT i;

    /* Get the offset of the dedicated IP address array for this DIP list. */
    if (GetFieldOffset(DIPLIST, DIPLIST_FIELD_ITEMS, &dwValue))
        dprintf("Can't get offset of %s in %s\n", DIPLIST_FIELD_ITEMS, DIPLIST);
    else
        pAddr = pList + dwValue;

    /* Get the size of a ULONG. */
    dwSize = GetTypeSize(ULONG_T);

    for (i = 0; i < MAX_ITEMS; i++) {
        /* Get the dedicated IP address, which is a DWORD, and convert it to a string. */
        dwValue = GetUlongFromAddress(pAddr);
        
        /* If the DIP is present for this entry, print it. */
        if (dwValue != NULL_VALUE) {
            /* Note the fact that we found at least one DIP. */
            bFound = TRUE;

            dwIPAddr.S_un.S_addr = dwValue;
            szString = inet_ntoa(dwIPAddr);
            
            dprintf("      Host %2u:                        %s\n", i+1, szString);
        }

        /* Move the pointer to the next DIP. */
        pAddr += dwSize;
    }

    /* If no DIPs were printed, print "None". */
    if (!bFound)
        dprintf("      None\n");

    if (ChkTarget)
    {
        dprintf("\n");
        
        /* Get the number of DIP list checks so far. */
        GetFieldValue(pList, DIPLIST, DIPLIST_FIELD_NUM_CHECKS, dwValue);
        
        dprintf("      Number of checks:               %u\n");
        
        /* Get the number of checks that required ONLY the bit-vector lookup. */
        GetFieldValue(pList, DIPLIST, DIPLIST_FIELD_NUM_FAST_CHECKS, dwValue);
        
        dprintf("      Number of fast checks:          %u\n");
        
        /* Get the number of checks that required an array access. */
        GetFieldValue(pList, DIPLIST, DIPLIST_FIELD_NUM_ARRAY_LOOKUPS, dwValue);
        
        dprintf("      Number of array lookups:        %u\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbkd\utils.h ===
/*
 * File: utils.h
 * Description: This file contains function prototypes for the utility
 *              functions for the NLB KD extensions.
 * History: Created by shouse, 1.4.01
 */

/* Prints an error message when the symbols are bad. */
VOID ErrorCheckSymbols (CHAR * symbol);

/* Tokenizes a string via a configurable list of tokens. */
char * mystrtok (char * string, char * control);

/* Returns a ULONG residing at a given memory location. */
ULONG GetUlongFromAddress (ULONG64 Location);

/* Returns a UCHAR residing at a given memory location. */
UCHAR GetUcharFromAddress (ULONG64 Location);

/* Returns a memory address residing at a given memory location. */
ULONG64 GetPointerFromAddress (ULONG64 Location);

/* Reads data from a memory location into a buffer. */
BOOL GetData (IN LPVOID ptr, IN ULONG64 dwAddress, IN ULONG size, IN PCSTR type);

/* Copies a string from memory into a buffer. */
BOOL GetString (IN ULONG64 dwAddress, IN LPWSTR buf, IN ULONG MaxChars);

/* Copies an ethernet MAC address from memory into a buffer. */
BOOL GetMAC (IN ULONG64 dwAddress, IN UCHAR * buf, IN ULONG NumChars);

/* Returns a string corresponding to the given connection flags. */
CHAR * ConnectionFlagsToString (UCHAR cFlags);

/* This IS the NLB hashing function. */
ULONG Map (ULONG v1, ULONG v2);

#define HASH1_SIZE 257
#define HASH2_SIZE 59

#pragma pack(4)

typedef struct {
    ULONG Items[MAX_ITEMS];
    ULONG BitVector[(HASH1_SIZE+sizeof(ULONG))/sizeof(ULONG)];
    UCHAR HashTable[HASH2_SIZE+MAX_ITEMS];

    struct {
        ULONG NumChecks;
        ULONG NumFastChecks;
        ULONG NumArrayLookups;
    } stats;

} DipList;

#pragma pack()

#define BITS_PER_HASHWORD          (8*sizeof((DipList*)0)->BitVector[0])
#define SELECTED_BIT(_hash_value)  (0x1L << ((_hash_value) % BITS_PER_HASHWORD))

/* This function searches a collision hash table for a given dedicated IP address and returns TRUE if found. */
BOOL DipListCheckItem (ULONG64 pList, ULONG Value);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbkd\utils.c ===
/*
 * File: utils.c
 * Description: This file contains the implementation of some utility
 *              functions for the NLB KD extensions.
 * Author: Created by shouse, 1.4.01
 */

#include "nlbkd.h"
#include "utils.h"
#include "print.h"
#include "packet.h"
#include "load.h"

/*
 * Function: ErrorCheckSymbols
 * Description: Prints an error message when the symbols are bad.
 * Author: Created by shouse, 1.4.01 - copied largely from ndiskd.dll
 */
VOID ErrorCheckSymbols (CHAR * symbol) {

    dprintf("NLBKD: Error: Could not access %s - check symbols for wlbs.sys\n", symbol);
}

/*
 * Function: mystrtok
 * Description: Tokenizes a string via a configurable list of tokens.
 * Author: Created by shouse, 1.4.01 - copied largely from ndiskd.dll
 */
char * mystrtok (char * string, char * control) {
    static unsigned char * str;
    CHAR * p;
    CHAR * s;

    if (string) str = string;

    if (!str || (*str == '\0')) return NULL;

    for (; *str; str++) {

        for (s = control; *s; s++)
            if (*str == *s) break;
        
        if (*s == '\0') break;
    }

    if (*str == '\0') {
        str = NULL;
        return NULL;
    }

    for (p = str + 1; *p; p++) {
        for (s = control; *s; s++) {
            if(*p == *s) {
                s = str;
                *p = '\0';
                str = p + 1;
                return s;
            }
        }
    }

    s = str;
    str = NULL;

    return s;
}

/*
 * Function: GetUlongFromAddress
 * Description: Returns a ULONG residing at a given memory location.
 * Author: Created by shouse, 1.4.01 - copied largely from ndiskd.dll
 */
ULONG GetUlongFromAddress (ULONG64 Location) {
    ULONG result;
    ULONG value;

    if ((!ReadMemory(Location, &value, sizeof(ULONG), &result)) || (result < sizeof(ULONG))) {
        dprintf("unable to read from %08x\n", Location);
        return 0;
    }

    return value;
}

/*
 * Function: GetUcharFromAddress
 * Description: Returns a UCHAR residing at a given memory location.
 * Author: Created by shouse, 1.4.01 - copied largely from ndiskd.dll
 */
UCHAR GetUcharFromAddress (ULONG64 Location) {
    ULONG result;
    UCHAR value;

    if ((!ReadMemory(Location, &value, sizeof(UCHAR), &result)) || (result < sizeof(UCHAR))) {
        dprintf("unable to read from %08x\n", Location);
        return 0;
    }

    return value;
}

/*
 * Function: GetPointerFromAddress
 * Description: Returns a memory address residing at a given memory location.
 * Author: Created by shouse, 1.4.01 - copied largely from ndiskd.dll
 */
ULONG64 GetPointerFromAddress (ULONG64 Location) {
    ULONG64 Value;

    if (ReadPtr(Location,&Value)) {
        dprintf("unable to read from %p\n", Location);
        return 0;
    }

    return Value;
}

/*
 * Function: GetData
 * Description: Reads data from a memory location into a buffer.
 * Author: Created by shouse, 1.4.01 - copied largely from ndiskd.dll
 */
BOOL GetData (IN LPVOID ptr, IN ULONG64 dwAddress, IN ULONG size, IN PCSTR type) {
    ULONG count = size;
    ULONG BytesRead;
    BOOL b;

    while (size > 0) {

        if (count >= 3000) count = 3000;

        b = ReadMemory(dwAddress, ptr, count, &BytesRead);

        if (!b || BytesRead != count) {
            dprintf("Unable to read %u bytes at %p, for %s\n", size, dwAddress, type);
            return FALSE;
        }

        dwAddress += count;
        size -= count;
        ptr = (LPVOID)((ULONG_PTR)ptr + count);
    }

    return TRUE;
}

/*
 * Function: GetString
 * Description: Copies a string from memory into a buffer.
 * Author: Created by shouse, 1.4.01 - copied largely from ndiskd.dll
 */
BOOL GetString (IN ULONG64 dwAddress, IN LPWSTR buf, IN ULONG MaxChars) {

    do {
        if (!GetData(buf, dwAddress, sizeof(*buf), "Character"))
            return FALSE;

        dwAddress += sizeof(*buf);

    } while (--MaxChars && *buf++ != '\0');

    return TRUE;
}

/*
 * Function: GetMAC
 * Description: Copies an ethernet MAC address from memory into a buffer.
 * Author: Created by shouse, 1.14.01
 */
BOOL GetMAC (IN ULONG64 dwAddress, IN UCHAR * buf, IN ULONG NumChars) {

    do {
        if (!GetData(buf, dwAddress, sizeof(*buf), "Character"))
            return FALSE;

        dwAddress += sizeof(*buf);

        buf++;

    } while (--NumChars);

    return TRUE;
}

/*
 * Function: ConnectionFlagsToString
 * Description: Returns a string corresponding to the given connection flags.
 * Author: Created by shouse, 4.14.01
 */
CHAR * ConnectionFlagsToString (UCHAR cFlags) {

    switch (cFlags) {
    case NLB_FILTER_FLAGS_CONN_UP:
        return "SYN";
    case NLB_FILTER_FLAGS_CONN_DATA:
        return "DATA";
    case NLB_FILTER_FLAGS_CONN_DOWN:
        return "FIN";
    case NLB_FILTER_FLAGS_CONN_RESET:
        return "RST";
    default:
        return "Unknown";
    }
}

/*
 * Function: Map
 * Description: This IS the NLB hashing function.
 * Author: Created by shouse, 4.14.01
 */
ULONG Map (ULONG v1, ULONG v2) {
    ULONG y = v1;
    ULONG z = v2;
    ULONG sum = 0;

    const ULONG a = 0x67; //key [0];
    const ULONG b = 0xdf; //key [1];
    const ULONG c = 0x40; //key [2];
    const ULONG d = 0xd3; //key [3];

    const ULONG delta = 0x9E3779B9;

    sum += delta;
    y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
    z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;

    sum += delta;
    y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
    z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;

    sum += delta;
    y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
    z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;

    sum += delta;
    y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
    z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;

    sum += delta;
    y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
    z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;

    sum += delta;
    y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
    z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;

    sum += delta;
    y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
    z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;

    sum += delta;
    y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
    z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;

    return y ^ z;
}

/*
 * Function: DipListCheckItem
 * Description: This function searches a collision hash table for
 *              a given dedicated IP address and returns TRUE if
 *              found.
 * Author: Created by shouse, 8.21.02
 */
BOOL DipListCheckItem (ULONG64 pList, ULONG Value) {
    BOOL      fRet = FALSE;
    DipList   DL;
    DipList * pDL = &DL;

    GetData(pDL, pList, sizeof(DipList), "DipList");

    /* Check bit table. */
    {
        ULONG Hash1 = Value % HASH1_SIZE;
        ULONG u     = Hash1 / BITS_PER_HASHWORD;

        if (!(pDL->BitVector[u] & SELECTED_BIT(Hash1)))
            goto end;
    }

    /* Check hash table. */
    {
        ULONG   Hash2 = Value % HASH2_SIZE;
        UCHAR * pItem = pDL->HashTable + Hash2;
        UCHAR   iItem;

        while ((iItem = *pItem) != 0) {
            /* Note (iItem-1) is the index in pDL->Items where the value is located. */
            if (pDL->Items[iItem-1] == Value) {
                fRet = TRUE; 
                break;
            }
            
            pItem++;
        }
    }

 end:

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\cfgutillib\myntrtl.h ===
//
// These are taken from NTRTL.H. Currently including ntrtl.h causes
// errors because of a conflict with some other header file.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\cfgutillib\cfgutil.cpp ===
//***************************************************************************
//  CFGUTIL.CPP
//
// 
//  Module: WMI Framework Instance provider 
//
//  Purpose: Low-level utilities to configure NICs -- bind/unbind,
//           get/set IP address lists, and get/set NLB cluster params.
//
//  Copyright (c)2001 Microsoft Corporation, All Rights Reserved
//
//  History:
//
//  04/05/01    JosephJ Created (original version, called cfgutils.cpp under
//                nlbmgr\provider).
//  07/23/01    JosephJ Moved functionality to lib.
//
//***************************************************************************
#include "private.h"
#include <clusapi.h>
//
// Following two needed ONLY for RtlEncryptMemory...
//
#include <ntsecapi.h>
#include <crypt.h>
#include "cfgutil.tmh"


#define  NLB_API_DLL_NAME  L"wlbsctrl.dll"
#define  NLB_CLIENT_NAME   L"NLBManager"

//
// This magic has the side effect defining "smart pointers"
//  IWbemServicesPtr
//  IWbemLocatorPtr
//  IWbemClassObjectPtr
//  IEnumWbemClassObjectPtr
//  IWbemCallResultPtr
//  IWbemStatusCodeTextPtr
//
// These types automatically call the COM Release function when the
// objects go out of scope.
//
_COM_SMARTPTR_TYPEDEF(IWbemServices, __uuidof(IWbemServices));
_COM_SMARTPTR_TYPEDEF(IWbemLocator, __uuidof(IWbemLocator));
_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject, __uuidof(IEnumWbemClassObject));
_COM_SMARTPTR_TYPEDEF(IWbemCallResult, __uuidof(IWbemCallResult));
_COM_SMARTPTR_TYPEDEF(IWbemStatusCodeText, __uuidof(IWbemStatusCodeText));


WBEMSTATUS
CfgUtilGetWmiAdapterObjFromAdapterConfigurationObj(
    IN  IWbemServicesPtr    spWbemServiceIF,    // smart pointer
    IN  IWbemClassObjectPtr spObj,              // smart pointer
    OUT  IWbemClassObjectPtr &spAdapterObj      // smart pointer, by reference
    );

USHORT crc16(LPCWSTR ptr);

#if OBSOLETE
WBEMSTATUS
get_string_parameter(
    IN  IWbemClassObjectPtr      spObj,
    IN  LPCWSTR szParameterName,
    OUT LPWSTR *ppStringValue
    );
#endif // OBSOLETE

WBEMSTATUS
get_nic_instance(
    IN  IWbemServicesPtr    spWbemServiceIF,
    IN  LPCWSTR             szNicGuid,
    OUT IWbemClassObjectPtr &sprefObj
    );

WBEMSTATUS
get_multi_string_parameter(
    IN  IWbemClassObjectPtr      spObj,
    IN  LPCWSTR szParameterName,
    IN  UINT    MaxStringLen,  // in wchars, INCLUDING space for trailing zeros.
    OUT UINT    *pNumItems,
    OUT LPCWSTR *ppStringValue
    );

WBEMSTATUS
set_string_parameter(
    IN  IWbemClassObjectPtr      spObj,
    IN  LPCWSTR szParameterName,
    IN  LPCWSTR szValue
    );

WBEMSTATUS
set_multi_string_parameter(
    IN  IWbemClassObjectPtr      spObj,
    IN  LPCWSTR szParameterName,
    IN  UINT    MaxStringLen,  // in wchars, INCLUDING space for trailing zeros.
    IN  UINT    NumItems,
    IN  LPCWSTR pStringValue
    );

WBEMSTATUS
get_friendly_name_from_registry(
    LPCWSTR szGuid,
    LPWSTR *pszFriendlyName
    );



//
// This locally-defined class implements interfaces to WMI, NetConfig,
// and low-level NLB APIs.
//
class CfgUtils
{

public:
    
    //
    // Initialization function -- call before using any other functions 
    //
    WBEMSTATUS
    Initialize(
        BOOL fServer, // TRUE == try to dynamically load wlbsstrl.dll.
        BOOL fNoPing        // TRUE == CfgUtilPing becomes a no-op, always
                            // returning success.
        );

    //
    // Deinitialization function -- call after using any other functions
    //
    VOID
    Deinitialize(
        VOID
        );

    //
    // Constructor and distructor. 
    //
    CfgUtils(VOID)
    {
        //
        // WARNING: We do a blanked zero memory initialization of our entire
        // structure. Any other initialization should go into the
        // Initialize() function.
        //
        ZeroMemory(this, sizeof(*this));

        InitializeCriticalSection(&m_Crit);
    }

    ~CfgUtils()
    {
        DeleteCriticalSection(&m_Crit);
    }

    //
    // Check if we're initialized
    //
    BOOL
    IsInitalized(VOID)
    {
        return m_ComInitialized && m_WmiInitialized;
    }

// OBSOLETE IWbemStatusCodeTextPtr  m_spWbemStatusIF; // Smart pointer
    IWbemServicesPtr        m_spWbemServiceIF; // Smart pointer

    //
    // Following are pointers to functions we call from dynamically-
    // loaded wlbsctrl.dll. m_hWlbsCtrlDll is the module handle
    // returned from LoadLibrary("wlbsctrl.dll");
    // It should be freed in the context of this->Deintialize.
    //
    HMODULE m_hWlbsCtrlDll;
    BOOL                               m_NLBApiHooksPresent; // Was Loadlibrary/GetProcAddress/WlbsOpen successful ?

    WlbsOpen_FUNC                      m_pfWlbsOpen; // NLB api to create connection to NLB driver, It returns INVALID_HANDLE_VALUE (NOT NULL) on failure
    WlbsLocalClusterControl_FUNC       m_pfWlbsLocalClusterControl; // NLB api to control local NLB operation
    WlbsAddPortRule_FUNC               m_pfWlbsAddPortRule; // NLB api to add a port rule
    WlbsDeleteAllPortRules_FUNC        m_pfWlbsDeleteAllPortRules; // NLB api to delete all port rules
    WlbsEnumPortRules_FUNC             m_pfWlbsEnumPortRules;// NLB api to enumerate port rules
    WlbsSetDefaults_FUNC               m_pfWlbsSetDefaults; // NLB api to set default values for NLB configuration
    WlbsValidateParams_FUNC            m_pfWlbsValidateParams; // NLB api to validate registry parameters
    WlbsParamReadReg_FUNC              m_pfWlbsParamReadReg; // NLB api to read registry parameters

    //
    // We need to define this prototype here, because it's not exported
    // in wlbsconfig.h
    typedef BOOL   (WINAPI *WlbsParamWriteReg_FUNC)
    (
        const GUID &      pAdapterGuid, 
        PWLBS_REG_PARAMS reg_data
    ); 

    WlbsParamWriteReg_FUNC              m_pfWlbsParamWriteReg; // NLB api to write registry parameters
    WlbsWriteAndCommitChanges_FUNC     m_pfWlbsWriteAndCommitChanges; // NLB api to write parametrs into registry and to commit changes to NLB driver 
    WlbsSetRemotePassword_FUNC         m_pfWlbsSetRemotePassword; // NLB api to set the remote password.
    WlbsGetClusterMembers_FUNC         m_pfWlbsGetClusterMembers; // NLB api to retrieve information on members of the cluster

    BOOL
    DisablePing(VOID)
    {
        return m_fNoPing!=FALSE;
    }

private:


    //
    // A single lock serialzes all access.
    // Use mfn_Lock and mfn_Unlock.
    //
    CRITICAL_SECTION m_Crit;

    BOOL m_ComInitialized;
    BOOL m_WmiInitialized;
    BOOL m_WinsockInitialized;
    BOOL m_fNoPing;

    VOID
    mfn_Lock(
        VOID
        )
    {
        EnterCriticalSection(&m_Crit);
    }

    VOID
    mfn_Unlock(
        VOID
        )
    {
        LeaveCriticalSection(&m_Crit);
    }

    VOID
    mfn_LoadWlbsFuncs(VOID);

    VOID
    mfn_UnloadWlbsFuncs(VOID); // ok to call multiple times (i.e. idempotent).
};


//
// This class manages NetCfg interfaces
//
class MyNetCfg
{

public:

    MyNetCfg(VOID)
    {
        m_pINetCfg  = NULL;
        m_pLock     = NULL;
    }

    ~MyNetCfg()
    {
        ASSERT(m_pINetCfg==NULL);
        ASSERT(m_pLock==NULL);
    }

    WBEMSTATUS
    Initialize(
        BOOL fWriteLock
        );

    VOID
    Deinitialize(
        VOID
        );


    WBEMSTATUS
    GetNlbCompatibleNics(
        OUT LPWSTR **ppszNics,
        OUT UINT   *pNumNics,
        OUT UINT   *pNumBoundToNlb // OPTIONAL
        );

    WBEMSTATUS
    GetNicIF(
        IN  LPCWSTR szNicGuid,
        OUT INetCfgComponent **ppINic
        );

    WBEMSTATUS
    GetBindingIF(
        IN  LPCWSTR                     szComponent,
        OUT INetCfgComponentBindings   **ppIBinding
        );

    typedef enum
    {
        NOOP,
        BIND,
        UNBIND

    } UPDATE_OP;

    WBEMSTATUS
    UpdateBindingState(
        IN  LPCWSTR         szNic,
        IN  LPCWSTR         szComponent,
        IN  UPDATE_OP       Op,
        OUT BOOL            *pfBound
        );

    static
    WBEMSTATUS
    GetWriteLockState(
        OUT BOOL *pfCanLock,
        LPWSTR   *pszHeldBy // OPTIONAL, free using delete[].
        );

private:

    INetCfg     *m_pINetCfg;
    INetCfgLock *m_pLock;

}; // Class MyNetCfg

//
// We keep a single global instance of this class around currently...
//
CfgUtils g_CfgUtils;


WBEMSTATUS
CfgUtilInitialize(BOOL fServer, BOOL fNoPing)
{
    return g_CfgUtils.Initialize(fServer, fNoPing);
}

VOID
CfgUtilDeitialize(VOID)
{
    return g_CfgUtils.Deinitialize();
}


WBEMSTATUS
CfgUtils::Initialize(BOOL fServer, BOOL fNoPing)
{
    WBEMSTATUS Status = WBEM_E_INITIALIZATION_FAILURE;
    HRESULT hr;
    TRACE_INFO(L"-> CfgUtils::Initialize(fServer=%lu, fNoPing=%lu)",
                fServer, fNoPing);

    mfn_Lock();

    //
    // Initialize COM
    //
    {
        hr = CoInitializeEx(0, COINIT_DISABLE_OLE1DDE| COINIT_MULTITHREADED);
        if ( FAILED(hr) )
        {
            TRACE_CRIT(L"CfgUtils: Failed to initialize COM library (hr=0x%08lx)", hr);
            goto end;
        }
        m_ComInitialized = TRUE;
    }

    //
    // WMI Initialization
    //
    {
        IWbemLocatorPtr         spWbemLocatorIF = NULL; // Smart pointer

#if OBSOLETE
        //
        // Get error text generator interface
        //
        SCODE sc = CoCreateInstance(
                    CLSID_WbemStatusCodeText,
                    0,
                    CLSCTX_INPROC_SERVER,
                    IID_IWbemStatusCodeText,
                    (LPVOID *) &m_spWbemStatusIF
                    );
        if( sc != S_OK )
        {
            ASSERT(m_spWbemStatusIF == NULL); // smart pointer
            TRACE_CRIT(L"CfgUtils: CoCreateInstance IWbemStatusCodeText failure\n");
            goto end;
        }
        TRACE_INFO(L"CfgUtils: m_spIWbemStatusIF=0x%p\n", (PVOID) m_spWbemStatusIF);
#endif // OBSOLETE

        //
        // Get "locator" interface
        //
        hr = CoCreateInstance(
                CLSID_WbemLocator, 0, 
                CLSCTX_INPROC_SERVER, 
                IID_IWbemLocator, 
                (LPVOID *) &spWbemLocatorIF
                );
 
        if (FAILED(hr))
        {
            ASSERT(spWbemLocatorIF == NULL); // smart pointer
            TRACE_CRIT(L"CoCreateInstance  IWebmLocator failed 0x%08lx", (UINT)hr);
            goto end;
        }

        //
        // Get interface to provider for NetworkAdapter class objects
        // on the local machine
        //
        _bstr_t serverPath = L"root\\cimv2";
        hr = spWbemLocatorIF->ConnectServer(
                serverPath,
                NULL, // strUser,
                NULL, // strPassword,
                NULL,
                0,
                NULL,
                NULL,
                &m_spWbemServiceIF
             );
        if (FAILED(hr))
        {
            ASSERT(m_spWbemServiceIF == NULL); // smart pointer
            TRACE_CRIT(L"ConnectServer to cimv2 failed 0x%08lx", (UINT)hr);
            goto end;
        }
        TRACE_INFO(L"CfgUtils: m_spIWbemServiceIF=0x%p\n", (PVOID) m_spWbemServiceIF);

        hr = CoSetProxyBlanket(
                    m_spWbemServiceIF,
                    RPC_C_AUTHN_WINNT,
                    RPC_C_AUTHZ_DEFAULT,      // RPC_C_AUTHZ_NAME,
                    COLE_DEFAULT_PRINCIPAL,   // NULL,
                    RPC_C_AUTHN_LEVEL_DEFAULT,
                    RPC_C_IMP_LEVEL_IMPERSONATE,
                    COLE_DEFAULT_AUTHINFO, // NULL,
                    EOAC_DEFAULT // EOAC_NONE
                    );
        
        if (FAILED(hr))
        {
            TRACE_INFO(L"Error 0x%08lx setting proxy blanket", (UINT) hr);
            goto end;
        }


        //
        // Release locator interface.
        //
        // <NO need to do this explicitly, because this is a smart pointer>
        //
        spWbemLocatorIF = NULL;
        m_WmiInitialized = TRUE;
    }


    //
    // Netconfig Initialization
    //
    {
        // Nothing to do here...
    }

    //
    // WLBS API Initialization
    //

    //
    // Dynamically load selected entrypoints from wlbsctrl.dll.
    // We do not fail initialization if this operation fails.
    // (Because this could be running on a machine that doesn't have
    // wlbsctrl.dll). Instead we set/clear a flag (m_NLBApiHooksPresent)
    //
    //
    if (fServer)
    {
        mfn_LoadWlbsFuncs();
    }
    Status  = WBEM_NO_ERROR;


    //
    // Winsock initialization. We don't consider it an error if we fail.
    // As only certain functions will fail (eg CfgUtilPing).
    //
    {
        WSADATA         data;
        int iWsaStatus = WSAStartup (WINSOCK_VERSION, & data);
        if (iWsaStatus == 0)
        {
            TRACE_INFO("%!FUNC! Winsock initialized successfully");
            m_WinsockInitialized = TRUE;
        }
        else
        {
            TRACE_CRIT("%!FUNC! WARNING Winsock initialization failed with error 0x%lx",
                    iWsaStatus);
            m_WinsockInitialized = FALSE;
        }
    }

end:

    mfn_Unlock();

    if (FAILED(Status))
    {
        TRACE_CRIT("%!FUNC! -- FAILING INITIALIZATION! Status=0x%08lx",
            (UINT) Status);
        CfgUtils::Deinitialize();
    }


    //
    // Set the NoPing field...
    //
    m_fNoPing = fNoPing;

    TRACE_INFO(L"<- CfgUtils::Initialize(Status=0x%08lx)", (UINT) Status);

    return Status;
}



VOID
CfgUtils::Deinitialize(
    VOID
    )
//
// NOTE: can be called in the context of a failed initialization.
//
{
    TRACE_INFO(L"-> CfgUtils::Deinitialize");

    mfn_Lock();

    //
    // Winsock deinitialization.
    //
    if (m_WinsockInitialized)
    {
        WSACleanup();
        m_WinsockInitialized = FALSE;
    }
    
    //
    // De-initialize WLBS API
    //
    mfn_UnloadWlbsFuncs();

    //
    // Deinitialize Netconfig
    //

    //
    // Deinitialize WMI
    //
    {
    #if OBSOLETE
        //
        // Release interface to NetworkAdapter provider
        //
        if (m_spWbemStatusIF!= NULL)
        {
            // Smart pointer.
            m_spWbemStatusIF= NULL;
        }
    #endif // OBSOLETE

        if (m_spWbemServiceIF!= NULL)
        {
            // Smart pointer.
            m_spWbemServiceIF= NULL;
        }

        m_WmiInitialized = FALSE;
    }

    //
    // Deinitialize COM.
    //
    if (m_ComInitialized)
    {
        TRACE_CRIT(L"CfgUtils: Deinitializing COM");
        CoUninitialize();
        m_ComInitialized = FALSE;
    }

    mfn_Unlock();

    TRACE_INFO(L"<- CfgUtils::Deinitialize");
}

VOID
CfgUtils::mfn_LoadWlbsFuncs(VOID)
{
    BOOL            fSuccess = FALSE;
    HMODULE         DllHdl;

    m_NLBApiHooksPresent = FALSE;

    if ((DllHdl = LoadLibrary(NLB_API_DLL_NAME)) == NULL)
    {
        TRACE_CRIT("%!FUNC! LoadLibrary of %ls failed with error : 0x%x", NLB_API_DLL_NAME, GetLastError());
    }
    else
    {

        m_pfWlbsOpen = (WlbsOpen_FUNC) GetProcAddress(DllHdl, "WlbsOpen");
        m_pfWlbsLocalClusterControl = (WlbsLocalClusterControl_FUNC) GetProcAddress(DllHdl, "WlbsLocalClusterControl");
        m_pfWlbsAddPortRule = (WlbsAddPortRule_FUNC) GetProcAddress(DllHdl, "WlbsAddPortRule");
        m_pfWlbsDeleteAllPortRules = (WlbsDeleteAllPortRules_FUNC) GetProcAddress(DllHdl, "WlbsDeleteAllPortRules");
        m_pfWlbsEnumPortRules = (WlbsEnumPortRules_FUNC) GetProcAddress(DllHdl, "WlbsEnumPortRules");
        m_pfWlbsSetDefaults = (WlbsSetDefaults_FUNC) GetProcAddress(DllHdl, "WlbsSetDefaults");
        m_pfWlbsValidateParams = (WlbsValidateParams_FUNC) GetProcAddress(DllHdl, "WlbsValidateParams");
        m_pfWlbsParamReadReg = (WlbsParamReadReg_FUNC) GetProcAddress(DllHdl, "WlbsParamReadReg");
        m_pfWlbsParamWriteReg = (WlbsParamWriteReg_FUNC) GetProcAddress(DllHdl, "ParamWriteReg");
        m_pfWlbsWriteAndCommitChanges = (WlbsWriteAndCommitChanges_FUNC) GetProcAddress(DllHdl, "WlbsWriteAndCommitChanges");
        m_pfWlbsSetRemotePassword = (WlbsSetRemotePassword_FUNC) GetProcAddress(DllHdl, "WlbsSetRemotePassword");
        m_pfWlbsGetClusterMembers = (WlbsGetClusterMembers_FUNC) GetProcAddress(DllHdl, "WlbsGetClusterMembers");

        if((m_pfWlbsOpen == NULL) 
         || (m_pfWlbsLocalClusterControl == NULL) 
         || (m_pfWlbsAddPortRule == NULL) 
         || (m_pfWlbsDeleteAllPortRules == NULL) 
         || (m_pfWlbsEnumPortRules == NULL) 
         || (m_pfWlbsSetDefaults == NULL) 
         || (m_pfWlbsValidateParams == NULL) 
         || (m_pfWlbsParamReadReg == NULL) 
         || (m_pfWlbsParamWriteReg == NULL) 
         || (m_pfWlbsWriteAndCommitChanges == NULL)
         || (m_pfWlbsSetRemotePassword == NULL)
         || (m_pfWlbsGetClusterMembers == NULL))
        {
            TRACE_CRIT("%!FUNC! GetProcAddress failed for NLB API DLL functions");
            FreeLibrary(DllHdl);
            DllHdl = NULL;
        }
        else
        {
            fSuccess = TRUE;
        }

    }

    if (fSuccess)
    {
        m_hWlbsCtrlDll = DllHdl;
        m_NLBApiHooksPresent = TRUE;
    }
    else
    {
        mfn_UnloadWlbsFuncs(); // this will zero-out the function pointers.
    }

    return;
}


VOID
CfgUtils::mfn_UnloadWlbsFuncs(VOID)
//
// ok to call multiple times (i.e. idempotent).
// MUST be called with lock held.
//
{
    m_NLBApiHooksPresent = FALSE;

    m_pfWlbsOpen                = NULL;
    m_pfWlbsLocalClusterControl = NULL;
    m_pfWlbsAddPortRule         = NULL;
    m_pfWlbsDeleteAllPortRules  = NULL;
    m_pfWlbsEnumPortRules       = NULL;
    m_pfWlbsSetDefaults         = NULL;
    m_pfWlbsValidateParams      = NULL;
    m_pfWlbsParamReadReg        = NULL ;
    m_pfWlbsParamWriteReg        = NULL ;
    m_pfWlbsWriteAndCommitChanges = NULL;
    m_pfWlbsSetRemotePassword    = NULL;
    m_pfWlbsGetClusterMembers   = NULL;

    if (m_hWlbsCtrlDll != NULL)
    {
        FreeLibrary(m_hWlbsCtrlDll);
        m_hWlbsCtrlDll = NULL;
    }
}

//***************************************************************************
//
//  SCODE CfgUtilParseAuthorityUserArgs
//
//  DESCRIPTION:
//
//  This function is a straight lift from the wmi sdk sample project : utillib,
//  File : wbemsec.cpp, Function : ParseAuthorityUserArgs
//  This function is used internally only.
//
//  Examines the Authority and User argument and determines the authentication
//  type and possibly extracts the domain name from the user arugment in the 
//  NTLM case.  For NTLM, the domain can be at the end of the authentication
//  string, or in the front of the user name, ex;  "redmond\a-davj"
//
//  PARAMETERS:
//
//  AuthArg             Output, contains the domain name
//  UserArg             Output, user name
//  Authority           Input
//  User                Input
//
//  RETURN VALUE: WBEMSTATUS
// 
//***************************************************************************

WBEMSTATUS CfgUtilParseAuthorityUserArgs(BSTR & AuthArg, BSTR & UserArg, LPCWSTR Authority, LPCWSTR User)
{

    TRACE_INFO(L"-> %!FUNC!");

    //
    // If the Authority string is passed, then, it better begin with "NTLMDOMAIN:"
    //
    if(!(Authority == NULL || wcslen(Authority) == 0 || !_wcsnicmp(Authority, L"NTLMDOMAIN:",11)))
    {
        TRACE_CRIT(L"%!FUNC! Invalid authority string : %ls, Must be NULL or empty or begin with \"NTLMDOMAIN:\"",Authority);
        TRACE_INFO(L"<- %!FUNC! returning WBEM_E_INVALID_PARAMETER");
        return WBEM_E_INVALID_PARAMETER;
    }

    // The ntlm case is more complex.  There are four cases
    // 1)  Authority = NTLMDOMAIN:name" and User = "User"
    // 2)  Authority = NULL and User = "User"
    // 3)  Authority = "NTLMDOMAIN:" User = "domain\user"
    // 4)  Authority = NULL and User = "domain\user"

    //
    // first step is to determine if there is a backslash in the user name somewhere between the
    // second and second to last character
    //

    WCHAR * pSlashInUser = NULL;
    if(User)
    {
        WCHAR * pEnd = (WCHAR *)User + wcslen(User) - 1;
        for(pSlashInUser = (WCHAR *)User; pSlashInUser <= pEnd; pSlashInUser++)
            if(*pSlashInUser == L'\\')      // dont think forward slash is allowed!
                break;
        if(pSlashInUser > pEnd)
            pSlashInUser = NULL;
    }

    //
    // If Authority string is passed and it is of the form "NTLMDOMAIN:XXXX", copy over "XXXX" into
    // AuthArg. The only other form that it could take is "NTLMDOMAIN:", in which case, we leave
    // AuthArg to be NULL.
    //
    if(Authority && wcslen(Authority) > 11) 
    {
        if(pSlashInUser)
        {
            TRACE_CRIT(L"%!FUNC! Invalid combination of User : %ls & Authority string : %ls",User,Authority);
            TRACE_INFO(L"<- %!FUNC! returning WBEM_E_INVALID_PARAMETER");
            return WBEM_E_INVALID_PARAMETER;
        }

        if ((AuthArg = SysAllocString(Authority + 11)) == NULL)
        {
            TRACE_CRIT(L"%!FUNC! Out of memory, Memory allocation failed for Authority string : %ls",Authority + 11);
            TRACE_INFO(L"<- %!FUNC! returning WBEM_E_OUT_OF_MEMORY");
            return WBEM_E_OUT_OF_MEMORY;
        }

        if(User) 
        {
            UserArg = SysAllocString(User);
            TRACE_CRIT(L"%!FUNC! Out of memory, Memory allocation failed for User string : %ls",User);
            SysFreeString(AuthArg);
            TRACE_INFO(L"<- %!FUNC! returning WBEM_E_OUT_OF_MEMORY");
            return WBEM_E_OUT_OF_MEMORY;
        }

        TRACE_INFO(L"<- %!FUNC! returning WBEM_NO_ERROR");
        return WBEM_NO_ERROR;
    }
    else if(pSlashInUser)
    {
        // backslash was found in "User", extract the domain name present before the backslash
        int iDomLen = pSlashInUser-User;
        WCHAR cTemp[MAX_PATH];
        wcsncpy(cTemp, User, iDomLen);
        cTemp[iDomLen] = 0;

        if ((AuthArg = SysAllocString(cTemp)) == NULL)
        {
            TRACE_CRIT(L"%!FUNC! Out of memory, Memory allocation failed for Authority (\"Authority\\User\") string : %ls",cTemp);
            TRACE_INFO(L"<- %!FUNC! returning WBEM_E_OUT_OF_MEMORY");
            return WBEM_E_OUT_OF_MEMORY;
        }
        if(wcslen(pSlashInUser+1))
        {
            if ((UserArg = SysAllocString(pSlashInUser+1)) == NULL)
            {
                TRACE_CRIT(L"%!FUNC! Out of memory, Memory allocation failed for Authority (\"Authority\\User\") string : %ls",pSlashInUser+1);
                SysFreeString(AuthArg);
                TRACE_INFO(L"<- %!FUNC! returning WBEM_E_OUT_OF_MEMORY");
                return WBEM_E_OUT_OF_MEMORY;
            }
        }
    }
    else // User name did not contain backslash (ie. domain) AND (Authority was NOT passed or was = "NTLMDOMAIN:")
    {
        if(User) 
        {
            if ((UserArg = SysAllocString(User)) == NULL)
            {
                TRACE_CRIT(L"%!FUNC! Out of memory, Memory allocation failed for User (No Authority) string : %ls",User);
                TRACE_INFO(L"<- %!FUNC! returning WBEM_E_OUT_OF_MEMORY");
                return WBEM_E_OUT_OF_MEMORY;
            }
        }
    }

    TRACE_INFO(L"<- %!FUNC! returning WBEM_NO_ERROR");
    return WBEM_NO_ERROR;
}

//
// Gets the list of statically-bound IP addresses for the NIC.
// Sets *pNumIpAddresses to 0 if DHCP
//
WBEMSTATUS
CfgUtilGetIpAddressesAndFriendlyName(
    IN  LPCWSTR szNic,
    OUT UINT    *pNumIpAddresses,
    OUT NLB_IP_ADDRESS_INFO **ppIpInfo, // Free using c++ delete operator.
    OUT LPWSTR *pszFriendlyName // Optional, Free using c++ delete
    )
{
    WBEMSTATUS          Status  = WBEM_NO_ERROR;
    IWbemClassObjectPtr spObj   = NULL;  // smart pointer
    HRESULT             hr;
    LPCWSTR             pAddrs  = NULL;
    LPCWSTR             pSubnets = NULL;
    UINT                AddrCount = 0;
    UINT                ValidAddrCount = 0;
    NLB_IP_ADDRESS_INFO *pIpInfo = NULL;

    TRACE_INFO(L"-> %!FUNC!(Nic=%ws)", szNic);

    *pNumIpAddresses = NULL;
    *ppIpInfo = NULL;
    if (pszFriendlyName!=NULL)
    {
        *pszFriendlyName = NULL;
    }

    //
    // If not initialized, fail...
    //
    if (!g_CfgUtils.IsInitalized())
    {
        TRACE_CRIT(L"%!FUNC!(Nic=%ws) FAILING because uninitialized", szNic);
        Status =  WBEM_E_INITIALIZATION_FAILURE;
        goto end;
    }

    //
    // Get WMI instance to specific NIC
    //
    Status = get_nic_instance(
                g_CfgUtils.m_spWbemServiceIF,
                szNic,
                spObj // pass by reference
                );
    if (FAILED(Status))
    {
        ASSERT(spObj == NULL);
        goto end;
    }


    //
    // Extract IP addresses and subnets.
    //
    {
        //
        // This gets the ip addresses in a 2D WCHAR array -- inner dimension
        // is WLBS_MAX_CLI_IP_ADDR.
        //
        Status =  get_multi_string_parameter(
                    spObj,
                    L"IPAddress", // szParameterName,
                    WLBS_MAX_CL_IP_ADDR, // MaxStringLen - in wchars, incl null
                    &AddrCount,
                    &pAddrs
                    );

        if (FAILED(Status))
        {
            pAddrs = NULL;
            goto end;
        }
        else
        {
            TRACE_INFO("GOT %lu IP ADDRESSES!", AddrCount);
        }

        UINT SubnetCount;
        Status =  get_multi_string_parameter(
                    spObj,
                    L"IPSubnet", // szParameterName,
                    WLBS_MAX_CL_NET_MASK, // MaxStringLen - in wchars, incl null
                    &SubnetCount,
                    &pSubnets
                    );

        if (FAILED(Status))
        {
            pSubnets = NULL;
            goto end;
        }
        else if (SubnetCount != AddrCount)
        {
            TRACE_CRIT("FAILING SubnetCount!=AddressCount!");
            goto end;
        }
    }

    //
    // Convert IP addresses to our internal form.
    //
    if (AddrCount != 0)
    {
        pIpInfo = new NLB_IP_ADDRESS_INFO[AddrCount];
        if (pIpInfo == NULL)
        {
            TRACE_CRIT("get_multi_str_parm: Alloc failure!");
            Status = WBEM_E_OUT_OF_MEMORY;
            goto end;
        }
        ZeroMemory(pIpInfo, AddrCount*sizeof(*pIpInfo));
        
        for (UINT u=0;u<AddrCount; u++)
        {
            //
            // We extrace each IP address and it's corresponding subnet mask
            // from the 2 2D arrays and insert it into a NLB_IP_ADDRESS_INFO
            // structure.
            //
            LPCWSTR pIp = pAddrs+u*WLBS_MAX_CL_IP_ADDR;
            LPCWSTR pSub = pSubnets+u*WLBS_MAX_CL_NET_MASK;
            TRACE_INFO("IPaddress: %ws; SubnetMask:%ws", pIp, pSub);
            UINT len = wcslen(pIp);
            UINT len1 = wcslen(pSub);
            if ( (len < WLBS_MAX_CL_IP_ADDR) && (len1 < WLBS_MAX_CL_NET_MASK))
            {
                //
                // We can sometimes get blank IP addresses -- if there's been
                // an IP address conflict. So let's skip those.
                //
                if (*pIp==0 || _wcsspnp(pIp, L".0")==NULL)
                {
                    TRACE_CRIT(L"%!FUNC! ignoring blank IP address!");
                }
                else
                {
                    CopyMemory(pIpInfo[u].IpAddress, pIp, (len+1)*sizeof(WCHAR));
                    CopyMemory(pIpInfo[u].SubnetMask, pSub, (len1+1)*sizeof(WCHAR));
                    ValidAddrCount++;
                }
            }
            else
            {
                //
                // This would be an implementation error in get_multi_string_...
                //
                ASSERT(FALSE);
                Status = WBEM_E_CRITICAL_ERROR;
                goto end;
            }
        }
    }

    if (ValidAddrCount == 0)
    {
        delete[] pIpInfo; // could be NULL.
        pIpInfo = NULL;
    }

    //
    // If requested, get friendly name.
    // We don't fail if there's an error, just return the empty "" string.
    //
    if (pszFriendlyName != NULL)
    {
        IWbemClassObjectPtr spAdapterObj   = NULL;  // smart pointer 
        LPWSTR   szFriendlyName  = NULL;
        WBEMSTATUS TmpStatus;

        TRACE_INFO(L"%!FUNC!: Getting friendly name for Nic %ws", szNic);

#if USE_WMI_FOR_FRIENDLY_NAME

        //
        // Enabling this code block causes us to take over 1000 times as long
        // to get the friendly name -- so don't enable it!
        // This code (i.e. the slow version) ships in .Net Server Beta3,
        // but is commented out and repaced by the faster registry-growelling
        // version.
        //

        do
        {
            TmpStatus = CfgUtilGetWmiAdapterObjFromAdapterConfigurationObj(
                            g_CfgUtils.m_spWbemServiceIF,
                            spObj,
                            spAdapterObj // passed by ref
                            );

            if (FAILED(TmpStatus))
            {
                break;
            }

            TmpStatus = CfgUtilGetWmiStringParam(
                            spAdapterObj,
                            L"NetConnectionID",
                            &szFriendlyName
                            );
            if (FAILED(TmpStatus))
            {
                TRACE_CRIT("%!FUNC! Get NetConnectionID failed error=0x%08lx\n",
                            (UINT) TmpStatus);

            }

        }  while (FALSE);
#else  !USE_WMI_FOR_FRIENDLY_NAME
        Status = get_friendly_name_from_registry(szNic, &szFriendlyName);

#endif //  !USE_WMI_FOR_FRIENDLY_NAME
        if (FAILED(Status))
        {
            TRACE_INFO(L"%!FUNC!: Got error 0x%lx attempting to get friendly name", Status);
            szFriendlyName  = NULL;
            Status = WBEM_NO_ERROR; // we'll ignore this..
        }
        else
        {
            TRACE_INFO(L"%!FUNC!: Got friendly name \"%ws\" for NIC %ws",
                    szFriendlyName ? szFriendlyName:L"<null>", szNic);
        }


        if (szFriendlyName == NULL)
        {
            //
            // Try to put an empty string.
            //
            szFriendlyName = new WCHAR[1];
            if (szFriendlyName == NULL)
            {
                Status = WBEM_E_OUT_OF_MEMORY;
                TRACE_CRIT("%!FUNC! Alloc failure!");
                goto end;
            }
            *szFriendlyName = 0; // Empty string
        }

        *pszFriendlyName = szFriendlyName;
        szFriendlyName = NULL;
    }

end:

    if (pAddrs != NULL)
    {
        delete pAddrs;
    }
    if (pSubnets != NULL)
    {
        delete pSubnets;
    }

    if (FAILED(Status))
    {
        if (pIpInfo != NULL)
        {
            delete[] pIpInfo;
            pIpInfo = NULL;
        }
        ValidAddrCount = 0;
    }

    *pNumIpAddresses = ValidAddrCount;
    *ppIpInfo = pIpInfo;
    spObj   = NULL;  // smart pointer

    TRACE_INFO(L"<- %!FUNC!(Nic=%ws) returns 0x%08lx", szNic, (UINT) Status);

    return Status;
}


//
// Sets the list of statically-bound IP addresses for the NIC.
// if NumIpAddresses is 0, the NIC is configured for DHCP.
//
WBEMSTATUS
CfgUtilSetStaticIpAddresses(
    IN  LPCWSTR szNic,
    IN  UINT    NumIpAddresses,
    IN  NLB_IP_ADDRESS_INFO *pIpInfo
    )
{
    WBEMSTATUS          Status = WBEM_E_CRITICAL_ERROR;
    IWbemClassObjectPtr      spWbemInputInstance = NULL; // smart pointer
    WCHAR *rgIpAddresses = NULL;
    WCHAR *rgIpSubnets   = NULL;
    LPWSTR             pRelPath = NULL;
    NLB_IP_ADDRESS_INFO AutonetIpInfo;

    TRACE_INFO(L"-> %!FUNC!(Nic=%ws)", szNic);

    //
    // If not initialized, fail...
    //
    if (!g_CfgUtils.IsInitalized())
    {
        TRACE_CRIT(L"%!FUNC!(Nic=%ws) FAILING because uninitialized", szNic);
        Status =  WBEM_E_INITIALIZATION_FAILURE;
        goto end;
    }

    if (NumIpAddresses == 0)
    {

        //
        // If there are no IP addresses specified, we generate a
        // random autonet address. This is because the wmi set operation 
        // below simply fails if no addresses are specified. Strictly speaking
        // we should try dhcp.
        //
        // AutoNet address in the address range 169.254,
        // and it will give itself a class B subnet mask that
        // is 255.255.0.0.
        //

        ZeroMemory(&AutonetIpInfo, sizeof(AutonetIpInfo));

        UINT u1, u2;
        u1 = crc16(szNic);
        u2 = (u1>>8)&0xff;
        u1 = u1&0xff;
        if (u1>=255)    u1=254;
        if (u2==0)      u2=1;
        if (u2>=255)    u2=254;

        StringCbPrintf(AutonetIpInfo.IpAddress, sizeof(AutonetIpInfo.IpAddress), L"169.254.%lu.%lu", u1, u2);
        ARRAYSTRCPY(AutonetIpInfo.SubnetMask, L"255.255.0.0");

        NumIpAddresses = 1;
        pIpInfo = &AutonetIpInfo;

        // SECURITY BUGBUG -- consider compiling this out...
    }


    if (NumIpAddresses != 0)
    {
        //
        // Convert IP addresses from our internal form into 2D arrays.
        //
        rgIpAddresses = new WCHAR[NumIpAddresses * WLBS_MAX_CL_IP_ADDR];
        rgIpSubnets   = new WCHAR[NumIpAddresses * WLBS_MAX_CL_NET_MASK];
        if (rgIpAddresses == NULL ||  rgIpSubnets == NULL)
        {
            TRACE_CRIT("SetStaticIpAddresses: Alloc failure!");
            Status = WBEM_E_OUT_OF_MEMORY;
            goto end;
        }

        for (UINT u=0;u<NumIpAddresses; u++)
        {
            //
            // We extrace each IP address and it's corresponding subnet mask
            // from the 2 2D arrays and insert it into a NLB_IP_ADDRESS_INFO
            // structure.
            //
            LPWSTR pIpDest  = rgIpAddresses+u*WLBS_MAX_CL_IP_ADDR;
            LPWSTR pSubDest = rgIpSubnets+u*WLBS_MAX_CL_NET_MASK;
            LPCWSTR pIpSrc  = pIpInfo[u].IpAddress;
            LPCWSTR pSubSrc = pIpInfo[u].SubnetMask;
            UINT len = wcslen(pIpSrc);
            UINT len1 = wcslen(pSubSrc);
            if ( (len < WLBS_MAX_CL_IP_ADDR) && (len1 < WLBS_MAX_CL_NET_MASK))
            {
                CopyMemory(pIpDest, pIpSrc, (len+1)*sizeof(WCHAR));
                CopyMemory(pSubDest, pSubSrc, (len1+1)*sizeof(WCHAR));
            }
            else
            {
                //
                // This would be an implementation error in get_multi_string_...
                //
                ASSERT(FALSE);
                goto end;
            }
        }
    }

    //
    // Get input instance and relpath...
    //
    Status =  CfgUtilGetWmiInputInstanceAndRelPath(
                    g_CfgUtils.m_spWbemServiceIF,
                    L"Win32_NetworkAdapterConfiguration", // szClassName
                    L"SettingID",               // szPropertyName
                    szNic,                      // szPropertyValue
                    L"EnableStatic",            // szMethodName,
                    spWbemInputInstance,        // smart pointer
                    &pRelPath                   // free using delete 
                    );

    if (FAILED(Status))
    {
        goto end;
    }

    //
    // Set up input parameters to the call to Enable static.
    //
    {
    
        //
        // This gets the ip addresses in a 2D WCHAR array -- inner dimension
        // is WLBS_MAX_CLI_IP_ADDR.
        //
        Status =  set_multi_string_parameter(
                    spWbemInputInstance,
                    L"IPAddress", // szParameterName,
                    WLBS_MAX_CL_IP_ADDR, // MaxStringLen - in wchars, incl null
                    NumIpAddresses,
                    rgIpAddresses
                    );

        if (FAILED(Status))
        {
            goto end;
        }
        else
        {
            TRACE_INFO("SET %lu IP ADDRESSES!", NumIpAddresses);
        }

        Status =  set_multi_string_parameter(
                    spWbemInputInstance,
                    L"SubnetMask", // szParameterName,
                    WLBS_MAX_CL_NET_MASK, // MaxStringLen - in wchars, incl null
                    NumIpAddresses,
                    rgIpSubnets
                    );

        if (FAILED(Status))
        {
            goto end;
        }
    }


    //
    // execute method and get the output result
    // WARNING: we try this a few times because the wmi call apperears to
    // suffer from a recoverable error. TODO: Need to get to the bottom of
    // this.
    //
    UINT uiMaxTries = 10;
    for (UINT NumTries=uiMaxTries; NumTries--;)
    {
        HRESULT hr;
        IWbemClassObjectPtr      spWbemOutput = NULL; // smart pointer.
        _variant_t v_retVal;

        TRACE_CRIT("Going to call EnableStatic");

        hr = g_CfgUtils.m_spWbemServiceIF->ExecMethod(
                     _bstr_t(pRelPath),
                     L"EnableStatic",
                     0, 
                     NULL, 
                     spWbemInputInstance,
                     &spWbemOutput, 
                     NULL
                     );                          
        TRACE_CRIT("EnableStatic returns");
    
        if( FAILED( hr) )
        {
            TRACE_CRIT("%!FUNC! IWbemServices::ExecMethod failure 0x%08lx while invoking EnableStatic", (UINT) hr);
            goto end;
        }

        hr = spWbemOutput->Get(
                    L"ReturnValue",
                     0,
                     &v_retVal,
                     NULL,
                     NULL
                     );
        if( FAILED( hr) )
        {
            TRACE_CRIT("%!FUNC! IWbemClassObject::Get failure while checking status of EnableStatic call");
            goto end;
        }

        LONG lRet = (LONG) v_retVal;
        v_retVal.Clear();

        if (lRet == 0)
        {
            TRACE_INFO("%!FUNC! EnableStatic returns SUCCESS! after %d attempts", uiMaxTries-NumTries);
            Status = WBEM_NO_ERROR;
            break;
        }

        // We failed. Sleep and try again.
        Sleep(1000);

        // Failures seen while testing status:
        // 0x42 = Invalid subnet mask (can happen when removing IPs from adapter, if removing all of them)
        // 0x51 = Unable to configure DHCP service 
        // 0x54 = IP not enabled on adapter (happens while the adapter is processing the request to add an IP)
        // For other return codes, see http://index2. Search for EnableStatic in sdnt\admin\wmi\wbem\providers\mofs\win32_network.mof
        if (lRet == 0x42 || lRet == 0x51 || lRet == 0x54) // These appear to be a recoverable errors
        {
            TRACE_INFO(
                "%!FUNC! EnableStatic on NIC %ws returns recoverable FAILURE:0x%08lx! after %d attempts",
                szNic,
                lRet,
                uiMaxTries-NumTries
                );
            Status = WBEM_E_CRITICAL_ERROR;
        }
        else
        {
            TRACE_INFO(
                "%!FUNC! EnableStatic on NIC %ws returns FAILURE:0x%08lx! after %d attempts",
                szNic,
                lRet,
                uiMaxTries-NumTries
                );
            Status = WBEM_E_CRITICAL_ERROR;
        }
    }

    if (!FAILED(Status))
    {
        BOOL fMatch = FALSE;
        UINT uMatchAttemptsLeft = 5;

        do
        {
            fMatch = TRUE;

            //
            // Sometimes this function returns before the ip addresses actually
            // show up in IPCONFIG. So let's check.
            //
            WBEMSTATUS wStat2;
            UINT NumAddrs2=0;
            NLB_IP_ADDRESS_INFO *pIpInfo2 = NULL;
            wStat2  = CfgUtilGetIpAddressesAndFriendlyName(
                        szNic,
                        &NumAddrs2,
                        &pIpInfo2,
                        NULL // pszFriendlyName (unused)
                        );
            if (FAILED(wStat2))
            {
                //
                // We won't bother trying again.
                //
                break;
            }

            if (NumAddrs2 == 0)
            {
                pIpInfo2 = NULL;
            }
    
            //
            // Check for match
            //
            if (NumAddrs2 != NumIpAddresses)
            {
                fMatch = FALSE;
            }
            else
            {

                for (UINT u=0; u<NumAddrs2; u++)
                {
                    NLB_IP_ADDRESS_INFO *pInfoA=pIpInfo+u;
                    NLB_IP_ADDRESS_INFO *pInfoB=pIpInfo2+u;
                    if (   _wcsicmp(pInfoA->IpAddress, pInfoB->IpAddress)
                        || _wcsicmp(pInfoA->SubnetMask, pInfoB->SubnetMask))
                    {
                        fMatch = FALSE;
                        break;
                    }
                }
            }
    
            delete[] pIpInfo2;

            if (fMatch)
            {
                break;
            }

            if (uMatchAttemptsLeft)
            {
                uMatchAttemptsLeft--;
                Sleep(2000);
            }

        } while (uMatchAttemptsLeft);
    }

end:

    if (rgIpAddresses != NULL)
    {
        delete[]  rgIpAddresses;
    }
    if (rgIpSubnets   != NULL)
    {
        delete[]  rgIpSubnets;
    }

    if (pRelPath != NULL)
    {
        delete pRelPath;
    }

    spWbemInputInstance = NULL;

    TRACE_INFO(L"<- %!FUNC!(Nic=%ws) returns 0x%08lx", szNic, (UINT) Status);

    return Status;
}

//
// Sets the IP addresses for the NIC to be DHCP-assigned.
//
WBEMSTATUS
CfgUtilSetDHCP(
    IN  LPCWSTR szNic
    )
{
    WBEMSTATUS          Status = WBEM_E_CRITICAL_ERROR;
    IWbemClassObjectPtr      spWbemInputInstance = NULL; // smart pointer
    LPWSTR             pRelPath = NULL;

    TRACE_INFO(L"-> %!FUNC!(Nic=%ws)", szNic);

    //
    // If not initialized, fail...
    //
    if (!g_CfgUtils.IsInitalized())
    {
        TRACE_CRIT(L"%!FUNC!(Nic=%ws) FAILING because uninitialized", szNic);
        Status =  WBEM_E_INITIALIZATION_FAILURE;
        goto end;
    }


    //
    // Get input instance and relpath...
    //
    Status =  CfgUtilGetWmiInputInstanceAndRelPath(
                    g_CfgUtils.m_spWbemServiceIF,
                    L"Win32_NetworkAdapterConfiguration", // szClassName
                    L"SettingID",               // szPropertyName
                    szNic,                      // szPropertyValue
                    L"EnableDHCP",              // szMethodName,
                    spWbemInputInstance,        // smart pointer
                    &pRelPath                   // free using delete 
                    );

    if (FAILED(Status))
    {
        goto end;
    }

    //
    // No input params to setup.
    //


    //
    // execute method and get the output result
    // WARNING: we try this a few times because the wmi call apperears to
    // suffer from a recoverable error. TODO: Need to get to the bottom of
    // this.
    //
    UINT uiMaxTries = 10;
    for (UINT NumTries=uiMaxTries; NumTries--;)
    {
        HRESULT hr;
        IWbemClassObjectPtr      spWbemOutput = NULL; // smart pointer.
        _variant_t v_retVal;

        TRACE_CRIT("Going to call EnableDHCP");

        hr = g_CfgUtils.m_spWbemServiceIF->ExecMethod(
                     _bstr_t(pRelPath),
                     L"EnableDHCP",
                     0, 
                     NULL, 
                     spWbemInputInstance,
                     &spWbemOutput, 
                     NULL
                     );                          
        TRACE_CRIT("EnableDHCP returns");
    
        if( FAILED( hr) )
        {
            TRACE_CRIT("%!FUNC! IWbemServices::ExecMethod failure 0x%08lx while invoking EnableDHCP", (UINT) hr);
            goto end;
        }

        hr = spWbemOutput->Get(
                    L"ReturnValue",
                     0,
                     &v_retVal,
                     NULL,
                     NULL
                     );
        if( FAILED( hr) )
        {
            TRACE_CRIT("%!FUNC! IWbemClassObject::Get failure while checking status of EnableDHCP call");
            goto end;
        }

        LONG lRet = (LONG) v_retVal;
        v_retVal.Clear();

        if (lRet == 0)
        {
            TRACE_INFO("%!FUNC! EnableDHCP returns SUCCESS! after %d attempts", uiMaxTries-NumTries);
            Status = WBEM_NO_ERROR;
            break;
        }

        // We failed. Sleep and try again.
        Sleep(1000);

        // Failures seen while testing status:
        // 0x42 = Invalid subnet mask (can happen when removing IPs from adapter, if removing all of them)
        // 0x51 = Unable to configure DHCP service 
        // 0x54 = IP not enabled on adapter (happens while the adapter is processing the request to add an IP)
        // For other return codes, see http://index2. Search for EnableStatic in sdnt\admin\wmi\wbem\providers\mofs\win32_network.mof
        if (lRet == 0x42 || lRet == 0x51 || lRet == 0x54) // These appear to be a recoverable errors
        {
            TRACE_INFO(
                "%!FUNC! EnableDHCP on NIC %ws returns recoverable FAILURE:0x%08lx! after %d attempts",
                szNic,
                lRet,
                uiMaxTries-NumTries
                );
            Status = WBEM_E_CRITICAL_ERROR;
        }
        else
        {
            TRACE_INFO(
                "%!FUNC! EnableDHCP on NIC %ws returns FAILURE:0x%08lx! after %d attempts",
                szNic,
                lRet,
                uiMaxTries-NumTries
                );
            Status = WBEM_E_CRITICAL_ERROR;
        }
    }

end:

    spWbemInputInstance = NULL;

    TRACE_INFO(L"<- %!FUNC!(Nic=%ws) returns 0x%08lx", szNic, (UINT) Status);

    return Status;
}


//
// Determines whether the specified nic is configured with DHCP or not.
//
WBEMSTATUS
CfgUtilGetDHCP(
    IN  LPCWSTR szNic,
    OUT BOOL    *pfDHCP
    )
{
    WBEMSTATUS          Status  = WBEM_NO_ERROR;
    IWbemClassObjectPtr spObj   = NULL;  // smart pointer
    HRESULT             hr;

    TRACE_INFO(L"-> %!FUNC!(Nic=%ws)", szNic);

    *pfDHCP = FALSE;

    //
    // If not initialized, fail...
    //
    if (!g_CfgUtils.IsInitalized())
    {
        TRACE_CRIT(L"%!FUNC!(Nic=%ws) FAILING because uninitialized", szNic);
        Status =  WBEM_E_INITIALIZATION_FAILURE;
        goto end;
    }

    //
    // Get WMI instance to specific NIC
    //
    Status = get_nic_instance(
                g_CfgUtils.m_spWbemServiceIF,
                szNic,
                spObj // pass by reference
                );
    if (FAILED(Status))
    {
        ASSERT(spObj == NULL);
        goto end;
    }

    //
    // Extract IP addresses and subnets.
    //
    Status = CfgUtilGetWmiBoolParam(
                    spObj,
                    L"DHCPEnabled", // szParameterName,
                    pfDHCP
                    );

    if (Status == WBEM_E_NOT_FOUND)
    {
        //
        // We treat not-found as no-dhcp -- this is what we see in practise.
        //
        *pfDHCP = FALSE;
        Status = WBEM_NO_ERROR;
    }
end:

    spObj   = NULL;  // smart pointer

    TRACE_INFO(L"<- %!FUNC!(Nic=%ws) returns 0x%08lx (fDHCP=%lu)",
         szNic, (UINT) Status, *pfDHCP);



    return Status;
}


WBEMSTATUS
CfgUtilGetNetcfgWriteLockState(
    OUT BOOL *pfCanLock,
    LPWSTR   *pszHeldBy // OPTIONAL, free using delete[].
    )
{
    WBEMSTATUS Status;

    Status  = MyNetCfg::GetWriteLockState(pfCanLock, pszHeldBy);

    return Status;
}

//
// Determines whether NLB is bound to the specified NIC.
//
WBEMSTATUS
CfgUtilCheckIfNlbBound(
    IN  LPCWSTR szNic,
    OUT BOOL *pfBound
    )
{
    WBEMSTATUS Status = WBEM_NO_ERROR;
    BOOL fNetCfgInitialized = FALSE;
    MyNetCfg NetCfg;
    BOOL fBound = FALSE;


    //
    // Get and initialize interface to netcfg
    //
    Status = NetCfg.Initialize(FALSE); // FALSE == don't get write lock.
    if (FAILED(Status))
    {
        goto end;
    }
    fNetCfgInitialized = TRUE;

    //
    //
    //
    Status =  NetCfg.UpdateBindingState(
                            szNic,
                            L"ms_wlbs",
                            MyNetCfg::NOOP,
                            &fBound
                            );

end:

    if (fNetCfgInitialized)
    {
        NetCfg.Deinitialize();
    }

    *pfBound = fBound;

    return Status;
}


//
// Binds/unbinds NLB to the specified NIC.
//
WBEMSTATUS
CfgUtilChangeNlbBindState(
    IN  LPCWSTR szNic,
    IN  BOOL fBind
    )
{
    WBEMSTATUS Status = WBEM_NO_ERROR;
    BOOL fNetCfgInitialized = FALSE;
    MyNetCfg NetCfg;
    BOOL fBound = FALSE;


    //
    // Get and initialize interface to netcfg
    //
    Status = NetCfg.Initialize(TRUE); // TRUE == get write lock.
    if (FAILED(Status))
    {
        goto end;
    }
    fNetCfgInitialized = TRUE;

    //
    //
    //
    Status =  NetCfg.UpdateBindingState(
                            szNic,
                            L"ms_wlbs",
                            fBind ? MyNetCfg::BIND : MyNetCfg::UNBIND,
                            &fBound
                            );

end:

    if (fNetCfgInitialized)
    {
        NetCfg.Deinitialize();
    }

    return Status;
}



//
// Gets the current NLB configuration for the specified NIC
//
WBEMSTATUS
CfgUtilGetNlbConfig(
    IN  LPCWSTR szNic,
    OUT WLBS_REG_PARAMS *pParams
    )
{
    GUID Guid;
    WBEMSTATUS Status = WBEM_NO_ERROR;


    // Verify that the NLB API hooks are present
    if (!g_CfgUtils.m_NLBApiHooksPresent)
    {
        TRACE_CRIT(L"%!FUNC! FAILING because NLB API hooks are not present");
        Status =  WBEM_E_INITIALIZATION_FAILURE;
        goto end;
    }

    HRESULT hr = CLSIDFromString((LPWSTR)szNic, &Guid);
    if (FAILED(hr))
    {
        Status = WBEM_E_INVALID_PARAMETER;
        goto end;
    }

    //
    // Read the configuration.
    //
    BOOL fRet = g_CfgUtils.m_pfWlbsParamReadReg(&Guid, pParams);

    if (!fRet)
    {
        TRACE_CRIT("Could not read NLB configuration for %wsz", szNic);
        Status = WBEM_E_CRITICAL_ERROR;
        goto end;
    }

    Status = WBEM_NO_ERROR;

end:

    // g_CfgUtils.mfn_Unlock();

    return Status;
}

//
// Sets the current NLB configuration for the specified NIC. This
// includes notifying the driver if required.
//
WBEMSTATUS
CfgUtilSetNlbConfig(
    IN  LPCWSTR szNic,
    IN  WLBS_REG_PARAMS *pParams,
    IN  BOOL fJustBound
    )
{
    GUID Guid;
    WBEMSTATUS Status = WBEM_NO_ERROR;
    DWORD dwRet = 0;
    WLBS_REG_PARAMS ParamsCopy;
    
    if (fJustBound)
    {
        // We need to set the install_date value to the current time.
        // This field is used in the heartbeats to distinguish two
        // hosts.
        // This is bug 480120 nlb:cluster converged when duplicate host ID exist
        // (see also wlbscfg.dll (netcfgconfig.cpp:
        //     CNetcfgCluster::InitializeWithDefault)
        time_t cur_time;
        ParamsCopy = *pParams; // Struct copy.
        ParamsCopy.install_date = time(& cur_time);
        pParams = &ParamsCopy;
    }


    // Verify that the NLB API hooks are present
    if (!g_CfgUtils.m_NLBApiHooksPresent)
    {
        TRACE_CRIT(L"%!FUNC! FAILING because NLB API hooks are not present");
        Status =  WBEM_E_INITIALIZATION_FAILURE;
        goto end;
    }

    HRESULT hr = CLSIDFromString((LPWSTR)szNic, &Guid);
    if (FAILED(hr))
    {
        Status = WBEM_E_INVALID_PARAMETER;
        goto end;
    }

    HANDLE  Nlb_driver_hdl;

    // Get handle to NLB driver
    if ((Nlb_driver_hdl = g_CfgUtils.m_pfWlbsOpen()) == INVALID_HANDLE_VALUE)
    {
        TRACE_CRIT("%!FUNC! WlbsOpen returned NULL, Could not create connection to NLB driver");
        Status = WBEM_E_CRITICAL_ERROR;
        goto end;
    }
        
    //
    // Write the configuration.
    //
    dwRet = g_CfgUtils.m_pfWlbsWriteAndCommitChanges(Nlb_driver_hdl, &Guid, pParams);

    if (dwRet != WLBS_OK)
    {
        TRACE_CRIT("Could not write NLB configuration for %wsz. Err=0x%08lx",
             szNic, dwRet);
        Status = WBEM_E_CRITICAL_ERROR;
    }
    else
    {

        Status = WBEM_NO_ERROR;
    }

    // Close handle to NLB driver
    CloseHandle(Nlb_driver_hdl);


end:

    return Status;
}


WBEMSTATUS
CfgUtilRegWriteParams(
    IN  LPCWSTR szNic,
    IN  WLBS_REG_PARAMS *pParams
    )
//
// Just writes the current NLB configuration for the specified NIC to the
// registry. MAY BE CALLED WHEN NLB IS UNBOUND.
//
{
    GUID Guid;
    WLBS_REG_PARAMS TmpParams = *pParams;
    WBEMSTATUS Status = WBEM_NO_ERROR;
    DWORD dwRet = 0;

    TRACE_INFO(L"->");
    
    // Verify that the NLB API hooks are present
    if (!g_CfgUtils.m_NLBApiHooksPresent)
    {
        TRACE_CRIT(L"FAILING because NLB API hooks are not present");
        Status =  WBEM_E_INITIALIZATION_FAILURE;
        goto end;
    }

    HRESULT hr = CLSIDFromString((LPWSTR)szNic, &Guid);
    if (FAILED(hr))
    {
        Status = WBEM_E_INVALID_PARAMETER;
        goto end;
    }

    //
    // Write the configuration.
    //
    dwRet = g_CfgUtils.m_pfWlbsParamWriteReg(Guid, &TmpParams);


    if (dwRet != WLBS_OK)
    {
        TRACE_CRIT("Could not write NLB configuration for %wsz. Err=0x%08lx",
             szNic, dwRet);
        Status = WBEM_E_CRITICAL_ERROR;
    }
    else
    {
        Status = WBEM_NO_ERROR;
    }


end:

    TRACE_INFO(L"<- returns %lx", Status);
    return Status;
}



WBEMSTATUS
CfgUtilsAnalyzeNlbUpdate(
    IN  const WLBS_REG_PARAMS *pCurrentParams, OPTIONAL
    IN  WLBS_REG_PARAMS *pNewParams,
    OUT BOOL *pfConnectivityChange
    )
{
    WBEMSTATUS Status = WBEM_E_CRITICAL_ERROR;
    BOOL fConnectivityChange = FALSE;


    //
    // If not initialized, fail...
    //
    if (!g_CfgUtils.IsInitalized())
    {
        TRACE_CRIT(L"%!FUNC! FAILING because uninitialized");
        Status =  WBEM_E_INITIALIZATION_FAILURE;
        goto end;
    }

    if (pCurrentParams != NULL)
    {
        //
        // If the structures have identical content, we return S_FALSE.
        // We do this check before we call ValidateParm below, because
        // ValidateParam has the side effect of filling out / modifying
        // certain fields.
        //
        if (memcmp(pCurrentParams, pNewParams, sizeof(*pCurrentParams))==0)
        {
            Status = WBEM_S_FALSE;
            goto end;
        }
    }

    //
    // Validate pNewParams -- this may also modify pNewParams slightly, by
    // re-formatting ip addresses into canonical format.
    //
    // Verify that the NLB API hooks are present
    BOOL fRet = FALSE;

    if (!g_CfgUtils.m_NLBApiHooksPresent)
    {
        fRet = MyWlbsValidateParams(pNewParams);
    }
    else
    {
        fRet = g_CfgUtils.m_pfWlbsValidateParams(pNewParams);
    }

    if (!fRet)
    {
        TRACE_CRIT(L"%!FUNC!FAILING because New params are invalid");
        Status = WBEM_E_INVALID_PARAMETER;
        goto end;
    }

    Status = WBEM_NO_ERROR;

    if (pCurrentParams == NULL)
    {
        //
        // NLB was not previously bound.
        //
        fConnectivityChange = TRUE;
        goto end;
    }

    //
    // Change in multicast modes or mac address.
    //
    if (    (pCurrentParams->mcast_support != pNewParams->mcast_support)
         || _wcsicmp(pCurrentParams->cl_mac_addr, pNewParams->cl_mac_addr)!=0)
    {
        fConnectivityChange = TRUE;
    }

    //
    // Change in primary cluster ip or subnet mask
    //
    if (   _wcsicmp(pCurrentParams->cl_ip_addr,pNewParams->cl_ip_addr)!=0
        || _wcsicmp(pCurrentParams->cl_net_mask,pNewParams->cl_net_mask)!=0)
    {
        fConnectivityChange = TRUE;
    }


end:
    *pfConnectivityChange = fConnectivityChange;
    return Status;
}


WBEMSTATUS
CfgUtilsValidateNicGuid(
    IN LPCWSTR szGuid
    )
//
//
{
    //
    // Sample GUID: {EBE09517-07B4-4E88-AAF1-E06F5540608B}
    //
    WBEMSTATUS Status = WBEM_E_INVALID_PARAMETER;
    UINT Length = wcslen(szGuid);

    #define MY_NLB_GUID_LEN 38
    if (Length != MY_NLB_GUID_LEN)
    {
        TRACE_CRIT("Length != %d", MY_NLB_GUID_LEN);
        goto end;
    }

    //
    // Open tcpip's registry key and look for guid there -- if not found,
    // we'll return WBEM_E_NOT_FOUND
    //
    {
        WCHAR szKey[128]; // This is enough for the tcpip+guid key
    
        ARRAYSTRCPY(szKey, L"SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces\\" );
        ARRAYSTRCAT(szKey, szGuid);
        HKEY hKey = NULL;
        LONG lRet;
        lRet = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE, // handle to an open key
                szKey,              // address of subkey name
                0,                  // reserved
                KEY_QUERY_VALUE,    // desired security access
                &hKey              // address of buffer for opened handle
                );
        if (lRet != ERROR_SUCCESS)
        {
            TRACE_CRIT("Guid %ws doesn't exist under tcpip", szGuid);
            Status = WBEM_E_NOT_FOUND;
            goto end;
        }
        RegCloseKey(hKey);
    }

    Status = WBEM_NO_ERROR;

end:

    return Status;
}


#if OBSOLETE
WBEMSTATUS
get_string_parameter(
    IN  IWbemClassObjectPtr      spObj,
    IN  LPCWSTR szParameterName,
    OUT LPWSTR *ppStringValue
    )
{
    WBEMSTATUS Status = WBEM_E_NOT_FOUND;
    WCHAR *pStringValue = NULL;
    _variant_t   v_value;
    CIMTYPE      v_type;
    HRESULT hr;

    hr = spObj->Get(
            _bstr_t(szParameterName), // Name
            0,                     // Reserved, must be 0     
            &v_value,               // Place to store value
            &v_type,                // Type of value
            NULL                   // Flavor (unused)
            );
   if (FAILED(hr))
   {
        // Couldn't read the Setting ID field!
        //
        TRACE_CRIT(
            "get_str_parm:Couldn't retrieve %ws from 0x%p",
            szParameterName,
            (PVOID) spObj
            );
        goto end;
   }
   else
   {
       if (v_type != VT_BSTR)
       {
            TRACE_CRIT(
                "get_str_parm: Parm value not of string type %ws from 0x%p",
                szParameterName,
                (PVOID) spObj
                );
            Status = WBEM_E_INVALID_PARAMETER;
       }
       else
       {

           _bstr_t bstrNicGuid(v_value);
           LPCWSTR sz = bstrNicGuid; // Pointer to internal buffer.

           if (sz==NULL)
           {
                // hmm.. null value 
                Status = WBEM_NO_ERROR;
           }
           else
           {
               UINT len = wcslen(sz);
               pStringValue = new WCHAR[len+1];
               if (pStringValue == NULL)
               {
                    TRACE_CRIT("get_str_parm: Alloc failure!");
                    Status = WBEM_E_OUT_OF_MEMORY;
               }
               else
               {
                    CopyMemory(pStringValue, sz, (len+1)*sizeof(WCHAR));
                    Status = WBEM_NO_ERROR;
               }
            }

            TRACE_VERB(
                "get_str_parm: String parm %ws of 0x%p is %ws",
                szParameterName,
                (PVOID) spObj,
                (sz==NULL) ? L"<null>" : sz
                );
       }

       v_value.Clear(); // Must be cleared after each call to Get.
    }

end:
    
    *ppStringValue = pStringValue;

    return Status;

}
#endif // OBSOLETE


WBEMSTATUS
get_nic_instance(
    IN  IWbemServicesPtr    spWbemServiceIF,
    IN  LPCWSTR             szNicGuid,
    OUT IWbemClassObjectPtr &sprefObj
    )
{
    WBEMSTATUS Status = WBEM_E_NOT_FOUND;
    IWbemClassObjectPtr spObj = NULL; // smart pointer.

    Status = CfgUtilGetWmiObjectInstance(
                    spWbemServiceIF,
                    L"Win32_NetworkAdapterConfiguration", // szClassName
                    L"SettingID", // szParameterName
                    szNicGuid,    // ParameterValue
                    spObj // smart pointer, passed by ref
                    );
    if (FAILED(Status))
    {
        ASSERT(spObj == NULL);
        goto end;
    }

end:

    if (FAILED(Status))
    {
        sprefObj = NULL;
    }
    else
    {
        sprefObj = spObj; // smart pointer.
    }


    return Status;
}


WBEMSTATUS
get_multi_string_parameter(
    IN  IWbemClassObjectPtr      spObj,
    IN  LPCWSTR szParameterName,
    IN  UINT    MaxStringLen,  // in wchars, INCLUDING space for trailing zeros.
    OUT UINT    *pNumItems,
    OUT LPCWSTR *ppStringValue
    )
{
    WBEMSTATUS Status = WBEM_E_NOT_FOUND;
    WCHAR *pStringValue = NULL;
    _variant_t   v_value;
    CIMTYPE      v_type;
    HRESULT hr;
    LONG count = 0;

    *ppStringValue = NULL;
    *pNumItems = 0;

    hr = spObj->Get(
            _bstr_t(szParameterName),
            0,                     // Reserved, must be 0     
            &v_value,               // Place to store value
            &v_type,                // Type of value
            NULL                   // Flavor (unused)
            );
    if (FAILED(hr))
    {
        // Couldn't read the requested parameter.
        //
        TRACE_CRIT(
            "get_multi_str_parm:Couldn't retrieve %ws from 0x%p",
            szParameterName,
            (PVOID) spObj
            );
        goto end;
    }


    {
        VARIANT    ipsV = v_value.Detach();

        do // while false
        {
            BSTR* pbstr;
    
            if (ipsV.vt == VT_NULL)
            {
                //
                // NULL string -- this is ok
                //
                count = 0;
            }
            else
            {
                count = ipsV.parray->rgsabound[0].cElements;
            }

            if (count==0)
            {
                Status = WBEM_NO_ERROR;
                break;
            }
    
            pStringValue = new WCHAR[count*MaxStringLen];
    
            if (pStringValue == NULL)
            {
                TRACE_CRIT("get_multi_str_parm: Alloc failure!");
                Status = WBEM_E_OUT_OF_MEMORY;
                break;
            }
            ZeroMemory(pStringValue, sizeof(WCHAR)*count*MaxStringLen);
    
            hr = SafeArrayAccessData(ipsV.parray, ( void **) &pbstr);
            if(FAILED(hr))
            {
                Status = WBEM_E_INVALID_PARAMETER; // TODO: pick better error
                break;
            }
    
            Status = WBEM_NO_ERROR;
            for( LONG x = 0; x < count; x++ )
            {
               LPCWSTR sz = pbstr[x]; // Pointer to internal buffer.
                
               if (sz==NULL)
               {
                    // hmm.. null value 
                    continue;
               }
               else
               {
                   UINT len = wcslen(sz);
                   if ((len+1) > MaxStringLen)
                   {
                        TRACE_CRIT("get_str_parm: string size too long!");
                        Status = WBEM_E_INVALID_PARAMETER;
                        break;
                   }
                   else
                   {
                        WCHAR *pDest = pStringValue+x*MaxStringLen;
                        CopyMemory(pDest, sz, (len+1)*sizeof(WCHAR));
                   }
                }
            }
    
            (VOID) SafeArrayUnaccessData( ipsV.parray );
    
        } while (FALSE);

        VariantClear( &ipsV );
    }

    if (FAILED(Status))
    {
        if (pStringValue!=NULL)
        {
            delete[] pStringValue;
            *pStringValue = NULL;
        }
    }
    else
    {
        *ppStringValue = pStringValue;
        *pNumItems = count;
    }


end:

   return Status;
}

    
//
// Static method to return the state of the lock;
//
WBEMSTATUS
MyNetCfg::GetWriteLockState(
    OUT BOOL *pfCanLock,
    LPWSTR   *pszHeldBy // OPTIONAL, free using delete[].
    )
{
    HRESULT     hr;
    INetCfg     *pnc = NULL;
    INetCfgLock *pncl = NULL;
    WBEMSTATUS  Status = WBEM_E_CRITICAL_ERROR;
    BOOL        fCanLock = FALSE;
    WCHAR       *szLockedBy = NULL;
    
    *pfCanLock = FALSE;
    if (pszHeldBy!=NULL)
    {
        *pszHeldBy = NULL;
    }

    hr = CoCreateInstance( CLSID_CNetCfg, 
                           NULL, 
                           CLSCTX_SERVER, 
                           IID_INetCfg, 
                           (void **) &pnc);

    if( !SUCCEEDED( hr ) )
    {
        // failure to create instance.
        TRACE_CRIT("ERROR: could not get interface to Net Config");
        pnc = NULL;
        goto end;
    }

    hr = pnc->QueryInterface( IID_INetCfgLock, ( void **) &pncl );
    if( !SUCCEEDED( hr ) )
    {
        TRACE_CRIT("ERROR: could not get interface to NetCfg Lock");
        pncl = NULL;
        goto end;
    }

    hr = pncl->AcquireWriteLock(100, NLB_CLIENT_NAME, &szLockedBy);
    if(hr == S_FALSE)
    {
        TRACE_INFO("Write lock held by %ws",
        (szLockedBy!=NULL) ? szLockedBy : L"<null>");
        if (pszHeldBy!=NULL && szLockedBy != NULL)
        {
            LPWSTR szTmp = NULL;
            UINT uLen = wcslen(szLockedBy);
            szTmp = new WCHAR[uLen+1];
            if (szTmp != NULL)
            {
                CopyMemory(szTmp, szLockedBy, (uLen+1)*sizeof(*szTmp));
            }
            *pszHeldBy = szTmp;
        }
        fCanLock = FALSE;
        Status = WBEM_NO_ERROR;
    }
    else if (hr == S_OK)
    {
        //
        // We could get the lock, let's release it.
        //
        (void) pncl->ReleaseWriteLock();
        fCanLock = TRUE;
        Status = WBEM_NO_ERROR;
    }
    else
    {
        TRACE_INFO("AcquireWriteLock failed with error 0x%08lx", (UINT) hr);
        fCanLock = FALSE;
        Status = WBEM_NO_ERROR;
    }
    CoTaskMemFree(szLockedBy); // szLockedBy can be NULL;

    *pfCanLock = fCanLock;

end:

    if (pncl!=NULL)
    {
        pncl->Release();
        pncl=NULL;
    }

    if (pnc != NULL)
    {
        pnc->Release();
        pnc= NULL;
    }

    return Status;
}


WBEMSTATUS
MyNetCfg::Initialize(
    BOOL fWriteLock
    )
{
    // 2/13/02 JosephJ SECURITY BUGBUG: verify that IF this call is made from a non-admin that we fail.
    //
    HRESULT     hr;
    INetCfg     *pnc = NULL;
    INetCfgLock *pncl = NULL;
    WBEMSTATUS  Status = WBEM_E_CRITICAL_ERROR;
    BOOL        fLocked = FALSE;
    BOOL        fInitialized=FALSE;
    
    if (m_pINetCfg != NULL || m_pLock != NULL)
    {
        ASSERT(FALSE);
        goto end;
    }

    //
    // 2/13/02 JosephJ SECURITY BUGBUG: CLSCTX_SERVER -- should we be specifying something more restrictive here?
    //                  Also: can some other COM object hijack this GUID?
    //
    hr = CoCreateInstance( CLSID_CNetCfg, 
                           NULL, 
                           CLSCTX_SERVER, 
                           IID_INetCfg, 
                           (void **) &pnc);

    if( !SUCCEEDED( hr ) )
    {
        // failure to create instance.
        TRACE_CRIT("ERROR: could not get interface to Net Config");
        pnc = NULL;
        goto end;
    }

    //
    // If require, get the write lock
    //
    if (fWriteLock)
    {
        WCHAR *szLockedBy = NULL;
        hr = pnc->QueryInterface( IID_INetCfgLock, ( void **) &pncl );
        if( !SUCCEEDED( hr ) )
        {
            TRACE_CRIT("ERROR: could not get interface to NetCfg Lock");
            pncl = NULL;
            goto end;
        }

        hr = pncl->AcquireWriteLock( 1, // One Second
                                     NLB_CLIENT_NAME,
                                     &szLockedBy);
        if( hr != S_OK )
        {
            TRACE_CRIT("Could not get write lock. Lock held by %ws",
            (szLockedBy!=NULL) ? szLockedBy : L"<null>");
            goto end;
            
        }
        CoTaskMemFree(szLockedBy); // szLockedBy can be NULL;
        fLocked = TRUE;
    }

    // Initializes network configuration by loading into 
    // memory all basic networking information
    //
    hr = pnc->Initialize( NULL );
    if( !SUCCEEDED( hr ) )
    {
        // failure to Initialize
        TRACE_CRIT("INetCfg::Initialize failure ");
        goto end;
    }
    fInitialized = TRUE;

    Status = WBEM_NO_ERROR; 
    
end:

    if (FAILED(Status))
    {
        if (pncl!=NULL)
        {
            if (fLocked)
            {
                pncl->ReleaseWriteLock();
            }
            pncl->Release();
            pncl=NULL;
        }
        if( pnc != NULL)
        {
            if (fInitialized)
            {
                pnc->Uninitialize();
            }
            pnc->Release();
            pnc= NULL;
        }
    }
    else
    {
        m_pINetCfg  = pnc;
        m_pLock     = pncl;
    }

    return Status;
}


VOID
MyNetCfg::Deinitialize(
    VOID
    )
{
    if (m_pLock!=NULL)
    {
        m_pLock->ReleaseWriteLock();
        m_pLock->Release();
        m_pLock=NULL;
    }
    if( m_pINetCfg != NULL)
    {
        m_pINetCfg->Uninitialize();
        m_pINetCfg->Release();
        m_pINetCfg= NULL;
    }
}


WBEMSTATUS
MyNetCfg::GetNicIF(
        IN  LPCWSTR szNicGuid,
        OUT INetCfgComponent **ppINic
        )
{
    WBEMSTATUS  Status = WBEM_E_CRITICAL_ERROR;
    INetCfgComponent *pncc = NULL;
    HRESULT hr;
    IEnumNetCfgComponent* pencc = NULL;
    ULONG                 countToFetch = 1;
    ULONG                 countFetched;
    DWORD                 characteristics;


    if (m_pINetCfg == NULL)
    {
        //
        // This means we're not initialized
        //
        ASSERT(FALSE);
        goto end;
    }

    hr = m_pINetCfg->EnumComponents( &GUID_DEVCLASS_NET, &pencc );
    if( !SUCCEEDED( hr ) )
    {
        // failure to Enumerate net components
        TRACE_CRIT("Could not enum netcfg adapters");
        pencc = NULL;
        goto end;
    }

    while( ( hr = pencc->Next( countToFetch, &pncc, &countFetched ) )== S_OK )
    {
        LPWSTR                szName = NULL; 

        hr = pncc->GetBindName( &szName );
        if (!SUCCEEDED(hr))
        {
            TRACE_CRIT("WARNING: couldn't get bind name for 0x%p, ignoring",
                    (PVOID) pncc);
            continue;
        }
        if(!_wcsicmp(szName, szNicGuid))
        {
            //
            // Got this one!
            //
            CoTaskMemFree( szName );
            break;
        }
        CoTaskMemFree( szName );
        pncc->Release();
        pncc=NULL;
    }

    if (pncc == NULL)
    {
        TRACE_CRIT("Could not find NIC %ws", szNicGuid);
        Status = WBEM_E_NOT_FOUND;
    }
    else
    {
        Status = WBEM_NO_ERROR;
    }

end:

    if (pencc != NULL)
    {
        pencc->Release();
    }

    *ppINic = pncc;

    return Status;
}


LPWSTR *
CfgUtilsAllocateStringArray(
    UINT NumStrings,
    UINT MaxStringLen      //  excluding ending NULL
    )
/*
    Allocate a single chunk of memory using the new LPWSTR[] operator.
    The first NumStrings LPWSTR values of this operator contain an array
    of pointers to WCHAR strings. Each of these strings
    is of size (MaxStringLen+1) WCHARS.
    The rest of the memory contains the strings themselve.

    Return NULL if NumStrings==0 or on allocation failure.

    Each of the strings are initialized to be empty strings (first char is 0).
*/
{
    LPWSTR *pStrings = NULL;
    UINT   TotalSize = 0;

    if (NumStrings == 0)
    {
        goto end;
    }

    //
    // Note - even if MaxStringLen is 0 we will allocate space for NumStrings
    // pointers and NumStrings empty (first char is 0) strings.
    //

    //
    // Calculate space for the array of pointers to strings...
    //
    TotalSize = NumStrings*sizeof(LPWSTR);

    //
    // Calculate space for the strings themselves...
    // Remember to add +1 for each ending 0 character.
    //
    TotalSize +=  NumStrings*(MaxStringLen+1)*sizeof(WCHAR);

    //
    // Allocate space for *both* the array of pointers and the strings
    // in one shot -- we're doing a new of type LPWSTR[] for the whole
    // lot, so need to specify the size in units of LPWSTR (with an
    // additional +1 in case there's roundoff.
    //
    pStrings = new LPWSTR[(TotalSize/sizeof(LPWSTR))+1];
    if (pStrings == NULL)
    {
        goto end;
    }

    //
    // Make sz point to the start of the place where we'll be placing
    // the string data.
    //
    LPWSTR sz = (LPWSTR) (pStrings+NumStrings);
    for (UINT u=0; u<NumStrings; u++)
    {
        *sz=NULL;
        pStrings[u] = sz;
        sz+=(MaxStringLen+1); // +1 for ending NULL
    }

end:

    return pStrings;

}



WBEMSTATUS
MyNetCfg::GetNlbCompatibleNics(
        OUT LPWSTR **ppszNics,
        OUT UINT   *pNumNics,
        OUT UINT   *pNumBoundToNlb // OPTIONAL
        )
/*
    Returns an array of pointers to string-version of GUIDS
    that represent the set of alive and healthy NICS that are
    suitable for NLB to bind to -- basically alive ethernet NICs.

    Delete ppNics using the delete WCHAR[] operator. Do not
    delete the individual strings.
*/
{
    #define MY_GUID_LENGTH  38

    WBEMSTATUS  Status = WBEM_E_CRITICAL_ERROR;
    HRESULT hr;
    IEnumNetCfgComponent* pencc = NULL;
    INetCfgComponent *pncc = NULL;
    ULONG                 countToFetch = 1;
    ULONG                 countFetched;
    UINT                  NumNics = 0;
    LPWSTR               *pszNics = NULL;
    INetCfgComponentBindings    *pINlbBinding=NULL;
    UINT                  NumNlbBoundNics = 0;

    typedef struct _MYNICNODE MYNICNODE;

    typedef struct _MYNICNODE
    {
        LPWSTR szNicGuid;
        MYNICNODE *pNext;
    } MYNICNODE;

    MYNICNODE *pNicNodeList = NULL;
    MYNICNODE *pNicNode     = NULL;


    *ppszNics = NULL;
    *pNumNics = 0;

    if (pNumBoundToNlb != NULL)
    {
        *pNumBoundToNlb  = 0;
    }

    if (m_pINetCfg == NULL)
    {
        //
        // This means we're not initialized
        //
        ASSERT(FALSE);
        goto end;
    }

    hr = m_pINetCfg->EnumComponents( &GUID_DEVCLASS_NET, &pencc );
    if( !SUCCEEDED( hr ) )
    {
        // failure to Enumerate net components
        TRACE_CRIT("%!FUNC! Could not enum netcfg adapters");
        pencc = NULL;
        goto end;
    }


    //
    // Check if nlb is bound to the nlb component.
    //

    //
    // If we need to count of NLB-bound nics, get instance of the nlb component
    //
    if (pNumBoundToNlb != NULL)
    {
        Status = GetBindingIF(L"ms_wlbs", &pINlbBinding);
        if (FAILED(Status))
        {
            TRACE_CRIT("%!FUNC! WARNING: NLB doesn't appear to be installed on this machine");
            pINlbBinding = NULL;
        }
    }

    while( ( hr = pencc->Next( countToFetch, &pncc, &countFetched ) )== S_OK )
    {
        LPWSTR                szName = NULL; 

        hr = pncc->GetBindName( &szName );
        if (!SUCCEEDED(hr))
        {
            TRACE_CRIT("%!FUNC! WARNING: couldn't get bind name for 0x%p, ignoring",
                    (PVOID) pncc);
            continue;
        }

        do // while FALSE -- just to allow breaking out
        {


            UINT Len = wcslen(szName);
            if (Len != MY_GUID_LENGTH)
            {
                TRACE_CRIT("%!FUNC! WARNING: GUID %ws has unexpected length %ul",
                        szName, Len);
                break;
            }
    
            DWORD characteristics = 0;
    
            hr = pncc->GetCharacteristics( &characteristics );
            if(!SUCCEEDED(hr))
            {
                TRACE_CRIT("%!FUNC! WARNING: couldn't get characteristics for %ws, ignoring",
                        szName);
                break;
            }
    
            if (((characteristics & NCF_PHYSICAL) || (characteristics & NCF_VIRTUAL)) && !(characteristics & NCF_HIDDEN))
            {
                ULONG devstat = 0;
    
                // This is a physical or virtual miniport that is NOT hidden. These
                // are the same adapters that show up in the "Network Connections"
                // dialog.  Hidden devices include WAN miniports, RAS miniports and 
                // NLB miniports - all of which should be excluded here.
    
                // check if the nic is enabled, we are only
                // interested in enabled nics.
                //
                hr = pncc->GetDeviceStatus( &devstat );
                if(!SUCCEEDED(hr))
                {
                    TRACE_CRIT(
                        "%!FUNC! WARNING: couldn't get dev status for %ws, ignoring",
                        szName
                        );
                    break;
                }
    
                // if any of the nics has any of the problem codes
                // then it cannot be used.
    
                if( devstat != CM_PROB_NOT_CONFIGURED
                    &&
                    devstat != CM_PROB_FAILED_START
                    &&
                    devstat != CM_PROB_NORMAL_CONFLICT
                    &&
                    devstat != CM_PROB_NEED_RESTART
                    &&
                    devstat != CM_PROB_REINSTALL
                    &&
                    devstat != CM_PROB_WILL_BE_REMOVED
                    &&
                    devstat != CM_PROB_DISABLED
                    &&
                    devstat != CM_PROB_FAILED_INSTALL
                    &&
                    devstat != CM_PROB_FAILED_ADD
                    )
                {
                    //
                    // No problem with this nic and also 
                    // physical device 
                    // thus we want it.
                    //

                    if (pINlbBinding != NULL)
                    {
                        BOOL fBound = FALSE;

                        hr = pINlbBinding->IsBoundTo(pncc);

                        if( !SUCCEEDED( hr ) )
                        {
                            TRACE_CRIT("IsBoundTo method failed for Nic %ws", szName);
                            goto end;
                        }
                    
                        if( hr == S_OK )
                        {
                            TRACE_VERB("BOUND: %ws\n", szName);
                            NumNlbBoundNics++;
                            fBound = TRUE;
                        }
                        else if (hr == S_FALSE )
                        {
                            TRACE_VERB("NOT BOUND: %ws\n", szName);
                            fBound = FALSE;
                        }
                    }


                    // We allocate a little node to keep this string
                    // temporarily and add it to our list of nodes.
                    //
                    pNicNode = new MYNICNODE;
                    if (pNicNode  == NULL)
                    {
                        Status = WBEM_E_OUT_OF_MEMORY;
                        goto end;
                    }
                    ZeroMemory(pNicNode, sizeof(*pNicNode));
                    pNicNode->szNicGuid = szName;
                    szName = NULL; // so we don't delete inside the lopp.
                    pNicNode->pNext = pNicNodeList;
                    pNicNodeList = pNicNode;
                    NumNics++;
                }
                else
                {
                    // There is a problem...
                    TRACE_CRIT(
                        "%!FUNC! WARNING: Skipping %ws because DeviceStatus=0x%08lx",
                        szName, devstat
                        );
                    break;
                }
            }
            else
            {
                TRACE_VERB("%!FUNC! Ignoring non-physical device %ws", szName);
            }

        } while (FALSE);

        if (szName != NULL)
        {
            CoTaskMemFree( szName );
        }
        pncc->Release();
        pncc=NULL;
    }

    if (pINlbBinding!=NULL)
    {
        pINlbBinding->Release();
        pINlbBinding = NULL;
    }

    if (NumNics==0)
    {
        Status = WBEM_NO_ERROR;
        goto end;
    }
    
    //
    // Now let's  allocate space for all the nic strings and:w
    // copy them over..
    //
    #define MY_GUID_LENGTH  38
    pszNics =  CfgUtilsAllocateStringArray(NumNics, MY_GUID_LENGTH);
    if (pszNics == NULL)
    {
        Status = WBEM_E_OUT_OF_MEMORY;
        goto end;
    }

    pNicNode= pNicNodeList;
    for (UINT u=0; u<NumNics; u++, pNicNode=pNicNode->pNext)
    {
        ASSERT(pNicNode != NULL); // because we just counted NumNics of em.
        UINT Len = wcslen(pNicNode->szNicGuid);
        if (Len != MY_GUID_LENGTH)
        {
            //
            // We should never get here beause we checked the length earlier.
            //
            TRACE_CRIT("%!FUNC! ERROR: GUID %ws has unexpected length %ul",
                    pNicNode->szNicGuid, Len);
            ASSERT(FALSE);
            Status = WBEM_E_CRITICAL_ERROR;
            goto end;
        }
        CopyMemory(
            pszNics[u],
            pNicNode->szNicGuid,
            (MY_GUID_LENGTH+1)*sizeof(WCHAR));
        ASSERT(pszNics[u][MY_GUID_LENGTH]==0);
    }

    Status = WBEM_NO_ERROR;


end:

    //
    // Now release the temporarly allocated memory.
    //
    pNicNode= pNicNodeList;
    while (pNicNode!=NULL)
    {
        MYNICNODE *pTmp = pNicNode->pNext;
        CoTaskMemFree(pNicNode->szNicGuid);
        pNicNode->szNicGuid = NULL;
        delete pNicNode;
        pNicNode = pTmp;
    }

    if (FAILED(Status))
    {
        TRACE_CRIT("%!FUNC! fails with status 0x%08lx", (UINT) Status);
        NumNics = 0;
        if (pszNics!=NULL)
        {
            delete pszNics;
            pszNics = NULL;
        }
    }
    else
    {
        if (pNumBoundToNlb != NULL)
        {
            *pNumBoundToNlb = NumNlbBoundNics;
        }
        *ppszNics = pszNics;
        *pNumNics = NumNics;
    }

    if (pencc != NULL)
    {
        pencc->Release();
    }

    return Status;
}


WBEMSTATUS
MyNetCfg::GetBindingIF(
        IN  LPCWSTR                     szComponent,
        OUT INetCfgComponentBindings   **ppIBinding
        )
{
    WBEMSTATUS                  Status = WBEM_E_CRITICAL_ERROR;
    INetCfgComponent            *pncc = NULL;
    INetCfgComponentBindings    *pnccb = NULL;
    HRESULT                     hr;


    if (m_pINetCfg == NULL)
    {
        //
        // This means we're not initialized
        //
        ASSERT(FALSE);
        goto end;
    }


    hr = m_pINetCfg->FindComponent(szComponent,  &pncc);

    if (FAILED(hr))
    {
        TRACE_CRIT("Error checking if component %ws does not exist\n", szComponent);
        pncc = NULL;
        goto end;
    }
    else if (hr == S_FALSE)
    {
        Status = WBEM_E_NOT_FOUND;
        TRACE_CRIT("Component %ws does not exist\n", szComponent);
        goto end;
    }
   
   
    hr = pncc->QueryInterface( IID_INetCfgComponentBindings, (void **) &pnccb );
    if( !SUCCEEDED( hr ) )
    {
        TRACE_CRIT("INetCfgComponent::QueryInterface failed ");
        pnccb = NULL;
        goto end;
    }

    Status = WBEM_NO_ERROR;

end:

    if (pncc)
    {
        pncc->Release();
        pncc=NULL;
    }

    *ppIBinding = pnccb;

    return Status;

}


WBEMSTATUS
set_string_parameter(
    IN  IWbemClassObjectPtr      spObj,
    IN  LPCWSTR szParameterName,
    IN  LPCWSTR szValue
    )
{
    WBEMSTATUS  Status = WBEM_E_CRITICAL_ERROR;
    HRESULT     hr;

    {
        _bstr_t     bstrName =  szParameterName;
        _variant_t  v_value = (LPWSTR) szValue; // Allocates.
    
        hr = spObj->Put(
                 bstrName, // Parameter Name
                 0, // Must be 0
                 &v_value,
                 0  // Must be 0
                 );
        v_value.Clear();
    
        if (FAILED(hr))
        {
            TRACE_CRIT("Unable to put parameter %ws", szParameterName);
            goto end;
        }
        Status = WBEM_NO_ERROR;

        //
        // I think bstrName releases the internally allocated string
        // on exiting this block.
        //

    }

end:

    return Status;
}

WBEMSTATUS
set_multi_string_parameter(
    IN  IWbemClassObjectPtr      spObj,
    IN  LPCWSTR szParameterName,
    IN  UINT    MaxStringLen,  // in wchars, INCLUDING space for trailing zeros.
    IN  UINT    NumItems,
    IN  LPCWSTR pStringValue
    )
{
    WBEMSTATUS   Status = WBEM_E_CRITICAL_ERROR;
    SAFEARRAY   *pSA = NULL;
    HRESULT hr;
    LONG Index = 0;

    //
    // Create safe array for the parameter values
    //
    pSA =  SafeArrayCreateVector(
                VT_BSTR,
                0,          // lower bound
                NumItems    // size of the fixed-sized vector.
                );
    if (pSA == NULL)
    {
        TRACE_CRIT("Could not create safe array");
        Status = WBEM_E_OUT_OF_MEMORY;
        goto end;
    }

    //
    // Place the strings into the safe array
    //
    {
        for (Index = 0; Index<NumItems; Index++)
        {
            LPCWSTR sz = pStringValue + Index*MaxStringLen;

            //
            // SafeArrayPutElement expects the string passed in to 
            // be of type BSTR, which is of type wchar *, except, that
            // the first 2 wchars contains length and other(?)
            // information. This is why you can't simply pass in sz.
            //
            // So to get this we initalize an object of type _bstr_t
            // based on sz. On initializaton, bstrValue allocates memory
            // and copies the string.
            //
            _bstr_t bstrValue = sz;
            wchar_t *pwchar = (wchar_t *) bstrValue; // returns internal pointer.

            // bpStr[Index] = sz; // may work as well.
            //
            // SafeArrayPutElement internally allocates space for pwchar and
            // copies over the string.
            // So pSA doesn't contain a direct reference to pwchar.
            //
            hr = SafeArrayPutElement(pSA, &Index, pwchar);
            if (FAILED(hr))
            {
                TRACE_CRIT("Unable to put element %wsz",  sz);
                (VOID) SafeArrayUnaccessData(pSA);
                goto end;
            }

            //
            // I think that bstrValue's contents are deallocated on exit of
            // this block.
            //
                
        }
    }
      
#if DBG
    //
    // Just check ...
    //
    {
        BSTR *pbStr=NULL;
        hr = SafeArrayAccessData(pSA, ( void **) &pbStr);
        if (FAILED(hr))
        {
            TRACE_CRIT("Could not access data of safe array");
            goto end;
        }
        for (UINT u = 0; u<NumItems; u++)
        {
            LPCWSTR sz = pbStr[u];
            if (_wcsicmp(sz, (pStringValue + u*MaxStringLen)))
            {
                TRACE_CRIT("!!!MISMATCH!!!!");
            }
            else
            {
                TRACE_CRIT("!!!MATCH!!!!");
            }
        }
        (VOID) SafeArrayUnaccessData(pSA);
        pbStr=NULL;
    }
#endif // DBG

    //
    // Put the parameter.
    //
    {
        VARIANT     V;
        _bstr_t  bstrName =  szParameterName;

        VariantInit(&V);
        V.vt = VT_ARRAY | VT_BSTR;
        V.parray = pSA;
        _variant_t   v_value;
        v_value.Attach(V);  // Takes owhership of V. V now becomes empty.
        ASSERT(V.vt == VT_EMPTY);
        pSA = NULL; // should be no need to delete this explicitly now.
                    // v_value.Clear() should delete it, I think.

        hr = spObj->Put(
                 bstrName, // Parameter Name
                 0, // Must be 0
                 &v_value,
                 0  // Must be 0
                 );

        v_value.Clear();
        if (FAILED(hr))
        {
            TRACE_CRIT("Unable to put parameter %ws", szParameterName);
            goto end;
        }
        Status = WBEM_NO_ERROR;
    }

    //
    // ?Destroy the data?
    //
    if (FAILED(Status))
    {
        if (pSA!=NULL)
        {
            SafeArrayDestroy(pSA);
            pSA = NULL;
        }
    }

end:

    return Status;
}



WBEMSTATUS
MyNetCfg::UpdateBindingState(
        IN  LPCWSTR         szNic,
        IN  LPCWSTR         szComponent,
        IN  UPDATE_OP       Op,
        OUT BOOL            *pfBound
        )
{
    WBEMSTATUS                  Status = WBEM_E_CRITICAL_ERROR;
    INetCfgComponent            *pINic = NULL;
    INetCfgComponentBindings    *pIBinding=NULL;
    BOOL                        fBound = FALSE;
    HRESULT                     hr;

    //
    // Get instance to the NIC
    //
    Status = GetNicIF(szNic, &pINic);
    if (FAILED(Status))
    {
        pINic = NULL;
        goto end;
    }

    //
    // Get instance of the nlb component
    //
    Status = GetBindingIF(szComponent, &pIBinding);
    if (FAILED(Status))
    {
        pIBinding = NULL;
        goto end;
    }

    //
    // Check if nlb is bound to the nlb component.
    //
    hr = pIBinding->IsBoundTo(pINic);
    if( !SUCCEEDED( hr ) )
    {
        TRACE_CRIT("IsBoundTo method failed for Nic %ws", szNic);
        goto end;
    }

    if( hr == S_OK )
    {
        fBound = TRUE;
    }
    else if (hr == S_FALSE )
    {
        fBound = FALSE;
    }

    if (    (Op == MyNetCfg::NOOP)
        ||  (Op == MyNetCfg::BIND && fBound)
        ||  (Op == MyNetCfg::UNBIND && !fBound))
    {
        Status = WBEM_NO_ERROR;
        goto end;
    }

    if (Op == MyNetCfg::BIND)
    {
        hr = pIBinding->BindTo( pINic );
    }
    else if (Op == MyNetCfg::UNBIND)
    {
        hr = pIBinding->UnbindFrom( pINic );
    }
    else
    {
        ASSERT(FALSE);
        goto end;
    }

    if (FAILED(hr))
    {
        TRACE_CRIT("Error 0x%08lx %ws %ws on %ws",
                (UINT) hr,
                ((Op==MyNetCfg::BIND) ? L"binding" : L"unbinding"),
                szComponent,
                szNic
                );
        goto end;
    }

    //
    // apply the binding change made.
    //
    hr = m_pINetCfg->Apply();
    if( !SUCCEEDED( hr ) )
    {
        TRACE_CRIT("INetCfg::Apply failed with 0x%08lx", (UINT) hr);
        goto end;
    }

    //
    // We're done. Our state should now be toggled.
    //
    fBound = !fBound;

    Status = WBEM_NO_ERROR;

end:

    if (pINic!=NULL)
    {
        pINic->Release();
        pINic = NULL;
    }

    if (pIBinding!=NULL)
    {
        pIBinding->Release();
        pIBinding = NULL;
    }

    *pfBound = fBound;

    return Status;
}

bool MapOpcodeToIoctl(WLBS_OPERATION_CODES Opcode, LONG *plIoctl)
{
    struct OPCODE_IOCTL_MAP
    {
        WLBS_OPERATION_CODES Opcode;
        LONG                 ioctl;
    } 

    OpcodeIoctlMap[] =
    {  
        {WLBS_START,            IOCTL_CVY_CLUSTER_ON},
        {WLBS_STOP,             IOCTL_CVY_CLUSTER_OFF},
        {WLBS_DRAIN,            IOCTL_CVY_CLUSTER_DRAIN},
        {WLBS_SUSPEND,          IOCTL_CVY_CLUSTER_SUSPEND},
        {WLBS_RESUME,           IOCTL_CVY_CLUSTER_RESUME},
        {WLBS_PORT_ENABLE,      IOCTL_CVY_PORT_ON},
        {WLBS_PORT_DISABLE,     IOCTL_CVY_PORT_OFF},
        {WLBS_PORT_DRAIN,       IOCTL_CVY_PORT_DRAIN},
        {WLBS_QUERY,            IOCTL_CVY_QUERY},
        {WLBS_QUERY_PORT_STATE, IOCTL_CVY_QUERY_PORT_STATE}
    };

    for (int i=0; i<sizeof(OpcodeIoctlMap) /sizeof(OpcodeIoctlMap[0]); i++)
    {
        if (OpcodeIoctlMap[i].Opcode == Opcode)
        {
            *plIoctl = OpcodeIoctlMap[i].ioctl;
            return true;
        }
    }

    //
    // Default
    //
    return false;
}


WBEMSTATUS
CfgUtilControlCluster(
    IN  LPCWSTR szNic,
    IN  WLBS_OPERATION_CODES Opcode,
    IN  DWORD   Vip,
    IN  DWORD   PortNum,
    OUT DWORD * pdwHostMap,
    OUT DWORD * pdwNlbStatus  
    )
{
    HRESULT hr;
    GUID Guid;
    WBEMSTATUS Status;
    LONG  ioctl;

    TRACE_INFO(L"-> %!FUNC! szNic : %ls, Opcode: %d, Vip : 0x%x, Port : 0x%x", szNic, Opcode, Vip, PortNum);

    if (pdwNlbStatus) 
    {
        *pdwNlbStatus = WLBS_FAILURE;
    }

    if (!g_CfgUtils.IsInitalized())
    {
        TRACE_CRIT(L"%!FUNC!(Nic=%ws) FAILING because uninitialized", szNic);
        Status =  WBEM_E_INITIALIZATION_FAILURE;
        goto end;
    }

    hr = CLSIDFromString((LPWSTR)szNic, &Guid);
    if (FAILED(hr))
    {
        TRACE_CRIT(
            L"CWlbsControl::Initialize failed at CLSIDFromString %ws",
            szNic
            );
        Status = WBEM_E_INVALID_PARAMETER;
        if (pdwNlbStatus) 
        {
            *pdwNlbStatus = WLBS_BAD_PARAMS;
        }
        goto end;
    }

    // Verify that the NLB API hooks are present
    if (!g_CfgUtils.m_NLBApiHooksPresent)
    {
        TRACE_CRIT(L"%!FUNC! FAILING because NLB API hooks are not present");
        Status =  WBEM_E_INITIALIZATION_FAILURE;
        goto end;
    }

    HANDLE  Nlb_driver_hdl;

    // Get handle to NLB driver
    if ((Nlb_driver_hdl = g_CfgUtils.m_pfWlbsOpen()) == INVALID_HANDLE_VALUE)
    {
        TRACE_CRIT(L"%!FUNC! WlbsOpen returned NULL, Could not create connection to NLB driver");
        Status = WBEM_E_CRITICAL_ERROR;
        goto end;
    }

    // Convert Opcode to ioctl
    if (!MapOpcodeToIoctl(Opcode, &ioctl))
    {
        TRACE_CRIT(L"%!FUNC!: Invalid value (0x%x) for operation!",Opcode);
        Status =  WBEM_E_INVALID_PARAMETER;
        if (pdwNlbStatus) 
        {
            *pdwNlbStatus = WLBS_BAD_PARAMS;
        }
        CloseHandle(Nlb_driver_hdl);
        goto end;
    }
        
    DWORD dwRet = g_CfgUtils.m_pfWlbsLocalClusterControl(Nlb_driver_hdl, &Guid, ioctl, Vip, PortNum, pdwHostMap);

    if (pdwNlbStatus) 
    {
        *pdwNlbStatus = dwRet;
    }

    // Close handle to NLB driver
    CloseHandle(Nlb_driver_hdl);


    Status = WBEM_NO_ERROR;

    switch(dwRet)
    {
    case WLBS_ALREADY:             break;
    case WLBS_CONVERGED:           break;
    case WLBS_CONVERGING:          break;
    case WLBS_DEFAULT:             break;
    case WLBS_DRAIN_STOP:          break;
    case WLBS_DRAINING:            break;
    case WLBS_OK:                  break;
    case WLBS_STOPPED:             break;
    case WLBS_SUSPENDED:           break;
    case NLB_PORT_RULE_NOT_FOUND:  break;
    case NLB_PORT_RULE_ENABLED:    break;
    case NLB_PORT_RULE_DISABLED:   break;
    case NLB_PORT_RULE_DRAINING:   break;
    case WLBS_BAD_PARAMS:          Status = WBEM_E_INVALID_PARAMETER; break;
    default:                       Status = WBEM_E_CRITICAL_ERROR; break;
    }

end:

    TRACE_INFO(L"<- %!FUNC! returns Status : 0x%x",Status);
    return Status;
}

WBEMSTATUS
CfgUtilGetClusterMembers(
    IN  LPCWSTR                 szNic,
    OUT DWORD                   *pNumMembers,
    OUT NLB_CLUSTER_MEMBER_INFO **ppMembers       // free using delete[]
    )
{
    HRESULT                     hr;
    GUID                        AdapterGuid;
    WBEMSTATUS                  Status = WBEM_E_CRITICAL_ERROR;
    DWORD                       dwNumHosts = CVY_MAX_HOSTS;
    PWLBS_RESPONSE              pResponse = NULL;
    NLB_CLUSTER_MEMBER_INFO*    pMembers = NULL;

    TRACE_INFO(L"-> szNic : %ls", szNic);

    ASSERT (pNumMembers != NULL);
    ASSERT (ppMembers != NULL);

    *pNumMembers = 0;
    *ppMembers = NULL;

    if (!g_CfgUtils.IsInitalized())
    {
        TRACE_CRIT(L"(Nic=%ws) FAILING because uninitialized", szNic);
        Status =  WBEM_E_INITIALIZATION_FAILURE;
        goto end;
    }

    hr = CLSIDFromString((LPWSTR)szNic, &AdapterGuid);
    if (FAILED(hr))
    {
        TRACE_CRIT(L"CLSIDFromString failed with error %ws", szNic);
        Status = WBEM_E_INVALID_PARAMETER;
        goto end;
    }

    // Verify that the NLB API hooks are present
    if (!g_CfgUtils.m_NLBApiHooksPresent)
    {
        TRACE_CRIT(L"FAILING because NLB API hooks are not present");
        Status =  WBEM_E_INITIALIZATION_FAILURE;
        goto end;
    }

    pResponse = new WLBS_RESPONSE[CVY_MAX_HOSTS];

    if (pResponse == NULL)
    {
        TRACE_CRIT(L"FAILING because memory allocation failed");
        Status = WBEM_E_OUT_OF_MEMORY;
        goto end;
    }

    ZeroMemory(pResponse, sizeof(WLBS_RESPONSE)*CVY_MAX_HOSTS);

    {
        DWORD dwStatus;

        dwStatus = g_CfgUtils.m_pfWlbsGetClusterMembers (
                        & AdapterGuid, 
                        & dwNumHosts,
                          pResponse
                        );

        //
        // WLBS_TIMEOUT, i.e., 0 hosts responding is considered a failure. So the only success code is WLBS_OK.
        // TODO: If we want timeout to be success, need to make a change here.
        //
        if (dwStatus != WLBS_OK)
        {
            TRACE_CRIT("error getting list of cluster members: 0x%x", dwStatus);
            Status = WBEM_E_FAILED;
            goto end;
        }

        if (dwNumHosts == 0)
        {
            //
            // Not an error, but we exit here because there were no cluster members.
            //
            TRACE_INFO("WlbsGetClusterMembers returned no cluster members");
            Status = WBEM_S_NO_ERROR;
            goto end;
        }
    }

    pMembers = new NLB_CLUSTER_MEMBER_INFO[dwNumHosts];

    if (pMembers == NULL)
    {
        TRACE_CRIT("error allocating struct to host cluster member info");
        Status = WBEM_E_OUT_OF_MEMORY;
        goto end;
    }

    //
    // Memory allocation succeeded, so set the size of the output array.
    //
    *pNumMembers = dwNumHosts;
    ZeroMemory(pMembers, sizeof(NLB_CLUSTER_MEMBER_INFO)*dwNumHosts);
    *ppMembers   = pMembers;

    for (int i=0; i < dwNumHosts; i++, pMembers++)
    {
        pMembers->HostId = pResponse[i].id;

        AbcdWszFromIpAddress(pResponse[i].address, pMembers->DedicatedIpAddress, ASIZECCH(pMembers->DedicatedIpAddress));

        if ((pResponse[i].options.query.hostname)[0] != L'\0')
        {
            wcsncpy(pMembers->HostName, pResponse[i].options.identity.fqdn, CVY_MAX_FQDN + 1);
            pMembers->HostName[CVY_MAX_FQDN] = L'\0';
        }
    }

    Status = WBEM_S_NO_ERROR;

end:

    // Clean up the output quantities if we had an error
    if (Status != WBEM_S_NO_ERROR)
    {
        if (pMembers != NULL)
        {
            delete [] pMembers;
            pMembers = NULL;
        }
    }

    if (pResponse != NULL)
    {
        delete [] pResponse;
        pResponse = NULL;
    }

    TRACE_INFO(L"<- returns Status : 0x%x",Status);
    return Status;
}

//
// Initializes pParams using default values.
//
VOID
CfgUtilInitializeParams(
    OUT WLBS_REG_PARAMS *pParams
    )
{
    //
    // We don't expect WlbsSetDefaults to fail (it should have been
    // defined returning VOID).
    //
    DWORD dwRet;


    // Verify that the NLB API hooks are present
    if (!g_CfgUtils.m_NLBApiHooksPresent)
    {
        dwRet = MyWlbsSetDefaults(pParams);
    }
    else
    {
        dwRet = g_CfgUtils.m_pfWlbsSetDefaults(pParams);
    }

    if (dwRet != WLBS_OK)
    {
        ZeroMemory(pParams, sizeof(*pParams));
        TRACE_CRIT("Internal error: WlbsSetDefaults failed");
        ASSERT(FALSE);
    }
}

//
// Converts the specified plain-text password into the hashed version
// and saves it in pParams.
//
DWORD
CfgUtilSetRemotePassword(
    IN WLBS_REG_PARAMS *pParams,
    IN LPCWSTR         szPassword
    
    )
{
    //
    // We don't expect WlbsSetDefaults to fail (it should have been
    // defined returning VOID).
    //
    DWORD dwRet;


    // Verify that the NLB API hooks are present
    if (!g_CfgUtils.m_NLBApiHooksPresent)
    {
        TRACE_CRIT(L"%!FUNC! FAILING because NLB API hooks are not present");
        dwRet =  WBEM_E_INITIALIZATION_FAILURE;
        goto end;
    }
    else
    {
        dwRet = g_CfgUtils.m_pfWlbsSetRemotePassword(pParams, szPassword);
    }

end:

    return dwRet;
}

WBEMSTATUS
CfgUtilSafeArrayFromStrings(
    IN  LPCWSTR       *pStrings,
    IN  UINT          NumStrings,
    OUT SAFEARRAY   **ppSA
    )
/*
    Allocates and returns a SAFEARRAY of strings -- strings are copies of
    the passed in values.

    Call  SafeArrayDestroy when done with the array.
*/
{
    WBEMSTATUS   Status = WBEM_E_CRITICAL_ERROR;
    SAFEARRAY   *pSA = NULL;
    HRESULT hr;
    LONG Index = 0;

    *ppSA = NULL;

    //
    // Create safe array for the parameter values
    //
    pSA =  SafeArrayCreateVector(
                VT_BSTR,
                0,          // lower bound
                NumStrings    // size of the fixed-sized vector.
                );
    if (pSA == NULL)
    {
        TRACE_CRIT("Could not create safe array");
        Status = WBEM_E_OUT_OF_MEMORY;
        goto end;
    }

    //
    // Place the strings into the safe array
    //
    {
        for (Index = 0; Index<NumStrings; Index++)
        {
            LPCWSTR sz = pStrings[Index];

            //
            // SafeArrayPutElement expects the string passed in to 
            // be of type BSTR, which is of type wchar *, except, that
            // the first 2 wchars contains length and other(?)
            // information. This is why you can't simply pass in sz.
            //
            // So to get this we initalize an object of type _bstr_t
            // based on sz. On initializaton, bstrValue allocates memory
            // and copies the string.
            //
            _bstr_t bstrValue = sz;
            wchar_t *pwchar = (wchar_t *) bstrValue; // returns internal pointer.

            // bpStr[Index] = sz; // may work as well.
            //
            // SafeArrayPutElement internally allocates space for pwchar and
            // copies over the string.
            // So pSA doesn't contain a direct reference to pwchar.
            //
            hr = SafeArrayPutElement(pSA, &Index, pwchar);
            if (FAILED(hr))
            {
                TRACE_CRIT("Unable to put element %wsz",  sz);
                (VOID) SafeArrayUnaccessData(pSA);
                goto end;
            }

            //
            // I think that bstrValue's contents are deallocated on exit of
            // this block.
            //
                
        }
    }
    Status = WBEM_NO_ERROR;
      
end:

    if (FAILED(Status))
    {
        if (pSA!=NULL)
        {
            SafeArrayDestroy(pSA);
            pSA = NULL;
        }
    }

    *ppSA = pSA;

    return Status;
}


WBEMSTATUS
CfgUtilStringsFromSafeArray(
    IN  SAFEARRAY   *pSA,
    OUT LPWSTR     **ppStrings,
    OUT UINT        *pNumStrings
    )
/*
    Extracts copies of the strings in the passed-in safe array.
    Free *pStrings using the delete operator when done.
    NOTE: Do NOT delete the individual strings -- they are
    stored in the memory allocated for pStrings.
*/
{
    WBEMSTATUS  Status      = WBEM_E_OUT_OF_MEMORY;
    LPWSTR     *pStrings    = NULL;
    LPCWSTR     csz;
    LPWSTR      sz;
    UINT        NumStrings = 0;
    UINT        u;
    HRESULT     hr;
    BSTR       *pbStr       =NULL;
    UINT        TotalSize   =0;
    LONG        UBound      = 0;

    *ppStrings = NULL;
    *pNumStrings = 0;

    hr = SafeArrayGetUBound(pSA, 1, &UBound);
    if (FAILED(hr))
    {
        TRACE_CRIT("Could not get upper bound of safe array");
        goto end;
    }
    NumStrings = (UINT) (UBound+1); // Convert from UpperBound to NumStrings.

    if (NumStrings == 0)
    {
        // nothing in array -- we're done.
        Status = WBEM_NO_ERROR;
        goto end;

    }

    hr = SafeArrayAccessData(pSA, ( void **) &pbStr);
    if (FAILED(hr))
    {
        TRACE_CRIT("Could not access data of safe array");
        goto end;
    }

    //
    // Calculate space for the array of pointers to strings...
    //
    TotalSize = NumStrings*sizeof(LPWSTR);

    //
    // Calculate space for the strings themselves...
    //
    for (u=0; u<NumStrings; u++)
    {
        csz = pbStr[u];
        TotalSize += (wcslen(csz)+1)*sizeof(WCHAR);
    }

    //
    // Allocate space for *both* the array of pointers and the strings
    // in one shot -- we're doing a new of type LPWSTR[] for the whole
    // lot, so need to specify the size in units of LPWSTR (with an
    // additional +1 in case there's roundoff).
    //
    pStrings = new LPWSTR[(TotalSize/sizeof(LPWSTR))+1];
    if (pStrings == NULL)
    {
        Status = WBEM_E_OUT_OF_MEMORY;
        (VOID) SafeArrayUnaccessData(pSA);
        goto end;
    }

    //
    // Make sz point to the start of the place where we'll be placing
    // the string data.
    //
    sz = (LPWSTR) (pStrings+NumStrings);
    for (u=0; u<NumStrings; u++)
    {
        csz = pbStr[u];
        UINT len = wcslen(csz)+1;
        CopyMemory(sz, csz, len*sizeof(WCHAR));
        pStrings[u] = sz;
        sz+=len;
    }

    (VOID) SafeArrayUnaccessData(pSA);
    Status = WBEM_NO_ERROR;

end:

    pbStr=NULL;
    if (FAILED(Status))
    {
        if (pStrings!=NULL)
        {
            delete[] pStrings;
            pStrings = NULL;
        }
        NumStrings = 0;
    }

    *ppStrings = pStrings;
    *pNumStrings = NumStrings;

    return Status;
}

WBEMSTATUS
CfgUtilGetWmiObjectInstance(
    IN  IWbemServicesPtr    spWbemServiceIF,
    IN  LPCWSTR             szClassName,
    IN  LPCWSTR             szPropertyName,
    IN  LPCWSTR             szPropertyValue,
    OUT IWbemClassObjectPtr &sprefObj // smart pointer
    )
{
    WBEMSTATUS Status = WBEM_E_NOT_FOUND;
    HRESULT hr;

    //
    // TODO: consider using  IWbemServices::ExecQuery
    //
    IEnumWbemClassObjectPtr  spEnum=NULL; // smart pointer
    IWbemClassObjectPtr spObj = NULL; // smart pointer.
    _bstr_t bstrClassName =  szClassName;

    //
    // get all instances of object
    //
    hr = spWbemServiceIF->CreateInstanceEnum(
             bstrClassName,
             WBEM_FLAG_RETURN_IMMEDIATELY,
             NULL,
             &spEnum
             );
    if (FAILED(hr))
    {
        TRACE_CRIT("IWbemServices::CreateInstanceEnum failure\n" );
        spEnum = NULL;
        goto end;
    }

    //
    // Look for the object with the matching property.
    //
    do
    {
        ULONG count = 1;
        
        hr = spEnum->Next(
                         INFINITE,
                         1,
                         &spObj,
                         &count
                         );
        //
        // Note -- Next() returns S_OK if number asked == number returned.
        //         and  S_FALSE if number asked < than number requested.
        //         Since we're asking for only ...
        //
        if (hr == S_OK)
        {
            LPWSTR szEnumValue = NULL;

            Status = CfgUtilGetWmiStringParam(
                        spObj,
                        szPropertyName,
                        &szEnumValue  // Delete when done.
                        );
            if (FAILED(Status))
            {
                //
                // Ignore this failure here.
                //

            }
            else if (szEnumValue!=NULL)
            {
               BOOL fFound = FALSE;
               if (!_wcsicmp(szEnumValue, szPropertyValue))
               {
                    fFound = TRUE;
               }
               delete szEnumValue;

               if (fFound)
               {
                    break; // BREAK BREAK BREAK BREAK
               }

            }
        }
        else
        {
            TRACE_INFO(
                "====0x%p->Next() returns Error 0x%lx; count=0x%lu", (PVOID) spObj,
                (UINT) hr, count);
        }


        //
        // Since I don't fully trust smart pointers, I'm specifically
        // setting spObj to NULL here...
        //
        spObj = NULL; // smart pointer

    } while (hr == S_OK);

    if (spObj == NULL)
    {
        //
        //  We couldn't find a NIC which matches the one asked for...
        //
        Status =  WBEM_E_NOT_FOUND;
        goto end;
    }

end:

    if (FAILED(Status))
    {
        sprefObj = NULL;
    }
    else
    {
        sprefObj = spObj; // smart pointer.
    }


    return Status;
}


WBEMSTATUS
CfgUtilGetWmiRelPath(
    IN  IWbemClassObjectPtr spObj,
    OUT LPWSTR *           pszRelPath          // free using delete 
    )
{
    WBEMSTATUS   Status = WBEM_E_CRITICAL_ERROR;
    LPWSTR pRelPath = NULL;


    //
    // Extract the relative path, needed for ExecMethod.
    //
    Status = CfgUtilGetWmiStringParam(
                spObj,
                L"__RELPATH", // szParameterName
                &pRelPath  // Delete when done.
                );
    if (FAILED(Status))
    {
        TRACE_CRIT("Couldn't get rel path");
        pRelPath = NULL;
        goto end;
    }
    else
    {
        if (pRelPath==NULL)
        {
            ASSERT(FALSE); // we don't expect this!
            goto end;
        }
        TRACE_VERB("GOT RELATIVE PATH %ws", pRelPath);
    }

end:
    *pszRelPath = pRelPath;

    return Status;
}


WBEMSTATUS
CfgUtilGetWmiInputInstanceAndRelPath(
    IN  IWbemServicesPtr    spWbemServiceIF,
    IN  LPCWSTR             szClassName,
    IN  LPCWSTR             szPropertyName, // NULL: return Class rel path
    IN  LPCWSTR             szPropertyValue,
    IN  LPCWSTR             szMethodName,
    OUT IWbemClassObjectPtr &spWbemInputInstance, // smart pointer
    OUT LPWSTR *            pszRelPath          // free using delete 
    )
{
    WBEMSTATUS          Status = WBEM_E_CRITICAL_ERROR;
    IWbemClassObjectPtr spClassObj   = NULL;  // smart pointer
    HRESULT             hr;
    LPWSTR              pRelPath = NULL;

    TRACE_INFO(L"-> %!FUNC!(PropertyValue=%ws)",
         szPropertyValue==NULL ? L"<class>" : szPropertyValue);

    //
    // Get CLASS object
    //
    {
        hr = spWbemServiceIF->GetObject(
                        _bstr_t(szClassName),
                        0,
                        NULL,
                        &spClassObj,
                        NULL
                        );

        if (FAILED(hr))
        {
            TRACE_CRIT("Couldn't get nic class object pointer");
            Status = (WBEMSTATUS)hr;
            goto end;
        }

    }

    //
    // Get WMI path to specific object
    //
    if (szPropertyName == NULL)
    {
        // Get WMI path to the class
        Status =  CfgUtilGetWmiRelPath(
                    spClassObj,
                    &pRelPath
                    );
        if (FAILED(Status))
        {
            goto end;
        }
    }
    else
    {
        IWbemClassObjectPtr spObj   = NULL;  // smart pointer
        pRelPath = NULL;

        Status = CfgUtilGetWmiObjectInstance(
                        spWbemServiceIF,
                        szClassName,
                        szPropertyName,
                        szPropertyValue,
                        spObj // smart pointer, passed by ref
                        );
        if (FAILED(Status))
        {
            ASSERT(spObj == NULL);
            goto end;
        }

        Status =  CfgUtilGetWmiRelPath(
                    spObj,
                    &pRelPath
                    );
        spObj = NULL; // smart pointer
        if (FAILED(Status))
        {
            goto end;
        }
    }

    //
    // Get the input parameters to the call to the method
    //
    {
        IWbemClassObjectPtr      spWbemInput = NULL; // smart pointer

        // check if any input parameters specified.
    
        hr = spClassObj->GetMethod(
                        szMethodName,
                        0,
                        &spWbemInput,
                        NULL
                        );
        if(FAILED(hr))
        {
            TRACE_CRIT("IWbemClassObject::GetMethod failure");
            Status = (WBEMSTATUS) hr;
            goto end;
        }
            
        if (spWbemInput != NULL)
        {
            hr = spWbemInput->SpawnInstance( 0, &spWbemInputInstance );
            if( FAILED( hr) )
            {
                TRACE_CRIT("IWbemClassObject::SpawnInstance failure. Unable to spawn instance." );
                Status = (WBEMSTATUS) hr;
                goto end;
            }
        }
        else
        {
            //
            // This method has no input arguments!
            //
            spWbemInputInstance = NULL;
        }

    }

    Status = WBEM_NO_ERROR;

end:


    if (FAILED(Status))
    {
        if (pRelPath != NULL)
        {
            delete pRelPath;
            pRelPath = NULL;
        }
    }

    *pszRelPath = pRelPath;

    TRACE_INFO(L"<- %!FUNC! returns 0x%08lx", (UINT) Status);

    return Status;
}


WBEMSTATUS
CfgUtilGetWmiStringParam(
    IN  IWbemClassObjectPtr spObj,
    IN  LPCWSTR             szParameterName,
    OUT LPWSTR *ppStringValue
)
{
    WBEMSTATUS Status = WBEM_E_NOT_FOUND;
    WCHAR *pStringValue = NULL;
    
    try
    {

        _variant_t   v_value;
        CIMTYPE      v_type;
        HRESULT hr;
    
        hr = spObj->Get(
                _bstr_t(szParameterName), // Name
                0,                     // Reserved, must be 0     
                &v_value,               // Place to store value
                &v_type,                // Type of value
                NULL                   // Flavor (unused)
                );
       if (FAILED(hr))
       {
            // Couldn't read the Setting ID field!
            //
            TRACE_CRIT(
                "get_str_parm:Couldn't retrieve %ws from 0x%p. Hr=0x%08lx",
                szParameterName,
                (PVOID) spObj,
                hr
                );
            goto end;
       }
       else if (v_type == VT_NULL || v_value.vt == VT_NULL)
       {
            pStringValue = NULL;
            Status = WBEM_NO_ERROR;
            goto end;
       }
       else
       {
           if (v_type != VT_BSTR)
           {
                TRACE_CRIT(
                    "get_str_parm: Parm value not of string type %ws from 0x%p",
                    szParameterName,
                    (PVOID) spObj
                    );
                Status = WBEM_E_INVALID_PARAMETER;
           }
           else
           {
    
               _bstr_t bstrNicGuid(v_value);
               LPCWSTR sz = bstrNicGuid; // Pointer to internal buffer.
    
               if (sz==NULL)
               {
                    // hmm.. null value 
                    pStringValue = NULL;
                    Status = WBEM_NO_ERROR;
               }
               else
               {
                   UINT len = wcslen(sz);
                   pStringValue = new WCHAR[len+1];
                   if (pStringValue == NULL)
                   {
                        TRACE_CRIT("get_str_parm: Alloc failure!");
                        Status = WBEM_E_OUT_OF_MEMORY;
                   }
                   else
                   {
                        CopyMemory(pStringValue, sz, (len+1)*sizeof(WCHAR));
                        Status = WBEM_NO_ERROR;
                   }
                }
    
                TRACE_VERB(
                    "get_str_parm: String parm %ws of 0x%p is %ws",
                    szParameterName,
                    (PVOID) spObj,
                    (sz==NULL) ? L"<null>" : sz
                    );
           }
    
           v_value.Clear(); // Must be cleared after each call to Get.
        }

    }
    catch( _com_error e )
    {
        TRACE_INFO(L"%!FUNC! -- com exception");
        Status = WBEM_E_NOT_FOUND;
    }

end:

    if (!FAILED(Status) && pStringValue == NULL)
    {
        //
        // We convert a NULL value to an empty, not NULL string.
        //
        pStringValue = new WCHAR[1];
        if (pStringValue == NULL)
        {
            Status = WBEM_E_OUT_OF_MEMORY;
        }
        else
        {
            *pStringValue = 0;
            Status = WBEM_NO_ERROR;
        }
    }

    
    *ppStringValue = pStringValue;

    return Status;

}


WBEMSTATUS
CfgUtilSetWmiStringParam(
    IN  IWbemClassObjectPtr spObj,
    IN  LPCWSTR             szParameterName,
    IN  LPCWSTR             szValue
    )
{
    WBEMSTATUS  Status = WBEM_E_CRITICAL_ERROR;

    try
    {

        HRESULT     hr;
        _bstr_t     bstrName =  szParameterName;
        _variant_t  v_value = (LPWSTR) szValue; // Allocates.
        
            hr = spObj->Put(
                     bstrName, // Parameter Name
                     0, // Must be 0
                     &v_value,
                     0  // Must be 0
                     );
            v_value.Clear();
        
            if (FAILED(hr))
            {
                TRACE_CRIT("Unable to put parameter %ws", szParameterName);
                goto end;
            }
            Status = WBEM_NO_ERROR;
    
        //
        // I think bstrName releases the internally allocated string
        // on exiting this block.
        //
    }
    catch( _com_error e )
    {
        TRACE_INFO(L"%!FUNC! -- com exception");
        Status = WBEM_E_INVALID_PARAMETER;
    }

end:

    return Status;
}


WBEMSTATUS
CfgUtilGetWmiStringArrayParam(
    IN  IWbemClassObjectPtr spObj,
    IN  LPCWSTR             szParameterName,
    OUT LPWSTR              **ppStrings,
    OUT UINT                *pNumStrings
)
{
    WBEMSTATUS Status = WBEM_E_NOT_FOUND;

    try
    {
        _variant_t   v_value;
        CIMTYPE      v_type;
        HRESULT hr;
        LONG count = 0;
    
        *ppStrings = NULL;
        *pNumStrings = 0;
    
        hr = spObj->Get(
                _bstr_t(szParameterName),
                0,                     // Reserved, must be 0     
                &v_value,               // Place to store value
                &v_type,                // Type of value
                NULL                   // Flavor (unused)
                );
        if (FAILED(hr))
        {
            // Couldn't read the requested parameter.
            //
            TRACE_CRIT(
                "get_multi_str_parm:Couldn't retrieve %ws from 0x%p",
                szParameterName,
                (PVOID) spObj
                );
            Status = WBEM_E_INVALID_PARAMETER;
            goto end;
        }
    
    
        if (v_type != (VT_ARRAY | VT_BSTR))
        {

           if (v_type == VT_NULL)
           {
                //
                // We convert a NULL value to zero strings
                //
                Status = WBEM_NO_ERROR;
                goto end;
           }
           TRACE_CRIT("vt is not of type string!");
           goto end;
        }
        else if (v_value.vt == VT_NULL)
        {
            //
            // I've seen this too...
            //
            // We convert a NULL value to zero strings
            //
            TRACE_CRIT("WARNING: vt is NULL!");
            Status = WBEM_NO_ERROR;
            goto end;

        }
        else
        {
            VARIANT    ipsV = v_value.Detach();
            SAFEARRAY   *pSA = ipsV.parray;
    
            Status =  CfgUtilStringsFromSafeArray(
                            pSA,
                            ppStrings,
                            pNumStrings
                            );
    
            VariantClear( &ipsV );
        }
    }
    catch( _com_error e )
    {
        TRACE_INFO(L"%!FUNC! -- com exception");
        Status = WBEM_E_NOT_FOUND;
    }

end:

   return Status;
}


WBEMSTATUS
CfgUtilSetWmiStringArrayParam(
    IN  IWbemClassObjectPtr spObj,
    IN  LPCWSTR             szParameterName,
    IN  LPCWSTR             *ppStrings,
    IN  UINT                NumStrings
)
{
    WBEMSTATUS   Status = WBEM_E_CRITICAL_ERROR;
    SAFEARRAY   *pSA = NULL;


    try
    {

        HRESULT hr;
        LONG Index = 0;
    
    
        Status = CfgUtilSafeArrayFromStrings(
                    ppStrings,
                    NumStrings,
                    &pSA
                    );
        if (FAILED(Status))
        {
            pSA = NULL;
            goto end;
        }
    
    
        //
        // Put the parameter.
        //
        {
            VARIANT     V;
            _bstr_t  bstrName =  szParameterName;
    
            VariantInit(&V);
            V.vt = VT_ARRAY | VT_BSTR;
            V.parray = pSA;
            _variant_t   v_value;
            v_value.Attach(V);  // Takes owhership of V. V now becomes empty.
            ASSERT(V.vt == VT_EMPTY);
            pSA = NULL; // should be no need to delete this explicitly now.
                        // v_value.Clear() should delete it, I think.
    
            hr = spObj->Put(
                     bstrName, // Parameter Name
                     0, // Must be 0
                     &v_value,
                     0  // Must be 0
                     );
    
            v_value.Clear();
            if (FAILED(hr))
            {
                Status = (WBEMSTATUS) hr;
                TRACE_CRIT("Unable to put parameter %ws", szParameterName);
                goto end;
            }
            Status = WBEM_NO_ERROR;
        }

    }
    catch( _com_error e )
    {
        TRACE_INFO(L"%!FUNC! -- com exception");
        Status = WBEM_E_INVALID_PARAMETER;
    }

end:

    if (pSA!=NULL)
    {
        SafeArrayDestroy(pSA);
        pSA = NULL;
    }

    return Status;
}


WBEMSTATUS
CfgUtilGetWmiDWORDParam(
    IN  IWbemClassObjectPtr spObj,
    IN  LPCWSTR             szParameterName,
    OUT DWORD              *pValue
)
{
    WBEMSTATUS Status = WBEM_E_NOT_FOUND;
    DWORD Value=0;


    try
    {
        _variant_t   v_value;
        CIMTYPE      v_type;
        HRESULT hr;
    
        hr = spObj->Get(
                _bstr_t(szParameterName), // Name
                0,                     // Reserved, must be 0     
                &v_value,               // Place to store value
                &v_type,                // Type of value
                NULL                   // Flavor (unused)
                );
       if (FAILED(hr))
       {
            // Couldn't read the parameter
            //
            TRACE_CRIT(
                "GetDWORDParm:Couldn't retrieve %ws from 0x%p",
                szParameterName,
                (PVOID) spObj
                );
            goto end;
       }
       else
       {
           Value = (DWORD) (long)  v_value;
           v_value.Clear(); // Must be cleared after each call to Get.
           Status = WBEM_NO_ERROR;
        }

    }
    catch( _com_error e )
    {
        TRACE_INFO(L"%!FUNC! -- com exception");
        Status = WBEM_E_NOT_FOUND;
    }

end:

    *pValue = Value;

    return Status;

}


WBEMSTATUS
CfgUtilSetWmiDWORDParam(
    IN  IWbemClassObjectPtr spObj,
    IN  LPCWSTR             szParameterName,
    IN  DWORD               Value
)
{
    WBEMSTATUS  Status = WBEM_E_CRITICAL_ERROR;


    try
    {

        HRESULT     hr;
        _bstr_t     bstrName =  szParameterName;
        _variant_t  v_value = (long) Value;
        
        hr = spObj->Put(
                 bstrName, // Parameter Name
                 0, // Must be 0
                 &v_value,
                 0  // Must be 0
                 );
        v_value.Clear();
    
        if (FAILED(hr))
        {
            TRACE_CRIT("Unable to put parameter %ws", szParameterName);
            goto end;
        }
        Status = WBEM_NO_ERROR;

    }
    catch( _com_error e )
    {
        TRACE_INFO(L"%!FUNC! -- com exception");
        Status = WBEM_E_INVALID_PARAMETER;
    }

end:

    return Status;
}


WBEMSTATUS
CfgUtilGetWmiBoolParam(
    IN  IWbemClassObjectPtr spObj,
    IN  LPCWSTR             szParameterName,
    OUT BOOL                *pValue
)
{
    WBEMSTATUS Status = WBEM_E_NOT_FOUND;
    BOOL Value=0;

    try
    {
        _variant_t   v_value;
        CIMTYPE      v_type;
        HRESULT hr;
    
        hr = spObj->Get(
                _bstr_t(szParameterName), // Name
                0,                     // Reserved, must be 0     
                &v_value,               // Place to store value
                &v_type,                // Type of value
                NULL                   // Flavor (unused)
                );
       if (FAILED(hr))
       {
            // Couldn't read the parameter
            //
            TRACE_CRIT(
                "GetDWORDParm:Couldn't retrieve %ws from 0x%p",
                szParameterName,
                (PVOID) spObj
                );
            goto end;
       }
       else
       {
           Value = ((bool)  v_value)!=0;
           v_value.Clear(); // Must be cleared after each call to Get.
           Status = WBEM_NO_ERROR;
        }

    }
    catch( _com_error e )
    {
        TRACE_INFO(L"%!FUNC! -- com exception");
        Status = WBEM_E_NOT_FOUND;
    }

end:

    *pValue = Value;

    return Status;
}


WBEMSTATUS
CfgUtilSetWmiBoolParam(
    IN  IWbemClassObjectPtr spObj,
    IN  LPCWSTR             szParameterName,
    IN  BOOL                Value
)
{
    WBEMSTATUS  Status = WBEM_E_CRITICAL_ERROR;

    try
    {
        HRESULT     hr;
        _bstr_t     bstrName =  szParameterName;
        _variant_t  v_value = (long) Value;
        
        hr = spObj->Put(
                 bstrName, // Parameter Name
                 0, // Must be 0
                 &v_value,
                 0  // Must be 0
                 );
        v_value.Clear();
    
        if (FAILED(hr))
        {
            TRACE_CRIT("Unable to put parameter %ws", szParameterName);
            goto end;
        }
        Status = WBEM_NO_ERROR;

    }
    catch( _com_error e )
    {
        TRACE_INFO(L"%!FUNC! -- com exception");
        Status = WBEM_E_INVALID_PARAMETER;
    }

end:

    return Status;
}


WBEMSTATUS
CfgUtilConnectToServer(
    IN  LPCWSTR szNetworkResource, // \\machinename\root\microsoftnlb  \root\...
    IN  LPCWSTR szUser,
    IN  LPCWSTR szPassword,
    IN  LPCWSTR szAuthority,
    OUT IWbemServices  **ppWbemService // deref when done.
    )
{
    HRESULT hr = WBEM_E_CRITICAL_ERROR;
    IWbemLocatorPtr     spLocator=NULL; // Smart pointer
    IWbemServices       *pService=NULL;

    try
    {

        _bstr_t                serverPath(szNetworkResource);
    
        *ppWbemService = NULL;
        
        hr = CoCreateInstance(CLSID_WbemLocator, 0, 
                              CLSCTX_INPROC_SERVER, 
                              IID_IWbemLocator, 
                              (LPVOID *) &spLocator);
     
        if (FAILED(hr))
        {
            TRACE_CRIT(L"CoCreateInstance  IWebmLocator failed 0x%08lx ", (UINT)hr);
            goto end;
        }

        for (int timesToRetry=0; timesToRetry<10; timesToRetry++)
        {
			//
    		// SECURITY BUGBUG -- need to make sure that 
    	    // password is zeroed out!
    	    //
            hr = spLocator->ConnectServer(
                    serverPath,
                    // (szUser!=NULL) ? (_bstr_t(szUser)) : NULL,
                    _bstr_t(szUser),
                    // (szPassword==NULL) ? NULL : _bstr_t(szPassword),
                    _bstr_t(szPassword),
                    NULL, // Locale
                    0,    // Security flags
                    //(szAuthority==NULL) ? NULL : _bstr_t(szAuthority),
                    _bstr_t(szAuthority),
                    NULL,
                    &pService
                 );

            if( !FAILED( hr) )
            {
                break;
            }

            //
            // these have been found to be special cases where retrying may
            // help. The errors below are not in any header file, and I searched
            // the index2a sources for these constants -- no hits.
            // TODO: file bug against WMI.
            //
            if( ( hr == 0x800706bf ) || ( hr == 0x80070767 ) || ( hr == 0x80070005 )  )
            {
                    TRACE_CRIT(L"connectserver recoverable failure, retrying.");
                    Sleep(500);
            }
            else
            {
                //
                // Unrecoverable error...
                //
                break;
            }
        }
    
    
        if (FAILED(hr))
        {
            TRACE_CRIT(L"Error 0x%08lx connecting to server", (UINT) hr);
            goto end;
        }
        else
        {
            TRACE_INFO(L"Successfully connected to server %s", serverPath);
        }

        // 2/13/02 JosephJ SECURITY BUGBUG: verify that Both calls to CoSetProxyBlanket are the right 
        // ones to be made, from a security perspective.
        //
        // If NONE of User, Password, Authority is passed, call
        // CoSetProxyBlanket with AuthInfo of COLE_DEFAULT_AUTHINFO
        //
        if(((szUser      == NULL) || (wcslen(szUser)      < 1)) 
         &&((szPassword  == NULL) || (wcslen(szPassword)  < 1))
         &&((szAuthority == NULL) || (wcslen(szAuthority) < 1))) 
        {
            hr = CoSetProxyBlanket(
                 pService,
                 RPC_C_AUTHN_WINNT,
                 RPC_C_AUTHZ_DEFAULT,      // RPC_C_AUTHZ_NAME,
                 COLE_DEFAULT_PRINCIPAL,   // NULL,
                 RPC_C_AUTHN_LEVEL_DEFAULT,
                 RPC_C_IMP_LEVEL_IMPERSONATE,
                 COLE_DEFAULT_AUTHINFO, // NULL,
                 EOAC_DEFAULT // EOAC_NONE
                 );
        }
        else // User or Authority was passed in, we need to create an authority argument for the login
        {
    
            COAUTHIDENTITY  authident;
            BSTR            AuthArg, UserArg;

            AuthArg = NULL; 
            UserArg = NULL;

            hr = CfgUtilParseAuthorityUserArgs(AuthArg, UserArg, szAuthority, szUser);
            if (FAILED(hr))
            {
                TRACE_CRIT(L"Error CfgUtilParseAuthorityUserArgs returns 0x%08lx", (UINT)hr);
                goto end;
            }

            if(UserArg)
            {
                authident.UserLength = wcslen(UserArg);
                authident.User = (LPWSTR)UserArg;
            }

            if(AuthArg)
            {
                authident.DomainLength = wcslen(AuthArg);
                authident.Domain = (LPWSTR)AuthArg;
            }

            if(szPassword)
            {
                authident.PasswordLength = wcslen(szPassword);
                authident.Password = (LPWSTR)szPassword;
            }

            authident.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

            hr = CoSetProxyBlanket(
                 pService,
                 RPC_C_AUTHN_WINNT,
                 RPC_C_AUTHZ_DEFAULT,      // RPC_C_AUTHZ_NAME,
                 COLE_DEFAULT_PRINCIPAL,   // NULL,
                 RPC_C_AUTHN_LEVEL_DEFAULT,
                 RPC_C_IMP_LEVEL_IMPERSONATE,
                 &authident,   // THIS IS THE DISTINGUISHING ARGUMENT
                 EOAC_DEFAULT // EOAC_NONE
                 );

            if(UserArg)
                SysFreeString(UserArg);
            if(AuthArg)
                SysFreeString(AuthArg);
        }
    
        if (FAILED(hr))
        {
            TRACE_CRIT(L"Error 0x%08lx setting proxy blanket", (UINT) hr);
            goto end;
        }
    
        hr = WBEM_NO_ERROR;

    }
    catch( _com_error e )
    {
        TRACE_INFO(L"%!FUNC! -- com exception");
        hr = WBEM_E_INVALID_PARAMETER;
    }

end:

    spLocator = NULL; // smart pointer.


    if (FAILED(hr))
    {
        if (pService != NULL)
        {
            pService->Release();
            pService=NULL;
        }
    }

    *ppWbemService = pService;

    return (WBEMSTATUS) hr;
}


WBEMSTATUS
CfgUtilGetWmiMachineName(
    IN  IWbemServicesPtr    spWbemServiceIF,
    OUT LPWSTR *            pszMachineName          // free using delete 
    )
/*
    Return the machine name and (optionally) machine guid.
*/
{
    WBEMSTATUS          Status = WBEM_E_CRITICAL_ERROR;
    IWbemClassObjectPtr spClassObj   = NULL;  // smart pointer
    HRESULT             hr;

    hr = spWbemServiceIF->GetObject(
                    _bstr_t(L"NlbsNic"),
                    0,
                    NULL,
                    &spClassObj,
                    NULL
                    );

    if (FAILED(hr))
    {
        TRACE_CRIT("Couldn't get nic class object pointer");
        Status = (WBEMSTATUS)hr;
        goto end;
    }


    Status = CfgUtilGetWmiStringParam(
                    spClassObj,
                    L"__Server", // <-------------------------
                    pszMachineName
                    );

    if (FAILED(Status))
    {
        TRACE_CRIT(L"%!FUNC! Attempt to read server name. Error=0x%08lx",
                (UINT) Status);
        *pszMachineName = NULL;
    }
    else
    {
        TRACE_CRIT(L"%!FUNC! Got __Server value:%ws", *pszMachineName);
    }

end:

    spClassObj   = NULL;  // smart pointer

    return Status;
}


WBEMSTATUS
CfgUtilsGetNlbCompatibleNics(
        OUT LPWSTR **ppszNics,
        OUT UINT   *pNumNics,
        OUT UINT   *pNumBoundToNlb // OPTIONAL
        )
{
    WBEMSTATUS Status = WBEM_NO_ERROR;
    BOOL fNetCfgInitialized = FALSE;
    MyNetCfg NetCfg;
    BOOL fBound = FALSE;


    //
    // Get and initialize interface to netcfg
    //
    Status = NetCfg.Initialize(FALSE); // TRUE == get write lock.
    if (FAILED(Status))
    {
        goto end;
    }
    fNetCfgInitialized = TRUE;

    //
    //
    //
    Status = NetCfg.GetNlbCompatibleNics(
                        ppszNics,
                        pNumNics,
                        pNumBoundToNlb // OPTIONAL
                        );

end:

    if (fNetCfgInitialized)
    {
        NetCfg.Deinitialize();
    }

    return Status;
}

WBEMSTATUS
CfgUtilGetWmiAdapterObjFromAdapterConfigurationObj(
    IN  IWbemServicesPtr    spWbemServiceIF,    // smart pointer
    IN  IWbemClassObjectPtr spObj,              // smart pointer
    OUT  IWbemClassObjectPtr &spAdapterObj      // smart pointer, by reference
    )
/*
    We need to return the "Win32_NetworkAdapter" object  associated with
    the  "Win32_NetworkAdapterConfiguration" object.

    The key of Win32_NetworkAdapter is DeviceId.
    The key of Win32_NetworkAdapterConfiguration is Index.

    We use the "Win32_NetworkAdapterSetting" association class for this.

*/
{
    #define ARRAYSIZE(_arr) (sizeof(_arr)/sizeof(_arr[0]))
    WCHAR                   sz[ 256 ];
    IEnumWbemClassObject *  pConfigurations = NULL;
    ULONG                   ulReturned = 0;
    DWORD                   dwIndex = 0;
    WBEMSTATUS              Status = WBEM_E_CRITICAL_ERROR;

    spAdapterObj = NULL; // smart pointer

    Status = CfgUtilGetWmiDWORDParam(
                    spObj,
                    L"Index",
                    &dwIndex
                    );
    if (FAILED(Status))
    {
        goto end;
    }

    StringCbPrintf(
         sz,
         sizeof( sz ),
         L"Associators of {Win32_NetworkAdapterConfiguration.Index='%d'}"
          L" where AssocClass=Win32_NetworkAdapterSetting",
         dwIndex
        );

    Status = (WBEMSTATUS) spWbemServiceIF->ExecQuery(
                 _bstr_t(L"WQL"),
                 _bstr_t(sz) ,
                 WBEM_FLAG_FORWARD_ONLY,
                 NULL,
                 &pConfigurations
                 );

    if (FAILED(Status))
    {
        TRACE_CRIT("%!FUNC!: ExecQuery \"%ws\" failed with error 0x%08lx",
            sz,
            (UINT) Status
            );
        pConfigurations = NULL;
        goto end;
    }

    Status = (WBEMSTATUS) pConfigurations->Next(
             WBEM_INFINITE,
             1,
             &spAdapterObj,
             &ulReturned
             );
    if ((Status != S_OK) || (ulReturned!=1))
    {
        TRACE_CRIT("%!FUNC!: No NetworkAdapter associated with NetworkAdapterCOnfiguration!");
        ASSERT(spAdapterObj == NULL); // smart pointer.
        goto end;
    }

end:

    if (pConfigurations!=NULL)
    {
        pConfigurations->Release();
        pConfigurations = NULL;
    }

    return Status;

}

//
// Gets the port rules, if any, from the specfied nlb params structure
//
WBEMSTATUS
CfgUtilGetPortRules(
    IN  const WLBS_REG_PARAMS *pConstParams,
    OUT WLBS_PORT_RULE **ppRules,   // Free using delete
    OUT UINT           *pNumRules
    )
{
    WBEMSTATUS Status;

    WLBS_REG_PARAMS *pParams  = (WLBS_REG_PARAMS *) pConstParams;
    *ppRules = NULL;
    *pNumRules = 0;

    WLBS_PORT_RULE  AllPortRules[WLBS_MAX_RULES];
    DWORD           NumRules = WLBS_MAX_RULES;
    DWORD           dwRes;

    // Verify that the NLB API hooks are present
    if (!g_CfgUtils.m_NLBApiHooksPresent)
    {
        dwRes = MyWlbsEnumPortRules (pParams, AllPortRules, &NumRules);
    }
    else
    {
        dwRes = g_CfgUtils.m_pfWlbsEnumPortRules (pParams, AllPortRules, &NumRules);
    }

    if (dwRes != WLBS_OK) 
    {
        Status = WBEM_E_INVALID_PARAMETER;
        goto end;
    }

    if (NumRules!=0)
    {
        *ppRules = new WLBS_PORT_RULE[NumRules];
        if (*ppRules == NULL)
        {
            Status = WBEM_E_OUT_OF_MEMORY;
            goto end;
        }
        CopyMemory(*ppRules, AllPortRules, sizeof(WLBS_PORT_RULE)*NumRules);
        *pNumRules = NumRules;
    }
    Status = WBEM_NO_ERROR;
end:

    return Status;
}

//
// Sets the specified port rules in the specfied nlb params structure
//
WBEMSTATUS
CfgUtilSetPortRules(
    IN WLBS_PORT_RULE *pRules,
    IN UINT           NumRules,
    IN OUT WLBS_REG_PARAMS *pParams
    )
{
    WBEMSTATUS Status;

    if (NumRules > WLBS_MAX_RULES)
    {
        Status = WBEM_E_INVALID_PARAMETER;
        goto end;
    }
    
    // Verify that the NLB API hooks are present
    if (!g_CfgUtils.m_NLBApiHooksPresent)
    {
        MyWlbsDeleteAllPortRules(pParams);
    }
    else
    {
        g_CfgUtils.m_pfWlbsDeleteAllPortRules(pParams);
    }

    for (UINT u = 0; u < NumRules; u++)
    {
        DWORD dwRes;
        // Verify that the NLB API hooks are present
        if (!g_CfgUtils.m_NLBApiHooksPresent)
        {
            dwRes = MyWlbsAddPortRule( pParams, pRules+u);
        }
        else
        {
            dwRes = g_CfgUtils.m_pfWlbsAddPortRule( pParams, pRules+u);
        }
    }

    Status =  WBEM_NO_ERROR;

end:
    return Status;

}


BOOL
CfgUtilsGetPortRuleString(
    IN PWLBS_PORT_RULE pPr,
    OUT LPWSTR pString         // At least NLB_MAX_PORT_STRING_SIZE wchars
    )
{
    const UINT cchString = NLB_MAX_PORT_STRING_SIZE;
    BOOL fRet = FALSE;
    HRESULT hr;

    LPCWSTR szProtocol = L"";
    LPCWSTR szMode = L"";
    LPCWSTR szAffinity = L"";

    if (cchString == 0) goto end;

    ZeroMemory(pString, cchString*sizeof(WCHAR));

    switch(pPr->protocol)
    {
    case CVY_TCP:
        szProtocol = L"TCP";
        break;
    case CVY_UDP:
        szProtocol = L"UDP";
        break;
    case CVY_TCP_UDP:
        szProtocol = L"BOTH";
        break;
    default:
        goto end; // bad parse
    }

    switch(pPr->mode)
    {
    case  CVY_SINGLE:
        szMode = L"SINGLE";
        break;
    case CVY_MULTI:
        szMode = L"MULTIPLE";
        switch(pPr->mode_data.multi.affinity)
        {
        case CVY_AFFINITY_NONE:
            szAffinity = L"NONE";
            break;
        case CVY_AFFINITY_SINGLE:
            szAffinity = L"SINGLE";
            break;
        case CVY_AFFINITY_CLASSC:
            szAffinity = L"CLASSC";
            break;
        default:
            goto end; // bad parse
        }
        break;
    case CVY_NEVER:
        szMode = L"DISABLED";
        break;
    default:
        goto end; // bad parse
    }

    *pString = 0;
    hr = StringCchPrintf(
        pString,
        cchString,
        L"ip=%ws protocol=%ws start=%u end=%u mode=%ws ",
        pPr->virtual_ip_addr,
        szProtocol,
        pPr->start_port,
        pPr->end_port,
        szMode
        );

    if (hr != S_OK)
    {
        goto end; // not enough space.
    }

    UINT Len = wcslen(pString);
    if (Len >= (cchString-1))
    {
        goto end; // not enough space to add anything else
    }

    if (pPr->mode == CVY_MULTI)
    {
        if (pPr->mode_data.multi.equal_load)
        {
            hr = StringCchPrintf(
                pString+Len,
                (cchString-Len),
                L"affinity=%ws",
                szAffinity
                );
        }
        else
        {
            hr = StringCchPrintf(
                pString+Len,
                (cchString-Len),
                L"affinity=%ws load=%u",
                szAffinity,
                pPr->mode_data.multi.load
                );
        }
    }
    else if (pPr->mode == CVY_SINGLE)
    {
            hr = StringCchPrintf(
                pString+Len,
                (cchString-Len),
                L"priority=%u",
                pPr->mode_data.single.priority
                );
    }

    if (hr == S_OK)
    {
        fRet = TRUE;
    }


end:

    return fRet;
}

BOOL
CfgUtilsSetPortRuleString(
    IN LPCWSTR pString,
    OUT PWLBS_PORT_RULE pPr
    )
{
//
//  Look for following name=value pairs
//
//      ip=1.1.1.1
//      protocol=[TCP|UDP|BOTH]
//      start=122
//      end=122
//      mode=[SINGLE|MULTIPLE|DISABLED]
//      affinity=[NONE|SINGLE|CLASSC]
//      load=80
//      priority=1"
//

    #define INVALID_VALUE ((DWORD)-1)
    LPWSTR psz = NULL;
    WCHAR szCleanedString[2*NLB_MAX_PORT_STRING_SIZE];
    WCHAR c;
    BOOL fRet = FALSE;
    DWORD protocol= INVALID_VALUE;
    DWORD start_port= INVALID_VALUE;
    DWORD end_port= INVALID_VALUE;
    DWORD mode= INVALID_VALUE;
    DWORD affinity= INVALID_VALUE;
    DWORD load= INVALID_VALUE;
    DWORD priority= INVALID_VALUE;

    ZeroMemory(pPr, sizeof(*pPr));

    //
    // Set szCleanedString  to be a version of pString in "canonical" form:
    // extraneous whitespace stripped out and whitspace represented by a
    // single '\b' character.
    {
        UINT Len = wcslen(pString);
        if (Len > (sizeof(szCleanedString)/sizeof(WCHAR)))
        {
            goto end;
        }
        ARRAYSTRCPY(szCleanedString, pString);

        //
        // convert different forms of whitespace into blanks
        //
        for (psz=szCleanedString; (c=*psz)!=0; psz++)
        {
            if (c == ' ' || c == '\t' || c == '\n')
            {
                *psz = ' ';
            }
        }

        //
        // convert runs of whitespace into a single blank
        // also get rid of initial whitespace
        //
        LPWSTR psz1 = szCleanedString;
        BOOL fRun = TRUE; // initial value of TRUE gets rid of initial space
        for (psz=szCleanedString; (c=*psz)!=0; psz++)
        {
            if (c == ' ')
            {
                if (fRun)
                {
                    continue;
                }
                else
                {
                    fRun = TRUE;
                }
            }
            else if (c == '=')
            {
                if (fRun)
                {
                    //
                    // The '=' was preceed by whitespace -- delete that
                    // whitespace. We keep fRun TRUE so subsequent whitespace
                    // is eliminated.
                    //
                    if (psz1 == szCleanedString)
                    {
                        // we're just starting, and we get an '=' -- bad
                        goto end;
                    }
                    psz1--;
                    if (*psz1 != ' ')
                    {
                        ASSERT(*psz1 == '=');
                        goto end; // two equals in a row, not accepted!
                    }
                }
            }
            else // non blank and non '=' chracter
            {
                fRun = FALSE;
            }
            *psz1++ = c;
        }
        *psz1=0;
    }

    // wprintf(L"CLEANED: \"%ws\"\n", szCleanedString);

    //
    // Now actually do the parse.
    //
    psz = szCleanedString;
    while(*psz!=0)
    {
        WCHAR Name[32];
        WCHAR Value[32];

        // 
        // Look for the Name in Name=Value pair.
        //
        if (swscanf(psz, L"%16[a-zA-Z]=%16[0-9.a-zA-Z]", Name, Value) != 2)
        {
            // bad parse;
            goto end;
        }

        //
        // Skip past the name=value pair -- it contains no blanks
        //
        for (; (c=*psz)!=NULL; psz++)
        {
           if (c==' ')
           {
             psz++; // to skip past the blank
             break;
           }
        }


        //
        // Now look for the specific name/values
        //
        //      ip=1.1.1.1
        //      protocol=[TCP|UDP|BOTH]
        //      start=122
        //      end=122
        //      mode=[SINGLE|MULTIPLE|DISABLED]
        //      affinity=[NONE|SINGLE|CLASSC]
        //      load=80
        //      priority=1"
        //
        if (!_wcsicmp(Name, L"ip"))
        {
            if (swscanf(Value, L"%15[0-9.]", pPr->virtual_ip_addr) != 1)
            {
                goto end;
            }
        }
        else if (!_wcsicmp(Name, L"protocol"))
        {
            if (!_wcsicmp(Value, L"TCP"))
            {
                protocol = CVY_TCP;
            }
            else if (!_wcsicmp(Value, L"UDP"))
            {
                protocol = CVY_UDP;
            }
            else if (!_wcsicmp(Value, L"BOTH"))
            {
                protocol = CVY_TCP_UDP;
            }
            else
            {
                // bad parse;
                goto end;
            }
        }
        else if (!_wcsicmp(Name, L"protocol"))
        {
        }
        else if (!_wcsicmp(Name, L"start"))
        {
            if (swscanf(Value, L"%u", &start_port)!=1)
            {
                // bad parse;
                goto end;
            }
            if (start_port > 65535)
            {
                // bad parse;
                goto end;
            }
        }
        else if (!_wcsicmp(Name, L"end"))
        {
            if (swscanf(Value, L"%u", &end_port)!=1)
            {
                // bad parse;
                goto end;
            }
            if (end_port > 65535)
            {
                // bad parse;
                goto end;
            }
        }
        else if (!_wcsicmp(Name, L"mode"))
        {
            if (!_wcsicmp(Value, L"SINGLE"))
            {
                mode = CVY_SINGLE;
            }
            else if (!_wcsicmp(Value, L"MULTIPLE"))
            {
                mode = CVY_MULTI;
            }
            else if (!_wcsicmp(Value, L"DISABLED"))
            {
                mode = CVY_NEVER;
            }
            else
            {
                // bad parse;
                goto end;
            }
        }
        else if (!_wcsicmp(Name, L"affinity"))
        {
            if (!_wcsicmp(Value, L"NONE"))
            {
                affinity = CVY_AFFINITY_NONE;
            }
            else if (!_wcsicmp(Value, L"SINGLE"))
            {
                affinity = CVY_AFFINITY_SINGLE;
            }
            else if (!_wcsicmp(Value, L"CLASSC"))
            {
                affinity = CVY_AFFINITY_CLASSC;
            }
            else
            {
                // bad parse;
                goto end;
            }
        }
        else if (!_wcsicmp(Name, L"load"))
        {
            if (swscanf(Value, L"%u", &load)!=1)
            {
                if (load > 100)
                {
                    // bad parse;
                    goto end;
                }
            }
        }
        else if (!_wcsicmp(Name, L"priority"))
        {
            if (swscanf(Value, L"%u", &priority)!=1)
            {
                if (priority > 31)
                {
                    // bad parse;
                    goto end;
                }
            }
        }
        else
        {
            // bad parse
            goto end;
        }
        // printf("SUCCESSFUL PARSE: %ws = %ws\n", Name, Value);
    }


    //
    // Set up the PARAMS structure, doing extra parameter validation along the
    // way.
    //
    switch(mode)
    {
        case CVY_SINGLE:

            if (load != INVALID_VALUE || affinity != INVALID_VALUE)
            {
                goto end; // bad parse;
            }
            if ((priority < CVY_MIN_PRIORITY) || (priority > CVY_MAX_PRIORITY))
            {
                goto end; // bad parse
            }
            pPr->mode_data.single.priority = priority;
            break;

        case CVY_MULTI:

            if (priority != INVALID_VALUE)
            {
                goto end; // bad parse;
            }

            switch(affinity)
            {
            case CVY_AFFINITY_NONE:
                break;
            case CVY_AFFINITY_SINGLE:
                break;
            case CVY_AFFINITY_CLASSC:
                break;
            case INVALID_VALUE:
            default:
                goto end; // bad parse;
            }

            pPr->mode_data.multi.affinity = affinity;

            if (load == INVALID_VALUE)
            {
                // this means it's unassigned, which means equal.
                pPr->mode_data.multi.equal_load = 1;
            }
            else if (load > CVY_MAX_LOAD)
            {
                goto end; // bad parse
            }
            else
            {
                pPr->mode_data.multi.load = load;
            }
            break;

        case CVY_NEVER:

            if (load != INVALID_VALUE || affinity != INVALID_VALUE 
                || priority != INVALID_VALUE)
            {
                goto end; // bad parse;
            }
            break;

        case INVALID_VALUE:
        default:
            goto end; // bad parse;

    }

    pPr->mode = mode;
    pPr->end_port = end_port;
    pPr->start_port = start_port;
    pPr->protocol = protocol;


    fRet = TRUE;

end:

    return fRet;
}


//
// Attempts to resolve the ip address and ping the host.
//
WBEMSTATUS
CfgUtilPing(
    LPCWSTR szBindString,
    UINT    Timeout, // In milliseconds.
    OUT ULONG  *pResolvedIpAddress // in network byte order.
    )
{
    WBEMSTATUS Status = WBEM_E_INVALID_PARAMETER;
    UINT w32Status = ERROR_SUCCESS;
    LONG inaddr;
    char rgchBindString[1024];
    TRACE_INFO("->%!FUNC!(BindString=%ws)", szBindString);

    *pResolvedIpAddress = 0;

    //
    // Convert to ANSI.
    //
    {
        UINT u = wcslen(szBindString);
        if (u >= (sizeof(rgchBindString)/sizeof(rgchBindString[0])))
        {
            Status = WBEM_E_INVALID_PARAMETER;
            goto end;
        }
        do
        {
            rgchBindString[u] = (char) szBindString[u];

        } while (u--);
    }

    //
    // Resolve to an IP address...
    //
    inaddr = inet_addr(rgchBindString);
    if (inaddr == -1L)
    {
        struct hostent *hostp = NULL;
        hostp = gethostbyname(rgchBindString);
        if (hostp) {
            unsigned char *pc = (unsigned char *) & inaddr;
            // If we find a host entry, set up the internet address
            inaddr = *(long *)hostp->h_addr;
            TRACE_VERB(
                L"%!FUNC! Resolved %ws to IP address %d.%d.%d.%d.\n",
                szBindString,
                pc[0],
                pc[1],
                pc[2],
                pc[3]
                );
        } else {
            // Neither dotted, not name.
            w32Status = WSAGetLastError();
            TRACE_CRIT(L"%!FUNC! WSA error 0x%08lx resolving address %ws.",
                    w32Status, szBindString);
            goto end;
        }
    }
    
    *pResolvedIpAddress = (ULONG) inaddr;


    //
    //
    //
    if (g_CfgUtils.DisablePing())
    {
        TRACE_INFO(L"%!FUNC!: ICMP ping disabled, so not actually pinging.");
        Status = WBEM_NO_ERROR;
        goto end;
    }

    //
    // Send Icmp echo.
    //
    HANDLE  IcmpHandle;

    IcmpHandle = IcmpCreateFile();
    if (IcmpHandle == INVALID_HANDLE_VALUE) {
        w32Status = GetLastError();
        TRACE_CRIT(L"%!FUNC! Unable to contact IP driver, error code %d.",w32Status);
        goto end;
    }

    const int MinInterval = 500;

    while (Timeout)
    {
        static BYTE SendBuffer[32];
        BYTE RcvBuffer[1024];
        int  numberOfReplies;
        numberOfReplies = IcmpSendEcho2(IcmpHandle,
                                        0,
                                        NULL,
                                        NULL,
                                        inaddr,
                                        SendBuffer,
                                        sizeof(SendBuffer),
                                        NULL,
                                        RcvBuffer,
                                        sizeof(RcvBuffer),
                                        MinInterval
                                        );

        if (numberOfReplies == 0) {

            int errorCode = GetLastError();
            TRACE_INFO(L"%!FUNC! Got no replies yet; ICMP Error %d", errorCode);

        
            if (Timeout > MinInterval)
            {
                Timeout -= MinInterval;
                // TODO: look at ping sources for proper error reporting
                // (host unreachable, etc...)
    
                Sleep(MinInterval);
            }
            else
            {
                Timeout = 0;
            }

        }
        else
        {
            Status = WBEM_NO_ERROR;
            break;
        }
    }

end:

    TRACE_INFO("<-%!FUNC! returns 0x%08lx", Status);
    return Status;
}



//
// Validates a network address
//
WBEMSTATUS
CfgUtilsValidateNetworkAddress(
    IN  LPCWSTR szAddress,        // format: "10.0.0.1[/255.0.0.0]"
    OUT PUINT puIpAddress,        // in network byte order
    OUT PUINT puSubnetMask,       // in network byte order (0 if unspecified)
    OUT PUINT puDefaultSubnetMask // depends on class: 'a', 'b', 'c', 'd', 'e'
    )
{
    WBEMSTATUS Status = WBEM_E_INVALID_PARAMETER;
    UINT w32Status = ERROR_SUCCESS;
    UINT uIpAddress=0;
    UINT uSubnetMask=0;
    UINT uDefaultSubnetMask=0;
    char rgchBindString[32];
    char *szIpAddress = rgchBindString;
    char *szSubnetMask = NULL;

    //
    // Take care of the fact that the following two args could be NULL
    //
    if (puSubnetMask == NULL)
    {
       puSubnetMask = &uSubnetMask;
    }
    if (puDefaultSubnetMask == NULL)
    {
       puDefaultSubnetMask = &uDefaultSubnetMask;
    }
    
    *puIpAddress = 0;
    *puSubnetMask = 0;
    *puDefaultSubnetMask = 0;

    //
    // Convert to ANSI.
    //
    {
        UINT u = wcslen(szAddress);
        if (u >= (sizeof(rgchBindString)/sizeof(rgchBindString[0])))
        {
            goto end;
        }
        
        do
        {
            char c =  (char) szAddress[u];

            //
            // NOTE: We're counting down. Last time through, c is 0.
            //

            //
            // We split up the network address into the ip address portion
            // and the subnet portion.
            //
            if (c == '/')
            {
                if (szSubnetMask != NULL)
                {
                    // multiple '/'s -- not good!
                    goto end;
                }

                szSubnetMask = &rgchBindString[u+1];
                c = 0;
            }

            rgchBindString[u] = c;

        } while (u--);
    }

    //
    // Get the UINT version of ip address and subnet.
    //
    uIpAddress = inet_addr(szIpAddress);
    if (szSubnetMask == NULL)
    {
        szSubnetMask = "";
    }
    uSubnetMask = inet_addr(szSubnetMask);


    //
    // Parameter validation...
    //
    {
        if (uIpAddress==0 || uIpAddress == INADDR_NONE)
        {
            // ip address null, or invalid
            goto end;
        }

        if (*szSubnetMask != 0 && uSubnetMask == INADDR_NONE)
        {
            // ip subnet specified, but invalid
            goto end;
        }

        //
        // Classify IP address 'a', 'b', 'c', 'd'
        //
        {
            //
            // Get msb byte in network byte order
            //
            unsigned char uc = (unsigned char) (uIpAddress & 0xff);
            if ((uc & 0x80) == 0)
            {
                // class A
                uDefaultSubnetMask  = 0x000000ff; // network order
            }
            else if (( uc & 0x40) == 0)
            {
                // class B
                uDefaultSubnetMask  = 0x0000ffff; // network order
            }
            else if (( uc & 0x20) == 0)
            {
                // class C
                uDefaultSubnetMask  = 0x00ffffff; // network order
            }
            else
            {
                // class D or E
                uDefaultSubnetMask  = 0;
            }
        }
    }
    *puIpAddress = uIpAddress;
    *puSubnetMask = uSubnetMask;
    *puDefaultSubnetMask = uDefaultSubnetMask;


    Status = WBEM_NO_ERROR;

end:

    return Status;
}

/*
    This function enables the "SeLoadDriverPrivilege" privilege (required to load/unload device driver)
    in the access token.

    What is the need for this function?
    The setup/pnp apis called by the nlb manager's wmi provider to bind/unbind NLB to the nic, require that the 
    "SeLoadDriverPrivilege" privilege be present AND enabled in the access token of the thread. 
    
    Why is this funcion placed here (in the client) instead of the provider?
    RPC not merely disables, but removes all privileges that are NOT enabled in the client and only passes along 
    to the server (ie. provider), those privileges that are enabled. Since "SeLoadDriverPrivilege" is not enabled
    by default, RPC would not pass this privilege along to the provider. So, if this function was placed in the 
    provider, it would fail because the privilege is NOT present to be enabled.

    This privilege needs to be enabled only when the server is located in the same machine as the client. When, the
    server is remote, it was observed that the "SeLoadDriverPrivilege" privilege is enabled by default.

    NOTE: When called by a non-admin, this function will fail because this privilege is not assigned to non-admins 
          and hence, can not be enabled. 
    --KarthicN, 5/7/02
*/

BOOL CfgUtils_Enable_Load_Unload_Driver_Privilege(VOID)
{
    HANDLE TokenHandle;
    TOKEN_PRIVILEGES TP;
    LUID  Luid;
    DWORD dwError;

    TRACE_INFO("->%!FUNC!");

    // Look up the LUID for "SeLoadDriverPrivilege"
    if (!LookupPrivilegeValue(NULL,                // lookup privilege on local system
                              SE_LOAD_DRIVER_NAME, // "SeLoadDriverPrivilege" : Load and unload device drivers
                              &Luid))              // receives LUID of privilege
    {
        TRACE_CRIT("%!FUNC! LookupPrivilegeValue() failed with error = %u", GetLastError() ); 
        TRACE_INFO("<-%!FUNC! Returning FALSE");
        return FALSE; 
    }

    // Get a handle to the process access token.
    if (!OpenProcessToken(GetCurrentProcess(),
                          TOKEN_ADJUST_PRIVILEGES,
                          &TokenHandle))
    {
        TRACE_CRIT("%!FUNC! OpenProcessToken() for TOKEN_ADJUST_PRIVILEGES failed with error = %u", GetLastError());
        TRACE_INFO("<-%!FUNC! Returning FALSE");
        return FALSE; 
    }

    TP.PrivilegeCount = 1;
    TP.Privileges[0].Luid = Luid;
    TP.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    // Enable the "SeLoadDriverPrivilege" privilege.
    AdjustTokenPrivileges(TokenHandle, 
                          FALSE, 
                          &TP, 
                          sizeof(TOKEN_PRIVILEGES), 
                          NULL,
                          NULL);

    // Call GetLastError to determine whether the function succeeded.
    dwError = GetLastError();
    if (dwError != ERROR_SUCCESS) 
    { 
        TRACE_CRIT("%!FUNC! AdjustTokenPrivileges() failed with error = %u", dwError ); 
        CloseHandle(TokenHandle);
        TRACE_INFO("<-%!FUNC! Returning FALSE");
        return FALSE; 
    } 

    CloseHandle(TokenHandle);

    TRACE_INFO("<-%!FUNC! Returning TRUE");
    return TRUE;
}

USHORT crc16(LPCWSTR ptr)
{
    int crc = 0;                    // Holds CRC
    int i;                          //
    int count;                      // holds len

    count = wcslen(ptr);
    while(--count >= 0) {
        i = *ptr;
        // make all uppercase // ((case insens))
        i = ((i >= 'a') && (i <= 'z')) ? (i-32) : i;
        crc = crc ^ (i << 8);
        ptr++;
        for (i=0; i<8; ++i)
            if (crc & 0x8000)
                crc = (crc << 1) ^ 0x1021;
            else
                crc = crc << 1;
    }
    return (crc & 0xffff);
}

WBEMSTATUS
get_friendly_name_from_registry(
    LPCWSTR szGuid,
    LPWSTR *pszFriendlyName
    )
{
    WBEMSTATUS wStat = WBEM_E_NOT_FOUND;
    HKEY        hkNetwork = NULL;
    WCHAR       adapter[200];
    int         ret;
    wchar_t     data[200];

    *pszFriendlyName = NULL;

    ret = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            L"SYSTEM\\CurrentControlSet\\Control\\Network",
            0,
            KEY_READ,
            &hkNetwork
            );

    if (ret != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! RegOpenKeyEx(Network) fails with err %lu", ret);
        hkNetwork = NULL;
        goto end;
    }

    *adapter=0;

#if OBSOLETE
    for (int num=0; 1; num++)
    {
        HKEY        hk=NULL;
        FILETIME    time;

        *adapter=0;

        DWORD dwDataBuffer=200;
        ret=RegEnumKeyEx(
                    hkNetwork,
                    num,
                    adapter,
                    &dwDataBuffer,
                    NULL,
                    NULL,
                    NULL,
                    &time);
        if ((ret!=ERROR_SUCCESS) && (ret!=ERROR_MORE_DATA)) 
        {
            if (ret != ERROR_NO_MORE_ITEMS)
            {
                TRACE_CRIT("%!FUNC! RegEnumKey(Network) returns error %lu", ret);
                wStat = WBEM_E_CRITICAL_ERROR;
            }
            else 
            {
                wStat = WBEM_E_NOT_FOUND;
            }
            break;
        }

        //
        // open the items one by one
        //
        ret=RegOpenKeyEx(hkNetwork, adapter, 0, KEY_READ, &hk);
        if (ret == ERROR_SUCCESS)
        {
            DWORD dwValueType=REG_SZ;
            dwDataBuffer=200;

            *data = 0;

            ret = RegQueryValueEx(
                    hk,
                    L"",
                    0,
                    &dwValueType,
                    (LPBYTE)data,
                    &dwDataBuffer
                    );

            RegCloseKey(hk);

            if (ret == ERROR_SUCCESS)
            {
                if (_wcsicmp(L"Network Adapters", data)==0)
                {
                    //
                    // Found it!
                    //
                    break;
                }
            }
        }
    }
#endif // OBSOLETE
    ARRAYSTRCPY(adapter, L"{4D36E972-E325-11CE-BFC1-08002BE10318}");


    if (*adapter!=0)
    {
        HKEY hk = NULL;
        wchar_t path[200];
        //
        // found the guid now
        // look for friendly nic name
        //
    
        StringCbPrintf(path, sizeof(path), L"%ws\\%ws\\Connection", adapter, szGuid);
        ret=RegOpenKeyEx(hkNetwork, path, 0, KEY_READ, &hk);
        if (ret != ERROR_SUCCESS)
        {
            TRACE_CRIT("%!FUNC! Error %lu trying to open path %ws", ret, path);
        }
        else
        {
            DWORD dwDataBuffer=200;
            DWORD dwValueType=REG_SZ;

            *data = 0;

            ret = RegQueryValueEx(
                    hk,
                    L"Name",
                    0,
                    &dwValueType,
                    (LPBYTE)data,
                    &dwDataBuffer
                    );

            RegCloseKey(hk);

            if(ret != ERROR_SUCCESS)
            {
                TRACE_CRIT("%!FUNC! Error %lu trying to query Name value on path %ws", ret, path);
            }
            else
            {
                //
                // We're done!
                //
                TRACE_CRIT("%!FUNC! Found friendly name: \"%ws\"", data);
                LPWSTR szName = new WCHAR[(dwDataBuffer+1)/sizeof(WCHAR)];
                if (szName == NULL)
                {
                    TRACE_CRIT("%!FUNC! Allocation failure!");
                    wStat = WBEM_E_OUT_OF_MEMORY;
                }
                else
                {
                    // note -- dwDataBuffer includes space for ending null.
                    CopyMemory(szName, data, dwDataBuffer);
                    *pszFriendlyName = szName;
                    wStat = WBEM_NO_ERROR;
                }
            }
        }
    }

end:

    if (hkNetwork!=NULL)
    {
        RegCloseKey(hkNetwork);
    }

    return wStat;
}

#define STATUS_SUCCESS 0

BOOL
CfgUtilEncryptPassword(
    IN  LPCWSTR szPassword,
    OUT UINT    cchEncPwd,  // size in chars of szEncPwd, inc space for ending 0
    OUT LPWSTR  szEncPwd
    )
{
    //
    // Note -- buffer passed to RtlEncrypt/DecryptMemory must be
    // multiples of RTL_ENCRYPT_MEMORY_SIZE -- so we must round them up
    // appropriately.
    //

    BOOL fRet = FALSE;
    UINT uLen = wcslen(szPassword);
    UINT uEncryptCb = (uLen+1)*sizeof(WCHAR);
    WCHAR rgPasswordCopy[64];

    // Round up if required...
    {
        UINT mod =  uEncryptCb % RTL_ENCRYPT_MEMORY_SIZE;
        if (mod != 0)
        {
            uEncryptCb += (RTL_ENCRYPT_MEMORY_SIZE - mod);
        };
    }

    ASSERT((uEncryptCb % RTL_ENCRYPT_MEMORY_SIZE)==0);

    if (uEncryptCb > sizeof(rgPasswordCopy))
    {
        // 
        // szPassword is too large for our internal buffer ... bail
        //
        fRet = FALSE;
        goto end;
    }

    // 
    // We're going to expand the encrypted password to make it 
    // printable -- so we require 2 chars for every byte
    // of encrypted data. Also need the space for ending NULL char.
    // Check if we have enough space...
    //
    if (2*uEncryptCb >= cchEncPwd)
    {
        // Nah, bail...
        fRet = FALSE;
        goto end;
    }

    RtlSecureZeroMemory(rgPasswordCopy, sizeof(rgPasswordCopy));
    ARRAYSTRCPY(rgPasswordCopy, szPassword);

    NTSTATUS ntStat;
    ntStat = RtlEncryptMemory (rgPasswordCopy, uEncryptCb, 0);
    if (ntStat != STATUS_SUCCESS)
    {
        TRACE_CRIT(L"%!FUNC! RtlEncryptMemory fails with ntStat 0x%lx", ntStat);
        fRet = FALSE;
        goto end;
    }

    //
    // Now we expand the encrypted password
    //
    {
        UINT u;
        for (u=0;u<uEncryptCb;u++)
        {
            //
            // In this loop, we treat rgPasswordCopy of a BYTE array of 
            // length uEncryptCb...
            //
            BYTE b = ((BYTE*)rgPasswordCopy)[u];
            szEncPwd[2*u] = 'a' + ((b & 0xf0) >> 4);
            szEncPwd[2*u+1] = 'a' + (b & 0xf);
        }
        ASSERT(2*u < cchEncPwd); // We already check this earlier...
        szEncPwd[2*u]=0;
    }

    fRet = TRUE;

end:

    return fRet;
}


BOOL
CfgUtilDecryptPassword(
    IN  LPCWSTR szEncPwd,
    OUT UINT    cchPwd,  // size in chars of szPwd, inc space for ending 0
    OUT LPWSTR  szPwd
    )
{
    BOOL fRet = FALSE;
    UINT uEncLen = wcslen(szEncPwd);
    UINT cbEncPwd = uEncLen/2; // Length, in bytes, of binary form of enc pwd.

    if (uEncLen == 0 || cchPwd == 0)
    {
        //
        // Encrypted pwd and cchPwd must be non-zero, 
        // 
        fRet = FALSE;
        goto end;
    }

    //
    // uEncLen is twice the number of BYTES in the binary form of the
    // encrypted password, and the latter number sould be a multiple
    // of  RTL_ENCRYPT_MEMORY_SIZE. Let's check this.
    //
    if (uEncLen % (RTL_ENCRYPT_MEMORY_SIZE*2)!=0)
    {
        // It's not, so we bail.
        fRet = FALSE;
        goto end;
    }

    //
    // Make sure there is enough space in szPwd to store the 
    // binary form of the encrypted password (and the final form of
    // the decrypted password, which will include the ending NULL).
    //
    if (cbEncPwd > cchPwd*sizeof(WCHAR))
    {
        // bail
        fRet = FALSE;
        goto end;
    }

    RtlSecureZeroMemory(szPwd, cchPwd*sizeof(WCHAR));
    //
    // Now let's translate the printable version of the encrypted password
    // to the binary version...
    //
    {
        UINT u;
        for (u=0; u<cbEncPwd; u++)
        {
            BYTE b;
            b = (BYTE) (szEncPwd[2*u] - 'a');
            b <<= 4;
            b |= (BYTE) (szEncPwd[2*u+1] - 'a');

            ((BYTE*)szPwd)[u] = b;
        }
        ASSERT(u<2*cchPwd);
    }


    NTSTATUS ntStat;
    ntStat = RtlDecryptMemory (szPwd, cbEncPwd, 0);
    if (ntStat != STATUS_SUCCESS)
    {
        TRACE_CRIT(L"%!FUNC! RtlEncryptMemory fails with ntStat 0x%lx", ntStat);
        fRet = FALSE;
        goto end;
    }

    //
    // At this point, the decrypted pwd MUST be null terminated, or we
    // have some error. Note also that we have pre-zeroed out szPwd on entry,
    // and checked that cchPwd is non zero.
    //
    if (szPwd[cchPwd-1] != 0)
    {
        // bad decryption...
        fRet = FALSE;
    }

    fRet = TRUE;


end:
    return fRet;
}

//
// Sets pfMSCSInstalled to TRUE if MSCS is installed, FALSE otherwise.
// Returns TRUE on success, FALSE otherwise.
//
BOOL
CfgUtilIsMSCSInstalled(VOID)
{
    BOOL fRet = FALSE;
    typedef DWORD (CALLBACK* LPFNGNCS)(LPCWSTR,DWORD*);
    LPFNGNCS pfnGetNodeClusterState = NULL;
    HINSTANCE hDll = NULL;
    DWORD dwClusterState = 0;

    hDll = LoadLibrary(L"clusapi.dll");
    if (NULL == hDll)
    {
        TRACE_CRIT("%!FUNC! Load clusapi.dll failed with %d", GetLastError());
        goto end;
    }

    pfnGetNodeClusterState = (LPFNGNCS) GetProcAddress(
                                            hDll,
                                            "GetNodeClusterState"
                                            );

    if (NULL == pfnGetNodeClusterState)
    {
        TRACE_CRIT("%!FUNC! GetProcAddress(GetNodeClusterState) failed with error %d", GetLastError());
        goto end;
    }

    if (ERROR_SUCCESS == pfnGetNodeClusterState(NULL, &dwClusterState))
    {
        if (    ClusterStateNotRunning == dwClusterState
             || ClusterStateRunning == dwClusterState)
        {
            fRet = TRUE;
            TRACE_INFO("%!FUNC! MSCS IS installed.");
        }
        else
        {
             // MSCS is not installed. That's good!
            TRACE_INFO("%!FUNC! MSCS Cluster state = %lu (assumed not installed)",
                dwClusterState);
        }
    }
    else
    {
       TRACE_CRIT("%!FUNC! error getting MSCS cluster state.");
    }

    (void) FreeLibrary(hDll);

end:

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\cfgutillib\extcfg.cpp ===
//***************************************************************************
//
//  EXTCFG.CPP
// 
//  Module: WMI Framework Instance provider 
//
//  Purpose: Low-level utilities to configure NICs -- bind/unbind,
//           get/set IP address lists, and get/set NLB cluster params.
//
//  Copyright (c)2001 Microsoft Corporation, All Rights Reserved
//
//  History:
//
//  04/05/01    JosephJ Created (original version, from updatecfg.cpp under
//                nlbmgr\provider).
//  07/23/01    JosephJ Moved functionality to lib.
//
//***************************************************************************
#include "private.h"
#include "extcfg.tmh"

//
// NLBUPD_MAX_NETWORK_ADDRESS_LENGTH is the max number of chars (excluding
// the terminating 0) of a string of the form "ip-addr/subnet", eg:
// "10.0.0.1/255.255.255.0"
//
#define NLBUPD_MAX_NETWORK_ADDRESS_LENGTH \
    (WLBS_MAX_CL_IP_ADDR + 1 + WLBS_MAX_CL_NET_MASK)


LPWSTR *
allocate_string_array(
    UINT NumStrings,
    UINT StringLen      //  excluding ending NULL
    );

WBEMSTATUS
address_string_to_ip_and_subnet(
    IN  LPCWSTR szAddress,
    OUT LPWSTR  szIp, // max WLBS_MAX_CL_IP_ADDR
    OUT LPWSTR  szSubnet // max WLBS_MAX_CL_NET_MASK
    );

WBEMSTATUS
ip_and_subnet_to_address_string(
    IN  LPCWSTR szIp,
    IN  LPCWSTR szSubnet,
    IN  UINT    cchAddress, // length in chars, including NULL.
    OUT LPWSTR  szAddress // max  NLBUPD_MAX_NETWORK_ADDRESS_LENGTH
                         // + 1 (for NULL)
    );

VOID
uint_to_szipaddr(
    UINT uIpAddress,   // Ip address or subnet -- no validation, network order
    UINT cchLen,
    WCHAR *rgAddress   // Expected to be at least 17 chars long
    );

const NLB_IP_ADDRESS_INFO *
find_ip_in_ipinfo(
        LPCWSTR szIpToFind,
        const NLB_IP_ADDRESS_INFO *pIpInfo,
        UINT NumIpInfos
        );

NLBERROR
NLB_EXTENDED_CLUSTER_CONFIGURATION::AnalyzeUpdate(
        IN  OUT NLB_EXTENDED_CLUSTER_CONFIGURATION *pNewCfg,
        OUT BOOL *pfConnectivityChange
        )
//
//  NLBERR_NO_CHANGE -- update is a no-op.
// 
//  Will MUNGE pNewCfg -- munge NlbParams and also
//  fill out pIpAddressInfo if it's NULL.
//
{
    NLBERROR nerr = NLBERR_INVALID_CLUSTER_SPECIFICATION;
    BOOL fConnectivityChange = FALSE;
    BOOL fSettingsChanged = FALSE;
    UINT NumIpAddresses = 0;
    NLB_IP_ADDRESS_INFO *pNewIpInfo = NULL;
    const NLB_EXTENDED_CLUSTER_CONFIGURATION *pOldCfg = this;
    UINT u;
    LPCWSTR szFriendlyName = m_szFriendlyName;

    if (szFriendlyName == NULL)
    {
        szFriendlyName = L"";
    }


    if (pOldCfg->fBound && !pOldCfg->fValidNlbCfg)
    {
        //
        // We're starting with a bound but invalid cluster state -- all bets are
        // off.
        //
        fConnectivityChange = TRUE;
        TRACE_CRIT("Analyze: Choosing Async because old state is invalid %ws", szFriendlyName);
    }
    else if (pOldCfg->fBound != pNewCfg->fBound)
    {
        //
        //  bound/unbound state is different -- we do async
        //
        fConnectivityChange = TRUE;

        if (pNewCfg->fBound)
        {
            TRACE_CRIT("Analyze: Request to bind NLB to %ws", szFriendlyName);
        }
        else
        {
            TRACE_CRIT("Analyze: Request to unbind NLB from %ws", szFriendlyName);
        }
    }
    else
    {
        if (pNewCfg->fBound)
        {
            TRACE_CRIT("Analyze: Request to change NLB configuration on %ws", szFriendlyName);
        }
        else
        {
            TRACE_CRIT("Analyze: NLB not bound and to remain not bound on %ws", szFriendlyName);
        }
    }

    if (pNewCfg->fBound)
    {
        const WLBS_REG_PARAMS   *pOldParams = NULL;

        if (pOldCfg->fBound)
        {
            pOldParams = &pOldCfg->NlbParams;
        }

        //
        // We may have been bound before and we remain bound, let's check if we
        // still need to do async, and also vaidate pNewCfg wlbs params in the
        // process
        //

        WBEMSTATUS
        TmpStatus = CfgUtilsAnalyzeNlbUpdate(
                    pOldParams,
                    &pNewCfg->NlbParams,
                    &fConnectivityChange
                    );
    
        if (FAILED(TmpStatus))
        {
            TRACE_CRIT("Analyze: Error analyzing nlb params for %ws", szFriendlyName);
            switch(TmpStatus)
            {

            case WBEM_E_INVALID_PARAMETER:
                nerr = NLBERR_INVALID_CLUSTER_SPECIFICATION;
                break;

            case  WBEM_E_INITIALIZATION_FAILURE:
                nerr = NLBERR_INITIALIZATION_FAILURE;
                break;

            default:
                nerr = NLBERR_LLAPI_FAILURE;
                break;
            }
            goto end;
        }

        //
        // NOTE: CfgUtilsAnalyzeNlbUpdate can return WBEM_S_FALSE if
        // the update is a no-op. We should be careful to preserve this
        // on success.
        //
        if (TmpStatus == WBEM_S_FALSE)
        {
            //
            // Let's check if a new password has been specified...
            //
            if (pNewCfg->NewRemoteControlPasswordSet())
            {
                fSettingsChanged = TRUE;
            }
        }
        else
        {
            fSettingsChanged = TRUE;
        }

        //
        // Check the supplied list of IP addresses, to make sure that
        // includes the dedicated IP first and the cluster vip and the
        // per-port-rule vips.
        //

        NumIpAddresses = pNewCfg->NumIpAddresses;

        if ((NumIpAddresses == 0) != (pNewCfg->pIpAddressInfo == NULL))
        {
            // Bogus input
            TRACE_CRIT("Analze: mismatch between NumIpAddresses and pIpInfo");
            goto end;
        }

        nerr = NLBERR_INVALID_CLUSTER_SPECIFICATION;

        if (NumIpAddresses == 0)
        {
            BOOL fRet;
            NlbIpAddressList IpList;

            if (pOldCfg->fBound && pOldCfg->fValidNlbCfg)
            {
                //
                // NLB is currently bound with a valid configuration.
                //

                //
                // If we we're told to do so, we try to preserve
                // old IP addresses  as far as possible. So we start with the
                // old config, remove the old dedicated IP address (if present),
                // and primary VIP, and add the new dedicated IP address (if
                // present) and cluster vip. If subnet masks have changed for
                // these we update them.
                //
                // All other IP addresses are left intact.
                //
                //
                if (pNewCfg->fAddClusterIps)
                {

                    //
                    // Start with the original set of ip addresses.
                    //
                    fRet = IpList.Set(
                            pOldCfg->NumIpAddresses,
                            pOldCfg->pIpAddressInfo,
                            0
                            );
    
                    if (!fRet)
                    {
                        TRACE_CRIT("!FUNC!: IpList.Set (orig ips) failed");
                        goto end;
                    }
    
                    if (_wcsicmp(pNewCfg->NlbParams.cl_ip_addr,
                            pOldCfg->NlbParams.cl_ip_addr) )
                    {
                        //
                        // If the cluster IP has changed,
                        // remove the old cluster IP address.
                        //
                        // 1/25/02 josephj NOTE: we only do this
                        // if the cluster IP has CHANGED,
                        // otherwise, by taking it out, we lose it's position
                        // in the old config, so we may end up changing it's
                        // position unnecessarily (added the wcsicmp 
                        // check above today).
                        //
                        // We don't care if it fails.
                        //
                        (VOID) IpList.Modify(
                                pOldCfg->NlbParams.cl_ip_addr,
                                NULL,
                                NULL
                                );
                    }

                    //
                    // Remove the old dedicated IP address first 
                    // We don't care if this fails.
                    //
                    (VOID) IpList.Modify(
                                pOldCfg->NlbParams.ded_ip_addr,
                                NULL, // new ip address
                                NULL  // new subnet mask
                                );
                    
                }
            }

            if (pNewCfg->fAddClusterIps)             
            {
                //
                // Now add the new cluster Ip address
                //
                fRet = IpList.Modify(
                        NULL,
                        pNewCfg->NlbParams.cl_ip_addr,
                        pNewCfg->NlbParams.cl_net_mask
                        );

                if (!fRet)
                {
                    TRACE_CRIT("!FUNC!: IpList.Modify (new cl ip) failed");
                    goto end;
                }
            }
                    
            if (pNewCfg->fAddDedicatedIp)             
            {
                //
                // Add the new dedicated IP address --
                // to ensure when we add it, it's at the head of the list.
                //

                //
                // We won't add it if it is null, of course.
                //
                if (!pNewCfg->IsBlankDedicatedIp())
                {
                    fRet  = IpList.Modify(
                                NULL,
                                pNewCfg->NlbParams.ded_ip_addr,
                                pNewCfg->NlbParams.ded_net_mask
                                );
                    if (!fRet)
                    {
                        TRACE_CRIT("!FUNC!: IpList.Modify (new ded ip) failed");
                        goto end;
                    }
                }
            }



            //
            // Finally, set these new addresses.
            //
            pNewCfg->SetNetworkAddressesRaw(NULL,0);
            IpList.Extract(
                REF pNewCfg->NumIpAddresses,
                REF pNewCfg->pIpAddressInfo
                );
            nerr = NLBERR_OK; 

        } // End case that NumIpAddresses is zero.


        //
        // We're done munging IP addresses; Now get the latest
        // ip address info and count and make sure things look ok.
        //
        pNewIpInfo = pNewCfg->pIpAddressInfo;
        NumIpAddresses = pNewCfg->NumIpAddresses;
        nerr = NLBERR_INVALID_CLUSTER_SPECIFICATION;

        //
        // Check that dedicated ip address, if present is first.
        //
        if (pNewCfg->fAddDedicatedIp && !pNewCfg->IsBlankDedicatedIp())
        {

            if (NumIpAddresses == 0)
            {
                //
                // We don't expect to get here because of checks above, but
                // neverthless...
                //
                TRACE_CRIT("%!FUNC! address list unexpectedly zero");
                nerr = NLBERR_INTERNAL_ERROR;
                goto end;
            }

            if (_wcsicmp(pNewIpInfo[0].IpAddress, pNewCfg->NlbParams.ded_ip_addr))
            {
                TRACE_CRIT("%!FUNC! ERROR: dedicated IP address(%ws) is not first IP address(%ws)",
                    pNewCfg->NlbParams.ded_ip_addr, pNewIpInfo[0].IpAddress);
                goto end;
            }

            if (_wcsicmp(pNewIpInfo[0].SubnetMask, pNewCfg->NlbParams.ded_net_mask))
            {
                TRACE_CRIT("%!FUNC! ERROR: dedicated net mask(%ws) does not match IP net mask(%ws)",
                    pNewCfg->NlbParams.ded_net_mask, pNewIpInfo[0].SubnetMask);
                goto end;
            }

        }

        //
        // Check that cluster-vip is present
        //
        if (fAddClusterIps)
        {
            for (u=0; u< NumIpAddresses; u++)
            {
                if (!_wcsicmp(pNewIpInfo[u].IpAddress, pNewCfg->NlbParams.cl_ip_addr))
                {
                    //
                    // Found it! Check that the subnet masks match.
                    //
                    if (_wcsicmp(pNewIpInfo[u].SubnetMask, pNewCfg->NlbParams.cl_net_mask))
                    {
                        TRACE_CRIT("Cluster subnet mask doesn't match that in addr list");
                        goto end;
                    }
                    break;
                }
            }
            if (u==NumIpAddresses)
            {
                TRACE_CRIT("Cluster ip address(%ws) is not in the list of addresses!", pNewCfg->NlbParams.cl_ip_addr);
                goto end;
            }
            //
            // Check that per-port-rule vips are present.
            // TODO
            {
            }
            }

    }
    else
    {
        //
        // NLB is to be unbound.
        //
        NumIpAddresses = pNewCfg->NumIpAddresses;

        if (NumIpAddresses == 0 && pOldCfg->fBound && pOldCfg->fValidNlbCfg)
        {
            //
            // No ip addresses specified and we're currently bound.
            // If the DIP is present in the current
            // list of IP addresses, we keep it even after we unbind.
            //
            const NLB_IP_ADDRESS_INFO *pFoundInfo = NULL;
            pFoundInfo = find_ip_in_ipinfo(
                            pOldCfg->NlbParams.ded_ip_addr,
                            pOldCfg->pIpAddressInfo,
                            pOldCfg->NumIpAddresses
                            );
            if (pFoundInfo != NULL)
            {
                //
                // Found it -- let's take it.
                //
                BOOL fRet;
                NlbIpAddressList IpList;
                fRet = IpList.Set(1, pFoundInfo, 0);
                if (fRet)
                {
                    TRACE_VERB(
                        "%!FUNC! preserving dedicated ip address %ws on unbind",
                        pFoundInfo->IpAddress
                        );
                    IpList.Extract(
                        REF pNewCfg->NumIpAddresses,
                        REF pNewCfg->pIpAddressInfo
                        );
                }
            }
        }
        else
        {

            //
            // We don't do any checking on the supplied
            // list of IP addresses -- we assume caller knows best. Note that
            // if NULL
            // we switch to dhcp/autonet.
            //
        }

    }

    nerr = NLBERR_INVALID_CLUSTER_SPECIFICATION;
    //
    // If there's any change in the list of ipaddresses or subnets, including
    // a change in the order, we switch to async.
    //
    if (pNewCfg->NumIpAddresses != pOldCfg->NumIpAddresses)
    {
        TRACE_INFO("Analyze: detected change in list of IP addresses on %ws", szFriendlyName);
        fConnectivityChange = TRUE;
    }
    else
    {
        NLB_IP_ADDRESS_INFO *pOldIpInfo = NULL;

        //
        // Check if there is a change in the list of ip addresses or
        // their order of appearance.
        //
        NumIpAddresses = pNewCfg->NumIpAddresses;
        pOldIpInfo = pOldCfg->pIpAddressInfo;
        pNewIpInfo = pNewCfg->pIpAddressInfo;
        for (u=0; u<NumIpAddresses; u++)
        {
            if (   _wcsicmp(pNewIpInfo[u].IpAddress, pOldIpInfo[u].IpAddress)
                || _wcsicmp(pNewIpInfo[u].SubnetMask, pOldIpInfo[u].SubnetMask))
            {
                TRACE_INFO("Analyze: detected change in list of IP addresses on %ws", szFriendlyName);
                fConnectivityChange = TRUE;
                break;
            }
        }
    }
    nerr = NLBERR_OK; 


end:


    if (nerr == NLBERR_OK)
    {
        *pfConnectivityChange = fConnectivityChange;

        if (fConnectivityChange)
        {
            fSettingsChanged = TRUE;
        }

        if (fSettingsChanged)
        {
            nerr = NLBERR_OK;
        }
        else
        {
            nerr = NLBERR_NO_CHANGE;
        }
    }
    
    return  nerr;
}


WBEMSTATUS
NLB_EXTENDED_CLUSTER_CONFIGURATION::Update(
        IN  const NLB_EXTENDED_CLUSTER_CONFIGURATION *pCfgNew
        )
//
// Applies the properties in pCfgNew to this.
// Does NOT copy szNewRemoteControlPassword -- instead sets that field to NULL
//
{
    WBEMSTATUS Status;
    UINT NumIpAddresses  = pCfgNew->NumIpAddresses;
    NLB_IP_ADDRESS_INFO *pIpAddressInfo = NULL;
    NLB_EXTENDED_CLUSTER_CONFIGURATION *pCfg = this;

    //
    // Free and realloc pCfg's ip info array if rquired.
    //
    if (pCfg->NumIpAddresses == NumIpAddresses)
    {
        //
        // we can re-use the existing one
        //
        pIpAddressInfo = pCfg->pIpAddressInfo;
    }
    else
    {
        //
        // Free the old one and allocate space for the new array if required.
        //

        if (NumIpAddresses != 0)
        {
            pIpAddressInfo = new NLB_IP_ADDRESS_INFO[NumIpAddresses];
            if (pIpAddressInfo == NULL)
            {
                TRACE_CRIT(L"Error allocating space for IP address info array");
                Status = WBEM_E_OUT_OF_MEMORY;
                goto end;
            }
        }

        if (pCfg->NumIpAddresses!=0)
        {
            delete pCfg->pIpAddressInfo;
            pCfg->pIpAddressInfo = NULL;
            pCfg->NumIpAddresses = 0;
        }

    }

    //
    // Copy over the new ip address info, if there is any.
    //
    if (NumIpAddresses)
    {
        CopyMemory(
            pIpAddressInfo,
            pCfgNew->pIpAddressInfo,
            NumIpAddresses*sizeof(*pIpAddressInfo)
            );
    }

   
    //
    // Do any other error checks here.
    //

    //
    // Struct copy the entire structure, then fix up the pointer to
    // ip address info array.
    //
    (VOID) pCfg->SetFriendlyName(NULL);
    delete m_szNewRemoteControlPassword;
    *pCfg = *pCfgNew; // struct copy
    pCfg->m_szFriendlyName = NULL; // TODO: clean this up. 
    pCfg->m_szNewRemoteControlPassword = NULL;
    pCfg->pIpAddressInfo = pIpAddressInfo;
    pCfg->NumIpAddresses = NumIpAddresses;
    (VOID) pCfg->SetFriendlyName(pCfgNew->m_szFriendlyName);

    //
    // Update does NOT copy over the new remote control password  or 
    // new hashed password -- in fact
    // it ends up clearing the new password fields.
    //
    pCfg->ClearNewRemoteControlPassword();

    Status = WBEM_NO_ERROR;

end:

    return Status;
}

WBEMSTATUS
NLB_EXTENDED_CLUSTER_CONFIGURATION::SetNetworkAddresses(
        IN  LPCWSTR *pszNetworkAddresses,
        IN  UINT    NumNetworkAddresses
        )
/*
    pszNetworkAddresses is an array of strings. These strings have the
    format "addr/subnet", eg: "10.0.0.1/255.0.0.0"
*/
{
    WBEMSTATUS Status = WBEM_E_CRITICAL_ERROR;
    NLB_IP_ADDRESS_INFO *pIpInfo = NULL;

    if (NumNetworkAddresses != 0)
    {
        UINT NumBad = 0;

        //
        // Allocate space for the new ip-address-info array
        //
        pIpInfo = new NLB_IP_ADDRESS_INFO[NumNetworkAddresses];
        if (pIpInfo == NULL)
        {
            TRACE_CRIT("%!FUNC!: Alloc failure!");
            Status = WBEM_E_OUT_OF_MEMORY;
            goto end;
        }
        ZeroMemory(pIpInfo, NumNetworkAddresses*sizeof(*pIpInfo));

        
        //
        // Convert IP addresses to our internal form.
        //
        for (UINT u=0;u<NumNetworkAddresses; u++)
        {
            //
            // We extrace each IP address and it's corresponding subnet mask
            // from the "addr/subnet" format insert it into a
            // NLB_IP_ADDRESS_INFO structure.
            //
            // SAMPLE:  10.0.0.1/255.0.0.0
            //
            LPCWSTR szAddr = pszNetworkAddresses[u];
            UINT uIpAddress = 0;

            //
            // If this is not a valid address, we skip it.
            //
            Status =  CfgUtilsValidateNetworkAddress(
                        szAddr,
                        &uIpAddress,
                        NULL,
                        NULL
                        );
            if (FAILED(Status))
            {
                TRACE_CRIT("%!FUNC!: Invalid ip or subnet: %ws", szAddr);
                NumBad++;
                continue;
            }

            ASSERT(u>=NumBad);

            Status =  address_string_to_ip_and_subnet(
                        szAddr,
                        pIpInfo[u-NumBad].IpAddress,
                        pIpInfo[u-NumBad].SubnetMask
                        );

            if (FAILED(Status))
            {
                //
                // This one of the ip/subnet parms is too large.
                //
                TRACE_CRIT("%!FUNC!:ip or subnet part too large: %ws", szAddr);
                goto end;
            }
        }

        NumNetworkAddresses -= NumBad;
        if (NumNetworkAddresses == 0)
        {
            delete[] pIpInfo;
            pIpInfo = NULL;
        }
    }

    //
    // Replace the old ip-address-info with the new one
    //
    if (this->pIpAddressInfo != NULL)
    {
        delete this->pIpAddressInfo;
        this->pIpAddressInfo = NULL;
    }
    this->pIpAddressInfo = pIpInfo;
    pIpInfo = NULL;
    this->NumIpAddresses = NumNetworkAddresses;
    Status = WBEM_NO_ERROR;

end:

    if (pIpInfo != NULL)
    {
        delete[] pIpInfo;
    }

    return Status;
}


WBEMSTATUS
NLB_EXTENDED_CLUSTER_CONFIGURATION::GetNetworkAddresses(
        OUT LPWSTR **ppszNetworkAddresses,   // free using delete
        OUT UINT    *pNumNetworkAddresses
        )
/*
    ppszNetworkAddresses is filled out on successful return to
    an array of strings. These strings have the
    format "addr/subnet", eg: "10.0.0.1/255.0.0.0"
*/
{
    WBEMSTATUS  Status = WBEM_E_CRITICAL_ERROR;
    UINT        AddrCount = this->NumIpAddresses;
    NLB_IP_ADDRESS_INFO *pIpInfo = this->pIpAddressInfo;
    LPWSTR      *pszNetworkAddresses = NULL;


    if (AddrCount != 0)
    {
        //
        // Convert IP addresses from our internal form into
        // format "addr/subnet", eg: "10.0.0.1/255.0.0.0"
        //
        // 
        const UINT cchLen =  WLBS_MAX_CL_IP_ADDR    // for IP address
                           + WLBS_MAX_CL_NET_MASK   // for subnet mask
                           + 1;                      // for separating '/' 


        pszNetworkAddresses =  allocate_string_array(
                               AddrCount,
                               cchLen
                               );
        if (pszNetworkAddresses == NULL)
        {
            TRACE_CRIT("%!FUNC!: Alloc failure!");
            Status = WBEM_E_OUT_OF_MEMORY;
            goto end;
        }

        for (UINT u=0;u<AddrCount; u++)
        {
            //
            // We extrace each IP address and it's corresponding subnet mask
            // insert them into a NLB_IP_ADDRESS_INFO
            // structure.
            //
            LPCWSTR pIpSrc  = pIpInfo[u].IpAddress;
            LPCWSTR pSubSrc = pIpInfo[u].SubnetMask;
            LPWSTR szDest   = pszNetworkAddresses[u];
            Status =  ip_and_subnet_to_address_string(
                            pIpSrc,
                            pSubSrc,
                            cchLen,
                            szDest
                            );
            if (FAILED(Status))
            {
                //
                // This would be an implementation error in get_multi_string_...
                //
                ASSERT(FALSE);
                Status = WBEM_E_CRITICAL_ERROR;
                goto end;
            }
        }
    }
    Status = WBEM_NO_ERROR;

end:

    if (FAILED(Status))
    {
        if (pszNetworkAddresses != NULL)
        {
            delete pszNetworkAddresses;
            pszNetworkAddresses = NULL;
        }
        AddrCount = 0;
    }
    
    *ppszNetworkAddresses = pszNetworkAddresses;
    *pNumNetworkAddresses = AddrCount;
    return Status;
}

        
WBEMSTATUS
NLB_EXTENDED_CLUSTER_CONFIGURATION::SetNetworkAddresPairs(
        IN  LPCWSTR *pszIpAddresses,
        IN  LPCWSTR *pszSubnetMasks,
        IN  UINT    NumNetworkAddresses
        )
{
    WBEMSTATUS Status = WBEM_E_CRITICAL_ERROR;
    goto end;

end:
    return Status;
}

WBEMSTATUS
NLB_EXTENDED_CLUSTER_CONFIGURATION::GetNetworkAddressPairs(
        OUT LPWSTR **ppszIpAddresses,   // free using delete
        OUT LPWSTR **ppszIpSubnetMasks,   // free using delete
        OUT UINT    *pNumNetworkAddresses
        )
{
    WBEMSTATUS Status = WBEM_E_CRITICAL_ERROR;
    goto end;

end:
    return Status;
}

WBEMSTATUS
NLB_EXTENDED_CLUSTER_CONFIGURATION::GetPortRules(
        OUT LPWSTR **ppszPortRules,
        OUT UINT    *pNumPortRules
        )
{
    WLBS_PORT_RULE *pRules = NULL;
    UINT            NumRules = 0;
    WBEMSTATUS      Status;
    LPWSTR          *pszPortRules = NULL;

    // DebugBreak();

    *ppszPortRules = NULL;
    *pNumPortRules = 0;

    Status =  CfgUtilGetPortRules(
                    &NlbParams,
                    &pRules,
                    &NumRules
                    );

    if (FAILED(Status) || NumRules == 0)
    {
        pRules = NULL;
        goto end;
    }

    pszPortRules = CfgUtilsAllocateStringArray(
                       NumRules,
                       NLB_MAX_PORT_STRING_SIZE
                       );

    if (pszPortRules == NULL)
    {
        Status = WBEM_E_OUT_OF_MEMORY;
        goto  end;
    }

    //
    // Now convert from the binary to the string format.
    //
    for (UINT u = 0; u< NumRules; u++)
    {
        BOOL fRet;
        fRet =  CfgUtilsGetPortRuleString(
                    pRules+u,
                    pszPortRules[u]
                    );
        if (!fRet)
        {
            //
            // Must be a bad binary port rule!
            // For now, we just set the port rule to "".
            //
            *pszPortRules[u]=0;
            TRACE_INFO("%!FUNC!: Invalid port rule %lu", u);
        }
                    
    }

    Status = WBEM_NO_ERROR;

end:

    delete pRules;

    *pNumPortRules = NumRules;
    *ppszPortRules = pszPortRules;

    return Status;
}


WBEMSTATUS
NLB_EXTENDED_CLUSTER_CONFIGURATION::SetPortRules(
        IN LPCWSTR *pszPortRules,
        IN UINT    NumPortRules
        )
{
    WBEMSTATUS Status = WBEM_E_CRITICAL_ERROR;
    WLBS_PORT_RULE *pRules = NULL;

    // DebugBreak();

    if (NumPortRules!=0)
    {
        pRules = new WLBS_PORT_RULE[NumPortRules];
        if (pRules == NULL)
        {
            TRACE_CRIT("%!FUNC!: Allocation failure!");
            Status = WBEM_E_OUT_OF_MEMORY;
            goto  end;
        }
    }

    //
    // Initialiez the binary form of the port rules.
    //
    for (UINT u=0; u < NumPortRules; u++)
    {
        LPCWSTR szRule = pszPortRules[u];
        BOOL fRet;
        fRet = CfgUtilsSetPortRuleString(
                    szRule,
                    pRules+u
                    );
        if (fRet == FALSE)
        {
            Status = WBEM_E_INVALID_PARAMETER;
            goto end;
        }
    }

    Status = CfgUtilSetPortRules(
                pRules,
                NumPortRules,
                &NlbParams
                );

end:

    delete[] pRules;
    return Status;
}


WBEMSTATUS
NLB_EXTENDED_CLUSTER_CONFIGURATION::SetPortRulesSafeArray(
    IN SAFEARRAY   *pSA
    )
{
    return WBEM_E_CRITICAL_ERROR;
}

WBEMSTATUS
NLB_EXTENDED_CLUSTER_CONFIGURATION::GetPortRulesSafeArray(
    OUT SAFEARRAY   **ppSA
    )
{
    return WBEM_E_CRITICAL_ERROR;
}


WBEMSTATUS
NLB_EXTENDED_CLUSTER_CONFIGURATION::GetClusterNetworkAddress(
        OUT LPWSTR *pszAddress
        )
/*
    allocate and return the cluster-ip and mask in address/subnet form.
    Eg: "10.0.0.1/255.0.0.0"
*/
{
    WBEMSTATUS Status = WBEM_E_OUT_OF_MEMORY;
    LPWSTR szAddress = NULL;

    if (fValidNlbCfg)
    {
        szAddress = new WCHAR[NLBUPD_MAX_NETWORK_ADDRESS_LENGTH+1];
        if (szAddress != NULL)
        {
            Status = ip_and_subnet_to_address_string(
                        NlbParams.cl_ip_addr,
                        NlbParams.cl_net_mask,
                        NLBUPD_MAX_NETWORK_ADDRESS_LENGTH+1,
                        szAddress
                        );
            if (FAILED(Status))
            {
                delete[] szAddress;
                szAddress = NULL;
            }
        }
    }

    *pszAddress = szAddress;

    return Status;
}

VOID
NLB_EXTENDED_CLUSTER_CONFIGURATION::SetClusterNetworkAddress(
        IN LPCWSTR szAddress
        )
{
    if (szAddress == NULL) szAddress = L"";
    (VOID) address_string_to_ip_and_subnet(
                    szAddress,
                    NlbParams.cl_ip_addr,
                    NlbParams.cl_net_mask
                    );
}

WBEMSTATUS
NLB_EXTENDED_CLUSTER_CONFIGURATION::GetClusterName(
        OUT LPWSTR *pszName
        )
/*
    allocate and return the cluster name
*/
{
    WBEMSTATUS Status = WBEM_E_OUT_OF_MEMORY;
    LPWSTR szName = NULL;

    if (fValidNlbCfg)
    {
        UINT len =  wcslen(NlbParams.domain_name);
        szName = new WCHAR[len+1]; // +1 for ending zero
        if (szName != NULL)
        {
            CopyMemory(szName, NlbParams.domain_name, (len+1)*sizeof(WCHAR));
            Status = WBEM_NO_ERROR;
        }
    }

    *pszName = szName;

    return Status;
}


VOID
NLB_EXTENDED_CLUSTER_CONFIGURATION::SetClusterName(
        IN LPCWSTR szName
        )
{
    if (szName == NULL) szName = L"";
    UINT len =  wcslen(szName);
    if (len>WLBS_MAX_DOMAIN_NAME)
    {
        TRACE_CRIT("%!FUNC!: Cluster name too large");
    }
    CopyMemory(NlbParams.domain_name, szName, (len+1)*sizeof(WCHAR));
}



WBEMSTATUS
NLB_EXTENDED_CLUSTER_CONFIGURATION::GetDedicatedNetworkAddress(
        OUT LPWSTR *pszAddress
        )
{
    WBEMSTATUS Status = WBEM_E_OUT_OF_MEMORY;
    LPWSTR szAddress = NULL;

    if (fValidNlbCfg)
    {
        szAddress = new WCHAR[NLBUPD_MAX_NETWORK_ADDRESS_LENGTH+1];
        if (szAddress != NULL)
        {
            Status = ip_and_subnet_to_address_string(
                        NlbParams.ded_ip_addr,
                        NlbParams.ded_net_mask,
                        NLBUPD_MAX_NETWORK_ADDRESS_LENGTH+1,
                        szAddress
                        );
            if (FAILED(Status))
            {
                delete[] szAddress;
                szAddress = NULL;
            }
        }
    }

    *pszAddress = szAddress;

    return Status;
}

VOID
NLB_EXTENDED_CLUSTER_CONFIGURATION::SetDedicatedNetworkAddress(
        IN LPCWSTR szAddress
        )
{
    if (szAddress == NULL || *szAddress == 0)
    {
        ARRAYSTRCPY(NlbParams.ded_ip_addr, CVY_DEF_DED_IP_ADDR);
        ARRAYSTRCPY(NlbParams.ded_net_mask, CVY_DEF_DED_NET_MASK);
    }
    else
    {
        (VOID) address_string_to_ip_and_subnet(
                        szAddress,
                        NlbParams.ded_ip_addr,
                        NlbParams.ded_net_mask
                        );
    }
}

NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE
NLB_EXTENDED_CLUSTER_CONFIGURATION::GetTrafficMode(
    VOID 
    ) const
{
    TRAFFIC_MODE TrafficMode =  TRAFFIC_MODE_UNICAST;
    
    if (NlbParams.mcast_support)
    {
        if (NlbParams.fIGMPSupport)
        {
            TrafficMode =  TRAFFIC_MODE_IGMPMULTICAST;
        }
        else
        {
            TrafficMode =  TRAFFIC_MODE_MULTICAST;
        }
    }

    return TrafficMode;
}

VOID
NLB_EXTENDED_CLUSTER_CONFIGURATION::SetTrafficMode(
    TRAFFIC_MODE Mode
    )
{
    switch(Mode)
    {
    case TRAFFIC_MODE_UNICAST:
        NlbParams.mcast_support = 0;
        NlbParams.fIGMPSupport  = 0;
        break;
    case TRAFFIC_MODE_IGMPMULTICAST:
        NlbParams.mcast_support = 1;
        NlbParams.fIGMPSupport  = 1;
        break;
    case TRAFFIC_MODE_MULTICAST:
        NlbParams.mcast_support = 1;
        NlbParams.fIGMPSupport  = 0;
        break;
    default:
        ASSERT(FALSE);
        break;
    }
}

UINT
NLB_EXTENDED_CLUSTER_CONFIGURATION::GetHostPriority(
    VOID
    )
{
    return NlbParams.host_priority;
}

VOID
NLB_EXTENDED_CLUSTER_CONFIGURATION::SetHostPriority(
    UINT Priority
    )
{
    NlbParams.host_priority = Priority;
}

//NLB_EXTENDED_CLUSTER_CONFIGURATION::START_MODE
DWORD
NLB_EXTENDED_CLUSTER_CONFIGURATION::GetClusterModeOnStart(
    VOID
    )
{
    //
    // If we decide to make cluster_mode something besides true/false we
    // need to make the change here too...
    //
    /*
    ASSERT(NlbParams.cluster_mode==TRUE || NlbParams.cluster_mode==FALSE);
    if (NlbParams.cluster_mode)
    {
        return START_MODE_STARTED;
    }
    else
    {
        return START_MODE_STOPPED;
    }
    */
    return NlbParams.cluster_mode;
}


VOID
NLB_EXTENDED_CLUSTER_CONFIGURATION::SetClusterModeOnStart(
//    START_MODE Mode
    DWORD Mode
    )
{
    /*
    switch(Mode)
    {
    case START_MODE_STARTED:
        NlbParams.cluster_mode = TRUE;
        break;
    case START_MODE_STOPPED:
        NlbParams.cluster_mode = FALSE;
        break;
    default:
        ASSERT(FALSE);
        break;
    }
    */
    NlbParams.cluster_mode = Mode;
}

BOOL
NLB_EXTENDED_CLUSTER_CONFIGURATION::GetPersistSuspendOnReboot(
    VOID
    )
{
    // This is a straight lift from wmi\ClusterWrapper.cpp\GetNodeConfig()
    // -KarthicN
    return ((NlbParams.persisted_states & CVY_PERSIST_STATE_SUSPENDED) != 0);
}


VOID
NLB_EXTENDED_CLUSTER_CONFIGURATION::SetPersistSuspendOnReboot(
    BOOL bPersistSuspendOnReboot
    )
{
    // This is a straight lift from wmi\ClusterWrapper.cpp\PutNodeConfig()
    // -KarthicN
    if (bPersistSuspendOnReboot) 
    {
        NlbParams.persisted_states |= CVY_PERSIST_STATE_SUSPENDED;
    }
    else
    {
        NlbParams.persisted_states &= ~CVY_PERSIST_STATE_SUSPENDED;
    }
}

BOOL
NLB_EXTENDED_CLUSTER_CONFIGURATION::GetRemoteControlEnabled(
    VOID
    ) const
{
    return (NlbParams.rct_enabled!=FALSE);
}

VOID
NLB_EXTENDED_CLUSTER_CONFIGURATION::SetRemoteControlEnabled(
    BOOL fEnabled
    )
{
    NlbParams.rct_enabled = (fEnabled!=FALSE);
}

WBEMSTATUS
NLB_EXTENDED_CLUSTER_CONFIGURATION::SetNetworkAddressesSafeArray(
    IN SAFEARRAY   *pSA
    )
{
    LPWSTR          *pStrings=NULL;
    UINT            NumStrings = 0;
    WBEMSTATUS      Status;
    Status =  CfgUtilStringsFromSafeArray(
                    pSA,
                    &pStrings,  // delete when done useing pStrings
                    &NumStrings
                    );
    if (FAILED(Status))
    {
        pStrings=NULL;
        goto end;
    }

    Status =  this->SetNetworkAddresses(
                    (LPCWSTR*)pStrings,
                    NumStrings
                    );

    if (pStrings != NULL)
    {
        delete pStrings;
    }

end:
    
    return Status;
}

WBEMSTATUS
NLB_EXTENDED_CLUSTER_CONFIGURATION::GetNetworkAddressesSafeArray(
    OUT SAFEARRAY   **ppSA
    )
{
    LPWSTR *pszNetworkAddresses = NULL;
    UINT NumNetworkAddresses = 0;
    SAFEARRAY   *pSA=NULL;
    WBEMSTATUS Status;

    Status = this->GetNetworkAddresses(
                    &pszNetworkAddresses,
                    &NumNetworkAddresses
                    );
    if (FAILED(Status))
    {
        pszNetworkAddresses = NULL;
        goto end;
    }

    Status = CfgUtilSafeArrayFromStrings(
                (LPCWSTR*) pszNetworkAddresses,
                NumNetworkAddresses, // can be zero
                &pSA
                );

    if (FAILED(Status))
    {
        pSA = NULL;
    }

end:

    *ppSA = pSA;
    if (pszNetworkAddresses != NULL)
    {
        delete pszNetworkAddresses;
        pszNetworkAddresses = NULL;
    }

    if (FAILED(Status))
    {
        TRACE_CRIT("%!FUNC!: couldn't extract network addresses from Cfg");
    }

    return Status;

}


LPWSTR *
allocate_string_array(
    UINT NumStrings,
    UINT MaxStringLen      //  excluding ending NULL
    )
/*
    Allocate a single chunk of memory using the new LPWSTR[] operator.
    The first NumStrings LPWSTR values of this operator contain an array
    of pointers to WCHAR strings. Each of these strings
    is of size (MaxStringLen+1) WCHARS.
    The rest of the memory contains the strings themselve.

    Return NULL if NumStrings==0 or on allocation failure.

    Each of the strings are initialized to be empty strings (first char is 0).
*/
{
    return  CfgUtilsAllocateStringArray(NumStrings, MaxStringLen);
}

WBEMSTATUS
address_string_to_ip_and_subnet(
    IN  LPCWSTR szAddress,
    OUT LPWSTR  szIp,    // max WLBS_MAX_CL_IP_ADDR including NULL
    OUT LPWSTR  szSubnet // max WLBS_MAX_CL_NET_MASK including NULL
    )
// Special case: if szAddress == "", we zero out both szIp and szSubnet;
{
    WBEMSTATUS Status = WBEM_E_CRITICAL_ERROR;

    if (*szAddress == 0) {szAddress = L"/";} // Special case mentioned above

    // from the "addr/subnet" format insert it into a
    // NLB_IP_ADDRESS_INFO structure.
    //
    // SAMPLE:  10.0.0.1/255.0.0.0
    //
    LPCWSTR pSlash = NULL;
    LPCWSTR pSrcSub = NULL;

    *szIp = 0;
    *szSubnet = 0;

    pSlash = wcsrchr(szAddress, (int) '/');
    if (pSlash == NULL)
    {
        TRACE_CRIT("%!FUNC!:missing subnet portion in %ws", szAddress);
        Status = WBEM_E_INVALID_PARAMETER;
        goto end;
    }
    pSrcSub = pSlash+1;
    UINT len = (UINT) (pSlash - szAddress);
    UINT len1 = wcslen(pSrcSub);
    if ( (len < WLBS_MAX_CL_IP_ADDR) && (len1 < WLBS_MAX_CL_NET_MASK))
    {
        CopyMemory(szIp, szAddress, len*sizeof(WCHAR));
        szIp[len] = 0;
        CopyMemory(szSubnet, pSrcSub, (len1+1)*sizeof(WCHAR));
    }
    else
    {
        //
        // One of the ip/subnet parms is too large.
        //
        TRACE_CRIT("%!FUNC!:ip or subnet part too large: %ws", szAddress);
        Status = WBEM_E_INVALID_PARAMETER;
        goto end;
    }

    Status = WBEM_NO_ERROR;

end:

    return Status;
}


WBEMSTATUS
ip_and_subnet_to_address_string(
    IN  LPCWSTR szIp,
    IN  LPCWSTR szSubnet,
    IN  UINT    cchAddress,
    OUT LPWSTR  szAddress// max WLBS_MAX_CL_IP_ADDR
                         // + 1(for slash) + WLBS_MAX_CL_NET_MASK + 1 (for NULL)
    )
{
    WBEMSTATUS Status = WBEM_E_INVALID_PARAMETER;
    UINT len =  wcslen(szIp)+wcslen(szSubnet) + 1; // +1 for separating '/'

    if (len >= NLBUPD_MAX_NETWORK_ADDRESS_LENGTH)
    {
        goto end;
    }
    else
    {
        HRESULT hr;
        hr = StringCchPrintf(
                szAddress,
                cchAddress,
                L"%ws/%ws", 
                szIp,
                szSubnet
                );
        if (hr == S_OK)
        {
            Status = WBEM_NO_ERROR;
        }
        else
        {
            Status = WBEM_E_INVALID_PARAMETER;
        }
    }

end:

    return Status;
}

WBEMSTATUS
NLB_EXTENDED_CLUSTER_CONFIGURATION::GetFriendlyName(
    OUT LPWSTR *pszFriendlyName // Free using delete
    ) const
{
    WBEMSTATUS Status = WBEM_E_NOT_FOUND;
    LPWSTR szName = NULL;

    *pszFriendlyName = NULL;

    if (m_szFriendlyName != NULL)
    {
        UINT len = wcslen(m_szFriendlyName);
        szName = new WCHAR[len+1]; // +1 for ending 0
        if (szName == NULL)
        {
            Status = WBEM_E_OUT_OF_MEMORY;
        }
        else
        {
            Status = WBEM_NO_ERROR;
            CopyMemory(szName, m_szFriendlyName, (len+1)*sizeof(WCHAR));
        }
    }

    *pszFriendlyName = szName;

    return Status;
}

WBEMSTATUS
NLB_EXTENDED_CLUSTER_CONFIGURATION::SetFriendlyName(
    IN LPCWSTR szFriendlyName // Saves a copy of szFriendlyName
    )
{
    WBEMSTATUS Status = WBEM_E_OUT_OF_MEMORY;
    LPWSTR szName = NULL;

    if (szFriendlyName != NULL)
    {
        UINT len = wcslen(szFriendlyName);
        szName = new WCHAR[len+1]; // +1 for ending 0
        if (szName == NULL)
        {
            goto end;
        }
        else
        {
            CopyMemory(szName, szFriendlyName, (len+1)*sizeof(WCHAR));
        }
    }

    Status = WBEM_NO_ERROR;

    if (m_szFriendlyName != NULL)
    {
        delete m_szFriendlyName;
        m_szFriendlyName = NULL;
    }
    m_szFriendlyName = szName;

end:

    return Status;
}

WBEMSTATUS
NLB_EXTENDED_CLUSTER_CONFIGURATION::SetNewRemoteControlPassword(
    IN LPCWSTR szRemoteControlPassword // Saves a copy of szRemoteControlPassword
    )
{
    WBEMSTATUS Status = WBEM_E_OUT_OF_MEMORY;
    LPWSTR szName = NULL;

    if (szRemoteControlPassword != NULL)
    {
        UINT len = wcslen(szRemoteControlPassword);
        szName = new WCHAR[len+1]; // +1 for ending 0
        if (szName == NULL)
        {
            goto end;
        }
        else
        {
            CopyMemory(szName, szRemoteControlPassword, (len+1)*sizeof(WCHAR));
        }

        m_fSetPassword = TRUE;
    }
    else
    {
        m_fSetPassword = FALSE;
    }

    Status = WBEM_NO_ERROR;

    if (m_szNewRemoteControlPassword != NULL)
    {
        delete m_szNewRemoteControlPassword;
        m_szNewRemoteControlPassword = NULL;
    }
    m_szNewRemoteControlPassword = szName;

end:

    return Status;
}


WBEMSTATUS
NLB_EXTENDED_CLUSTER_CONFIGURATION::
ModifyNetworkAddress(
        IN LPCWSTR szOldIpAddress, OPTIONAL // network order
        IN LPCWSTR szNewIpAddress,  OPTIONAL
        IN LPCWSTR szNewSubnetMask  OPTIONAL
        )
//
// NULL, NULL: clear all network addresses
// NULL, szNew: add
// szOld, NULL: remove
// szOld, szNew: replace (or add, if old doesn't exist)
//
{
    WBEMSTATUS Status = WBEM_E_INVALID_PARAMETER;
    BOOL fRet;
    NlbIpAddressList IpList;
    fRet = IpList.Set(this->NumIpAddresses, this->pIpAddressInfo, 0);
    if (fRet)
    {
        fRet = IpList.Modify(
                    szOldIpAddress,
                    szNewIpAddress,
                    szNewSubnetMask
                    );
    }
    if (fRet)
    {
        this->SetNetworkAddressesRaw(NULL,0);
        IpList.Extract(REF this->NumIpAddresses, REF this->pIpAddressInfo);
        Status = WBEM_NO_ERROR;
    }
    else
    {
        Status = WBEM_E_INVALID_PARAMETER;
    }

    return Status;
}


BOOL
NLB_EXTENDED_CLUSTER_CONFIGURATION::
IsBlankDedicatedIp(
    VOID
    ) const
//
// Dedicated IP is either the empty string or all zeros.
//
{
    return     (NlbParams.ded_ip_addr[0]==0)
            || (_wcsspnp(NlbParams.ded_ip_addr, L".0")==NULL);
}

const NLB_IP_ADDRESS_INFO *
NlbIpAddressList::Find(
        LPCWSTR szIp // IF NULL, returns first address
        ) const
//
// Looks for the specified IP address  -- returns an internal pointer
// to the found IP address info, if fount, otherwise NULL.
//
{
    const NLB_IP_ADDRESS_INFO *pInfo = NULL;

    if (szIp == NULL)
    {
        //
        // return the first if there is one, else NULL.
        //
        if (m_uNum != 0)
        {
            pInfo = m_pIpInfo;
        }
    }
    else
    {
        pInfo = find_ip_in_ipinfo(szIp, m_pIpInfo, m_uNum);
    }

    return pInfo;
}

BOOL
NlbIpAddressList::Copy(const NlbIpAddressList &refList)
{
    BOOL fRet;

    fRet = this->Set(refList.m_uNum, refList.m_pIpInfo, 0);

    return fRet;
}


BOOL
NlbIpAddressList::Validate(void)
// checks that there are no dups and all valid ip/subnets
{
    BOOL fRet = FALSE;
    NLB_IP_ADDRESS_INFO *pInfo   = m_pIpInfo;
    UINT                uNum    = m_uNum;

    for (UINT u = 0; u<uNum; u++)
    {
        UINT uIpAddress = 0;
        fRet = sfn_validate_info(REF pInfo[u], REF uIpAddress);

        if (!fRet) break;
    }

    return fRet;
}

BOOL
NlbIpAddressList::Set(
        UINT uNew,
        const NLB_IP_ADDRESS_INFO *pNewInfo,
        UINT uExtraCount
        )
/*
    Sets internal list to a copy of pNewInfo. Reallocates list if required.
    Reserves uExtraCount empty locations (perhaps more if it kept the old
    internal list) 
*/
{
    BOOL                fRet   = FALSE;
    UINT                uMax   = uNew+uExtraCount;
    NLB_IP_ADDRESS_INFO *pInfo  = NULL;
    
    // printf("-> set(%lu, %p, %lu): m_uNum=%lu m_uMax=%lu m_pIpInfo=0x%p\n",
    //     uNew, pNewInfo, uExtraCount,
    //      m_uNum, m_uMax, m_pIpInfo);

    if (uMax > m_uMax)
    {
        //
        // We'll re-allocate to get more space.
        //
        pInfo = new NLB_IP_ADDRESS_INFO[uMax];
        if (pInfo == NULL)
        {
            TRACE_CRIT("%!FUNC! allocation failure");
            goto end;
        }
    }
    else
    {
        //
        // The current m_pIpInfo is large enough; we'll keep it.
        //
        pInfo = m_pIpInfo;
        uMax = m_uMax;
    }

    if (uNew != 0)
    {
        if (pNewInfo == pInfo)
        {
            // Caller has passed m_pInfo as pNewInfo.
            // No need to copy.
        }
        else
        {
            // 
            // MoveMemory can deal with overlapping regions.
            //
            MoveMemory(pInfo, pNewInfo, sizeof(NLB_IP_ADDRESS_INFO)*uNew);
        }
    }

    if (uMax > uNew)
    {
        // 
        // Zero out the empty space.
        //
        ZeroMemory(pInfo+uNew, sizeof(NLB_IP_ADDRESS_INFO)*(uMax-uNew));
    }
    m_uNum = uNew;
    m_uMax = uMax;
    if (m_pIpInfo != pInfo)
    {
        delete[] m_pIpInfo;
        m_pIpInfo = pInfo;
    }
    fRet = TRUE;

end:

    // printf("<- set: fRet=%lu, m_uNum=%lu m_uMax=%lu m_pIpInfo=0x%p\n",
    //      fRet, m_uNum, m_uMax, m_pIpInfo);

    return fRet;
}


VOID
NlbIpAddressList::Extract(UINT &uNum, NLB_IP_ADDRESS_INFO * &pNewInfo)
/*
    Sets pNewInfo to the ip list (not a copy) and sets the internal list to
    null. Free using delete[].
*/
{
    uNum = m_uNum;
    pNewInfo = m_pIpInfo;
    m_uNum=0;
    m_uMax=0;
    m_pIpInfo = NULL;
}

static
VOID
uint_to_szipaddr(
    UINT uIpAddress,   // Ip address or subnet -- no validation, network order
    UINT cchLen,       // length of rgAddress, incluing space for NULL
    WCHAR *rgAddress   // Expected to be at least 17 chars long
    )
{
    BYTE *pb = (BYTE*) &uIpAddress;
    StringCchPrintf(rgAddress, cchLen, L"%lu.%lu.%lu.%lu", pb[0], pb[1], pb[2], pb[3]);
}

BOOL
NlbIpAddressList::Modify(
        LPCWSTR szOldIp,
        LPCWSTR szNewIp,
        LPCWSTR szNewSubnet
        )
//
// NULL, NULL, -: clear all network addresses
// NULL, szNew, -: add
// szOld, NULL, -: remove
// szOld, szNew, -: remove szOld if found; add or replace szNew.
//
{
    WBEMSTATUS Status = WBEM_E_CRITICAL_ERROR;
    BOOL fRet = FALSE;
    UINT uFoundOldOffset = 0;
    BOOL fFoundOldAddress = FALSE;

    // printf("-> modify: m_uNum=%lu m_uMax=%lu m_pIpInfo=0x%p\n",
    //     m_uNum, m_uMax, m_pIpInfo);

    if (szOldIp==NULL && szNewIp==NULL)
    {
        this->Clear();
        fRet =  TRUE;
        goto end;
    }

    if (szOldIp != NULL && szNewIp != NULL)
    {
        //
        // Both szOld and szNew are specified.
        // We'll first call ourselves recursively to remove szNewIp, if
        // it exists. Later on below we'll replace szOldIp with szNewIp
        // if szOldIp exists (i.e. at the same LOCATION of szOldIp), or
        // add it to the beginning if szOldIp doesn't exist.
        //
        (void) this->Modify(szNewIp, NULL, NULL);
    }

    if (szOldIp == NULL)
    {
        szOldIp = szNewIp; // so we don't add dups.
    }

    if (szOldIp != NULL)
    {
        const NLB_IP_ADDRESS_INFO *pFoundInfo = NULL;

        pFoundInfo =  find_ip_in_ipinfo(szOldIp, m_pIpInfo, m_uNum);
        if(pFoundInfo != NULL)
        {
            uFoundOldOffset = (ULONG) (UINT_PTR) (pFoundInfo-m_pIpInfo);
            fFoundOldAddress = TRUE;
        }
    }

    if (szNewIp == NULL)
    {
        //
        // Remove old Ip address
        //
        if (!fFoundOldAddress)
        {
            //
            // Old one not found
            //
            fRet = FALSE;
            goto end;
        }

        //
        // We bump up everything beyond this one
        //
        m_uNum--; // that this was at least 1 because we found the old
        for (UINT u=uFoundOldOffset; u<m_uNum; u++)
        {
            m_pIpInfo[u] = m_pIpInfo[u+1]; // struct copy.
        }
        //
        // Zero out the last (vacated) element.
        //
        ZeroMemory(&m_pIpInfo[m_uNum], sizeof(*m_pIpInfo));
    }
    else
    {
        UINT uNewIpAddress=0;
        UINT uNewSubnetMask=0;
        NLB_IP_ADDRESS_INFO NewIpInfo;
        ZeroMemory(&NewIpInfo, sizeof(NewIpInfo));

        Status =  CfgUtilsValidateNetworkAddress(
                    szNewIp,
                    &uNewIpAddress,
                    NULL,
                    NULL
                    );

        if (!FAILED(Status))
        {
            Status =  CfgUtilsValidateNetworkAddress(
                        szNewSubnet,
                        &uNewSubnetMask,
                        NULL,
                        NULL
                        );
        }

        if (FAILED(Status))
        {
            //
            // Invalid ip address.
            //
            TRACE_CRIT("%!FUNC!:ip or subnet part too large: %ws/%ws",
                    szNewIp, szNewSubnet);
            fRet = FALSE;
            goto end;
        }

        //
        // Convert into the IP_ADDRESS_INFO format.
        // Here we also convert to standard dotted notation.
        //
        uint_to_szipaddr(uNewIpAddress, ASIZE(NewIpInfo.IpAddress), NewIpInfo.IpAddress);
        uint_to_szipaddr(uNewSubnetMask, ASIZE(NewIpInfo.SubnetMask), NewIpInfo.SubnetMask);

        if (fFoundOldAddress == TRUE)
        {
            //
            // Replace the old one.
            //
            m_pIpInfo[uFoundOldOffset] = NewIpInfo; // struct copy.
        }
        else
        {
            //
            // Well add the new ip info to the head of the list.
            //

            if (m_uNum == m_uMax)
            {
                //
                // We need to allocate more space.
                // We somewhat arbitrarily reserve 2 spots
                // NOTE: this will cause a change in the value of
                // m_pIpInfo, m_uNum and m_uMax.
                //
                fRet = this->Set(m_uNum, m_pIpInfo, 2);
                if (!fRet)
                {
                    goto end;
                }
            }

            //
            // Move existing stuff one place down, to make place for the
            // new one.
            //
            if (m_uNum >= m_uMax)
            {
                // Ahem, should never get here because we just added
                // two extra spaces above.
                fRet = FALSE;
                goto end;
            }

            if (m_uNum)
            {
                // Note the regions overlap -- MoveMemory can handle this.
                //
                MoveMemory(m_pIpInfo+1, m_pIpInfo, m_uNum*sizeof(*m_pIpInfo));
            }
            //
            // Add a new one -- we'll add it to the beginning.
            //
            m_pIpInfo[0] = NewIpInfo; // struct copy.
            m_uNum++;

        }
    }
    
    fRet = TRUE;


end:

    // printf("<- modify: fRet=%lu, m_uNum=%lu m_uMax=%lu m_pIpInfo=0x%p\n",
    //      fRet, m_uNum, m_uMax, m_pIpInfo);

    return fRet;
}


BOOL
NlbIpAddressList::sfn_validate_info(
        const NLB_IP_ADDRESS_INFO &Info,
        UINT &uIpAddress
        )
{
    WBEMSTATUS Status;
    UINT uSubnetMask = 0;

    Status =  CfgUtilsValidateNetworkAddress(
                Info.IpAddress,
                &uIpAddress,
                NULL,
                NULL
                );

    if (!FAILED(Status))
    {
        Status =  CfgUtilsValidateNetworkAddress(
                    Info.SubnetMask,
                    &uSubnetMask,
                    NULL,
                    NULL
                    );
    }

    return (!FAILED(Status));
}


UINT *
ipaddresses_from_ipaddressinfo(
            const NLB_IP_ADDRESS_INFO *pInfo,
            UINT NumAddresses
            )
/*
    Free return value using "delete" operator.
*/
{
    UINT *rgOut = NULL;

    if (NumAddresses == 0) goto end;

    //
    // Allocate space.
    //
    rgOut = new UINT[NumAddresses];

    if (rgOut==NULL) goto end;

    //
    // Validate each address, thereby getting the ip address info.
    //
    for (UINT *pOut = rgOut; NumAddresses--; pOut++, pInfo++)
    {
        WBEMSTATUS wStat;
        wStat = CfgUtilsValidateNetworkAddress(
                    pInfo->IpAddress,
                    pOut,
                    NULL,
                    NULL
                    );
        if (FAILED(wStat))
        {
            TRACE_CRIT("%!FUNC! -- Validate address \"%ws\" failed!\n",
                    pInfo->IpAddress);
            delete[] rgOut;
            rgOut = NULL;
            goto end;
        }
    }
        
end:

    return rgOut;
}

BOOL
NlbIpAddressList::Apply(UINT NumNew, const NLB_IP_ADDRESS_INFO *pNewInfo)
/*
    Set our internal list to be a permutation of the ip addresses in pInfo.
    The permutation attempts to minimize the differences between the
    new and the current version: basically the relative order of any adresses
    that remain in new is preserved, and any new addresses are tacked on at
    the end.
*/
{
    BOOL                fRet        = FALSE;
    UINT                *rgOldIps   = NULL;
    UINT                *rgNewIps   = NULL;
    NLB_IP_ADDRESS_INFO *rgNewInfo  = NULL;
    UINT                NumFilled   = 0;
    UINT                NumOld      = m_uNum;


    if (NumNew == 0)
    {
        this->Clear();
        fRet = TRUE;
        goto end;
    }

    if (NumOld!=0)
    {
        rgOldIps = ipaddresses_from_ipaddressinfo(
                            m_pIpInfo,
                            m_uNum
                            );

        if (rgOldIps == NULL) goto end;
    }

    rgNewIps = ipaddresses_from_ipaddressinfo(
                        pNewInfo,
                        NumNew
                        );

    if (rgNewIps==NULL) goto end;

    rgNewInfo = new NLB_IP_ADDRESS_INFO[NumNew];
    if (rgNewInfo == NULL)
    {
        TRACE_CRIT("%!FUNC! allocation failure!");
        goto end;
    }

    //
    // We try to preserve our current order of IP addresses 
    // as far as possible. To do this, we go through each ip address
    // in our list in order -- if we find it in the new list, we
    // add it to our new copy -- thereby preserving the order of all
    // old IP addresses that are still present in the new list.
    //
    {

        for (UINT uOld = 0; uOld < NumOld; uOld++)
        {
            UINT uOldIp     = rgOldIps[uOld];

            //
            // See if it exists in new version -- if so add to new
            //
            for (UINT uNew=0; uNew<NumNew; uNew++)
            {
                if (uOldIp == rgNewIps[uNew])
                {
                    // yes it's still present, keep it.
                    if (NumFilled<NumNew)
                    {
                        rgNewInfo[NumFilled]
                         = pNewInfo[uNew];  // struct copy
                        NumFilled++;
                        rgNewIps[uNew] = 0; // we use this later.
                    }
                    else
                    {
                        TRACE_CRIT("%!FUNC! Out of new addresses!");
                        fRet = FALSE;
                        goto end;
                    }
                }
            }
        }
        
    }

    //
    // Now tack on any cluster IP addresses not already added on.
    //
    {
        //
        // See if it exists in cluster version -- if so add to new
        //
        for (UINT uNew=0; uNew<NumNew; uNew++)
        {
            if (rgNewIps[uNew] != 0)
            {
                //
                // yes it's a new cluster IP -- add it...
                // (remember we set rgClusterIps[uCluster] to zero
                // in the previous block, if we copied it over.
                //
                if (NumFilled<NumNew)
                {
                    rgNewInfo[NumFilled]
                     = pNewInfo[uNew];  // struct copy
                    NumFilled++;
                }
                else
                {
                    TRACE_CRIT("%!FUNC! Out of new addresses!");
                    fRet = FALSE;
                    goto end;
                }
            }
        }
    }

    //
    // At this point, we should have filled up all of the allocated space.
    //
    if (NumFilled != NumNew)
    {
        TRACE_CRIT("%!FUNC!  NumNewAddressesFilled != NumNewAddresses!");
        fRet = FALSE;
        goto end;
    }

    //
    // Now update our internal list.
    //
    delete[] m_pIpInfo;
    m_pIpInfo = rgNewInfo;
    m_uNum = m_uMax = NumNew;
    rgNewInfo = NULL; // so it doesn't get deleted below.

    fRet = TRUE;

end:

    delete[] rgOldIps;
    delete[] rgNewIps;
    delete[] rgNewInfo;

    return fRet;
}


const NLB_IP_ADDRESS_INFO *
find_ip_in_ipinfo(
        LPCWSTR szIpToFind,
        const NLB_IP_ADDRESS_INFO *pIpInfo,
        UINT NumIpInfos
        )
{

    UINT uIpAddressToFind = 0;
    UINT uIpAddress=0;
    const NLB_IP_ADDRESS_INFO *pInfo = NULL;
    WBEMSTATUS Status;

    Status =  CfgUtilsValidateNetworkAddress(
                szIpToFind,
                &uIpAddressToFind,
                NULL,
                NULL
                );

    if (Status == WBEM_NO_ERROR)
    {
        // Find location of old network address
        for (UINT u=0; u<NumIpInfos; u++)
        {
            Status =  CfgUtilsValidateNetworkAddress(
                        pIpInfo[u].IpAddress,
                        &uIpAddress,
                        NULL,
                        NULL
                        );
    
            if (Status == WBEM_NO_ERROR)
            {
                if (uIpAddressToFind == uIpAddress)
                {
                    // found it.
                    pInfo = &pIpInfo[u];
                    break;
                }
            }
        }
    }

    return pInfo;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\cfgutillib\private.h ===
/*++

Copyright(c) 2001  Microsoft Corporation

Module Name:

    NLB Manager provider test harness

File Name:

    private.h

Abstract:

    Internal headers


History:

    04/08/01    JosephJ Created

--*/

// #define NLB_USE_MUTEX 1


#include <FWcommon.h>
#include <assert.h>
#include <objbase.h>
#include <initguid.h>
#include <winsock2.h>
#include <ipexport.h>
#include <icmpapi.h>
#include <strsafe.h>
#include <wlbsutil.h>
#include <wlbsctrl.h>
#include <wlbsconfig.h>
#include <wlbsparm.h>
#include <netcfgx.h>
#include <devguid.h>
#include <cfg.h>
#include <wlbsiocl.h>
#include <nlberr.h>
#include <cfgutil.h>
#include "myntrtl.h"

//
// Debugging stuff...
//
extern BOOL g_DoBreaks;
#define MyBreak(_str) ((g_DoBreaks) ? (OutputDebugString(_str),DebugBreak(),1):0)


#define ASSERT assert
#define REF
#define ASIZE(_array) (sizeof(_array)/sizeof(_array[0]))

//
// Use this to copy to an array (not pointer) destination 
//
#define ARRAYSTRCPY(_dest, _src) \
            StringCbCopy((_dest), sizeof(_dest), (_src))

#define ARRAYSTRCAT(_dest, _src) \
            StringCbCat((_dest), sizeof(_dest), (_src))

//
// Following (MyXXX) functions are to be used only on systems
// that do not have wlbsctrl.dll installed.
//
// They are defined in wlbsprivate.cpp
//

DWORD
MyWlbsSetDefaults(PWLBS_REG_PARAMS    reg_data);

DWORD
MyWlbsEnumPortRules(
    const PWLBS_REG_PARAMS reg_data,
    PWLBS_PORT_RULE  rules,
    PDWORD           num_rules
    );

VOID
MyWlbsDeleteAllPortRules(
    PWLBS_REG_PARAMS reg_data
    );


DWORD MyWlbsAddPortRule(
    PWLBS_REG_PARAMS reg_data,
    const PWLBS_PORT_RULE rule
    );

BOOL MyWlbsValidateParams(
    const PWLBS_REG_PARAMS paramp
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\aboutdialog.cpp ===
//***************************************************************************
//
//  ABOUTDIALOG.CPP
// 
//  Module: NLB Manager
//
//  Purpose: LeftView, the tree view of NlbManager, and a few other
//           smaller classes.
//
//  Copyright (c)2001-2002 Microsoft Corporation, All Rights Reserved
//
//  History:
//
//  07/30/01    JosephJ adapted MHakim's  code
//
//***************************************************************************
#include "precomp.h"
#pragma hdrstop
#include "private.h"
#include "AboutDialog.h"

AboutDialog::AboutDialog(CWnd* parent )
        :
        CDialog( IDD, parent )
{
    
}


BOOL
AboutDialog::OnInitDialog()
{
    BOOL fRet = CDialog::OnInitDialog();

    //
    // Initialize the caption and discription based on the type of
    // dialog.
    //
    if (fRet)
    {
        LPCWSTR szWarning =  GETRESOURCEIDSTRING(IDS_ABOUT_WARNING);
        CWnd *pItem = GetDlgItem(IDC_STATIC_ABOUT_WARNING);
        if (szWarning != NULL && pItem != NULL)
        {
            pItem->SetWindowText(szWarning);
        }
    }

    return fRet;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\aboutdialog.h ===
#ifndef ABOUTDIALOG_H
#define ABOUTDIALOG_H

#include "stdafx.h"

#include "resource.h"

class AboutDialog : public CDialog
{
public:
    enum
    {
        IDD = IDD_ABOUT,
    };

    AboutDialog(CWnd* parent = NULL);

    virtual BOOL OnInitDialog();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\cfgutillib\wlbsprivate.cpp ===
//***************************************************************************
//  WLBSPRIVATE.CPP
//
// 
//  Module: WMI Framework Instance provider 
//
//  Purpose: Contains routines that access the private fields of
//           WLBS_REG_PARAMS
//
//  Copyright (c)2001 Microsoft Corporation, All Rights Reserved
//
//  History:
//
//  10/13/01    JosephJ Created (moved MyWlbsXXX functions from cfutil.cpp)
//
//***************************************************************************

//
// This macro allows us to access the private fields of WLBS_REG_PARAMS
//
#define WLBSAPI_INTERNAL_ONLY


#include "private.h"


VOID
CfgUtilSetHashedRemoteControlPassword(
    IN OUT WLBS_REG_PARAMS *pParams,
    IN DWORD dwHashedPassword
)
{
    pParams->i_rct_password = dwHashedPassword;
}

DWORD
CfgUtilGetHashedRemoteControlPassword(
    IN const WLBS_REG_PARAMS *pParams
)
{
    return pParams->i_rct_password;
}


//
// Following (MyXXX) functions are to be used only on systems
// that do not have wlbsctrl.dll installed.
//

DWORD MyWlbsSetDefaults(PWLBS_REG_PARAMS    reg_data)
{
    reg_data -> install_date = 0;
    reg_data -> i_verify_date = 0;
//    reg_data -> cluster_nic_name [0] = _TEXT('\0');
    reg_data -> i_parms_ver = CVY_DEF_VERSION;
    reg_data -> i_virtual_nic_name [0] = _TEXT('\0');
    reg_data -> host_priority = CVY_DEF_HOST_PRIORITY;
    reg_data -> cluster_mode = CVY_DEF_CLUSTER_MODE;
    reg_data -> persisted_states = CVY_DEF_PERSISTED_STATES;
    ARRAYSTRCPY (reg_data -> cl_mac_addr,  CVY_DEF_NETWORK_ADDR);
    ARRAYSTRCPY (reg_data -> cl_ip_addr,  CVY_DEF_CL_IP_ADDR);
    ARRAYSTRCPY (reg_data -> cl_net_mask,  CVY_DEF_CL_NET_MASK);
    ARRAYSTRCPY (reg_data -> ded_ip_addr,  CVY_DEF_DED_IP_ADDR);
    ARRAYSTRCPY (reg_data -> ded_net_mask,  CVY_DEF_DED_NET_MASK);
    ARRAYSTRCPY (reg_data -> domain_name,  CVY_DEF_DOMAIN_NAME);
    reg_data -> alive_period = CVY_DEF_ALIVE_PERIOD;
    reg_data -> alive_tolerance = CVY_DEF_ALIVE_TOLER;
    reg_data -> num_actions = CVY_DEF_NUM_ACTIONS;
    reg_data -> num_packets = CVY_DEF_NUM_PACKETS;
    reg_data -> num_send_msgs = CVY_DEF_NUM_SEND_MSGS;
    reg_data -> dscr_per_alloc = CVY_DEF_DSCR_PER_ALLOC;
    reg_data -> max_dscr_allocs = CVY_DEF_MAX_DSCR_ALLOCS;
    reg_data -> i_scale_client = CVY_DEF_SCALE_CLIENT;
    reg_data -> i_cleanup_delay = CVY_DEF_CLEANUP_DELAY;
    reg_data -> i_ip_chg_delay = CVY_DEF_IP_CHG_DELAY;
    reg_data -> i_nbt_support = CVY_DEF_NBT_SUPPORT;
    reg_data -> mcast_support = CVY_DEF_MCAST_SUPPORT;
    reg_data -> i_mcast_spoof = CVY_DEF_MCAST_SPOOF;
    reg_data -> mask_src_mac = CVY_DEF_MASK_SRC_MAC;
    reg_data -> i_netmon_alive = CVY_DEF_NETMON_ALIVE;
    reg_data -> i_effective_version = CVY_NT40_VERSION_FULL;
    reg_data -> i_convert_mac = CVY_DEF_CONVERT_MAC;
    reg_data -> i_num_rules = 0;
    memset (reg_data -> i_port_rules, 0, sizeof (WLBS_PORT_RULE) * WLBS_MAX_RULES);
    ARRAYSTRCPY (reg_data -> i_license_key,  CVY_DEF_LICENSE_KEY);
    reg_data -> i_rmt_password = CVY_DEF_RMT_PASSWORD;
    reg_data -> i_rct_password = CVY_DEF_RCT_PASSWORD;
    reg_data -> rct_port = CVY_DEF_RCT_PORT;
    reg_data -> rct_enabled = CVY_DEF_RCT_ENABLED;
    reg_data -> i_max_hosts        = CVY_MAX_HOSTS;
    reg_data -> i_max_rules        = CVY_MAX_USABLE_RULES;

    reg_data -> fIGMPSupport = CVY_DEF_IGMP_SUPPORT;
    ARRAYSTRCPY(reg_data -> szMCastIpAddress,  CVY_DEF_MCAST_IP_ADDR);
    reg_data -> fIpToMCastIp = CVY_DEF_IP_TO_MCASTIP;
        
    reg_data->bda_teaming.active = CVY_DEF_BDA_ACTIVE;
    reg_data->bda_teaming.master = CVY_DEF_BDA_MASTER;
    reg_data->bda_teaming.reverse_hash = CVY_DEF_BDA_REVERSE_HASH;
    reg_data->bda_teaming.team_id[0] = CVY_DEF_BDA_TEAM_ID;

    reg_data -> i_num_rules = 1;

    // fill in the first port rule.
    ARRAYSTRCPY(
        reg_data->i_port_rules[0].virtual_ip_addr,
        CVY_DEF_ALL_VIP
        );
    reg_data -> i_port_rules [0] . start_port = CVY_DEF_PORT_START;
    reg_data -> i_port_rules [0] . end_port = CVY_DEF_PORT_END;
    reg_data -> i_port_rules [0] . valid = TRUE;
    reg_data -> i_port_rules [0] . mode = CVY_DEF_MODE;
    reg_data -> i_port_rules [0] . mode_data . multi . equal_load = TRUE;
    reg_data -> i_port_rules [0] . mode_data . multi . affinity   = CVY_DEF_AFFINITY;
    reg_data -> i_port_rules [0] . mode_data . multi . load       = CVY_DEF_LOAD;
    reg_data -> i_port_rules [0] . protocol = CVY_DEF_PROTOCOL;
    CVY_RULE_CODE_SET(& reg_data -> i_port_rules [0]);

    return WLBS_OK;
}


DWORD MyWlbsEnumPortRules
(
    const PWLBS_REG_PARAMS reg_data,
    PWLBS_PORT_RULE  rules,
    PDWORD           num_rules
)
{

    DWORD count_rules, i, index;
    DWORD lowest_vip, lowest_port;
    BOOL array_flags [WLBS_MAX_RULES];
    WLBS_PORT_RULE sorted_rules [WLBS_MAX_RULES];

    if ((reg_data == NULL) || (num_rules == NULL))
    {
        return WLBS_BAD_PARAMS;
    }

    if (*num_rules == 0)
        rules = NULL;
    /* this array is used for keeping track of which rules have already been retrieved */
    /* This is needed since the rules are to be retrieved in the sorted order */

    memset ( array_flags, 0, sizeof(BOOL) * WLBS_MAX_RULES );

    count_rules = 0;

    while ((count_rules < *num_rules) && (count_rules < reg_data -> i_num_rules))
    {
        i = 0;

        /* find the first rule that has not been retrieved */
        while ((! reg_data -> i_port_rules [i] . valid) || array_flags [i])
        {
            i++;
        }

        lowest_vip = htonl(IpAddressFromAbcdWsz(reg_data -> i_port_rules [i] . virtual_ip_addr));
        lowest_port = reg_data -> i_port_rules [i] . start_port;
        index = i;

        /* Compare that rule with the other non-retrieved rules to get the rule with the
           lowest VIP & start_port */

        i++;
        while (i < WLBS_MAX_RULES)
        {
            if (reg_data -> i_port_rules [i] . valid && ( ! array_flags [i] ))
            {
                DWORD current_vip = htonl(IpAddressFromAbcdWsz(reg_data -> i_port_rules [i] . virtual_ip_addr));
                if ((current_vip < lowest_vip) 
                 || ((current_vip == lowest_vip) && (reg_data -> i_port_rules [i] . start_port < lowest_port)))
                {
                    lowest_vip = current_vip;
                    lowest_port = reg_data -> i_port_rules [i] . start_port;
                    index = i;
                }
            }
            i++;
        }
        /*       The array_flags [i] element is set to TRUE if the rule is retrieved */
        array_flags [index] = TRUE;
        sorted_rules [count_rules] = reg_data -> i_port_rules [index];
        count_rules ++;
    }

    /* write the sorted rules back into the return array */
    for (i = 0; i < count_rules; i++)
    {
        rules[i] = sorted_rules[i];
    }

    /* invalidate the remaining rules in the buffer */
    for (i = count_rules; i < *num_rules; i++)
        rules [i] . valid = FALSE;

    if (*num_rules < reg_data -> i_num_rules)
    {
        *num_rules = reg_data -> i_num_rules;
        return WLBS_TRUNCATED;
    }

    *num_rules = reg_data -> i_num_rules;
    return WLBS_OK;

} /* end WlbsEnumPortRules */


VOID MyWlbsDeleteAllPortRules
(
    PWLBS_REG_PARAMS reg_data
)
{

    reg_data -> i_num_rules = 0;

    ZeroMemory(reg_data -> i_port_rules, sizeof(reg_data -> i_port_rules));


} /* end WlbsDeleteAllPortRules */


DWORD MyWlbsAddPortRule
(
    PWLBS_REG_PARAMS reg_data,
    const PWLBS_PORT_RULE rule
)
{

    int i;
    DWORD vip;

    if ((reg_data == NULL) || (rule == NULL))
    {
        return WLBS_BAD_PARAMS;
    }

    /* Check if there is space for the new rule */
    if (reg_data -> i_num_rules == WLBS_MAX_RULES)
    {
        return WLBS_MAX_PORT_RULES;
    }

    /* check the rule for valid values */

    /* check for non-zero vip and conflict with dip */
    vip = IpAddressFromAbcdWsz(rule -> virtual_ip_addr);
    if (vip == 0 || (INADDR_NONE == vip && lstrcmpi(rule -> virtual_ip_addr, CVY_DEF_ALL_VIP) != 0))
    {
        return WLBS_BAD_PORT_PARAMS;
    }

    if (vip == IpAddressFromAbcdWsz(reg_data->ded_ip_addr))
    {
        return WLBS_BAD_PORT_PARAMS;
    }

    /* first check the range of the start and end ports */
    if ((rule -> start_port > rule -> end_port) ||
// CLEAN_64BIT        (rule -> start_port < CVY_MIN_PORT)     ||
        (rule -> end_port   > CVY_MAX_PORT))
    {
        return WLBS_BAD_PORT_PARAMS;
    }

    /* check the protocol range */
    if ((rule -> protocol < CVY_MIN_PROTOCOL) || (rule -> protocol > CVY_MAX_PROTOCOL))
    {
        return WLBS_BAD_PORT_PARAMS;
    }

    /* check filtering mode to see whether it is within range */
    if ((rule -> mode < CVY_MIN_MODE) || (rule -> mode > CVY_MAX_MODE))
    {
        return WLBS_BAD_PORT_PARAMS;
    }

    /* check load weight and affinity if multiple hosts */
    if (rule -> mode == CVY_MULTI)
    {
        if ((rule -> mode_data . multi . affinity < CVY_MIN_AFFINITY) ||
            (rule -> mode_data . multi . affinity > CVY_MAX_AFFINITY))
        {
            return WLBS_BAD_PORT_PARAMS;
        }

        if ((rule -> mode_data . multi . equal_load < CVY_MIN_EQUAL_LOAD) ||
            (rule -> mode_data . multi . equal_load > CVY_MAX_EQUAL_LOAD))
        {
            return WLBS_BAD_PORT_PARAMS;
        }

        if (! rule -> mode_data . multi . equal_load)
        {
            if ((rule -> mode_data . multi . load > CVY_MAX_LOAD))
                //CLEAN_64BIT (rule -> mode_data . multi . load < CVY_MIN_LOAD) ||
            {
                return WLBS_BAD_PORT_PARAMS;
            }
        }
    }

    /* check handling priority range if single host */
    if (rule -> mode == CVY_SINGLE)
    {
        if ((rule -> mode_data . single . priority < CVY_MIN_PRIORITY) ||
            (rule -> mode_data . single . priority > CVY_MAX_PRIORITY))
        {
            return WLBS_BAD_PORT_PARAMS;
        }
    }

    /* go through the rule list and then check for overlapping conditions */
    for (i = 0; i < WLBS_MAX_RULES; i++)
    {
        if (reg_data -> i_port_rules[i] . valid == TRUE)
        {
            if ((IpAddressFromAbcdWsz(reg_data -> i_port_rules[i] . virtual_ip_addr) == vip) 
            && (( (reg_data -> i_port_rules[i] . start_port <= rule -> start_port) &&
                  (reg_data -> i_port_rules[i] . end_port   >= rule -> start_port))      ||
                ( (reg_data -> i_port_rules[i] . start_port >= rule -> start_port)   &&
                  (reg_data -> i_port_rules[i] . start_port <= rule -> end_port))))
            {
                return WLBS_PORT_OVERLAP;
            }
        }
    }


    /* go through the rule list and find out the first empty spot
       and write out the port rule */

    for (i = 0 ; i < WLBS_MAX_RULES ; i++)
    {
        if (reg_data -> i_port_rules[i] . valid == FALSE)
        {
            reg_data -> i_num_rules ++ ;
            reg_data -> i_port_rules [i] = *rule;
            reg_data -> i_port_rules [i] . valid = TRUE;
            CVY_RULE_CODE_SET(& reg_data -> i_port_rules [i]);
            return WLBS_OK;
        }
    }

    return WLBS_MAX_PORT_RULES;

} /* end WlbsAddPortRule */


BOOL MyWlbsValidateParams(
    const PWLBS_REG_PARAMS paramp
    )
{
// Following stolen from wlbs\api
#define WLBS_FIELD_LOW 0
#define WLBS_FIELD_HIGH 255
#define WLBS_IP_FIELD_ZERO_LOW 1
#define WLBS_IP_FIELD_ZERO_HIGH 223


    bool fRet = FALSE;
    DWORD   idx;
    IN_ADDR dwIPAddr;
    CHAR *  szIPAddr;
    DWORD   num_rules;
    WLBS_PORT_RULE *port_rule;

    /* verify and if necessary reset the parameters */

    //
    // We don't validate the lower bound for unsigned words when the lower bound is 0. Otherwise we
    // get a compiler warning, promoted to an error, because such a test can't fail
    //
    // Ignore lower bound checking
    //
    CVY_CHECK_MAX (paramp -> i_scale_client, CVY_MAX_SCALE_CLIENT);

    CVY_CHECK_MAX (paramp -> i_nbt_support, CVY_MAX_NBT_SUPPORT);

    CVY_CHECK_MAX (paramp -> mcast_support, CVY_MAX_MCAST_SUPPORT);

    CVY_CHECK_MAX (paramp -> i_mcast_spoof, CVY_MAX_MCAST_SPOOF);

    CVY_CHECK_MAX (paramp -> mask_src_mac, CVY_MAX_MASK_SRC_MAC);

    CVY_CHECK_MAX (paramp -> i_netmon_alive, CVY_MAX_NETMON_ALIVE);

    CVY_CHECK_MAX (paramp -> i_convert_mac, CVY_MAX_CONVERT_MAC);

    CVY_CHECK_MAX (paramp -> rct_port, CVY_MAX_RCT_PORT);

    CVY_CHECK_MAX (paramp -> rct_enabled, CVY_MAX_RCT_ENABLED);

    CVY_CHECK_MAX (paramp -> i_cleanup_delay, CVY_MAX_CLEANUP_DELAY);

    CVY_CHECK_MAX (paramp -> i_ip_chg_delay, CVY_MAX_IP_CHG_DELAY);

    CVY_CHECK_MAX (paramp -> i_num_rules, CVY_MAX_NUM_RULES);

    CVY_CHECK_MAX (paramp -> cluster_mode, CVY_MAX_CLUSTER_MODE);
    //
    // End Ignore lower bound checking
    //

    //
    // CVY_NAME_VERSION is not validated since its value is used and manipulated before we get here
    // CVY_NAME_LICENSE_KEY is not validated since it can take any value.
    // RMT_PASSWORD is not validated since it can take any storable value
    // RCT_PASSWORD is not validated since it can take any storable value
    // CVY_NAME_IGMP_SUPPORT is not validated because it is of BOOL type and can thus take any value
    // CVY_NAME_IP_TO_MCASTIP is not validated because it is of BOOL type and can thus take any value
    // 

    CVY_CHECK_MIN (paramp -> alive_period, CVY_MIN_ALIVE_PERIOD);
    CVY_CHECK_MAX (paramp -> alive_period, CVY_MAX_ALIVE_PERIOD);

    CVY_CHECK_MIN (paramp -> alive_tolerance, CVY_MIN_ALIVE_TOLER);
    CVY_CHECK_MAX (paramp -> alive_tolerance, CVY_MAX_ALIVE_TOLER);

    CVY_CHECK_MIN (paramp -> num_actions, CVY_MIN_NUM_ACTIONS);
    CVY_CHECK_MAX (paramp -> num_actions, CVY_MAX_NUM_ACTIONS);

    CVY_CHECK_MIN (paramp -> num_packets, CVY_MIN_NUM_PACKETS);
    CVY_CHECK_MAX (paramp -> num_packets, CVY_MAX_NUM_PACKETS);

    CVY_CHECK_MIN (paramp -> dscr_per_alloc, CVY_MIN_DSCR_PER_ALLOC);
    CVY_CHECK_MAX (paramp -> dscr_per_alloc, CVY_MAX_DSCR_PER_ALLOC);

    CVY_CHECK_MIN (paramp -> max_dscr_allocs, CVY_MIN_MAX_DSCR_ALLOCS);
    CVY_CHECK_MAX (paramp -> max_dscr_allocs, CVY_MAX_MAX_DSCR_ALLOCS);

    CVY_CHECK_MIN (paramp -> num_send_msgs, (paramp -> i_max_hosts + 1) * 2);
    CVY_CHECK_MAX (paramp -> num_send_msgs, (paramp -> i_max_hosts + 1) * 10);

    CVY_CHECK_MIN (paramp -> host_priority, CVY_MIN_HOST_PRIORITY);
    CVY_CHECK_MAX (paramp -> host_priority, CVY_MAX_HOST_PRIORITY);

    /* If the cluster IP address is not 0.0.0.0, then make sure the IP address is valid. */
    if (lstrcmpi(paramp->cl_ip_addr, CVY_DEF_CL_IP_ADDR)) {
        /* Check the validity of the IP address. */
        if (!(dwIPAddr.S_un.S_addr = IpAddressFromAbcdWsz(paramp->cl_ip_addr)))
            goto error;
        
        /* Convert the DWORD back to a string.  We do this because 11.11.3 is a valid IP
           address the inet_addr converts to 11.11.0.3 as a DWORD.  Therefore, to keep
           the IP address string (which is used by other parts of NLB, such as the UI)
           consistent, we convert back to a string. */
        if (!(szIPAddr = inet_ntoa(dwIPAddr))) 
            goto error;

        /* Convert the ASCII string to unicode. */
        if (!MultiByteToWideChar(CP_ACP, 0, szIPAddr, -1, paramp->cl_ip_addr, WLBS_MAX_CL_IP_ADDR + 1))
            goto error;
    }

    /* If the cluster netmask is not 0.0.0.0, then make sure the netmask is valid. */
    if (lstrcmpi(paramp->cl_net_mask, CVY_DEF_CL_NET_MASK)) {
        /* Check the validity of the IP address. */
        if (!(dwIPAddr.S_un.S_addr = IpAddressFromAbcdWsz(paramp->cl_net_mask)))
            goto error;
        
        /* Convert the DWORD back to a string.  We do this because 11.11.3 is a valid IP
           address the inet_addr converts to 11.11.0.3 as a DWORD.  Therefore, to keep
           the IP address string (which is used by other parts of NLB, such as the UI)
           consistent, we convert back to a string. */
        if (!(szIPAddr = inet_ntoa(dwIPAddr))) 
            goto error;

        /* Convert the ASCII string to unicode. */
        if (!MultiByteToWideChar(CP_ACP, 0, szIPAddr, -1, paramp->cl_net_mask, WLBS_MAX_CL_NET_MASK + 1))
            goto error;
    }

    /* If the dedicated IP address is not 0.0.0.0, then make sure the IP address is valid. */
    if (lstrcmpi(paramp->ded_ip_addr, CVY_DEF_DED_IP_ADDR)) {
        /* Check the validity of the IP address. */
        if (!(dwIPAddr.S_un.S_addr = IpAddressFromAbcdWsz(paramp->ded_ip_addr)))
            goto error;
        
        /* Convert the DWORD back to a string.  We do this because 11.11.3 is a valid IP
           address the inet_addr converts to 11.11.0.3 as a DWORD.  Therefore, to keep
           the IP address string (which is used by other parts of NLB, such as the UI)
           consistent, we convert back to a string. */
        if (!(szIPAddr = inet_ntoa(dwIPAddr))) 
            goto error;

        /* Convert the ASCII string to unicode. */
        if (!MultiByteToWideChar(CP_ACP, 0, szIPAddr, -1, paramp->ded_ip_addr, WLBS_MAX_DED_IP_ADDR + 1))
            goto error;
    }

    /* If the dedicated netmask is not 0.0.0.0, then make sure the netmask is valid. */
    if (lstrcmpi(paramp->ded_net_mask, CVY_DEF_DED_NET_MASK)) {
        /* Check the validity of the IP address. */
        if (!(dwIPAddr.S_un.S_addr = IpAddressFromAbcdWsz(paramp->ded_net_mask)))
            goto error;
        
        /* Convert the DWORD back to a string.  We do this because 11.11.3 is a valid IP
           address the inet_addr converts to 11.11.0.3 as a DWORD.  Therefore, to keep
           the IP address string (which is used by other parts of NLB, such as the UI)
           consistent, we convert back to a string. */
        if (!(szIPAddr = inet_ntoa(dwIPAddr))) 
            goto error;

        /* Convert the ASCII string to unicode. */
        if (!MultiByteToWideChar(CP_ACP, 0, szIPAddr, -1, paramp->ded_net_mask, WLBS_MAX_DED_NET_MASK + 1))
            goto error;
    }

    /* Verify that the port rule VIP is valid, 
       Also, convert the port rule VIPs that might be in the x.x.x or x.x or x form to x.x.x.x */
    idx = 0;
    num_rules = paramp -> i_num_rules;
    while (idx < num_rules) 
    {
        port_rule = &paramp->i_port_rules[idx];

        /* Check if the port rule is valid and the vip is not "All Vip" */
        if (port_rule->valid && lstrcmpi(port_rule->virtual_ip_addr, CVY_DEF_ALL_VIP)) 
        {
            /* Get IP Address into DWORD form */
            if (!(dwIPAddr.S_un.S_addr = IpAddressFromAbcdWsz(port_rule->virtual_ip_addr)))
                goto error;

            /* Check for validity of IP Address */
            if ((dwIPAddr.S_un.S_un_b.s_b1 < WLBS_IP_FIELD_ZERO_LOW) 
             || (dwIPAddr.S_un.S_un_b.s_b1 > WLBS_IP_FIELD_ZERO_HIGH) 
             || (dwIPAddr.S_un.S_un_b.s_b2 < WLBS_FIELD_LOW) 
             || (dwIPAddr.S_un.S_un_b.s_b2 > WLBS_FIELD_HIGH) 
             || (dwIPAddr.S_un.S_un_b.s_b3 < WLBS_FIELD_LOW) 
             || (dwIPAddr.S_un.S_un_b.s_b3 > WLBS_FIELD_HIGH) 
             || (dwIPAddr.S_un.S_un_b.s_b4 < WLBS_FIELD_LOW) 
             || (dwIPAddr.S_un.S_un_b.s_b4 > WLBS_FIELD_HIGH)) 
                goto error;

            /* Convert the DWORD back to a string.  We do this because 11.11.3 is a valid IP
               address the inet_addr converts to 11.11.0.3 as a DWORD.  Therefore, to keep
               the IP address string (which is used by other parts of NLB, such as the UI)
               consistent, we convert back to a string. */
            if (!(szIPAddr = inet_ntoa(dwIPAddr))) 
                goto error;

            /* Convert the ASCII string to unicode. */
            if (!MultiByteToWideChar(CP_ACP, 0, szIPAddr, -1, port_rule->virtual_ip_addr, WLBS_MAX_CL_IP_ADDR + 1))
                goto error;
        }
        idx++;
    }

    /* If either the cluster IP address or the cluster netmask is not 0.0.0.0,
       then make sure the they are a valid IP address/netmask pair. */
    if (lstrcmpi(paramp->cl_ip_addr, CVY_DEF_CL_IP_ADDR) || lstrcmpi(paramp->cl_net_mask, CVY_DEF_CL_NET_MASK)) {
        /* If they have specified a cluster IP address, but no netmask, then fill it in for them. */
        if (!lstrcmpi(paramp->cl_net_mask, CVY_DEF_CL_NET_MASK))
        {
            ParamsGenerateSubnetMask(paramp->cl_ip_addr, paramp->cl_net_mask, ASIZECCH(paramp->cl_net_mask));
        }

        /* Check for valid cluster IP address/netmask pairs. */
        if (!IsValidIPAddressSubnetMaskPair(paramp->cl_ip_addr, paramp->cl_net_mask))
            goto error;
        
        /* Check to make sure that the cluster netmask is contiguous. */
        if (!IsContiguousSubnetMask(paramp->cl_net_mask))
            goto error;

        /* Check to make sure that the dedicated IP and cluster IP are not the same. */
        if (!wcscmp(paramp->ded_ip_addr, paramp->cl_ip_addr))
            goto error;
    }

    /* If either the dedicated IP address or the dedicated netmask is not 0.0.0.0,
       then make sure the they are a valid IP address/netmask pair. */
    if (lstrcmpi(paramp->ded_ip_addr, CVY_DEF_DED_IP_ADDR) || lstrcmpi(paramp->ded_net_mask, CVY_DEF_DED_NET_MASK)) {
        /* If they have specified a cluster IP address, but no netmask, then fill it in for them. */
        if (!lstrcmpi(paramp->ded_net_mask, CVY_DEF_DED_NET_MASK))
        {
            ParamsGenerateSubnetMask(paramp->ded_ip_addr, paramp->ded_net_mask, ASIZECCH(paramp->ded_net_mask));
        }

        /* Check for valid dedicated IP address/netmask pairs. */
        if (!IsValidIPAddressSubnetMaskPair(paramp->ded_ip_addr, paramp->ded_net_mask))
            goto error;
        
        /* Check to make sure that the dedicated netmask is contiguous. */
        if (!IsContiguousSubnetMask(paramp->ded_net_mask))
            goto error;
    }

    /* Check the mac address if the convert_mac flag is not set */
    if ( ! paramp -> i_convert_mac)
    {
        PWCHAR p1, p2;
        WCHAR mac_addr [WLBS_MAX_NETWORK_ADDR + 1];
        DWORD i, j;
        BOOL flag = TRUE;

        ARRAYSTRCPY (mac_addr,  paramp -> cl_mac_addr);

        p2 = p1 = mac_addr;

        for (i = 0 ; i < 6 ; i++)
        {
            if (*p2 == _TEXT('\0'))
            {
                flag = FALSE;
                break;
            }

            j = _tcstoul (p1, &p2, 16);

            if ( j > 255)
            {
                flag = FALSE;
                break;
            }

            if ( ! (*p2 == _TEXT('-') || *p2 == _TEXT(':') || *p2 == _TEXT('\0')) )
            {
                flag = FALSE;
                break;
            }

            if (*p2 == _TEXT('\0') && i < 5)
            {
                flag = FALSE;
                break;
            }

            p1 = p2 + 1;
            p2 = p1;

        }


        if (!flag)
        {
            goto error;
        }
    }

    if (paramp->fIGMPSupport && !paramp->mcast_support)
    {
        //
        // IGMP can not be enabled in unicast mode
        //

        goto error;
    }

    if (paramp->mcast_support && paramp->fIGMPSupport && !paramp->fIpToMCastIp)
    {
        //
        // Verify that the multicast IP is a valid IP form. Ignore default value case since it isn't a valid IP.
        // 
        if (lstrcmpi(paramp -> szMCastIpAddress, CVY_DEF_MCAST_IP_ADDR)) {
            /* Check the validity of the IP address. */
            if (!(dwIPAddr.S_un.S_addr = IpAddressFromAbcdWsz(paramp -> szMCastIpAddress)))
                goto error;
        
            /* Convert the DWORD back to a string.  We do this because 11.11.3 is a valid IP
               address the inet_addr converts to 11.11.0.3 as a DWORD.  Therefore, to keep
               the IP address string (which is used by other parts of NLB, such as the UI)
               consistent, we convert back to a string. */
            if (!(szIPAddr = inet_ntoa(dwIPAddr))) 
                goto error;

            /* Convert the ASCII string to unicode. */
            if (!MultiByteToWideChar(CP_ACP, 0, szIPAddr, -1, paramp -> szMCastIpAddress, WLBS_MAX_CL_IP_ADDR + 1))
                goto error;
        }

        //
        // Multicast mode with IGMP enabled, and user specified an multicast IP address,
        // The multicast IP address should be in the range of (224-239).x.x.x 
        //       but NOT (224-239).0.0.x or (224-239).128.0.x. 
        //

        DWORD dwMCastIp = IpAddressFromAbcdWsz(paramp->szMCastIpAddress);

        if ((dwMCastIp & 0xf0) != 0xe0 ||
            (dwMCastIp & 0x00ffff00) == 0 || 
            (dwMCastIp & 0x00ffff00) == 0x00008000)
        {
            goto error;
        }
    }

    /* Generate the MAC address. */
    ParamsGenerateMAC(paramp->cl_ip_addr, paramp->cl_mac_addr, ASIZECCH(paramp->cl_mac_addr), paramp->szMCastIpAddress, ASIZECCH(paramp->szMCastIpAddress), paramp->i_convert_mac, 
                      paramp->mcast_support, paramp->fIGMPSupport, paramp->fIpToMCastIp);

    //
    // We only process bda information if bda teaming is active. We can ignore these properties if it isn't. Dependencies
    // such as WriteRegParam will check this too to see if they should process the information.
    //
    if (paramp -> bda_teaming . active) {
        GUID TeamGuid;
        HRESULT hr;

        //
        // We don't validate the lower bound for unsigned words when the lower bound is 0. Otherwise we
        // get a compiler warning, promoted to an error, because such a test can't fail
        //
        // Ignore lower bound checking
        //
        CVY_CHECK_MAX (paramp -> bda_teaming . master, 1);

        CVY_CHECK_MAX (paramp -> bda_teaming . reverse_hash, 1);
        //
        // End Ignore lower bound checking
        //

        //
        // A teaming ID must be a GUID. Validate that it is, but we don't care what value. This means we ignore
        // the content of TeamGuid.
        //
        hr = CLSIDFromString(paramp -> bda_teaming . team_id, &TeamGuid);

        // If the conversion fails, bail out - the team ID must not have been a GUID
        if (hr != NOERROR) {
            goto error;
        }
    }    
    
    fRet = TRUE;
    goto end;
    
error:
    fRet = FALSE;
    goto end;

end:
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\application.cpp ===
#include "precomp.h"
#pragma hdrstop
#include "private.h"
#include "engine.h"
#include "resource.h"
#include "Document.h"
#include "Application.h"
#include "MainForm.h"
#include "AboutDialog.h"
#include "application.tmh"
#include <process.h>

Application theApplication;

MUsingCom usingCom;

BOOL CanRunNLB(void);

BEGIN_MESSAGE_MAP( Application, CWinApp )
    ON_COMMAND( ID_HELP, OnHelp )
    ON_COMMAND( ID_APP_ABOUT, OnAppAbout )
END_MESSAGE_MAP()

// #define szNLBMGRREG_DISABLE_DISCLAIMER L"DisableNlbMgrDisclaimer"


#if DBG
//
// Allow the DEMO cmdline option
//
#define ALLOW_DEMO 1
#endif //DBG

BOOL NoAdminNics(void);


void
CNlbMgrCommandLineInfo::ParseParam(
     LPCTSTR lpszParam,
     BOOL bFlag,
     BOOL bLast
     )
//
// -demo 
// -hostlist file.txt
// -help -?
// -autoresfresh
// -noping
{
    static enum Commands {
        None = 0,
        Demo,
        NoPing,
        HostList,
        AutoRefresh
    };

    static UINT LastCommand = None;

    TRACE_VERB("-> %!FUNC! (szParm=\"%ws\", bFlag=%lu, bLast=%lu)", lpszParam, bFlag, bLast);

    if (m_bUsage)
    {
        goto end;
    }

    if (bFlag)
    {
        /* Throw an error if this is a flag, but the last command was the
           HostList command, which REQUIRES a non-flag argument following it. */
        if (LastCommand == HostList)
        {
            /* Turn the host list option off to keep NLB manager 
               from trying to open  NULL filename. */
            m_bHostList = FALSE;

            m_bUsage = TRUE; // error
            goto end;
        }

    #if ALLOW_DEMO
        if (!_wcsicmp(lpszParam, L"demo"))
        {
            if (m_bDemo)
            {
                m_bUsage = TRUE; // error
                goto end;
            }

            m_bDemo = TRUE;
            LastCommand = Demo;
        }
        else
    #endif // ALLOW_DEMO
        if (!_wcsicmp(lpszParam, L"noping"))
        {
            if (m_bNoPing)
            {
                m_bUsage = TRUE; // error
                goto end;
            }

            m_bNoPing = TRUE;
            LastCommand = NoPing;
        }
        else if (!_wcsicmp(lpszParam, L"hostlist"))
        {
            if (m_bHostList || bLast)
            {
                m_bUsage = TRUE; // error
                goto end;
            }
            
            m_bHostList = TRUE;
            LastCommand = HostList;
        }
        else if (!_wcsicmp(lpszParam, L"autorefresh"))
        {
            if (m_bAutoRefresh) 
            {
                m_bUsage = TRUE; // error
                goto end;
            }

            m_bAutoRefresh = TRUE;
            LastCommand = AutoRefresh;
        }
        else
        {
            m_bUsage = TRUE; // error or help
        }
    }
    else
    {
        switch (LastCommand) {
        case None:
            m_bUsage = TRUE; // error
            break;
        case Demo:
            m_bUsage = TRUE; // error
            break;
        case NoPing:
            m_bUsage = TRUE; // error
            break;
        case HostList:
            m_bstrHostListFile = _bstr_t(lpszParam); // read the file name of the host list
            break;
        case AutoRefresh:
            m_refreshInterval = _wtoi(lpszParam); // read the refresh interval

            /* If the specified refresh interval is too small to be practical, re-set it. */
            if (m_refreshInterval < NLBMGR_AUTOREFRESH_MIN_INTERVAL)
                m_refreshInterval = NLBMGR_AUTOREFRESH_MIN_INTERVAL;

            break;
        default:
            m_bUsage = TRUE; // error
            break;
        }
        
        /* Re-set the last command. */
        LastCommand = None;
    }

end:

    TRACE_VERB("%!FUNC! <-");
}


BOOL
Application::ProcessShellCommand(
     CNlbMgrCommandLineInfo& rCmdInfo
     )
{
    BOOL fRet = FALSE;
    LPCWSTR szFile = NULL;
    TRACE_CRIT("-> %!FUNC!");

    fRet = CWinApp::ProcessShellCommand(rCmdInfo);

    if (!fRet)
    {
        goto end; 
    }

    szFile = (LPCWSTR) rCmdInfo.m_bstrHostListFile;
    if (szFile==NULL)
    {
        szFile = L"<null>";
    }

    TRACE_VERB("%!FUNC! bUsage=%lu bDemo=%lu bNoPing=%lu bHostList=%lu szFile=\"%ws\"",
        rCmdInfo.m_bUsage,
        rCmdInfo.m_bDemo,
        rCmdInfo.m_bNoPing,
        rCmdInfo.m_bHostList,
        szFile
        );

    if (rCmdInfo.m_bUsage)
    {
        _bstr_t bstrMsg     = GETRESOURCEIDSTRING( IDS_USAGE_MESSAGE );
        _bstr_t bstrTitle   = GETRESOURCEIDSTRING( IDS_USAGE_TITLE );

        ::MessageBox(
             NULL,
             (LPCWSTR) bstrMsg, 
             (LPCWSTR) bstrTitle,
             MB_ICONINFORMATION   | MB_OK
            );
        fRet = FALSE;
    }
    else
    {
        if (rCmdInfo.m_bDemo)
        {
            _bstr_t bstrMsg     = GETRESOURCEIDSTRING( IDS_DEMO_MESSAGE );
            _bstr_t bstrTitle   = GETRESOURCEIDSTRING( IDS_DEMO_TITLE );
            ::MessageBox(
                 NULL,
                 (LPCWSTR) bstrMsg,
                 (LPCWSTR) bstrTitle,
                 MB_ICONINFORMATION   | MB_OK
                );
        }
        fRet = TRUE;
    }

end:

    TRACE_CRIT("<- %!FUNC! returns %lu", fRet);
    return fRet;
}


BOOL
Application::InitInstance()
{
    BOOL fRet = FALSE;
    
    WPP_INIT_TRACING(L"Microsoft\\NLB\\TPROV");

    TRACE_INFO("------------ APPLICATION INITITIALIZATION -------------");

    //
    // Set the current thread id as the main thread id
    //
    m_dwMainThreadId = GetCurrentThreadId();

    ParseCommandLine(gCmdLineInfo);

    m_pSingleDocumentTemplate =
        new CSingleDocTemplate( IDR_MAINFRAME,
                                RUNTIME_CLASS( Document ),
                                RUNTIME_CLASS( MainForm ),
                                RUNTIME_CLASS( LeftView) );

    AddDocTemplate( m_pSingleDocumentTemplate );

    //
    // NOTE: ProcessShellCommand is our (Application) own version. It
    // calls CWinApp::ProcessShellCommand.
    //
    fRet = ProcessShellCommand( gCmdLineInfo );

	if (!fRet)
	{
	    goto end;
	}

    fRet = CanRunNLB();

    // fall through...

end:

    if (!fRet)
    {
        // Deinit tracing here.
        WPP_CLEANUP();
    }


    return fRet;
}


void
Application::OnAppAbout()
{
    AboutDialog aboutDlg;
    aboutDlg.DoModal();
}

void
Application::OnHelp()
{
    WCHAR wbuf[CVY_STR_SIZE];

    /* Spawn the windows help process. */
    StringCbPrintf(wbuf, sizeof(wbuf), L"%ls\\help\\%ls", _wgetenv(L"WINDIR"), CVY_HELP_FILE);
    _wspawnlp(P_NOWAIT, L"hh.exe", L"hh.exe", wbuf, NULL);
}

BOOL CanRunNLB(void)
/*
	Checks if NLB can run on the current machine. The main check is to make sure that there is atleast one active NIC without NLB bound.
*/
{
    if (NoAdminNics())
    {

        ::MessageBox(
             NULL,
             GETRESOURCEIDSTRING( IDS_CANTRUN_NONICS_TEXT), // Contents
             GETRESOURCEIDSTRING( IDS_CANTRUN_NONICS_CAPTION), // caption
             MB_ICONSTOP | MB_OK );
    }
    else
    {
        // ::ShowDisclaimer();
    }

	return TRUE;
}



//
// This class manages NetCfg interfaces
//
class AppMyNetCfg
{

public:

    AppMyNetCfg(VOID)
    {
        m_pINetCfg  = NULL;
        m_pLock     = NULL;
    }

    ~AppMyNetCfg()
    {
        ASSERT(m_pINetCfg==NULL);
        ASSERT(m_pLock==NULL);
    }

    WBEMSTATUS
    Initialize(
        BOOL fWriteLock
        );

    VOID
    Deinitialize(
        VOID
        );


    WBEMSTATUS
    GetNlbCompatibleNics(
        OUT LPWSTR **ppszNics,
        OUT UINT   *pNumNics,
        OUT UINT   *pNumBoundToNlb // OPTIONAL
        );

    WBEMSTATUS
    GetBindingIF(
        IN  LPCWSTR                     szComponent,
        OUT INetCfgComponentBindings   **ppIBinding
        );

private:

    INetCfg     *m_pINetCfg;
    INetCfgLock *m_pLock;

}; // Class AppMyNetCfg


WBEMSTATUS
AppMyNetCfg::Initialize(
    BOOL fWriteLock
    )
{
    HRESULT     hr;
    INetCfg     *pnc = NULL;
    INetCfgLock *pncl = NULL;
    WBEMSTATUS  Status = WBEM_E_CRITICAL_ERROR;
    BOOL        fLocked = FALSE;
    BOOL        fInitialized=FALSE;
    
    if (m_pINetCfg != NULL || m_pLock != NULL)
    {
        ASSERT(FALSE);
        goto end;
    }

    hr = CoCreateInstance( CLSID_CNetCfg, 
                           NULL, 
                           CLSCTX_SERVER, 
                           IID_INetCfg, 
                           (void **) &pnc);

    if( !SUCCEEDED( hr ) )
    {
        // failure to create instance.
        //TRACE_CRIT("ERROR: could not get interface to Net Config");
        goto end;
    }

    //
    // If require, get the write lock
    //
    if (fWriteLock)
    {
        WCHAR *szLockedBy = NULL;
        hr = pnc->QueryInterface( IID_INetCfgLock, ( void **) &pncl );
        if( !SUCCEEDED( hr ) )
        {
            //TRACE_CRIT("ERROR: could not get interface to NetCfg Lock");
            goto end;
        }

        hr = pncl->AcquireWriteLock( 1, // One Second
                                     L"NLBManager",
                                     &szLockedBy);
        if( hr != S_OK )
        {
            //TRACE_CRIT("Could not get write lock. Lock held by %ws",
            // (szLockedBy!=NULL) ? szLockedBy : L"<null>");
            goto end;
            
        }
    }

    // Initializes network configuration by loading into 
    // memory all basic networking information
    //
    hr = pnc->Initialize( NULL );
    if( !SUCCEEDED( hr ) )
    {
        // failure to Initialize
        //TRACE_CRIT("INetCfg::Initialize failure ");
        goto end;
    }

    Status = WBEM_NO_ERROR; 
    
end:

    if (FAILED(Status))
    {
        if (pncl!=NULL)
        {
            if (fLocked)
            {
                pncl->ReleaseWriteLock();
            }
            pncl->Release();
            pncl=NULL;
        }
        if( pnc != NULL)
        {
            if (fInitialized)
            {
                pnc->Uninitialize();
            }
            pnc->Release();
            pnc= NULL;
        }
    }
    else
    {
        m_pINetCfg  = pnc;
        m_pLock     = pncl;
    }

    return Status;
}


VOID
AppMyNetCfg::Deinitialize(
    VOID
    )
{
    if (m_pLock!=NULL)
    {
        m_pLock->ReleaseWriteLock();
        m_pLock->Release();
        m_pLock=NULL;
    }
    if( m_pINetCfg != NULL)
    {
        m_pINetCfg->Uninitialize();
        m_pINetCfg->Release();
        m_pINetCfg= NULL;
    }
}





WBEMSTATUS
AppMyNetCfg::GetNlbCompatibleNics(
        OUT LPWSTR **ppszNics,
        OUT UINT   *pNumNics,
        OUT UINT   *pNumBoundToNlb // OPTIONAL
        )
/*
    Returns an array of pointers to string-version of GUIDS
    that represent the set of alive and healthy NICS that are
    suitable for NLB to bind to -- basically alive ethernet NICs.

    Delete ppNics using the delete WCHAR[] operator. Do not
    delete the individual strings.
*/
{
    #define MY_GUID_LENGTH  38

    WBEMSTATUS  Status = WBEM_E_CRITICAL_ERROR;
    HRESULT hr;
    IEnumNetCfgComponent* pencc = NULL;
    INetCfgComponent *pncc = NULL;
    ULONG                 countToFetch = 1;
    ULONG                 countFetched;
    UINT                  NumNics = 0;
    LPWSTR               *pszNics = NULL;
    INetCfgComponentBindings    *pINlbBinding=NULL;
    UINT                  NumNlbBoundNics = 0;

    typedef struct _MYNICNODE MYNICNODE;

    typedef struct _MYNICNODE
    {
        LPWSTR szNicGuid;
        MYNICNODE *pNext;
    } MYNICNODE;

    MYNICNODE *pNicNodeList = NULL;
    MYNICNODE *pNicNode     = NULL;


    *ppszNics = NULL;
    *pNumNics = 0;

    if (pNumBoundToNlb != NULL)
    {
        *pNumBoundToNlb  = 0;
    }

    if (m_pINetCfg == NULL)
    {
        //
        // This means we're not initialized
        //
        ASSERT(FALSE);
        goto end;
    }

    hr = m_pINetCfg->EnumComponents( &GUID_DEVCLASS_NET, &pencc );
    if( !SUCCEEDED( hr ) )
    {
        // failure to Enumerate net components
        //TRACE_CRIT("%!FUNC! Could not enum netcfg adapters");
        pencc = NULL;
        goto end;
    }


    //
    // Check if nlb is bound to the nlb component.
    //

    //
    // If we need to count of NLB-bound nics, get instance of the nlb component
    //
    if (pNumBoundToNlb != NULL)
    {
        Status = GetBindingIF(L"ms_wlbs", &pINlbBinding);
        if (FAILED(Status))
        {
            //TRACE_CRIT("%!FUNC! WARNING: NLB doesn't appear to be installed on this machine");
            pINlbBinding = NULL;
        }
    }

    while( ( hr = pencc->Next( countToFetch, &pncc, &countFetched ) )== S_OK )
    {
        LPWSTR                szName = NULL; 

        hr = pncc->GetBindName( &szName );
        if (!SUCCEEDED(hr))
        {
            //TRACE_CRIT("%!FUNC! WARNING: couldn't get bind name for 0x%p, ignoring",
            //        (PVOID) pncc);
            continue;
        }

        do // while FALSE -- just to allow breaking out
        {


            UINT Len = wcslen(szName);
            if (Len != MY_GUID_LENGTH)
            {
                //TRACE_CRIT("%!FUNC! WARNING: GUID %ws has unexpected length %ul",
                //        szName, Len);
                break;
            }
    
            DWORD characteristics = 0;
    
            hr = pncc->GetCharacteristics( &characteristics );
            if(!SUCCEEDED(hr))
            {
                //TRACE_CRIT("%!FUNC! WARNING: couldn't get characteristics for %ws, ignoring",
                 //       szName);
                break;
            }
    
            if (((characteristics & NCF_PHYSICAL) || (characteristics & NCF_VIRTUAL)) && !(characteristics & NCF_HIDDEN))
            {
                ULONG devstat = 0;
    
                // This is a physical or virtual miniport that is NOT hidden. These
                // are the same adapters that show up in the "Network Connections"
                // dialog.  Hidden devices include WAN miniports, RAS miniports and 
                // NLB miniports - all of which should be excluded here.

                // check if the nic is enabled, we are only
                // interested in enabled nics.
                //
                hr = pncc->GetDeviceStatus( &devstat );
                if(!SUCCEEDED(hr))
                {
                    //TRACE_CRIT(
                    //    "%!FUNC! WARNING: couldn't get dev status for %ws, ignoring",
                     //   szName
                     //   );
                    break;
                }
    
                // if any of the nics has any of the problem codes
                // then it cannot be used.
    
                if( devstat != CM_PROB_NOT_CONFIGURED
                    &&
                    devstat != CM_PROB_FAILED_START
                    &&
                    devstat != CM_PROB_NORMAL_CONFLICT
                    &&
                    devstat != CM_PROB_NEED_RESTART
                    &&
                    devstat != CM_PROB_REINSTALL
                    &&
                    devstat != CM_PROB_WILL_BE_REMOVED
                    &&
                    devstat != CM_PROB_DISABLED
                    &&
                    devstat != CM_PROB_FAILED_INSTALL
                    &&
                    devstat != CM_PROB_FAILED_ADD
                    )
                {
                    //
                    // No problem with this nic and also 
                    // physical device 
                    // thus we want it.
                    //

                    if (pINlbBinding != NULL)
                    {
                        BOOL fBound = FALSE;

                        hr = pINlbBinding->IsBoundTo(pncc);

                        if( !SUCCEEDED( hr ) )
                        {
                            //TRACE_CRIT("IsBoundTo method failed for Nic %ws", szName);
                            goto end;
                        }
                    
                        if( hr == S_OK )
                        {
                            //TRACE_VERB("BOUND: %ws\n", szName);
                            NumNlbBoundNics++;
                            fBound = TRUE;
                        }
                        else if (hr == S_FALSE )
                        {
                            //TRACE_VERB("NOT BOUND: %ws\n", szName);
                            fBound = FALSE;
                        }
                    }


                    // We allocate a little node to keep this string
                    // temporarily and add it to our list of nodes.
                    //
                    pNicNode = new MYNICNODE;
                    if (pNicNode  == NULL)
                    {
                        Status = WBEM_E_OUT_OF_MEMORY;
                        goto end;
                    }
                    ZeroMemory(pNicNode, sizeof(*pNicNode));
                    pNicNode->szNicGuid = szName;
                    szName = NULL; // so we don't delete inside the lopp.
                    pNicNode->pNext = pNicNodeList;
                    pNicNodeList = pNicNode;
                    NumNics++;
                }
                else
                {
                    // There is a problem...
                    //TRACE_CRIT(
                        // "%!FUNC! WARNING: Skipping %ws because DeviceStatus=0x%08lx",
                        // szName, devstat
                        // );
                    break;
                }
            }
            else
            {
                //TRACE_VERB("%!FUNC! Ignoring non-physical device %ws", szName);
            }

        } while (FALSE);

        if (szName != NULL)
        {
            CoTaskMemFree( szName );
        }
        pncc->Release();
        pncc=NULL;
    }

    if (pINlbBinding!=NULL)
    {
        pINlbBinding->Release();
        pINlbBinding = NULL;
    }

    if (NumNics==0)
    {
        Status = WBEM_NO_ERROR;
        goto end;
    }
    
    //
    // Now let's  allocate space for all the nic strings and:w
    // copy them over..
    //
    #define MY_GUID_LENGTH  38
    pszNics =  CfgUtilsAllocateStringArray(NumNics, MY_GUID_LENGTH);
    if (pszNics == NULL)
    {
        Status = WBEM_E_OUT_OF_MEMORY;
        goto end;
    }

    pNicNode= pNicNodeList;
    for (UINT u=0; u<NumNics; u++, pNicNode=pNicNode->pNext)
    {
        ASSERT(pNicNode != NULL); // because we just counted NumNics of em.
        UINT Len = wcslen(pNicNode->szNicGuid);
        if (Len != MY_GUID_LENGTH)
        {
            //
            // We should never get here beause we checked the length earlier.
            //
            //TRACE_CRIT("%!FUNC! ERROR: GUID %ws has unexpected length %ul",
            //            pNicNode->szNicGuid, Len);
            ASSERT(FALSE);
            Status = WBEM_E_CRITICAL_ERROR;
            goto end;
        }
        CopyMemory(
            pszNics[u],
            pNicNode->szNicGuid,
            (MY_GUID_LENGTH+1)*sizeof(WCHAR));
        ASSERT(pszNics[u][MY_GUID_LENGTH]==0);
    }

    Status = WBEM_NO_ERROR;


end:

    //
    // Now release the temporarly allocated memory.
    //
    pNicNode= pNicNodeList;
    while (pNicNode!=NULL)
    {
        MYNICNODE *pTmp = pNicNode->pNext;
        CoTaskMemFree(pNicNode->szNicGuid);
        pNicNode->szNicGuid = NULL;
        delete pNicNode;
        pNicNode = pTmp;
    }

    if (FAILED(Status))
    {
        // TRACE_CRIT("%!FUNC! fails with status 0x%08lx", (UINT) Status);
        NumNics = 0;
        if (pszNics!=NULL)
        {
            delete pszNics;
            pszNics = NULL;
        }
    }
    else
    {
        if (pNumBoundToNlb != NULL)
        {
            *pNumBoundToNlb = NumNlbBoundNics;
        }
        *ppszNics = pszNics;
        *pNumNics = NumNics;
    }

    if (pencc != NULL)
    {
        pencc->Release();
    }

    return Status;
}


WBEMSTATUS
AppMyNetCfg::GetBindingIF(
        IN  LPCWSTR                     szComponent,
        OUT INetCfgComponentBindings   **ppIBinding
        )
{
    WBEMSTATUS                  Status = WBEM_E_CRITICAL_ERROR;
    INetCfgComponent            *pncc = NULL;
    INetCfgComponentBindings    *pnccb = NULL;
    HRESULT                     hr;


    if (m_pINetCfg == NULL)
    {
        //
        // This means we're not initialized
        //
        ASSERT(FALSE);
        goto end;
    }


    hr = m_pINetCfg->FindComponent(szComponent,  &pncc);

    if (FAILED(hr))
    {
        // TRACE_CRIT("Error checking if component %ws does not exist\n", szComponent);
        pncc = NULL;
        goto end;
    }
    else if (hr == S_FALSE)
    {
        Status = WBEM_E_NOT_FOUND;
        // TRACE_CRIT("Component %ws does not exist\n", szComponent);
        goto end;
    }
   
   
    hr = pncc->QueryInterface( IID_INetCfgComponentBindings, (void **) &pnccb );
    if( !SUCCEEDED( hr ) )
    {
        // TRACE_CRIT("INetCfgComponent::QueryInterface failed ");
        pnccb = NULL;
        goto end;
    }

    Status = WBEM_NO_ERROR;

end:

    if (pncc)
    {
        pncc->Release();
        pncc=NULL;
    }

    *ppIBinding = pnccb;

    return Status;

}



BOOL NoAdminNics(void)
/*
    Return  TRUE IFF all NICs on this machine are bound to NLB.
*/
{
    LPWSTR *pszNics = NULL;
    OUT UINT   NumNics = 0;
    OUT UINT   NumBoundToNlb  = 0;
    WBEMSTATUS Status = WBEM_NO_ERROR;
    BOOL fNetCfgInitialized = FALSE;
    AppMyNetCfg NetCfg;
    BOOL fRet = FALSE;

    //
    // Get and initialize interface to netcfg
    //
    Status = NetCfg.Initialize(FALSE); // TRUE == get write lock.
    if (FAILED(Status))
    {
        goto end;
    }
    fNetCfgInitialized = TRUE;

    //
    // Get the total list of enabled nics and the list of nics
    // bound to NLB. If there are non-zero enabled nics and all are
    // bound to NLB, we return TRUE.
    //
    Status = NetCfg.GetNlbCompatibleNics(
                        &pszNics,
                        &NumNics,
                        &NumBoundToNlb
                        );

    if (!FAILED(Status))
    {
        fRet =  NumNics && (NumNics == NumBoundToNlb);
        if (NumNics)
        {
            delete pszNics; 
            pszNics = NULL;
        }
    }

end:

    if (fNetCfgInitialized)
    {
        NetCfg.Deinitialize();
    }

    return fRet;
}


void
Application::ProcessMsgQueue()
{
    MSG msg;
    BOOL bDoingBackgroundProcessing = FALSE; 

    TRACE_INFO(L"-> %!FUNC!");

    if (!mfn_IsMainThread()) goto end;

    if (InterlockedIncrement(&m_lMsgProcReentrancyCount) > 1)
    {
        InterlockedDecrement(&m_lMsgProcReentrancyCount);
        goto end;
    }

    while ( ::PeekMessage( &msg, NULL, 0, 0, PM_NOREMOVE ) ) 
    {
    #if BUGFIX334243
        if (msg.message == MYWM_DEFER_UI_MSG)
        {
            // DummyAction(L"Hey -- got DEFER_UI_MSG ProcessMsgQueue!");
        }
    #endif // BUGFIX334243

        if ( !this->PumpMessage( ) ) 
        { 
            bDoingBackgroundProcessing = FALSE; 
            ::PostQuitMessage(0); 
            break; 
        } 
    } 

    // let MFC do its idle processing
    LONG lIdle = 0;
    while ( this->OnIdle(lIdle++ ) )
    {
    }

    // Perform some background processing here 
    // using another call to OnIdle

    this->DoWaitCursor(0); // process_msgqueue() breaks the hour glass cursor, This call restores the hour glass cursor if there was one 

    InterlockedDecrement(&m_lMsgProcReentrancyCount);

    if (m_fQuit)
    {
       ::PostQuitMessage(0); 
    }

end:

    TRACE_INFO(L"<- %!FUNC!");

    return;
}

//
// Get application-wide lock. If main thread, while waiting to get the lock,
// periodically process the msg loop.
//
VOID
Application::Lock()
{
    //
    // See  notes.txt entry
    //      01/23/2002 JosephJ DEADLOCK in Leftview::mfn_Lock
    // for the reason for this convoluted implementation of mfn_Lock
    //

    if (mfn_IsMainThread())
    {
        EnterCriticalSection(&m_crit);
    }
    else
    {
        while (!TryEnterCriticalSection(&m_crit))
        {
            this->ProcessMsgQueue();
            Sleep(100);
        }
    }
}

//
// Get application-wide unlock
//
VOID
Application::Unlock()
{
    LeaveCriticalSection(&m_crit);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\clusterpage.h ===
#ifndef CLUSTERPAGE_H
#define CLUSTERPAGE_H

#include "stdafx.h"

#include "resource.h"

#include "MNLBUIData.h"
#include "CommonClusterPage.h"

class ClusterPage : public CPropertyPage
{
public:
    enum
    {
        IDD = IDD_CLUSTER_PAGE,
    };


    ClusterPage(
                 CPropertySheet *pshOwner,
                 LeftView::OPERATION op,
                 NLB_EXTENDED_CLUSTER_CONFIGURATION *pNlbCfg,
                 ENGINEHANDLE ehCluster OPTIONAL
                 // ENGINEHANDLE ehInterface OPTIONAL
                );

    ~ClusterPage();


    // overrides of CPropertyPage
    virtual BOOL OnInitDialog();
    virtual BOOL OnNotify(WPARAM idCtrl , LPARAM pnmh , LRESULT* pResult) ;
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) ;

    BOOL SetActive(void);
    BOOL KillActive(void);

    afx_msg BOOL OnHelpInfo (HELPINFO* helpInfo );

    afx_msg void OnContextMenu( CWnd* pWnd, CPoint point );

    void
    mfn_SaveToNlbCfg(void);
    
protected:

    LeftView::OPERATION m_operation; // operational context
    BOOL                m_fWizard; // if this is a wizard
    BOOL                m_fDisableClusterProperties; // if we're to disable 
                                                     // cluster properties.
    ENGINEHANDLE m_ehCluster;   // engine handle to cluster (could be NULL)
    // ENGINEHANDLE m_ehInterface; //  engine handle to inteface (could be NULL)

    //
    // Pointer to the object that does the actual work
    //
    CCommonClusterPage* m_pCommonClusterPage;

    //
    // The struct to be passed to the CCommonClusterPage as input and output
    //
    NETCFG_WLBS_CONFIG  m_WlbsConfig;

    
    CPropertySheet *m_pshOwner;

    //
    // The (New) place to get/save config.
    //
    NLB_EXTENDED_CLUSTER_CONFIGURATION *m_pNlbCfg;

    void
    mfn_LoadFromNlbCfg(void);

    DECLARE_MESSAGE_MAP()
};

static DWORD g_aHelpIDs_IDD_CLUSTER_PAGE [] = {
    IDC_GROUP_CL_IP,              IDC_GROUP_CL_IP,
    IDC_TEXT_CL_IP,               IDC_EDIT_CL_IP,
    IDC_EDIT_CL_IP,               IDC_EDIT_CL_IP,
    IDC_TEXT_CL_MASK,             IDC_EDIT_CL_MASK,
    IDC_EDIT_CL_MASK,             IDC_EDIT_CL_MASK,
    IDC_TEXT_DOMAIN,              IDC_EDIT_DOMAIN,
    IDC_EDIT_DOMAIN,              IDC_EDIT_DOMAIN,
    IDC_TEXT_ETH,                 IDC_EDIT_ETH,
    IDC_EDIT_ETH,                 IDC_EDIT_ETH,
    IDC_GROUP_CL_MODE,            IDC_GROUP_CL_MODE,
    IDC_RADIO_UNICAST,            IDC_RADIO_UNICAST,
    IDC_RADIO_MULTICAST,          IDC_RADIO_MULTICAST,
    IDC_CHECK_IGMP,               IDC_CHECK_IGMP,
    IDC_GROUP_RCT,                IDC_CHECK_RCT,
    IDC_CHECK_RCT,                IDC_CHECK_RCT,
    IDC_TEXT_PASSW,               IDC_EDIT_PASSW,
    IDC_EDIT_PASSW,               IDC_EDIT_PASSW,
    IDC_TEXT_PASSW2,              IDC_EDIT_PASSW2,
    IDC_EDIT_PASSW2,              IDC_EDIT_PASSW2,
    0, 0
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\application.h ===
#ifndef APPLICATION_H
#define APPLICATION_H

#include "stdafx.h"

//
// Application-specific windows message to defer processing of UI.
// wParam -- unused
// lParam -- a pointer to an allocated CUIWorkItem object.
//              See document.h for details on the use of this object.
//
#define MYWM_DEFER_UI_MSG (WM_USER+1)

class Application : public CWinApp
{

public:

    Application( LPCTSTR lpszAppName = NULL )
        : m_dwMainThreadId(0),
          m_lMsgProcReentrancyCount(0),
          m_fQuit(FALSE),
          CWinApp(lpszAppName)
    {
        InitializeCriticalSection(&m_crit);
    }

    ~Application()
    {
        DeleteCriticalSection(&m_crit);
    }

    virtual BOOL InitInstance();

    BOOL
    ProcessShellCommand( CNlbMgrCommandLineInfo& rCmdInfo ); // overrides base

    afx_msg void OnHelp();
    afx_msg void OnAppAbout();

    //
    // If called in main thread's context:
    //      Process the msg queue and do background idle work
    // Else (some other thread)
    //      Do nothing
    //
    void
    ProcessMsgQueue();
    
    //
    // Get application-wide lock. If main thread, while waiting to get the lock,
    // periodically process the msg loop.
    //
    VOID
    Lock();

    //
    // Get application-wide unlock
    //
    VOID
    Unlock();

    BOOL
    IsMainThread(void)
    {
    #if BUGFIX334243
        return mfn_IsMainThread();
    #else  // !BUGFIX334243
        return TRUE;
    #endif // !BUGFIX334243
    }

    //
    // Returns return TRUE IFF called in the context of ProcessMsgQueue.
    //
    BOOL
    IsProcessMsgQueueExecuting(void)
    {
        return (m_lMsgProcReentrancyCount > 0);
    }

    VOID
    SetQuit(void)
    {
        m_fQuit = TRUE;
    }


    DECLARE_MESSAGE_MAP()

private:

    BOOL
    mfn_IsMainThread(void)
    {
        return (GetCurrentThreadId() == m_dwMainThreadId);
    }

	CSingleDocTemplate *m_pSingleDocumentTemplate;

    //
    // The thread ID of the main thread -- used to decide if a thread is
    // the main application thread.
    //
    DWORD            m_dwMainThreadId;

    CRITICAL_SECTION m_crit;

    //
    // Following keeps count of the number times ProcessMsgQueue is reentered.
    // It is incremented/decremented using InterlockedIncrement/Decrement,
    // and the lock is NOT held while doing so.
    //
    LONG            m_lMsgProcReentrancyCount;

    BOOL            m_fQuit;
};

extern Application theApplication;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\clusterportsdlg.h ===
#ifndef CLUSTERPORTSDLG_H
#define CLUSTERPORTSDLG_H

#include "stdafx.h"

#include "resource.h"

#include "MNLBUIData.h"

// forward declaration
class PortsPage;

class ClusterPortsDlg : public CDialog
{
    
public:
    enum
    {
        IDD = IDD_DIALOG_PORT_RULE_PROP_CLUSTER,
    };

    ClusterPortsDlg( PortsPage::PortData& portData,
                     CWnd* parent,
                     const int&   index = -1
                     );

    CIPAddressCtrl ipAddress;

    void PrintRangeError (unsigned int ids, int low, int high);

    // overrides of CDialog
    virtual void DoDataExchange( CDataExchange* pDX );

    virtual void OnOK();

    virtual BOOL OnInitDialog();


    // message handlers
    afx_msg void OnRadioMultiple();

    afx_msg void OnRadioSingle();

    afx_msg void OnRadioDisabled();

    afx_msg void OnCheckAllVIP();

    afx_msg BOOL OnHelpInfo (HELPINFO* helpInfo );

    afx_msg void OnContextMenu( CWnd* pWnd, CPoint point );

private:

    PortsPage::PortData& m_portData;

    PortsPage* m_parent;

    int m_index;

    void
    SetControlData();

    DECLARE_MESSAGE_MAP()

};

static DWORD g_aHelpIDs_IDD_PORT_RULE_PROP_CLUSTER [] = {
    IDC_GROUP_PORT_RULE_VIP,      IDC_GROUP_PORT_RULE_VIP,
    IDC_EDIT_PORT_RULE_VIP,       IDC_EDIT_PORT_RULE_VIP,
    IDC_CHECK_PORT_RULE_ALL_VIP,  IDC_CHECK_PORT_RULE_ALL_VIP,
    IDC_GROUP_RANGE,              IDC_GROUP_RANGE,
    IDC_TEXT_START,               IDC_EDIT_START,
    IDC_EDIT_START,               IDC_EDIT_START,
    IDC_SPIN_START,               IDC_EDIT_START,
    IDC_TEXT_END,                 IDC_EDIT_END,
    IDC_EDIT_END,                 IDC_EDIT_END,
    IDC_SPIN_END,                 IDC_EDIT_END,
    IDC_GROUP_PROTOCOLS,          IDC_GROUP_PROTOCOLS,
    IDC_RADIO_TCP,                IDC_RADIO_TCP,
    IDC_RADIO_UDP,                IDC_RADIO_UDP,
    IDC_RADIO_BOTH,               IDC_RADIO_BOTH,
    IDC_GROUP_MULTIPLE,           IDC_GROUP_MULTIPLE,
    IDC_RADIO_MULTIPLE,           IDC_RADIO_MULTIPLE,
    IDC_TEXT_AFF,                 IDC_TEXT_AFF,
    IDC_RADIO_AFF_NONE,           IDC_RADIO_AFF_NONE,
    IDC_RADIO_AFF_SINGLE,         IDC_RADIO_AFF_SINGLE,
    IDC_RADIO_AFF_CLASSC,         IDC_RADIO_AFF_CLASSC,
    IDC_CHECK_EQUAL,              IDC_CHECK_EQUAL,
    IDC_TEXT_MULTI,               IDC_TEXT_MULTI,
    IDC_EDIT_MULTI,               IDC_EDIT_MULTI,
    IDC_SPIN_MULTI,               IDC_EDIT_MULTI,
    IDC_CHECK_EQUAL,              IDC_CHECK_EQUAL,
    IDC_GROUP_SINGLE,             IDC_GROUP_MULTIPLE,
    IDC_RADIO_SINGLE,             IDC_RADIO_SINGLE,
    IDC_TEXT_SINGLE,              IDC_EDIT_SINGLE,
    IDC_EDIT_SINGLE,              IDC_EDIT_SINGLE,
    IDC_SPIN_SINGLE,              IDC_EDIT_SINGLE,
    IDC_GROUP_DISABLED,           IDC_GROUP_MULTIPLE,
    IDC_RADIO_DISABLED,           IDC_RADIO_DISABLED,
    0, 0
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\clusterpage.cpp ===
//***************************************************************************
//
//  CLUSTERPAGE.CPP
// 
//  Module: NLB Manager
//
//  Purpose: LeftView, the tree view of NlbManager, and a few other
//           smaller classes.
//
//  Copyright (c)2001-2002 Microsoft Corporation, All Rights Reserved
//
//  History:
//
//  02/12/01    Mhakim created
//  07/30/01    JosephJ complete rewrite
//  09/15/01    SHouse ctxt sensitive help
//  01/22/02    SHouse misc cleanup and features
//  
//
//***************************************************************************
#include "precomp.h"
#pragma hdrstop
#include "private.h"
#include "ClusterPage.h"

BEGIN_MESSAGE_MAP( ClusterPage, CPropertyPage )
    ON_WM_HELPINFO()        
    ON_WM_CONTEXTMENU()
END_MESSAGE_MAP()


ClusterPage::ClusterPage(
                 CPropertySheet *pshOwner,
                 LeftView::OPERATION op,
                 NLB_EXTENDED_CLUSTER_CONFIGURATION *pNlbCfg,
                 ENGINEHANDLE ehCluster OPTIONAL
                 // ENGINEHANDLE ehInterface OPTIONAL
                 )
    :
    m_pshOwner(pshOwner),
    CPropertyPage( ClusterPage::IDD ),
    m_pNlbCfg( pNlbCfg ),
    m_ehCluster(ehCluster)
    // m_ehInterface(ehInterface)

{
    m_operation = op;

    switch(op)
    {
    case LeftView::OP_NEWCLUSTER:
        m_fWizard=TRUE;
        m_fDisableClusterProperties=FALSE;
    break;

    case LeftView::OP_CLUSTERPROPERTIES:
        m_fWizard=FALSE;
        m_fDisableClusterProperties=FALSE;
    break;

    case LeftView::OP_HOSTPROPERTIES:
        m_fWizard=FALSE;
        m_fDisableClusterProperties=TRUE;
    break;

    default:
        ASSERT(FALSE);
    break;
    }

    ZeroMemory(&m_WlbsConfig, sizeof(m_WlbsConfig));
    mfn_LoadFromNlbCfg();

    m_pCommonClusterPage = new CCommonClusterPage(AfxGetInstanceHandle(), 
                                                  &m_WlbsConfig, false, NULL);
}

void
ClusterPage::mfn_LoadFromNlbCfg()
{
    ZeroMemory(&m_WlbsConfig, sizeof(m_WlbsConfig));

    ARRAYSTRCPY(m_WlbsConfig.cl_ip_addr, m_pNlbCfg->NlbParams.cl_ip_addr);
    ARRAYSTRCPY(m_WlbsConfig.cl_net_mask, m_pNlbCfg->NlbParams.cl_net_mask);
    ARRAYSTRCPY(m_WlbsConfig.domain_name, m_pNlbCfg->NlbParams.domain_name);
    ARRAYSTRCPY(m_WlbsConfig.cl_mac_addr, m_pNlbCfg->NlbParams.cl_mac_addr);

    //
    // pClusterProperty->multicastIpAddress could be NULL
    //
    if (m_pNlbCfg->NlbParams.szMCastIpAddress[0] != 0)
    {
        ARRAYSTRCPY(m_WlbsConfig.szMCastIpAddress, m_pNlbCfg->NlbParams.szMCastIpAddress);
    }
    m_WlbsConfig.fMcastSupport = m_pNlbCfg->NlbParams.mcast_support;
    m_WlbsConfig.fIGMPSupport = m_pNlbCfg->NlbParams.fIGMPSupport;
    m_WlbsConfig.fRctEnabled = m_pNlbCfg->NlbParams.rct_enabled;
    m_WlbsConfig.fMcastSupport = m_pNlbCfg->NlbParams.mcast_support;
    m_WlbsConfig.fIpToMCastIp = m_pNlbCfg->NlbParams.fIpToMCastIp;
    // m_WlbsConfig.fConvertMac = m_pNlbCfg->NlbParams.i_convert_mac;
    // TODO: check: Always generate the MAC address from IP
    m_WlbsConfig.fConvertMac = TRUE;
    
    *m_WlbsConfig.szPassword = 0;
}

void
ClusterPage::mfn_SaveToNlbCfg(void)
{

    //
    // Replace the old cluster IP address/subnet with the new one in the
    // list of network addresses.
    //
    {
        WBEMSTATUS wStat;
        wStat = m_pNlbCfg->ModifyNetworkAddress(
                    m_pNlbCfg->NlbParams.cl_ip_addr,
                    m_WlbsConfig.cl_ip_addr,
                    m_WlbsConfig.cl_net_mask
                    );
        if (FAILED(wStat))
        {
            _bstr_t bstrMsg   =  GETRESOURCEIDSTRING(IDS_INVALID_IP_OR_SUBNET);
            _bstr_t bstrTitle =  GETRESOURCEIDSTRING(IDS_INVALID_INFORMATION);

            ::MessageBox(
                 NULL,
                 bstrMsg,
                 bstrTitle,
                 MB_ICONINFORMATION   | MB_OK
                );
            goto end;
        }
    }

    ARRAYSTRCPY(m_pNlbCfg->NlbParams.cl_ip_addr, m_WlbsConfig.cl_ip_addr);
    ARRAYSTRCPY(m_pNlbCfg->NlbParams.cl_net_mask, m_WlbsConfig.cl_net_mask);
    ARRAYSTRCPY(m_pNlbCfg->NlbParams.domain_name, m_WlbsConfig.domain_name);
    ARRAYSTRCPY(m_pNlbCfg->NlbParams.cl_mac_addr, m_WlbsConfig.cl_mac_addr);

    //
    // pClusterProperty->multicastIpAddress could be NULL
    //
    if (m_WlbsConfig.szMCastIpAddress[0] != 0)
    {
        ARRAYSTRCPY(m_pNlbCfg->NlbParams.szMCastIpAddress, m_WlbsConfig.szMCastIpAddress);
    }
    m_pNlbCfg->NlbParams.mcast_support = m_WlbsConfig.fMcastSupport;
    m_pNlbCfg->NlbParams.fIGMPSupport = m_WlbsConfig.fIGMPSupport;
    m_pNlbCfg->NlbParams.rct_enabled= m_WlbsConfig.fRctEnabled; 
    m_pNlbCfg->NlbParams.mcast_support = m_WlbsConfig.fMcastSupport;
    m_pNlbCfg->NlbParams.fIpToMCastIp = m_WlbsConfig.fIpToMCastIp;
    // m_pNlbCfg->NlbParams.i_convert_mac= m_WlbsConfig.fConvertMac;
    // TODO: check: Always generate the MAC address from IP
    // m_pNlbCfg->NlbParams.i_convert_mac =  m_WlbsConfig.fConvertMac;
    
    // TODO: *m_pNlbCfg->NlbParams.password = 0;
    if (m_WlbsConfig.fChangePassword)
    {
    	m_pNlbCfg->SetNewRemoteControlPassword(m_WlbsConfig.szPassword);
    }
    else
    {
    	m_pNlbCfg->SetNewRemoteControlPassword(NULL);
    }
end:
    return;
}

ClusterPage::~ClusterPage()
{
    delete m_pCommonClusterPage;
}




//+----------------------------------------------------------------------------
//
// Function:  ClusterPage::OnInitDialog
//
// Description:  Process WM_INITDIALOG message
//
// Arguments: None
//
// Returns:   BOOL - 
//
// History:   fengsun Created Header    1/4/01
//
//+----------------------------------------------------------------------------
BOOL ClusterPage::OnInitDialog()
{
    CPropertyPage::OnInitDialog();

    //
    // Always set that the page has changed, so we don't have to keep track of this.
    //
    SetModified(TRUE);

    m_pCommonClusterPage->OnInitDialog(m_hWnd);

    if (m_fDisableClusterProperties)
    {
        //
        // The page is for host property.  
        // disable all cluster windows as we are at host level.
        //
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_CL_IP), FALSE );
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_CL_MASK), FALSE );
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_RADIO_UNICAST), FALSE );
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_RADIO_MULTICAST), FALSE );
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_CHECK_IGMP), FALSE );
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_DOMAIN), FALSE );
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_CHECK_RCT), FALSE );
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_PASSW), FALSE );
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_PASSW2), FALSE );

    }
    else
    {
        //
        // The page is for cluster property
        //
        // enable all cluster windows as we are at cluster level.
        //
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_CL_IP), TRUE );
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_CL_MASK), TRUE );
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_RADIO_UNICAST), TRUE );
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_RADIO_MULTICAST), TRUE );
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_CHECK_IGMP), TRUE );
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_DOMAIN), TRUE );
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_CHECK_RCT), TRUE );

        // enable remote control check box only if remote control is disabled.  
        //

        // if remote control is enabled , enable password windows
        // else disable them.

        if (m_WlbsConfig.fRctEnabled)
        {
            ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_PASSW), TRUE );
            ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_PASSW2), TRUE );
        }  
        else
        {
            ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_PASSW), FALSE );
            ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_PASSW2), FALSE );
        }
    }

    ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_ETH), FALSE );

    return TRUE;
}



//+----------------------------------------------------------------------------
//
// Function:  ClusterPage::OnContextMenu
//
// Description:  Process WM_CONTEXTMENU message
//
// Arguments: CWnd* pWnd - 
//            CPoint point - 
//
// Returns:   Nothing
//
// History:   fengsun Created Header    1/4/01
//
//+----------------------------------------------------------------------------




//+----------------------------------------------------------------------------
//
// Function:  ClusterPage::OnCommand
//
// Description:  Process WM_COMMAND message
//
// Arguments: WPARAM wParam - 
//            LPARAM lParam - 
//
// Returns:   BOOL - 
//
// History:   fengsun Created Header    1/4/01
//
//+----------------------------------------------------------------------------
BOOL ClusterPage::OnCommand(WPARAM wParam, LPARAM lParam) 
{
    switch (LOWORD(wParam))
    {
    case IDC_EDIT_CL_IP:
        return m_pCommonClusterPage->OnEditClIp(HIWORD(wParam),LOWORD(wParam), (HWND)lParam);
        break;

    case IDC_EDIT_CL_MASK:
        return m_pCommonClusterPage->OnEditClMask(HIWORD(wParam),LOWORD(wParam), (HWND)lParam);
        break;

    case IDC_CHECK_RCT:
        return m_pCommonClusterPage->OnCheckRct(HIWORD(wParam),LOWORD(wParam), (HWND)lParam);
        break;

    case IDC_BUTTON_HELP:
        return m_pCommonClusterPage->OnButtonHelp(HIWORD(wParam),LOWORD(wParam), (HWND)lParam);
        break;

    case IDC_RADIO_UNICAST:
        return m_pCommonClusterPage->OnCheckMode(HIWORD(wParam),LOWORD(wParam), (HWND)lParam);
        break;

    case IDC_RADIO_MULTICAST:
        return m_pCommonClusterPage->OnCheckMode(HIWORD(wParam),LOWORD(wParam), (HWND)lParam);
        break;

    case IDC_CHECK_IGMP:
        return m_pCommonClusterPage->OnCheckIGMP(HIWORD(wParam),LOWORD(wParam), (HWND)lParam);
        break;

    }
	return CPropertyPage::OnCommand(wParam, lParam);
}



//+----------------------------------------------------------------------------
//
// Function:  ClusterPage::OnNotify
//
// Description:  Process WM_NOTIFY message
//
// Arguments: WPARAM idCtrl - 
//            LPARAM pnmh - 
//            LRESULT* pResult - 
//
// Returns:   BOOL - 
//
// History:   fengsun Created Header    1/4/01
//
//+----------------------------------------------------------------------------
BOOL ClusterPage::OnNotify(WPARAM idCtrl , LPARAM pnmh , LRESULT* pResult) 
{
    NMHDR* pNmhdr = (NMHDR*)pnmh ;
    switch(pNmhdr->code)
    {

    case PSN_KILLACTIVE:

        if (KillActive())
        {
            *pResult = PSNRET_NOERROR;
        }
        else
        {
            *pResult = PSNRET_INVALID;
        }

        return TRUE;

    case PSN_SETACTIVE:

        if (this->SetActive())
        {
            *pResult = PSNRET_NOERROR;
        }
        else
        {
            *pResult = PSNRET_INVALID;
        }
        return TRUE;

    case IPN_FIELDCHANGED:
        *pResult =  m_pCommonClusterPage->OnIpFieldChange(idCtrl, pNmhdr, *(BOOL*)pResult);
        return TRUE;
    }

	return CPropertyPage::OnNotify(idCtrl, pnmh, pResult);
}


BOOL
ClusterPage::OnHelpInfo (HELPINFO* helpInfo )
{
    if( helpInfo->iContextType == HELPINFO_WINDOW )
    {
        ::WinHelp( static_cast<HWND> ( helpInfo->hItemHandle ), 
                   CVY_CTXT_HELP_FILE, 
                   HELP_WM_HELP, 
                   (ULONG_PTR ) g_aHelpIDs_IDD_CLUSTER_PAGE);
    }

    return TRUE;
}

void
ClusterPage::OnContextMenu( CWnd* pWnd, CPoint point )
{
    ::WinHelp( m_hWnd, 
               CVY_CTXT_HELP_FILE, 
               HELP_CONTEXTMENU, 
               (ULONG_PTR ) g_aHelpIDs_IDD_CLUSTER_PAGE);
}

BOOL
ClusterPage::SetActive()
{
    BOOL fRet =  TRUE;

    if (m_fWizard)
    {
        //
        // We're the first page, so only enable next.
        //
        m_pshOwner->SetWizardButtons(
                // PSWIZB_BACK|
                PSWIZB_NEXT|
                // PSWIZB_FINISH|
                // PSWIZB_DISABLEDFINISH|
                0
                );
    }

    fRet = m_pCommonClusterPage->Load();

    return fRet;
}


BOOL
ClusterPage::KillActive(void)
{
    BOOL fRet =  FALSE;

    fRet = m_pCommonClusterPage->Save();
    
    if (!fRet) goto end;


    //
    // Do extra checking here...
    //
    {
        //
        // Check that cluster IP is not used in any other way...
        //
        CLocalLogger    logConflict;
        BOOL            fExistsOnRawIterface = FALSE;
        NLBERROR nerr;
        
        nerr = gEngine.ValidateNewClusterIp(
                    m_ehCluster,
                    m_WlbsConfig.cl_ip_addr,
                    REF fExistsOnRawIterface,
                    REF logConflict
                    );

        if (nerr == NLBERR_INVALID_IP_ADDRESS_SPECIFICATION)
        {
            CLocalLogger    logMsg;

            if (m_ehCluster == NULL && fExistsOnRawIterface)
            {
                //
                // This is a NEW cluster, and the conflicting entity
                // is an existing interface NOT bound to any cluster known to
                // NLB Manager.
                // We'll give the user the opportunity to proceed...
                //
                int sel;
                logMsg.Log(
                    IDS_CIP_CONFLICTS_WITH_RAW_INTERFACE,
                    m_WlbsConfig.cl_ip_addr,
                    logConflict.GetStringSafe()
                    );
                sel = MessageBox(
                        logMsg.GetStringSafe(),
                        GETRESOURCEIDSTRING( IDS_PARM_WARNING ),
                        MB_YESNO | MB_ICONEXCLAMATION
                        );
                if (sel == IDNO)
                {
                    fRet = FALSE;
                    goto end;
                }
            }
            else
            {
                logMsg.Log(
                    IDS_NEW_CIP_CONFLICTS_WITH_XXX,
                    logConflict.GetStringSafe()
                    );
                MessageBox(
                    logMsg.GetStringSafe(),
                    GETRESOURCEIDSTRING( IDS_PARM_ERROR ),
                    MB_ICONSTOP | MB_OK
                    );
                fRet = FALSE;
                goto end;
            }


        }
    }

    //
    // Actually save to the passed-in NLB cfg. This "commits" the changes,
    // as far as this dialog is concerned.
    //
    mfn_SaveToNlbCfg();

end:

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\commonclusterpage.cpp ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    CommonClusterPage.cpp

Abstract:

    Windows Load Balancing Service (WLBS)
    Cluster page UI.  Shared by Notifier object and NLB Manager

Author:

    kyrilf
    shouse

// History:
// --------
// 
// Revised by : mhakim
// Date       : 02-09-01
// Reason     : Igmp box was enabled when it needed to be grayed out.
//
// Revised by : mhakim
// Date       : 02-12-01
// Reason     : Mac address was not being retrieved fully.

--*/


//
//  To share the code with notifier object
//      share string resurce
//      share the common structure
//      call SetChangedFlag() in OnInitDialog
//      add trace, assert
//      Share help file and add help handler
//      
//

#include "precomp.h"
#pragma hdrstop

#include "private.h"
#include <process.h>
#include "wlbsutil.h"
#include "CommonClusterPage.h"


#define DUMMY_PASSWORD L"somepassword"
#define EMPTY_PASSWORD L""

//
// No trace/assert for now
//
#define TraceMsg(x)
#define Assert(x)


//+---------------------------------------------------------------------------
//
//  Function:   SzLoadStringPcch
//
//  Purpose:    Load a resource string.  (This function will never return NULL.)
//
//  Arguments:
//      hinst [in]  Instance handle of module with the string resource.
//      unId  [in]  Resource ID of the string to load.
//      pcch  [out] Pointer to returned character length.
//
//  Returns:    Pointer to the constant string.
//
//  Author:     shaunco   24 Mar 1997
//              fengsun copied from net\config\common\ncbase\ncstring.cpp
//
//  Notes:      The loaded string is pointer directly into the read-only
//              resource section.  Any attempt to write through this pointer
//              will generate an access violation.
//
//              The implementations is referenced from "Win32 Binary Resource
//              Formats" (MSDN) 4.8 String Table Resources
//
//              User must have RCOPTIONS = -N turned on in your sources file.
//
PCWSTR
SzLoadStringPcch (
    IN HINSTANCE   hinst,
    IN UINT        unId,
    OUT int*       pcch)
{
    Assert(hinst);
    Assert(unId);
    Assert(pcch);

    static const WCHAR c_szSpace[] = L" ";

    PCWSTR psz = c_szSpace;
    int    cch = 1;

    // String Tables are broken up into 16 string segments.  Find the segment
    // containing the string we are interested in.
    HRSRC hrsrcInfo = FindResource (hinst,
                        (PWSTR)ULongToPtr( ((LONG)(((USHORT)unId >> 4) + 1)) ),
                        RT_STRING);
    if (hrsrcInfo)
    {
        // Page the resource segment into memory.
        HGLOBAL hglbSeg = LoadResource (hinst, hrsrcInfo);
        if (hglbSeg)
        {
            // Lock the resource.
            psz = (PCWSTR)LockResource(hglbSeg);
            if (psz)
            {
                // Move past the other strings in this segment.
                // (16 strings in a segment -> & 0x0F)
                unId &= 0x0F;

                cch = 0;
                do
                {
                    psz += cch;                // Step to start of next string
                    cch = *((WCHAR*)psz++);    // PASCAL like string count
                }
                while (unId--);

                // If we have a non-zero count, it includes the
                // null-terminiator.  Subtract this off for the return value.
                //
                if (cch)
                {
                    cch--;
                }
                else
                {
//                    AssertSz(0, "String resource not found");
                    psz = c_szSpace;
                    cch = 1;
                }
            }
            else
            {
                psz = c_szSpace;
                cch = 1;
//                TraceLastWin32Error("SzLoadStringPcch: LockResource failed.");
            }
        }
//        else
//            TraceLastWin32Error("SzLoadStringPcch: LoadResource failed.");
    }
//    else
//        TraceLastWin32Error("SzLoadStringPcch: FindResource failed.");

    *pcch = cch;
    Assert(*pcch);
    Assert(psz);
    return psz;
}

//+---------------------------------------------------------------------------
//
//  Function:   SzLoadString
//
//  Purpose:    Load a resource string.  (This function will never return NULL.)
//
//  Arguments:
//      hinst [in]  Instance handle of module with the string resource.
//      unId  [in]  Resource ID of the string to load.
//
//  Returns:    Pointer to the constant string.
//
//  Author:     shaunco   24 Mar 1997
//              fengsun copied from net\config\common\ncbase\ncstring.cpp
//
//  Notes:      See SzLoadStringPcch()
//
PCWSTR
SzLoadString (
    HINSTANCE   hinst,
    UINT        unId)
{
    int cch;
    return SzLoadStringPcch(hinst, unId, &cch);
}


//+---------------------------------------------------------------------------
//
//  Function:   NcMsgBox
//
//  Purpose:    Displays a message box using resource strings and replaceable
//              parameters.
//
//  Arguments:
//      hinst       [in] hinstance for resource strings
//      hwnd        [in] parent window handle
//      unIdCaption [in] resource id of caption string
//      unIdFormat  [in] resource id of text string (with %1, %2, etc.)
//      unStyle     [in] standard message box styles
//      ...         [in] replaceable parameters (optional)
//                          (these must be PCWSTRs as that is all
//                          FormatMessage handles.)
//
//  Returns:    the return value of MessageBox()
//
//  Author:     shaunco   24 Mar 1997
//              fengsun copied from net\config\common\ncbase\ncui.cpp
//
//  Notes:      FormatMessage is used to do the parameter substitution.
//
INT
WINAPIV
NcMsgBox (
    IN HINSTANCE   hinst,
    IN HWND        hwnd,
    IN UINT        unIdCaption,
    IN UINT        unIdFormat,
    IN UINT        unStyle,
    IN ...)
{
    PCWSTR pszCaption = SzLoadString (hinst, unIdCaption);
    PCWSTR pszFormat  = SzLoadString (hinst, unIdFormat);

    PWSTR  pszText = NULL;
    va_list val;
    va_start (val, unStyle);
    FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                   pszFormat, 0, 0, (PWSTR)&pszText, 0, &val);
    va_end (val);

    INT nRet = MessageBox (hwnd, pszText, pszCaption, unStyle);
    LocalFree (pszText);

    return nRet;
}


//+----------------------------------------------------------------------------
//
// Function:  CCommonClusterPage::CCommonClusterPage
//
// Description:  
//
// Arguments: HINSTANCE hInstance - instance handle for string resources
//            NETCFG_WLBS_CONFIG * paramp - IN/OUT NLB properties
//            bool fDisablePassword - whether do disable password editing
//            const DWORD * adwHelpIDs - a list of help ID pairs, or NULL.  
//                  The pointer has to be valid through the lifetime of this dialog.
//
// Returns:   Nothing
//
// History:   fengsun Created Header    1/4/01
//
//+----------------------------------------------------------------------------
CCommonClusterPage::CCommonClusterPage(HINSTANCE hInstance, 
                                       NETCFG_WLBS_CONFIG * paramp, 
                                       bool fDisablePassword, const DWORD * adwHelpIDs) :
                m_IpSubnetControl(IDC_EDIT_CL_IP, IDC_EDIT_CL_MASK)
{

    TraceMsg(L"CCommonClusterPage::CCommonClusterPage\n");

    m_paramp = paramp;
    m_adwHelpIDs = adwHelpIDs;
    m_rct_warned = FALSE;
    m_igmp_warned = FALSE;
    m_igmp_mcast_warned = FALSE;
    m_hInstance = hInstance;
    m_fDisablePassword = fDisablePassword;
}

/*
 * Method: CCommonClusterPage
 * Description: The class destructor.
 */
CCommonClusterPage::~CCommonClusterPage () {

    TraceMsg(L"CCommonClusterPage::~CCommonClusterPage\n");
}

/*
 * Method: OnInitDialog
 * Description: Called to initialize the cluster properties dialog.
 */
LRESULT CCommonClusterPage::OnInitDialog (HWND hWnd) 
{
    TraceMsg(L"CCommonClusterPage::OnInitDialog\n");

    m_hWnd = hWnd;

    /* Limit the field ranges for the address and password fields. */
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_DOMAIN, EM_SETLIMITTEXT, CVY_MAX_DOMAIN_NAME, 0);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_ETH, EM_SETLIMITTEXT, CVY_MAX_NETWORK_ADDR, 0);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_PASSW, EM_SETLIMITTEXT, CVY_MAX_RCT_CODE, 0);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_PASSW2, EM_SETLIMITTEXT, CVY_MAX_RCT_CODE, 0);

    /* Disable the MAC address field.  It should be read-only. */
    if (m_paramp->fConvertMac) ::EnableWindow(::GetDlgItem (m_hWnd, IDC_EDIT_ETH), FALSE);


    /* Copy a dummy password into the parameter set. */
    wcsncpy(m_passw, DUMMY_PASSWORD, CVY_MAX_RCT_CODE);
    wcsncpy(m_passw2, DUMMY_PASSWORD, CVY_MAX_RCT_CODE);

    m_IpSubnetControl.OnInitDialog(m_hWnd, AfxGetInstanceHandle()); 

    return 0;
}

/*
 * Method: OnContextMenu
 * Description: 
 */
LRESULT CCommonClusterPage::OnContextMenu () 
{

    TraceMsg(L"CCommonClusterPage::OnContextMenu\n");

    /* Spawn a help window. */
    if (m_adwHelpIDs != NULL)
        ::WinHelp(m_hWnd, CVY_CTXT_HELP_FILE, HELP_CONTEXTMENU, (ULONG_PTR)m_adwHelpIDs);

    return 0;
}

/*
 * Method: OnHelp
 * Description: 
 */
LRESULT CCommonClusterPage::OnHelp (UINT uMsg, WPARAM wParam, LPARAM lParam) {

    TraceMsg(L"CCommonClusterPage::OnHelp\n");

    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);

    /* Spawn a help window. */
    if ((HELPINFO_WINDOW == lphi->iContextType) && (m_adwHelpIDs != NULL))
        ::WinHelp(static_cast<HWND>(lphi->hItemHandle), CVY_CTXT_HELP_FILE, HELP_WM_HELP, (ULONG_PTR)m_adwHelpIDs);

    return 0;
}

/*
 * Method: Load
 * Description: Called when the cluster settings tab becomes active (is clicked). 
 */
BOOL CCommonClusterPage::Load (void)
{

    TraceMsg(L"CCommonClusterPage::Load\n");

    /* Populate the UI with the current configuration. */
    SetInfo();

    //
    // NLB mamager always has password editing disabled
    //

    /* Enable/disable the password entry boxes based on the state of the remote control checkbox. 
       Edited( mhakim 02-09-01)
       but only when remote control is enabled.
    */
    ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_PASSW), 
                   ::IsDlgButtonChecked(m_hWnd, IDC_CHECK_RCT)
                   && 
                   ::IsWindowEnabled( ::GetDlgItem( m_hWnd, IDC_CHECK_RCT ) ) );
    
    ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_PASSW2), 
                   ::IsDlgButtonChecked(m_hWnd, IDC_CHECK_RCT)
                   && 
                   ::IsWindowEnabled( ::GetDlgItem( m_hWnd, IDC_CHECK_RCT ) ) );

    /* Enable/disable the IGMP checkbox based on the state of the multicast checkbox. 
       Edited( mhakim 02-09-01)
       but only when multicast button is enabled.
     */
    ::EnableWindow(::GetDlgItem(m_hWnd, IDC_CHECK_IGMP), 
                   ::IsDlgButtonChecked (m_hWnd, IDC_RADIO_MULTICAST) 
                   && 
                   ::IsWindowEnabled( ::GetDlgItem( m_hWnd, IDC_RADIO_MULTICAST) ) );

    /* Fill in the cluster MAC address, based on the values of multicast, IGMP, and the cluster IP. */
    SetClusterMACAddress();

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, PSNRET_NOERROR);

    return TRUE;
}

/*
 * Method: Save
 * Description: Called When the focus moves away from the cluster settings tab.
 */
BOOL CCommonClusterPage::Save (void)
{
    LRESULT lRet;

    TraceMsg(L"CCommonClusterPage::OnKillActive\n");

    /* Get the new configuration from the UI. */
    UpdateInfo();

    lRet =  ValidateInfo();

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, lRet);

    return lRet==PSNRET_NOERROR;
}

/*
 * Method: OnButtonHelp
 * Description: Called when the user clicks the NLB "Help" button.
 */
LRESULT CCommonClusterPage::OnButtonHelp (WORD wNotifyCode, WORD wID, HWND hWndCtl) {
    WCHAR wbuf[CVY_STR_SIZE];

    TraceMsg(L"CCommonClusterPage::OnButtonHelp\n");

    switch (wNotifyCode) {
        case BN_CLICKED:
            /* Spawn the windows help process. */
            StringCbPrintf(wbuf, sizeof(wbuf), L"%%WINDIR%%\\help\\%ls::/installation.htm", CVY_HELP_FILE);
            _wspawnlp(P_NOWAIT, L"hh.exe", L"hh.exe", wbuf, NULL);
            break;
    }

    return 0;
}

/*
 * Method: OnEditClIp
 * Description: Called when the user edits the cluster IP address.
 */
LRESULT CCommonClusterPage::OnEditClIp (WORD wNotifyCode, WORD wID, HWND hWndCtl) {

    TraceMsg(L"CCommonClusterPage::OnEditClIp\n");

    switch (wNotifyCode) {
        case EN_CHANGE:
            /* Update the cluster MAC address. */
            SetClusterMACAddress();
            break;
    }

    return 0;
}

/*
 * Method: OnIpFieldChange
 * Description: Called wnen a field (byte) of the cluster IP address changes. We use this
 *              to make sure the first byte of the IP is not < 1 or > 223.
 */
LRESULT CCommonClusterPage::OnIpFieldChange (int idCtrl, LPNMHDR pnmh, BOOL & fHandled) 
{
    return m_IpSubnetControl.OnIpFieldChange(idCtrl, pnmh);
}

/*
 * Method: OnEditClMask
 * Description: Called when the user modifies the cluster netmask.
 */
LRESULT CCommonClusterPage::OnEditClMask (WORD wNotifyCode, WORD wID, HWND hWndCtl) 
{
    return m_IpSubnetControl.OnSubnetMask(wNotifyCode);
}

/*
 * Method: OnCheckRct
 * Description: Called when the user checks/unchecks the remote control enabled checkbox.
 */
LRESULT CCommonClusterPage::OnCheckRct (WORD wNotifyCode, WORD wID, HWND hWndCtl) {

    TraceMsg(L"CCommonClusterPage::OnCheckRct\n");

    switch (wNotifyCode) {
        case BN_CLICKED:
        /* Decide whether to enable or diable the password entry boxes based on the value of the remote checkbox. */
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_PASSW), ::IsDlgButtonChecked(m_hWnd, IDC_CHECK_RCT));
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_PASSW2), ::IsDlgButtonChecked(m_hWnd, IDC_CHECK_RCT));

    
        /* Warn the user about the implications of enabling remote control. */
        if (::IsDlgButtonChecked(m_hWnd, IDC_CHECK_RCT) && !m_rct_warned) {
            /* Alert the user. */            
            int iResponse = NcMsgBox(m_hInstance, m_hWnd, IDS_PARM_WARN, IDS_PARM_RCT_WARN,
                                     MB_APPLMODAL | MB_ICONEXCLAMATION | MB_YESNO | MB_DEFBUTTON2);

            if (iResponse == IDYES)
            {
                //
                // Dialog button is already checked, so don't do anything in this case.
                //
                /* Only warn the user once. */
                m_rct_warned = TRUE;
            }
            else
            {
                //
                // Any response other than Yes means No
                //
                if (::CheckDlgButton(m_hWnd, IDC_CHECK_RCT, BST_UNCHECKED))
                {
                    TraceMsg(L"CDialogCluster::OnCheckRct unchecking remote control option failed\n");
                }
            }
        }
        
        break;
    }
    
    return 0;
}

/*
 * Method: OnCheckMode
 * Description: Called when the user changes cluster mode.
 */
LRESULT CCommonClusterPage::OnCheckMode (WORD wNotifyCode, WORD wID, HWND hWndCtl) {

    TraceMsg(L"CCommonClusterPage::OnCheckMode\n");

    switch (wNotifyCode) {
    case BN_CLICKED:
        /* If the user has IGMP checked, but is turning off multicast support, warn them. */
        if (::IsDlgButtonChecked(m_hWnd, IDC_CHECK_IGMP) && !::IsDlgButtonChecked(m_hWnd, IDC_RADIO_MULTICAST)) {
            if (!m_igmp_mcast_warned) {
                /* Alert the user. */
                NcMsgBox(m_hInstance, ::GetActiveWindow(), IDS_PARM_WARN, IDS_PARM_IGMP_MCAST,
                         MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);            

                /* Only warn the user once. */
                m_igmp_mcast_warned = TRUE;
            } 

            /* Uncheck and disable the IGMP checkbox and set the IGMP support flag to FALSE. */
            ::CheckDlgButton(m_hWnd, IDC_CHECK_IGMP, FALSE);
            ::EnableWindow(::GetDlgItem(m_hWnd, IDC_CHECK_IGMP), FALSE);
            m_paramp->fIGMPSupport = FALSE;
        } else {
            /* Enable/disable and check/uncheck the IGMP checkbox based on the value of the cluster mode radio buttons. */
            ::EnableWindow(::GetDlgItem(m_hWnd, IDC_CHECK_IGMP), ::IsDlgButtonChecked(m_hWnd, IDC_RADIO_MULTICAST));
        }

        /* Update the cluster MAC address. */
        SetClusterMACAddress();
    
        break;
    }

    return 0;
}

/*
 * Method: OnCheckIGMP
 * Description: Called when the user checks/unchecks the IGMP support checkbox.
 */
LRESULT CCommonClusterPage::OnCheckIGMP (WORD wNotifyCode, WORD wID, HWND hWndCtl) {

    TraceMsg(L"CCommonClusterPage::OnCheckIGMP\n");

    switch (wNotifyCode) {
    case BN_CLICKED:
        /* Update the cluster MAC address. */
        SetClusterMACAddress();
    
        /* Warn the user about the implications of enabling remote control. */
        if (::IsDlgButtonChecked(m_hWnd, IDC_CHECK_IGMP) && !m_igmp_warned) {
            /* Alert the user. */
            NcMsgBox(m_hInstance, ::GetActiveWindow(), IDS_PARM_WARN, IDS_PARM_IGMP_WARN,
                     MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);
            
            /* Only warn the user once. */
            m_igmp_warned = TRUE;
        }

        break;
    }

    return 0;
}

/*
 * Method: SetClusterMACAddress
 * Description: Used to determine the cluster MAC address based on the cluster IP, and the
 *              state of multicast and IGMP support.
 */
void CCommonClusterPage::SetClusterMACAddress () {
    WCHAR cl_ip_addr[CVY_MAX_CL_IP_ADDR + 1];
    WCHAR cl_mac_addr[CVY_MAX_NETWORK_ADDR + 1];

    TraceMsg(L"CCommonClusterPage::SetClusterMACAddress\n");

    /* If the convert MAC flag isn't set, the bail out. */
    if (!m_paramp->fConvertMac) return;

    /* Retrieve the cluster IP address from the UI. */
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_CL_IP, WM_GETTEXT, CVY_MAX_CL_IP_ADDR + 1, (LPARAM)cl_ip_addr);
    
    /* Generate the cluster MAC address. */
    ParamsGenerateMAC(cl_ip_addr, cl_mac_addr, ASIZECCH(cl_mac_addr), m_paramp->szMCastIpAddress, ASIZECCH(m_paramp->szMCastIpAddress), m_paramp->fConvertMac, ::IsDlgButtonChecked(m_hWnd, IDC_RADIO_MULTICAST), 
                      ::IsDlgButtonChecked(m_hWnd, IDC_CHECK_IGMP), m_paramp->fIpToMCastIp);
    
    /* Set the cluster MAC address. */
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_ETH, WM_SETTEXT, 0, (LPARAM)cl_mac_addr);
}

/*
 * Method: CheckClusterMACAddress
 * Description: Used to check the cluster MAC address in the case where we aren't generating it ourselves.
 */
BOOL CCommonClusterPage::CheckClusterMACAddress () {
    PWCHAR p1, p2;
    WCHAR mac_addr[WLBS_MAX_NETWORK_ADDR + 1];
    DWORD i, j;
    BOOL flag = TRUE;
    
    /* Valid formats include:
       02:bf:0b:0b:01:01
       02-bf-0b-0b-01-01
       02:bf:0b:b:01:1 */

    /* Make a copy of the MAC address. */
    ARRAYSTRCPY(mac_addr, m_paramp->cl_mac_addr);
    
    /* Point to the beginning of the MAC. */
    p2 = p1 = mac_addr;
    
    /* Loop through all six bytes. */
    for (i = 0 ; i < 6 ; i++) {
        /* If we are pointing at the end of the string, its invalid. */
        if (*p2 == _TEXT('\0')) return FALSE;
        
        /* Convert the hex characters into decimal. */
        j = _tcstoul(p1, &p2, 16);
        
        /* If the number is greater than 255, then the format is bad. */
        if (j > 255) return FALSE;
        
        /* If the NEXT character is neither a -, :, nor the NUL character, then the format is bad. */
        if (!((*p2 == _TEXT('-')) || (*p2 == _TEXT(':')) || (*p2 == _TEXT('\0')))) return FALSE;
        
        /* If the NEXT character is the end of the string, but we don't have enough bytes yet, bail out. */
        if (*p2 == _TEXT('\0') && i < 5) return FALSE;
        
        /* Repoint to the NEXT character. */
        p1 = p2 + 1;
        p2 = p1;
    }

    return TRUE;
}

/*
 * Method: SetInfo
 * Description: Called to populate the UI with the current cluster settings.
 */
void CCommonClusterPage::SetInfo () {

    /* Check (or uncheck) the checkboxes. */
    ::CheckDlgButton(m_hWnd, IDC_CHECK_RCT, m_paramp->fRctEnabled);

    /* Check the appropriate radio button for cluster mode. */
    if (m_paramp->fMcastSupport) {
        ::CheckDlgButton(m_hWnd, IDC_RADIO_MULTICAST, TRUE);

        if (m_paramp->fIGMPSupport) ::CheckDlgButton(m_hWnd, IDC_CHECK_IGMP, TRUE);
    } else 
        ::CheckDlgButton(m_hWnd, IDC_RADIO_UNICAST, TRUE);

    m_IpSubnetControl.SetInfo(m_paramp->cl_ip_addr, m_paramp->cl_net_mask);

    /* Fill in the edit boxes. */
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_DOMAIN, WM_SETTEXT, 0, (LPARAM)m_paramp->domain_name);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_ETH, WM_SETTEXT, 0, (LPARAM)m_paramp->cl_mac_addr);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_PASSW, WM_SETTEXT, 0, (LPARAM)m_passw);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_PASSW2, WM_SETTEXT, 0, (LPARAM)m_passw2);
}

/*
 * Method: UpdateInfo
 * Description: Called to copy the UI state to the cluster configuration.
 */
void CCommonClusterPage::UpdateInfo () {

    TraceMsg(L"CCommonClusterPage::UpdateInfo\n");

    /* Retrieve the checkbox values. */
    m_paramp->fRctEnabled = ::IsDlgButtonChecked(m_hWnd, IDC_CHECK_RCT) == 1;

    /* Retrieve the cluster mode radio button value. */
    m_paramp->fIGMPSupport = ::IsDlgButtonChecked(m_hWnd, IDC_CHECK_IGMP) == 1;
    m_paramp->fMcastSupport = ::IsDlgButtonChecked(m_hWnd, IDC_RADIO_MULTICAST) == 1;

    m_IpSubnetControl.UpdateInfo(m_paramp->cl_ip_addr, m_paramp->cl_net_mask);

    /* Retrieve the entry box values. */
    // Edited ( mhakim 02-12-01 )
    // We need to retrieve one more byte for the domain name and network address.
//    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_DOMAIN, WM_GETTEXT, CVY_MAX_DOMAIN_NAME, (LPARAM)m_paramp->domain_name);
//    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_ETH, WM_GETTEXT, CVY_MAX_NETWORK_ADDR, (LPARAM)m_paramp->cl_mac_addr);

    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_DOMAIN, WM_GETTEXT, CVY_MAX_DOMAIN_NAME + 1, (LPARAM)m_paramp->domain_name);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_ETH, WM_GETTEXT, CVY_MAX_NETWORK_ADDR + 1, (LPARAM)m_paramp->cl_mac_addr);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_PASSW, WM_GETTEXT, CVY_MAX_RCT_CODE + 1, (LPARAM)m_passw);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_PASSW2, WM_GETTEXT, CVY_MAX_RCT_CODE + 1, (LPARAM)m_passw2);
}

/*
 * Method: ValidateInfo
 * Description: Called to validate the entries made by the user.
 */
LRESULT CCommonClusterPage::ValidateInfo () {
    DWORD IPAddr;

    TraceMsg(L"CCommonClusterPage::ValidateInfo\n");

    if (!m_IpSubnetControl.ValidateInfo())
    {
        //
        // Check whether IP address and subnet mask pair is valid
        //
        
        return PSNRET_INVALID;
    }

    //
    // Get the user input
    //
    m_IpSubnetControl.UpdateInfo(m_paramp->cl_ip_addr, m_paramp->cl_net_mask);

        
    /* Check to make sure that the dedicated IP and cluster IP are not the same. */
    if (!wcscmp(m_paramp->ded_ip_addr, m_paramp->cl_ip_addr)) {
        /* Alert the user. */
        NcMsgBox(m_hInstance, ::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_IP_CONFLICT,
                 MB_APPLMODAL | MB_ICONSTOP | MB_OK);
        
        /* An error occurred. */
        return PSNRET_INVALID;
    }

    if (!m_paramp->fConvertMac && !CheckClusterMACAddress()) {
        /* Alert the user. */
        NcMsgBox(m_hInstance, ::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_INVAL_MAC,
                 MB_APPLMODAL | MB_ICONSTOP | MB_OK);

        /* An error occurred. */
        return PSNRET_INVALID;
    }

    /* Only check for invalid passwords and update if remote control is enabled. */
    if (::IsDlgButtonChecked(m_hWnd, IDC_CHECK_RCT)) {
        /* Make sure the passwords match. */
        if (wcscmp(m_passw, m_passw2) != 0) {
            /* Alert the user. */
            NcMsgBox(m_hInstance, ::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_PASSWORD,
                     MB_APPLMODAL | MB_ICONSTOP | MB_OK);

            /* Empty the passwords. */
            m_passw [0] = m_passw2 [0] = 0;

            /* An error occurred. */
            return PSNRET_INVALID;
        } else {
            /* If the new password is not the dummy password, update the password. */
            if (wcscmp (m_passw, DUMMY_PASSWORD) != 0) {
                ARRAYSTRCPY(m_paramp->szPassword, m_passw);
                m_paramp->fChangePassword = true;
            }

        }
    }

    return PSNRET_NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\clusterportsdlg.cpp ===
#include "precomp.h"
#pragma hdrstop
#include "private.h"
#include "PortsPage.h"
#include "ClusterPortsDlg.h"

BEGIN_MESSAGE_MAP(ClusterPortsDlg, CDialog)
    ON_BN_CLICKED(IDC_RADIO_DISABLED, OnRadioDisabled)
    ON_BN_CLICKED(IDC_RADIO_MULTIPLE, OnRadioMultiple)
    ON_BN_CLICKED(IDC_CHECK_PORT_RULE_ALL_VIP, OnCheckAllVIP)
    ON_BN_CLICKED(IDC_RADIO_SINGLE, OnRadioSingle)
    ON_WM_HELPINFO()        
    ON_WM_CONTEXTMENU()        

END_MESSAGE_MAP()



ClusterPortsDlg::ClusterPortsDlg( PortsPage::PortData& portData, 
                                  CWnd* parent,
                                  const int&   index
                                  )
        :
        m_portData( portData ),
        CDialog( ClusterPortsDlg::IDD, parent ),
        m_index( index )
{
    m_parent = (PortsPage *) parent;
}


void 
ClusterPortsDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange( pDX );
    DDX_Control(pDX, IDC_EDIT_PORT_RULE_VIP, ipAddress);    
}

BOOL 
ClusterPortsDlg::OnInitDialog()
{
    CDialog::OnInitDialog();
    
    SetControlData();

    return TRUE;
}

void 
ClusterPortsDlg::OnOK()
{
    PortsPage::PortData portData;

    //
    // get port information.
    //

    BOOL fError;

    long start_port = ::GetDlgItemInt (m_hWnd, IDC_EDIT_START, &fError, FALSE);
    if( fError == FALSE )
    {
        // some problem with the data input.
        // it has been left blank.

        wchar_t buffer[Common::BUF_SIZE];

        StringCbPrintf( buffer, sizeof(buffer), GETRESOURCEIDSTRING( IDS_PARM_PORT_BLANK ), CVY_MIN_PORT,CVY_MAX_PORT  );

        MessageBox( buffer,
                    GETRESOURCEIDSTRING( IDS_PARM_ERROR ),
                    MB_ICONSTOP | MB_OK );

        return;
    }

    wchar_t buf[Common::BUF_SIZE];

    StringCbPrintf( buf, sizeof(buf), L"%d", start_port );
    portData.start_port = buf;

    long end_port =  ::GetDlgItemInt (m_hWnd, IDC_EDIT_END, &fError, FALSE);
    if( fError == FALSE )
    {
        // some problem with the data input.
        // it has been left blank.

        wchar_t buffer[Common::BUF_SIZE];

        StringCbPrintf( buffer, sizeof(buffer), GETRESOURCEIDSTRING( IDS_PARM_PORT_BLANK ), CVY_MIN_PORT,CVY_MAX_PORT  );

        MessageBox( buffer,
                    GETRESOURCEIDSTRING( IDS_PARM_ERROR ),
                    MB_ICONSTOP | MB_OK );


        return;
    }
    StringCbPrintf( buf, sizeof(buf), L"%d", end_port );
    portData.end_port = buf;

    // check if start port and end port both are in
    // proper range.
    if( !( start_port >= CVY_MIN_PORT 
           &&
           start_port <= CVY_MAX_PORT
           &&
           end_port >= CVY_MIN_PORT 
           &&
           end_port <= CVY_MAX_PORT )
        )
    {
        wchar_t buffer[Common::BUF_SIZE];

        StringCbPrintf( buffer, sizeof(buffer), GETRESOURCEIDSTRING( IDS_PARM_PORT_VAL ), CVY_MIN_PORT,CVY_MAX_PORT  );

        MessageBox( buffer,
                    GETRESOURCEIDSTRING( IDS_PARM_ERROR ),
                    MB_ICONSTOP | MB_OK );

        return;
    }

    // check if start port is less than or equal to end port.
    if( !(start_port <= end_port ) )
    {
        // start port is not less than or equal to end port. 
        MessageBox( GETRESOURCEIDSTRING(IDS_PARM_RANGE ),
                    GETRESOURCEIDSTRING( IDS_PARM_ERROR ),
                    MB_ICONSTOP | MB_OK );

        ::SetDlgItemInt(m_hWnd, IDC_EDIT_END, end_port, FALSE);

        return;
    }

    // get vip
    _bstr_t virtual_ip_addr;
    if (::IsDlgButtonChecked(m_hWnd, IDC_CHECK_PORT_RULE_ALL_VIP)) {
        // if ALL vips was checked, then set the VIP to 255.255.255.255.
        virtual_ip_addr = GETRESOURCEIDSTRING(IDS_REPORT_VIP_ALL);
        portData.virtual_ip_addr = virtual_ip_addr;
    } else {
        // otherwise, check for an empty vip.
        if (::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_PORT_RULE_VIP), IPM_ISBLANK, 0, 0)) {
            
            MessageBox(GETRESOURCEIDSTRING(IDS_PARM_VIP_BLANK),
                       GETRESOURCEIDSTRING(IDS_PARM_ERROR),
                       MB_ICONSTOP | MB_OK);
            
            return;
        }

        virtual_ip_addr = CommonUtils::getCIPAddressCtrlString(ipAddress);
        portData.virtual_ip_addr = virtual_ip_addr;

        // validate the vip.
        bool isIPValid = MIPAddress::checkIfValid(virtual_ip_addr); 
        
        if (isIPValid != true) {

            MessageBox(GETRESOURCEIDSTRING(IDS_PARM_INVAL_VIRTUAL_IP),
                       GETRESOURCEIDSTRING(IDS_PARM_ERROR),
                       MB_ICONSTOP | MB_OK);
            
            return;
        }
    }

    // check if there are are overlapped port rules.
    wchar_t portBuf[Common::BUF_SIZE];
    for( int i = 0; i < m_parent->m_portList.GetItemCount(); ++i )
    {
        if( i != m_index )  // not comparing against self
        {
            m_parent->m_portList.GetItemText( i, 1, portBuf, Common::BUF_SIZE );
            long start_port_existing =  _wtoi( portBuf );
            
            m_parent->m_portList.GetItemText( i, 2, portBuf, Common::BUF_SIZE );
            long end_port_existing = _wtoi( portBuf );
            
            m_parent->m_portList.GetItemText( i, 0, portBuf, Common::BUF_SIZE );
            _bstr_t virtual_ip_addr_existing = portBuf;
            
            if ( (virtual_ip_addr == virtual_ip_addr_existing) && 
                 ((start_port < start_port_existing &&
                   end_port >= start_port_existing ) ||
                  ( start_port >= start_port_existing &&
                    start_port <= end_port_existing )))
                
            {
                MessageBox( GETRESOURCEIDSTRING(IDS_PARM_OVERLAP ),
                            GETRESOURCEIDSTRING( IDS_PARM_ERROR ),
                            MB_ICONSTOP | MB_OK );
                
                return;
            }
        }
    }

    // get protocol
    if (::IsDlgButtonChecked (m_hWnd, IDC_RADIO_TCP))
    {
        portData.protocol = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_TCP );
    }
    else if( ::IsDlgButtonChecked (m_hWnd, IDC_RADIO_UDP))
    {
        portData.protocol = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_UDP );
    }
    else 
    {
        portData.protocol = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_BOTH);
    }

    // get filtering mode
    if (::IsDlgButtonChecked (m_hWnd, IDC_RADIO_MULTIPLE))
    {
        portData.mode = GETRESOURCEIDSTRING( IDS_REPORT_MODE_MULTIPLE );

        // get affinity
        if (::IsDlgButtonChecked (m_hWnd, IDC_RADIO_AFF_NONE))
        {
            portData.affinity = GETRESOURCEIDSTRING( IDS_REPORT_AFFINITY_NONE );            
        }
        else if (::IsDlgButtonChecked (m_hWnd, IDC_RADIO_AFF_SINGLE))
        {
            portData.affinity = GETRESOURCEIDSTRING( IDS_REPORT_AFFINITY_SINGLE );            
        }
        else
        {
            portData.affinity = GETRESOURCEIDSTRING( IDS_REPORT_AFFINITY_CLASSC );            
        }

        // for multiple mode, priority is empty.
        portData.priority = GETRESOURCEIDSTRING( IDS_REPORT_EMPTY );
    }
    else if (::IsDlgButtonChecked (m_hWnd, IDC_RADIO_SINGLE))
    {
        portData.mode = GETRESOURCEIDSTRING( IDS_REPORT_MODE_SINGLE );
        portData.priority = GETRESOURCEIDSTRING( IDS_REPORT_NA );

        // for single mode load and affinity are empty.
        portData.load = GETRESOURCEIDSTRING( IDS_REPORT_EMPTY );
        portData.affinity = GETRESOURCEIDSTRING( IDS_REPORT_EMPTY );
    }
    else
    {
        portData.mode = GETRESOURCEIDSTRING( IDS_REPORT_MODE_DISABLED );

        // for single mode priority load and affinity are empty.
        portData.priority = GETRESOURCEIDSTRING( IDS_REPORT_EMPTY );
        portData.load = GETRESOURCEIDSTRING( IDS_REPORT_EMPTY );
        portData.affinity = GETRESOURCEIDSTRING( IDS_REPORT_EMPTY );
    }

    // set the new port rule.
    m_portData = portData;

    EndDialog( IDOK );
}


void
ClusterPortsDlg::SetControlData()
{

    ::EnableWindow(GetDlgItem(IDC_CHECK_EQUAL)->m_hWnd, FALSE);
    ::ShowWindow(GetDlgItem(IDC_CHECK_EQUAL)->m_hWnd, SW_HIDE);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_START, EM_SETLIMITTEXT, 5, 0);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_END, EM_SETLIMITTEXT, 5, 0);
    ::SendDlgItemMessage(m_hWnd, IDC_SPIN_START, UDM_SETRANGE32, CVY_MIN_PORT, CVY_MAX_PORT);
    ::SendDlgItemMessage(m_hWnd, IDC_SPIN_END, UDM_SETRANGE32, CVY_MIN_PORT, CVY_MAX_PORT);

    // set the vip.
    if (!lstrcmpi(m_portData.virtual_ip_addr, GETRESOURCEIDSTRING(IDS_REPORT_VIP_ALL))) {
        ::CheckDlgButton(m_hWnd, IDC_CHECK_PORT_RULE_ALL_VIP, BST_CHECKED);
        ::EnableWindow(GetDlgItem(IDC_EDIT_PORT_RULE_VIP)->m_hWnd, FALSE);
    } else {
        CommonUtils::fillCIPAddressCtrlString(ipAddress, m_portData.virtual_ip_addr);
        ::CheckDlgButton(m_hWnd, IDC_CHECK_PORT_RULE_ALL_VIP, BST_UNCHECKED);
        ::EnableWindow(GetDlgItem(IDC_EDIT_PORT_RULE_VIP)->m_hWnd, TRUE);
    }

    // set the port range.
    ::SetDlgItemInt (m_hWnd, IDC_EDIT_START,  _wtoi( m_portData.start_port), FALSE);
    ::SetDlgItemInt (m_hWnd, IDC_EDIT_END,  _wtoi( m_portData.end_port ),   FALSE);

    // set the protocol.
    if( m_portData.protocol == GETRESOURCEIDSTRING(IDS_REPORT_PROTOCOL_TCP) )
    {
        ::CheckDlgButton( m_hWnd, IDC_RADIO_TCP, BST_CHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_UDP, BST_UNCHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_BOTH, BST_UNCHECKED );
    }
    else if( m_portData.protocol == GETRESOURCEIDSTRING(IDS_REPORT_PROTOCOL_UDP) )
    {
        ::CheckDlgButton( m_hWnd, IDC_RADIO_TCP, BST_UNCHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_UDP, BST_CHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_BOTH, BST_UNCHECKED );
    }
    else
    {
        ::CheckDlgButton( m_hWnd, IDC_RADIO_TCP, BST_UNCHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_UDP, BST_UNCHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_BOTH, BST_CHECKED );
    }

    // set the mode.
    if( m_portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_MULTIPLE) )
    { 
        ::CheckDlgButton( m_hWnd, IDC_RADIO_MULTIPLE, BST_CHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_SINGLE, BST_UNCHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_DISABLED, BST_UNCHECKED );

        :: EnableWindow (GetDlgItem (IDC_RADIO_AFF_NONE)->m_hWnd,   TRUE);
        :: EnableWindow (GetDlgItem (IDC_RADIO_AFF_SINGLE)->m_hWnd, TRUE);
        :: EnableWindow (GetDlgItem (IDC_RADIO_AFF_CLASSC)->m_hWnd, TRUE);

        if( m_portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_NONE ) )
        {
            ::CheckDlgButton( m_hWnd, IDC_RADIO_AFF_NONE, BST_CHECKED );
            ::CheckDlgButton( m_hWnd, IDC_RADIO_AFF_SINGLE, BST_UNCHECKED );
            ::CheckDlgButton( m_hWnd, IDC_RADIO_AFF_CLASSC, BST_UNCHECKED );
        }
        else if ( m_portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_SINGLE) )
        {
            ::CheckDlgButton( m_hWnd, IDC_RADIO_AFF_NONE, BST_UNCHECKED );
            ::CheckDlgButton( m_hWnd, IDC_RADIO_AFF_SINGLE, BST_CHECKED );
            ::CheckDlgButton( m_hWnd, IDC_RADIO_AFF_CLASSC, BST_UNCHECKED );
        }
        else
        {
            ::CheckDlgButton( m_hWnd, IDC_RADIO_AFF_NONE, BST_UNCHECKED );
            ::CheckDlgButton( m_hWnd, IDC_RADIO_AFF_SINGLE, BST_UNCHECKED );
            ::CheckDlgButton( m_hWnd, IDC_RADIO_AFF_CLASSC, BST_CHECKED );
        }
    }
    else if( m_portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_SINGLE) )
    {
        ::CheckDlgButton( m_hWnd, IDC_RADIO_MULTIPLE, BST_UNCHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_SINGLE, BST_CHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_DISABLED, BST_UNCHECKED );

        :: EnableWindow (GetDlgItem (IDC_RADIO_AFF_NONE)->m_hWnd,   FALSE);
        :: EnableWindow (GetDlgItem (IDC_RADIO_AFF_SINGLE)->m_hWnd, FALSE);
        :: EnableWindow (GetDlgItem (IDC_RADIO_AFF_CLASSC)->m_hWnd, FALSE);
    }
    else
    {
        ::CheckDlgButton( m_hWnd, IDC_RADIO_MULTIPLE, BST_UNCHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_SINGLE, BST_UNCHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_DISABLED, BST_CHECKED );

        :: EnableWindow (GetDlgItem (IDC_RADIO_AFF_NONE)->m_hWnd,   FALSE);
        :: EnableWindow (GetDlgItem (IDC_RADIO_AFF_SINGLE)->m_hWnd, FALSE);
        :: EnableWindow (GetDlgItem (IDC_RADIO_AFF_CLASSC)->m_hWnd, FALSE);
    }
}


void
ClusterPortsDlg::OnRadioMultiple() 
{
    // TODO: Add your control notification handler code here
    :: EnableWindow (GetDlgItem (IDC_RADIO_AFF_NONE)->m_hWnd,   TRUE);
    :: EnableWindow (GetDlgItem (IDC_RADIO_AFF_SINGLE)->m_hWnd, TRUE);
    :: EnableWindow (GetDlgItem (IDC_RADIO_AFF_CLASSC)->m_hWnd, TRUE);

    ::CheckDlgButton( m_hWnd, IDC_RADIO_AFF_NONE, BST_UNCHECKED );
    ::CheckDlgButton( m_hWnd, IDC_RADIO_AFF_SINGLE, BST_CHECKED );
    ::CheckDlgButton( m_hWnd, IDC_RADIO_AFF_CLASSC, BST_UNCHECKED );

 }

void 
ClusterPortsDlg::OnCheckAllVIP() 
{
    if (::IsDlgButtonChecked(m_hWnd, IDC_CHECK_PORT_RULE_ALL_VIP))
        ::EnableWindow(GetDlgItem(IDC_EDIT_PORT_RULE_VIP)->m_hWnd, FALSE);
    else
        ::EnableWindow(GetDlgItem(IDC_EDIT_PORT_RULE_VIP)->m_hWnd, TRUE);
}

void 
ClusterPortsDlg::OnRadioSingle() 
{
    // TODO: Add your control notification handler code here
    :: EnableWindow (GetDlgItem (IDC_RADIO_AFF_NONE)->m_hWnd,   FALSE);
    :: EnableWindow (GetDlgItem (IDC_RADIO_AFF_SINGLE)->m_hWnd, FALSE);
    :: EnableWindow (GetDlgItem (IDC_RADIO_AFF_CLASSC)->m_hWnd, FALSE);
}


void 
ClusterPortsDlg::OnRadioDisabled() 
{
    // TODO: Add your control notification handler code here
    :: EnableWindow (GetDlgItem (IDC_RADIO_AFF_NONE)->m_hWnd,   FALSE);
    :: EnableWindow (GetDlgItem (IDC_RADIO_AFF_SINGLE)->m_hWnd, FALSE);
    :: EnableWindow (GetDlgItem (IDC_RADIO_AFF_CLASSC)->m_hWnd, FALSE);

}

void ClusterPortsDlg::PrintRangeError (unsigned int ids, int low, int high) 
{
    /* Pop-up a message box. */
    wchar_t buffer[Common::BUF_SIZE];

    StringCbPrintf( buffer, sizeof(buffer), GETRESOURCEIDSTRING( ids ), low, high );

    MessageBox( buffer,
                GETRESOURCEIDSTRING( IDS_PARM_ERROR ),
                MB_ICONSTOP | MB_OK );
}

BOOL
ClusterPortsDlg::OnHelpInfo (HELPINFO* helpInfo )
{
    if( helpInfo->iContextType == HELPINFO_WINDOW )
    {
        ::WinHelp( static_cast<HWND> ( helpInfo->hItemHandle ), 
                   CVY_CTXT_HELP_FILE, HELP_WM_HELP, 
                   (ULONG_PTR ) g_aHelpIDs_IDD_PORT_RULE_PROP_CLUSTER );
    }

    return TRUE;
}

void
ClusterPortsDlg::OnContextMenu( CWnd* pWnd, CPoint point )
{
    ::WinHelp( m_hWnd, 
               CVY_CTXT_HELP_FILE, 
               HELP_CONTEXTMENU, 
               (ULONG_PTR ) g_aHelpIDs_IDD_PORT_RULE_PROP_CLUSTER );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\connect.h ===
//***************************************************************************
//
//  CONNECT.H
// 
//  Module: NLB Manager EXE
//
//  Purpose: Interface to the "connect to host" dialog.
//
//  Copyright (c)2001 Microsoft Corporation, All Rights Reserved
//
//  History:
//
//  07/30/01    JosephJ Created
//
//***************************************************************************
#pragma once


// class ConnectDialog : public CDialog
class ConnectDialog : public CPropertyPage
{

public:

    enum
    {
        IDD = IDD_DIALOG_CONNECT2
    };


    typedef enum
    {
        DLGTYPE_NEW_CLUSTER,
        DLGTYPE_EXISTING_CLUSTER,
        DLGTYPE_ADD_HOST

    } DlgType;


    ConnectDialog(
                 CPropertySheet *psh,
                 Document *pDocument,
                 NLB_EXTENDED_CLUSTER_CONFIGURATION *pNlbCfg,
                 ENGINEHANDLE *pehInterface, // IN OUT
                 DlgType type,
                 CWnd* parent
                );

    virtual BOOL OnInitDialog();

    virtual void OnOK();

    virtual BOOL OnSetActive();
    // virtual BOOL OnKillActive();
    virtual LRESULT OnWizardNext();

    // overrides CDialog -- see SDK documentation on DoDataExchange.
    // Used to map controls in resources to corresponding objects in this class.
    virtual void DoDataExchange( CDataExchange* pDX );

    //
    // We don't need these because we use the message map to
    // map button pressesdirectly to OnButtonConnect and OnButtonCredentials...
    //  
    // CButton     connectButton;    // Action: Connect to host
    // CButton     credentialsButton; // Action: Get non-default credentials.

    afx_msg void OnButtonConnect();
    afx_msg void OnSelchanged(NMHDR * pNotifyStruct, LRESULT * result );
    afx_msg void OnUpdateEditHostAddress();
    afx_msg BOOL OnHelpInfo (HELPINFO* helpInfo );
    afx_msg void OnContextMenu( CWnd* pWnd, CPoint point );

    BOOL        m_fOK;

    void GetMachineName(_bstr_t &refMachineName)
    {
        refMachineName = m_MachineName;
    }

private:

    CEdit       hostAddress;    // Host network address.
    CEdit       connectionStatus;   // Read-only status display
    CEdit       listHeading;   // Read-only status display
    // CListBox    interfaceList;      // List of interfaces (adapters)
    CListCtrl	interfaceList;
    

    DlgType     m_type;

    void
    mfn_InitializeListView(void);

    void
    mfn_InsertBoundInterface(
            ENGINEHANDLE ehInterfaceId,
            LPCWSTR szClusterName,
            LPCWSTR szClusterIp,
            LPCWSTR szInterfaceName
            );

    void
    mfn_InsertInterface(
            ENGINEHANDLE ehInterfaceId,
            LPCWSTR szInterfaceIp,
            LPCWSTR szInterfaceName,
            LPCWSTR szCluserIp
            );

    void
    mfn_SelectInterfaceIfAlreadyInCluster(
            LPCWSTR szClusterIp // OPTIONAL
            );

    void
    mfn_ApplySelectedInterfaceConfiguration(void);

    BOOL
    mfn_ValidateData(void);

    CPropertySheet *m_pshOwner;
    //
    // The machine name that the user has last successfully connected to.
    //
    _bstr_t  m_MachineName;

    //
    // Handle to the host
    //
    ENGINEHANDLE m_ehHostId;

    //
    // The interface that the user has selected (null if none selected).
    // The public GetSelectedInterfaceId may be used to retrieve this.
    //
    BOOL            m_fInterfaceSelected;
    ENGINEHANDLE    *m_pehSelectedInterfaceId;
    int             m_iInterfaceListItem;
    BOOL            m_fSelectedInterfaceIsInCluster;

    NLB_EXTENDED_CLUSTER_CONFIGURATION *m_pNlbCfg;

    Document *m_pDocument;

    static
    DWORD
    s_HelpIDs[];

    static
    DWORD
    s_ExistingClusterHelpIDs[];

    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\detailsview.cpp ===
//***************************************************************************
//
//  DETAILSVIEW.CPP
// 
//  Module: NLB Manager
//
//  Purpose: Implements DetailsView, the right-hand details list view.
//
//  Copyright (c)2001-2002 Microsoft Corporation, All Rights Reserved
//
//  History:
//
//  07/30/01    JosephJ Created
//
//***************************************************************************
#include "precomp.h"
#pragma hdrstop
#include "private.h"
#include "PortsPage.h"
#include "detailsview.tmh"

IMPLEMENT_DYNCREATE( DetailsView, CFormView )

BEGIN_MESSAGE_MAP( DetailsView, CFormView )

    ON_NOTIFY(HDN_ITEMCLICK, 0, OnColumnClick) 
    ON_NOTIFY(LVN_KEYDOWN,  IDC_LIST_DETAILS, OnNotifyKeyDown)
    ON_WM_SIZE()

END_MESSAGE_MAP()


DetailsView::DetailsView()
    : CFormView(IDD_DIALOG_DETAILSVIEW),
      m_initialized(FALSE),
      m_fPrepareToDeinitialize(FALSE)
{
    InitializeCriticalSection(&m_crit);
}

DetailsView::~DetailsView()
{
    DeleteCriticalSection(&m_crit);
}


void DetailsView::DoDataExchange(CDataExchange* pDX)
{
    // IDC_TEXT_DETAILS_CAPTION
    // TRACE_CRIT(L"<-> %!FUNC!");

	CFormView::DoDataExchange(pDX);
	DDX_Control(pDX, IDC_LIST_DETAILS, m_ListCtrl);
}

Document*
DetailsView::GetDocument()
{
    return ( Document *) m_pDocument;
}

/*
 * Method: OnSize
 * Description: This method is called by the WM_NOTIFY handler whenever
 *              a re-sizing of the details view occurs as the result of
 *              a window re-size or moving one of the window splitters.
 */
void 
DetailsView::OnSize( UINT nType, int cx, int cy )
{
    /* Call the Parent class OnSize method first. */
    CFormView::OnSize( nType, cx, cy );

    /* Call Resize to re-size the list view to fit the window. */
    Resize();
}

/*
 * Method: Resize
 * Description: This method is called in several places to specifically
 *              re-size the listview control to fit the window.
 */
void 
DetailsView::Resize()
{
    /* If the window has not yet been initialized, don't bother.
       This member is set in OnInitialUpdate. */
    if (m_initialized) {
        LONG Bottom;
        RECT Rect;
        
        /* Get a pointer to the caption edit box. */
        CWnd * ListCaption = GetDlgItem(IDC_TEXT_DETAILS_CAPTION);

        /* Get a pointer to the listview control. */
        CListCtrl & ListCtrl = GetListCtrl();

        /* Get the client rectangle of the caption dialog, which 
           stretches across the top of the window. */
        ListCaption->GetClientRect(&Rect);
        
        /* Note the location of the bottom. */
        Bottom = Rect.bottom;
        
        /* Now, get the client rectangle of the entire frame. */
        GetClientRect(&Rect);
        
        /* Re-set the top to be the bottom of the caption, plus 
           a little bit of empty space. */
        Rect.top = Bottom + 6;
        
        /* Re-set the window location of the LISTVIEW (Note: not
           the frame, just the listview).  Basically, we're re-
           sizing the listview to be the same as the frame, but 
           with its top equal to the bottom of the caption. */
        ListCtrl.MoveWindow(&Rect, TRUE); 
    }
}

void 
DetailsView::OnInitialUpdate()
{

    this->UpdateData(FALSE);

    //
    // register 
    // with the document class, 
    //
    GetDocument()->registerDetailsView(this);

    // initially nothing has been clicked.
    m_sort_column = -1;

    /* Mark the frame as initialized.  This is needed
       by the Resize notification callback. */
    m_initialized = TRUE;

    /* Set the initial size of the listview. */
    Resize();
}


void DetailsView::OnColumnClick(NMHDR* pNotifyStruct, LRESULT* pResult) 
{
    TRACE_CRIT(L"<->%!FUNC!");
    
    PortListUtils::OnColumnClick(
                (LPNMLISTVIEW) pNotifyStruct,
                REF GetListCtrl(),
                FALSE, // FALSE == is host level
                REF m_sort_ascending,
                REF m_sort_column
                );

}

//
// Handle a selection change notification from the left (tree) view
//
void
DetailsView::HandleLeftViewSelChange(
        IN IUICallbacks::ObjectType objtype,
        IN ENGINEHANDLE ehId
        )
{
    mfn_Lock();

    if (m_fPrepareToDeinitialize)
    {
        goto end;
    }

    if (ehId == NULL)
    {
        // Root view ...
        mfn_InitializeRootDisplay();
        goto end;
    }

    switch(objtype)
    {
    case  IUICallbacks::OBJ_CLUSTER:
        mfn_InitializeClusterDisplay(ehId);
        break;

    case  IUICallbacks::OBJ_INTERFACE:
        mfn_InitializeInterfaceDisplay(ehId);
        break;
        
    default:  // other object type unexpected
        ASSERT(FALSE);
        break;
    }

end:

    mfn_Unlock();

    return;
}

//
// Handle an event relating to a specific instance of a specific
// object type.
//
void
DetailsView::HandleEngineEvent(
    IN IUICallbacks::ObjectType objtype,
    IN ENGINEHANDLE ehClusterId, // could be NULL
    IN ENGINEHANDLE ehObjId,
    IN IUICallbacks::EventCode evt
    )
{
    if (m_fPrepareToDeinitialize)
    {
        goto end;
    }

    mfn_Lock();

    // DummyAction(L"DetailsView::HandleEngineEvent");

    //
    // If the object and type matches our, we'll re-draw our display...
    //
    if ((m_objType == objtype) && (m_ehObj == ehObjId))
    {
        //
        // It's us -- re-draw...
        //
        HandleLeftViewSelChange(objtype, ehObjId);
    }
    else if ((m_objType == IUICallbacks::OBJ_CLUSTER) && (m_ehObj == ehClusterId))
    {
        //
        // We're showing a cluster and this event is for one of our
        // interfaces -- for now we'll redraw ourselves. An optimization
        // would be to just re-draw that list element that represents the
        // interface.
        //
        HandleLeftViewSelChange(m_objType, m_ehObj);
    } 
    else if ((m_objType == IUICallbacks::OBJ_INVALID) && (objtype == IUICallbacks::OBJ_CLUSTER))
    {
        //
        // We're showing the root display (list of clusters and this 
        // event is a cluster update, so we need to refresh. 
        //
        HandleLeftViewSelChange(objtype, NULL);
    }
    mfn_Unlock();

end:
    return;

}


void
DetailsView::mfn_InitializeRootDisplay(VOID)
//
// Initialize the details-view display with the root is selected.
//
{

    vector <ENGINEHANDLE> ClusterList;
    vector <ENGINEHANDLE>::iterator iCluster;
    CListCtrl& ctrl = GetListCtrl();
    CLocalLogger logDescription;
    NLBERROR nerr;
    int i = 0;

    enum
    {
        COL_CL_NAME,
        COL_CL_IP_ADDR,
        COL_CL_IP_MASK,
        COL_CL_MODE,
        COL_CL_RCT_ENABLED
    }; 

    mfn_Clear();


    logDescription.Log(
        IDS_DETAILS_ROOT_DESCRIPTION
        );

    mfn_UpdateCaption(logDescription.GetStringSafe());

    ctrl.SetImageList( GetDocument()->m_images48x48, LVSIL_SMALL );

    ctrl.InsertColumn( COL_CL_NAME,
                       GETRESOURCEIDSTRING(IDS_DETAILS_COL_CLUSTER_NAME),
                       // L"Cluster name",
                       LVCFMT_LEFT,
                       175
        );
    ctrl.InsertColumn( COL_CL_IP_ADDR,
                       GETRESOURCEIDSTRING(IDS_DETAILS_COL_CIP),
                       // L"Cluster IP address",
                       LVCFMT_LEFT,
                       140
        );
    ctrl.InsertColumn( COL_CL_IP_MASK,
                       GETRESOURCEIDSTRING(IDS_DETAILS_COL_CIPMASK),
                       // L"Cluster IP subnet mask",
                       LVCFMT_LEFT,
                       140
        );
    ctrl.InsertColumn( COL_CL_MODE,
                       GETRESOURCEIDSTRING(IDS_DETAILS_COL_CMODE),
                       // L"Cluster mode",
                       LVCFMT_LEFT,
                       100
        );
    ctrl.InsertColumn( COL_CL_RCT_ENABLED,
                       GETRESOURCEIDSTRING(IDS_DETAILS_RCT_STATUS),
                       // L"Remote control status",
                       LVCFMT_LEFT,
                       125
        );

    nerr = gEngine.EnumerateClusters(ClusterList);

    if (FAILED(nerr)) goto end;

    for (iCluster = ClusterList.begin();
         iCluster != ClusterList.end(); 
         iCluster++) 
    {
        ENGINEHANDLE ehCluster = (ENGINEHANDLE)*iCluster;
        CClusterSpec cSpec;
        INT iIcon;
        LPCWSTR szClusterIp         = L"";
        LPCWSTR szClusterMask       = L"";
        LPCWSTR szClusterName       = L"";
        LPCWSTR szClusterMode       = L"";
        LPCWSTR szClusterRctEnabled = L"";
        const WLBS_REG_PARAMS * pParams;
        
        nerr = gEngine.GetClusterSpec(ehCluster, REF cSpec);

        if (FAILED(nerr)) goto end;

        if (cSpec.m_ClusterNlbCfg.IsValidNlbConfig())
        {
            pParams =  &cSpec.m_ClusterNlbCfg.NlbParams;

            szClusterName = pParams->domain_name;
            szClusterIp= pParams->cl_ip_addr;
            szClusterMask= pParams->cl_net_mask;
            szClusterMode = GETRESOURCEIDSTRING(IDS_DETAILS_HOST_CM_UNICAST); //"unicast";
            
            if (pParams->mcast_support)
            {
                if (pParams->fIGMPSupport)
                {
                    szClusterMode = GETRESOURCEIDSTRING(IDS_DETAILS_HOST_CM_IGMP); //"IGMP multicast";
                }
                else
                {
                    szClusterMode = GETRESOURCEIDSTRING(IDS_DETAILS_HOST_CM_MULTI); //"multicast";
                }
            }
            if (pParams->rct_enabled)
            {
                szClusterRctEnabled = GETRESOURCEIDSTRING(IDS_DETAILS_HOST_RCT_ENABLED); //"enabled";
            }
            else
            {
                szClusterRctEnabled = GETRESOURCEIDSTRING(IDS_DETAILS_HOST_RCT_DISABLED); //"disabled";
            }

            if (cSpec.m_fMisconfigured)
            {
                iIcon = Document::ICON_CLUSTER_BROKEN;
            }
            else
            {
                iIcon = Document::ICON_CLUSTER_OK;
            }

            //
            // Insert all the columns...
            //
            
            ctrl.InsertItem(
                LVIF_TEXT|LVIF_IMAGE|LVIF_PARAM, // nMask
                i,
                szClusterName, // text
                0, // nState
                0, // nStateMask
                iIcon,
                (LPARAM) ehCluster // lParam
                );
            
            ctrl.SetItemText( i, COL_CL_IP_ADDR, szClusterIp);
            ctrl.SetItemText( i, COL_CL_IP_MASK, szClusterMask);
            ctrl.SetItemText( i, COL_CL_MODE, szClusterMode);
            ctrl.SetItemText( i, COL_CL_RCT_ENABLED, szClusterRctEnabled);

            i++;
        }
    }

 end:

    return;
}

void
DetailsView::mfn_InitializeClusterDisplay(ENGINEHANDLE ehCluster)
//
// Initialize the details-view display with a cluster is selected.
//
{
    NLBERROR nerr;
    CClusterSpec     cSpec;
    CListCtrl& ctrl = GetListCtrl();
    CLocalLogger logDescription;
    enum
    {
        COL_INTERFACE_NAME=0,
        COL_STATUS,
        COL_DED_IP_ADDR,
        COL_DED_IP_MASK,
        COL_HOST_PRIORITY,
        COL_HOST_INITIAL_STATE
    }; 

    mfn_Clear();

    nerr = gEngine.GetClusterSpec(
                ehCluster,
                REF cSpec
                );
    
    if (FAILED(nerr)) goto end;

    if (cSpec.m_ClusterNlbCfg.IsValidNlbConfig())
    {
        logDescription.Log(
            IDS_DETAILS_CLUSTER_DESCRIPTION,
            cSpec.m_ClusterNlbCfg.NlbParams.domain_name,
            cSpec.m_ClusterNlbCfg.NlbParams.cl_ip_addr
            );
    }

    mfn_UpdateCaption(logDescription.GetStringSafe());

    ctrl.SetImageList( GetDocument()->m_images48x48, 
                                LVSIL_SMALL );

    ctrl.InsertColumn( COL_INTERFACE_NAME,
                           GETRESOURCEIDSTRING(IDS_DETAILS_COL_HOST),
                           // L"Host(Interface)",
                           LVCFMT_LEFT,
                           175
                           );
    ctrl.InsertColumn( COL_STATUS,
                           GETRESOURCEIDSTRING(IDS_DETAILS_COL_STATUS),
                           // L"Status",
                           LVCFMT_LEFT,
                           85
                           );
    ctrl.InsertColumn( COL_DED_IP_ADDR,
                           GETRESOURCEIDSTRING(IDS_DETAILS_COL_DIP),
                           // L"Dedicated IP address",
                           LVCFMT_LEFT,
                           140
                           );
    ctrl.InsertColumn( COL_DED_IP_MASK,
                           GETRESOURCEIDSTRING(IDS_DETAILS_COL_DIPMASK),
                           // L"Dedicated IP subnet mask",
                           LVCFMT_LEFT,
                           140
                           );
    ctrl.InsertColumn( COL_HOST_PRIORITY,
                           GETRESOURCEIDSTRING(IDS_DETAILS_COL_PRIORITY),
                           // L"Host priority",
                           LVCFMT_LEFT,
                           75
                           );
    ctrl.InsertColumn( COL_HOST_INITIAL_STATE,
                           GETRESOURCEIDSTRING(IDS_DETAILS_COL_INIT_STATE),
                           // L"Initial host state",
                           LVCFMT_LEFT,
                           100
                           );

    //
    // Now we loop through the interfaces in the cluster, adding one line of
    // information on each;
    //
    for( int i = 0; i < cSpec.m_ehInterfaceIdList.size(); ++i )
    {
        CInterfaceSpec   iSpec;
        CHostSpec        hSpec;
        _bstr_t bstrStatus;
        _bstr_t bstrDisplayName;
        ENGINEHANDLE ehIID = cSpec.m_ehInterfaceIdList[i];
        INT iIcon = 0;
        WBEMSTATUS wStat;
        LPCWSTR szDisplayName          = L"";
        LPCWSTR szStatus            = L"";
        LPCWSTR szDedIp             = L"";
        LPCWSTR szDedMask           = L"";
        LPCWSTR szHostPriority      = L"";
        LPCWSTR szHostInitialState  = L"";
        WCHAR rgPriority[64];
        WCHAR rgInitialState[64];
        const WLBS_REG_PARAMS *pParams = 
            &iSpec.m_NlbCfg.NlbParams;

        nerr = gEngine.GetInterfaceInformation(
                ehIID,
                REF hSpec,
                REF iSpec,
                REF bstrDisplayName,
                REF iIcon,
                REF bstrStatus
                );
        if (NLBFAILED(nerr))
        {
            continue;
        }
        else
        {
            szDisplayName = bstrDisplayName;
            szStatus = bstrStatus;
        }

        if (iSpec.m_NlbCfg.IsValidNlbConfig())
        {
            szDedIp       = pParams->ded_ip_addr;
            szDedMask     = pParams->ded_net_mask;

            StringCbPrintf(rgPriority, sizeof(rgPriority), L"%lu", pParams->host_priority);
            szHostPriority = rgPriority;

            // szHostInitialState
            switch(pParams->cluster_mode)
            {
            case CVY_HOST_STATE_STARTED:
                szHostInitialState  = GETRESOURCEIDSTRING(IDS_DETAILS_HOST_STATE_STARTED); // L"started";
                break;

            case CVY_HOST_STATE_STOPPED:
                szHostInitialState  = GETRESOURCEIDSTRING(IDS_DETAILS_HOST_STATE_STOPPED); // L"stopped";
                break;

            case CVY_HOST_STATE_SUSPENDED:
                szHostInitialState  = GETRESOURCEIDSTRING(IDS_DETAILS_HOST_STATE_SUSPENDED); // L"suspended";
                break;

            default:
                szHostInitialState  = GETRESOURCEIDSTRING(IDS_DETAILS_HOST_STATE_UNKNOWN); // L"unknown";
                break;
            }

            if (pParams->persisted_states & CVY_PERSIST_STATE_SUSPENDED)
            {
                StringCbPrintf(
                rgInitialState,
                sizeof(rgInitialState),
                (LPCWSTR) GETRESOURCEIDSTRING(IDS_DETAILS_PERSIST_SUSPEND), // L"%ws, persist suspend"
                 szHostInitialState);
                szHostInitialState = rgInitialState;
            }
        }


        //
        // Insert all the columns...
        //

        ctrl.InsertItem(
                 LVIF_TEXT|LVIF_IMAGE|LVIF_PARAM, // nMask
                 i,
                 szDisplayName, // text
                 0, // nState
                 0, // nStateMask
                 iIcon,
                 (LPARAM) ehIID // lParam
                 );
        ctrl.SetItemText( i, COL_STATUS, szStatus);
        ctrl.SetItemText( i, COL_DED_IP_ADDR, szDedIp);
        ctrl.SetItemText( i, COL_DED_IP_MASK, szDedMask);
        ctrl.SetItemText( i, COL_HOST_PRIORITY, szHostPriority);
        ctrl.SetItemText( i, COL_HOST_INITIAL_STATE, szHostInitialState);
    }

    //
    // Keep track of which object we're displaying...
    //
    m_ehObj = ehCluster;
    m_objType = IUICallbacks::OBJ_CLUSTER;

end:
    return;
}

void
DetailsView::mfn_InitializeInterfaceDisplay(ENGINEHANDLE ehInterface)
//
// Initialize the details-view display when an interface in a cluster is
// selected.
//
{
    NLBERROR nerr;
    CInterfaceSpec ISpec;
    CListCtrl& ctrl = GetListCtrl();

    mfn_Clear();

    nerr =  gEngine.GetInterfaceSpec(ehInterface, REF ISpec);

    if (NLBFAILED(nerr))
    {
        goto end;
    }

    //
    // Fill out the caption with host name and interface name...
    //
    {
        WBEMSTATUS  wStat;
        LPWSTR      szAdapter   = L"";
        LPCWSTR     szHostName  = L"";
        CHostSpec   hSpec;
        CLocalLogger log;

        nerr = gEngine.GetHostSpec(
                ISpec.m_ehHostId,
                REF hSpec
                );
        if (NLBOK(nerr))
        {
            szHostName = (LPCWSTR) hSpec.m_MachineName;
            if (szHostName == NULL)
            {
                szHostName = L"";
            }
        }

        wStat = ISpec.m_NlbCfg.GetFriendlyName(&szAdapter);
        if (FAILED(wStat))
        {
            szAdapter = NULL;
        }

        if (szAdapter == NULL)
        szAdapter = L"";
        
        log.Log(
            IDS_DETAILS_PORT_CAPTION,
            szHostName,
            szAdapter
            );
        delete szAdapter;

        mfn_UpdateCaption(log.GetStringSafe());
    }

    PortListUtils::LoadFromNlbCfg(
            &ISpec.m_NlbCfg,
            ctrl,
            FALSE, // FALSE == is host-level
            TRUE   // TRUE == displaying in the details view
            );
    //
    // Keep track of which object we're displaying...
    //
    m_ehObj = ehInterface;
    m_objType = IUICallbacks::OBJ_INTERFACE;

end:

    return;
}

void
DetailsView::mfn_UpdateInterfaceInClusterDisplay(
        ENGINEHANDLE ehInterface,
        BOOL fDelete
        )
//
// Update or delete the specified interface from the  cluster view.
// Assumes that a cluster is selected in the left view.
//
{
}

void
DetailsView::mfn_Clear(void)
//
// Delete all items and all columns in the list
//
{
    CListCtrl& ctrl = GetListCtrl();
    ctrl.DeleteAllItems();	

    // Delete all of the previous columns.
    LV_COLUMN colInfo;
    ZeroMemory(&colInfo, sizeof(colInfo));
    colInfo.mask = LVCF_SUBITEM;

    while(ctrl.GetColumn(0, &colInfo))
    {
        ctrl.DeleteColumn(0);
    }
    ctrl.SetImageList( NULL, LVSIL_SMALL );
    mfn_UpdateCaption(L"");

    //
    // Clear currently displayed object handle and it's type.
    //
    m_ehObj = NULL;
    m_objType = IUICallbacks::OBJ_INVALID;
}

VOID
DetailsView::mfn_UpdateCaption(LPCWSTR szText)
{
    SetDlgItemText(IDC_TEXT_DETAILS_CAPTION, szText);
}

void
DetailsView::mfn_Lock(void)
{
    //
    // See  notes.txt entry
    //      01/23/2002 JosephJ DEADLOCK in Leftview::mfn_Lock
    // for the reason for this convoluted implementation of mfn_Lock
    //

    while (!TryEnterCriticalSection(&m_crit))
    {
        ProcessMsgQueue();
        Sleep(100);
    }
}

void
DetailsView::Deinitialize(void)
{
    TRACE_INFO(L"-> %!FUNC!");
    ASSERT(m_fPrepareToDeinitialize);
    // DummyAction(L"Details::Deinitialize");
    TRACE_INFO(L"<- %!FUNC!");
}

void DetailsView::OnNotifyKeyDown( NMHDR* pNMHDR, LRESULT* pResult )
{
    TRACE_CRIT(L"<->%!FUNC!");
    NMLVKEYDOWN *pkd =  (NMLVKEYDOWN *) pNMHDR;

    if (pkd->wVKey == VK_F6 || pkd->wVKey == VK_TAB)
    {
        *pResult = 0;
        if (! (::GetAsyncKeyState(VK_SHIFT) & 0x8000))
        {
            GetDocument()->SetFocusNextView(this, (int) pkd->wVKey);
        }
        else
        {
            GetDocument()->SetFocusPrevView(this, (int) pkd->wVKey);
        }
    }
}

void
DetailsView::SetFocus(void)
{

    //
    // We override our SetFocus, because we really need to set the focus
    // on our list control, and also select a listview item if there isn't
    // one selected...
    //

    CListCtrl& ctrl = GetListCtrl();
    POSITION    pos = NULL;
    pos = ctrl.GetFirstSelectedItemPosition();

    //
    // If no item is selected, select one...
    //
    if(pos == NULL)
    {
       ctrl.SetItemState(0, LVIS_SELECTED, LVIS_SELECTED);
    }

    ctrl.SetFocus();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\commonclusterpage.h ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    CommonClusterDlg.h

Abstract:

    Windows Load Balancing Service (WLBS)
    Cluster page UI.  Shared by Notifier object and NLB Manager

Author:

    kyrilf
    shouse

--*/

#pragma once

#include "resource.h"
#include "wlbsparm.h"
#include "IpSubnetMaskControl.h"


#define WLBS_MAX_PASSWORD 16

//
// Common port rule structure shared by wlbscfg and nlbmanager
//
struct NETCFG_WLBS_PORT_RULE {
    DWORD start_port;             // Starting port number. 
    DWORD end_port;               // Ending port number. 
    DWORD mode;                   // Filtering mode. WLBS_PORT_RULE_XXXX 
    DWORD protocol;               // WLBS_TCP, WLBS_UDP or WLBS_TCP_UDP 

    union {
        struct {
            DWORD priority;       // Mastership priority: 1..32 or 0 for not-specified. 
        } single;                 // Data for single server mode. 

        struct {
            WORD equal_load;      // TRUE - Even load distribution. 
            WORD affinity;        // WLBS_AFFINITY_XXX 
            DWORD load;           // Percentage of load to handle locally 0..100. 
        } multi;                  // Data for multi-server mode. 

    } mode_data;                  // Data for appropriate port group mode. 
};

//
// Common properties that can be configured by wlbscfg and nlbmanager
//

struct NETCFG_WLBS_CONFIG {
    DWORD dwHostPriority;                             // Host priority ID.
    BOOL fRctEnabled;                                 // TRUE - remote control enabled. 
    BOOL fJoinClusterOnBoot;                          // TRUE - join cluster on boot.
    BOOL fMcastSupport;                               // TRUE - multicast mode, FALSE - unicast mode.
    BOOL fIGMPSupport;                                // TRUE - IGMP enabled.
    BOOL fIpToMCastIp;                                // TRUE - derive multicast IP from cluster IP.

    WCHAR szMCastIpAddress[CVY_MAX_CL_IP_ADDR + 1];   // The multicast IP address, if user-specified.
    TCHAR cl_mac_addr[CVY_MAX_NETWORK_ADDR + 1];      // Cluster MAC address.
    TCHAR cl_ip_addr[CVY_MAX_CL_IP_ADDR + 1];         // Cluster IP address.
    TCHAR cl_net_mask[CVY_MAX_CL_NET_MASK + 1];       // Netmask for cluster IP.
    TCHAR ded_ip_addr[CVY_MAX_DED_IP_ADDR + 1];       // Dedicated IP address or "" for none.
    TCHAR ded_net_mask[CVY_MAX_DED_NET_MASK + 1];     // Netmask for dedicated IP address or "" for none.
    TCHAR domain_name[CVY_MAX_DOMAIN_NAME + 1];       // Full Qualified Domain Name of the cluster. 

    bool fChangePassword;                             // Whether to change password, valid for SetAdapterConfig only.
    TCHAR szPassword[CVY_MAX_RCT_CODE + 1];           // Remote control password, valid for SetAdapterConfig only.

    bool fConvertMac;                                 // Whether the mac address is generated from IP.
    DWORD dwMaxHosts;                                 // Maximum # hosts allowed.
    DWORD dwMaxRules;                                 // Maximum # port group rules allowed.
    
    DWORD dwNumRules;                                 // # active port group rules 
    NETCFG_WLBS_PORT_RULE port_rules[CVY_MAX_RULES];  // Port rules
};


//+----------------------------------------------------------------------------
//
// class CCommonClusterPage
//
// Description: Provide a common class to display cluster property page for
//              notifier object and NLB Manager
//
// History:     shouse initial code
//              fengsun Created Header    1/04/01
//
//+----------------------------------------------------------------------------
class CCommonClusterPage
{
public:
    /* Constructors/Destructors. */
    CCommonClusterPage (HINSTANCE hInstance, NETCFG_WLBS_CONFIG * paramp, 
        bool fDisablePassword, const DWORD * phelpIDs = NULL);
    ~CCommonClusterPage ();

public:
    /* Message map functions. */
    LRESULT OnInitDialog (HWND hWnd);
    LRESULT OnContextMenu ();
    LRESULT OnHelp (UINT uMsg, WPARAM wParam, LPARAM lParam);

    BOOL Load (void);
    BOOL Save (void);

    LRESULT OnIpFieldChange (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);

    LRESULT OnEditClIp (WORD wNotifyCode, WORD wID, HWND hWndCtl);
    LRESULT OnEditClMask (WORD wNotifyCode, WORD wID, HWND hWndCtl);
    LRESULT OnCheckRct (WORD wNotifyCode, WORD wID, HWND hWndCtl);
    LRESULT OnButtonHelp (WORD wNotifyCode, WORD wID, HWND hWndCtl);
    LRESULT OnCheckMode (WORD wNotifyCode, WORD wID, HWND hWndCtl);
    LRESULT OnCheckIGMP (WORD wNotifyCode, WORD wID, HWND hWndCtl);

 	void External_UpdateInfo(void) {UpdateInfo();}

private:
    void SetClusterMACAddress ();
    BOOL CheckClusterMACAddress ();

    void SetInfo ();
    void UpdateInfo ();

    LRESULT ValidateInfo ();          

    NETCFG_WLBS_CONFIG * m_paramp;

    const DWORD * m_adwHelpIDs;

    BOOL m_rct_warned;
    BOOL m_igmp_warned;
    BOOL m_igmp_mcast_warned;

    WCHAR m_passw[CVY_MAX_RCT_CODE + 1];
    WCHAR m_passw2[CVY_MAX_RCT_CODE + 1];

    CIpSubnetMaskControl m_IpSubnetControl;

    HWND m_hWnd;
    HINSTANCE m_hInstance;
    bool m_fDisablePassword; // If true, always disable password editing
};

PCWSTR
SzLoadStringPcch (
    IN HINSTANCE   hinst,
    IN UINT        unId,
    OUT int*       pcch);

PCWSTR
SzLoadString (
    HINSTANCE   hinst,
    UINT        unId);

INT
WINAPIV
NcMsgBox (
    IN HINSTANCE   hinst,
    IN HWND        hwnd,
    IN UINT        unIdCaption,
    IN UINT        unIdFormat,
    IN UINT        unStyle,
    IN ...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\detailsview.h ===
//***************************************************************************
//
//  DETAILSVIEW.H
// 
//  Module: NLB Manager (client-side exe)
//
//  Purpose:  The (right hand side) view of details of something selected
//          on the left hand side.
//
//  Copyright (c)2001 Microsoft Corporation, All Rights Reserved
//
//  History:
//
//  07/25/01    JosephJ Created, from the now defunct RightTopView.
//
//***************************************************************************
#pragma once
#include "stdafx.h"
#include "Document.h"

class DetailsView : public CFormView
{
    DECLARE_DYNCREATE( DetailsView )

    void SetFocus(void);

protected:
	DetailsView(void);           // protected constructor used by dynamic creation
	~DetailsView();

public:


    virtual void OnInitialUpdate();
    virtual void DoDataExchange(CDataExchange* pDX);

    //
    // Called to indicate that deinitialization will soon follow.
    // After return from this call, the the details view will ignore
    // any HandleEngineEvent or HandleLeftViewSelChange requests.
    //
    void
    PrepareToDeinitialize(void)
    {
        m_fPrepareToDeinitialize = TRUE;
    }

    void Deinitialize(void);
    //
    // Update the view because of change relating to a specific instance of
    // a specific object type.
    //
    void
    HandleEngineEvent(
        IN IUICallbacks::ObjectType objtype,
        IN ENGINEHANDLE ehClusterId, // could be NULL
        IN ENGINEHANDLE ehObjId,
        IN IUICallbacks::EventCode evt
        );

    //
    // Handle a selection change notification from the left (tree) view
    //
    void
    HandleLeftViewSelChange(
        IN IUICallbacks::ObjectType objtype,
        IN ENGINEHANDLE ehId
        );

    BOOL m_initialized; // is the dialog initialized?

    afx_msg void OnSize( UINT nType, int cx, int cy );
    void Resize();

protected:
    Document* GetDocument();

    afx_msg void OnColumnClick( NMHDR* pNMHDR, LRESULT* pResult );
    afx_msg void OnNotifyKeyDown( NMHDR* pNMHDR, LRESULT* pResult );

private:
    bool m_sort_ascending;
    int m_sort_column;
    ENGINEHANDLE                m_ehObj;        // currently displayed obj
    IUICallbacks::ObjectType    m_objType;      // it's type.

    CListCtrl	m_ListCtrl;
    CListCtrl&
    GetListCtrl(void)
    {
        return m_ListCtrl;    
    }

    VOID
    mfn_UpdateCaption(LPCWSTR szText);

    void
    mfn_InitializeRootDisplay(VOID);

    void
    mfn_InitializeClusterDisplay(ENGINEHANDLE ehCluster);

    void
    mfn_InitializeInterfaceDisplay(ENGINEHANDLE ehInterface);

    void
    mfn_UpdateInterfaceInClusterDisplay(ENGINEHANDLE ehInterface, BOOL fDelete);

    void
    mfn_Clear(void);

	CRITICAL_SECTION m_crit;
    BOOL m_fPrepareToDeinitialize;

    void mfn_Lock(void);
    void mfn_Unlock(void) {LeaveCriticalSection(&m_crit);}

    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\disclaimer.h ===
//***************************************************************************
//
//  DISCLAIMER.H
// 
//  Module: NLB Manager EXE
//
//  Purpose: sets up a disclaimer dialogbox, which has a "don't remind
//           me again checkbox".
//
//  Copyright (c)2001 Microsoft Corporation, All Rights Reserved
//
//  History:
//
//  05/20/01    JosephJ Created
//
//***************************************************************************

#ifndef DISCLAIMER_H
#define DISCLAIMER_H

#include "stdafx.h"

#include "resource.h"

class DisclaimerDialog : public CDialog
{
public:
    enum
    {
        IDD = IDD_DISCLAIMER,
    };

    DisclaimerDialog(CWnd* parent = NULL);

    virtual BOOL OnInitDialog();

    virtual void OnOK();


    // overrides CDialog -- see SDK documentation on DoDataExchange.
    // Used to map controls in resources to corresponding objects in this class.
    virtual void DoDataExchange( CDataExchange* pDX );

    // CButton        dontRemindMe;
    int			   dontRemindMe;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\disclaimer.cpp ===
//***************************************************************************
//
//  UPDATECFG.CPP
// 
//  Module: NLB Manager
//
//  Purpose: Defines class NlbConfigurationUpdate, used for 
//           async update of NLB properties associated with a particular NIC.
//
//  Copyright (c)2001 Microsoft Corporation, All Rights Reserved
//
//  History:
//
//  04/05/01    JosephJ Created
//
//***************************************************************************
#include "precomp.h"
#pragma hdrstop
#include "disclaimer.h"

DisclaimerDialog::DisclaimerDialog(CWnd* parent )
        :
        CDialog( IDD, parent )
{}

void
DisclaimerDialog::DoDataExchange( CDataExchange* pDX )
{  
	CDialog::DoDataExchange(pDX);

   // DDX_Control( pDX, IDC_DO_NOT_REMIND, dontRemindMe );
   DDX_Check(pDX, IDC_DO_NOT_REMIND, dontRemindMe);
}


BOOL
DisclaimerDialog::OnInitDialog()
{
    BOOL fRet = CDialog::OnInitDialog();

    dontRemindMe = 0;
    return fRet;
}

void DisclaimerDialog::OnOK()
{
    //
    // Get the current check status ....
    //
	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\connect.cpp ===
//***************************************************************************
//
//  CONNECT.CPP
// 
//  Module: NLB Manager
//
//  Purpose: Implements ConnectDialog, which is a dialog for connecting
//           to a host, extracting and displaying its list of adapters.
//
//  Copyright (c)2001 Microsoft Corporation, All Rights Reserved
//
//  History:
//
//  07/30/01    JosephJ Created
//
//***************************************************************************
#include "precomp.h"
#pragma hdrstop
#include "private.h"
#include "connect.h"
#include "connect.tmh"


// BEGIN_MESSAGE_MAP( ConnectDialog, CDialog )

BEGIN_MESSAGE_MAP( ConnectDialog, CPropertyPage )

    ON_BN_CLICKED(IDC_BUTTON_CONNECT, OnButtonConnect)
    ON_WM_HELPINFO()        
    ON_WM_CONTEXTMENU()        
    ON_NOTIFY( LVN_ITEMCHANGED, IDC_LIST_INTERFACES, OnSelchanged )
    ON_EN_UPDATE(IDC_EDIT_HOSTADDRESS,OnUpdateEditHostAddress)

    //
    // Other options...
    //
    // ON_EN_SETFOCUS(IDC_EDIT_HOSTADDRESS,OnSetFocusEditHostAddress)
    // ON_WM_ACTIVATE()
    // ON_NOTIFY( NM_DBLCLK, IDC_LIST_INTERFACES, OnDoubleClick )
    // ON_NOTIFY( LVN_COLUMNCLICK, IDC_LIST_INTERFACES, OnColumnClick )
    //

END_MESSAGE_MAP()


//
// Static help-id maps
//

DWORD
ConnectDialog::s_HelpIDs[] =
{
    IDC_TEXT_HOSTADDRESS,   IDC_EDIT_HOSTADDRESS,
    IDC_EDIT_HOSTADDRESS,   IDC_EDIT_HOSTADDRESS,
    IDC_BUTTON_CONNECT,     IDC_BUTTON_CONNECT,
    IDC_GROUP_CONNECTION_STATUS, IDC_GROUP_CONNECTION_STATUS,
    IDC_TEXT_CONNECTION_STATUS, IDC_TEXT_CONNECTION_STATUS,
    IDC_TEXT_INTERFACES,    IDC_LIST_INTERFACES,
    IDC_LIST_INTERFACES,     IDC_LIST_INTERFACES,
    0, 0
};

DWORD
ConnectDialog::s_ExistingClusterHelpIDs[] = 
{
    IDC_TEXT_HOSTADDRESS,   IDC_EDIT_HOSTADDRESSEX,
    IDC_EDIT_HOSTADDRESS,   IDC_EDIT_HOSTADDRESSEX,
    IDC_BUTTON_CONNECT,     IDC_BUTTON_CONNECTEX,
    IDC_GROUP_CONNECTION_STATUS, IDC_GROUP_CONNECTION_STATUS,
    IDC_TEXT_CONNECTION_STATUS, IDC_TEXT_CONNECTION_STATUS,
    IDC_TEXT_INTERFACES,    IDC_LIST_INTERFACESEX,
    IDC_LIST_INTERFACES,     IDC_LIST_INTERFACESEX,
    0, 0
};


VOID zap_slash(LPWSTR sz) // Look for a the first '/' and set it to zero.
{
    sz = wcschr(sz, '/');
    if (sz!=NULL) *sz=0;
}

ConnectDialog::ConnectDialog(
           CPropertySheet *psh,
           Document *pDocument,
           NLB_EXTENDED_CLUSTER_CONFIGURATION *pNlbCfg,
           ENGINEHANDLE *pehInterface, // IN OUT
           DlgType type,
           CWnd* parent
           )
        :
        // CDialog( IDD, parent )
        CPropertyPage(IDD),
        m_type(type),
        m_fOK(FALSE),
        m_pshOwner(psh),
        m_pDocument(pDocument),
        m_fInterfaceSelected(FALSE),
        m_iInterfaceListItem(0),
        m_pehSelectedInterfaceId(pehInterface),
        m_fSelectedInterfaceIsInCluster(FALSE),
        m_pNlbCfg(pNlbCfg),
        m_ehHostId(NULL)
{
    *m_pehSelectedInterfaceId = NULL;
}

void
ConnectDialog::DoDataExchange( CDataExchange* pDX )
{  
	// CDialog::DoDataExchange(pDX);
	CPropertyPage::DoDataExchange(pDX);

    DDX_Control(pDX, IDC_LIST_INTERFACES, interfaceList);
    DDX_Control(pDX, IDC_TEXT_CONNECTION_STATUS, connectionStatus);
    DDX_Control(pDX, IDC_TEXT_INTERFACES, listHeading);
    DDX_Control(pDX, IDC_EDIT_HOSTADDRESS, hostAddress);

    //
    // Note: the buttons are handled by the ON_BN_CLICKED macro
    // above.
    //
    // DDX_Control(pDX, IDC_BUTTON_CONNECT, buttonConnect);
    // DDX_Control(pDX, IDC_BUTTON_CREDENTIALS, credentialsButton);

}


BOOL
ConnectDialog::OnInitDialog()
{
    // BOOL fRet = CDialog::OnInitDialog();
    BOOL fRet = CPropertyPage::OnInitDialog();
    _bstr_t bstrDescription;
    _bstr_t bstrListText;

    m_fOK = FALSE;

    switch(m_type)
    {
    case DLGTYPE_NEW_CLUSTER:
        bstrDescription =  GETRESOURCEIDSTRING(IDS_CONNECT_NEW_HINT);
        bstrListText    =  GETRESOURCEIDSTRING(IDS_CONNECT_NEW_LIST_TXT);
        break;

    case DLGTYPE_EXISTING_CLUSTER:
        bstrDescription =  GETRESOURCEIDSTRING(IDS_CONNECT_EXISTING_HINT);
        bstrListText    =  GETRESOURCEIDSTRING(IDS_CONNECT_EXISTING_LIST_TXT);
        break;

    case DLGTYPE_ADD_HOST:
        bstrDescription =  GETRESOURCEIDSTRING(IDS_CONNECT_ADD_HOST_HINT);
        bstrListText    =  GETRESOURCEIDSTRING(IDS_CONNECT_ADD_HOST_LIST_TXT);
        break;
    }

    //
    // Initialize the caption and discription based on the type of
    // dialog.
    //
    {
        CWnd *pItem = GetDlgItem(IDC_TEXT_CONNECT_DESCRIPTION);
        pItem->SetWindowText(bstrDescription);
        pItem = GetDlgItem(IDC_TEXT_INTERFACES);
        pItem->SetWindowText(bstrListText);
    }

    // Initialize the list control
    mfn_InitializeListView();

    // interfaceList.SetCurSel( 0 );
    // ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_HOSTADDRESS), TRUE );
    // ::EnableWindow(::GetDlgItem(m_hWnd, IDC_LIST_INTERFACES), TRUE );

    //
    // The "Connect" button starts out disabled. It is only enabled
    // when the uers types non-whitespace text in the host address
    // edit control.
    //
    ::EnableWindow (GetDlgItem(IDC_BUTTON_CONNECT)->m_hWnd, FALSE);
    return fRet;
}


BOOL
ConnectDialog::OnHelpInfo (HELPINFO* helpInfo )
{
    if( helpInfo->iContextType == HELPINFO_WINDOW )
    {
        //
        // We choose the context-senstive map  appropriate to the
        // type of dialog (m_type).
        //

        ULONG_PTR  pHelpIds =  (ULONG_PTR) s_HelpIDs;
        BOOL fExisting = (m_type == DLGTYPE_EXISTING_CLUSTER);

        if (fExisting)
        {
            pHelpIds =  (ULONG_PTR) s_ExistingClusterHelpIDs;
        }


        ::WinHelp( static_cast<HWND> ( helpInfo->hItemHandle ), 
                   CVY_CTXT_HELP_FILE, 
                   HELP_WM_HELP, 
                   (ULONG_PTR ) pHelpIds);
    }

    return TRUE;
}


void
ConnectDialog::OnContextMenu( CWnd* pWnd, CPoint point )
{
    ::WinHelp( m_hWnd, 
               CVY_CTXT_HELP_FILE, 
               HELP_CONTEXTMENU, 
               (ULONG_PTR ) s_HelpIDs);
}

void
ConnectDialog::mfn_InitializeListView(void)
//
// Set the columns on the list box based on the type of dialog
//
{
    BOOL fExisting = (m_type == DLGTYPE_EXISTING_CLUSTER);

    RECT rect;
    INT colWidth;

    interfaceList.GetClientRect(&rect);

    colWidth = (rect.right - rect.left)/4;

    if (fExisting)
    {
        //
        // The interface list is that of interfaces already bound to NLB.
        // we display the cluster dnsname and ip first, then adapter name.
        //
        interfaceList.InsertColumn(
                 0, 
                 GETRESOURCEIDSTRING( IDS_HEADER_IFLIST_CLUSTERNAME),
                 LVCFMT_LEFT, 
                 colWidth);
        interfaceList.InsertColumn(
                 1, 
                 GETRESOURCEIDSTRING( IDS_HEADER_IFLIST_CLUSTERIP),
                 LVCFMT_LEFT, 
                 colWidth);
        interfaceList.InsertColumn(
                 2, 
                 GETRESOURCEIDSTRING( IDS_HEADER_IFLIST_IFNAME),
                 LVCFMT_LEFT, 
                 colWidth * 2);
    }
    else
    {
        //
        // The interface list is that of interfaces NOT bound to NLB.
        // We display the current IP address first, then adapter name.
        //
        interfaceList.InsertColumn(
                 0, 
                 GETRESOURCEIDSTRING( IDS_HEADER_IFLIST_IFNAME),
                 LVCFMT_LEFT, 
                 colWidth * 2);
        interfaceList.InsertColumn(
                 1, 
                 GETRESOURCEIDSTRING( IDS_HEADER_IFLIST_IFIP),
                 LVCFMT_LEFT, 
                 colWidth);
        interfaceList.InsertColumn(
                 2, 
                 GETRESOURCEIDSTRING( IDS_HEADER_IFLIST_CLUSTERIP),
                 LVCFMT_LEFT, 
                 colWidth);
    }

    //
    // Allow entire row to be selected.
    //
    interfaceList.SetExtendedStyle(
            interfaceList.GetExtendedStyle() | LVS_EX_FULLROWSELECT );
}


void
ConnectDialog::mfn_InsertBoundInterface(
        ENGINEHANDLE ehInterfaceId,
        LPCWSTR szClusterName,
        LPCWSTR szClusterIp,
        LPCWSTR szInterfaceName
        )
{
    if (szClusterName == NULL)
    {
        szClusterName = L"";
    }
    if (szClusterIp == NULL)
    {
        szClusterIp = L"";
    }
    if (szInterfaceName == NULL)
    {
        szInterfaceName = L""; // TODO: localize
    }
    int iRet = interfaceList.InsertItem(
                 LVIF_TEXT | LVIF_PARAM, // nMask
                 0, // nItem,
                 szClusterName, // lpszItem
                 0, // nState   (unused)
                 0, // nStateMask (unused)
                 0, // nImage (unused)
                 (LPARAM) ehInterfaceId //  lParam
                 );
    // interfaceList.InsertItem(0, szClusterName);
    interfaceList.SetItem(
             0, // nItem
             1,// nSubItem
             LVIF_TEXT, // nMask
             szClusterIp, // lpszItem
             0,        // nImage
             0,        // nState
             0,        // nStateMask
             0        // lParam
             );
    interfaceList.SetItem(
             0, // nItem
             2,// nSubItem
             LVIF_TEXT, // nMask
             szInterfaceName, // lpszItem
             0,        // nImage
             0,        // nState
             0,        // nStateMask
             0        // lParam
             );
    
}

void
ConnectDialog::mfn_InsertInterface(
        ENGINEHANDLE ehInterfaceId,
        LPCWSTR szInterfaceIp,
        LPCWSTR szInterfaceName,
        LPCWSTR szClusterIp
        )
{
    if (szInterfaceIp == NULL)
    {
        szInterfaceIp = L"";
    }
    if (szInterfaceName == NULL)
    {
        szInterfaceName = L""; // TODO: localize
    }
    if (szClusterIp == NULL)
    {
        szClusterIp = L"";
    }

    int iRet = interfaceList.InsertItem(
             LVIF_TEXT | LVIF_PARAM, // nMask
             0, // nItem,
             szInterfaceName, // lpszItem
             0, // nState   (unused)
             0, // nStateMask (unused)
             0, // nImage (unused)
             (LPARAM) ehInterfaceId //  lParam
             );
    // interfaceList.InsertItem(0, szInterfaceIp);
    interfaceList.SetItem(
             0, // nItem
             1,// nSubItem
             LVIF_TEXT, // nMask
             szInterfaceIp, // lpszItem
             0,        // nImage
             0,        // nState
             0,        // nStateMask
             0        // lParam
             );
    // interfaceList.InsertItem(0, szInterfaceIp);
    interfaceList.SetItem(
             0, // nItem
             2,// nSubItem
             LVIF_TEXT, // nMask
             szClusterIp, // lpszItem
             0,        // nImage
             0,        // nState
             0,        // nStateMask
             0        // lParam
             );
    // interfaceList.SetCurSel( 0 );
    
}

void ConnectDialog::OnOK()
{
	// CDialog::OnOK();
	CPropertyPage::OnOK();
}

_bstr_t g_hostName;

void ConnectDialog::OnButtonConnect() 
/*
    User has clicked the "Connect" button.

    1. (For now) If empty string, do nothing. Later we'll disable/enable.
    2. Switch cursor to hourglass, connect, switch back from hourglass.
*/
{
    BOOL fExisting = (m_type == DLGTYPE_EXISTING_CLUSTER);
    BOOL fRet;
    #define MAX_HOST_ADDRESS_LENGTH 256
    WCHAR szHostAddress[MAX_HOST_ADDRESS_LENGTH+1];
    ENGINEHANDLE ehHostId;
    CHostSpec hSpec;
    BOOL fNicsAvailable = FALSE;
    NLBERROR err;
    _bstr_t bstrUserName;
    _bstr_t bstrPassword;
    _bstr_t bstrConnectionStatus;

    //
    // Get the connection string. If empty, we simply return.
    //
    {
        fRet  = GetDlgItemText(
                        IDC_EDIT_HOSTADDRESS,
                        szHostAddress,
                        MAX_HOST_ADDRESS_LENGTH
                        );
        if (!fRet)
        {
            goto end;
        }

        //
        // Clean out trailing whitespace..
        //
        {
            LPWSTR sz = (szHostAddress+wcslen(szHostAddress))-1;

            while (sz >= szHostAddress)
            {
                WCHAR c = *sz;
                if (c == ' ' || c == '\t')
                {
                    *sz = 0;
                }
                else
                {
                    break;
                }
                sz--;
            }
        }

        if (szHostAddress[0] == 0)
        {
            goto end;
        }
    }

    //
    // Let's see if we have any record of this connection string -- if so
    // we use that record's username and password as the first guest.
    //
    err = gEngine.LookupConnectionInfo(
                szHostAddress,
                REF bstrUserName,
                REF bstrPassword
                );
    if (NLBFAILED(err))
    {
        //
        // Nope -- let's use default credentials...
        //
        m_pDocument->getDefaultCredentials(REF bstrUserName, REF bstrPassword);
    }
    //
    // Set status
    //
    {
        bstrConnectionStatus = GETRESOURCEIDSTRING(IDS_CONNECT_STATUS_CONNECTING);
        SetDlgItemText(IDC_TEXT_CONNECTION_STATUS, (LPCWSTR) bstrConnectionStatus);
    }

    //
    // Clear the list of interfaces.
    //
    interfaceList.DeleteAllItems();


    //
    // These two buffers must be defined outside the loop below because 
    // ConnInfo points to them across multiple iterations.
    // We initialize them to the user-name and password we obtained above...
    //
    WCHAR rgUserName[CREDUI_MAX_USERNAME_LENGTH+1];
    WCHAR rgPassword[MAX_ENCRYPTED_PASSWORD_LENGTH];
    LPCWSTR szName = (LPCWSTR) bstrUserName;
    LPCWSTR szPassword = (LPCWSTR) bstrPassword;
    if (szName == NULL)
    {
        szName = L"";
    }
    if (szPassword == NULL)
    {
        szPassword = L"";
    }
    ARRAYSTRCPY(rgUserName, szName);
    ARRAYSTRCPY(rgPassword, szPassword);

    while (1)
    {
        WMI_CONNECTION_INFO ConnInfo;
        CLocalLogger logger;

        ZeroMemory(&ConnInfo, sizeof(ConnInfo));
        ConnInfo.szMachine = szHostAddress;

        if (*rgUserName == 0)
        {
            // Use default creds ...
            ConnInfo.szUserName = NULL;
            ConnInfo.szPassword = NULL;
        }
        else
        {
            ConnInfo.szUserName = rgUserName;
            ConnInfo.szPassword = rgPassword;
        }

        //
        // ACTUALLY CONNECT TO THE HOST
        //
        BeginWaitCursor();

        // TRUE 2nd param says overwrite the connection info for this host
        // if the connect succeeds.
        err =  gEngine.ConnectToHost(&ConnInfo, TRUE, REF  ehHostId, REF bstrConnectionStatus);
        EndWaitCursor();

        if (err != NLBERR_ACCESS_DENIED)
        {
            break;
        }

        //
        // We got an access-denied -- 
        // Bring ui UI prompting for new username and password.
        //
        _bstr_t bstrCaption = GETRESOURCEIDSTRING(IDS_CONNECT_UNABLE_TO_CONNECT);
        logger.Log(IDS_SPECIFY_MACHINE_CREDS, ConnInfo.szMachine);

        fRet = PromptForEncryptedCreds(
                    m_hWnd,
                    (LPCWSTR) bstrCaption,
                    logger.GetStringSafe(),
                    rgUserName,
                    ASIZE(rgUserName),
                    rgPassword,
                    ASIZE(rgPassword)
                    );
        if (!fRet)
        {
            err = NLBERR_CANCELLED;
            break;
        }
    
    } // while (1)

    if (err == NLBERR_OK)
    {
        //
        // Set status
        //
        bstrConnectionStatus = GETRESOURCEIDSTRING(IDS_CONNECT_STATUS_CONNECTED);
        SetDlgItemText(IDC_TEXT_CONNECTION_STATUS, (LPCWSTR) bstrConnectionStatus);

        //
        // Clear list of all items
        //
        interfaceList.DeleteAllItems();

        err = gEngine.GetHostSpec(ehHostId, REF hSpec);
        if (NLBFAILED(err))
        {
            goto end;
        }

        //
        // Extract list of interfaces
        //
        for( int i = 0; i < hSpec.m_ehInterfaceIdList.size(); ++i )
        {
            ENGINEHANDLE ehIID = hSpec.m_ehInterfaceIdList[i];
            CInterfaceSpec iSpec;

            err = gEngine.GetInterfaceSpec(ehIID, REF iSpec);
            if (err == NLBERR_OK)
            {
                //
                // Get interfaces.
                //
                // szFriendlyName
                // szClusterIp (NULL if nlb not bound)
                // szClusterName (NULL if nlb not bound)
                // szFirstIp (first ip bound to NLB)
                //
                WBEMSTATUS wStat;
                LPWSTR szFriendlyName = NULL;
                LPWSTR szClusterIp = NULL;
                LPWSTR szClusterName = NULL;
                LPWSTR *pszNetworkAddresses = NULL;
                BOOL   fNlbBound = FALSE;
                UINT   NumAddresses=0;
                LPWSTR  szFirstNetworkAddress = NULL;

                wStat = iSpec.m_NlbCfg.GetFriendlyName(&szFriendlyName);
                if (FAILED(wStat)) szFriendlyName = NULL;

                wStat = iSpec.m_NlbCfg.GetNetworkAddresses(
                            &pszNetworkAddresses,
                            &NumAddresses
                            );

                if (FAILED(wStat))
                {
                    pszNetworkAddresses = NULL;
                    NumAddresses = 0;
                }
                else if (NumAddresses != 0)
                {
                    szFirstNetworkAddress = pszNetworkAddresses[0];
                    zap_slash(szFirstNetworkAddress); // zap the /
                }

                if (iSpec.m_NlbCfg.IsNlbBound())
                {
                    fNlbBound = TRUE;
                    if (iSpec.m_NlbCfg.IsValidNlbConfig())
                    {
                        wStat = iSpec.m_NlbCfg.GetClusterNetworkAddress(
                                    &szClusterIp
                                    );
                        if (FAILED(wStat))
                        {
                            szClusterIp = NULL;
                        }
                        else if (szClusterIp!=NULL)
                        {
                            zap_slash(szClusterIp);
                        }
                        wStat = iSpec.m_NlbCfg.GetClusterName(
                                    &szClusterName
                                    );
                        if (FAILED(wStat))
                        {
                            szClusterName = NULL;
                        }
                    }
                }

                if (fExisting && fNlbBound)
                {
                    fNicsAvailable = TRUE;
                    mfn_InsertBoundInterface(
                            ehIID,
                            szClusterName,
                            szClusterIp,
                            szFriendlyName
                            );
                }
                else if (!fExisting)
                {
                    fNicsAvailable = TRUE;
                    mfn_InsertInterface(
                            ehIID,
                            szFirstNetworkAddress,
                            szFriendlyName,
                            szClusterIp
                            );
                }
                delete szFriendlyName;
                delete szClusterIp;
                delete szClusterName;
                delete pszNetworkAddresses;
            }
        }
        
        if (!fNicsAvailable)
        {
            //
            // There are no NICs on this host on which NLB may be installed.
            //
            if (fExisting)
            {
                MessageBox(
                     GETRESOURCEIDSTRING( IDS_CONNECT_NO_NICS_EXISTING_CLUSTER),
                     GETRESOURCEIDSTRING( IDS_CONNECT_SELECT_NICS_ERROR ),
                     MB_ICONSTOP | MB_OK
                     );
            }
            else
            {
                MessageBox(
                     GETRESOURCEIDSTRING( IDS_CONNECT_NO_NICS_NEW_CLUSTER ),
                     GETRESOURCEIDSTRING( IDS_CONNECT_SELECT_NICS_ERROR ),
                     MB_ICONSTOP | MB_OK
                     );
            }
    
        }
        else
        {
            m_ehHostId = ehHostId;
            m_MachineName =  hSpec.m_MachineName; // machine name.
            m_fInterfaceSelected = FALSE;
            m_iInterfaceListItem = 0;
            *m_pehSelectedInterfaceId = NULL;
            m_fSelectedInterfaceIsInCluster = FALSE;


            if (fExisting)
            {
                //
                // We're asked to pick an existing cluster.
                // Let's select the first interface bound to NLB
                //
                mfn_SelectInterfaceIfAlreadyInCluster(
                        NULL
                        );
            }
            else
            {
                //
                // We're asked to add a host to a cluster.
                //
                // Now we check if an interfaces is already part of 
                // the cluster. If so we select it and prevent the user from
                // subsequently changing this selection. Furthermore, we use
                // the host-specific settings that already exist on that
                // interface.
                //
                mfn_SelectInterfaceIfAlreadyInCluster(
                        m_pNlbCfg->NlbParams.cl_ip_addr
                        );

                //                            
                // Let's apply the selected interface's information.
                //
                mfn_ApplySelectedInterfaceConfiguration();
            }
        }
    }
    else
    {
        //
        // Error connecting.
        //
        LPCWSTR szErr = (LPCWSTR)bstrConnectionStatus;
        if (szErr == NULL)
        {
            szErr = L"";
        }

        SetDlgItemText(IDC_TEXT_CONNECTION_STATUS, szErr);
    }

end:

    return;
}


void ConnectDialog::OnSelchanged(NMHDR * pNotifyStruct, LRESULT * result )
/*
    A listbox item has been selected.
*/
{
    POSITION pos = interfaceList.GetFirstSelectedItemPosition();
    UINT     WizardFlags = 0;
    int index = -1;
    if( pos != NULL )
    {
        index = interfaceList.GetNextSelectedItem( pos );
    }

    if (m_type == DLGTYPE_NEW_CLUSTER)
    {
        //
        // We're not the first, so we enable the back button.
        //
        WizardFlags = PSWIZB_BACK;
    }


    if (m_fInterfaceSelected && index == m_iInterfaceListItem)
    {
        //
        // No change in selection; Nothing to do..
        // In fact we do NOT want to change the settings because the user
        // may have made some host-specific changes like change the
        // dedicated IP.
        //
        goto end;
    }

    if (m_fSelectedInterfaceIsInCluster)
    {
        BOOL fRet = FALSE;
        //
        // we don't allow a change in selection -- move back to
        // selecting the cluster ip.
        fRet = interfaceList.SetItemState(
                 m_iInterfaceListItem,
                 LVIS_FOCUSED | LVIS_SELECTED, // nState
                 LVIS_FOCUSED | LVIS_SELECTED // nMask
                 );

        if (fRet)
        {
            goto end;
        }
    }

    //
    // We are getting here ONLY if (a) there has been a change in the selection
    // and (b) the selected interface is NOT already in the cluster.
    // We'll set the dedicated ip and subnet mask to be the first
    // address/subnet bound to the adapter.
    //
    // If  adapter is configured for DHCP, we leave the dedicated IP field
    // blank.
    //

    if (index != -1)
    {

        //
        // Update m_pNlbCfg appropriately...
        //
        ENGINEHANDLE ehIID = NULL;

        ehIID = (ENGINEHANDLE) interfaceList.GetItemData(index);

        if (ehIID == NULL)
        {
            TRACE_CRIT("%!FUNC! could not get ehIID for index %lu", index);
            goto end;
        }
        else
        {
            //
            // Update the saved-away "selected interface" ID.
            //
            ENGINEHANDLE ehOldId = *m_pehSelectedInterfaceId;
            *m_pehSelectedInterfaceId = ehIID;
            m_fInterfaceSelected = TRUE;
            m_iInterfaceListItem = index;


            //
            // TODO: duplicate code
            //
            CInterfaceSpec iSpec;
            WBEMSTATUS wStat;
            LPWSTR szFriendlyName = NULL;
            LPWSTR szClusterIp = NULL;
            LPWSTR szClusterName = NULL;
            LPWSTR *pszNetworkAddresses = NULL;
            UINT   NumAddresses=0;
            LPWSTR  szFirstNetworkAddress = NULL;
            NLBERROR  err;

            err = gEngine.GetInterfaceSpec(ehIID, REF iSpec);
            if (!NLBOK(err))
            {
                TRACE_CRIT("%!FUNC! could not get iSpec for ehSpec 0x%lx", ehIID);
                goto end;
            }

            wStat = iSpec.m_NlbCfg.GetFriendlyName(&szFriendlyName);
            if (FAILED(wStat)) szFriendlyName = NULL;

            wStat = iSpec.m_NlbCfg.GetNetworkAddresses(
                        &pszNetworkAddresses,
                        &NumAddresses
                        );

            if (FAILED(wStat))
            {
                pszNetworkAddresses = NULL;
                NumAddresses = 0;
            }
            else if (NumAddresses != 0)
            {
                szFirstNetworkAddress = pszNetworkAddresses[0];
            }

            m_pNlbCfg->SetFriendlyName(szFriendlyName);

            if (iSpec.m_NlbCfg.IsNlbBound())
            {
                if (m_type != DLGTYPE_EXISTING_CLUSTER)
                {
                    //
                    // The user has selected an interface that is bound with
                    // some other IP address -- we should put up a message box
                    // here or maybe later, on kill-active.
                    //
                }
            }

            //
            // Set defaults for dedicatedip -- the first network address on
            // the NIC, but ONLY if this address is not a cluster IP address.
            //
            if (szFirstNetworkAddress != NULL)
            {
                LPCWSTR szAddress = szFirstNetworkAddress;

                WCHAR rgIp[WLBS_MAX_CL_IP_ADDR+1];
                LPCWSTR pSlash = wcsrchr(szAddress, (int) '/');

                if (pSlash != NULL)
                {
                    UINT len = (UINT) (pSlash - szAddress);
                    if (len < WLBS_MAX_CL_IP_ADDR)
                    {
                        CopyMemory(rgIp, szAddress, len*sizeof(WCHAR));
                        rgIp[len] = 0;
                        szAddress = rgIp;
                    }
                }

                if (!_wcsicmp(m_pNlbCfg->NlbParams.cl_ip_addr, szAddress))
                {
                    szFirstNetworkAddress = NULL;
                }

                if (iSpec.m_NlbCfg.fDHCP)
                {
                    //
                    // The adapter is currently under DHCP control. We don't
                    // want to suggest that we use the current IP address
                    // as the static DIP!
                    //
                    szFirstNetworkAddress = NULL;
                }

                //
                // TODO -- check also if this address conflicts with the
                // additional VIPS.
                //
            }
            m_pNlbCfg->SetDedicatedNetworkAddress(szFirstNetworkAddress); // NULL ok

            delete szFriendlyName;
            delete szClusterIp;
            delete szClusterName;
            delete pszNetworkAddresses;
        }

        if (m_type == DLGTYPE_EXISTING_CLUSTER)
        {
            // we're last page, so enable finish.
            WizardFlags |= PSWIZB_FINISH;
        }
        else
        {
            // we're not the last page, so enable next.
            WizardFlags |= PSWIZB_NEXT;
        }
    }

    m_pshOwner->SetWizardButtons(WizardFlags);

end:

    return;
}

BOOL
ConnectDialog::OnSetActive()
{
    BOOL fRet =  CPropertyPage::OnSetActive();

    if (fRet)
    {
        UINT    WizardFlags = 0;

        if (m_type == DLGTYPE_NEW_CLUSTER)
        {
           WizardFlags |= PSWIZB_BACK; // we're not the first page.
        }

        if (m_fInterfaceSelected)
        {
           WizardFlags |= PSWIZB_NEXT; // Ok to continue.
        }

        m_pshOwner->SetWizardButtons(WizardFlags);
    }
    return fRet;
}


LRESULT ConnectDialog::OnWizardNext()
{
    LRESULT lRet = 0;

    TRACE_INFO("%!FUNC! ->");

    lRet = CPropertyPage::OnWizardNext();

    if (lRet != 0)
    {
        goto end;
    }

    if (mfn_ValidateData())
    {
       lRet = 0;
    }
    else
    {
        lRet = -1; // validation failed -- stay in current page.
    }

end:

    TRACE_INFO("%!FUNC! <- returns %lu", lRet);
    return lRet;
}


void ConnectDialog::OnUpdateEditHostAddress()
{
    //
    // This gets called when the user has made changes to the connect-to-host
    // edit control.
    //

    //
    // We get the latest text -- if null or just blanks, we
    // disable the connect window.
    // Else we enable the connect window.
    //
    #define BUF_SIZ 32
    WCHAR rgBuf[BUF_SIZ+1];
    int l = hostAddress.GetWindowText(rgBuf, BUF_SIZ);

    if (l == 0 || _wcsspnp(rgBuf, L" \t")==NULL)
    {
        //
        // Empty string or entirely whitespace.
        //
        ::EnableWindow (GetDlgItem(IDC_BUTTON_CONNECT)->m_hWnd, FALSE);
    }
    else
    {
        //
        // Non-empty string -- enable button and make it the default.
        //
        ::EnableWindow (GetDlgItem(IDC_BUTTON_CONNECT)->m_hWnd, TRUE);
        this->SetDefID(IDC_BUTTON_CONNECT);
    }


}

void
ConnectDialog::mfn_SelectInterfaceIfAlreadyInCluster(LPCWSTR szClusterIp)
/*
    Check the list of interfaces to see if there exists an interface
    which is is already part of the cluster -- i.e., it is bound and it's
    cluster ip matches the one in m_pNlbCfg.

    If so, we select it, and furthermore, prevent the user from selecting
    any other interface.
    
*/
{
    ENGINEHANDLE ehInterfaceId = NULL;
    NLBERROR nerr;
    UINT NumFound = 0;
    nerr = gEngine.FindInterfaceOnHostByClusterIp(
                        m_ehHostId,
                        //m_pNlbCfg->NlbParams.cl_ip_addr,
                        szClusterIp,
                        REF ehInterfaceId,
                        REF NumFound
                        );
    if (!NLBOK(nerr))
    {
        // not found or bad host id or some other err -- we don't care which.
        goto end;
    }

    //
    // Find the list item with this ehInterfaceId.
    //
    {
        LVFINDINFO Info;
        int nItem;
        ZeroMemory(&Info, sizeof(Info));
        Info.flags = LVFI_PARAM;
        Info.lParam = ehInterfaceId;

        nItem = interfaceList.FindItem(&Info);

        if (nItem != -1)
        {
            BOOL    fRet;
            UINT    WizardFlags = 0;

            //
            // Found it! -- select it and use it's host-specific information
            //
            m_fInterfaceSelected = TRUE;
            m_iInterfaceListItem = nItem;
            *m_pehSelectedInterfaceId = ehInterfaceId;
            if (NumFound == 1)
            {
                m_fSelectedInterfaceIsInCluster = TRUE;
            }
            fRet = interfaceList.SetItemState(
                     nItem,
                     LVIS_FOCUSED | LVIS_SELECTED, // nState
                     LVIS_FOCUSED | LVIS_SELECTED // nMask
                     );

            if (m_type == DLGTYPE_NEW_CLUSTER)
            {
               WizardFlags |= PSWIZB_BACK; // we're not the first page.
            }

            if (m_type == DLGTYPE_EXISTING_CLUSTER)
            {
                WizardFlags |= PSWIZB_FINISH;
            }
            else
            {
                WizardFlags |= PSWIZB_NEXT;
            }
            // TODO: consider adding finish in add-host case here.

            m_pshOwner->SetWizardButtons(WizardFlags);

        }
    }


    //
    // Go through and set all other list items to have a gray background.
    //

end:

    return;
}

void
ConnectDialog::mfn_ApplySelectedInterfaceConfiguration(void)
{
    ENGINEHANDLE ehIID = *m_pehSelectedInterfaceId;
    CInterfaceSpec iSpec;
    WBEMSTATUS wStat;
    BOOL   fNlbBound = FALSE;
    NLBERROR err;
    NLB_EXTENDED_CLUSTER_CONFIGURATION TmpConfig;

    if (!m_fSelectedInterfaceIsInCluster) goto end;

    err = gEngine.GetInterfaceSpec(ehIID, REF iSpec);
    if (!NLBOK(err))
    {
        TRACE_CRIT("%!FUNC! could not get iSpec for ehSpec 0x%lx", ehIID);
        goto end;
    }

    if (!iSpec.m_NlbCfg.IsValidNlbConfig())
    {
        // can't trust NLB config info on this interface.
        goto end;
    }

    //
    // We'll make a copy of the interface's config and apply the cluster
    // properties to it and then copy this copy over to the cluster properties.
    //
   wStat = TmpConfig.Update(&iSpec.m_NlbCfg);
   if (FAILED(wStat))
   {
        TRACE_CRIT("%!FUNC! could not perform an internal copy!");
        goto end;
   }

   err = gEngine.ApplyClusterWideConfiguration(REF *m_pNlbCfg, TmpConfig);
   if (!NLBOK(err))
   {
        goto end;
   }

   wStat = m_pNlbCfg->Update(&TmpConfig);

   if (FAILED(wStat))
   {
     goto end;
   }

    // Fall through.

end:
    return;
}

BOOL
ConnectDialog::mfn_ValidateData()
/*
    Make sure the interface is not already part of a different cluster,
    or other problem (eg we're connnecting to this interface and it's DHCP)

    NewCluster: 
    ExistingCluster: 
    AddHost: 
    
    In all cases, we fail if pISpec already has an ehCluster associated with
    it. Put up a message box with the associated ehCluster.
*/
{

    BOOL fRet = FALSE;
    NLBERROR nerr;
    ENGINEHANDLE   ehHost = NULL;
    ENGINEHANDLE   ehCluster = NULL;
    _bstr_t         bstrFriendlyName;
    _bstr_t         bstrDisplayName;
    _bstr_t         bstrHostName;
    LPCWSTR         szFriendlyName = NULL;
    BOOL            fOkCancel=FALSE;
    CLocalLogger    msgLog;
    _bstr_t         bstrCaption;

    if (*m_pehSelectedInterfaceId == NULL)
    {
        
        //
        // We shouldn't get here because the "Next" button is only enabled
        // if there IS a selection; however we deal with this case anyway.
        //
        // bstrCaption = L"No interface selected";
        bstrCaption = GETRESOURCEIDSTRING (IDS_CONNECT_NO_INTERFACE_SELECTED);
        msgLog.Log(IDS_CONNECT_SELECT_AN_INTERFACE);
        goto end;
    }

    nerr =  gEngine.GetInterfaceIdentification(
                    *m_pehSelectedInterfaceId,
                    REF ehHost,
                    REF ehCluster,
                    REF bstrFriendlyName,
                    REF bstrDisplayName,
                    REF bstrHostName
                    );

    if (NLBFAILED(nerr))
    {
        //
        // This indicates an internal error like a bad handle.
        //
        bstrCaption = GETRESOURCEIDSTRING(IDS_CONNECT_UNABLE_TO_PROCEED);
        // szCaption = L"Unable to proceed";
        
        msgLog.Log(IDS_CONNECT_UNABLE_TO_PROCEEED_INTERNAL);
        // szMessage = L"Unable to proceed due to an internal error.";
        goto end;
    }

    szFriendlyName = (LPCWSTR) bstrFriendlyName;
    if (szFriendlyName == NULL)
    {
        szFriendlyName = L"";
    }

    if (ehCluster == NULL)
    {
        //
        // Should be good to go.
        // TODO -- if interface already bound AND m_type is NOT
        // DLGTYPE_EXISTING_CLUSTER, we should ask if user wants to
        // clobber the existing interface.
        //
        if (m_type != DLGTYPE_EXISTING_CLUSTER)
        {
            CInterfaceSpec iSpec;

            nerr = gEngine.GetInterfaceSpec(*m_pehSelectedInterfaceId, REF iSpec);
            if (nerr == NLBERR_OK)
            {

                //
                // Check if we're connected to this NIC, and
                // the NIC is DHCP, so we're not going to be able to
                // keep the connected IP address.
                //
                // If so, we cannot proceed.
                //
                {
                    ENGINEHANDLE   ehConnectionIF   = NULL;
                    _bstr_t        bstrConnectionString;
                    UINT           uConnectionIp   = 0;
    
                    nerr = gEngine.GetHostConnectionInformation(
                                ehHost,
                                REF ehConnectionIF,
                                REF bstrConnectionString,
                                REF uConnectionIp
                                );
                    if (NLBFAILED(nerr))
                    {
                        TRACE_CRIT(L"%!FUNC! gEngine.GetHostConnectionInformation fails!");
                        //
                        // We'll plow on...
                        //
                        ehConnectionIF = NULL;
                        uConnectionIp = 0;
                    }

                    if (ehConnectionIF == *m_pehSelectedInterfaceId)
                    {
                        //
                        // The selected interface is also the interface that we
                        // are connecting over...
                        //
            
                        if (iSpec.m_NlbCfg.fDHCP)
                        {
                            //
                            // Ouch -- it's also DHCP. We can't allow this...
                            //
                            msgLog.Log(IDS_CANT_USE_DHCP_NIC_MSG);
                            bstrCaption = GETRESOURCEIDSTRING(IDS_CONNECT_UNABLE_TO_PROCEED);
                            fRet = FALSE;
                            goto end;
                        }
                    }
                }


                //
                // Check if nlb is bound and if so, if it's cluster ip address
                // is different.
                //
                if (iSpec.m_NlbCfg.IsValidNlbConfig())
                {
                    //
                    // Hmm... interface is already bound to NLB.
                    // Let's see if the cluster IP address is different...
                    //
                    LPCWSTR szClusterIp = m_pNlbCfg->NlbParams.cl_ip_addr;
                    LPCWSTR szIfClusterIp = iSpec.m_NlbCfg.NlbParams.cl_ip_addr;
                    if (    szIfClusterIp[0]!=0
                         && (_wcsspnp(szIfClusterIp, L".0")!=NULL))
                    {
                        // non-blank cluster Ip address
                        if (wcscmp(szClusterIp, szIfClusterIp))
                        {
                            //
                            // IPs don't match! Put up message box..
                            //
                            msgLog.Log(
                                IDS_CONNECT_MSG_IF_ALREADY_BOUND,
                                szFriendlyName,
                                iSpec.m_NlbCfg.NlbParams.domain_name,
                                szIfClusterIp
                                );
                            bstrCaption = GETRESOURCEIDSTRING(IDS_CONNECT_CAP_IF_ALREADY_BOUND);
                            // szCaption = L"Interface already configured for NLB";
            
                            fOkCancel=TRUE;
                            fRet = FALSE;
                            goto end;
                        }
                    }
                }
            }
        }

        fRet = TRUE;
    }
    else
    {
        _bstr_t bstrClusterDescription;
        _bstr_t bstrIpAddress;
        _bstr_t bstrDomainName;
        LPCWSTR szClusterDescription = NULL;

        nerr  = gEngine.GetClusterIdentification(
                    ehCluster,
                    REF bstrIpAddress, 
                    REF bstrDomainName, 
                    REF bstrDisplayName
                    );

        if (FAILED(nerr))
        {
            TRACE_CRIT(L"%!FUNC!: Error 0x%lx getting ehCluster 0x%lx identification\n",
                nerr, ehCluster);
            bstrCaption = GETRESOURCEIDSTRING(IDS_CONNECT_UNABLE_TO_PROCEED);
            // szCaption = L"Unable to proceed";
            
            msgLog.Log(IDS_CONNECT_UNABLE_TO_PROCEEED_INTERNAL);
            // szMessage = L"Unable to proceed due to an internal error.";
            goto end;
        }
        szClusterDescription = bstrDisplayName;
        if (szClusterDescription==NULL)
        {
            szClusterDescription = L"";
        }


        //
        // We won't allow proceeding in this case, because this indicates that
        // this interface is already part of a cluster managed by NLB Manger.
        //
        msgLog.Log(
            IDS_CONNECT_MSG_INTERFACE_ALREADY_MANAGED,
            szFriendlyName,
            szClusterDescription
            );
        bstrCaption = GETRESOURCEIDSTRING(IDS_CONNECT_UNABLE_TO_PROCEED);

    }

end:

    if (!fRet)
    {
        LPCWSTR         szCaption = (LPCWSTR) bstrCaption;
        LPCWSTR         szMessage = msgLog.GetStringSafe();

        if (fOkCancel)
        {                                    

            int i =  MessageBox( szMessage, szCaption, MB_OKCANCEL);
            if (i == IDOK)
            {
                fRet = TRUE;
            }
        }
        else
        {
                MessageBox( szMessage, szCaption, MB_ICONSTOP | MB_OK);
        }
    }

    return fRet;
}

BOOL g_Silent = FALSE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\document.cpp ===
//***************************************************************************
//
//  DOCUMENT.CPP
// 
//  Module: NLB Manager
//
//  Purpose: Implements the document class for nlb manager.
//
//  Copyright (c)2001-2002 Microsoft Corporation, All Rights Reserved
//
//  History:
//
//  07/30/01    JosephJ Created based on MHakim's code
//
//***************************************************************************
#include "precomp.h"
#pragma hdrstop
#include "private.h"
#include "document.tmh"
#include "wchar.h"
#include "share.h"

IMPLEMENT_DYNCREATE( Document, CDocument )

CNlbEngine gEngine;
CNlbMgrCommandLineInfo gCmdLineInfo;

#define MAX_LOG_FILE_SIZE 10000000L // 10MB
#define BOM 0xFEFF // The first two bytes of a Unicode file must be this BOM. It is a hint to applications that the file is Unicode-enabled in little endian format.

Document::Document()
:
    m_pLeftView(NULL),
    m_pDetailsView(NULL),
    m_pLogView(NULL),
    m_pNlbEngine(NULL),
    m_dwLoggingEnabled(NULL),
    m_hStatusLog(NULL),
    m_fPrepareToDeinitialize(FALSE)
{
    TRACE_INFO("->%!FUNC!");

    *m_szLogFileName = 0;

    //
    // load the images which are used.
    //

    m_images48x48 = new CImageList;

    m_images48x48->Create( 16,            // x
                           16,            // y
                           ILC_COLOR16,   // 16 bit color
                           0,             // initially image list is empty
                           10 );          // max images is 10.  This value arbitrary.

    // Add the icons which we are going to use.
    // WARNING: these are added according to the order specified
    // in the Document::ICON_XXX enum
    //
     
    m_images48x48->Add( AfxGetApp()->LoadIcon( IDI_CLUSTERS));         // 1
    m_images48x48->Add( AfxGetApp()->LoadIcon( IDI_CLUSTER));       // 2

    m_images48x48->Add( AfxGetApp()->LoadIcon( IDI_HOST_STARTED));  // 3
    m_images48x48->Add( AfxGetApp()->LoadIcon( IDI_HOST_STOPPED));  // 4
    m_images48x48->Add( AfxGetApp()->LoadIcon( IDI_HOST_CONVERGING));
    m_images48x48->Add( AfxGetApp()->LoadIcon( IDI_HOST_SUSPENDED));
    m_images48x48->Add( AfxGetApp()->LoadIcon( IDI_HOST_DRAINING));
    m_images48x48->Add( AfxGetApp()->LoadIcon( IDI_HOST_DISCONNECTED));

    m_images48x48->Add( AfxGetApp()->LoadIcon( IDI_PORTRULE) );     // 5
    m_images48x48->Add( AfxGetApp()->LoadIcon( IDI_PENDING ));      // 6

    m_images48x48->Add( AfxGetApp()->LoadIcon( IDI_MYINFORMATIONAL ));// 7
    m_images48x48->Add( AfxGetApp()->LoadIcon( IDI_MYWARNING ));      // 8
    m_images48x48->Add( AfxGetApp()->LoadIcon( IDI_MYERROR ));        // 9

    m_images48x48->Add( AfxGetApp()->LoadIcon( IDI_CLUSTER_OK ));     // 10
    m_images48x48->Add( AfxGetApp()->LoadIcon( IDI_CLUSTER_PENDING ));// 11
    m_images48x48->Add( AfxGetApp()->LoadIcon( IDI_CLUSTER_BROKEN )); // 12
    m_images48x48->Add( AfxGetApp()->LoadIcon( IDI_HOST_OK ));        // 13
    m_images48x48->Add( AfxGetApp()->LoadIcon( IDI_HOST_PENDING ));   // 14
    m_images48x48->Add( AfxGetApp()->LoadIcon( IDI_HOST_MISCONFIGURED ));// 15
    m_images48x48->Add( AfxGetApp()->LoadIcon( IDI_HOST_UNREACHABLE ));// 16
    m_images48x48->Add( AfxGetApp()->LoadIcon( IDI_HOST_UNKNOWN ));   // 17


    //
    // Initialize the NLB Engine.
    //
    // NOTE: "this", of type Document, inherits from NlbEngine::IUICallbacks,
    // so it is the IUICallbacks interface that gets passed into
    // gEngine.Initialize below.
    //
    NLBERROR NlbErr = gEngine.Initialize(
                        REF *this,
                        gCmdLineInfo.m_bDemo,
                        gCmdLineInfo.m_bNoPing
                        );
    if (NlbErr != NLBERR_OK)
    {
        TRACE_CRIT("%!FUNC!: gEngine.Initialize failed with error %08lx",
                NlbErr);
        //TODO: displayNlbError(ID_INITIALIZATION_FAILURE, NlbErr);
    }

    m_dwLoggingEnabled = 0;
    ZeroMemory(m_szLogFileName, MAXFILEPATHLEN*sizeof(WCHAR));
    m_hStatusLog = NULL;

    //
    // TODO: figure out what to do if we fail to initialize logging in the constructor!
    //
    // // 2/12/02 JosephJ SECURITY BUGBUG: need to inform user that they could not start logging.
    //
    initLogging();

    //
    // TODO: figure out how to DEinitialize!!!
    //

    TRACE_INFO("<-%!FUNC!");
}

Document::~Document()
{
    // Don't check return value since we are exiting
    stopLogging();
}

void
Document::registerLogView( LogView* logView )
{
    m_pLogView = logView;
}

void
Document::registerDetailsView( DetailsView* detailsView )
{
    m_pDetailsView = detailsView;
}


DWORD WINAPI FinalInitialize(PVOID pvContext)
//
// This is typically called in the context of a work item.
//
{
    TRACE_INFO(L"-> %!FUNC!");
    // Check whether to connect to hosts specified in a host-list file
    if (gCmdLineInfo.m_bHostList) 
    {
        ((Document *)(pvContext))->LoadHostsFromFile(gCmdLineInfo.m_bstrHostListFile);
    }
    TRACE_INFO(L"<- %!FUNC!");
    return 0;
}

void
Document::registerLeftView(LeftView *pLeftView)
{
    TRACE_INFO(L"-> %!FUNC!");
    m_pLeftView = pLeftView;

    // If there is a file containing the list of hosts to connect to,
    // read the file in a background thread. This is so that the UI 
    // can show up while the communication with the hosts can go on
    // in the bakground. If this is NOT done, the UI will not show up
    // until we have heard from all of the hosts listed in the file.
    // -KarthicN
    if(!QueueUserWorkItem(FinalInitialize, this, WT_EXECUTEDEFAULT))
    {
        TRACE_CRIT(L"%!FUNC! QueueUserWorkItem failed with error : 0x%x", GetLastError());
    }
    TRACE_INFO(L"<- %!FUNC!");
}

//
// Asks the user to update user-supplied info about a host.
//
BOOL
Document::UpdateHostInformation(
    IN BOOL fNeedCredentials,
    IN BOOL fNeedConnectionString,
    IN OUT CHostSpec& host
)
{
    return FALSE;
}



//
// Log a message in human-readable form.
//
void
Document::Log(
    IN LogEntryType Type,
    IN const wchar_t    *szCluster, OPTIONAL
    IN const wchar_t    *szHost, OPTIONAL
    IN UINT ResourceID,
    ...
)
{
    WCHAR wszBuffer[1024];
    CString FormatString;

    if (m_fPrepareToDeinitialize)
    {
        goto end;
    }

    if (!FormatString.LoadString(ResourceID))
    {
        StringCbPrintf(wszBuffer, sizeof(wszBuffer), L"BAD/UNKNOWN resource ID %d", ResourceID);
    }
    else
    {
        DWORD dwRet;
       va_list arglist;
       va_start (arglist, ResourceID);

       dwRet = FormatMessage(
                  FORMAT_MESSAGE_FROM_STRING,
                  (LPCWSTR) FormatString,
                  0, // Message Identifier - Ignored 
                  0, // Language Identifier
                  wszBuffer,
                  ASIZE(wszBuffer)-1, 
                  &arglist
                  );
        if (dwRet == 0)
        {
            TRACE_CRIT("%!FUNC!: FormatMessage failed.");
            wszBuffer[0]=0;
        }
        
       va_end (arglist);
    }

    if (m_pLogView)
    {
        LogEntryHeader Header;
        Header.type = Type;
        Header.szCluster = szCluster;
        Header.szHost = szHost;

        if (!theApplication.IsMainThread())
        {
            //
            //
            // Let's allocate a UI work item and post the item to the mainform
            // thread so that the mainform thread will handle it.
            //
            //
            CUIWorkItem *pWorkItem = new CUIWorkItem(
                                            &Header,
                                            wszBuffer
                                            );
            if (pWorkItem != NULL)
            {
                if (!mfn_DeferUIOperation(pWorkItem))
                {
                    delete pWorkItem;
                }
            }
            goto end;
        }

        m_pLogView->LogString(&Header, wszBuffer);
    }

end:

    return;
}

//
// Log a message in human-readable form.
//
void
Document::LogEx(
    IN const LogEntryHeader *pHeader,
    IN UINT ResourceID,
    ...
)
{
    WCHAR wszBuffer[1024];
    CString FormatString;

    if (m_fPrepareToDeinitialize)
    {
        goto end;
    }

    if (!FormatString.LoadString(ResourceID))
    {
        StringCbPrintf(wszBuffer, sizeof(wszBuffer), L"BAD/UNKNOWN resource ID %d", ResourceID);
    }
    else
    {
        DWORD dwRet;
       va_list arglist;
       va_start (arglist, ResourceID);

       dwRet = FormatMessage(
                  FORMAT_MESSAGE_FROM_STRING,
                  (LPCWSTR) FormatString,
                  0, // Message Identifier - Ignored 
                  0, // Language Identifier
                  wszBuffer,
                  ASIZE(wszBuffer)-1, 
                  &arglist
                  );
        if (dwRet == 0)
        {
            TRACE_CRIT("%!FUNC!: FormatMessage failed.");
            wszBuffer[0]=0;
        }

       va_end (arglist);
    }

    if (m_pLogView)
    {
        if (!theApplication.IsMainThread())
        {
            //
            //
            // Let's allocate a UI work item and post the item to the mainform
            // thread so that the mainform thread will handle it.
            //
            //
            CUIWorkItem *pWorkItem = new CUIWorkItem(
                                            pHeader,
                                            wszBuffer
                                            );
            if (pWorkItem != NULL)
            {
                if (!mfn_DeferUIOperation(pWorkItem))
                {
                    delete pWorkItem;
                }
            }
            goto end;
        }

        m_pLogView->LogString(pHeader, wszBuffer);
    }

end:

    return;
}


//
// Handle an event relating to a specific instance of a specific
// object type.
//
void
Document::HandleEngineEvent(
    IN ObjectType objtype,
    IN ENGINEHANDLE ehClusterId, // could be NULL
    IN ENGINEHANDLE ehObjId,
    IN EventCode evt
    )
{
    TRACE_INFO(
        L"%!FUNC!: cid=%lx; id=%lx; obj=%lu, evt=%lu",
        (UINT) ehClusterId,
        (UINT) ehObjId,
        (UINT) objtype,
        (UINT) evt
        );

    if (m_fPrepareToDeinitialize)
    {
        goto end;
    }

    if (!theApplication.IsMainThread())
    {
        // DummyAction(L"HandleEngineEvent -- deferring UI");
        //
        //
        // Let's allocate a UI work item and post the item to the mainform
        // thread so that the mainform thread will handle it.
        //
        //
        CUIWorkItem *pWorkItem = new CUIWorkItem(
                                        objtype,
                                        ehClusterId,
                                        ehObjId,
                                        evt
                                        );
        if (pWorkItem != NULL)
        {
            if (!mfn_DeferUIOperation(pWorkItem))
            {
                delete pWorkItem;
            }
        }

        goto end;
    }


    //
    // TODO: consider locking and reference-counting below.
    //

    if (m_pLeftView != NULL)
    {
        m_pLeftView->HandleEngineEvent(objtype, ehClusterId, ehObjId, evt);
    }
    if (m_pDetailsView != NULL)
    {
        m_pDetailsView->HandleEngineEvent(objtype, ehClusterId, ehObjId, evt);
    }

end:

    return;
}


//
// Handle a selection change notification from the left (tree) view
//
void
Document::HandleLeftViewSelChange(
        IN IUICallbacks::ObjectType objtype,
        IN ENGINEHANDLE ehObj
        )
{
    if (m_fPrepareToDeinitialize)
    {
        goto end;
    }

    if (m_pDetailsView != NULL)
    {
        m_pDetailsView->HandleLeftViewSelChange(objtype, ehObj);
    }

end:
    return;
}

//
// Read registry settings. If there are none, create defaults according to what is set in constructor.
//
Document::LOG_RESULT Document::initLogging()
{

    LOG_RESULT  lrResult = REG_IO_ERROR;
    LONG        status;
    HKEY        key;
    WCHAR       szKey[MAXSTRINGLEN];
    WCHAR       szError[MAXSTRINGLEN];
    DWORD       size;
    DWORD       type;

    key = NlbMgrRegCreateKey(NULL);

    if (key == NULL)
    {
        TRACE_CRIT(L"%!FUNC! registry key doesn't exist");
        return REG_IO_ERROR;
    }

    size = sizeof (m_dwLoggingEnabled);
    type = REG_DWORD;
    status = RegQueryValueEx(key, L"LoggingEnabled", 0L, &type,
                              (LPBYTE) &m_dwLoggingEnabled, &size);

    if (status == ERROR_FILE_NOT_FOUND)
    {
        //
        // Create the regkey and initialize to what is set in constructor
        //
        status = RegSetValueEx(key, L"LoggingEnabled", 0L, REG_DWORD, (LPBYTE) &m_dwLoggingEnabled, size);

        if (status != ERROR_SUCCESS)
        {
            lrResult = REG_IO_ERROR;
            TRACE_CRIT(L"%!FUNC! failed while creating the LoggingEnabled registry value");
            goto end;
        }

    }
    else if (status != ERROR_SUCCESS)
    {
            lrResult = REG_IO_ERROR;
            TRACE_CRIT(L"%!FUNC! failed while reading logging enabledLoggingEnabled registry value");
            goto end;
    }

    size = MAXFILEPATHLEN*sizeof(WCHAR);
    type = REG_SZ;
    status = RegQueryValueEx(key, L"LogFileName", 0L, &type,
                              (LPBYTE) &m_szLogFileName, &size);

    if (status == ERROR_FILE_NOT_FOUND)
    {
        //
        // Create the regkey and initialize to empty string
        //
        status = RegSetValueEx(key, L"LogFileName", 0L, REG_SZ, (LPBYTE) &m_szLogFileName, size);

        if (status != ERROR_SUCCESS)
        {
            TRACE_CRIT(L"%!FUNC! failed while creating LogFileName registry value");
            lrResult = REG_IO_ERROR;
            goto end;
        }
    }
    else if (status == ERROR_MORE_DATA)
    {

        TRACE_CRIT(L"%!FUNC! the log file name in the registry is longer than the maximum number of characters supported: %d. Logging will not be started.", MAXSTRINGLEN-1);
        goto end;
    }
    else if (status != ERROR_SUCCESS)
    {
        lrResult = REG_IO_ERROR;
        TRACE_CRIT(L"%!FUNC! failed while reading LogFileName registry value");
        goto end;
    }

    //
    // Validate the log file name
    //
    if (!isDirectoryValid(m_szLogFileName))
    {
        lrResult = FILE_PATH_INVALID;
        TRACE_CRIT(L"%!FUNC! LogFileName has an invalid file path \"%ws\"",
                m_szLogFileName);
        goto end;   
    }

    if(m_dwLoggingEnabled != 0)
    {
        if (m_szLogFileName[0] == L'\0')
        {
            TRACE_CRIT(L"%!FUNC! Logging is enabled but a log file name has not been specified. Logging will not be started.");
        }
        else
        {
            if (NULL == m_hStatusLog)
            {
                lrResult = startLogging();
            }
        }
    }

end:
    // Close handle to the registry
    RegCloseKey(key);

    return lrResult;
}

//
// Change settings in memory and registry to allow logging.
//
LONG Document::enableLogging()
{
    LONG    status = ERROR_INTERNAL_ERROR;
    DWORD   dwLoggingEnabled = 1;
    HKEY    key;

    key = NlbMgrRegCreateKey(NULL);

    if (key == NULL)
    {
        TRACE_CRIT(L"%!FUNC! registry key doesn't exist");
        status = ERROR_CANTOPEN;
        goto end;
    }

    status = RegSetValueEx(key, L"LoggingEnabled", 0L, REG_DWORD, (LPBYTE) &dwLoggingEnabled, sizeof(DWORD));

    //
    // Ignore return value since we can't do anything if this fails.
    //
    RegCloseKey(key);

end:

    if (ERROR_SUCCESS == status)
    {
        m_dwLoggingEnabled = dwLoggingEnabled;
    }

    TRACE_INFO(L"%!FUNC! returns status=%i", status);

    return status;
}

//
// Change settings in memory and registry to prevent logging.
//
LONG Document::disableLogging()
{
    LONG    status = ERROR_INTERNAL_ERROR;
    DWORD   dwLoggingEnabled = 0;
    HKEY    key;

    key = NlbMgrRegCreateKey(NULL);

    if (key == NULL)
    {
        TRACE_CRIT(L"%!FUNC! registry key doesn't exist");
        status = ERROR_CANTOPEN;
        goto end;
    }

    status = RegSetValueEx(key, L"LoggingEnabled", 0L, REG_DWORD, (LPBYTE) &dwLoggingEnabled, sizeof(DWORD));

    //
    // Ignore return value since we can't do anything if this fails.
    //
    RegCloseKey(key);

end:
    if (ERROR_SUCCESS == status)
    {
        m_dwLoggingEnabled = dwLoggingEnabled;
    }

    TRACE_INFO(L"%!FUNC! returns status=%i", status);
    return status;
}

//
// Log information sent to LogView to a file
//
Document::LOG_RESULT Document::startLogging()
{
    Document::LOG_RESULT lrResult = STARTED;

    if (m_fPrepareToDeinitialize)
    {
        goto end;
    }

    if(m_dwLoggingEnabled == 0)
    {
        lrResult = NOT_ENABLED;
        TRACE_INFO(L"%!FUNC! failed because logging is not enabled");
        goto end;
    }

    if (m_szLogFileName[0] == L'\0')
    {
        lrResult = NO_FILE_NAME;
        TRACE_INFO(L"%!FUNC! failed because there is no log file name");
        goto end;
    }

    if (NULL != m_hStatusLog)
    {
        //
        // If we have a file open, we assume it is the correct one and return true
        //
        lrResult = ALREADY;
        TRACE_INFO(L"%!FUNC! is already running");
        goto end;
    }

    {
        //
        // Determine whether the log file exists.
        //
        boolean fWriteBOM = false;
        {
            FILE *hTmpLog = _wfsopen(m_szLogFileName, L"r", _SH_DENYNO);

            if (NULL == hTmpLog)
            {
                DWORD dwError = GetLastError();
                if (dwError == ERROR_FILE_NOT_FOUND)
                {
                    //
                    // This is a new file. Set a flag so we can write the 2-byte BOM
                    // inside it to indicate the Unicode encoding. The write will be done
                    // when we open the file for appending below.
                    //
                    fWriteBOM = true;
                }
                else
                {
                    TRACE_CRIT(L"%!FUNC! failure %u while opening log file for read", dwError);
                    lrResult = IO_ERROR;
                    goto end;
                }
            }
            else
            {
                //
                // The uninteresting case where the log file already exists. Close the file and move on.
                //
                fclose(hTmpLog);
            }
        }

        //
        // This is the "real" file-open for logging
        //
        if (NULL == (m_hStatusLog = _wfsopen(m_szLogFileName, L"a+b", _SH_DENYWR)))
        {
            TRACE_CRIT(L"%!FUNC! failed to open log file");
            lrResult = IO_ERROR;
            goto end;
        }

        //
        // Write the BOM to indicate that this file is Unicode encoded, but only for a new log file.
        //
        if (fWriteBOM)
        {
            //
            // According to MSDN, a file opened for append will always write to the end of
            // the file, regardless of fseek and fsetpos calls. We need the BOM at BOF but
            // we are OK since we know this is a new file.
            //
            USHORT usBOM = (USHORT) BOM;
            int i = fwrite(
                       &usBOM,          // Pointer to a buffer to write to file
                       sizeof(usBOM),   // The size of an item in bytes
                       1,               // Max count (in units of 2nd arg) of items in buffer to write to the file
                       m_hStatusLog);   // Pointer to the file stream

            if (i != 1) // Number of units actually written to file
            {
                TRACE_CRIT(L"%!FUNC! failed while writing Unicode BOM to pFILE 0x%p",
                           m_hStatusLog);
                lrResult = IO_ERROR;
                (void) stopLogging();
                goto end;
            }
        }
    }

    //
    // Now check if the file has exceeded the limit.
    //
    {
        //
        // seek to the end (sdk says fseek (or a write) needs to happen
        // before a file opened with append reports the correct offset via
        // ftell.)
        //
        int i = fseek(m_hStatusLog, 0, SEEK_END);
        if (i != 0)
        {
            TRACE_CRIT(L"%!FUNC! failure %lu attempting to seek to end of pFILE 0x%p",
                        i, m_hStatusLog);
            lrResult = IO_ERROR;
            (void) stopLogging();
            goto end;
        }

    #if 0 // We won't fail now -- so that a subsequent write will create
          // an entry in the in-memory log.
        i = ftell(m_hStatusLog);
        if (i == -1L)
        {
            TRACE_CRIT(L"%!FUNC! failure %lu calling ftell(pFILE 0x%p)",
                        i, m_hStatusLog);
            lrResult = IO_ERROR;
            (void) stopLogging();
            goto end;
        }

        if (i >= MAX_LOG_FILE_SIZE)
        {
            TRACE_CRIT(L"%!FUNC! File size exceeded: %lu (limit=%lu)",
                        i, MAX_LOG_FILE_SIZE);
            lrResult = FILE_TOO_LARGE;
            (void) stopLogging();
            goto end;
        }
    #endif // 0
    }



end:

    return lrResult;
}

//
// Stop logging information sent to LogView to a file
//
bool Document::stopLogging()
{
    bool ret = true;

    if (NULL != m_hStatusLog)
    {
        if (0 == fclose(m_hStatusLog))
        {
            TRACE_INFO(L"%!FUNC! logging stopped");
            m_hStatusLog = NULL;
        }
        else {
            TRACE_CRIT(L"%!FUNC! failed to close log file");
            ret = false;
        }
    }
    else
    {
        TRACE_INFO(L"%!FUNC! logging already stopped");
    }

    return ret;
}

//
// Retrieve the cached log file name
//
void Document::getLogfileName(WCHAR* pszFileName, DWORD dwBufLen)
{
    wcsncat(pszFileName, m_szLogFileName, dwBufLen);
}

//
// Set the log file name in memory and registry. false = couldn't write file name to registry.
//
LONG Document::setLogfileName(WCHAR* pszFileName)
{
    LONG    status;
    HKEY    key;

    ZeroMemory(m_szLogFileName, MAXFILEPATHLEN*sizeof(WCHAR));

    if (NULL != pszFileName && pszFileName != L'\0')
    {
        //
        // Truncate the file name if it is larger than what we can store.
        // Buffer is already initialized so that the last WCHAR is NULL.
        //
        wcsncat(m_szLogFileName, pszFileName, MAXFILEPATHLEN-1);
    }

    //
    // Write file name to the registry
    //
    key = NlbMgrRegCreateKey(NULL);

    if (key == NULL)
    {
        TRACE_CRIT(L"%!FUNC! registry key doesn't exist");
        goto end;
    }

    status = RegSetValueEx(key, L"LogFileName", 0L, REG_SZ, (LPBYTE) &m_szLogFileName, MAXFILEPATHLEN*sizeof(WCHAR));

    //
    // Ignore return value since we can't do anything if this fails.
    //
    RegCloseKey(key);

end:

    TRACE_INFO(L"%!FUNC! returns status=%i", status);
    return status;
}

//
// Log and entry from LogView into the log file. Flush it immediately.
//
void Document::logStatus(WCHAR* pszStatus)
{
    if (m_fPrepareToDeinitialize)
    {
        goto end;
    }


    if (m_dwLoggingEnabled == 0 || NULL == m_hStatusLog || NULL == pszStatus)
    {
        goto end;
    }

    //
    // Check if the log is grown too large ...
    //
    {
        BOOL fStopLogging = FALSE;

        int i = ftell(m_hStatusLog);
        if (i == -1L)
        {
            TRACE_CRIT(L"%!FUNC! failure %lu calling ftell(pFILE 0x%p)",
                        i, m_hStatusLog);
            (void) stopLogging();
            goto end;
        }

        if (i >= MAX_LOG_FILE_SIZE)
        {
            CLocalLogger logDetails;
            LogEntryHeader Header;
            TRACE_CRIT(L"%!FUNC! File size exceeded: %lu (limit=%lu)",
                        i, MAX_LOG_FILE_SIZE);
            (void) stopLogging();

            //
            // WANING -- we're logging, so this will cause this function
            // (logStatus) to be reentered, however it will bail out early
            // because we've stopped logging.
            //
            logDetails.Log(
                IDS_LOGFILE_FILE_TOO_LARGE_DETAILS,
                m_szLogFileName,
                MAX_LOG_FILE_SIZE/1000
                );
            Header.type      = LOG_ERROR;
            Header.szDetails = logDetails.GetStringSafe();
            this->LogEx(
                &Header,
                IDS_LOGFILE_FILE_TOO_LARGE
                );
            goto end;
        }
    }

    //
    // Now actually log.
    //
    {
        TRACE_INFO(L"%!FUNC! logging: %ls", pszStatus);

        PWCHAR pc = pszStatus;
        while (*pc != NULL)
        {
            if (*pc == '\n')
            {
                //
                // TODO: fputwc could fail with WEOF...
                //
                fputwc('\r', m_hStatusLog);
            }
            fputwc(*pc, m_hStatusLog);

            pc++;
        }

        fflush(m_hStatusLog);
    }

end:
    return;
}

//
// Check if the specified directory exists
//
// This function supports strings of the following format:
//      c:\myfile.log
//      c:myfile.log
//      c:\mydir1\mydir2\...\mydirN\myfile.log
// The requirement is that the destination directory must exist and is not a file.
// IOW, if c:\mydir1\mydir2 is a file, this function will fail the validity test
// if the input file name is c:\mydir1\mydir2\myfile.log
//
bool Document::isDirectoryValid(WCHAR* pwszFileName)
{
    bool fRet = false;

    WCHAR   pwszFullPath[_MAX_PATH + 1];

    ASSERT(pwszFileName != NULL);

    TRACE_INFO(L"-> Path = '%ls'", pwszFileName);

    //
    // Convert the input file name into a full path name (in case we are given a relative path)
    //
    if (_wfullpath(pwszFullPath, pwszFileName, _MAX_PATH) == NULL)
    {
        TRACE_CRIT(L"_wfullpath failed converting '%ls' to a full path. Name could be too long or could specify an invalid drive letter", pwszFileName);
        goto end;
    }

    //
    // Check the attributes of this file. We'll get an error if the specified path doesn't exist
    //
    DWORD dwAttrib = GetFileAttributes(pwszFullPath);
    if (dwAttrib == INVALID_FILE_ATTRIBUTES)
    {
        //
        // The only error we will continue on is a "file doesn't exist" error
        //
        DWORD dwStatus = GetLastError();
        if (dwStatus != ERROR_FILE_NOT_FOUND)
        {
            TRACE_CRIT(L"Error %d retrieving file attributes for '%ls'", dwStatus, pwszFullPath);
            goto end;
        }
    }
    else
    {
        if (dwAttrib & FILE_ATTRIBUTE_DIRECTORY)
        {
            TRACE_CRIT(L"'%ls' is a directory and can't be used as a log file", pwszFullPath);
            goto end;
        }
        else if (dwAttrib & (FILE_ATTRIBUTE_OFFLINE | FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM))
        {
            TRACE_CRIT(L"'%ls' can't be used as a log file because it is either an offline file, system file or a readonly file", pwszFullPath);
            goto end;
        }
    }

    fRet = true;

end:

    TRACE_INFO(L"<- returns fRet=%u", fRet);

    return fRet;
}

/*
bool Document::isDirectoryValid(WCHAR* pwszFileName)
{
    bool fRet = false;

    CFile           f;
    CFileException  e;
    UINT            uiOpenOptions = CFile::modeReadWrite | CFile::shareDenyWrite | CFile::modeCreate | CFile::modeNoTruncate;

    WCHAR   pwszFullPath[_MAX_PATH + 1];

    ASSERT(pwszFileName != NULL);

    TRACE_INFO(L"-> Path = '%ls'", pwszFileName);

    //
    // Convert the input file name into a full path name (in case we are given a relative path)
    //
    if (_wfullpath(pwszFullPath, pwszFileName, _MAX_PATH) == NULL)
    {
        TRACE_CRIT(L"_wfullpath failed converting '%ls' to a full path. Name could be too long or could specify an invalid drive letter", pwszFileName);
        goto end;
    }

    if(!f.Open(pwszFullPath, uiOpenOptions, &e))
    {
        if (e.m_cause != CFileException::fileNotFound && e.m_cause != CFileException::none)
        {
            TRACE_CRIT(L"Test open failed for '%ls' with CFileException cause = %d. See ", pwszFullPath, e.m_cause);
            goto end;
        }
    }

    f.Close();
    fRet = true;

end:

    TRACE_INFO(L"<- returns fRet=%u", fRet);

    return fRet;
}
*/

void Document::LoadHostsFromFile(_bstr_t &FileName)
{
    CStdioFile HostListFile;
    CString             HostName;
    WMI_CONNECTION_INFO ConnInfo;


    ZeroMemory(&ConnInfo, sizeof(ConnInfo));

    //
    // Take the credentials from the options field.
    //
    _bstr_t bstrUserName;
    _bstr_t bstrPassword;
    this->getDefaultCredentials(bstrUserName, bstrPassword);
    ConnInfo.szUserName = (LPCWSTR) bstrUserName;
    ConnInfo.szPassword = (LPCWSTR) bstrPassword;
    


    TRACE_INFO(L"-> %!FUNC! File name : %ls", (LPCWSTR)FileName);

    if (m_fPrepareToDeinitialize)
    {
        goto end;
    }

    Log(LOG_INFORMATIONAL, NULL, NULL, IDS_LOG_BEGIN_LOADING_FROM_FILE, (LPCWSTR) FileName);

    // Open file as a text file in read-only mode, allowing others to read when we have the file opened.
    if (!HostListFile.Open(FileName, CFile::modeRead | CFile::shareDenyWrite | CFile::typeText))
    {
        AfxMessageBox((LPCTSTR)(GETRESOURCEIDSTRING(IDS_FILE_OPEN_FAILED) + FileName));
        Log(LOG_ERROR, NULL, NULL, IDS_LOG_FILE_OPEN_FAILED, (LPCWSTR) FileName);
        TRACE_CRIT(L"%!FUNC! Could not open file: %ws", (LPCWSTR) FileName);
        goto end;
    }


    // Read host names from file in a loop
    // Call LoadHost for each host
    BeginWaitCursor();
    while(HostListFile.ReadString(REF HostName))
    {
        LPCWSTR szHostName = (LPCWSTR) HostName;
        
        //
        // We skip blank lines, and lines beginning with whitespace followed
        // by the ";" character, which we use as a comment char.
        //
        if (szHostName==NULL)
        {
            continue;
        }

        //
        // Skip initial whitespage
        //
        szHostName = _wcsspnp(szHostName, L" \t\n\r");
        if (szHostName==NULL)
        {
            continue;
        }

        //
        // Skip if string is empty (we don't expect this because the other
        // call didn't return NULL) OR the first char is a ';' character.
        //
        if (*szHostName == 0 || *szHostName == ';')
        {
            continue;
        }

        ConnInfo.szMachine = szHostName;
        gEngine.LoadHost(&ConnInfo, NULL);
    }
    EndWaitCursor();

    // Close file
    HostListFile.Close();

end:

    TRACE_INFO(L"<- %!FUNC!");
    return;
}

Document::VIEWTYPE
Document::GetViewType(CWnd* pWnd)
{
    VIEWTYPE vt = NO_VIEW;
    if (pWnd == m_pLeftView)
    {
        vt = LEFTVIEW;
    }
    else if (pWnd == m_pDetailsView)
    {
        vt = DETAILSVIEW;
    }
    else if (pWnd == m_pLogView)
    {
        vt = LOGVIEW;
    }

    return vt;
}

/* Method: SetFocusNextView
 * Description: Given the input window, sets the focus on the next view
 */
void
Document::SetFocusNextView(CWnd* pWnd, UINT nChar)
{
    Document::VIEWTYPE vt = this->GetViewType(pWnd);

    //
    // 05/10/2002 JosephJ
    // Note: we special case F6 and Details below because
    // (a) We can't cycle through DetailsView for TAB, because we can't
    //     figure out how to capture TAB in DetailsView
    // (b) We need to a special version of SetFocus for details view --
    //     check out DetailsView::SetFocus for details.
    //

    CWnd* pTmp = NULL;
    switch(vt)
    {
    case LEFTVIEW:
        if (nChar == VK_F6)
        {
            pTmp = m_pDetailsView;
        } 
        else
        {
           pTmp = m_pLogView;
        }
        break;
    case DETAILSVIEW:
        pTmp = m_pLogView;
        break;
    case LOGVIEW:
        pTmp = m_pLeftView;
        break;
    default:
        pTmp = m_pLeftView;
        break;
    }

    if (pTmp != NULL)
    {
        if (pTmp == m_pDetailsView)
        {
            m_pDetailsView->SetFocus();
        }
        else
        {
            pTmp->SetFocus();
        }
    }
}

/* Method: SetFocusPrevView
 * Description: Given the input window, sets the focus on the prev view
 */
void
Document::SetFocusPrevView(CWnd* pWnd, UINT nChar)
{
    Document::VIEWTYPE vt = this->GetViewType(pWnd);

    // 05/10/2002 JosephJ see note concerning VK_F6 and DetailsView in
    //              Document::SetFocusNextView

    CWnd* pTmp = NULL;
    switch(vt)
    {
    case LEFTVIEW:
        pTmp = m_pLogView;
        break;
    case DETAILSVIEW:
        pTmp = m_pLeftView;
        break;
    case LOGVIEW:
        if (nChar == VK_F6)
        {
            pTmp = m_pDetailsView;
        }
        else
        {
            pTmp = m_pLeftView;
        }
        break;
    default:
        pTmp = m_pLeftView;
        break;
    }

    if (pTmp != NULL)
    {
        if (pTmp == m_pDetailsView)
        {
            m_pDetailsView->SetFocus();
        }
        else
        {
            pTmp->SetFocus();
        }
    }
}

void
Document::OnCloseDocument()
{
    ASSERT(m_fPrepareToDeinitialize);

    //
    // Deinitialize log view
    //
    if (m_pLogView != NULL)
    {
        m_pLogView->Deinitialize();
    } 

    //
    // Deinitialize left view
    //
    if (m_pLeftView != NULL)
    {
        m_pLeftView->Deinitialize();
    } 

    //
    // Deinitialize details view
    //
    if (m_pDetailsView != NULL)
    {
        m_pDetailsView->Deinitialize();
    } 

    //
    // Deinitialize engine
    //
    gEngine.Deinitialize();

    CDocument::OnCloseDocument();
}

VOID
Document::PrepareToClose(BOOL fBlock)
{
    //
    // Cancel any pending operations in the engine, and prevent any
    // new operations to be launched. During this time, we want the
    // views and the log to be updated, so we don't PrepareToDeinitialize
    // for ourselves or the views yet...
    //
    {
        CWaitCursor wait;
        gEngine.PrepareToDeinitialize();
        gEngine.CancelAllPendingOperations(fBlock);
    }

    if (!fBlock)
    {
        goto end;
    }

    //
    // At this time there should be no more pending activity. Block
    // any further updates to the views...
    //

    m_fPrepareToDeinitialize = TRUE;

    if (m_pLeftView != NULL)
    {
        m_pLeftView->PrepareToDeinitialize();
    } 
    if (m_pDetailsView != NULL)
    {
        m_pDetailsView->PrepareToDeinitialize();
    } 
    if (m_pLogView != NULL)
    {
        m_pLogView->PrepareToDeinitialize();
    } 

end:

    return;
}

BOOL
Document::mfn_DeferUIOperation(CUIWorkItem *pWorkItem)
{
    BOOL fRet = FALSE;
    extern CWnd  *g_pMainFormWnd;

    if (g_pMainFormWnd != NULL)
    {
        fRet = g_pMainFormWnd->PostMessage(MYWM_DEFER_UI_MSG, 0, (LPARAM) pWorkItem);
    #if 0
        if (fRet)
        {
            DummyAction(L"PostMessage returns TRUE");
        }
        else
        {
            DummyAction(L"PostMessage returns FALSE");
        }
    #endif // 0
    }

    return fRet;
}

void
Document::HandleDeferedUIWorkItem(CUIWorkItem *pWorkItem)
{
    if (m_fPrepareToDeinitialize)
    {
        goto end;
    }

    if (!theApplication.IsMainThread())
    {
        goto end;
    }

    switch(pWorkItem->workItemType)
    {
    case CUIWorkItem::ITEM_LOG:
        if (m_pLogView)
        {
            LogEntryHeader Header;
            Header.type = pWorkItem->type;
            Header.szCluster = pWorkItem->bstrCluster;
            Header.szHost = pWorkItem->bstrHost;
            Header.szDetails = pWorkItem->bstrDetails;
            Header.szInterface = pWorkItem->bstrInterface;
            m_pLogView->LogString(&Header, (LPCWSTR) pWorkItem->bstrText);
        }
        break;

    case CUIWorkItem::ITEM_ENGINE_EVENT:
        this->HandleEngineEvent(
            pWorkItem->objtype,
            pWorkItem->ehClusterId,
            pWorkItem->ehObjId,
            pWorkItem->evt
            );
        break;

    default:
        break;
    }

end:
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\hostpage.cpp ===
//***************************************************************************
//
//  HOSTPAGE.CPP
// 
//  Module: NLB Manager
//
//  Purpose: Implements HostPage, which is a dialog for host-specific
//           properties
//
//  Copyright (c)2001-2002 Microsoft Corporation, All Rights Reserved
//
//  History:
//
//  07/30/01    JosephJ Created
//
//***************************************************************************
#include "precomp.h"
#pragma hdrstop
#include "private.h"
#include "HostPage.h"
#include "HostPage.tmh"

using namespace std;

BEGIN_MESSAGE_MAP( HostPage, CPropertyPage )
    ON_EN_SETFOCUS( IDC_EDIT_DED_IP, OnGainFocusDedicatedIP )
    ON_EN_SETFOCUS( IDC_EDIT_DED_MASK, OnGainFocusDedicatedMask )
    ON_WM_HELPINFO()        
    ON_WM_CONTEXTMENU()        
END_MESSAGE_MAP()


HostPage::HostPage(
        CPropertySheet *psh,
        NLB_EXTENDED_CLUSTER_CONFIGURATION *pNlbCfg,
        ENGINEHANDLE ehCluster OPTIONAL,
        const ENGINEHANDLE *pehInterface OPTIONAL
        )
            :
        m_pshOwner( psh),
        m_pNlbCfg( pNlbCfg ),
        CPropertyPage( HostPage::IDD ),
        m_clusterData(NULL),
        m_ehCluster(ehCluster),
        m_pehInterface(pehInterface),
        m_fSaved(FALSE)
{
    TRACE_INFO("%!FUNC! ->");

    //
    // Note: the following gEngine.GetAvailableXXX APIs can deal with
    // the fact that ehCluster may be NULL -- in which case they 
    // setup the out params to be all-available.
    //

    m_AvailableHostPriorities = gEngine.GetAvailableHostPriorities(
                                        ehCluster);
    mfn_LoadFromNlbCfg();

    TRACE_INFO("%!FUNC! <-");
}


void
HostPage::mfn_LoadFromNlbCfg(void)
{
    TRACE_INFO("%!FUNC! ->");

    DWORD HostId = 0;
    _bstr_t bstrDedIp =  (LPCWSTR) m_pNlbCfg->NlbParams.ded_ip_addr;
    _bstr_t bstrDedMask =  (LPCWSTR) m_pNlbCfg->NlbParams.ded_net_mask;
    BOOL fPersistSuspendedState =   m_pNlbCfg->NlbParams.persisted_states
                                  & CVY_PERSIST_STATE_SUSPENDED;
    DWORD preferredInitialHostState = m_pNlbCfg->NlbParams.cluster_mode;

    // fill in priority.
    wchar_t buf[Common::BUF_SIZE];
    ULONG availHostIds = m_AvailableHostPriorities;
    ENGINEHANDLE ehInterface = NULL;

    HostId =  m_pNlbCfg->NlbParams.host_priority;
    TRACE_CRIT("%!FUNC! HostId=%lu", HostId);

    if (HostId>0 && HostId<=32)
    {
        availHostIds |= (((ULONG)1)<<(HostId-1));
    }

    // Delete any current entries in the priorities combobox
    {
        int iLeft;

        do
        { 
            iLeft = priority.DeleteString(0);

        } while(iLeft != 0 && iLeft != CB_ERR);
    }

    for(ULONG u=0; u<32; u++)
    {
        if (availHostIds & (((ULONG)1)<<u))
        {
            StringCbPrintf(buf, sizeof(buf),  L"%d", (u+1));
            priority.AddString( buf );
            if (HostId == 0)
            {
                HostId = u+1; // let's pick the first available one.
            }
        }
    }

    // set selection to present hostid
    StringCbPrintf( buf, sizeof(buf), L"%d", HostId );
    priority.SelectString( -1, buf );

     // set persist suspend
    persistSuspend.SetCheck(fPersistSuspendedState);

     // set initial host state
    {
        int itemNum = 0;

        /* Delete all items currently in the combobox first. */
        do { 
            itemNum = initialState.DeleteString(0);
        } while (itemNum != 0 && itemNum != CB_ERR);

        itemNum = initialState.AddString(GETRESOURCEIDSTRING(IDS_HOST_STATE_STARTED));
        initialState.SetItemData(itemNum, (DWORD)CVY_HOST_STATE_STARTED);
        
        if (preferredInitialHostState == CVY_HOST_STATE_STARTED)
            initialState.SetCurSel(itemNum);

        itemNum = initialState.AddString(GETRESOURCEIDSTRING(IDS_HOST_STATE_STOPPED));
        initialState.SetItemData(itemNum, (DWORD)CVY_HOST_STATE_STOPPED);

        if (preferredInitialHostState == CVY_HOST_STATE_STOPPED)
            initialState.SetCurSel(itemNum);
        
        itemNum = initialState.AddString(GETRESOURCEIDSTRING(IDS_HOST_STATE_SUSPENDED));
        initialState.SetItemData(itemNum, (DWORD)CVY_HOST_STATE_SUSPENDED);

        if (preferredInitialHostState == CVY_HOST_STATE_SUSPENDED)
            initialState.SetCurSel(itemNum);
    }

    // fill in host ip
    CommonUtils::fillCIPAddressCtrlString( 
        ipAddress,
        bstrDedIp );

    // set host mask.
    CommonUtils::fillCIPAddressCtrlString( 
        subnetMask,
        bstrDedMask );

    //
    // Initialize the caption and discription based on the type of
    // dialog.
    //
    {
        CWnd *pItem = GetDlgItem(IDC_NIC_FRIENDLY);
        LPWSTR szFriendlyName = NULL;
        m_pNlbCfg->GetFriendlyName(&szFriendlyName);
        if (pItem != NULL && szFriendlyName != NULL)
        {
            pItem->SetWindowText(szFriendlyName);
        }
        delete szFriendlyName;
    }

    TRACE_INFO("%!FUNC! <-");
}

void
HostPage::DoDataExchange( CDataExchange* pDX )
{
    DDX_Control( pDX, IDC_EDIT_PRI, priority );    
    DDX_Control( pDX, IDC_CHECK_PERSIST_SUSPEND, persistSuspend );
    DDX_Control( pDX, IDC_COMBOBOX_DEFAULT_STATE, initialState );    
    DDX_Control( pDX, IDC_EDIT_DED_IP, ipAddress );    
    DDX_Control( pDX, IDC_EDIT_DED_MASK, subnetMask );    
}

BOOL
HostPage::OnInitDialog()
{
    TRACE_INFO("%!FUNC! ->");
    CPropertyPage::OnInitDialog();

    mfn_LoadFromNlbCfg();

    TRACE_INFO("%!FUNC! <-");
    return TRUE;
}


void
HostPage::OnOK()
{
    CPropertyPage::OnOK();    

    TRACE_INFO("%!FUNC! ->");
    //
    // Save the configuration to the NLB configuration structure
    // that was passed in the constructor of this dialog.
    //
    mfn_SaveToNlbCfg();
    TRACE_INFO("%!FUNC! <-");
}


BOOL
HostPage::mfn_ValidateDip(LPCWSTR szDip)
//
// If connection-IP is on this NIC:
//      MUST be the DIP (DIP can't be blank).
// Else if dip is blank:
//      return TRUE;
// Else // dip not blank
//      It must not be used anywhere else -- i.e., be part of a
//      cluster IP, or bound to any other interface known to NLB Manager.
//
//
// On errr, bring up appropriate MsgBox  and return FALSE.
// Else return TRUE.
//
{
    ENGINEHANDLE ehIF = NULL;
    BOOL         fRet = FALSE;
    NLBERROR     nerr;

    if (m_pehInterface != NULL)
    {
        ehIF = *m_pehInterface;
    }

    if (ehIF == NULL)
    {
        ASSERT(FALSE);
        goto end;
    }

    //
    // Check if this interface is the connection-interface and if so
    // what is the connection IP.
    //
    {
        UINT           uConnectionIp   = 0;
        ENGINEHANDLE   ehHost           = NULL;
        ENGINEHANDLE   ehCluster        = NULL;
        ENGINEHANDLE   ehConnectionIF   = NULL;
        _bstr_t        bstrFriendlyName;
        _bstr_t        bstrDisplayName;
        _bstr_t        bstrHostName;
        _bstr_t        bstrConnectionString;

        nerr = gEngine.GetInterfaceIdentification(
                    ehIF,
                    REF ehHost,
                    REF ehCluster,
                    REF bstrFriendlyName,
                    REF bstrDisplayName,
                    REF bstrHostName
                    );
        if (NLBFAILED(nerr))
        {
            fRet = TRUE;
            goto end;
        }

        nerr = gEngine.GetHostConnectionInformation(
                    ehHost,
                    REF ehConnectionIF,
                    REF bstrConnectionString,
                    REF uConnectionIp
                    );
        if (NLBFAILED(nerr))
        {
            TRACE_CRIT(L"%!FUNC! gEngine.GetHostConnectionInformation fails!");
            //
            // We'll plow on...
            //
            ehConnectionIF = NULL;
            uConnectionIp = 0;
        }

        if (ehConnectionIF == ehIF && uConnectionIp != 0)
        {
            //
            // The connection interface IS the current interface --
            // so dedicated IP MUST match the connection IP!
            //
            WBEMSTATUS wStat;
            UINT       uDipIp = 0;
            wStat =  CfgUtilsValidateNetworkAddress(
                        szDip,
                        &uDipIp,
                        NULL, // puSubnetMask
                        NULL // puDefaultSubnetMask
                        );
        
            if (!FAILED(wStat))
            {
                if (uDipIp != uConnectionIp)
                {
                    MessageBox( GETRESOURCEIDSTRING( IDS_CANT_CHANGE_DIP_MSG ),
                    GETRESOURCEIDSTRING( IDS_PARM_ERROR ),
                    MB_ICONSTOP | MB_OK );
                    fRet = FALSE;
                    goto end;
                }
            }

            fRet = TRUE;
            goto end;
        }
    }

    //
    // If Dip is blank, we're done
    //
    if (*szDip == 0 || !_wcsicmp(szDip, L"0.0.0.0"))
    {
        fRet = TRUE;
        goto end;
    }

    //
    // Check that DIP is not used elsewhere
    //
    {
        ENGINEHANDLE ehTmp =  NULL;
        BOOL         fIsNew = FALSE;
        CLocalLogger logConflict;

        nerr = gEngine.ValidateNewDedicatedIp(
                        ehIF,
                        szDip,
                        REF logConflict
                        );

        if (nerr == NLBERR_INVALID_IP_ADDRESS_SPECIFICATION)
        {
            CLocalLogger    logMsg;
            logMsg.Log(
                IDS_NEW_DIP_CONFLICTS_WITH_XXX,
                logConflict.GetStringSafe()
                );
            MessageBox(
                logMsg.GetStringSafe(),
                GETRESOURCEIDSTRING( IDS_PARM_ERROR ),
                MB_ICONSTOP | MB_OK
                );
            fRet = FALSE;
            goto end;
        }
    }

    fRet = TRUE;

end:
    return fRet;

}


BOOL
HostPage::OnSetActive()
{

    BOOL fRet;

    TRACE_INFO("%!FUNC! ->");

    fRet =  CPropertyPage::OnSetActive();
    if (fRet)
    {
        mfn_LoadFromNlbCfg();
        m_pshOwner->SetWizardButtons(
                PSWIZB_BACK|
                // PSWIZB_NEXT|
                PSWIZB_FINISH|
                // PSWIZB_DISABLEDFINISH|
                0
                );
    }

    TRACE_INFO("%!FUNC! <- returns %lu", fRet);
    return fRet;
}


BOOL
HostPage::OnKillActive()
{
    BOOL fRet;

    TRACE_INFO("%!FUNC! ->");

    fRet = mfn_ValidateData();

    if (!fRet)
    {
       CPropertyPage::OnCancel();
    }
    else
    {
        mfn_SaveToNlbCfg();
        fRet = CPropertyPage::OnKillActive();
    }

    TRACE_INFO("%!FUNC! <- returns %lu", fRet);
    return fRet;
}


BOOL HostPage::OnWizardFinish( )
/*
    Overwridden virtual function. OnWizardFinish is ONLY called if
    this is the last page in the wizard. So if you need to save stuff
    on OnKillActive.
*/
{
    BOOL fRet;
    TRACE_INFO("%!FUNC! ->");

    fRet = CPropertyPage::OnWizardFinish();
    if (fRet)
    {
        fRet = mfn_ValidateData();
        if (fRet)
        {
            //
            // Save the configuration to the NLB configuration structure
            // that was passed in the constructor of this dialog.
            //
            mfn_SaveToNlbCfg();
        }
    }

    TRACE_INFO("%!FUNC! <- returns %lu", fRet);
    return fRet;
}

BOOL
HostPage::mfn_ValidateData()
{
    DWORD HostId =  0;
    _bstr_t bstrDedIp;
    _bstr_t bstrDedMask;
    BOOL fPersistSuspendedState = false;
    BOOL fRet = false;
    wchar_t buf[Common::BUF_SIZE];
    
    TRACE_INFO("%!FUNC! ->");

    // fill in priority.
    {
        int selectedPriorityIndex = priority.GetCurSel();
        priority.GetLBText( selectedPriorityIndex, buf );
        HostId = _wtoi( buf );
    }

    bstrDedIp = 
        CommonUtils::getCIPAddressCtrlString( ipAddress );

    bstrDedMask = 
        CommonUtils::getCIPAddressCtrlString( subnetMask );

    fPersistSuspendedState = persistSuspend.GetCheck() ? true : false;

    // ip is blank
    // subnet is blank
    // valid

    if( ( !_wcsicmp((LPCWSTR)bstrDedIp, L"0.0.0.0") )
        &&
        ( !_wcsicmp((LPCWSTR)bstrDedMask, L"0.0.0.0") )
        )
    {
        // both ip and subnet can be blank or 0.0.0.0 in host page.  both but not
        // either.
        // 
        // this is empty, we just need to catch this case.
    }
    else if (!_wcsicmp((LPCWSTR)bstrDedIp, L"0.0.0.0"))
    {
        // if only ip is blank or 0.0.0.0 then this is not allowed
        MessageBox( GETRESOURCEIDSTRING( IDS_PARM_DED_IP_BLANK ),
                    GETRESOURCEIDSTRING( IDS_PARM_ERROR ),
                    MB_ICONSTOP | MB_OK );

        goto end;
    }
    else 
    {
        // check if ip is valid.
        bool isIPValid = MIPAddress::checkIfValid(bstrDedIp ); 
        if( isIPValid != true )
        {
            MessageBox( GETRESOURCEIDSTRING( IDS_PARM_INVAL_DED_IP ),
                        GETRESOURCEIDSTRING( IDS_PARM_ERROR ),
                        MB_ICONSTOP | MB_OK );

            goto end;
        }

        // check if subnet is 0.0.0.0
        // if so ask user if he wants us to fill it or not.
        if (!_wcsicmp((LPCWSTR)bstrDedMask, L"0.0.0.0") )
        {
            MessageBox( GETRESOURCEIDSTRING( IDS_PARM_DED_NM_BLANK ),
                        GETRESOURCEIDSTRING( IDS_PARM_ERROR ),
                        MB_ICONSTOP | MB_OK );


            MIPAddress::getDefaultSubnetMask( bstrDedIp, 
                                              bstrDedMask 
                                              );

            CommonUtils::fillCIPAddressCtrlString( subnetMask, 
                                                   bstrDedMask );
            goto end;
        }

        // check if subnet is contiguous
        bool isSubnetContiguous = MIPAddress::isContiguousSubnetMask( bstrDedMask );
        if( isSubnetContiguous == false )
        {
            MessageBox( GETRESOURCEIDSTRING( IDS_PARM_INVAL_DED_MASK ),
                        GETRESOURCEIDSTRING( IDS_PARM_ERROR ),
                        MB_ICONSTOP | MB_OK );

            goto end;

        }

        // check if ip address and subnet mask are valid as a pair
        bool isIPSubnetPairValid = MIPAddress::isValidIPAddressSubnetMaskPair( bstrDedIp,
                                                                               bstrDedMask );
        if( isIPSubnetPairValid == false )
        {
            MessageBox( GETRESOURCEIDSTRING( IDS_PARM_INVAL_DED_IP ),
                        GETRESOURCEIDSTRING( IDS_PARM_ERROR ),
                        MB_ICONSTOP | MB_OK );

            goto end;
        }
    }

    fRet = mfn_ValidateDip((LPCWSTR)bstrDedIp);

    if (!fRet)
    {
        //
        // We'll push the original dip and subnet values back to the UI
        //
        CommonUtils::fillCIPAddressCtrlString(
                     ipAddress, 
                     m_pNlbCfg->NlbParams.ded_ip_addr
                     );
        CommonUtils::fillCIPAddressCtrlString(
                     subnetMask, 
                     m_pNlbCfg->NlbParams.ded_net_mask
                     );
                                               
    }

end:

    TRACE_INFO("%!FUNC! <- returns %lu", fRet);
    return fRet;
}


VOID
HostPage::mfn_SaveToNlbCfg(void)
//
// Actually save stuff to nlbcfg.
//
{
    DWORD HostId =  0;
    _bstr_t bstrDedIp;
    _bstr_t bstrDedMask;
    BOOL fPersistSuspendedState = false;
    BOOL fRet = FALSE;
    DWORD preferredInitialHostState = 0;
    wchar_t buf[Common::BUF_SIZE];
    int itemNum = 0;

    TRACE_INFO("%!FUNC! ->");

    // fill in priority.
    int selectedPriorityIndex = priority.GetCurSel();
    priority.GetLBText( selectedPriorityIndex, buf );
    HostId = _wtoi( buf );

    bstrDedIp = 
        CommonUtils::getCIPAddressCtrlString( ipAddress );

    bstrDedMask = 
        CommonUtils::getCIPAddressCtrlString( subnetMask );

    fPersistSuspendedState = persistSuspend.GetCheck() ? true : false;
              
    itemNum = initialState.GetCurSel();
    preferredInitialHostState = initialState.GetItemData(itemNum);

    m_pNlbCfg->NlbParams.host_priority = HostId;
    ARRAYSTRCPY(m_pNlbCfg->NlbParams.ded_ip_addr, (LPCWSTR) bstrDedIp);
    ARRAYSTRCPY(m_pNlbCfg->NlbParams.ded_net_mask, (LPCWSTR) bstrDedMask);

    if (fPersistSuspendedState)
        m_pNlbCfg->NlbParams.persisted_states |= CVY_PERSIST_STATE_SUSPENDED;
    else
        m_pNlbCfg->NlbParams.persisted_states &= ~CVY_PERSIST_STATE_SUSPENDED;

    m_pNlbCfg->NlbParams.cluster_mode = preferredInitialHostState;

    m_fSaved = TRUE;

    TRACE_INFO("%!FUNC! <-");
    return;
}


void
HostPage::OnSelectedNicChanged()
{
}

BOOL
HostPage::OnHelpInfo (HELPINFO* helpInfo )
{
    if( helpInfo->iContextType == HELPINFO_WINDOW )
    {
        ::WinHelp( static_cast<HWND> ( helpInfo->hItemHandle ), CVY_CTXT_HELP_FILE, HELP_WM_HELP, (ULONG_PTR ) g_aHelpIDs_IDD_HOST_PAGE);
    }

    return TRUE;
}

void
HostPage::OnContextMenu( CWnd* pWnd, CPoint point )
{
    ::WinHelp( m_hWnd, CVY_CTXT_HELP_FILE, HELP_CONTEXTMENU, (ULONG_PTR ) g_aHelpIDs_IDD_HOST_PAGE);
}

void
HostPage::OnGainFocusDedicatedIP()
{
}



void
HostPage::OnGainFocusDedicatedMask()
{
    // if dedicated ip is valid
    // and subnet mask is blank, then generate
    // the default subnet mask.
    _bstr_t ipAddressString = CommonUtils::getCIPAddressCtrlString( ipAddress );

    if( ( MIPAddress::checkIfValid( ipAddressString ) == true ) 
        &&
        ( subnetMask.IsBlank() == TRUE )
        )
    {
        _bstr_t subnetMaskString;

        MIPAddress::getDefaultSubnetMask( ipAddressString,
                                          subnetMaskString );

        CommonUtils::fillCIPAddressCtrlString( subnetMask,
                                               subnetMaskString );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\document.h ===
#ifndef DOCUMENT_H
#define DOCUMENT_H
#pragma once
#include "private.h"

#define MAXFILEPATHLEN  256
#define MAXSTRINGLEN    256

#define NLBMGR_AUTOREFRESH_MIN_INTERVAL 15
#define NLBMGR_AUTOREFRESH_DEF_INTERVAL 60

//
// A single instance of this class, gCmdLineInfo, is initialized
// by the Application object.
//
class CNlbMgrCommandLineInfo : public CCommandLineInfo
{
public:

    CNlbMgrCommandLineInfo(VOID)
        : m_bDemo(FALSE), m_bNoPing(FALSE),  m_bHostList(FALSE),
          m_bUsage(FALSE), m_bAutoRefresh(FALSE),
          m_refreshInterval(NLBMGR_AUTOREFRESH_DEF_INTERVAL)
    {
    }

    BOOL m_bAutoRefresh;
    UINT m_refreshInterval;
    BOOL m_bDemo;
    BOOL m_bNoPing;
    BOOL m_bHostList;
    BOOL m_bUsage;
    _bstr_t m_bstrHostListFile;

    virtual
    void
    ParseParam( LPCTSTR lpszParam, BOOL bFlag, BOOL bLast );
};

extern CNlbMgrCommandLineInfo gCmdLineInfo;


class CUIWorkItem
{

public:

    //
    // Use this constructor to create a work item for a log request
    //
    CUIWorkItem(
        IN const IUICallbacks::LogEntryHeader *pHeader,
        IN const wchar_t    *szText
        )
    {
        workItemType  = ITEM_LOG;

        try
        {
            type          = pHeader->type;
            bstrCluster   = pHeader->szCluster;
            bstrHost      = pHeader->szHost;
            bstrInterface = pHeader->szInterface;
            bstrText      = szText;
            bstrDetails   = pHeader->szDetails;
        }
        catch(...)
        {
            //
            // in case there's an bstr alloc failure.
            //
            workItemType  = ITEM_INVALID;
        }
    }

    //
    // Use this constructor to create a work item for a "HandleEngineEvent"
    // notification.
    //
    CUIWorkItem(
        IN IUICallbacks::ObjectType objtypeX,
        IN ENGINEHANDLE ehClusterIdX, // could be NULL
        IN ENGINEHANDLE ehObjIdX,
        IN IUICallbacks::EventCode evtX
        )
    {
        workItemType = ITEM_ENGINE_EVENT;

        objtype     = objtypeX;
        ehClusterId = ehClusterIdX;
        ehObjId     = ehObjIdX;
        evt         = evtX;
    }

    ~CUIWorkItem()
    {
    }

    enum
    {
        ITEM_INVALID=0,
        ITEM_LOG,
        ITEM_ENGINE_EVENT

    } workItemType;

    //
    // Log function related
    //
    IUICallbacks::LogEntryType    type;
    _bstr_t         bstrCluster;
    _bstr_t         bstrHost;
    _bstr_t         bstrInterface;
    _bstr_t         bstrText;
    _bstr_t         bstrDetails;

    //
    // Handle engine event related...
    //
    IUICallbacks::ObjectType      objtype;
    ENGINEHANDLE    ehClusterId;
    ENGINEHANDLE    ehObjId;
    IUICallbacks::EventCode       evt;
};


class Document : public CDocument, public IUICallbacks
{
    DECLARE_DYNCREATE( Document )

public:

    enum IconNames
    {
        //
        // This order must exactly the order in which Icons are loaded
        // in Document::Document.
        //
    
        ICON_WORLD = 0,
        ICON_CLUSTER,

        ICON_HOST_STARTED,
        ICON_HOST_STOPPED,
        ICON_HOST_CONVERGING,
        ICON_HOST_SUSPENDED,
        ICON_HOST_DRAINING,
        ICON_HOST_DISCONNECTED,

        ICON_PORTRULE,
        ICON_PENDING,

        ICON_INFORMATIONAL,
        ICON_WARNING,
        ICON_ERROR,

        ICON_CLUSTER_OK,
        ICON_CLUSTER_PENDING,
        ICON_CLUSTER_BROKEN,

        ICON_HOST_OK,
        ICON_HOST_PENDING,
        ICON_HOST_MISCONFIGURED,
        ICON_HOST_UNREACHABLE,
        ICON_HOST_UNKNOWN
    };

    enum ListViewColumnSize
    {
        LV_COLUMN_MINSCULE    = 20,
        LV_COLUMN_TINY        = 60,
        LV_COLUMN_SMALL       = 70,
        LV_COLUMN_SMALLMEDIUM = 75,
        LV_COLUMN_MEDIUM      = 80,
        LV_COLUMN_LARGE       = 90,
        LV_COLUMN_LARGE2      = 160,
        LV_COLUMN_VERYLARGE   = 200,
        LV_COLUMN_GIGANTIC    = 500
    };


    // constructor
    Document();
    // destructor
    virtual ~Document();


    //
    // ------------------------------- overrides for IUICallbacks ----------
    //

    //
    // Asks the user to update user-supplied info about a host.
    //
    BOOL
    virtual
    Document::UpdateHostInformation(
        IN BOOL fNeedCredentials,
        IN BOOL fNeedConnectionString,
        IN OUT CHostSpec& host
        );


    //
    // Log a message in human-readable form.
    //
    virtual
    void
    Log(
        IN LogEntryType     Type,
        IN const wchar_t    *szCluster, OPTIONAL
        IN const wchar_t    *szHost, OPTIONAL
        IN UINT ResourceID,
        ...
    );

    virtual
    void
    LogEx(
        IN const LogEntryHeader *pHeader,
        IN UINT ResourceID,
        ...
    );

    //
    // Handle an event relating to a specific instance of a specific
    // object type.
    //
    virtual
    void
    HandleEngineEvent(
        IN ObjectType objtype,
        IN ENGINEHANDLE ehClusterId, // could be NULL
        IN ENGINEHANDLE ehObjId,
        IN EventCode evt
        );

    //
    // Handle a selection change notification from the left (tree) view
    //
    void
    HandleLeftViewSelChange(
        IN IUICallbacks::ObjectType objtype,
        IN ENGINEHANDLE ehObjId
        );

    // ------------------------------- END overrides for IUICallbacks ----------

	void
	registerLeftView(LeftView *pLeftView);

	void
	registerLogView(LogView *pLogView);

	void
	registerDetailsView(DetailsView *pDetailsView);

    void 
    LoadHostsFromFile(_bstr_t &FileName);

    VOID
    getDefaultCredentials(
        OUT _bstr_t  &bstrUserName, 
        OUT _bstr_t  &bstrPassword
        )
    {
        bstrUserName = m_bstrDefaultUserName;
        bstrPassword = m_bstrDefaultPassword;
    }

    VOID
    setDefaultCredentials(
        IN LPCWSTR  szUserName, 
        IN LPCWSTR  szPassword
        )
    {
        m_bstrDefaultUserName = _bstr_t(szUserName);
        m_bstrDefaultPassword = _bstr_t(szPassword);
    }
        

    void
    HandleDeferedUIWorkItem(CUIWorkItem *pWorkItem);


    CImageList* m_images48x48;

    //
    // Logging support
    //
    enum LOG_RESULT         {
             STARTED=0, ALREADY, NOT_ENABLED, NO_FILE_NAME, FILE_NAME_TOO_LONG,
             IO_ERROR, REG_IO_ERROR, FILE_PATH_INVALID, FILE_TOO_LARGE
         };
    inline bool             isLoggingEnabled() { return (m_dwLoggingEnabled != 0); }
    inline bool             isCurrentlyLogging() { return (NULL != m_hStatusLog); }
    Document::LOG_RESULT    initLogging();
    LONG                    enableLogging();
    LONG                    disableLogging();
    Document::LOG_RESULT    startLogging();
    bool                    stopLogging();
    void                    getLogfileName(WCHAR* pszFileName, DWORD dwBufLen);
    LONG                    setLogfileName(WCHAR* pszFileName);
    void                    logStatus(WCHAR* pszStatus);
    bool                    isDirectoryValid(WCHAR* pszFileName);
    // End logging support

    void SetFocusNextView(CWnd* pWnd, UINT nChar);
    void SetFocusPrevView(CWnd* pWnd, UINT nChar);

    virtual void OnCloseDocument();

    
    VOID
    PrepareToClose(BOOL fBlock);

private:

    //
    // Attempts to defer the specified operation by posting the operation
    // to the application's message queue where it will be picked up and
    // processed later. Returns TRUE IFF the operation has been posted
    // successfully. The caller should delete pWorkItem IFF the function
    // returns FALSE.
    //
    BOOL
    mfn_DeferUIOperation(CUIWorkItem *pWorkItem);

    LeftView        *m_pLeftView;
    DetailsView     *m_pDetailsView;
    LogView         *m_pLogView;
    CNlbEngine	    *m_pNlbEngine;
    DWORD           m_dwLoggingEnabled;
    WCHAR           m_szLogFileName[MAXFILEPATHLEN];
    FILE            *m_hStatusLog;
    BOOL            m_fPrepareToDeinitialize;

    enum VIEWTYPE { NO_VIEW = 0, LEFTVIEW, DETAILSVIEW, LOGVIEW };

    VIEWTYPE
    GetViewType(CWnd* pWnd); // Matches the CWnd* to that of the defined views

#if OBSOLETE
    void LoadHost(WMI_CONNECTION_INFO *pConnInfo);
#endif // OBSOLETE

    _bstr_t m_bstrDefaultUserName;
    _bstr_t m_bstrDefaultPassword; // TODO Security audit of this practise!!!!!
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\hostportsdlg.cpp ===
#include "precomp.h"
#pragma hdrstop
#include "private.h"
#include "PortsPage.h"
#include "HostPortsDlg.h"

BEGIN_MESSAGE_MAP(HostPortsDlg, CDialog)
    ON_BN_CLICKED(IDC_CHECK_EQUAL, OnCheckEqualLoad)
    ON_WM_HELPINFO()        
    ON_WM_CONTEXTMENU()        
END_MESSAGE_MAP()



HostPortsDlg::HostPortsDlg( PortsPage::PortData& portData, 
                            ENGINEHANDLE ehCluster, // OPTIONAL
                            CWnd* parent
                            )
        :
        m_portData( portData ),
        m_ehCluster( ehCluster ),
        CDialog( HostPortsDlg::IDD, parent )
{
    m_parent = (PortsPage *) parent;
}


void 
HostPortsDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange( pDX );

    DDX_Control(pDX, IDC_EDIT_SINGLE, m_priority);
    DDX_Control(pDX, IDC_EDIT_PORT_RULE_VIP, ipAddress);   
}

BOOL 
HostPortsDlg::OnInitDialog()
{
    CDialog::OnInitDialog();
    
    SetControlData();

    return TRUE;
}

void 
HostPortsDlg::OnOK()
{
    wchar_t buffer[Common::BUF_SIZE];

    //
    // The only thing which potentially could change
    // is the load weight if mode is multiple and the priority
    // if mode is single.
    //

    // set the new port rule.
    if( m_portData.mode == GETRESOURCEIDSTRING( IDS_REPORT_MODE_MULTIPLE ))
    {
        BOOL fEqualLoad = FALSE;

        if (::IsDlgButtonChecked (m_hWnd, IDC_CHECK_EQUAL))
        {
            fEqualLoad = TRUE;
            m_portData.load = GETRESOURCEIDSTRING( IDS_REPORT_LOAD_EQUAL );
        }

        if(!fEqualLoad)
        {
            // set the load here.
            BOOL fError;
            int weight = ::GetDlgItemInt (m_hWnd, IDC_EDIT_MULTI, &fError, FALSE);
            if( fError == FALSE )
            {
                // some problem with the data input.
                // it has been left blank.
                
                StringCbPrintf( buffer, sizeof(buffer), GETRESOURCEIDSTRING( IDS_PARM_LOAD_BLANK ), CVY_MIN_LOAD, CVY_MAX_LOAD);
    
                MessageBox( buffer,
                            GETRESOURCEIDSTRING( IDS_PARM_ERROR ),
                            MB_ICONSTOP | MB_OK );
                
                return;
            }
    
            if( !( weight >= CVY_MIN_LOAD 
                   &&
                   weight <= CVY_MAX_LOAD )
                )
            {
                // the weight value is not in valid range.
                // These controls are all screwed up, even 
                // after setting the limits we need to all 
                // this checking, it is amazing!!!
                //
                StringCbPrintf( buffer, sizeof(buffer), GETRESOURCEIDSTRING( IDS_PARM_LOAD ), CVY_MIN_LOAD,CVY_MAX_LOAD  );
    
                MessageBox( buffer,
                            GETRESOURCEIDSTRING( IDS_PARM_ERROR ),
                            MB_ICONSTOP | MB_OK );
                
                return;
            }
                
            StringCbPrintf( buffer, sizeof(buffer), L"%d", weight );
            m_portData.load = buffer;
        }
    }
    else if( m_portData.mode == GETRESOURCEIDSTRING( IDS_REPORT_MODE_SINGLE ) )
    {
        ::GetDlgItemText(m_hWnd, IDC_EDIT_SINGLE, buffer, Common::BUF_SIZE );

        m_portData.priority = buffer;
    }

    EndDialog( IDOK );
}


void
HostPortsDlg::SetControlData()
{
    // set ranges.
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_MULTI, EM_SETLIMITTEXT, 3, 0);
    ::SendDlgItemMessage(m_hWnd, IDC_SPIN_MULTI, UDM_SETRANGE32, CVY_MIN_LOAD, CVY_MAX_LOAD);

    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_SINGLE, EM_SETLIMITTEXT, 2, 0);
    ::SendDlgItemMessage(m_hWnd, IDC_SPIN_SINGLE, UDM_SETRANGE32, CVY_MIN_MAX_HOSTS, CVY_MAX_MAX_HOSTS);

    // set the vip.
    ::EnableWindow(GetDlgItem (IDC_EDIT_PORT_RULE_VIP)->m_hWnd, FALSE);    

    if (!lstrcmpi(m_portData.virtual_ip_addr, GETRESOURCEIDSTRING(IDS_REPORT_VIP_ALL))) {
        ::CheckDlgButton(m_hWnd, IDC_CHECK_PORT_RULE_ALL_VIP, BST_CHECKED);
    } else {
        CommonUtils::fillCIPAddressCtrlString(ipAddress, m_portData.virtual_ip_addr);
        ::CheckDlgButton(m_hWnd, IDC_CHECK_PORT_RULE_ALL_VIP, BST_UNCHECKED);
    }

    // set the ports
    ::SetDlgItemInt (m_hWnd, IDC_EDIT_START,  _wtoi( m_portData.start_port), FALSE);
    ::SetDlgItemInt (m_hWnd, IDC_EDIT_END,  _wtoi( m_portData.end_port ),   FALSE);

    // set the protocol.
    if( m_portData.protocol == GETRESOURCEIDSTRING(IDS_REPORT_PROTOCOL_TCP) )
    {
        ::CheckDlgButton( m_hWnd, IDC_RADIO_TCP, BST_CHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_UDP, BST_UNCHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_BOTH, BST_UNCHECKED );
    }
    else if( m_portData.protocol == GETRESOURCEIDSTRING(IDS_REPORT_PROTOCOL_UDP) )
    {
        ::CheckDlgButton( m_hWnd, IDC_RADIO_TCP, BST_UNCHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_UDP, BST_CHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_BOTH, BST_UNCHECKED );
    }
    else
    {
        ::CheckDlgButton( m_hWnd, IDC_RADIO_TCP, BST_UNCHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_UDP, BST_UNCHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_BOTH, BST_CHECKED );
    }

    // set the mode.
    if( m_portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_MULTIPLE) )
    { 
        ::CheckDlgButton( m_hWnd, IDC_RADIO_MULTIPLE, BST_CHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_SINGLE, BST_UNCHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_DISABLED, BST_UNCHECKED );

        :: EnableWindow (GetDlgItem (IDC_CHECK_EQUAL)->m_hWnd,    TRUE);

        if (m_portData.load == GETRESOURCEIDSTRING(IDS_REPORT_LOAD_EQUAL))
        {
            ::CheckDlgButton( m_hWnd, IDC_CHECK_EQUAL, BST_CHECKED );
            ::SetDlgItemInt (m_hWnd, IDC_EDIT_MULTI,  50, FALSE);
        }
        else
        {
            ::CheckDlgButton( m_hWnd, IDC_CHECK_EQUAL, BST_UNCHECKED );

            ::SetDlgItemInt (m_hWnd, IDC_EDIT_MULTI,  _wtoi( m_portData.load), FALSE);

            :: EnableWindow (GetDlgItem (IDC_TEXT_MULTI)->m_hWnd,    TRUE);
            :: EnableWindow (GetDlgItem (IDC_EDIT_MULTI)->m_hWnd,    TRUE);
            :: EnableWindow (GetDlgItem (IDC_SPIN_MULTI)->m_hWnd,    TRUE);
        }

        if( m_portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_NONE ) )
        {
            ::CheckDlgButton( m_hWnd, IDC_RADIO_AFF_NONE, BST_CHECKED );
            ::CheckDlgButton( m_hWnd, IDC_RADIO_AFF_SINGLE, BST_UNCHECKED );
            ::CheckDlgButton( m_hWnd, IDC_RADIO_AFF_CLASSC, BST_UNCHECKED );
        }
        else if ( m_portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_SINGLE) )
        {
            ::CheckDlgButton( m_hWnd, IDC_RADIO_AFF_NONE, BST_UNCHECKED );
            ::CheckDlgButton( m_hWnd, IDC_RADIO_AFF_SINGLE, BST_CHECKED );
            ::CheckDlgButton( m_hWnd, IDC_RADIO_AFF_CLASSC, BST_UNCHECKED );
        }
        else
        {
            ::CheckDlgButton( m_hWnd, IDC_RADIO_AFF_NONE, BST_UNCHECKED );
            ::CheckDlgButton( m_hWnd, IDC_RADIO_AFF_SINGLE, BST_UNCHECKED );
            ::CheckDlgButton( m_hWnd, IDC_RADIO_AFF_CLASSC, BST_CHECKED );
        }
    }
    else if( m_portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_SINGLE) )
    {
        ::CheckDlgButton( m_hWnd, IDC_RADIO_MULTIPLE, BST_UNCHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_SINGLE, BST_CHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_DISABLED, BST_UNCHECKED );

        BOOL fError;
    // fill in priority.
    wchar_t buf[Common::BUF_SIZE];
    ULONG availPriorities = 0xffffffff;
    UINT CurrentPriority =  _wtoi(m_portData.priority);
    WLBS_PORT_RULE Rule;
    ZeroMemory(&Rule, sizeof(Rule));
    ARRAYSTRCPY(Rule.virtual_ip_addr, m_portData.virtual_ip_addr);
    Rule.start_port = _wtoi(m_portData.start_port);
    Rule.mode = CVY_SINGLE;
    NLBERROR nerr;
    
    nerr = gEngine.GetAvailablePortRulePriorities(
                    m_ehCluster,
                    1,
                    &Rule,
                    &availPriorities
                    );
    if (NLBFAILED(nerr))
    {
        availPriorities = 0xffffffff;
    }

    if (CurrentPriority>0 && CurrentPriority<=32)
    {
        availPriorities |= (((ULONG)1)<<(CurrentPriority-1));
    }

    // Delete any current entries in the priorities combobox
    {
        int iLeft;

        do
        { 
            iLeft = m_priority.DeleteString(0);

        } while(iLeft != 0 && iLeft != CB_ERR);
    }

    for(ULONG u=0; u<32; u++)
    {
        if (availPriorities & (((ULONG)1)<<u))
        {
            StringCbPrintf( buf, sizeof(buf), L"%d", (u+1));
            m_priority.AddString( buf );
            if (CurrentPriority == 0)
            {
                CurrentPriority = u+1; // let's pick the first available one.
            }
        }
    }


        // set selection to present hostid
        StringCbPrintf( buf, sizeof(buf), L"%d", CurrentPriority);
        m_priority.SelectString( -1, buf );

        :: EnableWindow (GetDlgItem (IDC_TEXT_SINGLE)->m_hWnd,    TRUE);
        :: EnableWindow (GetDlgItem (IDC_EDIT_SINGLE)->m_hWnd,    TRUE);
    }
}


BOOL
HostPortsDlg::OnHelpInfo (HELPINFO* helpInfo )
{
    if( helpInfo->iContextType == HELPINFO_WINDOW )
    {
        ::WinHelp( static_cast<HWND> ( helpInfo->hItemHandle ), 
                   CVY_CTXT_HELP_FILE, HELP_WM_HELP, 
                   (ULONG_PTR ) g_aHelpIDs_IDD_PORT_RULE_PROP_HOSTS );
    }

    return TRUE;
}

void
HostPortsDlg::OnContextMenu( CWnd* pWnd, CPoint point )
{
    ::WinHelp( m_hWnd, 
               CVY_CTXT_HELP_FILE, 
               HELP_CONTEXTMENU, 
               (ULONG_PTR ) g_aHelpIDs_IDD_PORT_RULE_PROP_HOSTS );
}

void HostPortsDlg::OnCheckEqualLoad()
//
// If the equal-load checkbox is Checked
//      Enable the load-weight controls
// else
//      Disable the controls
//
{
    BOOL fEnable = FALSE;

    fEnable = !::IsDlgButtonChecked(m_hWnd, IDC_CHECK_EQUAL);

    :: EnableWindow (GetDlgItem (IDC_TEXT_MULTI)->m_hWnd,    fEnable);
    :: EnableWindow (GetDlgItem (IDC_EDIT_MULTI)->m_hWnd,    fEnable);
    :: EnableWindow (GetDlgItem (IDC_SPIN_MULTI)->m_hWnd,    fEnable);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\engine.h ===
//***************************************************************************
//
//  ENGINE.H
// 
//  Module: NLB Manager (client-side exe)
//
//  Purpose:  Engine used to operate on groups of NLB hosts.
//          This file has no UI aspects.
//
//  Copyright (c)2001 Microsoft Corporation, All Rights Reserved
//
//  History:
//
//  07/25/01    JosephJ Created
//
//***************************************************************************
#pragma once
    

//
// This class deliberately causes the following errors...
// CNoCopy xx;
// CNoCopy yy = xx; << Will cause compiler error
// CNoCopy zz;  
// zz = xx;         << Will cause compiler error
//
// Inheret from it if you want your class to also forbid the above operations.
//
class CNoCopy
{
protected:
    CNoCopy(void) {}
    ~CNoCopy() {}

private:
    CNoCopy(const CNoCopy&);
    CNoCopy& operator = (const CNoCopy&);
};

typedef ULONG ENGINEHANDLE;

//
// Specification, or settings of a cluster.
// This includes the list of interfacees (i.e., specific adapters on
// specific hosts) that constitute the cluster.
//
class CClusterSpec // : private CNoCopy
{
public:

    CClusterSpec(void)
    : m_fMisconfigured(FALSE),
      m_fPending(FALSE),
      m_ehDefaultInterface(NULL),
      m_ehPendingOperation(NULL),
      m_fNewRctPassword(NULL)
    {
        // can't do this (vector)!  ZeroMemory(this, sizeof(*this));
        ZeroMemory(&m_timeLastUpdate, sizeof(m_timeLastUpdate));
    }
    ~CClusterSpec()     {}

    NLBERROR
    Copy(const CClusterSpec &);

    NLBERROR
    UpdateClusterConfig(
        const NLB_EXTENDED_CLUSTER_CONFIGURATION &refNewConfig
        )
    {
        NLBERROR nerr = NLBERR_OK;
        WBEMSTATUS wStat;
        wStat = m_ClusterNlbCfg.Update(&refNewConfig);
        if (FAILED(wStat))
        {
            nerr =  NLBERR_INTERNAL_ERROR;
        }

        return nerr;
    }

    // _bstr_t m_bstrId;      // Uniquely identifies this cluster in NLB Manager.
    _bstr_t m_bstrDisplayName; // Name use for display only (eg: "Cluster1");

    BOOL m_fMisconfigured; // Whether or not the cluster is misconfigured.

    BOOL m_fPending;       // Whether or not there is a pending operation on
                           // this cluster.
    BOOL m_fNewRctPassword; // A new remote-control password is specified
                            // As long as it is set, the dwHashedPassword
                            // value can not be trusted.

    //
    // List of interfaces that form this cluster.
    //
    vector<ENGINEHANDLE> m_ehInterfaceIdList;

    SYSTEMTIME m_timeLastUpdate;

    //
    // ClusterNlbCfg is the "official" NLB configuration for the cluster.
    // It is obtained from one of the hosts.
    //
    NLB_EXTENDED_CLUSTER_CONFIGURATION m_ClusterNlbCfg;

    //
    // The host that was last used to get the cluster config.
    //
    ENGINEHANDLE m_ehDefaultInterface;

    ENGINEHANDLE m_ehPendingOperation;
};



//
// Specification, or settings of a host. This includes the list of
// NLB compatible interfaces on the host, machine name, machine GUID,
// connection string, etc.
//
class CHostSpec // : private CNoCopy
{

public:

    CHostSpec(void)
      : m_fReal(FALSE),
      m_fUnreachable(FALSE),
      m_ConnectionIpAddress(0)
    {
        // can't do this! ZeroMemory(this, sizeof(*this));
    }

    ~CHostSpec()     {}

    void Copy(const CHostSpec &);

    BOOL m_fReal;          // Whether or not this host is known to correspond
                           // to real hosts.

    BOOL m_fUnreachable;   // Whether or not this host is contactable.
                           // to real hosts.

    //
    // List of NLB-compatible interfaces  (adapters) on this host.
    //
    vector<ENGINEHANDLE> m_ehInterfaceIdList;

    //
    // Connection info.
    //
    _bstr_t m_ConnectionString;
 	_bstr_t m_UserName;
 	_bstr_t m_Password;
    ULONG   m_ConnectionIpAddress; // in network byte order.

    _bstr_t m_MachineName;
    _bstr_t m_MachineGuid;


};


//
// Specification, or settings of a specific interface (adapter) on a specifc
// host. This includes the NLB configuration on that interface, ip addresses
// bound to the interface, friendly name of the interface, etc.
//
class CInterfaceSpec // : private CNoCopy
{

public:

    CInterfaceSpec(void)
    : m_fPending(FALSE),
      m_fMisconfigured(FALSE),
      m_fReal(FALSE),
      m_ehHostId(NULL),
      m_ehCluster(NULL),
      m_fValidClusterState(FALSE),
      m_ehPendingOperation(FALSE)
    {
        // can't do this! ZeroMemory(this, sizeof(*this));
    }
    ~CInterfaceSpec()     {}

    void Copy(const CInterfaceSpec &);

    ENGINEHANDLE m_ehHostId; // The ID of the host that owns this interface.
    ENGINEHANDLE m_ehCluster; // The ID of the cluster that this interface is
                            // a part of, if any.

    BOOL m_fPending;       // Whether or not there is a pending operation on
                           // this host.

    BOOL m_fMisconfigured; // Whether or not the cluster is misconfigured.

    BOOL m_fReal;          // Whether or not this cluster is known to correspond
                         // to real hosts.

    BOOL  m_fValidClusterState; // Whether or not the "m_dwClusterState" contains a valid value

    DWORD m_dwClusterState;     // Cluster State : If valid (ie. if m_fValidClusterState is TRUE) 
                                // One of WLBS_CONVERGING/CONVERGED/DEFAULT/DRAINING/STOPPED/SUSPENDED
    _bstr_t m_Guid;

    _bstr_t m_bstrMachineName; // Cache of the host name -- so we don't have to
                            // keep looking up the host info just for getting
                            // the host's name.

    NLB_EXTENDED_CLUSTER_CONFIGURATION m_NlbCfg;

    _bstr_t m_bstrStatusDetails; // Details (if any) of ongoing updates or
                                 // misconfiguration.

    ENGINEHANDLE m_ehPendingOperation;

};


//
// Abstract class (interface) for callbacks to the UI to provide status
// updates and logging etc...
//
class IUICallbacks
{

public:

    typedef enum
    {
        OBJ_INVALID=0,
        OBJ_CLUSTER,
        OBJ_HOST,
        OBJ_INTERFACE,
        OBJ_OPERATION

    } ObjectType;

    typedef enum
    {
        EVT_ADDED,
        EVT_REMOVED,
        EVT_STATUS_CHANGE,
        EVT_INTERFACE_ADDED_TO_CLUSTER,
        EVT_INTERFACE_REMOVED_FROM_CLUSTER

    } EventCode;


    typedef enum
    {
       LOG_ERROR,
       LOG_WARNING,
       LOG_INFORMATIONAL

    } LogEntryType;

    class LogEntryHeader
    {
    public:
        LogEntryHeader(void)
             : type(LOG_INFORMATIONAL),
               szCluster(NULL),
               szHost(NULL),
               szInterface(NULL),
               szDetails(NULL)
        {}

        LogEntryType    type;
        const wchar_t   *szCluster;     // OPTIONAL
        const wchar_t   *szHost;        // OPTIONAL
        const wchar_t   *szInterface;   // OPTIONAL
        const wchar_t   *szDetails;     // OPTIONAL

    };

    //
    // Asks the user to update user-supplied info about a host.
    //
    virtual 
    BOOL
    UpdateHostInformation(
        IN BOOL fNeedCredentials,
        IN BOOL fNeedConnectionString,
        IN OUT CHostSpec& host
    ) = NULL;


    //
    // Log a message in human-readable form.
    //
    virtual
    void
    Log(
        IN LogEntryType     Type,
        IN const wchar_t    *szCluster, OPTIONAL
        IN const wchar_t    *szHost, OPTIONAL
        IN UINT ResourceID,
        ...
    ) = NULL;

    virtual
    void
    LogEx(
        IN const LogEntryHeader *pHeader,
        IN UINT ResourceID,
        ...
    ) = NULL;

    //
    // Handle an event relating to a specific instance of a specific
    // object type.
    //
    virtual
    void
    HandleEngineEvent(
        IN ObjectType objtype,
        IN ENGINEHANDLE ehClusterId, // could be NULL
        IN ENGINEHANDLE ehObjId,
        IN EventCode evt
        ) = NULL;

};


//
// Used internally by CNlbEngine
//
class CEngineCluster
{
public:

    CEngineCluster(VOID)
    {
    }
            
    ~CEngineCluster() {};

    CClusterSpec m_cSpec;
};

class CEngineOperation
{

public:

    CEngineOperation(ENGINEHANDLE ehOp, ENGINEHANDLE ehObj, PVOID pvCtxt)
    : ehOperation(ehOp),
      ehObject(ehObj),
      pvContext(pvCtxt),
      fCanceled(FALSE)
    {}

    ~CEngineOperation()
    {
    }

    ENGINEHANDLE ehOperation;
    ENGINEHANDLE ehObject;

    _bstr_t     bstrDescription;
    BOOL        fCanceled;
    PVOID       pvContext;
};

class CNlbEngine
{

public:

    CNlbEngine(void)
    :   m_pCallbacks(NULL),
        m_NewHandleValue(1),
        m_fHandleOverflow(FALSE),
        m_fDeinitializing(FALSE),
        m_fPrepareToDeinitialize(FALSE),
        m_WorkItemCount(0)

    {
        InitializeCriticalSection(&m_crit);
    }

    ~CNlbEngine()
    {
        ASSERT(m_WorkItemCount > 0);
        DeleteCriticalSection(&m_crit);
    }

    NLBERROR
    Initialize(
        IN IUICallbacks & ui,
        BOOL fDemo,
        BOOL fNoPing
        ); // logging, UI callbacks of various kinds.

    void
    Deinitialize(void);

    //
    // Called to indicate that deinitialization will soon follow.
    // After return from this call, the engine will not create any new
    // objects -- interface, host, cluster, operations or start operations.
    // The engine may however continue to call the UI callback routines.
    //
    void
    PrepareToDeinitialize(void)
    {
        m_fPrepareToDeinitialize = TRUE;
    }

    NLBERROR
    ConnectToHost(
        IN  PWMI_CONNECTION_INFO pConnInfo,
        IN  BOOL  fOverwriteConnectionInfo,
        OUT ENGINEHANDLE &ehHost,
        OUT _bstr_t &bstrError
        );

    NLBERROR
    LookupClusterByIP(
        IN  LPCWSTR szIP,
        IN  const NLB_EXTENDED_CLUSTER_CONFIGURATION *pInitialConfig OPTIONAL,
        OUT ENGINEHANDLE &ehCluster,
        OUT BOOL &fIsNew
        );
        //
        // if pInitialConfig is NULL we'll lookup and not try to create.
        // if not NULL and we don't find an existing cluster, well create
        // a new one and initialize it with the specified configuration.
        //

    NLBERROR
    LookupInterfaceByIp(
        IN  ENGINEHANDLE    ehHost, // OPTIONAL  -- if NULL all hosts are looked
        IN  LPCWSTR         szIpAddress,
        OUT ENGINEHANDLE    &ehIf
        );

    NLBERROR
    LookupConnectionInfo(
        IN  LPCWSTR szConnectionString,
        OUT _bstr_t &bstrUsername,
        OUT _bstr_t &bstrPassword
        );

    void
    DeleteCluster(IN ENGINEHANDLE ehCluster, BOOL fRemoveInterfaces);

    NLBERROR
    AutoExpandCluster(
        IN ENGINEHANDLE ehCluster
        );


    NLBERROR
    AddInterfaceToCluster(
        IN ENGINEHANDLE ehCluster,
        IN ENGINEHANDLE ehInterface
        );

    NLBERROR
    RemoveInterfaceFromCluster(
        IN ENGINEHANDLE ehCluster,
        IN ENGINEHANDLE ehInterface
        );

    NLBERROR
    RefreshAllHosts(
        void
        );

    NLBERROR
    RefreshCluster(
        IN ENGINEHANDLE ehCluster
        );

#if OBSOLETE
    NLBERROR
    RefreshInterfaceOld(
        IN ENGINEHANDLE ehInterface,
        IN BOOL fRemoveFromClusterIfUnbound,
        IN OUT BOOL &fClusterPropertiesUpdated
        );
#endif // OBSOLETE

    //
    // Queries the host that owns the interface for other
    // cluster members, and connects to those and adds those
    // members to the cluster.
    //
    // If (fSync) it will do this synchronously, else it will do it
    // in the background.
    //
    VOID
    AddOtherClusterMembers(
        IN ENGINEHANDLE ehInterface,
        IN BOOL fSync
        );

    //
    // Only call this from the background thread work item thread
    // (i.e., not really a public function, but I don't like using
    // "friend").
    //
    VOID
    AddOtherClusterMembersWorkItem(
        IN ENGINEHANDLE ehInterface
        );

    NLBERROR
    RefreshInterface(
        IN ENGINEHANDLE ehInterface,
        IN BOOL fNewOperation,
        IN BOOL fClusterWide
        );

    NLBERROR
    AnalyzeCluster(
        const ENGINEHANDLE ehCluster
    );
    NLBERROR
    GetHostSpec(
        IN ENGINEHANDLE ehHost,
        OUT CHostSpec& HostSpec
        );

    NLBERROR
    GetHostConnectionInformation(
        IN  ENGINEHANDLE ehHost,
        OUT ENGINEHANDLE &ehConnectionIF,
        OUT _bstr_t      &bstrConnectionString,
        OUT UINT         &uConnectionIp
        );

    NLBERROR
    GetClusterSpec(
        IN ENGINEHANDLE ehCluster,
        OUT CClusterSpec& ClusterSpec
        );


    NLBERROR
    GetInterfaceSpec(
        IN ENGINEHANDLE ehInterface,
        OUT CInterfaceSpec&
        );

    NLBERROR
    UpdateInterface(
        IN ENGINEHANDLE ehInterface,
        IN NLB_EXTENDED_CLUSTER_CONFIGURATION &refNewConfig,
        // IN OUT BOOL &fClusterPropertiesUpdated,
        OUT CLocalLogger logConflict
        );

    NLBERROR
    UpdateCluster(
        IN ENGINEHANDLE ehCluster,
        IN const NLB_EXTENDED_CLUSTER_CONFIGURATION *pNewConfig OPTIONAL,
        IN OUT  CLocalLogger   &logConflict
        );

    
    NLBERROR
    EnumerateClusters(
        OUT vector <ENGINEHANDLE> & ehClusterList
        );

    NLBERROR
    EnumerateHosts(
        OUT vector <ENGINEHANDLE> & ehHostList
        );

    BOOL
    GetObjectType(
        IN  ENGINEHANDLE ehObj,
        OUT IUICallbacks::ObjectType &objType
        );
    
    //
    // Return a bitmap of available host IDs for the specified cluster.
    //
    ULONG
    GetAvailableHostPriorities(
            ENGINEHANDLE ehCluster // OPTIONAL
            );


    //
    // Fill in an array of bitmaps of available priorities for each specified
    // port rule.
    //
    NLBERROR
    GetAvailablePortRulePriorities(
                IN ENGINEHANDLE    ehCluster, OPTIONAL
                IN UINT            NumRules,
                IN WLBS_PORT_RULE  rgRules[],
                IN OUT ULONG       rgAvailablePriorities[] // At least NumRules
                );

    NLBERROR
    GetAllHostConnectionStrings(
                OUT vector <_bstr_t> & ConnectionStringList
                );

    NLBERROR
    ControlClusterOnInterface(
                IN ENGINEHANDLE          ehInterfaceId,
                IN WLBS_OPERATION_CODES  Operation,
                IN CString               szVipArray[],
                IN DWORD                 pdwPortNumArray[],
                IN DWORD                 dwNumOfPortRules,
                IN BOOL                  fNewOperation
                );

    NLBERROR
    ControlClusterOnCluster(
                IN ENGINEHANDLE          ehClusterId,
                IN WLBS_OPERATION_CODES  Operation,
                IN CString               szVipArray[],
                IN DWORD                 pdwPortNumArray[],
                IN DWORD                 dwNumOfPortRules
                );

    NLBERROR
    FindInterfaceOnHostByClusterIp(
                IN  ENGINEHANDLE ehHostId,
                IN  LPCWSTR szClusterIp,    // OPTIONAL
                OUT ENGINEHANDLE &ehInterfaceId, // first found
                OUT UINT &NumFound
                );

    NLBERROR
    InitializeNewHostConfig(
                IN  ENGINEHANDLE          ehClusterId,
                OUT NLB_EXTENDED_CLUSTER_CONFIGURATION &NlbCfg
                );

    static // TODO: move somewhere else -- more a utility function.
    NLBERROR
    ApplyClusterWideConfiguration(
        IN      const NLB_EXTENDED_CLUSTER_CONFIGURATION &ClusterConfig,
        IN OUT       NLB_EXTENDED_CLUSTER_CONFIGURATION &ConfigToUpdate
        );


    NLBERROR
    GetInterfaceInformation(
        IN  ENGINEHANDLE    ehInterface,
        OUT CHostSpec&      hSpec,
        OUT CInterfaceSpec& iSpec,
        OUT _bstr_t&        bstrDisplayName,
        OUT INT&            iIcon,
        OUT _bstr_t&        bstrStatus
        );


    NLBERROR
    GetInterfaceIdentification(
        IN  ENGINEHANDLE    ehInterface,
        OUT ENGINEHANDLE&   ehHost,
        OUT ENGINEHANDLE&   ehCluster,
        OUT _bstr_t &       bstrFriendlyName,
        OUT _bstr_t &       bstrDisplayName,
        OUT _bstr_t &       bstrHostName
        );


    NLBERROR
    GetClusterIdentification(
        IN  ENGINEHANDLE    ehCluster,
        OUT _bstr_t &       bstrIpAddress, 
        OUT _bstr_t &       bstrDomainName, 
        OUT _bstr_t &       bstrDisplayName
        );


    //
    // Verify that the specified ip address may be used as a new cluster IP
    // address for the specified existing cluster ehCluster (or a new
    // cluster, if ehCluster is NULL).
    //
    // If there is no conflict (i.e. address can be used), the function returns
    // NLBERR_OK.
    //
    // If the IP address is already used for something, that "something"
    // is specified in logConflict and the function returns
    // NLBERR_INVALID_IP_ADDRESS_SPECIFICATION.
    //
    // If the IP address already exists on an interface that is NOT
    // part of a cluster known to NLBManager, fExistOnRawInterface is set
    // to TRUE, else fExistOnRawInterface is set to FALSE.
    //
    NLBERROR
    ValidateNewClusterIp(
        IN      ENGINEHANDLE    ehCluster,  // OPTIONAL
        IN      LPCWSTR         szIp,
        OUT     BOOL           &fExistsOnRawIterface,
        IN OUT  CLocalLogger   &logConflict
        );


    //
    // Verify that the specified ip address may be used as the dedicated IP
    // address for the specified existing interface.
    //
    // If there is no conflict (i.e. address can be used), the function returns
    // NLBERR_OK.
    //
    // If the IP address is already used for something, that "something"
    // is specified in logConflict and the function returns
    // NLBERR_INVALID_IP_ADDRESS_SPECIFICATION.
    //
    NLBERROR
    ValidateNewDedicatedIp(
        IN      ENGINEHANDLE    ehIF,
        IN      LPCWSTR         szIp,
        IN OUT  CLocalLogger   &logConflict
        );


    //
    // Updates the specified interface, assuming it has already been set up
    // to do an update in the background -- this function is ONLY
    // called from the work-item thread internally to CNlbEngine.
    //
    VOID
    UpdateInterfaceWorkItem(
        IN  ENGINEHANDLE ehIF
        );

    //
    // If it's possible to start an interface operation at this time,
    // the function returns NLB_OK, setting fCanStart to TRUE.
    //
    // If it can't start an interface, because there is an existing interface
    // operation or a cluster operation ongoing, the function returns NLB_OK,
    // and sets fCanStart to FALSE.
    //
    // Otherwise (some kind of error) it returns an error value.
    //
    NLBERROR
    CanStartInterfaceOperation(
        IN  ENGINEHANDLE ehIF,
        OUT BOOL &fCanStart
        );

    //
    // Similar to CanStartInterfaceOperation, except it applies to the specified
    // cluster.
    //
    NLBERROR
    CanStartClusterOperation(
        IN  ENGINEHANDLE ehCluster,
        OUT BOOL &fCanStart
        );

    UINT
    ListPendingOperations(
        CLocalLogger &logOperations
        );
    

    //
    // Mark all pending operations as cancelled.
    // If (fBlock), will block until no more operations are pending.
    //
    void
    CancelAllPendingOperations(
        BOOL fBlock
        );

    
    //
    // Attempts to connect to the specified host and manages
    // the specified cluster (szClusterIp) under nlb manager.
    // If szClusterIp is NULL, it will manage all clusters on the host.
    //
    NLBERROR
    LoadHost(
        IN  PWMI_CONNECTION_INFO pConnInfo,
        IN  LPCWSTR szClusterIp OPTIONAL
        );

    VOID
    AnalyzeInterface_And_LogResult(ENGINEHANDLE ehIID);


    //
    // Goes through all hosts, and deletes any that have no interface
    // that is being managed as a cluster in Nlbmgr.exe. Will skip (not delete)
    // hosts that have pending operations on them.
    //
    VOID
    PurgeUnmanagedHosts(void);

    VOID
    UnmanageHost(ENGINEHANDLE ehHost);

    private:


    IUICallbacks *m_pCallbacks;

	CRITICAL_SECTION m_crit;

    void mfn_Lock(void) {EnterCriticalSection(&m_crit);}
    void mfn_Unlock(void) {LeaveCriticalSection(&m_crit);}

    NLBERROR
    mfn_RefreshHost(
        IN  PWMI_CONNECTION_INFO pConnInfo,
        IN  ENGINEHANDLE ehHost,
        IN  BOOL  fOverwriteConnectionInfo
        );

    NLBERROR
    mfn_GetHostFromInterfaceLk(
          IN ENGINEHANDLE ehIId,
          OUT CInterfaceSpec* &pISpec,
          OUT CHostSpec* &pHSpec
          );

    void
    mfn_GetInterfaceHostNameLk(
      ENGINEHANDLE ehIId,
      _bstr_t &bstrHostName
      );

    NLBERROR
    mfn_LookupHostByNameLk(
        IN  LPCWSTR szHostName,
        IN  BOOL fCreate,
        OUT ENGINEHANDLE &ehHost,
        OUT CHostSpec*   &pHostSpec,
        OUT BOOL &fIsNew
        );


    NLBERROR
    mfn_LookupInterfaceByGuidLk(
        IN  LPCWSTR szInterfaceGuid,
        IN  BOOL fCreate,
        OUT ENGINEHANDLE &ehInterface,
        OUT CInterfaceSpec*   &pISpec,
        OUT BOOL &fIsNew
        );

    NLBERROR
    mfn_LookupInterfaceByIpLk(
        IN  ENGINEHANDLE    ehHost, // OPTIONAL  -- if NULL all hosts are looked
        IN  LPCWSTR         szIpAddress,
        OUT ENGINEHANDLE    &ehIf
        );

    VOID
    CNlbEngine::mfn_NotifyHostInterfacesChange(ENGINEHANDLE ehHost);

    VOID
    mfn_ReallyUpdateInterface(
        IN ENGINEHANDLE ehInterface,
        IN NLB_EXTENDED_CLUSTER_CONFIGURATION &refNewConfig
        // IN OUT BOOL &fClusterPropertiesUpdated
        );

    VOID
    mfn_GetLogStrings(
        IN   WLBS_OPERATION_CODES          Operation, 
        IN   LPCWSTR                       szVip,
        IN   DWORD                       * pdwPortNum,
        IN   DWORD                         dwOperationStatus, 
        IN   DWORD                         dwClusterOrPortStatus, 
        OUT  IUICallbacks::LogEntryType  & LogLevel,
        OUT  _bstr_t                     & OperationStr, 
        OUT  _bstr_t                     & OperationStatusStr, 
        OUT  _bstr_t                     & ClusterOrPortStatusStr
        );

    NLBERROR
    mfn_AnalyzeInterfaceLk(
        ENGINEHANDLE ehInterface,
        CLocalLogger &logger
    );

    NLBERROR
    mfn_ClusterOrInterfaceOperationsPendingLk(
        IN	CEngineCluster *pECluster,
        OUT BOOL &fCanStart
        );

    VOID
    mfn_DeleteHostIfNotManagedLk(
            ENGINEHANDLE ehHost
            );

	map< ENGINEHANDLE, CEngineCluster* > m_mapIdToEngineCluster;
	map< ENGINEHANDLE, CHostSpec* > m_mapIdToHostSpec;
	map< ENGINEHANDLE, CInterfaceSpec* > m_mapIdToInterfaceSpec;
	map< ENGINEHANDLE, CEngineOperation* > m_mapIdToOperation;


    //
    // Following is dummy...
    //
	map< _bstr_t, ENGINEHANDLE> m_mapHostNameToHostId;

    //
    // Used to create new handle values.
    // Incremented using InterlockedIncrement each time
    // a new handle value is reached.
    // 0 is an invalid handle value,
    //
    LONG m_NewHandleValue;
    BOOL m_fHandleOverflow;
    BOOL m_fDeinitializing;
    BOOL m_fPrepareToDeinitialize;

    //
    // Count of outstanding work items -- maintained by 
    // InterlockedIncrement/Decrement.
    // CancelAllPendingOperations waits for this count to go to zero
    // before returning.
    //
    // Also, the destructor blocks until this count goes to zero.
    //
    LONG m_WorkItemCount;

    ENGINEHANDLE
    mfn_NewHandleLk(IUICallbacks::ObjectType);

    void
    mfn_SetInterfaceMisconfigStateLk(
        IN  CInterfaceSpec *pIF,
        IN  BOOL fMisconfig,
        IN  LPCWSTR szMisconfigDetails
        );
    
    BOOL
    mfn_HostHasManagedClustersLk(CHostSpec *pHSpec);

    void
    mfn_UpdateInterfaceStatusDetails(ENGINEHANDLE ehIF, LPCWSTR szDetails);

    CEngineOperation *
    mfn_NewOperationLk(ENGINEHANDLE ehObj, PVOID pvCtxt, LPCWSTR szDescription);

    VOID
    mfn_DeleteOperationLk(ENGINEHANDLE ehOperation);

    CEngineOperation *
    mfn_GetOperationLk(ENGINEHANDLE ehOp);

    NLBERROR
    mfn_StartInterfaceOperationLk(
        IN  ENGINEHANDLE ehIF,
        IN  PVOID pvCtxt,
        IN  LPCWSTR szDescription,
        OUT ENGINEHANDLE *pExistingOperation
        );

    VOID
    mfn_StopInterfaceOperationLk(
        IN  ENGINEHANDLE ehIF
        );

    NLBERROR
    mfn_StartClusterOperationLk(
        IN  ENGINEHANDLE ehCluster,
        IN  PVOID pvCtxt,
        IN  LPCWSTR szDescription,
        OUT ENGINEHANDLE *pExistingOperation
        );

    VOID
    mfn_StopClusterOperationLk(
        ENGINEHANDLE ehCluster
        );


    NLBERROR
    mfn_RefreshInterface(
        IN ENGINEHANDLE ehInterface
        );

    BOOL
    mfn_UpdateClusterProps(
        ENGINEHANDLE ehClusterId,
        ENGINEHANDLE ehIId
        );


    //
    // Waits for the count of pending operations on interfaces in this cluster
    // got go to zero.
    //
    NLBERROR
    mfn_WaitForInterfaceOperationCompletions(
        IN  ENGINEHANDLE ehCluster
        );


    //
    // Verifies that all interfaces and the cluster have the same cluster mode.
    //
    // Will fail if any interface is marked misconfigured or is
    // not bound to NLB. 
    //
    // On returning success, fSameMode is set to TRUE iff all IFs and the
    // cluster have the same mode.
    //
    NLBERROR
    mfn_VerifySameModeLk(
        IN  ENGINEHANDLE    ehCluster,
        OUT BOOL            &fSameMode
        );

    //
    // Check connectivity to the host. If not available mark
    // it as such. Update the UI.
    //
    NLBERROR
    mfn_CheckHost(
        IN PWMI_CONNECTION_INFO pConnInfo,
        IN ENGINEHANDLE ehHost // OPTIONAL
        );

    VOID
    mfn_UnlinkHostFromClusters(
        IN ENGINEHANDLE ehHost
        );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\engine.cpp ===
//***************************************************************************
//
//  ENGINE.CPP
// 
//  Module: NLB Manager (client-side exe)
//
//  Purpose:  Implements the engine used to operate on groups of NLB hosts.
//          This file has no UI aspects.
//
//  Copyright (c)2001 Microsoft Corporation, All Rights Reserved
//
//  History:
//
//  07/25/01    JosephJ Created
//
//***************************************************************************
#include "precomp.h"
#pragma hdrstop
#include "AboutDialog.h"
#include "private.h"

#include "engine.tmh"

//
// ENGINEHANDLE incodes the type of the object -- the following constant
// is the number of bits used to encode the type.
//
#define TYPE_BIT_COUNT 0x3


BOOL
validate_extcfg(
    const NLB_EXTENDED_CLUSTER_CONFIGURATION &Config
    );


BOOL
get_used_port_rule_priorities(
    IN const NLB_EXTENDED_CLUSTER_CONFIGURATION &Config,
    IN UINT                 NumRules,
    IN const WLBS_PORT_RULE rgRules[],
    IN OUT ULONG            rgUsedPriorities[] // At least NumRules
    );

const WLBS_PORT_RULE *
find_port_rule(
    const WLBS_PORT_RULE *pRules,
    UINT NumRules,
    LPCWSTR szVIP,
    UINT StartPort
    );

VOID
remove_dedicated_ip_from_nlbcfg(
        NLB_EXTENDED_CLUSTER_CONFIGURATION &ClusterCfg
        );

NLBERROR
analyze_nlbcfg(
        IN const    NLB_EXTENDED_CLUSTER_CONFIGURATION &NlbCfg,
        IN const    NLB_EXTENDED_CLUSTER_CONFIGURATION &OtherNlbCfg,
        IN          LPCWSTR         szOtherDescription,
        IN          BOOL            fClusterProps,
        IN          BOOL            fDisablePasswordCheck,
        IN OUT      CLocalLogger    &logger
        );


DWORD
WINAPI
UpdateInterfaceWorkItemRoutine(
  LPVOID lpParameter   // thread data
  );

DWORD
WINAPI
AddClusterMembersWorkItemRoutine(
  LPVOID lpParameter   // thread data
  );


void
CHostSpec::Copy(const CHostSpec &hs)
/*
    This is the copy operator. Need to make a copy of strings in embedded
    vectors.
*/
{
    *this = hs;
}

NLBERROR
CClusterSpec::Copy(const CClusterSpec &cs)
/*
    This is the copy operator. Need to munge the m_ClusterNlbCfg field.
    TODO: fix this hack.
    TODO: if we fail we leave CClusterSpec trashed!
*/
{
    NLBERROR nerr = NLBERR_INTERNAL_ERROR;

    m_ClusterNlbCfg.Clear();
    *this = cs; // non-trivial copy
    ZeroMemory(&m_ClusterNlbCfg, sizeof(m_ClusterNlbCfg));
    m_ClusterNlbCfg.Clear(); // TODO: please! cleanup NLB_EXTENDED...
    //
    // Copy over the cluster configuration.
    //
    {
        WBEMSTATUS wStat;

        wStat = m_ClusterNlbCfg.Update(&cs.m_ClusterNlbCfg);

        if (FAILED(wStat))
        {
            //
            // We've trashed m_ClusterNlbCfg -- set defaults.
            //
            CfgUtilInitializeParams(&m_ClusterNlbCfg.NlbParams);
    
            if (wStat == WBEM_E_OUT_OF_MEMORY)
            {
                nerr = NLBERR_RESOURCE_ALLOCATION_FAILURE;
            }
            else
            {
                //
                // We assume that it's because the cluster spec is invalid.
                //
                nerr = NLBERR_INVALID_CLUSTER_SPECIFICATION;
            }
        }
        else
        {
            nerr = NLBERR_OK;
        }
    }

    return nerr;
}

void
CInterfaceSpec::Copy(const CInterfaceSpec &is)
/*
    This is the copy operator. Need to munge the m_NlbCfg field.
    TODO: fix this hack.
    TODO: add return value (m_NlbCfg.Update now returns an error).
*/
{
    *this = is;
    ZeroMemory(&m_NlbCfg, sizeof(m_NlbCfg));
    m_NlbCfg.Update(&is.m_NlbCfg);
}


NLBERROR
CNlbEngine::Initialize(
    IN IUICallbacks & ui,
    BOOL fDemo,
    BOOL fNoPing
    )
{
    NLBERROR nerr = NLBERR_INTERNAL_ERROR;

    TRACE_INFO(L"-> %!FUNC! (bDemo=%lu)", fDemo);

    //
    // Enable the "SeLoadDriverPrivilege" privilege in the process access token.
    // This is needed in the case when the server is local (ie. same machine).
    // Do NOT check for the return value since this function will fail when called 
    // as a non-admin. It is not only ok but also necessary to ignore the failure of
    // this function because: 
    // 1. We already check in the wmi provider that the caller is an administrator on
    //    the server and if the privilege is enabled. This is why it is ok to ignore 
    //    failures in this function.
    // 2. Non-admins can run nlb manager. They only need to be admins on the server.
    //    This is why it is necessary to ignore failures in this function.
    //
    CfgUtils_Enable_Load_Unload_Driver_Privilege();

    WBEMSTATUS wStat = CfgUtilInitialize(FALSE, fNoPing);

    if (!FAILED(wStat))
    {
        mfn_Lock();
    
        //
        // Save away the callback object.
        //
        m_pCallbacks = &ui;
    
        mfn_Unlock();
    
        if (fDemo)
        {
            TRACE_CRIT("%!FUNC! RUNNING ENGINE IN DEMO MODE");
            NlbHostFake();
        }
          
        nerr = NLBERR_OK;
    }

    TRACE_INFO(L"<- %!FUNC!");
    return nerr;
}

void
CNlbEngine::Deinitialize(void)
// TODO: cleanup
{
    TRACE_INFO(L"-> %!FUNC!");
    ASSERT(m_fPrepareToDeinitialize);
    // DummyAction(L"Engine::Deinitialize");
    TRACE_INFO(L"<- %!FUNC!");
    return;
}


NLBERROR
CNlbEngine::ConnectToHost(
    IN  PWMI_CONNECTION_INFO pConnInfo,
    IN  BOOL  fOverwriteConnectionInfo,
    OUT ENGINEHANDLE &ehHost,
    OUT _bstr_t &bstrError
    )
/*
    Connect the the host specfieid in pConnInfo (includes username and password)

    If (fOverwriteConnectionInfo) is true, then it will overwrite
    connection-info (connection string, connection IP, credentials)
    that pre-exists for this host with the stuff in pConnInfo.
*/
{
    NLBERROR nerr = NLBERR_INTERNAL_ERROR;
    LPWSTR szWmiMachineName = NULL;
    LPWSTR szWmiMachineGuid = NULL;
    WBEMSTATUS wStatus;
    ULONG uIpAddress;
    BOOL fNlbMgrProviderInstalled = FALSE;

    TRACE_INFO(L"-> %!FUNC!(%ws)", pConnInfo->szMachine);

    ehHost = NULL; 

    wStatus =  NlbHostPing(pConnInfo->szMachine, 2000, &uIpAddress);
    if (FAILED(wStatus))
    {
        nerr = NLBERR_PING_TIMEOUT; // todo more specific error.
        bstrError =  GETRESOURCEIDSTRING(IDS_PING_FAILED);
        goto end;
    }

    wStatus = NlbHostGetMachineIdentification(
                       pConnInfo,
                       &szWmiMachineName,
                       &szWmiMachineGuid,
                       &fNlbMgrProviderInstalled
                       );
    if (FAILED(wStatus))
    {
        GetErrorCodeText(wStatus, bstrError);
        if (wStatus ==  E_ACCESSDENIED)
        {
            nerr = NLBERR_ACCESS_DENIED;
        }
        else
        {
            // TODO: map proper errors.
            nerr = NLBERR_NOT_FOUND;
        }
        TRACE_CRIT(L"Connecting to %ws returns error %ws",
            pConnInfo->szMachine, (LPCWSTR) bstrError);
        szWmiMachineName = NULL;
        szWmiMachineGuid = NULL;
        goto end;
    }

    //
    //  We use the MachineName (TODO: replace by MachineGuid) as the
    //  primary key of Hosts.
    //
    {
        CHostSpec*   pHost = NULL;
        BOOL fIsNew = FALSE;
        ehHost = NULL;

        mfn_Lock();

        nerr =  mfn_LookupHostByNameLk(
                    szWmiMachineName,
                    TRUE, // create if needed
                    REF ehHost,
                    REF pHost,
                    REF fIsNew
                    );
        
        if (nerr != NLBERR_OK)
        {
            mfn_Unlock();
            goto end;
        }

        if (fIsNew)
        {
            pHost->m_fReal = FALSE; // set to true once the nics are populated.
            pHost->m_MachineGuid = _bstr_t(szWmiMachineGuid);
            pHost->m_ConnectionString = _bstr_t(pConnInfo->szMachine);
            pHost->m_ConnectionIpAddress = uIpAddress;
            pHost->m_UserName = _bstr_t(pConnInfo->szUserName);
            pHost->m_Password = _bstr_t(pConnInfo->szPassword);
        }

        mfn_Unlock();

    
        nerr = mfn_RefreshHost(
                pConnInfo,
                ehHost,
                fOverwriteConnectionInfo
                );
    }

end:

    delete szWmiMachineName;
    delete szWmiMachineGuid;
    
    return nerr;
}



void
CNlbEngine::DeleteCluster(
    IN ENGINEHANDLE ehCluster,
    IN BOOL fRemoveInterfaces)
{
    NLBERROR nerr =  NLBERR_INTERNAL_ERROR;
    vector<ENGINEHANDLE> RemovedInterfaces;

    TRACE_INFO(L"-> %!FUNC!(ehC=0x%lx)",ehCluster);
    mfn_Lock();

    do // while false
    {
        CEngineCluster *pECluster = m_mapIdToEngineCluster[ehCluster];
        CClusterSpec *pCSpec =  NULL;
        BOOL fEmptyCluster = FALSE;

        if  (pECluster == NULL)
        {
            // Invalid ehCluster
            TRACE_CRIT("%!FUNC! -- invalid ehCluster 0x%lx",  ehCluster);
            break;
        }
        pCSpec = &pECluster->m_cSpec;
        fEmptyCluster = (pCSpec->m_ehInterfaceIdList.size()==0);

        //
        // fail if operations are pending on this cluster. We determine
        // this indirectly by checking if we're allowed to start a
        // cluster-wide operation, which will only succeed if 
        // there no ongoing operations on the cluster OR its interfaces.
        //
        BOOL fCanStart = FALSE;

        nerr = mfn_ClusterOrInterfaceOperationsPendingLk(
                    pECluster,
                    REF fCanStart
                    );
        if (NLBFAILED(nerr) || !fCanStart)
        {
            TRACE_CRIT("%!FUNC! Not deleting cluster eh0x%lx because of pending activity.",
                   ehCluster);
            
            nerr = NLBERR_OTHER_UPDATE_ONGOING;
            break;
        }

        if (!fEmptyCluster)
        {
            if (!fRemoveInterfaces)
            {
                TRACE_CRIT("%!FUNC! Not deleting cluster eh0x%lx because it's not empty",
                   ehCluster);
                break;
            }

            RemovedInterfaces = pCSpec->m_ehInterfaceIdList; // vector copy

            //
            // We unlink all the interfaces from this cluster.
            //
            while(!pCSpec->m_ehInterfaceIdList.empty())
            {
                vector <ENGINEHANDLE>::iterator iItem
                             = pCSpec->m_ehInterfaceIdList.begin();
                ENGINEHANDLE ehIF = *iItem;
                CInterfaceSpec *pISpec = NULL;

                //
                // Unlink the interface from the cluster.
                // (this is with the lock held)
                //
                pISpec =  m_mapIdToInterfaceSpec[ehIF]; // map
                if (pISpec != NULL)
                {
                    if (pISpec->m_ehCluster == ehCluster)
                    {
                        pISpec->m_ehCluster = NULL;

                        //
                        // Delete the host and its interfaces if
                        // none of them are managed by nlbmanager (i.e., show
                        // up as members of a cluster managed by nlbmgr).
                        //
                        mfn_DeleteHostIfNotManagedLk(pISpec->m_ehHostId);
                    }
                    else
                    {
                        TRACE_CRIT(L"ehC(0x%x) points to ehI(0x%x), but ehI points to different cluster ehC(0x%x)",
                            ehCluster, ehIF, pISpec->m_ehCluster);
                        ASSERT(!"Cluser/interface handle corruption!");
                    }
                }
                pCSpec->m_ehInterfaceIdList.erase(iItem);
            }
        }

        m_mapIdToEngineCluster.erase(ehCluster);
        delete pECluster;
        pECluster = NULL;
        nerr =  NLBERR_OK;


    } while (FALSE);
    
    mfn_Unlock();

    if (nerr == NLBERR_OK)
    {
        //
        // Notify the UI
        //


        for( int i = 0; i < RemovedInterfaces.size(); ++i )
        {
            ENGINEHANDLE ehIId =  RemovedInterfaces[i];
            m_pCallbacks->HandleEngineEvent(
                IUICallbacks::OBJ_INTERFACE,
                ehCluster,
                ehIId,
                IUICallbacks::EVT_INTERFACE_REMOVED_FROM_CLUSTER
                );
        }

        m_pCallbacks->HandleEngineEvent(
            IUICallbacks::OBJ_CLUSTER,
            ehCluster,
            ehCluster,
            IUICallbacks::EVT_REMOVED
            );
    }

    TRACE_INFO(L"<- %!FUNC!");
    return;
}

NLBERROR
CNlbEngine::AutoExpandCluster(
    IN ENGINEHANDLE ehClusterId
    )
{
    TRACE_INFO(L"-> %!FUNC!");

    TRACE_INFO(L"<- %!FUNC!");
    return NLBERR_OK;
}

NLBERROR
CNlbEngine::AddInterfaceToCluster(
    IN ENGINEHANDLE ehClusterId,
    IN ENGINEHANDLE ehInterfaceId
    )
{
    NLBERROR nerr =  NLBERR_INTERNAL_ERROR;
    ENGINEHANDLE ehIfId = ehInterfaceId; 

    TRACE_INFO(L"-> %!FUNC!");

    mfn_Lock();

    CInterfaceSpec *pISpec = NULL;
    CClusterSpec *pCSpec =  NULL;

    do  // while false
    {
        CEngineCluster *pECluster =  NULL;
        pECluster =  m_mapIdToEngineCluster[ehClusterId]; // map
        if (pECluster == NULL)
        {
            nerr = NLBERR_NOT_FOUND;
            TRACE_CRIT("%!FUNC! -- could not find cluster associated with id 0x%lx",
                    (UINT) ehClusterId
                    );
            break; 
        }
        pCSpec = &pECluster->m_cSpec;
        pISpec =  m_mapIdToInterfaceSpec[ehInterfaceId]; // map
    
        if (pISpec == NULL)
        {
            nerr = NLBERR_NOT_FOUND;
            TRACE_CRIT("%!FUNC! -- could not find interface associated with id 0x%lx",
                    (UINT) ehInterfaceId
                    );
            break; 
        }

        //
        // The interface is valid. Now push in the interface if it is not
        // already a part of the this cluster.
        //

        if (pISpec->m_ehCluster != NULL)
        {
            if (pISpec->m_ehCluster != ehClusterId)
            {
                //
                // We don't allow the same interface to be part of
                // two clusters!
                //
                nerr =  NLBERR_INTERNAL_ERROR;
                TRACE_CRIT("%!FUNC! -- Interface eh 0x%lx is a member of an other cluster eh0x%lx.", ehIfId, pISpec->m_ehCluster);
                break;
            }
        }

        //
        // Note: find is a pre-defined template function.
        //
        if(find(
             pCSpec->m_ehInterfaceIdList.begin(),
             pCSpec->m_ehInterfaceIdList.end(),
             ehIfId
             ) !=  pCSpec->m_ehInterfaceIdList.end())
        {
            // item already exists.
            // for now we'll ignore this.
            if (pISpec->m_ehCluster != ehClusterId)
            {
                TRACE_CRIT("%!FUNC! -- ERROR Interface eh 0x%lx  ehCluster doesn't match!", ehIfId);
                nerr =  NLBERR_INTERNAL_ERROR;
                break;
            }
        }
        else
        {
            pISpec->m_ehCluster = ehClusterId;
            pCSpec->m_ehInterfaceIdList.push_back(ehIfId);
        }
        nerr = NLBERR_OK;


    } while (FALSE);

    mfn_Unlock();

    if (nerr == NLBERR_OK)
    {
        //
        // Inform the UI of the addition of a new interface under the
        // specified cluster.
        //
        m_pCallbacks->HandleEngineEvent(
            IUICallbacks::OBJ_INTERFACE,
            ehClusterId,
            ehInterfaceId,
            IUICallbacks::EVT_INTERFACE_ADDED_TO_CLUSTER
            );
        
    }


    TRACE_INFO(L"<- %!FUNC! returns 0x%lx", nerr);
    return nerr;
}

NLBERROR
CNlbEngine::RemoveInterfaceFromCluster(
    IN ENGINEHANDLE ehClusterId,
    IN ENGINEHANDLE ehIfId
    )
{
    NLBERROR nerr =  NLBERR_INTERNAL_ERROR;
    TRACE_INFO(L"-> %!FUNC!");
    BOOL fEmptyCluster = FALSE; // TRUE IFF no more interfaces in cluster.

    mfn_Lock();

    CInterfaceSpec *pISpec = NULL;
    CClusterSpec *pCSpec =  NULL;

    do  // while false
    {
        CEngineCluster *pECluster =  m_mapIdToEngineCluster[ehClusterId]; // map

        if (pECluster == NULL)
        {
            nerr = NLBERR_NOT_FOUND;
            TRACE_CRIT("%!FUNC! -- could not find cluster associated with id 0x%lx",
                    (UINT) ehClusterId
                    );
            break; 
        }
        pCSpec = &pECluster->m_cSpec;
        pISpec =  m_mapIdToInterfaceSpec[ehIfId]; // map
    
        if (pISpec == NULL)
        {
            nerr = NLBERR_NOT_FOUND;
            TRACE_CRIT("%!FUNC! -- could not find interface associated with id 0x%lx",
                    (UINT) ehIfId
                    );
            break; 
        }
    
        vector <ENGINEHANDLE>::iterator iFoundItem;

        //
        // The interface is valid. No push in the interface if it is not
        // already a part of the this cluster.
        //

        //
        // Note: find is a pre-defined template function.
        //
        iFoundItem = find(
             pCSpec->m_ehInterfaceIdList.begin(),
             pCSpec->m_ehInterfaceIdList.end(),
             ehIfId
             );
        if (iFoundItem != pCSpec->m_ehInterfaceIdList.end())
        {
            // item exists, remove it.
            pCSpec->m_ehInterfaceIdList.erase(iFoundItem);
            
            if (pISpec->m_ehCluster != ehClusterId)
            {
                // shouldn't get here!
                ASSERT(FALSE);
                TRACE_CRIT("%!FUNC!: ERROR pISpec->m_ehCluster(0x%lx) != ehCluster(0x%lx)", pISpec->m_ehCluster, ehClusterId);
            }
            else
            {
                fEmptyCluster = (pCSpec->m_ehInterfaceIdList.size()==0);
                pISpec->m_ehCluster = NULL;
                if (pCSpec->m_ehDefaultInterface == ehIfId)
                {
                    //
                    // We're removing the interface whose properties are
                    // the basis of the cluser-wide view. 
                    //
                    pCSpec->m_ehDefaultInterface = NULL;
                }
                nerr =  NLBERR_OK;
            }
        }
        else
        {
            // item doesn't exist.
        }

    } while (FALSE);

    mfn_Unlock();

    if (nerr == NLBERR_OK)
    {
        //
        // Inform the UI of the removal of an interface under the
        // specified cluster.
        //
        m_pCallbacks->HandleEngineEvent(
            IUICallbacks::OBJ_INTERFACE,
            ehClusterId,
            ehIfId,
            IUICallbacks::EVT_INTERFACE_REMOVED_FROM_CLUSTER
            );

        if (fEmptyCluster)
        {
            //
            // The cluster is empty -- delete it.
            //
            this->DeleteCluster(ehClusterId, FALSE); // FALSE == don't remove IF.
        }
        
    }


    TRACE_INFO(L"<- %!FUNC!");
    return nerr;
}


NLBERROR
CNlbEngine::RefreshAllHosts(
    void
    )
{
    TRACE_INFO(L"-> %!FUNC!");
/*
    For each host in host map
        Get Adapter List
           - Delete all Interfaces that are no longer present
           - Add/Update all host infos, one by one.
    Do all this in the background.

*/
    TRACE_INFO(L"<- %!FUNC!");
    return NLBERR_OK;
}


NLBERROR
CNlbEngine::RefreshCluster(
    IN ENGINEHANDLE ehCluster
    )
{
    TRACE_INFO(L"-> %!FUNC!");
/*
    For each interface in cluster
       - Add/Update interface info, one by one.

*/
    TRACE_INFO(L"<- %!FUNC!");
    return NLBERR_OK;
}


NLBERROR
CNlbEngine::mfn_RefreshInterface(
    IN ENGINEHANDLE ehInterface
    )
/*
   Add/Update interface info, deleting interface info if it's no longer there.
    Take/share code from RefreshHost


    Get host connection string.
    Get szNicGuid.
    Ping host.
    GetClusterConfiguration.
    Update.
    Notify UI of status change.
*/
{
    CLocalLogger logger;
    NLBERROR            nerr = NLBERR_INTERNAL_ERROR;
    WBEMSTATUS          wStatus = WBEM_E_CRITICAL_ERROR;
    ULONG               uIpAddress=0;
    WMI_CONNECTION_INFO ConnInfo;
    NLB_EXTENDED_CLUSTER_CONFIGURATION  NlbCfg; // class
    LPCWSTR             szNic = NULL;
    _bstr_t             bstrUserName;
    _bstr_t             bstrPassword;
    _bstr_t             bstrConnectionString;
    _bstr_t             bstrNicGuid;
    _bstr_t             bstrHostName;
    BOOL                fMisconfigured = FALSE;
    LPCWSTR             szHostName = NULL;
    ENGINEHANDLE        ehHost;
    BOOL                fCheckHost = FALSE;

    TRACE_INFO(L"-> %!FUNC! (ehIF=0x%lx)", (UINT) ehInterface);

    ZeroMemory(&ConnInfo, sizeof(ConnInfo));

    //
    // Get connection info from the interface's host.
    //
    {
        mfn_Lock();

        CHostSpec *pHSpec =  NULL;
        CInterfaceSpec *pISpec =  NULL;
    
        nerr = this->mfn_GetHostFromInterfaceLk(ehInterface,REF pISpec, REF pHSpec);
    
        if (nerr != NLBERR_OK)
        {
            TRACE_CRIT("%!FUNC!: ERROR couldn't get info on this if id!");
            mfn_Unlock();
            goto end;
        }
    
        //
        // We must make copies here because once we unlock
        // we don't know what's going to happen to pHSpec.
        //
        bstrUserName = pHSpec->m_UserName;
        bstrPassword = pHSpec->m_Password;
        bstrConnectionString  = pHSpec->m_ConnectionString;
        bstrNicGuid = pISpec->m_Guid;
        bstrHostName = pHSpec->m_MachineName;
        ehHost  = pISpec->m_ehHostId;

        //
        // If the host was previously marked unreachable, we'll
        // try to check again if it's there (and update it's state).
        //
        fCheckHost =  pHSpec->m_fUnreachable;

        mfn_Unlock();
    }

    ConnInfo.szUserName = (LPCWSTR) bstrUserName;
    ConnInfo.szPassword = (LPCWSTR) bstrPassword;
    ConnInfo.szMachine =  (LPCWSTR) bstrConnectionString;

    if (fCheckHost)
    {
        nerr = mfn_CheckHost(&ConnInfo, ehHost);
        if (NLBFAILED(nerr))
        {
            goto end;
        }
    }

    szNic = (LPCWSTR) bstrNicGuid;
    szHostName = (LPCWSTR) bstrHostName;


    wStatus =  NlbHostPing(ConnInfo.szMachine, 2000, &uIpAddress);
    if (FAILED(wStatus))
    {

        m_pCallbacks->Log(
            IUICallbacks::LOG_ERROR,
            NULL, // szCluster
            szHostName,
            IDS_LOG_PING_FAILED,
            ConnInfo.szMachine
            );
        //
        // TODO update host
        //
        fMisconfigured = TRUE;
        logger.Log(IDS_LOG_COULD_NOT_PING_HOST);
    }
    else
    {

        wStatus = NlbHostGetConfiguration(
                    &ConnInfo,
                    szNic,
                    &NlbCfg
                    );

        if (FAILED(wStatus))
        {
            TRACE_CRIT(L"%!FUNC! Error reading extended configuration for %ws\n", szNic);
            m_pCallbacks->Log(
                IUICallbacks::LOG_ERROR,
                NULL, // szCluster
                szHostName,
                IDS_LOG_COULD_NOT_GET_IF_CONFIG,
                szNic,
                (UINT) wStatus
                );
            fMisconfigured = TRUE;
            logger.Log(IDS_LOG_COULD_NOT_READ_IF_CONFIG);
        }
    }


    //
    // Now that we've read the latest cfg info onto NlbCfg, let's update it
    // (or mark the IF as misconfigured if there's been an error.)
    //
    {
        CInterfaceSpec *pISpec = NULL;
        mfn_Lock();
        pISpec =  m_mapIdToInterfaceSpec[ehInterface]; // map
        if (pISpec != NULL)
        {
            pISpec->m_fReal = TRUE;
            if (!fMisconfigured)
            {
                wStatus = pISpec->m_NlbCfg.Update(&NlbCfg);
                if (FAILED(wStatus))
                {
                    TRACE_CRIT("%!FUNC! error updating nlbcfg for eh%lx", ehInterface);
                    fMisconfigured = TRUE;
                    logger.Log(IDS_LOG_FAILED_UPDATE);
                }

                //
                // Update the host's connection IP address
                //
                if (uIpAddress != 0)
                {
                    CHostSpec *pHSpec =  NULL;
                    CInterfaceSpec *pTmpISpec = NULL;
                    nerr = this->mfn_GetHostFromInterfaceLk(
                                    ehInterface,
                                    REF pTmpISpec,
                                    REF pHSpec
                                    );

                    if (nerr == NLBERR_OK)
                    {
                        pHSpec->m_ConnectionIpAddress = uIpAddress;
                    }
                }
            }

            //
            // Set/clear the misconfiguration state.
            //
            {
                LPCWSTR szDetails = NULL;
                UINT Size = 0;

                if (fMisconfigured)
                {
                    logger.ExtractLog(szDetails, Size);
                }
                mfn_SetInterfaceMisconfigStateLk(pISpec, fMisconfigured, szDetails);
            }
        }
        mfn_Unlock();
    }

    if (fMisconfigured)
    {
        //
        // We couldn't read the latest settings for some reason --
        // check connectivity to the host and update the host status if
        // necessary.
        //
        nerr = mfn_CheckHost(&ConnInfo, ehHost);
        if (NLBOK(nerr))
        {
           //
           // We still want to fail this because we couldn't get
           // the updated configuration.
           //
           nerr = NLBERR_INVALID_CLUSTER_SPECIFICATION; 
        }
    }
    else
    {
        nerr = NLBERR_OK;
    }

end:

    TRACE_INFO(L"<- %!FUNC!");
    return nerr;
}


NLBERROR
CNlbEngine::RefreshInterface(
    IN ENGINEHANDLE ehInterface,
    IN BOOL fNewOperation,
    IN BOOL fClusterWide
    )
/*
   Add/Update interface info, deleting interface info if it's no longer there.
    Take/share code from RefreshHost


    Get host connection string.
    Get szNicGuid.
    Ping host.
    GetClusterConfiguration.
    Update.
    Notify UI of status change.
*/
{
    CLocalLogger    logger;
    NLBERROR        nerr            = NLBERR_INTERNAL_ERROR;
    BOOL            fMisconfigured  = FALSE;
    BOOL            fRemoveInterfaceFromCluster = FALSE;
    BOOL            fStopOperationOnExit = FALSE;
    ENGINEHANDLE    ehCluster = NULL;

    TRACE_INFO(L"-> %!FUNC! (ehIF=0x%lx)", (UINT) ehInterface);

    if (fNewOperation)
    {
        //
        // This function is to be run in the context of a NEW operation.
        // Verify that we can do a refresh at this time, and if so, start an
        // operation to track the refresh.
        //
    
        CInterfaceSpec *pISpec      =  NULL;

        mfn_Lock();
    
        pISpec =  m_mapIdToInterfaceSpec[ehInterface]; // map
    
        if (pISpec == NULL)
        {
            TRACE_CRIT("%!FUNC!: ERROR couldn't get info on this if id!");
            goto end_unlock;
        }

        if (!fClusterWide)
        {
            ehCluster   =  pISpec->m_ehCluster;
        
            if (ehCluster != NULL)
            {
                // 
                // Make sure that there's no pending cluster-wide operation
                // going on for the cluster that this IF is a part of.
                //
                CEngineCluster  *pECluster  = NULL;
                pECluster =  m_mapIdToEngineCluster[ehCluster]; // map
                if (pECluster != NULL)
                {
                    if (pECluster->m_cSpec.m_ehPendingOperation != NULL)
                    {
                        nerr = NLBERR_BUSY;
                        TRACE_CRIT("%!FUNC!: ehIF 0x%lx: Can't proceed because of existing op 0x%lx",
                             ehInterface,
                             pECluster->m_cSpec.m_ehPendingOperation
                             );
                        goto end_unlock;
                    }
                }
            }
        }

        //
        // Now try to start an operation...
        //
        {
            ENGINEHANDLE ExistingOp = NULL;
            nerr =  mfn_StartInterfaceOperationLk(
                       ehInterface,
                       NULL, // pvCtxt
                       GETRESOURCEIDSTRING(IDS_LOG_REFRESH_INTERFACE),
                       &ExistingOp
                       );
            if (NLBFAILED(nerr))
            {
                goto end_unlock;
            }

            //
            // We did start the operation -- so we keep track of this, so that
            // we stop the operation on exit.
            //

            fStopOperationOnExit = TRUE;
        }

        mfn_Unlock();
    }

    //
    // Here's where we actually refresh the interface.
    //
    nerr = mfn_RefreshInterface(ehInterface);
    if (!NLBOK(nerr))
    {
        mfn_Lock();
        goto end_unlock;
    }

    //
    // Now let's analyze the result ...
    //
    {
        CInterfaceSpec *pISpec   = NULL;

        mfn_Lock();

        pISpec =  m_mapIdToInterfaceSpec[ehInterface]; // map
        if (pISpec != NULL)
        {
            fMisconfigured = pISpec->m_fMisconfigured;
            ehCluster = pISpec->m_ehCluster;

            if (!fMisconfigured)
            {
                if (ehCluster != NULL)
                {
                    if (!pISpec->m_NlbCfg.IsNlbBound())
                    {
                        //
                        //  NLB is not bound on this interface --
                        // remove this interface from the cluster.
                        fRemoveInterfaceFromCluster = TRUE;
                    }
                    else
                    {
                        nerr = this->mfn_AnalyzeInterfaceLk(ehInterface, REF logger);
                        if (NLBFAILED(nerr))
                        {
                            fMisconfigured = TRUE;
                        }
                    }
                }

                //
                // Set the new misconfiguration state.
                //
                {
                    LPCWSTR szDetails = NULL;
                    UINT Size = 0;
    
                    if (fMisconfigured)
                    {
                        logger.ExtractLog(szDetails, Size);
                    }
                    mfn_SetInterfaceMisconfigStateLk(pISpec, fMisconfigured, szDetails);
                }
            }
        }
        mfn_Unlock();
    }

    if (fRemoveInterfaceFromCluster)
    {
        this->RemoveInterfaceFromCluster(ehCluster, ehInterface);
    }
    else
    {
        //
        // Report state 
        //
        if (fMisconfigured)
        {
            //
            // Log ...
            //
            LPCWSTR szDetails  = NULL;
            LPCWSTR szCluster  = NULL;
            LPCWSTR szHostName = NULL;
            LPCWSTR szInterface = NULL;
            UINT Size = 0;
        
            ENGINEHANDLE ehHost;
            _bstr_t        bstrDisplayName;
            _bstr_t        bstrFriendlyName;
            _bstr_t        bstrHostName;
            _bstr_t        bstrIpAddress;
            
            
            nerr = this->GetInterfaceIdentification(
                    ehInterface,
                    REF ehHost,
                    REF ehCluster,
                    REF bstrFriendlyName,
                    REF bstrDisplayName,
                    REF bstrHostName
                    );
    
            if (NLBOK(nerr))
            {

                _bstr_t bstrDomainName;
                _bstr_t bstrClusterDisplayName;
        
                nerr  = this->GetClusterIdentification(
                            ehCluster,
                            REF bstrIpAddress, 
                            REF bstrDomainName, 
                            REF bstrClusterDisplayName
                            );
                if (NLBOK(nerr))
                {
                    szCluster = bstrIpAddress;
                }

                szHostName = bstrHostName;
                szInterface = bstrFriendlyName;
            }


            logger.ExtractLog(szDetails, Size);
            IUICallbacks::LogEntryHeader Header;
            Header.szDetails = szDetails;
            Header.type = IUICallbacks::LOG_ERROR;
            Header.szCluster = szCluster;
            Header.szHost = szHostName;
            Header.szInterface = szInterface;

            m_pCallbacks->LogEx(
                &Header,
                IDS_LOG_INTERFACE_MISCONFIGURATION
                );
        }
        else
        {
            ControlClusterOnInterface( ehInterface, WLBS_QUERY, NULL, NULL, 0, FALSE);
        }

    }

    nerr = NLBERR_OK;
    mfn_Lock();

    //
    // Fall through ...
    //

end_unlock:

    if (fStopOperationOnExit)
    {
        mfn_StopInterfaceOperationLk(ehInterface);
    }

    mfn_Unlock();

    if (fStopOperationOnExit && !fRemoveInterfaceFromCluster)
    {
        //
        // Notify the UI of this update...
        // (but only if we've not already removed it from
        // the cluster!)
        //
        m_pCallbacks->HandleEngineEvent(
            IUICallbacks::OBJ_INTERFACE,
            ehCluster,
            ehInterface,
            IUICallbacks::EVT_STATUS_CHANGE
            );
    }

    TRACE_INFO(L"<- %!FUNC!");
    return nerr;
}


NLBERROR
CNlbEngine::AnalyzeCluster(
    ENGINEHANDLE ehClusterId
)
{
    TRACE_INFO(L"-> %!FUNC!");

/*
    TODO: consider doing this with a specific host in mind

    For each IF I1
        AnalyzeHost(host-of(I1))
        For each other IF I2
            AnalyzeTwoHosts(I1, I2)

    AnalyzeTwoHosts(I1, I2):
        - check that cluster params match
        - check that port rules are compatible
        - check that host properties do not collide.
        - check dedicated IP subnets match.

     AnalyzeHost(H1)
        For each IF I1
            AnalyzeSingleIf(I1) (including checking dedicated ips)


*/
    TRACE_INFO(L"<- %!FUNC!");
    return NLBERR_OK;
}

NLBERROR
CNlbEngine::mfn_AnalyzeInterfaceLk(
    ENGINEHANDLE ehInterface,
    CLocalLogger &logger
)
/*
    -- check interface props against cluster properties
    -- if cluster props match out,
        for each host id NOT marked fMisconfigured,
                check host properties.
    -- Does NOT mark fMisconfigured if error detected -- caller is expected
       to do so.
    -- Spews stuff to log regarding any misconfigurations.
*/
{
    NLBERROR nerr = NLBERR_INVALID_CLUSTER_SPECIFICATION;
    const CEngineCluster *pECluster =  NULL;
    const CInterfaceSpec *pISpec = NULL;
    BOOL  fIgnoreRctPassword = FALSE;
    TRACE_INFO(L"-> %!FUNC!");


    pISpec =  m_mapIdToInterfaceSpec[ehInterface]; // map
    if (pISpec == NULL)
    {
        nerr = NLBERR_INTERFACE_NOT_FOUND;
        goto end;
    }

    //
    // If interface is NOT part of a cluster, we're done.
    //
    if (pISpec->m_ehCluster == NULL)
    {
        TRACE_CRIT("ehIF 0x%lx m_ehCluster member is NULL!", ehInterface);
        goto end;
    }

    //
    // Check the interface against itself ...
    //
    {
        nerr = AnalyzeNlbConfiguration(REF pISpec->m_NlbCfg, logger);
        if (NLBFAILED(nerr))
        {
            goto end;
        }
    }

    //
    // Get the cluster data that this interface is a part of.
    //
    pECluster =  m_mapIdToEngineCluster[pISpec->m_ehCluster]; // map
    if (pECluster == NULL)
    {
        TRACE_CRIT(L"ehIF 0x%lx m_ehCluster member 0x%lx is INVALID!",
             ehInterface, pISpec->m_ehCluster);
        nerr = NLBERR_INTERNAL_ERROR;
        goto end;
    }

    //
    // Check interface against cluster.
    //
    fIgnoreRctPassword = pECluster->m_cSpec.m_fNewRctPassword;
    nerr = analyze_nlbcfg(
                REF pISpec->m_NlbCfg,
                REF pECluster->m_cSpec.m_ClusterNlbCfg,
                (LPCWSTR) GETRESOURCEIDSTRING(IDS_CLUSTER),
                // L"Cluster",
                TRUE, // TRUE == ClusterProps
                fIgnoreRctPassword, // TRUE==Disable RCT password check
                REF logger
                );

    if (NLBFAILED(nerr))
    {
        //
        // If analyzing against cluster props fails, we don't bother
        // analyzing against other hosts...
        //
        TRACE_CRIT(L"analyze_nlbcfg returns error 0x%lx", nerr);
        goto end;
    }

    //
    // Now check against all hosts before us in the list of hosts in the
    // cluster -- but only those that are not already marked misconfigured.
    // 
    //
    {
        const vector<ENGINEHANDLE> &InterfaceList = 
        pECluster->m_cSpec.m_ehInterfaceIdList;

        for( int i = 0; i < InterfaceList.size(); ++i )
        {
            ENGINEHANDLE ehIOther = InterfaceList[i];
            const CInterfaceSpec *pISpecOther = NULL;
            WCHAR rgOtherDescription[256];
            *rgOtherDescription = 0;


            if (ehIOther == ehInterface)
            {
                //
                // We've reached the interface being analyzed -- we don't
                // compare with any of the remaining interfaces.
                //
                break;
            }

            pISpecOther = m_mapIdToInterfaceSpec[ehIOther]; // map

            if (pISpecOther == NULL)
            {
                TRACE_CRIT("Unexpected: NULL pISpec for ehInterface 0x%lx",
                        ehIOther);
                continue;
            }

            //
            // We don't compare of the other interface is marked misconfigured,
            // or is not bound with NLB with valid nlb config data.
            //
            if (    pISpecOther->m_fMisconfigured
                 || !pISpecOther->m_NlbCfg.IsValidNlbConfig())
            {
                TRACE_VERB("%!FUNC!: Skipping misconfigured ISpec with ehInt 0x%lx",
                        ehIOther);
                continue;
            }

            // Skip the other interface if it's properties are being updated.
            //
            if  (pISpecOther->m_ehPendingOperation != NULL)
            {
                TRACE_VERB("%!FUNC!: Skipping ISpec with ehInt 0x%lx because of pending OP on it",
                        ehIOther);
                continue;
            }

            //
            // Create the description string of the other adapter.
            //
            {
                WBEMSTATUS wStat;
                LPWSTR szAdapter = NULL;
                LPCWSTR szHostName =  pISpecOther->m_bstrMachineName;
                wStat = pISpecOther->m_NlbCfg.GetFriendlyName(&szAdapter);
                if (FAILED(wStat))
                {
                    szAdapter = NULL;
                }
                
                StringCbPrintf(
                    rgOtherDescription,
                    sizeof(rgOtherDescription),
                    L"%ws(%ws)",
                    (szHostName==NULL ? L"" : szHostName),
                    (szAdapter==NULL ? L"" : szAdapter)
                    );
                delete szAdapter;
            }
    
            //
            // Let's check this host's config with the other host's
            //
            NLBERROR nerrTmp;
            nerrTmp = analyze_nlbcfg(
                        REF pISpec->m_NlbCfg,
                        REF pISpecOther->m_NlbCfg,
                        rgOtherDescription,
                        FALSE, // FALSE == Check host-specific props
                        FALSE, // FALSE == Enable remote-control password check
                        REF logger
                        );
            if (NLBFAILED(nerrTmp))
            {
                nerr = nerrTmp; // so we don't overwrite failure with success
            }
        }
    }

end:

    TRACE_INFO(L"<- %!FUNC! returns 0x%lx", nerr);
    return nerr;
}

NLBERROR
analyze_nlbcfg(
        IN const    NLB_EXTENDED_CLUSTER_CONFIGURATION &NlbCfg,
        IN const    NLB_EXTENDED_CLUSTER_CONFIGURATION &OtherNlbCfg,
        IN          LPCWSTR         szOtherDescription, OPTIONAL
        IN          BOOL            fClusterProps,
        IN          BOOL            fDisablePasswordCheck,
        IN OUT      CLocalLogger    &logger
/*
    Analyze the NLB configuration NlbCfg against OtherNlbCfg.
    If fClusterProps, treat OtherNlbCfg as cluster-wide props, else
    treat OtherNlbCfg as the properties of a specific host.

    When logging errors to logger, use szOtherDescription to refer to
    OtherNlbCfg.

    if szOtherDesctiption is NULL, DO NOT log.

    Return value:
         NLB_OK if the configurations are compatible.
         NLBERR_INVALID_CLUSTER_SPECIFICATION if the NlbParams are incompatible.
         NLBERR_INVALID_IP_ADDRESS_SPECIFICATION
         NLBERR_SUBNET_MISMATCH
         NLBERR_NLB_NOT_INSTALLED
         or some other NLBERR_XXX error

*/
)
{
    NLBERROR nerr = NLBERR_INVALID_CLUSTER_SPECIFICATION;
    BOOL fMisconfigured = FALSE; // Start out assuming no misconfig.

    #define LOG(_expr) if (szOtherDescription!=NULL) {_expr;}

    if (szOtherDescription != NULL)
    {
        //
        // We'll call ourselves RECURSIVELY just to determine up-front
        // if any conflicts were detected.
        // This is so we can put a log entry saying that conflicts were
        // detected with szOtherDescription.
        // Subsequent log entries do not specifiy szOtherDescription.
        //

        CLocalLogger null_logger;
        nerr = analyze_nlbcfg(          // RECURSIVE CALL
                    REF NlbCfg,
                    REF OtherNlbCfg,
                    NULL, // NULL == don't log.
                    fClusterProps,
                    fDisablePasswordCheck,
                    REF null_logger
                    );

        if (NLBFAILED(nerr))
        {
            //
            // There was a failure -- so we make a log entry saying so
            //
            logger.Log(IDS_LOG_CONFIG_CONFLICTS_WITH_OTHER, szOtherDescription);
        }
        else
        {
            // looks good...
            goto end;
        }
    }

    //
    // Check cluster properties
    //
    {
        if (NlbCfg.NlbParams.mcast_support != OtherNlbCfg.NlbParams.mcast_support)
        {
            LOG(logger.Log(IDS_LOG_CLUSTER_MODE_DIFFERS))
            fMisconfigured = TRUE;
        }
        else if (NlbCfg.NlbParams.mcast_support &&
            NlbCfg.NlbParams.fIGMPSupport != OtherNlbCfg.NlbParams.fIGMPSupport)
        {
            LOG(logger.Log(IDS_LOG_CLUSTER_MULTICAST_MODE_DIFFERS))
            fMisconfigured = TRUE;
        }

        if (wcscmp(NlbCfg.NlbParams.cl_ip_addr, OtherNlbCfg.NlbParams.cl_ip_addr))
        {
            LOG(logger.Log(IDS_LOG_CIP_DIFFERS))
            fMisconfigured = TRUE;
        }

        if (wcscmp(NlbCfg.NlbParams.cl_net_mask, OtherNlbCfg.NlbParams.cl_net_mask))
        {
            LOG(logger.Log(IDS_LOG_CIPMASK_DIFFERS))
            fMisconfigured = TRUE;
        }


        if (wcscmp(NlbCfg.NlbParams.domain_name, OtherNlbCfg.NlbParams.domain_name))
        {
            LOG(logger.Log(IDS_LOG_DOMAIN_NAME_DIFFERS))
            fMisconfigured = TRUE;
        }

        //
        // Remote control
        //
        if (NlbCfg.GetRemoteControlEnabled() != 
            OtherNlbCfg.GetRemoteControlEnabled())
        {
            LOG(logger.Log(IDS_LOG_RCT_DIFFERS))
            fMisconfigured = TRUE;
        }
        else if (NlbCfg.GetRemoteControlEnabled() && !fDisablePasswordCheck)
        {
            //
            // Check the password...
            //
            DWORD dw = CfgUtilGetHashedRemoteControlPassword(&NlbCfg.NlbParams);
            DWORD dw1=CfgUtilGetHashedRemoteControlPassword(&OtherNlbCfg.NlbParams);
            if (dw!=dw1)
            {
                LOG(logger.Log(IDS_LOG_RCT_PWD_DIFFERS, dw, dw1 ))
                fMisconfigured = TRUE;
            }
        }
    }


    //
    // Check port rules.
    //
    {
        WLBS_PORT_RULE *pIRules = NULL;
        WLBS_PORT_RULE *pCRules = NULL;
        UINT NumIRules=0;
        UINT NumCRules=0;

        WBEMSTATUS wStat;
        wStat =  CfgUtilGetPortRules(&NlbCfg.NlbParams, &pIRules, &NumIRules);
        if (FAILED(wStat))
        {
            LOG(logger.Log(IDS_LOG_CANT_EXTRACT_PORTRULES))
            fMisconfigured = TRUE;
            goto end;
        }
        wStat = CfgUtilGetPortRules(&OtherNlbCfg.NlbParams, &pCRules, &NumCRules);
        if (FAILED(wStat))
        {
            LOG(logger.Log(IDS_LOG_CANT_EXTRACT_OTHER_PORT_RULES, szOtherDescription))
            fMisconfigured = TRUE;
            goto end;
        }

        if (NumIRules != NumCRules)
        {
            LOG(logger.Log(IDS_LOG_PORT_RULE_COUNT_DIFFERS))

            // keep going.
            fMisconfigured = TRUE;

        }
        else
        {
            //
            // Let's assume that the order is the same, because I think it's
            // returned sorted.
            //
            for (UINT u = 0; u< NumIRules; u++)
            {
                WLBS_PORT_RULE  IRule = pIRules[u]; // struct copy
                WLBS_PORT_RULE  CRule = pCRules[u]; // struct copy

                if (lstrcmpi(IRule.virtual_ip_addr, CRule.virtual_ip_addr))
                {
                    LOG(logger.Log(IDS_LOG_PORT_RULE_CIP_DIFFERS,u+1))
                    fMisconfigured = TRUE;
                    continue;
                }

                if (IRule.start_port != CRule.start_port)
                {
                    LOG(logger.Log(IDS_LOG_PORT_RULE_START_DIFFERS, u+1))
                    fMisconfigured = TRUE;
                    continue;
                }

                if (IRule.end_port != CRule.end_port)
                {
                    LOG(logger.Log(IDS_LOG_PORT_RULE_END_DIFFERS, u+1))
                    fMisconfigured = TRUE;
                }

                if (IRule.protocol != CRule.protocol)
                {
                    LOG(logger.Log(IDS_LOG_PORT_RULE_PROT_DIFFERS, u+1))
                    fMisconfigured = TRUE;
                }

                if (IRule.mode != CRule.mode)
                {
                    LOG(logger.Log(IDS_LOG_PORT_RULE_MODE_DIFFERS, u+1))
                    fMisconfigured = TRUE;
                }

                if (IRule.mode == CVY_MULTI)
                {
                    // Check that affinity matches -- none/single/class-C
                    if (IRule.mode_data.multi.affinity != CRule.mode_data.multi.affinity)
                    {
                        LOG(logger.Log(IDS_LOG_PORT_RULE_AFFINITY_DIFFERS, u+1))
                        fMisconfigured = TRUE;
                    }
                }


                if (!fClusterProps && IRule.mode == CVY_SINGLE)
                {
                    if (IRule.mode_data.single.priority
                        == CRule.mode_data.single.priority)
                    {
                        LOG(logger.Log(IDS_LOG_PORT_RULE_PRIORITY_CONFLICT, u+1))
                        fMisconfigured =  TRUE;
                    }
                }
            }
        }

        delete[] pIRules;
        delete[] pCRules;
    }

    //
    // Interface checks out against the cluster-wide parameters;
    // Now check this interface's parameters against itself -- things
    // like the dedicated IP address is bound on the nic itself and is the
    // the first address on the NIC, etc.
    //
    if  (!fClusterProps)
    {
        if (!NlbCfg.IsBlankDedicatedIp())
        {
            if (!wcscmp(NlbCfg.NlbParams.ded_ip_addr, OtherNlbCfg.NlbParams.ded_ip_addr))
            {
                //
                // Same dedicated ip and it's not blank!
                //
                LOG(logger.Log(IDS_LOG_DIP_CONFLICT))
                fMisconfigured = TRUE;
            }
        }

        // Let's check host priority.
        if (NlbCfg.NlbParams.host_priority == OtherNlbCfg.NlbParams.host_priority)
        {
            LOG(logger.Log(IDS_LOG_HOST_PRIORITY_CONFLICT))
            fMisconfigured = TRUE;
        }
    }

    nerr = NLBERR_OK;

end:

    if (NLBOK(nerr) && fMisconfigured)
    {
        nerr = NLBERR_INVALID_CLUSTER_SPECIFICATION;
    }

    return nerr;
}




NLBERROR
CNlbEngine::GetInterfaceSpec(
    IN ENGINEHANDLE ehInterfaceId,
    OUT CInterfaceSpec& refISpec
    )
{
    // TRACE_INFO(L"-> %!FUNC!");
    NLBERROR err = NLBERR_OK;

    mfn_Lock();
    
    CInterfaceSpec *pISpec =  m_mapIdToInterfaceSpec[ehInterfaceId]; // map

    if (pISpec == NULL)
    {
        err = NLBERR_INTERFACE_NOT_FOUND;
    }
    else
    {
        refISpec.Copy(*pISpec);
    }

    mfn_Unlock();

    // TRACE_INFO(L"<- %!FUNC!");
    return err;
}


VOID
CNlbEngine::mfn_GetLogStrings(
    IN   WLBS_OPERATION_CODES          Operation, 
    IN   LPCWSTR                       szVip,
    IN   DWORD                       * pdwPortNum,
    IN   DWORD                         dwOperationStatus, 
    IN   DWORD                         dwClusterOrPortStatus, 
    OUT  IUICallbacks::LogEntryType  & LogLevel,
    OUT  _bstr_t                     & OperationStr, 
    OUT  _bstr_t                     & OperationStatusStr, 
    OUT  _bstr_t                     & ClusterOrPortStatusStr) 
{
    if (szVip && pdwPortNum) 
    {
        TRACE_INFO(L"-> %!FUNC! Operation : %d, Vip : %ls, Port : %u, Operation Status : %u, Port Status : %u", 
                                Operation, szVip, *pdwPortNum, dwOperationStatus, dwClusterOrPortStatus);
    }
    else
    {
        TRACE_INFO(L"-> %!FUNC! Operation : %d, Operation Status : %u, Cluster Status : %u", 
                                Operation, dwOperationStatus, dwClusterOrPortStatus);
    }

    struct STATUS_TO_DESCR_MAP
    {
        DWORD  dwStatus;
        DWORD  dwResourceId;
    }
    AllNlbStatusToDescrMap[] =
    {
        // Cluster States
        {WLBS_CONVERGING,         IDS_STATE_CONVERGING},// Converging
        {WLBS_CONVERGED,          IDS_STATE_CONVERGED}, // Converged as non-default, we do not specify "default"/"non-default" in the description 'cos there is a
        {WLBS_DEFAULT,            IDS_STATE_CONVERGED}, // Converged as default,     transient case where for a short duration, the default node shows up a non-default
        {WLBS_DRAINING,           IDS_STATE_CONVERGED_DRAINING}, // Converged, but draining

        // Port States
        {NLB_PORT_RULE_NOT_FOUND, IDS_PORT_RULE_NOT_FOUND}, 
        {NLB_PORT_RULE_ENABLED,   IDS_PORT_RULE_ENABLED},   
        {NLB_PORT_RULE_DISABLED,  IDS_PORT_RULE_DISABLED}, 
        {NLB_PORT_RULE_DRAINING,  IDS_PORT_RULE_DRAINING},

        // Operation Specific errors 
        {WLBS_SUSPENDED,          IDS_HOST_SUSPENDED}, // start/stop/drain_stop/enable/disable/drain/query-failure-host is suspended
        {WLBS_STOPPED,            IDS_HOST_STOPPED},   // enable/disable/drain/query-failure-host is already stopped
        {WLBS_BAD_PARAMS,         IDS_BAD_PARAMS},     // start-failure-host is stopped due to bad parameters
        {WLBS_NOT_FOUND,          IDS_NOT_FOUND},      // enable/disable/drain-failure-not found
        {WLBS_DISCONNECTED,       IDS_DISCONNECTED},   // query-failure-media disconnected

        // Generic errors
        {WLBS_BAD_PASSW,          IDS_BAD_PASSWORD},   // *-failure-Bad password
        {WLBS_FAILURE,            IDS_FAILURE},        // *-failure-critical error
        {WLBS_REFUSED,            IDS_REFUSED},        // *-failure-request refused by BDA
        {WLBS_IO_ERROR,           IDS_IO_ERROR},       // *-failure-error trying to connect to nlb driver

        // Success values
        {WLBS_OK,                 IDS_EMPTY_STRING},        // Success
        {WLBS_ALREADY,            IDS_ALREADY},        // host is already in this state
        {WLBS_DRAIN_STOP,         IDS_DRAIN_STOP},     // was draining
    };

    struct OPERATION_TO_DESCR_MAP
    {
        WLBS_OPERATION_CODES  Operation;
        DWORD                 dwResourceId;
        bool                  bClusterOperation;
    }
    OperationToDescrMap[] =
    {
        {WLBS_START,              IDS_COMMAND_START,              true},
        {WLBS_STOP,               IDS_COMMAND_STOP,               true},
        {WLBS_DRAIN,              IDS_COMMAND_DRAINSTOP,          true},
        {WLBS_SUSPEND,            IDS_COMMAND_SUSPEND,            true},
        {WLBS_RESUME,             IDS_COMMAND_RESUME,             true},
        {WLBS_QUERY,              IDS_COMMAND_QUERY,              true},
        {WLBS_PORT_ENABLE,        IDS_COMMAND_ENABLE,             false},
        {WLBS_PORT_DISABLE,       IDS_COMMAND_DISABLE,            false},
        {WLBS_PORT_DRAIN,         IDS_COMMAND_DRAIN,              false},
        {WLBS_QUERY_PORT_STATE,   IDS_COMMAND_QUERY_PORT,         false}
    };

    bool   bClusterOperation;
    DWORD  dwResourceId, dwIdx, dwClusterOrPortResourceId, dwMaxOperations;
    WCHAR  wcTempStr[1024];

    // Initialize log level to Informational
    LogLevel = IUICallbacks::LOG_INFORMATIONAL;

    // Initialize all return strings to empty string
    OperationStr = GETRESOURCEIDSTRING(IDS_EMPTY_STRING);
    OperationStatusStr = OperationStr;
    ClusterOrPortStatusStr = OperationStr;


    // Form the "Operation" string

    dwMaxOperations = sizeof(OperationToDescrMap)/sizeof(OperationToDescrMap[0]);

    for (dwIdx = 0; dwIdx < dwMaxOperations; dwIdx++)
    {
        if (OperationToDescrMap[dwIdx].Operation == Operation)
        {
            dwResourceId = OperationToDescrMap[dwIdx].dwResourceId;
            bClusterOperation = OperationToDescrMap[dwIdx].bClusterOperation;
            break;
        }
    }

    if (dwIdx == dwMaxOperations)
    {
        dwResourceId = IDS_UNKNOWN;
        bClusterOperation = true; // really a don't care
    }
         
    // If a cluster operation, merely assign the string, else (ie. port operation),
    // put in the vip & port information as well
    if (bClusterOperation) 
    {
        ARRAYSTRCPY(wcTempStr, GETRESOURCEIDSTRING(dwResourceId));
    }
    else // Port operation
    {
        if (_wcsicmp(szVip, CVY_DEF_ALL_VIP) == 0)
        {
            StringCbPrintf(
                wcTempStr,
                sizeof(wcTempStr),
                GETRESOURCEIDSTRING(dwResourceId), (LPWSTR)GETRESOURCEIDSTRING(IDS_ALL_VIP_DESCR), *pdwPortNum);
        }
        else
        {
            StringCbPrintf(
                 wcTempStr,
                 sizeof(wcTempStr),
                 GETRESOURCEIDSTRING(dwResourceId), szVip, *pdwPortNum);
        }
    }

    OperationStr = wcTempStr;

    // Form the "Operation Status" string
    // Could take one of the following forms :
    // SUCCESS,
    // SUCCESS (Note : XXXX),
    // FAILURE (Cause : XXXX)
    if (dwOperationStatus == WLBS_OK)
    {
        ARRAYSTRCPY(
            wcTempStr,
            GETRESOURCEIDSTRING(IDS_SUCCESS_AND_COMMA)
            );
    }
    else if (dwOperationStatus == WLBS_ALREADY)
    {
        if (bClusterOperation) 
        {
            dwResourceId = IDS_HOST_ALREADY_STATE;
        }
        else // Port operation
        {
            dwResourceId = IDS_PORT_ALREADY_STATE;
        }
        StringCbPrintf(
             wcTempStr,
             sizeof(wcTempStr),
             GETRESOURCEIDSTRING(IDS_SUCCESS_AND_NOTE), (LPWSTR)GETRESOURCEIDSTRING(dwResourceId)
            );
    }
    else if ((dwOperationStatus == WLBS_DRAIN_STOP) 
          && ((Operation == WLBS_START) || (Operation == WLBS_STOP) || (Operation == WLBS_SUSPEND))
            )
    {
        LogLevel = IUICallbacks::LOG_WARNING;
        StringCbPrintf(
            wcTempStr,
            sizeof(wcTempStr),
            GETRESOURCEIDSTRING(IDS_SUCCESS_AND_NOTE), (LPWSTR)GETRESOURCEIDSTRING(IDS_DRAIN_STOP)
            );
    }
    else if ((dwOperationStatus == WLBS_STOPPED) 
          && ((Operation == WLBS_DRAIN) || (Operation == WLBS_SUSPEND))
            )
    {
        LogLevel = IUICallbacks::LOG_WARNING;
        if (Operation == WLBS_DRAIN) 
        {
            dwResourceId = IDS_ALREADY_STOPPED;
        }
        else // Suspend
        {
            dwResourceId = IDS_HOST_STOPPED;
        }
        StringCbPrintf(
            wcTempStr,
            sizeof(wcTempStr),
            GETRESOURCEIDSTRING(IDS_SUCCESS_AND_NOTE), (LPWSTR)GETRESOURCEIDSTRING(dwResourceId)
            );
    }
    else // All other operation statuses
    {
        // We get here only on a failure

        LogLevel = IUICallbacks::LOG_ERROR;

        dwMaxOperations = sizeof(AllNlbStatusToDescrMap)/sizeof(AllNlbStatusToDescrMap[0]);

        // Get the "Cause" string
        for (dwIdx = 0; dwIdx < dwMaxOperations; dwIdx++)
        {
            if (AllNlbStatusToDescrMap[dwIdx].dwStatus == dwOperationStatus)
            {
                dwResourceId = AllNlbStatusToDescrMap[dwIdx].dwResourceId;
                break;
            }
        }

        if (dwIdx == dwMaxOperations)
        {
            dwResourceId = IDS_UNKNOWN;
        }

        StringCbPrintf(
            wcTempStr,
            sizeof(wcTempStr),
            GETRESOURCEIDSTRING(IDS_FAILURE_AND_CAUSE), (LPWSTR)GETRESOURCEIDSTRING(dwResourceId)
            );
    }

    OperationStatusStr = wcTempStr;

    // If the operation's status is failure, return
    if (LogLevel == IUICallbacks::LOG_ERROR) 
    {
        TRACE_INFO(L"<- %!FUNC!, returning operation status : failure");
        return;
    }

    // Get Cluster or Port Status
    if (bClusterOperation) 
    {
        dwClusterOrPortResourceId = IDS_HOST_STATE;
    }
    else // Port Operation
    {
        dwClusterOrPortResourceId = IDS_PORT_RULE_STATE;
    }

    // Get the "ClusterOrPortState" string

    dwMaxOperations = sizeof(AllNlbStatusToDescrMap)/sizeof(AllNlbStatusToDescrMap[0]);

    for (dwIdx = 0; dwIdx < dwMaxOperations; dwIdx++)
    {
        if (AllNlbStatusToDescrMap[dwIdx].dwStatus == dwClusterOrPortStatus)
        {
            dwResourceId = AllNlbStatusToDescrMap[dwIdx].dwResourceId;
            break;
        }
    }

    if (dwIdx == dwMaxOperations)
    {
        dwResourceId = IDS_UNKNOWN;
    }

    StringCbPrintf(
        wcTempStr,
        sizeof(wcTempStr),
        GETRESOURCEIDSTRING(dwClusterOrPortResourceId), (LPWSTR)GETRESOURCEIDSTRING(dwResourceId)
        );

    ClusterOrPortStatusStr = wcTempStr;

    // Determine if the value returned for Cluster/Port state is valid & if not, set the log level to "error" 
    if (bClusterOperation) 
    {
        switch(dwClusterOrPortStatus)
        {
        case WLBS_CONVERGING:
        case WLBS_CONVERGED:
        case WLBS_DEFAULT:
        case WLBS_DRAINING:
        case WLBS_STOPPED:  // really a failure in the sense of not being able to get the host map, but not flagging it here
        case WLBS_SUSPENDED:// 'cos it is a "normal" case
            break;

        default:
            LogLevel = IUICallbacks::LOG_ERROR;
            break;
        }
    }
    else // Port operation
    {
        switch(dwClusterOrPortStatus)
        {
        case NLB_PORT_RULE_ENABLED:
        case NLB_PORT_RULE_DISABLED:
        case NLB_PORT_RULE_DRAINING:
            break;

        default:
            LogLevel = IUICallbacks::LOG_ERROR;
            break;
        }
    }

    TRACE_INFO(L"<- %!FUNC!");
    return;
}

NLBERROR
CNlbEngine::ControlClusterOnInterface(
    IN ENGINEHANDLE         ehInterfaceId,
    IN WLBS_OPERATION_CODES Operation,
    IN CString              szVipArray[],
    IN DWORD                pdwPortNumArray[],
    IN DWORD                dwNumOfPortRules,
    IN BOOL                 fNewOperation
    )
{
    TRACE_INFO(L"-> %!FUNC!");

    LPCWSTR         szNicGuid, szHostName, szClusterIp;
    NLBERROR        err    =  NLBERR_OK;
    CHostSpec      *pHSpec =  NULL;
    CInterfaceSpec *pISpec =  NULL;
    DWORD           dwOperationStatus, dwClusterOrPortStatus, dwHostMap, dwNumOfIterations, dwIdx;
    WBEMSTATUS      Status;
    BOOL            bClusterOperation;
    IUICallbacks::LogEntryType LogLevel;
    _bstr_t OperationStr, OperationStatusStr, ClusterOrPortStatusStr;
    BOOL            fStopOperationOnExit = FALSE;


    if (fNewOperation)
    {
        //
        // This function is to be run in the context of a NEW operation.
        // Verify that we can do a control op at this time, and if so, start an
        // operation to track the control.
        //
    
        mfn_Lock();
    
        pISpec =  m_mapIdToInterfaceSpec[ehInterfaceId]; // map
    
        if (pISpec == NULL)
        {
            TRACE_CRIT("%!FUNC!: ERROR couldn't get info on this if id!");
            goto end_unlock;
        }

        //
        // Now try to start an operation...
        //
        {
            ENGINEHANDLE ExistingOp = NULL;
            err =  mfn_StartInterfaceOperationLk(
                       ehInterfaceId,
                       NULL, // pvCtxt
                       GETRESOURCEIDSTRING(IDS_LOG_CONTROL_INTERFACE),
                       &ExistingOp
                       );
            if (NLBFAILED(err))
            {
                goto end_unlock;
            }

            //
            // We did start the operation -- so we keep track of this, so that
            // we stop the operation on exit.
            //

            fStopOperationOnExit = TRUE;
        }
        pISpec = NULL;

        mfn_Unlock();
    }

    mfn_Lock();

    err = CNlbEngine::mfn_GetHostFromInterfaceLk(ehInterfaceId, REF pISpec, REF pHSpec);

    if (err != NLBERR_OK)
    {
        TRACE_CRIT(L"%!FUNC! could not get pISpec,pHSpec for ehIF 0x%lx", ehInterfaceId);
        goto end_unlock;
    }

    WMI_CONNECTION_INFO ConnInfo;
    ConnInfo.szUserName = (LPCWSTR) pHSpec->m_UserName;
    ConnInfo.szPassword = (LPCWSTR) pHSpec->m_Password;
    ConnInfo.szMachine =  (LPCWSTR) pHSpec->m_ConnectionString;

    szNicGuid  = (LPCWSTR)(pISpec->m_Guid);
    szClusterIp= pISpec->m_NlbCfg.NlbParams.cl_ip_addr;
    szHostName = (LPCWSTR)(pHSpec->m_MachineName);

    if (szNicGuid == NULL)
    {
        TRACE_CRIT(L"%!FUNC! ERROR -- NULL szNicGuid!");
        goto end_unlock;
    }

    mfn_Unlock();

    if (dwNumOfPortRules == 0) 
    {
        bClusterOperation = TRUE;
        dwNumOfIterations = 1;
    }
    else // Port operation 
    {
        bClusterOperation = FALSE;
        dwNumOfIterations = dwNumOfPortRules;
    }

    m_pCallbacks->HandleEngineEvent(
    IUICallbacks::OBJ_INTERFACE,
    NULL, // ehClusterId,
    ehInterfaceId,
    IUICallbacks::EVT_STATUS_CHANGE
    );
    ProcessMsgQueue();

    for (dwIdx = 0 ; dwIdx < dwNumOfIterations ; dwIdx++) 
    {
        LPCWSTR  szVip      =  (szVipArray) ? (LPCTSTR)(szVipArray[dwIdx]) : NULL;
        DWORD   *pdwPortNum =  (pdwPortNumArray) ? &pdwPortNumArray[dwIdx] : NULL;

        Status = NlbHostControlCluster(&ConnInfo,
                                       szNicGuid, 
                                       szVip,
                                       pdwPortNum,
                                       Operation, 
                                       &dwOperationStatus, 
                                       &dwClusterOrPortStatus,
                                       &dwHostMap);
        if (FAILED(Status)) 
        {
            if (Status == WBEM_E_INVALID_PARAMETER)
            {
                err = NLBERR_INVALID_CLUSTER_SPECIFICATION;
                dwOperationStatus = WLBS_BAD_PARAMS;
            }
            else // Critical Error
            {
                err = NLBERR_INTERNAL_ERROR;
                dwOperationStatus = WLBS_FAILURE;
            }
        }

        // Get the strings to log into log view
        mfn_GetLogStrings(Operation, 
                          szVip,
                          pdwPortNum,
                          dwOperationStatus, 
                          dwClusterOrPortStatus, 
                      REF LogLevel,
                      REF OperationStr, 
                      REF OperationStatusStr, 
                      REF ClusterOrPortStatusStr
                         );

        // If operation is NOT Query, Log result in Log View
        // We do NOT log results of a Query 'cos this is done for a "Refresh"
        // and we do not want to tell what is happening underneath. Instead,
        // the change in color coding will reflect any changes to the cluster state.
        if (Operation != WLBS_QUERY) 
        {
            m_pCallbacks->Log(LogLevel,
                              szClusterIp,
                              szHostName,
                              IDS_LOG_CONTROL_CLUSTER,
                              (LPWSTR)OperationStr, 
                              (LPWSTR)OperationStatusStr, 
                              (LPWSTR)ClusterOrPortStatusStr);
            ProcessMsgQueue();
        }
    }

    mfn_Lock();

    if (bClusterOperation)
    {
        pISpec->m_fValidClusterState = TRUE;
        pISpec->m_dwClusterState = dwClusterOrPortStatus;
    }

end_unlock:

    if (fStopOperationOnExit)
    {
        mfn_StopInterfaceOperationLk(ehInterfaceId);
    }

    mfn_Unlock();

    if (fStopOperationOnExit)
    {
        m_pCallbacks->HandleEngineEvent(
        IUICallbacks::OBJ_INTERFACE,
        NULL, // ehClusterId,
        ehInterfaceId,
        IUICallbacks::EVT_STATUS_CHANGE
        );
        ProcessMsgQueue();
    }

    TRACE_INFO(L"<- %!FUNC! return : %u", err);

    return err;
}



NLBERROR
CNlbEngine::ControlClusterOnCluster(
        IN ENGINEHANDLE          ehClusterId,
        IN WLBS_OPERATION_CODES  Operation,
        IN CString               szVipArray[],
        IN DWORD                 pdwPortNumArray[],
        IN DWORD                 dwNumOfPortRules
        )
/*
    Perform Cluster wide control operations
*/
{

    TRACE_INFO(L"-> %!FUNC!");

    NLBERROR nerr = NLBERR_OK;
    BOOL fStopOperationOnExit = FALSE;
    vector<ENGINEHANDLE> InterfaceListCopy;


    //
    // First thing we do is to see if we can start the cluster operation...
    //
    {
        BOOL fCanStart = FALSE; 

        nerr = this->CanStartClusterOperation(ehClusterId, REF fCanStart);

        if (NLBFAILED(nerr))
        {
            goto end;
        }

        if (!fCanStart)
        {
             nerr = NLBERR_BUSY;
             goto end;
        }
    }


    {
        mfn_Lock();
        CClusterSpec *pCSpec =  NULL;
        CEngineCluster *pECluster =  m_mapIdToEngineCluster[ehClusterId]; // map
    
        if (pECluster == NULL)
        {
            nerr = NLBERR_NOT_FOUND;
            goto end_unlock;
        }
        pCSpec = &pECluster->m_cSpec;

        //
        // Attempt to start the refresh operation -- will fail if there is
        // already an operation started on this cluster.
        //
        {
            ENGINEHANDLE ExistingOp= NULL;
            CLocalLogger logDescription;
    
            logDescription.Log(
                IDS_LOG_CONTROL_CLUSTER_OPERATION_DESCRIPTION,
                pCSpec->m_ClusterNlbCfg.NlbParams.cl_ip_addr
                );
    
            nerr =  mfn_StartClusterOperationLk(
                       ehClusterId,
                       NULL, // pvCtxt
                       logDescription.GetStringSafe(),
                       &ExistingOp
                       );
    
            if (NLBFAILED(nerr))
            {
                goto end_unlock;
            }
            else
            {
                fStopOperationOnExit = TRUE;
            }
        }

        InterfaceListCopy = pCSpec->m_ehInterfaceIdList; // vector copy
        mfn_Unlock();
    }

    m_pCallbacks->HandleEngineEvent(
        IUICallbacks::OBJ_CLUSTER,
        ehClusterId,
        ehClusterId,
        IUICallbacks::EVT_STATUS_CHANGE
        );
    ProcessMsgQueue(); 
    mfn_Lock();

    {
        //
        // Perform control operation on each interface in this cluster...
        //
    
        for( int i = 0; i < InterfaceListCopy.size(); ++i )
        {
            ENGINEHANDLE ehIId =  InterfaceListCopy[i];
    
            mfn_Unlock();

            nerr = this->ControlClusterOnInterface(
                                    ehIId,
                                    Operation,
                                    szVipArray,
                                    pdwPortNumArray,
                                    dwNumOfPortRules,
                                    TRUE
                                    );
                         
            mfn_Lock();
        }
    }

end_unlock:

    if (fStopOperationOnExit)
    {
        //
        // We'll stop the operation, assumed to be started in this function.
        //
        mfn_StopClusterOperationLk(ehClusterId);
    }

    mfn_Unlock();

    if (fStopOperationOnExit)
    {
        m_pCallbacks->HandleEngineEvent(
            IUICallbacks::OBJ_CLUSTER,
            ehClusterId,
            ehClusterId,
            IUICallbacks::EVT_STATUS_CHANGE
            );
        ProcessMsgQueue();
    }

end:

    TRACE_INFO(L"<- %!FUNC! return : %u", nerr);
    return nerr;
}

NLBERROR
CNlbEngine::FindInterfaceOnHostByClusterIp(
            IN  ENGINEHANDLE ehHostId,
            IN  LPCWSTR szClusterIp,    // OPTIONAL
            OUT ENGINEHANDLE &ehInterfaceId, // first found
            OUT UINT &NumFound
            )
/*
    Return the handle of the interface on the specified host that is 
    bound to a cluster with the specified cluster IP address.
*/
{
    CHostSpec   *pHSpec     = NULL;
    NLBERROR    err         = NLBERR_OK;
    UINT        uClusterIp  = 0;
    WBEMSTATUS  wStat;
    ENGINEHANDLE ehFoundIID = NULL;
    UINT        MyNumFound  = 0;

    ehInterfaceId = NULL;
    NumFound = 0;

    mfn_Lock();

    if (szClusterIp != NULL)
    {
        wStat =  CfgUtilsValidateNetworkAddress(
                    szClusterIp,
                    &uClusterIp,
                    NULL, // puSubnetMask
                    NULL // puDefaultSubnetMask
                    );
    
        if (FAILED(wStat))
        {
            TRACE_CRIT("%!FUNC! invalid szClusterIp (%ws) specified", szClusterIp);
            err = NLBERR_INVALID_IP_ADDRESS_SPECIFICATION;
            goto end;
        }
    }

    pHSpec =  m_mapIdToHostSpec[ehHostId]; // map
    if (pHSpec == NULL)
    {
        err = NLBERR_HOST_NOT_FOUND;
        goto end;
    }

    //
    // Now look through the interfaces, searching for a cluster ip.
    //
    for( int i = 0; i < pHSpec->m_ehInterfaceIdList.size(); ++i )
    {
        ENGINEHANDLE ehIID = NULL;
        ehIID = pHSpec->m_ehInterfaceIdList[i];
        CInterfaceSpec *pISpec = NULL;

        pISpec =  m_mapIdToInterfaceSpec[ehIID]; // map

        if (pISpec == NULL)
        {
            TRACE_CRIT("%!FUNC! unexpected null pISpec for IID 0x%lx", ehIID);
            continue;
        }

        if (szClusterIp == NULL)
        {
            if (pISpec->m_NlbCfg.IsNlbBound())
            {
                MyNumFound++;
                if (ehFoundIID == NULL)
                {
                    //
                    // First interface bound to NLB -- we'll save this away.
                    // and continue.
                    //
                    ehFoundIID = ehIID;
                }
            }

            continue;
        }

        //
        // A non-null szClusterIp is specified. We'll see if it matches
        // the cluster IP (if any) on this interface.
        //

        if (pISpec->m_NlbCfg.IsValidNlbConfig())
        {
            UINT uThisClusterIp = 0;
            LPCWSTR szThisClusterIp =  pISpec->m_NlbCfg.NlbParams.cl_ip_addr;
            wStat =  CfgUtilsValidateNetworkAddress(
                        szThisClusterIp,
                        &uThisClusterIp,
                        NULL, // puSubnetMask
                        NULL // puDefaultSubnetMask
                        );
        
            if (FAILED(wStat))
            {
                continue;
            }

            if (uThisClusterIp == uClusterIp)
            {
                MyNumFound++;

                if (ehFoundIID == NULL)
                {
                    //
                    // First interface bound to NLB -- we'll save this away.
                    // and continue.
                    //
                    ehFoundIID = ehIID;
                }
                else
                {
                    //
                    // Hmm... more than one nlb cluster with the same IP?
                    // could be a bad config on one or both.
                    //
                    TRACE_CRIT("%!FUNC! two clusters on ehHost 0x%lx have cluster ip %ws",  ehHostId, szClusterIp);
                }
            }
        }
    }

    if (MyNumFound != 0)
    {
        
        ASSERT(ehFoundIID != NULL);
        ehInterfaceId = ehFoundIID;
        NumFound = MyNumFound;
        err = NLBERR_OK;
    }
    else
    {
        err = NLBERR_INTERFACE_NOT_FOUND;
    }

end:

    mfn_Unlock();

    return err;
}

NLBERROR
CNlbEngine::InitializeNewHostConfig(
            IN  ENGINEHANDLE          ehCluster,
            OUT NLB_EXTENDED_CLUSTER_CONFIGURATION &NlbCfg
            )
/*
    Initialize NlbCfg based on the current cluster parameters as well
    as good host-specific defaults like host priority, taking into account
    other members of the cluster.
*/
{
    NLBERROR nerr = NLBERR_INTERNAL_ERROR;
    WBEMSTATUS wStatus = WBEM_E_CRITICAL_ERROR;
    WLBS_PORT_RULE *pRules = NULL;
    BOOL fAvailablePortRulePrioritiesSet = FALSE;

    //
    // Get the cluster spec and copy over it to NlbCfg.
    //
    {
        mfn_Lock();
    
        CEngineCluster *pECluster =  m_mapIdToEngineCluster[ehCluster]; // map
        
        if (pECluster == NULL)
        {
            nerr = NLBERR_NOT_FOUND;
            mfn_Unlock();
            goto end;
        }
    
        //
        // Copy over the cluster spec's params.
        //
        wStatus = NlbCfg.Update(&pECluster->m_cSpec.m_ClusterNlbCfg);

        mfn_Unlock();
    }

    if (FAILED(wStatus))
    {
        TRACE_CRIT("%!FUNC! Error copying over cluster params ehC=0x%lx",
                ehCluster);
        nerr = NLBERR_RESOURCE_ALLOCATION_FAILURE;
        goto end;

    }

    if(!NlbCfg.IsValidNlbConfig()) {
        //
        // We expect the configuration to be valid -- i.e., NLB bound, with
        // valid parameters.
        //
        TRACE_CRIT("%!FUNC! --  current configuration is unbound/invalid!");
        goto end;
    }

    //
    // Set host-id (priority) to the first available host priority.
    //
    {
        ULONG AvailablePriorities = this->GetAvailableHostPriorities(ehCluster);
        ULONG HostId = 1;

        for(ULONG u=0; u<32; u++)
        {
            if (AvailablePriorities & (((ULONG)1)<<u))
            {
                HostId = u+1; // let's pick the first available one.
                break;
            }
        }

        NlbCfg.NlbParams.host_priority = HostId;
    }

    //
    // For each single-host-affinity port rule, set the host priority to
    // the host-id if that's available, else the first available host priority
    //
    {
        UINT NumRules=0;
        ULONG       rgAvailablePriorities[WLBS_MAX_RULES];

        ZeroMemory(rgAvailablePriorities, sizeof(rgAvailablePriorities));
       
        wStatus =  CfgUtilGetPortRules(
                    &NlbCfg.NlbParams,
                    &pRules,
                    &NumRules
                    );
        if (FAILED(wStatus))
        {
            TRACE_CRIT("%!FUNC! error 0x%08lx extracting port rules!", wStatus);
            pRules = NULL;
            goto end;
        }

        nerr =  this->GetAvailablePortRulePriorities(
                            ehCluster,
                            NumRules,
                            pRules,
                            rgAvailablePriorities
                            );

        if (NLBOK(nerr))
        {
            fAvailablePortRulePrioritiesSet = TRUE;
        }
        else
        {
            fAvailablePortRulePrioritiesSet = FALSE;
        }

        //
        // Now for each rule, put defaults
        //
        for (UINT u=0; u<NumRules;u++)
        {
            WLBS_PORT_RULE *pRule = pRules+u;
            UINT Mode = pRule->mode;
            if (Mode != CVY_NEVER)
            {
                if  (Mode == CVY_MULTI)
                {
                    pRule->mode_data.multi.equal_load = TRUE; //default
                    //
                    // The equal_load value is set in the cluster
                    // properties dialog.
                    //
                    pRule->mode_data.multi.load = 50;
                }
                else if (Mode == CVY_SINGLE)
                {
                    ULONG PortPriority = 0; 
                    ULONG AvailablePriorities = 0;
            
                    //
                    // Default is set to this host's host ID (priority)
                    //
                    PortPriority = NlbCfg.NlbParams.host_priority;


                    if (fAvailablePortRulePrioritiesSet)
                    {
                        AvailablePriorities = rgAvailablePriorities[u];
                    }

                    if (AvailablePriorities != 0
                        && 0 == ((1<<(PortPriority-1)) & AvailablePriorities) )
                    {
                        //
                        // There are available priorities, but unfortunately
                        // the default priority is not available -- pick
                        //  the first available priority.
                        //
                        for(ULONG v=0; v<32; v++)
                        {
                            if (AvailablePriorities & (((ULONG)1)<<v))
                            {
                                PortPriority = v+1; // let's pick this one
                                break;
                            }
                        }
                    }
            
                    pRule->mode_data.single.priority =  PortPriority;
                }
            }
        }

        //
        // Finally, set the port rules..
        //
    
        wStatus =   CfgUtilSetPortRules(
                    pRules,
                    NumRules,
                    &NlbCfg.NlbParams
                    );
        if (FAILED(wStatus))
        {
            TRACE_CRIT("%!FUNC! error 0x%08lx setting port rules!", wStatus);
            goto end;
        }

        nerr = NLBERR_OK;
    }


end:

    delete pRules; // can be NULL
    return nerr;
}


NLBERROR
CNlbEngine::UpdateInterface(
    IN ENGINEHANDLE ehInterfaceId,
    IN NLB_EXTENDED_CLUSTER_CONFIGURATION &refNewConfigIn,
    // IN OUT BOOL &fClusterPropertiesUpdated,
    OUT CLocalLogger logConflict
    )
{
/*
    Will MUNGE refNewConfig --  slightly munges refNewConfig.NlbParams,
    and will fill in default pIpAddressInfo if it's not set.
*/

    NLBERROR        err                 = NLBERR_OK;
    BOOL            fConnectivityChange = FALSE;
    BOOL            fStopOperationOnExit= FALSE;
    NLB_EXTENDED_CLUSTER_CONFIGURATION
                    *pPendingConfig     = NULL;
    LPCWSTR         szHostName          = NULL;
    LPCWSTR         szClusterIp         = NULL;
    LPCWSTR         szDisplayName       = NULL; // of interface
    ENGINEHANDLE    ehHost              = NULL;
    ENGINEHANDLE    ehCluster           = NULL;
    _bstr_t         bstrFriendlyName;
    _bstr_t         bstrDisplayName;
    _bstr_t         bstrHostName;

    //
    // Following to decide whether to log that we're not adding the
    // dedicated IP because it's already on another interface.
    //
    BOOL            fDedicatedIpOnOtherIf = FALSE;
    ENGINEHANDLE    ehOtherIf = NULL;

    TRACE_INFO(L"-> %!FUNC!");


    err = this->GetInterfaceIdentification(
                ehInterfaceId,
                REF ehHost,
                REF ehCluster,
                REF bstrFriendlyName,
                REF bstrDisplayName,
                REF bstrHostName
                );

    if (NLBFAILED(err))
    {
        goto end;
    }

    szDisplayName  = bstrDisplayName;
    szHostName      = bstrHostName;
    if (szDisplayName == NULL)
    {
        szDisplayName = L"";
    }
    if (szHostName == NULL)
    {
        szHostName = L"";
    }
    
    mfn_Lock();

    CInterfaceSpec *pISpec =  m_mapIdToInterfaceSpec[ehInterfaceId]; // map

    if (pISpec == NULL)
    {
        err = NLBERR_INTERFACE_NOT_FOUND;
        goto end_unlock;
    }

    //
    // Make a copy of refNewConfig, because we'll likely be doing
    // the update operation in the background.
    //
    pPendingConfig = new NLB_EXTENDED_CLUSTER_CONFIGURATION;
    if (pPendingConfig == NULL)
    {
        err = NLBERR_RESOURCE_ALLOCATION_FAILURE;
        goto end_unlock;
    }
    else
    {
        WBEMSTATUS wStat1;
        wStat1 = pPendingConfig->Update(&refNewConfigIn);
        if (FAILED(wStat1))
        {
            delete pPendingConfig;
            pPendingConfig = NULL;
            err = NLBERR_RESOURCE_ALLOCATION_FAILURE;
            goto end_unlock;
        }
        //
        // Copy over the RCT password -- which does NOT get copied over
        // by the Update method above. The new password can be in the form
        // of a string or hashed-version.
        //
        //
        if (refNewConfigIn.NewRemoteControlPasswordSet())
        {
            LPCWSTR szNewPassword = NULL;
            szNewPassword = refNewConfigIn.GetNewRemoteControlPasswordRaw();

            if (szNewPassword != NULL)
            {
                //
                // Note: szNewPassword will be NULL UNLESS the user has explicitly
                // specified a new password.
                //
                pPendingConfig->SetNewRemoteControlPassword(szNewPassword);
            }
            else
            {
                //
                // This means the hash password is being updated...
                // This typically means that this is a new host and we're
                // setting up it's remote control password.
                //
                DWORD dwHash = 0;
                BOOL fRet = refNewConfigIn.GetNewHashedRemoteControlPassword(
                                    REF dwHash
                                    );
                if (fRet)
                {
                    pPendingConfig->SetNewHashedRemoteControlPassword(
                                        dwHash
                                        );
                }
                else
                {
                    TRACE_CRIT("refNewConfigIn fNewPassword set; but could not get either szPassword or new hashed password!");
                }
            }
        }
    }

    NLB_EXTENDED_CLUSTER_CONFIGURATION &refNewConfig = *pPendingConfig;
    szClusterIp = refNewConfig.NlbParams.cl_ip_addr;

    //
    // Attempt to start the update operation -- will fail if there is
    // already an operation started on this interface.
    //
    {
        ENGINEHANDLE ExistingOp= NULL;

        CLocalLogger logDescription;


        logDescription.Log(
            IDS_LOG_UPDATE_INTERFACE_OPERATION_DESCRIPTION,
            szDisplayName
            );

        err =  mfn_StartInterfaceOperationLk(
                   ehInterfaceId,
                   pPendingConfig,
                   logDescription.GetStringSafe(),
                   &ExistingOp
                   );

        if (NLBFAILED(err))
        {
            if (err == NLBERR_BUSY)
            {
                //
                // This means that there was an existing operation.
                // Let's get its description and add it to the log.
                //
                CEngineOperation *pExistingOp;
                pExistingOp  = mfn_GetOperationLk(ExistingOp);
                if (pExistingOp != NULL)
                {
                    LPCWSTR szDescrip =  pExistingOp->bstrDescription;
                    if (szDescrip == NULL)
                    {
                        szDescrip = L"";
                    }
                    
                    logConflict.Log(
                            IDS_LOG_OPERATION_PENDING_ON_INTERFACE,
                            szDescrip
                            );
                }
            }
            goto end_unlock;
        }
        else
        {
            fStopOperationOnExit = TRUE;
        }
    }

    ehHost = pISpec->m_ehHostId;

    //
    // Validate new config and get out if there's no real updating to
    // be done.
    //
    {

        if (refNewConfig.IsNlbBound())
        {

            if (refNewConfig.NumIpAddresses==0)
            {
                refNewConfig.fAddClusterIps = TRUE;
                refNewConfig.fAddDedicatedIp = TRUE;
            }
            else
            {
                //
                // refNewConfig has a non-null IP address list.
                // 
                // We interpret this to be the list of cluster IP addresses
                // with possibly the dedicated ip address as the
                // first IP address.
                //
                //
                // We'll re-order the ip address list to match the
                // existing order of IP addresses on the adapter as
                // far as possible.
                // 
                // Then we'll add the dedicated IP address list if we
                // need to.
                //

                BOOL fRet = FALSE;
                NlbIpAddressList addrList;

                //
                // Make a copy of the old adddress list in addrList
                //
                fRet = addrList.Set(pISpec->m_NlbCfg.NumIpAddresses,
                                    pISpec->m_NlbCfg.pIpAddressInfo, 1);
    
                if (!fRet)
                {
                    TRACE_CRIT(L"Unable to copy old IP address list");
                    err = NLBERR_RESOURCE_ALLOCATION_FAILURE;
                    goto end_unlock;
                }

                //
                // addrList.Apply will taken on the new ip address list,
                // but try to preserve the old order.
                //
                fRet = addrList.Apply(refNewConfig.NumIpAddresses,
                            refNewConfig.pIpAddressInfo);
                if (!fRet)
                {
                    TRACE_CRIT(L"Unable to apply new IP address list");
                    err = NLBERR_RESOURCE_ALLOCATION_FAILURE;
                    goto end_unlock;
                }

                //
                // If there is a dedicated IP address AND it
                // does not exist elsewhere on this host, add it to
                // the beginning of the list.
                //
                if (!refNewConfig.IsBlankDedicatedIp())
                {
                    ENGINEHANDLE ehIF = NULL;

                    err = this->mfn_LookupInterfaceByIpLk(
                            NULL, // NULL == look through all hosts.
                            refNewConfig.NlbParams.ded_ip_addr,
                            REF ehOtherIf
                            );

                    if (NLBOK(err) && ehOtherIf != ehInterfaceId)
                    {
                        //
                        // Hmm... another interface already has this
                        // interface?
                        //
                        // We'll log this and NOT add the dedicated IP
                        // address...
                        //
                        fDedicatedIpOnOtherIf = TRUE;
                        (VOID) addrList.Modify(
                                    refNewConfig.NlbParams.ded_ip_addr,
                                    NULL,
                                    NULL
                                    );
                    }
                    else
                    {

                        fRet  = addrList.Modify(
                                    NULL,
                                    refNewConfig.NlbParams.ded_ip_addr,
                                    refNewConfig.NlbParams.ded_net_mask
                                    );
                        if (!fRet)
                        {
                            TRACE_CRIT(L"Unable to add ded IP to addr list");
                            err = NLBERR_RESOURCE_ALLOCATION_FAILURE;
                            goto end_unlock;
                        }
                    }
                }

                //
                // Set refNewConfig's ip address list to the newly
                // computed values.
                //
                refNewConfig.SetNetworkAddressesRaw(NULL,0);
                addrList.Extract(
                    REF refNewConfig.NumIpAddresses,
                    REF refNewConfig.pIpAddressInfo
                    );
            }

        }

        err =  pISpec->m_NlbCfg.AnalyzeUpdate(
                   &refNewConfig,
                   &fConnectivityChange
                   );

        if (err == NLBERR_NO_CHANGE)
        {
            //
            // Nothing has changed -- we skip
            //
            err = NLBERR_OK;
            goto end_unlock;
        }

        //
        // err could indicate failure -- we'll deal with that a little
        // bit further down.
        //

    } // validate/munge refNewConfig



    if (!NLBOK(err))
    {
        mfn_Unlock();

        //
        // Probably a parameter error -- we'll get the latest
        // config and display it...
        //
        m_pCallbacks->Log(
            IUICallbacks::LOG_ERROR,
            szClusterIp,
            szHostName,
            IDS_LOG_CANT_UPDATE_BAD_PARAMS
            );
        (void) this->RefreshInterface(
                        ehInterfaceId,
                        FALSE,  // FALSE == don't start a new operation
                        FALSE   // FALSE == this is not cluster-wide
                        ); 

        mfn_Lock();
        goto end_unlock;
    }

    mfn_Unlock();

    if (fDedicatedIpOnOtherIf)
    {
        LPCWSTR  szOtherIf = NULL;
        _bstr_t  bstrOtherFriendlyName;
        _bstr_t  bstrOtherDisplayName;
        _bstr_t  bstrOtherHostName;

        ENGINEHANDLE   ehOtherHost;
        ENGINEHANDLE   ehOtherCluster;
        NLBERROR tmpErr;
        IUICallbacks::LogEntryType logType = IUICallbacks::LOG_WARNING;

        tmpErr =  this->GetInterfaceIdentification(
                            ehOtherIf,
                            REF ehOtherHost,
                            REF ehOtherCluster,
                            REF bstrOtherFriendlyName,
                            REF bstrOtherDisplayName,
                            REF bstrOtherHostName
                            );

        if (NLBOK(tmpErr))
        {
            if (ehOtherHost != ehHost)
            {
                // Odd -- ded ip on another host?
                logType = IUICallbacks::LOG_ERROR;
                szOtherIf = bstrOtherDisplayName; // includes host name
            }
            else
            {
                szOtherIf = bstrOtherFriendlyName;
            }
        }

        if (szOtherIf == NULL)
        {
            szOtherIf = L"";
        }


        //
        // Let's log the fact that the dedicated Ip address is
        // on some other interface.
        //
        TRACE_INFO(L"WARNING: dedicated IP address for eIF 0x%lx is on eIF 0x%lx",
                ehInterfaceId, ehOtherIf);

        m_pCallbacks->Log(
            IUICallbacks::LOG_INFORMATIONAL,
            szClusterIp,
            szHostName,
            IDS_LOG_DEDICATED_IP_ON_OTHER_INTERFACE,
            refNewConfig.NlbParams.ded_ip_addr,
            szOtherIf
            );
    }

    if (!fConnectivityChange)
    {
        //
        // If there's not going to be a connectivity change, we
        // will not try to update the IP address list.
        //
        refNewConfig.SetNetworkAddresses(NULL, 0);
        if (refNewConfig.IsNlbBound())
        {
            refNewConfig.fAddClusterIps = TRUE;
            refNewConfig.fAddDedicatedIp = TRUE;

        }
    }


    //
    // Notify the UI that we're going to start the update
    //
    {
        m_pCallbacks->Log(
            IUICallbacks::LOG_INFORMATIONAL,
            szClusterIp,
            szHostName,
            IDS_LOG_BEGIN_HOST_UPDATE
            );
    
        m_pCallbacks->HandleEngineEvent(
            IUICallbacks::OBJ_INTERFACE,
            NULL, // ehClusterId,
            ehInterfaceId,
            IUICallbacks::EVT_STATUS_CHANGE
            );
        ProcessMsgQueue();
    }


#if BUGFIX334243
    BOOL fUpdateNow = FALSE;
#else // !BUGFIX334243
    BOOL fUpdateNow = TRUE;
#endif // !BUGFIX334243

    //
    // We are committed to going through with the update now -- either
    // sync or async.
    //
    InterlockedIncrement(&m_WorkItemCount);
    fStopOperationOnExit = FALSE;

    //
    // We MUST call UpdateInterfaceWorItemRoutine now (either sync or async),
    // which  will stop the operation when done and also decrement 
    // m_mWorkItemCount.
    //

    if (!fUpdateNow)
    {
        BOOL fRet;
        //
        // We'll attempt to perform the update in the background ...
        //

        fRet = QueueUserWorkItem(
                            UpdateInterfaceWorkItemRoutine,
                            (PVOID) (UINT_PTR) ehInterfaceId,
                            WT_EXECUTELONGFUNCTION
                            );

        if (fRet)
        {
            fUpdateNow = FALSE;
        }
        else
        {
            fUpdateNow = TRUE; // Update now if QueueUsesrWorkItem fails.
        }
    }
    
    if (fUpdateNow)
    {
        //
        // Call the work item synchronously
        //
        UpdateInterfaceWorkItemRoutine((LPVOID) (UINT_PTR) ehInterfaceId);
    }

    goto end;

end_unlock:

    if (fStopOperationOnExit)
    {
        //
        // We'll stop the operation, assumed to be started in this function.
        //
        mfn_StopInterfaceOperationLk(ehInterfaceId);
        fStopOperationOnExit = FALSE;
    }

    mfn_Unlock();

end:

    ASSERT(!fStopOperationOnExit);

    TRACE_INFO(L"<- %!FUNC!");
    return err;
}


NLBERROR
CNlbEngine::UpdateCluster(
        IN ENGINEHANDLE ehClusterId,
        IN const NLB_EXTENDED_CLUSTER_CONFIGURATION *pNewConfig OPTIONAL,
        IN OUT  CLocalLogger   &logConflict
        )
/*
    Attempt to push all the cluster-wide (i.e. non-host-specific)
    information on *pNewConfig to each host in the cluster.

    Update the cluster's copy of NlbConfig to be *pNewConfig.

    Set cluster's pending state on starting and set it
    appropriately when done (could be misconfigured).

*/
{
    NLBERROR nerr = NLBERR_OK;
    _bstr_t bstrClusterIp;
    TRACE_INFO(L"-> %!FUNC!");
    vector<ENGINEHANDLE> InterfaceListCopy;
    BOOL fStopOperationOnExit = FALSE;

    //
    // First thing we do is to see if we can start the cluster operation...
    //
    if (pNewConfig != NULL)
    {
        BOOL fCanStart = FALSE; 

        nerr = this->CanStartClusterOperation(ehClusterId, REF fCanStart);

        if (NLBFAILED(nerr))
        {
            goto end;
        }

        if (!fCanStart)
        {
             nerr = NLBERR_BUSY;
             goto end;
        }
    }


    {
        mfn_Lock();
        CClusterSpec *pCSpec =  NULL;
        CEngineCluster *pECluster =  m_mapIdToEngineCluster[ehClusterId]; // map
    
        if (pECluster == NULL)
        {
            nerr = NLBERR_NOT_FOUND;
            goto end_unlock;
        }
        pCSpec = &pECluster->m_cSpec;

        //
        // Attempt to start the update operation -- will fail if there is
        // already an operation started on this cluster.
        //
        {
            ENGINEHANDLE ExistingOp= NULL;
            CLocalLogger logDescription;

            logDescription.Log(
                IDS_LOG_UPDATE_CLUSTER_OPERATION_DESCRIPTION,
                pCSpec->m_ClusterNlbCfg.NlbParams.cl_ip_addr
                );
    
            nerr =  mfn_StartClusterOperationLk(
                       ehClusterId,
                       NULL, // pvCtxt
                       logDescription.GetStringSafe(),
                       &ExistingOp
                       );
    
            if (NLBFAILED(nerr))
            {
                if (nerr == NLBERR_BUSY)
                {
                    //
                    // This means that there was an existing operation.
                    // Let's get its description and add it to the log.
                    //
                    CEngineOperation *pExistingOp;
                    pExistingOp  = mfn_GetOperationLk(ExistingOp);
                    if (pExistingOp != NULL)
                    {
                        LPCWSTR szDescrip =  pExistingOp->bstrDescription;
                        if (szDescrip == NULL)
                        {
                            szDescrip = L"";
                        }
                        
                        logConflict.Log(
                                IDS_LOG_OPERATION_PENDING_ON_CLUSTER,
                                szDescrip
                                );
                    }
                }
                goto end_unlock;
            }
            else
            {
                fStopOperationOnExit = TRUE;
            }
        }

        if (pNewConfig != NULL)
        {
            pCSpec->m_ClusterNlbCfg.Update(pNewConfig); // TODO: error ret
            //
            // Note: Update above has the side effect of setting
            // m_ClusterNlbCfg's szNewPassword field to NULL -- this is what
            // we want. However, we do mark the fact that the
            // password is new -- because the cluster's version of the
            // hashed-password is now obsolete -- it needs to be updated
            // by reading one of the hosts' versions. 
            // pCSpec->m_fNewRctPassword  track this state.
            //
            if (pNewConfig->GetNewRemoteControlPasswordRaw() != NULL)
            {
                pCSpec->m_fNewRctPassword = TRUE;
                //
                // The above flag will be cleared (and the hashed password
                // value updated) at the end of the
                // first update operation for one of the interfaces.
                //
                // It is also cleared when the cluster properties are
                // updated as part of a refresh operation.
                //
            }
        }
    
        bstrClusterIp = _bstr_t(pCSpec->m_ClusterNlbCfg.NlbParams.cl_ip_addr);
        InterfaceListCopy = pCSpec->m_ehInterfaceIdList; // vector copy
        mfn_Unlock();
    }

    m_pCallbacks->HandleEngineEvent(
        IUICallbacks::OBJ_CLUSTER,
        ehClusterId,
        ehClusterId,
        IUICallbacks::EVT_STATUS_CHANGE
        );
    ProcessMsgQueue();



    mfn_Lock();


    BOOL fRetryUpdateCluster = FALSE;

    do
    {


        LPCWSTR szClusterIp = bstrClusterIp;
        UINT    uNumModeChanges = 0; // number of IF's undergoing mode changes.
        UINT    uNumUpdateErrors = 0; // number of IF's with update errors.

        //
        // fClusterPropertiesUpdated keeps track of whether the cluster
        // properties were updated as a course of refreshing and or updating
        // the interface -- we update the cluster props at most once:
        // for the first interface that successfully performs the update
        // (or if pNewConfig == NULL) for the first interface that
        // successfully refreshes its properties AND is still bound.
        //
        //
        BOOL    fClusterPropertiesUpdated  = FALSE;

        //
        // Update each interface in this cluster...
        //
    
        for( int i = 0; i < InterfaceListCopy.size(); ++i )
        {
            CInterfaceSpec TmpISpec;

            _bstr_t bstrHostName = L"";

            ENGINEHANDLE ehIId =  InterfaceListCopy[i];
    
            mfn_GetInterfaceHostNameLk(
                    ehIId,
                    REF bstrHostName
                    );

            mfn_Unlock();

            //
            // Get the latest interface information and (if
            // pNewConfig != NULL) merge in the cluster information.
            //
            {
                BOOL fSkipHost = TRUE;

                if (pNewConfig == NULL)
                {
                    //
                    // This is a REFRESH CLUSTER operation
                    //

                    nerr = this->RefreshInterface(ehIId, TRUE, TRUE);
                    if (NLBOK(nerr))
                    {
                        //
                        // Let's update the cluster-wide properties with
                        // this interface if:
                        //
                        //  1. We haven't already updated the props in this
                        //     loop.
                        //
                        //  2. The above interface is bound to NLB,
                        //     and the IP address matches
                        //     the clusters' ip address.
                        //
                        if (!fClusterPropertiesUpdated)
                        {
                            fClusterPropertiesUpdated = mfn_UpdateClusterProps(
                                                            ehClusterId,
                                                            ehIId
                                                            );
                        }
                    }
                }
                else
                {
                    //
                    // This is a CHANGE CLUSTER CONFIGURATION operation
                    // Let's first get the latest version of this interface'
                    // properties.
                    //

                    nerr = this->mfn_RefreshInterface(ehIId);
                }

                //
                // If this fails, we don't try to update. Instead
                // we send a log message and continue.
                // Note: RefreshInterface will send an interface-status
                // change machine.
                //
                if (nerr == NLBERR_OK)
                {
                    nerr = this->GetInterfaceSpec(ehIId, REF TmpISpec);
                    if (nerr == NLBERR_OK)
                    {
                        fSkipHost = FALSE;
                    }
                }

                if (!fSkipHost && pNewConfig != NULL)
                {
                    if (pNewConfig->fBound)
                    {
                        NLB_EXTENDED_CLUSTER_CONFIGURATION *pOldConfig
                                =  &TmpISpec.m_NlbCfg;

                        //
                        // Check if there is a mode change involved...
                        // because if so, the provider will not add
                        // any cluster IP addresses.
                        //
                        // We keep track of all IFs with mode changes, and
                        // if any, we'll do this whole cluster-wide update
                        // process a 2nd time, at which time the IP addresses
                        // will be added.
                        //
                        if (pOldConfig->IsValidNlbConfig())
                        {
                            NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE tmOld, tmNew;

                            tmOld = pOldConfig->GetTrafficMode();
                            tmNew = pNewConfig->GetTrafficMode();
                            if (tmOld != tmNew)
                            {
                                // Mode change!
                                uNumModeChanges++;
                                TRACE_INFO(L"%!FUNC!: ehIF 0x%lx: Detected mode change!\n", ehIId);
                            }
                        }

                        //
                        // Merge in the cluster-specific information
                        //
                        nerr =  ApplyClusterWideConfiguration(
                                    REF  *pNewConfig,
                                    REF  TmpISpec.m_NlbCfg
                                    );
                        if (nerr != NLBERR_OK)
                        {
                            fSkipHost = TRUE;
                        }
                    }
                    else
                    {
                        //
                        // We're asked to unbind all hosts!
                        //
                        TmpISpec.m_NlbCfg.fAddDedicatedIp = FALSE;
                        TmpISpec.m_NlbCfg.SetNetworkAddresses(NULL, 0);
                        TmpISpec.m_NlbCfg.SetNlbBound(FALSE);
                
                        if (!TmpISpec.m_NlbCfg.IsBlankDedicatedIp())
                        {
                            WCHAR rgBuf[64];
                            LPCWSTR szAddr = rgBuf;
                            StringCbPrintf(
                                rgBuf,
                                sizeof(rgBuf),
                                L"%ws/%ws",
                                TmpISpec.m_NlbCfg.NlbParams.ded_ip_addr,
                                TmpISpec.m_NlbCfg.NlbParams.ded_net_mask
                                );
                            TmpISpec.m_NlbCfg.SetNetworkAddresses(&szAddr, 1);
                        }
                    }
                }

                if (fSkipHost && pNewConfig != NULL)
                {
                    TRACE_CRIT(L"%!FUNC!: Couldn't get latest interface spec when trying to update cluster");
                    m_pCallbacks->Log(
                        IUICallbacks::LOG_ERROR,
                        szClusterIp,
                        (LPCWSTR) bstrHostName,
                        IDS_LOG_SKIP_INTERFACE_UPDATE_ON_ERROR, // "...%lx"
                        nerr // TODO -- replace by textual description.
                        );
                    mfn_Lock();

                    uNumUpdateErrors++;
                    continue;
                }
            }

            //
            // Actually update the interface -- likely it will complete
            // in the background.
            //
            if (pNewConfig != NULL)
            {
                CLocalLogger logConflict;
                nerr = this->UpdateInterface(
                                    ehIId,
                                    REF TmpISpec.m_NlbCfg,
                                    // REF fClusterPropertiesUpdated,
                                    REF logConflict
                                    );
            }

            mfn_Lock();

        }

        //
        // If there are mode changes for one-or-more nodes, we'll need
        // to wait for ALL updates to complete, and then try again.
        //
        if (uNumUpdateErrors!=0)
        {
            nerr = NLBERR_OPERATION_FAILED;
        }
        else
        {
            if (fRetryUpdateCluster && uNumModeChanges!=0)
            {
                //
                // We're gone through a 2nd time and STILL there are
                // mode changes! We bail.
                //
                TRACE_CRIT(L"%!FUNC! ehC 0x%lx: %lu Mode changes on 2nd phase. Bailing", ehClusterId, uNumModeChanges);
                nerr = NLBERR_OPERATION_FAILED;
            }
            else
            {
                nerr = NLBERR_OK;
            }
        }

        fRetryUpdateCluster = FALSE;

        if (NLBOK(nerr) && uNumModeChanges!=0)
        {
            BOOL fSameMode = FALSE;

            //
            // There were one or more mode changes!
            // Let's wait for *all* updates to complete successfully.
            // Then we'll check to make sure that the modes on all
            // hosts match the cluster IP address' modes. If they do
            // (and there were no update errors), we'll re-run the
            // update process, this time hopefully adding 
            // the IP addresses that would have been stripped had there been
            // mode changes.
            //
            mfn_Unlock();
            nerr = mfn_WaitForInterfaceOperationCompletions(ehClusterId);
            mfn_Lock();

            if (NLBOK(nerr))
            {
                nerr = mfn_VerifySameModeLk(ehClusterId, REF fSameMode);
            }

            if (NLBOK(nerr) && fSameMode)
            {
                TRACE_CRIT(L"%!FUNC! chC 0x%lx: SECOND PHASE on CHANGE MODE",
                        ehClusterId);
                fRetryUpdateCluster = TRUE;
            }
        }

        if (uNumModeChanges && NLBFAILED(nerr))
        {
            mfn_Unlock();
            //
            // There was a problem, log it, as well as the list of
            // cluster IP addresses/subnets.
            // TODO: add details.
            //
            m_pCallbacks->Log(
                IUICallbacks::LOG_INFORMATIONAL,
                szClusterIp,
                NULL,
                IDS_LOG_ERRORS_DETECTED_DURING_MODE_CHANGE
                );
            mfn_Lock();
        }

    } while (NLBOK(nerr) && fRetryUpdateCluster);

    //
    // We're done -- set the cluster's fPending field to false, and if
    // necessary (if no interfaces) delete the cluster.
    //
    {
        BOOL fEmptyCluster = FALSE;
        CClusterSpec *pCSpec =  NULL;
        CEngineCluster *pECluster =  m_mapIdToEngineCluster[ehClusterId]; // map
    
        if (pECluster == NULL)
        {
            nerr = NLBERR_NOT_FOUND;
            goto end_unlock;
        }
        pCSpec = &pECluster->m_cSpec;
        fEmptyCluster = (pCSpec->m_ehInterfaceIdList.size()==0);
        ASSERT(fStopOperationOnExit);
        mfn_StopClusterOperationLk(ehClusterId);
        fStopOperationOnExit = FALSE;

        mfn_Unlock();

        if (fEmptyCluster)
        {
            //
            // The cluster is empty -- delete it.
            //
            this->DeleteCluster(ehClusterId, FALSE); // FALSE == don't remove IF
        }
        else
        {
            m_pCallbacks->HandleEngineEvent(
                IUICallbacks::OBJ_CLUSTER,
                ehClusterId,
                ehClusterId,
                IUICallbacks::EVT_STATUS_CHANGE
                );
            ProcessMsgQueue();
        }
        mfn_Lock();
    }
    
    // fall through ...

end_unlock:


    if (fStopOperationOnExit)
    {
        //
        // We'll stop the operation, assumed to be started in this function.
        //
        mfn_StopClusterOperationLk(ehClusterId);

    }

    mfn_Unlock();

    if (fStopOperationOnExit)
    {
        m_pCallbacks->HandleEngineEvent(
            IUICallbacks::OBJ_CLUSTER,
            ehClusterId,
            ehClusterId,
            IUICallbacks::EVT_STATUS_CHANGE
            );
        ProcessMsgQueue();
        fStopOperationOnExit = FALSE;
    } 

end:

    ASSERT(!fStopOperationOnExit);
    TRACE_INFO(L"<- %!FUNC!");
    return nerr;
}


NLBERROR
CNlbEngine::GetClusterSpec(
    IN ENGINEHANDLE ehClusterId,
    OUT CClusterSpec& refClusterSpec
    )
{
    // TRACE_INFO(L"-> %!FUNC!");
    NLBERROR err = NLBERR_OK;

    mfn_Lock();

    CEngineCluster *pECluster =  m_mapIdToEngineCluster[ehClusterId]; // map

    if (pECluster == NULL)
    {
        err = NLBERR_INTERFACE_NOT_FOUND;
    }
    else
    {
        //
        // This is really an assert condition -- the cluster spec should
        // NEVER have a non-blank dedicated IP address.
        //
        if (!pECluster->m_cSpec.m_ClusterNlbCfg.IsBlankDedicatedIp())
        {
            err = NLBERR_INTERNAL_ERROR;
            TRACE_CRIT(L"%!FUNC! unexpected: cluster eh 0x%lx has non-blank ded-ip!", ehClusterId);
        }
        else
        {
            refClusterSpec.Copy(pECluster->m_cSpec);
        }
    }

    mfn_Unlock();

    // TRACE_INFO(L"<- %!FUNC!");
    return err;
}


NLBERROR
CNlbEngine::GetHostSpec(
    IN ENGINEHANDLE ehHostId,
    OUT CHostSpec& refHostSpec
    )
{
    NLBERROR err = NLBERR_OK;

    // TRACE_INFO(L"-> %!FUNC!(0x%lx)", (UINT)ehHostId);

    mfn_Lock();

    CHostSpec *pHSpec =  m_mapIdToHostSpec[ehHostId]; // map

    if (pHSpec == NULL)
    {
        err = NLBERR_INTERFACE_NOT_FOUND;
    }
    else
    {
        refHostSpec.Copy(*pHSpec);
    }

    if (err != NLBERR_OK)
    {
        TRACE_INFO(
             L"<- %!FUNC!(0x%lx) Host not found",
             ehHostId
             );
    }

    mfn_Unlock();

    return err;
}


NLBERROR
CNlbEngine::GetHostConnectionInformation(
    IN  ENGINEHANDLE ehHost,
    OUT ENGINEHANDLE &ehConnectionIF,
    OUT _bstr_t      &bstrConnectionString,
    OUT UINT         &uConnectionIp
    )
/*
    For the specified host ehHost,
    Look up it's connection IP, and search all its interfaces
    for the specific connection IP.

    Return the found interface handle, connection string and connection IP.
*/
{
    NLBERROR nerr = NLBERR_INTERNAL_ERROR;
    CHostSpec *pHSpec =  NULL;

    mfn_Lock();

    pHSpec =  m_mapIdToHostSpec[ehHost]; // map

    if (pHSpec == NULL)
    {
        nerr = NLBERR_NOT_FOUND;
        goto end_unlock;
    }

    
    //
    // Lookup the interface that has the connection IP
    //
    uConnectionIp =  pHSpec->m_ConnectionIpAddress;
    if (uConnectionIp != 0)
    {
        WCHAR rgIp[128];
        LPBYTE pb = (LPBYTE) &uConnectionIp;
        StringCbPrintf(
            rgIp,
            sizeof(rgIp),
            L"%lu.%lu.%lu.%lu",
            pb[0], pb[1], pb[2], pb[3]
            );
        nerr =  mfn_LookupInterfaceByIpLk(ehHost, rgIp, REF ehConnectionIF);
    }

    if (NLBOK(nerr))
    {
        bstrConnectionString = pHSpec->m_ConnectionString;
    }
    else
    {
        ehConnectionIF  = NULL;
        uConnectionIp   = 0;
    }

end_unlock:

    mfn_Unlock();

    return nerr;
}

NLBERROR
CNlbEngine::EnumerateClusters(
    OUT vector <ENGINEHANDLE> & ClusterIdList
    )
{
    TRACE_INFO(L"-> %!FUNC!");

    mfn_Lock();

    map< ENGINEHANDLE, CEngineCluster* >::iterator iCluster;
    
    ClusterIdList.clear();
    
    for (iCluster = m_mapIdToEngineCluster.begin(); 
         iCluster != m_mapIdToEngineCluster.end(); 
         iCluster++) 
    {
        ENGINEHANDLE ehClusterId = (*iCluster).first;
        
        if (m_mapIdToEngineCluster[ehClusterId])
            ClusterIdList.push_back(ehClusterId);
    }

    mfn_Unlock();

    TRACE_INFO(L"<- %!FUNC!");
    return NLBERR_OK;
}

NLBERROR
CNlbEngine::EnumerateHosts(
    OUT vector <ENGINEHANDLE> & HostIdList
    )
{
    TRACE_INFO(L"-> %!FUNC!");
// TODO
    TRACE_INFO(L"<- %!FUNC!");
    return NLBERR_OK;
}

NLBERROR
CNlbEngine::GetAllHostConnectionStrings(
    OUT vector <_bstr_t> & ConnectionStringList
    )
//
// Actually only returns the strings for hosts that have at least one
// interface that is part of a cluster that is displayed  by NLB Manager.
// (see .net server bug 499068)
//
{
    TRACE_INFO(L"-> %!FUNC!");

    mfn_Lock();

    map< ENGINEHANDLE, CHostSpec* >::iterator iter;

    for( iter = m_mapIdToHostSpec.begin();
         iter != m_mapIdToHostSpec.end();
         ++iter)
    {
        CHostSpec *pHSpec =  (CHostSpec *) ((*iter).second);
        if (pHSpec != NULL)
        {
            if (mfn_HostHasManagedClustersLk(pHSpec))
            {
                ConnectionStringList.push_back(pHSpec->m_ConnectionString);
            }
        }
    }

    mfn_Unlock();

    TRACE_INFO(L"<- %!FUNC!");
    return NLBERR_OK;
}


BOOL
CNlbEngine::GetObjectType(
    IN  ENGINEHANDLE ehObj,
    OUT IUICallbacks::ObjectType &objType
    )
{
    BOOL fRet = FALSE;
    UINT uType;

    objType = IUICallbacks::OBJ_INVALID;

    if (ehObj == NULL)
    {
        goto end;
    } 
    //
    // Extract object type -- the first TYPE_BIT_COUNT bits of ehObj.
    //
    uType = ((UINT) ehObj) & (0xffffffff>>(32-TYPE_BIT_COUNT));

    mfn_Lock();

    switch(uType)
    {
    case IUICallbacks::OBJ_INTERFACE:

        if (m_mapIdToInterfaceSpec[ehObj] != NULL)
        {
            objType = IUICallbacks::OBJ_INTERFACE;
            fRet = TRUE;
        }
        break;

     case IUICallbacks::OBJ_CLUSTER:
        if (m_mapIdToEngineCluster[ehObj] != NULL)
        {
            objType = IUICallbacks::OBJ_CLUSTER;
            fRet = TRUE;
        }
        break;

     case IUICallbacks::OBJ_HOST:
        if (m_mapIdToHostSpec[ehObj] != NULL)
        {
            objType = IUICallbacks::OBJ_HOST;
            fRet = TRUE;
        }
        break;

    case IUICallbacks::OBJ_OPERATION:

        if (m_mapIdToOperation[ehObj] != NULL)
        {
            objType = IUICallbacks::OBJ_OPERATION;
            fRet = TRUE;
        }
        break;

    default:
        break;
    }

    mfn_Unlock();

end:

    return fRet;
}

//
// Return a bitmap of available host IDs for the specified cluster.
//
ULONG
CNlbEngine::GetAvailableHostPriorities(
        ENGINEHANDLE ehCluster // OPTIONAL
        )
{
    ULONG UsedPriorities = 0;
    
    mfn_Lock();

    do // while false
    {
        if (ehCluster == NULL) break;

        CEngineCluster *pECluster = m_mapIdToEngineCluster[ehCluster]; // map
        if (pECluster == NULL) break;
        
        //
        // For each interface, 
        // build up a bitmap of used priorities. Return the inverse of that
        // bitmap.
        //
        for( int i = 0; i < pECluster->m_cSpec.m_ehInterfaceIdList.size(); ++i )
        {

            ENGINEHANDLE ehIId =  pECluster->m_cSpec.m_ehInterfaceIdList[i];
            CInterfaceSpec *pISpec =  m_mapIdToInterfaceSpec[ehIId]; // map
            if (pISpec == NULL)
            {
                TRACE_CRIT("%!FUNC! no interface in ehC 0x%x for ehI 0x%x",
                    ehCluster, ehIId);
                continue;
            }
            if (pISpec->m_NlbCfg.IsValidNlbConfig())
            {
                UINT HostPriority = pISpec->m_NlbCfg.NlbParams.host_priority;
                UsedPriorities |= (1<<(HostPriority-1));
            }
        }
    } while (FALSE);

    mfn_Unlock();

    return ~UsedPriorities;
}

//
// Fill in an array of bitmaps of available priorities for each specified
// port rule. The port rule must be valid.
// If a port rule is not single-host-priority, the bitmap for that 
// port rule is undefined.
//
NLBERROR
CNlbEngine::GetAvailablePortRulePriorities(
            IN ENGINEHANDLE    ehCluster, OPTIONAL
            IN UINT            NumRules,
            IN WLBS_PORT_RULE  rgRules[],
            IN OUT ULONG       rgAvailablePriorities[] // At least NumRules
            )
{
    //
    // If ehCluster==NULL, set all to 0xffffffff
    //
    // For each interface, locate the specified port rules (based on vip and
    // start port) and build up a bitmap of used priorities.
    // fill in rgRules with the inverse of the bitmaps.
    //
    // Todo Account for priorities of pending operations.
    //

    mfn_Lock();

    //
    // We initially use rgAvailablePriorities to store USED priorities.
    // Intialize to 0.
    //
    for (UINT u=0; u<NumRules; u++)
    {
         rgAvailablePriorities[u] = 0;
    }

    do // while false
    {
        ULONG       *rgUsedPriorities = rgAvailablePriorities;

        if (ehCluster == NULL) break;

        CEngineCluster *pECluster = m_mapIdToEngineCluster[ehCluster]; // map
        if (pECluster == NULL) break;
        
        //
        // For each interface, locate the specified port rule and
        // build up a bitmap of used priorities. Return the inverse of that
        // bitmap.
        //
        for( int i = 0; i < pECluster->m_cSpec.m_ehInterfaceIdList.size(); ++i )
        {

            ENGINEHANDLE ehIId =  pECluster->m_cSpec.m_ehInterfaceIdList[i];
            CInterfaceSpec *pISpec =  m_mapIdToInterfaceSpec[ehIId]; // map
            if (pISpec == NULL)
            {
                TRACE_CRIT("%!FUNC! no interface in ehC 0x%x for ehI 0x%x",
                    ehCluster, ehIId);
                continue;
            }

            if (pISpec->m_NlbCfg.IsValidNlbConfig())
            {
                //
                // get_used_port_rule_priorities will add its priority
                // to the bitmap of each single-host port rule.
                //
                (void) get_used_port_rule_priorities(
                            REF pISpec->m_NlbCfg,
                            NumRules,
                            rgRules,
                            rgUsedPriorities
                            );
            }
        }

    } while (FALSE);

    //
    // We initially used rgAvailablePriorities to store USED priorities.
    // So invert each.
    //
    for (UINT u=0; u<NumRules; u++)
    {
         rgAvailablePriorities[u] =  ~rgAvailablePriorities[u];
    }

    mfn_Unlock();

    return NLBERR_OK;
}



NLBERROR
CNlbEngine::mfn_GetHostFromInterfaceLk(
      IN ENGINEHANDLE ehIId,
      OUT CInterfaceSpec* &pISpec,
      OUT CHostSpec* &pHSpec
      )
{
    NLBERROR nerr = NLBERR_INTERNAL_ERROR;

    pHSpec = NULL;
    pISpec =  m_mapIdToInterfaceSpec[ehIId]; // map

    if (pISpec == NULL)
    {
        nerr = NLBERR_NOT_FOUND;
    }
    else
    {
        ENGINEHANDLE ehHost = pISpec->m_ehHostId;
        pHSpec =  m_mapIdToHostSpec[ehHost]; // map
        nerr = NLBERR_OK;
    }

    return nerr;
}


void
CNlbEngine::mfn_GetInterfaceHostNameLk(
      ENGINEHANDLE ehIId,
      _bstr_t &bstrHostName
      )
/*
    This function returns the host name of the specified interface.
    It sets bstrHostName to "" (not NULL) on error.
*/
{
    NLBERROR nerr;
    _bstr_t *pName = NULL;
    CHostSpec *pHSpec =  NULL;
    CInterfaceSpec *pISpec =  NULL;


    nerr = CNlbEngine::mfn_GetHostFromInterfaceLk(ehIId,REF pISpec, REF pHSpec);

    if (nerr == NLBERR_OK)
    {
        pName = &pHSpec->m_MachineName;
    }

    if (pName == NULL)
    {
        bstrHostName = _bstr_t(L"");
    }
    else
    {
        bstrHostName = *pName;
    }
}


ENGINEHANDLE
CNlbEngine::mfn_NewHandleLk(IUICallbacks::ObjectType type)
//
// Returns a unique number from 1 to 2^31-1 (1 to ~ 2 billion).
// If it is called more than 2 billion times it will start returning zero
// from then onwards.
//
{
    ULONG uVal =0;

    if (m_fPrepareToDeinitialize)
    {
        goto end;
    }

    if ((UINT)type >= (1<<TYPE_BIT_COUNT))
    {
        TRACE_CRIT(L"%!FUNC!: Invalid obj type");
        goto end;
    }

    if (!m_fHandleOverflow)
    {
        uVal = (ULONG) InterlockedIncrement(&m_NewHandleValue);

        //
        // uVal could be less than 2^(32-TypeBitCount)) to save
        // so that it doesn't over flow when we shift it by TypeBitCounts.
        //
        // Extreme cases: if TypeBitCount==32, uVal should be less
        // then 1<<0, or 1 -- so it can only have one value 0.
        //
        // If TypeBitCount==0, uVal should be less than 1<<32, i.e., any
        // valid uint value.
        //
        if (uVal >= (1<<(32-TYPE_BIT_COUNT)))
        {
            //
            // Overflow!!!
            //
            TRACE_CRIT(L"%!FUNC!: Handle overflow!");
            m_fHandleOverflow = TRUE;
            uVal = 0;
            goto end;
        }

        //
        // Construct the handle by compositing the type and the counter value.
        //
        uVal = ((uVal<<TYPE_BIT_COUNT) | (UINT) type);
    }

end:

    return (ENGINEHANDLE) uVal;
}


NLBERROR
CNlbEngine::ApplyClusterWideConfiguration(
        IN      const NLB_EXTENDED_CLUSTER_CONFIGURATION &ClusterConfig,
        IN OUT       NLB_EXTENDED_CLUSTER_CONFIGURATION &ConfigToUpdate
        )
/*
    Apply only the cluster-wide parameters in ClusterConfig to
    ConfigToUpdate.

    When updateing port rules, try to preserve the host-specific info
    (load weight, host priority).


    NOTE: It WILL replace the ConfigToUpdate's list of IP addresses with
    the list of IP addresses in ClusterConfig. This will REMOVE the 
    dedicated IP address from the list of IP addresses. The dedicated IP
    address will be added before the interface is actually updated -- in
    CNlbEngine::UpdateInterface.


    WLBS_REG_PARAMS cluster-wide params...

        BOOL fRctEnabled
        BOOL fMcastSupport
        BOOL fIGMPSupport
        
        TCHAR cl_ip_addr[CVY_MAX_CL_IP_ADDR + 1]
        TCHAR cl_net_mask[CVY_MAX_CL_NET_MASK + 1]
        TCHAR domain_name[CVY_MAX_DOMAIN_NAME + 1]
        
        bool fChangePassword
        TCHAR szPassword[CVY_MAX_RCT_CODE + 1]
        DWORD dwNumRules
        NETCFG_WLBS_PORT_RULE port_rules[CVY_MAX_RULES]


*/
{
    NLBERROR nerr = NLBERR_INTERNAL_ERROR;
    WLBS_PORT_RULE *pOldRules = NULL;
    WLBS_PORT_RULE *pNewRules = NULL;

    if (!ClusterConfig.fBound || !validate_extcfg(ClusterConfig))
    {
        TRACE_CRIT("%!FUNC! -- cluster configuration is invalid!");
        goto end;
    }

    if(!ConfigToUpdate.IsValidNlbConfig())
    {
        //
        // We expect the configuration to be valid -- i.e., NLB bound, with
        // valid parameters.
        //
        TRACE_CRIT("%!FUNC! --  current configuration is unbound/invalid!");
        goto end;
    }

    ConfigToUpdate.NlbParams.rct_enabled = ClusterConfig.NlbParams.rct_enabled;
    ConfigToUpdate.NlbParams.mcast_support = ClusterConfig.NlbParams.mcast_support;
    ConfigToUpdate.NlbParams.fIGMPSupport = ClusterConfig.NlbParams.fIGMPSupport;


    CopyMemory(
        ConfigToUpdate.NlbParams.cl_ip_addr,
        ClusterConfig.NlbParams.cl_ip_addr,
        sizeof(ConfigToUpdate.NlbParams.cl_ip_addr)
        );

    CopyMemory(
        ConfigToUpdate.NlbParams.cl_net_mask,
        ClusterConfig.NlbParams.cl_net_mask,
        sizeof(ConfigToUpdate.NlbParams.cl_net_mask)
        );
    
    CopyMemory(
        ConfigToUpdate.NlbParams.domain_name,
        ClusterConfig.NlbParams.domain_name,
        sizeof(ConfigToUpdate.NlbParams.domain_name)
        );

    //
    // TODO -- we need to preserve Ip addresses and their order in
    // hosts, as far as possible. For now we decide the order.
    //
    {
        BOOL fRet = FALSE;
        NlbIpAddressList addrList;

        fRet = addrList.Set(ClusterConfig.NumIpAddresses,
                    ClusterConfig.pIpAddressInfo, 0);

        if (!fRet)
        {
            TRACE_CRIT(L"Could not copy over ip addresses!");
            goto end;
        }

        ConfigToUpdate.SetNetworkAddressesRaw(NULL,0);
        addrList.Extract(
            REF ConfigToUpdate.NumIpAddresses,
            REF ConfigToUpdate.pIpAddressInfo
            );
    }

    // password -- copy and set some flag only if changed.
    {
        LPCWSTR szNewPassword = NULL;
        szNewPassword = ClusterConfig.GetNewRemoteControlPasswordRaw();
    
        //
        // Note: szNewPassword will be NULL UNLESS the user has explicitly
        // specified a new password.
        //
        ConfigToUpdate.SetNewRemoteControlPassword(szNewPassword);
    }



    //
    // Fold in port rules.
    //
    {
        UINT NumOldRules=0;
        UINT NumNewRules=0;
        WBEMSTATUS wStat;

        wStat =  CfgUtilGetPortRules(
                    &ConfigToUpdate.NlbParams,
                    &pOldRules,
                    &NumOldRules
                    );
        if (FAILED(wStat))
        {
            TRACE_CRIT("%!FUNC! error 0x%08lx extracting old port rules!", wStat);
            pOldRules=NULL;
            goto end;
        }

        wStat =  CfgUtilGetPortRules(
                    &ClusterConfig.NlbParams,
                    &pNewRules,
                    &NumNewRules
                    );
        if (FAILED(wStat))
        {
            TRACE_CRIT("%!FUNC! error 0x%08lx extracting new port rules!", wStat);
            pNewRules = NULL;
            goto end;
        }

        //
        // Now for each new port rule, if it makes sense, pick up
        // host-specific info from old port rules.
        //
        for (UINT u=0; u<NumNewRules;u++)
        {
            WLBS_PORT_RULE *pNewRule = pNewRules+u;
            const WLBS_PORT_RULE *pOldRule =  NULL; // mapStartPortToOldRule[pNewRule->start_port];
            UINT NewMode = pNewRule->mode;

            pOldRule =  find_port_rule(
                            pOldRules,
                            NumOldRules,
                            pNewRule->virtual_ip_addr,
                            pNewRule->start_port
                            );

            if (NewMode != CVY_NEVER)
            {
                //
                // We need to fill in host-specific stuff
                //
                if (pOldRule!=NULL && pOldRule->mode == NewMode)
                {
                    //
                    // We can pick up the old rule's info.
                    //
                    if (NewMode == CVY_MULTI)
                    {
                        //
                        // We ignore the cluster's equal_load  and
                        // load fields.
                        //
                        pNewRule->mode_data.multi.equal_load =
                                        pOldRule->mode_data.multi.equal_load;
                        pNewRule->mode_data.multi.load =
                                            pOldRule->mode_data.multi.load;
                    }
                    else if (NewMode == CVY_SINGLE)
                    {
                        //
                        // TODO: priorities can potentially clash here.
                        //
                        pNewRule->mode_data.single.priority = 
                        pOldRule->mode_data.single.priority;
                    }
                }
                else
                {
                    //
                    // We need to pick defaults.
                    //
                    if  (NewMode == CVY_MULTI)
                    {
                        pNewRule->mode_data.multi.equal_load = TRUE; //default

                        pNewRule->mode_data.multi.load = 50;
                    }
                    else if (NewMode == CVY_SINGLE)
                    {
                        //
                        // TODO: need to pick a new priority here!
                        // for now we pick the host's priority -- but
                        // we need to really pick one that
                        // doesn't clash!
                        //
                        pNewRule->mode_data.single.priority = 
                        ConfigToUpdate.NlbParams.host_priority;
                    }
                }
            }
        }

        //
        // Finally, set the new port rules..
        //
    
        wStat =   CfgUtilSetPortRules(
                    pNewRules,
                    NumNewRules,
                    &ConfigToUpdate.NlbParams
                    );
        if (FAILED(wStat))
        {
            TRACE_CRIT("%!FUNC! error 0x%08lx setting new port rules!", wStat);
            goto end;
        }

        nerr = NLBERR_OK;
    }

end:

    delete pOldRules; // can be NULL
    delete pNewRules; // can be NULL

    return nerr;
}


NLBERROR
CNlbEngine::mfn_RefreshHost(
        IN  PWMI_CONNECTION_INFO pConnInfo,
        IN  ENGINEHANDLE ehHost,
        IN  BOOL  fOverwriteConnectionInfo
        )
{

    NLBERROR nerr = NLBERR_INTERNAL_ERROR;
    LPWSTR *pszNics = NULL;
    UINT   NumNics = 0;
    UINT   NumNlbBound = 0;
    WBEMSTATUS wStatus = WBEM_E_CRITICAL_ERROR;
    CHostSpec *pHost = NULL;
    vector<ENGINEHANDLE> InterfaceListCopy;


    wStatus =  NlbHostGetCompatibleNics(
                pConnInfo,
                &pszNics,
                &NumNics,
                &NumNlbBound
                );

    if (FAILED(wStatus))
    {
        pszNics = NULL;
        // TODO -- check for authentication failure -- ask for new creds.
    }

    //
    // Update the connection string, IP,  and status of the host.
    //
    {
        mfn_Lock();
        pHost =  m_mapIdToHostSpec[ehHost]; // map
        if (pHost != NULL)
        {
            pHost->m_fReal = TRUE;

            if (fOverwriteConnectionInfo)
            {
                pHost->m_ConnectionString = _bstr_t(pConnInfo->szMachine);
                pHost->m_UserName = _bstr_t(pConnInfo->szUserName);
                pHost->m_Password = _bstr_t(pConnInfo->szPassword);
            }

            if (FAILED(wStatus))
            {
                pHost->m_fUnreachable = TRUE;
            }
            else
            {
                pHost->m_fUnreachable = FALSE;
            }
        }
        pHost = NULL;
        mfn_Unlock();
    }

    //
    // Update that status of all interfaces in the host.
    //
    mfn_NotifyHostInterfacesChange(ehHost);
    
    if (FAILED(wStatus))
    {
        // TODO -- proper return error. 
        goto end;
    }

    //
    // We first go through and add all the interfaces- 
    //
    mfn_Lock();
    pHost =  m_mapIdToHostSpec[ehHost]; // map
    if (pHost == NULL)
    {
        mfn_Unlock();
        goto end;
    }
    for (UINT u=0; u<NumNics; u++)
    {
        LPCWSTR szNic           = pszNics[u];
        ENGINEHANDLE  ehInterface = NULL;
        CInterfaceSpec *pISpec = NULL;
        BOOL fIsNew = FALSE;


        nerr =  mfn_LookupInterfaceByGuidLk(
                    szNic,
                    TRUE, // TRUE==ok to create
                    REF ehInterface,
                    REF pISpec,
                    REF fIsNew
                    );

        if (nerr == NLBERR_OK)
        {
            if (fIsNew)
            {
                //
                // We've just created a brand new interface object.
                // Add it to the host's list of interfaces, and
                // add a reference to this host in the interface object.
                //
                pISpec->m_ehHostId = ehHost;
                pISpec->m_fReal = FALSE; // we'll update this later.
                pHost->m_ehInterfaceIdList.push_back(ehInterface);

            }

            //
            // Keep a copy of the machine name in the interface.
            // Here we'll update if it's changed -- could happen if
            // host's machine name has changed while NLB manager is still
            // running.
            //
            if (pISpec->m_bstrMachineName != pHost->m_MachineName) // bstr
            {
                pISpec->m_bstrMachineName = pHost->m_MachineName; // bstr
            }
        }
    }
    InterfaceListCopy = pHost->m_ehInterfaceIdList; // vector copy
    pHost = NULL;
    mfn_Unlock();

    //
    // Having added any new interfaces, we now we go through 
    // ALL interfaces in the host, refreshing them -- potentially getting
    // rid of ones which are no longer in the host.
    //
    for(u = 0; u < InterfaceListCopy.size(); ++u )
    {
        ENGINEHANDLE ehIId =  InterfaceListCopy[u];
        (void) this->RefreshInterface(
                        ehIId,
                        TRUE,  // TRUE == start a new operation
                        FALSE   // FALSE == this is not cluster-wide
                        ); 
    }

    nerr = NLBERR_OK;


end:

    delete pszNics;
    return nerr;
}



NLBERROR
CNlbEngine::mfn_LookupInterfaceByGuidLk(
    IN  LPCWSTR szInterfaceGuid,
    IN  BOOL fCreate,
    OUT ENGINEHANDLE &ehInterface,
    OUT CInterfaceSpec*   &pISpec,
    OUT BOOL &fIsNew
    )
{
    NLBERROR nerr = NLBERR_INTERNAL_ERROR;

    fIsNew = FALSE;

    ehInterface = NULL;
    pISpec=NULL;

    map< ENGINEHANDLE, CInterfaceSpec* >::iterator iter;

    for( iter = m_mapIdToInterfaceSpec.begin();
         iter != m_mapIdToInterfaceSpec.end();
         ++iter)
    {
        CInterfaceSpec*   pTmp = (*iter).second;
        ENGINEHANDLE ehTmp =  (*iter).first;
        if (pTmp == NULL || ehTmp == NULL)
        {
            TRACE_CRIT("%!FUNC! map: unexpected pair(eh=0x%lx, pISpec=%p)",
                 (UINT) ehTmp, pTmp);
            continue;
        }
        else
        {
            TRACE_VERB("%!FUNC! map: pair(eh=0x%lx, pISpec=%p), szGuid=%ws",
                 (UINT) ehTmp, pTmp, (LPCWSTR) pTmp->m_Guid);
        }

        if (!_wcsicmp((LPCWSTR)pTmp->m_Guid, szInterfaceGuid))
        {
            // found it!
            ehInterface =  ehTmp;
            pISpec = pTmp;
            break;
        }
    }

    if (pISpec!=NULL)
    {
        if (ehInterface==NULL)
        {
            TRACE_CRIT("%!FUNC! unexpected null handle for pISpec %ws", szInterfaceGuid);
        }
        else
        {
            nerr = NLBERR_OK;
        }
        goto end;
    }

    if (!fCreate)
    {
      nerr = NLBERR_NOT_FOUND;
      goto end;
    }

    //
    // Create a new interface
    //
    {
        pISpec = new CInterfaceSpec;
        if (pISpec == NULL)
        {
            nerr = NLBERR_RESOURCE_ALLOCATION_FAILURE;
            goto end;
        }
        fIsNew = TRUE;
        pISpec->m_fReal = FALSE;
        pISpec->m_Guid = _bstr_t(szInterfaceGuid);


        //
        // Get us a handle to this interface
        //
        ehInterface = CNlbEngine::mfn_NewHandleLk(IUICallbacks::OBJ_INTERFACE);
        if (ehInterface == NULL)
        {
            TRACE_CRIT("%!FUNC! could not reserve a new interface handle");
            nerr = NLBERR_RESOURCE_ALLOCATION_FAILURE;
            delete pISpec;
            pISpec=NULL;
            goto end;
        }
    
        TRACE_VERB("%!FUNC!: map new pair(eh=0x%lx, pISpec=%p), szGuid=%ws",
                 (UINT) ehInterface, pISpec, (LPCWSTR) pISpec->m_Guid);
        m_mapIdToInterfaceSpec[ehInterface] = pISpec;

        nerr = NLBERR_OK;
    }

end:

    return nerr;
}


NLBERROR
CNlbEngine::mfn_LookupInterfaceByIpLk(
    IN  ENGINEHANDLE    ehHost, // OPTIONAL  -- if NULL all hosts are looked
    IN  LPCWSTR         szIpAddress,
    OUT ENGINEHANDLE    &ehInterface
    )
{
    NLBERROR nerr = NLBERR_INTERNAL_ERROR;
    ehInterface = NULL;

    map< ENGINEHANDLE, CInterfaceSpec* >::iterator iter;

    for( iter = m_mapIdToInterfaceSpec.begin();
         iter != m_mapIdToInterfaceSpec.end();
         ++iter)
    {
        const CInterfaceSpec*   pTmp = (*iter).second;
        ENGINEHANDLE ehTmp =  (*iter).first;
        if (pTmp == NULL || ehTmp == NULL)
        {
            continue;
        }

        if (ehHost==NULL || ehHost==pTmp->m_ehHostId)
        {
            UINT NumIps = pTmp->m_NlbCfg.NumIpAddresses;
            const NLB_IP_ADDRESS_INFO *pInfo = pTmp->m_NlbCfg.pIpAddressInfo;

            for (UINT u = 0; u<NumIps; u++)
            {
                if (!wcscmp(pInfo[u].IpAddress, szIpAddress))
                {
                    // found it!
                    TRACE_VERB(L"%!FUNC! found szIp %ws on ehIF 0x%lx",
                            szIpAddress, ehTmp);
                    ehInterface =  ehTmp;
                    break;
                }
            }
        }
    }

    if (ehInterface == NULL)
    {
        nerr = NLBERR_NOT_FOUND;
    }
    else
    {
        nerr = NLBERR_OK;
    }

    return nerr;
}



NLBERROR
CNlbEngine::mfn_LookupHostByNameLk(
    IN  LPCWSTR szHostName,
    IN  BOOL fCreate,
    OUT ENGINEHANDLE &ehHost,
    OUT CHostSpec*   &pHostSpec,
    OUT BOOL &fIsNew
    )
{
    NLBERROR nerr = NLBERR_INTERNAL_ERROR;

    fIsNew = FALSE;

    ehHost = NULL;

    map< ENGINEHANDLE, CHostSpec* >::iterator iter;
    pHostSpec = NULL;

    for( iter = m_mapIdToHostSpec.begin();
         iter != m_mapIdToHostSpec.end();
         ++iter)
    {
        CHostSpec*   pTmp= (*iter).second;
        ENGINEHANDLE ehTmp =  (*iter).first;
        if (pTmp == NULL || ehTmp == NULL)
        {
            TRACE_CRIT("%!FUNC! map: unexpected pair(eh=0x%lx, pHSpec=%p)",
                 (UINT) ehTmp, pTmp);
            continue;
        }
        else
        {
            TRACE_VERB("%!FUNC! map: pair(eh=0x%lx, pHSpec=%p), szHost=%ws",
                 (UINT) ehTmp, pTmp, (LPCWSTR) pTmp->m_MachineName);
        }
        if (!_wcsicmp(pTmp->m_MachineName, szHostName))
        {
            // found it!
            ehHost =  ehTmp;
            pHostSpec = pTmp;
            break;
        }
    }

    if (pHostSpec!=NULL)
    {
        if (ehHost==NULL)
        {
            TRACE_CRIT("%!FUNC! unexpected null handle for pHostSpec %ws", szHostName);
        }
        else
        {
            nerr = NLBERR_OK;
        }
        goto end;
    }

    if (!fCreate)
    {
      nerr = NLBERR_NOT_FOUND;
      goto end;
    }

    //
    // Create a new host
    //
    {
        pHostSpec = new CHostSpec;
        if (pHostSpec == NULL)
        {
            nerr = NLBERR_RESOURCE_ALLOCATION_FAILURE;
            goto end;
        }
        fIsNew = TRUE;
        pHostSpec->m_fReal = FALSE;
        pHostSpec->m_MachineName = _bstr_t(szHostName);


        //
        // Get us a handle to this host
        //
        ehHost = CNlbEngine::mfn_NewHandleLk(IUICallbacks::OBJ_HOST);
        if (ehHost == NULL)
        {
            TRACE_CRIT("%!FUNC! could not reserve a new host handle");
            nerr = NLBERR_RESOURCE_ALLOCATION_FAILURE;
            delete pHostSpec;
            pHostSpec=NULL;
            goto end;
        }
    
        m_mapIdToHostSpec[ehHost] = pHostSpec;
        TRACE_VERB("%!FUNC!: map new pair(eh=0x%lx, pHost=%p), szName=%ws",
                 (UINT) ehHost, pHostSpec, (LPCWSTR) pHostSpec->m_MachineName);


        nerr = NLBERR_OK;
    }

end:

    return nerr;
}


VOID
CNlbEngine::mfn_NotifyHostInterfacesChange(ENGINEHANDLE ehHost)
{
    vector<ENGINEHANDLE> InterfaceListCopy;

    //
    // Get copy of interface list (because we can't callback into the UI
    // with locks held).
    //
    {
        mfn_Lock();
    
        CHostSpec *pHSpec = NULL;
    
        pHSpec =  m_mapIdToHostSpec[ehHost]; // map
        if (pHSpec == NULL)
        {
            TRACE_CRIT("%!FUNC! invalid host handle 0x%lx", (UINT)ehHost);
        }
        else
        {
            InterfaceListCopy = pHSpec->m_ehInterfaceIdList; // vector copy
        }
        mfn_Unlock();
    }

    for(int i = 0; i < InterfaceListCopy.size(); ++i )
    {
        ENGINEHANDLE ehIId =  InterfaceListCopy[i];
        m_pCallbacks->HandleEngineEvent(
            IUICallbacks::OBJ_INTERFACE,
            NULL, // ehClusterId,
            ehIId,
            IUICallbacks::EVT_STATUS_CHANGE
            );
    }
}

NLBERROR
CNlbEngine::LookupClusterByIP(
        IN  LPCWSTR szIP,
        IN  const NLB_EXTENDED_CLUSTER_CONFIGURATION *pInitialConfig OPTIONAL,
        OUT ENGINEHANDLE &ehCluster,
        OUT BOOL &fIsNew
        )
//
// if pInitialConfig below is NULL we'll lookup and not try to create.
// if not NULL and we don't find an existing cluster, well create
// a new one and initialize it with the specified configuration.
//
{
    NLBERROR nerr = NLBERR_INTERNAL_ERROR;

    mfn_Lock();

    fIsNew = FALSE;
    ehCluster = NULL;

    map< ENGINEHANDLE, CEngineCluster* >::iterator iter;

    for( iter = m_mapIdToEngineCluster.begin();
         iter != m_mapIdToEngineCluster.end();
         ++iter)
    {
        CEngineCluster*   pTmp = (*iter).second;
        ENGINEHANDLE ehTmp =  (*iter).first;
        LPCWSTR szTmpIp = NULL;
        if (pTmp == NULL || ehTmp == NULL)
        {
            TRACE_CRIT("%!FUNC! map: unexpected pair(eh=0x%lx, pEC=%p)",
                 (UINT) ehTmp, pTmp);
            continue;
        }
        else
        {
            szTmpIp = pTmp->m_cSpec.m_ClusterNlbCfg.NlbParams.cl_ip_addr;
            TRACE_VERB("%!FUNC! map: pair(eh=0x%lx, pEC=%p), szIP=%ws",
                 (UINT) ehTmp, pTmp, szTmpIp);
        }

        if (!_wcsicmp(szTmpIp, szIP))
        {
            // found it!
            ehCluster =  ehTmp;
            break;
        }
    }

    if (ehCluster!=NULL)
    {
        nerr = NLBERR_OK;
        goto end;
    }

    if (pInitialConfig == NULL)
    {
      nerr = NLBERR_NOT_FOUND;
      goto end;
    }

    //
    // Create a new cluster
    //
    {
        CEngineCluster*    pECluster = new CEngineCluster;

        if (pECluster == NULL)
        {
            TRACE_CRIT("%!FUNC! could not allocate cluster object");
            nerr = NLBERR_RESOURCE_ALLOCATION_FAILURE;
            goto end;
        }

        fIsNew = TRUE;
        WBEMSTATUS wStatus;
        wStatus = pECluster->m_cSpec.m_ClusterNlbCfg.Update(pInitialConfig);
        //
        // Note: Update above has the side effect of setting
        // m_ClusterNlbCfg's szNewPassword field to NULL -- this is what
        // we want.
        //
        if (FAILED(wStatus))
        {
            TRACE_CRIT("%!FUNC! could not copy cluster spec. Err=0x%lx!",
                    (UINT) wStatus);
            nerr = NLBERR_RESOURCE_ALLOCATION_FAILURE;
            goto end;
        }


        //
        // Remove the dedicated IP address, if any from the cluster version of
        // NLB Config -- both from the NlbParams and from the IP address list.
        //
        remove_dedicated_ip_from_nlbcfg(REF pECluster->m_cSpec.m_ClusterNlbCfg);
    
        //
        // Get us a handle to this cluster
        //
        ehCluster = CNlbEngine::mfn_NewHandleLk(IUICallbacks::OBJ_CLUSTER);

        if (ehCluster == NULL)
        {
            TRACE_CRIT("%!FUNC! could not reserve a new cluster handle");
            nerr = NLBERR_RESOURCE_ALLOCATION_FAILURE;
            delete pECluster;
            goto end;
        }
    
        m_mapIdToEngineCluster[ehCluster] = pECluster;
        TRACE_VERB("%!FUNC!: map new pair(eh=0x%lx, pEC=%p)",
                     (UINT) ehCluster, pECluster);
    
        mfn_Unlock();
    
        //
        // Call the ui to notify it about the new cluster creation.
        //
        m_pCallbacks->HandleEngineEvent(
            IUICallbacks::OBJ_CLUSTER,
            ehCluster,
            ehCluster,
            IUICallbacks::EVT_ADDED
            );
        ProcessMsgQueue();

        mfn_Lock();

        nerr = NLBERR_OK;
    }

end:

    mfn_Unlock();

    return nerr;
}

NLBERROR
CNlbEngine::LookupInterfaceByIp(
        IN  ENGINEHANDLE    ehHost, // OPTIONAL  -- if NULL all hosts are looked
        IN  LPCWSTR         szIpAddress,
        OUT ENGINEHANDLE    &ehIf
        )
{
    NLBERROR nerr;
    mfn_Lock();
    nerr =  mfn_LookupInterfaceByIpLk(ehHost, szIpAddress, REF ehIf);
    mfn_Unlock();

    return nerr;
}


NLBERROR
CNlbEngine::LookupConnectionInfo(
    IN  LPCWSTR szConnectionString,
    OUT _bstr_t &bstrUsername,
    OUT _bstr_t &bstrPassword
    )
//
// Look through existing hosts, looking for any which have a matching 
// connection string. If found, fill out bstrUsername and bstrPassword
// for that host.
//
{
    NLBERROR nerr = NLBERR_NOT_FOUND;
    TRACE_VERB(L"-> Lookup: szConnString=%ws", szConnectionString);

    bstrUsername = (LPCWSTR) NULL;
    bstrPassword = (LPCWSTR) NULL;

    mfn_Lock();

    map< ENGINEHANDLE, CHostSpec* >::iterator iter;

    for( iter = m_mapIdToHostSpec.begin();
         iter != m_mapIdToHostSpec.end();
         ++iter)
    {
        CHostSpec*      pTmp = (*iter).second;
        LPCWSTR         szHostConnString = NULL;
        ENGINEHANDLE    ehTmp =  (*iter).first;

        if (pTmp == NULL || ehTmp == NULL)
        {
            continue;
        }

        szHostConnString = (LPCWSTR) pTmp->m_ConnectionString;
        if (szHostConnString == NULL)
        {
            szHostConnString = L"";
        }

        if (!_wcsicmp(szHostConnString, szConnectionString))
        {
            // found it! Fill out username and password.
            bstrUsername = pTmp->m_UserName;
            bstrPassword = pTmp->m_Password;
            LPCWSTR szU = (LPCWSTR) bstrUsername;
            LPCWSTR szP = (LPCWSTR) bstrPassword;
            if (szU == NULL) szU = L"";
            if (szP == NULL) szP = L"";
            nerr = NLBERR_OK;
            TRACE_VERB(L"Found un=%ws pwd=%ws", szU, szP);
            break;
        }
    }

    mfn_Unlock();

    TRACE_VERB("<- returns 0x%x", nerr);
    return nerr;
}


NLBERROR
CNlbEngine::GetInterfaceInformation(
        IN  ENGINEHANDLE    ehInterface,
        OUT CHostSpec&      hSpec,
        OUT CInterfaceSpec& iSpec,
        OUT _bstr_t&        bstrDisplayName,
        OUT INT&            iIcon,
        OUT _bstr_t&        bstrStatus
        )
/*
    Looks up a bunch of information about the specified interface.

    bstrDisplayName -- this is a combination of the host name and interface name
    bstrDisplay     -- text version of the interface's operational status.
    iIcon           -- icon version of the interface's operational status.
                        (one of the  Document::IconNames enums)
*/
{
    // First get host and interface spec.
    //
    NLBERROR        nerr;
    LPCWSTR         szHostName  = L"";
    LPCWSTR         szStatus    = L"";

    bstrDisplayName = (LPCWSTR) NULL;
    bstrStatus      = (LPCWSTR) NULL;
    iIcon           = 0;

    nerr = this->GetInterfaceSpec(
                ehInterface,
                REF iSpec
                );

    if (NLBFAILED(nerr))
    {
        TRACE_CRIT("%!FUNC! : could not get interface spec! nerr=0x%lx", nerr);
        goto end;
    }
    nerr = this->GetHostSpec(
            iSpec.m_ehHostId,
            REF hSpec
            );

    if (NLBOK(nerr))
    {
        szHostName = (LPCWSTR) hSpec.m_MachineName;
        if (szHostName == NULL)
        {
            szHostName = L"";
        }
    }
    else
    {
        TRACE_CRIT("%!FUNC! : could not get host spec! nerr=0x%lx", nerr);
        goto end;
    }


    //
    // Determine the icon and bstrStatus
    //
    if (hSpec.m_fUnreachable)
    {
        szStatus = GETRESOURCEIDSTRING(IDS_HOST_STATE_UNREACHABLE); //"Unreachable";
        iIcon = Document::ICON_HOST_UNREACHABLE;
    }
    else if (iSpec.m_fPending)
    {
        szStatus = GETRESOURCEIDSTRING(IDS_HOST_STATE_PENDING); //"Pending";
        iIcon = Document::ICON_CLUSTER_PENDING;
    }
    else if (iSpec.m_fMisconfigured)
    {
        szStatus = GETRESOURCEIDSTRING(IDS_HOST_STATE_MISCONFIGURED); // "Misconfigured"
        iIcon = Document::ICON_HOST_MISCONFIGURED;
    }
    else if (!hSpec.m_fReal)
    {
        szStatus = GETRESOURCEIDSTRING(IDS_HOST_STATE_UNKNOWN); // "Unknown";
        iIcon = Document::ICON_HOST_UNKNOWN;
    }
    else
    {
        szStatus = GETRESOURCEIDSTRING(IDS_HOST_STATE_UNKNOWN); // "Unknown";
        iIcon = Document::ICON_HOST_OK;

        //
        // Choose icon based on operational state if we have it
        //
        if (!iSpec.m_NlbCfg.IsNlbBound())
        {
                szStatus = GETRESOURCEIDSTRING(IDS_STATE_NLB_NOT_BOUND); // L"NLB not bound";
        }
        else if (iSpec.m_fValidClusterState)
        {
            switch(iSpec.m_dwClusterState)
            {
            case  WLBS_CONVERGING:
                iIcon  = Document::ICON_HOST_CONVERGING;
                szStatus = GETRESOURCEIDSTRING(IDS_STATE_CONVERGING);
                // szStatus = L"Converging";
                break;

            case  WLBS_CONVERGED:
            case  WLBS_DEFAULT:
                iIcon  = Document::ICON_HOST_STARTED;
                szStatus = GETRESOURCEIDSTRING(IDS_STATE_CONVERGED);
                // szStatus = L"Converged";
                break;

            case WLBS_STOPPED:
                szStatus = GETRESOURCEIDSTRING(IDS_HOST_STATE_STOPPED);
                iIcon  = Document::ICON_HOST_STOPPED;
                // szStatus = L"Stopped";
                break;

            case WLBS_SUSPENDED:
                szStatus = GETRESOURCEIDSTRING(IDS_HOST_STATE_SUSPENDED);
                iIcon  = Document::ICON_HOST_SUSPENDED;
                // szStatus = L"Suspended";
                break;

            case WLBS_DRAINING:
                szStatus = GETRESOURCEIDSTRING(IDS_HOST_DRAINING);
                // szStatus = L"Draining";
                iIcon  = Document::ICON_HOST_DRAINING;
                break;

            case WLBS_DISCONNECTED:
                szStatus = GETRESOURCEIDSTRING(IDS_HOST_DISCONNECTED);
                // szStatus = L"Disconnected";
                iIcon  = Document::ICON_HOST_DISCONNECTED;
                break;

            default:
                //
                // Don't know what this is -- default to "OK" icon.
                //
                szStatus = GETRESOURCEIDSTRING(IDS_HOST_STATE_UNKNOWN);
                // szStatus = L"Unknown";
                iIcon  = Document::ICON_HOST_OK;
                break;
            }
        }
    }
    bstrStatus = _bstr_t(szStatus);

    //
    // Fill out the DisplayName
    //
    {
        WBEMSTATUS  wStat;
        LPWSTR      szAdapter   = L"";
        WCHAR       rgText[256];


        wStat = iSpec.m_NlbCfg.GetFriendlyName(&szAdapter);
        if (FAILED(wStat))
        {
            szAdapter = NULL;
        }

        StringCbPrintf(
            rgText,
            sizeof(rgText),
            L"%ws(%ws)",
            szHostName,
            (szAdapter==NULL ? L"" : szAdapter)
            );
        delete szAdapter;

        bstrDisplayName = _bstr_t(rgText);
    }

end:

    return nerr;
}

NLBERROR
CNlbEngine::GetInterfaceIdentification(
        IN  ENGINEHANDLE    ehInterface,
        OUT ENGINEHANDLE&   ehHost,
        OUT ENGINEHANDLE&   ehCluster,
        OUT _bstr_t&           bstrFriendlyName,
        OUT _bstr_t&           bstrDisplayName,
        OUT _bstr_t&           bstrHostName
        )
{
    // First get host and interface spec.
    //
    NLBERROR        nerr = NLBERR_INTERNAL_ERROR;
    CInterfaceSpec *pISpec =   NULL;
    LPCWSTR         szHostName  = L"";

    mfn_Lock();

    bstrFriendlyName= (LPCWSTR) NULL;
    bstrDisplayName = (LPCWSTR) NULL;
    ehHost          = NULL;
    ehCluster       = NULL;

    pISpec          =  m_mapIdToInterfaceSpec[ehInterface]; // map

    if (pISpec == NULL)
    {
        TRACE_CRIT("%!FUNC! : could not get interface spec for ehI 0x%lx!",
            ehInterface);
        nerr = NLBERR_INTERFACE_NOT_FOUND;
        goto end;
    }

    if (pISpec->m_ehHostId == NULL)
    {
        TRACE_CRIT("%!FUNC! : ehI 0x%lx has NULL ehHost spec!", ehInterface);
        goto end;
    }
    else
    {
        CHostSpec *pHSpec =  NULL;
        pHSpec =  m_mapIdToHostSpec[pISpec->m_ehHostId]; // map
        if (pHSpec == NULL)
        {
            TRACE_CRIT("%!FUNC! : ehI 0x%lx has invalid ehHost 0x%lx!",
                 ehInterface, pISpec->m_ehHostId);
            goto end;
        }
        
        bstrHostName = pHSpec->m_MachineName;
        szHostName = (LPCWSTR) pHSpec->m_MachineName;
        if (szHostName == NULL)
        {
            szHostName = L"";
        }
    }
    
    nerr = NLBERR_OK;
    ehHost = pISpec->m_ehHostId;
    ehCluster = pISpec->m_ehCluster;

    //
    // Fill out the bstrFriendlyName and bstrDisplayName
    //
    {
        WBEMSTATUS  wStat;
        LPWSTR      szAdapter   = L"";
        WCHAR       rgText[256];

        wStat = pISpec->m_NlbCfg.GetFriendlyName(&szAdapter);
        if (FAILED(wStat))
        {
            szAdapter = NULL;
        }

        StringCbPrintf(
            rgText,
            sizeof(rgText),
            L"%ws(%ws)",
            szHostName,
            (szAdapter==NULL ? L"" : szAdapter)
            );
        bstrFriendlyName = _bstr_t(szAdapter);
        delete szAdapter;

        bstrDisplayName = _bstr_t(rgText);
    }

end:

    mfn_Unlock();

    return nerr;
}


NLBERROR
CNlbEngine::GetClusterIdentification(
        IN  ENGINEHANDLE    ehCluster,
        OUT _bstr_t&           bstrIpAddress, 
        OUT _bstr_t&           bstrDomainName, 
        OUT _bstr_t&           bstrDisplayName
        )
{
    NLBERROR    nerr = NLBERR_NOT_FOUND;
    WCHAR rgTmp[256];

    bstrIpAddress   = (LPCWSTR) NULL;
    bstrDomainName  = (LPCWSTR) NULL;
    bstrDisplayName = (LPCWSTR) NULL;

    mfn_Lock();

    CEngineCluster *pECluster = m_mapIdToEngineCluster[ehCluster]; // map
    
    if (pECluster != NULL)
    {
        WLBS_REG_PARAMS *pParams =&pECluster->m_cSpec.m_ClusterNlbCfg.NlbParams;
        
        StringCbPrintf(
            rgTmp,
            sizeof(rgTmp),
            L"%ws(%ws)",
            pParams->domain_name,
            pParams->cl_ip_addr
            );
        bstrIpAddress   = _bstr_t(pParams->cl_ip_addr);
        bstrDomainName  = _bstr_t(pParams->domain_name);
        bstrDisplayName = _bstr_t(rgTmp);

        nerr = NLBERR_OK;
    }

    mfn_Unlock();

    return nerr;
}


NLBERROR
CNlbEngine::ValidateNewClusterIp(
    IN      ENGINEHANDLE    ehCluster,  // OPTIONAL
    IN      LPCWSTR         szIp,
    OUT     BOOL           &fExistsOnRawIterface,
    IN OUT  CLocalLogger   &logConflict
    )
{
    NLBERROR     nerr = NLBERR_INVALID_IP_ADDRESS_SPECIFICATION;
    BOOL         fRet = FALSE;
    ENGINEHANDLE ehTmp =  NULL;
    BOOL         fIsNew = FALSE;

    fExistsOnRawIterface = FALSE;

    //
    // Check that CIP is not used elsewhere
    //
    nerr =  this->LookupClusterByIP(
                szIp,
                NULL, //  pInitialConfig
                REF ehTmp,
                REF fIsNew
                );

    if (NLBOK(nerr) && ehCluster != ehTmp)
    {
        //
        // CIP matches some other cluster!
        //
        _bstr_t bstrIpAddress;
        _bstr_t bstrDomainName;
        _bstr_t bstrClusterDisplayName;
        LPCWSTR szCluster = NULL;

        nerr  = this->GetClusterIdentification(
                    ehTmp,
                    REF bstrIpAddress, 
                    REF bstrDomainName, 
                    REF bstrClusterDisplayName
                    );
        if (NLBOK(nerr))
        {
            szCluster = bstrClusterDisplayName;
        }
        if (szCluster == NULL)
        {
            szCluster = L"";
        }

        logConflict.Log(IDS_CLUSTER_XXX, szCluster);
        goto end;
    }

    ehTmp = NULL;

    nerr =  this->LookupInterfaceByIp(
                NULL, //  NULL == search for all hosts
                szIp,
                REF ehTmp
                );
    if (NLBOK(nerr))
    {
        ENGINEHANDLE ehExistingCluster;
        ENGINEHANDLE ehExistingHost;
        _bstr_t        bstrDisplayName;
        _bstr_t        bstrFriendlyName;
        _bstr_t        bstrHostName;
        LPCWSTR         szInterface = NULL;
        
        nerr = this->GetInterfaceIdentification(
                ehTmp,
                ehExistingHost,
                ehExistingCluster,
                bstrFriendlyName,
                bstrDisplayName,
                bstrHostName
                );

        if (NLBOK(nerr))
        {
            if (ehCluster == NULL || ehCluster != ehExistingCluster)
            {
                //
                // CONFLICT
                //

                if (ehExistingCluster == NULL)
                {
                    //
                    // Conflicting interface NOT part of an existing cluster.
                    //
                    fExistsOnRawIterface =  TRUE;
                }

                szInterface = bstrDisplayName;
                if (szInterface == NULL)
                {
                    szInterface = L"";
                }
                logConflict.Log(IDS_INTERFACE_XXX, szInterface);
                goto end;
            }
        }
    }

    fRet = TRUE;

end:

    if (fRet)
    {
        nerr = NLBERR_OK;
    }
    else
    {
        nerr = NLBERR_INVALID_IP_ADDRESS_SPECIFICATION;
    }

    return nerr;
}



NLBERROR
CNlbEngine::ValidateNewDedicatedIp(
    IN      ENGINEHANDLE    ehIF,
    IN      LPCWSTR         szDip,
    IN OUT  CLocalLogger   &logConflict
    )
{
    NLBERROR     nerr = NLBERR_INVALID_IP_ADDRESS_SPECIFICATION;
    BOOL         fRet = FALSE;
    ENGINEHANDLE ehTmp =  NULL;
    BOOL         fIsNew = FALSE;

    if (ehIF == NULL)
    {
        ASSERT(FALSE);
        goto end;
    }

    //
    // Check that DIP is not used elsewhere
    //
    nerr =  this->LookupClusterByIP(
                szDip,
                NULL, //  pInitialConfig
                REF ehTmp,
                REF fIsNew
                );

    if (NLBOK(nerr))
    {
        //
        // DIP matches some cluster!
        //
        _bstr_t bstrIpAddress;
        _bstr_t bstrDomainName;
        _bstr_t bstrClusterDisplayName;
        LPCWSTR szCluster = NULL;

        nerr  = this->GetClusterIdentification(
                    ehTmp,
                    REF bstrIpAddress, 
                    REF bstrDomainName, 
                    REF bstrClusterDisplayName
                    );
        if (NLBOK(nerr))
        {
            szCluster = bstrClusterDisplayName;
        }
        if (szCluster == NULL)
        {
            szCluster = L"";
        }

        logConflict.Log(IDS_CLUSTER_XXX, szCluster);
        goto end;
    }

    ehTmp = NULL;

    nerr =  this->LookupInterfaceByIp(
                NULL, //  NULL == search for all hosts
                szDip,
                REF ehTmp
                );
    if (NLBOK(nerr))
    {
        if (ehTmp != ehIF)
        {
            ENGINEHANDLE   ehHost1;
            ENGINEHANDLE   ehCluster1;
            _bstr_t        bstrDisplayName1;
            _bstr_t        bstrFriendlyName;
            _bstr_t        bstrHostName;
            LPCWSTR         szInterface = NULL;
    
            nerr = this->GetInterfaceIdentification(
                    ehTmp,
                    ehHost1,
                    ehCluster1,
                    bstrFriendlyName,
                    bstrDisplayName1,
                    bstrHostName
                    );
            szInterface = bstrDisplayName1;
            if (szInterface == NULL)
            {
                szInterface = L"";
            }
                
            logConflict.Log(IDS_INTERFACE_XXX, szInterface);
            goto end;
        }
    }

    fRet = TRUE;

end:

    if (fRet)
    {
        nerr = NLBERR_OK;
    }
    else
    {
        nerr = NLBERR_INVALID_IP_ADDRESS_SPECIFICATION;
    }

    return nerr;
}


VOID
CNlbEngine::mfn_ReallyUpdateInterface(
    IN ENGINEHANDLE ehInterface,
    IN NLB_EXTENDED_CLUSTER_CONFIGURATION &refNewConfig
    //IN OUT BOOL &fClusterPropertiesUpdated
    )
{
    #define NLBMGR_MAX_OPERATION_DURATION 120   // 2 minutes
    BOOL fCancelled = FALSE;
    CHostSpec *pHSpec =  NULL;
    CInterfaceSpec *pISpec =  NULL;
    WBEMSTATUS CompletionStatus, wStatus;
    _bstr_t bstrNicGuid;
    _bstr_t bstrHostName;
    _bstr_t bstrUserName;
    _bstr_t bstrConnectionString;
    _bstr_t bstrPassword;
    NLBERROR nerr;
    CLocalLogger logClientIdentification;
    WCHAR rgMachineName[512];
    DWORD cbMachineName = (DWORD) ASIZE(rgMachineName);
    BOOL fRet;
    DWORD StartTime = GetTickCount();

    fRet = GetComputerNameEx(
                ComputerNameDnsFullyQualified,
                rgMachineName, 
                &cbMachineName
                );

    if (!fRet)
    {
        *rgMachineName = 0;
    }
    logClientIdentification.Log(IDS_CLIENT_IDENTIFICATION, rgMachineName);

    mfn_Lock();

    nerr = CNlbEngine::mfn_GetHostFromInterfaceLk(ehInterface,REF pISpec, REF pHSpec);

    if (nerr != NLBERR_OK)
    {
        TRACE_CRIT("%!FUNC! could not get pISpec,pHSpec for ehIF 0x%lx",
                    ehInterface);
        goto end_unlock;
    }

    //
    // We need to keep local bstrs because once we release the lock
    // pHSpec may go away (or re-assign it's bstrs) -- .net svr bug 513056.
    //
    bstrUserName        = pHSpec->m_UserName;
    bstrConnectionString= pHSpec->m_ConnectionString;
    bstrPassword        = pHSpec->m_Password;
    bstrNicGuid         = pISpec->m_Guid;
    bstrHostName        = pHSpec->m_MachineName;

    WMI_CONNECTION_INFO ConnInfo;
    ConnInfo.szUserName = (LPCWSTR) bstrUserName;
    ConnInfo.szPassword = (LPCWSTR) bstrPassword;
    ConnInfo.szMachine  = (LPCWSTR) bstrConnectionString;
    LPCWSTR szNicGuid   = (LPCWSTR) bstrNicGuid;
    LPCWSTR szHostName  = (LPCWSTR) bstrHostName;

    if (szNicGuid == NULL)
    {
        TRACE_CRIT("%!FUNC! ERROR -- NULL szNicGuid!");
        goto end_unlock;
    }

    mfn_Unlock();

    UINT Generation; // TODO track the generation
    LPWSTR  pLog = NULL;
    LPCWSTR szClusterIp = refNewConfig.NlbParams.cl_ip_addr;

    ProcessMsgQueue(); // TODO: eliminate when doing this in the background

    wStatus = NlbHostDoUpdate(
                &ConnInfo,
                szNicGuid,
                logClientIdentification.GetStringSafe(),
                // L"NLB Manager on <this machine>", // TODO: localize
                &refNewConfig,
                &Generation,
                &pLog
                );

    if (wStatus == WBEM_S_PENDING)
    {
        m_pCallbacks->Log(
            IUICallbacks::LOG_INFORMATIONAL,
            szClusterIp,
            szHostName,
            IDS_LOG_WAITING_FOR_PENDING_OPERATION, // %d
            Generation
            );
    }

    while (wStatus == WBEM_S_PENDING)
    {
        //
        // Check if we've exceeded the absolute time for cancellation.
        //
        {
            DWORD CurrentTime = GetTickCount();
            UINT  DurationInSeconds=0;
            if (CurrentTime < StartTime)
            {
                //
                // Timer overflow -- fixup: we do this the "cheap" way
                // of re-setting start time, so that we'll end up with at most
                // twice the max delay in the event of a timer overflow.
                //
                StartTime = CurrentTime;
            }
            DurationInSeconds= (UINT) (CurrentTime - StartTime)/1000;

            if ( DurationInSeconds > NLBMGR_MAX_OPERATION_DURATION)
            {
                TRACE_CRIT("%!FUNC! Operation canceled because max time exceeded");
                fCancelled = TRUE;
                break;
            }
        }

        
        //
        // Check if this pending operation is cancelled...
        //
        {
            CInterfaceSpec *pTmpISpec = NULL;
            ENGINEHANDLE ehOperation  = NULL;

            mfn_Lock();

            pTmpISpec = m_mapIdToInterfaceSpec[ehInterface]; // map
            if (pTmpISpec == NULL)
            {
                ASSERT(FALSE);
                wStatus = WBEM_E_CRITICAL_ERROR;
                mfn_Unlock();
                break;
            }
            
            ehOperation  =  pTmpISpec->m_ehPendingOperation;
            if (ehOperation != NULL)
            {
                CEngineOperation *pOperation;
                pOperation = m_mapIdToOperation[ehOperation];

                if (pOperation != NULL)
                {
                    if (pOperation->fCanceled)
                    {
                        TRACE_CRIT("%!FUNC! ehOp 0x%lx CANCELLED!",
                            ehOperation);
                        fCancelled = TRUE;
                    }
                }
            }

            mfn_Unlock();

            if (fCancelled)
            {
                break;
            }
        }

        if (pLog != NULL)
        {
            mfn_UpdateInterfaceStatusDetails(ehInterface, pLog);
            delete pLog;
            pLog = NULL;
        }

        for (UINT u=0;u<50;u++)
        {
            ProcessMsgQueue(); // TODO: eliminate when doing this in the background
            Sleep(100);
        }
        ULONG uIpAddress = 0;
        wStatus =  NlbHostPing(ConnInfo.szMachine, 2000, &uIpAddress);
        if (FAILED(wStatus))
        {
            TRACE_CRIT("%!FUNC!: ping %ws failed!", ConnInfo.szMachine);
            wStatus = WBEM_S_PENDING;
            continue;
        }

        wStatus = NlbHostGetUpdateStatus(
                    &ConnInfo,
                    szNicGuid,
                    Generation,
                    &CompletionStatus,
                    &pLog
                    );

        if (!FAILED(wStatus))
        {
            wStatus = CompletionStatus;
        }
    }

    if (fCancelled == TRUE)
    {
        wStatus = WBEM_S_OPERATION_CANCELLED;
    }
    else
    {
        BOOL fNewRctPassword = FALSE;
        //
        // Get latest information from the host
        //
        (void) this->RefreshInterface(
                        ehInterface,
                        FALSE,  // FALSE == don't start a new operation
                        FALSE   // FALSE == this is not cluster-wide
                        ); 

        //
        // If we're doing a RCT password-change, AND the updated operation
        // completed successfully AND the cluster's fNewRctPassword flag is
        // set, we'll update the cluster's rct hash value and clear the
        // fNewRctPassword flag.
        //
        fNewRctPassword = (refNewConfig.GetNewRemoteControlPasswordRaw()!=NULL);

        if (fNewRctPassword && !FAILED(wStatus))
        {
            CEngineCluster *pECluster =  NULL;

            mfn_Lock();

            pISpec = m_mapIdToInterfaceSpec[ehInterface]; // map
            if (pISpec != NULL)
            {
                ENGINEHANDLE ehCluster = pISpec->m_ehCluster;
                if (ehCluster != NULL)
                {
                    pECluster =  m_mapIdToEngineCluster[ehCluster]; // map
                }
            }
    
            if (pECluster != NULL)
            {
                if (pECluster->m_cSpec.m_fNewRctPassword)
                {
                    //
                    // Update cluster's rct hash and clear m_fNewRctPassword
                    //
                    DWORD dwNewHash; 
                    dwNewHash = CfgUtilGetHashedRemoteControlPassword(
                                    &pISpec->m_NlbCfg.NlbParams
                                    );

                    TRACE_VERB(L"Updating cluster remote control password to %lu",
                                dwNewHash
                                );
                    CfgUtilSetHashedRemoteControlPassword(
                            &pECluster->m_cSpec.m_ClusterNlbCfg.NlbParams,
                            dwNewHash
                            );
                    pECluster->m_cSpec.m_fNewRctPassword = FALSE;
                }
            }
        
            mfn_Unlock();
        }

    }

    //
    // Log the final results.
    //
    {
        IUICallbacks::LogEntryHeader Header;
        Header.szDetails = pLog;
        Header.szCluster = szClusterIp;
        Header.szHost = szHostName;

        if (FAILED(wStatus))
        {
            Header.type = IUICallbacks::LOG_ERROR;
            if (Generation != 0)
            {
                m_pCallbacks->LogEx(
                    &Header,
                    IDS_LOG_FINAL_STATUS_FAILED,
                    Generation,
                    wStatus
                    );
            }
            else
            {
                m_pCallbacks->LogEx(
                    &Header,
                    IDS_LOG_FINAL_STATUS_FAILED_NOGEN,
                    wStatus
                    );
            }
        }
        else
        {
            Header.type = IUICallbacks::LOG_INFORMATIONAL;
            m_pCallbacks->LogEx(
                &Header,
                IDS_LOG_FINAL_STATUS_SUCCEEDED,
                Generation
                );
        }
    }

    if (pLog != NULL)
    {
        delete pLog;
        pLog = NULL;
    }

    ProcessMsgQueue(); // TODO: eliminate when doing this in the background


    mfn_Lock();

end_unlock:

    mfn_Unlock();

    return;
}


VOID
CNlbEngine::mfn_SetInterfaceMisconfigStateLk(
    IN  CInterfaceSpec *pIF,
    IN  BOOL fMisconfig,
    IN  LPCWSTR szMisconfigDetails
    )
/*
    Set/clear the interface misconfigured status.
    If fMisconfig, save away the szMisconfigDetails, else clear the 
    internal misconfig details field.
*/
{
    pIF->m_fMisconfigured = fMisconfig;

    if (fMisconfig)
    {
        pIF->m_bstrStatusDetails = _bstr_t(szMisconfigDetails);
    }
    else
    {
        pIF->m_bstrStatusDetails = LPCWSTR(NULL);
    }
}

BOOL
CNlbEngine::mfn_HostHasManagedClustersLk(CHostSpec *pHSpec)
//
// Return true if there exists at least one IF which is part of
// a cluster displayed by NLB Manager.
//
{
    BOOL fRet = FALSE;

    vector<ENGINEHANDLE> &InterfaceList =  pHSpec->m_ehInterfaceIdList;
    for(UINT u = 0; u < InterfaceList.size(); ++u )
    {
        ENGINEHANDLE ehI =  InterfaceList[u];
        CInterfaceSpec *pISpec = m_mapIdToInterfaceSpec[ehI]; // map
        if (pISpec != NULL)
        {
            if (pISpec->m_ehCluster != NULL)
            {
                fRet = TRUE;
                break;
            }
        }
    }

    return fRet;
}

void
CNlbEngine::mfn_UpdateInterfaceStatusDetails(
                ENGINEHANDLE ehIF,
                LPCWSTR szDetails
                )
//
// Update the textual status details field of the interface.
// These details give the detailed information on the current status
// of the interface. For example: if misconfigured, misconfig details,
// or if there is an update operation ongoing, details about that operation.
//
{
    CInterfaceSpec *pISpec = NULL;



    mfn_Lock();

    pISpec =  m_mapIdToInterfaceSpec[ehIF]; // map

    if (pISpec != NULL)
    {
        pISpec->m_bstrStatusDetails = szDetails;
    }

    mfn_Unlock();
}


BOOL
validate_extcfg(
    const NLB_EXTENDED_CLUSTER_CONFIGURATION &Config
    )
/*
    Do some internal checks to make sure that the data is valid.
    Does not change internal state.
*/
{
    BOOL fRet = FALSE;

    if (Config.fBound)
    {
        WBEMSTATUS Status;
        //
        // NLB is bound -- let's validate NLB paramaters.
        //
        WLBS_REG_PARAMS TmpParams = Config.NlbParams; // struct copy.
        BOOL  fConnectivityChange = FALSE;

        Status = CfgUtilsAnalyzeNlbUpdate(
                    NULL, // OPTIONAL pCurrentParams
                    &TmpParams,
                    &fConnectivityChange
                    );
        if (FAILED(Status))
        {
            goto end;
        }
    }
    
    fRet = TRUE;

end:

    return fRet;
}

VOID
remove_dedicated_ip_from_nlbcfg(
        NLB_EXTENDED_CLUSTER_CONFIGURATION &ClusterCfg
        )
{
    LPCWSTR     szDedIp = ClusterCfg.NlbParams.ded_ip_addr;
    UINT        NumIps  = ClusterCfg.NumIpAddresses;
    NLB_IP_ADDRESS_INFO
                *pIpInfo =  ClusterCfg.pIpAddressInfo;

    if (*szDedIp == 0) goto end;

    //
    // Go through address list, looking for this Ip address. If we find it,
    // we remove it.
    //
    for (UINT u=0; u<NumIps; u++)
    {
        if (!wcscmp(szDedIp, pIpInfo[u].IpAddress))
        {
            //
            // Found it! Move everything ahead up by one.
            //
            for (UINT v=u+1; v<NumIps; v++)
            {
                pIpInfo[v-1]=pIpInfo[v]; // Struct copy.
            }
            ClusterCfg.NumIpAddresses--;

            //
            // Zero-out last entry just for grins...
            //
            pIpInfo[NumIps-1].IpAddress[0]=0;
            pIpInfo[NumIps-1].SubnetMask[0]=0;

            break;
        }
    }

    ARRAYSTRCPY(ClusterCfg.NlbParams.ded_ip_addr, CVY_DEF_DED_IP_ADDR);

    ARRAYSTRCPY(ClusterCfg.NlbParams.ded_net_mask, CVY_DEF_DED_NET_MASK);

end:

    return;
}

BOOL
get_used_port_rule_priorities(
    IN const NLB_EXTENDED_CLUSTER_CONFIGURATION &Config,
    IN UINT                  NumRules,
    IN const WLBS_PORT_RULE  rgRules[],
    IN OUT ULONG             rgUsedPriorities[] // At least NumRules
    )
/*
    Add to the array of bitmaps the priority that
    that represents the used priorities for
    each specified port rule. If the port rule is not single-host
    the bitmap for that port rule is left unmodified
*/
{
    const WLBS_REG_PARAMS *pParams = &Config.NlbParams;
    WLBS_PORT_RULE *pCfgRules = NULL;
    WBEMSTATUS wStatus;
    UINT NumCfgRules = 0;
    BOOL fRet = FALSE;

    //
    // Get the list of port rules in Config.
    //
    wStatus =  CfgUtilGetPortRules(
                pParams,
                &pCfgRules,
                &NumCfgRules
                );
    if (FAILED(wStatus))
    {
        pCfgRules = NULL;
        goto end;
    }

    //
    // For each port rule in rgRules, if single-host mode,
    // locate the corresponding port rule  in Config, and if found,
    // (and the latter port rule is single-host) make a bitmap out of
    // the single-host priority.
    //
    for (UINT u=0; u<NumRules; u++)
    {
        const WLBS_PORT_RULE *pCfgRule = NULL;
        const WLBS_PORT_RULE *pRule = rgRules+u;

        if (pRule->mode == CVY_SINGLE)
        {
            UINT   uPriority = 0;
            pCfgRule = find_port_rule(
                         pCfgRules,
                         NumCfgRules,
                         rgRules[u].virtual_ip_addr,
                         rgRules[u].start_port
                         );
    
            
            if (pCfgRule != NULL && pCfgRule->mode == CVY_SINGLE)
            {
                uPriority =  pCfgRule->mode_data.single.priority;
            }

            if (uPriority!=0)
            {
                rgUsedPriorities[u] |= 1<<(uPriority-1);
            }
        }
    }

end:

    delete[] pCfgRules;
    return fRet;
}


const WLBS_PORT_RULE *
find_port_rule(
    const WLBS_PORT_RULE *pRules,
    UINT NumRules,
    LPCWSTR szVIP,
    UINT StartPort
    )
/*
    Locate the port rule with the specified vip and start-port.
    Return pointer to the found rule or NULL if not found.
*/
{
    const WLBS_PORT_RULE *pFoundRule = NULL;
    LPCWSTR szAllVip = GETRESOURCEIDSTRING(IDS_REPORT_VIP_ALL);
    
    for (UINT u=0;u<NumRules; u++)
    {
        const WLBS_PORT_RULE *pRule = pRules+u;
        LPCWSTR szRuleVip = pRule->virtual_ip_addr;

        //
        // Unfortunately, "All" and "255.255.255.255" are synonomous :-(
        //
        if (!lstrcmpi(szVIP, L"255.255.255.255"))
        {
            szVIP = szAllVip;
        }
        if (!lstrcmpi(szRuleVip, L"255.255.255.255"))
        {
            szRuleVip = szAllVip;
        }


        
        if (    !lstrcmpi(szVIP, szRuleVip)
            && StartPort == pRule->start_port)
        {
            pFoundRule = pRule;
            break;
        }
    }

    return pFoundRule;
}

CEngineOperation *
CNlbEngine::mfn_NewOperationLk(ENGINEHANDLE ehObj, PVOID pvCtxt, LPCWSTR szDescription)
{
    ENGINEHANDLE ehOperation;
    CEngineOperation *pOperation = NULL;

    if (m_fPrepareToDeinitialize)
    {
        goto end;
    }

    ehOperation = CNlbEngine::mfn_NewHandleLk(IUICallbacks::OBJ_OPERATION);
    if (ehOperation == NULL)
    {
        TRACE_CRIT("%!FUNC! could not reserve a new operation handle");
        goto end;
    }

    pOperation = new CEngineOperation(ehOperation, ehObj, pvCtxt);

    if (pOperation == NULL)
    {
        TRACE_CRIT("%!FUNC!: allocation failure");
        goto end;
    }

    pOperation->bstrDescription = _bstr_t(szDescription);

    TRACE_VERB(L"%!FUNC!: map new pair(eh=0x%lx, pISpec=%p), szDescr=%ws",
             (UINT) ehOperation, pOperation,
             szDescription==NULL? L"<null>" : szDescription);
    m_mapIdToOperation[ehOperation] = pOperation;


end:

    return pOperation;
}


VOID
CNlbEngine::mfn_DeleteOperationLk(ENGINEHANDLE ehOperation)
{
    CEngineOperation *pOperation;
    pOperation = m_mapIdToOperation[ehOperation];

    if (pOperation == NULL)
    {
        ASSERT(!"corrupted operation");
        TRACE_CRIT("%!FUNC! corrupted operation eh 0x%lx!", ehOperation);
    }
    else
    {
        m_mapIdToOperation.erase(ehOperation);
        TRACE_VERB("%!FUNC! deleting operation eh 0x%lx pOp 0x%p",
            ehOperation, pOperation);
        pOperation->ehOperation = NULL;
        delete pOperation;
    }
}


CEngineOperation *
CNlbEngine::mfn_GetOperationLk(ENGINEHANDLE ehOp)
{
    CEngineOperation *pOperation;
    pOperation = m_mapIdToOperation[ehOp];

    if (pOperation == NULL || pOperation->ehOperation != ehOp)
    {
        TRACE_CRIT("%!FUNC! invalid or corrupt ehOp 0x%lx (pOp=0x%p)",
                ehOp, pOperation);

        pOperation = NULL;
    }

    return pOperation;
}



NLBERROR
CNlbEngine::mfn_StartInterfaceOperationLk(
    IN  ENGINEHANDLE ehIF,
    IN  PVOID pvCtxt,
    IN  LPCWSTR szDescription,
    OUT ENGINEHANDLE *pExistingOperation
    )
{
    NLBERROR            nerr        = NLBERR_OK;
    CInterfaceSpec      *pISpec     = NULL;
    CEngineOperation    *pOperation = NULL;

    *pExistingOperation = NULL;

    pISpec =  m_mapIdToInterfaceSpec[ehIF]; // map
    if (pISpec == NULL)
    {
        nerr = NLBERR_NOT_FOUND;
        goto end;
    }

    if (pISpec->m_ehPendingOperation != NULL)
    {
        TRACE_CRIT("%!FUNC!: Not starting operation on ehIF 0x%lx because operation 0x%lx already pending",
             ehIF, pISpec->m_ehPendingOperation);
        *pExistingOperation = pISpec->m_ehPendingOperation;
        nerr = NLBERR_BUSY;
        goto end;
    }

    pOperation = mfn_NewOperationLk(
                    ehIF,
                    pvCtxt,
                    szDescription
                    );
    if (pOperation == NULL)
    {
        nerr = NLBERR_RESOURCE_ALLOCATION_FAILURE;
        goto end;
    }

    TRACE_VERB("%!FUNC!: Starting operation eh 0x%lx on ehIF 0x%lx",
         pOperation->ehOperation, ehIF);
    pISpec->m_ehPendingOperation = pOperation->ehOperation;
    pISpec->m_fPending = TRUE;
    nerr = NLBERR_OK;

    // fall through ...

end:

    return nerr;
}


VOID
CNlbEngine::mfn_StopInterfaceOperationLk(
    IN  ENGINEHANDLE ehIF
    )
{
    CInterfaceSpec  *pISpec = NULL;
    ENGINEHANDLE ehOperation = NULL;

    pISpec = m_mapIdToInterfaceSpec[ehIF]; // map
    if (pISpec == NULL)
    {
        TRACE_CRIT("%!FUNC!: Invalid ehIF 0x%lx", ehIF);
        goto end;
    }
    
    ehOperation = pISpec->m_ehPendingOperation;
    
    if (ehOperation != NULL)
    {
        TRACE_VERB("%!FUNC!: Stopping operation eh 0x%lx on pIspec 0x%p",
             ehOperation, pISpec);
        pISpec->m_ehPendingOperation = NULL;
        pISpec->m_fPending = FALSE;
        mfn_DeleteOperationLk(ehOperation);
    }
    else
    {
        TRACE_VERB("%!FUNC!: No operation to stop on pISpec 0x%p", pISpec);
    }
    
end:
    return;
}


NLBERROR
CNlbEngine::mfn_StartClusterOperationLk(
        IN  ENGINEHANDLE ehCluster,
        IN  PVOID pvCtxt,
        IN  LPCWSTR szDescription,
        OUT ENGINEHANDLE *pExistingOperation
        )
{
    NLBERROR            nerr        = NLBERR_OK;
    CEngineCluster      *pECluster  = NULL;
    CClusterSpec        *pCSpec     = NULL;
    CEngineOperation    *pOperation = NULL;

    *pExistingOperation = NULL;

    pECluster = m_mapIdToEngineCluster[ehCluster]; // map
    if (pECluster == NULL)
    {
        nerr = NLBERR_NOT_FOUND;
        goto end;
    }
    pCSpec = &pECluster->m_cSpec;

    if (pCSpec->m_ehPendingOperation != NULL)
    {
        TRACE_CRIT("%!FUNC!: Not starting operation on ehCluster 0x%lx because operation 0x%lx already pending",
             ehCluster, pCSpec->m_ehPendingOperation);
        *pExistingOperation = pCSpec->m_ehPendingOperation;
        nerr = NLBERR_BUSY;
        goto end;
    }

    pOperation = mfn_NewOperationLk(
                    ehCluster,
                    pvCtxt,
                    szDescription
                    );
    if (pOperation == NULL)
    {
        nerr = NLBERR_RESOURCE_ALLOCATION_FAILURE;
        goto end;
    }

    TRACE_VERB("%!FUNC!: Starting operation eh 0x%lx on ehC 0x%lx",
         pOperation->ehOperation, ehCluster);
    pCSpec->m_ehPendingOperation = pOperation->ehOperation;
    pCSpec->m_fPending = TRUE;
    nerr = NLBERR_OK;

    // fall through ...


end:

    return nerr;
}


VOID
CNlbEngine::mfn_StopClusterOperationLk(
    ENGINEHANDLE ehCluster
    )
{
    CEngineCluster  *pECluster  = NULL;
    CClusterSpec    *pCSpec = NULL;
    ENGINEHANDLE    ehOperation = NULL;

    pECluster = m_mapIdToEngineCluster[ehCluster]; // map
    if (pECluster == NULL)
    {
        TRACE_CRIT("%!FUNC!: Invalid ehC 0x%lx", ehCluster);
        goto end;
    }
    pCSpec = &pECluster->m_cSpec;
    
    ehOperation = pCSpec->m_ehPendingOperation;
    if (ehOperation != NULL)
    {
        TRACE_VERB("%!FUNC!: Stopping operation eh 0x%lx on pCSpec 0x%p",
             ehOperation, pCSpec);
        pCSpec->m_ehPendingOperation = NULL;
        pCSpec->m_fPending = FALSE;
        mfn_DeleteOperationLk(ehOperation);
    }
    else
    {
        TRACE_VERB("%!FUNC!: No operation to stop on pCSpec 0x%p", pCSpec);
    }

end:

    return;
}


UINT
CNlbEngine::ListPendingOperations(
    CLocalLogger &logOperations
    )
//
// List pending operations -- but ONLY list those operations that
// contain non-null, non-blank descriptions.
//
{
    UINT uCount = 0;

    mfn_Lock();

    map< ENGINEHANDLE, CEngineOperation* >::iterator iter;

    for( iter = m_mapIdToOperation.begin();
         iter != m_mapIdToOperation.end();
         ++iter)
    {
        CEngineOperation *pOperation =  ((*iter).second);
        if (pOperation != NULL)
        {
            LPCWSTR szDescr = pOperation->bstrDescription;

            //
            // Only add operations with  non-null, non-blank descriptions.
            // We don't list "hidden" operations -- specifically
            // the transient operation created in the background work item
            // to make sure that the app doesn't go away while in the work item.
            //
            if (szDescr != NULL && *szDescr!=0)
            {
                logOperations.Log(
                    IDS_LOG_PENDING_OPERATION,
                    szDescr
                    );
                uCount++;
            }
        }
    }

    mfn_Unlock();

    return uCount;
}

VOID
CNlbEngine::UpdateInterfaceWorkItem(ENGINEHANDLE ehIF)
{
    ENGINEHANDLE        ehOperation     = NULL;
    ENGINEHANDLE        ehClusterId     = NULL;
    CEngineOperation    *pExistingOp    = NULL;
    CInterfaceSpec      *pISpec         = NULL;
    ENGINEHANDLE        ehHostToTryRemove = NULL;
    NLB_EXTENDED_CLUSTER_CONFIGURATION
                        *pNewCfg = NULL;
    _bstr_t bstrHostName;
    _bstr_t bstrClusterIp;

    mfn_Lock();


    
    pISpec =  m_mapIdToInterfaceSpec[ehIF]; // map
    if (pISpec == NULL)
    {
        ASSERT(FALSE);
        TRACE_CRIT("%!FUNC! Invalid ehIF 0x%lx", ehIF);
        goto end_unlock;
    }

    ehOperation = pISpec->m_ehPendingOperation;
    if (ehOperation == NULL)
    {
        ASSERT(FALSE);
        TRACE_CRIT("%!FUNC! ehIF 0x%lx: No pending operation", ehIF);
        goto end_unlock;
    }

    pExistingOp  = mfn_GetOperationLk(ehOperation);
    if (pExistingOp == NULL)
    {
        ASSERT(FALSE);
        TRACE_CRIT("%!FUNC! ehIF 0x%lx: Invalid ehOp 0x%lx", ehIF, ehOperation);
        goto end_unlock;
    }

    pNewCfg = (NLB_EXTENDED_CLUSTER_CONFIGURATION *) pExistingOp->pvContext;
    if (pNewCfg == NULL)
    {
        ASSERT(FALSE);
        TRACE_CRIT("%!FUNC! ehIF 0x%lx: ehOp 0x%lx: NULL pvContext",
                    ehIF, ehOperation);
        goto end_unlock;
    }

    bstrClusterIp = pNewCfg->NlbParams.cl_ip_addr;
    ehClusterId   = pISpec->m_ehCluster;

    mfn_GetInterfaceHostNameLk(
            ehIF,
            REF bstrHostName
            );

    mfn_Unlock();

    //
    // Actually do the update...
    //
    // BOOL fClusterPropertiesUpdated = TRUE; // so we won't update...
    mfn_ReallyUpdateInterface(
            ehIF,
            *pNewCfg
           //  REF fClusterPropertiesUpdated
            );

    m_pCallbacks->Log(
        IUICallbacks::LOG_INFORMATIONAL,
        (LPCWSTR) bstrClusterIp,
        (LPCWSTR) bstrHostName,
        IDS_LOG_END_HOST_UPDATE
        );

    mfn_Lock();

    //
    // We'll stop the operation, assumed to be started in this function.
    //
    mfn_StopInterfaceOperationLk(ehIF);

    //
    // The operation could have added or removed the IF to a cluster,
    // so we need to re-obtain the cluster ID (could be NULL).
    //
    {
        pISpec =  m_mapIdToInterfaceSpec[ehIF]; // map
        if (pISpec != NULL)
        {
            ehClusterId = pISpec->m_ehCluster;

            //
            // If NLB is unbound we need to check if the host can be
            // completely removed from nlbmgr (if no interfaces on
            // the host are managed by this instance of nlbmgr).
            //
            if (!pISpec->m_NlbCfg.IsNlbBound())
            {
                ehHostToTryRemove = pISpec->m_ehHostId;
            }
        }
    }

    mfn_Unlock();

    //
    // Notify the UI about the status change (operation complete)
    //
    m_pCallbacks->HandleEngineEvent(
        IUICallbacks::OBJ_INTERFACE,
        ehClusterId,
        ehIF,
        IUICallbacks::EVT_STATUS_CHANGE
        );

    mfn_Lock();

    //fall through

end_unlock:

    //
    // pNewCfg (if non null) was allocated before this function was
    // called, and saved as the pOperation->pvContext. It's our responsibility
    // to delete it here.
    //
    delete pNewCfg;

    if (ehHostToTryRemove != NULL)
    {
        mfn_DeleteHostIfNotManagedLk(ehHostToTryRemove);
    }
    mfn_Unlock();

    //
    // This must be the LAST function call, because the engine may get
    // wiped out after this.
    //
    InterlockedDecrement(&m_WorkItemCount);
}


NLBERROR
CNlbEngine::CanStartInterfaceOperation(
        IN ENGINEHANDLE ehIF,
        IN BOOL &fCanStart
        )
{
    NLBERROR    nerr = NLBERR_INTERNAL_ERROR;
    CInterfaceSpec *pISpec =  NULL;

    fCanStart = FALSE;

    mfn_Lock();

    pISpec =  m_mapIdToInterfaceSpec[ehIF]; // map
    if (pISpec == NULL)
    {
        nerr = NLBERR_NOT_FOUND;
        goto end_unlock;
    }

    //
    // If there is an operation ongoing, we can't start
    //
    if (pISpec->m_ehPendingOperation != NULL)
    {
        fCanStart = FALSE;
        nerr = NLBERR_OK;
        goto end_unlock;
    }

    //
    // If the interface is part of a cluster, and there is a pending operation
    // on that cluster, we can't start
    //
    if (pISpec->m_ehCluster != NULL)
    {
        CEngineCluster *pECluster = m_mapIdToEngineCluster[pISpec->m_ehCluster]; // map
        if (pECluster == NULL)
        {
            //
            // Invalid cluster!
            //
            TRACE_CRIT("%!FUNC! ehIF:0x%lx; Invalid ehCluster 0x%lx",
                    ehIF, pISpec->m_ehCluster);
            goto end_unlock;
        }
        if (pECluster->m_cSpec.m_ehPendingOperation != NULL)
        {
            //
            // A cluster-wide operation is pending -- so can't start.
            //
            fCanStart = FALSE;
            nerr = NLBERR_OK;
            goto end_unlock;
        }
    }

    //
    // Looks like we CAN start at this time (although the moment we
    // exit the lock the situation may change).
    //
    fCanStart = TRUE;
    nerr = NLBERR_OK;

end_unlock:
    mfn_Unlock();

    return nerr;
}


NLBERROR
CNlbEngine::mfn_ClusterOrInterfaceOperationsPendingLk(
    IN	CEngineCluster *pECluster,
    OUT BOOL &fCanStart
    )
{
    NLBERROR    nerr = NLBERR_INTERNAL_ERROR;

    fCanStart = FALSE;

    //
    // If there is an operation ongoing, we can't start
    //
    if (pECluster->m_cSpec.m_ehPendingOperation != NULL)
    {
        fCanStart = FALSE;
        nerr = NLBERR_OK;
        goto end;
    }

    //
    // Lets look at all of our interfaces, checking if there are pending
    // operations on each of the interfaces.
    //
    {
        BOOL fOperationPending = FALSE;
        vector<ENGINEHANDLE> &InterfaceList =
                     pECluster->m_cSpec.m_ehInterfaceIdList; // vector reference

        for( int i = 0; i < InterfaceList.size(); ++i )
        {
            ENGINEHANDLE ehIF = InterfaceList[i];
            CInterfaceSpec *pISpec = m_mapIdToInterfaceSpec[ehIF]; // map
            if (pISpec == NULL)
            {
                //
                // Hmm... invalid interface handle? We'll ignore this one.
                //
                continue;
            }
            if (pISpec->m_ehPendingOperation != NULL)
            {
                fOperationPending = TRUE;
                break;
            }
        }

        if (fOperationPending)
        {
            fCanStart = FALSE;
            nerr = NLBERR_OK;
            goto end;
        }
    }

    //
    // Looks like we CAN start at this time (although the moment we
    // exit the lock the situation may change).
    //
    fCanStart = TRUE;
    nerr = NLBERR_OK;

end:
    return nerr;
}


NLBERROR
CNlbEngine::CanStartClusterOperation(
        IN ENGINEHANDLE ehCluster,
        IN BOOL &fCanStart
        )
{
    CEngineCluster *pECluster = NULL;
    NLBERROR    nerr = NLBERR_INTERNAL_ERROR;

    fCanStart = FALSE;

    mfn_Lock();

    pECluster = m_mapIdToEngineCluster[ehCluster]; // map

    if (pECluster == NULL)
    {
        nerr = NLBERR_NOT_FOUND;
    }
    else
    {
        nerr = mfn_ClusterOrInterfaceOperationsPendingLk(pECluster, REF fCanStart);
    }

    mfn_Unlock();
    return nerr;
}

DWORD
WINAPI
UpdateInterfaceWorkItemRoutine(
  LPVOID lpParameter   // thread data
  )
{
    gEngine.UpdateInterfaceWorkItem((ENGINEHANDLE) (UINT_PTR) lpParameter);
    return 0;
}

DWORD
WINAPI
AddClusterMembersWorkItemRoutine(
  LPVOID lpParameter   // thread data
  )
{
    gEngine.AddOtherClusterMembersWorkItem(
        (ENGINEHANDLE) (UINT_PTR) lpParameter
        );
    return 0;
}

BOOL
CNlbEngine::mfn_UpdateClusterProps(
    ENGINEHANDLE ehCluster,
    ENGINEHANDLE ehInterface
    )
/*
    Update the specified cluster properties to be the specified interface
     properties PROVIDED:
        1. The IF is a member of the cluster
        2. The configuration shows that it is bound to the same cluster IP.
    
    Return true iff the cluter props were actually updated.

*/
{
    BOOL            fClusterUpdated = FALSE;
    CEngineCluster *pECluster       = NULL;
    CInterfaceSpec *pISpec          = NULL;

    mfn_Lock();

    pECluster   = m_mapIdToEngineCluster[ehCluster]; // map
    pISpec      = m_mapIdToInterfaceSpec[ehInterface]; // map

    if (pECluster == NULL || pISpec == NULL)
    {
        goto end_unlock;
    }

    if (pISpec->m_ehCluster != ehCluster)
    {
        goto end_unlock;
    }

    if ( pISpec->m_NlbCfg.IsValidNlbConfig()
         && !_wcsicmp(
                pECluster->m_cSpec.m_ClusterNlbCfg.NlbParams.cl_ip_addr,
                pISpec->m_NlbCfg.NlbParams.cl_ip_addr
                ) )
    {
        pECluster->m_cSpec.m_ehDefaultInterface = ehInterface;
        pECluster->m_cSpec.m_ClusterNlbCfg.Update(&pISpec->m_NlbCfg);
        TRACE_INFO(L"Updating ehCluster 0x%lx spec -- using ehIF 0x%lx",
                ehCluster, ehInterface);
        //
        // Remove the dedicated IP address from cluster's version of
        // the NlbParams and the IP address list.
        //
        remove_dedicated_ip_from_nlbcfg(REF pECluster->m_cSpec.m_ClusterNlbCfg);

        //
        // Since we've just read all the config (including remote control hash
        // value) we can now clear the  pECluster->m_cSpec.m_fNewRctPassword
        // flag.
        //
        TRACE_VERB(L"Clearing pECluster->m_cSpec.m_fNewRctPassword");
        pECluster->m_cSpec.m_fNewRctPassword = FALSE;

        fClusterUpdated = TRUE;
    }

end_unlock:

    mfn_Unlock();

    if (fClusterUpdated)
    {
        m_pCallbacks->HandleEngineEvent(
            IUICallbacks::OBJ_CLUSTER,
            ehCluster,
            ehCluster,
            IUICallbacks::EVT_STATUS_CHANGE
            );
    }

    return fClusterUpdated;
}


void
CNlbEngine::CancelAllPendingOperations(
    BOOL fBlock
    )
{
    //
    // if (fBlock), we wait until BOTH m_WorkItemCount and
    // the number of operations goes to zero.
    //
    // An Operations are created BEFORE the workitemcount is incremented, 
    // so we don't have to deal with the transient possibility that
    // both are zero (and we get out) but soon after the count goes to non
    // zero
    //



    map< ENGINEHANDLE, CEngineOperation* >::iterator iter;

    if (!fBlock)
    { 
        mfn_Lock();

        for( iter = m_mapIdToOperation.begin();
             iter != m_mapIdToOperation.end();
             ++iter)
        {
            CEngineOperation *pOperation =  ((*iter).second);
            if (pOperation != NULL)
            {
                pOperation->fCanceled = TRUE;
            }
        }

        mfn_Unlock();
    } 
    else
    {

        //
        // If we're asked to block, we assume that this is while
        // we're prepairing to deinitialize, at which point we are
        // guaranteed that no new operations can be added.
        // It is possible that new work items can be added,
        // however a work item is created  in the context of
        // an operation, so once the operation count goes
        // to zero, no new work items will be created.
        //
        ASSERT(m_fPrepareToDeinitialize);

        BOOL fPending = FALSE;

        do
        {
            fPending = FALSE;

            mfn_Lock();
    
            for( iter = m_mapIdToOperation.begin();
                 iter != m_mapIdToOperation.end();
                 ++iter)
            {
                CEngineOperation *pOperation =  ((*iter).second);
                if (pOperation != NULL)
                {
                    pOperation->fCanceled = TRUE;
                    fPending = TRUE;
                }
            }
    
            //
            // The additional check below must come AFTER the previous
            // loop. If we had this check before the loop, it could be that
            // there are no work item's before we check the loop, but the
            // instant we check the loop for operations, the work item count
            // goes positive but when we actually check the loop here are zero
            // operations. Actually that's not possible because we have
            // mfn_Lock held, so never mind.
            //
            //
            fPending |= (m_WorkItemCount > 0);

            mfn_Unlock();

            if (fPending)
            {
                ProcessMsgQueue();
                Sleep(50);
            }
    
        } while (fPending);
    }

    return;
}


NLBERROR
CNlbEngine::mfn_WaitForInterfaceOperationCompletions(
    IN  ENGINEHANDLE ehCluster
    )
{
    NLBERROR        nerr        = NLBERR_INTERNAL_ERROR;
    CEngineCluster  *pECluster  = NULL;
    CClusterSpec    *pCSpec     = NULL;
    ENGINEHANDLE    ehOperation = NULL;
    BOOL            fOperationsPending = FALSE;

    mfn_Lock();

    pECluster = m_mapIdToEngineCluster[ehCluster]; // map
    if (pECluster == NULL)
    {
        TRACE_CRIT("%!FUNC!: Invalid ehC 0x%lx", ehCluster);
        goto end_unlock;
    }
    pCSpec = &pECluster->m_cSpec;
    
    ehOperation = pCSpec->m_ehPendingOperation;
    if (ehOperation == NULL)
    {
        //
        // We expect that this function is only called when there is a
        // pending cluster-wide operation.
        //
        TRACE_CRIT("%!FUNC! ehC 0x%lx Failing because no cluster operation pending", ehCluster);
        goto end_unlock;
    }

    //
    // Now in a loop, enumerate the interfaces in the cluster,
    // cheking for pending operations.
    //
    TRACE_INFO(L"%!FUNC! Begin wait for cluster ehC 0x%lx operations to complete", ehCluster);
    do
    {
        fOperationsPending = FALSE;

        vector<ENGINEHANDLE> &InterfaceList =
                     pECluster->m_cSpec.m_ehInterfaceIdList; // vector reference

        for( int i = 0; i < InterfaceList.size(); ++i )
        {
            ENGINEHANDLE ehIF = InterfaceList[i];
            CInterfaceSpec *pISpec = m_mapIdToInterfaceSpec[ehIF]; // map
            if (pISpec == NULL)
            {
                //
                // Hmm... invalid interface handle? We'll ignore this one.
                //
                continue;
            }
            if (pISpec->m_ehPendingOperation != NULL)
            {
                fOperationsPending = TRUE;
                break;
            }
        }

        if (fOperationsPending)
        {
            mfn_Unlock();
            for (UINT u=0;u<50;u++)
            {
                ProcessMsgQueue();
                Sleep(100);
            }
            mfn_Lock();
        }
    }
    while (fOperationsPending);

    TRACE_INFO(L"%!FUNC! End wait for cluster ehC 0x%lx operations to complete.", ehCluster);
    nerr        = NLBERR_OK;

end_unlock:
    mfn_Unlock();

    return nerr;
}


//
// Verifies that all interfaces and the cluster have the same cluster mode.
//
// Will fail if any interface is marked misconfigured or is
// not bound to NLB. 
//
// On returning success, fSameMode is set to TRUE iff all IFs and the
// cluster have the same mode.
//
NLBERROR
CNlbEngine::mfn_VerifySameModeLk(
    IN  ENGINEHANDLE    ehCluster,
    OUT BOOL            &fSameMode
    )
{
    NLBERROR        nerr        = NLBERR_INTERNAL_ERROR;
    CEngineCluster  *pECluster  = NULL;
    CClusterSpec    *pCSpec     = NULL;

    fSameMode = FALSE;

    mfn_Lock();

    pECluster = m_mapIdToEngineCluster[ehCluster]; // map
    if (pECluster == NULL)
    {
        TRACE_CRIT("%!FUNC!: Invalid ehC 0x%lx", ehCluster);
        goto end_unlock;
    }
    pCSpec = &pECluster->m_cSpec;

    //
    // Let's check for mode changes...
    //
    {
        BOOL fConfigError = FALSE;
        NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE tmC;

        tmC = pCSpec->m_ClusterNlbCfg.GetTrafficMode();

        vector<ENGINEHANDLE> &InterfaceList =
                     pECluster->m_cSpec.m_ehInterfaceIdList; // vector reference

        fSameMode = TRUE;
        for( int i = 0; i < InterfaceList.size(); ++i )
        {
            ENGINEHANDLE ehIF = InterfaceList[i];
            CInterfaceSpec *pISpec = m_mapIdToInterfaceSpec[ehIF]; // map
            if (pISpec == NULL)
            {
                //
                // Hmm... invalid interface handle? We'll ignore this one.
                //
                continue;
            }

            //
            // Note: we can't check for pISpec->m_fMisconfigured because
            // the cluster may be marked misconfig because it doesn't
            // match the cluster parameters, which can happen on
            // mode changes (the ip addresses could be missing in the
            // interface).
            // 

            if (!pISpec->m_NlbCfg.IsValidNlbConfig())
            {
                fConfigError = TRUE;
                break;
            }

            {
                NLB_EXTENDED_CLUSTER_CONFIGURATION::TRAFFIC_MODE tmI;
                tmI =  pISpec->m_NlbCfg.GetTrafficMode();
                if (tmI != tmC)
                {
                    // 
                    // Mode change!
                    //
                    fSameMode = FALSE;
                    break;
                }
            }
        }

        if (fConfigError)
        {
            nerr = NLBERR_INVALID_CLUSTER_SPECIFICATION;
            fSameMode = FALSE;
        } 
        else
        {
            nerr = NLBERR_OK;
        }
    }

end_unlock:
    mfn_Unlock();

    return nerr;
}

VOID
CNlbEngine::AddOtherClusterMembers(
        IN ENGINEHANDLE ehInterface,
        IN BOOL fSync
        )
{
    BOOL            fStopOperationOnExit = FALSE;
    ENGINEHANDLE    ehCluster = NULL;
    NLBERROR        nerr = NLBERR_INTERNAL_ERROR;

    //
    // Get cluster ID, and attempt to start a cluster-wide operation
    // on it
    //
    {
        mfn_Lock();

        CInterfaceSpec  *pISpec = NULL;
        CClusterSpec    *pCSpec =  NULL;

        pISpec =  m_mapIdToInterfaceSpec[ehInterface]; // map
        if (pISpec != NULL)
        {
            ehCluster = pISpec->m_ehCluster;
            if (ehCluster != NULL)
            {
                CEngineCluster  *pECluster =  NULL;
                pECluster =  m_mapIdToEngineCluster[ehCluster]; // map
                pCSpec = &pECluster->m_cSpec;
            }
        }
    
        if (pCSpec == NULL)
        {
            TRACE_CRIT(L"%!FUNC! Could not get interface or cluster associated with ehIF 0x%08lx", ehInterface);
            goto end_unlock;
        }


        //
        // Attempt to start the update operation -- will fail if there is
        // already an operation started on this cluster.
        //
        {
            ENGINEHANDLE ExistingOp= NULL;
            CLocalLogger logDescription;
    
            logDescription.Log(
                IDS_LOG_ADD_CLUSTER_MEMBERS_OPERATION_DESCRIPTION,
                pCSpec->m_ClusterNlbCfg.NlbParams.cl_ip_addr
                );
    
            nerr =  mfn_StartClusterOperationLk(
                       ehCluster,
                       NULL, // pvCtxt
                       logDescription.GetStringSafe(),
                       &ExistingOp
                       );
    
            if (NLBFAILED(nerr))
            {
                //
                // TODO: Log the fact that we couldn't do the update because
                // of existing activity.
                //
                goto end_unlock;
            }
            else
            {
                //
                // At this point we're cleared to do a cluster-wide operation.
                //
                fStopOperationOnExit = TRUE;
                InterlockedIncrement(&m_WorkItemCount);
            }
        }
        mfn_Unlock();

        m_pCallbacks->HandleEngineEvent(
            IUICallbacks::OBJ_CLUSTER,
            ehCluster,
            ehCluster,
            IUICallbacks::EVT_STATUS_CHANGE
            );
        
    }


    if (fSync)
    {
        this->AddOtherClusterMembersWorkItem(
            ehInterface
            );
        fStopOperationOnExit = FALSE; // it'll be stopped by the above func.
    }
    else
    {
        BOOL fRet;

        //
        // We'll perform the operation in the background...
        //
        fRet = QueueUserWorkItem(
                    AddClusterMembersWorkItemRoutine,
                    (PVOID) (UINT_PTR) ehInterface,
                    WT_EXECUTELONGFUNCTION
                    );

        if (fRet)
        {
            fStopOperationOnExit = FALSE; // it'll be stopped in the background
        }
        else
        {
            TRACE_CRIT(L"%!FUNC! Could not queue work item");
            //
            // We don't bother to log this evidently low-resource situation.
            //
        }
    }

    mfn_Lock();

end_unlock:

    if (fStopOperationOnExit)
    {
        mfn_StopClusterOperationLk(ehCluster);
    }
    mfn_Unlock();

    if (fStopOperationOnExit)
    {
        m_pCallbacks->HandleEngineEvent(
            IUICallbacks::OBJ_CLUSTER,
            ehCluster,
            ehCluster,
            IUICallbacks::EVT_STATUS_CHANGE
            );
        InterlockedDecrement(&m_WorkItemCount);
    }

    return;
}


VOID
CNlbEngine::AddOtherClusterMembersWorkItem(
        IN ENGINEHANDLE ehInterface
        )
{
    ENGINEHANDLE ehCluster = NULL;
    ENGINEHANDLE ehHost    = NULL;
    _bstr_t bstrUserName;
    _bstr_t bstrPassword;
    _bstr_t bstrConnectionString;
    _bstr_t bstrNicGuid;
    _bstr_t bstrClusterIp;
    DWORD                   NumMembers = 0;
    NLB_CLUSTER_MEMBER_INFO *pMembers = NULL;

    {
        mfn_Lock();

        CInterfaceSpec  *pISpec = NULL;
        CClusterSpec    *pCSpec = NULL;
        CHostSpec       *pHSpec = NULL;
    
        pISpec =  m_mapIdToInterfaceSpec[ehInterface]; // map
        if (pISpec != NULL)
        {
            ehCluster = pISpec->m_ehCluster;
            if (ehCluster != NULL)
            {
                CEngineCluster  *pECluster =  NULL;
                pECluster =  m_mapIdToEngineCluster[ehCluster]; // map
                pCSpec = &pECluster->m_cSpec;

                if (pCSpec->m_ClusterNlbCfg.IsValidNlbConfig())
                {
                    bstrClusterIp = pCSpec->m_ClusterNlbCfg.NlbParams.cl_ip_addr;
                }
            }
        }
    
        if (pCSpec == NULL)
        {
            TRACE_CRIT(L"%!FUNC! Could not get interface or cluster associated with ehIF 0x%08lx", ehInterface);
            goto end_unlock;
        }
    
        ehHost = pISpec->m_ehHostId;
    
        //
        // Get the host ID
        //
        if (ehHost != NULL)
        {
            pHSpec =  m_mapIdToHostSpec[ehHost]; // map
        }

        if (pHSpec == NULL)
        {
            TRACE_CRIT("%!FUNC! Could not get ptr to host spec. Bailing.");
            goto end_unlock;
        }

        //
        // Save copies of these in local bstrs  before we unlock...
        //
        bstrUserName = pHSpec->m_UserName;
        bstrPassword = pHSpec->m_Password;
        bstrConnectionString = pHSpec->m_ConnectionString;
        bstrNicGuid = pISpec->m_Guid;

        if ((LPCWSTR)bstrNicGuid == (LPCWSTR)NULL)
        {
            // probably a low-memory situation...
            goto end_unlock;
        }

        mfn_Unlock();
    }

    //
    // Attempt to get the list of other cluster members from the
    // interface
    //
    {
        WMI_CONNECTION_INFO    ConnInfo;
        WBEMSTATUS wStat;
        LPCWSTR szNicGuid = bstrNicGuid;

        ZeroMemory(&ConnInfo, sizeof(ConnInfo));
        ConnInfo.szMachine     = (LPCWSTR) bstrConnectionString;
        ConnInfo.szUserName    = (LPCWSTR) bstrUserName;
        ConnInfo.szPassword    = (LPCWSTR) bstrPassword;

        wStat = NlbHostGetClusterMembers(
                            &ConnInfo, 
                            szNicGuid,
                            &NumMembers,
                            &pMembers       // free using delete[]
                            );
        if (FAILED(wStat))
        {
            NumMembers = 0;
            pMembers = NULL;
            //
            // TODO: Log error
            //
            mfn_Lock();
            goto end_unlock;
        }
    }


    //
    // For each member, attempt to connect to that host and add the specific
    // cluster.
    //
    {
        WBEMSTATUS wStat;
        LPCWSTR szNicGuid = bstrNicGuid;


#if 0
        CLocalLogger    logger;
        for (UINT u=0; u<NumMembers; u++)
        {
            NLB_CLUSTER_MEMBER_INFO *pMember = pMembers+u;
            logger.Log(
                IDS_DBG_LOG_ADD_CLUSTER_MEMBER, 
                pMember->HostId,
                pMember->DedicatedIpAddress,
                pMember->HostName
                );
        }
        ::MessageBox(
             NULL,
             logger.GetStringSafe(), // contents
             L"DEBUGINFO: GOING TO ADD THESE HOSTS...",
             MB_ICONINFORMATION   | MB_OK
            );
#endif // 0

        for (UINT u=0; u<NumMembers; u++)
        {
            NLB_CLUSTER_MEMBER_INFO *pMember = pMembers+u;
            WMI_CONNECTION_INFO    ConnInfo;
            ZeroMemory(&ConnInfo, sizeof(ConnInfo));
            ConnInfo.szUserName    = (LPCWSTR) bstrUserName;
            ConnInfo.szPassword    = (LPCWSTR) bstrPassword;
            if (*pMember->HostName != 0)
            {
                ConnInfo.szMachine     = pMember->HostName;
            } else if (*pMember->DedicatedIpAddress != 0
                       && (_wcsicmp(pMember->DedicatedIpAddress,
                           L"0.0.0.0")))
            {
                // non-blank dedicated IP -- let's try that...
                ConnInfo.szMachine     = pMember->DedicatedIpAddress;
            }

            if (ConnInfo.szMachine == NULL)
            {
                // Can't connect to this IP 
                // TODO: inform user in some way
                continue;
            }

            //
            // Now actually attempt to add the host
            //
            this->LoadHost(&ConnInfo, (LPCWSTR) bstrClusterIp);
        }
    }

    mfn_Lock();


end_unlock:

    if (ehCluster != NULL)
    {
        mfn_StopClusterOperationLk(ehCluster);
    }

    mfn_Unlock();

    m_pCallbacks->HandleEngineEvent(
        IUICallbacks::OBJ_CLUSTER,
        ehCluster,
        ehCluster,
        IUICallbacks::EVT_STATUS_CHANGE
        );

    delete [] pMembers; // may be NULL

    InterlockedDecrement(&m_WorkItemCount); // Don't touch this after this,
                                            // because it may no longer be valid
    return;
}

NLBERROR
CNlbEngine::LoadHost(
    IN  PWMI_CONNECTION_INFO pConnInfo,
    IN  LPCWSTR szClusterIp OPTIONAL
    )
{

    ENGINEHANDLE  ehHostId;
    _bstr_t       bstrConnectError;
    CHostSpec     hSpec;
    NLBERROR      err = NLBERR_INTERNAL_ERROR;

    TRACE_INFO(L"-> %!FUNC! Host name : %ls", (LPCWSTR)(pConnInfo->szMachine));


    if (m_fPrepareToDeinitialize)
    {
        err =  NLBERR_CANCELLED;
        goto end;
    }

    m_pCallbacks->Log(IUICallbacks::LOG_INFORMATIONAL, NULL, NULL,
         IDS_LOADFILE_LOOKING_FOR_CLUSTERS, pConnInfo->szMachine);
    ProcessMsgQueue();

    err = this->ConnectToHost(
                    pConnInfo,
                    FALSE,  // FALSE == don't overwrite connection info if
                            // already present
                    REF  ehHostId,
                    REF bstrConnectError
                    );
    if (err != NLBERR_OK)
    {
        m_pCallbacks->Log(IUICallbacks::LOG_ERROR, NULL, NULL, IDS_CONNECT_TO_HOST_FAILED, (LPCWSTR)bstrConnectError, (LPCWSTR)(pConnInfo->szMachine));
        TRACE_CRIT(L"<- %!FUNC! ConnectToHost returned error (string : %ls, retval : 0x%x)",(LPCWSTR)bstrConnectError, err);
        goto end;
    }

    if ((err = this->GetHostSpec(ehHostId, REF hSpec)) != NLBERR_OK)
    {
        m_pCallbacks->Log(IUICallbacks::LOG_ERROR, NULL, NULL, IDS_CRITICAL_ERROR_HOST, (LPCWSTR)(pConnInfo->szMachine));
        TRACE_CRIT(L"<- %!FUNC! GetHostSpec returned error : 0x%x", err);
        goto end;
    }

    //
    // Extract list of interfaces
    //
    for( int i = 0; i < hSpec.m_ehInterfaceIdList.size(); ++i )
    {
        ENGINEHANDLE   ehIID = hSpec.m_ehInterfaceIdList[i];
        CInterfaceSpec iSpec;

        ProcessMsgQueue();

        if ((err = this->GetInterfaceSpec(ehIID, REF iSpec)) != NLBERR_OK)
        {
            m_pCallbacks->Log(IUICallbacks::LOG_ERROR, NULL, NULL, IDS_CRITICAL_ERROR_HOST, (LPCWSTR)(pConnInfo->szMachine));
            TRACE_CRIT(L"%!FUNC! GetInterfaceSpec returned error : 0x%x", err);
            continue;
        }

        //
        // Check if interface has NLB bound to it
        // AND it is  NOT part of a cluster that nlb manager is already managing
        // AND (if szClusterIp NON-NULL, it matches the  specified cluster IP
        // 
        //
        if (iSpec.m_NlbCfg.IsNlbBound() && (iSpec.m_ehCluster == NULL)) 
        {
            LPCWSTR      szThisClusterIp;
            ENGINEHANDLE ehCluster;
            BOOL         fIsNew;

            szThisClusterIp = iSpec.m_NlbCfg.NlbParams.cl_ip_addr;
            if (   szClusterIp != NULL
                && _wcsicmp(szClusterIp, szThisClusterIp))
            {
                // different cluster ip
                TRACE_INFO(L"%!FUNC! Skipping cluster with CIP %ws because it doesn't match passed-in CIP %ws",
                        szThisClusterIp, szClusterIp);
                continue;
            }

            if ((err = this->LookupClusterByIP(szThisClusterIp, &(iSpec.m_NlbCfg), REF ehCluster, REF fIsNew)) != NLBERR_OK)
            {
                m_pCallbacks->Log(IUICallbacks::LOG_ERROR, NULL, NULL, IDS_CRITICAL_ERROR_HOST, (LPCWSTR)(pConnInfo->szMachine));
                TRACE_CRIT(L"%!FUNC! LookupClusterByIP returned error : 0x%x for cluster ip : %ls", err, szThisClusterIp);
                continue;

            }

            if (this->AddInterfaceToCluster(ehCluster, ehIID) != NLBERR_OK)
            {
                m_pCallbacks->Log(IUICallbacks::LOG_ERROR, NULL, NULL, IDS_CRITICAL_ERROR_HOST, (LPCWSTR)(pConnInfo->szMachine));
                TRACE_CRIT(L"%!FUNC! AddInterfaceToCluster returned error : 0x%x", err);
                continue;
            }

            /* Analyze this interface for misconfiguration */
            this->AnalyzeInterface_And_LogResult(ehIID);
        }
    }


end:
    ProcessMsgQueue();

    TRACE_INFO(L"<- %!FUNC!");
    return err;

}

/*
The following function analyzes the specified NLB interface for misconfiguration and logs
the result. I created this function (as opposed to adding it inline) because this code
needs to run in two cases:
1. CNLBEngine::LoadHost
2. LeftView::OnWorldConnect
--KarthicN, July 31, 2002
*/
VOID
CNlbEngine::AnalyzeInterface_And_LogResult(ENGINEHANDLE ehIID)
{
    CLocalLogger    logger;
    NLBERROR        err;

    mfn_Lock();

    err = this->mfn_AnalyzeInterfaceLk(ehIID, REF logger);
    if (NLBFAILED(err))
    {
        ENGINEHANDLE    ehCluster;
        LPCWSTR         szDetails = NULL;
        UINT            Size = 0;

        logger.ExtractLog(szDetails, Size);
        mfn_SetInterfaceMisconfigStateLk(m_mapIdToInterfaceSpec[ehIID], TRUE, szDetails);

        mfn_Unlock();

        //
        // Log ...
        //
        LPCWSTR szCluster   = NULL;
        LPCWSTR szHostName  = NULL;
        LPCWSTR szInterface = NULL;

        ENGINEHANDLE   ehHost;
        _bstr_t        bstrDisplayName;
        _bstr_t        bstrFriendlyName;
        _bstr_t        bstrHostName;
        _bstr_t        bstrIpAddress;

        err = this->GetInterfaceIdentification(
                ehIID,
                REF ehHost,
                REF ehCluster,
                REF bstrFriendlyName,
                REF bstrDisplayName,
                REF bstrHostName
                );

        if (NLBOK(err))
        {

            _bstr_t bstrDomainName;
            _bstr_t bstrClusterDisplayName;

            err  = this->GetClusterIdentification(
                        ehCluster,
                        REF bstrIpAddress, 
                        REF bstrDomainName, 
                        REF bstrClusterDisplayName
                        );
            if (NLBOK(err))
            {
                szCluster = bstrIpAddress;
            }

            szHostName = bstrHostName;
            szInterface = bstrFriendlyName;
        }


        IUICallbacks::LogEntryHeader Header;
        Header.szDetails = szDetails;
        Header.type = IUICallbacks::LOG_ERROR;
        Header.szCluster = szCluster;
        Header.szHost = szHostName;
        Header.szInterface = szInterface;

        m_pCallbacks->LogEx(
            &Header,
            IDS_LOG_INTERFACE_MISCONFIGURATION
            );

        // Change Icon to "Banged out"
        m_pCallbacks->HandleEngineEvent(
            IUICallbacks::OBJ_INTERFACE,
            ehCluster,
            ehIID,
            IUICallbacks::EVT_STATUS_CHANGE
            ); 
    }
    else
    {
        mfn_Unlock();
    }

    return;
}


VOID
CNlbEngine::mfn_DeleteHostIfNotManagedLk(
        ENGINEHANDLE ehHost
        )
/*
    Checks all the interfaces of host ehHost. If none of them are
    members of any cluster, and no pending operations are existing on
    them, we will delete the host and all its interfaces.

    Called with lock held!
*/
{
    CHostSpec *pHSpec =  NULL;
    BOOL fBusy = FALSE;
    UINT u;

    pHSpec =  m_mapIdToHostSpec[ehHost]; // map

    if (pHSpec == NULL) goto end;

    // DummyAction(L"DeleteHostIfNotManaged");


    //
    // Go through the list of interfaces, seeing if ANY interface
    // is part of a cluster or there are updates pending on it..
    //
    for(u = 0; u < pHSpec->m_ehInterfaceIdList.size(); ++u )
    {
        ENGINEHANDLE ehIId =  pHSpec->m_ehInterfaceIdList[u];
        CInterfaceSpec *pISpec = NULL;

        pISpec =  m_mapIdToInterfaceSpec[ehIId]; // map

        if (pISpec == NULL) continue;

        ASSERT(pISpec->m_ehHostId == ehHost);
        if (pISpec->m_ehCluster != NULL)
        {
            // Found an interface still part of a cluster, bail.
            fBusy = TRUE;
            break;
        }

        //
        //
        //
        if (pISpec->m_ehPendingOperation != NULL)
        {
            //
            // We really don't expect this, but it COULD happen.
            //
            TRACE_CRIT("Ignoring eh(0x%x) because it has pending operation 0x%x even though it's not a part of a cluster.",
                    ehIId,
                    pISpec->m_ehPendingOperation
                    );
            fBusy = TRUE;
            break;
        }
    }

    if (fBusy) goto end;

    TRACE_INFO(L"Deleting all interfaces under host eh(0x%x)", ehHost);
    for(u = 0; u < pHSpec->m_ehInterfaceIdList.size(); ++u )
    {
        ENGINEHANDLE ehIId =   pHSpec->m_ehInterfaceIdList[u];
        CInterfaceSpec *pISpec = NULL;

        pISpec =  m_mapIdToInterfaceSpec[ehIId]; // map

        if (pISpec == NULL) continue;

        ASSERT(pISpec->m_ehHostId == ehHost);
        ASSERT(pISpec->m_ehCluster == NULL);    // we checked above
        ASSERT(pISpec->m_ehPendingOperation == NULL); // we checked above

        //
        // Kill this interface!
        //
        TRACE_INFO(L"Deleting Interface eh=0x%x pISpec=0x%p",
            ehIId, pISpec);
        m_mapIdToInterfaceSpec.erase(ehIId);
        delete pISpec;
    }

    //
    // Erase the list of intefaces for this host...
    //
    pHSpec->m_ehInterfaceIdList.clear();


#if 1
    //
    // Now delete the host
    //
    TRACE_INFO(L"Deleting Host eh=0x%x pHSpec=0x%p",
        ehHost, pHSpec);
    m_mapIdToHostSpec.erase(ehHost);
    delete pHSpec;
#endif // 0

end:
    return;
}


VOID
CNlbEngine::PurgeUnmanagedHosts(void)
{
    vector <ENGINEHANDLE> PurgeHostList;

    TRACE_INFO(L"-> %!FUNC!");

    mfn_Lock();

    map< ENGINEHANDLE, CHostSpec* >::iterator iter;

    for( iter = m_mapIdToHostSpec.begin();
         iter != m_mapIdToHostSpec.end();
         ++iter)
    {
        CHostSpec *pHSpec =  (CHostSpec *) ((*iter).second);
        ENGINEHANDLE ehHost =  (ENGINEHANDLE) ((*iter).first);
        if (pHSpec != NULL)
        {
            if (!mfn_HostHasManagedClustersLk(pHSpec))
            {
                //
                // No managed clusters on this host -- a candidate
                // for deleting.
                //
                PurgeHostList.push_back(ehHost);
            }
        }
    }


    //
    // Now try to delete the hosts...
    // We do this out of the enumeration above because we want to
    // avoid modifying the map while we're iterating through it.
    //
    for(int i = 0; i < PurgeHostList.size(); ++i )
    {
        ENGINEHANDLE ehHost =  PurgeHostList[i];
        if (ehHost != NULL)
        {
            mfn_DeleteHostIfNotManagedLk(ehHost);
        }
    }

    mfn_Unlock();

    TRACE_INFO(L"<- %!FUNC!");

}

NLBERROR
CNlbEngine::mfn_CheckHost(
    IN PWMI_CONNECTION_INFO pConnInfo,
    IN ENGINEHANDLE ehHost // OPTIONAL
    )
/*
    TODO -- this function shares code with ConnectToHost -- get rid of
            the duplicated code somehow.
*/
{
    NLBERROR nerr = NLBERR_INTERNAL_ERROR;
    LPWSTR szWmiMachineName = NULL;
    LPWSTR szWmiMachineGuid = NULL;
    WBEMSTATUS wStatus;
    ULONG uIpAddress;
    BOOL fNlbMgrProviderInstalled = FALSE;
    _bstr_t  bstrError;

    TRACE_INFO(L"-> %!FUNC!(%ws)", pConnInfo->szMachine);


    wStatus =  NlbHostPing(pConnInfo->szMachine, 2000, &uIpAddress);
    if (FAILED(wStatus))
    {
        nerr = NLBERR_PING_TIMEOUT; // todo more specific error.
        bstrError =  GETRESOURCEIDSTRING(IDS_PING_FAILED);
    }
    else
    {

        wStatus = NlbHostGetMachineIdentification(
                           pConnInfo,
                           &szWmiMachineName,
                           &szWmiMachineGuid,
                           &fNlbMgrProviderInstalled
                           );
        if (FAILED(wStatus))
        {
            GetErrorCodeText(wStatus, bstrError);
            if (wStatus ==  E_ACCESSDENIED)
            {
                nerr = NLBERR_ACCESS_DENIED;
            }
            else
            {
                // TODO: map proper errors.
                nerr = NLBERR_NOT_FOUND;
            }
            TRACE_CRIT(L"Connecting to %ws returns error %ws",
                pConnInfo->szMachine, (LPCWSTR) bstrError);
            szWmiMachineName = NULL;
            szWmiMachineGuid = NULL;
        }
        else
        {
            nerr = NLBERR_OK;
        }
    }

    delete szWmiMachineName;
    delete szWmiMachineGuid;
    
    if (ehHost!=NULL)
    {
        CHostSpec *pHSpec = NULL;
        mfn_Lock();
        pHSpec =  m_mapIdToHostSpec[ehHost]; // map
        if (pHSpec != NULL)
        {
            if (NLBOK(nerr) ||  nerr == NLBERR_ACCESS_DENIED)
            {
                pHSpec->m_fUnreachable = FALSE;
            }
            else
            {
                pHSpec->m_fUnreachable = TRUE;
            }
        }
        else
        {
        }
        mfn_Unlock();

        //
        // Update the status of the specified host...
        //
        mfn_NotifyHostInterfacesChange(ehHost);

        //
        // Log error
        //
        if (NLBFAILED(nerr))
        {
            m_pCallbacks->Log(
                    IUICallbacks::LOG_ERROR,
                    NULL,
                    (LPCWSTR)(pConnInfo->szMachine),
                    IDS_CONNECT_TO_HOST_FAILED,
                    (LPCWSTR)bstrError,
                    (LPCWSTR)(pConnInfo->szMachine)
                    );
            TRACE_CRIT(L"<- %!FUNC! returning error (string : %ls, retval : 0x%x)",
                    (LPCWSTR)bstrError, nerr);
        }
    }

    return nerr;
}

VOID
CNlbEngine::mfn_UnlinkHostFromClusters(
        IN ENGINEHANDLE ehHost
        )
{
    CHostSpec *pHSpec =  NULL;
    BOOL fBusy = FALSE;
    UINT u;
    vector <ENGINEHANDLE> UnlinkInterfaceList;

    mfn_Lock();

    pHSpec =  m_mapIdToHostSpec[ehHost]; // map

    if (pHSpec == NULL) goto end;

    //
    // Go through the list of interfaces, adding any interfaces
    // that are part of a cluster to a temporary list.
    //
    for(u = 0; u < pHSpec->m_ehInterfaceIdList.size(); ++u )
    {
        ENGINEHANDLE ehIId =  pHSpec->m_ehInterfaceIdList[u];
        CInterfaceSpec *pISpec = NULL;

        pISpec =  m_mapIdToInterfaceSpec[ehIId]; // map

        if (pISpec == NULL) continue;

        ASSERT(pISpec->m_ehHostId == ehHost);
        if (pISpec->m_ehCluster != NULL)
        {
            //
            // Add this to the list of interfaces we're going to unlink
            // from its cluster.
            //
            UnlinkInterfaceList.push_back(ehIId);
        }
    }
    pHSpec = NULL;



    TRACE_INFO(L"Unlinking all interfaces under host eh(0x%x)", ehHost);
    for(u = 0; u < UnlinkInterfaceList.size(); ++u )
    {
        ENGINEHANDLE ehIId =   UnlinkInterfaceList[u];
        CInterfaceSpec *pISpec = NULL;
        ENGINEHANDLE ehCluster = NULL;

        pISpec =  m_mapIdToInterfaceSpec[ehIId]; // map

        if (pISpec == NULL) continue;

        ASSERT(pISpec->m_ehHostId == ehHost);
        ehCluster = pISpec->m_ehCluster;
        

        if (ehCluster != NULL)
        {
            mfn_Unlock();
            (VOID) CNlbEngine::RemoveInterfaceFromCluster(ehCluster, ehIId);
            mfn_Lock();
        }
    }
end:
    mfn_Unlock();
    return;
}

VOID
CNlbEngine::UnmanageHost(ENGINEHANDLE ehHost)
{
    mfn_UnlinkHostFromClusters(ehHost);
    mfn_Lock();
    mfn_DeleteHostIfNotManagedLk(ehHost);
    mfn_Unlock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\hostportsdlg.h ===
#ifndef HOSTPORTSDLG_H
#define HOSTPORTSDLG_H

#include "stdafx.h"

#include "resource.h"

#include "MNLBUIData.h"

// forward declaration
class PortsPage;

class HostPortsDlg : public CDialog
{
    
public:
    enum
    {
        IDD = IDD_DIALOG_PORT_RULE_PROP_HOSTS,
    };

    HostPortsDlg( PortsPage::PortData& portData,
                  ENGINEHANDLE ehCluster, // OPTIONAL
                  CWnd* parent
                     );

    CIPAddressCtrl ipAddress;

    // overrides of CDialog
    virtual void DoDataExchange( CDataExchange* pDX );

    virtual void OnOK();

    virtual BOOL OnInitDialog();

    afx_msg BOOL OnHelpInfo (HELPINFO* helpInfo );

    afx_msg void OnContextMenu( CWnd* pWnd, CPoint point );

    afx_msg void   OnCheckEqualLoad();


    // message handlers

    // 
    CComboBox   m_priority;

private:

    PortsPage::PortData& m_portData;

    PortsPage* m_parent;

    void
    SetControlData();

    ENGINEHANDLE m_ehCluster;

    DECLARE_MESSAGE_MAP()

};

static DWORD g_aHelpIDs_IDD_PORT_RULE_PROP_HOSTS [] = {
    IDC_GROUP_PORT_RULE_VIP,      IDC_GROUP_PORT_RULE_VIP,
    IDC_EDIT_PORT_RULE_VIP,       IDC_EDIT_PORT_RULE_VIP,
    IDC_CHECK_PORT_RULE_ALL_VIP,  IDC_CHECK_PORT_RULE_ALL_VIP,
    IDC_GROUP_RANGE,              IDC_GROUP_RANGE,
    IDC_TEXT_START,               IDC_EDIT_START,
    IDC_EDIT_START,               IDC_EDIT_START,
    IDC_SPIN_START,               IDC_EDIT_START,
    IDC_TEXT_END,                 IDC_EDIT_END,
    IDC_EDIT_END,                 IDC_EDIT_END,
    IDC_SPIN_END,                 IDC_EDIT_END,
    IDC_GROUP_PROTOCOLS,          IDC_GROUP_PROTOCOLS,
    IDC_RADIO_TCP,                IDC_RADIO_TCP,
    IDC_RADIO_UDP,                IDC_RADIO_UDP,
    IDC_RADIO_BOTH,               IDC_RADIO_BOTH,
    IDC_GROUP_MULTIPLE,           IDC_GROUP_MULTIPLE,
    IDC_RADIO_MULTIPLE,           IDC_RADIO_MULTIPLE,
    IDC_TEXT_AFF,                 IDC_TEXT_AFF,
    IDC_RADIO_AFF_NONE,           IDC_RADIO_AFF_NONE,
    IDC_RADIO_AFF_SINGLE,         IDC_RADIO_AFF_SINGLE,
    IDC_RADIO_AFF_CLASSC,         IDC_RADIO_AFF_CLASSC,
    IDC_CHECK_EQUAL,              IDC_CHECK_EQUAL,
    IDC_TEXT_MULTI,               IDC_TEXT_MULTI,
    IDC_EDIT_MULTI,               IDC_EDIT_MULTI,
    IDC_SPIN_MULTI,               IDC_EDIT_MULTI,
    IDC_CHECK_EQUAL,              IDC_CHECK_EQUAL,
    IDC_GROUP_SINGLE,             IDC_GROUP_MULTIPLE,
    IDC_RADIO_SINGLE,             IDC_RADIO_SINGLE,
    IDC_TEXT_SINGLE,              IDC_EDIT_SINGLE,
    IDC_EDIT_SINGLE,              IDC_EDIT_SINGLE,
    IDC_SPIN_SINGLE,              IDC_EDIT_SINGLE,
    IDC_GROUP_DISABLED,           IDC_GROUP_MULTIPLE,
    IDC_RADIO_DISABLED,           IDC_RADIO_DISABLED,
    0, 0
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\hostpage.h ===
#ifndef HOSTPAGE_H
#define HOSTPAGE_H

#include "stdafx.h"

#include "resource.h"

#include "MNLBUIData.h"
#include "IpSubnetMaskControl.h"

class HostPage : public CPropertyPage
{
public:
    enum
    {
        IDD = IDD_HOST_PAGE,
    };

    HostPage(
        CPropertySheet *psh,
        NLB_EXTENDED_CLUSTER_CONFIGURATION *pNlbCfg,
        ENGINEHANDLE ehCluster OPTIONAL,
        const ENGINEHANDLE *pehInterface OPTIONAL
        );

    // member controls

    CComboBox      nicName;

    CComboBox      priority;

    //
    // IpAddress and subnet mask
    //
    CIPAddressCtrl ipAddress;

    CIPAddressCtrl subnetMask;
    
    CComboBox      initialState;
    CButton        persistSuspend;

    // overrides of CPropertyPage
    virtual void DoDataExchange( CDataExchange* pDX );

    virtual BOOL OnInitDialog();

    virtual void OnOK();

    virtual BOOL OnSetActive();

    virtual BOOL OnKillActive();

    afx_msg void OnSelectedNicChanged();

    afx_msg void OnGainFocusDedicatedIP();

    afx_msg void OnGainFocusDedicatedMask();

    afx_msg BOOL OnHelpInfo (HELPINFO* helpInfo );

    afx_msg void OnContextMenu( CWnd* pWnd, CPoint point );

    virtual BOOL OnWizardFinish( );

private:

    CPropertySheet *m_pshOwner;

    ULONG   m_AvailableHostPriorities;

    ENGINEHANDLE m_ehCluster;   // engine handle to cluster (could be NULL)
    const ENGINEHANDLE *m_pehInterface; // engine handle to inteface (could be NULL)

    ClusterData* m_clusterData;

    // The (New) place to get/save config.
    //
    NLB_EXTENDED_CLUSTER_CONFIGURATION *m_pNlbCfg;

    BOOL m_fSaved; // If the config has been saved (from ui) at least once.


    void
    mfn_LoadFromNlbCfg(void);

    void
    mfn_SaveToNlbCfg(void);

    BOOL
    mfn_ValidateData();

    BOOL
    mfn_ValidateDip(LPCWSTR szDip);


    DECLARE_MESSAGE_MAP()
};

// help ids for this dialog.
//
static DWORD g_aHelpIDs_IDD_HOST_PAGE [] = {
    IDC_GROUP_NIC,                IDC_GROUP_NIC,
    IDC_NIC_FRIENDLY,             IDC_NIC_FRIENDLY,
    IDC_TEXT_PRI,                 IDC_EDIT_PRI,
    IDC_EDIT_PRI,                 IDC_EDIT_PRI,
    IDC_GROUP_DED_IP,             IDC_GROUP_DED_IP,
    IDC_TEXT_DED_IP,              IDC_EDIT_DED_IP,
    IDC_EDIT_DED_IP,              IDC_EDIT_DED_IP,
    IDC_TEXT_DED_MASK,            IDC_EDIT_DED_MASK,
    IDC_EDIT_DED_MASK,            IDC_EDIT_DED_MASK,
    IDC_GROUP_INITIAL_HOST_STATE, IDC_GROUP_INITIAL_HOST_STATE,
    IDC_COMBOBOX_DEFAULT_STATE,   IDC_COMBOBOX_DEFAULT_STATE,
    IDC_TEXT_DEFAULT_STATE,       IDC_COMBOBOX_DEFAULT_STATE,
    IDC_CHECK_PERSIST_SUSPEND,    IDC_CHECK_PERSIST_SUSPEND,
    0, 0
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\ipsubnetmaskcontrol.cpp ===
#include "precomp.h"
#pragma hdrstop
#include <stdio.h>
#include <process.h>
#include "IpSubnetMaskControl.h"
#include "wlbsconfig.h"
#include "wlbsutil.h"

/* Limitations for IP address fields. */
#define WLBS_FIELD_EMPTY -1
#define WLBS_FIELD_LOW 0
#define WLBS_FIELD_HIGH 255

#define WLBS_BLANK_HPRI -1

void PrintIPRangeError(HINSTANCE hInstance, HWND hWnd, unsigned int ids, int value, int low, int high);


CIpSubnetMaskControl::CIpSubnetMaskControl(DWORD dwIpAddressId, DWORD dwSubnetMaskId) 
{
    m_dwIpAddressId = dwIpAddressId;
    m_dwSubnetMaskId = dwSubnetMaskId;
    m_hWndDialog = NULL;
    m_hInstance = NULL;

    ZeroMemory(&m_IPFieldChangeState, sizeof(m_IPFieldChangeState));
}


//+----------------------------------------------------------------------------
//
// Function:  CIpSubnetMaskControl::OnInitDialog
//
// Description:  Called upon WM_INITDIALOG message.  
//
// Arguments: HWND hWnd - the parent dialog window
//            HINSTANCE hInstance - instance handle for resources
//
// Returns:   Nothing
//
// History:   fengsun Created Header    1/10/01
//
//+----------------------------------------------------------------------------
void CIpSubnetMaskControl::OnInitDialog(HWND hWnd, HINSTANCE hInstance) 
{
    m_hWndDialog = hWnd;
    m_hInstance = hInstance;

    /* Limit the field ranges for the address fields. */
    ::SendDlgItemMessage(hWnd, m_dwIpAddressId, EM_SETLIMITTEXT, CVY_MAX_CL_IP_ADDR, 0);
    ::SendDlgItemMessage(hWnd, m_dwSubnetMaskId, EM_SETLIMITTEXT, CVY_MAX_CL_NET_MASK, 0);

    /* Limit the zeroth field of the dedicated IP address between 1 and 223. */
    ::SendDlgItemMessage(m_hWndDialog, m_dwIpAddressId, IPM_SETRANGE, 0, (LPARAM)MAKEIPRANGE(WLBS_IP_FIELD_ZERO_LOW, WLBS_IP_FIELD_ZERO_HIGH));
}



/*
 * Method: OnSubnetMask
 * Description: Called when the user modifies the host netmask.
 */
LRESULT CIpSubnetMaskControl::OnSubnetMask(WORD wNotifyCode) 
{
    WCHAR wszIpAddress [CVY_MAX_CL_IP_ADDR + 1];
    WCHAR wszSubnetMask [CVY_MAX_CL_NET_MASK + 1];

    switch (wNotifyCode) 
    {
        case EN_SETFOCUS:
            /* Only generate a netmask if the netmask is currently empty and the IP address is not. */
            if (::SendMessage(::GetDlgItem(m_hWndDialog, m_dwSubnetMaskId), IPM_ISBLANK, 0, 0) &&
                !::SendMessage(::GetDlgItem(m_hWndDialog, m_dwIpAddressId), IPM_ISBLANK, 0, 0)) 
            {
                /* Retrieve the cluster IP address. */
                ::SendDlgItemMessage(m_hWndDialog, m_dwIpAddressId, WM_GETTEXT, CVY_MAX_CL_IP_ADDR + 1, (LPARAM)wszIpAddress);

                /* Fill the subnet mask. */
                ParamsGenerateSubnetMask(wszIpAddress, wszSubnetMask, ASIZECCH(wszSubnetMask));

                /* Set the cluster subnet mask. */
                ::SendDlgItemMessage(m_hWndDialog, m_dwSubnetMaskId, WM_SETTEXT, 0, (LPARAM)wszSubnetMask);

                break;
            }
    }

    return 0;
}






/*
 * Method: OnIpFieldChange
 * Description: Called wnen a field (byte) of the IP address/subnetmask changes. We use this
 *              to make sure the first byte of the IP is not < 1 or > 223.
 */
LRESULT CIpSubnetMaskControl::OnIpFieldChange(int idCtrl, LPNMHDR pnmh) 
{
    LPNMIPADDRESS Ip;
    int low = WLBS_FIELD_LOW;
    int high = WLBS_FIELD_HIGH;

    Ip = (LPNMIPADDRESS)pnmh;

    if (idCtrl == m_dwIpAddressId)
    {
        /* Field zero of the cluster IP address has different limits. */
        if (!Ip->iField) 
        {
            low = WLBS_IP_FIELD_ZERO_LOW;
            high = WLBS_IP_FIELD_ZERO_HIGH;
        }        
    }

    /* The notifier may call us twice for the same change, so we have to do the bookkeeping to make 
       sure we only alert the user once.  Use static variables to keep track of our state.  This will 
       allow us to ignore duplicate alerts. */
    if ((m_IPFieldChangeState.IpControl != Ip->hdr.idFrom) || (m_IPFieldChangeState.Field != Ip->iField) || 
        (m_IPFieldChangeState.Value != Ip->iValue) || (m_IPFieldChangeState.RejectTimes > 0)) {
        m_IPFieldChangeState.RejectTimes = 0;
        m_IPFieldChangeState.IpControl = Ip->hdr.idFrom;
        m_IPFieldChangeState.Field = Ip->iField;
        m_IPFieldChangeState.Value = Ip->iValue;

        /* Check the field value against its limits. */
        if ((Ip->iValue != WLBS_FIELD_EMPTY) && ((Ip->iValue < low) || (Ip->iValue > high))) 
        {
            /* Alert the user. */
            PrintIPRangeError(m_hInstance, m_hWndDialog, 
                    (idCtrl == m_dwIpAddressId) ? IDS_PARM_CL_IP_FIELD : IDS_PARM_CL_NM_FIELD, 
                    Ip->iValue, low, high);
        }
    } else m_IPFieldChangeState.RejectTimes++;
        

    return 0;
}





//+----------------------------------------------------------------------------
//
// Function:  CIpSubnetMaskControl::SetInfo
//
// Description:  Set the value to the control
//
// Arguments: const WCHAR* pszIpAddress - 
//            const WCHAR* pszSubnetMask - 
//
// Returns:   Nothing
//
// History:  shouse initial code 
//           fengsun Created Header    1/10/01
//
//+----------------------------------------------------------------------------
void CIpSubnetMaskControl::SetInfo(const WCHAR* pszIpAddress, const WCHAR* pszSubnetMask)
{
    /* If the cluster IP address or subnet mask are the default values, set them to NUL strings. */

    /* If the dedicated IP address is empty, then clear the entry box.  Otherwise, populate it with the IP address. */
    if (!pszIpAddress[0] || !wcscmp(pszIpAddress, CVY_DEF_CL_IP_ADDR))
        ::SendMessage(::GetDlgItem(m_hWndDialog, m_dwIpAddressId), IPM_CLEARADDRESS, 0, 0);
    else
        ::SendDlgItemMessage(m_hWndDialog, m_dwIpAddressId, WM_SETTEXT, 0, (LPARAM)pszIpAddress);

    /* If the host subnet mask is empty, then clear the entry box.  Otherwise, populate it with the netmask. */
    if (!pszSubnetMask[0] || !wcscmp(pszSubnetMask, CVY_DEF_CL_NET_MASK))
        ::SendMessage(::GetDlgItem(m_hWndDialog, m_dwSubnetMaskId), IPM_CLEARADDRESS, 0, 0);
    else
        ::SendDlgItemMessage(m_hWndDialog, m_dwSubnetMaskId, WM_SETTEXT, 0, (LPARAM)pszSubnetMask);
}






//+----------------------------------------------------------------------------
//
// Function:  CIpSubnetMaskControl::UpdateInfo
//
// Description:  Retrieve value from control
//
// Arguments: OUT WCHAR* pszIpAddress - 
//            OUT WCHAR* pszSubnetMask - 
//
// Returns:   Nothing
//
// History:  shouse initial code 
//           fengsun Created Header    1/10/01
//
//+----------------------------------------------------------------------------
void CIpSubnetMaskControl::UpdateInfo(OUT WCHAR* pszIpAddress, OUT WCHAR* pszSubnetMask) 
/*
    We expect that outparams are of  
    (CVY_MAX_CL_IP_ADDR + 1) and (CVY_MAX_CL_NET_MASK + 1)
    characters each, respectively.
*/
{
    /* If the dedicated IP entry box is empty, then the dedicated IP address is NUL.  Otherwise, grab it from the UI. */
    if (::SendMessage(::GetDlgItem(m_hWndDialog, m_dwIpAddressId), IPM_ISBLANK, 0, 0))
    {
        StringCchCopy(pszIpAddress, CVY_MAX_CL_IP_ADDR+1,  CVY_DEF_CL_IP_ADDR);
    }
    else
    {
        ::SendDlgItemMessage(m_hWndDialog, m_dwIpAddressId, WM_GETTEXT, CVY_MAX_CL_IP_ADDR, (LPARAM)pszIpAddress);
    }

    /* If the host net mask entry box is empty, then the host net mask is NUL.  Otherwise, grab it from the UI. */
    if (::SendMessage(::GetDlgItem(m_hWndDialog, m_dwSubnetMaskId), IPM_ISBLANK, 0, 0))
    {
        StringCchCopy(pszSubnetMask, CVY_MAX_CL_NET_MASK+1, CVY_DEF_CL_NET_MASK);
    }
    else
    {
        ::SendDlgItemMessage(m_hWndDialog, m_dwSubnetMaskId, WM_GETTEXT, CVY_MAX_CL_NET_MASK, (LPARAM)pszSubnetMask);
    }
}



//+----------------------------------------------------------------------------
//
// Function:  CIpSubnetMaskControl::ValidateInfo
//
// Description:  Validate whether user input is valid
//
// Arguments: None
//
// Returns:   bool - TRUE if valid
//
// History:  shouse initial code 
//           fengsun Created Header    1/10/01
//
//+----------------------------------------------------------------------------
bool CIpSubnetMaskControl::ValidateInfo() 
{
    DWORD IPAddr;

    /* Check for blank IP address */
    if (::SendMessage(::GetDlgItem(m_hWndDialog, m_dwIpAddressId), IPM_ISBLANK, 0, 0)) 
    {
        /* Alert the user. */
        NcMsgBox(m_hInstance, ::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_CL_IP_BLANK,
                 MB_APPLMODAL | MB_ICONSTOP | MB_OK);

        SetFocus(::GetDlgItem(m_hWndDialog, m_dwIpAddressId));

        /* An error occurred. */
        return false;
    }

    /* Check for blank netmask */
    if (::SendMessage(::GetDlgItem(m_hWndDialog, m_dwSubnetMaskId), IPM_ISBLANK, 0, 0)) 
    {
        /* Fill in the netmask for the user. */
        OnSubnetMask(EN_SETFOCUS);

        /* Alert the user. */
        NcMsgBox(m_hInstance, ::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_CL_NM_BLANK,
                 MB_APPLMODAL | MB_ICONSTOP | MB_OK);

        /* An error occurred. */
        return false;
    }

    /* Only perform the rest of the IP checking if the user has specified both a dedicated
       IP address and a corresponding netmask. */
    if (!::SendMessage(::GetDlgItem(m_hWndDialog, m_dwIpAddressId), IPM_ISBLANK, 0, 0) &&
        !::SendMessage(::GetDlgItem(m_hWndDialog, m_dwSubnetMaskId), IPM_ISBLANK, 0, 0)) {
        /* Get the dedicated IP address. */
        ::SendDlgItemMessage(m_hWndDialog, m_dwIpAddressId, IPM_GETADDRESS, 0, (LPARAM)&IPAddr);
        
        /* Make sure that the first octet is not zero.  If it is, make it 1 and alter the user. */
        if (!FIRST_IPADDRESS(IPAddr)) {
            /* Make the first octet 1 instead of the erroneous 0. */
            IPAddr = IPAddr | (DWORD)(WLBS_IP_FIELD_ZERO_LOW << 24);
            
            /* Set the IP address and update our dedicated IP address string. */
            ::SendDlgItemMessage(m_hWndDialog, m_dwIpAddressId, IPM_SETADDRESS, 0, (LPARAM)IPAddr);
            
            /* Alert the user. */
            PrintIPRangeError(m_hInstance, m_hWndDialog, IDS_PARM_CL_IP_FIELD, 0, 
                            WLBS_IP_FIELD_ZERO_LOW, WLBS_IP_FIELD_ZERO_HIGH);

            SetFocus(::GetDlgItem(m_hWndDialog, m_dwIpAddressId));
            return false;
        }

        WCHAR szIpAddress [CVY_MAX_CL_IP_ADDR + 1];
        WCHAR szSubnetMask [CVY_MAX_CL_IP_ADDR + 1];

        ::SendDlgItemMessage(m_hWndDialog, m_dwIpAddressId, WM_GETTEXT, CVY_MAX_CL_IP_ADDR, (LPARAM)szIpAddress);
        ::SendDlgItemMessage(m_hWndDialog, m_dwSubnetMaskId, WM_GETTEXT, CVY_MAX_CL_NET_MASK, (LPARAM)szSubnetMask);

        /* Check for valid dedicated IP address/netmask pairs. */
        if (!IsValidIPAddressSubnetMaskPair(szIpAddress, szSubnetMask)) {
            /* Alert the user. */
            NcMsgBox(m_hInstance, ::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_INVAL_CL_IP,
                     MB_APPLMODAL | MB_ICONSTOP | MB_OK);
            
            SetFocus(::GetDlgItem(m_hWndDialog, m_dwIpAddressId));

            /* An error occurred. */
            return false;
        }
        
        /* Check to make sure that the netmask is contiguous. */
        if (!IsContiguousSubnetMask(szSubnetMask)) {
            /* Alert the user. */
            NcMsgBox(m_hInstance, ::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_INVAL_CL_MASK,
                     MB_APPLMODAL | MB_ICONSTOP | MB_OK);
            
            SetFocus(::GetDlgItem(m_hWndDialog, m_dwIpAddressId));

            /* An error occurred. */
            return false;
        }
    }

    return true;  // no error
}


/*
 * Method: PrintIPRangeError
 * Description: Displays a message box warning the user of an out-of-range entry in
 *              an IP address octet.
 */
void PrintIPRangeError (HINSTANCE hInstance, HWND hWnd, unsigned int ids, int value, int low, int high) 
{
    WCHAR szCurrent[12];
    WCHAR szLow[12];
    WCHAR szHigh[12];

    /* Fill in the range and the offending value. */
    StringCbPrintf(szHigh, sizeof(szHigh), L"%d", high);
    StringCbPrintf(szCurrent, sizeof(szCurrent), L"%d", value);
    StringCbPrintf(szLow, sizeof(szLow), L"%d", low);
    
    /* Pop-up a message box. */
    NcMsgBox(hInstance, hWnd, IDS_PARM_ERROR, ids, MB_APPLMODAL | MB_ICONSTOP | MB_OK, szCurrent, szLow, szHigh);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\leftview.h ===
#ifndef LEFTVIEW_H
#define LEFTVIEW_H

#include "stdafx.h"
#include "Document.h"
#include "resource.h"

#include "MNLBUIData.h"

#define IDT_REFRESH 1

class LeftView : public CTreeView
{
    DECLARE_DYNCREATE( LeftView )

public:

	//
	// The following enum identifies some operations -- these are used in the implementation of
	// certain dialog classes to decide how to present their UI elements -- eg ClusterPage (clusterpage.h,.cpp).
	//
	typedef enum
	{
		OP_NEWCLUSTER,
		OP_EXISTINGCLUSTER,
		OP_ADDHOST,
		OP_CLUSTERPROPERTIES,
		OP_HOSTPROPERTIES
		
	} OPERATION;

    virtual void OnInitialUpdate();

    LeftView();

    ~LeftView();

    //
    // Called to indicate that deinitialization will soon follow.
    // After return from this call, the the left view will ignore
    // any HandleEngineEvent entries and the various cmdhandlers (in particular)
    // OnRefresh and auto-refresh) will be no-ops.
    //
    void
    PrepareToDeinitialize(void)
    {
        m_fPrepareToDeinitialize = TRUE;
    }

    void Deinitialize(void);
    
    //
    // Get connection information about a specific host.
    //
    BOOL
    GetConnectString(
        IN OUT CHostSpec& host
    );


    //
    // Update the view because of change relating to a specific instance of
    // a specific object type.
    //
    void
    HandleEngineEvent(
        IN IUICallbacks::ObjectType objtype,
        IN ENGINEHANDLE ehClusterId, // could be NULL
        IN ENGINEHANDLE ehObjId,
        IN IUICallbacks::EventCode evt
        );

    // world level.
    void OnFileLoadHostlist(void);
    void OnFileSaveHostlist(void);

    void OnWorldConnect(void);

    void OnWorldNewCluster(void);

    // cluster level.
    UINT m_refreshTimer;
    void OnTimer(UINT nIDEvent);

    void OnRefresh(BOOL bRefreshAll);
    
    void OnClusterProperties(void);

    void OnClusterRemove(void);

    void OnClusterUnmanage(void);

    void OnClusterAddHost(void);

    void OnOptionsCredentials(void);

    void OnOptionsLogSettings(void);

    void OnClusterControl(UINT nID );

    void OnClusterPortControl(UINT nID );

    // host level
    void OnHostProperties(void);

    void OnHostStatus(void);

    void OnHostRemove(void);

    void OnHostControl(UINT nID );

    void OnHostPortControl(UINT nID );

    Document* GetDocument();

protected:

private:
    TVINSERTSTRUCT rootItem;

    CString worldName;

    _bstr_t title;


    // message handlers.
    afx_msg BOOL OnHelpInfo (HELPINFO* helpInfo );
    afx_msg void OnContextMenu( CWnd* pWnd, CPoint point );
    afx_msg void OnRButtonDown( UINT nFlags, CPoint point );
    afx_msg void OnKeyDown( UINT nChar, UINT nRepCnt, UINT nFlags );
    afx_msg void OnLButtonDblClk( UINT nFlags, CPoint point );

    // change in selection.
    afx_msg void OnSelchanged(NMHDR* pNMHDR, LRESULT* pResult);


    void
    mfn_InsertCluster(
        ENGINEHANDLE ehClusterId,
        const CClusterSpec *pCSpec
        );

    void
    mfn_DeleteCluster(
        ENGINEHANDLE ehID
        );

    void
    mfn_InsertInterface(
        ENGINEHANDLE ehClusterID,
        ENGINEHANDLE ehInterfaceID,
        const CHostSpec *pHSpec,
        const CInterfaceSpec *pISpec
        );

    void
    mfn_DeleteInterface(
        ENGINEHANDLE ehInterfaceID
        );

    WLBS_OPERATION_CODES
    mfn_MapResourceIdToOpcode(bool bClusterWide, DWORD dwResourceId);


	map< ENGINEHANDLE, HTREEITEM > mapIdToInterfaceItem;
	map< ENGINEHANDLE, HTREEITEM > mapIdToClusterItem;

	CRITICAL_SECTION m_crit;
    BOOL m_fPrepareToDeinitialize;

    void mfn_Lock(void);
    void mfn_Unlock(void) {LeaveCriticalSection(&m_crit);}

    NLBERROR
    mfn_GetSelectedInterface(
            ENGINEHANDLE &ehInterface,
            ENGINEHANDLE &ehCluster
            );

    NLBERROR
    mfn_GetSelectedCluster(
            ENGINEHANDLE &ehCluster
            );

    int
    mfn_GetFileNameFromDialog(
            bool    bLoadHostList,
            CString &FileName
            );


    void
    mfn_EnableClusterMenuItems(BOOL fEnable);

    void
    mfn_EnableHostMenuItems(BOOL fEnable);

    DECLARE_MESSAGE_MAP()
};    

class LogSettingsDialog : public CDialog
{

public:

    enum
    {
        IDD = IDD_DIALOG_LOGSETTINGS
    };

    LogSettingsDialog(Document* pDocument, CWnd* parent = NULL);

    virtual BOOL OnInitDialog();

    virtual void OnOK();

    afx_msg BOOL OnHelpInfo (HELPINFO* helpInfo );
    afx_msg void OnContextMenu( CWnd* pWnd, CPoint point );
    afx_msg void  OnSpecifyLogSettings();
    afx_msg void  OnUpdateEditLogfileName();

    // overrides CDialog -- see SDK documentation on DoDataExchange.
    // Used to map controls in resources to corresponding objects in this class.
    virtual void DoDataExchange( CDataExchange* pDX );

    CEdit       m_LogFileName;
    CEdit       m_DoLogging;
    bool        m_fLoggingEnabledOnInit;
    Document    *m_pDocument;
    
    static
    DWORD
    s_HelpIDs[];

    DECLARE_MESSAGE_MAP()
};


//
// This dialog is a read-only dialog that reports on log details or
// misconfiguration details.
//
class DetailsDialog : public CDialog
{
public:

    enum
    {
        IDD = IDD_DIALOG_LOG_DETAILS
    };

    DetailsDialog(
            Document* pDocument,
            LPCWSTR szCaption,
            LPCWSTR szDate,
            LPCWSTR szTime,
            LPCWSTR szCluster,
            LPCWSTR szHost,
            LPCWSTR szInterface,
            LPCWSTR szSummary,
            LPCWSTR szDetails,
            CWnd* parent = NULL
            );

    ~DetailsDialog();

    virtual BOOL OnInitDialog();

    afx_msg void OnActivate( UINT nState, CWnd* pWndOther, BOOL bMinimized );

    // overrides CDialog -- see SDK documentation on DoDataExchange.
    // Used to map controls in resources to corresponding objects in this class.
    virtual void DoDataExchange( CDataExchange* pDX );

    Document    *m_pDocument;
    LPCWSTR     m_szCaption;
    LPCWSTR     m_szDate;
    LPCWSTR     m_szTime;
    LPCWSTR     m_szCluster;
    LPCWSTR     m_szHost;
    LPCWSTR     m_szInterface;
    LPCWSTR     m_szSummary;

    CEdit       m_Details;
    LPWSTR      m_szMungedDetails;

    DECLARE_MESSAGE_MAP()
};

/* 
 * All NLB manager property sheets must use this property sheet, which inherits
 * from CPropertySheet in order to add the context sensitive help icon to the 
 * title bar, as per KB Q244232. (shouse, 9.25.01)
 */
class CNLBMgrPropertySheet : public CPropertySheet {
public:
    CNLBMgrPropertySheet(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0 ) {
        CPropertySheet::CPropertySheet(nIDCaption, pParentWnd, iSelectPage);
    }
    
    CNLBMgrPropertySheet(LPCTSTR pszCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0) {
        CPropertySheet::CPropertySheet(pszCaption, pParentWnd, iSelectPage);
    } 

    virtual BOOL OnInitDialog () {
        BOOL bResult = CPropertySheet::OnInitDialog();

        /* Add the context help icon to the title bar. */
        ModifyStyleEx(0, WS_EX_CONTEXTHELP);
        return bResult;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\ipsubnetmaskcontrol.h ===
#pragma once

#include "resource.h"
#include "wlbsparm.h"

#define WLBS_IP_FIELD_ZERO_LOW 1
#define WLBS_IP_FIELD_ZERO_HIGH 223


//+----------------------------------------------------------------------------
//
// class CIpSubnetMaskControl
//
// Description: Add error checking for an IP address and subnet mask pair.
//              Generate default subnetmask based on ip
//
// History:     shouse initial code
//              fengsun Created class    1/12/01
//
//+----------------------------------------------------------------------------
class CIpSubnetMaskControl
{
public:
    CIpSubnetMaskControl(DWORD dwIpAddressResourceId, DWORD dwSubnetMaskResourceId);
    ~CIpSubnetMaskControl(){};

    void OnInitDialog(HWND hWnd, HINSTANCE hInstance);

    LRESULT OnSubnetMask(WORD wNotifyCode);
    LRESULT OnIpFieldChange(int idCtrl, LPNMHDR pnmh);

    void SetInfo(const WCHAR* pszIpAddress, const WCHAR* pszSubnetMask);


    void UpdateInfo(OUT WCHAR* pszIpAddress, OUT WCHAR* pszSubnetMask);
        /*
            We expect that above outparams are of  
            (CVY_MAX_CL_IP_ADDR + 1) and (CVY_MAX_CL_NET_MASK + 1)
            characters each, respectively.
        */


    bool ValidateInfo();

protected:

    DWORD m_dwIpAddressId;
    DWORD m_dwSubnetMaskId;
    HWND  m_hWndDialog;  // parent dialog window handle
    HINSTANCE m_hInstance; // instance handle for error string resource

    //
    // The PropertySheet may call us twice for the same change, so we have to do the bookkeeping to make 
    // sure we only alert the user once.  Use static variables to keep track of our state.  This will 
    //        allow us to ignore duplicate alerts. 
    //
    struct {
        UINT IpControl;
        int Field;
        int Value;
        UINT RejectTimes;
    } m_IPFieldChangeState;
};


INT
WINAPIV
NcMsgBox (
    IN HINSTANCE   hinst,
    IN HWND        hwnd,
    IN UINT        unIdCaption,
    IN UINT        unIdFormat,
    IN UINT        unStyle,
    IN ...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\logview.h ===
//***************************************************************************
//
//  LOGVIEW.H
// 
//  Module: NLB Manager (client-side exe)
//
//  Purpose:  View of a log of events.
//
//  Copyright (c)2001 Microsoft Corporation, All Rights Reserved
//
//  History:
//
//  08/03/01    JosephJ Adapted from now defunct RightBottomView
//
//***************************************************************************
#pragma once


#include "stdafx.h"
#include "Document.h"

// class LogView : public CEditView
class LogView : public CListView
{
    DECLARE_DYNCREATE( LogView )

public:
    virtual void OnInitialUpdate();

    LogView();
    ~LogView();

    void
    Deinitialize(void);

    //
    // Log a message in human-readable form.
    //
    void
    LogString(
        IN const IUICallbacks::LogEntryHeader *pHeader,
        IN const wchar_t    *szText
        );

    //
    // Called to indicate that deinitialization will soon follow.
    // After return from this call, the the log view will ignore
    // any new log entires (LogString will become a no-op).
    //
    void
    PrepareToDeinitialize(void)
    {
        m_fPrepareToDeinitialize = TRUE;
    }


protected:
    Document* GetDocument();

    //message handlers
    afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags );

    afx_msg void OnDoubleClick( NMHDR* pNMHDR, LRESULT* pResult );

	CRITICAL_SECTION m_crit;
    BOOL m_fPrepareToDeinitialize;

    void mfn_Lock(void);
    void mfn_Unlock(void) {LeaveCriticalSection(&m_crit);}
    void mfn_DisplayDetails(int index);

    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\leftview.cpp ===
//***************************************************************************
//
//  LEFTVIEW.CPP
// 
//  Module: NLB Manager
//
//  Purpose: LeftView, the tree view of NlbManager, and a few other
//           smaller classes.
//
//  Copyright (c)2001-2002 Microsoft Corporation, All Rights Reserved
//
//  History:
//
//  07/30/01    JosephJ Created (re-wrote MHakim's version)
//
//***************************************************************************
#include "precomp.h"
#pragma hdrstop
#include "private.h"
#include "Connect.h"
#include "vipspage.h"
#include "PortsControlPage.h"
#include "HostPage.h"
#include "ClusterPage.h"
#include "PortsPage.h"
#include "PortsCtrl.h"
#include "MNLBUIData.h"
#include "resource.h"
#include "leftview.tmh"

//
// Static help-id maps
//

DWORD
LogSettingsDialog::s_HelpIDs[] =
{
    IDC_CHECK_LOGSETTINGS, IDC_CHECK_LOGSETTINGS,
    IDC_GROUP_LOGSETTINGS, IDC_GROUP_LOGSETTINGS,
    IDC_EDIT_LOGFILENAME, IDC_EDIT_LOGFILENAME,
    IDC_TEXT_LOGFILENAME, IDC_EDIT_LOGFILENAME,
    0, 0
};


void
DummyAction(LPCWSTR szMsg)
{
    ::MessageBox(
         NULL,
         szMsg, // contents
         L"DUMMY ACTION", // caption
         MB_ICONINFORMATION   | MB_OK
        );
}


using namespace std;

IMPLEMENT_DYNCREATE( LeftView, CTreeView )

BEGIN_MESSAGE_MAP( LeftView, CTreeView )

    ON_WM_KEYDOWN()
    ON_WM_TIMER()
    ON_WM_RBUTTONDOWN()
    ON_WM_LBUTTONDBLCLK()
    ON_NOTIFY_REFLECT(TVN_SELCHANGED, OnSelchanged)

END_MESSAGE_MAP()

BEGIN_MESSAGE_MAP( LogSettingsDialog, CDialog )

    ON_WM_HELPINFO()        
    ON_WM_CONTEXTMENU()        
    ON_BN_CLICKED(IDC_CHECK_LOGSETTINGS, OnSpecifyLogSettings)
    ON_EN_UPDATE(IDC_EDIT_LOGFILENAME, OnUpdateEditLogfileName)

END_MESSAGE_MAP()


// Sort the item in reverse alphabetical order.

LeftView::LeftView()
    :  m_refreshTimer(0),
       m_fPrepareToDeinitialize(FALSE)
{
    TRACE_INFO(L"-> %!FUNC!");
    InitializeCriticalSection(&m_crit);
    TRACE_INFO(L"<- %!FUNC!");
}

/*
 * Method: OnTimer
 * Description: This method is called by the timer notification handler if
 *              a timer has expired that is intended for this window.
 */
void LeftView::OnTimer(UINT nIDEvent)
{
    /* Call the base class timer routine first. */
    CTreeView::OnTimer(nIDEvent);

    if (theApplication.IsProcessMsgQueueExecuting())
    {
        goto end;
    }

    if (m_fPrepareToDeinitialize)
    {
        goto end;
    }

    switch (nIDEvent) {
    case IDT_REFRESH:
        /* If this is a refresh timer, refresh everything. */
        OnRefresh(TRUE);
        break;
    default:
        break;
    }

end:
    return;

}

LeftView::~LeftView()
{
    /* If a timer is set, kill it. */
    if (m_refreshTimer) KillTimer(m_refreshTimer);

    DeleteCriticalSection(&m_crit);
}
 
Document*
LeftView::GetDocument()
{
    return ( Document *) m_pDocument;
}


void 
LeftView::OnInitialUpdate(void)
{
    TRACE_INFO(L"-> %!FUNC!");
    CTreeView::OnInitialUpdate();

    // get present style.
    LONG presentStyle;
    
    presentStyle = GetWindowLong( m_hWnd, GWL_STYLE );

    // Set the last error to zero to avoid confusion.  See sdk for SetWindowLong.
    SetLastError(0);

    // set new style.
    LONG rcLong;

    rcLong = SetWindowLong( m_hWnd,
                            GWL_STYLE,
                            presentStyle | TVS_HASLINES | TVS_HASBUTTONS | TVS_SHOWSELALWAYS | TVS_LINESATROOT );

    //
    // Get and set the image list which is used by this 
    // tree view from document.
    //
    GetTreeCtrl().SetImageList( GetDocument()->m_images48x48, 
                                TVSIL_NORMAL );


    // insert root icon which is world

    const _bstr_t& worldLevel = GETRESOURCEIDSTRING( IDS_WORLD_NAME );

    rootItem.hParent        = TVI_ROOT;             
    rootItem.hInsertAfter   = TVI_FIRST;           
    rootItem.item.mask      = TVIF_IMAGE | TVIF_PARAM | TVIF_SELECTEDIMAGE | TVIF_TEXT | TVIF_CHILDREN;  
    rootItem.item.pszText   = worldLevel;
    rootItem.item.cchTextMax= worldLevel.length() + 1;
    rootItem.item.iImage    = 0;
    rootItem.item.iSelectedImage = 0;
    rootItem.item.lParam    = 0;   
    rootItem.item.cChildren = 1;

    GetTreeCtrl().InsertItem(  &rootItem );


    //
    // we will register 
    // with the document class, 
    // as we are the left pane
    //
    GetDocument()->registerLeftView(this);

    /* If autorefresh was specified on the command line, setup a timer
       to refresh the cluster at the specified interval (in seconds). */
    if (gCmdLineInfo.m_bAutoRefresh)
        m_refreshTimer = SetTimer(IDT_REFRESH, gCmdLineInfo.m_refreshInterval * 1000, NULL);

    TRACE_INFO(L"<- %!FUNC!");
}


void 
LeftView::OnRButtonDown( UINT nFlags, CPoint point )
{

    CMenu menu;
    CTreeView::OnRButtonDown(nFlags, point);

    if (theApplication.IsProcessMsgQueueExecuting())
    {
        goto end;
    }

    // do a hit test
    // here we are checking that right button is down on 
    // a tree view item or icon.
    TVHITTESTINFO hitTest;

    hitTest.pt = point;

    GetTreeCtrl().HitTest( &hitTest );
    if( !(hitTest.flags == TVHT_ONITEMLABEL )
        && 
        !(hitTest.flags == TVHT_ONITEMICON )
        )
    {
        return;
    }

    // make the item right clicked on the 
    // selected item.

    GetTreeCtrl().SelectItem( hitTest.hItem );

    LRESULT result;
    OnSelchanged( NULL, &result );

    HTREEITEM hdlSelItem = hitTest.hItem;

    // get the image of the item which
    // has been selected.  From this we can make out it it is
    // world level, cluster level or host level.
    TVITEM  selItem;
    selItem.hItem = hdlSelItem;
    selItem.mask = TVIF_IMAGE ;
    
    GetTreeCtrl().GetItem( &selItem );
		
    /// Depending upon item selected show the pop up menu.
    int menuIndex;


    IUICallbacks::ObjectType objType;
    BOOL fValidHandle;
    fValidHandle = gEngine.GetObjectType(
                    (ENGINEHANDLE)selItem.lParam,
                    REF objType);
    
    if (!fValidHandle)
    {
            menuIndex = 0;
    }
    else
    {
        switch(objType)
        {
        case  IUICallbacks::OBJ_CLUSTER:
            menuIndex = 1;
            break;

        case  IUICallbacks::OBJ_INTERFACE:
            menuIndex = 2;
            break;
            
        default:  // other object type unexpected
            ASSERT(FALSE);
            return;
        }
    }

    menu.LoadMenu( IDR_POPUP );

    CMenu* pContextMenu = menu.GetSubMenu( menuIndex );

    ClientToScreen( &point );


    //
    // We specify our PARENT below because MainForm handles all
    // control operations -- see class MainForm.
    //
    pContextMenu->TrackPopupMenu( TPM_RIGHTBUTTON,
                                  point.x,
                                  point.y,
                                  this->GetParent()  );

end:

    return;
}


void 
LeftView::OnRefresh(BOOL bRefreshAll)
{
    // find tree view cluster member which has been selected.
    //
    ENGINEHANDLE ehClusterId = NULL;
    NLBERROR nerr;


    if (theApplication.IsProcessMsgQueueExecuting())
    {
        goto end;
    }

    if (!bRefreshAll) {
        BOOL fInterface = FALSE;

        nerr =  mfn_GetSelectedCluster(REF ehClusterId);
        
        if (nerr != NLBERR_OK)
        {
            TRACE_CRIT("%!FUNC! -- invalid ehCluster!");
            goto end;
        }
        
        
        //
        // Hack -- the following block uses the fact that mfn_GetSelectedCluster
        // returns a handle (the interface handle) if the selection happens
        // to be on an interface. So it checks to see whether it's an interface
        // or cluster. Later, depending on which, we call either UpdateCluster or
        // RefreshInterface.
        //
        {
            BOOL fValidHandle;
            IUICallbacks::ObjectType objType;
            fValidHandle = gEngine.GetObjectType(
                ehClusterId,
                REF objType);
            
            if (fValidHandle && objType == IUICallbacks::OBJ_INTERFACE)
            {
                fInterface = TRUE;
            }
        }
        
        {
            CWaitCursor wait;
            
            if (fInterface)
            {
                nerr = gEngine.RefreshInterface(
                            ehClusterId,
                            TRUE,   // TRUE == start new operation
                            FALSE   // FALSE == this is NOT cluster wide
                            );

                if (nerr != NLBERR_OK)
                {
                    TRACE_CRIT("%!FUNC! -- gEngine.RefreshInterface returns 0x%lx", nerr);
                }
            }
            else
            {
                CLocalLogger logConflicts;
                nerr = gEngine.UpdateCluster(
                    ehClusterId,
                    NULL,
                    REF logConflicts
                    );
                if (nerr != NLBERR_OK)
                {
                    TRACE_CRIT("%!FUNC! gEngine.UpdateCluster returns 0x%lx", nerr);
                }
            }
        }

    } else {

        //
        // Refresh all ...
        //

        vector <ENGINEHANDLE> ClusterList;
        vector <ENGINEHANDLE>::iterator iCluster;

        nerr = gEngine.EnumerateClusters(ClusterList);
        
        if (FAILED(nerr)) goto end;
        
        for (iCluster = ClusterList.begin();
             iCluster != ClusterList.end(); 
             iCluster++) 
        {
            ENGINEHANDLE ehClusterId1 = (ENGINEHANDLE)*iCluster;
            CLocalLogger logConflicts;

            nerr = gEngine.UpdateCluster(ehClusterId1, NULL, REF logConflicts);

            if (nerr != NLBERR_OK)
            {
                TRACE_CRIT("%!FUNC! gEngine.UpdateCluster returns 0x%lx", nerr);
            }
        }
    }

end:

    gEngine.PurgeUnmanagedHosts();

    // LRESULT result;
    // OnSelchanged( NULL, &result );
    return;
}


void LeftView::OnFileLoadHostlist(void)
{
    CString    FileName;

    TRACE_INFO(L"-> %!FUNC!");
   
    if (theApplication.IsProcessMsgQueueExecuting())
    {
        goto end;
    }

    if (mfn_GetFileNameFromDialog(true, REF FileName) == IDOK)
    {
        GetDocument()->LoadHostsFromFile((_bstr_t)(LPCTSTR)FileName); 
    }

end:

    TRACE_INFO(L"<- %!FUNC!");
}

int LeftView::mfn_GetFileNameFromDialog(bool bLoadHostList, CString &FileName)
{
    int ret;
    _bstr_t bstrFileFilter = GETRESOURCEIDSTRING(IDS_HOSTLIST_FILE_FILTER);

    // Create File dialog
    CFileDialog dlg(bLoadHostList,  // TRUE for "Open", FALSE for "Save As"
                    L".txt",        // Default File Extension
                    NULL,           // Initial File Name
                    OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | (bLoadHostList ? OFN_FILEMUSTEXIST : 0), 
                    (LPCWSTR) bstrFileFilter
                   );
    if ((ret = dlg.DoModal()) == IDOK)
    {
        FileName = dlg.GetPathName();  // Get file name with complete path
    }
    return ret;
}

void LeftView::OnFileSaveHostlist(void)
{
    CString    FileName;

    TRACE_INFO(L"-> %!FUNC!");

    if (mfn_GetFileNameFromDialog(false, REF FileName) == IDOK)
    {
        CStdioFile SaveHostListFile;

        TRACE_INFO(L"%!FUNC! File name : %ls", (LPCWSTR)FileName);

        // Open file
        if (!SaveHostListFile.Open(FileName, CFile::modeCreate | CFile::modeWrite | CFile::typeText))
        {
            TRACE_CRIT(L"%!FUNC! CFile::Open failed for file : %ls",FileName);
            AfxMessageBox((LPCTSTR)(GETRESOURCEIDSTRING(IDS_FILE_OPEN_FAILED) + FileName));
            return;
        }

        CString     HostName;

        // Write host names to a file
        vector <_bstr_t> HostList;

        if (gEngine.GetAllHostConnectionStrings(REF HostList) == NLBERR_OK)
        {
            for (int i = 0 ; i < HostList.size(); i++) 
            {
                SaveHostListFile.WriteString((LPCTSTR)(HostList.at(i) + _bstr_t(_T("\n"))));
            }
        }

        // Close file
        SaveHostListFile.Close();

        return;

    }

    TRACE_INFO(L"<- %!FUNC!");
}


void
LeftView::OnWorldConnect(void)
/*
    Connect to existing.
*/
{
    if (theApplication.IsProcessMsgQueueExecuting())
    {
        goto end_end;
    }

    {
        _bstr_t tabbedDlgCaption = GETRESOURCEIDSTRING(IDS_CONNECT_EXISTING_CAPTION);
        CNLBMgrPropertySheet tabbedDlg( tabbedDlgCaption );
        NLB_EXTENDED_CLUSTER_CONFIGURATION NlbCfg;
        ENGINEHANDLE ehInterface = NULL;
    
    
        int rc = IDCANCEL;
        ConnectDialog ConnectDlg(
                &tabbedDlg,
                GetDocument(),
                &NlbCfg,
                &ehInterface,
                ConnectDialog::DLGTYPE_EXISTING_CLUSTER,
                this
                );
    
        tabbedDlg.m_psh.dwFlags = tabbedDlg.m_psh.dwFlags | PSH_NOAPPLYNOW; 
    
        tabbedDlg.AddPage(&ConnectDlg);
    
        //
        // Specify that we want the property page to show up as a wizard.
        //
        tabbedDlg.SetWizardMode();
    
        //
        // Actually execute the modal dialog.
        //
        rc = tabbedDlg.DoModal();
    
        // if( rc != IDOK)
        if( rc != ID_WIZFINISH  )
        {
            goto end;
        }
    
        do // while false
        {
            ENGINEHANDLE ehIId = ehInterface; // Interface id
            ENGINEHANDLE ehCId; // Cluster id
    
            if (ehIId == NULL) break;
    
            //
            // Create a cluster in the engine and get the ID of the cluster.
            // We specify NlbCfg as the default cluster parameters 
            // of the cluster.
            //
            NLBERROR nerr;
    
            CInterfaceSpec ISpec;
            nerr =  gEngine.GetInterfaceSpec(ehIId, REF ISpec);
    
            if (nerr != NLBERR_OK)
            {
                break;
            }
    
            PNLB_EXTENDED_CLUSTER_CONFIGURATION pNlbCfg = &ISpec.m_NlbCfg;
            BOOL fIsNew = FALSE;
            LPCWSTR szIP =  pNlbCfg->NlbParams.cl_ip_addr;
    
                nerr = gEngine.LookupClusterByIP(
                            szIP,
                            pNlbCfg,
                            ehCId,
                            fIsNew
                            );
    
            if (nerr != NLBERR_OK)
            {
                break;
            }
    
            //
            // Now lets add the interface to NLBManager's view of the cluster.
            //
            nerr = gEngine.AddInterfaceToCluster(
                        ehCId,
                        ehIId
                        );
            if (nerr != NLBERR_OK)
            {
                break;
            }

            // Analyze this interface and log results
            gEngine.AnalyzeInterface_And_LogResult(ehIId);

#if BUGFIX476216
            //
            // If it's a valid cluster IP address, let's try to 
            // add the other hosts to the cluster as well.
            //
            gEngine.AddOtherClusterMembers(
                ehIId,
                FALSE   // FALSE == do it in the background.
                );
#endif //  BUGFIX476216
    
    
        } while (FALSE);
    }

end:

    //
    // We have have connected to hosts we are not actually managing...
    //
    gEngine.PurgeUnmanagedHosts();

end_end:

    return;
}


void
LeftView::OnWorldNewCluster(void)
{
    if (theApplication.IsProcessMsgQueueExecuting())
    {
        goto end;
    }

    {
        _bstr_t tabbedDlgCaption = GETRESOURCEIDSTRING(IDS_CONNECT_NEW_CAPTION);
        CNLBMgrPropertySheet tabbedDlg( tabbedDlgCaption );
        ENGINEHANDLE ehInterface = NULL;
        tabbedDlg.m_psh.dwFlags = tabbedDlg.m_psh.dwFlags | PSH_NOAPPLYNOW; 
    
        NLB_EXTENDED_CLUSTER_CONFIGURATION NlbCfg;
    
        NlbCfg.SetDefaultNlbCluster();
    
        //
        // Create the cluster, host and ports pages
        //
        ClusterPage clusterPage(&tabbedDlg, LeftView::OP_NEWCLUSTER, &NlbCfg, NULL);
        HostPage    hostPage(&tabbedDlg, &NlbCfg, NULL, &ehInterface);
        PortsPage   portsPage(&tabbedDlg, &NlbCfg, true, NULL);
        VipsPage   vipsPage(&tabbedDlg, &NlbCfg, TRUE, NULL);
    
        //
        // Create the connect-and-select-NIC page...
        //
        ConnectDialog ConnectDlg(
            &tabbedDlg,
            GetDocument(),
            &NlbCfg,
            &ehInterface,
            ConnectDialog::DLGTYPE_NEW_CLUSTER,
            this
            );
    
    
        tabbedDlg.AddPage(&clusterPage);
        tabbedDlg.AddPage(&vipsPage);
        tabbedDlg.AddPage(&portsPage);
        tabbedDlg.AddPage(&ConnectDlg);
        tabbedDlg.AddPage(&hostPage);
    
        //
        // Specify that we want the property page to show up as a wizard.
        //
        tabbedDlg.SetWizardMode();
    
        //
        // Actually execute the modal wizard.
        //
        int rc = tabbedDlg.DoModal();
        if( rc == ID_WIZFINISH  )
        {
    
            do // while false
            {
                ENGINEHANDLE ehIId = ehInterface; // Interface id
                ENGINEHANDLE ehCId; // Cluster id
    
                if(ehIId == NULL) break;
    
                //
                // Create a cluster in the engine and get the ID of the cluster.
                // We specify NlbCfg as the default cluster parameters 
                // of the cluster.
                //
                NLBERROR nerr;
    
                BOOL fIsNew = FALSE;
                LPCWSTR szIP =  NlbCfg.NlbParams.cl_ip_addr;
                nerr = gEngine.LookupClusterByIP(
                            szIP,
                            &NlbCfg,
                            ehCId,
                            fIsNew
                            );
    
                if (nerr != NLBERR_OK)
                {
                    break;
                }
    
                //
                // Now lets add the interface to the cluster.
                // Note that at this point the interface is not yet bound to NLB
                // so is out of whack. We will then ask the Engine to
                // bind NLB, specifying the same config data (NlbCfg)
                // that we used to create the cluster above, so the
                // cluster and host will be in sync on successful update.
                //
                nerr = gEngine.AddInterfaceToCluster(
                            ehCId,
                            ehIId
                            );
                if (nerr != NLBERR_OK)
                {
                    break;
                }
    
                //
                // Now update the interface!
                // This operation will actually configure NLB on the interface.
                // The engine will notify us when done and what the status
                // is.
                // In theory the engine can return pending here right away,
                // in which case we'll exit the configure-new-cluster wizard,
                // leaving the cursor set to arrow-hourglass.
                //
                {
                    CWaitCursor wait;
    
                    // BOOL fClusterPropertiesUpdated = FALSE;
                    CLocalLogger logConflict;
                    nerr = gEngine.UpdateInterface(
                                ehIId,
                                REF NlbCfg,
                                // REF fClusterPropertiesUpdated,
                                REF logConflict
                                );
                    if (nerr == NLBERR_BUSY)
                    {
                        //
                        // This means that there is some other operation ongoing.
                        //
                        MessageBox(
                             GETRESOURCEIDSTRING(IDS_CANT_CREATE_NEW_CLUSTER_MSG),
                             GETRESOURCEIDSTRING(IDS_CANT_CREATE_NEW_CLUSTER_CAP),
                             MB_OK
                             );
                    }
                }
        
            } while (FALSE);
    
        }
    }

    //
    // We have have connected to hosts we are not actually managing...
    //
    gEngine.PurgeUnmanagedHosts();

end:

    return;
}
    

void
LeftView::OnClusterProperties(void)
{
    // find tree view cluster member which has been selected.
    //
    CClusterSpec cSpec;
    ENGINEHANDLE ehClusterId = NULL;
    NLBERROR nerr;
    WBEMSTATUS wStat;
    NLB_EXTENDED_CLUSTER_CONFIGURATION CurrentClusterCfg;

    if (theApplication.IsProcessMsgQueueExecuting())
    {
        goto end;
    }

    nerr =  mfn_GetSelectedCluster(REF ehClusterId);

    if (nerr != NLBERR_OK)
    {
        goto end;
    }

    //
    // Let's pick up the 
    // CClusterSpec
    //
    {
        nerr = gEngine.GetClusterSpec(
                    ehClusterId,
                    REF cSpec
                    );

        if (nerr != NLBERR_OK)
        {
            TRACE_CRIT("%!FUNC! could not get ClusterSpec");
            goto end;
        }
        
    }

    wStat = CurrentClusterCfg.Update(&cSpec.m_ClusterNlbCfg);
    if (FAILED(wStat))
    {
        TRACE_CRIT("%!FUNC! could not copy cluster properties!");
        goto end;
    }

    while (1)
    {
        CLocalLogger logErrors;
        CLocalLogger logDifferences;


        _bstr_t tabbedDlgCaption = GETRESOURCEIDSTRING( IDS_PROPERTIES_CAPTION );
        CNLBMgrPropertySheet tabbedDlg( tabbedDlgCaption );
        tabbedDlg.m_psh.dwFlags = tabbedDlg.m_psh.dwFlags | PSH_NOAPPLYNOW; 
        ClusterPage clusterPage(&tabbedDlg, LeftView::OP_CLUSTERPROPERTIES, &cSpec.m_ClusterNlbCfg, ehClusterId);
        VipsPage   vipsPage(&tabbedDlg, &cSpec.m_ClusterNlbCfg, TRUE, NULL);

        PortsPage   portsPage(&tabbedDlg, &cSpec.m_ClusterNlbCfg, true, ehClusterId);
    
        tabbedDlg.AddPage( &clusterPage );
        tabbedDlg.AddPage(&vipsPage);
    
        tabbedDlg.AddPage( &portsPage );
    
        //
        // Set the property sheet caption
        // TODO: localize
        //
        {
            _bstr_t bstrTitle =  GETRESOURCEIDSTRING(IDS_CLUSTER);
            tabbedDlg.SetTitle((LPCWSTR) bstrTitle, PSH_PROPTITLE);
        }

        int rc = tabbedDlg.DoModal();
        if( rc != IDOK )
        {
            goto end;
        }

        //
        //
        //
        BOOL fConnectivityChange = FALSE;
        nerr = AnalyzeNlbConfigurationPair(
                    cSpec.m_ClusterNlbCfg,
                    CurrentClusterCfg,
                    TRUE,  // fOtherIsCluster
                    FALSE, // fCheckOtherForConsistancy
                    REF fConnectivityChange,
                    REF logErrors,
                    REF logDifferences
                    );

        if (nerr == NLBERR_OK)
        {
            LPCWSTR szDifferences = logDifferences.GetStringSafe();
            if (*szDifferences!=0)
            {
                CLocalLogger logMsg;
                int sel;
                LPCWSTR szMessage;

                logMsg.Log(IDS_CLUSTER_PROPS_CHANGE_MSG_HDR);
                logMsg.LogString(szDifferences);
                logMsg.Log(IDS_CLUSTER_PROPS_CHANGE_MSG_SUFFIX);
                szMessage = logMsg.GetStringSafe();

                sel = MessageBox(
                          szMessage,
                          GETRESOURCEIDSTRING(IDS_CONFIRM_CLUSTER_PROPS_CHANGE),
                          MB_YESNO | MB_ICONEXCLAMATION | MB_DEFBUTTON2
                          );
            
                if ( sel == IDNO )
                {
                    continue; // we'll bring back the properties...
                }
            }
        }

        {
            CWaitCursor wait;
            CLocalLogger logConflicts;
            nerr = gEngine.UpdateCluster(
                        ehClusterId,
                        &cSpec.m_ClusterNlbCfg,
                        REF logConflicts
                        );
            if (nerr == NLBERR_BUSY)
            {
                //
                // This means that there is some other operation ongoing.
                //
                MessageBox(
                     GETRESOURCEIDSTRING(IDS_CANT_UPDATE_CLUSTER_PROPS_MSG),
                     GETRESOURCEIDSTRING(IDS_CANT_UPDATE_CLUSTER_PROPS_CAP),
                     MB_OK
                     );
            }
            break;
        }
    }

end:

    return;
}


void
LeftView::OnHostProperties(void)
{

    NLBERROR nerr;
    ENGINEHANDLE ehInterfaceId = NULL;
    ENGINEHANDLE ehCluster = NULL;
    CInterfaceSpec iSpec;

    if (theApplication.IsProcessMsgQueueExecuting())
    {
        goto end;
    }

    nerr =  mfn_GetSelectedInterface(REF ehInterfaceId, REF ehCluster);

    if (nerr != NLBERR_OK)
    {
        goto end;
    }

    //
    // Let's pick up the Interface ID, and
    // retrieve the CInterfaceSpec for it.
    //
    {
        nerr = gEngine.GetInterfaceSpec(
                    ehInterfaceId,
                    REF iSpec
                    );

        if (nerr != NLBERR_OK)
        {
            TRACE_CRIT("%!FUNC! could not get InterfaceSpec");
            goto end;
        }
        
    }


    {
        _bstr_t tabbedDlgCaption = GETRESOURCEIDSTRING( IDS_PROPERTIES_CAPTION );
        CNLBMgrPropertySheet tabbedDlg( tabbedDlgCaption );
        tabbedDlg.m_psh.dwFlags = tabbedDlg.m_psh.dwFlags | PSH_NOAPPLYNOW; 
        ClusterPage clusterPage(&tabbedDlg, LeftView::OP_HOSTPROPERTIES, &iSpec.m_NlbCfg, ehCluster);
        PortsPage   portsPage(&tabbedDlg, &iSpec.m_NlbCfg, FALSE, ehCluster);
        HostPage    hostPage(&tabbedDlg, &iSpec.m_NlbCfg, ehCluster, &ehInterfaceId);
        VipsPage    vipsPage(&tabbedDlg, &iSpec.m_NlbCfg, FALSE, NULL);

    
        //
        // Display the host page first
        //
        tabbedDlg.m_psh.nStartPage = 2; 

        tabbedDlg.AddPage( &clusterPage );
        tabbedDlg.AddPage(&vipsPage);
    
        tabbedDlg.AddPage( &hostPage );
        tabbedDlg.AddPage( &portsPage );
    
        //
        // Set the property sheet title
        // TODO: localize
        //
        {
            _bstr_t bstrTitle =  GETRESOURCEIDSTRING(IDS_HOST);
            tabbedDlg.SetTitle(bstrTitle, PSH_PROPTITLE);
        }

        int rc = tabbedDlg.DoModal();
        if( rc != IDOK )
        {
            goto end;
        }

        //
        // Now update the interface!
        // This operation will actually update the NLB properties on the
        // interface. The engine will notify us when done and what the status
        // is.
        // In theory the engine can return pending here right away,
        // in which case we'll exit the configure-new-cluster wizard,
        // leaving the cursor set to arrow-hourglass.
        //
        {
            CWaitCursor wait;
            //
            // We update the interface, but ask the provider to preserve
            // the IP addresses, deleteing the old  dedicated IP address
            // if required and adding the new one if required.
            //
            iSpec.m_NlbCfg.fAddDedicatedIp = TRUE;
            iSpec.m_NlbCfg.SetNetworkAddresses(NULL, 0);

            // BOOL fClusterPropertiesUpdated = FALSE;
            CLocalLogger logConflict;
            nerr = gEngine.UpdateInterface(
                        ehInterfaceId,
                        REF iSpec.m_NlbCfg,
                        // REF fClusterPropertiesUpdated,
                        REF logConflict
                        );
            if (nerr == NLBERR_BUSY)
            {
                //
                // This means that there is some other operation ongoing.
                //
                MessageBox(
                     GETRESOURCEIDSTRING(IDS_CANT_UPDATE_HOST_PROPS_MSG),
                     GETRESOURCEIDSTRING(IDS_CANT_UPDATE_HOST_PROPS_CAP),
                     MB_OK
                     );
            }
        }
    }

end:

    return;
}


void
LeftView::OnHostStatus(void)
{
    NLBERROR nerr;
    ENGINEHANDLE ehInterfaceId = NULL;
    ENGINEHANDLE ehCluster = NULL;
    CInterfaceSpec iSpec;
    _bstr_t bstrDisplayName;
    _bstr_t bstrFriendlyName;
    _bstr_t bstrClusterDisplayName;
    _bstr_t bstrStatus;
    _bstr_t bstrDetails;
    CHostSpec hSpec;
    int       iIcon=0;

    _bstr_t bstrTime;
    _bstr_t bstrDate;

    LPCWSTR szCaption = NULL;
    LPCWSTR szDate = NULL;
    LPCWSTR szTime = NULL;
    LPCWSTR szCluster = NULL;
    LPCWSTR szHost = NULL;
    LPCWSTR szInterface = NULL;
    LPCWSTR szSummary = NULL;
    LPCWSTR szDetails = NULL;
    CLocalLogger logCaption;
    CLocalLogger logSummary;

    nerr =  mfn_GetSelectedInterface(REF ehInterfaceId, REF ehCluster);

    if (NLBFAILED(nerr))
    {
        goto end;
    }

    nerr = gEngine.GetInterfaceInformation(
            ehInterfaceId,
            REF hSpec,
            REF iSpec,
            REF bstrDisplayName,
            REF iIcon,
            REF bstrStatus
            );
    if (NLBFAILED(nerr))
    {
        goto end;
    }

    //
    // Fill caption
    //
    {
        // bstrDisplayName += L" Status"; // TODO: localize
        logCaption.Log(IDS_HOST_STATUS_CAPTION, (LPCWSTR) bstrDisplayName);
        szCaption = logCaption.GetStringSafe();
    }

    //
    // Fill date and time
    //
    {
        GetTimeAndDate(REF bstrTime, REF bstrDate);
        szTime = bstrTime;
        szDate = bstrDate;
        if (szTime == NULL) szTime = L"";
        if (szDate == NULL) szDate = L"";
    }

    //
    // Fill cluster
    //
    {
        ehCluster = iSpec.m_ehCluster;
        if (ehCluster != NULL)
        {
            _bstr_t bstrIpAddress;
            _bstr_t bstrDomainName;

            nerr  = gEngine.GetClusterIdentification(
                        ehCluster,
                        REF bstrIpAddress, 
                        REF bstrDomainName, 
                        REF bstrClusterDisplayName
                        );
            if (NLBOK(nerr))
            {
                szCluster = bstrClusterDisplayName;
            }
        }
    }

    //
    // Fill Host
    //
    {
        szHost = hSpec.m_MachineName;
    }

    //
    // Fill Interface
    //
    {
        ENGINEHANDLE   ehHost1;
        ENGINEHANDLE   ehCluster1;
        _bstr_t         bstrDisplayName1;
        _bstr_t         bstrHostName1;

        nerr = gEngine.GetInterfaceIdentification(
                ehInterfaceId,
                ehHost1,
                ehCluster1,
                bstrFriendlyName,
                bstrDisplayName1,
                bstrHostName1
                );
        szInterface = bstrFriendlyName;
    }

    //
    // Fill summary and details
    //
    logSummary.Log(IDS_HOST_STATUS_SUMMARY, (LPCWSTR) bstrStatus);
    szSummary = logSummary.GetStringSafe();

    //if (iSpec.m_fMisconfigured)
    // {
    szDetails = iSpec.m_bstrStatusDetails;
    //}

    //
    // Display the status...
    //
    {
        DetailsDialog Details(
                        GetDocument(),
                        szCaption,      // Caption
                        szDate,
                        szTime,
                        szCluster,
                        szHost,
                        szInterface,
                        szSummary,
                        szDetails,
                        this        // parent
                        );
    
        (void) Details.DoModal();
    }

end:
    return;
}

void
LeftView::OnClusterRemove(void)
{
    // find tree view cluster member which has been selected.
    //
    CClusterSpec cSpec;
    ENGINEHANDLE ehClusterId = NULL;
    NLBERROR nerr;
    int userSelection;

    if (theApplication.IsProcessMsgQueueExecuting())
    {
        goto end;
    }

    // verify once again that user really wants to remove.

    userSelection = MessageBox(
                     GETRESOURCEIDSTRING (IDS_WARNING_CLUSTER_REMOVE ),
                     GETRESOURCEIDSTRING (IDR_MAINFRAME ),
                     MB_YESNO | MB_ICONEXCLAMATION |  MB_DEFBUTTON2);

    if( userSelection == IDNO )
    {
        goto end;
    }

    nerr =  mfn_GetSelectedCluster(REF ehClusterId);

    if (nerr != NLBERR_OK)
    {
        goto end;
    }

    //
    // Let's pick up the 
    // CClusterSpec
    //
    {
        nerr = gEngine.GetClusterSpec(
                    ehClusterId,
                    REF cSpec
                    );

        if (nerr != NLBERR_OK)
        {
            TRACE_CRIT("%!FUNC! could not get ClusterSpec");
            goto end;
        }
        
    }

    //
    // Set the cluste to "unbound" and update it! The rest should take care
    // of itself!
    //
    {
        CWaitCursor wait;
        CLocalLogger logConflicts;
        cSpec.m_ClusterNlbCfg.SetNlbBound(FALSE);
        nerr = gEngine.UpdateCluster(
                    ehClusterId,
                    &cSpec.m_ClusterNlbCfg,
                    REF logConflicts
                    );
        if (nerr == NLBERR_BUSY)
        {
            //
            // This means that there is some other operation ongoing.
            //
            MessageBox(
                 GETRESOURCEIDSTRING(IDS_CANT_DELETE_CLUSTER_MSG),
                 GETRESOURCEIDSTRING(IDS_CANT_DELETE_CLUSTER_CAP),
                 MB_OK
                 );
        }
    }

end:

    return;
}



void
LeftView::OnClusterUnmanage(void)
{
    CClusterSpec cSpec;
    ENGINEHANDLE ehClusterId = NULL;
    NLBERROR nerr;

    if (theApplication.IsProcessMsgQueueExecuting())
    {
        goto end;
    }

    // find tree view cluster member which has been selected.
    //
    
    nerr =  mfn_GetSelectedCluster(REF ehClusterId);

    if (nerr != NLBERR_OK)
    {
        goto end;
    }

    //
    // Set the cluste to "unbound" and update it! The rest should take care
    // of itself!
    //
    {
        gEngine.DeleteCluster(ehClusterId, TRUE); // TRUE == unlink all interfaces.
    }

end:

    return;
}
 

void
LeftView::OnClusterAddHost(void)
/*
    This method is called to add a new (from NLB Manager's perspective)
    host to the selected cluster. Now this host may already be part
    of the cluster -- in the sence it's configured to be part of the cluster.
    If so, we try to preserve the host-specific properties.
*/
{

    // find tree view cluster member which has been selected.
    //
    NLB_EXTENDED_CLUSTER_CONFIGURATION NlbCfg;
    ENGINEHANDLE ehClusterId = NULL;
    ENGINEHANDLE ehInterface = NULL;
    NLBERROR nerr;
    BOOL fPurge = FALSE;

    if (theApplication.IsProcessMsgQueueExecuting())
    {
        goto end;
    }


    nerr =  mfn_GetSelectedCluster(REF ehClusterId);

    if (nerr != NLBERR_OK)
    {
        goto end;
    }

	
    //
    // Let's ask the engine to initialize a NlbCfg structure for 
    // a new host to cluster ehClusterId -- it will set up host-specific
    // parameters (like host priority) with good defaults, taking into
    // accound other members of the cluster.
    //
    {
        nerr = gEngine.InitializeNewHostConfig(
                    ehClusterId,
                    REF NlbCfg
                    );

        if (nerr != NLBERR_OK)
        {
            TRACE_CRIT("%!FUNC! could not get ClusterSpec");
            goto end;
        }
        
    }

    fPurge = TRUE;

    do  // while false
    {
        _bstr_t tabbedDlgCaption = GETRESOURCEIDSTRING(IDS_CONNECT_ADD_HOST_CAPTION);
        CNLBMgrPropertySheet tabbedDlg( tabbedDlgCaption );
        tabbedDlg.m_psh.dwFlags = tabbedDlg.m_psh.dwFlags | PSH_NOAPPLYNOW; 
    
    
        //
        // Create the host and ports pages
        //
        HostPage    hostPage(&tabbedDlg, &NlbCfg, ehClusterId, &ehInterface);
        PortsPage   portsPage(&tabbedDlg, &NlbCfg, false, ehClusterId);
    
        //
        // Create the connect-and-select-NIC page...
        //
        ConnectDialog ConnectDlg(
            &tabbedDlg,
            GetDocument(),
            &NlbCfg,
            &ehInterface,
            ConnectDialog::DLGTYPE_ADD_HOST,
            this
            );
    
    
        tabbedDlg.AddPage(&ConnectDlg);
        // NO need for cluster page. tabbedDlg.AddPage(&clusterPage);
        tabbedDlg.AddPage(&hostPage);
        tabbedDlg.AddPage(&portsPage);
    
        //
        // Specify that we want the property page to show up as a wizard.
        //
        tabbedDlg.SetWizardMode();
    
        //
        // Actually execute the modal wizard.
        //
        int rc = tabbedDlg.DoModal();
        if( rc != ID_WIZFINISH  )
        {
            goto end;
        }
        else
        {
            ENGINEHANDLE ehIId = ehInterface; // Interface id

            if(ehIId == NULL) break;

            //
            // Now lets add the interface to the cluster.
            // Note that at this point the interface is not yet bound to NLB
            // so is out of whack. We will then ask the Engine to
            // bind NLB, specifying the same config data (NlbCfg)
            // that we used to create the cluster above, so the
            // cluster and host will be in sync on successful update.
            //
            nerr = gEngine.AddInterfaceToCluster(
                        ehClusterId,
                        ehIId
                        );
            if (nerr != NLBERR_OK)
            {
                break;
            }

            //
            // Now update the interface!
            // This operation will actually configure NLB on the interface.
            // The engine will notify us when done and what the status
            // is.
            // In theory the engine can return pending here right away,
            // in which case we'll exit the configure-new-cluster wizard,
            // leaving the cursor set to arrow-hourglass.
            //
            {
                CWaitCursor wait;
                //
                // TODO -- we need to preserve Ip addresses and their order in
                // hosts, as far as possible. For now we decide the order.
                //
                NlbCfg.fAddDedicatedIp = TRUE;

                //
                // We need to EXPLICITLY ask for the remote control password
                // hash to be set -- otherwise it is ignored. 
                // This (adding a node) is the ONLY place where the 
                // hash remote control password is set.
                //
                {
                    DWORD dwHash =  CfgUtilGetHashedRemoteControlPassword(
                                        &NlbCfg.NlbParams
                                        );
                    NlbCfg.SetNewHashedRemoteControlPassword(
                                        dwHash
                                        );
                }

                // BOOL fClusterPropertiesUpdated = TRUE; // so we don't update
                CLocalLogger logConflict;
                nerr = gEngine.UpdateInterface(
                            ehIId,
                            REF NlbCfg,
                            // fClusterPropertiesUpdated,
                            REF logConflict
                            );
                if (nerr == NLBERR_BUSY)
                {
                    //
                    // This means that there is some other operation ongoing.
                    //
                    MessageBox(
                         GETRESOURCEIDSTRING(IDS_CANT_ADD_HOST_MSG),
                         GETRESOURCEIDSTRING(IDS_CANT_ADD_HOST_CAP),
                         MB_OK
                         );
                }
            }
        }
    } while (FALSE);

end:

    if (fPurge)
    {
        //
        // We have have connected to hosts we are not actually managing...
        //
        gEngine.PurgeUnmanagedHosts();
    }

    return;

}


void
LeftView::OnOptionsCredentials(void)
{
    TRACE_INFO("-> %!FUNC!");
    
    WCHAR rgUserName[CREDUI_MAX_USERNAME_LENGTH+1];
    WCHAR rgPassword[2*sizeof(WCHAR)*(CREDUI_MAX_PASSWORD_LENGTH+1)];
    BOOL fRet;
    _bstr_t     bstrUserName;
    _bstr_t     bstrPassword;

    rgUserName[0] = 0;
    rgPassword[0] = 0;

    GetDocument()->getDefaultCredentials(bstrUserName, bstrPassword);

    LPCWSTR szName = (LPCWSTR) bstrUserName;
    LPCWSTR szPassword = (LPCWSTR) bstrPassword;

    if (szName == NULL)
    {
        szName = L"";
    }
    if (szPassword == NULL)
    {
        szPassword = L"";
    }
    ARRAYSTRCPY(rgUserName, szName);
    ARRAYSTRCPY(rgPassword, szPassword);

    //
    // NOTE: PromptForEncryptedCred (utils.h) in/out rgPassword is
    // encrypted, so we don't need to bother with zeroing out buffers
    // and so forth.
    //
    fRet = PromptForEncryptedCreds(
                m_hWnd, // TODO -- make this the mainfrm window.
                GETRESOURCEIDSTRING(IDS_DEFAULT_CREDS_CAP),
                GETRESOURCEIDSTRING(IDS_DEFAULT_CREDS_MSG),
                rgUserName,
                ASIZE(rgUserName),
                rgPassword,
                ASIZE(rgPassword)
                );
    if (fRet)
    {
        if (*rgUserName == 0)
        {
            //
            // Use logged-on user's credentials
            //
            GetDocument()->setDefaultCredentials(NULL, NULL);
        }
        else
        {
            //
            // TODO: prepend %computername% if required.
            //
            // SECURITY BUGBUG:  see  ConnectDialog::OnButtonConnect() 
            //      for how to encrypt password and zero-out rgPassword.
            //
            GetDocument()->setDefaultCredentials(rgUserName, rgPassword);
        }
    }
    else
    {
        TRACE_CRIT(L"Not setting credentials because PromptForEncryptedCreds failed");
    }
}


void
LeftView::OnOptionsLogSettings(void)
{
    int rc;
    LogSettingsDialog Settings(GetDocument(), this);

    rc = Settings.DoModal();
}

void
LeftView::OnHostRemove(void)
{
    // verify once again that user really wants to remove.
    NLBERROR nerr;
    ENGINEHANDLE ehInterfaceId = NULL;
    ENGINEHANDLE ehCluster = NULL;
    ENGINEHANDLE ehHost = NULL;
    CInterfaceSpec iSpec;
    BOOL fUnmanageDeadHost = FALSE;

    if (theApplication.IsProcessMsgQueueExecuting())
    {
        goto end;
    }

    nerr =  mfn_GetSelectedInterface(REF ehInterfaceId, REF ehCluster);

    if (nerr != NLBERR_OK)
    {
        goto end;
    }

    //
    // Get interface and host information. If host is marked
    // UNREACHABLE, ask user if he simply wants to unmanage the host.
    // Else ask the user to confirm that he wants to delete the cluster.
    //
    {
        CHostSpec hSpec;
        int userSelection;
        _bstr_t bstrStatus;
        _bstr_t bstrDisplayName;
        CLocalLogger logMsg;
        int iIcon;

        nerr = gEngine.GetInterfaceInformation(
                ehInterfaceId,
                REF hSpec,
                REF iSpec,
                REF bstrDisplayName,
                REF iIcon,
                REF bstrStatus
                );
        if (NLBFAILED(nerr))
        {
            TRACE_CRIT(L"Could not get info on interface eh%x", ehInterfaceId);
            goto end;
        }

        ehHost = iSpec.m_ehHostId;

        if (hSpec.m_fUnreachable)
        {
            LPCWSTR szHost = L"";
            szHost = hSpec.m_MachineName;
            if (szHost == NULL)
            {
                szHost = L"";
            }
            fUnmanageDeadHost = TRUE;
            logMsg.Log(IDS_REMOVE_DEAD_HOST, szHost);
        }
        else
        {
            LPCWSTR szInterface;
            szInterface =  bstrDisplayName;
            if (szInterface == NULL)
            {
                szInterface = L"";
            }

            logMsg.Log(IDS_WARNING_HOST_REMOVE, szInterface);
        }

        //
        // verify that user really wants to remove.
        //
        userSelection = MessageBox(
                             logMsg.GetStringSafe(),
                             GETRESOURCEIDSTRING (IDR_MAINFRAME ),
                             MB_YESNO | MB_ICONEXCLAMATION | MB_DEFBUTTON2);

        if( userSelection == IDNO )
        {
            goto end;
        }

        if (fUnmanageDeadHost)
        {
            gEngine.UnmanageHost(ehHost);
            goto end;
        }
    }



    //
    // retrieve the CInterfaceSpec for ehInterfaceId
    //
    nerr = gEngine.GetInterfaceSpec(
                ehInterfaceId,
                REF iSpec
                );

    if (nerr != NLBERR_OK)
    {
        TRACE_CRIT("%!FUNC! could not get InterfaceSpec");
        goto end;
    }

    //
    // Now update the interface!
    // This operation will actually update the NLB properties on the
    // interface. The engine will notify us when done and what the status
    // is.
    // In theory the engine can return pending here right away,
    // in which case we'll exit the configure-new-cluster wizard,
    // leaving the cursor set to arrow-hourglass.
    //
    {
        CWaitCursor wait;

        iSpec.m_NlbCfg.fAddDedicatedIp = FALSE;
        iSpec.m_NlbCfg.SetNetworkAddresses(NULL, 0);
        iSpec.m_NlbCfg.SetNlbBound(FALSE);

        if (!iSpec.m_NlbCfg.IsBlankDedicatedIp())
        {
            WCHAR rgBuf[64];
            LPCWSTR szAddr = rgBuf;
            StringCbPrintf(
                rgBuf,
                sizeof(rgBuf),
                L"%ws/%ws",
                iSpec.m_NlbCfg.NlbParams.ded_ip_addr,
                iSpec.m_NlbCfg.NlbParams.ded_net_mask
                );
            iSpec.m_NlbCfg.SetNetworkAddresses(&szAddr, 1);
        }

        // BOOL fClusterPropertiesUpdated = TRUE; // so we don't update
        CLocalLogger logConflict;
        nerr = gEngine.UpdateInterface(
                    ehInterfaceId,
                    REF iSpec.m_NlbCfg,
                    // fClusterPropertiesUpdated,
                    logConflict
                    );
        if (nerr == NLBERR_BUSY)
        {
            //
            // This means that there is some other operation ongoing.
            //
            MessageBox(
                 GETRESOURCEIDSTRING(IDS_CANT_DELETE_HOST_MSG),
                 GETRESOURCEIDSTRING(IDS_CANT_DELETE_HOST_CAP),
                 MB_OK
                 );
        }
    }
    
end:

    return;
}


void
LeftView::OnClusterControl( UINT nID )
{
    // find tree view cluster member which has been selected.
    ENGINEHANDLE ehClusterId = NULL;
    NLBERROR nerr;

    if (theApplication.IsProcessMsgQueueExecuting())
    {
        goto end;
    }

    nerr =  mfn_GetSelectedCluster(REF ehClusterId);

    if (nerr == NLBERR_OK)
    {
        // Call control cluster function
        WLBS_OPERATION_CODES opCode;
        BOOL fOk = TRUE;
        opCode = mfn_MapResourceIdToOpcode(true, nID);
        switch(opCode)
        {
        case WLBS_STOP:
        case WLBS_DRAIN:
        case WLBS_SUSPEND:
            {
                int sel = MessageBox(
                          GETRESOURCEIDSTRING(IDS_CONFIRM_CLUSTER_CONTROL_MSG),
                          GETRESOURCEIDSTRING(IDS_CONFIRM_CLUSTER_CONTROL_CAP),
                          MB_OKCANCEL | MB_ICONEXCLAMATION
                          );
            
                if ( sel == IDCANCEL )
                {
                    fOk = FALSE;
                }
            }
            break;
        default:
            break;
        }
        if (fOk)
        {
            nerr = gEngine.ControlClusterOnCluster(ehClusterId, opCode, NULL, NULL, 0);
        }
    }

end:
    return;
}

void
LeftView::OnClusterPortControl( UINT nID )
{
    ENGINEHANDLE ehClusterId = NULL;
    CClusterSpec cSpec;
    NLBERROR     nerr;

    TRACE_INFO(L"-> %!FUNC!");

    if (theApplication.IsProcessMsgQueueExecuting())
    {
        goto end;
    }

    nerr =  mfn_GetSelectedCluster(REF ehClusterId);

    if (nerr == NLBERR_OK)
    {
        //
        // Let's pick up the Cluster ID, and
        // retrieve the CClusterSpec for it.
        //
        nerr = gEngine.GetClusterSpec(ehClusterId, REF cSpec);
        if (nerr == NLBERR_OK)
        {
            CPortsCtrl PortCtrl(ehClusterId, &cSpec.m_ClusterNlbCfg, true);

            // The port control operations are performed by the PortCtrl message handler functions
            PortCtrl.DoModal();
        }
        else
        {
            TRACE_CRIT("%!FUNC! could not get ClusterSpec");
        }
    }
    else
    {
        TRACE_CRIT("%!FUNC! could not get Cluster");
    }

end:

    /*
    LRESULT result;
    OnSelchanged( NULL, &result );
    */

    TRACE_INFO(L"<- %!FUNC!");
    return;
}

WLBS_OPERATION_CODES
LeftView::mfn_MapResourceIdToOpcode(bool bClusterWide, DWORD dwResourceId)
{
    struct RESOURCE_ID_OPCODE_MAP
    {
        WLBS_OPERATION_CODES  Opcode;
        DWORD                 dwClusterResourceId;
        DWORD                 dwHostResourceId;
    }
    ResourceIdToOpcodeMap[] =
    {
        {WLBS_QUERY,              ID_CLUSTER_EXE_QUERY,       ID_HOST_EXE_QUERY},
        {WLBS_START,              ID_CLUSTER_EXE_START,       ID_HOST_EXE_START},
        {WLBS_STOP,               ID_CLUSTER_EXE_STOP,        ID_HOST_EXE_STOP},
        {WLBS_DRAIN,              ID_CLUSTER_EXE_DRAINSTOP,   ID_HOST_EXE_DRAINSTOP},
        {WLBS_SUSPEND,            ID_CLUSTER_EXE_SUSPEND,     ID_HOST_EXE_SUSPEND},
        {WLBS_RESUME,             ID_CLUSTER_EXE_RESUME,      ID_HOST_EXE_RESUME},
        {WLBS_PORT_ENABLE,        ID_CLUSTER_EXE_ENABLE,      ID_HOST_EXE_ENABLE},
        {WLBS_PORT_DISABLE,       ID_CLUSTER_EXE_DISABLE,     ID_HOST_EXE_DISABLE},
        {WLBS_PORT_DRAIN,         ID_CLUSTER_EXE_DRAIN,       ID_HOST_EXE_DRAIN}
    };

    if (bClusterWide) 
    {
        for (DWORD dwIdx = 0; dwIdx < sizeof(ResourceIdToOpcodeMap)/sizeof(ResourceIdToOpcodeMap[0]); dwIdx++)
        {
            if (ResourceIdToOpcodeMap[dwIdx].dwClusterResourceId == dwResourceId)
            {
                return ResourceIdToOpcodeMap[dwIdx].Opcode;
            }
        }
    }
    else
    {
        for (DWORD dwIdx = 0; dwIdx < sizeof(ResourceIdToOpcodeMap)/sizeof(ResourceIdToOpcodeMap[0]); dwIdx++)
        {
            if (ResourceIdToOpcodeMap[dwIdx].dwHostResourceId == dwResourceId)
            {
                return ResourceIdToOpcodeMap[dwIdx].Opcode;
            }
        }
    }

    // Can get here only the operation is not defined in the above map.
    // return the most harmless of operatios, ie. query in that case
    return WLBS_QUERY;
}

void
LeftView::OnHostControl( UINT nID )
{

    NLBERROR nerr;
    ENGINEHANDLE ehInterfaceId = NULL;
    ENGINEHANDLE ehCluster = NULL;

    if (theApplication.IsProcessMsgQueueExecuting())
    {
        goto end;
    }

    // Get the interface id
    nerr =  mfn_GetSelectedInterface(REF ehInterfaceId, REF ehCluster);

    if (nerr == NLBERR_OK)
    {
        // Call control cluster function
        nerr = gEngine.ControlClusterOnInterface(ehInterfaceId, mfn_MapResourceIdToOpcode(false, nID), NULL, NULL, 0, TRUE);
    }

end:

    return;
}

void
LeftView::OnHostPortControl( UINT nID )
{
    NLBERROR nerr;
    ENGINEHANDLE ehInterfaceId = NULL;
    ENGINEHANDLE ehCluster = NULL;
    CInterfaceSpec iSpec;

    TRACE_INFO(L"-> %!FUNC!");

    if (theApplication.IsProcessMsgQueueExecuting())
    {
        goto end;
    }
    nerr =  mfn_GetSelectedInterface(REF ehInterfaceId, REF ehCluster);
    if (nerr == NLBERR_OK)
    {
        //
        // Let's pick up the Interface ID, and
        // retrieve the CInterfaceSpec for it.
        //
        nerr = gEngine.GetInterfaceSpec(
                    ehInterfaceId,
                    REF iSpec
                    );
        if (nerr == NLBERR_OK)
        {
            CPortsCtrl PortCtrl(ehInterfaceId, &iSpec.m_NlbCfg, false);

            // The port control operations are performed by the PortCtrl message handler functions
            PortCtrl.DoModal();
        }
        else
        {
            TRACE_CRIT("%!FUNC! could not get InterfaceSpec");
        }
    }
    else
    {
        TRACE_CRIT("%!FUNC! could not get Interface");
    }


end:

    /*
    LRESULT result;
    OnSelchanged( NULL, &result );
    */

    TRACE_INFO(L"<- %!FUNC!");
    return;
}

void 
LeftView::OnSelchanged(NMHDR* pNMHDR, LRESULT* pResult) 
{
    BOOL rcBOOL;

    if (m_fPrepareToDeinitialize)
    {
        goto end;
    }

    // get selected item.
    //
    HTREEITEM hdlSelItem;    
    hdlSelItem = GetTreeCtrl().GetSelectedItem();

    TVITEM    selItem;
    selItem.hItem = hdlSelItem;
    selItem.mask = TVIF_PARAM | TVIF_IMAGE;
    GetTreeCtrl().GetItem( &selItem );

    CWnd* pMain = AfxGetMainWnd();
    CMenu* pMenu = pMain->GetMenu();
    CMenu* subMenu;

    UINT retValue;

    BOOL retBool;

    IUICallbacks::ObjectType objType;
    ENGINEHANDLE ehObj =  (ENGINEHANDLE)selItem.lParam;
    BOOL fValidHandle;
    fValidHandle = gEngine.GetObjectType(ehObj, REF objType);
    
    if (!fValidHandle)
    {
        objType = IUICallbacks::OBJ_INVALID;
        ehObj = NULL;
    }

    GetDocument()->HandleLeftViewSelChange(
            objType,
            ehObj
            );

    if (!fValidHandle)
    {

            // We assume that this is root icon.

            // disable all commands at cluster and host level.

            mfn_EnableClusterMenuItems(FALSE);
            mfn_EnableHostMenuItems(FALSE);

            pMain->DrawMenuBar();

        goto end; // root case
    }
    
    switch(objType)
    {


        case IUICallbacks::OBJ_CLUSTER:

            // this is some cluster
            
            // enable all commands at cluster level menu.
            // disable all commands at host level.

            mfn_EnableClusterMenuItems(TRUE);
            mfn_EnableHostMenuItems(FALSE);

            pMain->DrawMenuBar();

            break;

        case IUICallbacks::OBJ_INTERFACE:

            // this is some node.

            // disable all commands at cluster level.
            // enable all commands at host level.

            mfn_EnableClusterMenuItems(FALSE);
            mfn_EnableHostMenuItems(TRUE);

            pMain->DrawMenuBar();
            
            break;

    default: // unknown object -- ignore.
            break;
    } // switch (objType)
	
end:

    *pResult = 0;
}
        

//
// Handle an event relating to a specific instance of a specific
// object type.
//
void
LeftView::HandleEngineEvent(
    IN IUICallbacks::ObjectType objtype,
    IN ENGINEHANDLE ehClusterId, // could be NULL
    IN ENGINEHANDLE ehObjId,
    IN IUICallbacks::EventCode evt
    )
{
    if (m_fPrepareToDeinitialize)
    {
        goto end;
    }

    switch(objtype)
    {

    case  IUICallbacks::OBJ_CLUSTER:
    {
        NLBERROR nerr;
        CClusterSpec cSpec;
        nerr = gEngine.GetClusterSpec(
                    ehObjId,
                    REF cSpec
                    );


        switch(evt)
        {
        case IUICallbacks::EVT_ADDED:
        {
            if (nerr == NLBERR_OK)
            {
                mfn_InsertCluster(ehObjId, &cSpec);
            }
            else
            {
                TRACE_CRIT("%!FUNC! : could not get cluster spec!");
            }
        }
        break;

        case IUICallbacks::EVT_REMOVED:
        {
            //
            // We can get called to delete a cluster with an ehObjId which
            // is no longer valid -- this happens when the object has just
            // been deleted and the engine is notifying the UI of the deletion.
            //
            mfn_DeleteCluster(ehObjId);
        }
        break;

        case IUICallbacks::EVT_STATUS_CHANGE:
        {
            //
            // A cluster status change.
            //
            if (nerr == NLBERR_OK)
            {
                mfn_InsertCluster(ehObjId, &cSpec);
            }
            else
            {
                TRACE_CRIT("%!FUNC! : could not get cluster spec!");
            }
        }
        break;
    
        default:
        break;
        }
    }
    break;

    case  IUICallbacks::OBJ_INTERFACE:

        {
        // First get host and interface spec.
        //
        NLBERROR nerr;
        CInterfaceSpec iSpec;
        CHostSpec hSpec;
        nerr = gEngine.GetInterfaceSpec(
                    ehObjId,
                    REF iSpec
                    );

        if (nerr == NLBERR_OK)
        {
            nerr = gEngine.GetHostSpec(
                    iSpec.m_ehHostId,
                    REF hSpec
                    );
            if (nerr == NLBERR_OK)
            {
                // mfn_InsertInterface(ehClusterId, ehObjId, &hSpec, &iSpec);
            }
            else
            {
                TRACE_CRIT("%!FUNC! : could not get host spec!");
                break;
            }
        }
        else
        {
            TRACE_CRIT("%!FUNC! : could not get interface spec for ehI 0x%lx!",
                            ehObjId);

            // 08/14/2002 JosephJ
            // Fix for .NET Server Bug# 684406
            // " nlbmgr:host icon is not removed from
            // the right list view when host is removed from cluster"
            //
            // What's happening is that the interface is deleted in the engine,
            // so the above call will fail. But we must still remove it from
            // the UI -- don't know why we didn't hit this before.
            // (Actually I know -- this is because we have logic to delete
            // a host when no interface is being managed by NLB -- that is
            // what caused this regression).
            //
            if (evt==IUICallbacks::EVT_INTERFACE_REMOVED_FROM_CLUSTER)
            {
                TRACE_CRIT("%!FUNC! ignoring above error and proceeding with remove IF operation for  ehI 0x%lx", ehObjId);
            }
            else
            {
                break;
            }
        }

        switch(evt)
        {

        case IUICallbacks::EVT_INTERFACE_ADDED_TO_CLUSTER:
        {
            mfn_InsertInterface(ehClusterId, ehObjId, &hSpec, &iSpec);
        }
        break;

        case IUICallbacks::EVT_INTERFACE_REMOVED_FROM_CLUSTER:
        {
            mfn_DeleteInterface(ehObjId);
        }
        break;
    
        case IUICallbacks::EVT_STATUS_CHANGE:
        {
            //
            // An interface status change.
            //
            mfn_InsertInterface(ehClusterId, ehObjId, &hSpec, &iSpec);
        }
        default:
        break;
        } // switch(evt)

        } // case IUICallbacks::OBJ_INTERFACE:
    break;

    default: // unknown obj type -- ignore.
    break;

    } // switch(objtype)

end:
    return;
}

    
void
LeftView::mfn_InsertCluster(
    ENGINEHANDLE       ehClusterId,
    const CClusterSpec *pCSpec
    )
/*
    Insert OR update the specified cluster node in the tree view
    Do NOT insert child interfaces.
*/
{
    TVINSERTSTRUCT   insItem;
    LPCWSTR  szText = L"";
    ENGINEHANDLE ehId = ehClusterId;
    INT iIcon;
    CTreeCtrl &treeCtrl = GetTreeCtrl();
    HTREEITEM htRoot = treeCtrl.GetRootItem();
    BOOL fRet = FALSE;
    WCHAR rgText[256];

    ZeroMemory(&insItem, sizeof(insItem));

    //
    // Decide on the icon type
    //
    {
        if (pCSpec->m_fPending)
        {
            iIcon = Document::ICON_CLUSTER_PENDING;
        }
        else if (pCSpec->m_fMisconfigured)
        {
            iIcon = Document::ICON_CLUSTER_BROKEN;
        }
        else
        {
            iIcon = Document::ICON_CLUSTER_OK;
        }
    }


    //
    // Construct the text
    //
    StringCbPrintf(
                rgText,
                sizeof(rgText),
                L"%ws (%ws)",
                pCSpec->m_ClusterNlbCfg.NlbParams.domain_name,
                pCSpec->m_ClusterNlbCfg.NlbParams.cl_ip_addr
                );

    szText = rgText;

    //
    // Now we insert/update the item.
    //

    insItem.hParent        = htRoot;
    insItem.hInsertAfter   = TVI_LAST;           
    insItem.item.mask      = TVIF_IMAGE | TVIF_PARAM | TVIF_SELECTEDIMAGE
                          | TVIF_TEXT | TVIF_CHILDREN;  
    insItem.item.pszText   =  (LPWSTR) szText;
    insItem.item.cchTextMax=  wcslen(szText)+1;
    insItem.item.iImage    = iIcon;
    insItem.item.iSelectedImage = iIcon;
    insItem.item.lParam    = (LPARAM ) ehId;
    insItem.item.cChildren = 1; // 1== has one or more chilren.
                             // NOTE: the control doesn't NEED
                             // to have children at this time -- this field
                             // simply indicates whether or not to display the
                             // '+' sign.


    mfn_Lock();

    // map< _bstr_t, HTREEITEM > mapIdToInterfaceItem;
    // map< _bstr_t, HTREEITEM > mapIdToClusterItem;

    HTREEITEM htItem = NULL;

    htItem = mapIdToClusterItem[ehId]; // map

    if (htItem == NULL)
    {
        //
        // This is a new cluster node -- we'll insert it to the tree view
        // at the end.
        //
        htItem = treeCtrl.InsertItem( &insItem ); // NULL on error.
        mapIdToClusterItem[ehId] = htItem; // map
    }
    else
    {
        //
        // This is an update to an existing cluster node -- we'll
        // just refresh it.
        //
        insItem.item.hItem = htItem;
        insItem.item.mask =  TVIF_IMAGE | TVIF_HANDLE | TVIF_SELECTEDIMAGE
                          | TVIF_TEXT | TVIF_CHILDREN;
        fRet = treeCtrl.SetItem(&insItem.item);

    }


    mfn_Unlock();

    treeCtrl.Expand( htRoot, TVE_EXPAND );
}



void
LeftView::mfn_DeleteCluster(
    ENGINEHANDLE ehID
    )
/*
    Delete the specified cluster node in the treeview as well as all its
    childern interfaces.
*/
{

    mfn_Lock();

    HTREEITEM htItem = NULL;
    CTreeCtrl &treeCtrl = GetTreeCtrl();

    htItem = mapIdToClusterItem[ehID]; // map

    if (htItem == NULL)
    {
        TRACE_CRIT("%!FUNC! remove ehId=0x%lx: no corresponding htItem!",
                ehID);
    }
    else
    {
        treeCtrl.DeleteItem(htItem);
        mapIdToClusterItem[ehID] = NULL; // map
    }
    mfn_Unlock();
}

void
LeftView::mfn_InsertInterface(
    ENGINEHANDLE ehClusterID,
    ENGINEHANDLE ehInterfaceID,
    const CHostSpec *pHSpec,
    const CInterfaceSpec *pISpec
    )
/*
    Insert OR update the specified interface node under the
    specified cluster node.
*/
{
    TVINSERTSTRUCT   insItem;
    WCHAR  rgText[256];
    LPCWSTR szText = L"";
    ENGINEHANDLE  ehId = ehInterfaceID;
    INT iIcon = Document::ICON_HOST_UNKNOWN;
    CTreeCtrl &treeCtrl = GetTreeCtrl();
    HTREEITEM htParent = NULL;
    BOOL fRet = FALSE;
    _bstr_t bstrDisplayName;


    ZeroMemory(&insItem, sizeof(insItem));

    {
        _bstr_t bstrStatus;
        CInterfaceSpec iSpec;
        CHostSpec hSpec;

        NLBERROR nerr;
        nerr = gEngine.GetInterfaceInformation(
                ehInterfaceID,
                REF hSpec,
                REF iSpec,
                REF bstrDisplayName,
                REF iIcon,
                REF bstrStatus
                );
        if (NLBFAILED(nerr))
        {
            goto end;
        }

        if (ehClusterID != NULL && ehClusterID != iSpec.m_ehCluster)
        {
            //
            // Ahem, out of sync here -- the IF is NOT part of the cluster!
            //
            TRACE_CRIT("%!FUNC! remove ehId=0x%lx is not member of ehCluster 0x%lx", ehId, ehClusterID);
            goto end;
        }

        szText = bstrDisplayName;
    }


    mfn_Lock();

    insItem.hInsertAfter   = TVI_LAST;           
    insItem.item.mask      = TVIF_IMAGE | TVIF_PARAM | TVIF_SELECTEDIMAGE
                          | TVIF_TEXT | TVIF_CHILDREN;  
    insItem.item.pszText   =  (LPWSTR) szText;
    insItem.item.cchTextMax=  wcslen(szText)+1;
    insItem.item.iImage    = iIcon;
    insItem.item.iSelectedImage = iIcon;
    insItem.item.lParam    = (LPARAM ) ehId;
    insItem.item.cChildren = 0; // 0== has no children.

    HTREEITEM htItem = NULL;

    htItem = mapIdToInterfaceItem[ehId]; // map

    if (htItem == NULL)
    {
        htParent =  mapIdToClusterItem[ehClusterID]; // map
        if (htParent == NULL)
        {
            // no such parent?!!!
    
            goto end_unlock;
        }
        insItem.hParent        = htParent;
        //
        // This is a new interface node -- we'll insert it to the tree view
        // at the end.
        //

        htItem = treeCtrl.InsertItem( &insItem ); // NULL on error.
        mapIdToInterfaceItem[ehId] = htItem; // map
    }
    else
    {
        insItem.item.hItem = htItem;
        insItem.item.mask =  TVIF_IMAGE | TVIF_HANDLE | TVIF_SELECTEDIMAGE
                          | TVIF_TEXT | TVIF_CHILDREN;
        fRet = treeCtrl.SetItem(&insItem.item);

    }

    if(htParent)
    {
        treeCtrl.Expand( htParent, TVE_EXPAND );
    }

end_unlock:

    mfn_Unlock();

end:
    return;
}

void
LeftView::mfn_DeleteInterface(
    ENGINEHANDLE ehInterfaceID
    )
/*
    Remove the specified interface node from the tree view.
*/
{

    mfn_Lock();

    HTREEITEM htItem = NULL;
    CTreeCtrl &treeCtrl = GetTreeCtrl();

    htItem = mapIdToInterfaceItem[ehInterfaceID]; // map

    if (htItem == NULL)
    {
        TRACE_CRIT("%!FUNC! remove ehId=0x%lx: no corresponding htItem!",
                ehInterfaceID);
    }
    else
    {
        treeCtrl.DeleteItem(htItem);
        mapIdToInterfaceItem[ehInterfaceID] = NULL; // map
    }
    mfn_Unlock();
}


NLBERROR
LeftView::mfn_GetSelectedInterface(
        ENGINEHANDLE &ehInterface,
        ENGINEHANDLE &ehCluster
        )
/*
    If the user has currently selectd an interface in the left (tree) view,
    set out params to the handle to the interface, and to the cluster the
    interface belongs, and  return NLBERR_OK.

    Other wise return NLBERR_NOT_FOUND.

    NOTE: we do not check the validity of the returned handles -- the caller
    should do that
*/
{
    NLBERROR nerr = NLBERR_NOT_FOUND;
    HTREEITEM hdlSelectedItem = GetTreeCtrl().GetSelectedItem();

    ehInterface = NULL;
    ehCluster = NULL;

    // find tree view host member which has been selected.
    //
    TVITEM selectedItem;
    selectedItem.hItem = hdlSelectedItem;
    selectedItem.mask = TVIF_PARAM;
   
    BOOL fRet = GetTreeCtrl().GetItem( &selectedItem );
    
    if (!fRet)
    {
        TRACE_CRIT("%!FUNC!: could not get selected item!");
        goto end;
    }

    ehInterface = (ENGINEHANDLE) selectedItem.lParam;

    // get parent cluster of the selected host member.
    HTREEITEM hdlParentItem;
    hdlParentItem = GetTreeCtrl().GetParentItem( hdlSelectedItem );

    TVITEM    parentItem;
    parentItem.hItem = hdlParentItem;
    parentItem.mask = TVIF_PARAM;
    
    fRet = GetTreeCtrl().GetItem( &parentItem );
    if (!fRet)
    {
        TRACE_CRIT("%!FUNC!: could not get parent of selected item!");
        ehInterface = NULL;
        goto end;
    }

    ehCluster = (ENGINEHANDLE) parentItem.lParam;

    nerr = NLBERR_OK;

end:
    
    return nerr;
}


NLBERROR
LeftView::mfn_GetSelectedCluster(
        ENGINEHANDLE &ehCluster
        )
/*
    If the user has currently selectd a cluster in the left (tree) view,
    set out param to the handle the cluster belongs to and return NLBERR_OK.

    Other wise return NLBERR_NOT_FOUND.

    NOTE: we do not check the validity of the returned handle -- the caller
    should do that
*/
{
    NLBERROR nerr = NLBERR_NOT_FOUND;
    HTREEITEM hdlSelectedItem = GetTreeCtrl().GetSelectedItem();

    ehCluster = NULL;

    // find tree view cluster which has been selected.
    //
    TVITEM selectedItem;
    selectedItem.hItem = hdlSelectedItem;
    selectedItem.mask = TVIF_PARAM;
   
    BOOL fRet = GetTreeCtrl().GetItem( &selectedItem );
    
    if (!fRet)
    {
        TRACE_CRIT("%!FUNC!: could not get selected item!");
        goto end;
    }

    ehCluster = (ENGINEHANDLE) selectedItem.lParam;
    nerr = NLBERR_OK;

end:
    
    return nerr;
}

//
//-------------------------------------------------------------------
//  Implementation of class LogSettingsDialog.
//-------------------------------------------------------------------
//

LogSettingsDialog::LogSettingsDialog(Document* pDocument, CWnd* parent)
        :
        CDialog( IDD, parent ), m_pDocument(pDocument)
{
}

void
LogSettingsDialog::DoDataExchange( CDataExchange* pDX )
{  
	CDialog::DoDataExchange(pDX);

    DDX_Control(pDX, IDC_EDIT_LOGFILENAME, m_LogFileName);
}


BOOL
LogSettingsDialog::OnInitDialog()
{
    WCHAR szLogFileName[MAXFILEPATHLEN];
    ZeroMemory(szLogFileName, MAXFILEPATHLEN*sizeof(WCHAR));

    m_fLoggingEnabledOnInit = m_pDocument->isLoggingEnabled();
    ::CheckDlgButton(m_hWnd, IDC_CHECK_LOGSETTINGS, m_fLoggingEnabledOnInit);

    ::EnableWindow (GetDlgItem(IDC_EDIT_LOGFILENAME)->m_hWnd, m_fLoggingEnabledOnInit);

    m_pDocument->getLogfileName(szLogFileName, MAXFILEPATHLEN-1);
    ::SetDlgItemText(m_hWnd, IDC_EDIT_LOGFILENAME, szLogFileName);

    this->SetDefID(IDCANCEL);

    BOOL fRet = CDialog::OnInitDialog();
    return fRet;
}


BOOL
LogSettingsDialog::OnHelpInfo (HELPINFO* helpInfo )
{
    if( helpInfo->iContextType == HELPINFO_WINDOW )
    {
        ::WinHelp( static_cast<HWND> ( helpInfo->hItemHandle ), 
                   CVY_CTXT_HELP_FILE, 
                   HELP_WM_HELP, 
                   (ULONG_PTR ) s_HelpIDs);
    }

    return TRUE;
}


void
LogSettingsDialog::OnContextMenu( CWnd* pWnd, CPoint point )
{
    ::WinHelp( m_hWnd, 
               CVY_CTXT_HELP_FILE, 
               HELP_CONTEXTMENU, 
               (ULONG_PTR ) s_HelpIDs);
}

void LogSettingsDialog::OnOK()
{
    WCHAR szLogFileName[MAXFILEPATHLEN];
    WCHAR szError[MAXSTRINGLEN];
    Document::LOG_RESULT lrResult;
    BOOL fEnableLogging = FALSE;
    BOOL fModified      = FALSE; // The file name was modified in the dialog
    BOOL fError         = FALSE; // In which case szError has message.
    BOOL fCurrentlyLogging = m_pDocument->isCurrentlyLogging();
    LPCWSTR szCaption   = L"";
    BOOL fCancelOK = FALSE;

    szLogFileName[0] = 0; 
    szError[0]=0;
    fEnableLogging = ::IsDlgButtonChecked(m_hWnd, IDC_CHECK_LOGSETTINGS);

    if (m_LogFileName.GetModify())
    {
        //
        // Get the new name from the dialog
        //
        if (0 == ::GetDlgItemText(m_hWnd, IDC_EDIT_LOGFILENAME, szLogFileName, MAXFILEPATHLEN-1))
        {
            szLogFileName[0] = 0;
        }
        fModified = TRUE;
    }
    else
    {
        //
        // Get the current name
        //
        m_pDocument->getLogfileName(szLogFileName, MAXFILEPATHLEN-1);
    }
    
    TRACE_INFO(L"%!FUNC! LoggingEnabled was %u and now is %u", m_fLoggingEnabledOnInit, fEnableLogging);

    if (fEnableLogging)
    {
        BOOL fStartLogging = TRUE;

        if (fModified || !fCurrentlyLogging)
        {
            //
            // EITHER we weren't logging OR
            // the file name is modified:  Validate the log file name.
            //
            fError = !m_pDocument->isDirectoryValid(szLogFileName);
            if (fError)
            {
                szCaption = GETRESOURCEIDSTRING(IDS_FILEERR_INVALID_PATH_CAP);
                wcsncat(
                    szError,
                    GETRESOURCEIDSTRING(IDS_FILEERR_INVALID_PATH_MSG),
                    MAXSTRINGLEN-1
                    );
                szError[MAXSTRINGLEN-1]=0;
                fStartLogging = FALSE;
                fCancelOK = TRUE;
            }
            else
            {
                m_pDocument->stopLogging(); // don't report error
            }

            if (fStartLogging)
            {
                m_pDocument->setLogfileName(szLogFileName);
                m_pDocument->enableLogging();

                //
                // Start the logging
                //
                lrResult = m_pDocument->startLogging();

                if (Document::STARTED != lrResult && Document::ALREADY != lrResult)
                {
                    fError = TRUE;
                    szCaption = GETRESOURCEIDSTRING(IDS_FILEERR_LOGGING_NOT_STARTED);
                    // szCaption   =  L"Failed to start logging"; // caption
                    LPCWSTR sz = NULL;

                    switch (lrResult)
                    {
                    case Document::NOT_ENABLED:
                        sz = GETRESOURCEIDSTRING(IDS_LOGFILE_NOT_ENABLED);
                        // wcsncat(szError, L"Logging is not currently enabled", MAXSTRINGLEN-1);
                        break;
                    case Document::NO_FILE_NAME:
                        sz = GETRESOURCEIDSTRING(IDS_LOGFILE_NOT_SPECIFIED);
                        // wcsncat(szError, L"Log file name has not been specified\nLogging will not be started.", MAXSTRINGLEN-1);
                        break;
                    case Document::FILE_NAME_TOO_LONG:
                        sz = GETRESOURCEIDSTRING(IDS_LOGFILE_TOO_LONG);
                        // wcsncat(szError, L"Log file name is too long", MAXSTRINGLEN-1);
                        break;
                    case Document::IO_ERROR:
                        sz = GETRESOURCEIDSTRING(IDS_LOGFILE_IO_ERROR);
                        // wcsncat(szError, L"Error opening log file", MAXSTRINGLEN-1);
                        break;
                    case Document::REG_IO_ERROR:
                        sz = GETRESOURCEIDSTRING(IDS_LOGFILE_REG_ERROR);
                        // wcsncat(szError, L"Registry IO error", MAXSTRINGLEN-1);
                        break;
                    case Document::FILE_TOO_LARGE:
                        sz = GETRESOURCEIDSTRING(IDS_LOGFILE_FILE_TOO_LARGE);
                        break;
                    default:
                        sz = GETRESOURCEIDSTRING(IDS_LOGFILE_UNKNOWN_ERROR);
                        // wcsncat(szError, L"Unknown error", MAXSTRINGLEN-1);
                        break;
                    }
                    wcsncat(szError, sz, MAXSTRINGLEN-1);
                    szError[MAXSTRINGLEN-1]=0;
                }
            }

            if (!fError)
            {
                //
                // Persist logging in the registry
                //
                LONG lStatus = m_pDocument->enableLogging();
                if (ERROR_SUCCESS != lStatus)
                {
                    fError = TRUE;
                    szCaption = GETRESOURCEIDSTRING(IDS_FILEERR_CANT_SAVE_TO_REG);
                    // szCaption = 
                    //      L"Error storing the enabled state in the registry";
                    FormatMessage(
                                  FORMAT_MESSAGE_FROM_SYSTEM,
                                  NULL,
                                  (DWORD) lStatus,
                                  0,    // language identifier
                                  szError,
                                  MAXSTRINGLEN-1,
                                  NULL
                                 );
    
                }
            }
        }
    }
    else
    {
        //
        // Logging is not currently enabled. If it was previously enabled,
        // we stop it.
        //
        if (fCurrentlyLogging)
        {
            m_pDocument->stopLogging(); // don't report error
        }
        LONG lStatus = m_pDocument->disableLogging();
        if (fModified)
        {
           m_pDocument->setLogfileName(szLogFileName);
        }

        if (ERROR_SUCCESS != lStatus)
        {
            fError = TRUE;
            //
            // Keep going, but inform user
            //
            szCaption = GETRESOURCEIDSTRING(IDS_FILEERR_CANT_DISABLE_LOGGING);
            // szCaption = L"Error disabling logging";
            ZeroMemory(szError, MAXSTRINGLEN*sizeof(WCHAR));
            FormatMessage(
                          FORMAT_MESSAGE_FROM_SYSTEM,
                          NULL,
                          (DWORD) lStatus,
                          0,    // language identifier
                          szError,
                          MAXSTRINGLEN-1,
                          NULL
                         );
        }

    }

    if (fError)
    {
        // put up error msg box
        ::MessageBox(
                 NULL,
                 szError, // contents
                 szCaption,
                 MB_ICONINFORMATION   | MB_OK
                );
        TRACE_CRIT(L"%!FUNC! ERROR %ws: %ws", szError, szCaption);
    }

    if (!fCancelOK)
    {
	    CDialog::OnOK();
    }
}

void LogSettingsDialog::OnSpecifyLogSettings() 
{
    BOOL fEnable = FALSE;

    fEnable = ::IsDlgButtonChecked(m_hWnd, IDC_CHECK_LOGSETTINGS);

    ::EnableWindow (GetDlgItem(IDC_EDIT_LOGFILENAME)->m_hWnd,      fEnable);

    if (fEnable)
    {
        //
        // We don't allow the user to press "OK" if there is no text in
        // the dialog.
        //
        if (m_LogFileName.GetWindowTextLength() == 0)
        {
            this->SetDefID(IDCANCEL);
        }
        else
        {
            this->SetDefID(IDOK);
        }
    }
    else
    {
            this->SetDefID(IDOK);
    }
}

void LogSettingsDialog::OnUpdateEditLogfileName()
{
    //
    // This gets called when the user has made changes to the filename
    // edit control.
    //

    //
    // We don't allow the user to press "OK" if there is no text in
    // the dialog.
    //
    if (m_LogFileName.GetWindowTextLength() == 0)
    {
        this->SetDefID(IDCANCEL);
    }
    else
    {
        this->SetDefID(IDOK);
    }
}

void
LeftView::OnKeyDown( UINT nChar, UINT nRepCnt, UINT nFlags )
{
    CTreeView::OnKeyDown(nChar, nRepCnt, nFlags);

    if (nChar == VK_F5)
    {
        /* Refresh.  If the high order bit of the SHORT returned by GetKeyState
           is set, then the Control key is depressed; otherwise, it is not.  If
           CTRL+F5 is pressed, this is a refresh ALL operation, otherwise only
           the selected cluster or interface in the tree view will be refreshed. */
        if (GetKeyState(VK_CONTROL) & 0x8000)
            this->OnRefresh(TRUE);
        else
            this->OnRefresh(FALSE);
    }
    else if (nChar == VK_TAB || nChar == VK_F6)
    {
        if (! (::GetAsyncKeyState(VK_SHIFT) & 0x8000))
        {
            GetDocument()->SetFocusNextView(this, nChar);
        }
        else
        {
            GetDocument()->SetFocusPrevView(this, nChar);
        }
    }

}

void
LeftView::OnLButtonDblClk( UINT nFlags, CPoint point )
{
    CTreeView::OnLButtonDblClk( nFlags, point );
}


void
LeftView::mfn_EnableClusterMenuItems(BOOL fEnable)
{
    CWnd*   pMain   = AfxGetMainWnd();
    CMenu*  pMenu   = pMain->GetMenu();
    CMenu*  subMenu = pMenu->GetSubMenu( 1 ); // cluster menu
    UINT    nEnable = MF_BYCOMMAND | MF_DISABLED | MF_GRAYED;

    if (fEnable)
    {
        nEnable = MF_BYCOMMAND | MF_ENABLED;
    }

    subMenu->EnableMenuItem( ID_CLUSTER_ADD_HOST,           nEnable);
    subMenu->EnableMenuItem( ID_CLUSTER_REMOVE,             nEnable);
    subMenu->EnableMenuItem( ID_CLUSTER_PROPERTIES,         nEnable);
    subMenu->EnableMenuItem( ID_REFRESH,                    nEnable);
    subMenu->EnableMenuItem( ID_CLUSTER_UNMANAGE,           nEnable);
    subMenu->EnableMenuItem( ID_CLUSTER_EXE_QUERY,          nEnable);
    subMenu->EnableMenuItem( ID_CLUSTER_EXE_START,          nEnable);
    subMenu->EnableMenuItem( ID_CLUSTER_EXE_STOP,           nEnable);
    subMenu->EnableMenuItem( ID_CLUSTER_EXE_DRAINSTOP,      nEnable);
    subMenu->EnableMenuItem( ID_CLUSTER_EXE_RESUME,         nEnable);
    subMenu->EnableMenuItem( ID_CLUSTER_EXE_SUSPEND,        nEnable);
    subMenu->EnableMenuItem( ID_CLUSTER_EXE_PORT_CONTROL,   nEnable);
}


void
LeftView::mfn_EnableHostMenuItems(BOOL fEnable)
{
    CWnd*   pMain   = AfxGetMainWnd();
    CMenu*  pMenu   = pMain->GetMenu();
    CMenu*  subMenu = pMenu->GetSubMenu( 2 ); // host menu
    UINT    nEnable = MF_BYCOMMAND | MF_DISABLED | MF_GRAYED;

    if (fEnable)
    {
        nEnable = MF_BYCOMMAND | MF_ENABLED;
    }

    subMenu->EnableMenuItem( ID_HOST_REMOVE,            nEnable);
    subMenu->EnableMenuItem( ID_HOST_PROPERTIES,        nEnable);
    subMenu->EnableMenuItem( ID_HOST_STATUS,            nEnable);
    subMenu->EnableMenuItem( ID_HOST_EXE_QUERY,         nEnable);
    subMenu->EnableMenuItem( ID_HOST_EXE_START,         nEnable);
    subMenu->EnableMenuItem( ID_HOST_EXE_STOP,          nEnable);
    subMenu->EnableMenuItem( ID_HOST_EXE_DRAINSTOP,     nEnable);
    subMenu->EnableMenuItem( ID_HOST_EXE_RESUME,        nEnable);
    subMenu->EnableMenuItem( ID_HOST_EXE_SUSPEND,       nEnable);
    subMenu->EnableMenuItem( ID_HOST_EXE_PORT_CONTROL,  nEnable);
}

//
//-------------------------------------------------------------------
//  Implementation of class DetailsDialog.
//-------------------------------------------------------------------
//

DetailsDialog::DetailsDialog(
        Document* pDocument,
        LPCWSTR szCaption,
        LPCWSTR szDate,
        LPCWSTR szTime,
        LPCWSTR szCluster,
        LPCWSTR szHost,
        LPCWSTR szInterface,
        LPCWSTR szSummary,
        LPCWSTR szDetails,
        CWnd* parent
        )
    :
      CDialog( IDD, parent ),
      m_pDocument(pDocument),
      m_szCaption(szCaption),
      m_szDate(szDate),
      m_szTime(szTime),
      m_szCluster(szCluster),
      m_szHost(szHost),
      m_szInterface(szInterface),
      m_szSummary(szSummary),
      m_szMungedDetails(NULL)
{
    LPWSTR szMungedDetails = NULL;

    //
    // Unfortunately, the edit control requires \r\n to indicate a line break,
    // while szDetails has just \n to indicate a line break. So we need to
    // insert \r before every \n.
    //
    {
        LPCWSTR sz = NULL;
        LPWSTR szNew = NULL;
        UINT CharCount=0, LineCount=0;
    
        if (szDetails == NULL) goto end;

        for(sz=szDetails; *sz!=0; sz++)
        {
            CharCount++;
            if (*sz == '\n')
            {
                LineCount++;
            }
        }
    
        szMungedDetails = new WCHAR[CharCount+LineCount+1]; // +1 for end NULL
    
        if (szMungedDetails == NULL)
        {
            goto end;
        }
        
        szNew = szMungedDetails;
        for(sz=szDetails; *sz!=0; sz++)
        {
            if (*sz == '\n' && LineCount)
            {
                *szNew++ = '\r';
                LineCount--;
            }
            *szNew++ = *sz;
        }
        *szNew = 0;
    
        ASSERT(LineCount==0);

    }

end:

    m_szMungedDetails   = szMungedDetails;
}

DetailsDialog::~DetailsDialog()
{
    delete m_szMungedDetails;
}

void
DetailsDialog::DoDataExchange( CDataExchange* pDX )
{  
	CDialog::DoDataExchange(pDX);

    DDX_Control(pDX, IDC_EDIT_LOGDETAIL, m_Details);
}

BEGIN_MESSAGE_MAP( DetailsDialog, CDialog )
    ON_WM_ACTIVATE()
END_MESSAGE_MAP()

/*
 * Method: OnActivate
 * Description: This method is called when the log details window
 *              becomes active.  This callback allows us to un-select
 *              the text in the details box, which for some mysterious
 *              reason, is highlighted by default.
 */
void
DetailsDialog::OnActivate( UINT nState, CWnd* pWndOther, BOOL bMinimized )
{
    /* Call the base class OnActivate handler. */
    CDialog::OnActivate(nState, pWndOther, bMinimized);

    /* Get a pointer to the details edit box. */
    CEdit * details = (CEdit *)GetDlgItem(IDC_EDIT_LOGDETAIL);
    
    /* Set the entire text contents to be un-selected. */
    details->SetSel(0, 0, FALSE);
}

BOOL
DetailsDialog::OnInitDialog()
{
    BOOL fRet = FALSE;

    this->SetWindowText(m_szCaption);

    if (m_szDate!=NULL)
    {
        ::SetDlgItemText(m_hWnd, IDC_TEXT_LOGDETAIL_DATE1, m_szDate);
    }

    if (m_szTime!=NULL)
    {
        ::SetDlgItemText(m_hWnd, IDC_TEXT_LOGDETAIL_TIME1, m_szTime);
    }

    if (m_szCluster!=NULL)
    {
        ::SetDlgItemText(m_hWnd, IDC_TEXT_LOGDETAIL_CLUSTER1, m_szCluster);
    }

    if (m_szHost!=NULL)
    {
        ::SetDlgItemText(m_hWnd, IDC_TEXT_LOGDETAIL_HOST1, m_szHost);
    }

    if (m_szInterface!=NULL)
    {
        ::SetDlgItemText(m_hWnd, IDC_TEXT_LOGDETAIL_INTERFACE1, m_szInterface);
    }

    if (m_szSummary!=NULL)
    {
        ::SetDlgItemText(m_hWnd, IDC_TEXT_LOGDETAIL_DESCRIPTION1, m_szSummary);
    }

    if (m_szMungedDetails != NULL)
    {
        ::SetDlgItemText(m_hWnd, IDC_EDIT_LOGDETAIL, m_szMungedDetails);
    }

    fRet = CDialog::OnInitDialog();
    return fRet;
}


void
LeftView::mfn_Lock(void)
{
    //
    // See  notes.txt entry
    //      01/23/2002 JosephJ DEADLOCK in Leftview::mfn_Lock
    // for the reason for this convoluted implementation of mfn_Lock
    //

    while (!TryEnterCriticalSection(&m_crit))
    {
        ProcessMsgQueue();
        Sleep(100);
    }
}

void
LeftView::Deinitialize(void)
{
    TRACE_INFO(L"-> %!FUNC!");
    ASSERT(m_fPrepareToDeinitialize);
    // DummyAction(L"LeftView::Deinitialize");
    TRACE_INFO(L"<- %!FUNC!");
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\logview.cpp ===
//***************************************************************************
//
//  LOGVIEW.CPP
// 
//  Module: NLB Manager (client-side exe)
//
//  Purpose:  Implementation of the view of a log of events.
//
//  Copyright (c)2001 Microsoft Corporation, All Rights Reserved
//
//  History:
//
//  08/03/01    JosephJ Adapted from now defunct RightBottomView
//
//***************************************************************************
#include "precomp.h"
#pragma hdrstop
#include "private.h"

IMPLEMENT_DYNCREATE( LogView, CListView )


BEGIN_MESSAGE_MAP( LogView, CListView )

    ON_WM_KEYDOWN()
   // ON_NOTIFY(HDN_ITEMCLICK, 0, OnHeaderClock) 
    ON_NOTIFY_REFLECT(NM_DBLCLK,  OnDoubleClick)
   // ON_NOTIFY(NM_CLICK,  1, OnDoubleClick)
   // ON_NOTIFY(NM_KEYDOWN,  1, OnDoubleClick)



END_MESSAGE_MAP()


LogView::LogView()
    : m_fPrepareToDeinitialize(FALSE)
{
    InitializeCriticalSection(&m_crit);
}

LogView::~LogView()
{
    DeleteCriticalSection(&m_crit);
}

Document*
LogView::GetDocument()
{
    return ( Document *) m_pDocument;
}


void 
LogView::OnInitialUpdate()
{
    CListCtrl& ctrl = GetListCtrl();

    //
    // set images for this view.
    //
    ctrl.SetImageList( GetDocument()->m_images48x48, 
                                LVSIL_SMALL );

    //
    // set the style, we only want report
    // view
    //

    // get present style.
    LONG presentStyle;
    
    presentStyle = GetWindowLong( m_hWnd, GWL_STYLE );

    // Set the last error to zero to avoid confusion.  
    // See sdk for SetWindowLong.
    SetLastError(0);

    // set new style.
    SetWindowLong( m_hWnd,
                   GWL_STYLE,
                   // presentStyle | LVS_REPORT | WS_TILED | WS_CAPTION
                   // presentStyle | LVS_REPORT | WS_CAPTION
                   // presentStyle | LVS_REPORT | WS_DLGFRAME
                   presentStyle | LVS_REPORT| LVS_NOSORTHEADER
                 );

    // SetWindowText(L"Log view");

    ctrl.InsertColumn(0, 
                 GETRESOURCEIDSTRING( IDS_HEADER_LOG_TYPE),
                 LVCFMT_LEFT, 
                 Document::LV_COLUMN_TINY );

    ctrl.InsertColumn(1, 
                 GETRESOURCEIDSTRING( IDS_HEADER_LOG_DATE),
                 LVCFMT_LEFT, 
                 Document::LV_COLUMN_SMALL );

    ctrl.InsertColumn(2, 
                 GETRESOURCEIDSTRING( IDS_HEADER_LOG_TIME),
                 LVCFMT_LEFT, 
                 Document::LV_COLUMN_SMALLMEDIUM );

    ctrl.InsertColumn(3, 
                 GETRESOURCEIDSTRING( IDS_HEADER_LOG_CLUSTER),
                 LVCFMT_LEFT, 
                 Document::LV_COLUMN_MEDIUM);

    ctrl.InsertColumn(4, 
                 GETRESOURCEIDSTRING( IDS_HEADER_LOG_HOST),
                 LVCFMT_LEFT, 
                 Document::LV_COLUMN_LARGE);

    ctrl.InsertColumn(5, 
                 GETRESOURCEIDSTRING( IDS_HEADER_LOG_TEXT),
                 LVCFMT_LEFT, 
                 Document::LV_COLUMN_GIGANTIC);

    ctrl.SetExtendedStyle( ctrl.GetExtendedStyle() | LVS_EX_FULLROWSELECT );

    IUICallbacks::LogEntryHeader Header;

    // we will register 
    // with the document class, 
    // as we are the status pane
    // and status is reported via us.
    GetDocument()->registerLogView( this );

    //
    // Log a starting-nlbmgr message (needs to be after the registration,
    // because if file-logging is enabled and there is an error writing
    // the the file, that code tries to log an error message -- that message
    // would get dropped if we have not yet registered.
    //
    LogString(
        &Header,
        GETRESOURCEIDSTRING(IDS_LOG_NLBMANAGER_STARTED)
        );

    //
    // Make this initial entry the selected one. We want some row highlighted
    // to provide a visual cue as we move between views using keystrokes.
    //
    GetListCtrl().SetItemState(0, LVIS_SELECTED, LVIS_SELECTED);

}

//
// Log a message in human-readable form.
//
void
LogView::LogString(
    IN const IUICallbacks::LogEntryHeader *pHeader,
    IN const wchar_t    *szText
    )
{

    mfn_Lock();

    IUICallbacks::LogEntryType Type = pHeader->type;
    const wchar_t    *szCluster = pHeader->szCluster;
    const wchar_t    *szHost = pHeader->szHost;
    const wchar_t    *szDetails = pHeader->szDetails;
    static LONG sSequence=0;
    LONG Seq;
    LPCWSTR szType = L"";
    UINT Image = 0;
    CListCtrl& ctrl = GetListCtrl();
    WCHAR szSequenceNo[64];
    LPCWSTR szDate = NULL;
    LPCWSTR szTime = NULL;
    _bstr_t bstrTime;
    _bstr_t bstrDate;
    INT nItem = ctrl.GetItemCount();
    _bstr_t bstrText = _bstr_t(szText);
    BOOL fLogTrimError = FALSE;

    if (m_fPrepareToDeinitialize)
    {
        goto end_unlock;
    }

    //
    // If total count exceeds our limit by 100 entries, 
    // get rid of the first 100 entries and log a message saying we've
    // got rid of those entries.
    //
    #define MAX_LOG_ITEMS_IN_LIST       1000
    #define LOG_ITEMS_TO_DELETE         100
    if (nItem > MAX_LOG_ITEMS_IN_LIST)
    {
        for (int i=0;i < LOG_ITEMS_TO_DELETE;i++)
        {
           LPCWSTR szDetails =  (LPCWSTR) ctrl.GetItemData(0);
           delete szDetails; // may be NULL
           ctrl.DeleteItem(0);
        }

        //
        // Get the updated count...
        //
        nItem = ctrl.GetItemCount();

        fLogTrimError = TRUE;
    }

    if (szCluster == NULL)
    {
        szCluster = L"";
    }

    if (szHost == NULL)
    {
        szHost = L"";
    }

    if (szDetails != NULL)
    {
        //
        // There is detail-info. We make a copy of it and save it
        // as the lParam structure. TODO -- copy the
        // interface and other info as well.
        //
        UINT uLen = wcslen(szDetails)+1; // +1 for ending NULL;
        WCHAR *szTmp = new WCHAR[uLen];
        if (szTmp!=NULL)
        {
            CopyMemory(szTmp, szDetails, uLen*sizeof(WCHAR));
        }
        szDetails = szTmp; // could be NULL on mem failure.

        if (szDetails != NULL)
        {
            //
            // We'll add a hint to the text to double click for details...
            //
            bstrText += GETRESOURCEIDSTRING( IDS_LOG_DETAILS_HINT);
            LPCWSTR szTmp1 = bstrText;
            if (szTmp1 != NULL)
            {
                szText = szTmp1;
            }
        }
    }

    GetTimeAndDate(REF bstrTime, REF bstrDate);
    szTime = bstrTime;
    szDate = bstrDate;
    if (szTime == NULL) szTime = L"";
    if (szDate == NULL) szDate = L"";

    Seq = InterlockedIncrement(&sSequence);
    StringCbPrintf(szSequenceNo, sizeof(szSequenceNo), L"%04lu", Seq);

    switch(Type)
    {
    case IUICallbacks::LOG_ERROR:
        Image = Document::ICON_ERROR;
        szType = GETRESOURCEIDSTRING(IDS_PARM_ERROR);
        break;

    case IUICallbacks::LOG_WARNING:
        Image = Document::ICON_WARNING;
        szType = GETRESOURCEIDSTRING(IDS_PARM_WARN);
        break;

    case IUICallbacks::LOG_INFORMATIONAL:
        Image = Document::ICON_INFORMATIONAL;
        szType = GETRESOURCEIDSTRING(IDS_LOGTYPE_INFORMATION);
        break;
    }

    ctrl.InsertItem(
             LVIF_TEXT|LVIF_IMAGE|LVIF_PARAM, // nMask
             nItem,
             szSequenceNo, // text
             0, // nState
             0, // nStateMask
             Image,
             (LPARAM) szDetails // lParam
             );

    ctrl.SetItem(
             nItem,
             1,// nSubItem
             LVIF_TEXT, // nMask
             szDate, // lpszItem
             0,        // nImage
             0,        // nState
             0,        // nStateMask
             0        // lParam
             );

    ctrl.SetItem(
             nItem,
             2,// nSubItem
             LVIF_TEXT, // nMask
             szTime, // lpszItem
             0,        // nImage
             0,        // nState
             0,        // nStateMask
             0        // lParam
             );

    ctrl.SetItem(
             nItem,
             3,// nSubItem
             LVIF_TEXT, // nMask
             szCluster, // lpszItem
             0,        // nImage
             0,        // nState
             0,        // nStateMask
             0        // lParam
             );

    ctrl.SetItem(
             nItem,
             4,// nSubItem
             LVIF_TEXT, // nMask
             szHost, // lpszItem
             0,        // nImage
             0,        // nState
             0,        // nStateMask
             0        // lParam
             );

    ctrl.SetItem(
             nItem,
             5,// nSubItem
             LVIF_TEXT, // nMask
             szText, // lpszItem
             0,        // nImage
             0,        // nState
             0,        // nStateMask
             0        // lParam
             );

    ctrl.EnsureVisible(nItem, FALSE); // FALSE == partial visibility not ok.
    WCHAR logBuf[2*MAXSTRINGLEN];
    StringCbPrintf(
        logBuf,
        sizeof(logBuf),
        L"%ls\t%ls\t%ls\t%ls\t%ls\t%ls\t%ls\t\n",
        szSequenceNo, szType, szDate, szTime, szCluster, szHost, szText
        );
    GetDocument()->logStatus(logBuf);

    if (szDetails != NULL)
    {
        GetDocument()->logStatus((LPWSTR) szDetails);
    }

end_unlock:

    mfn_Unlock();


    if (fLogTrimError)
    {
        static LONG ReentrancyCount;
        //
        // We're going to call ourselves recursively, better make sure that 
        // we will NOT try to trim the log this time, or else we'll end
        // up in a recursive loop.
        //
        if (InterlockedIncrement(&ReentrancyCount)==1)
        {
            IUICallbacks::LogEntryHeader Header;
            Header.type      = IUICallbacks::LOG_WARNING;
            this->LogString(
                &Header,
                GETRESOURCEIDSTRING(IDS_LOG_TRIMMING_LOG_ENTRIES)
                );
        }
        InterlockedDecrement(&ReentrancyCount);
    }
    return;
}

void LogView::OnKeyDown( UINT nChar, UINT nRepCnt, UINT nFlags )
{
    CListView::OnKeyDown(nChar, nRepCnt, nFlags);

    if (nChar == VK_TAB || nChar == VK_F6)
    {
        // if (::GetAsyncKeyState(VK_SHIFT) > 0)
        if (! (::GetAsyncKeyState(VK_SHIFT) & 0x8000))
        {
            GetDocument()->SetFocusNextView(this, nChar);
        }
        else
        {
            GetDocument()->SetFocusPrevView(this, nChar);
        }
        // DummyAction(L"LogView TAB!");
    }
    else if (nChar == VK_RETURN)
    {
        POSITION    pos = NULL;
        CListCtrl&  ctrl = GetListCtrl();
        pos = ctrl.GetFirstSelectedItemPosition();
        if(pos != NULL)
        {
            int index = ctrl.GetNextSelectedItem( pos );
            mfn_DisplayDetails(index);
        }
        this->SetFocus();
    }

}


void LogView::OnDoubleClick(NMHDR* pNotifyStruct, LRESULT* pResult) 
{
    LPNMLISTVIEW  lpnmlv = (LPNMLISTVIEW) pNotifyStruct; // to get index
    mfn_DisplayDetails(lpnmlv->iItem);
}
void
LogView::mfn_DisplayDetails(int iItem)
{
    LPCWSTR szCaption = NULL;
    WCHAR rgEvent[64];
    WCHAR rgDate[256];
    WCHAR rgTime[256];
    WCHAR rgCluster[256];
    WCHAR rgHost[256];
    WCHAR rgSummary[256];
    CListCtrl& ctrl = GetListCtrl();
    LPCWSTR szDetails =  (LPCWSTR) ctrl.GetItemData(iItem);
    CLocalLogger logCaption;

    if (szDetails == NULL)
    {
        goto end;
    }
    UINT uLen;
    uLen = ctrl.GetItemText(iItem, 0, rgEvent, ASIZE(rgEvent)-1);
    rgEvent[uLen]=0;
    logCaption.Log(IDS_LOG_ENTRY_DETAILS, rgEvent);
    szCaption = logCaption.GetStringSafe();

    uLen = ctrl.GetItemText(iItem, 1, rgDate, ASIZE(rgDate)-1);
    rgDate[uLen]=0;

    uLen = ctrl.GetItemText(iItem, 2, rgTime, ASIZE(rgTime)-1);
    rgTime[uLen]=0;

    uLen = ctrl.GetItemText(iItem, 3, rgCluster, ASIZE(rgCluster)-1);
    rgTime[uLen]=0;

    uLen = ctrl.GetItemText(iItem, 4, rgHost, ASIZE(rgHost)-1);
    rgHost[uLen]=0;

    uLen = ctrl.GetItemText(iItem, 5, rgSummary, ASIZE(rgSummary)-1);
    rgTime[uLen]=0;

    if (szDetails != NULL)
    {
        //
        // We need to REMOVE the hint text we added to the summary
        // In the LogView list entry (see LogView::LogString, or search
        // for IDS_LOG_DETAILS_HINT).
        //
        _bstr_t bstrHint = GETRESOURCEIDSTRING( IDS_LOG_DETAILS_HINT);
        LPCWSTR szHint = bstrHint;
        if (szHint != NULL)
        {
            LPWSTR szLoc = wcsstr(rgSummary, szHint);
            if (szLoc != NULL)
            {
                //
                // Found the hint -- chop it off..
                //
                *szLoc = 0;
            }
        }
    }

    {
        DetailsDialog Details(
                        GetDocument(),
                        szCaption,      // Caption
                        rgDate,
                        rgTime,
                        rgCluster,
                        rgHost,
                        NULL, // TODO: rgInterface
                        rgSummary,
                        szDetails,
                        this        // parent
                        );
    
        (void) Details.DoModal();
    }

end:

    return;
}

void
LogView::mfn_Lock(void)
{
    //
    // See  notes.txt entry
    //      01/23/2002 JosephJ DEADLOCK in Leftview::mfn_Lock
    // for the reason for this convoluted implementation of mfn_Lock
    //

    while (!TryEnterCriticalSection(&m_crit))
    {
        ProcessMsgQueue();
        Sleep(100);
    }
}

void
LogView::Deinitialize(void)
{
    ASSERT(m_fPrepareToDeinitialize);
    // DummyAction(L"LogView::Deinitialize");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\mainform.h ===
#ifndef MAINFORM_H
#define MAINFORM_H

#include "stdafx.h"

#include "Document.h"

class MainForm : public CFrameWnd
{
    DECLARE_DYNCREATE( MainForm )

public:
    MainForm();
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    virtual LRESULT WindowProc( UINT message, WPARAM wParam, LPARAM lParam );



    Document *GetDocument(void)
    {
        if (m_pLeftView != NULL)
        {
            return m_pLeftView->GetDocument();
        }
        else
        {
            return NULL;
        }
    }

private:

    CToolBar         toolBar;
    CStatusBar       statusBar; 

    CSplitterWnd     splitterWindow;
    CSplitterWnd     splitterWindow2;

    //
    // This is just so that we can direct menu selections (which can come from
    // any of the views) to the left view, which actually has the code
    // to handle them.
    //
    LeftView        *m_pLeftView;

protected:

    afx_msg void OnClose( );


    // message handlers
    afx_msg int OnCreate( LPCREATESTRUCT lpCreateStruct );

    // world level.
    afx_msg void OnFileLoadHostlist();
    afx_msg void OnFileSaveHostlist();

    afx_msg void OnWorldConnect();

    afx_msg void OnWorldNewCluster();

    // cluster level.
    afx_msg void OnRefresh();
    
    afx_msg void OnClusterProperties();

    afx_msg void OnClusterRemove();

    afx_msg void OnClusterUnmanage();

    afx_msg void OnClusterAddHost();

    afx_msg void OnOptionsCredentials();

    afx_msg void OnOptionsLogSettings();

    afx_msg void OnClusterControl(UINT nID );

    afx_msg void OnClusterPortControl(UINT nID );

    // host level
    afx_msg void OnHostProperties();
    afx_msg void OnHostStatus();

    afx_msg void OnHostRemove();

    afx_msg void OnHostControl(UINT nID );

    afx_msg void OnHostPortControl(UINT nID );

    afx_msg void OnSizing(UINT fwSide, LPRECT pRect);

    // overrides
    virtual
    BOOL
    OnCreateClient( LPCREATESTRUCT lpcs, CCreateContext* pContext );

    DECLARE_MESSAGE_MAP()
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\mainform.cpp ===
#include "precomp.h"
#pragma hdrstop
#include "private.h"
#include "mainform.h"
#include "resource.h"

IMPLEMENT_DYNCREATE( MainForm, CFrameWnd )

BEGIN_MESSAGE_MAP( MainForm, CFrameWnd )

    ON_WM_CREATE()
    ON_WM_CLOSE()
    ON_WM_SIZING()

    ON_COMMAND(ID_FILE_LOAD_HOSTLIST, OnFileLoadHostlist)
    ON_COMMAND(ID_FILE_SAVE_HOSTLIST, OnFileSaveHostlist) 

    ON_COMMAND( ID_WORLD_CONNECT, OnWorldConnect )
    ON_COMMAND( ID_WORLD_NEW, OnWorldNewCluster )
    ON_COMMAND( ID_REFRESH, OnRefresh )

    ON_COMMAND( ID_CLUSTER_PROPERTIES, OnClusterProperties )

    ON_COMMAND( ID_CLUSTER_REMOVE, OnClusterRemove )
    ON_COMMAND( ID_CLUSTER_UNMANAGE, OnClusterUnmanage )
    ON_COMMAND( ID_CLUSTER_ADD_HOST, OnClusterAddHost )

    ON_COMMAND( ID_OPTIONS_CREDENTIALS, OnOptionsCredentials )

    ON_COMMAND( ID_OPTIONS_LOGSETTINGS, OnOptionsLogSettings )

    ON_COMMAND_RANGE( ID_CLUSTER_EXE_QUERY, ID_CLUSTER_EXE_RESUME,
                      OnClusterControl )

    ON_COMMAND_RANGE( ID_CLUSTER_EXE_PORT_CONTROL, ID_CLUSTER_EXE_PORT_CONTROL, 
                      OnClusterPortControl )

    ON_COMMAND( ID_HOST_PROPERTIES, OnHostProperties )
    ON_COMMAND( ID_HOST_STATUS, OnHostStatus )
    ON_COMMAND( ID_HOST_REMOVE, OnHostRemove )

    ON_COMMAND_RANGE( ID_HOST_EXE_QUERY, ID_HOST_EXE_RESUME,
                      OnHostControl )
    ON_COMMAND_RANGE( ID_HOST_EXE_PORT_CONTROL, ID_HOST_EXE_PORT_CONTROL, 
                      OnHostPortControl )


END_MESSAGE_MAP()

MainForm::MainForm()
    : m_pLeftView(NULL)
{
    m_bAutoMenuEnable = FALSE;
}

//
// 2/14/01: JosephJ This is used by class Document -- couldn't figure
// out what MFC calls to make to get the main frame class.
// See  notes.txt entry:
//          02/14/2002 JosephJ Processing UI updates in the foreground
//
CWnd  *g_pMainFormWnd;

int 
MainForm::OnCreate( LPCREATESTRUCT lpCreateStruct )
{
    static const unsigned int indicator = ID_SEPARATOR;

    if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
        return -1;

    statusBar.Create( this );
    statusBar.SetIndicators( &indicator, 1 );
    g_pMainFormWnd = this;

    return 0;
}

BOOL MainForm::PreCreateWindow(CREATESTRUCT& cs)
{
    if( !CFrameWnd::PreCreateWindow(cs) )
        return FALSE;
    // The following will prevent the "-" getting added to the window title
    cs.style &= ~FWS_ADDTOTITLE;
    return TRUE;
}


LRESULT
MainForm::WindowProc( UINT message, WPARAM wParam, LPARAM lParam )
//
// For design information, see  notes.txt entry:
//          02/14/2002 JosephJ Processing UI updates in the foreground
//
{
    if (message == MYWM_DEFER_UI_MSG)
    {
        CUIWorkItem *pWorkItem = NULL;
        Document *pDocument = this->GetDocument();
        pWorkItem = (CUIWorkItem *) lParam;
        if (pWorkItem != NULL && pDocument != NULL)
        {
            pDocument->HandleDeferedUIWorkItem(pWorkItem);
        }
        delete pWorkItem;
        return 0;
    }
    else
    {
        return  CFrameWnd::WindowProc(message, wParam, lParam);
    }
}

/*
 * Method: OnSizing
 * Description: This method is called when the main window is being re-sized.
 *              We use this callback to preserve the window size ratios by
 *              moving the splitter windows as the window is re-sized.
 */
void 
MainForm::OnSizing(UINT fwSide, LPRECT pRect)
{
    /* Call the base class OnSizing method. */
    CFrameWnd::OnSizing(fwSide, pRect);

    // go for 30-70 split column split
    // and 60-40 row split.
    CRect rect;
    GetWindowRect( &rect );
    splitterWindow2.SetColumnInfo( 0, rect.Width() * 0.3, 10 );
    splitterWindow2.SetColumnInfo( 1, rect.Width() * 0.7, 10 );
    splitterWindow2.RecalcLayout();

    splitterWindow.SetRowInfo( 0, rect.Height() * 0.6, 10 );
    splitterWindow.SetRowInfo( 1, rect.Height() * 0.4, 10 );
    splitterWindow.RecalcLayout();
}

BOOL
MainForm::OnCreateClient( LPCREATESTRUCT lpcs, CCreateContext* pContext )
{
    // create the splitter window.
    // it is really a splitter within a splitter

    //  ---------------------------------
    //  |        | List                 |
    //  |        |                      |
    //  | Tree   |                      |
    //  |        |                      |
    //  |-------------------------------|
    //  |        Edit                   |
    //  |                               |
    //  |                               |
    //  ---------------------------------

    // left pane is a treeview control
    // right pane is another splitter with listview control
    // and bottom is editview control.

    splitterWindow.CreateStatic( this, 2, 1 );


    // create nested splitter.
    splitterWindow2.CreateStatic( &splitterWindow, 1, 2,
                                  WS_CHILD | WS_VISIBLE | WS_BORDER,
                                  splitterWindow.IdFromRowCol( 0, 0 )
                                  );

    splitterWindow2.CreateView( 0, 
                                0, 
                                RUNTIME_CLASS( LeftView ),
                                CSize( 0, 0 ),
                                pContext );

    splitterWindow2.CreateView( 0, 
                                1, 
                                RUNTIME_CLASS( DetailsView ),
                                CSize( 0, 0 ),
                                pContext );

    
    //
    // Save a way a pointer to the left view -- we use this to send
    // it menu operations.
    //
    m_pLeftView = (LeftView*) splitterWindow2.GetPane(0,0);

    //
    // create log view
    //
    splitterWindow.CreateView( 1, 
                               0, 
                               RUNTIME_CLASS( LogView ),
                               CSize( 0, 0 ),
                               pContext );

    // go for 30-70 split column split
    // and 60-40 row split.
    CRect rect;
    GetWindowRect( &rect );
    splitterWindow2.SetColumnInfo( 0, rect.Width() * 0.3, 10 );
    splitterWindow2.SetColumnInfo( 1, rect.Width() * 0.7, 10 );
    splitterWindow2.RecalcLayout();

    splitterWindow.SetRowInfo( 0, rect.Height() * 0.6, 10 );
    splitterWindow.SetRowInfo( 1, rect.Height() * 0.4, 10 );
    splitterWindow.RecalcLayout();

    return TRUE;
}

    // world level.
void MainForm::OnFileLoadHostlist()
{
    if (m_pLeftView != NULL) m_pLeftView->OnFileLoadHostlist();
}

void MainForm::OnFileSaveHostlist()
{
    if (m_pLeftView != NULL) m_pLeftView->OnFileSaveHostlist();
}


void MainForm::OnWorldConnect()
{
    if (m_pLeftView != NULL) m_pLeftView->OnWorldConnect();
}

void MainForm::OnWorldNewCluster()
{
    if (m_pLeftView != NULL) m_pLeftView->OnWorldNewCluster();
}

    // cluster level.
void MainForm::OnRefresh()
{
    if (m_pLeftView != NULL) m_pLeftView->OnRefresh(FALSE);
}
    
void MainForm::OnClusterProperties()
{
    if (m_pLeftView != NULL) m_pLeftView->OnClusterProperties();
}

void MainForm::OnClusterRemove()
{
    if (m_pLeftView != NULL) m_pLeftView->OnClusterRemove();
}

void MainForm::OnClusterUnmanage()
{
    if (m_pLeftView != NULL) m_pLeftView->OnClusterUnmanage();
}

void MainForm::OnClusterAddHost()
{
    if (m_pLeftView != NULL) m_pLeftView->OnClusterAddHost();
}

void MainForm::OnOptionsCredentials()
{
    if (m_pLeftView != NULL) m_pLeftView->OnOptionsCredentials();
}

void MainForm::OnOptionsLogSettings()
{
    if (m_pLeftView != NULL) m_pLeftView->OnOptionsLogSettings();
}

void MainForm::OnClusterControl(UINT nID )
{
    if (m_pLeftView != NULL) m_pLeftView->OnClusterControl(nID);
}

void MainForm::OnClusterPortControl(UINT nID )
{
    if (m_pLeftView != NULL) m_pLeftView->OnClusterPortControl(nID);
}

    // host level
void MainForm::OnHostProperties()
{
    if (m_pLeftView != NULL) m_pLeftView->OnHostProperties();
}

void MainForm::OnHostStatus()
{
    if (m_pLeftView != NULL) m_pLeftView->OnHostStatus();
}

void MainForm::OnHostRemove()
{
    if (m_pLeftView != NULL) m_pLeftView->OnHostRemove();
}

void MainForm::OnHostControl(UINT nID )
{
    if (m_pLeftView != NULL) m_pLeftView->OnHostControl(nID);
}

void MainForm::OnHostPortControl(UINT nID )
{
    if (m_pLeftView != NULL) m_pLeftView->OnHostPortControl(nID);
}

void MainForm::OnClose( )
{
    Document *pDocument = NULL;
    BOOL fBlock = !theApplication.IsProcessMsgQueueExecuting();

    //
    // Display pending operations ...
    //
    //
    CLocalLogger logOperations;
    UINT         uCount = 0;
    logOperations.Log(IDS_LOG_PENDING_OPERATIONS_ON_EXIT_MSG);
    uCount = gEngine.ListPendingOperations(logOperations);
    if (uCount != 0)
    {
        int sel;
        sel = ::MessageBox(
             NULL,
             logOperations.GetStringSafe(),
             GETRESOURCEIDSTRING(IDS_LOG_PENDING_OPERATIONS_ON_EXIT_CAP),
             MB_ICONINFORMATION   | MB_OKCANCEL
            );
        
        if (sel != IDOK)
        {
            goto end;
        }
    }

    pDocument =  this->GetDocument();

    if (pDocument != NULL)
    {
        pDocument->PrepareToClose(fBlock);
    }

    if (fBlock)
    {
        CFrameWnd::OnClose();
    }
    else
    {
        theApplication.SetQuit();
    }
        
    
end:

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\mnlbuidata.h ===
#ifndef _MNLBUIDATA_H
#define _MNLBUIDATA_H
//
// Copyright (c) Microsoft.  All Rights Reserved 
//
// THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF Microsoft.
// The copyright notice above does not evidence any
// actual or intended publication of such source code.
//
// OneLiner : muidata interface file.
// DevUnit  : wlbstest
// Author   : Murtaza Hakim
//
// Description: 
// -----------
// This data structure is as follows
//
// ClusterData has inforamtion about 
// cluster
// portrules 
// and hosts.
// 
// The portRules are map structures with the start port mapping to the detailed port rule.
//
// the portrules unequal load balanced have a map which maps the host id and the 
// load weight for that particular host.
//
// the portrules failover have a map which maps the host id and the 
// priority for that particular host.
//
//
#include "utils.h"

class PortDataX
{
public:

    enum MNLBPortRule_Error
    {
        MNLBPortRule_SUCCESS = 0,
        
        InvalidRule = 1,

        InvalidNode = 2,

        COM_FAILURE  = 10,
    };

    enum Protocol
    {
        tcp,
        udp,
        both,
    };


    enum Affinity
    {
        none,
        single,
        classC,
    };


    //
    // Description:
    // -----------
    // constructor.
    // 
    // Parameters:
    // ----------
    // startPort             IN   : start port in range.
    // endPort               IN   : end port in range.
    // trafficToHandle       IN   : set port for specified protocol.
    // 
    // Returns:
    // -------
    // none.
    PortDataX( long startPort,
                  long endPort,
                  Protocol      trafficToHandle,
                  bool equal,
                  long load,
                  Affinity affinity,
                  long priority);


    //
    // Description:
    // -----------
    // default constructor.
    // 
    // Parameters:
    // ----------
    // none.
    // 
    // Returns:
    // -------
    // none.

    PortDataX();


    bool
    operator==(const PortDataX& objToCompare ) const; 

    bool
    operator!=(const PortDataX& objToCompare ) const;

    long _key;

    long _startPort;
    long _endPort;

    Protocol      _trafficToHandle;

    bool          _isEqualLoadBalanced;
    
    long _load;

    long _priority;

    Affinity      _affinity;


	map< _bstr_t, long > machineMapToLoadWeight;
    map< _bstr_t, long > machineMapToPriority;
    
    set<long>
    getAvailablePriorities(); 
};

struct HostData
{
    HostProperties hp;
    
    _bstr_t        connectionIP;
};

struct ClusterData
{
    vector<_bstr_t> virtualIPs;
    vector<_bstr_t> virtualSubnets;

    ClusterProperties cp;

    map< long, PortDataX> portX;

    map< _bstr_t, HostData>  hosts;

    set<int>
    getAvailableHostIDS();

    bool connectedDirect;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\mnlbuidata.cpp ===
// Copyright (c)  Microsoft.  All rights reserved.
//
// This is unpublished source code of Microsoft.
// The copyright notice above does not evidence any
// actual or intended publication of such source code.

// OneLiner  :  Implementation of MNLBCluster
// DevUnit   :  wlbstest
// Author    :  Murtaza Hakim

// include files
#include "precomp.h"
#pragma hdrstop
#include "private.h"

// done
// constructor
//
PortDataX::PortDataX( long startPort,
                  long endPort,
                  Protocol      trafficToHandle,
                  bool equal,
                  long load,
                  Affinity affinity,
                  long priority)
        : _startPort( startPort ),
          _endPort( endPort ),
          _trafficToHandle( trafficToHandle ),
         _isEqualLoadBalanced( equal ),
          _affinity( affinity ),
          _priority( priority ),
          _key( startPort )
{}


// done
// default constructor
//
PortDataX::PortDataX()
        :_startPort( 0 ),
         _endPort( 65535 ),
         _trafficToHandle( both ),
         _key( 0 )
{}


// done
// equality operator
bool
PortDataX::operator==(const PortDataX& objToCompare ) const
{
    if( (_startPort == objToCompare._startPort )
        &&
        (_endPort == objToCompare._endPort )        
        &&
        (_trafficToHandle == objToCompare._trafficToHandle )
        )
    {
        return true;
    }
    else
    {
        return false;
    }
}

// done
// inequality operator
bool
PortDataX::operator!=(const PortDataX& objToCompare ) const
{
    return !( *this == objToCompare );
}




set<long>
PortDataX::getAvailablePriorities()
{
    set<long> availablePriorities;

    // initially make all available.
    for( int i = 1; i <= WLBS_MAX_HOSTS; ++i )
    {
        availablePriorities.insert( i );
    }

    // remove priorities not available.
    map<_bstr_t, long>::iterator top;
    for( top = machineMapToPriority.begin(); 
         top != machineMapToPriority.end(); 
         ++top )
    {
        availablePriorities.erase(  (*top).second );
    }

    return availablePriorities;
}    



// getAvailableHostIDS
//
set<int>
ClusterData::getAvailableHostIDS()
{
    set<int> availableHostIDS;
    
    // initially make all available.
    for( int i = 1; i <= WLBS_MAX_HOSTS; ++i )
    {
        availableHostIDS.insert( i );
    }

    // remove host ids not available.
    map<_bstr_t, HostData>::iterator top;
    for( top = hosts.begin(); top != hosts.end(); ++top )
    {
        availableHostIDS.erase(  (*top).second.hp.hID );
    }

    return availableHostIDS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\portscontrolpage.h ===
#pragma once
#include "private.h"
class PortsControlPage : public CPropertyPage
{
public:
    enum
    {
        IDD = IDD_PORTS_CONTROL_PAGE,
    };

    // member controls.
    PortsControlPage( ClusterData*   p_clusterData,
                      unsigned long*        portSelected,
                      UINT         ID = PortsControlPage::IDD );

    CComboBox      portList;

    // overrides of CPropertyPage
    virtual void DoDataExchange( CDataExchange* pDX );

    virtual BOOL OnInitDialog();

    virtual void OnOK();

    afx_msg BOOL OnHelpInfo (HELPINFO* helpInfo );

    afx_msg void OnContextMenu( CWnd* pWnd, CPoint point );

protected :

    unsigned long* m_portSelected;

    ClusterData* m_clusterData;

    map< long, PortDataX> m_portX;

	
    DECLARE_MESSAGE_MAP()
};

static DWORD g_aHelpIDs_IDD_PORTS_CONTROL_PAGE [] = {
    IDC_TEXT_START_PORT,        IDC_TEXT_START_PORT,
    IDC_PORTS,                  IDC_PORTS,
    0,0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\portscontrolpage.cpp ===
#include "precomp.h"
#pragma hdrstop
#include "PortsControlPage.h"
#include "utils.h"



BEGIN_MESSAGE_MAP( PortsControlPage, CPropertyPage )
    ON_WM_HELPINFO()        
    ON_WM_CONTEXTMENU()        
END_MESSAGE_MAP()

void
PortsControlPage::DoDataExchange( CDataExchange* pDX )
{
    CPropertyPage::DoDataExchange( pDX );

    DDX_Control( pDX, IDC_PORTS, portList );
}

PortsControlPage::PortsControlPage( ClusterData*   p_clusterData,
                                    unsigned long*        portSelected,
                                    UINT     ID )
        :
        m_clusterData( p_clusterData ),
        m_portSelected( portSelected ),
        CPropertyPage( ID )
{
}

BOOL
PortsControlPage::OnInitDialog()
{
    CPropertyPage::OnInitDialog();

    // fill the portList with available ports.
    
    // first is allow user ability to select 
    // all ports.
    portList.AddString( GETRESOURCEIDSTRING( IDS_PORTS_ALL ) );

    wchar_t buf[Common::BUF_SIZE];

    map< long, PortDataX>::iterator topX;
    for( topX = m_portX.begin();
         topX != m_portX.end();
         ++topX )
    {
        StringCbPrintf( buf, sizeof(buf), L"%d", (*topX).second._startPort );
        portList.AddString( buf );
    }

    // make the all ports selection the
    // default selection.
    portList.SelectString( -1,
                           GETRESOURCEIDSTRING( IDS_PORTS_ALL ) );
    return TRUE;
}

void
PortsControlPage::OnOK()
{
    // get port which needs to be affected.
    int currentSelection = portList.GetCurSel();
    wchar_t buf[ Common::BUF_SIZE ];
    
    portList.GetLBText( currentSelection, buf );

    if( _bstr_t ( buf ) == GETRESOURCEIDSTRING( IDS_PORTS_ALL ) )
    {
        *m_portSelected = Common::ALL_PORTS;
    }
    else
    {
        *m_portSelected = _wtoi( buf );
    }

    CPropertyPage::OnOK();
}

BOOL
PortsControlPage::OnHelpInfo (HELPINFO* helpInfo )
{
    if( helpInfo->iContextType == HELPINFO_WINDOW )
    {
        ::WinHelp( static_cast<HWND> ( helpInfo->hItemHandle ), 
                   CVY_CTXT_HELP_FILE, 
                   HELP_WM_HELP, 
                   (ULONG_PTR ) g_aHelpIDs_IDD_PORTS_CONTROL_PAGE );
    }

    return TRUE;
}

void
PortsControlPage::OnContextMenu( CWnd* pWnd, CPoint point )
{
    ::WinHelp( m_hWnd, 
               CVY_CTXT_HELP_FILE, 
               HELP_CONTEXTMENU, 
               (ULONG_PTR ) g_aHelpIDs_IDD_PORTS_CONTROL_PAGE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\portsctrl.cpp ===
#include "precomp.h"
#pragma hdrstop
#include "private.h"
#include "PortsPage.h"
#include "PortsCtrl.h"
#include "portsctrl.tmh"

using namespace std;

/////////////////////////////////////////////////////////////////////////////
// CPortsCtrl dialog

CPortsCtrl::CPortsCtrl(ENGINEHANDLE                         ehClusterOrInterfaceId,
                       NLB_EXTENDED_CLUSTER_CONFIGURATION * pNlbCfg,
                       bool                                 fIsClusterLevel,
                       CWnd                               * pParent /*=NULL*/)
    	   :CDialog(CPortsCtrl::IDD, pParent),
            m_ehClusterOrInterfaceId( ehClusterOrInterfaceId ),
            m_isClusterLevel( fIsClusterLevel ),
            m_pNlbCfg( pNlbCfg ),
            m_sort_column( 0 ),
            m_sort_ascending( true)
{

}

void CPortsCtrl::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	DDX_Control(pDX, IDC_LIST_PORT_RULE, m_portList);
	DDX_Control(pDX, IDC_BUTTON_ENABLE, m_Enable);
	DDX_Control(pDX, IDC_BUTTON_DISABLE, m_Disable);
	DDX_Control(pDX, IDC_BUTTON_DRAIN, m_Drain);
	DDX_Control(pDX, IDOK, m_Close);
}

BEGIN_MESSAGE_MAP(CPortsCtrl, CDialog)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_LIST_PORT_RULE, OnColumnClick)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST_PORT_RULE, OnSelchanged )
	ON_BN_CLICKED(IDC_BUTTON_ENABLE, OnEnable)
	ON_BN_CLICKED(IDC_BUTTON_DISABLE, OnDisable)
	ON_BN_CLICKED(IDC_BUTTON_DRAIN, OnDrain)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPortsCtrl message handlers

BOOL CPortsCtrl::OnInitDialog()
{
    TRACE_INFO(L"-> %!FUNC!");
         
    CDialog::OnInitDialog();

    // Add column headers & form port rule list
    PortListUtils::LoadFromNlbCfg(m_pNlbCfg, REF m_portList, m_isClusterLevel, FALSE);

    // If the number of port rules is zero, then, gray out the enable, disable & drain buttons
    if (m_portList.GetItemCount() == 0)
    {
        m_Enable.EnableWindow(FALSE);
        m_Disable.EnableWindow(FALSE);
        m_Drain.EnableWindow(FALSE);
    }
    else // there is one or more port rules
    {
        // selection the first item in list.
        m_portList.SetItemState( 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED );
    }

    TRACE_INFO(L"<- %!FUNC! returns TRUE");
	return TRUE;  // return TRUE  unless you set the focus to a control
}


void CPortsCtrl::OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult) 
{
    PortListUtils::OnColumnClick((LPNMLISTVIEW) pNMHDR,
                              REF m_portList,
                                  m_isClusterLevel,
                              REF m_sort_ascending,
                              REF m_sort_column);
	*pResult = 0;
}

void CPortsCtrl::OnSelchanged(NMHDR* pNMHDR, LRESULT * pResult)
{    
    TRACE_INFO(L"-> %!FUNC!");
    // If no port rule is selected, then gray out the enable, disable and drain buttons. 
    if (m_portList.GetFirstSelectedItemPosition() == NULL) 
    {
        m_Enable.EnableWindow(FALSE);
        m_Disable.EnableWindow(FALSE);
        m_Drain.EnableWindow(FALSE);
    }
    else // a port rule is selected, check if the enable, disable, drain buttons are grayed out. If they are, enable them
    {
        if (m_Enable.IsWindowEnabled() == FALSE)
        {
            m_Enable.EnableWindow(TRUE);
            m_Disable.EnableWindow(TRUE);
            m_Drain.EnableWindow(TRUE);
        }
    }
    /*
    LPNMLISTVIEW lv = (LPNMLISTVIEW)pNMHDR;
    TRACE_INFO(L"%!FUNC! iItem : %d", lv->iItem);
    TRACE_INFO(L"%!FUNC! iSubItem : %d", lv->iSubItem);
    TRACE_INFO(L"%!FUNC! uNewState : %u", lv->uNewState);
    TRACE_INFO(L"%!FUNC! uOldState : %u", lv->uOldState);
    TRACE_INFO(L"%!FUNC! uChanged : %u", lv->uChanged);
    */

	*pResult = 0;
    TRACE_INFO(L"<- %!FUNC!");
    return;
}

void CPortsCtrl::OnEnable() 
{
    CWaitCursor wait;

    SetDlgItemText(IDC_OPER_STATUS_TEXT, GETRESOURCEIDSTRING(IDS_INFO_ENABLING_PORTS));
    mfn_DoPortControlOperation(WLBS_PORT_ENABLE); 
    SetDlgItemText(IDC_OPER_STATUS_TEXT, GETRESOURCEIDSTRING(IDS_INFO_DONE));

    return;
}

void CPortsCtrl::OnDisable() 
{
    CWaitCursor wait;

    SetDlgItemText(IDC_OPER_STATUS_TEXT, GETRESOURCEIDSTRING(IDS_INFO_DISABLING_PORTS));
    mfn_DoPortControlOperation(WLBS_PORT_DISABLE); 
    SetDlgItemText(IDC_OPER_STATUS_TEXT, GETRESOURCEIDSTRING(IDS_INFO_DONE));
    return;
}

void CPortsCtrl::OnDrain() 
{
    CWaitCursor wait;

    SetDlgItemText(IDC_OPER_STATUS_TEXT, GETRESOURCEIDSTRING(IDS_INFO_DRAINING_PORTS));
    mfn_DoPortControlOperation(WLBS_PORT_DRAIN); 
    SetDlgItemText(IDC_OPER_STATUS_TEXT, GETRESOURCEIDSTRING(IDS_INFO_DONE));
    return;
}

NLBERROR CPortsCtrl::mfn_DoPortControlOperation(WLBS_OPERATION_CODES Opcode) 
{
    CString  szVipArray[WLBS_MAX_RULES], szTemp;
    DWORD    pdwStartPortArray[WLBS_MAX_RULES];
    DWORD    dwNumOfPortRules;

    POSITION pos = m_portList.GetFirstSelectedItemPosition();
    if (pos == NULL)
    {
        return NLBERR_INTERNAL_ERROR;
    }

    // Loop thru the selected port rules and get the VIP & Start Port
	dwNumOfPortRules = 0;
    do
    {
        int index = m_portList.GetNextSelectedItem(REF pos);

        // Get VIP, Note : 0 is the column index for VIP
        szVipArray[dwNumOfPortRules] = m_portList.GetItemText( index, 0 );

        // Check for "All Vip" and replace "All" with "255.255.255.255"
        if (!lstrcmpi(szVipArray[dwNumOfPortRules], GETRESOURCEIDSTRING(IDS_REPORT_VIP_ALL)))
        {
            szVipArray[dwNumOfPortRules] = CVY_DEF_ALL_VIP;
        }

        // Get Start Port, Note : 1 is the column index for Start Port
        szTemp = m_portList.GetItemText( index, 1);
        pdwStartPortArray[dwNumOfPortRules] = _wtol(szTemp);

        ++dwNumOfPortRules;
    }
    while (pos);

    if (m_isClusterLevel) 
    {
        return gEngine.ControlClusterOnCluster(m_ehClusterOrInterfaceId, 
                                               Opcode, 
                                               szVipArray, 
                                               pdwStartPortArray, 
                                               dwNumOfPortRules);
    }
    else
    {
        return gEngine.ControlClusterOnInterface(m_ehClusterOrInterfaceId, 
                                                 Opcode, 
                                                 szVipArray, 
                                                 pdwStartPortArray, 
                                                 dwNumOfPortRules,
                                                 TRUE
                                                 );
    }

    return NLBERR_INTERNAL_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\portsctrl.h ===
#ifndef PORTSCTRL_H
#define PORTSCTRL_H

#include "stdafx.h"

#include "resource.h"


/////////////////////////////////////////////////////////////////////////////
// CPortsCtrl dialog

class CPortsCtrl : public CDialog
{
// Construction
public:
    CPortsCtrl(ENGINEHANDLE                         ehClusterOrInterfaceId,
               NLB_EXTENDED_CLUSTER_CONFIGURATION * pNlbCfg,
               bool                                 fIsClusterLevel,
               CWnd                               * pParent = NULL);

// Dialog Data
	enum { IDD = IDD_PORTS_CTRL };

	CListCtrl	m_portList;

	CButton	    m_Enable;
	CButton	    m_Disable;
	CButton	    m_Drain;

	CButton	    m_Close;

    bool        m_isClusterLevel;

	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support

// Implementation
protected:


	virtual BOOL OnInitDialog();

	afx_msg void OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSelchanged(NMHDR* pNMHDR, LRESULT* pResult);

	afx_msg void OnEnable();
	afx_msg void OnDisable();
	afx_msg void OnDrain();

private:
    ENGINEHANDLE                         m_ehClusterOrInterfaceId;
    NLB_EXTENDED_CLUSTER_CONFIGURATION * m_pNlbCfg;
    bool                                 m_sort_ascending;
    int                                  m_sort_column;

    NLBERROR mfn_DoPortControlOperation(WLBS_OPERATION_CODES Opcode);

	DECLARE_MESSAGE_MAP()
};

#endif // PORTSCTRL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\portspage.cpp ===
#include "precomp.h"
#pragma hdrstop
#include "private.h"
#include "PortsPage.h"
#include "ClusterPortsDlg.h"
#include "HostPortsDlg.h"
#include "MNLBUIData.h"
#include "portspage.tmh"

using namespace std;

BEGIN_MESSAGE_MAP(PortsPage, CPropertyPage)
    ON_BN_CLICKED(IDC_BUTTON_ADD, OnButtonAdd)
    ON_BN_CLICKED(IDC_BUTTON_DEL, OnButtonDel)
    ON_BN_CLICKED(IDC_BUTTON_MODIFY, OnButtonModify)
    ON_NOTIFY( NM_DBLCLK, IDC_LIST_PORT_RULE, OnDoubleClick )
    ON_NOTIFY( LVN_ITEMCHANGED, IDC_LIST_PORT_RULE, OnSelchanged )
    ON_NOTIFY( LVN_COLUMNCLICK, IDC_LIST_PORT_RULE, OnColumnClick )
    ON_WM_HELPINFO()
    ON_WM_CONTEXTMENU()
END_MESSAGE_MAP()

PortsPage::PortData::PortData()
{
    wchar_t buf[Common::BUF_SIZE];
    StringCbPrintf( buf, sizeof(buf),  L"%d", CVY_MIN_PORT );
    start_port = buf;

    StringCbPrintf( buf, sizeof(buf), L"%d", CVY_MAX_PORT );
    end_port = buf;

    virtual_ip_addr = GETRESOURCEIDSTRING( IDS_REPORT_VIP_ALL );
    protocol = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_BOTH );
    mode = GETRESOURCEIDSTRING( IDS_REPORT_MODE_MULTIPLE );
    load = GETRESOURCEIDSTRING( IDS_REPORT_LOAD_EQUAL );
    affinity = GETRESOURCEIDSTRING( IDS_REPORT_AFFINITY_SINGLE );
}




PortsPage::PortsPage(
                 CPropertySheet *psh,
                 NLB_EXTENDED_CLUSTER_CONFIGURATION *pNlbCfg,
                 bool         fIsClusterLevel,
                 ENGINEHANDLE ehCluster OPTIONAL
                 // ENGINEHANDLE ehInterface OPTIONAL
                )

        :
          m_pshOwner(psh),
          m_pNlbCfg( pNlbCfg ),
          m_isClusterLevel( fIsClusterLevel ),
          CPropertyPage(PortsPage::IDD),
          m_sort_column( -1 ),
          m_ehCluster(ehCluster)
          // m_ehInterface(ehInterface)
{}

PortsPage:: ~PortsPage()
{}

void PortsPage::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);

    DDX_Control(pDX, IDC_LIST_PORT_RULE, m_portList);

    DDX_Control(pDX, IDC_BUTTON_ADD, buttonAdd );

    DDX_Control(pDX, IDC_BUTTON_MODIFY, buttonModify );

    DDX_Control(pDX, IDC_BUTTON_DEL, buttonDel );
}

void
PortsPage::OnOK()
{
    TRACE_INFO("%!FUNC! ->");
    CPropertyPage::OnOK();

    mfn_SaveToNlbCfg();

    TRACE_INFO("%!FUNC! <-");
}

BOOL
PortsPage::OnSetActive()
{
    TRACE_INFO("%!FUNC! ->");
    BOOL fRet =  CPropertyPage::OnSetActive();

    if (fRet)
    {
        m_pshOwner->SetWizardButtons(
                PSWIZB_NEXT|
                PSWIZB_BACK |
                // PSWIZB_FINISH|
                // PSWIZB_DISABLEDFINISH|
                0
                );
    }

    TRACE_INFO("%!FUNC! <- returns %lu", fRet);
    return fRet;
}


BOOL
PortsPage::OnKillActive()
{


    TRACE_INFO("%!FUNC! ->");

    BOOL fRet =  CPropertyPage::OnKillActive();

    if (fRet)
    {
        //
        // Save the configuration to the NLB configuration structure
        // that was passed in the constructor of this dialog.
        //
        mfn_SaveToNlbCfg();
    }
    TRACE_INFO("%!FUNC! <- returns %lu", fRet);
    return fRet;
}


BOOL PortsPage::OnWizardFinish( )
/*
    Overwridden virtual function. Will NOT be called if this is not the last page in the wizard!
*/
{
    TRACE_INFO("%!FUNC! ->");
    BOOL fRet = CPropertyPage::OnWizardFinish();
    if (fRet)
    {
        //
        // Save the configuration to the NLB configuration structure
        // that was passed in the constructor of this dialog.
        //
        mfn_SaveToNlbCfg();
    }

    TRACE_INFO("%!FUNC! <- returns %lu", fRet);
    return fRet;
}


BOOL
PortsPage::OnInitDialog()
{
    TRACE_INFO("%!FUNC! ->");

    CPropertyPage::OnInitDialog();

    // Add column headers & form port rule list
    PortListUtils::LoadFromNlbCfg(m_pNlbCfg, REF m_portList, m_isClusterLevel, FALSE);

    int numItems = m_portList.GetItemCount();

    if( numItems > 0 )
    {
        buttonModify.EnableWindow( TRUE );

        buttonDel.EnableWindow( TRUE );

        if( numItems >= CVY_MAX_USABLE_RULES )
        {
            // greater should not happen,
            // but just to be sure.

            buttonAdd.EnableWindow( FALSE );
        }
        else
        {
            buttonAdd.EnableWindow( TRUE );
        }

        // make selection the first item in list.
        //
        m_portList.SetItemState( 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED );
    }
    else
    {
        buttonAdd.EnableWindow( TRUE );

        // disable the edit and remove buttons.
        buttonModify.EnableWindow( FALSE );

        buttonDel.EnableWindow( FALSE );
    }

    if (!m_isClusterLevel)
    {
        //
        // Can't add/remove port rules in the host version.
        //
        buttonAdd.EnableWindow( FALSE );

        buttonDel.EnableWindow( FALSE );
    }

    TRACE_INFO("%!FUNC! <- returns %lu", TRUE);
    return TRUE;
}


void
PortsPage::OnButtonAdd()
{
    PortData portData;

    ClusterPortsDlg clusterPortRuleDialog( portData, this );

    int rc = clusterPortRuleDialog.DoModal();
    if( rc != IDOK )
    {
        return;
    }
    else
    {
        // add this port rule.
        int index = 0;

        // cluster ip address
        LVITEM item;
        item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
        item.iItem = index;
        item.iSubItem = 0;
        item.iImage = 2;
        item.lParam = -1;
        item.pszText = portData.virtual_ip_addr;
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.InsertItem( &item );

        // start port
        item.mask = LVIF_TEXT;
        item.iItem = index;
        item.iSubItem = 1;
        item.pszText = portData.start_port;
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        // end port
        item.mask = LVIF_TEXT;
        item.iItem = index;
        item.iSubItem = 2;
        item.pszText = portData.end_port;
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        // protocol
        item.mask = LVIF_TEXT;
        item.iItem = index;
        item.iSubItem = 3;
        item.pszText = portData.protocol;
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        // mode
        item.mask = LVIF_TEXT;
        item.iItem = index;
        item.iSubItem = 4;
        item.pszText = portData.mode;
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        // priority
        item.mask = LVIF_TEXT;
        item.iItem = index;
        item.iSubItem = 5;
        item.pszText = portData.priority;
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        // load
        item.mask = LVIF_TEXT;
        item.iItem = index;
        item.iSubItem = 6;
        item.pszText = portData.load;
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        // affinity
        item.mask = LVIF_TEXT;
        item.iItem = index;
        item.iSubItem = 7;
        item.pszText = portData.affinity;
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        // check if max port limit reached.
        if( m_portList.GetItemCount() >= CVY_MAX_USABLE_RULES )
        {
            // as max port rule limit reached.
            // disable further additions.
            buttonAdd.EnableWindow( FALSE );

            buttonDel.EnableWindow( TRUE );

            buttonModify.EnableWindow( TRUE );

            buttonDel.SetFocus();
        }
        else
        {
            buttonAdd.EnableWindow( TRUE );
            buttonDel.EnableWindow( TRUE );
            buttonModify.EnableWindow( TRUE );
        }

        // set focus to this item
        m_portList.SetItemState( index, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED );
    }
}

void
PortsPage::OnButtonDel()
{
    // get the current selection.
    POSITION pos = m_portList.GetFirstSelectedItemPosition();
    if( pos == NULL )
    {
        return;
    }

    int index = m_portList.GetNextSelectedItem( pos );

    // delete it.
    m_portList.DeleteItem( index );

    // if this was the last port rule.
    if( m_portList.GetItemCount() == 0 )
    {
        // as no more port rules in list
        // disable modify and remove buttons.
        // also set focus to add button

        buttonAdd.EnableWindow( TRUE );

        buttonModify.EnableWindow( FALSE );

        buttonDel.EnableWindow( FALSE );

        buttonAdd.SetFocus();
    }
    else
    {
        // enable the add, modify button.
        buttonAdd.EnableWindow( TRUE );

        buttonModify.EnableWindow( TRUE );

        buttonDel.EnableWindow( TRUE );

        // make selection the first item in list.
        //
        m_portList.SetItemState( 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED );

    }
}


void
PortsPage::OnButtonModify()
{
    // get the current selection.
    POSITION pos = m_portList.GetFirstSelectedItemPosition();
    if( pos == NULL )
    {
        return;
    }

    int index = m_portList.GetNextSelectedItem( pos );

    PortData portData;

    wchar_t buffer[Common::BUF_SIZE];

    m_portList.GetItemText( index, 0, buffer, Common::BUF_SIZE );
    portData.virtual_ip_addr = buffer;

    m_portList.GetItemText( index, 1, buffer, Common::BUF_SIZE );
    portData.start_port = buffer;

    m_portList.GetItemText( index, 2, buffer, Common::BUF_SIZE );
    portData.end_port = buffer;

    m_portList.GetItemText( index, 3, buffer, Common::BUF_SIZE );
    portData.protocol = buffer;

    m_portList.GetItemText( index, 4, buffer, Common::BUF_SIZE );
    portData.mode = buffer;

    m_portList.GetItemText( index, 5, buffer, Common::BUF_SIZE );
    portData.priority = buffer;

    m_portList.GetItemText( index, 6, buffer, Common::BUF_SIZE );
    portData.load = buffer;

    m_portList.GetItemText( index, 7, buffer, Common::BUF_SIZE );
    portData.affinity = buffer;

    ClusterPortsDlg clusterPortRuleDialog( portData, this, index );

    HostPortsDlg hostPortRuleDialog( portData, m_ehCluster,  this );

    int rc;
    if( m_isClusterLevel == true )
    {
        rc = clusterPortRuleDialog.DoModal();
    }
    else
    {
        rc = hostPortRuleDialog.DoModal();
    }

    if( rc != IDOK )
    {
        return;
    }
    else
    {
        // delete the old item and add the new item.
        // before you delete the old item find its param
        // value
        DWORD key = m_portList.GetItemData( index );
        m_portList.DeleteItem( index );

        // as this is being modified the
        // key remains the old one.

        // start port
        LVITEM item;
        item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
        item.iItem = index;
        item.iSubItem = 0;
        item.iImage = 2;
        item.lParam = key;
        item.pszText = portData.virtual_ip_addr;
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.InsertItem( &item );

        // start port
        item.mask = LVIF_TEXT;
        item.iItem = index;
        item.iSubItem = 1;
        item.pszText = portData.start_port;
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        // end port
        item.mask = LVIF_TEXT;
        item.iItem = index;
        item.iSubItem = 2;
        item.pszText = portData.end_port;
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        // protocol
        item.mask = LVIF_TEXT;
        item.iItem = index;
        item.iSubItem = 3;
        item.pszText = portData.protocol;
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        // mode
        item.mask = LVIF_TEXT;
        item.iItem = index;
        item.iSubItem = 4;
        item.pszText = portData.mode;
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        // priority
        item.mask = LVIF_TEXT;
        item.iItem = index;
        item.iSubItem = 5;
        item.pszText = portData.priority;
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        // load
        item.mask = LVIF_TEXT;
        item.iItem = index;
        item.iSubItem = 6;
        item.pszText = portData.load;
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        // affinity
        item.mask = LVIF_TEXT;
        item.iItem = index;
        item.iSubItem = 7;
        item.pszText = portData.affinity;
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        // set focus to this item
        m_portList.SetItemState( index, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED );
    }
}

void
PortsPage::OnDoubleClick( NMHDR * pNotifyStruct, LRESULT * result )
{
    if( buttonModify.IsWindowEnabled() == TRUE )
    {
        OnButtonModify();
    }
}

void
PortsPage::OnSelchanged( NMHDR * pNotifyStruct, LRESULT * result )
{    
    LPNMLISTVIEW lv = (LPNMLISTVIEW)pNotifyStruct;
    POSITION pos;
    int index;
    
    /* When the user selects a port rule, change the port rule description. */
    if (lv->uChanged & LVIF_STATE) FillPortRuleDescription();
    
    pos = m_portList.GetFirstSelectedItemPosition();

    if (pos == NULL) {
        /* If no port rule is selected, then disable the edit and delete buttons. */
        buttonModify.EnableWindow( FALSE );
        buttonDel.EnableWindow( FALSE );

        return;
    } else {
        /* If one is selected, make sure the edit and delete buttons are enabled. */
        buttonModify.EnableWindow( TRUE );
        buttonDel.EnableWindow( TRUE );
    }

    /* Find the index of the currently selected port rule. */
    index = m_portList.GetNextSelectedItem(pos);

    // if it is not cluster level, which means host level.
    if( m_isClusterLevel == false )
    {
        // initially disable all buttons
        buttonModify.EnableWindow( FALSE );
        buttonAdd.EnableWindow( FALSE );
        buttonDel.EnableWindow( FALSE );

        PortData portData;

        wchar_t buffer[Common::BUF_SIZE];

        m_portList.GetItemText( index, 4, buffer, Common::BUF_SIZE );
        portData.mode = buffer;

        if(  portData.mode != GETRESOURCEIDSTRING( IDS_REPORT_MODE_DISABLED ) )
        {
            buttonModify.EnableWindow( TRUE );
        }
    }
}

/*
 * Method: FillPortRuleDescription
 * Description: Called when the user double clicks an item in the listbox. 
 */
void PortsPage::FillPortRuleDescription ()
{
    CLocalLogger logDesc;
    POSITION pos;
    int index;            
    
    pos = m_portList.GetFirstSelectedItemPosition();

    if (pos == NULL) {
        /* If there is no port rule selected, then display information about how traffic
           not covered by the port rule set is handled. */
        ::SetDlgItemText(m_hWnd, IDC_TEXT_PORT_RULE_DESCR, GETRESOURCEIDSTRING(IDS_PORT_RULE_DEFAULT));
        
        return;
    }

    /* Find the index of the currently selected port rule. */
    index = m_portList.GetNextSelectedItem(pos);
        
    PortData portData;
    wchar_t buffer[Common::BUF_SIZE];
    
    portData.key = m_portList.GetItemData( index );
    
    m_portList.GetItemText( index, 0, buffer, Common::BUF_SIZE );
    portData.virtual_ip_addr = buffer;
    
    m_portList.GetItemText( index, 1, buffer, Common::BUF_SIZE );
    portData.start_port = buffer;
    
    m_portList.GetItemText( index, 2, buffer, Common::BUF_SIZE );
    portData.end_port = buffer;
    
    m_portList.GetItemText( index, 3, buffer, Common::BUF_SIZE );
    portData.protocol = buffer;
    
    m_portList.GetItemText( index, 4, buffer, Common::BUF_SIZE );
    portData.mode = buffer;
    
    m_portList.GetItemText( index, 5, buffer, Common::BUF_SIZE );
    portData.priority = buffer;
    
    m_portList.GetItemText( index, 6, buffer, Common::BUF_SIZE );
    portData.load = buffer;
    
    m_portList.GetItemText( index, 7, buffer, Common::BUF_SIZE );
    portData.affinity = buffer;

    ARRAYSTRCPY(buffer, portData.virtual_ip_addr);
    
    /* This code is terrible - for localization reasons, we require an essentially static string table entry
       for each possible port rule configuration.  So, we have to if/switch ourselves to death trying to 
       match this port rule with the correct string in the table - then we pop in stuff like port ranges. */
    if (portData.virtual_ip_addr == GETRESOURCEIDSTRING(IDS_REPORT_VIP_ALL)) {
        /* No VIP is specified. */
        if (portData.protocol == GETRESOURCEIDSTRING(IDS_REPORT_PROTOCOL_TCP)) {
            /* Rule covers TCP. */
            if (portData.start_port == portData.end_port) {
                /* Rule covers a single port value, not a range. */
                if (portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_DISABLED)) {
                    /* Disabled port rule. */
                    logDesc.Log(IDS_PORT_RULE_ALL_VIP_TCP_PORT_DISABLED, _wtoi(portData.start_port));

                } else if (portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_SINGLE)) {
                    /* Single host filtering (failover) port rule. */
                    logDesc.Log(IDS_PORT_RULE_ALL_VIP_TCP_PORT_SINGLE, _wtoi(portData.start_port));

                } else if (portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_MULTIPLE)) {
                    /* Multiple host filtering (load-balanced) port rule. */
                    if (portData.load == GETRESOURCEIDSTRING(IDS_REPORT_LOAD_EQUAL))
                        /* Equally balanced amongst members. */
                        logDesc.Log(IDS_PORT_RULE_ALL_VIP_TCP_PORT_MULTIPLE_EQUAL, _wtoi(portData.start_port));
                    else
                        /* Unequally balanced amongst members by load weight. */
                        logDesc.Log(IDS_PORT_RULE_ALL_VIP_TCP_PORT_MULTIPLE_UNEQUAL, _wtoi(portData.start_port));

                    if (portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_NONE)) {
                        /* No client affinity. */
                        logDesc.Log(IDS_PORT_RULE_AFFINITY_NONE);

                    } else if (portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_SINGLE)) {
                        /* Single affinity. */
                        logDesc.Log(IDS_PORT_RULE_AFFINITY_SINGLE);

                    } else if (portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_CLASSC)) {
                        /* Class C affinity. */
                        logDesc.Log(IDS_PORT_RULE_AFFINITY_CLASSC);

                    }
                }
            } else {
                /* Rule covers a range of ports. */
                if (portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_DISABLED)) {
                    /* Disabled port rule. */
                    logDesc.Log(IDS_PORT_RULE_ALL_VIP_TCP_PORTS_DISABLED, _wtoi(portData.start_port), _wtoi(portData.end_port));

                } else if (portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_SINGLE)) {
                    /* Single host filtering (failover) port rule. */
                    logDesc.Log(IDS_PORT_RULE_ALL_VIP_TCP_PORTS_SINGLE, _wtoi(portData.start_port), _wtoi(portData.end_port));

                } else if (portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_MULTIPLE)) {
                    /* Multiple host filtering (load-balanced) port rule. */
                    if (portData.load == GETRESOURCEIDSTRING(IDS_REPORT_LOAD_EQUAL))
                        /* Equally balanced amongst members. */
                        logDesc.Log(IDS_PORT_RULE_ALL_VIP_TCP_PORTS_MULTIPLE_EQUAL, _wtoi(portData.start_port), _wtoi(portData.end_port));
                    else
                        /* Unequally balanced amongst members by load weight. */
                        logDesc.Log(IDS_PORT_RULE_ALL_VIP_TCP_PORTS_MULTIPLE_UNEQUAL, _wtoi(portData.start_port), _wtoi(portData.end_port));

                    if (portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_NONE)) {
                        /* No client affinity. */
                        logDesc.Log(IDS_PORT_RULE_AFFINITY_NONE);

                    } else if (portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_SINGLE)) {
                        /* Single affinity. */
                        logDesc.Log(IDS_PORT_RULE_AFFINITY_SINGLE);

                    } else if (portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_CLASSC)) {
                        /* Class C affinity. */
                        logDesc.Log(IDS_PORT_RULE_AFFINITY_CLASSC);

                    }
                }
            }
        } else if (portData.protocol == GETRESOURCEIDSTRING(IDS_REPORT_PROTOCOL_UDP)) {
            /* Rule covers UDP. */
            if (portData.start_port == portData.end_port) {
                /* Rule covers a single port value, not a range. */
                if (portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_DISABLED)) {
                    /* Disabled port rule. */
                    logDesc.Log(IDS_PORT_RULE_ALL_VIP_UDP_PORT_DISABLED, _wtoi(portData.start_port));

                } else if (portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_SINGLE)) {
                    /* Single host filtering (failover) port rule. */
                    logDesc.Log(IDS_PORT_RULE_ALL_VIP_UDP_PORT_SINGLE, _wtoi(portData.start_port));

                } else if (portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_MULTIPLE)) {
                    /* Multiple host filtering (load-balanced) port rule. */
                    if (portData.load == GETRESOURCEIDSTRING(IDS_REPORT_LOAD_EQUAL))
                        /* Equally balanced amongst members. */
                        logDesc.Log(IDS_PORT_RULE_ALL_VIP_UDP_PORT_MULTIPLE_EQUAL, _wtoi(portData.start_port));
                    else
                        /* Unequally balanced amongst members by load weight. */
                        logDesc.Log(IDS_PORT_RULE_ALL_VIP_UDP_PORT_MULTIPLE_UNEQUAL, _wtoi(portData.start_port));

                    if (portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_NONE)) {
                        /* No client affinity. */
                        logDesc.Log(IDS_PORT_RULE_AFFINITY_NONE);

                    } else if (portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_SINGLE)) {
                        /* Single affinity. */
                        logDesc.Log(IDS_PORT_RULE_AFFINITY_SINGLE);

                    } else if (portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_CLASSC)) {
                        /* Class C affinity. */
                        logDesc.Log(IDS_PORT_RULE_AFFINITY_CLASSC);

                    }
                }
            } else {
                /* Rule covers a range of ports. */
                if (portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_DISABLED)) {
                    /* Disabled port rule. */
                    logDesc.Log(IDS_PORT_RULE_ALL_VIP_UDP_PORTS_DISABLED, _wtoi(portData.start_port), _wtoi(portData.end_port));

                } else if (portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_SINGLE)) {
                    /* Single host filtering (failover) port rule. */
                    logDesc.Log(IDS_PORT_RULE_ALL_VIP_UDP_PORTS_SINGLE, _wtoi(portData.start_port), _wtoi(portData.end_port));

                } else if (portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_MULTIPLE)) {
                    /* Multiple host filtering (load-balanced) port rule. */
                    if (portData.load == GETRESOURCEIDSTRING(IDS_REPORT_LOAD_EQUAL))
                        /* Equally balanced amongst members. */
                        logDesc.Log(IDS_PORT_RULE_ALL_VIP_UDP_PORTS_MULTIPLE_EQUAL, _wtoi(portData.start_port), _wtoi(portData.end_port));
                    else
                        /* Unequally balanced amongst members by load weight. */
                        logDesc.Log(IDS_PORT_RULE_ALL_VIP_UDP_PORTS_MULTIPLE_UNEQUAL, _wtoi(portData.start_port), _wtoi(portData.end_port));

                    if (portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_NONE)) {
                        /* No client affinity. */
                        logDesc.Log(IDS_PORT_RULE_AFFINITY_NONE);

                    } else if (portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_SINGLE)) {
                        /* Single affinity. */
                        logDesc.Log(IDS_PORT_RULE_AFFINITY_SINGLE);

                    } else if (portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_CLASSC)) {
                        /* Class C affinity. */
                        logDesc.Log(IDS_PORT_RULE_AFFINITY_CLASSC);

                    }
                }
            }
        } else if (portData.protocol == GETRESOURCEIDSTRING(IDS_REPORT_PROTOCOL_BOTH)) {
            /* Rule covers both TCP and UDP. */
            if (portData.start_port == portData.end_port) {
                /* Rule covers a single port value, not a range. */
                if (portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_DISABLED)) {
                    /* Disabled port rule. */
                    logDesc.Log(IDS_PORT_RULE_ALL_VIP_BOTH_PORT_DISABLED, _wtoi(portData.start_port));

                } else if (portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_SINGLE)) {
                    /* Single host filtering (failover) port rule. */
                    logDesc.Log(IDS_PORT_RULE_ALL_VIP_BOTH_PORT_SINGLE, _wtoi(portData.start_port));
            
                } else if (portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_MULTIPLE)) {
                    /* Multiple host filtering (load-balanced) port rule. */
                    if (portData.load == GETRESOURCEIDSTRING(IDS_REPORT_LOAD_EQUAL))
                        /* Equally balanced amongst members. */
                        logDesc.Log(IDS_PORT_RULE_ALL_VIP_BOTH_PORT_MULTIPLE_EQUAL, _wtoi(portData.start_port));
                    else
                        /* Unequally balanced amongst members by load weight. */
                        logDesc.Log(IDS_PORT_RULE_ALL_VIP_BOTH_PORT_MULTIPLE_UNEQUAL, _wtoi(portData.start_port));

                    if (portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_NONE)) {
                        /* No client affinity. */
                        logDesc.Log(IDS_PORT_RULE_AFFINITY_NONE);

                    } else if (portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_SINGLE)) {
                        /* Single affinity. */
                        logDesc.Log(IDS_PORT_RULE_AFFINITY_SINGLE);

                    } else if (portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_CLASSC)) {
                        /* Class C affinity. */
                        logDesc.Log(IDS_PORT_RULE_AFFINITY_CLASSC);

                    }
                }
            } else {
                /* Rule covers a range of ports. */
                if (portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_DISABLED)) {
                    /* Disabled port rule. */
                    logDesc.Log(IDS_PORT_RULE_ALL_VIP_BOTH_PORTS_DISABLED, _wtoi(portData.start_port), _wtoi(portData.end_port));

                } else if (portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_SINGLE)) {
                    /* Single host filtering (failover) port rule. */
                    logDesc.Log(IDS_PORT_RULE_ALL_VIP_BOTH_PORTS_SINGLE, _wtoi(portData.start_port), _wtoi(portData.end_port));

                } else if (portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_MULTIPLE)) {
                    /* Multiple host filtering (load-balanced) port rule. */
                    if (portData.load == GETRESOURCEIDSTRING(IDS_REPORT_LOAD_EQUAL))
                        /* Equally balanced amongst members. */
                        logDesc.Log(IDS_PORT_RULE_ALL_VIP_BOTH_PORTS_MULTIPLE_EQUAL, _wtoi(portData.start_port), _wtoi(portData.end_port));
                    else
                        /* Unequally balanced amongst members by load weight. */
                        logDesc.Log(IDS_PORT_RULE_ALL_VIP_BOTH_PORTS_MULTIPLE_UNEQUAL, _wtoi(portData.start_port), _wtoi(portData.end_port));

                    if (portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_NONE)) {
                        /* No client affinity. */
                        logDesc.Log(IDS_PORT_RULE_AFFINITY_NONE);

                    } else if (portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_SINGLE)) {
                        /* Single affinity. */
                        logDesc.Log(IDS_PORT_RULE_AFFINITY_SINGLE);

                    } else if (portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_CLASSC)) {
                        /* Class C affinity. */
                        logDesc.Log(IDS_PORT_RULE_AFFINITY_CLASSC);

                    }
                }
            }
        }
    } else {
        /* VIP is specified. */
        if (portData.protocol == GETRESOURCEIDSTRING(IDS_REPORT_PROTOCOL_TCP)) {
            /* Rule covers TCP. */
            if (portData.start_port == portData.end_port) {
                /* Rule covers a single port value, not a range. */
                if (portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_DISABLED)) {
                    /* Disabled port rule. */
                    logDesc.Log(IDS_PORT_RULE_VIP_TCP_PORT_DISABLED, buffer, _wtoi(portData.start_port));

                } else if (portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_SINGLE)) {
                    /* Single host filtering (failover) port rule. */
                    logDesc.Log(IDS_PORT_RULE_VIP_TCP_PORT_SINGLE, buffer, _wtoi(portData.start_port));

                } else if (portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_MULTIPLE)) {
                    /* Multiple host filtering (load-balanced) port rule. */
                    if (portData.load == GETRESOURCEIDSTRING(IDS_REPORT_LOAD_EQUAL))
                        /* Equally balanced amongst members. */
                        logDesc.Log(IDS_PORT_RULE_VIP_TCP_PORT_MULTIPLE_EQUAL, buffer, _wtoi(portData.start_port));
                    else
                        /* Unequally balanced amongst members by load weight. */
                        logDesc.Log(IDS_PORT_RULE_VIP_TCP_PORT_MULTIPLE_UNEQUAL, buffer, _wtoi(portData.start_port));

                    if (portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_NONE)) {
                        /* No client affinity. */
                        logDesc.Log(IDS_PORT_RULE_AFFINITY_NONE);

                    } else if (portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_SINGLE)) {
                        /* Single affinity. */
                        logDesc.Log(IDS_PORT_RULE_AFFINITY_SINGLE);

                    } else if (portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_CLASSC)) {
                        /* Class C affinity. */
                        logDesc.Log(IDS_PORT_RULE_AFFINITY_CLASSC);

                    }
                }
            } else {
                /* Rule covers a range of ports. */
                if (portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_DISABLED)) {
                    /* Disabled port rule. */
                    logDesc.Log(IDS_PORT_RULE_VIP_TCP_PORTS_DISABLED, buffer, _wtoi(portData.start_port), _wtoi(portData.end_port));

                } else if (portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_SINGLE)) {
                    /* Single host filtering (failover) port rule. */
                    logDesc.Log(IDS_PORT_RULE_VIP_TCP_PORTS_SINGLE, buffer, _wtoi(portData.start_port), _wtoi(portData.end_port));

                } else if (portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_MULTIPLE)) {
                    /* Multiple host filtering (load-balanced) port rule. */
                    if (portData.load == GETRESOURCEIDSTRING(IDS_REPORT_LOAD_EQUAL))
                        /* Equally balanced amongst members. */
                        logDesc.Log(IDS_PORT_RULE_VIP_TCP_PORTS_MULTIPLE_EQUAL, buffer, _wtoi(portData.start_port), _wtoi(portData.end_port));
                    else
                        /* Unequally balanced amongst members by load weight. */
                        logDesc.Log(IDS_PORT_RULE_VIP_TCP_PORTS_MULTIPLE_UNEQUAL, buffer, _wtoi(portData.start_port), _wtoi(portData.end_port));

                    if (portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_NONE)) {
                        /* No client affinity. */
                        logDesc.Log(IDS_PORT_RULE_AFFINITY_NONE);

                    } else if (portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_SINGLE)) {
                        /* Single affinity. */
                        logDesc.Log(IDS_PORT_RULE_AFFINITY_SINGLE);

                    } else if (portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_CLASSC)) {
                        /* Class C affinity. */
                        logDesc.Log(IDS_PORT_RULE_AFFINITY_CLASSC);

                    }
                }
            }
        } else if (portData.protocol == GETRESOURCEIDSTRING(IDS_REPORT_PROTOCOL_UDP)) {
            /* Rule covers UDP. */
            if (portData.start_port == portData.end_port) {
                /* Rule covers a single port value, not a range. */
                if (portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_DISABLED)) {
                    /* Disabled port rule. */
                    logDesc.Log(IDS_PORT_RULE_VIP_UDP_PORT_DISABLED, buffer, _wtoi(portData.start_port));

                } else if (portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_SINGLE)) {
                    /* Single host filtering (failover) port rule. */
                    logDesc.Log(IDS_PORT_RULE_VIP_UDP_PORT_SINGLE, buffer, _wtoi(portData.start_port));

                } else if (portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_MULTIPLE)) {
                    /* Multiple host filtering (load-balanced) port rule. */
                    if (portData.load == GETRESOURCEIDSTRING(IDS_REPORT_LOAD_EQUAL))
                        /* Equally balanced amongst members. */
                        logDesc.Log(IDS_PORT_RULE_VIP_UDP_PORT_MULTIPLE_EQUAL, buffer, _wtoi(portData.start_port));
                    else
                        /* Unequally balanced amongst members by load weight. */
                        logDesc.Log(IDS_PORT_RULE_VIP_UDP_PORT_MULTIPLE_UNEQUAL, buffer, _wtoi(portData.start_port));

                    if (portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_NONE)) {
                        /* No client affinity. */
                        logDesc.Log(IDS_PORT_RULE_AFFINITY_NONE);

                    } else if (portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_SINGLE)) {
                        /* Single affinity. */
                        logDesc.Log(IDS_PORT_RULE_AFFINITY_SINGLE);

                    } else if (portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_CLASSC)) {
                        /* Class C affinity. */
                        logDesc.Log(IDS_PORT_RULE_AFFINITY_CLASSC);

                    }
                }
            } else {
                /* Rule covers a range of ports. */
                if (portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_DISABLED)) {
                    /* Disabled port rule. */
                    logDesc.Log(IDS_PORT_RULE_VIP_UDP_PORTS_DISABLED, buffer, _wtoi(portData.start_port), _wtoi(portData.end_port));

                } else if (portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_SINGLE)) {
                    /* Single host filtering (failover) port rule. */
                    logDesc.Log(IDS_PORT_RULE_VIP_UDP_PORTS_SINGLE, buffer, _wtoi(portData.start_port), _wtoi(portData.end_port));

                } else if (portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_MULTIPLE)) {
                    /* Multiple host filtering (load-balanced) port rule. */
                    if (portData.load == GETRESOURCEIDSTRING(IDS_REPORT_LOAD_EQUAL))
                        /* Equally balanced amongst members. */
                        logDesc.Log(IDS_PORT_RULE_VIP_UDP_PORTS_MULTIPLE_EQUAL, buffer, _wtoi(portData.start_port), _wtoi(portData.end_port));
                    else
                        /* Unequally balanced amongst members by load weight. */
                        logDesc.Log(IDS_PORT_RULE_VIP_UDP_PORTS_MULTIPLE_UNEQUAL, buffer, _wtoi(portData.start_port), _wtoi(portData.end_port));

                    if (portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_NONE)) {
                        /* No client affinity. */
                        logDesc.Log(IDS_PORT_RULE_AFFINITY_NONE);

                    } else if (portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_SINGLE)) {
                        /* Single affinity. */
                        logDesc.Log(IDS_PORT_RULE_AFFINITY_SINGLE);

                    } else if (portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_CLASSC)) {
                        /* Class C affinity. */
                        logDesc.Log(IDS_PORT_RULE_AFFINITY_CLASSC);

                    }
                }
            }
        } else if (portData.protocol == GETRESOURCEIDSTRING(IDS_REPORT_PROTOCOL_BOTH)) {
            /* Rule covers both TCP and UDP. */
            if (portData.start_port == portData.end_port) {
                /* Rule covers a single port value, not a range. */
                if (portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_DISABLED)) {
                    /* Disabled port rule. */
                    logDesc.Log(IDS_PORT_RULE_VIP_BOTH_PORT_DISABLED, buffer, _wtoi(portData.start_port));

                } else if (portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_SINGLE)) {
                    /* Single host filtering (failover) port rule. */
                    logDesc.Log(IDS_PORT_RULE_VIP_BOTH_PORT_SINGLE, buffer, _wtoi(portData.start_port));
            
                } else if (portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_MULTIPLE)) {
                    /* Multiple host filtering (load-balanced) port rule. */
                    if (portData.load == GETRESOURCEIDSTRING(IDS_REPORT_LOAD_EQUAL))
                        /* Equally balanced amongst members. */
                        logDesc.Log(IDS_PORT_RULE_VIP_BOTH_PORT_MULTIPLE_EQUAL, buffer, _wtoi(portData.start_port));
                    else
                        /* Unequally balanced amongst members by load weight. */
                        logDesc.Log(IDS_PORT_RULE_VIP_BOTH_PORT_MULTIPLE_UNEQUAL, buffer, _wtoi(portData.start_port));

                    if (portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_NONE)) {
                        /* No client affinity. */
                        logDesc.Log(IDS_PORT_RULE_AFFINITY_NONE);

                    } else if (portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_SINGLE)) {
                        /* Single affinity. */
                        logDesc.Log(IDS_PORT_RULE_AFFINITY_SINGLE);

                    } else if (portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_CLASSC)) {
                        /* Class C affinity. */
                        logDesc.Log(IDS_PORT_RULE_AFFINITY_CLASSC);

                    }
                }
            } else {
                /* Rule covers a range of ports. */
                if (portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_DISABLED)) {
                    /* Disabled port rule. */
                    logDesc.Log(IDS_PORT_RULE_VIP_BOTH_PORTS_DISABLED, buffer, _wtoi(portData.start_port), _wtoi(portData.end_port));

                } else if (portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_SINGLE)) {
                    /* Single host filtering (failover) port rule. */
                    logDesc.Log(IDS_PORT_RULE_VIP_BOTH_PORTS_SINGLE, buffer, _wtoi(portData.start_port), _wtoi(portData.end_port));

                } else if (portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_MULTIPLE)) {
                    /* Multiple host filtering (load-balanced) port rule. */
                    if (portData.load == GETRESOURCEIDSTRING(IDS_REPORT_LOAD_EQUAL))
                        /* Equally balanced amongst members. */
                        logDesc.Log(IDS_PORT_RULE_VIP_BOTH_PORTS_MULTIPLE_EQUAL, buffer, _wtoi(portData.start_port), _wtoi(portData.end_port));
                    else
                        /* Unequally balanced amongst members by load weight. */
                        logDesc.Log(IDS_PORT_RULE_VIP_BOTH_PORTS_MULTIPLE_UNEQUAL, buffer, _wtoi(portData.start_port), _wtoi(portData.end_port));

                    if (portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_NONE)) {
                        /* No client affinity. */
                        logDesc.Log(IDS_PORT_RULE_AFFINITY_NONE);

                    } else if (portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_SINGLE)) {
                        /* Single affinity. */
                        logDesc.Log(IDS_PORT_RULE_AFFINITY_SINGLE);

                    } else if (portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_CLASSC)) {
                        /* Class C affinity. */
                        logDesc.Log(IDS_PORT_RULE_AFFINITY_CLASSC);

                    }
                }
            }
        }
    }
    /* Set the port rule description text. */
    ::SetDlgItemText(m_hWnd, IDC_TEXT_PORT_RULE_DESCR, logDesc.GetStringSafe());
}


BOOL
PortsPage::OnHelpInfo (HELPINFO* helpInfo )
{
    if( helpInfo->iContextType == HELPINFO_WINDOW )
    {
        ::WinHelp( static_cast<HWND> ( helpInfo->hItemHandle ), CVY_CTXT_HELP_FILE, HELP_WM_HELP, (ULONG_PTR ) g_aHelpIDs_IDD_DIALOG_PORTS);
    }

    return TRUE;
}

void
PortsPage::OnContextMenu( CWnd* pWnd, CPoint point )
{
    ::WinHelp( m_hWnd, CVY_CTXT_HELP_FILE, HELP_CONTEXTMENU, (ULONG_PTR ) g_aHelpIDs_IDD_DIALOG_PORTS);
}

void
PortsPage::OnColumnClick( NMHDR * pNotifyStruct, LRESULT * result )
{

    PortListUtils::OnColumnClick((LPNMLISTVIEW) pNotifyStruct,
                                  REF m_portList,
                                      m_isClusterLevel,
                                  REF m_sort_ascending,
                                  REF m_sort_column);

    /* The rule selected has likely changed as a result of the sort, so
       make sure the port rule description is correct. */
    FillPortRuleDescription();
}

void
PortListUtils::OnColumnClick(LPNMLISTVIEW   lv,
                             CListCtrl    & portList,
                             bool           isClusterLevel,
                             bool         & sort_ascending,
                             int          & sort_column)
{
    // get present port rules in list.
    vector<PortsPage::PortData> ports;
    getPresentPorts(REF portList, &ports );

    // sort these port rules depending upon the header which has
    // been clicked.

    switch( lv->iSubItem )
    {
        case 0:
            // user has clicked cluster ip address.
            sort( ports.begin(), ports.end(), comp_vip() );
            break;

        case 1:
            // user has clicked start port.
            sort( ports.begin(), ports.end(), comp_start_port() );
            break;

        case 2:
            // user has clicked end port
            sort( ports.begin(), ports.end(), comp_end_port() );

            break;

        case 3:
            // user has clicked protocol
            sort( ports.begin(), ports.end(), comp_protocol() );
            break;

        case 4:
            // user has clicked mode
            sort( ports.begin(), ports.end(), comp_mode() );
            break;

        case 5:
            // user has clicked priority
            if( isClusterLevel == true )
            {
                sort( ports.begin(), ports.end(), comp_priority_string() );
            }
            else
            {
                sort( ports.begin(), ports.end(), comp_priority_int() );
            }
            break;

        case 6:
            // user has clicked load
            if( isClusterLevel == true )
            {
                sort( ports.begin(), ports.end(), comp_load_string() );
            }
            else
            {
                sort( ports.begin(), ports.end(), comp_load_int() );
            }


            break;

        case 7:
            // user has clicked affinity
            sort( ports.begin(), ports.end(), comp_affinity() );
            break;

        default:
            break;
    }

    /* If we are sorting by the same column we were previously sorting by,
       then we reverse the sort order. */
    if( sort_column == lv->iSubItem )
    {
        sort_ascending = !sort_ascending;
    }
    else
    {
        // default sort is ascending.
        sort_ascending = true;
    }

    sort_column = lv->iSubItem;

    int portIndex;
    int itemCount = portList.GetItemCount();
    for( int index = 0; index < itemCount; ++index )
    {
        if( sort_ascending == true )
        {
            portIndex = index;
        }
        else
        {
            portIndex = ( itemCount - 1 ) - index;
        }

        portList.SetItemData( index, ports[portIndex].key );
        portList.SetItemText( index, 0, ports[portIndex].virtual_ip_addr );
        portList.SetItemText( index, 1, ports[portIndex].start_port );
        portList.SetItemText( index, 2, ports[portIndex].end_port );
        portList.SetItemText( index, 3, ports[portIndex].protocol );
        portList.SetItemText( index, 4, ports[portIndex].mode );
        portList.SetItemText( index, 5, ports[portIndex].priority );
        portList.SetItemText( index, 6, ports[portIndex].load );
        portList.SetItemText( index, 7, ports[portIndex].affinity );
    }

    return;
}


void
PortListUtils::getPresentPorts(CListCtrl &portList, vector<PortsPage::PortData>* ports )
{
    // get all the port rules presently in the list.
    for( int index = 0; index < portList.GetItemCount(); ++index )
    {
        PortsPage::PortData portData;
        wchar_t buffer[Common::BUF_SIZE];

        portData.key = portList.GetItemData( index );

        portList.GetItemText( index, 0, buffer, Common::BUF_SIZE );
        portData.virtual_ip_addr = buffer;

        portList.GetItemText( index, 1, buffer, Common::BUF_SIZE );
        portData.start_port = buffer;

        portList.GetItemText( index, 2, buffer, Common::BUF_SIZE );
        portData.end_port = buffer;

        portList.GetItemText( index, 3, buffer, Common::BUF_SIZE );
        portData.protocol = buffer;

        portList.GetItemText( index, 4, buffer, Common::BUF_SIZE );
        portData.mode = buffer;

        portList.GetItemText( index, 5, buffer, Common::BUF_SIZE );
        portData.priority = buffer;

        portList.GetItemText( index, 6, buffer, Common::BUF_SIZE );
        portData.load = buffer;

        portList.GetItemText( index, 7, buffer, Common::BUF_SIZE );
        portData.affinity = buffer;

        ports->push_back( portData );
    }
}

void
PortListUtils::LoadFromNlbCfg(
    NLB_EXTENDED_CLUSTER_CONFIGURATION * pNlbCfg, 
    CListCtrl                          & portList, 
    bool                                 isClusterLevel,
    bool                                 isDetailsView
)
{
    WLBS_PORT_RULE *pRules = NULL;
    WLBS_REG_PARAMS *pParams = NULL;
    UINT NumRules = 0;
    WBEMSTATUS wStat;
    TRACE_INFO("%!FUNC! ->");

    // the size of columns is equal
    // to core.  Wish there were some defines somewhere.
    //
    if (!isDetailsView) {
        portList.InsertColumn( 0,
                               GETRESOURCEIDSTRING( IDS_HEADER_P_VIP ) ,
                               LVCFMT_LEFT,
                               98 );
        portList.InsertColumn( 1,
                               GETRESOURCEIDSTRING( IDS_HEADER_P_START ) ,
                               LVCFMT_LEFT,
                               42 );
        portList.InsertColumn( 2,
                               GETRESOURCEIDSTRING( IDS_HEADER_P_END ),
                               LVCFMT_LEFT,
                               42 );
        portList.InsertColumn( 3,
                               GETRESOURCEIDSTRING( IDS_HEADER_P_PROTOCOL ),
                               LVCFMT_LEFT,
                               44 );
        portList.InsertColumn( 4,
                               GETRESOURCEIDSTRING( IDS_HEADER_P_MODE ),
                               LVCFMT_LEFT,
                               53 );
        portList.InsertColumn( 5,
                               GETRESOURCEIDSTRING( IDS_HEADER_P_PRIORITY ),
                               LVCFMT_LEFT,
                               43 );
        portList.InsertColumn( 6,
                               GETRESOURCEIDSTRING( IDS_HEADER_P_LOAD ),
                               LVCFMT_LEFT,
                               52 );
        portList.InsertColumn( 7,
                               GETRESOURCEIDSTRING( IDS_HEADER_P_AFFINITY ),
                               LVCFMT_LEFT,
                               50 );
    } else {
        portList.InsertColumn( 0,
                               GETRESOURCEIDSTRING( IDS_HEADER_P_VIP ) ,
                               LVCFMT_LEFT,
                               140 );
        portList.InsertColumn( 1,
                               GETRESOURCEIDSTRING( IDS_HEADER_P_START ) ,
                               LVCFMT_LEFT,
                               75 );
        portList.InsertColumn( 2,
                               GETRESOURCEIDSTRING( IDS_HEADER_P_END ),
                               LVCFMT_LEFT,
                               75 );
        portList.InsertColumn( 3,
                               GETRESOURCEIDSTRING( IDS_HEADER_P_PROTOCOL ),
                               LVCFMT_LEFT,
                               75 );
        portList.InsertColumn( 4,
                               GETRESOURCEIDSTRING( IDS_HEADER_P_MODE ),
                               LVCFMT_LEFT,
                               75 );
        portList.InsertColumn( 5,
                               GETRESOURCEIDSTRING( IDS_HEADER_P_PRIORITY ),
                               LVCFMT_LEFT,
                               75 );
        portList.InsertColumn( 6,
                               GETRESOURCEIDSTRING( IDS_HEADER_P_LOAD ),
                               LVCFMT_LEFT,
                               75 );
        portList.InsertColumn( 7,
                               GETRESOURCEIDSTRING( IDS_HEADER_P_AFFINITY ),
                               LVCFMT_LEFT,
                               75 );
    }

    portList.SetExtendedStyle( portList.GetExtendedStyle() | LVS_EX_FULLROWSELECT );

    wStat =  CfgUtilGetPortRules(&pNlbCfg->NlbParams, &pRules, &NumRules);
    if (FAILED(wStat))
    {
        pRules = NULL;
        TRACE_CRIT("%!FUNC! error 0x%08lx extracting port rules!", wStat);
        goto end;
    }

    for (UINT index = 0; index<NumRules; index++)
    {
        WLBS_PORT_RULE *pRule = &pRules[index];
        LPCWSTR szPriority = GETRESOURCEIDSTRING(IDS_REPORT_EMPTY);
        LPCWSTR szAffinity = szPriority; // empty
        LPCWSTR szLoad = szPriority; // empty
        LPCWSTR szMode = szPriority; // empty

        wchar_t buf[Common::BUF_SIZE];
        wchar_t rgPriority[Common::BUF_SIZE];
        wchar_t rgLoad[Common::BUF_SIZE];

        // vip
        LVITEM item;

        /* Convert "255.255.255.255" to "All" for display purposes. */
        if (!lstrcmpi(pRule->virtual_ip_addr, CVY_DEF_ALL_VIP))
            item.pszText = GETRESOURCEIDSTRING(IDS_REPORT_VIP_ALL);
        else {
            ARRAYSTRCPY(buf, pRule->virtual_ip_addr);
            item.pszText = buf;
        }

        item.mask = LVIF_TEXT | LVIF_PARAM;
        item.iItem = index;
        item.iSubItem = 0;
        item.lParam = pRule->start_port;
        item.cchTextMax = Common::BUF_SIZE;
        portList.InsertItem( &item );

        // start port
        StringCbPrintf( buf, sizeof(buf), L"%d", pRule->start_port);
        item.mask = LVIF_TEXT;
        item.iItem = index;
        item.iSubItem = 1;
        item.pszText = buf;
        item.cchTextMax = Common::BUF_SIZE;
        portList.SetItem( &item );

        // end port
        StringCbPrintf( buf, sizeof(buf), L"%d", pRule->end_port);
        item.mask = LVIF_TEXT;
        item.iItem = index;
        item.iSubItem = 2;
        item.pszText = buf;
        item.cchTextMax = Common::BUF_SIZE;
        portList.SetItem( &item );

        // protocol
        item.mask = LVIF_TEXT;
        item.iItem = index;
        item.iSubItem = 3;
        switch(pRule->protocol)
        {
            case CVY_TCP :
                item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_TCP );
                break;

            case CVY_UDP :
                item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_UDP );
                break;

            default:
                item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_BOTH );
                break;
        }
        item.cchTextMax = Common::BUF_SIZE;
        portList.SetItem( &item );

        // mode
        switch(pRule->mode)
        {

        case CVY_SINGLE:
            szMode = GETRESOURCEIDSTRING(IDS_REPORT_MODE_SINGLE );
            if (!isClusterLevel)
            {
                StringCbPrintf( rgPriority, sizeof(rgPriority), L"%d", pRule->mode_data.single.priority );
                szPriority = rgPriority;
            }
            break;

        case CVY_NEVER:
            szMode = GETRESOURCEIDSTRING(IDS_REPORT_MODE_DISABLED );
            break;

        default: // assume multi
            szMode = GETRESOURCEIDSTRING(IDS_REPORT_MODE_MULTIPLE );
            
            if (isClusterLevel)
            {
                szLoad = GETRESOURCEIDSTRING(IDS_REPORT_EMPTY);
            }
            else
            {
                if (pRule->mode_data.multi.equal_load)
                {
                    szLoad = GETRESOURCEIDSTRING(IDS_REPORT_LOAD_EQUAL);
                }
                else
                {
                    UINT load = pRule->mode_data.multi.load;
                    StringCbPrintf(rgLoad, sizeof(rgLoad), L"%d", load);
                    szLoad = rgLoad;
                }
            }
            switch (pRule->mode_data.multi.affinity)
            {
                case CVY_AFFINITY_SINGLE:
                    szAffinity =GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_SINGLE);
                    break;

                case CVY_AFFINITY_CLASSC:
                    szAffinity =GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_CLASSC);
                    break;

                default: // assume no affinity
                    szAffinity =GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_NONE);
                    break;
            }
            break;
        }

        // mode
        item.mask = LVIF_TEXT;
        item.iItem = index;
        item.iSubItem = 4;
        item.pszText = (LPWSTR) szMode;
        item.cchTextMax = Common::BUF_SIZE;
        portList.SetItem( &item );

        // priority
        item.mask = LVIF_TEXT;
        item.iItem = index;
        item.iSubItem = 5;
        item.pszText = (LPWSTR) szPriority;
        item.cchTextMax = Common::BUF_SIZE;
        portList.SetItem( &item );

        // load
        item.mask = LVIF_TEXT;
        item.iItem = index;
        item.iSubItem = 6;
        item.pszText = (LPWSTR) szLoad;
        item.cchTextMax = Common::BUF_SIZE;
        portList.SetItem( &item );

        // affinity
        item.mask = LVIF_TEXT;
        item.iItem = index;
        item.iSubItem = 7;
        item.pszText = (LPWSTR) szAffinity;
        item.cchTextMax = Common::BUF_SIZE;
        portList.SetItem( &item );

    }

end:

    delete pRules; // can be NULL

    TRACE_INFO("%!FUNC! <-");
}

void
PortsPage::mfn_SaveToNlbCfg(void)
{
    // get present port rules
    vector<PortData> ports;
    PortListUtils::getPresentPorts(m_portList, &ports );
    UINT NumRules = ports.size();
    WLBS_PORT_RULE PortRules[CVY_MAX_USABLE_RULES];

    TRACE_INFO("%!FUNC! ->");

    if (NumRules > CVY_MAX_USABLE_RULES)
    {
        // should't get here, but anyway...
        NumRules = CVY_MAX_USABLE_RULES;
    }

    for( int i = 0; i < NumRules; ++i )
    {
        WLBS_PORT_RULE  PortRule;
        DWORD dwMode;
        ZeroMemory(&PortRule, sizeof(PortRule));

        //
        // mode (multiple/single/disabled)
        //
        {
            if( ports[i].mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_MULTIPLE))
            {
                dwMode = CVY_MULTI;
            }
            else if(ports[i].mode==GETRESOURCEIDSTRING(IDS_REPORT_MODE_SINGLE))
            {
                dwMode = CVY_SINGLE;
            }
            else // assume disabled.
            {
                dwMode = CVY_NEVER;
            }
            PortRule.mode = dwMode;
        }

        //
        // Start and end ports
        //
        {
            PortRule.start_port = _wtoi( ports[i].start_port );

            PortRule.end_port = _wtoi( ports[i].end_port );
        }

        //
        // Protocol
        //
        if (ports[i].protocol==GETRESOURCEIDSTRING(IDS_REPORT_PROTOCOL_TCP))
        {
            PortRule.protocol = CVY_TCP;
        }
        else if(ports[i].protocol==GETRESOURCEIDSTRING(IDS_REPORT_PROTOCOL_UDP))
        {
            PortRule.protocol =  CVY_UDP;
        }
        else // assume both
        {
            PortRule.protocol =  CVY_TCP_UDP;
        }

        // Virtual IP address.  Convert "All" back to an IP address - 255.255.255.255. */
        if (!lstrcmpi(ports[i].virtual_ip_addr, GETRESOURCEIDSTRING(IDS_REPORT_VIP_ALL)))
            ARRAYSTRCPY(PortRule.virtual_ip_addr, CVY_DEF_ALL_VIP);
        else
            ARRAYSTRCPY(PortRule.virtual_ip_addr, ports[i].virtual_ip_addr);

        //
        // mode-specific data.
        //
        if (dwMode == CVY_SINGLE)
        {
             if (m_isClusterLevel)
             {
                //
                // CfgUtilsSetPortRules needs valid port rules, so we fill
                // in an arbitrary but valid value.
                //
                PortRule.mode_data.single.priority = 1;
             }
             else
             {
                PortRule.mode_data.single.priority = _wtoi(ports[i].priority);
             }
        }
        else if (dwMode == CVY_MULTI)
        {


            if (m_isClusterLevel)
            {
                //
                // Set the defaults here ...
                //
                PortRule.mode_data.multi.equal_load = TRUE;
                PortRule.mode_data.multi.load       = CVY_DEF_LOAD;
            }
            else
            {
                if (ports[i].load == GETRESOURCEIDSTRING(IDS_REPORT_LOAD_EQUAL))
                {
                    PortRule.mode_data.multi.equal_load = TRUE;
                    PortRule.mode_data.multi.load = 50;
                }
                else
                {
                    PortRule.mode_data.multi.equal_load = FALSE;
                    PortRule.mode_data.multi.load = _wtoi(ports[i].load);
                }
            }

            if (ports[i].affinity==GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_SINGLE))
            {
                PortRule.mode_data.multi.affinity =  CVY_AFFINITY_SINGLE;
            }
            else if (ports[i].affinity == GETRESOURCEIDSTRING( IDS_REPORT_AFFINITY_CLASSC))
            {
                PortRule.mode_data.multi.affinity =  CVY_AFFINITY_CLASSC;
            }
            else // assume no affinity...
            {
                PortRule.mode_data.multi.affinity =  CVY_AFFINITY_NONE;
            }
        }
        PortRules[i] = PortRule; // struct copy
    }

    WBEMSTATUS wStat;

    wStat = CfgUtilSetPortRules(PortRules, NumRules, &m_pNlbCfg->NlbParams);
    if (FAILED(wStat))
    {
        TRACE_CRIT("%!FUNC!: Could not set port rules -- err=0x%lx!", wStat);
    }

    TRACE_INFO("%!FUNC! <-");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\portspage.h ===
#ifndef PORTSPAGE_H
#define PORTSPAGE_H

#include "stdafx.h"

#include "resource.h"

#include "MNLBUIData.h"

class PortsPage : public CPropertyPage
{
public:
    struct PortData
    {
        PortData();

        DWORD key;

        _bstr_t virtual_ip_addr;
        _bstr_t start_port;
        _bstr_t end_port;
        _bstr_t protocol;
        _bstr_t mode;
        _bstr_t priority;        
        _bstr_t load;
        bool    equal;
        _bstr_t affinity;
    };


    enum
    {
        IDD = IDD_DIALOG_PORTS,
    };

    
    PortsPage(
                 CPropertySheet *psh,
                 NLB_EXTENDED_CLUSTER_CONFIGURATION *pNlbCfg,
                 bool         fIsClusterLevel,
                 ENGINEHANDLE ehCluster OPTIONAL
                 // ENGINEHANDLE ehInterface OPTIONAL
             );

    ~PortsPage();


    // overrides of CPropertyPage
    virtual void OnOK();

    virtual BOOL OnSetActive();

    virtual BOOL OnKillActive();

    virtual BOOL OnInitDialog();

    virtual BOOL OnWizardFinish();

    virtual void DoDataExchange( CDataExchange* pDX );

    afx_msg void OnButtonAdd();

    afx_msg void OnButtonDel();

    afx_msg void OnButtonModify();

    afx_msg void OnDoubleClick( NMHDR * pNotifyStruct, LRESULT * result );

    afx_msg void OnColumnClick( NMHDR * pNotifyStruct, LRESULT * result );

    afx_msg void OnSelchanged( NMHDR * pNotifyStruct, LRESULT * result );

    afx_msg BOOL OnHelpInfo (HELPINFO* helpInfo );

    afx_msg void OnContextMenu( CWnd* pWnd, CPoint point );

    void FillPortRuleDescription ();

    // data members 
    CListCtrl	m_portList;

    CButton     buttonAdd;

    CButton     buttonModify;

    CButton     buttonDel;

    map< long, PortDataX> m_mapPortX;

    bool         m_isClusterLevel;

    _bstr_t      machine;

private:

    CPropertySheet *m_pshOwner;

    bool m_sort_ascending;

    int m_sort_column;

    ENGINEHANDLE m_ehCluster;   // engine handle to cluster (could be NULL)
    // ENGINEHANDLE m_ehInterface; //  engine handle to inteface (could be NULL)

    // The (New) place to get/save config.
    //
    NLB_EXTENDED_CLUSTER_CONFIGURATION *m_pNlbCfg;

    void
    mfn_SaveToNlbCfg(void);
    

    DECLARE_MESSAGE_MAP()

};

class PortListUtils
{
public:
    static void getPresentPorts(CListCtrl &portList, 
                                vector<PortsPage::PortData>* ports );

    static void LoadFromNlbCfg(NLB_EXTENDED_CLUSTER_CONFIGURATION * pNlbCfg, 
                               CListCtrl                          & portList, 
                               bool                                 isClusterLevel,
                               bool                                 isDetailsView
        );

    static void OnColumnClick(LPNMLISTVIEW   lv,
                              CListCtrl    & portList,
                              bool           isClusterLevel,
                              bool         & sort_ascending,
                              int          & sort_column);
};

static DWORD g_aHelpIDs_IDD_DIALOG_PORTS [] = {
    IDC_TEXT_PORT_RULE,           IDC_LIST_PORT_RULE,
    IDC_LIST_PORT_RULE,           IDC_LIST_PORT_RULE,
    IDC_BUTTON_ADD,               IDC_BUTTON_ADD,
    IDC_BUTTON_MODIFY,            IDC_BUTTON_MODIFY,
    IDC_BUTTON_DEL,               IDC_BUTTON_DEL,
    IDC_GROUP_PORT_RULE_DESCR,    IDC_GROUP_PORT_RULE_DESCR,
    IDC_TEXT_PORT_RULE_DESCR,     IDC_GROUP_PORT_RULE_DESCR,
    0, 0
};

class comp_vip
{
public:
    bool operator()( PortsPage::PortData x, PortsPage::PortData y )
        {
            return ( x.virtual_ip_addr < y.virtual_ip_addr );
        }
};

class comp_start_port
{
public:
    bool operator()( PortsPage::PortData x, PortsPage::PortData y )
        {
            return ( _wtoi( x.start_port ) < _wtoi( y.start_port ) );
        }
};

class comp_end_port
{
public:
    bool operator()( PortsPage::PortData x, PortsPage::PortData y )
        {
            return ( _wtoi( x.end_port ) < _wtoi( y.end_port ) );
        }
};

class comp_protocol
{
public:
    bool operator()( PortsPage::PortData x, PortsPage::PortData y )
        {
            return  ( x.protocol  <  y.protocol ); 
        }
};

class comp_mode
{
public:
    bool operator()( PortsPage::PortData x, PortsPage::PortData y )
        {
            return  ( x.mode  <  y.mode ); 
        }
};

class comp_priority_string
{
public:
    bool operator()( PortsPage::PortData x, PortsPage::PortData y )
        {
            return (  x.priority  <  y.priority );
        }
};

class comp_priority_int
{
public:
    bool operator()( PortsPage::PortData x, PortsPage::PortData y )
        {
            return ( _wtoi( x.priority ) < _wtoi( y.priority ) );
        }
};

class comp_load_string
{
public:
    bool operator()( PortsPage::PortData x, PortsPage::PortData y )
        {
            return  ( x.load  <  y.load ); 
        }
};

class comp_load_int
{
public:
    bool operator()( PortsPage::PortData x, PortsPage::PortData y )
        {
            return ( _wtoi( x.load ) < _wtoi( y.load ) );
        }
};


class comp_affinity
{
public:
    bool operator()( PortsPage::PortData x, PortsPage::PortData y )
        {
            return  ( x.affinity  <  y.affinity ); 
        }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\private.h ===
//***************************************************************************
//
//  PRIVATE.H
// 
//  Module: NLB Manager (client-side exe)
//
//  Purpose:  Common include file.
//
//  Copyright (c)2001 Microsoft Corporation, All Rights Reserved
//
//  History:
//
//  07/27/01    JosephJ Created
//
//***************************************************************************
#pragma once

#define BUGFIX334243 1
#define BUGFIX476216 1

#define ASIZE(_array) (sizeof(_array)/sizeof(_array[0]))

#include "utils.h"
#include "engine.h"

class LeftView;
class Document;
class DetailsView;
class LogView;

//
// Fake placeholders for now
//
#define dataSink(_val) (0)
void DummyAction(LPCWSTR szMsg);

extern CNlbEngine gEngine;

#include "MNLBUIData.h"
#include "document.h"
#include "leftview.h"
#include "detailsview.h"
#include "logview.h"
#include "application.h"
#include "resource.h"


//
// Use this to copy to an array (not pointer) destination 
//
#define ARRAYSTRCPY(_dest, _src) \
            StringCbCopy((_dest), sizeof(_dest), (_src))

#define ARRAYSTRCAT(_dest, _src) \
            StringCbCat((_dest), sizeof(_dest), (_src))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\precomp.h ===
#include "stdafx.h"

#include <vector>
#include <algorithm>
using namespace std;

#include <netcfgx.h>
#include <devguid.h>
#include <cfg.h>
#include <wincred.h>

#include <wlbsconfig.h>
#include <nlberr.h>
#include <cfgutil.h>
#include <nlbclient.h>

//
// Used to annotate pass-by-reference arguments in function calls.
//
#define REF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	nlbmanager1.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information
#include "precomp.h"
#pragma hdrstop

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDR_MAINFRAME                   101
#define IDI_WORLD                       102
#define IDI_CLUSTER                     103
#define IDI_HOST_STARTED                104
#define IDI_HOST_STOPPED                105
#define IDI_HOST_UNREACHABLE            106
#define IDR_POPUP                       108
#define IDD_ABOUT                       109
#define IDD_CLUSTER_PAGE                113
#define IDD_HOST_PAGE                   114
#define IDI_PORTRULE                    119
#define IDI_PENDING                     123
#define IDI_MYWARNING                   128
#define IDI_MYERROR                     129
#define IDI_MYINFORMATIONAL             130
#define IDI_EXCLEM                      131
#define IDI_CLOCK                       133
#define IDI_ICON1                       134
#define IDI_CLUSTER_PENDING             135
#define IDI_CLUSTER_BROKEN              136
#define IDI_HOST_PENDING                137
#define IDI_HOST_STARTED2               138
#define IDI_HOST_MISCONFIGURED          139
#define IDI_HOST_UNKNOWN                140
#define IDI_HOST_OK                     141
#define IDI_CLUSTER_OK                  142
#define IDI_QUESTION2                   144
#define IDI_HOURGLASS                   145
#define IDI_CLUSTERS                    150
#define IDI_HOST_CONVERGING             151
#define IDI_HOST_SUSPENDED              152
#define IDI_HOST_DRAINING               153
#define IDI_HOST_DISCONNECTED           154
#define IDD_CLUSTER_CLUSTER             533
#define IDD_HOST_PORTS                  535
#define IDD_CLUSTER_PORTS               536
#define IDD_MANAGE_VIRTUAL_IPS_PAGE     538
#define IDD_DIALOG_PORTS                540
#define IDD_DIALOG_PORT_RULE_PROP_HOSTS 541
#define IDD_DIALOG_PORT_RULE_PROP_CLUSTER 542
#define IDD_PORTS_CONTROL_PAGE          543
#define IDD_DIALOG_CONNECT2             545
#define IDD_DIALOG_LOGSETTINGS          547
#define IDD_DIALOG_CLUSTER_IPS          548
#define IDD_PORTS_CTRL                  549
#define IDD_DIALOG_LOG_DETAILS          550
#define IDD_DIALOG_DETAILSVIEW          551
#define IDD_DIALOG_IP_ADDRESS           552

/* The controls for the cluster properties page. */
#define IDC_GROUP_CL_IP                 1000
#define IDC_TEXT_CL_IP                  1001
#define IDC_EDIT_CL_IP                  1002
#define IDC_TEXT_CL_MASK                1003
#define IDC_EDIT_CL_MASK                1004
#define IDC_TEXT_DOMAIN                 1005
#define IDC_EDIT_DOMAIN                 1006
#define IDC_TEXT_ETH                    1007
#define IDC_EDIT_ETH                    1008
#define IDC_GROUP_CL_MODE               1009
#define IDC_RADIO_UNICAST               1010
#define IDC_RADIO_MULTICAST             1011
#define IDC_CHECK_IGMP                  1012
#define IDC_GROUP_RCT                   1013
#define IDC_CHECK_RCT                   1014
#define IDC_TEXT_PASSW                  1015
#define IDC_EDIT_PASSW                  1016
#define IDC_TEXT_PASSW2                 1017
#define IDC_EDIT_PASSW2                 1018
#define IDC_BUTTON_HELP                 1019

#define IDC_CLUSTER_MEMBER              1023
#define IDC_VIRTUAL_IP                  1025
#define IDC_ADD_VIP                     1026
#define IDC_VIP_LIST                    1027
#define IDC_REMOVE_VIP                  1028
#define IDC_SCROLLBAR1                  1031
#define IDC_GROUP_NIC                   1035
#define IDC_TEXT_CLUSTER_IP             1036
#define IDC_TEXT_MACHINE_IP             1037
#define IDC_TEXT_MACHINE_IP_LIST        1038
#define IDC_TEXT_CONNECTION_STATUS      1039
#define IDC_TEXT_CLUSTER_MEMBER         1040
#define IDC_TEXT_MACHINE                1042
#define IDC_TEXT_SECONDARY_IP           1043
#define IDC_TEXT_SECONDARY_IP_LIST      1044
#define IDC_BUTTON_OK                   1047
#define IDC_BUTTON_CANCEL               1048
#define IDC_BUTTON_CONNECT              1049
#define IDC_BUTTON_CREDENTIALS          1050
#define IDC_LIST_INTERFACES             1051
#define IDC_GROUP_CONNECTION_STATUS     1052
#define IDC_TEXT_HOSTADDRESS            1053
#define IDC_TEXT_PASSWORD               1054
#define IDC_TEXT_USERNAME               1055
#define IDC_CHECK_CREDENTIALS           1057
#define IDC_TEXT_LOGSETTINGS            1060
#define IDC_CHECK_LOGSETTINGS           1061
#define IDC_TEXT_LOGFILENAME            1062
#define IDC_EDIT_LOGFILENAME            1063
#define IDC_EDIT_PRIMARY_IP             1064
#define IDC_TEXT_PRIMARY_IP             1065
#define IDC_GROUP_ADDITIONAL_VIPS       1066
#define IDC_LIST_ADDITIONAL_VIPS        1067
#define IDC_BUTTON_MODIFY_VIP           1068
#define IDC_BUTTON_ADD_VIP              1069
#define IDC_BUTTON_REMOVE_VIP           1070
#define IDC_GROUP_LOGSETTINGS           1071
#define IDC_TEXT_INTERFACES             1072
#define IDC_TEXT_CONNECT_DESCRIPTION    1073
#define IDC_EDIT_HOSTADDRESS            1074

/*
    The following are reserved for context-sensitive help.
   They are related to the corresponding IDs without the "EX":
    IDC_EDIT_HOSTADDRESS IDC_BUTTON_CONNECT IDC_LIST_INTERFACES

    Do not use them for any controls.
*/
#define IDC_EDIT_HOSTADDRESSEX          1076
#define IDC_BUTTON_CONNECTEX            1077
#define IDC_LIST_INTERFACESEX           1078

/* The following are used for Port Control operations */

#define IDC_BUTTON_ENABLE               1079
#define IDC_BUTTON_DISABLE              1080
#define IDC_BUTTON_DRAIN                1081
#define IDC_OPER_STATUS_BOX             1082
#define IDC_OPER_STATUS_TEXT            1083

#define IDC_GROUP_PRIMARY_IP            1084
#define IDC_TEXT_PRIMARY_MASK           1085
#define IDC_EDIT_PRIMARY_MASK           1086

/* The controls for the host properties page. */
#define IDC_TEXT_PRI                    2000
#define IDC_EDIT_PRI                    2001
#define IDC_GROUP_DED_IP                2003
#define IDC_TEXT_DED_IP                 2004
#define IDC_EDIT_DED_IP                 2005
#define IDC_TEXT_DED_MASK               2006
#define IDC_EDIT_DED_MASK               2007
#define IDC_COMBOBOX_DEFAULT_STATE      2008
#define IDC_TEXT_DEFAULT_STATE          2009
#define IDC_GROUP_INITIAL_HOST_STATE    2010
#define IDC_CHECK_PERSIST_SUSPEND       2011

/* The controls for the port rules page. */
#define IDC_TEXT_PORT_RULE              3000
#define IDC_LIST_PORT_RULE              3001
#define IDC_BUTTON_ADD                  3002
#define IDC_BUTTON_MODIFY               3003
#define IDC_BUTTON_DEL                  3004
#define IDC_GROUP_PORT_RULE_DESCR       3005
#define IDC_TEXT_PORT_RULE_DESCR        3006

/* The controls for the port rule properties page. */
#define IDC_GROUP_RANGE                 4000
#define IDC_EDIT_START                  4001
#define IDC_SPIN_START                  4002
#define IDC_EDIT_END                    4003
#define IDC_SPIN_END                    4004
#define IDC_GROUP_PROTOCOLS             4005
#define IDC_RADIO_TCP                   4006
#define IDC_RADIO_UDP                   4007
#define IDC_RADIO_BOTH                  4008
#define IDC_GROUP_SINGLE                4009
#define IDC_GROUP_MULTIPLE              4010
#define IDC_GROUP_DISABLED              4011
#define IDC_RADIO_SINGLE                4012
#define IDC_RADIO_MULTIPLE              4013
#define IDC_RADIO_DISABLED              4014
#define IDC_TEXT_AFF                    4015
#define IDC_RADIO_AFF_NONE              4016
#define IDC_RADIO_AFF_SINGLE            4017
#define IDC_RADIO_AFF_CLASSC            4018
#define IDC_TEXT_MULTI                  4019
#define IDC_EDIT_MULTI                  4020
#define IDC_SPIN_MULTI                  4021
#define IDC_CHECK_EQUAL                 4022
#define IDC_TEXT_SINGLE                 4023
#define IDC_EDIT_SINGLE                 4024
#define IDC_SPIN_SINGLE                 4025
#define IDC_TEXT_START                  4026
#define IDC_TEXT_END                    4027
#define IDC_GROUP_PORT_RULE_VIP         4028
#define IDC_EDIT_PORT_RULE_VIP          4029
#define IDC_CHECK_PORT_RULE_ALL_VIP     4030

#define IDC_TEXT_IP_ADDRESS             4031
#define IDC_EDIT_IP_ADDRESS             4032
#define IDC_TEXT_SUBNET_MASK            4033
#define IDC_EDIT_SUBNET_MASK            4034

#define IDC_STATIC_ABOUT_WARNING        4050
#define IDS_ABOUT_WARNING               4051

/* The following are used for the Log Details view dialog */
#define IDC_EDIT_LOGDETAIL              1500
#define IDC_TEXT_LOGDETAIL_EVENT        1501
#define IDC_TEXT_LOGDETAIL_EVENT1       1502
#define IDC_TEXT_LOGDETAIL_DATE         1503
#define IDC_TEXT_LOGDETAIL_DATE1        1504
#define IDC_TEXT_LOGDETAIL_TIME         1505
#define IDC_TEXT_LOGDETAIL_TIME1        1506
#define IDC_TEXT_LOGDETAIL_CLUSTER      1507
#define IDC_TEXT_LOGDETAIL_CLUSTER1     1508
#define IDC_TEXT_LOGDETAIL_HOST         1509
#define IDC_TEXT_LOGDETAIL_HOST1        1510
#define IDC_TEXT_LOGDETAIL_INTERFACE    1511
#define IDC_TEXT_LOGDETAIL_INTERFACE1   1512
#define IDC_TEXT_LOGDETAIL_DESCRIPTION  1513
#define IDC_TEXT_LOGDETAIL_DESCRIPTION1 1514
#define IDC_TEXT_LOGDETAIL_DETAILS      1515

/* The following are used for the Details View (right view) dialog */
#define IDC_LIST_DETAILS                1600
#define IDC_TEXT_DETAILS_CAPTION        1601

#define ID_WORLD_NEW                    40001
#define ID_WORLD_CONNECT                40003
#define ID_REFRESH_DIRECT               40005
#define ID_REFRESH_INDIRECT             40006
#define ID_REFRESH                      40007
#define ID_HELP_TOPICS                  40009
#define ID_CLUSTER_ADD_HOST             40016
#define ID_CLUSTER_REMOVE               40017
#define ID_CLUSTER_PROPERTIES           40018
#define ID_CLUSTER_UNMANAGE             40019
#define ID_CLUSTER_EXE_QUERY            40020
#define ID_CLUSTER_EXE_START            40021
#define ID_CLUSTER_EXE_STOP             40022
#define ID_CLUSTER_EXE_DRAINSTOP        40023
#define ID_CLUSTER_EXE_SUSPEND          40024
#define ID_CLUSTER_EXE_RESUME           40025
#define ID_CLUSTER_EXE_ENABLE           40026
#define ID_CLUSTER_EXE_DISABLE          40027
#define ID_CLUSTER_EXE_DRAIN            40028
#define ID_CLUSTER_EXE_PORT_CONTROL     40029
#define ID_CLUSTER_MANAGE_VIPS          40030
#define ID_VIEW_STATUSBAR               40042
#define ID_OPTIONS_CREDENTIALS          40048
#define ID_OPTIONS_LOGSETTINGS          40049
#define ID_FILE_LOAD_HOSTLIST           40050
#define ID_FILE_SAVE_HOSTLIST           40051
#define ID_HOST_REMOVE                  40130
#define ID_HOST_PROPERTIES              40131
#define ID_HOST_EXE_QUERY               40132
#define ID_HOST_EXE_START               40133
#define ID_HOST_EXE_STOP                40134
#define ID_HOST_EXE_DRAINSTOP           40135
#define ID_HOST_EXE_SUSPEND             40136
#define ID_HOST_EXE_RESUME              40137
#define ID_HOST_EXE_ENABLE              40138
#define ID_HOST_EXE_DISABLE             40139
#define ID_HOST_EXE_DRAIN               40140
#define ID_HOST_EXE_PORT_CONTROL        40141
#define ID_HOST_STATUS                  40142
#define IDS_WORLD_NAME                  41040
#define IDS_PROPERTIES_CAPTION          41041
#define IDS_FULL_INTERNET_NAME          41042
#define IDS_INFO_DONE                   41143
#define IDS_INFO_SUCCESS                41144
#define IDS_INFO_FAILED                 41145
#define IDS_INFO_REQUEST                41146
#define IDS_INFO_NEW_EXCEPTION          41147
#define IDS_INFO_FINDING_P              41246
#define IDS_INFO_FINDING_CL             41247
#define IDS_INFO_FINDING_H              41248
#define IDS_INFO_FINDING_CL_P           41249
#define IDS_INFO_FINDING_H_P            41250
#define IDS_INFO_FINDING_P_ELB          41251
#define IDS_INFO_FINDING_P_ULB          41252
#define IDS_INFO_FINDING_P_D            41253
#define IDS_INFO_FINDING_P_F            41254
#define IDS_INFO_MODIFYING_P            41354
#define IDS_INFO_MODIFYING_CL_P         41355
#define IDS_INFO_MODIFYING_H_P          41356
#define IDS_INFO_MODIFYING_P_ELB        41357
#define IDS_INFO_MODIFYING_P_ULB        41358
#define IDS_INFO_MODIFYING_P_F          41359
#define IDS_INFO_MODIFYING_P_D          41360
#define IDS_INFO_MODIFYING_CN           41361
#define IDS_INFO_MODIFYING_CP_AND_ADD_IP 41362
#define IDS_INFO_CONNECTING             41446
#define IDS_INFO_ENABLING_PORTS         41447  
#define IDS_INFO_DISABLING_PORTS        41448
#define IDS_INFO_DRAINING_PORTS         41449
#define IDS_INFO_NEWLINE                41540
#define IDS_INFO_LINE_SEPARATOR         41541
#define IDS_INFO_ADDING_CL_IP           41650
#define IDS_INFO_REMOVING_CL_IP         41651
#define IDS_INFO_BINDING_NLB            41750
#define IDS_INFO_UNBINDING_NLB          41751
#define IDS_WLBS_OK                     41850
#define IDS_WLBS_DRAIN_STOP             41851
#define IDS_WLBS_BAD_PARAMS             41852
#define IDS_WLBS_NOT_FOUND              41853
#define IDS_WLBS_STOPPED                41854
#define IDS_WLBS_CONVERGING             41855
#define IDS_WLBS_CONVERGED              41856
#define IDS_WLBS_DEFAULT                41857
#define IDS_WLBS_DRAINING               41858
#define IDS_WLBS_SUSPENDED              41859
#define IDS_WLBS_REBOOT                 41860
#define IDS_WLBS_INIT_ERROR             41861
#define IDS_WLBS_BAD_PASSW              41862
#define IDS_WLBS_IO_ERROR               41863
#define IDS_WLBS_TIMEOUT                41864
#define IDS_WLBS_PORT_OVERLAP           41865
#define IDS_WLBS_BAD_PORT_PARAMS        41866
#define IDS_WLBS_MAX_PORT_RULES         41867
#define IDS_WLBS_TRUNCATED              41868
#define IDS_WLBS_REG_ERROR              41869
#define IDS_WLBS_ALREADY                41870
#define IDS_COMMAND_QUERY               41880
#define IDS_COMMAND_START               41881
#define IDS_COMMAND_STOP                41882
#define IDS_COMMAND_DRAINSTOP           41883
#define IDS_COMMAND_RESUME              41884
#define IDS_COMMAND_SUSPEND             41885
#define IDS_COMMAND_ENABLE              41886
#define IDS_COMMAND_DISABLE             41887
#define IDS_COMMAND_DRAIN               41888
#define IDS_WLBS_UNKNOWN                41899
#define IDS_MACHINE_LIST_EMPTY          41947
#define IDS_MACHINE_ALREADY             41948
#define IDS_CLUSTER_ALREADY             41949
#define IDS_HOST_ALREADY                41950
#define IDS_HOST_ADDING                 41951
#define IDS_CLUSTER_MAX                 41952
#define IDS_NIC_BOUND                   41953
#define IDS_NIC_UNBOUND                 41954
#define IDS_HEADER_C_IP                 42100
#define IDS_HEADER_C_SUBNET             42101
#define IDS_HEADER_INTERNET_NAME        42102
#define IDS_HEADER_MAC_ADDRESS          42103
#define IDS_HEADER_C_MODE               42104
#define IDS_HEADER_REMOTE_CTRL          42105
#define IDS_HEADER_MACHINE              42199
#define IDS_HEADER_D_IP                 42200
#define IDS_HEADER_D_SUBNET             42201
#define IDS_HEADER_PRIORITY             42202
#define IDS_HEADER_INITIAL_STATE        42203
#define IDS_HEADER_NIC                  42204
#define IDS_HEADER_P_START              42250
#define IDS_HEADER_P_END                42251
#define IDS_HEADER_P_PROTOCOL           42252
#define IDS_HEADER_P_MODE               42253
#define IDS_HEADER_P_LOAD               42254
#define IDS_HEADER_P_AFFINITY           42255
#define IDS_HEADER_P_PRIORITY           42256
#define IDS_HEADER_P_VIP                42257
#define IDS_HEADER_LOG_TYPE             42275
#define IDS_HEADER_LOG_DATE             42276
#define IDS_HEADER_LOG_TIME             42277
#define IDS_HEADER_LOG_CLUSTER          42278
#define IDS_HEADER_LOG_HOST             42279
#define IDS_HEADER_LOG_TEXT             42280
#define IDS_HEADER_IFLIST_CLUSTERNAME   42290
#define IDS_HEADER_IFLIST_CLUSTERIP     42291
#define IDS_HEADER_IFLIST_IFNAME        42292
#define IDS_HEADER_IFLIST_IFIP          42293
#define IDS_REPORT_MULTICAST            42300
#define IDS_REPORT_UNICAST              42301
#define IDS_REPORT_IGMP                 42302
#define IDS_REPORT_ON                   42303
#define IDS_REPORT_OFF                  42304
#define IDS_REPORT_PROTOCOL_TCP         42305
#define IDS_REPORT_PROTOCOL_UDP         42306
#define IDS_REPORT_PROTOCOL_BOTH        42307
#define IDS_REPORT_LOAD_EQUAL           42308
#define IDS_REPORT_LOAD_UNEQUAL         42309
#define IDS_REPORT_MODE_MULTIPLE        42310
#define IDS_REPORT_MODE_SINGLE          42311
#define IDS_REPORT_MODE_DISABLED        42312
#define IDS_REPORT_AFFINITY_SINGLE      42313
#define IDS_REPORT_AFFINITY_NONE        42314
#define IDS_REPORT_AFFINITY_CLASSC      42315
#define IDS_REPORT_EMPTY                42316
#define IDS_REPORT_NA                   42317
#define IDS_REPORT_VIP_ALL              42318

#define IDS_HEADER_VIPLIST_NETWORKADDRESS 42350
#define IDS_WARNING_CLUSTER_REMOVE      42400
#define IDS_WARNING_HOST_REMOVE         42401
#define IDS_VIRTUAL_IPS_CAPTION         42402
#define IDS_CONNECT_CAPTION             42403
#define IDS_CONNECT_CLUSTER_CAPTION     42404
#define IDS_WARNING_IP_INVALID          42405
#define IDS_WARNING_CL_CONN_SAME        42406
#define IDS_CONNECT_NEW_CAPTION         42500
#define IDS_CONNECT_NEW_HINT            42501
#define IDS_CONNECT_NEW_LIST_TXT        42502
#define IDS_CONNECT_EXISTING_CAPTION    42503
#define IDS_CONNECT_EXISTING_HINT       42504
#define IDS_CONNECT_EXISTING_LIST_TXT   42505
#define IDS_CONNECT_ADD_HOST_CAPTION    42506
#define IDS_CONNECT_ADD_HOST_HINT       42507
#define IDS_CONNECT_ADD_HOST_LIST_TXT   42508
#define IDS_CONNECT_NO_NICS_NEW_CLUSTER 42509
#define IDS_CONNECT_NO_NICS_EXISTING_CLUSTER 42510
#define IDS_CONNECT_SELECT_NICS_ERROR   42511
#define IDC_NIC_FRIENDLY                52010
#define IDC_LIST                        53020
#define IDC_EDIT_PRIORITY               53038
#define IDC_SPIN_PRIORITY               53039
#define IDC_EDIT_LOAD                   53040
#define IDC_SPIN_LOAD                   53041
#define IDC_EDIT_LIST_TITLE             53070
#define IDC_CLUSTER_IP                  55001
#define IDC_ADD_MACHINE                 56002
#define IDC_ADVANCED                    56003
#define IDC_NOT_ADVANCED                56004
#define IDC_DEL_MACHINE                 56005
#define IDC_SECONDARY_IP                56006
#define IDC_SECONDARY_IP_LIST           56007
#define IDC_TEXT_START_PORT             56100
#define IDC_PORTS                       56101
#define IDS_PARM_PASSWORD               57001
#define IDS_PARM_IGMP_MCAST             57002
#define IDS_PARM_IGMP_WARN              57003
#define IDS_PARM_WARN                   57004
#define IDS_PARM_ERROR                  57005
#define IDS_PARM_CL_IP_BLANK            57006
#define IDS_PARM_CL_NM_BLANK            57007
#define IDS_PARM_INVAL_CL_IP            57008
#define IDS_PARM_INVAL_CL_MASK          57009
#define IDS_PARM_CL_IP_FIELD            57010
#define IDS_PARM_CL_NM_FIELD            57011
#define IDS_PARM_IP_CONFLICT            57012
#define IDS_PARM_INVAL_MAC              57013
#define IDS_PARM_RCT_WARN               57014
#define IDS_PARM_DIP_MISCONFIG          57015
#define IDS_PARM_DED_IP_BLANK           57016
#define IDS_PARM_DED_NM_BLANK           57017
#define IDS_PARM_INVAL_DED_IP           57018
#define IDS_PARM_INVAL_DED_MASK         57019
#define IDS_PARM_VIP_BLANK              57020
#define IDS_PARM_DIP_CONFLICT_VIP       57022
#define IDS_PARM_INVAL_VIRTUAL_IP       57023
#define IDS_PARM_PORT_BLANK             57100
#define IDS_PARM_LOAD_BLANK             57101
#define IDS_PARM_PORT_VAL               57102
#define IDS_PARM_LOAD                   57103
#define IDS_PARM_RULES                  57104
#define IDS_PARM_RANGE                  57105
#define IDS_PARM_OVERLAP                57106
#define IDS_PORTS_ALL                   57107
#define IDS_PORTS_CONTROL_NONE          57108
#define IDS_INVAL_DHCP_NIC              57109
#define IDS_INVAL_DIP                   57110
#define IDS_BOTTOM_PANE_TITLE           57112
#define IDS_REFRESH_CLUSTER             57113
#define IDS_CANTRUN_NONICS_TEXT         57200
#define IDS_CANTRUN_NONICS_CAPTION      57201
#define IDS_ERROR_BLANK_USERNAME        57202

#define IDS_LOG_BEGIN_HOST_UPDATE      57300
#define IDS_LOG_END_HOST_UPDATE        57301
#define IDS_LOG_SKIP_INTERFACE_UPDATE_ON_ERROR 57302
#define IDS_LOG_WAITING_FOR_PENDING_OPERATION 57303
#define IDS_LOG_FINAL_STATUS_FAILED     57304
#define IDS_LOG_FINAL_STATUS_SUCCEEDED  57305

#define IDS_HOST_STATE_STARTED          57306
#define IDS_HOST_STATE_STOPPED          57307
#define IDS_HOST_STATE_SUSPENDED        57308
#define IDS_FILE_OPEN_FAILED            57309
#define IDS_LOG_FILE_OPEN_FAILED        57310
#define IDS_CONNECT_TO_HOST_FAILED      57311
#define IDS_CRITICAL_ERROR_HOST         57312
#define IDS_LOADFILE_LOOKING_FOR_CLUSTERS 57313
#define IDS_LOG_BEGIN_LOADING_FROM_FILE 57314
#define IDS_LOG_PING_FAILED             57315
#define IDS_LOG_COULD_NOT_GET_IF_CONFIG 57316
#define IDS_LOG_CANT_UPDATE_BAD_PARAMS  57317
#define IDS_LOG_INTERFACE_MISCONFIGURATION  57318
#define IDS_LOG_DEDICATED_IP_ON_OTHER_INTERFACE 57319
#define IDS_LOG_DETAILS_HINT            57320
#define IDS_LOG_FINAL_STATUS_FAILED_NOGEN     57321
#define IDS_HOST_STATE_UNREACHABLE      57322
#define IDS_HOST_STATE_PENDING          57323
#define IDS_HOST_STATE_MISCONFIGURED    57324
#define IDS_STATE_NLB_NOT_BOUND         57325

/* String table entries for the port rule descriptions. */
#define IDS_PORT_RULE_DEFAULT                             57400
#define IDS_PORT_RULE_ALL_VIP_TCP_PORT_DISABLED           57401
#define IDS_PORT_RULE_ALL_VIP_TCP_PORT_SINGLE             57402
#define IDS_PORT_RULE_ALL_VIP_TCP_PORT_MULTIPLE_EQUAL     57403
#define IDS_PORT_RULE_ALL_VIP_TCP_PORT_MULTIPLE_UNEQUAL   57404
#define IDS_PORT_RULE_ALL_VIP_TCP_PORTS_DISABLED          57405
#define IDS_PORT_RULE_ALL_VIP_TCP_PORTS_SINGLE            57406
#define IDS_PORT_RULE_ALL_VIP_TCP_PORTS_MULTIPLE_EQUAL    57407
#define IDS_PORT_RULE_ALL_VIP_TCP_PORTS_MULTIPLE_UNEQUAL  57408
#define IDS_PORT_RULE_ALL_VIP_UDP_PORT_DISABLED           57409
#define IDS_PORT_RULE_ALL_VIP_UDP_PORT_SINGLE             57410
#define IDS_PORT_RULE_ALL_VIP_UDP_PORT_MULTIPLE_EQUAL     57411
#define IDS_PORT_RULE_ALL_VIP_UDP_PORT_MULTIPLE_UNEQUAL   57412
#define IDS_PORT_RULE_ALL_VIP_UDP_PORTS_DISABLED          57413
#define IDS_PORT_RULE_ALL_VIP_UDP_PORTS_SINGLE            57414
#define IDS_PORT_RULE_ALL_VIP_UDP_PORTS_MULTIPLE_EQUAL    57415
#define IDS_PORT_RULE_ALL_VIP_UDP_PORTS_MULTIPLE_UNEQUAL  57416
#define IDS_PORT_RULE_ALL_VIP_BOTH_PORT_DISABLED          57417
#define IDS_PORT_RULE_ALL_VIP_BOTH_PORT_SINGLE            57418
#define IDS_PORT_RULE_ALL_VIP_BOTH_PORT_MULTIPLE_EQUAL    57419
#define IDS_PORT_RULE_ALL_VIP_BOTH_PORT_MULTIPLE_UNEQUAL  57420
#define IDS_PORT_RULE_ALL_VIP_BOTH_PORTS_DISABLED         57421
#define IDS_PORT_RULE_ALL_VIP_BOTH_PORTS_SINGLE           57422
#define IDS_PORT_RULE_ALL_VIP_BOTH_PORTS_MULTIPLE_EQUAL   57423
#define IDS_PORT_RULE_ALL_VIP_BOTH_PORTS_MULTIPLE_UNEQUAL 57424
#define IDS_PORT_RULE_VIP_TCP_PORT_DISABLED               57431
#define IDS_PORT_RULE_VIP_TCP_PORT_SINGLE                 57432
#define IDS_PORT_RULE_VIP_TCP_PORT_MULTIPLE_EQUAL         57433
#define IDS_PORT_RULE_VIP_TCP_PORT_MULTIPLE_UNEQUAL       57434
#define IDS_PORT_RULE_VIP_TCP_PORTS_DISABLED              57435
#define IDS_PORT_RULE_VIP_TCP_PORTS_SINGLE                57436
#define IDS_PORT_RULE_VIP_TCP_PORTS_MULTIPLE_EQUAL        57437
#define IDS_PORT_RULE_VIP_TCP_PORTS_MULTIPLE_UNEQUAL      57438
#define IDS_PORT_RULE_VIP_UDP_PORT_DISABLED               57439
#define IDS_PORT_RULE_VIP_UDP_PORT_SINGLE                 57440
#define IDS_PORT_RULE_VIP_UDP_PORT_MULTIPLE_EQUAL         57441
#define IDS_PORT_RULE_VIP_UDP_PORT_MULTIPLE_UNEQUAL       57442
#define IDS_PORT_RULE_VIP_UDP_PORTS_DISABLED              57443
#define IDS_PORT_RULE_VIP_UDP_PORTS_SINGLE                57444
#define IDS_PORT_RULE_VIP_UDP_PORTS_MULTIPLE_EQUAL        57445
#define IDS_PORT_RULE_VIP_UDP_PORTS_MULTIPLE_UNEQUAL      57446
#define IDS_PORT_RULE_VIP_BOTH_PORT_DISABLED              57447
#define IDS_PORT_RULE_VIP_BOTH_PORT_SINGLE                57448
#define IDS_PORT_RULE_VIP_BOTH_PORT_MULTIPLE_EQUAL        57449
#define IDS_PORT_RULE_VIP_BOTH_PORT_MULTIPLE_UNEQUAL      57450
#define IDS_PORT_RULE_VIP_BOTH_PORTS_DISABLED             57451
#define IDS_PORT_RULE_VIP_BOTH_PORTS_SINGLE               57452
#define IDS_PORT_RULE_VIP_BOTH_PORTS_MULTIPLE_EQUAL       57453
#define IDS_PORT_RULE_VIP_BOTH_PORTS_MULTIPLE_UNEQUAL     57454
#define IDS_PORT_RULE_AFFINITY_NONE                       57455
#define IDS_PORT_RULE_AFFINITY_SINGLE                     57456
#define IDS_PORT_RULE_AFFINITY_CLASSC                     57457


// Generic Strings
#define IDS_EMPTY_STRING                 57458
#define IDS_UNKNOWN                      57459


// "Operation" Strings
#define IDS_COMMAND_QUERY_PORT           57460

// "Operation result" strings
#define IDS_SUCCESS_AND_COMMA            57470
#define IDS_SUCCESS_AND_NOTE             57471
#define IDS_FAILURE_AND_CAUSE            57472

// "Cluster/Port State" strings
#define IDS_HOST_STATE                   57473
#define IDS_PORT_RULE_STATE              57474

// All Vip
#define IDS_ALL_VIP_DESCR                57475

// "Note" Strings
#define IDS_HOST_ALREADY_STATE           57476
#define IDS_PORT_ALREADY_STATE           57477
#define IDS_ALREADY_STOPPED              57478
#define IDS_DRAIN_STOP                   57479
#define IDS_HOST_STOPPED                 57480

// "Cause" Strings
#define IDS_HOST_SUSPENDED               57481
#define IDS_BAD_PARAMS                   57482
#define IDS_NOT_FOUND                    57483
#define IDS_DISCONNECTED                 57484
#define IDS_BAD_PASSWORD                 57485
#define IDS_FAILURE                      57486
#define IDS_REFUSED                      57487
#define IDS_IO_ERROR                     57488

// "Cluster State" Strings
#define IDS_STATE_CONVERGING             57489  
#define IDS_STATE_CONVERGED              57490
#define IDS_STATE_CONVERGED_DRAINING     57491

// "Port State" Strings
#define IDS_PORT_RULE_NOT_FOUND          57492
#define IDS_PORT_RULE_ENABLED            57493
#define IDS_PORT_RULE_DISABLED           57494
#define IDS_PORT_RULE_DRAINING           57495

// Other strings
#define IDS_ALREADY                      57496

// "Operation" operation result : "Operation result" "Cluster/Port State"
#define IDS_LOG_CONTROL_CLUSTER          57497

//
// More strings...
//
#define IDS_PING_FAILED                 57501
#define IDS_HOSTLIST_FILE_FILTER        57502
#define IDS_CLUSTER                     57503
#define IDS_HOST                        57504 
#define IDS_USAGE_MESSAGE               57505
#define IDS_USAGE_TITLE                 57506
#define IDS_DEMO_MESSAGE                57507
#define IDS_DEMO_TITLE                  57508
#define IDS_INVALID_IP_OR_SUBNET        57509
#define IDS_INVALID_INFORMATION         57510
#define IDS_CONNECT_STATUS_CONNECTING   57511
#define IDS_CONNECT_STATUS_CONNECTED    57512
#define IDS_CONNECT_UNABLE_TO_CONNECT   57513
#define IDS_SPECIFY_MACHINE_CREDS       57514
#define IDS_CONNECT_NO_INTERFACE_SELECTED           57515
#define IDS_CONNECT_SELECT_AN_INTERFACE             57516
#define IDS_CONNECT_UNABLE_TO_PROCEED               57517
#define IDS_CONNECT_UNABLE_TO_PROCEEED_INTERNAL     57518
#define IDS_CONNECT_MSG_IF_ALREADY_BOUND            57519
#define IDS_CONNECT_CAP_IF_ALREADY_BOUND            57520
#define IDS_CONNECT_MSG_INTERFACE_ALREADY_MANAGED   57521
#define IDS_DETAILS_CLUSTER_DESCRIPTION     57522
#define IDS_DETAILS_COL_HOST                57523
#define IDS_DETAILS_COL_STATUS              57524
#define IDS_DETAILS_COL_DIP                 57525
#define IDS_DETAILS_COL_DIPMASK             57526
#define IDS_DETAILS_COL_PRIORITY            57527
#define IDS_DETAILS_COL_INIT_STATE          57528
#define IDS_DETAILS_COL_CLUSTER_NAME        57529
#define IDS_DETAILS_COL_CIP                 57530
#define IDS_DETAILS_COL_CIPMASK             57531
#define IDS_DETAILS_COL_CMODE               57532
#define IDS_DETAILS_RCT_STATUS              57533
#define IDS_DETAILS_HOST_STATE_STARTED      57534
#define IDS_DETAILS_HOST_STATE_STOPPED      57535
#define IDS_DETAILS_HOST_STATE_SUSPENDED    57536
#define IDS_DETAILS_HOST_STATE_UNKNOWN      57537
#define IDS_DETAILS_PERSIST_SUSPEND         57538
#define IDS_DETAILS_HOST_CM_UNICAST         57539
#define IDS_DETAILS_HOST_CM_IGMP            57540
#define IDS_DETAILS_HOST_CM_MULTI           57541
#define IDS_DETAILS_HOST_RCT_ENABLED        57542
#define IDS_DETAILS_HOST_RCT_DISABLED       57543
#define IDS_DETAILS_PORT_CAPTION            57544

#define IDS_LOG_COULD_NOT_PING_HOST             57545
#define IDS_LOG_COULD_NOT_READ_IF_CONFIG        57546
#define IDS_LOG_FAILED_UPDATE                   57547
#define IDS_LOG_CONFIG_CONFLICTS_WITH_OTHER     57548
#define IDS_LOG_CLUSTER_MODE_DIFFERS            57549
#define IDS_LOG_CLUSTER_MULTICAST_MODE_DIFFERS  57550
#define IDS_LOG_CIP_DIFFERS                     57551
#define IDS_LOG_CIPMASK_DIFFERS                 57552
#define IDS_LOG_DOMAIN_NAME_DIFFERS             57553
#define IDS_LOG_RCT_DIFFERS                     57554
#define IDS_LOG_RCT_PWD_DIFFERS                 57555
#define IDS_LOG_CANT_EXTRACT_PORTRULES          57556
#define IDS_LOG_CANT_EXTRACT_OTHER_PORT_RULES   57557
#define IDS_LOG_PORT_RULE_COUNT_DIFFERS         57558
#define IDS_LOG_PORT_RULE_CIP_DIFFERS           57559
#define IDS_LOG_PORT_RULE_START_DIFFERS         57560
#define IDS_LOG_PORT_RULE_END_DIFFERS           57561
#define IDS_LOG_PORT_RULE_PROT_DIFFERS          57562
#define IDS_LOG_PORT_RULE_MODE_DIFFERS          57563
#define IDS_LOG_PORT_RULE_AFFINITY_DIFFERS      57564
#define IDS_LOG_PORT_RULE_PRIORITY_CONFLICT     57565
#define IDS_LOG_DIP_CONFLICT                    57566
#define IDS_LOG_HOST_PRIORITY_CONFLICT          57567

#define IDS_HOST_DISCONNECTED                   57568
#define IDS_HOST_DRAINING                       57569
#define IDS_HOST_STATE_UNKNOWN                  57570

#define IDS_HOST_STATUS_CAPTION                 57571
#define IDS_HOST_STATUS_SUMMARY                 57572
#define IDS_DEFAULT_CREDS_MSG                   57573
#define IDS_DEFAULT_CREDS_CAP                   57574
#define IDS_FILEERR_INVALID_PATH_CAP            57575
#define IDS_FILEERR_INVALID_PATH_MSG            57576
#define IDS_FILEERR_LOGGING_NOT_STARTED         57577
#define IDS_LOGFILE_NOT_ENABLED                 57578
#define IDS_LOGFILE_NOT_SPECIFIED               57579
#define IDS_LOGFILE_TOO_LONG                    57580
#define IDS_LOGFILE_IO_ERROR                    57581
#define IDS_LOGFILE_REG_ERROR                   57582
#define IDS_LOGFILE_UNKNOWN_ERROR               57583
#define IDS_FILEERR_CANT_SAVE_TO_REG            57584
#define IDS_FILEERR_CANT_DISABLE_LOGGING        57585
#define IDS_LOG_NLBMANAGER_STARTED              57586
#define IDS_LOGTYPE_INFORMATION                 57587
#define IDS_LOG_ENTRY_DETAILS                   57588

#define IDS_LOG_DATE                            57589
#define IDS_LOG_TIME                            57590
#define IDS_CLIENT_IDENTIFICATION               57591
#define IDS_LOG_INVALID_CLUSTER_SPECIFICATION   57592
#define IDS_LOG_RESOURCE_ALLOCATION_FAILURE     57593
#define IDS_LOG_INVALID_CIP                     57594
#define IDS_LOG_CIP_MISSING_FROM_TCPIP          57595
#define IDS_LOG_CIP_SUBNET_MASK_MISMATCH        57596
#define IDS_LOG_CIP_EQUAL_DIP                   57597
#define IDS_LOG_DIP_MISSING_FROM_TCPIP          57598
#define IDS_LOG_DIP_NOT_FIRST_IN_TCPIP          57599
#define IDS_LOG_DIP_SUBNET_MASK_MISMATCH        57600
#define IDS_LOG_VIP_NOT_IN_TCPIP                57601
#define IDS_LOG_PORTVIP_MATCHES_DIP             57602

#define IDS_LOG_ADDED_IPADDR_HEADER             57603
#define IDS_LOG_ADDED_IPADDR                    57604
#define IDS_LOG_REMOVED_IPADDR_HEADER           57605
#define IDS_LOG_REMOVE_IPADDR                   57606
#define IDS_LOG_MODIFIED_IPADDR_HEADER          57607
#define IDS_LOG_MODIFIED_IPADDR                 57608
#define IDS_CONFIRM_CLUSTER_PROPS_CHANGE        57609
#define IDS_LOG_MODIFIED_CLUSTER_NAME           57610
#define IDS_LOG_MODIFIED_TRAFFIC_MODE           57611
#define IDS_LOG_MODIFIED_RCT                    57612
#define IDS_LOG_NEW_RCT_PWD                     57613
#define IDS_CLUSTER_PROPS_CHANGE_MSG_HDR        57614
#define IDS_CLUSTER_PROPS_CHANGE_MSG_SUFFIX     57615
#define IDS_CONFIRM_CLUSTER_CONTROL_MSG         57616
#define IDS_CONFIRM_CLUSTER_CONTROL_CAP         57617
#define IDS_CANT_CHANGE_DIP_MSG                 57618
#define IDS_NEW_DIP_CONFLICTS_WITH_XXX          57619
#define IDS_NEW_CIP_CONFLICTS_WITH_XXX          57620
#define IDS_CLUSTER_XXX                         57621
#define IDS_INTERFACE_XXX                       57622
#define IDS_CIP_CONFLICTS_WITH_RAW_INTERFACE    57623
#define IDS_PARM_WARNING                        57624
#define IDS_LOG_PENDING_OPERATION               57625
#define IDS_LOG_OPERATION_PENDING_ON_INTERFACE  57626
#define IDS_LOG_OPERATION_PENDING_ON_CLUSTER    57627
#define IDS_CANT_UPDATE_CLUSTER_PROPS_MSG       57628
#define IDS_CANT_UPDATE_CLUSTER_PROPS_CAP       57629
#define IDS_CANT_UPDATE_HOST_PROPS_MSG          57630
#define IDS_CANT_UPDATE_HOST_PROPS_CAP          57631
#define IDS_CANT_DELETE_HOST_MSG                57632
#define IDS_CANT_DELETE_HOST_CAP                57633
#define IDS_LOG_UPDATE_INTERFACE_OPERATION_DESCRIPTION 57634
#define IDS_LOG_REFRESH_INTERFACE               57635

#define IDS_DETAILS_ROOT_DESCRIPTION            57636
#define IDS_CANT_USE_DHCP_NIC_MSG               57637
#define IDS_HEADER_VIPLIST_IP_ADDRESS           57641
#define IDS_HEADER_VIPLIST_SUBNET_MASK          57642
#define IDS_CANT_CREATE_NEW_CLUSTER_MSG         57643
#define IDS_CANT_CREATE_NEW_CLUSTER_CAP         57644
#define IDS_CANT_ADD_HOST_MSG                   57645
#define IDS_CANT_ADD_HOST_CAP                   57646
#define IDS_LOG_UPDATE_CLUSTER_OPERATION_DESCRIPTION 57647
#define IDS_CANT_DELETE_CLUSTER_MSG             57648
#define IDS_CANT_DELETE_CLUSTER_CAP             57649
#define IDS_LOG_PENDING_OPERATIONS_ON_EXIT_CAP  57650
#define IDS_LOG_PENDING_OPERATIONS_ON_EXIT_MSG  57651
#define IDS_LOG_CONTROL_INTERFACE               57652
#define IDS_LOG_CONTROL_CLUSTER_OPERATION_DESCRIPTION  57653
#define IDS_LOG_ERRORS_DETECTED_DURING_MODE_CHANGE 57654
#define IDS_LOG_ADD_CLUSTER_MEMBERS_OPERATION_DESCRIPTION 57655
#define IDS_DBG_LOG_ADD_CLUSTER_MEMBER   57656
#define IDS_LOGFILE_FILE_TOO_LARGE       57657
#define IDS_LOGFILE_FILE_TOO_LARGE_DETAILS  57658
#define IDS_LOG_TRIMMING_LOG_ENTRIES  57659
#define IDS_REMOVE_DEAD_HOST                57660


#define IDS_ERROR_ACCESS_DENIED                 57700
#define IDS_ERROR_NLB_NOT_FOUND                 57701
#define IDS_ERROR_CODE                          57702
#define IDS_ERROR_INVALID_LOCAL_CREDENTIALS     57703

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        152
#define _APS_NEXT_COMMAND_VALUE         40053
#define _APS_NEXT_CONTROL_VALUE         1084
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__4ABADA68_E961_4E94_80C9_36FC8222478E__INCLUDED_)
#define AFX_STDAFX_H__4ABADA68_E961_4E94_80C9_36FC8222478E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afx.h>
#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxcview.h>
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 ...
#include <comdef.h>
#include <wbemidl.h>
#include <string>
#include <vector>
#include <map>
#include <set>
#include <winsock2.h>
#include <memory>

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <iostream>
#include <strsafe.h>

using namespace std;

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__4ABADA68_E961_4E94_80C9_36FC8222478E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\vipspage.cpp ===
//***************************************************************************
//
//  VIPSPAGE.CPP
// 
//  Module: NLB Manager
//
//  Purpose: Implements VipsPage, which is a dialog for managing the list
//           of cluster ip addresses.
//
//  Copyright (c)2001 Microsoft Corporation, All Rights Reserved
//
//  History:
//
//  09/24/01    JosephJ Created
//  01/22/2002  SHouse cleaned up this dialog 
//
//***************************************************************************
#include "precomp.h"
#pragma hdrstop
#include "private.h"
#include "vipspage.h"
#include "vipspage.tmh"


// BEGIN_MESSAGE_MAP( VipsPage, CDialog )

BEGIN_MESSAGE_MAP( VipsPage, CPropertyPage )

    ON_BN_CLICKED(IDC_BUTTON_ADD_VIP, OnButtonAdd)
    ON_BN_CLICKED(IDC_BUTTON_MODIFY_VIP, OnButtonEdit)
    ON_BN_CLICKED(IDC_BUTTON_REMOVE_VIP, OnButtonRemove)
    ON_NOTIFY(NM_DBLCLK, IDC_LIST_ADDITIONAL_VIPS, OnDoubleClick)

    ON_WM_HELPINFO()        
    ON_WM_CONTEXTMENU()        
    ON_NOTIFY( LVN_ITEMCHANGED, IDC_LIST_ADDITIONAL_VIPS, OnSelchanged )

    //
    // Other options...
    //
    // ON_EN_SETFOCUS(IDC_EDIT_HOSTADDRESS,OnSetFocusEditHostAddress)
    // ON_WM_ACTIVATE()
    // ON_NOTIFY( NM_DBLCLK, IDC_LIST_ADDITONAL_VIPS, OnDoubleClick )
    // ON_NOTIFY( LVN_COLUMNCLICK, IDC_LIST_ADDITONAL_VIPS, OnColumnClick )
    //

END_MESSAGE_MAP()


//
// Static help-id maps
//

DWORD
VipsPage::s_HelpIDs[] =
{
    IDC_GROUP_PRIMARY_IP,      IDC_EDIT_PRIMARY_IP,
    IDC_TEXT_PRIMARY_IP,       IDC_EDIT_PRIMARY_IP,
    IDC_EDIT_PRIMARY_IP,       IDC_EDIT_PRIMARY_IP,
    IDC_TEXT_PRIMARY_MASK,     IDC_EDIT_PRIMARY_IP,
    IDC_EDIT_PRIMARY_MASK,     IDC_EDIT_PRIMARY_IP,
    IDC_GROUP_ADDITIONAL_VIPS, IDC_LIST_ADDITIONAL_VIPS,
    IDC_LIST_ADDITIONAL_VIPS,  IDC_LIST_ADDITIONAL_VIPS,
    IDC_BUTTON_ADD_VIP,        IDC_BUTTON_ADD_VIP,
    IDC_BUTTON_MODIFY_VIP,     IDC_BUTTON_MODIFY_VIP,
    IDC_BUTTON_REMOVE_VIP,     IDC_BUTTON_REMOVE_VIP,
    0, 0
};


VipsPage::VipsPage(
           CPropertySheet *psh,
           NLB_EXTENDED_CLUSTER_CONFIGURATION *pNlbCfg,
           BOOL fClusterView,
           CWnd* parent
           )
        :
        CPropertyPage(IDD),
        m_pshOwner(psh),
        m_pNlbCfg(pNlbCfg),
        m_fClusterView(fClusterView),
        m_fModified(FALSE),
        m_uPrimaryClusterIp(0)
{

}

void
VipsPage::DoDataExchange( CDataExchange* pDX )
{  
	// CDialog::DoDataExchange(pDX);
	CPropertyPage::DoDataExchange(pDX);

    DDX_Control(pDX, IDC_LIST_ADDITIONAL_VIPS, listAdditionalVips);

    //
    // Note: the buttons are handled by the ON_BN_CLICKED macro
    // above.
    //
    // DDX_Control(pDX, IDC_BUTTON_CONNECT, buttonConnect);
    // DDX_Control(pDX, IDC_BUTTON_CREDENTIALS, credentialsButton);
}


BOOL
VipsPage::OnInitDialog()
{
    BOOL fRet = CPropertyPage::OnInitDialog();

    if (fRet)
    {
        CWnd *pItem = NULL;

        // Initialize the list control
        mfn_InitializeListView();
    
        mfn_LoadFromNlbCfg();

        /* Disable the Delete button. */
        pItem = GetDlgItem(IDC_BUTTON_REMOVE_VIP);
        if (pItem)
        {
            ::EnableWindow (pItem->m_hWnd, FALSE);
        }

        /* Disable the Edit button. */
        pItem = GetDlgItem(IDC_BUTTON_MODIFY_VIP);
        if (pItem)
        {
            ::EnableWindow (pItem->m_hWnd, FALSE);
        }        

        /* Enable the Add button only if we're showing cluster 
           properties; otherwise its read-only, disable it. */
        pItem = GetDlgItem(IDC_BUTTON_ADD_VIP);
        if (pItem)
        {
            ::EnableWindow (pItem->m_hWnd, m_fClusterView);
        }        

        /* Disable the primary IP address dialog. */
        pItem = GetDlgItem(IDC_EDIT_PRIMARY_IP);
        if (pItem)
        {
            ::EnableWindow (pItem->m_hWnd, FALSE);
        }        

        /* Disable the primary IP subnet mask dialog */
        pItem = GetDlgItem(IDC_EDIT_PRIMARY_MASK);
        if (pItem)
        {
            ::EnableWindow (pItem->m_hWnd, FALSE);
        }        
    }

    return fRet;
}


BOOL
VipsPage::OnHelpInfo (HELPINFO* helpInfo )
{
    if( helpInfo->iContextType == HELPINFO_WINDOW )
    {
        ::WinHelp( static_cast<HWND> ( helpInfo->hItemHandle ), 
                   CVY_CTXT_HELP_FILE, 
                   HELP_WM_HELP, 
                   (ULONG_PTR ) s_HelpIDs);
    }

    return TRUE;
}


void
VipsPage::OnContextMenu( CWnd* pWnd, CPoint point )
{
    ::WinHelp( m_hWnd, 
               CVY_CTXT_HELP_FILE, 
               HELP_CONTEXTMENU, 
               (ULONG_PTR ) s_HelpIDs);
}

BOOL
VipsPage::OnKillActive()
{
    // validate data

    mfn_SaveToNlbCfg();

    return TRUE;
}

void
VipsPage::mfn_InitializeListView(void)
//
// Set the columns on the list box based on the type of dialog
//
{
    RECT rect;
    INT colWidth;
    CWnd * List = GetDlgItem(IDC_LIST_ADDITIONAL_VIPS);

    List->GetClientRect(&rect);

    colWidth = (rect.right - rect.left)/2;

    //
    // The interface list is that of interfaces already bound to NLB.
    // we display the cluster dnsname and ip first, then adapter name.
    //
    listAdditionalVips.InsertColumn(
             0, 
             GETRESOURCEIDSTRING( IDS_HEADER_VIPLIST_IP_ADDRESS),
             LVCFMT_LEFT, 
             colWidth);

    listAdditionalVips.InsertColumn(
             1, 
             GETRESOURCEIDSTRING( IDS_HEADER_VIPLIST_SUBNET_MASK),
             LVCFMT_LEFT, 
             colWidth);

    //
    // Allow entire row to be selected.
    //
    listAdditionalVips.SetExtendedStyle(listAdditionalVips.GetExtendedStyle() | LVS_EX_FULLROWSELECT );
}

void
VipsPage::mfn_InsertNetworkAddress(
        LPCWSTR szIP,
        LPCWSTR szSubnetMask,
        UINT lParam,
        int nItem
)
{
    LVFINDINFO Info;
    int eItem;
    
    ZeroMemory(&Info, sizeof(Info));
    
    Info.flags = LVFI_PARAM;
    Info.lParam = lParam;

    eItem = listAdditionalVips.FindItem(&Info);

    /* If we found an entry that already has this IP address, we
       need to do some extra work to resolve the duplicate entry. */
    if (eItem != -1) {
        /* If this is an Add operation, then we should simple usurp
           this entry in the list and re-use it for this IP.  If a 
           user tries to add an IP address that already exists, we'll
           in effect change it to a modify operation in the case that
           the subnet mask has changed; otherwise its a no-op. */
        if (nItem == -1) {
            /* Change nItem to eItem to usurp the existing list entry
               for this new IP address entry. */
            nItem = eItem;

        /* Otherwise, if this is already an edit operation, then what
           what actually need to do is both turn this operation into 
           an edit on the existing entry we found for this IP address,
           but further, we need to delete the item we were actually in
           the process of editing, as it was the user's intention to
           get rid of that IP address. */
        } else if (eItem != nItem) {
            /* Delete the list entry we're "editing". */
            listAdditionalVips.DeleteItem(nItem);

            /* Change nItem to eItem to usurp the existing list entry
               for this new IP address entry. */
            nItem = eItem;
        }
    }

    /* An index of -1 indicates a new item to list.  If the index is NOT
       -1, then we're dealing with changes to an existing list item. */
    if (nItem != -1) {

        listAdditionalVips.SetItemText(nItem, 0, szIP);
        listAdditionalVips.SetItemText(nItem, 1, szSubnetMask);
        
    /* Otherwise, insert a new item. */
    } else {

        nItem = listAdditionalVips.GetItemCount();

        /* Add the IP address. */
        listAdditionalVips.InsertItem(
            LVIF_TEXT | LVIF_PARAM, // nMask
            nItem,                  // nItem
            szIP,
            0,                      // nState
            0,                      // nStateMask
            0,                      // nImage
            lParam                  // lParam
            );
        
        /* Add the subnet mask. */
        listAdditionalVips.SetItemText(nItem, 1, szSubnetMask);
    }

    /* Select the new or modified rule. */
    listAdditionalVips.SetItemState(nItem, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);

    return;
}

void VipsPage::OnOK()
{
    mfn_SaveToNlbCfg();
    CPropertyPage::OnOK();
}

void VipsPage::OnButtonAdd() 
/*
    User has clicked the "Add" button.
    2. Switch cursor to hourglass, connect, switch back from hourglass.
*/
{
    LPWSTR szIPAddress = NULL;
    LPWSTR szSubnetMask = NULL;
    
    /* Create a dialog to add a new VIP.  Initialize with empty strings 
       (or NULL) since this is an Add operation. */
    CIPAddressDialog pIPDlg(L"", L"");
    
    /* Show the dialog box.  If the user presses "OK", update the VIP list, otherwise ignore it. */
    if (pIPDlg.DoModal() == IDOK) {
        WCHAR szMungedIpAddress[WLBS_MAX_CL_IP_ADDR+1];
        WCHAR szDefaultSubnetMask[WLBS_MAX_CL_NET_MASK+1];
        WCHAR szConcatenatedIPandMask[WLBS_MAX_CL_IP_ADDR + WLBS_MAX_CL_NET_MASK + 2];
        LPWSTR szNewIPAddress = NULL;
        LPWSTR szNewSubnetMask = NULL;
        UINT uClusterIp = 0;
        UINT uSubnetMask = 0;
        UINT uDefaultSubnetMask = 0;

        /* Get the IP address and subnet mask the user typed into the dialog. 
           Note that the dialog allocates the memory for us and we're required
           to free it when we're done. */
        szIPAddress = pIPDlg.GetIPAddress();
        szSubnetMask = pIPDlg.GetSubnetMask();

        /* Cat the IP address and subnetmask for verification by CfgUtilsValidateNetworkAddress. */
        StringCbPrintf(
            szConcatenatedIPandMask,
            sizeof(szConcatenatedIPandMask),
            L"%ls/%ls", szIPAddress, szSubnetMask
            );

        //
        // Validate the network address -- if failure, put up msg box.
        // TODO: call extended validation function.
        //
        {
            WBEMSTATUS wStat;
            
            wStat = CfgUtilsValidateNetworkAddress(
                szConcatenatedIPandMask,
                &uClusterIp,
                &uSubnetMask,
                &uDefaultSubnetMask
                );
            
            if (!FAILED(wStat))
            {
                //
                // Add some more checks...
                //
                UINT u = uClusterIp&0xff;
                if (u<1 || u>=224)
                {
                    wStat = WBEM_E_CRITICAL_ERROR;
                }
            }
            
            if (FAILED(wStat))
            {
                ::MessageBox(
                    NULL,
                    GETRESOURCEIDSTRING(IDS_INVALID_IP_OR_SUBNET),
                    GETRESOURCEIDSTRING(IDS_INVALID_INFORMATION),
                    MB_ICONINFORMATION   | MB_OK
                    );
                goto end;
            }
            
            //
            // Can't add the primary cluster vip.
            //
            if (uClusterIp == m_uPrimaryClusterIp)
            {
                goto end;
            }
        }
        
        if (*szSubnetMask == 0)
        {
            // subnet mask was not specified -- substitute default.
            uSubnetMask = uDefaultSubnetMask;
        }

        //
        // Change subnet to canonical form...
        //
        {
            LPBYTE pb = (LPBYTE) &uSubnetMask;
            StringCbPrintf(
                szDefaultSubnetMask,
                sizeof(szDefaultSubnetMask),
                L"%lu.%lu.%lu.%lu",
                pb[0], pb[1], pb[2], pb[3]
                );
            szNewSubnetMask = szDefaultSubnetMask;
        }

        //
        // Change IP to canonical form
        //
        {
            LPBYTE pb = (LPBYTE) &uClusterIp;
            StringCbPrintf(
                szMungedIpAddress,
                sizeof(szMungedIpAddress),
                L"%lu.%lu.%lu.%lu",
                pb[0], pb[1], pb[2], pb[3]
                );
            szNewIPAddress = szMungedIpAddress;
        }
        
        //
        // mfn_InsertNetworkAddress will make sure it's inserted in the 
        // proper location and will not insert it if it's a duplicate.
        //
        mfn_InsertNetworkAddress(szNewIPAddress, szNewSubnetMask, uClusterIp, -1);
        
        m_fModified = TRUE; // we'll need to update m_pNlbCfg later.
    }
    
 end:

    /* Move the focus from the add button back to the list view. */
    listAdditionalVips.SetFocus();

    /* Free the IP address and subnet mask memory that were allocated by CIPAddressDialog. */
    if (szIPAddress) free(szIPAddress);
    if (szSubnetMask) free(szSubnetMask);

    return;
}

void VipsPage::OnButtonRemove() 
/*
    User has clicked the "Remove" button.
*/
{
    int nItem;
    UINT uCount;

    /* Get the selected item - if nothing is selected, bail out. */
    nItem = listAdditionalVips.GetNextItem(-1, LVNI_ALL|LVNI_SELECTED);
    if (nItem == -1)
    {
        goto end;
    }

    /* Delete the selected entry. */
    listAdditionalVips.DeleteItem(nItem);

    uCount = listAdditionalVips.GetItemCount();

    if (uCount > nItem) {
        /* This was NOT the last (in order) VIP in the list, so highlight
           the VIP in the same position in the list box. */
        listAdditionalVips.SetItemState(nItem, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);        
    } else if (uCount > 0) {
        /* This was the last (in order) VIP in the list, so we highlight
           the VIP "behind" us in the list - our position minus one. */
        listAdditionalVips.SetItemState(nItem - 1, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);        
    } else {
        /* The list is empty - no need to select anything. */
    }

    m_fModified = TRUE; // we'll need to update m_pNlbCfg later.

end:

    /* Move the focus from the delete button back to the list view. */
    listAdditionalVips.SetFocus();

    return;
}

void VipsPage::OnDoubleClick (NMHDR * pNotifyStruct, LRESULT * result )
{
    OnButtonEdit();

    *result = 0;
    return;
}

void VipsPage::OnButtonEdit() 
/*
    User has clicked the "Edit" button.
*/
{
    WCHAR wszSubnetMask[64];
    WCHAR wszIPAddress[64];
    LPWSTR szIPAddress = NULL;
    LPWSTR szSubnetMask = NULL;

    int nItem;
    int iLen;
    
    nItem = listAdditionalVips.GetNextItem(-1, LVNI_ALL|LVNI_SELECTED);
    
    if (nItem == -1)
    {
        return;
    }
    
    /* Get the IP address from the listview. */
    iLen = listAdditionalVips.GetItemText(
        nItem,
        0,
        wszIPAddress,
        sizeof(wszIPAddress)/sizeof(*wszIPAddress));
    
    wszIPAddress[(sizeof(wszIPAddress)/sizeof(*wszIPAddress))-1]=0;
    
    /* Get the subnet mask from the listview. */
    iLen = listAdditionalVips.GetItemText(
        nItem,
        1,
        wszSubnetMask,
        sizeof(wszSubnetMask)/sizeof(*wszSubnetMask));
    
    wszSubnetMask[(sizeof(wszSubnetMask)/sizeof(*wszSubnetMask))-1]=0;
    
    /* Create a dialog to add a new VIP.  Initialize with the IP address and
       subnet masks retrieved from the listview since this is an Edit operation. */
    CIPAddressDialog pIPDlg(wszIPAddress, wszSubnetMask);

    /* Show the dialog box.  If the user presses "OK", update the VIP list, otherwise ignore it. */
    if (pIPDlg.DoModal() == IDOK) {
        WCHAR szMungedIpAddress[WLBS_MAX_CL_IP_ADDR+1];
        WCHAR szDefaultSubnetMask[WLBS_MAX_CL_NET_MASK+1];
        WCHAR szConcatenatedIPandMask[WLBS_MAX_CL_IP_ADDR + WLBS_MAX_CL_NET_MASK + 2];
        LPWSTR szNewIPAddress = NULL;
        LPWSTR szNewSubnetMask = NULL;
        UINT uClusterIp = 0;
        UINT uSubnetMask = 0;
        UINT uDefaultSubnetMask = 0;

        /* Get the IP address and subnet mask the user typed into the dialog. 
           Note that the dialog allocates the memory for us and we're required
           to free it when we're done. */
        szIPAddress = pIPDlg.GetIPAddress();
        szSubnetMask = pIPDlg.GetSubnetMask();

        /* Cat the IP address and subnetmask for verification by CfgUtilsValidateNetworkAddress. */
        StringCbPrintf(
            szConcatenatedIPandMask,
            sizeof(szConcatenatedIPandMask),
            L"%ls/%ls", szIPAddress, szSubnetMask
            );

        //
        // Validate the network address -- if failure, put up msg box.
        // TODO: call extended validation function.
        //
        {
            WBEMSTATUS wStat;
            
            wStat = CfgUtilsValidateNetworkAddress(
                szConcatenatedIPandMask,
                &uClusterIp,
                &uSubnetMask,
                &uDefaultSubnetMask
                );
            
            if (!FAILED(wStat))
            {
                //
                // Add some more checks...
                //
                UINT u = uClusterIp&0xff;
                if (u<1 || u>=224)
                {
                    wStat = WBEM_E_CRITICAL_ERROR;
                }
            }
            
            if (FAILED(wStat))
            {
                ::MessageBox(
                    NULL,
                    GETRESOURCEIDSTRING(IDS_INVALID_IP_OR_SUBNET),
                    GETRESOURCEIDSTRING(IDS_INVALID_INFORMATION),
                    MB_ICONINFORMATION   | MB_OK
                    );
                goto end;
            }
            
            //
            // Can't add the primary cluster vip.
            //
            if (uClusterIp == m_uPrimaryClusterIp)
            {
                goto end;
            }
        }
        
        if (*szSubnetMask == 0)
        {
            // subnet mask was not specified -- substitute default.
            uSubnetMask = uDefaultSubnetMask;
        }

        //
        // Change subnet to canonical form...
        //
        {
            LPBYTE pb = (LPBYTE) &uSubnetMask;
            StringCbPrintf(
                szDefaultSubnetMask,
                sizeof(szDefaultSubnetMask),
                L"%lu.%lu.%lu.%lu",
                pb[0], pb[1], pb[2], pb[3]
                );
            szNewSubnetMask = szDefaultSubnetMask;
        }

        //
        // Change IP to canonical form
        //
        {
            LPBYTE pb = (LPBYTE) &uClusterIp;
            StringCbPrintf(
                szMungedIpAddress,
                sizeof(szMungedIpAddress),
                L"%lu.%lu.%lu.%lu",
                pb[0], pb[1], pb[2], pb[3]
                );
            szNewIPAddress = szMungedIpAddress;
        }
        
        //
        // mfn_InsertNetworkAddress will make sure it's inserted in the 
        // proper location and will not insert it if it's a duplicate.
        //
        mfn_InsertNetworkAddress(szNewIPAddress, szNewSubnetMask, uClusterIp, nItem);
        
        m_fModified = TRUE; // we'll need to update m_pNlbCfg later.
    }
    
 end:

    /* Move the focus from the edit button back to the list view. */
    listAdditionalVips.SetFocus();

    /* Free the IP address and subnet mask memory that were allocated by CIPAddressDialog. */
    if (szIPAddress) free(szIPAddress);
    if (szSubnetMask) free(szSubnetMask);

    return;
}


void VipsPage::OnSelchanged(NMHDR * pNotifyStruct, LRESULT * result )
/*
    A listbox item has been selected.
*/
{
    POSITION pos;
    BOOL fSelected = FALSE;

    if (!m_fClusterView)
    {
        goto end; // we don't allow modifications unless its the cluster
                  // view.
    }

    pos = listAdditionalVips.GetFirstSelectedItemPosition();
    fSelected = FALSE;
    if( pos != NULL )
    {
        int index = listAdditionalVips.GetNextSelectedItem( pos );
        fSelected = TRUE;
    }
    else
    {
    }

    if (fSelected)
    {
        // enable remove
        ::EnableWindow (GetDlgItem(IDC_BUTTON_REMOVE_VIP)->m_hWnd, TRUE);
        // enable edit
        ::EnableWindow (GetDlgItem(IDC_BUTTON_MODIFY_VIP)->m_hWnd, TRUE);
    }
    else
    {
        // disable remove
        ::EnableWindow (GetDlgItem(IDC_BUTTON_REMOVE_VIP)->m_hWnd, FALSE);
        // disable edit
        ::EnableWindow (GetDlgItem(IDC_BUTTON_MODIFY_VIP)->m_hWnd, FALSE);
    }

end:

    *result = 0;
    return;
}

BOOL
VipsPage::OnSetActive()
{
    BOOL fRet =  CPropertyPage::OnSetActive();
    m_pshOwner->SetWizardButtons(
            PSWIZB_BACK|
            PSWIZB_NEXT|
            // PSWIZB_FINISH|
            // PSWIZB_DISABLEDFINISH|
            0
            );

    mfn_LoadFromNlbCfg();

    return fRet;
}

void
VipsPage::mfn_LoadFromNlbCfg(void)
{
    WBEMSTATUS wStatus;
    UINT uClusterIp = 0;
    UINT uDedicatedIp = 0;
    WBEMSTATUS wStat;

    //
    // Initialize the cluster network address.
    //
    {
        CWnd *pItem = GetDlgItem(IDC_EDIT_PRIMARY_IP);

        m_uPrimaryClusterIp = 0;

        if (pItem)
        {
            wStat = CfgUtilsValidateNetworkAddress(
                m_pNlbCfg->NlbParams.cl_ip_addr,
                &uClusterIp,
                NULL,
                NULL
                );
            
            if (wStat != WBEM_NO_ERROR)
            {
                uClusterIp = 0;
                pItem->SetWindowText(L"");
            }
            else
            {
                m_uPrimaryClusterIp = uClusterIp;
                pItem->SetWindowText(m_pNlbCfg->NlbParams.cl_ip_addr);
            }
        }

        pItem = GetDlgItem(IDC_EDIT_PRIMARY_MASK);

        if (pItem)
        {
            pItem->SetWindowText(m_pNlbCfg->NlbParams.cl_net_mask);
        }
    }

    //
    // Get the DWORD form of the dedicated IP address
    //
    {
        wStat = CfgUtilsValidateNetworkAddress(
                    m_pNlbCfg->NlbParams.ded_ip_addr,
                    &uDedicatedIp,
                    NULL,
                    NULL
                    );

        if (wStat != WBEM_NO_ERROR)
        {
            uDedicatedIp = 0;
        }
    }

    //
    // Fill in the list box, EXCLUDING the cluster network address
    // and dedicated ip address (if each are present)
    //
    {
        //
        // Clear the list box
        //
        listAdditionalVips.DeleteAllItems();


        //
        // For each ip address list, if it's not the vip or dip,
        // insert it into the list view.
        //
        // Find location of old network address
        for (UINT u=0; u<m_pNlbCfg->NumIpAddresses; u++)
        {
            UINT uTmpIp = 0;
            NLB_IP_ADDRESS_INFO *pInfo = & m_pNlbCfg->pIpAddressInfo[u];
            wStat =  CfgUtilsValidateNetworkAddress(
                        pInfo->IpAddress,
                        &uTmpIp,
                        NULL,
                        NULL
                        );
    
            if (wStat == WBEM_NO_ERROR)
            {
                if (uTmpIp == uDedicatedIp || uTmpIp == uClusterIp)
                {
                    //
                    // It's the cluster ip or the dedicated ip -- skip.
                    //
                    continue;
                }
            }
            else
            {
                TRACE_CRIT(L"%!FUNC! Invalid IP address %ws",
                        m_pNlbCfg->pIpAddressInfo[u].IpAddress);

                //
                // Invalid IP -- don't display it -- should we?
                //
                continue;
            }

            mfn_InsertNetworkAddress(
                pInfo->IpAddress,
                pInfo->SubnetMask,
                uTmpIp,
                -1
                );
        }
    }

    m_fModified = FALSE; // not been modified since we've last synched
                         // with m_pNlbCfg.
}

void
VipsPage::mfn_SaveToNlbCfg(void)
/*
    Save settings to m_pNlbCfg
*/
{
    WBEMSTATUS wStatus;
    
    if (!m_fModified)
    {
        // Nothing to do.
        goto end;
    }

    m_fModified = FALSE;

    //
    // We expect that the list ctrl never contains the
    // primary cluster IP, so we'll always add it first,
    // followed by all the ip in the list ctrl.
    //
    {
        // Pre-allocate the array
        UINT uCount =  listAdditionalVips.GetItemCount();

        NLB_IP_ADDRESS_INFO *rgInfo = new NLB_IP_ADDRESS_INFO[uCount+1];

        if (rgInfo == NULL)
        {
            TRACE_CRIT("%!FUNC! allocation failure!");
            goto end;
        }

        ZeroMemory(rgInfo, sizeof(NLB_IP_ADDRESS_INFO)*(uCount+1));

        //
        // Insert the primary vip first.
        //
        ARRAYSTRCPY(
            rgInfo[0].IpAddress,
            m_pNlbCfg->NlbParams.cl_ip_addr
            );
        ARRAYSTRCPY(
            rgInfo[0].SubnetMask,
            m_pNlbCfg->NlbParams.cl_net_mask
            );

        //
        // Insert the remaining ones.
        //
        for (int nItem = 0; nItem < uCount; nItem++)
        {
            NLB_IP_ADDRESS_INFO *pInfo = &rgInfo[nItem+1];
            WCHAR rgTmp[64];
            int iLen;

            /* Get the IP address. */
            iLen =  listAdditionalVips.GetItemText(
                        nItem,
                        0, // nSubItem,
                        rgTmp,
                        sizeof(rgTmp)/sizeof(*rgTmp));

            rgTmp[(sizeof(rgTmp)/sizeof(*rgTmp))-1]=0;

            if (iLen > 0)
            {
                ARRAYSTRCPY(pInfo->IpAddress, rgTmp);
            }

            /* Get the subnet mask. */
            iLen =  listAdditionalVips.GetItemText(
                        nItem,
                        1, // nSubItem,
                        rgTmp,
                        sizeof(rgTmp)/sizeof(*rgTmp));

            rgTmp[(sizeof(rgTmp)/sizeof(*rgTmp))-1]=0;

            if (iLen > 0)
            {
                ARRAYSTRCPY(pInfo->SubnetMask, rgTmp);
            }
        }

        //
        // Now replace the old address list with the new.
        //
        m_pNlbCfg->SetNetworkAddressesRaw(rgInfo, uCount+1);
    }

end:

    return;
}

/*** CIPAddressDialog ***/

DWORD
CIPAddressDialog::s_HelpIDs[] =
{
    IDC_TEXT_IP_ADDRESS,      IDC_EDIT_IP_ADDRESS,
    IDC_EDIT_IP_ADDRESS,      IDC_EDIT_IP_ADDRESS,
    IDC_TEXT_SUBNET_MASK,     IDC_EDIT_IP_ADDRESS,
    IDC_EDIT_SUBNET_MASK,     IDC_EDIT_IP_ADDRESS,
    0, 0
};

BEGIN_MESSAGE_MAP(CIPAddressDialog, CDialog)

    ON_EN_SETFOCUS (IDC_EDIT_SUBNET_MASK, OnEditSubnetMask)

    ON_WM_HELPINFO()        
    ON_WM_CONTEXTMENU()    

END_MESSAGE_MAP()

CIPAddressDialog::CIPAddressDialog (LPWSTR szIPAddress, LPWSTR szSubnetMask)
    : CDialog(CIPAddressDialog::IDD)
{
    ZeroMemory(&address, sizeof(address));

    /* If an initial IP address was specified, copy it into local storage. */
    if (szIPAddress)
        wcsncpy(address.IpAddress, szIPAddress, WLBS_MAX_CL_IP_ADDR);

    /* If an initial subnet mask was specified, copy it into local storage. */
    if (szSubnetMask)
        wcsncpy(address.SubnetMask, szSubnetMask, WLBS_MAX_CL_NET_MASK);
}

CIPAddressDialog::~CIPAddressDialog ()
{

}

void CIPAddressDialog::DoDataExchange( CDataExchange* pDX )
{  
    CDialog::DoDataExchange(pDX);
    
    DDX_Control(pDX, IDC_EDIT_IP_ADDRESS, IPAddress);
    DDX_Control(pDX, IDC_EDIT_SUBNET_MASK, SubnetMask);
}

BOOL CIPAddressDialog::OnHelpInfo (HELPINFO* helpInfo )
{
    if( helpInfo->iContextType == HELPINFO_WINDOW )
    {
        ::WinHelp( static_cast<HWND> ( helpInfo->hItemHandle ), 
                   CVY_CTXT_HELP_FILE, 
                   HELP_WM_HELP, 
                   (ULONG_PTR ) s_HelpIDs);
    }

    return TRUE;
}

void CIPAddressDialog::OnContextMenu( CWnd* pWnd, CPoint point )
{
    ::WinHelp( m_hWnd, 
               CVY_CTXT_HELP_FILE, 
               HELP_CONTEXTMENU, 
               (ULONG_PTR ) s_HelpIDs);
}

BOOL CIPAddressDialog::OnInitDialog ()
{
    /* Call the base class initialize method. */
    BOOL fRet = CDialog::OnInitDialog();

    if (fRet)
    {
        /* Set the valid ranges on each field of the IP address. */
        IPAddress.SetFieldRange(0, 1, 223);
        IPAddress.SetFieldRange(1, 0, 255);
        IPAddress.SetFieldRange(2, 0, 255);
        IPAddress.SetFieldRange(3, 0, 255);

        /* Set the valid ranges on each field of the subnet mask. */
        SubnetMask.SetFieldRange(0, 0, 255);
        SubnetMask.SetFieldRange(1, 0, 255);
        SubnetMask.SetFieldRange(2, 0, 255);
        SubnetMask.SetFieldRange(3, 0, 255);

        /* If the IP address is blank, clear the dialog; otherwise, convert
           the string to an IP address DWORD and fill in the dialog. */
        if (!lstrlen(address.IpAddress))
            IPAddress.ClearAddress();
        else
            IPAddress.SetAddress(WideStringToIPAddress(address.IpAddress));

        /* If the subnet mask is blank, clear the dialog; otherwise, convert
           the string to an IP address DWORD and fill in the dialog. */
        if (!lstrlen(address.SubnetMask))
            SubnetMask.ClearAddress();
        else
            SubnetMask.SetAddress(WideStringToIPAddress(address.SubnetMask));
    }

    return fRet;
}

/*
 * Method: OnEditSubnetMask
 * Description: This method is invoked when the focus changes to the 
 *              subnet mask control.  If the IP address has been already
 *              specified and the subnet mask is blank, auto-generate one. 
 */
void CIPAddressDialog::OnEditSubnetMask ()
{
    /* Only if the IP address is NOT blank and the subnet mask IS
       blank do we want to auto-generate a subnet mask. */
    if (!IPAddress.IsBlank() && SubnetMask.IsBlank()) {
        WCHAR wszIPAddress[WLBS_MAX_CL_IP_ADDR + 1];
        WCHAR wszSubnetMask[WLBS_MAX_CL_NET_MASK + 1];
        DWORD dwIPAddress;

        /* Get the IP address from the IP address dialog. */
        IPAddress.GetAddress(dwIPAddress);

        /* Convert the IP address to a unicode string. */
        IPAddressToWideString(dwIPAddress, wszIPAddress);

        /* Generate a subnet mask from the class of the given IP address. */
        GenerateSubnetMask(wszIPAddress, ASIZE(wszSubnetMask), wszSubnetMask);

        /* Fill in the subnet mask dialog with the generated subnet mask. */
        SubnetMask.SetAddress(WideStringToIPAddress(wszSubnetMask));
    }
}

/*
 * Method: On OK
 * Description: Called when the user presses OK.  If the user presses 
 *              Cancel, no method is called and changes are lost.
 */
void CIPAddressDialog::OnOK () 
{
    DWORD dwIPAddress;
    DWORD dwSubnetMask;

    if (IPAddress.IsBlank()) {
        /* If the IP address dialog is blank, store an empty
           string; if we actually perform a GetAddress call, 
           it will tell us its 0.0.0.0 and we want to be able
           to tell the difference between blank and 0.0.0.0. */
        wcsncpy(address.IpAddress, L"", WLBS_MAX_CL_IP_ADDR);

    } else {
        /* Otherwise, get the IP address DWORD from the control
           and convert it to a unicode string. */
        IPAddress.GetAddress(dwIPAddress);
        
        IPAddressToWideString(dwIPAddress, address.IpAddress);

    }

    if (SubnetMask.IsBlank()) {
        /* If the subnet mask dialog is blank, store an empty
           string; if we actually perform a GetAddress call, 
           it will tell us its 0.0.0.0 and we want to be able
           to tell the difference between blank and 0.0.0.0. */
        wcsncpy(address.SubnetMask, L"", WLBS_MAX_CL_NET_MASK);

    } else {
        /* Otherwise, get the IP address DWORD from the control
           and convert it to a unicode string. */
        SubnetMask.GetAddress(dwSubnetMask);
        
        IPAddressToWideString(dwSubnetMask, address.SubnetMask);

    }

    /* Check the validity of the IP address and subnet mask.  If 
       one or both is invalid, throw up an error and don't close
       the dialog. */
    if (!IsValid(address.IpAddress, address.SubnetMask)) {
        ::MessageBox(
            NULL,
            GETRESOURCEIDSTRING(IDS_INVALID_IP_OR_SUBNET),
            GETRESOURCEIDSTRING(IDS_INVALID_INFORMATION),
            MB_ICONINFORMATION   | MB_OK
            );

        /* If the IP address is blank, clear the dialog; otherwise, convert
           the string to an IP address DWORD and fill in the dialog. */
        if (!lstrlen(address.IpAddress))
            IPAddress.ClearAddress();
        else
            IPAddress.SetAddress(WideStringToIPAddress(address.IpAddress));

        /* If the subnet mask is blank, clear the dialog; otherwise, convert
           the string to an IP address DWORD and fill in the dialog. */
        if (!lstrlen(address.SubnetMask))
            SubnetMask.ClearAddress();
        else
            SubnetMask.SetAddress(WideStringToIPAddress(address.SubnetMask));

        return;
    }

    EndDialog(IDOK);
}

/*
 * Method: 
 * Description: 
 */
DWORD CIPAddressDialog::WideStringToIPAddress (const WCHAR*  wszIPAddress)
{   
    CHAR  szIPAddress[MAXIPSTRLEN + 1];
    DWORD dwIPAddress;
    DWORD dwTemp;
    BYTE * pTemp = (BYTE *)&dwTemp;
    BYTE * pIPAddress = (BYTE *)&dwIPAddress;

    if (!wszIPAddress) return 0;

    WideCharToMultiByte(CP_ACP, 0, wszIPAddress, -1, szIPAddress, sizeof(szIPAddress), NULL, NULL);

    dwTemp = inet_addr(szIPAddress);

    pIPAddress[0] = pTemp[3];
    pIPAddress[1] = pTemp[2];
    pIPAddress[2] = pTemp[1];
    pIPAddress[3] = pTemp[0];    

    return dwIPAddress;
}

/*
 * Method: 
 * Description: 
 */
void CIPAddressDialog::IPAddressToWideString (DWORD dwIPAddress, LPWSTR wszIPAddress)
{
    CHAR * szIPAddress;
    DWORD dwTemp;
    BYTE * pTemp = (BYTE *)&dwTemp;
    const BYTE * pIPAddress = (const BYTE *)&dwIPAddress;

    if (!wszIPAddress) return;
    
    pTemp[0] = pIPAddress[3];
    pTemp[1] = pIPAddress[2];
    pTemp[2] = pIPAddress[1];
    pTemp[3] = pIPAddress[0];

    szIPAddress = inet_ntoa(*(struct in_addr *)&dwTemp);

    if (!szIPAddress)
    {
        wcsncpy(wszIPAddress, L"", MAXIPSTRLEN);
        return; 
    }

    MultiByteToWideChar(CP_ACP, 0, szIPAddress, -1, wszIPAddress,  MAXIPSTRLEN + 1);
}

/*
 * Method: 
 * Description: 
 */
void CIPAddressDialog::GetIPAddressOctets (LPWSTR wszIPAddress, DWORD dwIPAddress[4]) 
{
    DWORD dwIP = WideStringToIPAddress(wszIPAddress);
    const BYTE * bp = (const BYTE *)&dwIP;

    dwIPAddress[3] = (DWORD)bp[0];
    dwIPAddress[2] = (DWORD)bp[1];
    dwIPAddress[1] = (DWORD)bp[2];
    dwIPAddress[0] = (DWORD)bp[3];
}

/*
 * Method: 
 * Description: 
 */
BOOL CIPAddressDialog::IsValid (LPWSTR wszIPAddress, LPWSTR wszSubnetMask) 
{
    BOOL fNoError = TRUE;

    DWORD dwAddr = WideStringToIPAddress(wszIPAddress);
    DWORD dwMask = WideStringToIPAddress(wszSubnetMask);

    if (!IsContiguousSubnetMask(wszSubnetMask))
        return FALSE;
    
    if (( (dwMask | dwAddr) == 0xFFFFFFFF)      // Is the host ID all 1's ?
        || (((~dwMask) & dwAddr) == 0)          // Is the host ID all 0's ?
        || ( (dwMask   & dwAddr) == 0))         // Is the network ID all 0's ?
        return FALSE;
    
    DWORD ardwNetID[4];
    DWORD ardwHostID[4];
    DWORD ardwIp[4];
    DWORD ardwMask[4];
    
    GetIPAddressOctets(wszIPAddress, ardwIp);
    GetIPAddressOctets(wszSubnetMask, ardwMask);

    INT nFirstByte = ardwIp[0] & 0xFF;

    // setup Net ID
    ardwNetID[0] = ardwIp[0] & ardwMask[0] & 0xFF;
    ardwNetID[1] = ardwIp[1] & ardwMask[1] & 0xFF;
    ardwNetID[2] = ardwIp[2] & ardwMask[2] & 0xFF;
    ardwNetID[3] = ardwIp[3] & ardwMask[3] & 0xFF;

    // setup Host ID
    ardwHostID[0] = ardwIp[0] & (~(ardwMask[0]) & 0xFF);
    ardwHostID[1] = ardwIp[1] & (~(ardwMask[1]) & 0xFF);
    ardwHostID[2] = ardwIp[2] & (~(ardwMask[2]) & 0xFF);
    ardwHostID[3] = ardwIp[3] & (~(ardwMask[3]) & 0xFF);

    // check each case
    if( ((nFirstByte & 0xF0) == 0xE0)  || // Class D
        ((nFirstByte & 0xF0) == 0xF0)  || // Class E
        (ardwNetID[0] == 127) ||          // NetID cannot be 127...
        ((ardwNetID[0] == 0) &&           // netid cannot be 0.0.0.0
         (ardwNetID[1] == 0) &&
         (ardwNetID[2] == 0) &&
         (ardwNetID[3] == 0)) ||
        // netid cannot be equal to sub-net mask
        ((ardwNetID[0] == ardwMask[0]) &&
         (ardwNetID[1] == ardwMask[1]) &&
         (ardwNetID[2] == ardwMask[2]) &&
         (ardwNetID[3] == ardwMask[3])) ||
        // hostid cannot be 0.0.0.0
        ((ardwHostID[0] == 0) &&
         (ardwHostID[1] == 0) &&
         (ardwHostID[2] == 0) &&
         (ardwHostID[3] == 0)) ||
        // hostid cannot be 255.255.255.255
        ((ardwHostID[0] == 0xFF) &&
         (ardwHostID[1] == 0xFF) &&
         (ardwHostID[2] == 0xFF) &&
         (ardwHostID[3] == 0xFF)) ||
        // test for all 255
        ((ardwIp[0] == 0xFF) &&
         (ardwIp[1] == 0xFF) &&
         (ardwIp[2] == 0xFF) &&
         (ardwIp[3] == 0xFF)))
        return FALSE;

    return TRUE;
}

/*
 * Method: 
 * Description: 
 */
BOOL CIPAddressDialog::IsContiguousSubnetMask (LPWSTR wszSubnetMask) 
{
    DWORD dwSubnetMask[4];

    GetIPAddressOctets(wszSubnetMask, dwSubnetMask);

    DWORD dwMask = (dwSubnetMask[0] << 24) + (dwSubnetMask[1] << 16)
        + (dwSubnetMask[2] << 8) + dwSubnetMask[3];
    
    DWORD i, dwContiguousMask;
    
    // Find out where the first '1' is in binary going right to left
    dwContiguousMask = 0;

    for (i = 0; i < sizeof(dwMask)*8; i++) {
        dwContiguousMask |= 1 << i;
        
        if (dwContiguousMask & dwMask)
            break;
    }
    
    // At this point, dwContiguousMask is 000...0111...  If we inverse it,
    // we get a mask that can be or'd with dwMask to fill in all of
    // the holes.
    dwContiguousMask = dwMask | ~dwContiguousMask;

    // If the new mask is different, correct it here
    if (dwMask != dwContiguousMask)
        return FALSE;
    else
        return TRUE;
}

/*
 * Method: 
 * Description: 
 */
BOOL CIPAddressDialog::GenerateSubnetMask (LPWSTR wszIPAddress,
         UINT cchSubnetMask,
         LPWSTR wszSubnetMask
         )
{
    DWORD b[4];

    if (swscanf(wszIPAddress, L"%d.%d.%d.%d", b, b+1, b+2, b+3) != EOF)
    {
        if ((b[0] >= 1) && (b[0] <= 126)) {
            b[0] = 255;
            b[1] = 0;
            b[2] = 0;
            b[3] = 0;
        } else if ((b[0] >= 128) && (b[0] <= 191)) {
            b[0] = 255;
            b[1] = 255;
            b[2] = 0;
            b[3] = 0;
        } else if ((b[0] >= 192) && (b[0] <= 223)) {
            b[0] = 255;
            b[1] = 255;
            b[2] = 255;
            b[3] = 0;
        } else {
            b[0] = 0;
            b[1] = 0;
            b[2] = 0;
            b[3] = 0;
        }
    }
    else
    {
        b[0] = 0;
        b[1] = 0;
        b[2] = 0;
        b[3] = 0;
    }

    StringCchPrintf(
            wszSubnetMask,
            cchSubnetMask,
            L"%d.%d.%d.%d", b[0], b[1], b[2], b[3]);

    return((b[0] + b[1] + b[2] + b[3]) > 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\utils.cpp ===
//***************************************************************************
//
//  UTILS.CPP
// 
//  Module: NLB Manager (client-side exe)
//
//  Purpose:  Misc utilities
//
//  Copyright (c)2001 Microsoft Corporation, All Rights Reserved
//
//  History:
//
//  07/25/01    JosephJ Created
//
//***************************************************************************
#include "precomp.h"
#pragma hdrstop
#include "wlbsutil.h"
#include "private.h"
#include "utils.tmh"


#define szNLBMGRREG_BASE_KEY L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\NLB"

LPCWSTR
clustermode_description(
            const WLBS_REG_PARAMS *pParams
            );

LPCWSTR
rct_description(
            const WLBS_REG_PARAMS *pParams
            );

// default constructor
//
ClusterProperties::ClusterProperties()
{
    cIP = L"0.0.0.0";
    cSubnetMask = L"0.0.0.0";
    #define szDEFAULT_CLUSTER_NAME L"www.nlb-cluster.com"
    cFullInternetName = szDEFAULT_CLUSTER_NAME;
    cNetworkAddress = L"00-00-00-00-00-00";

    multicastSupportEnabled = false;
    remoteControlEnabled = false;
    password = L"";
    igmpSupportEnabled = false;
    clusterIPToMulticastIP = true;
}

// equality operator
//
bool
ClusterProperties::operator==( const ClusterProperties& objToCompare )
{
    bool btemp1, btemp2; // Variables to pass to below function. Returned values not used
    return !HaveClusterPropertiesChanged(objToCompare, &btemp1, &btemp2);
}

// equality operator
//
bool
ClusterProperties::HaveClusterPropertiesChanged( const ClusterProperties& objToCompare, 
                                                 bool                    *pbOnlyClusterNameChanged,
                                                 bool                    *pbClusterIpChanged)
{
    *pbClusterIpChanged = false;
    *pbOnlyClusterNameChanged = false;

    if( cIP != objToCompare.cIP )
    {
        *pbClusterIpChanged = true;
        return true;
    }
    else if (
        ( cSubnetMask != objToCompare.cSubnetMask )
        ||
        ( cNetworkAddress != objToCompare.cNetworkAddress )
        ||
        ( multicastSupportEnabled != objToCompare.multicastSupportEnabled )
        ||
        ( igmpSupportEnabled != objToCompare.igmpSupportEnabled )
        ||
        ( clusterIPToMulticastIP != objToCompare.clusterIPToMulticastIP )
        )
    {
        return true;
    }
    else if (
        ( cFullInternetName != objToCompare.cFullInternetName )
        ||
        ( remoteControlEnabled != objToCompare.remoteControlEnabled )
        )
    {
        *pbOnlyClusterNameChanged = true;
        return true;
    }
    else if (
        ( remoteControlEnabled == true )
        &&
        ( password != objToCompare.password )        
        )
    {
        *pbOnlyClusterNameChanged = true;
        return true;
    }

    return false;
}

// inequality operator
//
bool
ClusterProperties::operator!=( const ClusterProperties& objToCompare )
{
    bool btemp1, btemp2; // Variables to pass to below function. Returned values not used
    return HaveClusterPropertiesChanged(objToCompare, &btemp1, &btemp2);
}

// default constructor
//
HostProperties::HostProperties()
{
    // TODO set all properties with default values.
}

// equality operator
//
bool
HostProperties::operator==( const HostProperties& objToCompare )
{
    if( ( hIP == objToCompare.hIP )
        &&
        ( hSubnetMask == objToCompare.hSubnetMask )        
        &&
        ( hID == objToCompare.hID )
        &&
        ( initialClusterStateActive == objToCompare.initialClusterStateActive )
        &&
        ( machineName == objToCompare.machineName )
        )
    {
        return true;
    }
    else
    {
        return false;
    }
}

// inequality operator
//
bool
HostProperties::operator!=( const HostProperties& objToCompare )
{
    return !operator==(objToCompare );
}


_bstr_t
CommonUtils::getCIPAddressCtrlString( CIPAddressCtrl& ip )
{
    	unsigned long addr;
	ip.GetAddress( addr );
	
	PUCHAR bp = (PUCHAR) &addr;	

	wchar_t buf[BUF_SIZE];
	StringCbPrintf(buf, sizeof(buf), L"%d.%d.%d.%d", bp[3], bp[2], bp[1], bp[0] );

        return _bstr_t( buf );
}


void
CommonUtils::fillCIPAddressCtrlString( CIPAddressCtrl& ip, 
                                       const _bstr_t& ipAddress )
{
    // set the IPAddress control to blank if ipAddress is zero.

    unsigned long addr = inet_addr( ipAddress );
    if( addr != 0 )
    {

        PUCHAR bp = (PUCHAR) &addr;

        ip.SetAddress( bp[0], bp[1], bp[2], bp[3] );
    }
    else
    {
        ip.ClearAddress();
    }
}

void
CommonUtils::getVectorFromSafeArray( SAFEARRAY*&  stringArray, 
                                     vector<_bstr_t>& strings )
{
    LONG count = stringArray->rgsabound[0].cElements;
    BSTR* pbstr;
    HRESULT hr;

    if( SUCCEEDED( SafeArrayAccessData( stringArray, ( void **) &pbstr)))
    {
        for( LONG x = 0; x < count; x++ )
        {
            strings.push_back( pbstr[x] );
        }

        hr = SafeArrayUnaccessData( stringArray );
    }
}    


// checkIfValid
//
bool
MIPAddress::checkIfValid( const _bstr_t&  ipAddrToCheck )
{
    // The validity rules are as follows
    //
    // The first byte (FB) has to be : 0 < FB < 224 && FB != 127
    // Note that 127 is loopback address.
    // hostid portion of an address cannot be zero.
    //
    // class A range is 1 - 126.  hostid portion is last 3 bytes.
    // class B range is 128 - 191 hostid portion is last 2 bytes
    // class C range is 192 - 223 hostid portion is last byte.

    // split up the ipAddrToCheck into its 4 bytes.
    //

    WTokens tokens;
    tokens.init( wstring( ipAddrToCheck ) , L".");
    vector<wstring> byteTokens = tokens.tokenize();
    if( byteTokens.size() != 4 )
    {
        return false;
    }

    int firstByte = _wtoi( byteTokens[0].c_str() );
    int secondByte = _wtoi( byteTokens[1].c_str() );
    int thirdByte = _wtoi( byteTokens[2].c_str() );
    int fourthByte = _wtoi( byteTokens[3].c_str() );

    // check firstByte
    if ( ( firstByte > 0 )
         &&
         ( firstByte < 224 )
         && 
         ( firstByte != 127 )
         )
    {
        // check that host id portion is not zero.
        IPClass ipClass;
        getIPClass( ipAddrToCheck, ipClass );
        switch( ipClass )
        {
            case classA :
                // last three bytes should not be zero.
                if( ( _wtoi( byteTokens[1].c_str() ) == 0 )
                    &&
                    ( _wtoi( byteTokens[2].c_str() )== 0 )
                    &&
                    ( _wtoi( byteTokens[3].c_str() )== 0 )
                    )
                {
                    return false;
                }
                break;

            case classB :
                // last two bytes should not be zero.
                if( ( _wtoi( byteTokens[2].c_str() )== 0 )
                    &&
                    ( _wtoi( byteTokens[3].c_str() )== 0 )
                    )
                {
                    return false;
                }
                break;

            case classC :
                // last byte should not be zero.
                if( _wtoi( byteTokens[3].c_str() ) 
                    == 0 )
                {
                    return false;
                }
                break;

            default :
                // this should not have happened.
                return false;
                break;
        }
                
        return true;
    }
    else
    {
        return false;
    }
}


// getDefaultSubnetMask
//
bool
MIPAddress::getDefaultSubnetMask( const _bstr_t&  ipAddr,
                                 _bstr_t&        subnetMask )
{
    
    // first ensure that the ip is valid.
    //
    bool isValid = checkIfValid( ipAddr );
    if( isValid == false )
    {
        return false;
    }

    // get the class to which this ip belongs.
    // as this determines the subnet.
    IPClass ipClass;

    getIPClass( ipAddr,
                ipClass );

    switch( ipClass )
    {
        case classA :
            subnetMask = L"255.0.0.0";
            break;

        case classB :
            subnetMask = L"255.255.0.0";
            break;

        case classC :
            subnetMask = L"255.255.255.0";
            break;

        default :
                // this should not have happened.
                return false;
                break;
    }

    return true;
}


// getIPClass
//
bool
MIPAddress::getIPClass( const _bstr_t& ipAddr,
                        IPClass&        ipClass )
{

    // get the first byte of the ipAddr
    
    WTokens tokens;
    tokens.init( wstring( ipAddr ) , L".");
    vector<wstring> byteTokens = tokens.tokenize();

    if( byteTokens.size() == 0 )
    {
        return false;
    }

    int firstByte = _wtoi( byteTokens[0].c_str() );

    if( ( firstByte >= 1 )
        &&
        ( firstByte <= 126  )
        )
    {
        // classA
        ipClass = classA;
        return true;
    }
    else if( (firstByte >= 128 )
             && 
             (firstByte <= 191 )
             )
    {
        // classB
        ipClass = classB;
        return true;
    }
    else if( (firstByte  >= 192 )
             && 
             (firstByte <= 223 )
             )
    {
        // classC
        ipClass = classC;
        return true;
    }
    else if( (firstByte  >= 224 )
             && 
             (firstByte <= 239 )
             )
    {
        // classD
        ipClass = classD;
        return true;
    }
    else if( (firstByte  >= 240 )
             && 
             (firstByte <= 247 )
             )
    {
        // classE
        ipClass = classE;
        return true;
    }
    else
    {
        // invalid net portiion.
        return false;
    }
}

    
                        
bool
MIPAddress::isValidIPAddressSubnetMaskPair( const _bstr_t& ipAddress,
                                            const _bstr_t& subnetMask )
{
    if( IsValidIPAddressSubnetMaskPair( ipAddress, subnetMask ) == TRUE )
    {
        return true;
    }
    else
    {
        return false;
    }
}

bool
MIPAddress::isContiguousSubnetMask( const _bstr_t& subnetMask )
{
    if( IsContiguousSubnetMask( subnetMask ) == TRUE )
    {
        return true;
    }
    else
    {
        return false;
    }
}


MUsingCom::MUsingCom( DWORD type )
        : status( MUsingCom_SUCCESS )
{
    HRESULT hr;

    // Initialize com.
    hr = CoInitializeEx(0, type );
    if ( FAILED(hr) )
    {
        // cout << "Failed to initialize COM library" << hr << endl;
        status = COM_FAILURE;
    }
}


// destructor
MUsingCom::~MUsingCom()
{
    CoUninitialize();
}    


// getStatus
MUsingCom::MUsingCom_Error
MUsingCom::getStatus()
{
    return status;
}



// static member definition.
map< UINT, _bstr_t>
ResourceString::resourceStrings;

ResourceString* ResourceString::_instance = 0;

// Instance
//
ResourceString*
ResourceString::Instance()
{
    if( _instance == 0 )
    {
        _instance = new ResourceString;
    }

    return _instance;
}

// GetIDString
//
const _bstr_t&
ResourceString::GetIDString( UINT id )
{
    // check if string has been loaded previously.
    if( resourceStrings.find( id ) == resourceStrings.end() )
    {
        // first time load.
        CString str;
        if( str.LoadString( id ) == 0 )
        {
            // no string mapping to this id.
            throw _com_error( WBEM_E_NOT_FOUND );
        }

        resourceStrings[id] = str;
    }

    return resourceStrings[ id ];
}

// GETRESOURCEIDSTRING
// helper function.
//
const _bstr_t&
GETRESOURCEIDSTRING( UINT id )
{
	return ResourceString::GetIDString( id );
}



//
// constructor
WTokens::WTokens( wstring strToken, wstring strDelimit )
        : _strToken( strToken ), _strDelimit( strDelimit )
{}
//
// default constructor
WTokens::WTokens()
{}
//
// destructor
WTokens::~WTokens()
{}
//
// tokenize
vector<wstring>
WTokens::tokenize()
{
    vector<wstring> vecTokens;
    wchar_t* token;

    token = wcstok( (wchar_t *) _strToken.c_str() , _strDelimit.c_str() );
    while( token != NULL )
    {
        vecTokens.push_back( token );
        token = wcstok( NULL, _strDelimit.c_str() );
    }
    return vecTokens;
}
//
void
WTokens::init( 
    wstring strToken,
    wstring strDelimit )
{
    _strToken = strToken;
    _strDelimit = strDelimit;
}

void
GetErrorCodeText(WBEMSTATUS wStat , _bstr_t& errText )
{
    WCHAR rgch[128];
    UINT  uErr = (UINT) wStat;
    LPCWSTR szErr = NULL;
    CLocalLogger log;

    switch(uErr)
    {
    case WBEM_E_ACCESS_DENIED:
        szErr =  GETRESOURCEIDSTRING(IDS_ERROR_ACCESS_DENIED);
        break;

    case E_ACCESSDENIED:
        szErr =  GETRESOURCEIDSTRING(IDS_ERROR_ACCESS_DENIED);
        break;

    case 0x800706ba: // RPC service unavailable
        // TODO: find the constant definition for this.
        szErr =  GETRESOURCEIDSTRING(IDS_ERROR_NLB_NOT_FOUND);
        break;

    case WBEM_E_LOCAL_CREDENTIALS:
        szErr =  GETRESOURCEIDSTRING(IDS_ERROR_INVALID_LOCAL_CREDENTIALS);
        break;

    default:
        log.Log(IDS_ERROR_CODE, (UINT) uErr);
        szErr = log.GetStringSafe();
        break;
    }
    errText = szErr;
}




UINT
NlbMgrRegReadUINT(
    HKEY hKey,
    LPCWSTR szName,
    UINT Default
    )
{
    LONG lRet;
    DWORD dwType;
    DWORD dwData;
    DWORD dwRet;

    dwData = sizeof(dwRet);
    lRet =  RegQueryValueEx(
              hKey,         // handle to key to query
              szName,
              NULL,         // reserved
              &dwType,   // address of buffer for value type
              (LPBYTE) &dwRet, // address of data buffer
              &dwData  // address of data buffer size
              );
    if (    lRet != ERROR_SUCCESS
        ||  dwType != REG_DWORD
        ||  dwData != sizeof(dwData))
    {
        dwRet = (DWORD) Default;
    }

    return (UINT) dwRet;
}


VOID
NlbMgrRegWriteUINT(
    HKEY hKey,
    LPCWSTR szName,
    UINT Value
    )
{
    LONG lRet;

    lRet = RegSetValueEx(
            hKey,           // handle to key to set value for
            szName,
            0,              // reserved
            REG_DWORD,     // flag for value type
            (BYTE*) &Value,// address of value data
            sizeof(Value)  // size of value data
            );

    if (lRet !=ERROR_SUCCESS)
    {
        // trace error
    }
}

HKEY
NlbMgrRegCreateKey(
    LPCWSTR szSubKey
    )
{
    WCHAR szKey[256];
    DWORD dwOptions = 0;
    HKEY hKey = NULL;

    ARRAYSTRCPY(szKey,  szNLBMGRREG_BASE_KEY);

    if (szSubKey != NULL)
    {
        if (wcslen(szSubKey)>128)
        {
            // too long.
            goto end;
        }
        ARRAYSTRCAT(szKey, L"\\");
        ARRAYSTRCAT(szKey, szSubKey);
    }

    DWORD dwDisposition;

    LONG lRet;

    lRet = RegCreateKeyEx(
            HKEY_CURRENT_USER, // handle to an open key
            szKey,             // address of subkey name
            0,                 // reserved
            L"class",          // address of class string
            0,                 // special options flag
            KEY_ALL_ACCESS,    // desired security access
            NULL,              // address of key security structure
            &hKey,             // address of buffer for opened handle
            &dwDisposition     // address of disposition value buffer
            );
    if (lRet != ERROR_SUCCESS)
    {
        hKey = NULL;
    }

end:

    return hKey;
}


void
GetTimeAndDate(_bstr_t &bstrTime, _bstr_t &bstrDate)
{
    WCHAR wszTime[128];
    WCHAR wszDate[128];
    ConvertTimeToTimeAndDateStrings(time(NULL), wszTime, ASIZECCH(wszTime), wszDate, ASIZECCH(wszDate));

    bstrTime = _bstr_t(wszTime);
    bstrDate = _bstr_t(wszDate);
}

VOID
CLocalLogger::Log(
    IN UINT ResourceID,
    // IN LPCWSTR FormatString,
    ...
)
{
    DWORD dwRet;
    WCHAR wszFormat[2048];
    WCHAR wszBuffer[2048];
    HINSTANCE hInst = AfxGetInstanceHandle();

    if (!LoadString(hInst, ResourceID, wszFormat, ASIZE(wszFormat)-1))
    {
        TRACE_CRIT("LoadString returned 0, GetLastError() : 0x%x, Could not log message !!!", GetLastError());
        goto end;
    }

    va_list arglist;
    va_start (arglist, ResourceID);

    dwRet = FormatMessage(FORMAT_MESSAGE_FROM_STRING,
                          wszFormat, 
                          0, // Message Identifier - Ignored for FORMAT_MESSAGE_FROM_STRING
                          0, // Language Identifier
                          wszBuffer,
                          ASIZE(wszBuffer)-1, 
                          &arglist);
    va_end (arglist);

    if (dwRet==0)
    {
        TRACE_CRIT("FormatMessage returned error : %u, Could not log message !!!", dwRet);
        goto end;
    }

    UINT uLen = wcslen(wszBuffer)+1; // 1 for extra NULL
    if ((m_LogSize < (m_CurrentOffset+uLen)))
    {
        //
        // Not enough space -- we double the buffer + some extra
        // and copy over the old log.
        //
        UINT uNewSize =  2*m_LogSize+uLen+1024;
        WCHAR *pTmp = new WCHAR[uNewSize];

        if (pTmp == NULL)
        {
            goto end;
        }

        if (m_CurrentOffset!=0)
        {
            CopyMemory(pTmp, m_pszLog, m_CurrentOffset*sizeof(WCHAR));
            pTmp[m_CurrentOffset] = 0;
        }
        delete[] m_pszLog;
        m_pszLog = pTmp;
        m_LogSize = uNewSize;
    }

    //
    // Having made sure there is enough space, copy over the new stuff
    //
    CopyMemory(m_pszLog+m_CurrentOffset, wszBuffer, uLen*sizeof(WCHAR));
    m_CurrentOffset += (uLen-1); // -1 for ending NULL.

end:

    return;
}


VOID
CLocalLogger::LogString(
    LPCWSTR wszBuffer
)
{
    UINT uLen = wcslen(wszBuffer)+1; // 1 for extra NULL
    if ((m_LogSize < (m_CurrentOffset+uLen)))
    {
        //
        // Not enough space -- we double the buffer + some extra
        // and copy over the old log.
        //
        UINT uNewSize =  2*m_LogSize+uLen+1024;
        WCHAR *pTmp = new WCHAR[uNewSize];

        if (pTmp == NULL)
        {
            goto end;
        }

        if (m_CurrentOffset!=0)
        {
            CopyMemory(pTmp, m_pszLog, m_CurrentOffset*sizeof(WCHAR));
            pTmp[m_CurrentOffset] = 0;
        }
        delete[] m_pszLog;
        m_pszLog = pTmp;
        m_LogSize = uNewSize;
    }

    //
    // Having made sure there is enough space, copy over the new stuff
    //
    CopyMemory(m_pszLog+m_CurrentOffset, wszBuffer, uLen*sizeof(WCHAR));
    m_CurrentOffset += (uLen-1); // -1 for ending NULL.

end:

    return;
}


NLBERROR
AnalyzeNlbConfiguration(
    IN const NLB_EXTENDED_CLUSTER_CONFIGURATION &Cfg,
    IN OUT CLocalLogger &logErrors
    )
//
// logErrors - a log of config errors
//
{
    NLBERROR  nerr = NLBERR_INVALID_CLUSTER_SPECIFICATION;
    WBEMSTATUS wStatus;
    const WLBS_REG_PARAMS *pParams = &Cfg.NlbParams;
    BOOL fRet = FALSE;
    NlbIpAddressList addrList;
    BOOL fError = FALSE;

    //
    // We expect NLB to be bound and have a valid configuration (i.e.,
    // one wholse NlbParams contains initialized data).
    //
    if (!Cfg.IsValidNlbConfig())
    {
        logErrors.Log(IDS_LOG_INVALID_CLUSTER_SPECIFICATION);
        nerr = NLBERR_INVALID_CLUSTER_SPECIFICATION;
        goto end;

    }

    //
    // Make a copy of the the tcpip address list in addrList
    //
    fRet = addrList.Set(Cfg.NumIpAddresses, Cfg.pIpAddressInfo, 0);

    if (!fRet)
    {
        TRACE_CRIT(L"Unable to copy old IP address list");
        nerr = NLBERR_RESOURCE_ALLOCATION_FAILURE;
        logErrors.Log(IDS_LOG_RESOURCE_ALLOCATION_FAILURE);
        fError = TRUE;
        goto end;
    }
    //
    // Check stuff related to the cluster ip and subnet.
    //
    do
    {
        UINT uClusterIp = 0;
        const NLB_IP_ADDRESS_INFO *pClusterIpInfo = NULL;

        //
        // Check that IP is valid
        //
        {
            wStatus =  CfgUtilsValidateNetworkAddress(
                            pParams->cl_ip_addr,
                            &uClusterIp,
                            NULL,
                            NULL
                            );
            if (FAILED(wStatus))
            {
                logErrors.Log(IDS_LOG_INVALID_CIP, pParams->cl_ip_addr);
                nerr = NLBERR_INVALID_CLUSTER_SPECIFICATION;
                fError = TRUE;
                goto end;
            }
        }

        //
        // Check that cluster IP is present in tcpip  address list
        //
        {
            pClusterIpInfo = addrList.Find(pParams->cl_ip_addr);
            if (pClusterIpInfo == NULL)
            {
                logErrors.Log(IDS_LOG_CIP_MISSING_FROM_TCPIP, pParams->cl_ip_addr);
                fError = TRUE; // we keep going...
            }
        }

        //
        // Check that the cluster subnet matches what is in the tcpip address
        // list.
        //
        if (pClusterIpInfo != NULL)
        {
            if (_wcsicmp(pParams->cl_net_mask, pClusterIpInfo->SubnetMask))
            {
                logErrors.Log(
                     IDS_LOG_CIP_SUBNET_MASK_MISMATCH,
                     pParams->cl_net_mask,
                     pClusterIpInfo->SubnetMask
                     );
                fError = TRUE; // we keep going...
            }
        }

    } while (FALSE);

    //
    // Check stuff related to the dedicated IP (if present)
    //
    do
    {
        const NLB_IP_ADDRESS_INFO *pDedicatedIpInfo = NULL;

        //
        // If empty dip, bail...
        //
        if (Cfg.IsBlankDedicatedIp())
        {
            break;
        }

        //
        // Check that DIP doesn't match CIP
        //
        if (!_wcsicmp(pParams->cl_ip_addr, pParams->ded_ip_addr))
        {
            logErrors.Log(IDS_LOG_CIP_EQUAL_DIP, pParams->cl_ip_addr);
            fError = TRUE;
        }

        //
        // Check that the DIP is the 1st address in tcpip's address list.
        //
        {
            const NLB_IP_ADDRESS_INFO *pTmpIpInfo = NULL;

            pDedicatedIpInfo = addrList.Find(pParams->ded_ip_addr);
            if (pDedicatedIpInfo == NULL)
            {
                logErrors.Log(IDS_LOG_DIP_MISSING_FROM_TCPIP, pParams->ded_ip_addr);
                fError = TRUE; // we keep going...
            }
            else
            {

                pTmpIpInfo = addrList.Find(NULL); // returns the 1st
    
                if (pTmpIpInfo != pDedicatedIpInfo)
                {
                    logErrors.Log(IDS_LOG_DIP_NOT_FIRST_IN_TCPIP, pParams->ded_ip_addr);
                }
            }
            
        }

        //
        // Check that the DIP subnet matches that in tcpip's address list.
        //
        if (pDedicatedIpInfo != NULL)
        {
            if (_wcsicmp(pParams->ded_net_mask, pDedicatedIpInfo->SubnetMask))
            {
                logErrors.Log(
                     IDS_LOG_DIP_SUBNET_MASK_MISMATCH,
                     pParams->ded_net_mask,
                     pDedicatedIpInfo->SubnetMask
                     );
                fError = TRUE; // we keep going...
            }
        }
        
    } while (FALSE);

    //
    // Check host priority
    //
    // NOTHING to do.
    //
    

    //
    // Check port rules
    //
    {
        WLBS_PORT_RULE *pRules = NULL;
        UINT NumRules=0;
        LPCWSTR szAllVip = GETRESOURCEIDSTRING(IDS_REPORT_VIP_ALL);
        LPCWSTR szPrevVip = NULL;

        wStatus =  CfgUtilGetPortRules(pParams, &pRules, &NumRules);
        if (FAILED(wStatus))
        {
            logErrors.Log(IDS_LOG_CANT_EXTRACT_PORTRULES);
            fError = TRUE;
            nerr = NLBERR_INVALID_CLUSTER_SPECIFICATION;
            goto end;
        }

        for (UINT u = 0; u< NumRules; u++)
        {
            LPCWSTR szVip = pRules[u].virtual_ip_addr;
            const NLB_IP_ADDRESS_INFO *pIpInfo = NULL;

            //
            // Skip the "all-vips" (255.255.255.255) case...
            //
            if (!lstrcmpi(szVip, szAllVip))
            {
                continue;
            }
            if (!lstrcmpi(szVip, L"255.255.255.255"))
            {
                continue;
            }

            //
            // SKip if we've already checked this VIP (assumes the vips 
            // are in sorted order)
            //
            if (szPrevVip != NULL && !lstrcmpi(szVip, szPrevVip))
            {
                continue;
            }

            szPrevVip = szVip;
    
            //
            // Check that the VIP is present in tcpip's address list.
            //
            pIpInfo = addrList.Find(szVip); // returns the 1st

            if (pIpInfo == NULL)
            {
                logErrors.Log(IDS_LOG_VIP_NOT_IN_TCPIP, szVip);
                fError = TRUE; // We continue...
            }

            //
            // Check that VIPs don't match DIPS.
            //
            {
                if (!lstrcmpi(szVip, pParams->ded_ip_addr))
                {
                    logErrors.Log(IDS_LOG_PORTVIP_MATCHES_DIP, szVip);
                }
            }
        }
    }

    if (fError)
    {
        nerr = NLBERR_INVALID_CLUSTER_SPECIFICATION;
    }
    else
    {
        nerr = NLBERR_OK;
    }

end:

    return nerr;
}


NLBERROR
AnalyzeNlbConfigurationPair(
    IN const NLB_EXTENDED_CLUSTER_CONFIGURATION &Cfg,
    IN const NLB_EXTENDED_CLUSTER_CONFIGURATION &OtherCfg,
    IN BOOL             fOtherIsCluster,
    IN BOOL             fCheckOtherForConsistancy,
    OUT BOOL            &fConnectivityChange,
    IN OUT CLocalLogger &logErrors,
    IN OUT CLocalLogger &logDifferences
    )
{
    NLBERROR  nerr = NLBERR_INVALID_CLUSTER_SPECIFICATION;
    WBEMSTATUS wStatus;
    const WLBS_REG_PARAMS *pParams = &Cfg.NlbParams;
    const WLBS_REG_PARAMS *pOtherParams = &OtherCfg.NlbParams;
    BOOL fRet = FALSE;
    NlbIpAddressList addrList;
    NlbIpAddressList otherAddrList;
    BOOL fError = FALSE;
    BOOL fOtherChange = FALSE;

    fConnectivityChange = FALSE;

    //
    // We expect NLB to be bound and have a valid configuration (i.e.,
    // one wholse NlbParams contains initialized data).
    //
    if (!Cfg.IsValidNlbConfig())
    {
        logErrors.Log(IDS_LOG_INVALID_CLUSTER_SPECIFICATION);
        nerr = NLBERR_INVALID_CLUSTER_SPECIFICATION;
        fError = TRUE;
        goto end;
    }
    if (!OtherCfg.IsValidNlbConfig())
    {
        if (OtherCfg.IsNlbBound())
        {
            // TODO:
        }
        else
        {
            // TODO:
        }
        nerr = NLBERR_OK;
        fConnectivityChange = TRUE;
        goto end;
    }

    //
    // Make a copy of the the tcpip address list in addrList
    //
    fRet = addrList.Set(Cfg.NumIpAddresses, Cfg.pIpAddressInfo, 0);
    if (!fRet)
    {
        TRACE_CRIT(L"Unable to copy IP address list");
        nerr = NLBERR_RESOURCE_ALLOCATION_FAILURE;
        logErrors.Log(IDS_LOG_RESOURCE_ALLOCATION_FAILURE);
        fError = TRUE;
        goto end;
    }

    //
    // Make a copy of the other tcpip address list in otherAddrList
    //
    fRet = otherAddrList.Set(OtherCfg.NumIpAddresses, OtherCfg.pIpAddressInfo, 0);
    if (!fRet)
    {
        TRACE_CRIT(L"Unable to copy other IP address list");
        nerr = NLBERR_RESOURCE_ALLOCATION_FAILURE;
        logErrors.Log(IDS_LOG_RESOURCE_ALLOCATION_FAILURE);
        fError = TRUE;
        goto end;
    }

    //
    // Check for changes in IP address lists
    //
    {
        UINT u;
        BOOL fWriteHeader=TRUE;

        //
        // Look for added
        //
        fWriteHeader=TRUE;
        for (u=0;u<Cfg.NumIpAddresses; u++)
        {
            NLB_IP_ADDRESS_INFO *pIpInfo = Cfg.pIpAddressInfo+u;
            const NLB_IP_ADDRESS_INFO *pOtherIpInfo = NULL;
            pOtherIpInfo = otherAddrList.Find(pIpInfo->IpAddress);
            if (pOtherIpInfo == NULL)
            {
                // found a new one!
                fConnectivityChange = TRUE;
                if (fWriteHeader)
                {
                    logDifferences.Log(IDS_LOG_ADDED_IPADDR_HEADER);
                    fWriteHeader=FALSE;
                }
                logDifferences.Log(
                    IDS_LOG_ADDED_IPADDR,
                    pIpInfo->IpAddress,
                    pIpInfo->SubnetMask
                    );
            }
        }

        //
        // Look for removed
        //
        fWriteHeader=TRUE;
        for (u=0;u<OtherCfg.NumIpAddresses; u++)
        {
            NLB_IP_ADDRESS_INFO *pOtherIpInfo = OtherCfg.pIpAddressInfo+u;
            const NLB_IP_ADDRESS_INFO *pIpInfo = NULL;
            pIpInfo = addrList.Find(pOtherIpInfo->IpAddress);
            if (pIpInfo == NULL)
            {
                // found a removed one!
                fConnectivityChange = TRUE;
                if (fWriteHeader)
                {
                    logDifferences.Log(IDS_LOG_REMOVED_IPADDR_HEADER);
                    fWriteHeader = FALSE;
                }
                logDifferences.Log(
                    IDS_LOG_REMOVE_IPADDR,
                    pOtherIpInfo->IpAddress,
                    pOtherIpInfo->SubnetMask
                    );
            }
        }

        //
        // Look for modified
        //
        fWriteHeader=TRUE;
        for (u=0;u<Cfg.NumIpAddresses; u++)
        {
            NLB_IP_ADDRESS_INFO *pIpInfo = Cfg.pIpAddressInfo+u;
            const NLB_IP_ADDRESS_INFO *pOtherIpInfo = NULL;
            pOtherIpInfo = otherAddrList.Find(pIpInfo->IpAddress);
            if (    pOtherIpInfo != NULL
                 && lstrcmpi(pIpInfo->SubnetMask, pOtherIpInfo->SubnetMask))
            {
                // found a modified one!
                fConnectivityChange = TRUE;
                if (fWriteHeader)
                {
                    logDifferences.Log(IDS_LOG_MODIFIED_IPADDR_HEADER);
                    fWriteHeader = FALSE;
                }
                logDifferences.Log(
                    IDS_LOG_MODIFIED_IPADDR,
                    pOtherIpInfo->IpAddress,
                    pOtherIpInfo->SubnetMask,
                    pIpInfo->SubnetMask
                    );
            }
        }
    }

    //
    // Cluster name
    //
    {
        if (lstrcmpi(pOtherParams->domain_name, pParams->domain_name))
        {
            logDifferences.Log(
                IDS_LOG_MODIFIED_CLUSTER_NAME,
                pOtherParams->domain_name,
                pParams->domain_name
                );

            fConnectivityChange = TRUE;
        }
    }

    //
    // Check for cluster traffic mode change
    //
    {
        BOOL fModeChange = FALSE;
        if (pParams->mcast_support != pOtherParams->mcast_support)
        {
            fModeChange = TRUE;
        }
        else if (pParams->mcast_support &&
            pParams->fIGMPSupport != pOtherParams->fIGMPSupport)
        {
            fModeChange = TRUE;
        }

        if (fModeChange)
        {
            LPCWSTR szClusterMode = clustermode_description(pParams);
            LPCWSTR szOtherClusterMode = clustermode_description(pOtherParams);

            logDifferences.Log(
                IDS_LOG_MODIFIED_TRAFFIC_MODE,
                szOtherClusterMode,
                szClusterMode
                );

            fConnectivityChange = TRUE;
        }
    }


    //
    // Check if there is change in rct or a new rct password specified...
    //
    {
        if (Cfg.GetRemoteControlEnabled() != 
            OtherCfg.GetRemoteControlEnabled())
        {
            LPCWSTR szRctDescription = rct_description(pParams);
            LPCWSTR szOtherRctDescription = rct_description(pOtherParams);
            logDifferences.Log(
                IDS_LOG_MODIFIED_RCT,
                szOtherRctDescription,
                szRctDescription
                );

            fOtherChange = TRUE;
        }
        else 
        {
            LPCWSTR szNewPwd = Cfg.GetNewRemoteControlPasswordRaw();
            if (szNewPwd != NULL)
            {
                logDifferences.Log(IDS_LOG_NEW_RCT_PWD);
                fOtherChange = TRUE;
            }
        }
    }
    
    //
    // Port rules
    //
    {
    }
    nerr = NLBERR_OK;

end:

    return nerr;
}

LPCWSTR
clustermode_description(
            const WLBS_REG_PARAMS *pParams
            )
{
    LPCWSTR szClusterMode = GETRESOURCEIDSTRING(IDS_DETAILS_HOST_CM_UNICAST);

    if (pParams->mcast_support)
    {
        if (pParams->fIGMPSupport)
        {
            szClusterMode = GETRESOURCEIDSTRING(IDS_DETAILS_HOST_CM_IGMP);
        }
        else
        {
            szClusterMode = GETRESOURCEIDSTRING(IDS_DETAILS_HOST_CM_MULTI);
        }
    }

    return szClusterMode;
}

LPCWSTR
rct_description(
            const WLBS_REG_PARAMS *pParams
            )
{
    LPCWSTR szClusterRctEnabled;
    if (pParams->rct_enabled)
    {
        szClusterRctEnabled = GETRESOURCEIDSTRING(IDS_DETAILS_HOST_RCT_ENABLED);
    }
    else
    {
        szClusterRctEnabled = GETRESOURCEIDSTRING(IDS_DETAILS_HOST_RCT_DISABLED);
    }

    return szClusterRctEnabled;
}

void
ProcessMsgQueue()
{
    theApplication.ProcessMsgQueue();
}

BOOL
PromptForEncryptedCreds(
    IN      HWND    hWnd,
    IN      LPCWSTR szCaptionText,
    IN      LPCWSTR szMessageText,
    IN OUT  LPWSTR  szUserName,
    IN      UINT    cchUserName,
    IN OUT  LPWSTR  szPassword,  // encrypted password
    IN      UINT    cchPassword       // size of szPassword
    )
/*
    Decrypts szPassword, then brings UI prompting the user to change
    the password, then encrypts the resultant password.
*/
{
    TRACE_INFO("-> %!FUNC!");
    BOOL    fRet = FALSE;
    DWORD   dwRet = 0;
    CREDUI_INFO UiInfo;
    PCTSTR  pszTargetName= L"%computername%";
    WCHAR   rgUserName[CREDUI_MAX_USERNAME_LENGTH+1];
    WCHAR   rgClearPassword[CREDUI_MAX_PASSWORD_LENGTH+1];
    WCHAR   rgEncPassword[MAX_ENCRYPTED_PASSWORD_LENGTH];
    BOOL    fSave = FALSE;
    DWORD   dwFlags = 0;
    HRESULT hr;

    rgUserName[0] = 0;
    rgClearPassword[0] = 0;
    rgEncPassword[0] = 0;

    hr = ARRAYSTRCPY(rgUserName, szUserName);
    if (hr != S_OK)
    {
        TRACE_CRIT(L"rgUserName buffer too small for szUserName");
        goto end;
    }

    //
    // Decrypt the password...
    // WARNING: after decryption we need to be sure to zero-out
    // the clear-text pwd before returning from this function.
    //
    // Special case: If enc pwd is  "", we "decrypt" it  to "".
    //
    if (*szPassword == 0)
    {
        *rgClearPassword = 0;
        fRet = TRUE;
    }
    else
    {
        fRet = CfgUtilDecryptPassword(
                        szPassword,
                        ASIZE(rgClearPassword),
                        rgClearPassword
                        );
    }

    if (!fRet)
    {
        TRACE_CRIT(L"CfgUtilDecryptPassword fails! -- bailing!");
        goto end;
    }

    ZeroMemory(&UiInfo, sizeof(UiInfo));
    UiInfo.cbSize = sizeof(CREDUI_INFO);
    UiInfo.hwndParent = hWnd;
    UiInfo.pszMessageText = szMessageText;
    UiInfo.pszCaptionText = szCaptionText;
    UiInfo.hbmBanner = NULL; // use default.

    //
    // Specifying DO_NOT_PERSIST and GENERIC_CREDENTIALS disables all syntax
    // checking, so a null username can be specified.
    //
    dwFlags =   CREDUI_FLAGS_DO_NOT_PERSIST 
              | CREDUI_FLAGS_GENERIC_CREDENTIALS
              // | CREDUI_FLAGS_VALIDATE_USERNAME 
              // | CREDUI_FLAGS_COMPLETE_USERNAME 
              // | CREDUI_FLAGS_USERNAME_TARGET_CREDENTIALS
              ;

    dwRet = CredUIPromptForCredentials (
                        &UiInfo,
                        pszTargetName,
                        NULL, // Reserved
                        0,    // dwAuthError
                        rgUserName,
                        ASIZE(rgUserName),
                        rgClearPassword,
                        ASIZE(rgClearPassword),
                        &fSave,
                        dwFlags
                        );
    if (dwRet != 0)
    {
        TRACE_CRIT(L"CredUIPromptForCredentials fails. dwRet = 0x%x", dwRet);
        fRet = FALSE;
    }
    else
    {
        if (*rgUserName == 0)
        {
            *rgEncPassword=0; // we ignore the password field in this case.
            fRet = TRUE;
        }
        else
        {
            //
            // TODO: prepend %computername% if required.
            //
            fRet = CfgUtilEncryptPassword(
                      rgClearPassword,
                      ASIZE(rgEncPassword),
                      rgEncPassword
                      );
            
        }

        if (!fRet)
        {
            TRACE_CRIT("CfgUtilEncryptPassword fails");
        }
        else
        {
            //
            // We want to make sure we will succeed before we overwrite
            // the user's passed-in buffers for username and password...
            //
            UINT uLen = wcslen(rgEncPassword);
            if (uLen >= cchPassword)
            {
                TRACE_CRIT(L"cchPassword is too small");
                fRet = FALSE;
            }
            uLen = wcslen(rgUserName);
            if(uLen >= cchUserName)
            {
                TRACE_CRIT(L"cchUserName is too small");
                fRet = FALSE;
            }
        }

        if (fRet)
        {
            (void)StringCchCopy(szPassword, cchPassword, rgEncPassword);
            (void)StringCchCopy(szUserName, cchUserName, rgUserName);
            
        }
    }

end:

    SecureZeroMemory(rgClearPassword, sizeof(rgClearPassword));

    TRACE_INFO("<- %!FUNC! returns %d", (int) fRet);
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\utils.h ===
#ifndef _UTILS_H
#define _UTILS_H
//
// Copyright (c) Microsoft.  All Rights Reserved 
//
// THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF Microsoft.
// The copyright notice above does not evidence any
// actual or intended publication of such source code.
//
// OneLiner : common include file.
// DevUnit  : wlbstest
// Author   : Murtaza Hakim
//
// Description: 
// -----------

// History:
// --------
// 
//
// Revised by : mhakim
// Date       : 02-12-01
// Reason     : added password to clusterproperties.

#include <vector>


using namespace std;

struct ClusterProperties
{
    // default constructor
    ClusterProperties();
    
    // Equality operator
    bool
    operator==( const ClusterProperties& objToCompare );

    // inequality operator
    bool
    operator!=( const ClusterProperties& objToCompare );

    bool HaveClusterPropertiesChanged( const ClusterProperties& objToCompare, 
                                       bool *pbOnlyClusterNameChanged,
                                       bool *pbClusterIpChanged);

    _bstr_t cIP;                            // Primary IP address.

    _bstr_t cSubnetMask;                    // Subnet mask.

    _bstr_t cFullInternetName;              // Full Internet name.

    _bstr_t cNetworkAddress;                // Network address.

    bool   multicastSupportEnabled;         // Multicast support.

    bool   remoteControlEnabled;            // Remote control.

    // Edited (mhakim 12-02-01)
    // password may be required to be set.
    // but note that it cannot be got from an existing cluster.

    _bstr_t password;                       // Remote control password.

// for whistler

    bool   igmpSupportEnabled;              // igmp support 

    bool  clusterIPToMulticastIP;           // indicates whether to use cluster ip or user provided ip.

    _bstr_t multicastIPAddress;             // user provided multicast ip.

    long   igmpJoinInterval;                // user provided multicast ip.
};

struct HostProperties
{
    // default constructor
    HostProperties();
    
    // Equality operator
    bool
    operator==( const HostProperties& objToCompare );

    // inequality operator
    bool
    operator!=( const HostProperties& objToCompare );

    _bstr_t hIP;                           // Dedicated IP Address.
    _bstr_t hSubnetMask;                   // Subnet mask.
        
    long    hID;                           // Priority(Unique host ID).

    bool   initialClusterStateActive;      // Initial Cluster State.

    _bstr_t machineName;                   // machine name.
};

class Common
{
public:
    enum
    {
        BUF_SIZE = 1000,
        ALL_PORTS = 0xffffffff,
        ALL_HOSTS = 100,
        THIS_HOST = 0,
    };
};

class CommonUtils
{

public:
    // converts the CIPAddressCtrl embedded ip into
    // dotted decimal string representation.
    static
    _bstr_t
    getCIPAddressCtrlString( CIPAddressCtrl& ip );
    
    // fills the CIPAddressCtrl with the dotted decimal
    // string representation.
    static
    void
    fillCIPAddressCtrlString( CIPAddressCtrl& ip, 
                              const _bstr_t& ipAdddress );

    static
    void
    getVectorFromSafeArray( SAFEARRAY*&      stringArray,
                            vector<_bstr_t>& strings );

    static
    void
    getSafeArrayFromVector( const vector<_bstr_t>& strings,
                            SAFEARRAY*&      stringArray
                            );

    
private:
    enum
    {
        BUF_SIZE = 1000,
    };
};



// typedefs for _com_ptr_t

_COM_SMARTPTR_TYPEDEF(IWbemServices, __uuidof(IWbemServices));
_COM_SMARTPTR_TYPEDEF(IWbemLocator, __uuidof(IWbemLocator));
_COM_SMARTPTR_TYPEDEF(IWbemClassObject, __uuidof(IWbemClassObject));
_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject, __uuidof(IEnumWbemClassObject));
_COM_SMARTPTR_TYPEDEF(IWbemCallResult, __uuidof(IWbemCallResult));
_COM_SMARTPTR_TYPEDEF(IWbemStatusCodeText, __uuidof(IWbemStatusCodeText));


#define NLBMGR_USERNAME (const BSTR) NULL
#define NLBMGR_PASSWORD (const BSTR) NULL

void
GetErrorCodeText(WBEMSTATUS wStat , _bstr_t& errText );

// Class Definition
class MIPAddress
{
public:

    enum IPClass
    {
        classA,
        classB,
        classC,
        classD,
        classE
    };

    // Description
    // -----------
    // Checks if the ip address supplied is valid.
    //
    // IP address needs to be in dotted decimal 
    // for eg. 192.31.56.2, 128.1.1.1, 1.1.1.1 etc.
    // ip addresses in the form 192.31 are not allowed.
    // There must be exactly four parts.
    //
    //
    // Parameters
    // ----------
    // ipAddrToCheck   in     : ipAddr to check in dotted dec notation.
    //
    // Returns
    // -------
    // true if valid else false.

    static
    bool
    checkIfValid(const _bstr_t&  ipAddrToCheck );

    // Description
    // -----------
    // Gets the default subnet mask for ip address.  The ip address 
    // needs to be valid for operation to be successful.
    //
    // IP address needs to be in dotted decimal 
    // for eg. 192.31.56.2, 128.1.1.1, 1.1.1.1 etc.
    // ip addresses in the form 192.31 are not allowed.
    // There must be exactly four parts.
    //
    // Parameters
    // ----------
    // ipAddress     IN     : ip address for which default subnet required.
    // subnetMask    OUT    : default subnet mask for ip.
    //
    // Returns
    // -------
    // true if able to find default subnet or false if ipAddress was
    // invalid.

    static
    bool
    getDefaultSubnetMask( const _bstr_t& ipAddr,
                          _bstr_t&       subnetMask  );

    // Description
    // -----------
    // Gets the class to which this ip address belongs.
    // class A: 1   - 126
    // class B: 128 - 191
    // class C: 192 - 223
    // class D: 224 - 239
    // class D: 240 - 247
    //
    // IP address needs to be in dotted decimal 
    // for eg. 192.31.56.2, 128.1.1.1, 1.1.1.1 etc.
    // ip addresses in the form 192.31 are not allowed.
    // There must be exactly four parts.
    //
    // Parameters
    // ----------
    // ipAddress     IN     : ip address for which class is to be found.
    // ipClass       OUT    : class to which ip belongs.
    //
    // Returns
    // -------
    // true if able to find class or false if not able to find.
    // 

    static
    bool
    getIPClass( const _bstr_t& ipAddr, 
                IPClass&       ipClass );
    
    static
    bool
    isValidIPAddressSubnetMaskPair( const _bstr_t& ipAddress,
                                    const _bstr_t& subnetMask );

    static
    bool
    isContiguousSubnetMask( const _bstr_t& subnetMask );

private:

};

//------------------------------------------------------
// Ensure Type Safety
//------------------------------------------------------
typedef class MIPAddress MIPAddress;

class MUsingCom
{
public:

    enum MUsingCom_Error
    {
        MUsingCom_SUCCESS = 0,
        
        COM_FAILURE       = 1,
    };


    // constructor
    MUsingCom( DWORD  type = COINIT_DISABLE_OLE1DDE | COINIT_MULTITHREADED );

    // destructor
    ~MUsingCom();

    //
    MUsingCom_Error
    getStatus();

private:
    MUsingCom_Error status;
};


class ResourceString
{

public:

    static
    ResourceString*
    Instance();

    static
    const _bstr_t&
    GetIDString( UINT id );

protected:

private:
    static map< UINT, _bstr_t> resourceStrings;

    static ResourceString* _instance;

};

// helper functions
const _bstr_t&
GETRESOURCEIDSTRING( UINT id );

#include <vector>
using namespace std;


//
//------------------------------------------------------
//
//------------------------------------------------------
// External References
//------------------------------------------------------
//
//------------------------------------------------------
// Constant Definitions
//
//------------------------------------------------------
class WTokens
{
public:
    //
    //    
    // data
    // none
    //
    // constructor
    //------------------------------------------------------
    // Description
    // -----------
    // constructor
    //
    // Returns
    // -------
    // none.
    //
    //------------------------------------------------------
    WTokens( 
        wstring strToken,     // IN: Wstring to tokenize.
        wstring strDelimit ); // IN: Delimiter.
    //
    //------------------------------------------------------
    // Description
    // -----------
    // Default constructor
    //
    // Returns
    // -------
    // none.
    //
    //------------------------------------------------------
    WTokens();
    //
    // destructor
    //------------------------------------------------------
    // Description
    // -----------
    // destructor
    //
    // Returns
    // -------
    // none.
    //------------------------------------------------------
    ~WTokens();
    //
    // member functions
    //------------------------------------------------------
    // Description
    // -----------
    //
    // Returns
    // -------
    // The tokens.
    //------------------------------------------------------
    vector<wstring>
    tokenize();
    //
    //------------------------------------------------------
    // Description
    // -----------
    // constructor
    //
    // Returns
    // -------
    // none.
    //
    //------------------------------------------------------
    void
    init( 
        wstring strToken,     // IN: Wstring to tokenize.
        wstring strDelimit ); // IN: Delimiter.
    //
protected:
    // Data
    // none
    //
    // Constructors
    // none
    //
    // Destructor
    // none
    //
    // Member Functions
    // none
    //
private:
    //
    /// Data
    wstring _strToken;
    wstring _strDelimit;
    //
    /// Constructors
    /// none
    //
    /// Destructor
    /// none
    //
    /// Member Functions
    /// none
    //
};

HKEY
NlbMgrRegCreateKey(
    LPCWSTR szSubKey // Optional
    );

UINT
NlbMgrRegReadUINT(
    HKEY hKey,
    LPCWSTR szName,
    UINT Default
    );

VOID
NlbMgrRegWriteUINT(
    HKEY hKey,
    LPCWSTR szName,
    UINT Value
    );

void
GetTimeAndDate(_bstr_t &bstrTime, _bstr_t &bstrDate);

//
//------------------------------------------------------
// Inline Functions
//------------------------------------------------------
//
//------------------------------------------------------
// Ensure Type Safety
//------------------------------------------------------
typedef class WTokens WTokens;


//
// Used for maintaining a log on the stack. 
// Usage is NOT thread-safe -- each instance must be used
// by a single thread.
//
class CLocalLogger
{
    public:
    
        CLocalLogger(VOID)
        :  m_pszLog (NULL), m_LogSize(0), m_CurrentOffset(0)
        {
            m_Empty[0] = 0; // The empty string.
        }
        
        ~CLocalLogger()
        {
            delete[] m_pszLog;
            m_pszLog=NULL;
        }
    
        VOID
        LogString(
            LPCWSTR szStr
        );
        

        VOID
        Log(
            IN UINT ResourceID,
            ...
        );

        
    
        VOID
        ExtractLog(OUT LPCWSTR &pLog, UINT &Size)
        //
        // pLog --  set to pointer to internal buffer if there is stuff in the
        //          log, otherwise NULL.
        //
        // Size -- in chars; includes ending NULL
        //
        {
            if (m_CurrentOffset != 0)
            {
                pLog = m_pszLog;
                Size = m_CurrentOffset+1; // + 1 for ending NULL.
            }
            else
            {
                pLog = NULL;
                Size = 0;
            }
        }

        LPCWSTR
        GetStringSafe(void)
        {
            LPCWSTR szLog = NULL;
            UINT Size;
            ExtractLog(REF szLog, REF Size);
            if (szLog == NULL)
            {
                //
                // Replace NULL by a pointer to an empty string.
                //
                szLog = m_Empty;
            }

            return szLog;
        }

    private:
    
    WCHAR *m_pszLog;
    UINT m_LogSize;       // Current size of the log.
    UINT m_CurrentOffset;     // Characters left in the log.
    WCHAR m_Empty[1];  // The empty string.
};

NLBERROR
AnalyzeNlbConfiguration(
    IN const NLB_EXTENDED_CLUSTER_CONFIGURATION &Cfg,
    IN OUT CLocalLogger &logErrors
    );
//
// logErrors - a log of config errors
//

NLBERROR
AnalyzeNlbConfigurationPair(
    IN const NLB_EXTENDED_CLUSTER_CONFIGURATION &Cfg,
    IN const NLB_EXTENDED_CLUSTER_CONFIGURATION &OtherCfg,
    IN BOOL             fOtherIsCluster,
    IN BOOL             fCheckOtherForConsistancy,
    OUT BOOL            &fConnectivityChange,
    IN OUT CLocalLogger &logErrors,
    IN OUT CLocalLogger &logDifferences
    );
//
// logErrors - a log of config errors
// logDifferences - a log of differences between
//      Cfg and UpOtherCfg.
// fCheckOtherForConsistancy -- if true, we will check Cfg 
//      against pOtherCfg. If fOtherIsCluster, we expect
//      cluster wide properties to match, else we expect
//      cluster-wide properties to match as well as host-specific
//      properteis to not conflict.
//

//
// Processes the windows and afx msg loops.
//

void
ProcessMsgQueue(void);


//
// Max length in chars, and including ending NULL, for an encrypted
// password.
//
#define MAX_ENCRYPTED_PASSWORD_LENGTH \
            (2*sizeof(WCHAR)*(CREDUI_MAX_PASSWORD_LENGTH+1))

BOOL
PromptForEncryptedCreds(
    IN      HWND    hWnd,
    IN      LPCWSTR szCaptionText,
    IN      LPCWSTR szMessageText,
    IN OUT  LPWSTR  szUserName,
    IN      UINT    cchUserName,
    IN OUT  LPWSTR  szPassword,  // encrypted password
    IN      UINT    cchPassword       // size of szPassword
    );

#endif // _UTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\nlbclientlib\myntrtl.h ===
//
// These are taken from NTRTL.H. Currently including ntrtl.h causes
// errors because of a conflict with some other header file.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\vipspage.h ===
//***************************************************************************
//
//  VIPSPAGE.H
// 
//  Module: NLB Manager EXE
//
//  Purpose: Interface to the "Cluster IP Addresses" dialog.
//
//  Copyright (c)2001 Microsoft Corporation, All Rights Reserved
//
//  History:
//
//  09/23/01    JosephJ Created
//
//***************************************************************************
#pragma once


class VipsPage : public CPropertyPage
{

public:

    enum
    {
        IDD = IDD_DIALOG_CLUSTER_IPS
    };


    VipsPage(
                 CPropertySheet *psh,
                 NLB_EXTENDED_CLUSTER_CONFIGURATION *pNlbCfg,
                 BOOL fClusterView,
                 CWnd* parent
                );

    virtual BOOL OnInitDialog();

    virtual void OnOK();

    virtual BOOL OnSetActive();
    virtual BOOL OnKillActive();

    // overrides CDialog -- see SDK documentation on DoDataExchange.
    // Used to map controls in resources to corresponding objects in this class.
    virtual void DoDataExchange( CDataExchange* pDX );

    afx_msg BOOL OnHelpInfo (HELPINFO* helpInfo );
    afx_msg void OnContextMenu( CWnd* pWnd, CPoint point );
    afx_msg void OnButtonAdd();
    afx_msg void OnButtonRemove();
    afx_msg void OnButtonEdit();
    afx_msg void OnSelchanged(NMHDR * pNotifyStruct, LRESULT * result );
    afx_msg void OnDoubleClick(NMHDR * pNotifyStruct, LRESULT * result );
    afx_msg void OnUpdateEditAddVip();

private:

    BOOL m_fClusterView;
    BOOL m_fModified; // If it's been modified since we've last saved stuff
                      // to m_pNlbCfg;
    UINT m_uPrimaryClusterIp; // UINT version of cluster ip, in network order
    CEdit       editAddVip;
    CListCtrl	listAdditionalVips;
    
    void
    mfn_SaveToNlbCfg(void);

    void
    mfn_LoadFromNlbCfg(void);

    void
    mfn_InitializeListView(void);

    void
    mfn_InsertNetworkAddress(
            LPCWSTR szIP,
            LPCWSTR szSubnetMask,
            UINT lParam,
            int nItem
            );

    CPropertySheet *m_pshOwner;


    NLB_EXTENDED_CLUSTER_CONFIGURATION *m_pNlbCfg;

    static
    DWORD
    s_HelpIDs[];

    DECLARE_MESSAGE_MAP()
};

#define MAXIPSTRLEN 15 /* xxx.xxx.xxx.xxx */

class CIPAddressDialog : public CDialog {
public:
    enum { IDD = IDD_DIALOG_IP_ADDRESS };

    CIPAddressDialog (LPWSTR szIPAddress, LPWSTR szSubnetMask);
    ~CIPAddressDialog ();

    // overrides CDialog -- see SDK documentation on DoDataExchange.
    // Used to map controls in resources to corresponding objects in this class.
    virtual void DoDataExchange( CDataExchange* pDX );

public:
    virtual BOOL OnInitDialog();

    virtual void OnOK();

    void OnEditSubnetMask();

    afx_msg BOOL OnHelpInfo (HELPINFO* helpInfo );
    afx_msg void OnContextMenu( CWnd* pWnd, CPoint point );

    LPWSTR GetIPAddress() { return _wcsdup(address.IpAddress); }
    LPWSTR GetSubnetMask() { return _wcsdup(address.SubnetMask); }

private:
    DWORD WideStringToIPAddress (const WCHAR*  wszIPAddress);
    void IPAddressToWideString (DWORD dwIPAddress, LPWSTR wszIPAddress);
    void GetIPAddressOctets (LPWSTR wszIPAddress, DWORD dwIPAddress[4]);
    BOOL IsValid (LPWSTR szIPAddress, LPWSTR szSubnetMask);
    BOOL IsContiguousSubnetMask (LPWSTR wszSubnetMask);
    BOOL CIPAddressDialog::GenerateSubnetMask (LPWSTR wszIPAddress,
             UINT cchSubnetMask,
             LPWSTR wszSubnetMask
             );

    CIPAddressCtrl IPAddress;
    CIPAddressCtrl SubnetMask;

    NLB_IP_ADDRESS_INFO address;

    static
    DWORD
    s_HelpIDs[];

    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\inc\nlberr.h ===
//***************************************************************************
//
//  NLBERR.H
// 
//  Purpose: A list of NLB-specific error codes that are visible
//           externally, via WMI.
//
//  Copyright (c)2001 Microsoft Corporation, All Rights Reserved
//
//  History:
//
//  08/01/01    JosephJ Created
//
//***************************************************************************
#pragma once

/*

    NLB ERRORs are reported in two UINTs.

    The first UINT identifies the error "meta-type" -- WBEM rror, wlbscrl error,
    or errro defined here itself.

    The second UINT is specific to the meta-type.
*/

typedef UINT NLBMETAERROR;
//
// It's values are one of the NLBMETAERR_XXX constants below.
//


typedef UINT NLBERROR;
//
// It's values are one of the NLBERR_XXX constants below.
//


#define NLBMETAERR_OK         0 // NO ERROR -- SUCCESS
#define NLBMETAERR_NLBERR     1 // One of the NLBERR_XXX constants below
#define NLBMETAERR_WLBSCTRL   2 // A WLBS error defined in wlbsctrl.h
#define NLBMETAERR_WIN32      3 // A Win32 Error
#define NLBMETAERR_HRESULT    4 // A HRESULT Error (includes WBEMSTATUS)


//
// Utility macros. NOTE: NLBERR_NO_CHANGE is considered an error by
// these macros. The return value of the few APIs that return NLBERR_NO_CHANGE
// need to be processed specially.
//
#define NLBOK(_nlberr)     ( (_nlberr) == NLBERR_OK)
#define NLBFAILED(_nlberr) (!NLBOK(_nlberr))

#define NLBERR_OK                               0

//
// General errors
//
#define NLBERR_INTERNAL_ERROR                   100
#define NLBERR_RESOURCE_ALLOCATION_FAILURE      101
#define NLBERR_LLAPI_FAILURE                    102
#define NLBERR_UNIMPLEMENTED                    103
#define NLBERR_NOT_FOUND                        104
#define NLBERR_ACCESS_DENIED                    105
#define NLBERR_NO_CHANGE                        106
#define NLBERR_INITIALIZATION_FAILURE           107
#define NLBERR_CANCELLED                        108
#define NLBERR_BUSY                             109
#define NLBERR_OPERATION_FAILED                 110

//
// Errors related to analyze and update-configuration.
//
#define NLBERR_OTHER_UPDATE_ONGOING             200
#define NLBERR_UPDATE_PENDING                   201
#define NLBERR_INVALID_CLUSTER_SPECIFICATION    202
#define NLBERR_INVALID_IP_ADDRESS_SPECIFICATION 203
#define NLBERR_COULD_NOT_MODIFY_IP_ADDRESSES    204
#define NLBERR_SUBNET_MISMATCH                  205
#define NLBERR_NLB_NOT_INSTALLED                306
#define NLBERR_CLUSTER_IP_ALREADY_EXISTS        307
#define NLBERR_INTERFACE_NOT_FOUND              308
#define NLBERR_INTERFACE_NOT_BOUND_TO_NLB       309
#define NLBERR_INTERFACE_NOT_COMPATIBLE_WITH_NLB    310
#define NLBERR_INTERFACE_DISABLED               311
#define NLBERR_HOST_NOT_FOUND                   312

//
// Errors related to remote configuration through WMI
//
#define NLBERR_AUTHENTICATION_FAILURE           400
#define NLBERR_RPC_FAILURE                      401
#define NLBERR_PING_HOSTUNREACHABLE             402
#define NLBERR_PING_CANTRESOLVE                 403
#define NLBERR_PING_TIMEOUT                     404


//
// Errors related to cluster-wide analysis
//
#define NLBERR_INCONSISTANT_CLUSTER_CONFIGURATION 501
#define NLBERR_MISMATCHED_PORTRULES           502
#define NLBERR_HOSTS_PARTITIONED              503
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\inc\nlbclient.h ===
/*++

Copyright(c) 2001  Microsoft Corporation

Module Name:

    NLB Manager

File Name:

    nlbclient.h

Abstract:

    Header file for NLB client-side WMI utility functions to configure
    an NLB host.

    Lib which implements the functionality is in
    nlbmgr\nlbclientlib.

History:

    07/23/01    JosephJ Created (used to be nlbmgr\provider\tests\nlbhost.h)

--*/

typedef struct
{
 	LPCWSTR              szMachine;   // Must be non-NULL
 	LPCWSTR              szUserName;  // NULL == use current
 	LPCWSTR              szPassword;  // NULL == use current
    
} WMI_CONNECTION_INFO, *PWMI_CONNECTION_INFO;

//
// Specify this value for hashed remote control pwd
//
#define INVALID_HASHED_REMOTE_CONTROL_PASSWORD_VALUE 1783995a

typedef
VOID
(*PFN_LOGGER)(
    PVOID           Context,
    const   WCHAR * Text
    );

VOID
NlbHostFake(
    VOID)
    ;
/*
    Makes the NlbHostXXX apis operate in "fake mode", where they don't
    actually connect to any real machines.
*/

WBEMSTATUS
NlbHostGetConfiguration(
    IN  PWMI_CONNECTION_INFO pConnInfo, // NULL implies local
    IN  LPCWSTR              szNicGuid,
    OUT PNLB_EXTENDED_CLUSTER_CONFIGURATION pCurrentCfg
    );


WBEMSTATUS
NlbHostGetCompatibleNics(
    IN  PWMI_CONNECTION_INFO pConnInfo, // NULL implies local
    OUT LPWSTR **ppszNics,  // free using delete
    OUT UINT   *pNumNics,  // free using delete
    OUT UINT   *pNumBoundToNlb
    );


WBEMSTATUS
NlbHostGetMachineIdentification(
    IN  PWMI_CONNECTION_INFO pConnInfo, // NULL implies local
    OUT LPWSTR *pszMachineName, // free using delete
    OUT LPWSTR *pszMachineGuid,  OPTIONAL // free using delete -- may be null
    OUT BOOL *pfNlbMgrProviderInstalled // If nlb manager provider is installed.
    );


WBEMSTATUS
NlbHostDoUpdate(
    IN  PWMI_CONNECTION_INFO pConnInfo, // NULL implies local
    IN  LPCWSTR              szNicGuid,
    IN  LPCWSTR              szClientDescription,
    IN  PNLB_EXTENDED_CLUSTER_CONFIGURATION pNewState,
    OUT UINT                 *pGeneration,
    OUT WCHAR                **ppLog    // free using delete operator.
);


WBEMSTATUS
NlbHostGetUpdateStatus(
    IN  PWMI_CONNECTION_INFO pConnInfo, // NULL implies local
    IN  LPCWSTR              szNicGuid,
    IN  UINT                 Generation,
    OUT WBEMSTATUS           *pCompletionStatus,
    OUT WCHAR                **ppLog    // free using delete operator.
    );

WBEMSTATUS
NlbHostControlCluster(
    IN  PWMI_CONNECTION_INFO pConnInfo, 
    IN  LPCWSTR              szNicGuid,
    IN  LPCWSTR              szVip,
    IN  DWORD               *pdwPortNum,
    IN  WLBS_OPERATION_CODES Operation,
    OUT DWORD               *pdwOperationStatus,
    OUT DWORD               *pdwClusterOrPortStatus,
    OUT DWORD               *pdwHostMap
    );

WBEMSTATUS
NlbHostGetClusterMembers(
    IN  PWMI_CONNECTION_INFO    pConnInfo, 
    IN  LPCWSTR                 szNicGuid,
    OUT DWORD                   *pNumMembers,
    OUT NLB_CLUSTER_MEMBER_INFO **ppMembers       // free using delete[]
    );

//
// Attempts to resolve the ip address and ping the host.
//
WBEMSTATUS
NlbHostPing(
    LPCWSTR szBindString,
    UINT    Timeout, // In milliseconds.
    OUT ULONG  *pResolvedIpAddress // in network byte order.
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\nlbclientlib\fake.h ===
/*++

Copyright(c) 2001  Microsoft Corporation

Module Name:

    NLB Manager

File Name:

    Fake.h

Abstract:

    Fake Implementation of NlbHostXXX Apis (FakeNlbHostXXX apis)

    NLBHost is responsible for connecting to an NLB host and getting/setting
    its NLB-related configuration.

History:

    09/02/01    JosephJ Created

--*/

VOID
FakeInitialize(VOID);

WBEMSTATUS
FakeNlbHostGetMachineIdentification(
    IN  PWMI_CONNECTION_INFO pConnInfo, // NULL implies local
    OUT LPWSTR *pszMachineName, // free using delete
    OUT LPWSTR *pszMachineGuid,  // free using delete -- may be null
    OUT BOOL *pfNlbMgrProviderInstalled // If nlb manager provider is installed.
    );

WBEMSTATUS
FakeNlbHostGetCompatibleNics(
        PWMI_CONNECTION_INFO pConnInfo, // NULL implies local
        OUT LPWSTR **ppszNics,  // free using delete
        OUT UINT   *pNumNics,  // free using delete
        OUT UINT   *pNumBoundToNlb
        );


WBEMSTATUS
FakeNlbHostGetConfiguration(
 	IN  PWMI_CONNECTION_INFO  pConnInfo, // NULL implies local
    IN  LPCWSTR              szNicGuid,
    OUT PNLB_EXTENDED_CLUSTER_CONFIGURATION pCurrentCfg
    );


WBEMSTATUS
FakeNlbHostDoUpdate(
    IN  PWMI_CONNECTION_INFO pConnInfo, // NULL implies local
    IN  LPCWSTR              szNicGuid,
    IN  LPCWSTR              szClientDescription,
    IN  PNLB_EXTENDED_CLUSTER_CONFIGURATION pNewState,
    OUT UINT                 *pGeneration,
    OUT WCHAR                **ppLog    // free using delete operator.
);


WBEMSTATUS
FakeNlbHostGetUpdateStatus(
    IN  PWMI_CONNECTION_INFO pConnInfo, // NULL implies local
    IN  LPCWSTR              szNicGuid,
    IN  UINT                 Generation,
    OUT WBEMSTATUS           *pCompletionStatus,
    OUT WCHAR                **ppLog    // free using delete operator.
    );



WBEMSTATUS
FakeNlbHostPing(
    IN  LPCWSTR szBindString,
    IN  UINT    Timeout, // In milliseconds.
    OUT ULONG  *pResolvedIpAddress // in network byte order.
    );

WBEMSTATUS
FakeNlbHostControlCluster(
    IN  PWMI_CONNECTION_INFO pConnInfo, // NULL implies local
    IN  LPCWSTR              szNicGuid,
    IN  LPCWSTR              szVip,
    IN  DWORD               *pdwPortNum,
    IN  WLBS_OPERATION_CODES Operation,
    OUT DWORD               *pdwOperationStatus,
    OUT DWORD               *pdwClusterOrPortStatus,
    OUT DWORD               *pdwHostMap
    );

WBEMSTATUS
FakeNlbHostGetClusterMembers(
    IN  PWMI_CONNECTION_INFO    pConnInfo,  // NULL implies local
    IN  LPCWSTR                 szNicGuid,
    OUT DWORD                   *pNumMembers,
    OUT NLB_CLUSTER_MEMBER_INFO **ppMembers       // free using delete[]
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\nlbclientlib\fake.cpp ===
/*++
Copyright(c) 2001  Microsoft Corporation

Module Name:

    NLB Manager

File Name:

    Fake.cpp

Abstract:

    Fake Implementation of NlbHostXXX Apis (FakeNlbHostXXX apis)

    NLBHost is responsible for connecting to an NLB host and getting/setting
    its NLB-related configuration.

History:

    09/02/01    JosephJ Created

--*/
#include "private.h"

#define SZ_REG_HOSTS L"Hosts"               // Where host information is saved.
#define SZ_REG_FQDN L"FQDN"                 // Fully qualified domain name
#define SZ_REG_INTERFACES L"Interfaces"     // Fully qualified domain name

#define BASE_SLEEP 125

BOOL
is_ip_address(LPCWSTR szMachine);

HKEY
open_demo_key(LPCWSTR szSubKey, BOOL fCreate);

DWORD WINAPI FakeThreadProc(
  LPVOID lpParameter   // thread data
);

typedef struct
{
    LPCWSTR szDomainName;
    LPCWSTR szClusterNetworkAddress;
    LPCWSTR *pszPortRules;
    
} CLUSTER_INFO;

LPCWSTR rgPortRules1[] = {
            L"ip=255.255.255.255 protocol=UDP start=80 end=288 mode=MULTIPLE"
                                                L" affinity=NONE load=80",
            NULL
            }; 

CLUSTER_INFO
Cluster1Info =  {L"good1.com", L"10.0.0.100/255.0.0.0", rgPortRules1};



//
// Keeps track of a pending operation...
//
class CFakePendingInfo
{
public:
    CFakePendingInfo(const NLB_EXTENDED_CLUSTER_CONFIGURATION *pCfg)
    {
        wStatus = Config.Update(pCfg);

        if (!FAILED(wStatus))
        {
            wStatus = WBEM_S_PENDING;
        }
        // bstrLog;
    }

    NLB_EXTENDED_CLUSTER_CONFIGURATION Config;
    WBEMSTATUS wStatus;

    _bstr_t bstrLog;

};


typedef struct
{
    //
    // These fields are set on initialization
    //
    LPCWSTR szInterfaceGuid;
    LPCWSTR szFriendlyName;
    LPCWSTR szNetworkAddress;
    BOOL fNlb;
    BOOL fHidden;
    CLUSTER_INFO *pCluster1Info;
    UINT InitialHostPriority;

    //
    // These are set/updated
    //

    //
    // Current configuration
    //
    PNLB_EXTENDED_CLUSTER_CONFIGURATION pConfig;

    //
    // If there is a pending update, info about the pending update.
    //
    CFakePendingInfo *pPendingInfo;
    WBEMSTATUS CompletedUpdateStatus;

} FAKE_IF_INFO;

typedef struct
{
    LPCWSTR szHostName;
    LPCWSTR szFQDN;
    FAKE_IF_INFO *IfInfoList;
    LPCWSTR szUserName;
    LPCWSTR szPassword;

    //
    // Run-time state:
    //
    DWORD dwOperationalState; // WLBS_STOPPED, etc...

    BOOL fDead; // If set, we'll pretend this host is dead.

} FAKE_HOST_INFO;

WBEMSTATUS initialize_interface(FAKE_IF_INFO *pIF);

WBEMSTATUS  lookup_fake_if(
                FAKE_HOST_INFO *pHost,
                LPCWSTR szNicGuid,
                FAKE_IF_INFO **ppIF
                );

WBEMSTATUS  lookup_fake_host(
                LPCWSTR szConnectionString,
                FAKE_IF_INFO **ppIF,
                FAKE_HOST_INFO **ppHost
                );

FAKE_IF_INFO rgH1IfList[] = {
    { L"{H1I10000-0000-0000-0000-000000000000}",
      L"NLB-Front1",   L"172.31.56.101/255.0.0.0", FALSE },
    { L"{H1I20000-0000-0000-0000-000000000000}",
      L"back1",        L"10.0.0.1/255.0.0.0",      FALSE },
    { L"{H1I30000-0000-0000-0000-000000000000}",
      L"back2",        L"11.0.0.1/255.0.0.0",      FALSE }, { NULL }
};


FAKE_IF_INFO rgH2IfList[] = {

    { L"{H2I10000-0000-0000-0000-000000000000}",
      L"NLB-Front2",   L"172.31.56.102/255.0.0.0", FALSE },
    { L"{H2I20000-0000-0000-0000-000000000000}",
      L"back1",        L"10.0.0.2/255.0.0.0",      FALSE },
    { L"{H2I30000-0000-0000-0000-000000000000}",
      L"back2",        L"11.0.0.2/255.0.0.0",      FALSE },
    { NULL }
};


FAKE_IF_INFO rgH3IfList[] = {
    { L"{H3I10000-0000-0000-0000-000000000000}",
      L"NLB-Front3",   L"172.31.56.103/255.0.0.0", FALSE },
    { L"{H3I20000-0000-0000-0000-000000000000}",
      L"back1",        L"10.0.0.3/255.0.0.0",      FALSE },
    { L"{H3I30000-0000-0000-0000-000000000000}",
      L"back2",        L"11.0.0.3/255.0.0.0",      FALSE },
    { NULL }
};


FAKE_IF_INFO rgH4IfList[] = {
    { L"{H4I10000-0000-0000-0000-000000000000}",
      L"nic1",         L"10.1.0.1/255.0.0.0",      TRUE,  FALSE, &Cluster1Info},
    { L"{H4I20000-0000-0000-0000-000000000000}",
      L"nic2",         L"11.1.0.1/255.0.0.0",      FALSE },
    { L"{H4I30000-0000-0000-0000-000000000000}",
      L"nic3",         L"12.1.0.1/255.0.0.0",      FALSE },
    { NULL }
};

FAKE_IF_INFO rgH5IfList[] = {
    { L"{H5I10000-0000-0000-0000-000000000000}",
      L"nic1",         L"10.1.0.2/255.0.0.0",      TRUE },
    { L"{H5I20000-0000-0000-0000-000000000000}",
      L"nic2",         L"11.1.0.2/255.0.0.0",      FALSE },
    { L"{H5I30000-0000-0000-0000-000000000000}",
      L"nic3",         L"12.1.0.2/255.0.0.0",      FALSE },
    { NULL }
};

FAKE_IF_INFO rgH6IfList[] = {
    { L"{H6I10000-0000-0000-0000-000000000000}",
      L"nic1",         L"10.1.0.3/255.0.0.0",      TRUE },
    { L"{H6I20000-0000-0000-0000-000000000000}",
      L"nic2",         L"11.1.0.3/255.0.0.0",      FALSE },
    { L"{H6I30000-0000-0000-0000-000000000000}",
      L"nic3",         L"12.1.0.3/255.0.0.0",      FALSE },
    { NULL }
};

FAKE_HOST_INFO rgFakeHostInfo[] = 
{
    { L"NLB-A",   L"nlb-a.cheesegalaxy.com", rgH1IfList },
    { L"NLB-B",   L"nlb-b.cheesegalaxy.com", rgH2IfList },
    { L"NLB-C",   L"nlb-c.cheesegalaxy.com", rgH3IfList },
    { L"NLB-X",   L"nlb-x.cheesegalaxy.com", rgH4IfList },
    { L"NLB-Y",   L"nlb-y.cheesegalaxy.com", rgH5IfList },
    { L"NLB-Z",   L"nlb-z.cheesegalaxy.com", rgH6IfList, L"un", L"pwd" },
    { NULL }
};


class CFake
{

public:

    CFake(void)
    {
        InitializeCriticalSection(&m_crit);
    }

    ~CFake()
    {
        DeleteCriticalSection(&m_crit);
    }


    CRITICAL_SECTION m_Lock;

    PNLB_EXTENDED_CLUSTER_CONFIGURATION pConfig;

    // map<_bstr_t, PNLB_EXTENDED_CLUSTER_CONFIGURATION> mapGuidToExtCfg;
    // map<_bstr_t, UINT> mapGuidToExtCfg;

	CRITICAL_SECTION m_crit;

    void mfn_Lock(void) {EnterCriticalSection(&m_crit);}
    void mfn_Unlock(void) {LeaveCriticalSection(&m_crit);}
};

CFake gFake;


VOID
FakeInitialize(VOID)
{
    //
    // 
    //
}

LPWSTR
reg_read_string(
        HKEY hk,
        LPCWSTR szName,
        BOOL fMultiSz
        );

WBEMSTATUS
FakeNlbHostConnect(
    PWMI_CONNECTION_INFO pConnInfo, // NULL implies local
    OUT FAKE_HOST_INFO **pHost
    );


WBEMSTATUS
FakeNlbHostGetCompatibleNics(
        PWMI_CONNECTION_INFO pConnInfo, // NULL implies local
        OUT LPWSTR **ppszNics,  // free using delete
        OUT UINT   *pNumNics,  // free using delete
        OUT UINT   *pNumBoundToNlb
        )
{
    FAKE_HOST_INFO      *pHost = NULL;
    WBEMSTATUS          Status = WBEM_E_CRITICAL_ERROR;
    UINT                NumNics=0;
    UINT                NumBoundToNlb=0;
    LPWSTR              *pszNics = NULL;

    *ppszNics = NULL;
    *pNumNics = NULL;
    *pNumBoundToNlb = NULL;

    Status = FakeNlbHostConnect(pConnInfo, &pHost);

    gFake.mfn_Lock();

    if (FAILED(Status))
    {
        goto end;
    }

    FAKE_IF_INFO *pIF = NULL;

    for (pIF=pHost->IfInfoList; pIF->szInterfaceGuid!=NULL; pIF++)
    {
        if (!pIF->fHidden)
        {
            NumNics++;
        }
    }

    if (NumNics==0)
    {
        Status = WBEM_NO_ERROR;
        goto end;
        
    }
    //
    // Now let's  allocate space for all the nic strings and
    // copy them over..
    //
    #define MY_GUID_LENGTH  38
    pszNics =  CfgUtilsAllocateStringArray(NumNics, MY_GUID_LENGTH);
    if (pszNics == NULL)
    {
        Status = WBEM_E_OUT_OF_MEMORY;
        goto end;
    }

    for (pIF=pHost->IfInfoList; pIF->szInterfaceGuid!=NULL; pIF++)
    {
        UINT u = (UINT)(pIF-pHost->IfInfoList);
        UINT Len = wcslen(pIF->szInterfaceGuid);

        if (pIF->fHidden)
        {
            continue;
        }

        if (Len > MY_GUID_LENGTH)
        {
            ASSERT(FALSE);
            Status = WBEM_E_CRITICAL_ERROR;
            goto end;
        }
        CopyMemory(
            pszNics[u],
            pIF->szInterfaceGuid,
            (Len+1)*sizeof(WCHAR));
            ASSERT(pszNics[u][Len]==0);

        if (pIF->fNlb)
        {
            NumBoundToNlb++;
        }
    }

    Status = WBEM_NO_ERROR;

end:

    gFake.mfn_Unlock();

    if (FAILED(Status))
    {
        delete pszNics;
        pszNics = NULL;
        NumNics = 0;
        NumBoundToNlb = 0;
    }

    *ppszNics = pszNics;
    *pNumNics = NumNics;

    if (pNumBoundToNlb !=NULL)
    {
        *pNumBoundToNlb = NumBoundToNlb;
    }

    return Status;
}


WBEMSTATUS
FakeNlbHostGetMachineIdentification(
    IN  PWMI_CONNECTION_INFO pConnInfo, // NULL implies local
    OUT LPWSTR *pszMachineName, // free using delete
    OUT LPWSTR *pszMachineGuid,  // free using delete -- may be null
    OUT BOOL *pfNlbMgrProviderInstalled // If nlb manager provider is installed.
    )
{
    FAKE_HOST_INFO      *pHost = NULL;
    WBEMSTATUS          Status = WBEM_E_CRITICAL_ERROR;

    *pszMachineName = NULL;
    *pszMachineGuid = NULL;
    *pfNlbMgrProviderInstalled = TRUE;

    Status = FakeNlbHostConnect(pConnInfo, &pHost);

    if (FAILED(Status))
    {
        goto end;
    }

    //
    // Set WMI machine name
    //
    {
        UINT u = wcslen(pHost->szHostName);
        LPWSTR szMachineName = NULL;

        szMachineName = new WCHAR[u+1];
        if (szMachineName == NULL)
        {
            Status = WBEM_E_CRITICAL_ERROR;
            goto end;
        }
        StringCchCopy(szMachineName, u+1, pHost->szHostName);
        *pszMachineName = szMachineName;
    }

    Status = WBEM_NO_ERROR;

end:

    return Status;
}



WBEMSTATUS
FakeNlbHostGetConfiguration(
 	IN  PWMI_CONNECTION_INFO  pConnInfo, // NULL implies local
    IN  LPCWSTR              szNicGuid,
    OUT PNLB_EXTENDED_CLUSTER_CONFIGURATION pCurrentCfg
    )
{
    WBEMSTATUS          Status = WBEM_E_CRITICAL_ERROR;
    FAKE_HOST_INFO *pHost = NULL;

    Status = FakeNlbHostConnect(pConnInfo, &pHost);

    if (FAILED(Status))
    {
        goto end;
    }

    //
    // Look for the specified interface
    //
    FAKE_IF_INFO *pIF = NULL;

    Status = lookup_fake_if(pHost, szNicGuid, &pIF);

    if (!FAILED(Status))
    {
        gFake.mfn_Lock();
        Status = pCurrentCfg->Update(pIF->pConfig);
        gFake.mfn_Unlock();
    }

end:

    return Status;
}



WBEMSTATUS
FakeNlbHostDoUpdate(
    IN  PWMI_CONNECTION_INFO pConnInfo, // NULL implies local
    IN  LPCWSTR              szNicGuid,
    IN  LPCWSTR              szClientDescription,
    IN  PNLB_EXTENDED_CLUSTER_CONFIGURATION pNewState,
    OUT UINT                 *pGeneration,
    OUT WCHAR                **ppLog    // free using delete operator.
)
{
    WBEMSTATUS          Status = WBEM_E_CRITICAL_ERROR;
    FAKE_HOST_INFO *pHost = NULL;

    *ppLog = NULL;

    Status = FakeNlbHostConnect(pConnInfo, &pHost);

    if (FAILED(Status))
    {
        goto end;
    }

    //
    // Look for the specified interface
    //
    FAKE_IF_INFO *pIF = NULL;

    Status = lookup_fake_if(pHost, szNicGuid, &pIF);

    if (!FAILED(Status))
    {
        BOOL fSetPwd = FALSE;
        DWORD dwHashPwd = 0;


        //
        // Report if there's a password specified...
        //
        {
            LPCWSTR szNewPwd = pNewState->GetNewRemoteControlPasswordRaw();
            WCHAR rgTmp[256];
            if (szNewPwd == NULL)
            {
                BOOL fRet = FALSE;
    
                fRet = pNewState->GetNewHashedRemoteControlPassword(
                                    dwHashPwd
                                    );

                if (fRet)
                {
                    StringCbPrintf(rgTmp, sizeof(rgTmp), L"NewHashPwd=0x%08lx", dwHashPwd);
                    szNewPwd = rgTmp;
                    fSetPwd = TRUE;
                }
            }
            else
            {
                //
                // Create our own ad-hoc hash here...
                //
                for (LPCWSTR sz = szNewPwd; *sz; sz++)
                {
                    dwHashPwd ^= *sz;
                    if (dwHashPwd & 0x80000000)
                    {
                        dwHashPwd  <<= 1;
                        dwHashPwd  |= 1;
                    }
                    else
                    {
                        dwHashPwd  <<=1;
                    }
                }

                fSetPwd = TRUE;
            }

            if (szNewPwd != NULL)
            {
        #if 0
                ::MessageBox(
                     NULL,
                     szNewPwd, // msg
                     L"Update: new password specified!", // caption
                     MB_ICONINFORMATION   | MB_OK
                    );
        #endif // 0
            }
        }

        Sleep(2*BASE_SLEEP);
        gFake.mfn_Lock();
        NLB_EXTENDED_CLUSTER_CONFIGURATION NewCopy;
        Status = NewCopy.Update(pNewState);
        if (!FAILED(Status))
        {
            NLBERROR nerr;
            BOOL fConnChange = FALSE;
            DWORD dwOldHashPwd =  CfgUtilGetHashedRemoteControlPassword(
                                        &pIF->pConfig->NlbParams
                                        );

            //
            // Set the hashed pwd field if necessary, otherwise preserve
            // the old one.
            //
            if (!fSetPwd)
            {
                dwHashPwd = dwOldHashPwd;
            }

        #if 0
            if (dwHashPwd != dwOldHashPwd)
            {
                WCHAR buf[64];
                (void)StringCbPrintf(
                            buf,
                            sizeof(buf),
                            L"Old=0x%lx New=0x%lx",
                            dwOldHashPwd, dwHashPwd
                            );
                ::MessageBox(
                     NULL,
                     buf, // msg
                     L"Fake Update: Change in dwHashPwd!", // caption
                     MB_ICONINFORMATION   | MB_OK
                    );
            }
        #endif // 0

            CfgUtilSetHashedRemoteControlPassword(
                    &NewCopy.NlbParams,
                    dwHashPwd
                    );


            nerr = pIF->pConfig->AnalyzeUpdate(&NewCopy, &fConnChange);
            // TODO: if fConnChange, do stuff in background.
            if (NLBOK(nerr))
            {
                if (pIF->pPendingInfo != NULL)
                {
                    Status = WBEM_E_SERVER_TOO_BUSY;
                }
                else
                {
                    if (fConnChange)
                    {
                        //
                        // We'll do the update in the background.
                        //
                        CFakePendingInfo *pPendingInfo;
                        pPendingInfo = new CFakePendingInfo(&NewCopy);
                        if (pPendingInfo == NULL)
                        {
                            Status = WBEM_E_OUT_OF_MEMORY;
                        }
                        else
                        {
                            BOOL fRet;
                            pIF->pPendingInfo = pPendingInfo;
                            fRet = QueueUserWorkItem(
                                        FakeThreadProc,
                                        pIF,
                                        // WT_EXECUTEDEFAULT
                                        WT_EXECUTELONGFUNCTION
                                        );

                            if (fRet)
                            {
                                Status = WBEM_S_PENDING;
                            }
                            else
                            {
                                Status = WBEM_E_OUT_OF_MEMORY;
                                pIF->pPendingInfo = NULL;
                                delete pPendingInfo;
                            }
                        }
                    }
                    else
                    {
                        Status = pIF->pConfig->Update(&NewCopy);
                        pIF->pConfig->Generation++;
                    }
                }

            }
            else
            {
                if (nerr == NLBERR_NO_CHANGE)
                {
                    Status = WBEM_S_FALSE;
                }
                else if (nerr == NLBERR_INVALID_CLUSTER_SPECIFICATION)
                {
                    Status = WBEM_E_INVALID_PARAMETER;
                }
            }
        }

        gFake.mfn_Unlock();
    }


end:

    return Status;
}



WBEMSTATUS
FakeNlbHostGetUpdateStatus(
    IN  PWMI_CONNECTION_INFO pConnInfo, // NULL implies local
    IN  LPCWSTR              szNicGuid,
    IN  UINT                 Generation,
    OUT WBEMSTATUS           *pCompletionStatus,
    OUT WCHAR                **ppLog    // free using delete operator.
    )
{
    WBEMSTATUS          Status = WBEM_E_CRITICAL_ERROR;
    FAKE_HOST_INFO *pHost = NULL;

    Status = FakeNlbHostConnect(pConnInfo, &pHost);

    if (FAILED(Status))
    {
        goto end;
    }

    //
    // Look for the specified interface
    //
    FAKE_IF_INFO *pIF = NULL;

    Status = lookup_fake_if(pHost, szNicGuid, &pIF);

    if (!FAILED(Status))
    {
        gFake.mfn_Lock();

        if (pIF->pPendingInfo != NULL)
        {
            *pCompletionStatus = WBEM_S_PENDING;
        }
        else
        {
            *pCompletionStatus = pIF->CompletedUpdateStatus;
        }
        Status = WBEM_NO_ERROR;

        gFake.mfn_Unlock();
    }

end:

    return Status;
}


WBEMSTATUS
FakeNlbHostPing(
    IN  LPCWSTR szBindString,
    IN  UINT    Timeout, // In milliseconds.
    OUT ULONG  *pResolvedIpAddress // in network byte order.
    )
{
    WBEMSTATUS          Status = WBEM_E_CRITICAL_ERROR;
    FAKE_HOST_INFO *pHost = NULL;

    //Status = FakeNlbHostConnect(pConnInfo, &pHost);
    *pResolvedIpAddress = 0x0100000a;

    Status = WBEM_NO_ERROR;
    if (FAILED(Status))
    {
        goto end;
    }


end:

    return Status;
}

BOOL
is_ip_address(LPCWSTR szMachine)
/*
    Returns TRUE IFF szMachine is an IP address.
    It doesn't check if it's a valid IP address.
    In fact, all it checks is if it's only consisting
    of numbers and dots.
*/
{
    BOOL fRet = FALSE;
    #define BUFSZ 20
    WCHAR rgBuf[BUFSZ];

    if (wcslen(szMachine) >= BUFSZ)                 goto end;
    if (swscanf(szMachine, L"%[0-9.]", rgBuf)!=1)   goto end;
    if (wcscmp(szMachine, rgBuf))                   goto end;

    fRet = TRUE;

end:

    return fRet;

}

HKEY
open_demo_key(LPCWSTR szSubKey, BOOL fCreate)
/*
    Open nlbmanager demo registry key with read/write access.
*/
{
    WCHAR szKey[1024];
    HKEY hKey = NULL;
    LONG lRet;

    StringCbCopy(szKey, sizeof(szKey),
    L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\NLB\\NlbManager\\Demo"
    );
    if (szSubKey != NULL)
    {
        StringCbCat(szKey, sizeof(szKey), L"\\");
        StringCbCat(szKey, sizeof(szKey), szSubKey);
    }


    if (fCreate)
    {
        DWORD dwDisposition;
        lRet = RegCreateKeyEx(
                HKEY_LOCAL_MACHINE, // handle to an open key
                szKey,                // address of subkey name
                0,                  // reserved
                L"class",           // address of class string
                0,          //      special options flag
                KEY_ALL_ACCESS,     // desired security access
                NULL,               // address of key security structure
                &hKey,              // address of buffer for opened handle
                &dwDisposition   // address of disposition value buffer
                );
    }
    else
    {
        lRet = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE, // handle to an open key
                szKey,                // address of subkey name
                0,                  // reserved
                KEY_ALL_ACCESS,     // desired security access
                &hKey              // address of buffer for opened handle
                );
    }

    if (lRet != ERROR_SUCCESS)
    {
        hKey = NULL;
    }

    return hKey;
}

LPWSTR
reg_read_string(
        HKEY hk,
        LPCWSTR szName,
        BOOL fMultiSz
        )
/*
    Read a string from the registry, allocating memory using "new WCHAR"
*/
{
    LONG lRet;
    DWORD dwType;
    DWORD dwData = 0;
    DWORD dwDesiredType = REG_SZ;
    
    if (fMultiSz)
    {
        dwDesiredType = REG_MULTI_SZ;
    }

    lRet =  RegQueryValueEx(
              hk,         // handle to key to query
              szName,
              NULL,         // reserved
              &dwType,   // address of buffer for value type
              (LPBYTE) NULL, // address of data buffer
              &dwData  // address of data buffer size
              );
    if (    lRet != ERROR_SUCCESS
        ||  dwType != dwDesiredType
        ||  dwData <= sizeof(WCHAR))
    {
        goto end;
    }

    LPWSTR szValue  = new WCHAR[dwData/sizeof(WCHAR)+1]; // bytes to wchars

    if (szValue == NULL) goto end;


    lRet =  RegQueryValueEx(
              hk,         // handle to key to query
              szName,
              NULL,         // reserved
              &dwType,   // address of buffer for value type
              (LPBYTE) szValue, // address of data buffer
              &dwData  // address of data buffer size
              );
    if (    lRet != ERROR_SUCCESS
        ||  dwType != dwDesiredType
        ||  dwData <= sizeof(WCHAR))
    {
        delete[] szValue;
        szValue  = NULL;
        goto end;
    }


end:

    return szValue;
}

WBEMSTATUS
FakeNlbHostConnect(
    PWMI_CONNECTION_INFO pConnInfo, // NULL implies local
    OUT FAKE_HOST_INFO **ppHost
    )
{

    WBEMSTATUS Status = WBEM_E_CRITICAL_ERROR;

    /*
        For now, just look for machine name of fqdn
    */

    FAKE_HOST_INFO *pfhi = rgFakeHostInfo;

    LPCWSTR szHostName;
    LPCWSTR szFQDN;
    FAKE_IF_INFO *IfInfoList;
    LPCWSTR szMachine = NULL;
    LPCWSTR szUserName = pConnInfo->szUserName;
    LPCWSTR szPassword = pConnInfo->szPassword;
    
    *ppHost = NULL;

    if (pConnInfo == NULL)
    {
        // We don't support local connections.
        Status = WBEM_E_NOT_FOUND;
        goto end;
    }

    if (szUserName == NULL)
    {
        szUserName = L"null-name";
    }

    szMachine = pConnInfo->szMachine; // should not be NULL.
    
    for (; pfhi->szHostName != NULL; pfhi++)
    {
        if (   !_wcsicmp(szMachine, pfhi->szHostName)
            || !_wcsicmp(szMachine, pfhi->szFQDN))
        {
            break;
        }
    }
    if (pfhi->szHostName == NULL || pfhi->fDead)
    {
        Sleep(3*BASE_SLEEP);
        Status = WBEM_E_NOT_FOUND;
    }
    else
    {
        Sleep(BASE_SLEEP);

        if (pfhi->szUserName != NULL)
        {

            WCHAR   rgClearPassword[128];
            if (szPassword == NULL)
            {
                ARRAYSTRCPY(rgClearPassword, L"null-password");
            }
            else
            {
                BOOL fRet = CfgUtilDecryptPassword(
                                szPassword,
                                ASIZE(rgClearPassword),
                                rgClearPassword
                                );
    
                if (!fRet)
                {
                    ARRAYSTRCPY(rgClearPassword, L"bogus-password");
                }
            }
    

            if (   !_wcsicmp(szUserName, pfhi->szUserName)
                && !_wcsicmp(rgClearPassword, pfhi->szPassword))
                    
            {
                Status = WBEM_NO_ERROR;
                *ppHost = pfhi;
            }
            else
            {
                Status = (WBEMSTATUS) E_ACCESSDENIED;
            }

            // We don't need to put this here, because
            // this is fake (demo-mode) code:
            // RtlSecureZeroMemory(rgClearPassword);
        }
        else
        {
                Status = WBEM_NO_ERROR;
                *ppHost = pfhi;
        }
    }

end:
    return  Status;

}

WBEMSTATUS initialize_interface(FAKE_IF_INFO *pIF)
{
    WBEMSTATUS  Status = WBEM_E_CRITICAL_ERROR;
    PNLB_EXTENDED_CLUSTER_CONFIGURATION pConfig = NULL;

    if (pIF->pConfig != NULL)
    {
        ASSERT(FALSE);
        goto end;
    }
    pConfig = new NLB_EXTENDED_CLUSTER_CONFIGURATION;

    if (pConfig == NULL) goto end;

    Status =  pConfig->SetFriendlyName(pIF->szFriendlyName);

    if (FAILED(Status)) goto end;

    Status = pConfig->SetNetworkAddresses(&pIF->szNetworkAddress, 1);

    if (FAILED(Status)) goto end;

    if (pIF->fNlb)
    {
        pConfig->SetDefaultNlbCluster();
        pConfig->SetClusterName(L"BadCluster.COM");
    }
    pIF->pConfig = pConfig;
    pIF->pConfig->Generation = 1;
    pIF->pPendingInfo = NULL;
    pIF->CompletedUpdateStatus = WBEM_E_CRITICAL_ERROR;

end:
    return Status;
}

WBEMSTATUS  lookup_fake_if(
                FAKE_HOST_INFO *pHost,
                LPCWSTR szNicGuid,
                FAKE_IF_INFO **ppIF
                )
{
    WBEMSTATUS  Status = WBEM_E_CRITICAL_ERROR;
    FAKE_IF_INFO *pIF;

    *ppIF = NULL;

    for (pIF=pHost->IfInfoList; pIF->szInterfaceGuid!=NULL; pIF++)
    {
       if (!wcscmp(szNicGuid, pIF->szInterfaceGuid))
       {
            if (!pIF->fHidden)
            {
                break;
            }
       }
    }

    if (pIF->szInterfaceGuid==NULL)
    {
        Status = WBEM_E_NOT_FOUND;
        goto end;
    }

    //
    // Perform on-demand initialization
    //
    {
        Status = WBEM_NO_ERROR;

        gFake.mfn_Lock();
        if (pIF->pConfig == NULL)
        {
            Status = initialize_interface(pIF);
            ASSERT(pIF->pConfig!=NULL);
        }
        gFake.mfn_Unlock();
        *ppIF = pIF;
    }

end:

    return Status;
}


WBEMSTATUS  lookup_fake_host(
                LPCWSTR szConnectionString,
                FAKE_IF_INFO **ppIF,
                FAKE_HOST_INFO **ppHost
                );

WBEMSTATUS
FakeNlbHostControlCluster(
    IN  PWMI_CONNECTION_INFO pConnInfo, // NULL implies local
    IN  LPCWSTR              szNicGuid,
    IN  LPCWSTR              szVip,
    IN  DWORD               *pdwPortNum,
    IN  WLBS_OPERATION_CODES Operation,
    OUT DWORD               *pdwOperationStatus,
    OUT DWORD               *pdwClusterOrPortStatus,
    OUT DWORD               *pdwHostMap
)
{
    FAKE_HOST_INFO      *pHost = NULL;
    WBEMSTATUS          Status = WBEM_E_CRITICAL_ERROR;
    DWORD dwPort = 0;
    LPCWSTR szPort = L"(null)";
    LPCWSTR szOp = L"";
    if (pdwPortNum != NULL)
    {
        dwPort = *pdwPortNum;
        szPort = L"";
    }

    if (szVip == NULL)
    {
        szVip = L"null";
    }
   
    Status = FakeNlbHostConnect(pConnInfo, &pHost);

    if (FAILED(Status))
    {
        goto end;
    }

    DWORD dwOperationalState = WLBS_CONVERGED;

    if (pHost->dwOperationalState != 0)
    {
        dwOperationalState = pHost->dwOperationalState;
    }

    switch(Operation)
    {
    case WLBS_START:
        szOp = L"start";
        if (dwOperationalState == WLBS_STOPPED)
        {
            dwOperationalState = WLBS_CONVERGING;
        }
        else
        {
            dwOperationalState = WLBS_CONVERGED;
        }
        break;
    case WLBS_STOP:
        szOp = L"stop";
        dwOperationalState = WLBS_STOPPED;
        break;
    case WLBS_DRAIN:      
        szOp = L"drain";
        dwOperationalState = WLBS_DRAINING;
        break;
    case WLBS_SUSPEND:     
        szOp = L"suspend";
        dwOperationalState = WLBS_SUSPENDED;
        break;
    case WLBS_RESUME:       
        szOp = L"resume";
        // dwOperationalState = WLBS_CONVERGED;
        dwOperationalState = WLBS_DISCONNECTED;
        break;
    case WLBS_PORT_ENABLE:  
        szOp = L"port-enable";
        break;
    case WLBS_PORT_DISABLE:  
        szOp = L"port-disable";
        break;
    case WLBS_PORT_DRAIN:     
        szOp = L"port-drain";
        break;
    case WLBS_QUERY:           
        szOp = L"query";
        break;
    case WLBS_QUERY_PORT_STATE:
        szOp = L"port-query";
        break;
    default:
        szOp = L"unknown";
        break;
    }

    wprintf(
        L"FakeNlbHostControlCluster: op=%ws "
        L"ip=%ws "
        L"Port=%lu%ws\n",
        szOp,
        szVip,
        dwPort, szPort
        );

    pHost->dwOperationalState = dwOperationalState;
    *pdwOperationStatus     =  WLBS_ALREADY; // dummy values ...
    *pdwClusterOrPortStatus =  dwOperationalState;
    *pdwHostMap             =  0x3;

end:

    return Status;

}


WBEMSTATUS
FakeNlbHostGetClusterMembers(
    IN  PWMI_CONNECTION_INFO    pConnInfo,  // NULL implies local
    IN  LPCWSTR                 szNicGuid,
    OUT DWORD                   *pNumMembers,
    OUT NLB_CLUSTER_MEMBER_INFO **ppMembers       // free using delete[]
    )
{
    WBEMSTATUS      Status = WBEM_E_CRITICAL_ERROR;
    FAKE_HOST_INFO  *pHost = NULL;

    *pNumMembers    = 0;
    *ppMembers      = NULL;

    Status = FakeNlbHostConnect(pConnInfo, &pHost);

    if (FAILED(Status))
    {
        goto end;
    }

    //
    // Look for the specified interface
    //
    FAKE_IF_INFO *pIF = NULL;

    Status = lookup_fake_if(pHost, szNicGuid, &pIF);

    if (!FAILED(Status))
    {
        gFake.mfn_Lock();

        if (pIF->pConfig->IsValidNlbConfig())
        {
            NLB_CLUSTER_MEMBER_INFO *pMembers;
            pMembers = new NLB_CLUSTER_MEMBER_INFO[1];
            if (pMembers == NULL)
            {
                Status = WBEM_E_OUT_OF_MEMORY;
            }
            else
            {
                ZeroMemory(pMembers, sizeof(*pMembers));
                pMembers->HostId = pIF->pConfig->NlbParams.host_priority;
                StringCbCopy(
                    pMembers->DedicatedIpAddress,
                    sizeof(pMembers->DedicatedIpAddress),
                    pIF->pConfig->NlbParams.ded_ip_addr
                    );
                StringCbCopy(
                    pMembers->HostName,
                    sizeof(pMembers->HostName),
                    pHost->szFQDN
                    );
                *pNumMembers = 1;
                *ppMembers = pMembers;
            }
        }

        gFake.mfn_Unlock();
    }

end:

    return Status;
}

DWORD WINAPI FakeThreadProc(
  LPVOID lpParameter   // thread data
)
{
    FAKE_IF_INFO *pIF = (FAKE_IF_INFO *) lpParameter;

    //
    // Display the msg box to block input.
    //
    {
        WCHAR rgBuf[256];

        gFake.mfn_Lock();
    
        StringCbPrintf(
            rgBuf,
            sizeof(rgBuf),
            L"Update of NIC %ws (GUID %ws)",
            pIF->szFriendlyName,
            pIF->szInterfaceGuid
            );

        gFake.mfn_Unlock();
    
        //
        // Call this AFTER unlocking!
        //
    #if 0
        MessageBox(NULL, rgBuf, L"FakeThreadProc", MB_OK);
    #endif // 0
    }

    //
    // Now actually lock and perform the update...
    //

    gFake.mfn_Lock();

    if (pIF->pPendingInfo == NULL)
    {
        ASSERT(FALSE);
        goto end_unlock;
    }

    pIF->CompletedUpdateStatus = 
         pIF->pConfig->Update(&pIF->pPendingInfo->Config);
    pIF->pConfig->Generation++;
    delete pIF->pPendingInfo;
    pIF->pPendingInfo = NULL;

end_unlock:

    gFake.mfn_Unlock();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\nlbclientlib\nlbclient.cpp ===
/*++

Copyright(c) 2001  Microsoft Corporation

Module Name:

    NLB Manager

File Name:

    NlbClient.cpp

Abstract:

    Implementation of class NLBHost

    NLBHost is responsible for connecting to an NLB host and getting/setting
    its NLB-related configuration.

History:

    03/31/01    JosephJ Created
    07/27/01    JosephJ Moved to current location (used to be called
                 nlbhost.cpp under  provider\tests).

    NLB client-side WMI utility functions to configure
    an NLB host.

--*/

#include "private.h"
#include "nlbclient.tmh"

extern BOOL g_Silent;

BOOL g_Fake; // If true, operate in "fake mode" -- see NlbHostFake()


WBEMSTATUS
extract_GetClusterConfiguration_output_params(
    IN  IWbemClassObjectPtr                 spWbemOutput,
    OUT PNLB_EXTENDED_CLUSTER_CONFIGURATION pCfg
    );

WBEMSTATUS
setup_GetClusterConfiguration_input_params(
    IN LPCWSTR                              szNic,
    IN IWbemClassObjectPtr                  spWbemInput
    );

WBEMSTATUS
setup_UpdateClusterConfiguration_input_params(
    IN LPCWSTR                              szClientDescription,
    IN LPCWSTR                              szNic,
    IN PNLB_EXTENDED_CLUSTER_CONFIGURATION  pCfg,
    IN IWbemClassObjectPtr                  spWbemInput
    );

WBEMSTATUS
connect_to_server(
    IN  PWMI_CONNECTION_INFO pConnInfo, // NULL implies local
    OUT IWbemServicesPtr    &spWbemService // Smart pointer
    );

VOID
NlbHostFake(
    VOID)
    
/*
    Makes the NlbHostXXX apis operate in "fake mode", where they don't
    actually connect to any real machines.
*/
{
    g_Fake = TRUE;
    FakeInitialize();
}

WBEMSTATUS
NlbHostGetConfiguration(
    IN  PWMI_CONNECTION_INFO  pConnInfo, // NULL implies local
    IN  LPCWSTR              szNicGuid,
    OUT PNLB_EXTENDED_CLUSTER_CONFIGURATION pCurrentCfg
    )
{
    WBEMSTATUS          Status = WBEM_E_CRITICAL_ERROR;
    IWbemServicesPtr    spWbemService = NULL; // Smart pointer
    IWbemClassObjectPtr spWbemInput  = NULL; // smart pointer
    IWbemClassObjectPtr spWbemOutput = NULL; // smart pointer.
    LPWSTR              pRelPath = NULL;

    TRACE_INFO("->%!FUNC!(GUID=%ws)", szNicGuid);

    if (g_Fake)
    {
        Status = FakeNlbHostGetConfiguration(pConnInfo, szNicGuid, pCurrentCfg);
        goto end;
    }

    //
    // Get interface to the NLB namespace on the specified machine
    //
    Status =  connect_to_server(pConnInfo, REF spWbemService);
    if (FAILED(Status))
    {
        goto end;
    }

    //
    // Get wmi input instance to "GetClusterConfiguration" method
    //
    {
        Status =  CfgUtilGetWmiInputInstanceAndRelPath(
                    spWbemService,
                    L"NlbsNic",             // szClassName
                    NULL,         // szParameterName
                    NULL,              // szPropertyValue
                    L"GetClusterConfiguration",    // szMethodName,
                    spWbemInput,            // smart pointer
                    &pRelPath               // free using delete 
                    );

        if (FAILED(Status))
        {
            wprintf(
               L"ERROR 0x%08lx trying to get instance of GetClusterConfiguration\n",
                (UINT) Status
                );
            goto end;
        }
    }

    //
    // Setup params for the "GetClusterConfiguration" method
    // NOTE: spWbemInput could be NULL.
    //
    Status = setup_GetClusterConfiguration_input_params(
                szNicGuid,
                spWbemInput
                );

    if (FAILED(Status))
    {
        goto end;
    }

    //
    // Call the "GetClusterConfiguration" method
    //
    {
        HRESULT hr;

        if (!g_Silent)
        {
            wprintf(L"Going to get GetClusterConfiguration...\n");
        }

        hr = spWbemService->ExecMethod(
                     _bstr_t(pRelPath),
                     L"GetClusterConfiguration",
                     0, 
                     NULL, 
                     spWbemInput,
                     &spWbemOutput, 
                     NULL
                     );                          
    
        if( FAILED( hr) )
        {
            wprintf(L"GetClusterConfiguration returns with failure 0x%8lx\n",
                        (UINT) hr);
            Status = WBEM_E_CRITICAL_ERROR;
            goto end;
        }
        else
        {
            if (!g_Silent)
            {
                wprintf(L"GetClusterConfiguration returns successfully\n");
            }
        }

        if (spWbemOutput == NULL)
        {
            //
            // Hmm --- no output ?!
            //
            printf("ExecMethod GetClusterConfiguration had no output");
            Status = WBEM_E_NOT_FOUND;
            goto end;
        }
    }

    //
    // Extract params from the "GetClusterConfiguration" method
    //
    Status = extract_GetClusterConfiguration_output_params(
                spWbemOutput,
                pCurrentCfg
                );

end:

    if (pRelPath != NULL)
    {
        delete pRelPath;
    }

    spWbemService = NULL; // Smart pointer
    spWbemInput   = NULL; // smart pointer
    spWbemOutput  = NULL; // smart pointer.

    TRACE_INFO("<-%!FUNC! returns 0x%08lx", Status);
    return Status;
}



WBEMSTATUS
NlbHostDoUpdate(
    IN  PWMI_CONNECTION_INFO pConnInfo, // NULL implies local
    IN  LPCWSTR              szNicGuid,
    IN  LPCWSTR              szClientDescription,
    IN  PNLB_EXTENDED_CLUSTER_CONFIGURATION pNewState,
    OUT UINT                 *pGeneration,
    OUT WCHAR                **ppLog    // free using delete operator.
)
{

    WBEMSTATUS          Status = WBEM_E_CRITICAL_ERROR;
    IWbemServicesPtr    spWbemService = NULL; // Smart pointer
    IWbemClassObjectPtr spWbemInput  = NULL; // smart pointer
    IWbemClassObjectPtr spWbemOutput = NULL; // smart pointer.
    LPWSTR              pRelPath = NULL;
    TRACE_INFO("->%!FUNC!(GUID=%ws)", szNicGuid);

    *pGeneration = 0;
    *ppLog = NULL;

    if (g_Fake)
    {
        Status =  FakeNlbHostDoUpdate(
                    pConnInfo,
                    szNicGuid,
                    szClientDescription,
                    pNewState,
                    pGeneration,
                    ppLog
                    );
        goto end;
    }

    //
    // Get interface to the NLB namespace on the specified machine
    //
    Status =  connect_to_server(pConnInfo, REF spWbemService);
    if (FAILED(Status))
    {
        goto end;
    }

    //
    // Get wmi input instance to "UpdateClusterConfiguration" method
    //
    {
        Status =  CfgUtilGetWmiInputInstanceAndRelPath(
                    spWbemService,
                    L"NlbsNic",             // szClassName
                    NULL,         // szParameterName
                    NULL,              // szPropertyValue
                    L"UpdateClusterConfiguration",    // szMethodName,
                    spWbemInput,            // smart pointer
                    &pRelPath               // free using delete 
                    );

        if (FAILED(Status))
        {
            wprintf(
               L"ERROR 0x%08lx trying to get instance of UpdateConfiguration\n",
                (UINT) Status
                );
            goto end;
        }
    }

    //
    // Setup params for the "UpdateClusterConfiguration" method
    // NOTE: spWbemInput could be NULL.
    //
    Status = setup_UpdateClusterConfiguration_input_params(
                szClientDescription,
                szNicGuid,
                pNewState,
                spWbemInput
                );

    if (FAILED(Status))
    {
        goto end;
    }

    //
    // Call the "UpdateClusterConfiguration" method
    //
    {
        HRESULT hr;

        wprintf(L"Going get UpdateClusterConfiguration...\n");

        hr = spWbemService->ExecMethod(
                     _bstr_t(pRelPath),
                     L"UpdateClusterConfiguration",
                     0, 
                     NULL, 
                     spWbemInput,
                     &spWbemOutput, 
                     NULL
                     );                          
    
        if( FAILED( hr) )
        {
            wprintf(L"UpdateConfiguration returns with failure 0x%8lx\n",
                        (UINT) hr);
            goto end;
        }
        else
        {
            wprintf(L"UpdateConfiguration returns successfully\n");
        }

        if (spWbemOutput == NULL)
        {
            //
            // Hmm --- no output ?!
            //
            printf("ExecMethod UpdateConfiguration had no output");
            Status = WBEM_E_NOT_FOUND;
            goto end;
        }
    }

    //
    // Extract params from the "UpdateClusterConfiguration" method
    //
    {
        DWORD dwReturnValue = 0;

        Status = CfgUtilGetWmiDWORDParam(
                    spWbemOutput,
                    L"ReturnValue",      // <--------------------------------
                    &dwReturnValue
                    );
        if (FAILED(Status))
        {
            wprintf(L"Attempt to read ReturnValue failed. Error=0x%08lx\n",
                 (UINT) Status);
            goto end;
        }
    
    
        LPWSTR szLog = NULL;

        Status = CfgUtilGetWmiStringParam(
                        spWbemOutput,
                        L"Log", // <-------------------------
                        &szLog
                        );
    
        if (FAILED(Status))
        {
            szLog = NULL;
        }
        *ppLog = szLog;

        DWORD dwGeneration = 0;
        Status = CfgUtilGetWmiDWORDParam(
                    spWbemOutput,
                    L"NewGeneration",      // <--------------------------------
                    &dwGeneration
                    );
        if (FAILED(Status))
        {
            //
            // Generation should always be specified for pending operations.
            // TODO: for successful operations also?
            //
            if ((WBEMSTATUS)dwReturnValue == WBEM_S_PENDING)
            {
                wprintf(L"Attempt to read NewGeneration for pending update failed. Error=0x%08lx\n",
                     (UINT) Status);
                Status = WBEM_E_CRITICAL_ERROR;
                goto end;
            }
            dwGeneration = 0; // we don't care if it's not set for non-pending
        }
        *pGeneration = (UINT) dwGeneration;
        

        //
        // Make the return status reflect the true status of the update 
        // operation.
        //
        Status = (WBEMSTATUS) dwReturnValue;
    }

end:

    if (pRelPath != NULL)
    {
        delete pRelPath;
    }

    spWbemService = NULL; // Smart pointer
    spWbemInput   = NULL; // smart pointer
    spWbemOutput  = NULL; // smart pointer.

    TRACE_INFO("<-%!FUNC! returns 0x%08lx", Status);
    return Status;
}

WBEMSTATUS
NlbHostControlCluster(
    IN  PWMI_CONNECTION_INFO pConnInfo, // NULL implies local
    IN  LPCWSTR              szNicGuid,
    IN  LPCWSTR              szVip,
    IN  DWORD               *pdwPortNum,
    IN  WLBS_OPERATION_CODES Operation,
    OUT DWORD               *pdwOperationStatus,
    OUT DWORD               *pdwClusterOrPortStatus,
    OUT DWORD               *pdwHostMap
)
{

    WBEMSTATUS          Status = WBEM_E_CRITICAL_ERROR;
    IWbemServicesPtr    spWbemService = NULL; // Smart pointer
    IWbemClassObjectPtr spWbemInput  = NULL; // smart pointer
    IWbemClassObjectPtr spWbemOutput = NULL; // smart pointer.
    LPWSTR              pRelPath = NULL;

    if (szVip && pdwPortNum) 
        TRACE_INFO("->%!FUNC!(GUID=%ws), szVip : %ls, Port : 0x%x, Operation : %d", szNicGuid, szVip, *pdwPortNum, Operation);
    else
        TRACE_INFO("->%!FUNC!(GUID=%ws), szVip : N/A, Port : N/A, Operation : %d", szNicGuid, Operation);


    if (g_Fake)
    {
        Status =  FakeNlbHostControlCluster(
                    pConnInfo,
                    szNicGuid,
                    szVip,
                    pdwPortNum,
                    Operation,
                    pdwOperationStatus,
                    pdwClusterOrPortStatus,
                    pdwHostMap
                    );
        goto end;
    }

    // Initialize return variables to failure values
    if (pdwOperationStatus) 
        *pdwOperationStatus = WLBS_FAILURE;
    if (pdwClusterOrPortStatus) 
        *pdwClusterOrPortStatus = WLBS_FAILURE;
    if (pdwHostMap) 
        *pdwHostMap = 0;

    //
    // Get interface to the NLB namespace on the specified machine
    //
    Status =  connect_to_server(pConnInfo, REF spWbemService);
    if (FAILED(Status))
    {
        goto end;
    }
    

    //
    // Get wmi input instance to "ControlCluster" method
    //
    {
        Status =  CfgUtilGetWmiInputInstanceAndRelPath(
                    spWbemService,
                    L"NlbsNic",        // szClassName
                    NULL,              // szParameterName
                    NULL,              // szPropertyValue
                    L"ControlCluster", // szMethodName,
                    spWbemInput,       // smart pointer
                    &pRelPath          // free using delete 
                    );

        if (FAILED(Status))
        {
            wprintf(
               L"ERROR 0x%08lx trying to get instance of UpdateConfiguration\n",
                (UINT) Status
                );
            goto end;
        }
    }

    // Setup input parameters

    // Put in Adapter GUID
    Status =  CfgUtilSetWmiStringParam(
                spWbemInput,
                L"AdapterGuid",
                szNicGuid
                );
    if (FAILED(Status))
    {
        TRACE_CRIT(L"Error trying to set Adapter GUID : %ls",szNicGuid);
        goto end;
    }

    // If passed, Put in Virtual IP Address
    // Virtual IP Address will be passed only for port operations
    if (szVip) 
    {
        Status =  CfgUtilSetWmiStringParam(
                    spWbemInput,
                    L"VirtualIpAddress",
                    szVip
                    );
        if (FAILED(Status))
        {
            TRACE_CRIT(L"Error trying to set Virtual IP Address : %ls",szVip);
            goto end;
        }
    }

    // If passed, Put in Port Number
    // Port number will be passed only for port operations
    if (pdwPortNum) 
    {
        CfgUtilSetWmiDWORDParam(
          spWbemInput,
          L"Port",
          *pdwPortNum
          );
    }

    // Put in Operation
    CfgUtilSetWmiDWORDParam(
      spWbemInput,
      L"Operation",
      (DWORD)Operation
      );

    //
    // Call the "ControlCluster" method
    //
    {
        HRESULT hr;

        wprintf(L"Going get ControlCluster...\n");

        hr = spWbemService->ExecMethod(
                     _bstr_t(pRelPath),
                     L"ControlCluster",
                     0, 
                     NULL, 
                     spWbemInput,
                     &spWbemOutput, 
                     NULL
                     );                          
    
        if( FAILED( hr) )
        {
            wprintf(L"ControlCluster returns with failure 0x%8lx\n",
                        (UINT) hr);
            goto end;
        }
        //else
        //{
        //    wprintf(L"ControlCluster returns successfully\n");
        //}

        if (spWbemOutput == NULL)
        {
            //
            // Hmm --- no output ?!
            //
            printf("ExecMethod ControlCluster had no output");
            Status = WBEM_E_NOT_FOUND;
            goto end;
        }
    }

    //
    // Extract output params from the "ControlCluster" method
    //
    {
        DWORD dwTemp;

        // Get return value
        Status = CfgUtilGetWmiDWORDParam(
                    spWbemOutput,
                    L"ReturnValue",
                    &dwTemp
                    );
        if (FAILED(Status))
        {
            wprintf(L"Attempt to read ReturnValue failed. Error=0x%08lx\n",
                 (UINT) Status);
            goto end;
        }
        else
        {
            if (pdwOperationStatus) 
                *pdwOperationStatus = dwTemp;        
        }
    
        // Get Cluster or Port Status
        Status = CfgUtilGetWmiDWORDParam(
                    spWbemOutput,
                    L"CurrentState",
                    &dwTemp
                    );
        if (FAILED(Status))
        {
            wprintf(L"Attempt to read CurrentState failed. Error=0x%08lx\n",
                 (UINT) Status);
            goto end;
        }
        else
        {
            if (pdwClusterOrPortStatus) 
                *pdwClusterOrPortStatus = dwTemp;        
        }
    
        // If present, Get Host Map
        // For port operations, Host Map will not be returned
        Status = CfgUtilGetWmiDWORDParam(
                    spWbemOutput,
                    L"HostMap",      
                    &dwTemp
                    );
        if (FAILED(Status))
        {
            if ((Operation != WLBS_PORT_ENABLE) 
             && (Operation != WLBS_PORT_DISABLE) 
             && (Operation != WLBS_PORT_DRAIN) 
             && (Operation != WLBS_QUERY_PORT_STATE)
               ) 
            {
                wprintf(L"Attempt to read HostMap failed. Error=0x%08lx\n", (UINT) Status);
                goto end;
            }
        }
        else
        {
            if (pdwHostMap) 
                *pdwHostMap = dwTemp;        
        }
    
        Status = WBEM_NO_ERROR;
    }

end:

    if (pRelPath != NULL)
    {
        delete pRelPath;
    }

    spWbemService = NULL; // Smart pointer
    spWbemInput   = NULL; // smart pointer
    spWbemOutput  = NULL; // smart pointer.

    TRACE_INFO("<-%!FUNC! returns 0x%08lx", Status);
    return Status;
}


WBEMSTATUS
NlbHostGetClusterMembers(
    IN  PWMI_CONNECTION_INFO    pConnInfo, 
    IN  LPCWSTR                 szNicGuid,
    OUT DWORD                   *pNumMembers,
    OUT NLB_CLUSTER_MEMBER_INFO **ppMembers       // free using delete[]
    )
{

    WBEMSTATUS          Status        = WBEM_E_CRITICAL_ERROR;
    IWbemServicesPtr    spWbemService = NULL; // Smart pointer
    IWbemClassObjectPtr spWbemInput   = NULL;  // smart pointer
    IWbemClassObjectPtr spWbemOutput  = NULL;  // smart pointer.
    LPWSTR              pRelPath      = NULL;

    GUID                AdapterGuid;
    DWORD               dwStatus;
    LPWSTR              *pszHostIdList             = NULL;
    LPWSTR              *pszDedicatedIpAddressList = NULL;
    LPWSTR              *pszHostNameList           = NULL;
    UINT                NumHostIds                 = 0;
    UINT                NumDips                    = 0;
    UINT                NumHostNames               = 0;

    TRACE_VERB(L"->(GUID=%ws)", szNicGuid);

    ASSERT (pNumMembers != NULL);
    ASSERT (ppMembers != NULL);

    *pNumMembers = 0;
    *ppMembers = NULL;

    if (g_Fake)
    {
        TRACE_INFO(L"faking call");
        Status =  FakeNlbHostGetClusterMembers(
                    pConnInfo,
                    szNicGuid,
                    pNumMembers,
                    ppMembers
                    );
        goto end;
    }

    //
    // Get interface to the NLB namespace on the specified machine
    //
    Status =  connect_to_server(pConnInfo, REF spWbemService);
    if (FAILED(Status))
    {
        goto end;
    }
    

    //
    // Get wmi input instance to "ControlCluster" method
    //
    {
        Status =  CfgUtilGetWmiInputInstanceAndRelPath(
                    spWbemService,
                    L"NlbsNic",           // szClassName
                    NULL,                 // szParameterName
                    NULL,                 // szPropertyValue
                    L"GetClusterMembers", // szMethodName,
                    spWbemInput,          // smart pointer
                    &pRelPath             // free using delete 
                    );

        if (FAILED(Status))
        {
            wprintf(
               L"ERROR 0x%08lx trying to get instance of UpdateConfiguration\n",
                (UINT) Status
                );
            TRACE_CRIT(L"CfgUtilGetWmiInputInstanceAndRelPath failed with status 0x%x", Status);
            goto end;
        }
    }

    //
    // Setup input parameters
    //
    Status =  CfgUtilSetWmiStringParam(
                spWbemInput,
                L"AdapterGuid",
                szNicGuid
                );

    if (FAILED(Status))
    {
        TRACE_CRIT(L"Error trying to set Adapter GUID : %ls", szNicGuid);
        goto end;
    }

    {
        HRESULT hr;

        wprintf(L"Calling GetClusterMembers...\n");

        hr = spWbemService->ExecMethod(
                     _bstr_t(pRelPath),
                     L"GetClusterMembers",
                     0, 
                     NULL, 
                     spWbemInput,
                     &spWbemOutput, 
                     NULL
                     );                          
    
        if( FAILED( hr) )
        {
            wprintf(L"GetClusterMembers returns with failure 0x%8lx\n",
                        (UINT) hr);
            TRACE_CRIT(L"ExecMethod (GetClusterMembers) failed with hresult 0x%x", hr);
            goto end;
        }

        if (spWbemOutput == NULL)
        {
            //
            // Hmm --- no output ?!
            //
            printf("ExecMethod GetClusterMembers had no output");
            Status = WBEM_E_NOT_FOUND;
            TRACE_CRIT(L"ExecMethod (GetClusterMembers) failed with hresult 0x%x", hr);
            goto end;
        }
    }

    //
    // Extract output params from the "GetClusterMembers" method
    //
    {
        DWORD dwTemp;

        // Get return value
        Status = CfgUtilGetWmiDWORDParam(
                    spWbemOutput,
                    L"ReturnValue",
                    &dwTemp
                    );

        if (FAILED(Status))
        {
            wprintf(L"Attempt to read ReturnValue failed. Error=0x%08lx\n",
                 (UINT) Status);
            TRACE_CRIT(L"Attempt to read ReturnValue failed. Error=0x%08lx", (UINT) Status);
            goto end;
        }
        else
        {
            dwStatus = dwTemp;
        }

        if (dwStatus != WBEM_S_NO_ERROR)
        {
            TRACE_CRIT(L"GetClusterMembers failed return status = 0x%x", dwStatus);
            Status = WBEM_NO_ERROR;
            goto end;
        }

        // Get the array of host IDs
        Status = CfgUtilGetWmiStringArrayParam(
                    spWbemOutput,
                    L"HostIds",
                    &pszHostIdList,
                    &NumHostIds
                    );
        if (FAILED(Status))
        {
            pszHostIdList = NULL;
            NumHostIds = 0;
            wprintf(L"Attempt to read HostIds failed. Error=0x%08lx\n",
                 (UINT) Status);
            TRACE_CRIT(L"Attempt to read HostIds failed. Error=0x%08lx", (UINT) Status);
            goto end;
        }

        // Get the array of Dedicated IPs
        Status = CfgUtilGetWmiStringArrayParam(
                    spWbemOutput,
                    L"DedicatedIpAddresses",
                    &pszDedicatedIpAddressList,
                    &NumDips
                    );
        if (FAILED(Status))
        {
            pszDedicatedIpAddressList = NULL;
            NumDips = 0;
            wprintf(L"Attempt to read DedicatedIpAddresses failed. Error=0x%08lx\n",
                 (UINT) Status);
            TRACE_CRIT(L"Attempt to read DedicatedIpAddresses failed. Error=0x%08lx", (UINT) Status);
            goto end;
        }

        // Get the array of host IDs
        Status = CfgUtilGetWmiStringArrayParam(
                    spWbemOutput,
                    L"HostNames",
                    &pszHostNameList,
                    &NumHostNames
                    );
        if (FAILED(Status))
        {
            pszHostNameList = NULL;
            NumHostNames = 0;
            wprintf(L"Attempt to read HostNames failed. Error=0x%08lx\n",
                 (UINT) Status);
            TRACE_CRIT(L"Attempt to read HostNames failed. Error=0x%08lx", (UINT) Status);
            goto end;
        }

        if (NumHostIds != NumDips || NumDips != NumHostNames)
        {
            TRACE_CRIT(L"Information arrays of host information are of different lengths. NumHostIds=%d, NumDips=%d, NumHostNames=%d", NumHostIds, NumDips, NumHostNames);
            Status = WBEM_E_FAILED;
            goto end;
        }

        *ppMembers = new NLB_CLUSTER_MEMBER_INFO[NumHostIds];

        if (*ppMembers == NULL)
        {
            TRACE_CRIT(L"Memory allocation for NLB_CLUSTER_MEMBER_INFO array failed");
            Status = WBEM_E_OUT_OF_MEMORY;
            goto end;
        }

        *pNumMembers = NumHostIds;

        //
        // Copy the string information into buffers for output
        //
        for (int i=0; i< NumHostIds; i++)
        {
            (*ppMembers)[i].HostId = wcstoul(pszHostIdList[i], NULL, 0);

            wcsncpy((*ppMembers)[i].DedicatedIpAddress, pszDedicatedIpAddressList[i], WLBS_MAX_CL_IP_ADDR);
            (*ppMembers)[i].DedicatedIpAddress[WLBS_MAX_CL_IP_ADDR - 1] = L'\0';

            wcsncpy((*ppMembers)[i].HostName, pszHostNameList[i], CVY_MAX_FQDN + 1);
            (*ppMembers)[i].HostName[CVY_MAX_FQDN] = L'\0';
        }

        Status = WBEM_NO_ERROR;
    }

end:

    if (pRelPath != NULL)
    {
        delete pRelPath;
    }

    if (pszHostIdList != NULL)
    {
        delete [] pszHostIdList;
    }

    if (pszDedicatedIpAddressList != NULL)
    {
        delete [] pszDedicatedIpAddressList;
    }

    if (pszHostNameList != NULL)
    {
        delete [] pszHostNameList;
    }

    spWbemService = NULL; // Smart pointer
    spWbemInput   = NULL; // smart pointer
    spWbemOutput  = NULL; // smart pointer.

    TRACE_VERB(L"<- returns 0x%08lx", Status);
    return Status;
}


WBEMSTATUS
NlbHostGetUpdateStatus(
    IN  PWMI_CONNECTION_INFO pConnInfo, // NULL implies local
    IN  LPCWSTR              szNicGuid,
    IN  UINT                 Generation,
    OUT WBEMSTATUS           *pCompletionStatus,
    OUT WCHAR                **ppLog    // free using delete operator.
    )
{
    WBEMSTATUS          Status = WBEM_E_CRITICAL_ERROR;
    IWbemServicesPtr    spWbemService = NULL; // Smart pointer
    IWbemClassObjectPtr spWbemInput  = NULL; // smart pointer
    IWbemClassObjectPtr spWbemOutput = NULL; // smart pointer.
    LPWSTR              pRelPath = NULL;
    TRACE_INFO("->%!FUNC!(GUID=%ws)", szNicGuid);

    *ppLog = NULL;
    *pCompletionStatus = WBEM_E_CRITICAL_ERROR;

    if (g_Fake)
    {
        Status = FakeNlbHostGetUpdateStatus(
                        pConnInfo,
                        szNicGuid,
                        Generation,
                        pCompletionStatus,
                        ppLog
                        );
        goto end;
    }

    //
    // Get interface to the NLB namespace on the specified machine
    //
    Status =  connect_to_server(pConnInfo, REF spWbemService);
    if (FAILED(Status))
    {
        goto end;
    }
    

    //
    // Get wmi input instance to  "QueryConfigurationUpdateStatus" method
    //
    {
        Status =  CfgUtilGetWmiInputInstanceAndRelPath(
                    spWbemService,
                    L"NlbsNic",             // szClassName
                    NULL,         // szParameterName
                    NULL,              // szPropertyValue
                    L"QueryConfigurationUpdateStatus", // szMethodName,
                    spWbemInput,            // smart pointer
                    &pRelPath               // free using delete 
                    );
        if (FAILED(Status))
        