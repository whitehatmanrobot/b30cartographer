   {
        EXECUTE_ASSERT(ReleaseDC(m_hwnd,m_hdc));
        m_hdc = NULL;
    }

    if (m_MemoryDC)
    {
        EXECUTE_ASSERT(DeleteDC(m_MemoryDC));
        m_MemoryDC = NULL;
    }

    // Reset the window variables
    m_hwnd = NULL;

    return NOERROR;
}


// This is called by the worker window thread after it has created the main
// window and it wants to initialise the rest of the owner objects window
// variables such as the device contexts. We execute this function with the
// critical section still locked. Nothing in this function must generate any
// SendMessage calls to the window because this is executing on the window
// thread so the message will never be processed and we will deadlock

HRESULT CBaseWindow::InitialiseWindow(HWND hwnd)
{
    // Initialise the window variables

    ASSERT(IsWindow(hwnd));
    m_hwnd = hwnd;

    if (m_bDoGetDC)
    {
        EXECUTE_ASSERT(m_hdc = GetDC(hwnd));
        EXECUTE_ASSERT(m_MemoryDC = CreateCompatibleDC(m_hdc));

        EXECUTE_ASSERT(SetStretchBltMode(m_hdc,COLORONCOLOR));
        EXECUTE_ASSERT(SetStretchBltMode(m_MemoryDC,COLORONCOLOR));
    }

    return NOERROR;
}

HRESULT CBaseWindow::DoCreateWindow()
{
    WNDCLASS wndclass;                  // Used to register classes
    BOOL bRegistered;                   // Is this class registered
    HWND hwnd;                          // Handle to our window

    bRegistered = GetClassInfo(m_hInstance,   // Module instance
                               m_pClassName,  // Window class
                               &wndclass);                 // Info structure

    // if the window is to be used for drawing puposes and we are getting a DC
    // for the entire lifetime of the window then changes the class style to do
    // say so. If we don't set this flag then the DC comes from the cache and is
    // really bad.
    if (m_bDoGetDC)
    {
        m_ClassStyles |= CS_OWNDC;
    }

    if (bRegistered == FALSE) {

        // Register the renderer window class

        wndclass.lpszClassName = m_pClassName;
        wndclass.style         = m_ClassStyles;
        wndclass.lpfnWndProc   = WndProc;
        wndclass.cbClsExtra    = 0;
        wndclass.cbWndExtra    = sizeof(CBaseWindow *);
        wndclass.hInstance     = m_hInstance;
        wndclass.hIcon         = NULL;
        wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW);
        wndclass.hbrBackground = (HBRUSH) NULL;
        wndclass.lpszMenuName  = NULL;

        RegisterClass(&wndclass);
    }

    // Create the frame window.  Pass the pBaseWindow information in the
    // CreateStruct which allows our message handling loop to get hold of
    // the pBaseWindow pointer.

    CBaseWindow *pBaseWindow = this;                      // The owner window object
    hwnd = CreateWindowEx(m_WindowStylesEx,               // Extended styles
                          m_pClassName,                   // Registered name
                          TEXT("ActiveMovie Window"),     // Window title
                          m_WindowStyles,                 // Window styles
                          CW_USEDEFAULT,                  // Start x position
                          CW_USEDEFAULT,                  // Start y position
                          DEFWIDTH,                       // Window width
                          DEFHEIGHT,                      // Window height
                          NULL,                           // Parent handle
                          NULL,                           // Menu handle
                          m_hInstance,                    // Instance handle
                          &pBaseWindow);                  // Creation data

    // If we failed signal an error to the object constructor (based on the
    // last Win32 error on this thread) then signal the constructor thread
    // to continue, release the mutex to let others have a go and exit

    if (hwnd == NULL) {
        DWORD Error = GetLastError();
        return AmHresultFromWin32(Error);
    }

    // Check the window LONG is the object who created us
    ASSERT(GetWindowLongPtr(hwnd, 0) == (LONG_PTR)this);

    // Initialise the window and then signal the constructor so that it can
    // continue and then finally unlock the object's critical section. The
    // window class is left registered even after we terminate the thread
    // as we don't know when the last window has been closed. So we allow
    // the operating system to free the class resources as appropriate

    InitialiseWindow(hwnd);

    DbgLog((LOG_TRACE, 2, TEXT("Created window class (%s) HWND(%8.8X)"),
            m_pClassName, hwnd));

    return S_OK;
}


// The base class provides some default handling and calls DefWindowProc

LRESULT CBaseWindow::OnReceiveMessage(HWND hwnd,         // Window handle
                                      UINT uMsg,         // Message ID
                                      WPARAM wParam,     // First parameter
                                      LPARAM lParam)     // Other parameter
{
    ASSERT(IsWindow(hwnd));

    if (PossiblyEatMessage(uMsg, wParam, lParam))
        return 0;

    // This is sent by the IVideoWindow SetWindowForeground method. If the
    // window is invisible we will show it and make it topmost without the
    // foreground focus. If the window is visible it will also be made the
    // topmost window without the foreground focus. If wParam is TRUE then
    // for both cases the window will be forced into the foreground focus

    if (uMsg == m_ShowStageMessage) {

        BOOL bVisible = IsWindowVisible(hwnd);
        SetWindowPos(hwnd, HWND_TOP, 0, 0, 0, 0,
                     SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW |
                     (bVisible ? SWP_NOACTIVATE : 0));

        // Should we bring the window to the foreground
        if (wParam == TRUE) {
            SetForegroundWindow(hwnd);
        }
        return (LRESULT) 1;
    }

    // When we go fullscreen we have to add the WS_EX_TOPMOST style to the
    // video window so that it comes out above any task bar (this is more
    // relevant to WindowsNT than Windows95). However the SetWindowPos call
    // must be on the same thread as that which created the window. The
    // wParam parameter can be TRUE or FALSE to set and reset the topmost

    if (uMsg == m_ShowStageTop) {
        HWND HwndTop = (wParam == TRUE ? HWND_TOPMOST : HWND_NOTOPMOST);
        BOOL bVisible = IsWindowVisible(hwnd);
        SetWindowPos(hwnd, HwndTop, 0, 0, 0, 0,
                     SWP_NOMOVE | SWP_NOSIZE |
                     (wParam == TRUE ? SWP_SHOWWINDOW : 0) |
                     (bVisible ? SWP_NOACTIVATE : 0));
        return (LRESULT) 1;
    }

    // New palette stuff
    if (uMsg == m_RealizePalette) {
        ASSERT(m_hwnd == hwnd);
        return OnPaletteChange(m_hwnd,WM_QUERYNEWPALETTE);
    }

    switch (uMsg) {

        // Repaint the window if the system colours change

    case WM_SYSCOLORCHANGE:

        InvalidateRect(hwnd,NULL,FALSE);
        return (LRESULT) 1;

    // Somebody has changed the palette
    case WM_PALETTECHANGED:

        OnPaletteChange((HWND)wParam,uMsg);
        return (LRESULT) 0;

        // We are about to receive the keyboard focus so we ask GDI to realise
        // our logical palette again and hopefully it will be fully installed
        // without any mapping having to be done during any picture rendering

    case WM_QUERYNEWPALETTE:
        ASSERT(m_hwnd == hwnd);
        return OnPaletteChange(m_hwnd,uMsg);

    // do NOT fwd WM_MOVE. the parameters are the location of the parent
    // window, NOT what the renderer should be looking at.  But we need
    // to make sure the overlay is moved with the parent window, so we
    // do this.
    case WM_MOVE:
        if (IsWindowVisible(m_hwnd)) {
            PostMessage(m_hwnd,WM_PAINT,0,0);
        }
        break;

    // Store the width and height as useful base class members

    case WM_SIZE:

        OnSize(LOWORD(lParam), HIWORD(lParam));
        return (LRESULT) 0;

    // Intercept the WM_CLOSE messages to hide the window

    case WM_CLOSE:

        OnClose();
        return (LRESULT) 0;
    }
    return DefWindowProc(hwnd,uMsg,wParam,lParam);
}


// This handles the Windows palette change messages - if we do realise our
// palette then we return TRUE otherwise we return FALSE. If our window is
// foreground application then we should get first choice of colours in the
// system palette entries. We get best performance when our logical palette
// includes the standard VGA colours (at the beginning and end) otherwise
// GDI may have to map from our palette to the device palette while drawing

LRESULT CBaseWindow::OnPaletteChange(HWND hwnd,UINT Message)
{
    // First check we are not changing the palette during closedown

    if (m_hwnd == NULL || hwnd == NULL) {
        return (LRESULT) 0;
    }
    ASSERT(!m_bRealizing);

    // Should we realise our palette again

    if ((Message == WM_QUERYNEWPALETTE || hwnd != m_hwnd)) {
        //  It seems that even if we're invisible that we can get asked
        //  to realize our palette and this can cause really ugly side-effects
        //  Seems like there's another bug but this masks it a least for the
        //  shutting down case.
        if (!IsWindowVisible(m_hwnd)) {
            DbgLog((LOG_TRACE, 1, TEXT("Realizing when invisible!")));
            return (LRESULT) 0;
        }

        // Avoid recursion with multiple graphs in the same app
#ifdef DEBUG
        m_bRealizing = TRUE;
#endif
        DoRealisePalette(Message != WM_QUERYNEWPALETTE);
#ifdef DEBUG
        m_bRealizing = FALSE;
#endif

        // Should we redraw the window with the new palette
        if (Message == WM_PALETTECHANGED) {
            InvalidateRect(m_hwnd,NULL,FALSE);
        }
    }

    return (LRESULT) 1;
}


// Determine if the window exists.

bool CBaseWindow::WindowExists()
{
    return !!IsWindow(m_hwnd);
}


// Return the default window rectangle

RECT CBaseWindow::GetDefaultRect()
{
    RECT DefaultRect = {0,0,DEFWIDTH,DEFHEIGHT};
    ASSERT(m_hwnd);
    // ASSERT(m_hdc);
    return DefaultRect;
}


// Return the current window width

LONG CBaseWindow::GetWindowWidth()
{
    ASSERT(m_hwnd);
    // ASSERT(m_hdc);
    return m_Width;
}


// Return the current window height

LONG CBaseWindow::GetWindowHeight()
{
    ASSERT(m_hwnd);
    // ASSERT(m_hdc);
    return m_Height;
}


// Return the window handle

HWND CBaseWindow::GetWindowHWND()
{
    ASSERT(m_hwnd);
    // ASSERT(m_hdc);
    return m_hwnd;
}


// Return the window drawing device context

HDC CBaseWindow::GetWindowHDC()
{
    ASSERT(m_hwnd);
    ASSERT(m_hdc);
    return m_hdc;
}


// Return the offscreen window drawing device context

HDC CBaseWindow::GetMemoryHDC()
{
    ASSERT(m_hwnd);
    ASSERT(m_MemoryDC);
    return m_MemoryDC;
}


#ifdef DEBUG
HPALETTE CBaseWindow::GetPalette()
{
    // The palette lock should always be held when accessing
    // m_hPalette.
    ASSERT(CritCheckIn(&m_PaletteLock));
    return m_hPalette;
}
#endif // DEBUG


// This is available to clients who want to change the window visiblity. It's
// little more than an indirection to the Win32 ShowWindow although these is
// some benefit in going through here as this function may change sometime

HRESULT CBaseWindow::DoShowWindow(LONG ShowCmd)
{
    ShowWindow(m_hwnd,ShowCmd);
    return NOERROR;
}


// Generate a WM_PAINT message for the video window

void CBaseWindow::PaintWindow(BOOL bErase)
{
    InvalidateRect(m_hwnd,NULL,bErase);
}


// Allow an application to have us set the video window in the foreground. We
// have this because it is difficult for one thread to do do this to a window
// owned by another thread. Rather than expose the message we use to execute
// the inter thread send message we provide the interface function. All we do
// is to SendMessage to the video window renderer thread with a WM_SHOWSTAGE

void CBaseWindow::DoSetWindowForeground(BOOL bFocus)
{
    SendMessage(m_hwnd,m_ShowStageMessage,(WPARAM) bFocus,(LPARAM) 0);
}


// Constructor initialises the owning object pointer. Since we are a worker
// class for the main window object we have relatively few state variables to
// look after. We are given device context handles to use later on as well as
// the source and destination rectangles (but reset them here just in case)

CDrawImage::CDrawImage(CBaseWindow *pBaseWindow) :
    m_pBaseWindow(pBaseWindow),
    m_hdc(NULL),
    m_MemoryDC(NULL),
    m_bStretch(FALSE),
    m_pMediaType(NULL),
    m_bUsingImageAllocator(FALSE)
{
    ASSERT(pBaseWindow);
    ResetPaletteVersion();
    SetRectEmpty(&m_TargetRect);
    SetRectEmpty(&m_SourceRect);

    m_perfidRenderTime = MSR_REGISTER(TEXT("Single Blt time"));
}


// Overlay the image time stamps on the picture. Access to this method is
// serialised by the caller. We display the sample start and end times on
// top of the video using TextOut on the device context we are handed. If
// there isn't enough room in the window for the times we don't show them

void CDrawImage::DisplaySampleTimes(IMediaSample *pSample)
{
#ifdef DEBUG
    //
    // Only allow the "annoying" time messages if the users has turned the
    // logging "way up"
    //
    BOOL bAccept = DbgCheckModuleLevel(LOG_TRACE, 5);
    if (bAccept == FALSE) {
        return;
    }
#endif

    TCHAR szTimes[TIMELENGTH];      // Time stamp strings
    ASSERT(pSample);                // Quick sanity check
    RECT ClientRect;                // Client window size
    SIZE Size;                      // Size of text output

    // Get the time stamps and window size

    pSample->GetTime((REFERENCE_TIME*)&m_StartSample, (REFERENCE_TIME*)&m_EndSample);
    HWND hwnd = m_pBaseWindow->GetWindowHWND();
    EXECUTE_ASSERT(GetClientRect(hwnd,&ClientRect));

    // Format the sample time stamps

    wsprintf(szTimes,TEXT("%08d : %08d"),
             m_StartSample.Millisecs(),
             m_EndSample.Millisecs());

    ASSERT(lstrlen(szTimes) < TIMELENGTH);

    // Put the times in the middle at the bottom of the window

    GetTextExtentPoint32(m_hdc,szTimes,lstrlen(szTimes),&Size);
    INT XPos = ((ClientRect.right - ClientRect.left) - Size.cx) / 2;
    INT YPos = ((ClientRect.bottom - ClientRect.top) - Size.cy) * 4 / 5;

    // Check the window is big enough to have sample times displayed

    if ((XPos > 0) && (YPos > 0)) {
        TextOut(m_hdc,XPos,YPos,szTimes,lstrlen(szTimes));
    }
}


// This is called when the drawing code sees that the image has a down level
// palette cookie. We simply call the SetDIBColorTable Windows API with the
// palette that is found after the BITMAPINFOHEADER - we return no errors

void CDrawImage::UpdateColourTable(HDC hdc,BITMAPINFOHEADER *pbmi)
{
    ASSERT(pbmi->biClrUsed);
    RGBQUAD *pColourTable = (RGBQUAD *)(pbmi+1);

    // Set the new palette in the device context

    UINT uiReturn = SetDIBColorTable(hdc,(UINT) 0,
                                     pbmi->biClrUsed,
                                     pColourTable);

    // Should always succeed but check in debug builds
    ASSERT(uiReturn == pbmi->biClrUsed);
}


// No source rectangle scaling is done by the base class

RECT CDrawImage::ScaleSourceRect(const RECT *pSource)
{
    ASSERT(pSource);
    return *pSource;
}


// This is called when the funky output pin uses our allocator. The samples we
// allocate are special because the memory is shared between us and GDI thus
// removing one copy when we ask for the image to be rendered. The source type
// information is in the main renderer m_mtIn field which is initialised when
// the media type is agreed in SetMediaType, the media type may be changed on
// the fly if, for example, the source filter needs to change the palette

void CDrawImage::FastRender(IMediaSample *pMediaSample)
{
    BITMAPINFOHEADER *pbmi;     // Image format data
    DIBDATA *pDibData;          // Stores DIB information
    BYTE *pImage;               // Pointer to image data
    HBITMAP hOldBitmap;         // Store the old bitmap
    CImageSample *pSample;      // Pointer to C++ object

    ASSERT(m_pMediaType);

    // From the untyped source format block get the VIDEOINFO and subsequently
    // the BITMAPINFOHEADER structure. We can cast the IMediaSample interface
    // to a CImageSample object so we can retrieve it's DIBSECTION details

    pbmi = HEADER(m_pMediaType->Format());
    pSample = (CImageSample *) pMediaSample;
    pDibData = pSample->GetDIBData();
    hOldBitmap = (HBITMAP) SelectObject(m_MemoryDC,pDibData->hBitmap);

    // Get a pointer to the real image data

    HRESULT hr = pMediaSample->GetPointer(&pImage);
    if (FAILED(hr)) {
        return;
    }

    // Do we need to update the colour table, we increment our palette cookie
    // each time we get a dynamic format change. The sample palette cookie is
    // stored in the DIBDATA structure so we try to keep the fields in sync
    // By the time we get to draw the images the format change will be done
    // so all we do is ask the renderer for what it's palette version is

    if (pDibData->PaletteVersion < GetPaletteVersion()) {
        ASSERT(pbmi->biBitCount <= iPALETTE);
        UpdateColourTable(m_MemoryDC,pbmi);
        pDibData->PaletteVersion = GetPaletteVersion();
    }

    // This allows derived classes to change the source rectangle that we do
    // the drawing with. For example a renderer may ask a codec to stretch
    // the video from 320x240 to 640x480, in which case the source we see in
    // here will still be 320x240, although the source we want to draw with
    // should be scaled up to 640x480. The base class implementation of this
    // method does nothing but return the same rectangle as we are passed in

    RECT SourceRect = ScaleSourceRect(&m_SourceRect);

    // Is the window the same size as the video

    if (m_bStretch == FALSE) {

        // Put the image straight into the window

        BitBlt(
            (HDC) m_hdc,                            // Target device HDC
            m_TargetRect.left,                      // X sink position
            m_TargetRect.top,                       // Y sink position
            m_TargetRect.right - m_TargetRect.left, // Destination width
            m_TargetRect.bottom - m_TargetRect.top, // Destination height
            m_MemoryDC,                             // Source device context
            SourceRect.left,                        // X source position
            SourceRect.top,                         // Y source position
            SRCCOPY);                               // Simple copy

    } else {

        // Stretch the image when copying to the window

        StretchBlt(
            (HDC) m_hdc,                            // Target device HDC
            m_TargetRect.left,                      // X sink position
            m_TargetRect.top,                       // Y sink position
            m_TargetRect.right - m_TargetRect.left, // Destination width
            m_TargetRect.bottom - m_TargetRect.top, // Destination height
            m_MemoryDC,                             // Source device HDC
            SourceRect.left,                        // X source position
            SourceRect.top,                         // Y source position
            SourceRect.right - SourceRect.left,     // Source width
            SourceRect.bottom - SourceRect.top,     // Source height
            SRCCOPY);                               // Simple copy
    }

    // This displays the sample times over the top of the image. This used to
    // draw the times into the offscreen device context however that actually
    // writes the text into the image data buffer which may not be writable

    #ifdef DEBUG
    DisplaySampleTimes(pMediaSample);
    #endif

    // Put the old bitmap back into the device context so we don't leak
    SelectObject(m_MemoryDC,hOldBitmap);
}


// This is called when there is a sample ready to be drawn, unfortunately the
// output pin was being rotten and didn't choose our super excellent shared
// memory DIB allocator so we have to do this slow render using boring old GDI
// SetDIBitsToDevice and StretchDIBits. The down side of using these GDI
// functions is that the image data has to be copied across from our address
// space into theirs before going to the screen (although in reality the cost
// is small because all they do is to map the buffer into their address space)

void CDrawImage::SlowRender(IMediaSample *pMediaSample)
{
    // Get the BITMAPINFOHEADER for the connection

    ASSERT(m_pMediaType);
    BITMAPINFOHEADER *pbmi = HEADER(m_pMediaType->Format());
    BYTE *pImage;

    // Get the image data buffer

    HRESULT hr = pMediaSample->GetPointer(&pImage);
    if (FAILED(hr)) {
        return;
    }

    // This allows derived classes to change the source rectangle that we do
    // the drawing with. For example a renderer may ask a codec to stretch
    // the video from 320x240 to 640x480, in which case the source we see in
    // here will still be 320x240, although the source we want to draw with
    // should be scaled up to 640x480. The base class implementation of this
    // method does nothing but return the same rectangle as we are passed in

    RECT SourceRect = ScaleSourceRect(&m_SourceRect);

    LONG lAdjustedSourceTop = SourceRect.top;
    // if the origin of bitmap is bottom-left, adjust soruce_rect_top
    // to be the bottom-left corner instead of the top-left.
    if (pbmi->biHeight > 0) {
       lAdjustedSourceTop = pbmi->biHeight - SourceRect.bottom;
    }
    // Is the window the same size as the video

    if (m_bStretch == FALSE) {

        // Put the image straight into the window

        SetDIBitsToDevice(
            (HDC) m_hdc,                            // Target device HDC
            m_TargetRect.left,                      // X sink position
            m_TargetRect.top,                       // Y sink position
            m_TargetRect.right - m_TargetRect.left, // Destination width
            m_TargetRect.bottom - m_TargetRect.top, // Destination height
            SourceRect.left,                        // X source position
            lAdjustedSourceTop,                     // Adjusted Y source position
            (UINT) 0,                               // Start scan line
            pbmi->biHeight,                         // Scan lines present
            pImage,                                 // Image data
            (BITMAPINFO *) pbmi,                    // DIB header
            DIB_RGB_COLORS);                        // Type of palette

    } else {

        // Stretch the image when copying to the window

        StretchDIBits(
            (HDC) m_hdc,                            // Target device HDC
            m_TargetRect.left,                      // X sink position
            m_TargetRect.top,                       // Y sink position
            m_TargetRect.right - m_TargetRect.left, // Destination width
            m_TargetRect.bottom - m_TargetRect.top, // Destination height
            SourceRect.left,                        // X source position
            lAdjustedSourceTop,                     // Adjusted Y source position
            SourceRect.right - SourceRect.left,     // Source width
            SourceRect.bottom - SourceRect.top,     // Source height
            pImage,                                 // Image data
            (BITMAPINFO *) pbmi,                    // DIB header
            DIB_RGB_COLORS,                         // Type of palette
            SRCCOPY);                               // Simple image copy
    }

    // This shows the sample reference times over the top of the image which
    // looks a little flickery. I tried using GdiSetBatchLimit and GdiFlush to
    // control the screen updates but it doesn't quite work as expected and
    // only partially reduces the flicker. I also tried using a memory context
    // and combining the two in that before doing a final BitBlt operation to
    // the screen, unfortunately this has considerable performance penalties
    // and also means that this code is not executed when compiled retail

    #ifdef DEBUG
    DisplaySampleTimes(pMediaSample);
    #endif
}


// This is called with an IMediaSample interface on the image to be drawn. We
// decide on the drawing mechanism based on who's allocator we are using. We
// may be called when the window wants an image painted by WM_PAINT messages
// We can't realise the palette here because we have the renderer lock, any
// call to realise may cause an interthread send message to the window thread
// which may in turn be waiting to get the renderer lock before servicing it

BOOL CDrawImage::DrawImage(IMediaSample *pMediaSample)
{
    ASSERT(m_hdc);
    ASSERT(m_MemoryDC);
    NotifyStartDraw();

    // If the output pin used our allocator then the samples passed are in
    // fact CVideoSample objects that contain CreateDIBSection data that we
    // use to do faster image rendering, they may optionally also contain a
    // DirectDraw surface pointer in which case we do not do the drawing

    if (m_bUsingImageAllocator == FALSE) {
        SlowRender(pMediaSample);
        EXECUTE_ASSERT(GdiFlush());
        NotifyEndDraw();
        return TRUE;
    }

    // This is a DIBSECTION buffer

    FastRender(pMediaSample);
    EXECUTE_ASSERT(GdiFlush());
    NotifyEndDraw();
    return TRUE;
}


BOOL CDrawImage::DrawVideoImageHere(
    HDC hdc,
    IMediaSample *pMediaSample,
    LPRECT lprcSrc,
    LPRECT lprcDst
    )
{
    ASSERT(m_pMediaType);
    BITMAPINFOHEADER *pbmi = HEADER(m_pMediaType->Format());
    BYTE *pImage;

    // Get the image data buffer

    HRESULT hr = pMediaSample->GetPointer(&pImage);
    if (FAILED(hr)) {
        return FALSE;
    }

    RECT SourceRect;
    RECT TargetRect;

    if (lprcSrc) {
        SourceRect = *lprcSrc;
    }
    else  SourceRect = ScaleSourceRect(&m_SourceRect);

    if (lprcDst) {
        TargetRect = *lprcDst;
    }
    else  TargetRect = m_TargetRect;

    LONG lAdjustedSourceTop = SourceRect.top;
    // if the origin of bitmap is bottom-left, adjust soruce_rect_top
    // to be the bottom-left corner instead of the top-left.
    if (pbmi->biHeight > 0) {
       lAdjustedSourceTop = pbmi->biHeight - SourceRect.bottom;
    }


    // Stretch the image when copying to the DC

    BOOL bRet = (0 != StretchDIBits(hdc,
                                    TargetRect.left,
                                    TargetRect.top,
                                    TargetRect.right - TargetRect.left,
                                    TargetRect.bottom - TargetRect.top,
                                    SourceRect.left,
                                    lAdjustedSourceTop,
                                    SourceRect.right - SourceRect.left,
                                    SourceRect.bottom - SourceRect.top,
                                    pImage,
                                    (BITMAPINFO *)pbmi,
                                    DIB_RGB_COLORS,
                                    SRCCOPY));
    return bRet;
}


// This is called by the owning window object after it has created the window
// and it's drawing contexts. We are constructed with the base window we'll
// be drawing into so when given the notification we retrive the device HDCs
// to draw with. We cannot call these in our constructor as they are virtual

void CDrawImage::SetDrawContext()
{
    m_MemoryDC = m_pBaseWindow->GetMemoryHDC();
    m_hdc = m_pBaseWindow->GetWindowHDC();
}


// This is called to set the target rectangle in the video window, it will be
// called whenever a WM_SIZE message is retrieved from the message queue. We
// simply store the rectangle and use it later when we do the drawing calls

void CDrawImage::SetTargetRect(RECT *pTargetRect)
{
    ASSERT(pTargetRect);
    m_TargetRect = *pTargetRect;
    SetStretchMode();
}


// Return the current target rectangle

void CDrawImage::GetTargetRect(RECT *pTargetRect)
{
    ASSERT(pTargetRect);
    *pTargetRect = m_TargetRect;
}


// This is called when we want to change the section of the image to draw. We
// use this information in the drawing operation calls later on. We must also
// see if the source and destination rectangles have the same dimensions. If
// not we must stretch during the drawing rather than a direct pixel copy

void CDrawImage::SetSourceRect(RECT *pSourceRect)
{
    ASSERT(pSourceRect);
    m_SourceRect = *pSourceRect;
    SetStretchMode();
}


// Return the current source rectangle

void CDrawImage::GetSourceRect(RECT *pSourceRect)
{
    ASSERT(pSourceRect);
    *pSourceRect = m_SourceRect;
}


// This is called when either the source or destination rectanges change so we
// can update the stretch flag. If the rectangles don't match we stretch the
// video during the drawing otherwise we call the fast pixel copy functions
// NOTE the source and/or the destination rectangle may be completely empty

void CDrawImage::SetStretchMode()
{
    // Calculate the overall rectangle dimensions

    LONG SourceWidth = m_SourceRect.right - m_SourceRect.left;
    LONG SinkWidth = m_TargetRect.right - m_TargetRect.left;
    LONG SourceHeight = m_SourceRect.bottom - m_SourceRect.top;
    LONG SinkHeight = m_TargetRect.bottom - m_TargetRect.top;

    m_bStretch = TRUE;
    if (SourceWidth == SinkWidth) {
        if (SourceHeight == SinkHeight) {
            m_bStretch = FALSE;
        }
    }
}


// Tell us whose allocator we are using. This should be called with TRUE if
// the filter agrees to use an allocator based around the CImageAllocator
// SDK base class - whose image buffers are made through CreateDIBSection.
// Otherwise this should be called with FALSE and we will draw the images
// using SetDIBitsToDevice and StretchDIBitsToDevice. None of these calls
// can handle buffers which have non zero strides (like DirectDraw uses)

void CDrawImage::NotifyAllocator(BOOL bUsingImageAllocator)
{
    m_bUsingImageAllocator = bUsingImageAllocator;
}


// Are we using the image DIBSECTION allocator

BOOL CDrawImage::UsingImageAllocator()
{
    return m_bUsingImageAllocator;
}


// We need the media type of the connection so that we can get the BITMAPINFO
// from it. We use that in the calls to draw the image such as StretchDIBits
// and also when updating the colour table held in shared memory DIBSECTIONs

void CDrawImage::NotifyMediaType(CMediaType *pMediaType)
{
    m_pMediaType = pMediaType;
}


// We store in this object a cookie maintaining the current palette version.
// Each time a palettised format is changed we increment this value so that
// when we come to draw the images we look at the colour table value they
// have and if less than the current we know to update it. This version is
// only needed and indeed used when working with shared memory DIBSECTIONs

LONG CDrawImage::GetPaletteVersion()
{
    return m_PaletteVersion;
}


// Resets the current palette version number

void CDrawImage::ResetPaletteVersion()
{
    m_PaletteVersion = PALETTE_VERSION;
}


// Increment the current palette version

void CDrawImage::IncrementPaletteVersion()
{
    m_PaletteVersion++;
}


// Constructor must initialise the base allocator. Each sample we create has a
// palette version cookie on board. When the source filter changes the palette
// during streaming the window object increments an internal cookie counter it
// keeps as well. When it comes to render the samples it looks at the cookie
// values and if they don't match then it knows to update the sample's colour
// table. However we always create samples with a cookie of PALETTE_VERSION
// If there have been multiple format changes and we disconnect and reconnect
// thereby causing the samples to be reallocated we will create them with a
// cookie much lower than the current version, this isn't a problem since it
// will be seen by the window object and the versions will then be updated

CImageAllocator::CImageAllocator(CBaseFilter *pFilter,
                                 TCHAR *pName,
                                 HRESULT *phr) :
    CBaseAllocator(pName,NULL,phr,TRUE,TRUE),
    m_pFilter(pFilter)
{
    ASSERT(phr);
    ASSERT(pFilter);
}


// Check our DIB buffers have been released

#ifdef DEBUG
CImageAllocator::~CImageAllocator()
{
    ASSERT(m_bCommitted == FALSE);
}
#endif


// Called from destructor and also from base class to free resources. We work
// our way through the list of media samples deleting the DIBSECTION created
// for each. All samples should be back in our list so there is no chance a
// filter is still using one to write on the display or hold on a pending list

void CImageAllocator::Free()
{
    ASSERT(m_lAllocated == m_lFree.GetCount());
    EXECUTE_ASSERT(GdiFlush());
    CImageSample *pSample;
    DIBDATA *pDibData;

    while (m_lFree.GetCount() != 0) {
        pSample = (CImageSample *) m_lFree.RemoveHead();
        pDibData = pSample->GetDIBData();
        EXECUTE_ASSERT(DeleteObject(pDibData->hBitmap));
        EXECUTE_ASSERT(CloseHandle(pDibData->hMapping));
        delete pSample;
    }

    m_lAllocated = 0;
}


// Prepare the allocator by checking all the input parameters

STDMETHODIMP CImageAllocator::CheckSizes(ALLOCATOR_PROPERTIES *pRequest)
{
    // Check we have a valid connection

    if (m_pMediaType == NULL) {
        return VFW_E_NOT_CONNECTED;
    }

    // NOTE We always create a DIB section with the source format type which
    // may contain a source palette. When we do the BitBlt drawing operation
    // the target display device may contain a different palette (we may not
    // have the focus) in which case GDI will do after the palette mapping

    VIDEOINFOHEADER *pVideoInfo = (VIDEOINFOHEADER *) m_pMediaType->Format();

    // When we call CreateDIBSection it implicitly maps only enough memory
    // for the image as defined by thee BITMAPINFOHEADER. If the user asks
    // for an image smaller than this then we reject the call, if they ask
    // for an image larger than this then we return what they can have

    if ((DWORD) pRequest->cbBuffer < pVideoInfo->bmiHeader.biSizeImage) {
        return E_INVALIDARG;
    }

    // Reject buffer prefixes

    if (pRequest->cbPrefix > 0) {
        return E_INVALIDARG;
    }

    pRequest->cbBuffer = pVideoInfo->bmiHeader.biSizeImage;
    return NOERROR;
}


// Agree the number of media sample buffers and their sizes. The base class
// this allocator is derived from allows samples to be aligned only on byte
// boundaries NOTE the buffers are not allocated until the Commit call

STDMETHODIMP CImageAllocator::SetProperties(
    ALLOCATOR_PROPERTIES * pRequest,
    ALLOCATOR_PROPERTIES * pActual)
{
    ALLOCATOR_PROPERTIES Adjusted = *pRequest;

    // Check the parameters fit with the current connection

    HRESULT hr = CheckSizes(&Adjusted);
    if (FAILED(hr)) {
        return hr;
    }
    return CBaseAllocator::SetProperties(&Adjusted, pActual);
}


// Commit the memory by allocating the agreed number of media samples. For
// each sample we are committed to creating we have a CImageSample object
// that we use to manage it's resources. This is initialised with a DIBDATA
// structure that contains amongst other things the GDI DIBSECTION handle
// We will access the renderer media type during this so we must have locked
// (to prevent the format changing for example). The class overrides Commit
// and Decommit to do this locking (base class Commit in turn calls Alloc)

HRESULT CImageAllocator::Alloc(void)
{
    ASSERT(m_pMediaType);
    CImageSample *pSample;
    DIBDATA DibData;

    // Check the base allocator says it's ok to continue

    HRESULT hr = CBaseAllocator::Alloc();
    if (FAILED(hr)) {
        return hr;
    }

    // We create a new memory mapped object although we don't map it into our
    // address space because GDI does that in CreateDIBSection. It is possible
    // that we run out of resources before creating all the samples in which
    // case the available sample list is left with those already created

    ASSERT(m_lAllocated == 0);
    while (m_lAllocated < m_lCount) {

        // Create and initialise a shared memory GDI buffer

        HRESULT hr = CreateDIB(m_lSize,DibData);
        if (FAILED(hr)) {
            return hr;
        }

        // Create the sample object and pass it the DIBDATA

        pSample = CreateImageSample(DibData.pBase,m_lSize);
        if (pSample == NULL) {
            EXECUTE_ASSERT(DeleteObject(DibData.hBitmap));
            EXECUTE_ASSERT(CloseHandle(DibData.hMapping));
            return E_OUTOFMEMORY;
        }

        // Add the completed sample to the available list

        pSample->SetDIBData(&DibData);
        m_lFree.Add(pSample);
        m_lAllocated++;
    }
    return NOERROR;
}


// We have a virtual method that allocates the samples so that a derived class
// may override it and allocate more specialised sample objects. So long as it
// derives its samples from CImageSample then all this code will still work ok

CImageSample *CImageAllocator::CreateImageSample(LPBYTE pData,LONG Length)
{
    HRESULT hr = NOERROR;
    CImageSample *pSample;

    // Allocate the new sample and check the return codes

    pSample = new CImageSample((CBaseAllocator *) this,   // Base class
                               NAME("Video sample"),      // DEBUG name
                               (HRESULT *) &hr,           // Return code
                               (LPBYTE) pData,            // DIB address
                               (LONG) Length);            // Size of DIB

    if (pSample == NULL || FAILED(hr)) {
        delete pSample;
        return NULL;
    }
    return pSample;
}


// This function allocates a shared memory block for use by the source filter
// generating DIBs for us to render. The memory block is created in shared
// memory so that GDI doesn't have to copy the memory when we do a BitBlt

HRESULT CImageAllocator::CreateDIB(LONG InSize,DIBDATA &DibData)
{
    BITMAPINFO *pbmi;       // Format information for pin
    BYTE *pBase;            // Pointer to the actual image
    HANDLE hMapping;        // Handle to mapped object
    HBITMAP hBitmap;        // DIB section bitmap handle

    // Create a file mapping object and map into our address space

    hMapping = CreateFileMapping(hMEMORY,         // Use system page file
                                 NULL,            // No security attributes
                                 PAGE_READWRITE,  // Full access to memory
                                 (DWORD) 0,       // Less than 4Gb in size
                                 InSize,          // Size of buffer
                                 NULL);           // No name to section
    if (hMapping == NULL) {
        DWORD Error = GetLastError();
        return MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, Error);
    }

    // NOTE We always create a DIB section with the source format type which
    // may contain a source palette. When we do the BitBlt drawing operation
    // the target display device may contain a different palette (we may not
    // have the focus) in which case GDI will do after the palette mapping

    pbmi = (BITMAPINFO *) HEADER(m_pMediaType->Format());
    if (m_pMediaType == NULL) {
        DbgBreak("Invalid media type");
    }

    hBitmap = CreateDIBSection((HDC) NULL,          // NO device context
                               pbmi,                // Format information
                               DIB_RGB_COLORS,      // Use the palette
                               (VOID **) &pBase,    // Pointer to image data
                               hMapping,            // Mapped memory handle
                               (DWORD) 0);          // Offset into memory

    if (hBitmap == NULL || pBase == NULL) {
        EXECUTE_ASSERT(CloseHandle(hMapping));
        DWORD Error = GetLastError();
        return MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, Error);
    }

    // Initialise the DIB information structure

    DibData.hBitmap = hBitmap;
    DibData.hMapping = hMapping;
    DibData.pBase = pBase;
    DibData.PaletteVersion = PALETTE_VERSION;
    GetObject(hBitmap,sizeof(DIBSECTION),(VOID *)&DibData.DibSection);

    return NOERROR;
}


// We use the media type during the DIBSECTION creation

void CImageAllocator::NotifyMediaType(CMediaType *pMediaType)
{
    m_pMediaType = pMediaType;
}


// Overriden to increment the owning object's reference count

STDMETHODIMP_(ULONG) CImageAllocator::NonDelegatingAddRef()
{
    return m_pFilter->AddRef();
}


// Overriden to decrement the owning object's reference count

STDMETHODIMP_(ULONG) CImageAllocator::NonDelegatingRelease()
{
    return m_pFilter->Release();
}


// If you derive a class from CMediaSample that has to transport specialised
// member variables and entry points then there are three alternate solutions
// The first is to create a memory buffer larger than actually required by the
// sample and store your information either at the beginning of it or at the
// end, the former being moderately safer allowing for misbehaving transform
// filters. You then adjust the buffer address when you create the base media
// sample. This has the disadvantage of breaking up the memory allocated to
// the samples into separate blocks. The second solution is to implement a
// class derived from CMediaSample and support additional interface(s) that
// convey your private data. This means defining a custom interface. The final
// alternative is to create a class that inherits from CMediaSample and adds
// the private data structures, when you get an IMediaSample in your Receive()
// call check to see if your allocator is being used, and if it is then cast
// the IMediaSample into one of your objects. Additional checks can be made
// to ensure the sample's this pointer is known to be one of your own objects

CImageSample::CImageSample(CBaseAllocator *pAllocator,
                           TCHAR *pName,
                           HRESULT *phr,
                           LPBYTE pBuffer,
                           LONG length) :
    CMediaSample(pName,pAllocator,phr,pBuffer,length),
    m_bInit(FALSE)
{
    ASSERT(pAllocator);
    ASSERT(pBuffer);
}


// Set the shared memory DIB information

void CImageSample::SetDIBData(DIBDATA *pDibData)
{
    ASSERT(pDibData);
    m_DibData = *pDibData;
    m_bInit = TRUE;
}


// Retrieve the shared memory DIB data

DIBDATA *CImageSample::GetDIBData()
{
    ASSERT(m_bInit == TRUE);
    return &m_DibData;
}


// This class handles the creation of a palette. It is fairly specialist and
// is intended to simplify palette management for video renderer filters. It
// is for this reason that the constructor requires three other objects with
// which it interacts, namely a base media filter, a base window and a base
// drawing object although the base window or the draw object may be NULL to
// ignore that part of us. We try not to create and install palettes unless
// absolutely necessary as they typically require WM_PALETTECHANGED messages
// to be sent to every window thread in the system which is very expensive

CImagePalette::CImagePalette(CBaseFilter *pBaseFilter,
                             CBaseWindow *pBaseWindow,
                             CDrawImage *pDrawImage) :
    m_pBaseWindow(pBaseWindow),
    m_pFilter(pBaseFilter),
    m_pDrawImage(pDrawImage),
    m_hPalette(NULL)
{
    ASSERT(m_pFilter);
}


// Destructor

#ifdef DEBUG
CImagePalette::~CImagePalette()
{
    ASSERT(m_hPalette == NULL);
}
#endif


// We allow dynamic format changes of the palette but rather than change the
// palette every time we call this to work out whether an update is required.
// If the original type didn't use a palette and the new one does (or vica
// versa) then we return TRUE. If neither formats use a palette we'll return
// FALSE. If both formats use a palette we compare their colours and return
// FALSE if they match. This therefore short circuits palette creation unless
// absolutely necessary since installing palettes is an expensive operation

BOOL CImagePalette::ShouldUpdate(const VIDEOINFOHEADER *pNewInfo,
                                 const VIDEOINFOHEADER *pOldInfo)
{
    // We may not have a current format yet

    if (pOldInfo == NULL) {
        return TRUE;
    }

    // Do both formats not require a palette

    if (ContainsPalette(pNewInfo) == FALSE) {
        if (ContainsPalette(pOldInfo) == FALSE) {
            return FALSE;
        }
    }

    // Compare the colours to see if they match

    DWORD VideoEntries = pNewInfo->bmiHeader.biClrUsed;
    if (ContainsPalette(pNewInfo) == TRUE)
        if (ContainsPalette(pOldInfo) == TRUE)
            if (pOldInfo->bmiHeader.biClrUsed == VideoEntries)
                if (pOldInfo->bmiHeader.biClrUsed > 0)
                    if (memcmp((PVOID) GetBitmapPalette(pNewInfo),
                               (PVOID) GetBitmapPalette(pOldInfo),
                               VideoEntries * sizeof(RGBQUAD)) == 0) {

                        return FALSE;
                    }
    return TRUE;
}


// This is normally called when the input pin type is set to install a palette
// We will typically be called from two different places. The first is when we
// have negotiated a palettised media type after connection, the other is when
// we receive a new type during processing with an updated palette in which
// case we must remove and release the resources held by the current palette

// We can be passed an optional device name if we wish to prepare a palette
// for a specific monitor on a multi monitor system

HRESULT CImagePalette::PreparePalette(const CMediaType *pmtNew,
                                      const CMediaType *pmtOld,
				      LPSTR szDevice)
{
    const VIDEOINFOHEADER *pNewInfo = (VIDEOINFOHEADER *) pmtNew->Format();
    const VIDEOINFOHEADER *pOldInfo = (VIDEOINFOHEADER *) pmtOld->Format();
    ASSERT(pNewInfo);

    // This is an performance optimisation, when we get a media type we check
    // to see if the format requires a palette change. If either we need one
    // when previously we didn't or vica versa then this returns TRUE, if we
    // previously needed a palette and we do now it compares their colours

    if (ShouldUpdate(pNewInfo,pOldInfo) == FALSE) {
        NOTE("No update needed");
        return S_FALSE;
    }

    // We must notify the filter graph that the application may have changed
    // the palette although in practice we don't bother checking to see if it
    // is really different. If it tries to get the palette either the window
    // or renderer lock will ensure it doesn't get in until we are finished

    RemovePalette();
    m_pFilter->NotifyEvent(EC_PALETTE_CHANGED,0,0);

    // Do we need a palette for the new format

    if (ContainsPalette(pNewInfo) == FALSE) {
        NOTE("New has no palette");
        return S_FALSE;
    }

    if (m_pBaseWindow) {
        m_pBaseWindow->LockPaletteLock();
    }

    // If we're changing the palette on the fly then we increment our palette
    // cookie which is compared against the cookie also stored in all of our
    // DIBSECTION media samples. If they don't match when we come to draw it
    // then we know the sample is out of date and we'll update it's palette

    NOTE("Making new colour palette");
    m_hPalette = MakePalette(pNewInfo, szDevice);
    ASSERT(m_hPalette != NULL);

    if (m_pBaseWindow) {
        m_pBaseWindow->UnlockPaletteLock();
    }

    // The window in which the new palette is to be realised may be a NULL
    // pointer to signal that no window is in use, if so we don't call it
    // Some filters just want to use this object to create/manage palettes

    if (m_pBaseWindow) m_pBaseWindow->SetPalette(m_hPalette);

    // This is the only time where we need access to the draw object to say
    // to it that a new palette will be arriving on a sample real soon. The
    // constructor may take a NULL pointer in which case we don't call this

    if (m_pDrawImage) m_pDrawImage->IncrementPaletteVersion();
    return NOERROR;
}


// Helper function to copy a palette out of any kind of VIDEOINFO (ie it may
// be YUV or true colour) into a palettised VIDEOINFO. We use this changing
// palettes on DirectDraw samples as a source filter can attach a palette to
// any buffer (eg YUV) and hand it back. We make a new palette out of that
// format and then copy the palette colours into the current connection type

HRESULT CImagePalette::CopyPalette(const CMediaType *pSrc,CMediaType *pDest)
{
    // Reset the destination palette before starting

    VIDEOINFOHEADER *pDestInfo = (VIDEOINFOHEADER *) pDest->Format();
    pDestInfo->bmiHeader.biClrUsed = 0;
    pDestInfo->bmiHeader.biClrImportant = 0;

    // Does the destination have a palette

    if (PALETTISED(pDestInfo) == FALSE) {
        NOTE("No destination palette");
        return S_FALSE;
    }

    // Does the source contain a palette

    const VIDEOINFOHEADER *pSrcInfo = (VIDEOINFOHEADER *) pSrc->Format();
    if (ContainsPalette(pSrcInfo) == FALSE) {
        NOTE("No source palette");
        return S_FALSE;
    }

    // The number of colours may be zero filled

    DWORD PaletteEntries = pSrcInfo->bmiHeader.biClrUsed;
    if (PaletteEntries == 0) {
        DWORD Maximum  = (1 << pSrcInfo->bmiHeader.biBitCount);
        NOTE1("Setting maximum colours (%d)",Maximum);
        PaletteEntries = Maximum;
    }

    // Make sure the destination has enough room for the palette

    ASSERT(pSrcInfo->bmiHeader.biClrUsed <= iPALETTE_COLORS);
    ASSERT(pSrcInfo->bmiHeader.biClrImportant <= PaletteEntries);
    ASSERT(COLORS(pDestInfo) == GetBitmapPalette(pDestInfo));
    pDestInfo->bmiHeader.biClrUsed = PaletteEntries;
    pDestInfo->bmiHeader.biClrImportant = pSrcInfo->bmiHeader.biClrImportant;
    ULONG BitmapSize = GetBitmapFormatSize(HEADER(pSrcInfo));

    if (pDest->FormatLength() < BitmapSize) {
        NOTE("Reallocating destination");
        pDest->ReallocFormatBuffer(BitmapSize);
    }

    // Now copy the palette colours across

    CopyMemory((PVOID) COLORS(pDestInfo),
               (PVOID) GetBitmapPalette(pSrcInfo),
               PaletteEntries * sizeof(RGBQUAD));

    return NOERROR;
}


// This is normally called when the palette is changed (typically during a
// dynamic format change) to remove any palette we previously installed. We
// replace it (if necessary) in the video window with a standard VGA palette
// that should always be available even if this is a true colour display

HRESULT CImagePalette::RemovePalette()
{
    if (m_pBaseWindow) {
        m_pBaseWindow->LockPaletteLock();
    }

    // Do we have a palette to remove

    if (m_hPalette != NULL) {

        if (m_pBaseWindow) {
            // Make sure that the window's palette handle matches
            // our palette handle.
            ASSERT(m_hPalette == m_pBaseWindow->GetPalette());

            m_pBaseWindow->UnsetPalette();
        }

        EXECUTE_ASSERT(DeleteObject(m_hPalette));
        m_hPalette = NULL;
    }

    if (m_pBaseWindow) {
        m_pBaseWindow->UnlockPaletteLock();
    }

    return NOERROR;
}


// Called to create a palette for the object, the data structure used by GDI
// to describe a palette is a LOGPALETTE, this includes a variable number of
// PALETTEENTRY fields which are the colours, we have to convert the RGBQUAD
// colour fields we are handed in a BITMAPINFO from the media type into these
// This handles extraction of palettes from true colour and YUV media formats

// We can be passed an optional device name if we wish to prepare a palette
// for a specific monitor on a multi monitor system

HPALETTE CImagePalette::MakePalette(const VIDEOINFOHEADER *pVideoInfo, LPSTR szDevice)
{
    ASSERT(ContainsPalette(pVideoInfo) == TRUE);
    ASSERT(pVideoInfo->bmiHeader.biClrUsed <= iPALETTE_COLORS);
    BITMAPINFOHEADER *pHeader = HEADER(pVideoInfo);

    const RGBQUAD *pColours;            // Pointer to the palette
    LOGPALETTE *lp;                     // Used to create a palette
    HPALETTE hPalette;                  // Logical palette object

    lp = (LOGPALETTE *) new BYTE[sizeof(LOGPALETTE) + SIZE_PALETTE];
    if (lp == NULL) {
        return NULL;
    }

    // Unfortunately for some hare brained reason a GDI palette entry (a
    // PALETTEENTRY structure) is different to a palette entry from a DIB
    // format (a RGBQUAD structure) so we have to do the field conversion
    // The VIDEOINFO containing the palette may be a true colour type so
    // we use GetBitmapPalette to skip over any bit fields if they exist

    lp->palVersion = PALVERSION;
    lp->palNumEntries = (USHORT) pHeader->biClrUsed;
    if (lp->palNumEntries == 0) lp->palNumEntries = (1 << pHeader->biBitCount);
    pColours = GetBitmapPalette(pVideoInfo);

    for (DWORD dwCount = 0;dwCount < lp->palNumEntries;dwCount++) {
        lp->palPalEntry[dwCount].peRed = pColours[dwCount].rgbRed;
        lp->palPalEntry[dwCount].peGreen = pColours[dwCount].rgbGreen;
        lp->palPalEntry[dwCount].peBlue = pColours[dwCount].rgbBlue;
        lp->palPalEntry[dwCount].peFlags = 0;
    }

    MakeIdentityPalette(lp->palPalEntry, lp->palNumEntries, szDevice);

    // Create a logical palette

    hPalette = CreatePalette(lp);
    ASSERT(hPalette != NULL);
    delete[] lp;
    return hPalette;
}


// GDI does a fair job of compressing the palette entries you give it, so for
// example if you have five entries with an RGB colour (0,0,0) it will remove
// all but one of them. When you subsequently draw an image it will map from
// your logical palette to the compressed device palette. This function looks
// to see if it is trying to be an identity palette and if so sets the flags
// field in the PALETTEENTRYs so they remain expanded to boost performance

// We can be passed an optional device name if we wish to prepare a palette
// for a specific monitor on a multi monitor system

HRESULT CImagePalette::MakeIdentityPalette(PALETTEENTRY *pEntry,INT iColours, LPSTR szDevice)
{
    PALETTEENTRY SystemEntries[10];         // System palette entries
    BOOL bIdentityPalette = TRUE;           // Is an identity palette
    ASSERT(iColours <= iPALETTE_COLORS);    // Should have a palette
    const int PalLoCount = 10;              // First ten reserved colours
    const int PalHiStart = 246;             // Last VGA palette entries

    // Does this have the full colour range

    if (iColours < 10) {
        return S_FALSE;
    }

    // Apparently some displays have odd numbers of system colours

    // Get a DC on the right monitor - it's ugly, but this is the way you have
    // to do it
    HDC hdc;
    if (szDevice == NULL || lstrcmpiA(szDevice, "DISPLAY") == 0)
        hdc = CreateDCA("DISPLAY", NULL, NULL, NULL);
    else
        hdc = CreateDCA(NULL, szDevice, NULL, NULL);
    if (NULL == hdc) {
        return E_OUTOFMEMORY;
    }
    INT Reserved = GetDeviceCaps(hdc,NUMRESERVED);
    if (Reserved != 20) {
        DeleteDC(hdc);
        return S_FALSE;
    }

    // Compare our palette against the first ten system entries. The reason I
    // don't do a memory compare between our two arrays of colours is because
    // I am not sure what will be in the flags fields for the system entries

    UINT Result = GetSystemPaletteEntries(hdc,0,PalLoCount,SystemEntries);
    for (UINT Count = 0;Count < Result;Count++) {
        if (SystemEntries[Count].peRed != pEntry[Count].peRed ||
                SystemEntries[Count].peGreen != pEntry[Count].peGreen ||
                    SystemEntries[Count].peBlue != pEntry[Count].peBlue) {
                        bIdentityPalette = FALSE;
        }
    }

    // And likewise compare against the last ten entries

    Result = GetSystemPaletteEntries(hdc,PalHiStart,PalLoCount,SystemEntries);
    for (Count = 0;Count < Result;Count++) {
        if (INT(Count) + PalHiStart < iColours) {
            if (SystemEntries[Count].peRed != pEntry[PalHiStart + Count].peRed ||
                    SystemEntries[Count].peGreen != pEntry[PalHiStart + Count].peGreen ||
                        SystemEntries[Count].peBlue != pEntry[PalHiStart + Count].peBlue) {
                            bIdentityPalette = FALSE;
            }
        }
    }

    // If not an identity palette then return S_FALSE

    DeleteDC(hdc);
    if (bIdentityPalette == FALSE) {
        return S_FALSE;
    }

    // Set the non VGA entries so that GDI doesn't map them

    for (Count = PalLoCount;INT(Count) < min(PalHiStart,iColours);Count++) {
        pEntry[Count].peFlags = PC_NOCOLLAPSE;
    }
    return NOERROR;
}


// Constructor initialises the VIDEOINFO we keep storing the current display
// format. The format can be changed at any time, to reset the format held
// by us call the RefreshDisplayType directly (it's a public method). Since
// more than one thread will typically call us (ie window threads resetting
// the type and source threads in the type checking methods) we have a lock

CImageDisplay::CImageDisplay()
{
    RefreshDisplayType(NULL);
}



// This initialises the format we hold which contains the display device type
// We do a conversion on the display device type in here so that when we start
// type checking input formats we can assume that certain fields have been set
// correctly, an example is when we make the 16 bit mask fields explicit. This
// is normally called when we receive WM_DEVMODECHANGED device change messages

// The optional szDeviceName parameter tells us which monitor we are interested
// in for a multi monitor system

HRESULT CImageDisplay::RefreshDisplayType(LPSTR szDeviceName)
{
    CAutoLock cDisplayLock(this);

    // Set the preferred format type

    ZeroMemory((PVOID)&m_Display,sizeof(VIDEOINFOHEADER)+sizeof(TRUECOLORINFO));
    m_Display.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    m_Display.bmiHeader.biBitCount = FALSE;

    // Get the bit depth of a device compatible bitmap

    // get caps of whichever monitor they are interested in (multi monitor)
    HDC hdcDisplay;
    // it's ugly, but this is the way you have to do it
    if (szDeviceName == NULL || lstrcmpiA(szDeviceName, "DISPLAY") == 0)
        hdcDisplay = CreateDCA("DISPLAY", NULL, NULL, NULL);
    else
        hdcDisplay = CreateDCA(NULL, szDeviceName, NULL, NULL);
    if (hdcDisplay == NULL) {
    ASSERT(FALSE);
    DbgLog((LOG_ERROR,1,TEXT("ACK! Can't get a DC for %hs"),
                szDeviceName ? szDeviceName : "<NULL>"));
    return E_FAIL;
    } else {
    DbgLog((LOG_TRACE,3,TEXT("Created a DC for %s"),
                szDeviceName ? szDeviceName : "<NULL>"));
    }
    HBITMAP hbm = CreateCompatibleBitmap(hdcDisplay,1,1);
    if ( hbm )
    {
        GetDIBits(hdcDisplay,hbm,0,1,NULL,(BITMAPINFO *)&m_Display.bmiHeader,DIB_RGB_COLORS);

        // This call will get the colour table or the proper bitfields
        GetDIBits(hdcDisplay,hbm,0,1,NULL,(BITMAPINFO *)&m_Display.bmiHeader,DIB_RGB_COLORS);
        DeleteObject(hbm);
    }
    DeleteDC(hdcDisplay);

    // Complete the display type initialisation

    ASSERT(CheckHeaderValidity(&m_Display));
    UpdateFormat(&m_Display);
    DbgLog((LOG_TRACE,3,TEXT("New DISPLAY bit depth =%d"),
                m_Display.bmiHeader.biBitCount));
    return NOERROR;
}


// We assume throughout this code that any bitfields masks are allowed no
// more than eight bits to store a colour component. This checks that the
// bit count assumption is enforced and also makes sure that all the bits
// set are contiguous. We return a boolean TRUE if the field checks out ok

BOOL CImageDisplay::CheckBitFields(const VIDEOINFO *pInput)
{
    DWORD *pBitFields = (DWORD *) BITMASKS(pInput);

    for (INT iColour = iRED;iColour <= iBLUE;iColour++) {

        // First of all work out how many bits are set

        DWORD SetBits = CountSetBits(pBitFields[iColour]);
        if (SetBits > iMAXBITS || SetBits == 0) {
            NOTE1("Bit fields for component %d invalid",iColour);
            return FALSE;
        }

        // Next work out the number of zero bits prefix
        DWORD PrefixBits = CountPrefixBits(pBitFields[iColour]);

        // This is going to see if all the bits set are contiguous (as they
        // should be). We know how much to shift them right by from the
        // count of prefix bits. The number of bits set defines a mask, we
        // invert this (ones complement) and AND it with the shifted bit
        // fields. If the result is NON zero then there are bit(s) sticking
        // out the left hand end which means they are not contiguous

        DWORD TestField = pBitFields[iColour] >> PrefixBits;
        DWORD Mask = ULONG_MAX << SetBits;
        if (TestField & Mask) {
            NOTE1("Bit fields for component %d not contiguous",iColour);
            return FALSE;
        }
    }
    return TRUE;
}


// This counts the number of bits set in the input field

DWORD CImageDisplay::CountSetBits(DWORD Field)
{
    // This is a relatively well known bit counting algorithm

    DWORD Count = 0;
    DWORD init = Field;

    // Until the input is exhausted, count the number of bits

    while (init) {
        init = init & (init - 1);  // Turn off the bottommost bit
        Count++;
    }
    return Count;
}


// This counts the number of zero bits upto the first one set NOTE the input
// field should have been previously checked to ensure there is at least one
// set although if we don't find one set we return the impossible value 32

DWORD CImageDisplay::CountPrefixBits(DWORD Field)
{
    DWORD Mask = 1;
    DWORD Count = 0;

    while (TRUE) {
        if (Field & Mask) {
            return Count;
        }
        Count++;

        ASSERT(Mask != 0x80000000);
        if (Mask == 0x80000000) {
            return Count;
        }
        Mask <<= 1;
    }
}


// This is called to check the BITMAPINFOHEADER for the input type. There are
// many implicit dependancies between the fields in a header structure which
// if we validate now make for easier manipulation in subsequent handling. We
// also check that the BITMAPINFOHEADER matches it's specification such that
// fields likes the number of planes is one, that it's structure size is set
// correctly and that the bitmap dimensions have not been set as negative

BOOL CImageDisplay::CheckHeaderValidity(const VIDEOINFO *pInput)
{
    // Check the bitmap width and height are not negative.

    if (pInput->bmiHeader.biWidth <= 0 ||
    pInput->bmiHeader.biHeight <= 0) {
        NOTE("Invalid bitmap dimensions");
        return FALSE;
    }

    // Check the compression is either BI_RGB or BI_BITFIELDS

    if (pInput->bmiHeader.biCompression != BI_RGB) {
        if (pInput->bmiHeader.biCompression != BI_BITFIELDS) {
            NOTE("Invalid compression format");
            return FALSE;
        }
    }

    // If BI_BITFIELDS compression format check the colour depth

    if (pInput->bmiHeader.biCompression == BI_BITFIELDS) {
        if (pInput->bmiHeader.biBitCount != 16) {
            if (pInput->bmiHeader.biBitCount != 32) {
                NOTE("BI_BITFIELDS not 16/32 bit depth");
                return FALSE;
            }
        }
    }

    // Check the assumptions about the layout of the bit fields

    if (pInput->bmiHeader.biCompression == BI_BITFIELDS) {
        if (CheckBitFields(pInput) == FALSE) {
            NOTE("Bit fields are not valid");
            return FALSE;
        }
    }

    // Are the number of planes equal to one

    if (pInput->bmiHeader.biPlanes != 1) {
        NOTE("Number of planes not one");
        return FALSE;
    }

    // Check the image size is consistent (it can be zero)

    if (pInput->bmiHeader.biSizeImage != GetBitmapSize(&pInput->bmiHeader)) {
        if (pInput->bmiHeader.biSizeImage) {
            NOTE("Image size incorrectly set");
            return FALSE;
        }
    }

    // Check the size of the structure

    if (pInput->bmiHeader.biSize != sizeof(BITMAPINFOHEADER)) {
        NOTE("Size of BITMAPINFOHEADER wrong");
        return FALSE;
    }
    return CheckPaletteHeader(pInput);
}


// This runs a few simple tests against the palette fields in the input to
// see if it looks vaguely correct. The tests look at the number of palette
// colours present, the number considered important and the biCompression
// field which should always be BI_RGB as no other formats are meaningful

BOOL CImageDisplay::CheckPaletteHeader(const VIDEOINFO *pInput)
{
    // The checks here are for palettised videos only

    if (PALETTISED(pInput) == FALSE) {
        if (pInput->bmiHeader.biClrUsed) {
            NOTE("Invalid palette entries");
            return FALSE;
        }
        return TRUE;
    }

    // Compression type of BI_BITFIELDS is meaningless for palette video

    if (pInput->bmiHeader.biCompression != BI_RGB) {
        NOTE("Palettised video must be BI_RGB");
        return FALSE;
    }

    // Check the number of palette colours is correct

    if (pInput->bmiHeader.biClrUsed > PALETTE_ENTRIES(pInput)) {
        NOTE("Too many colours in palette");
        return FALSE;
    }

    // The number of important colours shouldn't exceed the number used

    if (pInput->bmiHeader.biClrImportant > pInput->bmiHeader.biClrUsed) {
        NOTE("Too many important colours");
        return FALSE;
    }
    return TRUE;
}


// Return the format of the video display

const VIDEOINFO *CImageDisplay::GetDisplayFormat()
{
    return &m_Display;
}


// Return TRUE if the display uses a palette

BOOL CImageDisplay::IsPalettised()
{
    return PALETTISED(&m_Display);
}


// Return the bit depth of the current display setting

WORD CImageDisplay::GetDisplayDepth()
{
    return m_Display.bmiHeader.biBitCount;
}


// Initialise the optional fields in a VIDEOINFO. These are mainly to do with
// the source and destination rectangles and palette information such as the
// number of colours present. It simplifies our code just a little if we don't
// have to keep checking for all the different valid permutations in a header
// every time we want to do anything with it (an example would be creating a
// palette). We set the base class media type before calling this function so
// that the media types between the pins match after a connection is made

HRESULT CImageDisplay::UpdateFormat(VIDEOINFO *pVideoInfo)
{
    ASSERT(pVideoInfo);

    BITMAPINFOHEADER *pbmi = HEADER(pVideoInfo);
    SetRectEmpty(&pVideoInfo->rcSource);
    SetRectEmpty(&pVideoInfo->rcTarget);

    // Set the number of colours explicitly

    if (PALETTISED(pVideoInfo)) {
        if (pVideoInfo->bmiHeader.biClrUsed == 0) {
            pVideoInfo->bmiHeader.biClrUsed = PALETTE_ENTRIES(pVideoInfo);
        }
    }

    // The number of important colours shouldn't exceed the number used, on
    // some displays the number of important colours is not initialised when
    // retrieving the display type so we set the colours used correctly

    if (pVideoInfo->bmiHeader.biClrImportant > pVideoInfo->bmiHeader.biClrUsed) {
        pVideoInfo->bmiHeader.biClrImportant = PALETTE_ENTRIES(pVideoInfo);
    }

    // Change the image size field to be explicit

    if (pVideoInfo->bmiHeader.biSizeImage == 0) {
        pVideoInfo->bmiHeader.biSizeImage = GetBitmapSize(&pVideoInfo->bmiHeader);
    }
    return NOERROR;
}


// Lots of video rendering filters want code to check proposed formats are ok
// This checks the VIDEOINFO we are passed as a media type. If the media type
// is a valid media type then we return NOERROR otherwise E_INVALIDARG. Note
// however we only accept formats that can be easily displayed in the display
// so if we are on a 16 bit device we will not accept 24 bit images. The one
// complexity is that most displays draw 8 bit palettised images efficiently
// Also if the input format is less colour bits per pixel then we also accept

HRESULT CImageDisplay::CheckVideoType(const VIDEOINFO *pInput)
{
    // First of all check the VIDEOINFOHEADER looks correct

    if (CheckHeaderValidity(pInput) == FALSE) {
        return E_INVALIDARG;
    }

    // Virtually all devices support palettised images efficiently

    if (m_Display.bmiHeader.biBitCount == pInput->bmiHeader.biBitCount) {
        if (PALETTISED(pInput) == TRUE) {
            ASSERT(PALETTISED(&m_Display) == TRUE);
            NOTE("(Video) Type connection ACCEPTED");
            return NOERROR;
        }
    }


    // Is the display depth greater than the input format

    if (m_Display.bmiHeader.biBitCount > pInput->bmiHeader.biBitCount) {
        NOTE("(Video) Mismatch agreed");
        return NOERROR;
    }

    // Is the display depth less than the input format

    if (m_Display.bmiHeader.biBitCount < pInput->bmiHeader.biBitCount) {
        NOTE("(Video) Format mismatch");
        return E_INVALIDARG;
    }


    // Both input and display formats are either BI_RGB or BI_BITFIELDS

    ASSERT(m_Display.bmiHeader.biBitCount == pInput->bmiHeader.biBitCount);
    ASSERT(PALETTISED(pInput) == FALSE);
    ASSERT(PALETTISED(&m_Display) == FALSE);

    // BI_RGB 16 bit representation is implicitly RGB555, and likewise BI_RGB
    // 24 bit representation is RGB888. So we initialise a pointer to the bit
    // fields they really mean and check against the display device format
    // This is only going to be called when both formats are equal bits pixel

    const DWORD *pInputMask = GetBitMasks(pInput);
    const DWORD *pDisplayMask = GetBitMasks((VIDEOINFO *)&m_Display);

    if (pInputMask[iRED] != pDisplayMask[iRED] ||
            pInputMask[iGREEN] != pDisplayMask[iGREEN] ||
                pInputMask[iBLUE] != pDisplayMask[iBLUE]) {

        NOTE("(Video) Bit field mismatch");
        return E_INVALIDARG;
    }

    NOTE("(Video) Type connection ACCEPTED");
    return NOERROR;
}


// Return the bit masks for the true colour VIDEOINFO provided

const DWORD *CImageDisplay::GetBitMasks(const VIDEOINFO *pVideoInfo)
{
    static const DWORD FailMasks[] = {0,0,0};

    if (pVideoInfo->bmiHeader.biCompression == BI_BITFIELDS) {
        return BITMASKS(pVideoInfo);
    }

    ASSERT(pVideoInfo->bmiHeader.biCompression == BI_RGB);

    switch (pVideoInfo->bmiHeader.biBitCount) {
        case 16: return bits555;
        case 24: return bits888;
        case 32: return bits888;
        default: return FailMasks;
    }
}


// Check to see if we can support media type pmtIn as proposed by the output
// pin - We first check that the major media type is video and also identify
// the media sub type. Then we thoroughly check the VIDEOINFO type provided
// As well as the contained VIDEOINFO being correct the major type must be
// video, the subtype a recognised video format and the type GUID correct

HRESULT CImageDisplay::CheckMediaType(const CMediaType *pmtIn)
{
    // Does this have a VIDEOINFOHEADER format block

    const GUID *pFormatType = pmtIn->FormatType();
    if (*pFormatType != FORMAT_VideoInfo) {
        NOTE("Format GUID not a VIDEOINFOHEADER");
        return E_INVALIDARG;
    }
    ASSERT(pmtIn->Format());

    // Check the format looks reasonably ok

    ULONG Length = pmtIn->FormatLength();
    if (Length < SIZE_VIDEOHEADER) {
        NOTE("Format smaller than a VIDEOHEADER");
        return E_FAIL;
    }

    VIDEOINFO *pInput = (VIDEOINFO *) pmtIn->Format();

    // Check the major type is MEDIATYPE_Video

    const GUID *pMajorType = pmtIn->Type();
    if (*pMajorType != MEDIATYPE_Video) {
        NOTE("Major type not MEDIATYPE_Video");
        return E_INVALIDARG;
    }

    // Check we can identify the media subtype

    const GUID *pSubType = pmtIn->Subtype();
    if (GetBitCount(pSubType) == USHRT_MAX) {
        NOTE("Invalid video media subtype");
        return E_INVALIDARG;
    }
    return CheckVideoType(pInput);
}


// Given a video format described by a VIDEOINFO structure we return the mask
// that is used to obtain the range of acceptable colours for this type, for
// example, the mask for a 24 bit true colour format is 0xFF in all cases. A
// 16 bit 5:6:5 display format uses 0xF8, 0xFC and 0xF8, therefore given any
// RGB triplets we can AND them with these fields to find one that is valid

BOOL CImageDisplay::GetColourMask(DWORD *pMaskRed,
                                  DWORD *pMaskGreen,
                                  DWORD *pMaskBlue)
{
    CAutoLock cDisplayLock(this);
    *pMaskRed = 0xFF;
    *pMaskGreen = 0xFF;
    *pMaskBlue = 0xFF;

    // If this format is palettised then it doesn't have bit fields

    if (m_Display.bmiHeader.biBitCount < 16) {
        return FALSE;
    }

    // If this is a 24 bit true colour display then it can handle all the
    // possible colour component ranges described by a byte. It is never
    // allowed for a 24 bit colour depth image to have BI_BITFIELDS set

    if (m_Display.bmiHeader.biBitCount == 24) {
        ASSERT(m_Display.bmiHeader.biCompression == BI_RGB);
        return TRUE;
    }

    // Calculate the mask based on the format's bit fields

    const DWORD *pBitFields = (DWORD *) GetBitMasks((VIDEOINFO *)&m_Display);
    DWORD *pOutputMask[] = { pMaskRed, pMaskGreen, pMaskBlue };

    // We know from earlier testing that there are no more than iMAXBITS
    // bits set in the mask and that they are all contiguous. All that
    // therefore remains is to shift them into the correct position

    for (INT iColour = iRED;iColour <= iBLUE;iColour++) {

        // This works out how many bits there are and where they live

        DWORD PrefixBits = CountPrefixBits(pBitFields[iColour]);
        DWORD SetBits = CountSetBits(pBitFields[iColour]);

        // The first shift moves the bit field so that it is right justified
        // in the DWORD, after which we then shift it back left which then
        // puts the leading bit in the bytes most significant bit position

        *(pOutputMask[iColour]) = pBitFields[iColour] >> PrefixBits;
        *(pOutputMask[iColour]) <<= (iMAXBITS - SetBits);
    }
    return TRUE;
}


/*  Helper to convert to VIDEOINFOHEADER2
*/
STDAPI ConvertVideoInfoToVideoInfo2(AM_MEDIA_TYPE *pmt)
{
    ASSERT(pmt->formattype == FORMAT_VideoInfo);
    VIDEOINFO *pVideoInfo = (VIDEOINFO *)pmt->pbFormat;
    PVOID pvNew = CoTaskMemAlloc(pmt->cbFormat + sizeof(VIDEOINFOHEADER2) -
                                 sizeof(VIDEOINFOHEADER));
    if (pvNew == NULL) {
        return E_OUTOFMEMORY;
    }
    CopyMemory(pvNew, pmt->pbFormat, FIELD_OFFSET(VIDEOINFOHEADER, bmiHeader));
    ZeroMemory((PBYTE)pvNew + FIELD_OFFSET(VIDEOINFOHEADER, bmiHeader),
               sizeof(VIDEOINFOHEADER2) - sizeof(VIDEOINFOHEADER));
    CopyMemory((PBYTE)pvNew + FIELD_OFFSET(VIDEOINFOHEADER2, bmiHeader),
               pmt->pbFormat + FIELD_OFFSET(VIDEOINFOHEADER, bmiHeader),
               pmt->cbFormat - FIELD_OFFSET(VIDEOINFOHEADER, bmiHeader));
    VIDEOINFOHEADER2 *pVideoInfo2 = (VIDEOINFOHEADER2 *)pvNew;
    pVideoInfo2->dwPictAspectRatioX = (DWORD)pVideoInfo2->bmiHeader.biWidth;
    pVideoInfo2->dwPictAspectRatioY = (DWORD)pVideoInfo2->bmiHeader.biHeight;
    pmt->formattype = FORMAT_VideoInfo2;
    CoTaskMemFree(pmt->pbFormat);
    pmt->pbFormat = (PBYTE)pvNew;
    pmt->cbFormat += sizeof(VIDEOINFOHEADER2) - sizeof(VIDEOINFOHEADER);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\base\videoctl.h ===
//------------------------------------------------------------------------------
// File: VideoCtl.h
//
// Desc: DirectShow base classes.
//
// Copyright (c) 1992-2001 Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __VIDEOCTL__
#define __VIDEOCTL__

// These help with property page implementations. The first can be used to
// load any string from a resource file. The buffer to load into is passed
// as an input parameter. The same buffer is the return value if the string
// was found otherwise it returns TEXT(""). The GetDialogSize is passed the
// resource ID of a dialog box and returns the size of it in screen pixels

#define STR_MAX_LENGTH 256
TCHAR * WINAPI StringFromResource(TCHAR *pBuffer, int iResourceID);

#ifdef UNICODE
#define WideStringFromResource StringFromResource
char* WINAPI StringFromResource(char*pBuffer, int iResourceID);
#else
WCHAR * WINAPI WideStringFromResource(WCHAR *pBuffer, int iResourceID);
#endif


BOOL WINAPI GetDialogSize(int iResourceID,     // Dialog box resource identifier
                          DLGPROC pDlgProc,    // Pointer to dialog procedure
                          LPARAM lParam,       // Any user data wanted in pDlgProc
                          SIZE *pResult);      // Returns the size of dialog box

// Class that aggregates an IDirectDraw interface

class CAggDirectDraw : public IDirectDraw, public CUnknown
{
protected:

    LPDIRECTDRAW m_pDirectDraw;

public:

    DECLARE_IUNKNOWN
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv);

    // Constructor and destructor

    CAggDirectDraw(TCHAR *pName,LPUNKNOWN pUnk) :
        CUnknown(pName,pUnk),
        m_pDirectDraw(NULL) { };

    virtual CAggDirectDraw::~CAggDirectDraw() { };

    // Set the object we should be aggregating
    void SetDirectDraw(LPDIRECTDRAW pDirectDraw) {
        m_pDirectDraw = pDirectDraw;
    }

    // IDirectDraw methods

    STDMETHODIMP Compact();
    STDMETHODIMP CreateClipper(DWORD dwFlags,LPDIRECTDRAWCLIPPER *lplpDDClipper,IUnknown *pUnkOuter);
    STDMETHODIMP CreatePalette(DWORD dwFlags,LPPALETTEENTRY lpColorTable,LPDIRECTDRAWPALETTE *lplpDDPalette,IUnknown *pUnkOuter);
    STDMETHODIMP CreateSurface(LPDDSURFACEDESC lpDDSurfaceDesc,LPDIRECTDRAWSURFACE *lplpDDSurface,IUnknown *pUnkOuter);
    STDMETHODIMP DuplicateSurface(LPDIRECTDRAWSURFACE lpDDSurface,LPDIRECTDRAWSURFACE *lplpDupDDSurface);
    STDMETHODIMP EnumDisplayModes(DWORD dwSurfaceDescCount,LPDDSURFACEDESC lplpDDSurfaceDescList,LPVOID lpContext,LPDDENUMMODESCALLBACK lpEnumCallback);
    STDMETHODIMP EnumSurfaces(DWORD dwFlags,LPDDSURFACEDESC lpDDSD,LPVOID lpContext,LPDDENUMSURFACESCALLBACK lpEnumCallback);
    STDMETHODIMP FlipToGDISurface();
    STDMETHODIMP GetCaps(LPDDCAPS lpDDDriverCaps,LPDDCAPS lpDDHELCaps);
    STDMETHODIMP GetDisplayMode(LPDDSURFACEDESC lpDDSurfaceDesc);
    STDMETHODIMP GetFourCCCodes(LPDWORD lpNumCodes,LPDWORD lpCodes);
    STDMETHODIMP GetGDISurface(LPDIRECTDRAWSURFACE *lplpGDIDDSurface);
    STDMETHODIMP GetMonitorFrequency(LPDWORD lpdwFrequency);
    STDMETHODIMP GetScanLine(LPDWORD lpdwScanLine);
    STDMETHODIMP GetVerticalBlankStatus(LPBOOL lpblsInVB);
    STDMETHODIMP Initialize(GUID *lpGUID);
    STDMETHODIMP RestoreDisplayMode();
    STDMETHODIMP SetCooperativeLevel(HWND hWnd,DWORD dwFlags);
    STDMETHODIMP SetDisplayMode(DWORD dwWidth,DWORD dwHeight,DWORD dwBpp);
    STDMETHODIMP WaitForVerticalBlank(DWORD dwFlags,HANDLE hEvent);
};


// Class that aggregates an IDirectDrawSurface interface

class CAggDrawSurface : public IDirectDrawSurface, public CUnknown
{
protected:

    LPDIRECTDRAWSURFACE m_pDirectDrawSurface;

public:

    DECLARE_IUNKNOWN
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv);

    // Constructor and destructor

    CAggDrawSurface(TCHAR *pName,LPUNKNOWN pUnk) :
        CUnknown(pName,pUnk),
        m_pDirectDrawSurface(NULL) { };

    virtual ~CAggDrawSurface() { };

    // Set the object we should be aggregating
    void SetDirectDrawSurface(LPDIRECTDRAWSURFACE pDirectDrawSurface) {
        m_pDirectDrawSurface = pDirectDrawSurface;
    }

    // IDirectDrawSurface methods

    STDMETHODIMP AddAttachedSurface(LPDIRECTDRAWSURFACE lpDDSAttachedSurface);
    STDMETHODIMP AddOverlayDirtyRect(LPRECT lpRect);
    STDMETHODIMP Blt(LPRECT lpDestRect,LPDIRECTDRAWSURFACE lpDDSrcSurface,LPRECT lpSrcRect,DWORD dwFlags,LPDDBLTFX lpDDBltFx);
    STDMETHODIMP BltBatch(LPDDBLTBATCH lpDDBltBatch,DWORD dwCount,DWORD dwFlags);
    STDMETHODIMP BltFast(DWORD dwX,DWORD dwY,LPDIRECTDRAWSURFACE lpDDSrcSurface,LPRECT lpSrcRect,DWORD dwTrans);
    STDMETHODIMP DeleteAttachedSurface(DWORD dwFlags,LPDIRECTDRAWSURFACE lpDDSAttachedSurface);
    STDMETHODIMP EnumAttachedSurfaces(LPVOID lpContext,LPDDENUMSURFACESCALLBACK lpEnumSurfacesCallback);
    STDMETHODIMP EnumOverlayZOrders(DWORD dwFlags,LPVOID lpContext,LPDDENUMSURFACESCALLBACK lpfnCallback);
    STDMETHODIMP Flip(LPDIRECTDRAWSURFACE lpDDSurfaceTargetOverride,DWORD dwFlags);
    STDMETHODIMP GetAttachedSurface(LPDDSCAPS lpDDSCaps,LPDIRECTDRAWSURFACE *lplpDDAttachedSurface);
    STDMETHODIMP GetBltStatus(DWORD dwFlags);
    STDMETHODIMP GetCaps(LPDDSCAPS lpDDSCaps);
    STDMETHODIMP GetClipper(LPDIRECTDRAWCLIPPER *lplpDDClipper);
    STDMETHODIMP GetColorKey(DWORD dwFlags,LPDDCOLORKEY lpDDColorKey);
    STDMETHODIMP GetDC(HDC *lphDC);
    STDMETHODIMP GetFlipStatus(DWORD dwFlags);
    STDMETHODIMP GetOverlayPosition(LPLONG lpdwX,LPLONG lpdwY);
    STDMETHODIMP GetPalette(LPDIRECTDRAWPALETTE *lplpDDPalette);
    STDMETHODIMP GetPixelFormat(LPDDPIXELFORMAT lpDDPixelFormat);
    STDMETHODIMP GetSurfaceDesc(LPDDSURFACEDESC lpDDSurfaceDesc);
    STDMETHODIMP Initialize(LPDIRECTDRAW lpDD,LPDDSURFACEDESC lpDDSurfaceDesc);
    STDMETHODIMP IsLost();
    STDMETHODIMP Lock(LPRECT lpDestRect,LPDDSURFACEDESC lpDDSurfaceDesc,DWORD dwFlags,HANDLE hEvent);
    STDMETHODIMP ReleaseDC(HDC hDC);
    STDMETHODIMP Restore();
    STDMETHODIMP SetClipper(LPDIRECTDRAWCLIPPER lpDDClipper);
    STDMETHODIMP SetColorKey(DWORD dwFlags,LPDDCOLORKEY lpDDColorKey);
    STDMETHODIMP SetOverlayPosition(LONG dwX,LONG dwY);
    STDMETHODIMP SetPalette(LPDIRECTDRAWPALETTE lpDDPalette);
    STDMETHODIMP Unlock(LPVOID lpSurfaceData);
    STDMETHODIMP UpdateOverlay(LPRECT lpSrcRect,LPDIRECTDRAWSURFACE lpDDDestSurface,LPRECT lpDestRect,DWORD dwFlags,LPDDOVERLAYFX lpDDOverlayFX);
    STDMETHODIMP UpdateOverlayDisplay(DWORD dwFlags);
    STDMETHODIMP UpdateOverlayZOrder(DWORD dwFlags,LPDIRECTDRAWSURFACE lpDDSReference);
};


// DirectShow must work on multiple platforms.  In particular, it also runs on
// Windows NT 3.51 which does not have DirectDraw capabilities. The filters
// cannot therefore link statically to the DirectDraw library. To make their
// lives that little bit easier we provide this class that manages loading
// and unloading the library and creating the initial IDirectDraw interface

typedef DWORD (WINAPI *PGETFILEVERSIONINFOSIZE)(LPTSTR,LPDWORD);
typedef BOOL (WINAPI *PGETFILEVERSIONINFO)(LPTSTR,DWORD,DWORD,LPVOID);
typedef BOOL (WINAPI *PVERQUERYVALUE)(LPVOID,LPTSTR,LPVOID,PUINT);

class CLoadDirectDraw
{
    LPDIRECTDRAW m_pDirectDraw;     // The DirectDraw driver instance
    HINSTANCE m_hDirectDraw;        // Handle to the loaded library

public:

    CLoadDirectDraw();
    ~CLoadDirectDraw();

    HRESULT LoadDirectDraw(LPSTR szDevice);
    void ReleaseDirectDraw();
    HRESULT IsDirectDrawLoaded();
    LPDIRECTDRAW GetDirectDraw();
    BOOL IsDirectDrawVersion1();
};

#endif // __VIDEOCTL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\base\winutil.h ===
//------------------------------------------------------------------------------
// File: WinUtil.h
//
// Desc: DirectShow base classes - defines generic handler classes.
//
//@@BEGIN_MSINTERNAL
//
//       December 1995
//
//@@END_MSINTERNAL
// Copyright (c) 1992-2001 Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


// Make sure that you call PrepareWindow to initialise the window after
// the object has been constructed. It is a separate method so that
// derived classes can override useful methods like MessageLoop. Also
// any derived class must call DoneWithWindow in its destructor. If it
// doesn't a message may be retrieved and call a derived class member
// function while a thread is executing the base class destructor code

#ifndef __WINUTIL__
#define __WINUTIL__

const int DEFWIDTH = 320;                    // Initial window width
const int DEFHEIGHT = 240;                   // Initial window height
const int CAPTION = 256;                     // Maximum length of caption
const int TIMELENGTH = 50;                   // Maximum length of times
const int PROFILESTR = 128;                  // Normal profile string
const WORD PALVERSION = 0x300;               // GDI palette version
const LONG PALETTE_VERSION = (LONG) 1;       // Initial palette version
const COLORREF VIDEO_COLOUR = 0;             // Defaults to black background
const HANDLE hMEMORY = (HANDLE) (-1);        // Says to open as memory file

#define WIDTH(x) ((*(x)).right - (*(x)).left)
#define HEIGHT(x) ((*(x)).bottom - (*(x)).top)
#define SHOWSTAGE TEXT("WM_SHOWSTAGE")
#define SHOWSTAGETOP TEXT("WM_SHOWSTAGETOP")
#define REALIZEPALETTE TEXT("WM_REALIZEPALETTE")

class AM_NOVTABLE CBaseWindow
{
protected:

    HINSTANCE m_hInstance;          // Global module instance handle
    HWND m_hwnd;                    // Handle for our window
    HDC m_hdc;                      // Device context for the window
    LONG m_Width;                   // Client window width
    LONG m_Height;                  // Client window height
    BOOL m_bActivated;              // Has the window been activated
    LPTSTR m_pClassName;            // Static string holding class name
    DWORD m_ClassStyles;            // Passed in to our constructor
    DWORD m_WindowStyles;           // Likewise the initial window styles
    DWORD m_WindowStylesEx;         // And the extended window styles
    UINT m_ShowStageMessage;        // Have the window shown with focus
    UINT m_ShowStageTop;            // Makes the window WS_EX_TOPMOST
    UINT m_RealizePalette;          // Makes us realize our new palette
    HDC m_MemoryDC;                 // Used for fast BitBlt operations
    HPALETTE m_hPalette;            // Handle to any palette we may have
    BYTE m_bNoRealize;              // Don't realize palette now
    BYTE m_bBackground;             // Should we realise in background
    BYTE m_bRealizing;              // already realizing the palette
    CCritSec m_WindowLock;          // Serialise window object access
    BOOL m_bDoGetDC;                // Should this window get a DC
    bool m_bDoPostToDestroy;        // Use PostMessage to destroy
    CCritSec m_PaletteLock;         // This lock protects m_hPalette.
                                    // It should be held anytime the
                                    // program use the value of m_hPalette.

    // Maps windows message procedure into C++ methods
    friend LRESULT CALLBACK WndProc(HWND hwnd,      // Window handle
                                    UINT uMsg,      // Message ID
                                    WPARAM wParam,  // First parameter
                                    LPARAM lParam); // Other parameter

    virtual LRESULT OnPaletteChange(HWND hwnd, UINT Message);

public:

    CBaseWindow(BOOL bDoGetDC = TRUE, bool bPostToDestroy = false);

#ifdef DEBUG
    virtual ~CBaseWindow();
#endif

    virtual HRESULT DoneWithWindow();
    virtual HRESULT PrepareWindow();
    virtual HRESULT InactivateWindow();
    virtual HRESULT ActivateWindow();
    virtual BOOL OnSize(LONG Width, LONG Height);
    virtual BOOL OnClose();
    virtual RECT GetDefaultRect();
    virtual HRESULT UninitialiseWindow();
    virtual HRESULT InitialiseWindow(HWND hwnd);

    HRESULT CompleteConnect();
    HRESULT DoCreateWindow();

    HRESULT PerformanceAlignWindow();
    HRESULT DoShowWindow(LONG ShowCmd);
    void PaintWindow(BOOL bErase);
    void DoSetWindowForeground(BOOL bFocus);
    virtual HRESULT SetPalette(HPALETTE hPalette);
    void SetRealize(BOOL bRealize)
    {
        m_bNoRealize = !bRealize;
    }

    //  Jump over to the window thread to set the current palette
    HRESULT SetPalette();
    void UnsetPalette(void);
    virtual HRESULT DoRealisePalette(BOOL bForceBackground = FALSE);

    void LockPaletteLock();
    void UnlockPaletteLock();

    virtual BOOL PossiblyEatMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
	    { return FALSE; };

    // Access our window information

    bool WindowExists();
    LONG GetWindowWidth();
    LONG GetWindowHeight();
    HWND GetWindowHWND();
    HDC GetMemoryHDC();
    HDC GetWindowHDC();

    #ifdef DEBUG
    HPALETTE GetPalette();
    #endif // DEBUG

    // This is the window procedure the derived object should override

    virtual LRESULT OnReceiveMessage(HWND hwnd,          // Window handle
                                     UINT uMsg,          // Message ID
                                     WPARAM wParam,      // First parameter
                                     LPARAM lParam);     // Other parameter

    // Must be overriden to return class and window styles

    virtual LPTSTR GetClassWindowStyles(
                            DWORD *pClassStyles,          // Class styles
                            DWORD *pWindowStyles,         // Window styles
                            DWORD *pWindowStylesEx) PURE; // Extended styles
};


// This helper class is entirely subservient to the owning CBaseWindow object
// All this object does is to split out the actual drawing operation from the
// main object (because it was becoming too large). We have a number of entry
// points to set things like the draw device contexts, to implement the actual
// drawing and to set the destination rectangle in the client window. We have
// no critical section locking in this class because we are used exclusively
// by the owning window object which looks after serialising calls into us

// If you want to use this class make sure you call NotifyAllocator once the
// allocate has been agreed, also call NotifyMediaType with a pointer to a
// NON stack based CMediaType once that has been set (we keep a pointer to
// the original rather than taking a copy). When the palette changes call
// IncrementPaletteVersion (easiest thing to do is to also call this method
// in the SetMediaType method most filters implement). Finally before you
// start rendering anything call SetDrawContext so that we can get the HDCs
// for drawing from the CBaseWindow object we are given during construction

class CDrawImage
{
protected:

    CBaseWindow *m_pBaseWindow;     // Owning video window object
    CRefTime m_StartSample;         // Start time for the current sample
    CRefTime m_EndSample;           // And likewise it's end sample time
    HDC m_hdc;                      // Main window device context
    HDC m_MemoryDC;                 // Offscreen draw device context
    RECT m_TargetRect;              // Target destination rectangle
    RECT m_SourceRect;              // Source image rectangle
    BOOL m_bStretch;                // Do we have to stretch the images
    BOOL m_bUsingImageAllocator;    // Are the samples shared DIBSECTIONs
    CMediaType *m_pMediaType;       // Pointer to the current format
    int m_perfidRenderTime;         // Time taken to render an image
    LONG m_PaletteVersion;          // Current palette version cookie

    // Draw the video images in the window

    void SlowRender(IMediaSample *pMediaSample);
    void FastRender(IMediaSample *pMediaSample);
    void DisplaySampleTimes(IMediaSample *pSample);
    void UpdateColourTable(HDC hdc,BITMAPINFOHEADER *pbmi);
    void SetStretchMode();

public:

    // Used to control the image drawing

    CDrawImage(CBaseWindow *pBaseWindow);
    BOOL DrawImage(IMediaSample *pMediaSample);
    BOOL DrawVideoImageHere(HDC hdc, IMediaSample *pMediaSample,
                            LPRECT lprcSrc, LPRECT lprcDst);
    void SetDrawContext();
    void SetTargetRect(RECT *pTargetRect);
    void SetSourceRect(RECT *pSourceRect);
    void GetTargetRect(RECT *pTargetRect);
    void GetSourceRect(RECT *pSourceRect);
    virtual RECT ScaleSourceRect(const RECT *pSource);

    // Handle updating palettes as they change

    LONG GetPaletteVersion();
    void ResetPaletteVersion();
    void IncrementPaletteVersion();

    // Tell us media types and allocator assignments

    void NotifyAllocator(BOOL bUsingImageAllocator);
    void NotifyMediaType(CMediaType *pMediaType);
    BOOL UsingImageAllocator();

    // Called when we are about to draw an image

    void NotifyStartDraw() {
        MSR_START(m_perfidRenderTime);
    };

    // Called when we complete an image rendering

    void NotifyEndDraw() {
        MSR_STOP(m_perfidRenderTime);
    };
};


// This is the structure used to keep information about each GDI DIB. All the
// samples we create from our allocator will have a DIBSECTION allocated to
// them. When we receive the sample we know we can BitBlt straight to an HDC

typedef struct tagDIBDATA {

    LONG        PaletteVersion;     // Current palette version in use
    DIBSECTION  DibSection;         // Details of DIB section allocated
    HBITMAP     hBitmap;            // Handle to bitmap for drawing
    HANDLE      hMapping;           // Handle to shared memory block
    BYTE        *pBase;             // Pointer to base memory address

} DIBDATA;


// This class inherits from CMediaSample and uses all of it's methods but it
// overrides the constructor to initialise itself with the DIBDATA structure
// When we come to render an IMediaSample we will know if we are using our own
// allocator, and if we are, we can cast the IMediaSample to a pointer to one
// of these are retrieve the DIB section information and hence the HBITMAP

class CImageSample : public CMediaSample
{
protected:

    DIBDATA m_DibData;      // Information about the DIBSECTION
    BOOL m_bInit;           // Is the DIB information setup

public:

    // Constructor

    CImageSample(CBaseAllocator *pAllocator,
                 TCHAR *pName,
                 HRESULT *phr,
                 LPBYTE pBuffer,
                 LONG length);

    // Maintain the DIB/DirectDraw state

    void SetDIBData(DIBDATA *pDibData);
    DIBDATA *GetDIBData();
};


// This is an allocator based on the abstract CBaseAllocator base class that
// allocates sample buffers in shared memory. The number and size of these
// are determined when the output pin calls Prepare on us. The shared memory
// blocks are used in subsequent calls to GDI CreateDIBSection, once that
// has been done the output pin can fill the buffers with data which will
// then be handed to GDI through BitBlt calls and thereby remove one copy

class CImageAllocator : public CBaseAllocator
{
protected:

    CBaseFilter *m_pFilter;   // Delegate reference counts to
    CMediaType *m_pMediaType;           // Pointer to the current format

    // Used to create and delete samples

    HRESULT Alloc();
    void Free();

    // Manage the shared DIBSECTION and DCI/DirectDraw buffers

    HRESULT CreateDIB(LONG InSize,DIBDATA &DibData);
    STDMETHODIMP CheckSizes(ALLOCATOR_PROPERTIES *pRequest);
    virtual CImageSample *CreateImageSample(LPBYTE pData,LONG Length);

public:

    // Constructor and destructor

    CImageAllocator(CBaseFilter *pFilter,TCHAR *pName,HRESULT *phr);
#ifdef DEBUG
    ~CImageAllocator();
#endif

    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    STDMETHODIMP_(ULONG) NonDelegatingRelease();
    void NotifyMediaType(CMediaType *pMediaType);

    // Agree the number of buffers to be used and their size

    STDMETHODIMP SetProperties(
        ALLOCATOR_PROPERTIES *pRequest,
        ALLOCATOR_PROPERTIES *pActual);
};


// This class is a fairly specialised helper class for image renderers that
// have to create and manage palettes. The CBaseWindow class looks after
// realising palettes once they have been installed. This class can be used
// to create the palette handles from a media format (which must contain a
// VIDEOINFO structure in the format block). We try to make the palette an
// identity palette to maximise performance and also only change palettes
// if actually required to (we compare palette colours before updating).
// All the methods are virtual so that they can be overriden if so required

class CImagePalette
{
protected:

    CBaseWindow *m_pBaseWindow;             // Window to realise palette in
    CBaseFilter *m_pFilter;                 // Media filter to send events
    CDrawImage *m_pDrawImage;               // Object who will be drawing
    HPALETTE m_hPalette;                    // The palette handle we own

public:

    CImagePalette(CBaseFilter *pBaseFilter,
                  CBaseWindow *pBaseWindow,
                  CDrawImage *pDrawImage);

#ifdef DEBUG
    virtual ~CImagePalette();
#endif

    static HPALETTE MakePalette(const VIDEOINFOHEADER *pVideoInfo, LPSTR szDevice);
    HRESULT RemovePalette();
    static HRESULT MakeIdentityPalette(PALETTEENTRY *pEntry,INT iColours, LPSTR szDevice);
    HRESULT CopyPalette(const CMediaType *pSrc,CMediaType *pDest);
    BOOL ShouldUpdate(const VIDEOINFOHEADER *pNewInfo,const VIDEOINFOHEADER *pOldInfo);
    HRESULT PreparePalette(const CMediaType *pmtNew,const CMediaType *pmtOld,LPSTR szDevice);

    BOOL DrawVideoImageHere(HDC hdc, IMediaSample *pMediaSample, LPRECT lprcSrc, LPRECT lprcDst)
    {
        return m_pDrawImage->DrawVideoImageHere(hdc, pMediaSample, lprcSrc,lprcDst);
    }
};


// Another helper class really for video based renderers. Most such renderers
// need to know what the display format is to some degree or another. This
// class initialises itself with the display format. The format can be asked
// for through GetDisplayFormat and various other accessor functions. If a
// filter detects a display format change (perhaps it gets a WM_DEVMODECHANGE
// message then it can call RefreshDisplayType to reset that format). Also
// many video renderers will want to check formats as they are proposed by
// source filters. This class provides methods to check formats and only
// accept those video formats that can be efficiently drawn using GDI calls

class CImageDisplay : public CCritSec
{
protected:

    // This holds the display format; biSize should not be too big, so we can
    // safely use the VIDEOINFO structure
    VIDEOINFO m_Display;

    static DWORD CountSetBits(const DWORD Field);
    static DWORD CountPrefixBits(const DWORD Field);
    static BOOL CheckBitFields(const VIDEOINFO *pInput);

public:

    // Constructor and destructor

    CImageDisplay();

    // Used to manage BITMAPINFOHEADERs and the display format

    const VIDEOINFO *GetDisplayFormat();
    HRESULT RefreshDisplayType(LPSTR szDeviceName);
    static BOOL CheckHeaderValidity(const VIDEOINFO *pInput);
    static BOOL CheckPaletteHeader(const VIDEOINFO *pInput);
    BOOL IsPalettised();
    WORD GetDisplayDepth();

    // Provide simple video format type checking

    HRESULT CheckMediaType(const CMediaType *pmtIn);
    HRESULT CheckVideoType(const VIDEOINFO *pInput);
    HRESULT UpdateFormat(VIDEOINFO *pVideoInfo);
    const DWORD *GetBitMasks(const VIDEOINFO *pVideoInfo);

    BOOL GetColourMask(DWORD *pMaskRed,
                       DWORD *pMaskGreen,
                       DWORD *pMaskBlue);
};

//  Convert a FORMAT_VideoInfo to FORMAT_VideoInfo2
STDAPI ConvertVideoInfoToVideoInfo2(AM_MEDIA_TYPE *pmt);

#endif // __WINUTIL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\base\wxdebug.cpp ===
//------------------------------------------------------------------------------
// File: WXDebug.cpp
//
// Desc: DirectShow base classes - implements ActiveX system debugging
//       facilities.    
//
// Copyright (c) 1992-2001 Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#define _WINDLL

#include <streams.h>
#include <stdarg.h>
#include <stdio.h>

#ifdef DEBUG
#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE
#endif // _UNICODE
#endif // UNICODE
#endif // DEBUG

#include <tchar.h>

#ifdef DEBUG

// The Win32 wsprintf() function writes a maximum of 1024 characters to it's output buffer.
// See the documentation for wsprintf()'s lpOut parameter for more information.
const INT iDEBUGINFO = 1024;                 // Used to format strings

/* For every module and executable we store a debugging level for each of
   the five categories (eg LOG_ERROR and LOG_TIMING). This makes it easy
   to isolate and debug individual modules without seeing everybody elses
   spurious debug output. The keys are stored in the registry under the
   HKEY_LOCAL_MACHINE\SOFTWARE\Debug\<Module Name>\<KeyName> key values
   NOTE these must be in the same order as their enumeration definition */

TCHAR *pKeyNames[] = {
    TEXT("TIMING"),      // Timing and performance measurements
    TEXT("TRACE"),       // General step point call tracing
    TEXT("MEMORY"),      // Memory and object allocation/destruction
    TEXT("LOCKING"),     // Locking/unlocking of critical sections
    TEXT("ERROR"),       // Debug error notification
    TEXT("CUSTOM1"),
    TEXT("CUSTOM2"),
    TEXT("CUSTOM3"),
    TEXT("CUSTOM4"),
    TEXT("CUSTOM5")
    };

const TCHAR CAutoTrace::_szEntering[] = TEXT("Entering: %s");
const TCHAR CAutoTrace::_szLeaving[]  = TEXT("Leaving: %s");

const INT iMAXLEVELS = NUMELMS(pKeyNames);  // Maximum debug categories

HINSTANCE m_hInst;                          // Module instance handle
TCHAR m_ModuleName[iDEBUGINFO];             // Cut down module name
DWORD m_Levels[iMAXLEVELS];                 // Debug level per category
CRITICAL_SECTION m_CSDebug;                 // Controls access to list
DWORD m_dwNextCookie;                       // Next active object ID
ObjectDesc *pListHead = NULL;               // First active object
DWORD m_dwObjectCount;                      // Active object count
BOOL m_bInit = FALSE;                       // Have we been initialised
HANDLE m_hOutput = INVALID_HANDLE_VALUE;    // Optional output written here
DWORD dwWaitTimeout = INFINITE;             // Default timeout value
DWORD dwTimeOffset;			    // Time of first DbgLog call
bool g_fUseKASSERT = false;                 // don't create messagebox
bool g_fDbgInDllEntryPoint = false;
bool g_fAutoRefreshLevels = false;

const TCHAR *pBaseKey = TEXT("SOFTWARE\\Debug");
const TCHAR *pGlobalKey = TEXT("GLOBAL");
static CHAR *pUnknownName = "UNKNOWN";

TCHAR *TimeoutName = TEXT("TIMEOUT");

/* This sets the instance handle that the debug library uses to find
   the module's file name from the Win32 GetModuleFileName function */

void WINAPI DbgInitialise(HINSTANCE hInst)
{
    InitializeCriticalSection(&m_CSDebug);
    m_bInit = TRUE;

    m_hInst = hInst;
    DbgInitModuleName();
    if (GetProfileInt(m_ModuleName, TEXT("BreakOnLoad"), 0))
       DebugBreak();
    DbgInitModuleSettings(false);
    DbgInitGlobalSettings(true);
    dwTimeOffset = timeGetTime();
}


/* This is called to clear up any resources the debug library uses - at the
   moment we delete our critical section and the object list. The values we
   retrieve from the registry are all done during initialisation but we don't
   go looking for update notifications while we are running, if the values
   are changed then the application has to be restarted to pick them up */

void WINAPI DbgTerminate()
{
    if (m_hOutput != INVALID_HANDLE_VALUE) {
       EXECUTE_ASSERT(CloseHandle(m_hOutput));
       m_hOutput = INVALID_HANDLE_VALUE;
    }
    DeleteCriticalSection(&m_CSDebug);
    m_bInit = FALSE;
}


/* This is called by DbgInitLogLevels to read the debug settings
   for each logging category for this module from the registry */

void WINAPI DbgInitKeyLevels(HKEY hKey, bool fTakeMax)
{
    LONG lReturn;               // Create key return value
    LONG lKeyPos;               // Current key category
    DWORD dwKeySize;            // Size of the key value
    DWORD dwKeyType;            // Receives it's type
    DWORD dwKeyValue;           // This fields value

    /* Try and read a value for each key position in turn */
    for (lKeyPos = 0;lKeyPos < iMAXLEVELS;lKeyPos++) {

        dwKeySize = sizeof(DWORD);
        lReturn = RegQueryValueEx(
            hKey,                       // Handle to an open key
            pKeyNames[lKeyPos],         // Subkey name derivation
            NULL,                       // Reserved field
            &dwKeyType,                 // Returns the field type
            (LPBYTE) &dwKeyValue,       // Returns the field's value
            &dwKeySize );               // Number of bytes transferred

        /* If either the key was not available or it was not a DWORD value
           then we ensure only the high priority debug logging is output
           but we try and update the field to a zero filled DWORD value */

        if (lReturn != ERROR_SUCCESS || dwKeyType != REG_DWORD)  {

            dwKeyValue = 0;
            lReturn = RegSetValueEx(
                hKey,                   // Handle of an open key
                pKeyNames[lKeyPos],     // Address of subkey name
                (DWORD) 0,              // Reserved field
                REG_DWORD,              // Type of the key field
                (PBYTE) &dwKeyValue,    // Value for the field
                sizeof(DWORD));         // Size of the field buffer

            if (lReturn != ERROR_SUCCESS) {
                DbgLog((LOG_ERROR,0,TEXT("Could not create subkey %s"),pKeyNames[lKeyPos]));
                dwKeyValue = 0;
            }
        }
        if(fTakeMax)
        {
            m_Levels[lKeyPos] = max(dwKeyValue,m_Levels[lKeyPos]);
        }
        else
        {
            if((m_Levels[lKeyPos] & LOG_FORCIBLY_SET) == 0) {
                m_Levels[lKeyPos] = dwKeyValue;
            }
        }
    }

    /*  Read the timeout value for catching hangs */
    dwKeySize = sizeof(DWORD);
    lReturn = RegQueryValueEx(
        hKey,                       // Handle to an open key
        TimeoutName,                // Subkey name derivation
        NULL,                       // Reserved field
        &dwKeyType,                 // Returns the field type
        (LPBYTE) &dwWaitTimeout,    // Returns the field's value
        &dwKeySize );               // Number of bytes transferred

    /* If either the key was not available or it was not a DWORD value
       then we ensure only the high priority debug logging is output
       but we try and update the field to a zero filled DWORD value */

    if (lReturn != ERROR_SUCCESS || dwKeyType != REG_DWORD)  {

        dwWaitTimeout = INFINITE;
        lReturn = RegSetValueEx(
            hKey,                   // Handle of an open key
            TimeoutName,            // Address of subkey name
            (DWORD) 0,              // Reserved field
            REG_DWORD,              // Type of the key field
            (PBYTE) &dwWaitTimeout, // Value for the field
            sizeof(DWORD));         // Size of the field buffer

        if (lReturn != ERROR_SUCCESS) {
            DbgLog((LOG_ERROR,0,TEXT("Could not create subkey %s"),pKeyNames[lKeyPos]));
            dwWaitTimeout = INFINITE;
        }
    }
}

void WINAPI DbgOutString(LPCTSTR psz)
{
    if (m_hOutput != INVALID_HANDLE_VALUE) {
        UINT  cb = lstrlen(psz);
        DWORD dw;
#ifdef UNICODE
        CHAR szDest[2048];
        WideCharToMultiByte(CP_ACP, 0, psz, -1, szDest, NUMELMS(szDest), 0, 0);
        WriteFile (m_hOutput, szDest, cb, &dw, NULL);
#else
        WriteFile (m_hOutput, psz, cb, &dw, NULL);
#endif
    } else {
        OutputDebugString (psz);
    }
}

/* Called by DbgInitGlobalSettings to setup alternate logging destinations
 */

void WINAPI DbgInitLogTo (
    HKEY hKey)
{
    LONG  lReturn;
    DWORD dwKeyType;
    DWORD dwKeySize;
    TCHAR szFile[MAX_PATH] = {0};
    static const TCHAR cszKey[] = TEXT("LogToFile");

    dwKeySize = MAX_PATH;
    lReturn = RegQueryValueEx(
        hKey,                       // Handle to an open key
        cszKey,                     // Subkey name derivation
        NULL,                       // Reserved field
        &dwKeyType,                 // Returns the field type
        (LPBYTE) szFile,            // Returns the field's value
        &dwKeySize);                // Number of bytes transferred

    // create an empty key if it does not already exist
    //
    if (lReturn != ERROR_SUCCESS || dwKeyType != REG_SZ)
       {
       dwKeySize = sizeof(TCHAR);
       lReturn = RegSetValueEx(
            hKey,                   // Handle of an open key
            cszKey,                 // Address of subkey name
            (DWORD) 0,              // Reserved field
            REG_SZ,                 // Type of the key field
            (PBYTE)szFile,          // Value for the field
            dwKeySize);            // Size of the field buffer
       }

    // if an output-to was specified.  try to open it.
    //
    if (m_hOutput != INVALID_HANDLE_VALUE) {
       EXECUTE_ASSERT(CloseHandle (m_hOutput));
       m_hOutput = INVALID_HANDLE_VALUE;
    }
    if (szFile[0] != 0)
       {
       if (!lstrcmpi(szFile, TEXT("Console"))) {
          m_hOutput = GetStdHandle (STD_OUTPUT_HANDLE);
          if (m_hOutput == INVALID_HANDLE_VALUE) {
             AllocConsole ();
             m_hOutput = GetStdHandle (STD_OUTPUT_HANDLE);
          }
          SetConsoleTitle (TEXT("ActiveX Debug Output"));
       } else if (szFile[0] &&
                lstrcmpi(szFile, TEXT("Debug")) &&
                lstrcmpi(szFile, TEXT("Debugger")) &&
                lstrcmpi(szFile, TEXT("Deb")))
          {
            m_hOutput = CreateFile(szFile, GENERIC_WRITE,
                                 FILE_SHARE_READ,
                                 NULL, OPEN_ALWAYS,
                                 FILE_ATTRIBUTE_NORMAL,
                                 NULL);
          if (INVALID_HANDLE_VALUE != m_hOutput)
              {
              static const TCHAR cszBar[] = TEXT("\r\n\r\n=====DbgInitialize()=====\r\n\r\n");
              SetFilePointer (m_hOutput, 0, NULL, FILE_END);
              DbgOutString (cszBar);
              }
          }
       }
}



/* This is called by DbgInitLogLevels to read the global debug settings for
   each logging category for this module from the registry. Normally each
   module has it's own values set for it's different debug categories but
   setting the global SOFTWARE\Debug\Global applies them to ALL modules */

void WINAPI DbgInitGlobalSettings(bool fTakeMax)
{
    LONG lReturn;               // Create key return value
    TCHAR szInfo[iDEBUGINFO];   // Constructs key names
    HKEY hGlobalKey;            // Global override key

    /* Construct the global base key name */
    wsprintf(szInfo,TEXT("%s\\%s"),pBaseKey,pGlobalKey);

    /* Create or open the key for this module */
    lReturn = RegCreateKeyEx(HKEY_LOCAL_MACHINE,   // Handle of an open key
                             szInfo,               // Address of subkey name
                             (DWORD) 0,            // Reserved value
                             NULL,                 // Address of class name
                             (DWORD) 0,            // Special options flags
                             KEY_ALL_ACCESS,       // Desired security access
                             NULL,                 // Key security descriptor
                             &hGlobalKey,          // Opened handle buffer
                             NULL);                // What really happened

    if (lReturn != ERROR_SUCCESS) {
        DbgLog((LOG_ERROR,0,TEXT("Could not access GLOBAL module key")));
        return;
    }

    DbgInitKeyLevels(hGlobalKey, fTakeMax);
    RegCloseKey(hGlobalKey);
}


/* This sets the debugging log levels for the different categories. We start
   by opening (or creating if not already available) the SOFTWARE\Debug key
   that all these settings live under. We then look at the global values
   set under SOFTWARE\Debug\Global which apply on top of the individual
   module settings. We then load the individual module registry settings */

void WINAPI DbgInitModuleSettings(bool fTakeMax)
{
    LONG lReturn;               // Create key return value
    TCHAR szInfo[iDEBUGINFO];   // Constructs key names
    HKEY hModuleKey;            // Module key handle

    /* Construct the base key name */
    wsprintf(szInfo,TEXT("%s\\%s"),pBaseKey,m_ModuleName);

    /* Create or open the key for this module */
    lReturn = RegCreateKeyEx(HKEY_LOCAL_MACHINE,   // Handle of an open key
                             szInfo,               // Address of subkey name
                             (DWORD) 0,            // Reserved value
                             NULL,                 // Address of class name
                             (DWORD) 0,            // Special options flags
                             KEY_ALL_ACCESS,       // Desired security access
                             NULL,                 // Key security descriptor
                             &hModuleKey,          // Opened handle buffer
                             NULL);                // What really happened

    if (lReturn != ERROR_SUCCESS) {
        DbgLog((LOG_ERROR,0,TEXT("Could not access module key")));
        return;
    }

    DbgInitLogTo(hModuleKey);
    DbgInitKeyLevels(hModuleKey, fTakeMax);
    RegCloseKey(hModuleKey);
}


/* Initialise the module file name */

void WINAPI DbgInitModuleName()
{
    TCHAR FullName[iDEBUGINFO];     // Load the full path and module name
    TCHAR *pName;                   // Searches from the end for a backslash

    GetModuleFileName(m_hInst,FullName,iDEBUGINFO);
    pName = _tcsrchr(FullName,'\\');
    if (pName == NULL) {
        pName = FullName;
    } else {
        pName++;
    }
    lstrcpy(m_ModuleName,pName);
}

struct MsgBoxMsg
{
    HWND hwnd;
    TCHAR *szTitle;
    TCHAR *szMessage;
    DWORD dwFlags;
    INT iResult;
};

//
// create a thread to call MessageBox(). calling MessageBox() on
// random threads at bad times can confuse the host (eg IE).
//
DWORD WINAPI MsgBoxThread(
  LPVOID lpParameter   // thread data
  )
{
    MsgBoxMsg *pmsg = (MsgBoxMsg *)lpParameter;
    pmsg->iResult = MessageBox(
        pmsg->hwnd,
        pmsg->szTitle,
        pmsg->szMessage,
        pmsg->dwFlags);
    
    return 0;
}

INT MessageBoxOtherThread(
    HWND hwnd,
    TCHAR *szTitle,
    TCHAR *szMessage,
    DWORD dwFlags)
{
    if(g_fDbgInDllEntryPoint)
    {
        // can't wait on another thread because we have the loader
        // lock held in the dll entry point.
        return MessageBox(hwnd, szTitle, szMessage, dwFlags);
    }
    else
    {
        MsgBoxMsg msg = {hwnd, szTitle, szMessage, dwFlags, 0};
        DWORD dwid;
        HANDLE hThread = CreateThread(
            0,                      // security
            0,                      // stack size
            MsgBoxThread,
            (void *)&msg,           // arg
            0,                      // flags
            &dwid);
        if(hThread)
        {
            WaitForSingleObject(hThread, INFINITE);
            CloseHandle(hThread);
            return msg.iResult;
        }

        // break into debugger on failure.
        return IDCANCEL;
    }
}

/* Displays a message box if the condition evaluated to FALSE */

void WINAPI DbgAssert(const TCHAR *pCondition,const TCHAR *pFileName,INT iLine)
{
    if(g_fUseKASSERT)
    {
        DbgKernelAssert(pCondition, pFileName, iLine);
    }
    else
    {

        TCHAR szInfo[iDEBUGINFO];

        wsprintf(szInfo, TEXT("%s \nAt line %d of %s\nContinue? (Cancel to debug)"),
                 pCondition, iLine, pFileName);

        INT MsgId = MessageBoxOtherThread(NULL,szInfo,TEXT("ASSERT Failed"),
                                          MB_SYSTEMMODAL |
                                          MB_ICONHAND |
                                          MB_YESNOCANCEL |
                                          MB_SETFOREGROUND);
        switch (MsgId)
        {
          case IDNO:              /* Kill the application */

              FatalAppExit(FALSE, TEXT("Application terminated"));
              break;

          case IDCANCEL:          /* Break into the debugger */

              DebugBreak();
              break;

          case IDYES:             /* Ignore assertion continue execution */
              break;
        }
    }
}

/* Displays a message box at a break point */

void WINAPI DbgBreakPoint(const TCHAR *pCondition,const TCHAR *pFileName,INT iLine)
{
    if(g_fUseKASSERT)
    {
        DbgKernelAssert(pCondition, pFileName, iLine);
    }
    else
    {
        TCHAR szInfo[iDEBUGINFO];

        wsprintf(szInfo, TEXT("%s \nAt line %d of %s\nContinue? (Cancel to debug)"),
                 pCondition, iLine, pFileName);

        INT MsgId = MessageBoxOtherThread(NULL,szInfo,TEXT("Hard coded break point"),
                                          MB_SYSTEMMODAL |
                                          MB_ICONHAND |
                                          MB_YESNOCANCEL |
                                          MB_SETFOREGROUND);
        switch (MsgId)
        {
          case IDNO:              /* Kill the application */

              FatalAppExit(FALSE, TEXT("Application terminated"));
              break;

          case IDCANCEL:          /* Break into the debugger */

              DebugBreak();
              break;

          case IDYES:             /* Ignore break point continue execution */
              break;
        }
    }
}

void WINAPI DbgBreakPoint(const TCHAR *pFileName,INT iLine,const TCHAR* szFormatString,...)
{
    // A debug break point message can have at most 2000 characters if 
    // ANSI or UNICODE characters are being used.  A debug break point message
    // can have between 1000 and 2000 double byte characters in it.  If a 
    // particular message needs more characters, then the value of this constant
    // should be increased.
    const DWORD MAX_BREAK_POINT_MESSAGE_SIZE = 2000;

    TCHAR szBreakPointMessage[MAX_BREAK_POINT_MESSAGE_SIZE];
    
    const DWORD MAX_CHARS_IN_BREAK_POINT_MESSAGE = sizeof(szBreakPointMessage) / sizeof(TCHAR);

    va_list va;
    va_start( va, szFormatString );

    int nReturnValue = _vsntprintf( szBreakPointMessage, MAX_CHARS_IN_BREAK_POINT_MESSAGE, szFormatString, va );

    va_end(va);
    
    // _vsnprintf() returns -1 if an error occurs.
    if( -1 == nReturnValue ) {
        DbgBreak( "ERROR in DbgBreakPoint().  The variable length debug message could not be displayed because _vsnprintf() failed." );
        return;
    }

    ::DbgBreakPoint( szBreakPointMessage, pFileName, iLine );
}


/* When we initialised the library we stored in the m_Levels array the current
   debug output level for this module for each of the five categories. When
   some debug logging is sent to us it can be sent with a combination of the
   categories (if it is applicable to many for example) in which case we map
   the type's categories into their current debug levels and see if any of
   them can be accepted. The function looks at each bit position in turn from
   the input type field and then compares it's debug level with the modules.

   A level of 0 means that output is always sent to the debugger.  This is
   due to producing output if the input level is <= m_Levels.
*/


BOOL WINAPI DbgCheckModuleLevel(DWORD Type,DWORD Level)
{
    if(g_fAutoRefreshLevels)
    {
        // re-read the registry every second. We cannot use RegNotify() to
        // notice registry changes because it's not available on win9x.
        static g_dwLastRefresh = 0;
        DWORD dwTime = timeGetTime();
        if(dwTime - g_dwLastRefresh > 1000) {
            g_dwLastRefresh = dwTime;

            // there's a race condition: multiple threads could update the
            // values. plus read and write not synchronized. no harm
            // though.
            DbgInitModuleSettings(false);
        }
    }


    DWORD Mask = 0x01;

    // If no valid bits are set return FALSE
    if ((Type & ((1<<iMAXLEVELS)-1))) {

	// speed up unconditional output.
	if (0==Level)
	    return(TRUE);
	
        for (LONG lKeyPos = 0;lKeyPos < iMAXLEVELS;lKeyPos++) {
            if (Type & Mask) {
                if (Level <= (m_Levels[lKeyPos] & ~LOG_FORCIBLY_SET)) {
                    return TRUE;
                }
            }
            Mask <<= 1;
        }
    }
    return FALSE;
}


/* Set debug levels to a given value */

void WINAPI DbgSetModuleLevel(DWORD Type, DWORD Level)
{
    DWORD Mask = 0x01;

    for (LONG lKeyPos = 0;lKeyPos < iMAXLEVELS;lKeyPos++) {
        if (Type & Mask) {
            m_Levels[lKeyPos] = Level | LOG_FORCIBLY_SET;
        }
        Mask <<= 1;
    }
}

/* whether to check registry values periodically. this isn't turned
   automatically because of the potential performance hit. */
void WINAPI DbgSetAutoRefreshLevels(bool fAuto)
{
    g_fAutoRefreshLevels = fAuto;
}

#ifdef UNICODE
// 
// warning -- this function is implemented twice for ansi applications
// linking to the unicode library
// 
void WINAPI DbgLogInfo(DWORD Type,DWORD Level,const CHAR *pFormat,...)
{
    /* Check the current level for this type combination */

    BOOL bAccept = DbgCheckModuleLevel(Type,Level);
    if (bAccept == FALSE) {
        return;
    }

    TCHAR szInfo[2000];

    /* Format the variable length parameter list */

    va_list va;
    va_start(va, pFormat);

    lstrcpy(szInfo,m_ModuleName);
    wsprintf(szInfo + lstrlen(szInfo),
             TEXT("(tid %x) %8d : "),
             GetCurrentThreadId(), timeGetTime() - dwTimeOffset);

    CHAR szInfoA[2000];
    WideCharToMultiByte(CP_ACP, 0, szInfo, -1, szInfoA, NUMELMS(szInfoA), 0, 0);

    wvsprintfA(szInfoA + lstrlenA(szInfoA), pFormat, va);
    lstrcatA(szInfoA, "\r\n");

    WCHAR wszOutString[2000];
    MultiByteToWideChar(CP_ACP, 0, szInfoA, -1, wszOutString, NUMELMS(wszOutString));
    DbgOutString(wszOutString);

    va_end(va);
}

void DbgAssert(const CHAR *pCondition,const CHAR *pFileName,INT iLine)
{
    if(g_fUseKASSERT)
    {
        DbgKernelAssert(pCondition, pFileName, iLine);
    }
    else
    {

        TCHAR szInfo[iDEBUGINFO];

        wsprintf(szInfo, TEXT("%hs \nAt line %d of %hs\nContinue? (Cancel to debug)"),
                 pCondition, iLine, pFileName);

        INT MsgId = MessageBoxOtherThread(NULL,szInfo,TEXT("ASSERT Failed"),
                                          MB_SYSTEMMODAL |
                                          MB_ICONHAND |
                                          MB_YESNOCANCEL |
                                          MB_SETFOREGROUND);
        switch (MsgId)
        {
          case IDNO:              /* Kill the application */

              FatalAppExit(FALSE, TEXT("Application terminated"));
              break;

          case IDCANCEL:          /* Break into the debugger */

              DebugBreak();
              break;

          case IDYES:             /* Ignore assertion continue execution */
              break;
        }
    }
}

/* Displays a message box at a break point */

void WINAPI DbgBreakPoint(const CHAR *pCondition,const CHAR *pFileName,INT iLine)
{
    if(g_fUseKASSERT)
    {
        DbgKernelAssert(pCondition, pFileName, iLine);
    }
    else
    {
        TCHAR szInfo[iDEBUGINFO];

        wsprintf(szInfo, TEXT("%hs \nAt line %d of %hs\nContinue? (Cancel to debug)"),
                 pCondition, iLine, pFileName);

        INT MsgId = MessageBoxOtherThread(NULL,szInfo,TEXT("Hard coded break point"),
                                          MB_SYSTEMMODAL |
                                          MB_ICONHAND |
                                          MB_YESNOCANCEL |
                                          MB_SETFOREGROUND);
        switch (MsgId)
        {
          case IDNO:              /* Kill the application */

              FatalAppExit(FALSE, TEXT("Application terminated"));
              break;

          case IDCANCEL:          /* Break into the debugger */

              DebugBreak();
              break;

          case IDYES:             /* Ignore break point continue execution */
              break;
        }
    }
}

void WINAPI DbgKernelAssert(const CHAR *pCondition,const CHAR *pFileName,INT iLine)
{
    DbgLog((LOG_ERROR,0,TEXT("Assertion FAILED (%hs) at line %d in file %hs"),
           pCondition, iLine, pFileName));
    DebugBreak();
}

#endif

/* Print a formatted string to the debugger prefixed with this module's name
   Because the COMBASE classes are linked statically every module loaded will
   have their own copy of this code. It therefore helps if the module name is
   included on the output so that the offending code can be easily found */

// 
// warning -- this function is implemented twice for ansi applications
// linking to the unicode library
// 
void WINAPI DbgLogInfo(DWORD Type,DWORD Level,const TCHAR *pFormat,...)
{
    
    /* Check the current level for this type combination */

    BOOL bAccept = DbgCheckModuleLevel(Type,Level);
    if (bAccept == FALSE) {
        return;
    }

    TCHAR szInfo[2000];

    /* Format the variable length parameter list */

    va_list va;
    va_start(va, pFormat);

    lstrcpy(szInfo,m_ModuleName);
    wsprintf(szInfo + lstrlen(szInfo),
             TEXT("(tid %x) %8d : "),
             GetCurrentThreadId(), timeGetTime() - dwTimeOffset);

    _vstprintf(szInfo + lstrlen(szInfo), pFormat, va);
    lstrcat(szInfo, TEXT("\r\n"));
    DbgOutString(szInfo);

    va_end(va);
}


/* If we are executing as a pure kernel filter we cannot display message
   boxes to the user, this provides an alternative which puts the error
   condition on the debugger output with a suitable eye catching message */

void WINAPI DbgKernelAssert(const TCHAR *pCondition,const TCHAR *pFileName,INT iLine)
{
    DbgLog((LOG_ERROR,0,TEXT("Assertion FAILED (%s) at line %d in file %s"),
           pCondition, iLine, pFileName));
    DebugBreak();
}



/* Each time we create an object derived from CBaseObject the constructor will
   call us to register the creation of the new object. We are passed a string
   description which we store away. We return a cookie that the constructor
   uses to identify the object when it is destroyed later on. We update the
   total number of active objects in the DLL mainly for debugging purposes */

DWORD WINAPI DbgRegisterObjectCreation(const CHAR *szObjectName,
                                       const WCHAR *wszObjectName)
{
    /* If this fires you have a mixed DEBUG/RETAIL build */

    ASSERT(!!szObjectName ^ !!wszObjectName);

    /* Create a place holder for this object description */

    ObjectDesc *pObject = new ObjectDesc;
    ASSERT(pObject);

    /* It is valid to pass a NULL object name */
    if (pObject == NULL) {
        return FALSE;
    }

    /* Check we have been initialised - we may not be initialised when we are
       being pulled in from an executable which has globally defined objects
       as they are created by the C++ run time before WinMain is called */

    if (m_bInit == FALSE) {
        DbgInitialise(GetModuleHandle(NULL));
    }

    /* Grab the list critical section */
    EnterCriticalSection(&m_CSDebug);

    /* If no name then default to UNKNOWN */
    if (!szObjectName && !wszObjectName) {
        szObjectName = pUnknownName;
    }

    /* Put the new description at the head of the list */

    pObject->m_szName = szObjectName;
    pObject->m_wszName = wszObjectName;
    pObject->m_dwCookie = ++m_dwNextCookie;
    pObject->m_pNext = pListHead;

    pListHead = pObject;
    m_dwObjectCount++;

    DWORD ObjectCookie = pObject->m_dwCookie;
    ASSERT(ObjectCookie);

    if(wszObjectName) {
        DbgLog((LOG_MEMORY,2,TEXT("Object created   %d (%ls) %d Active"),
                pObject->m_dwCookie, wszObjectName, m_dwObjectCount));
    } else {
        DbgLog((LOG_MEMORY,2,TEXT("Object created   %d (%hs) %d Active"),
                pObject->m_dwCookie, szObjectName, m_dwObjectCount));
    }

    LeaveCriticalSection(&m_CSDebug);
    return ObjectCookie;
}


/* This is called by the CBaseObject destructor when an object is about to be
   destroyed, we are passed the cookie we returned during construction that
   identifies this object. We scan the object list for a matching cookie and
   remove the object if successful. We also update the active object count */

BOOL WINAPI DbgRegisterObjectDestruction(DWORD dwCookie)
{
    /* Grab the list critical section */
    EnterCriticalSection(&m_CSDebug);

    ObjectDesc *pObject = pListHead;
    ObjectDesc *pPrevious = NULL;

    /* Scan the object list looking for a cookie match */

    while (pObject) {
        if (pObject->m_dwCookie == dwCookie) {
            break;
        }
        pPrevious = pObject;
        pObject = pObject->m_pNext;
    }

    if (pObject == NULL) {
        DbgBreak("Apparently destroying a bogus object");
        LeaveCriticalSection(&m_CSDebug);
        return FALSE;
    }

    /* Is the object at the head of the list */

    if (pPrevious == NULL) {
        pListHead = pObject->m_pNext;
    } else {
        pPrevious->m_pNext = pObject->m_pNext;
    }

    /* Delete the object and update the housekeeping information */

    m_dwObjectCount--;

    if(pObject->m_wszName) {
        DbgLog((LOG_MEMORY,2,TEXT("Object destroyed %d (%ls) %d Active"),
                pObject->m_dwCookie, pObject->m_wszName, m_dwObjectCount));
    } else {
        DbgLog((LOG_MEMORY,2,TEXT("Object destroyed %d (%hs) %d Active"),
                pObject->m_dwCookie, pObject->m_szName, m_dwObjectCount));
    }

    delete pObject;
    LeaveCriticalSection(&m_CSDebug);
    return TRUE;
}


/* This runs through the active object list displaying their details */

void WINAPI DbgDumpObjectRegister()
{
    TCHAR szInfo[iDEBUGINFO];

    /* Grab the list critical section */

    EnterCriticalSection(&m_CSDebug);
    ObjectDesc *pObject = pListHead;

    /* Scan the object list displaying the name and cookie */

    DbgLog((LOG_MEMORY,2,TEXT("")));
    DbgLog((LOG_MEMORY,2,TEXT("   ID             Object Description")));
    DbgLog((LOG_MEMORY,2,TEXT("")));

    while (pObject) {
        if(pObject->m_wszName) {
            wsprintf(szInfo,TEXT("%5d (%8x) %30ls"),pObject->m_dwCookie, &pObject, pObject->m_wszName);
        } else {
            wsprintf(szInfo,TEXT("%5d (%8x) %30hs"),pObject->m_dwCookie, &pObject, pObject->m_szName);
        }
        DbgLog((LOG_MEMORY,2,szInfo));
        pObject = pObject->m_pNext;
    }

    wsprintf(szInfo,TEXT("Total object count %5d"),m_dwObjectCount);
    DbgLog((LOG_MEMORY,2,TEXT("")));
    DbgLog((LOG_MEMORY,1,szInfo));
    LeaveCriticalSection(&m_CSDebug);
}

/*  Debug infinite wait stuff */
DWORD WINAPI DbgWaitForSingleObject(HANDLE h)
{
    DWORD dwWaitResult;
    do {
        dwWaitResult = WaitForSingleObject(h, dwWaitTimeout);
        ASSERT(dwWaitResult == WAIT_OBJECT_0);
    } while (dwWaitResult == WAIT_TIMEOUT);
    return dwWaitResult;
}
DWORD WINAPI DbgWaitForMultipleObjects(DWORD nCount,
                                CONST HANDLE *lpHandles,
                                BOOL bWaitAll)
{
    DWORD dwWaitResult;
    do {
        dwWaitResult = WaitForMultipleObjects(nCount,
                                              lpHandles,
                                              bWaitAll,
                                              dwWaitTimeout);
        ASSERT((DWORD)(dwWaitResult - WAIT_OBJECT_0) < MAXIMUM_WAIT_OBJECTS);
    } while (dwWaitResult == WAIT_TIMEOUT);
    return dwWaitResult;
}

void WINAPI DbgSetWaitTimeout(DWORD dwTimeout)
{
    dwWaitTimeout = dwTimeout;
}

#endif /* DEBUG */

#ifdef _OBJBASE_H_

    /*  Stuff for printing out our GUID names */

    GUID_STRING_ENTRY g_GuidNames[] = {
    #define OUR_GUID_ENTRY(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    { #name, { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } } },
        #include <uuids.h>
    };

    CGuidNameList GuidNames;
    int g_cGuidNames = sizeof(g_GuidNames) / sizeof(g_GuidNames[0]);

    char *CGuidNameList::operator [] (const GUID &guid)
    {
        for (int i = 0; i < g_cGuidNames; i++) {
            if (g_GuidNames[i].guid == guid) {
                return g_GuidNames[i].szName;
            }
        }
        if (guid == GUID_NULL) {
            return "GUID_NULL";
        }

	// !!! add something to print FOURCC guids?
	
	// shouldn't this print the hex CLSID?
        return "Unknown GUID Name";
    }

#endif /* _OBJBASE_H_ */

/*  CDisp class - display our data types */

// clashes with REFERENCE_TIME
CDisp::CDisp(LONGLONG ll, int Format)
{
    // note: this could be combined with CDisp(LONGLONG) by
    // introducing a default format of CDISP_REFTIME
    LARGE_INTEGER li;
    li.QuadPart = ll;
    switch (Format) {
	case CDISP_DEC:
	{
	    TCHAR  temp[20];
	    int pos=20;
	    temp[--pos] = 0;
	    int digit;
	    // always output at least one digit
	    do {
		// Get the rightmost digit - we only need the low word
	        digit = li.LowPart % 10;
		li.QuadPart /= 10;
		temp[--pos] = (TCHAR) digit+L'0';
	    } while (li.QuadPart);
	    wsprintf(m_String, TEXT("%s"), temp+pos);
	    break;
	}
	case CDISP_HEX:
	default:
	    wsprintf(m_String, TEXT("0x%X%8.8X"), li.HighPart, li.LowPart);
    }
};

CDisp::CDisp(REFCLSID clsid)
{
    WCHAR strClass[CHARS_IN_GUID+1];
    StringFromGUID2(clsid, strClass, sizeof(strClass) / sizeof(strClass[0]));
    ASSERT(sizeof(m_String)/sizeof(m_String[0]) >= CHARS_IN_GUID+1);
    wsprintf(m_String, TEXT("%ls"), strClass);
};

#ifdef __STREAMS__
/*  Display stuff */
CDisp::CDisp(CRefTime llTime)
{
    LPTSTR lpsz = m_String;
    LONGLONG llDiv;
    if (llTime < 0) {
        llTime = -llTime;
        lpsz += wsprintf(lpsz, TEXT("-"));
    }
    llDiv = (LONGLONG)24 * 3600 * 10000000;
    if (llTime >= llDiv) {
        lpsz += wsprintf(lpsz, TEXT("%d days "), (LONG)(llTime / llDiv));
        llTime = llTime % llDiv;
    }
    llDiv = (LONGLONG)3600 * 10000000;
    if (llTime >= llDiv) {
        lpsz += wsprintf(lpsz, TEXT("%d hrs "), (LONG)(llTime / llDiv));
        llTime = llTime % llDiv;
    }
    llDiv = (LONGLONG)60 * 10000000;
    if (llTime >= llDiv) {
        lpsz += wsprintf(lpsz, TEXT("%d mins "), (LONG)(llTime / llDiv));
        llTime = llTime % llDiv;
    }
    wsprintf(lpsz, TEXT("%d.%3.3d sec"),
             (LONG)llTime / 10000000,
             (LONG)((llTime % 10000000) / 10000));
};

#endif // __STREAMS__


/*  Display pin */
CDisp::CDisp(IPin *pPin)
{
    PIN_INFO pi;
    TCHAR str[MAX_PIN_NAME];
    CLSID clsid;

    if (pPin) {
       pPin->QueryPinInfo(&pi);
       pi.pFilter->GetClassID(&clsid);
       QueryPinInfoReleaseFilter(pi);
      #ifndef UNICODE
       WideCharToMultiByte(GetACP(), 0, pi.achName, lstrlenW(pi.achName) + 1,
                           str, MAX_PIN_NAME, NULL, NULL);
      #else
       lstrcpy(str, pi.achName);
      #endif
    } else {
       lstrcpy(str, TEXT("NULL IPin"));
    }

    m_pString = (PTCHAR) new TCHAR[lstrlen(str)+64];
    if (!m_pString) {
	return;
    }

    wsprintf(m_pString, TEXT("%hs(%s)"), GuidNames[clsid], str);
}

/*  Display filter or pin */
CDisp::CDisp(IUnknown *pUnk)
{
    IBaseFilter *pf;
    HRESULT hr = pUnk->QueryInterface(IID_IBaseFilter, (void **)&pf);
    if(SUCCEEDED(hr))
    {
        FILTER_INFO fi;
        hr = pf->QueryFilterInfo(&fi);
        if(SUCCEEDED(hr))
        {
            QueryFilterInfoReleaseGraph(fi);

            m_pString = new TCHAR[lstrlenW(fi.achName)  + 1];
            if(m_pString)
            {
                wsprintf(m_pString, TEXT("%ls"), fi.achName);
            }
        }

        pf->Release();

        return;
    }

    IPin *pp;
    hr = pUnk->QueryInterface(IID_IPin, (void **)&pp);
    if(SUCCEEDED(hr))
    {
        CDisp::CDisp(pp);
        pp->Release();
        return;
    }
}


CDisp::~CDisp()
{
}

CDispBasic::~CDispBasic()
{
    if (m_pString != m_String) {
	delete [] m_pString;
    }
}

CDisp::CDisp(double d)
{
#ifdef DEBUG
    _stprintf(m_String, TEXT("%.16g"), d);
#else
    wsprintf(m_String, TEXT("%d.%03d"), (int) d, (int) ((d - (int) d) * 1000));
#endif
}


/* If built for debug this will display the media type details. We convert the
   major and subtypes into strings and also ask the base classes for a string
   description of the subtype, so MEDIASUBTYPE_RGB565 becomes RGB 565 16 bit
   We also display the fields in the BITMAPINFOHEADER structure, this should
   succeed as we do not accept input types unless the format is big enough */

#ifdef DEBUG
void WINAPI DisplayType(LPTSTR label, const AM_MEDIA_TYPE *pmtIn)
{

    /* Dump the GUID types and a short description */

    DbgLog((LOG_TRACE,5,TEXT("")));
    DbgLog((LOG_TRACE,2,TEXT("%s  M type %hs  S type %hs"), label,
	    GuidNames[pmtIn->majortype],
	    GuidNames[pmtIn->subtype]));
    DbgLog((LOG_TRACE,5,TEXT("Subtype description %s"),GetSubtypeName(&pmtIn->subtype)));

    /* Dump the generic media types */

    if (pmtIn->bTemporalCompression) {
	DbgLog((LOG_TRACE,5,TEXT("Temporally compressed")));
    } else {
	DbgLog((LOG_TRACE,5,TEXT("Not temporally compressed")));
    }

    if (pmtIn->bFixedSizeSamples) {
	DbgLog((LOG_TRACE,5,TEXT("Sample size %d"),pmtIn->lSampleSize));
    } else {
	DbgLog((LOG_TRACE,5,TEXT("Variable size samples")));
    }

    if (pmtIn->formattype == FORMAT_VideoInfo) {
	/* Dump the contents of the BITMAPINFOHEADER structure */
	BITMAPINFOHEADER *pbmi = HEADER(pmtIn->pbFormat);
	VIDEOINFOHEADER *pVideoInfo = (VIDEOINFOHEADER *)pmtIn->pbFormat;

	DbgLog((LOG_TRACE,5,TEXT("Source rectangle (Left %d Top %d Right %d Bottom %d)"),
	       pVideoInfo->rcSource.left,
	       pVideoInfo->rcSource.top,
	       pVideoInfo->rcSource.right,
	       pVideoInfo->rcSource.bottom));

	DbgLog((LOG_TRACE,5,TEXT("Target rectangle (Left %d Top %d Right %d Bottom %d)"),
	       pVideoInfo->rcTarget.left,
	       pVideoInfo->rcTarget.top,
	       pVideoInfo->rcTarget.right,
	       pVideoInfo->rcTarget.bottom));

	DbgLog((LOG_TRACE,5,TEXT("Size of BITMAPINFO structure %d"),pbmi->biSize));
	if (pbmi->biCompression < 256) {
	    DbgLog((LOG_TRACE,2,TEXT("%dx%dx%d bit  (%d)"),
		    pbmi->biWidth, pbmi->biHeight,
		    pbmi->biBitCount, pbmi->biCompression));
	} else {
	    DbgLog((LOG_TRACE,2,TEXT("%dx%dx%d bit '%4.4hs'"),
		    pbmi->biWidth, pbmi->biHeight,
		    pbmi->biBitCount, &pbmi->biCompression));
	}

	DbgLog((LOG_TRACE,2,TEXT("Image size %d"),pbmi->biSizeImage));
	DbgLog((LOG_TRACE,5,TEXT("Planes %d"),pbmi->biPlanes));
	DbgLog((LOG_TRACE,5,TEXT("X Pels per metre %d"),pbmi->biXPelsPerMeter));
	DbgLog((LOG_TRACE,5,TEXT("Y Pels per metre %d"),pbmi->biYPelsPerMeter));
	DbgLog((LOG_TRACE,5,TEXT("Colours used %d"),pbmi->biClrUsed));

    } else if (pmtIn->majortype == MEDIATYPE_Audio) {
	DbgLog((LOG_TRACE,2,TEXT("     Format type %hs"),
	    GuidNames[pmtIn->formattype]));
	DbgLog((LOG_TRACE,2,TEXT("     Subtype %hs"),
	    GuidNames[pmtIn->subtype]));

	if ((pmtIn->subtype != MEDIASUBTYPE_MPEG1Packet)
	  && (pmtIn->cbFormat >= sizeof(PCMWAVEFORMAT)))
	{
	    /* Dump the contents of the WAVEFORMATEX type-specific format structure */

	    WAVEFORMATEX *pwfx = (WAVEFORMATEX *) pmtIn->pbFormat;
            DbgLog((LOG_TRACE,2,TEXT("wFormatTag %u"), pwfx->wFormatTag));
            DbgLog((LOG_TRACE,2,TEXT("nChannels %u"), pwfx->nChannels));
            DbgLog((LOG_TRACE,2,TEXT("nSamplesPerSec %lu"), pwfx->nSamplesPerSec));
            DbgLog((LOG_TRACE,2,TEXT("nAvgBytesPerSec %lu"), pwfx->nAvgBytesPerSec));
            DbgLog((LOG_TRACE,2,TEXT("nBlockAlign %u"), pwfx->nBlockAlign));
            DbgLog((LOG_TRACE,2,TEXT("wBitsPerSample %u"), pwfx->wBitsPerSample));

            /* PCM uses a WAVEFORMAT and does not have the extra size field */

            if (pmtIn->cbFormat >= sizeof(WAVEFORMATEX)) {
                DbgLog((LOG_TRACE,2,TEXT("cbSize %u"), pwfx->cbSize));
            }
	} else {
	}

    } else {
	DbgLog((LOG_TRACE,2,TEXT("     Format type %hs"),
	    GuidNames[pmtIn->formattype]));
	// !!!! should add code to dump wave format, others
    }
}


void WINAPI DumpGraph(IFilterGraph *pGraph, DWORD dwLevel)
{
    if( !pGraph )
    {
        return;
    }

    IEnumFilters *pFilters;

    DbgLog((LOG_TRACE,dwLevel,TEXT("DumpGraph [%x]"), pGraph));

    if (FAILED(pGraph->EnumFilters(&pFilters))) {
	DbgLog((LOG_TRACE,dwLevel,TEXT("EnumFilters failed!")));
    }

    IBaseFilter *pFilter;
    ULONG	n;
    while (pFilters->Next(1, &pFilter, &n) == S_OK) {
	FILTER_INFO	info;

	if (FAILED(pFilter->QueryFilterInfo(&info))) {
	    DbgLog((LOG_TRACE,dwLevel,TEXT("    Filter [%x]  -- failed QueryFilterInfo"), pFilter));
	} else {
	    QueryFilterInfoReleaseGraph(info);

	    // !!! should QueryVendorInfo here!
	
	    DbgLog((LOG_TRACE,dwLevel,TEXT("    Filter [%x]  '%ls'"), pFilter, info.achName));

	    IEnumPins *pins;

	    if (FAILED(pFilter->EnumPins(&pins))) {
		DbgLog((LOG_TRACE,dwLevel,TEXT("EnumPins failed!")));
	    } else {

		IPin *pPin;
		while (pins->Next(1, &pPin, &n) == S_OK) {
		    PIN_INFO	info;

		    if (FAILED(pPin->QueryPinInfo(&info))) {
			DbgLog((LOG_TRACE,dwLevel,TEXT("          Pin [%x]  -- failed QueryPinInfo"), pPin));
		    } else {
			QueryPinInfoReleaseFilter(info);

			IPin *pPinConnected = NULL;

			HRESULT hr = pPin->ConnectedTo(&pPinConnected);

			if (pPinConnected) {
			    DbgLog((LOG_TRACE,dwLevel,TEXT("          Pin [%x]  '%ls' [%sput]")
							   TEXT("  Connected to pin [%x]"),
				    pPin, info.achName,
				    info.dir == PINDIR_INPUT ? TEXT("In") : TEXT("Out"),
				    pPinConnected));

			    pPinConnected->Release();

			    // perhaps we should really dump the type both ways as a sanity
			    // check?
			    if (info.dir == PINDIR_OUTPUT) {
				AM_MEDIA_TYPE mt;

				hr = pPin->ConnectionMediaType(&mt);

				if (SUCCEEDED(hr)) {
				    DisplayType(TEXT("Connection type"), &mt);

				    FreeMediaType(mt);
				}
			    }
			} else {
			    DbgLog((LOG_TRACE,dwLevel,
				    TEXT("          Pin [%x]  '%ls' [%sput]"),
				    pPin, info.achName,
				    info.dir == PINDIR_INPUT ? TEXT("In") : TEXT("Out")));

			}
		    }

		    pPin->Release();

		}

		pins->Release();
	    }

	}
	
	pFilter->Release();
    }

    pFilters->Release();

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\dmodev\include\dmo.h ===
//------------------------------------------------------------------------------
// File: DMO.h
//
// Desc: Headers needed by almost all DMOs.
//
// Copyright (c) 1999 - 2000, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __DMO_H__
#define __DMO_H__


#include "mediaerr.h"

// When using ATL we get collisions on Lock so in this case rename
// IMediaObject::Lock to IMediaObject::DMOLock

#ifdef FIX_LOCK_NAME
#define Lock DMOLock
#endif
#include "mediaobj.h"
#ifdef FIX_LOCK_NAME
#undef Lock
#endif
#include "dmoreg.h"
#include "dmort.h"

#endif //__DMO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\base\wxdebug.h ===
//------------------------------------------------------------------------------
// File: WXDebug.h
//
// Desc: DirectShow base classes - provides debugging facilities.
//
//@@BEGIN_MSINTERNAL
//
//       January 1995
//
//@@END_MSINTERNAL
// Copyright (c) 1992-2001 Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __WXDEBUG__
#define __WXDEBUG__

// This library provides fairly straight forward debugging functionality, this
// is split into two main sections. The first is assertion handling, there are
// three types of assertions provided here. The most commonly used one is the
// ASSERT(condition) macro which will pop up a message box including the file
// and line number if the condition evaluates to FALSE. Then there is the
// EXECUTE_ASSERT macro which is the same as ASSERT except the condition will
// still be executed in NON debug builds. The final type of assertion is the
// KASSERT macro which is more suitable for pure (perhaps kernel) filters as
// the condition is printed onto the debugger rather than in a message box.
//
// The other part of the debug module facilties is general purpose logging.
// This is accessed by calling DbgLog(). The function takes a type and level
// field which define the type of informational string you are presenting and
// it's relative importance. The type field can be a combination (one or more)
// of LOG_TIMING, LOG_TRACE, LOG_MEMORY, LOG_LOCKING and LOG_ERROR. The level
// is a DWORD value where zero defines highest important. Use of zero as the
// debug logging level is to be encouraged ONLY for major errors or events as
// they will ALWAYS be displayed on the debugger. Other debug output has it's
// level matched against the current debug output level stored in the registry
// for this module and if less than the current setting it will be displayed.
//
// Each module or executable has it's own debug output level for each of the
// five types. These are read in when the DbgInitialise function is called
// for DLLs linking to STRMBASE.LIB this is done automatically when the DLL
// is loaded, executables must call it explicitely with the module instance
// handle given to them through the WINMAIN entry point. An executable must
// also call DbgTerminate when they have finished to clean up the resources
// the debug library uses, once again this is done automatically for DLLs

// These are the five different categories of logging information

enum {  LOG_TIMING = 0x01,    // Timing and performance measurements
        LOG_TRACE = 0x02,     // General step point call tracing
        LOG_MEMORY =  0x04,   // Memory and object allocation/destruction
        LOG_LOCKING = 0x08,   // Locking/unlocking of critical sections
        LOG_ERROR = 0x10,     // Debug error notification
        LOG_CUSTOM1 = 0x20,
        LOG_CUSTOM2 = 0x40,
        LOG_CUSTOM3 = 0x80,
        LOG_CUSTOM4 = 0x100,
        LOG_CUSTOM5 = 0x200,
};

#define LOG_FORCIBLY_SET 0x80000000

enum {  CDISP_HEX = 0x01,
        CDISP_DEC = 0x02};

// For each object created derived from CBaseObject (in debug builds) we
// create a descriptor that holds it's name (statically allocated memory)
// and a cookie we assign it. We keep a list of all the active objects
// we have registered so that we can dump a list of remaining objects

typedef struct tag_ObjectDesc {
    const CHAR *m_szName;
    const WCHAR *m_wszName;
    DWORD m_dwCookie;
    tag_ObjectDesc *m_pNext;
} ObjectDesc;

#define DLLIMPORT __declspec(dllimport)
#define DLLEXPORT __declspec(dllexport)

#ifdef DEBUG

    #define NAME(x) TEXT(x)

    // These are used internally by the debug library (PRIVATE)

    void WINAPI DbgInitKeyLevels(HKEY hKey, bool fTakeMax);
    void WINAPI DbgInitGlobalSettings(bool fTakeMax);
    void WINAPI DbgInitModuleSettings(bool fTakeMax);
    void WINAPI DbgInitModuleName();
    DWORD WINAPI DbgRegisterObjectCreation(
        const CHAR *szObjectName, const WCHAR *wszObjectName);

    BOOL WINAPI DbgRegisterObjectDestruction(DWORD dwCookie);

    // These are the PUBLIC entry points

    BOOL WINAPI DbgCheckModuleLevel(DWORD Type,DWORD Level);
    void WINAPI DbgSetModuleLevel(DWORD Type,DWORD Level);
    void WINAPI DbgSetAutoRefreshLevels(bool fAuto);

    // Initialise the library with the module handle

    void WINAPI DbgInitialise(HINSTANCE hInst);
    void WINAPI DbgTerminate();

    void WINAPI DbgDumpObjectRegister();

    // Display error and logging to the user

    void WINAPI DbgAssert(const TCHAR *pCondition,const TCHAR *pFileName,INT iLine);
    void WINAPI DbgBreakPoint(const TCHAR *pCondition,const TCHAR *pFileName,INT iLine);
    void WINAPI DbgBreakPoint(const TCHAR *pFileName,INT iLine,const TCHAR* szFormatString,...);

    void WINAPI DbgKernelAssert(const TCHAR *pCondition,const TCHAR *pFileName,INT iLine);
    void WINAPI DbgLogInfo(DWORD Type,DWORD Level,const TCHAR *pFormat,...);
#ifdef UNICODE
    void WINAPI DbgLogInfo(DWORD Type,DWORD Level,const CHAR *pFormat,...);
    void WINAPI DbgAssert(const CHAR *pCondition,const CHAR *pFileName,INT iLine);
    void WINAPI DbgBreakPoint(const CHAR *pCondition,const CHAR *pFileName,INT iLine);
    void WINAPI DbgKernelAssert(const CHAR *pCondition,const CHAR *pFileName,INT iLine);
#endif
    void WINAPI DbgOutString(LPCTSTR psz);

    //  Debug infinite wait stuff
    DWORD WINAPI DbgWaitForSingleObject(HANDLE h);
    DWORD WINAPI DbgWaitForMultipleObjects(DWORD nCount,
                                    CONST HANDLE *lpHandles,
                                    BOOL bWaitAll);
    void WINAPI DbgSetWaitTimeout(DWORD dwTimeout);

#ifdef __strmif_h__
    // Display a media type: Terse at level 2, verbose at level 5
    void WINAPI DisplayType(LPTSTR label, const AM_MEDIA_TYPE *pmtIn);

    // Dump lots of information about a filter graph
    void WINAPI DumpGraph(IFilterGraph *pGraph, DWORD dwLevel);
#endif

    #define KASSERT(_x_) if (!(_x_))         \
        DbgKernelAssert(TEXT(#_x_),TEXT(__FILE__),__LINE__)

    //  Break on the debugger without putting up a message box
    //  message goes to debugger instead

    #define KDbgBreak(_x_)                   \
        DbgKernelAssert(TEXT(#_x_),TEXT(__FILE__),__LINE__)

    // We chose a common name for our ASSERT macro, MFC also uses this name
    // So long as the implementation evaluates the condition and handles it
    // then we will be ok. Rather than override the behaviour expected we
    // will leave whatever first defines ASSERT as the handler (i.e. MFC)
    #ifndef ASSERT
        #define ASSERT(_x_) if (!(_x_))         \
            DbgAssert(TEXT(#_x_),TEXT(__FILE__),__LINE__)
    #endif

    #define DbgAssertAligned( _ptr_, _alignment_ ) ASSERT( ((DWORD_PTR) (_ptr_)) % (_alignment_) == 0)

    //  Put up a message box informing the user of a halt
    //  condition in the program

    #define DbgBreak(_x_)                   \
        DbgBreakPoint(TEXT(#_x_),TEXT(__FILE__),__LINE__)

    #define EXECUTE_ASSERT(_x_) ASSERT(_x_)
    #define DbgLog(_x_) DbgLogInfo _x_
    // MFC style trace macros

    #define NOTE(_x_)             DbgLog((LOG_TRACE,5,TEXT(_x_)))
    #define NOTE1(_x_,a)          DbgLog((LOG_TRACE,5,TEXT(_x_),a))
    #define NOTE2(_x_,a,b)        DbgLog((LOG_TRACE,5,TEXT(_x_),a,b))
    #define NOTE3(_x_,a,b,c)      DbgLog((LOG_TRACE,5,TEXT(_x_),a,b,c))
    #define NOTE4(_x_,a,b,c,d)    DbgLog((LOG_TRACE,5,TEXT(_x_),a,b,c,d))
    #define NOTE5(_x_,a,b,c,d,e)  DbgLog((LOG_TRACE,5,TEXT(_x_),a,b,c,d,e))

#else

    // Retail builds make public debug functions inert  - WARNING the source
    // files do not define or build any of the entry points in debug builds
    // (public entry points compile to nothing) so if you go trying to call
    // any of the private entry points in your source they won't compile

    #define NAME(_x_) ((TCHAR *) NULL)

    #define DbgInitialise(hInst)
    #define DbgTerminate()
    #define DbgLog(_x_) 0
    #define DbgOutString(psz)
    #define DbgAssertAligned( _ptr_, _alignment_ ) 0

    #define DbgRegisterObjectCreation(pObjectName)
    #define DbgRegisterObjectDestruction(dwCookie)
    #define DbgDumpObjectRegister()

    #define DbgCheckModuleLevel(Type,Level)
    #define DbgSetModuleLevel(Type,Level)
    #define DbgSetAutoRefreshLevels(fAuto)

    #define DbgWaitForSingleObject(h)  WaitForSingleObject(h, INFINITE)
    #define DbgWaitForMultipleObjects(nCount, lpHandles, bWaitAll)     \
               WaitForMultipleObjects(nCount, lpHandles, bWaitAll, INFINITE)
    #define DbgSetWaitTimeout(dwTimeout)

    #define KDbgBreak(_x_)
    #define DbgBreak(_x_)

    #define KASSERT(_x_) ((void)0)
    #ifndef ASSERT
	#define ASSERT(_x_) ((void)0)
    #endif
    #define EXECUTE_ASSERT(_x_) ((void)(_x_))

    // MFC style trace macros

    #define NOTE(_x_) ((void)0)
    #define NOTE1(_x_,a) ((void)0)
    #define NOTE2(_x_,a,b) ((void)0)
    #define NOTE3(_x_,a,b,c) ((void)0)
    #define NOTE4(_x_,a,b,c,d) ((void)0)
    #define NOTE5(_x_,a,b,c,d,e) ((void)0)

    #define DisplayType(label, pmtIn) ((void)0)
    #define DumpGraph(pGraph, label) ((void)0)
#endif


// Checks a pointer which should be non NULL - can be used as follows.

#define CheckPointer(p,ret) {if((p)==NULL) return (ret);}

//   HRESULT Foo(VOID *pBar)
//   {
//       CheckPointer(pBar,E_INVALIDARG)
//   }
//
//   Or if the function returns a boolean
//
//   BOOL Foo(VOID *pBar)
//   {
//       CheckPointer(pBar,FALSE)
//   }

// These validate pointers when symbol VFWROBUST is defined
// This will normally be defined in debug not retail builds

#ifdef DEBUG
    #define VFWROBUST
#endif

#ifdef VFWROBUST

    #define ValidateReadPtr(p,cb) \
        {if(IsBadReadPtr((PVOID)p,cb) == TRUE) \
            DbgBreak("Invalid read pointer");}

    #define ValidateWritePtr(p,cb) \
        {if(IsBadWritePtr((PVOID)p,cb) == TRUE) \
            DbgBreak("Invalid write pointer");}

    #define ValidateReadWritePtr(p,cb) \
        {ValidateReadPtr(p,cb) ValidateWritePtr(p,cb)}

    #define ValidateStringPtr(p) \
        {if(IsBadStringPtr((LPCTSTR)p,INFINITE) == TRUE) \
            DbgBreak("Invalid string pointer");}

    #define ValidateStringPtrA(p) \
        {if(IsBadStringPtrA((LPCSTR)p,INFINITE) == TRUE) \
            DbgBreak("Invalid ANSI string pointer");}

    #define ValidateStringPtrW(p) \
        {if(IsBadStringPtrW((LPCWSTR)p,INFINITE) == TRUE) \
            DbgBreak("Invalid UNICODE string pointer");}

#else
    #define ValidateReadPtr(p,cb) 0
    #define ValidateWritePtr(p,cb) 0
    #define ValidateReadWritePtr(p,cb) 0
    #define ValidateStringPtr(p) 0
    #define ValidateStringPtrA(p) 0
    #define ValidateStringPtrW(p) 0
#endif


#ifdef _OBJBASE_H_

    //  Outputting GUID names.  If you want to include the name
    //  associated with a GUID (eg CLSID_...) then
    //
    //      GuidNames[yourGUID]
    //
    //  Returns the name defined in uuids.h as a string

    typedef struct {
        CHAR   *szName;
        GUID    guid;
    } GUID_STRING_ENTRY;

    class CGuidNameList {
    public:
        CHAR *operator [] (const GUID& guid);
    };

    extern CGuidNameList GuidNames;

#endif

#ifndef REMIND
    //  REMIND macro - generates warning as reminder to complete coding
    //  (eg) usage:
    //
    //  #pragma message (REMIND("Add automation support"))


    #define QUOTE(x) #x
    #define QQUOTE(y) QUOTE(y)
    #define REMIND(str) __FILE__ "(" QQUOTE(__LINE__) ") :  " str
#endif

//  Method to display objects in a useful format
//
//  eg If you want to display a LONGLONG ll in a debug string do (eg)
//
//  DbgLog((LOG_TRACE, n, TEXT("Value is %s"), (LPCTSTR)CDisp(ll, CDISP_HEX)));


class CDispBasic
{
public:
    CDispBasic() { m_pString = m_String; };
    ~CDispBasic();
protected:
    PTCHAR m_pString;  // normally points to m_String... unless too much data
    TCHAR m_String[50];
};
class CDisp : public CDispBasic
{
public:
    CDisp(LONGLONG ll, int Format = CDISP_HEX); // Display a LONGLONG in CDISP_HEX or CDISP_DEC form
    CDisp(REFCLSID clsid);      // Display a GUID
    CDisp(double d);            // Display a floating point number
#ifdef __strmif_h__
#ifdef __STREAMS__
    CDisp(CRefTime t);          // Display a Reference Time
#endif
    CDisp(IPin *pPin);          // Display a pin as {filter clsid}(pin name)
    CDisp(IUnknown *pUnk);      // Display a filter or pin
#endif // __strmif_h__
    ~CDisp();

    //  Implement cast to (LPCTSTR) as parameter to logger
    operator LPCTSTR()
    {
        return (LPCTSTR)m_pString;
    };
};

 
#if defined(DEBUG)
class CAutoTrace
{
private:
    const TCHAR* _szBlkName;
    const int _level;
    static const TCHAR _szEntering[];
    static const TCHAR _szLeaving[];
public:
    CAutoTrace(const TCHAR* szBlkName, const int level = 15)
        : _szBlkName(szBlkName), _level(level)
    {DbgLog((LOG_TRACE, _level, _szEntering, _szBlkName));}
 
    ~CAutoTrace()
    {DbgLog((LOG_TRACE, _level, _szLeaving, _szBlkName));}
};
 
#define AMTRACE(_x_) CAutoTrace __trace _x_
#else
#define AMTRACE(_x_)
#endif

#endif // __WXDEBUG__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\base\wxutil.cpp ===
//------------------------------------------------------------------------------
// File: WXUtil.cpp
//
// Desc: DirectShow base classes - implements helper classes for building
//       multimedia filters.
//
// Copyright (c) 1992-2001 Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#include <streams.h>

//
//  Declare function from largeint.h we need so that PPC can build
//

//
// Enlarged integer divide - 64-bits / 32-bits > 32-bits
//

#ifndef _X86_

#define LLtoU64(x) (*(unsigned __int64*)(void*)(&(x)))

__inline
ULONG
WINAPI
EnlargedUnsignedDivide (
    IN ULARGE_INTEGER Dividend,
    IN ULONG Divisor,
    IN PULONG Remainder
    )
{
        // return remainder if necessary
        if (Remainder != NULL)
                *Remainder = (ULONG)(LLtoU64(Dividend) % Divisor);
        return (ULONG)(LLtoU64(Dividend) / Divisor);
}

#else
__inline
ULONG
WINAPI
EnlargedUnsignedDivide (
    IN ULARGE_INTEGER Dividend,
    IN ULONG Divisor,
    IN PULONG Remainder
    )
{
    ULONG ulResult;
    _asm {
        mov eax,Dividend.LowPart
        mov edx,Dividend.HighPart
        mov ecx,Remainder
        div Divisor
        or  ecx,ecx
        jz  short label
        mov [ecx],edx
label:
        mov ulResult,eax
    }
    return ulResult;
}
#endif

// --- CAMEvent -----------------------
CAMEvent::CAMEvent(BOOL fManualReset)
{
    m_hEvent = CreateEvent(NULL, fManualReset, FALSE, NULL);
}

CAMEvent::~CAMEvent()
{
    if (m_hEvent) {
	EXECUTE_ASSERT(CloseHandle(m_hEvent));
    }
}


// --- CAMMsgEvent -----------------------
// One routine.  The rest is handled in CAMEvent

BOOL CAMMsgEvent::WaitMsg(DWORD dwTimeout)
{
    // wait for the event to be signalled, or for the
    // timeout (in MS) to expire.  allow SENT messages
    // to be processed while we wait
    DWORD dwWait;
    DWORD dwStartTime;

    // set the waiting period.
    DWORD dwWaitTime = dwTimeout;

    // the timeout will eventually run down as we iterate
    // processing messages.  grab the start time so that
    // we can calculate elapsed times.
    if (dwWaitTime != INFINITE) {
        dwStartTime = timeGetTime();
    }

    do {
        dwWait = MsgWaitForMultipleObjects(1,&m_hEvent,FALSE, dwWaitTime, QS_SENDMESSAGE);
        if (dwWait == WAIT_OBJECT_0 + 1) {
	    MSG Message;
            PeekMessage(&Message,NULL,0,0,PM_NOREMOVE);

	    // If we have an explicit length of time to wait calculate
	    // the next wake up point - which might be now.
	    // If dwTimeout is INFINITE, it stays INFINITE
	    if (dwWaitTime != INFINITE) {

		DWORD dwElapsed = timeGetTime()-dwStartTime;

		dwWaitTime =
		    (dwElapsed >= dwTimeout)
			? 0  // wake up with WAIT_TIMEOUT
			: dwTimeout-dwElapsed;
	    }
        }
    } while (dwWait == WAIT_OBJECT_0 + 1);

    // return TRUE if we woke on the event handle,
    //        FALSE if we timed out.
    return (dwWait == WAIT_OBJECT_0);
}

// --- CAMThread ----------------------


CAMThread::CAMThread()
    : m_EventSend(TRUE)     // must be manual-reset for CheckRequest()
{
    m_hThread = NULL;
}

CAMThread::~CAMThread() {
    Close();
}


// when the thread starts, it calls this function. We unwrap the 'this'
//pointer and call ThreadProc.
DWORD WINAPI
CAMThread::InitialThreadProc(LPVOID pv)
{
    HRESULT hrCoInit = CAMThread::CoInitializeHelper();
    if(FAILED(hrCoInit)) {
        DbgLog((LOG_ERROR, 1, TEXT("CoInitializeEx failed.")));
    }

    CAMThread * pThread = (CAMThread *) pv;

    HRESULT hr = pThread->ThreadProc();

    if(SUCCEEDED(hrCoInit)) {
        CoUninitialize();
    }

    return hr;
}

BOOL
CAMThread::Create()
{
    DWORD threadid;

    CAutoLock lock(&m_AccessLock);

    if (ThreadExists()) {
	return FALSE;
    }

    m_hThread = CreateThread(
		    NULL,
		    0,
		    CAMThread::InitialThreadProc,
		    this,
		    0,
		    &threadid);

    if (!m_hThread) {
	return FALSE;
    }

    return TRUE;
}

DWORD
CAMThread::CallWorker(DWORD dwParam)
{
    // lock access to the worker thread for scope of this object
    CAutoLock lock(&m_AccessLock);

    if (!ThreadExists()) {
	return (DWORD) E_FAIL;
    }

    // set the parameter
    m_dwParam = dwParam;

    // signal the worker thread
    m_EventSend.Set();

    // wait for the completion to be signalled
    m_EventComplete.Wait();

    // done - this is the thread's return value
    return m_dwReturnVal;
}

// Wait for a request from the client
DWORD
CAMThread::GetRequest()
{
    m_EventSend.Wait();
    return m_dwParam;
}

// is there a request?
BOOL
CAMThread::CheckRequest(DWORD * pParam)
{
    if (!m_EventSend.Check()) {
	return FALSE;
    } else {
	if (pParam) {
	    *pParam = m_dwParam;
	}
	return TRUE;
    }
}

// reply to the request
void
CAMThread::Reply(DWORD dw)
{
    m_dwReturnVal = dw;

    // The request is now complete so CheckRequest should fail from
    // now on
    //
    // This event should be reset BEFORE we signal the client or
    // the client may Set it before we reset it and we'll then
    // reset it (!)

    m_EventSend.Reset();

    // Tell the client we're finished

    m_EventComplete.Set();
}

HRESULT CAMThread::CoInitializeHelper()
{
    // call CoInitializeEx and tell OLE not to create a window (this
    // thread probably won't dispatch messages and will hang on
    // broadcast msgs o/w).
    //
    // If CoInitEx is not available, threads that don't call CoCreate
    // aren't affected. Threads that do will have to handle the
    // failure. Perhaps we should fall back to CoInitialize and risk
    // hanging?
    //

    // older versions of ole32.dll don't have CoInitializeEx

    HRESULT hr = E_FAIL;
    HINSTANCE hOle = GetModuleHandle(TEXT("ole32.dll"));
    if(hOle)
    {
        typedef HRESULT (STDAPICALLTYPE *PCoInitializeEx)(
            LPVOID pvReserved, DWORD dwCoInit);
        PCoInitializeEx pCoInitializeEx =
            (PCoInitializeEx)(GetProcAddress(hOle, "CoInitializeEx"));
        if(pCoInitializeEx)
        {
            hr = (*pCoInitializeEx)(0, COINIT_DISABLE_OLE1DDE );
        }
    }
    else
    {
        // caller must load ole32.dll
        DbgBreak("couldn't locate ole32.dll");
    }

    return hr;
}


// destructor for CMsgThread  - cleans up any messages left in the
// queue when the thread exited
CMsgThread::~CMsgThread()
{
    if (m_hThread != NULL) {
        WaitForSingleObject(m_hThread, INFINITE);
        EXECUTE_ASSERT(CloseHandle(m_hThread));
    }

    POSITION pos = m_ThreadQueue.GetHeadPosition();
    while (pos) {
        CMsg * pMsg = m_ThreadQueue.GetNext(pos);
        delete pMsg;
    }
    m_ThreadQueue.RemoveAll();

    if (m_hSem != NULL) {
        EXECUTE_ASSERT(CloseHandle(m_hSem));
    }
}

BOOL
CMsgThread::CreateThread(
    )
{
    m_hSem = CreateSemaphore(NULL, 0, 0x7FFFFFFF, NULL);
    if (m_hSem == NULL) {
        return FALSE;
    }

    m_hThread = ::CreateThread(NULL, 0, DefaultThreadProc,
			       (LPVOID)this, 0, &m_ThreadId);
    return m_hThread != NULL;
}


// This is the threads message pump.  Here we get and dispatch messages to
// clients thread proc until the client refuses to process a message.
// The client returns a non-zero value to stop the message pump, this
// value becomes the threads exit code.

DWORD WINAPI
CMsgThread::DefaultThreadProc(
    LPVOID lpParam
    )
{
    CMsgThread *lpThis = (CMsgThread *)lpParam;
    CMsg msg;
    LRESULT lResult;

    // !!!
    CoInitialize(NULL);

    // allow a derived class to handle thread startup
    lpThis->OnThreadInit();

    do {
	lpThis->GetThreadMsg(&msg);
	lResult = lpThis->ThreadMessageProc(msg.uMsg,msg.dwFlags,
					    msg.lpParam, msg.pEvent);
    } while (lResult == 0L);

    // !!!
    CoUninitialize();

    return (DWORD)lResult;
}


// Block until the next message is placed on the list m_ThreadQueue.
// copies the message to the message pointed to by *pmsg
void
CMsgThread::GetThreadMsg(CMsg *msg)
{
    CMsg * pmsg = NULL;

    // keep trying until a message appears
    while (TRUE) {
        {
            CAutoLock lck(&m_Lock);
            pmsg = m_ThreadQueue.RemoveHead();
            if (pmsg == NULL) {
                m_lWaiting++;
            } else {
                break;
            }
        }
        // the semaphore will be signalled when it is non-empty
        WaitForSingleObject(m_hSem, INFINITE);
    }
    // copy fields to caller's CMsg
    *msg = *pmsg;

    // this CMsg was allocated by the 'new' in PutThreadMsg
    delete pmsg;

}


// NOTE: as we need to use the same binaries on Win95 as on NT this code should
// be compiled WITHOUT unicode being defined.  Otherwise we will not pick up
// these internal routines and the binary will not run on Win95.

#ifndef UNICODE
// Windows 95 doesn't implement this, so we provide an implementation.
LPWSTR
WINAPI
lstrcpyWInternal(
    LPWSTR lpString1,
    LPCWSTR lpString2
    )
{
    LPWSTR  lpReturn = lpString1;
    while (*lpString1++ = *lpString2++);

    return lpReturn;
}

// Windows 95 doesn't implement this, so we provide an implementation.
LPWSTR
WINAPI
lstrcpynWInternal(
    LPWSTR lpString1,
    LPCWSTR lpString2,
    int     iMaxLength
    )
{
    ASSERT(iMaxLength);
    LPWSTR  lpReturn = lpString1;
    if (iMaxLength) {
        while (--iMaxLength && (*lpString1++ = *lpString2++));

        // If we ran out of room (which will be the case if
        // iMaxLength is now 0) we still need to terminate the
        // string.
        if (!iMaxLength) *lpString1 = L'\0';
    }
    return lpReturn;
}

int
WINAPI
lstrcmpWInternal(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    )
{
    do {
	WCHAR c1 = *lpString1;
	WCHAR c2 = *lpString2;
	if (c1 != c2)
	    return (int) c1 - (int) c2;
    } while (*lpString1++ && *lpString2++);
    return 0;
}


int
WINAPI
lstrcmpiWInternal(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    )
{
    do {
	WCHAR c1 = *lpString1;
	WCHAR c2 = *lpString2;
	if (c1 >= L'A' && c1 <= L'Z')
	    c1 -= (WCHAR) (L'A' - L'a');
	if (c2 >= L'A' && c2 <= L'Z')
	    c2 -= (WCHAR) (L'A' - L'a');
	
	if (c1 != c2)
	    return (int) c1 - (int) c2;
    } while (*lpString1++ && *lpString2++);

    return 0;
}


int
WINAPI
lstrlenWInternal(
    LPCWSTR lpString
    )
{
    int i = -1;
    while (*(lpString+(++i)))
        ;
    return i;
}


int WINAPIV wsprintfWInternal(LPWSTR wszOut, LPCWSTR pszFmt, ...)
{
    char fmt[256]; // !!!
    char ach[256]; // !!!
    int i;

    va_list va;
    va_start(va, pszFmt);
    WideCharToMultiByte(GetACP(), 0, pszFmt, -1, fmt, 256, NULL, NULL);
    i = wvsprintfA(ach, fmt, va);
    va_end(va);

    MultiByteToWideChar(CP_ACP, 0, ach, -1, wszOut, i+1);

    return i;
}
#else

// need to provide the implementations in unicode for non-unicode
// builds linking with the unicode strmbase.lib
LPWSTR WINAPI lstrcpyWInternal(
    LPWSTR lpString1,
    LPCWSTR lpString2
    )
{
    return lstrcpyW(lpString1, lpString2);
}

LPWSTR WINAPI lstrcpynWInternal(
    LPWSTR lpString1,
    LPCWSTR lpString2,
    int     iMaxLength
    )
{
    return lstrcpynW(lpString1, lpString2, iMaxLength);
}

int WINAPI lstrcmpWInternal(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    )
{
    return lstrcmpW(lpString1, lpString2);
}


int WINAPI lstrcmpiWInternal(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    )
{
    return lstrcmpiW(lpString1, lpString2);
}


int WINAPI lstrlenWInternal(
    LPCWSTR lpString
    )
{
    return lstrlenW(lpString);
}


int WINAPIV wsprintfWInternal(
    LPWSTR wszOut, LPCWSTR pszFmt, ...)
{
    va_list va;
    va_start(va, pszFmt);
    int i = wvsprintfW(wszOut, pszFmt, va);
    va_end(va);
    return i;
}
#endif


// Helper function - convert int to WSTR
void WINAPI IntToWstr(int i, LPWSTR wstr)
{
#ifdef UNICODE
    wsprintf(wstr, L"%d", i);
#else
    TCHAR temp[32];
    wsprintf(temp, "%d", i);
    MultiByteToWideChar(CP_ACP, 0, temp, -1, wstr, 32);
#endif
} // IntToWstr


#if 0
void * memchrInternal(const void *pv, int c, size_t sz)
{
    BYTE *pb = (BYTE *) pv;
    while (sz--) {
	if (*pb == c)
	    return (void *) pb;
	pb++;
    }
    return NULL;
}
#endif


#define MEMORY_ALIGNMENT        4
#define MEMORY_ALIGNMENT_LOG2   2
#define MEMORY_ALIGNMENT_MASK   MEMORY_ALIGNMENT - 1

void * __stdcall memmoveInternal(void * dst, const void * src, size_t count)
{
    void * ret = dst;

#ifdef _X86_
    if (dst <= src || (char *)dst >= ((char *)src + count)) {

        /*
         * Non-Overlapping Buffers
         * copy from lower addresses to higher addresses
         */
        _asm {
            mov     esi,src
            mov     edi,dst
            mov     ecx,count
            cld
            mov     edx,ecx
            and     edx,MEMORY_ALIGNMENT_MASK
            shr     ecx,MEMORY_ALIGNMENT_LOG2
            rep     movsd
            or      ecx,edx
            jz      memmove_done
            rep     movsb
memmove_done:
        }
    }
    else {

        /*
         * Overlapping Buffers
         * copy from higher addresses to lower addresses
         */
        _asm {
            mov     esi,src
            mov     edi,dst
            mov     ecx,count
            std
            add     esi,ecx
            add     edi,ecx
            dec     esi
            dec     edi
            rep     movsb
            cld
        }
    }
#else
    MoveMemory(dst, src, count);
#endif

    return ret;
}

/*  Arithmetic functions to help with time format conversions
*/

#ifdef _M_ALPHA
// work around bug in version 12.00.8385 of the alpha compiler where
// UInt32x32To64 sign-extends its arguments (?)
#undef UInt32x32To64
#define UInt32x32To64(a, b) (((ULONGLONG)((ULONG)(a)) & 0xffffffff) * ((ULONGLONG)((ULONG)(b)) & 0xffffffff))
#endif

/*   Compute (a * b + d) / c */
LONGLONG WINAPI llMulDiv(LONGLONG a, LONGLONG b, LONGLONG c, LONGLONG d)
{
    /*  Compute the absolute values to avoid signed arithmetic problems */
    ULARGE_INTEGER ua, ub;
    DWORDLONG uc;

    ua.QuadPart = (DWORDLONG)(a >= 0 ? a : -a);
    ub.QuadPart = (DWORDLONG)(b >= 0 ? b : -b);
    uc          = (DWORDLONG)(c >= 0 ? c : -c);
    BOOL bSign = (a < 0) ^ (b < 0);

    /*  Do long multiplication */
    ULARGE_INTEGER p[2];
    p[0].QuadPart  = UInt32x32To64(ua.LowPart, ub.LowPart);

    /*  This next computation cannot overflow into p[1].HighPart because
        the max number we can compute here is:

                 (2 ** 32 - 1) * (2 ** 32 - 1) +  // ua.LowPart * ub.LowPart
    (2 ** 32) *  (2 ** 31) * (2 ** 32 - 1) * 2    // x.LowPart * y.HighPart * 2

    == 2 ** 96 - 2 ** 64 + (2 ** 64 - 2 ** 33 + 1)
    == 2 ** 96 - 2 ** 33 + 1
    < 2 ** 96
    */

    ULARGE_INTEGER x;
    x.QuadPart     = UInt32x32To64(ua.LowPart, ub.HighPart) +
                     UInt32x32To64(ua.HighPart, ub.LowPart) +
                     p[0].HighPart;
    p[0].HighPart  = x.LowPart;
    p[1].QuadPart  = UInt32x32To64(ua.HighPart, ub.HighPart) + x.HighPart;

    if (d != 0) {
        ULARGE_INTEGER ud[2];
        if (bSign) {
            ud[0].QuadPart = (DWORDLONG)(-d);
            if (d > 0) {
                /*  -d < 0 */
                ud[1].QuadPart = (DWORDLONG)(LONGLONG)-1;
            } else {
                ud[1].QuadPart = (DWORDLONG)0;
            }
        } else {
            ud[0].QuadPart = (DWORDLONG)d;
            if (d < 0) {
                ud[1].QuadPart = (DWORDLONG)(LONGLONG)-1;
            } else {
                ud[1].QuadPart = (DWORDLONG)0;
            }
        }
        /*  Now do extended addition */
        ULARGE_INTEGER uliTotal;

        /*  Add ls DWORDs */
        uliTotal.QuadPart  = (DWORDLONG)ud[0].LowPart + p[0].LowPart;
        p[0].LowPart       = uliTotal.LowPart;

        /*  Propagate carry */
        uliTotal.LowPart   = uliTotal.HighPart;
        uliTotal.HighPart  = 0;

        /*  Add 2nd most ls DWORDs */
        uliTotal.QuadPart += (DWORDLONG)ud[0].HighPart + p[0].HighPart;
        p[0].HighPart      = uliTotal.LowPart;

        /*  Propagate carry */
        uliTotal.LowPart   = uliTotal.HighPart;
        uliTotal.HighPart  = 0;

        /*  Add MS DWORDLONGs - no carry expected */
        p[1].QuadPart     += ud[1].QuadPart + uliTotal.QuadPart;

        /*  Now see if we got a sign change from the addition */
        if ((LONG)p[1].HighPart < 0) {
            bSign = !bSign;

            /*  Negate the current value (ugh!) */
            p[0].QuadPart  = ~p[0].QuadPart;
            p[1].QuadPart  = ~p[1].QuadPart;
            p[0].QuadPart += 1;
            p[1].QuadPart += (p[0].QuadPart == 0);
        }
    }

    /*  Now for the division */
    if (c < 0) {
        bSign = !bSign;
    }


    /*  This will catch c == 0 and overflow */
    if (uc <= p[1].QuadPart) {
        return bSign ? (LONGLONG)0x8000000000000000 :
                       (LONGLONG)0x7FFFFFFFFFFFFFFF;
    }

    DWORDLONG ullResult;

    /*  Do the division */
    /*  If the dividend is a DWORD_LONG use the compiler */
    if (p[1].QuadPart == 0) {
        ullResult = p[0].QuadPart / uc;
        return bSign ? -(LONGLONG)ullResult : (LONGLONG)ullResult;
    }

    /*  If the divisor is a DWORD then its simpler */
    ULARGE_INTEGER ulic;
    ulic.QuadPart = uc;
    if (ulic.HighPart == 0) {
        ULARGE_INTEGER uliDividend;
        ULARGE_INTEGER uliResult;
        DWORD dwDivisor = (DWORD)uc;
        // ASSERT(p[1].HighPart == 0 && p[1].LowPart < dwDivisor);
        uliDividend.HighPart = p[1].LowPart;
        uliDividend.LowPart = p[0].HighPart;
#ifndef USE_LARGEINT
        uliResult.HighPart = (DWORD)(uliDividend.QuadPart / dwDivisor);
        p[0].HighPart = (DWORD)(uliDividend.QuadPart % dwDivisor);
        uliResult.LowPart = 0;
        uliResult.QuadPart = p[0].QuadPart / dwDivisor + uliResult.QuadPart;
#else
        /*  NOTE - this routine will take exceptions if
            the result does not fit in a DWORD
        */
        if (uliDividend.QuadPart >= (DWORDLONG)dwDivisor) {
            uliResult.HighPart = EnlargedUnsignedDivide(
                                     uliDividend,
                                     dwDivisor,
                                     &p[0].HighPart);
        } else {
            uliResult.HighPart = 0;
        }
        uliResult.LowPart = EnlargedUnsignedDivide(
                                 p[0],
                                 dwDivisor,
                                 NULL);
#endif
        return bSign ? -(LONGLONG)uliResult.QuadPart :
                        (LONGLONG)uliResult.QuadPart;
    }


    ullResult = 0;

    /*  OK - do long division */
    for (int i = 0; i < 64; i++) {
        ullResult <<= 1;

        /*  Shift 128 bit p left 1 */
        p[1].QuadPart <<= 1;
        if ((p[0].HighPart & 0x80000000) != 0) {
            p[1].LowPart++;
        }
        p[0].QuadPart <<= 1;

        /*  Compare */
        if (uc <= p[1].QuadPart) {
            p[1].QuadPart -= uc;
            ullResult += 1;
        }
    }

    return bSign ? - (LONGLONG)ullResult : (LONGLONG)ullResult;
}

LONGLONG WINAPI Int64x32Div32(LONGLONG a, LONG b, LONG c, LONG d)
{
    ULARGE_INTEGER ua;
    DWORD ub;
    DWORD uc;

    /*  Compute the absolute values to avoid signed arithmetic problems */
    ua.QuadPart = (DWORDLONG)(a >= 0 ? a : -a);
    ub = (DWORD)(b >= 0 ? b : -b);
    uc = (DWORD)(c >= 0 ? c : -c);
    BOOL bSign = (a < 0) ^ (b < 0);

    /*  Do long multiplication */
    ULARGE_INTEGER p0;
    DWORD p1;
    p0.QuadPart  = UInt32x32To64(ua.LowPart, ub);

    if (ua.HighPart != 0) {
        ULARGE_INTEGER x;
        x.QuadPart     = UInt32x32To64(ua.HighPart, ub) + p0.HighPart;
        p0.HighPart  = x.LowPart;
        p1   = x.HighPart;
    } else {
        p1 = 0;
    }

    if (d != 0) {
        ULARGE_INTEGER ud0;
        DWORD ud1;

        if (bSign) {
            //
            //  Cast d to LONGLONG first otherwise -0x80000000 sign extends
            //  incorrectly
            //
            ud0.QuadPart = (DWORDLONG)(-(LONGLONG)d);
            if (d > 0) {
                /*  -d < 0 */
                ud1 = (DWORD)-1;
            } else {
                ud1 = (DWORD)0;
            }
        } else {
            ud0.QuadPart = (DWORDLONG)d;
            if (d < 0) {
                ud1 = (DWORD)-1;
            } else {
                ud1 = (DWORD)0;
            }
        }
        /*  Now do extended addition */
        ULARGE_INTEGER uliTotal;

        /*  Add ls DWORDs */
        uliTotal.QuadPart  = (DWORDLONG)ud0.LowPart + p0.LowPart;
        p0.LowPart       = uliTotal.LowPart;

        /*  Propagate carry */
        uliTotal.LowPart   = uliTotal.HighPart;
        uliTotal.HighPart  = 0;

        /*  Add 2nd most ls DWORDs */
        uliTotal.QuadPart += (DWORDLONG)ud0.HighPart + p0.HighPart;
        p0.HighPart      = uliTotal.LowPart;

        /*  Add MS DWORDLONGs - no carry expected */
        p1 += ud1 + uliTotal.HighPart;

        /*  Now see if we got a sign change from the addition */
        if ((LONG)p1 < 0) {
            bSign = !bSign;

            /*  Negate the current value (ugh!) */
            p0.QuadPart  = ~p0.QuadPart;
            p1 = ~p1;
            p0.QuadPart += 1;
            p1 += (p0.QuadPart == 0);
        }
    }

    /*  Now for the division */
    if (c < 0) {
        bSign = !bSign;
    }


    /*  This will catch c == 0 and overflow */
    if (uc <= p1) {
        return bSign ? (LONGLONG)0x8000000000000000 :
                       (LONGLONG)0x7FFFFFFFFFFFFFFF;
    }

    /*  Do the division */

    /*  If the divisor is a DWORD then its simpler */
    ULARGE_INTEGER uliDividend;
    ULARGE_INTEGER uliResult;
    DWORD dwDivisor = uc;
    uliDividend.HighPart = p1;
    uliDividend.LowPart = p0.HighPart;
    /*  NOTE - this routine will take exceptions if
        the result does not fit in a DWORD
    */
    if (uliDividend.QuadPart >= (DWORDLONG)dwDivisor) {
        uliResult.HighPart = EnlargedUnsignedDivide(
                                 uliDividend,
                                 dwDivisor,
                                 &p0.HighPart);
    } else {
        uliResult.HighPart = 0;
    }
    uliResult.LowPart = EnlargedUnsignedDivide(
                             p0,
                             dwDivisor,
                             NULL);
    return bSign ? -(LONGLONG)uliResult.QuadPart :
                    (LONGLONG)uliResult.QuadPart;
}

#ifdef DEBUG
/******************************Public*Routine******************************\
* Debug CCritSec helpers
*
* We provide debug versions of the Constructor, destructor, Lock and Unlock
* routines.  The debug code tracks who owns each critical section by
* maintaining a depth count.
*
* History:
*
\**************************************************************************/

CCritSec::CCritSec()
{
    InitializeCriticalSection(&m_CritSec);
    m_currentOwner = m_lockCount = 0;
    m_fTrace = FALSE;
}

CCritSec::~CCritSec()
{
    DeleteCriticalSection(&m_CritSec);
}

void CCritSec::Lock()
{
    UINT tracelevel=3;
    DWORD us = GetCurrentThreadId();
    DWORD currentOwner = m_currentOwner;
    if (currentOwner && (currentOwner != us)) {
        // already owned, but not by us
        if (m_fTrace) {
            DbgLog((LOG_LOCKING, 2, TEXT("Thread %d about to wait for lock %x owned by %d"),
                GetCurrentThreadId(), &m_CritSec, currentOwner));
            tracelevel=2;
	        // if we saw the message about waiting for the critical
	        // section we ensure we see the message when we get the
	        // critical section
        }
    }
    EnterCriticalSection(&m_CritSec);
    if (0 == m_lockCount++) {
        // we now own it for the first time.  Set owner information
        m_currentOwner = us;

        if (m_fTrace) {
            DbgLog((LOG_LOCKING, tracelevel, TEXT("Thread %d now owns lock %x"), m_currentOwner, &m_CritSec));
        }
    }
}

void CCritSec::Unlock() {
    if (0 == --m_lockCount) {
        // about to be unowned
        if (m_fTrace) {
            DbgLog((LOG_LOCKING, 3, TEXT("Thread %d releasing lock %x"), m_currentOwner, &m_CritSec));
        }

        m_currentOwner = 0;
    }
    LeaveCriticalSection(&m_CritSec);
}

void WINAPI DbgLockTrace(CCritSec * pcCrit, BOOL fTrace)
{
    pcCrit->m_fTrace = fTrace;
}

BOOL WINAPI CritCheckIn(CCritSec * pcCrit)
{
    return (GetCurrentThreadId() == pcCrit->m_currentOwner);
}

BOOL WINAPI CritCheckIn(const CCritSec * pcCrit)
{
    return (GetCurrentThreadId() == pcCrit->m_currentOwner);
}

BOOL WINAPI CritCheckOut(CCritSec * pcCrit)
{
    return (GetCurrentThreadId() != pcCrit->m_currentOwner);
}

BOOL WINAPI CritCheckOut(const CCritSec * pcCrit)
{
    return (GetCurrentThreadId() != pcCrit->m_currentOwner);
}
#endif


STDAPI WriteBSTR(BSTR *pstrDest, LPCWSTR szSrc)
{
    *pstrDest = SysAllocString( szSrc );
    if( !(*pstrDest) ) return E_OUTOFMEMORY;
    return NOERROR;
}


STDAPI FreeBSTR(BSTR* pstr)
{
    if( *pstr == NULL ) return S_FALSE;
    SysFreeString( *pstr );
    return NOERROR;
}


// Return a wide string - allocating memory for it
// Returns:
//    S_OK          - no error
//    E_POINTER     - ppszReturn == NULL
//    E_OUTOFMEMORY - can't allocate memory for returned string
STDAPI AMGetWideString(LPCWSTR psz, LPWSTR *ppszReturn)
{
    CheckPointer(ppszReturn, E_POINTER);
    ValidateReadWritePtr(ppszReturn, sizeof(LPWSTR));
    DWORD nameLen = sizeof(WCHAR) * (lstrlenW(psz)+1);
    *ppszReturn = (LPWSTR)CoTaskMemAlloc(nameLen);
    if (*ppszReturn == NULL) {
       return E_OUTOFMEMORY;
    }
    CopyMemory(*ppszReturn, psz, nameLen);
    return NOERROR;
}

// Waits for the HANDLE hObject.  While waiting messages sent
// to windows on our thread by SendMessage will be processed.
// Using this function to do waits and mutual exclusion
// avoids some deadlocks in objects with windows.
// Return codes are the same as for WaitForSingleObject
DWORD WINAPI WaitDispatchingMessages(
    HANDLE hObject,
    DWORD dwWait,
    HWND hwnd,
    UINT uMsg,
    HANDLE hEvent)
{
    BOOL bPeeked = FALSE;
    DWORD dwResult;
    DWORD dwStart;
    DWORD dwThreadPriority;

    static UINT uMsgId = 0;

    HANDLE hObjects[2] = { hObject, hEvent };
    if (dwWait != INFINITE && dwWait != 0) {
        dwStart = GetTickCount();
    }
    for (; ; ) {
        DWORD nCount = NULL != hEvent ? 2 : 1;

        //  Minimize the chance of actually dispatching any messages
        //  by seeing if we can lock immediately.
        dwResult = WaitForMultipleObjects(nCount, hObjects, FALSE, 0);
        if (dwResult < WAIT_OBJECT_0 + nCount) {
            break;
        }

        DWORD dwTimeOut = dwWait;
        if (dwTimeOut > 10) {
            dwTimeOut = 10;
        }
        dwResult = MsgWaitForMultipleObjects(
                             nCount,
                             hObjects,
                             FALSE,
                             dwTimeOut,
                             hwnd == NULL ? QS_SENDMESSAGE :
                                            QS_SENDMESSAGE + QS_POSTMESSAGE);
        if (dwResult == WAIT_OBJECT_0 + nCount ||
            dwResult == WAIT_TIMEOUT && dwTimeOut != dwWait) {
            MSG msg;
            if (hwnd != NULL) {
                while (PeekMessage(&msg, hwnd, uMsg, uMsg, PM_REMOVE)) {
                    DispatchMessage(&msg);
                }
            }
            // Do this anyway - the previous peek doesn't flush out the
            // messages
            PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);

            if (dwWait != INFINITE && dwWait != 0) {
                DWORD dwNow = GetTickCount();

                // Working with differences handles wrap-around
                DWORD dwDiff = dwNow - dwStart;
                if (dwDiff > dwWait) {
                    dwWait = 0;
                } else {
                    dwWait -= dwDiff;
                }
                dwStart = dwNow;
            }
            if (!bPeeked) {
                //  Raise our priority to prevent our message queue
                //  building up
                dwThreadPriority = GetThreadPriority(GetCurrentThread());
                if (dwThreadPriority < THREAD_PRIORITY_HIGHEST) {
                    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);
                }
                bPeeked = TRUE;
            }
        } else {
            break;
        }
    }
    if (bPeeked) {
        SetThreadPriority(GetCurrentThread(), dwThreadPriority);
        if (HIWORD(GetQueueStatus(QS_POSTMESSAGE)) & QS_POSTMESSAGE) {
            if (uMsgId == 0) {
                uMsgId = RegisterWindowMessage(TEXT("AMUnblock"));
            }
            if (uMsgId != 0) {
                MSG msg;
                //  Remove old ones
                while (PeekMessage(&msg, (HWND)-1, uMsgId, uMsgId, PM_REMOVE)) {
                }
            }
            PostThreadMessage(GetCurrentThreadId(), uMsgId, 0, 0);
        }
    }
    return dwResult;
}

HRESULT AmGetLastErrorToHResult()
{
    DWORD dwLastError = GetLastError();
    if(dwLastError != 0)
    {
        return HRESULT_FROM_WIN32(dwLastError);
    }
    else
    {
        return E_FAIL;
    }
}

IUnknown* QzAtlComPtrAssign(IUnknown** pp, IUnknown* lp)
{
    if (lp != NULL)
        lp->AddRef();
    if (*pp)
        (*pp)->Release();
    *pp = lp;
    return lp;
}

/******************************************************************************

CompatibleTimeSetEvent

    CompatibleTimeSetEvent() sets the TIME_KILL_SYNCHRONOUS flag before calling
timeSetEvent() if the current operating system supports it.  TIME_KILL_SYNCHRONOUS
is supported on Windows XP and later operating systems.

Parameters:
- The same parameters as timeSetEvent().  See timeSetEvent()'s documentation in 
the Platform SDK for more information.

Return Value:
- The same return value as timeSetEvent().  See timeSetEvent()'s documentation in 
the Platform SDK for more information.

******************************************************************************/
MMRESULT CompatibleTimeSetEvent( UINT uDelay, UINT uResolution, LPTIMECALLBACK lpTimeProc, DWORD_PTR dwUser, UINT fuEvent )
{
    #if WINVER >= 0x0501
    {
        static bool fCheckedVersion = false;
        static bool fTimeKillSynchronousFlagAvailable = false; 

        if( !fCheckedVersion ) {
            fTimeKillSynchronousFlagAvailable = TimeKillSynchronousFlagAvailable();
            fCheckedVersion = true;
        }

        if( fTimeKillSynchronousFlagAvailable ) {
            fuEvent = fuEvent | TIME_KILL_SYNCHRONOUS;
        }
    }
    #endif // WINVER >= 0x0501

    return timeSetEvent( uDelay, uResolution, lpTimeProc, dwUser, fuEvent );
}

bool TimeKillSynchronousFlagAvailable( void )
{
    OSVERSIONINFO osverinfo;

    osverinfo.dwOSVersionInfoSize = sizeof(osverinfo);

    if( GetVersionEx( &osverinfo ) ) {
        
        // Windows XP's major version is 5 and its' minor version is 1.
        // timeSetEvent() started supporting the TIME_KILL_SYNCHRONOUS flag
        // in Windows XP.
        if( (osverinfo.dwMajorVersion > 5) || 
            ( (osverinfo.dwMajorVersion == 5) && (osverinfo.dwMinorVersion >= 1) ) ) {
            return true;
        }
    }

    return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\dmodev\include\dmobase.h ===
//------------------------------------------------------------------------------
// File: DMOBase.h
//
// Desc: A collection of DMO base classes.
//
// Copyright (c) 1999-2001 Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


// Current hierarchy:
//
//   IMediaObject
//   |
//   +-- C1in1outDMO - generic base class for DMOs with 1 in and 1 out
//   |   |
//   |   +-- FBRDMO - base class for fixed sample size, fixed bitrate DMOs
//   |   |   |
//   |   |   +-- CPCMDMO - base class for PCM audio DMOs
//   |   |
//   |   +-- C1for1DMO - base class for single sample per buffer 1-in/1-out DMOs
//   |       |
//   |       +-- C1for1QCDMO - adds IDMOQualityControl to C1for1DMO
//   |
//   +-- CGenericDMO - resonably generic base class for multi-input/output DMOs
//

#ifndef __DMOBASE_H_
#define __DMOBASE_H_

#include "dmo.h"
#include "assert.h"
#include "math.h"

//
// locking helper class
//
#ifdef DMO_NOATL
class CDMOAutoLock {
public:
   CDMOAutoLock(CRITICAL_SECTION* pcs)
      : m_pcs(pcs)
   {
      EnterCriticalSection(m_pcs);
   }
   ~CDMOAutoLock() {
      LeaveCriticalSection(m_pcs);
   }
private:
   CRITICAL_SECTION* m_pcs;
};
#else
class CDMOAutoLock {
public:
   CDMOAutoLock(CComAutoCriticalSection* pcs)
      : m_pcs(pcs)
   {
      m_pcs->Lock();
   }
   ~CDMOAutoLock() {
      m_pcs->Unlock();
   }
private:
   CComAutoCriticalSection* m_pcs;
};
#endif


//
// C1in1outDMO - generic base class for 1-input/1-output DMOs.
//
//
//
// C1in1outDMO implements all IMediaObject methods.  The derived class
// customizes the DMO's behavior by overriding some or all of the following
// virtual functions:
//
// Main Streaming:
//    AcceptInput          // accept one new input buffer
//    ProduceOutput        // fill up one output buffer with new data
//    AcceptingInput       // check if DMO is ready for new input
// Other streaming:
//    PrepareForStreaming  // hook called after both types have been set
//    Discontinuity        // notify DMO of a discontinuity
//    DoFlush              // discard all data and start anew
// Mediatype negotiation:
//    GetInputType         // input type enumerator
//    GetOutputType        // output type enumerator
//    CheckInputType       // verifies proposed input type is acceptable
//    CheckOutputType      // verifies proposed output type is acceptable
// Buffer size negotiation:
//    GetInputFlags        // input data flow flags
//    GetOutputFlags       // output fata flow flags
//    GetInputSizeInfo     // input buffer size requirements
//    GetOutputSizeInfo    // output buffer size requirements
//
// This base class assumes that the derived class will not override any
// IMediaObject methods directly - the derived class should override the
// methods listed above instead.
//
//
//
// The base class provides a default implementation for each of the
// overridables listed above.  However, to make a useful DMO the derived class
// probably needs to override at least the following two methods:
//
//    HRESULT AcceptingInput();
//    HRESULT AcceptInput(BYTE* pData,
//                        ULONG ulSize,
//                        DWORD dwFlags,
//                        REFERENCE_TIME rtTimestamp,
//                        REFERENCE_TIME rtTimelength,
//                        IMediaBuffer* pMediaBuffer);
//    HRESULT ProduceOutput(BYTE *pData,
//                        ULONG ulAvail,
//                        ULONG* pulUsed,
//                        DWORD* pdwStatus,
//                        REFERENCE_TIME *prtTimestamp,
//                        REFERENCE_TIME *prtTimelength);
//
// All good DMOs should also override these (the default implementation
// simply accepts any mediatype, which in general is not good DMO behavior):
//
//    HRESULT GetInputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt);
//    HRESULT GetOutputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt);
//    HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt);
//    HRESULT CheckOutputType(const DMO_MEDIA_TYPE *pmt);
//
// DMOs that store data and/or state information may need to implement
//
//    HRESULT PrepareForStreaming();
//    HRESULT Discontinuity();
//    HRESULT Flush();
//
// Finally, DMOs that make any buffer size assumptions will need to override
// these:
//
//    HRESULT GetInputFlags(DWORD* pdwFlags);
//    HRESULT GetOutputFlags(DWORD* pdwFlags);
//    HRESULT GetInputSizeInfo(ULONG *pulSize, ULONG *pcbMaxLookahead, ULONG *pulAlignment);
//    HRESULT GetOutputSizeInfo(ULONG *pulSize, ULONG *pulAlignment);
//
//
//
// The following functions are provided by this base class exclusively for use
// by the derived class.  The derived class should call these to find out the
// currently set mediatype(s) whenever it needs to make a decision that
// depends on the mediatype used.  Each of these returns NULL if the mediatype
// has not been set yet.
//
//    DMO_MEDIA_TYPE *InputType();
//    DMO_MEDIA_TYPE *OutputType().
//

#define PROLOGUE \
    CDMOAutoLock l(&m_cs); \
    if (ulStreamIndex >= 1) \
       return DMO_E_INVALIDSTREAMINDEX

class C1in1outDMO : public IMediaObject
{
public:
    C1in1outDMO() :
       m_bInputTypeSet(FALSE),
       m_bOutputTypeSet(FALSE),
       m_bIncomplete(FALSE)
    {
#ifdef DMO_NOATL
       InitializeCriticalSection(&m_cs);
#endif
    }
    ~C1in1outDMO() {

       FreeInputType();
       FreeOutputType();

#ifdef DMO_NOATL
       DeleteCriticalSection(&m_cs);
#endif
    }

public:
    //
    // IMediaObject methods
    //
    STDMETHODIMP GetStreamCount(unsigned long *pulNumberOfInputStreams, unsigned long *pulNumberOfOutputStreams)
    {
        CDMOAutoLock l(&m_cs);
        if (pulNumberOfInputStreams == NULL ||
            pulNumberOfOutputStreams == NULL) {
            return E_POINTER;
        }
        *pulNumberOfInputStreams = 1;
        *pulNumberOfOutputStreams = 1;
        return S_OK;
    }
    STDMETHODIMP GetInputStreamInfo(ULONG ulStreamIndex, DWORD *pdwFlags)
    {
       if( NULL == pdwFlags ) {
          return E_POINTER;
       }

       PROLOGUE;
       return GetInputFlags(pdwFlags);
    }
    STDMETHODIMP GetOutputStreamInfo(ULONG ulStreamIndex, DWORD *pdwFlags)
    {
       if( NULL == pdwFlags ) {
          return E_POINTER;
       }

       PROLOGUE;
       return GetOutputFlags(pdwFlags);
    }
    STDMETHODIMP GetInputType(ULONG ulStreamIndex, ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
       PROLOGUE;
       return GetInputType(ulTypeIndex, pmt);
    }
    STDMETHODIMP GetOutputType(ULONG ulStreamIndex, ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
       PROLOGUE;
       return GetOutputType(ulTypeIndex, pmt);
    }
    STDMETHODIMP GetInputCurrentType(ULONG ulStreamIndex, DMO_MEDIA_TYPE *pmt) {
       PROLOGUE;

       if (m_bInputTypeSet)
           return MoCopyMediaType(pmt, &m_InputType);
       else
          return DMO_E_TYPE_NOT_SET;
    }
    STDMETHODIMP GetOutputCurrentType(ULONG ulStreamIndex, DMO_MEDIA_TYPE *pmt) {
       PROLOGUE;

       if (m_bOutputTypeSet)
           return MoCopyMediaType(pmt, &m_OutputType);
       else
          return DMO_E_TYPE_NOT_SET;
    }
    STDMETHODIMP GetInputSizeInfo(ULONG ulStreamIndex, ULONG *pulSize, ULONG *pcbMaxLookahead, ULONG *pulAlignment) {
        
       if( (NULL == pulSize) || (NULL == pcbMaxLookahead) || (NULL == pulAlignment) ) {
          return E_POINTER;
       }

       PROLOGUE;

       if (!m_bInputTypeSet)
          return DMO_E_TYPE_NOT_SET;
       return GetInputSizeInfo(pulSize, pcbMaxLookahead, pulAlignment);
    }
    STDMETHODIMP GetOutputSizeInfo(ULONG ulStreamIndex, ULONG *pulSize, ULONG *pulAlignment) {

       if( (NULL == pulSize) || (NULL == pulAlignment) ) {
          return E_POINTER;
       }

       PROLOGUE;

       if (!m_bOutputTypeSet)
          return DMO_E_TYPE_NOT_SET;
       return GetOutputSizeInfo(pulSize, pulAlignment);
    }
    STDMETHODIMP SetInputType(ULONG ulStreamIndex, const DMO_MEDIA_TYPE *pmt, DWORD dwFlags) {

       PROLOGUE;

       HRESULT hr = ValidateSetTypeParameters(pmt, dwFlags);
       if (FAILED(hr)) {
          return hr;
       }

       if (DMO_SET_TYPEF_CLEAR & dwFlags) {
          FreeInputType();
          return NOERROR;
       } else {
          hr = CheckInputType(pmt);
          if (FAILED(hr))
             return hr;

          if (dwFlags & DMO_SET_TYPEF_TEST_ONLY)
             return NOERROR;

          hr = AtomicCopyMediaType(pmt, &m_InputType, m_bInputTypeSet);
          if (FAILED(hr)) {
             return hr;
          }

          m_bInputTypeSet = TRUE;

          if (m_bOutputTypeSet) {
             hr = PrepareForStreaming();
             if (FAILED(hr)) {
                FreeInputType();
                return hr;
             }
          }

          return NOERROR;
       }
    }
    STDMETHODIMP SetOutputType(ULONG ulStreamIndex, const DMO_MEDIA_TYPE *pmt, DWORD dwFlags) {
        
       PROLOGUE;

       HRESULT hr = ValidateSetTypeParameters(pmt, dwFlags);
       if (FAILED(hr)) {
          return hr;
       }

       if (DMO_SET_TYPEF_CLEAR & dwFlags) {
          FreeOutputType();
          return NOERROR;
       } else {
           hr = CheckOutputType(pmt);
           if (FAILED(hr))
              return hr;

           if (dwFlags & DMO_SET_TYPEF_TEST_ONLY)
              return NOERROR;

           hr = AtomicCopyMediaType(pmt, &m_OutputType, m_bOutputTypeSet);
           if (FAILED(hr)) {
              return hr;
           }

           m_bOutputTypeSet = TRUE;

           if (m_bInputTypeSet) {
              hr = PrepareForStreaming();
              if (FAILED(hr)) {
                 FreeOutputType();
                 return hr;
              }
           }

           return NOERROR;
       }
    }
    STDMETHODIMP GetInputStatus(
        ULONG ulStreamIndex,
        DWORD *pdwStatus
    ) {

       if( NULL == pdwStatus ) {
          return E_POINTER;
       }

       PROLOGUE;

       *pdwStatus = 0;
       if (AcceptingInput() == S_OK)
          *pdwStatus |= DMO_INPUT_STATUSF_ACCEPT_DATA;
       return NOERROR;

    }
    STDMETHODIMP GetInputMaxLatency(unsigned long ulStreamIndex, REFERENCE_TIME *prtLatency) {
       return E_NOTIMPL;
    }
    STDMETHODIMP SetInputMaxLatency(unsigned long ulStreamIndex, REFERENCE_TIME rtLatency) {
       return E_NOTIMPL;
    }
    STDMETHODIMP Discontinuity(ULONG ulStreamIndex) {
       PROLOGUE;
       return Discontinuity();
    }

    STDMETHODIMP Flush()
    {
       CDMOAutoLock l(&m_cs);
       DoFlush();
       return NOERROR;
    }
    STDMETHODIMP AllocateStreamingResources() {return S_OK;}
    STDMETHODIMP FreeStreamingResources() {return S_OK;}

    //
    // Processing methods - public entry points
    //
    STDMETHODIMP ProcessInput(
        DWORD ulStreamIndex,
        IMediaBuffer *pBuffer, // [in], must not be NULL
        DWORD dwFlags, // [in] - discontinuity, timestamp, etc.
        REFERENCE_TIME rtTimestamp, // [in], valid if flag set
        REFERENCE_TIME rtTimelength // [in], valid if flag set
    ) {
       PROLOGUE;
       if (!TypesSet()) {
          return DMO_E_TYPE_NOT_SET;
       }
       if (AcceptingInput() != S_OK)
          return DMO_E_NOTACCEPTING;
       if (!pBuffer)
          return E_POINTER;

       // deal with the IMediaBuffer so the derived class doesn't have to
       BYTE *pData;
       ULONG ulSize;
       HRESULT hr = pBuffer->GetBufferAndLength(&pData, &ulSize);
       if (FAILED(hr))
          return hr;
       if (pData == NULL)
          ulSize = 0;

       m_bIncomplete = TRUE; // new input means we may be able to produce output

       return AcceptInput(pData, ulSize, dwFlags, rtTimestamp, rtTimelength, pBuffer);
    }

    STDMETHODIMP ProcessOutput(
                    DWORD dwReserved,
                    DWORD ulOutputBufferCount,
                    DMO_OUTPUT_DATA_BUFFER *pOutputBuffers,
                    DWORD *pdwStatus)
    {
       HRESULT hr;
       CDMOAutoLock l(&m_cs);

       if (pdwStatus == NULL) {
           return E_POINTER;
       }

       *pdwStatus = 0;

       if (ulOutputBufferCount != 1)
          return E_INVALIDARG;

       if (!TypesSet()) {
          return DMO_E_TYPE_NOT_SET;
       }

       pOutputBuffers[0].dwStatus = 0;

       // deal with the IMediaBuffer so the derived class doesn't have to
       BYTE *pOut;
       ULONG ulSize;
       ULONG ulAvail;

       if (pOutputBuffers[0].pBuffer) {
           hr = pOutputBuffers[0].pBuffer->GetBufferAndLength(&pOut, &ulSize);
           if (FAILED(hr)) return hr;
           hr = pOutputBuffers[0].pBuffer->GetMaxLength(&ulAvail);
           if (FAILED(hr)) return hr;

           if (ulSize) { // skip any already used portion of the buffer
              if (ulSize > ulAvail)
                 return E_INVALIDARG;
              ulAvail -= ulSize;
              pOut += ulSize;
           }
       }
       else { // no IMediaBuffer
           //
           // If (a) the output stream says it can operate without buffers, AND
           //    (b) the DISCARD flag was set in dwReserved,
           // then call ProduceOutput with a NULL output buffer pointer.
           //
           // Otherwise just return the INCOMPLETE flag without any processing.
           //
           DWORD dwFlags;
           if (SUCCEEDED(GetOutputFlags(&dwFlags)) &&
               ((dwFlags & DMO_OUTPUT_STREAMF_DISCARDABLE) ||
                (dwFlags & DMO_OUTPUT_STREAMF_OPTIONAL)
               ) &&
               (dwReserved & DMO_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER))
           { // process, but discard the output
               pOut = NULL;
               ulAvail = 0;
           }
           else { // just report the incomplete status without altering our state
              if (m_bIncomplete)
                 pOutputBuffers[0].dwStatus |= DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE;
              return NOERROR;
           }
       }

       ULONG ulProduced = 0;
       hr = ProduceOutput(pOut,
                          ulAvail,
                          &ulProduced,
                          &(pOutputBuffers[0].dwStatus),
                          &(pOutputBuffers[0].rtTimestamp),
                          &(pOutputBuffers[0].rtTimelength));
       if (FAILED(hr))
          return hr;

       HRESULT hrProcess = hr; // remember this in case it's S_FALSE

       // remember the DMO's incomplete status
       if (pOutputBuffers[0].dwStatus & DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE)
          m_bIncomplete = TRUE;
       else
          m_bIncomplete = FALSE;

       if (pOut) { // if using an output buffer, set the amount we used
           if (ulProduced > ulAvail)
              return E_FAIL;

           hr = pOutputBuffers[0].pBuffer->SetLength(ulSize + ulProduced);
           if (FAILED(hr))
              return hr;
       }

       return hrProcess;
    }
#ifdef FIX_LOCK_NAME
    STDMETHODIMP DMOLock(LONG lLock)
#else
    STDMETHODIMP Lock(LONG lLock)
#endif
    {
        if (lLock) {
#ifdef DMO_NOATL
            EnterCriticalSection(&m_cs);
#else
            m_cs.Lock();
#endif
        } 
        else 
        {
#ifdef DMO_NOATL
            LeaveCriticalSection(&m_cs);
#else
            m_cs.Unlock();
#endif
        }
        return S_OK;
    }

protected:
    HRESULT AtomicCopyMediaType(const DMO_MEDIA_TYPE *pmtSource, DMO_MEDIA_TYPE *pmtDestination, BOOL bDestinationInitialized) {

       // pmtDestination should always point to a valid DMO_MEDIA_TYPE structure.
       assert(NULL != pmtDestination);

       DMO_MEDIA_TYPE mtTempDestination;

       // actually set the type
       HRESULT hr = MoCopyMediaType(&mtTempDestination, pmtSource);
       if (FAILED(hr)) {
          return hr;
       }

       // Free any previous mediatype
       if (bDestinationInitialized) {
          MoFreeMediaType(pmtDestination);
       }

       *pmtDestination = mtTempDestination;

        return S_OK;
    }

    //
    // private methods for use by derived class
    //
    DMO_MEDIA_TYPE *InputType() {
       if (m_bInputTypeSet)
          return &m_InputType;
       else
          return NULL;
    }
    DMO_MEDIA_TYPE *OutputType() {
       if (m_bOutputTypeSet)
          return &m_OutputType;
       else
          return NULL;
    }

protected:
    //
    // To be overriden by the derived class
    //
    virtual HRESULT GetInputFlags(DWORD* pdwFlags) {
       *pdwFlags = 0; // default implementation assumes no lookahead
       return NOERROR;
    }
    virtual HRESULT GetOutputFlags(DWORD* pdwFlags) {
       *pdwFlags = 0;
       return NOERROR;
    }

    virtual HRESULT GetInputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
       return DMO_E_NO_MORE_ITEMS; // default implementation exposes no types
    }
    virtual HRESULT GetOutputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
       return DMO_E_NO_MORE_ITEMS; // default implementation exposes no types
    }
    virtual HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt) {
       if ((pmt == NULL) || ((pmt->cbFormat > 0) && (pmt->pbFormat == NULL)))
          return E_POINTER;
       return S_OK; // default implementation accepts anything
    }
    virtual HRESULT CheckOutputType(const DMO_MEDIA_TYPE *pmt) {
       if ((pmt == NULL) || ((pmt->cbFormat > 0) && (pmt->pbFormat == NULL)))
          return E_POINTER;
       return S_OK; // default implementation accepts anything
    }

    virtual HRESULT GetInputSizeInfo(ULONG *pulSize, ULONG *pcbMaxLookahead, ULONG *pulAlignment) {
       *pulSize = 1; // default implementation imposes no size requirements
       *pcbMaxLookahead = 0; // default implementation assumes no lookahead
       *pulAlignment = 1; // default implementation assumes no alignment
       return NOERROR;
    }
    virtual HRESULT GetOutputSizeInfo(ULONG *pulSize, ULONG *pulAlignment) {
       *pulSize = 1; // default implementation imposes no size requirements
       *pulAlignment = 1; // default implementation assumes no alignment
       return NOERROR;
    }

    virtual HRESULT PrepareForStreaming() {
       return NOERROR;
    }
    virtual HRESULT AcceptingInput() {
       return S_FALSE;
    }
    virtual HRESULT Discontinuity() {
       return NOERROR;
    }
    virtual HRESULT DoFlush() {
       return NOERROR;
    }

    virtual HRESULT AcceptInput(BYTE* pData,
                                ULONG ulSize,
                                DWORD dwFlags,
                                REFERENCE_TIME rtTimestamp,
                                REFERENCE_TIME rtTimelength,
                                IMediaBuffer* pMediaBuffer
    ) {
       m_bIncomplete = FALSE;
       return S_FALSE;
    }
    virtual HRESULT ProduceOutput(BYTE *pData,
                                  ULONG ulAvail,
                                  ULONG* pulUsed,
                                  DWORD* pdwStatus,
                                  REFERENCE_TIME *prtTimestamp,
                                  REFERENCE_TIME *prtTimelength
    ) {
       *pulUsed = 0;
       return S_FALSE;
    }

    HRESULT ValidateSetTypeParameters(const DMO_MEDIA_TYPE *pmt, DWORD dwFlags)
    {
       // Validate parameters.
       if (!(DMO_SET_TYPEF_CLEAR & dwFlags)) {
          // The DMO specification states that pmt CANNOT be NULL if
          // the DMO_SET_TYPEF_CLEAR flag is NOT set.
          if (NULL == pmt) {
             return E_POINTER;
          }
       }

       // The caller cannot set the DMO_SET_TYPEF_CLEAR flag and the 
       // DMO_SET_TYPEF_TEST_ONLY flag.  The DMO specification prohibits 
       // this combination because the two flags are mutually exclusive.
       if ((DMO_SET_TYPEF_CLEAR & dwFlags) && (DMO_SET_TYPEF_TEST_ONLY & dwFlags)) {
          return E_INVALIDARG;
       }

       // Check for illegal flags.
       if (~(DMO_SET_TYPEF_CLEAR | DMO_SET_TYPEF_TEST_ONLY) & dwFlags) {
            return E_INVALIDARG;
       }

       return S_OK;
    }

    bool TypesSet() {
        return m_bInputTypeSet && m_bOutputTypeSet;
    }

    void FreeInputType() {
       if (m_bInputTypeSet) {
          MoFreeMediaType( &m_InputType );
          m_bInputTypeSet = FALSE;
       }
    }

    void FreeOutputType() {
       if (m_bOutputTypeSet) {
          MoFreeMediaType( &m_OutputType );
          m_bOutputTypeSet = FALSE;
       }
    }

protected:
    // mediatype stuff
    BOOL m_bInputTypeSet;
    BOOL m_bOutputTypeSet;
    DMO_MEDIA_TYPE m_InputType;
    DMO_MEDIA_TYPE m_OutputType;

    BOOL m_bIncomplete;
protected:
#ifdef DMO_NOATL
    CRITICAL_SECTION m_cs;
#else
    CComAutoCriticalSection m_cs;
#endif
};



//
// C1for1DMO - base class for 1-input/1-output DMOs which
//  - work on whole samples at a time, one sample per buffer
//  - produce exactly one output sample for every input sample
//  - don't need to accumulate more than 1 input sample before producing
//  - don't produce any additional stuff at the end
//  - the output sample corresponds in time to the input sample
//
// The derived class must implement:
//    HRESULT Process(BYTE* pIn,
//                    ULONG ulBytesIn,
//                    BYTE* pOut,
//                    ULONG* pulProduced);
//    HRESULT GetSampleSizes(ULONG* pulMaxInputSampleSize,
//                           ULONG* pulMaxOutputSampleSize);
//
//
// The derived class should implement:
//    HRESULT GetInputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt);
//    HRESULT GetOutputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt);
//    HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt);
//    HRESULT CheckOutputType(const DMO_MEDIA_TYPE *pmt);
//
// The derived class may implement if it needs to:
//    HRESULT Init();
//
// The following methods are implemented by the base class.  The derived class
// should call these to find out if the input/output type has been set and if
// so what it was set to.
//    DMO_MEDIA_TYPE *InputType();
//    DMO_MEDIA_TYPE *OutputType().
//

class C1for1DMO : public C1in1outDMO
{
public:
    C1for1DMO() :
       m_pBuffer(NULL)
    {
    }
    ~C1for1DMO() {
       if (m_pBuffer)
          m_pBuffer->Release();
    }

protected:
    //
    // Implement C1in1outDMO overridables
    //
    virtual HRESULT GetInputFlags(DWORD* pdwFlags) {
       *pdwFlags = DMO_INPUT_STREAMF_WHOLE_SAMPLES |
                   DMO_INPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER;
       return NOERROR;
    }
    virtual HRESULT GetOutputFlags(DWORD* pdwFlags) {
       *pdwFlags = DMO_OUTPUT_STREAMF_WHOLE_SAMPLES |
                   DMO_OUTPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER;
       return NOERROR;
    }

    HRESULT GetInputSizeInfo(ULONG *pulSize, ULONG *pcbMaxLookahead, ULONG *pulAlignment) {
       HRESULT hr = GetSampleSizes(&m_ulMaxInputSize, &m_ulMaxOutputSize);
       if (FAILED(hr))
          return hr;

       *pulSize = m_ulMaxInputSize;
       *pcbMaxLookahead = 0;
       *pulAlignment = 1;
       return NOERROR;
    }
    HRESULT GetOutputSizeInfo(ULONG *pulSize, ULONG *pulAlignment) {
       HRESULT hr = GetSampleSizes(&m_ulMaxInputSize, &m_ulMaxOutputSize);
       if (FAILED(hr))
          return hr;

       *pulSize = m_ulMaxOutputSize;
       *pulAlignment = 1;
       return NOERROR;
    }
    HRESULT PrepareForStreaming() {
       HRESULT hr = GetSampleSizes(&m_ulMaxInputSize, &m_ulMaxOutputSize);
       if (FAILED(hr))
          return hr;

       return Init();
    }
    HRESULT AcceptingInput() {
       return m_pBuffer ? S_FALSE : S_OK; // accept unless holding one already
    }
    HRESULT AcceptInput(BYTE* pData,
                        ULONG ulSize,
                        DWORD dwFlags,
                        REFERENCE_TIME rtTimestamp,
                        REFERENCE_TIME rtTimelength,
                        IMediaBuffer* pMediaBuffer
    ) {
       if (AcceptingInput() != S_OK)
          return E_FAIL;
       m_pData        = pData;
       m_ulSize       = ulSize;
       m_dwFlags      = dwFlags;
       m_rtTimestamp  = rtTimestamp;
       m_rtTimelength = rtTimelength;
       m_pBuffer      = pMediaBuffer;
       pMediaBuffer->AddRef();
       return NOERROR;
    }
    HRESULT DoFlush() {
        Discontinuity();
        if (m_pBuffer) {
            m_pBuffer->Release();
            m_pBuffer = NULL;
        }
        return NOERROR;
    }
    HRESULT ProduceOutput(BYTE *pOut,
                          ULONG ulAvail,
                          ULONG* pulUsed,
                          DWORD* pdwStatus,
                          REFERENCE_TIME *prtTimestamp,
                          REFERENCE_TIME *prtTimelength
    ) {
       *pulUsed = 0;
       *pdwStatus = 0;

       if (!m_pBuffer)
          return S_FALSE;

       if (pOut) {
          if (ulAvail < m_ulMaxOutputSize)
             return E_INVALIDARG;
       }

       HRESULT hr = Process(m_pData, m_ulSize, pOut, pulUsed);

       m_pBuffer->Release();
       m_pBuffer = NULL;

       if (FAILED(hr))
          return hr;

       if (*pulUsed == 0)
          return S_FALSE;

       if (m_dwFlags & DMO_INPUT_DATA_BUFFERF_SYNCPOINT)
          *pdwStatus |= DMO_OUTPUT_DATA_BUFFERF_SYNCPOINT;
       if (m_dwFlags & DMO_INPUT_DATA_BUFFERF_TIME)
          *pdwStatus |= DMO_OUTPUT_DATA_BUFFERF_TIME;
       if (m_dwFlags & DMO_INPUT_DATA_BUFFERF_TIMELENGTH)
          *pdwStatus |= DMO_OUTPUT_DATA_BUFFERF_TIMELENGTH;
       *prtTimestamp = m_rtTimestamp;
       *prtTimelength = m_rtTimelength;

       return hr;
    }
protected:
    //
    // To be implemented by derived class
    //
    virtual HRESULT Process(BYTE* pIn,
                            ULONG ulBytesIn,
                            BYTE* pOut,
                            ULONG* pulProduced) = 0;
    virtual HRESULT GetSampleSizes(ULONG* pulMaxInputSampleSize,
                                   ULONG* pulMaxOutputSampleSize) = 0;
    virtual HRESULT Init() {
       return NOERROR;
    }

   IMediaBuffer* m_pBuffer;
   BYTE* m_pData;
   ULONG m_ulSize;
   DWORD m_dwFlags;
   REFERENCE_TIME m_rtTimestamp;
   REFERENCE_TIME m_rtTimelength;

   ULONG m_ulMaxOutputSize;
   ULONG m_ulMaxInputSize;
};

//
// C1for1QCDMO - adds an IDMOQualityControl implementation to C1for1DMO. Just like
// C1for1DMO, this base class assumes that the DMO produces exactly one output sample
// for each input sample, etc. etc.
//
// A class that derives from C1for1QCDMO has access to / ability to override all
// the same methods as with C1for1DMO, except
//   (1) A class derived from C1for1QCDMO should override QCProcess instead of
//       Process because C1for1QCDMO::Process implements some code required for
//       quality control.  QCProcess has the same prototype as C1for1DMO::Process.
//   (2) If a class derived from C1for1QCDMO overrides Init(), it should at some
//       point call C1for1QCDMO::Init() to make sure C1for1QCDMO's quality control
//       data members are properly initialized.
//
class C1for1QCDMO : public C1for1DMO, public IDMOQualityControl {
public:
   //
   // IDMOQualityControl
   //
   STDMETHODIMP SetNow(REFERENCE_TIME rtNow) {
      // Remember SetNow values even if quality control is not currently enabled
      DWORD dwTicks = GetTickCount();
      CDMOAutoLock l(&m_cs);
      m_rtNow = rtNow;
      m_dwNow = dwTicks;
      return NOERROR;
   }
   STDMETHODIMP SetStatus(DWORD dwFlags) {
      // Any point in grabbing the object lock here ?
      if (dwFlags & DMO_QUALITY_STATUS_ENABLED)
         m_bQualityControlEnabled = TRUE;
      else
         m_bQualityControlEnabled = FALSE;
      return NOERROR;
   }
   STDMETHODIMP GetStatus(DWORD *pdwFlags) {
      // Any point in grabbing the object lock here ?
      if (m_bQualityControlEnabled)
         *pdwFlags = DMO_QUALITY_STATUS_ENABLED;
      else
         *pdwFlags = 0;
      return NOERROR;
   }

protected:
   HRESULT Init() {
      m_bQualityControlEnabled = FALSE;
      m_rtProcess = 100000; // 10 ms - initial guess at processing time
      return NOERROR;
   }

   // Override Process to add quality control
   HRESULT Process(BYTE* pIn,ULONG ulBytesIn,BYTE* pOut,ULONG* pulProduced) {
      // Skip the sample if it is likely to be late.
      if (m_bQualityControlEnabled &&
          (m_dwFlags & DMO_INPUT_DATA_BUFFERF_TIME) &&   // timestamp present
          (m_rtNow + (GetTickCount() - m_dwNow) * 10000 + m_rtProcess > m_rtTimestamp + 0000000)) {
         *pulProduced = 0;
         return S_FALSE;
      }

      DWORD dwBefore = GetTickCount();
      HRESULT hr = QCProcess(m_pData, m_ulSize, pOut, pulProduced);
      DWORD dwAfter = GetTickCount();

      // Make the new m_rtProcess a weighted average of the old m_rtProcess
      // and the value we just got.  0.8 and 0.2 give a time constant of about 4,
      // and it takes about 10 iterations to reach 90% - seems reasonable, but
      // I don't know what the optimal value is.
      m_rtProcess = (REFERENCE_TIME)(0.8 * m_rtProcess + 0.2 * (((REFERENCE_TIME)(dwAfter - dwBefore)) * 10000));
      return hr;
   }

   // To be implemented by derived class
   virtual HRESULT QCProcess(BYTE* pIn,
                             ULONG ulBytesIn,
                             BYTE* pOut,
                             ULONG* pulProduced) = 0;

private:
   // variables used by quality control code
   BOOL m_bQualityControlEnabled;
   REFERENCE_TIME m_rtNow;
   DWORD m_dwNow;
   REFERENCE_TIME m_rtProcess; // average processing delay
};

//
// CFBRDMO - DMO base class for 'fixed bitrate' DMOs.  More specifically,
// this base class assumes the following:
//  - 1 input, 1 output;
//  - both input and output consist of equally sized 'quanta';
//  - input/output quantum sizes can be determined from mediatypes;
//  - each output quantum can be generated independently (without looking at
//     previous output quanta);
//  - if multiple input quanta are needed to generate a particular output
//     quantum ('window overhead'), then the range of input required has an upper
//     bound derived from mediatypes on both sides (i.e., both 'lookahead'
//     and 'input memory' are bounded).
//
// The derived class must implement the following virtual functions:
//    HRESULT FBRProcess(DWORD cQuanta, BYTE *pIn, BYTE *pOut);
//    HRESULT GetStreamingParams(
//       DWORD *pdwInputQuantumSize, // in bytes
//       DWORD *pdwOutputQuantumSize, // in bytes
//       DWORD *pdwMaxLookahead, // in input quanta, 0 means no lookahead
//       DWORD *pdwLookBehind,
//       REFERENCE_TIME *prtQuantumDuration, // same for input and output quanta
//       REFERENCE_TIME *prtDurationDenominator // optional, normally 1
//    );
// The derived class should also implement the following:
//    HRESULT GetInputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt);
//    HRESULT GetOutputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt);
//    HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt);
//    HRESULT CheckOutputType(const DMO_MEDIA_TYPE *pmt);
// The derived class may need to implement the followng:
//    HRESULT Init();
//    HRESULT Discontinuity();
//
// The derived class may use these entry points into the base class to get
// the currently set mediatypes:
//    DMO_MEDIA_TYPE *InputType();
//    DMO_MEDIA_TYPE *OutputType().
//
// The sum of *pdwMaxLookahead and *pdwLoookbehind is the 'window overhead' of
// the algorithm (the window overhead is 0 if the algorithm only needs the
// current input sample).
//
// Because the non-zero window overhead case is more complicated, it is handled by a
// separate set of functions in this base class.  The names of all non-zero
// window overhead functions have the 'NZWO' prefix.  The names of the
// zero window overhead functions begin with 'ZWO'.
//
// A data copy on the input side is necessary in the non-zero window overhead case.
//

class CFBRDMO : public C1in1outDMO
{
public:
    CFBRDMO() :
       m_bParametersSet(FALSE),
       m_pMediaBuffer(NULL),
       m_pAllocAddr(NULL),
       m_bStreaming(FALSE)
    {
    }
    ~CFBRDMO() {
       /*
       if (m_bStreaming)
          StopStreaming();
       */
       if (m_pAllocAddr)
          delete[] m_pAllocAddr;
       if (m_pMediaBuffer)
          m_pMediaBuffer->Release();
    }

protected:
    //
    // Implement C1in1outDMO overridables
    //
    HRESULT GetInputSizeInfo(ULONG *pulSize, ULONG *pcbMaxLookahead, ULONG *pulAlignment) {
       if (!(InputType() && OutputType()))
          return DMO_E_TYPE_NOT_SET;
       //
       // For efficiency reasons we might like to be fed fairly large amounts
       // of data at a time, but technically all we need is one quantum.
       //
       *pulSize = m_ulInputQuantumSize;
       *pcbMaxLookahead = 0; // this base class does not rely on HOLDS_BUFFERS
       *pulAlignment = 1;
       return NOERROR;
    }
    HRESULT GetOutputSizeInfo(ULONG *pulSize, ULONG *pulAlignment) {
       if (!(InputType() && OutputType()))
          return DMO_E_TYPE_NOT_SET;
       *pulSize = m_ulOutputQuantumSize;
       *pulAlignment = 1;
       return NOERROR;
    }

    virtual HRESULT Discontinuity() {
       m_bDiscontinuity = TRUE;
       return NOERROR;
    }

    virtual HRESULT AcceptInput(BYTE* pData,
                                ULONG ulSize,
                                DWORD dwFlags,
                                REFERENCE_TIME rtTimestamp,
                                REFERENCE_TIME rtTimelength,
                                IMediaBuffer* pBuffer
    ) {
       BOOL bTimestamp = (dwFlags & DMO_INPUT_DATA_BUFFERF_TIME) ? TRUE : FALSE;

       if (m_ulWindowOverhead)
          return NZWOProcessInput(pBuffer, pData, ulSize, bTimestamp, rtTimestamp);
       else
          return ZWOProcessInput(pBuffer, pData, ulSize, bTimestamp, rtTimestamp);
    }
    virtual HRESULT ProduceOutput(BYTE *pOut,
                                  ULONG ulAvail,
                                  ULONG* pulUsed,
                                  DWORD* pdwStatus,
                                  REFERENCE_TIME *prtTimestamp,
                                  REFERENCE_TIME *prtTimelength
    ) {
       HRESULT hr;
       if (!m_bParametersSet)
          return DMO_E_TYPE_NOT_SET;

       // call Discontinuity() if this is the first ProcessOutput() call
       if (!m_bStreaming) {
          HRESULT hr = Discontinuity();
          if (FAILED(hr))
             return hr;
          m_bStreaming = TRUE;
       }

       *pdwStatus = 0;

       ULONG ulInputQuantaAvailable = InputQuantaAvailable();
       if (!ulInputQuantaAvailable)
          return S_FALSE; // did not produce anything

       ULONG ulOutputQuantaPossible = ulAvail / m_ulOutputQuantumSize;
       if (!ulOutputQuantaPossible)
          return E_INVALIDARG;

       ULONG ulQuantaToProcess = min(ulOutputQuantaPossible, ulInputQuantaAvailable);
       assert(ulQuantaToProcess > 0);

       BOOL bTimestamp;
       if (m_ulWindowOverhead)
          hr = NZWOProcessOutput(pOut, ulQuantaToProcess, &bTimestamp, prtTimestamp);
       else
          hr = ZWOProcessOutput(pOut, ulQuantaToProcess, &bTimestamp, prtTimestamp);
       if (FAILED(hr))
          return hr;

       *pulUsed = ulQuantaToProcess * m_ulOutputQuantumSize;

       *pdwStatus |= DMO_OUTPUT_DATA_BUFFERF_SYNCPOINT;
       if (bTimestamp)
          *pdwStatus |= DMO_OUTPUT_DATA_BUFFERF_TIME;

       // any data left ?
       if (InputQuantaAvailable()) // yes - set incomplete
          *pdwStatus |= DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE;
       else if (m_bDiscontinuity) // no - process any discontinuity
          DoFlush();

       return NOERROR;
    }
    HRESULT DoFlush()
    {
       Discontinuity();

       // reset flags
       m_bDiscontinuity = FALSE;
       m_bTimestamps = FALSE;

       if (m_ulWindowOverhead)
          NZWODiscardData();
       else
          ZWODiscardData();

       return NOERROR;
    }
    HRESULT AcceptingInput() {
       if (!m_bParametersSet) // uninitialized
          return S_FALSE;

       BOOL bResult;
       if (m_ulWindowOverhead)
          bResult = NZWOQueryAccept();
       else
          bResult = ZWOQueryAccept();

       return bResult ? S_OK : S_FALSE;
    }
    // End C1in1out overridables implementation

private:
    //
    // Common private code (window overhead or no window overhead)
    //
    // returns the number of input quanta available minus any window overhead
    ULONG InputQuantaAvailable() {
       if (m_ulWindowOverhead)
          return NZWOAvail();
       else
          return ZWOAvail();
    }

    // Private method to compute/allocate stuff once all types have been set.
    HRESULT PrepareForStreaming () {
       m_bParametersSet = FALSE;
       // Now that both types are set, query the derived class for params
       HRESULT hr;
       if (FAILED(hr = GetStreamingParams(&m_ulInputQuantumSize,
                               &m_ulOutputQuantumSize,
                               &m_ulLookahead,
                               &m_ulLookbehind,
                               &m_rtDurationNumerator,
                               &m_rtDenominator)))
          return hr;

       // m_ulOutputQuantumSize and m_ulInputQuantumSize should never be 0.
       assert( (0 != m_ulInputQuantumSize) && (0 != m_ulOutputQuantumSize) );

       if (!m_rtDenominator) {
          assert(!"bad object - duration denominator should not be 0 !");
          return E_FAIL;
       }
       // Attempt to reduce the fraction.  Probably the most complicated number
       // we will ever see is 44100 = (3 * 7 * 2 * 5) ^ 2, so trying the first
       // few numbers should suffice in most cases.
       DWORD dwP[] = {2,3,5,7,11,13,17,19,23,29,31};
       for (DWORD c = 0; c < sizeof(dwP) / sizeof(DWORD); c++) {
          while ((m_rtDurationNumerator % dwP[c] == 0) &&
                 (m_rtDenominator % dwP[c] == 0)) {
             m_rtDurationNumerator /= dwP[c];
             m_rtDenominator /= dwP[c];
          }
       }

       // We cannot afford to have huge denominators, unfortunately, because
       // we store timestamp numerators using 64 bits, so a large denominator
       // could result in timestamp overflows.  So if the denominator is still
       // too large, reduce it anyway with loss of precision.
       ULONG ulMax = 0x10000; // largest acceptable denominator value
       if (m_rtDenominator >= ulMax) {
          double actual_ratio = (double)m_rtDurationNumerator * (double)m_rtDenominator;
          ULONG ulDenominator = 1;
          // Repeatedly increase the denominator until either the actual ratio
          // can be represented precisely using the denominator, or the
          // denominator gets too large.
          do {
             double fractional_part = actual_ratio * (double)ulDenominator
                                    - floor(actual_ratio * (double)ulDenominator);
             if (fractional_part == 0)
                break;
             ULONG ulNewDenominator = (ULONG)floor(ulDenominator / fractional_part);
             if (ulNewDenominator >= ulMax)
                break;
             ulDenominator = ulNewDenominator;
          } while(1);
          m_rtDurationNumerator = (ULONG)floor(actual_ratio * ulDenominator);
          m_rtDenominator = ulDenominator;
       }

       m_ulWindowOverhead = m_ulLookahead + m_ulLookbehind;
       if (!m_ulWindowOverhead) // No window overhead - the simple case
          m_bParametersSet = TRUE;
       else // The complicated case with window overhead
          AllocateCircularBuffer();

       m_bTimestamps = FALSE;
       m_bDiscontinuity = FALSE;

       if (m_bStreaming) {
          //StopStreaming();
          m_bStreaming = FALSE;
       }
       
       hr = Init();
       if( FAILED( hr ) ) {
          m_bParametersSet = FALSE;
          return hr;
       }

       return m_bParametersSet ? NOERROR : E_FAIL;
    }
    // end common code

    //
    // zero window overhead case code
    //
    HRESULT ZWOProcessInput(IMediaBuffer* pBuffer,
                                     BYTE* pData,
                                     ULONG ulSize,
                                     BOOL bTimestamp,
                                     REFERENCE_TIME rtTimestamp) {
       assert(!m_pMediaBuffer);

       m_bTimestamp = bTimestamp;
       m_rtTimestamp = rtTimestamp;
       m_pData = pData;
       m_ulData = ulSize;
       m_ulUsed = 0;

       // make sure they gave us a meaningful amount of data
       if (m_ulData < m_ulInputQuantumSize)
          return S_FALSE;

       // save the buffer we were given
       m_pMediaBuffer = pBuffer;
       pBuffer->AddRef();
       return NOERROR;
    }
    HRESULT ZWOProcessOutput(BYTE* pOut,
                                      ULONG ulQuantaToProcess,
                                      BOOL* pbTimestamp,
                                      REFERENCE_TIME* prtTimestamp) {
       assert(m_ulUsed % m_ulInputQuantumSize == 0);
       HRESULT hr = FBRProcess(ulQuantaToProcess, m_pData + m_ulUsed, pOut);
       if (FAILED(hr)) return hr;
       ZWOConsume(ulQuantaToProcess);

       if (m_bTimestamp) { // there was a timestamp on this input buffer
          // m_rtTimestamp refers to the beginning of the input buffer.
          // Extrapolate to the beginning of the area we just processed.
          *prtTimestamp = m_rtTimestamp +
               (m_ulUsed % m_ulInputQuantumSize) * m_rtDurationNumerator /
                                                   m_rtDenominator;
          *pbTimestamp = TRUE;
       }
       else if (m_bTimestamps) { // there was a timestamp earlier
          // should we extrapolate from a previous timestamp ?
          *pbTimestamp = FALSE;
       }
       else // no timestamps at all
          *pbTimestamp = FALSE;

       return NOERROR;
    }
    ULONG ZWOAvail() {
       if (m_pMediaBuffer) {
          assert(m_ulData - m_ulUsed >= m_ulInputQuantumSize);
          return (m_ulData - m_ulUsed) / m_ulInputQuantumSize;
       }
       else
          return 0;
    }
    void ZWOConsume(ULONG ulN) { // the zero window overhead version
       assert(m_pMediaBuffer);
       m_ulUsed += ulN * m_ulInputQuantumSize;
       assert(m_ulData >= m_ulUsed);
       if (m_ulData - m_ulUsed < m_ulInputQuantumSize) {
          m_pMediaBuffer->Release();
          m_pMediaBuffer = NULL;
       }
    }
    BOOL ZWOQueryAccept() {
        // Accept if and only if (IFF) the DMO is not already holding a buffer.
       if (!m_pMediaBuffer)
          return TRUE;
       else
          return FALSE;
    }
    void ZWODiscardData() {
       if (m_pMediaBuffer) {
          m_pMediaBuffer->Release();
          m_pMediaBuffer = NULL;
       }
    }
    // End zero window overhead case code

    //
    // Non zero window overhead case code.
    //
    HRESULT NZWOProcessInput(IMediaBuffer* pBuffer,
                                  BYTE* pData,
                                  ULONG ulSize,
                                  BOOL bTimestamp,
                                  REFERENCE_TIME rtTimestamp) {
       if (bTimestamp) { // process the timestamp
          if (!m_bTimestamps) { // this is the first timestamp we've seen
             // Just getting started - initialize the timestamp to refer to
             // the first input quantum for which we will actually generate
             // output (the first m_ulLookbehind quanta are pure lookbehind and
             // generate no output).
             m_rtTimestampNumerator = rtTimestamp * m_rtDenominator
                                    + m_ulLookbehind * m_rtDurationNumerator;

          }
          else {
             // We are already streaming and just got a new timestamp.  Use it
             // to check if our stored timestamp has somehow drifted away from
             // where it should be and adjust if it is far enough off.

             ULONG ulInputQuantaAvailable = InputQuantaAvailable();
             if (ulInputQuantaAvailable) {
                // ulInputQuantaAvailable is how far back in time the next
                // quantum we would process is located relative the beginning
                // of the new buffer we just received.

                // Compute what the timestamp back there ought to be now.
                REFERENCE_TIME rtTimestampNumerator;
                rtTimestampNumerator = m_rtDenominator * rtTimestamp
                                     - ulInputQuantaAvailable * m_rtDurationNumerator;

                // Adjust the stored timestamp if it is off by more than half
                // the duration of a quantum.  Should also have a DbgLog here.
                if ((m_rtTimestampNumerator >= rtTimestampNumerator + m_rtDurationNumerator / 2) ||
                    (m_rtTimestampNumerator <= rtTimestampNumerator - m_rtDurationNumerator / 2)) {
                   m_rtTimestampNumerator = rtTimestampNumerator;
                }
             }
             else {
                // We must still be accumulating the initial window overhead.
                // Too early to need an adjustment, one would hope.
             }
          }
          m_bTimestamps = TRUE;
       }

       if (BufferUsed() + ulSize > m_ulBufferAllocated)
          return E_FAIL; // need a max input size to prevent this

       // append to our buffer
       AppendData(pData, ulSize);

       // are we ready to produce now ?
       if (NZWOAvail())
          return NOERROR;
       else
          return S_FALSE; // no output can be produced yet
    }
    HRESULT NZWOProcessOutput(BYTE* pOut,
                                   ULONG ulQuantaToProcess,
                                   BOOL* pbTimestamp,
                                   REFERENCE_TIME* prtTimestamp) {
       //
       // Handle any timestamps
       //
       if (m_bTimestamps) {
          // In window overhead mode the stored timestamp refers to the input
          // data immediately after lookbehind, which corresponds to the
          // begining of the output buffer by definition of FDRProcess.
          *prtTimestamp = m_rtTimestampNumerator / m_rtDenominator;
          *pbTimestamp = TRUE;

       }
       else
          *pbTimestamp = FALSE;

       //
       // Handle the data
       //
       HRESULT hr;
       ULONG ulInputNeeded = m_ulInputQuantumSize * (ulQuantaToProcess + m_ulWindowOverhead);
       assert(ulInputNeeded < BufferUsed());
       if (m_ulDataHead + ulInputNeeded <= m_ulBufferAllocated) {
          // No wraparound, everything is easy
          hr = FBRProcess(ulQuantaToProcess,
                          m_pCircularBuffer + m_ulDataHead + m_ulLookbehind * m_ulInputQuantumSize,
                          pOut);
          if (FAILED(hr))
             return hr;
          NZWOConsume(ulQuantaToProcess);
       }
       else { // The data we want to send wraps around the end
          // Q.: does it wrap around inside the window overhead area
          // or inside the main data area ?
          if (m_ulDataHead + m_ulWindowOverhead * m_ulInputQuantumSize < m_ulBufferAllocated) {
             // The wraparound occurs inside the main data area.  Advance the
             // window overhead up to the wraparound point by processing some data.
             ULONG ulAdvance = m_ulBufferAllocated - (m_ulDataHead + m_ulWindowOverhead * m_ulInputQuantumSize);
             assert(ulAdvance % m_ulInputQuantumSize == 0);
             ulAdvance /= m_ulInputQuantumSize; // convert to quanta
             assert(ulAdvance > 0);
             assert(ulAdvance < ulQuantaToProcess);
             hr = FBRProcess(ulAdvance,
                             m_pCircularBuffer + m_ulDataHead + m_ulLookbehind * m_ulInputQuantumSize,
                             pOut);
             if (FAILED(hr))
                return hr;
             NZWOConsume(ulAdvance);

             // Adjust stuff so that the code below can act
             // as if this extra process call never happened.
             pOut += m_ulOutputQuantumSize * ulAdvance;
             ulQuantaToProcess -= ulAdvance;
             assert(ulQuantaToProcess > 0);

             // Now the wraparound point should be exactly on the boundary
             // between window overhead and main data.
             assert(m_ulDataHead + m_ulWindowOverhead * m_ulInputQuantumSize == m_ulBufferAllocated);
          } // wraparound in main data

          // When we get here, the wraparound point occurs somewhere inside
          // the window overhead area or right on the border between window overhead and
          // main data.
          assert(m_ulDataHead + m_ulWindowOverhead * m_ulInputQuantumSize >= m_ulBufferAllocated);
          ULONG ulLookaheadToCopy = m_ulBufferAllocated - m_ulDataHead;

          // copy to the special area we reserved at the front
          memcpy(m_pCircularBuffer - ulLookaheadToCopy,
                 m_pCircularBuffer + m_ulDataHead,
                 ulLookaheadToCopy);

          // Now the block we are interested in is all in one piece
          hr = FBRProcess(ulQuantaToProcess,
                          m_pCircularBuffer - ulLookaheadToCopy  + m_ulLookbehind * m_ulInputQuantumSize,
                          pOut);
          if (FAILED(hr))
             return hr;
          NZWOConsume(ulQuantaToProcess);
       } // data handling - wraparound case
       return NOERROR;
    }
    void AllocateCircularBuffer() {
       // free any previously allocated input buffer
       if (m_pAllocAddr)
          delete[] m_pAllocAddr;

       // need a better way to decide this number
       m_ulBufferAllocated = max(m_ulInputQuantumSize * 16, 65536L);
       m_ulDataHead = m_ulDataTail = 0;

       // reserve room at the front for copying window overhead
       ULONG ulPrefix = m_ulWindowOverhead * m_ulInputQuantumSize;
       m_pAllocAddr = new BYTE[m_ulBufferAllocated + ulPrefix];
       if (!m_pAllocAddr)
          return;
       m_pCircularBuffer = m_pAllocAddr + ulPrefix;

       m_bParametersSet = TRUE;
    }
    BOOL NZWOQueryAccept() {
       // We are using a temp input buffer.  Is there room to append more ?
       // The answer really depends on how much data they will try to feed
       // us.  Without knowing the maximum input buffer size, we will accept
       // more if the input buffer is less than half full.
       if (2 * BufferUsed() < m_ulBufferAllocated)
          return TRUE;
       else
          return FALSE;
    }
    ULONG NZWOAvail() {
       ULONG ulInputQuantaAvailable = BufferUsed() / m_ulInputQuantumSize;
       if (ulInputQuantaAvailable > m_ulWindowOverhead)
          return ulInputQuantaAvailable - m_ulWindowOverhead;
       else
          return 0;
    }
    void NZWOConsume(ULONG ulN) { // the window overhead version
       assert(ulN * m_ulInputQuantumSize <= BufferUsed());
       m_ulDataHead += ulN * m_ulInputQuantumSize;
       if (m_ulDataHead > m_ulBufferAllocated) //wraparound
          m_ulDataHead -= m_ulBufferAllocated;

       // Advance the timestamp.
       // The same denominator is used for both timestamp and duration.
       m_rtTimestampNumerator += ulN * m_rtDurationNumerator;
    }
    ULONG BufferUsed() {
       if (m_ulDataTail >= m_ulDataHead)
          return m_ulDataTail - m_ulDataHead;
       else
          return m_ulBufferAllocated - (m_ulDataHead - m_ulDataTail);
    }
    void AppendData(BYTE *pData, ULONG ulSize) {
       if (m_ulDataTail + ulSize <= m_ulBufferAllocated) { // no wraparound
          memcpy(m_pCircularBuffer + m_ulDataTail, pData, ulSize);
		  m_ulDataTail += ulSize;
       }
       else { // wraparound
          memcpy(m_pCircularBuffer + m_ulDataTail, pData, m_ulBufferAllocated - m_ulDataTail);
          memcpy(m_pCircularBuffer, pData + m_ulBufferAllocated - m_ulDataTail, ulSize - (m_ulBufferAllocated - m_ulDataTail));
		  m_ulDataTail += ulSize;
		  m_ulDataTail -= m_ulBufferAllocated;
       }
    }
    void NZWODiscardData() {
       m_ulDataHead = m_ulDataTail = 0;
    }
    // End window overhead case code


protected:
    //
    // To be implemebted by the derived class
    //
    virtual HRESULT FBRProcess(DWORD cQuanta, BYTE *pIn, BYTE *pOut) = 0;
    virtual HRESULT GetStreamingParams(
                       DWORD *pdwInputQuantumSize, // in bytes
                       DWORD *pdwOutputQuantumSize, // in bytes
                       DWORD *pdwMaxLookahead, // in input quanta, 0 means no lookahead
                       DWORD *pdwLookbehind,
                       REFERENCE_TIME *prtQuantumDuration, // same for input and output quanta
                       REFERENCE_TIME *prtDurationDenominator // optional, normally 1
                    ) = 0;
    virtual HRESULT Init() {
       return NOERROR;
    }

private:

    BOOL m_bNewInput;

    // streaming parameters
    BOOL m_bParametersSet;
    ULONG m_ulInputQuantumSize;
    ULONG m_ulOutputQuantumSize;
    ULONG m_ulLookahead;
    ULONG m_ulLookbehind;
    ULONG m_ulWindowOverhead;
    REFERENCE_TIME m_rtDurationNumerator;
    REFERENCE_TIME m_rtDenominator;

    // streaming state
    BOOL m_bTimestamps; // we have seen at least one timestamp
    BOOL m_bDiscontinuity;
    BOOL m_bStreaming;

    // zero window overhead case input data
    IMediaBuffer *m_pMediaBuffer;
    BYTE *m_pData;
    ULONG m_ulData;
    ULONG m_ulUsed;
    BOOL m_bTimestamp; // timestamp on current buffer
    REFERENCE_TIME m_rtTimestamp;

    // window overhead case input data
    BYTE *m_pCircularBuffer;
    BYTE *m_pAllocAddr;
    ULONG m_ulBufferAllocated;
    ULONG m_ulDataHead;
    ULONG m_ulDataTail;
    REFERENCE_TIME m_rtTimestampNumerator; // uses the same denominator as duration

};


// CPCMDMO - base class for PCM audio transform filters.
// Helps non-converting PCM audio transforms with mediatype negotiation.
// Based on CFBRDMO - study that first.
//
// Derived class must implement:
//     FBRProcess()
// Deriver class may implement:
//   Discontinuity() // default implementaion does nothing
//   Init()          // default implementaion does nothing
//   GetPCMParams()    // default implementation proposes 44100/2/16
//   CheckPCMParams()  // default implementation accepts any 8/16 bit format
//   GetWindowParams()   // default implementation assumes no lookahead/lookbehind
//
// This class conveniently provides the following data members accessible
// by the derived class:
//   ULONG m_ulSamplingRate
//   ULONG m_cChannels
//   BOOL m_b8bit
//
#include <mmreg.h>
#include <uuids.h>

class CPCMDMO : public CFBRDMO
{
protected:
   //
   // implement pure virtual CFBRDMO methods
   //
   HRESULT GetInputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
      if (ulTypeIndex > 0)
         return DMO_E_NO_MORE_ITEMS;
      if (pmt != NULL) {
         HRESULT hr = GetType(pmt, OutputType());
         if (FAILED(hr)) {
            return hr;
         }
      }

      return S_OK;
   }
   HRESULT GetOutputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
      if (ulTypeIndex > 0)
         return DMO_E_NO_MORE_ITEMS;
      if (pmt != NULL) {
         HRESULT hr = GetType(pmt, InputType());
         if (FAILED(hr)) {
            return hr;
         }
      }

      return S_OK;
   }
   HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt) {
      return CheckType(pmt, OutputType());
   }
   HRESULT CheckOutputType(const DMO_MEDIA_TYPE *pmt) {
      return CheckType(pmt, InputType());
   }
   HRESULT Init() {
      return NOERROR;
   }
   HRESULT Discontinuity() {
      return NOERROR;
   }
   HRESULT GetStreamingParams(
              DWORD *pdwInputQuantumSize, // in bytes
              DWORD *pdwOutputQuantumSize, // in bytes
              DWORD *pdwMaxLookahead, // in input quanta, 0 means no lookahead
              DWORD *pdwMaxLookbehind,
              REFERENCE_TIME *prtQuantumDuration, // same for input and output quanta
              REFERENCE_TIME *prtDurationDenominator // optional, normally 1
           ) {
      // Sanity check: all of this should have been taken care of by base class
      DMO_MEDIA_TYPE* pmtIn =  InputType();
      DMO_MEDIA_TYPE* pmtOut = OutputType();
      if (!pmtIn || !pmtOut)
         return DMO_E_TYPE_NOT_SET;
      if (CheckType(pmtIn, NULL) || CheckType(pmtOut, pmtIn))
         return DMO_E_TYPE_NOT_ACCEPTED;

      WAVEFORMATEX *pWave = (WAVEFORMATEX*)pmtIn->pbFormat;

      m_b8bit          = (pWave->wBitsPerSample == 8);
      m_cChannels      = pWave->nChannels;
      m_ulSamplingRate = pWave->nSamplesPerSec;

      *pdwInputQuantumSize    = pWave->nBlockAlign;
      *pdwOutputQuantumSize   = pWave->nBlockAlign;
      *prtQuantumDuration     = 10000000; // rt units per sec
      *prtDurationDenominator = pWave->nSamplesPerSec;

      GetWindowParams(pdwMaxLookahead, pdwMaxLookbehind);
      return NOERROR;
   }

protected:
   //
   // Methods to be overridden by derived class
   //
   // We use this to get lookahead/lookbehind from the derived class
   virtual void GetWindowParams(DWORD *pdwMaxLookahead,
                                DWORD *pdwMaxLookbehind) {
      *pdwMaxLookahead = 0;
      *pdwMaxLookbehind = 0;
   }
   // derived class can override these if it has specific requirements
   virtual void GetPCMParams(BOOL* pb8bit, DWORD* pcChannels, DWORD* pdwSamplesPerSec) {
      // These values are what the DMO will advertise in its media type.
      // Specifying them here does not mean that this is the only acceptable
      // combination - CheckPCMParams() is the ultimate authority on what we will
      // accept.
      *pb8bit = FALSE;
      *pcChannels = 2;
      *pdwSamplesPerSec = 44100;
   }
   virtual BOOL CheckPCMParams(BOOL b8bit, DWORD cChannels, DWORD dwSamplesPerSec) {
      // Default implementation accepts anything.  Override if you have specific
      // requirements WRT sampling rate, number of channels, or bit depth.
      return TRUE;
   }

private:
   //
   // private helpers
   //
   HRESULT GetType(DMO_MEDIA_TYPE* pmt, const DMO_MEDIA_TYPE *pmtOther) {

      HRESULT hr;

      // If the other type is set, enumerate that.  Otherwise propose 44100/2/16.
      if (pmtOther) {
         hr = MoCopyMediaType(pmt, pmtOther);
         if (FAILED(hr)) {
            return hr;
         }
         return NOERROR;
      }

      hr = MoInitMediaType(pmt, sizeof(WAVEFORMATEX));
      if (FAILED(hr))
         return hr;

      pmt->majortype  = MEDIATYPE_Audio;
      pmt->subtype    = MEDIASUBTYPE_PCM;
      pmt->formattype = FORMAT_WaveFormatEx;

      WAVEFORMATEX* pWave = (WAVEFORMATEX*) pmt->pbFormat;
      pWave->wFormatTag = WAVE_FORMAT_PCM;

      BOOL b8bit;
      DWORD cChannels;
      GetPCMParams(&b8bit, &cChannels, &(pWave->nSamplesPerSec));
      (pWave->nChannels) = (unsigned short)cChannels;
      pWave->wBitsPerSample = b8bit ? 8 : 16;
      pWave->nBlockAlign = pWave->nChannels * pWave->wBitsPerSample / 8;
      pWave->nAvgBytesPerSec = pWave->nSamplesPerSec * pWave->nBlockAlign;
      pWave->cbSize = 0;

      return NOERROR;
   }
   HRESULT CheckType(const DMO_MEDIA_TYPE *pmt, DMO_MEDIA_TYPE *pmtOther) {

      if (NULL == pmt) {
         return E_POINTER;
      }

      // verify that this is PCM with a WAVEFORMATEX format specifier
      if ((pmt->majortype  != MEDIATYPE_Audio) ||
          (pmt->subtype    != MEDIASUBTYPE_PCM) ||
          (pmt->formattype != FORMAT_WaveFormatEx) ||
          (pmt->cbFormat < sizeof(WAVEFORMATEX)) ||
          (pmt->pbFormat == NULL))
         return DMO_E_TYPE_NOT_ACCEPTED;

      // If other type set, accept only if identical to that.  Otherwise accept
      // any standard PCM audio.
      if (pmtOther) {
         if (memcmp(pmt->pbFormat, pmtOther->pbFormat, sizeof(WAVEFORMATEX)))
            return DMO_E_TYPE_NOT_ACCEPTED;
      }
      else {
         WAVEFORMATEX* pWave = (WAVEFORMATEX*)pmt->pbFormat;
         if ((pWave->wFormatTag != WAVE_FORMAT_PCM) ||
             ((pWave->wBitsPerSample != 8) && (pWave->wBitsPerSample != 16)) ||
             (pWave->nBlockAlign != pWave->nChannels * pWave->wBitsPerSample / 8) ||
             (pWave->nAvgBytesPerSec != pWave->nSamplesPerSec * pWave->nBlockAlign) ||
             !CheckPCMParams((pWave->wBitsPerSample == 8), pWave->nChannels, pWave->nSamplesPerSec))
            return DMO_E_TYPE_NOT_ACCEPTED;
      }
      return NOERROR;
   }

protected:
   // format info - the derived class may look at these (but no modify)
   ULONG m_ulSamplingRate;
   ULONG m_cChannels;
   BOOL m_b8bit;
};

//
// CGenericDMO - generic DMO base class.  This is currently the only base
// class for DMOs that have multiple inputs or multiple outputs.
//
// This base class tries to be reasonably generic.  The derived class reports
// how many streams it supports and describes each stream by calling
// CreateInputStreams() and CreateOutputStreams().  Each of these functions
// takes an array of STREAMDESCRIPTOR structures, each of which poits to an
// array of FORMATENTRY structures.
//
// This base class uses CInputStream and COutputStream classes (both derived
// from CStream) to keep track of input and output stream.  However, these
// objects are not visible to the derived class - the derived class only sees
// stream IDs.
//
// One limitation of the scheme use here is that the derived class cannot
// override the GetType/SetType methods individually for each stream.  It must
// either (a) live with a static, finite set of types communicated via the
// STREAMDESCRIPTOR structure, or (b) override all IMediaObject type methods
// and handle type negotiation for all streams itself.
//
// Processing occurs when the base class calles DoProcess (overridden by the
// derived class).  DoProcess receives an array of input buffer structs and
// an array of output buffer structs.  The base class takes care of talking
// to IMediaBuffers, so the derived class only sees actual data pointers.
//

// flags used to communicate with the derived class
enum _INPUT_STATUS_FLAGS {
   INPUT_STATUSF_RESIDUAL // cannot be further processed w/o additional input
};

// These are used to pass buffers between this class and the derived class.
typedef struct _INPUTBUFFER {
   BYTE *pData;                 // [in] - if NULL, the rest are garbage
   DWORD cbSize;                // [in]
   DWORD cbUsed;                // [out]
   DWORD dwFlags;               // [in] - DMO_INPUT_DATA_BUFFERF_XXX
   DWORD dwStatus;              // [out] - INPUT_STATUSF_XXX from above
   REFERENCE_TIME rtTimestamp;  // [in]
   REFERENCE_TIME rtTimelength; // [in]
} INPUTBUFFER, *PINPUTBUFFER;
typedef struct _OUTPUTBUFFER {
   BYTE *pData;                 // [in]
   DWORD cbSize;                // [in]
   DWORD cbUsed;                // [out]
   DWORD dwFlags;               // [out] - DMO_OUTPUT_DATA_BUFFERF_XXX
   REFERENCE_TIME rtTimestamp;  // [out]
   REFERENCE_TIME rtTimelength; // [out]
} OUTPUTBUFFER, *POUTPUTBUFFER;

// Used by derived class to describe the format supported by each stream
typedef struct _FORMATENTRY
{
    const GUID *majortype;
    const GUID *subtype;
    const GUID *formattype;
    DWORD cbFormat;
    BYTE* pbFormat;
} FORMATENTRY;

// These are used by the derived class to described its streams
typedef struct _INPUTSTREAMDESCRIPTOR {
   DWORD        cFormats;
   FORMATENTRY *pFormats;
   DWORD        dwMinBufferSize;
   BOOL         bHoldsBuffers;
   DWORD        dwMaxLookahead; // used if HOLDS_BUFFERS set
} INPUTSTREAMDESCRIPTOR;
typedef struct _OUTPUTSTREAMDESCRIPTOR {
   DWORD        cFormats;
   FORMATENTRY *pFormats;
   DWORD        dwMinBufferSize;
} OUTPUTSTREAMDESCRIPTOR;

// Common input/output stream stuff
class CStream {
public:
    DMO_MEDIA_TYPE       m_MediaType;
    BOOL                m_bEOS;
    BOOL                m_bTypeSet;

    DWORD        m_cFormats;
    FORMATENTRY *m_pFormats;
    DWORD        m_dwMinBufferSize;

    //  Should really pass in a format type list
    CStream()
    {
        MoInitMediaType(&m_MediaType, 0);
        m_bTypeSet = FALSE;
        Flush();
    }
    ~CStream()
    {
        MoFreeMediaType(&m_MediaType);
    }
    HRESULT Flush() {
       m_bEOS = FALSE;
       return NOERROR;
    }
    HRESULT StreamInfo(unsigned long *pdwFlags)
    {
       if (pdwFlags == NULL) {
           return E_POINTER;
       }
       *pdwFlags = 0;
       return S_OK;
    }
    HRESULT GetType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt)
    {
        if (ulTypeIndex >= m_cFormats) {
            return E_INVALIDARG;
        }
        //  Just return our types
        MoInitMediaType(pmt, m_pFormats[ulTypeIndex].cbFormat);
        pmt->majortype  = *m_pFormats[ulTypeIndex].majortype;
        pmt->subtype    = *m_pFormats[ulTypeIndex].subtype;
        pmt->formattype = *m_pFormats[ulTypeIndex].formattype;
        memcpy(pmt->pbFormat, m_pFormats[ulTypeIndex].pbFormat, m_pFormats[ulTypeIndex].cbFormat);
        return S_OK;
    }
    HRESULT GetCurrentType(DMO_MEDIA_TYPE *pmt)
    {
        if (NULL == pmt) {
            return E_POINTER;
        }

        if (m_bTypeSet) {
           //  check success
           MoCopyMediaType(pmt, &(m_MediaType));
           return S_OK;
        }
        else
           return DMO_E_TYPE_NOT_SET;
    }
    HRESULT SetType(const DMO_MEDIA_TYPE *pmt, DWORD dwFlags)
    {
        //  Need to check this
        HRESULT hr = CheckType(pmt, 0);
        if (FAILED(hr)) {
            return hr;
        }
        if (dwFlags & DMO_SET_TYPEF_TEST_ONLY) {
           return NOERROR; // check konly
        }
        //  check success
        MoCopyMediaType(&m_MediaType, pmt);

        m_bTypeSet = TRUE;;
        return S_OK;
    }
    HRESULT CheckType(const DMO_MEDIA_TYPE *pmt, DWORD dwFlags)
    {
        if (pmt == NULL) {
            return E_POINTER;
        }
        //if (dwFlags & ~DMO_SET_TYPEF_NOT_PARTIAL)
        //    return E_INVALIDARG;

        //  Default - check GUIDs

        bool bMatched = false;
        for (DWORD i = 0; i < m_cFormats; i++) {
            const FORMATENTRY *pFormat = &(m_pFormats[i]);
            if (pmt->majortype  == *(pFormat->majortype) &&
                pmt->subtype    == *(pFormat->subtype) &&
                pmt->formattype == *(pFormat->formattype)) {
                bMatched = true;
                break;
            }
        }

        if (bMatched) {
            return S_OK;
        } else {
            return DMO_E_INVALIDTYPE;
        }
    }
    HRESULT SizeInfo(ULONG *plSize, ULONG *plAlignment)
    {
        if (plSize == NULL || plAlignment == NULL) {
            return E_POINTER;
        }

        *plAlignment = 1;
        *plSize      = m_dwMinBufferSize;
        return S_OK;
    }
};

// Input stream specific stuff
class CInputStream : public CStream {
public:
    BOOL         m_bHoldsBuffers;
    DWORD        m_dwMaxLookahead; // used if HOLDS_BUFFERS set

    // Current input sample
    IMediaBuffer *m_pMediaBuffer;
    DWORD m_dwFlags; // discontinuity, etc.
    REFERENCE_TIME m_rtTimestamp;
    REFERENCE_TIME m_rtTimelength;
    BYTE *m_pData;
    DWORD m_cbSize;
    DWORD m_cbUsed;

    // residual
    BYTE *m_pbResidual;
    DWORD m_cbResidual;
    DWORD m_cbResidualBuffer;

    // temporary buffer for handling the residual
    BYTE *m_pbTemp;

   HRESULT Flush() {
      if (m_pMediaBuffer) {
         m_pMediaBuffer->Release();
         m_pMediaBuffer = NULL;
      }
      return CStream::Flush();
   }
   CInputStream() {
      m_pMediaBuffer = NULL;
      m_pbResidual = NULL;
      m_pbTemp = NULL;
   }
   ~CInputStream() {
      if (m_pMediaBuffer)
         m_pMediaBuffer->Release();
      if (m_pbResidual)
         delete[] m_pbResidual;
   }
   HRESULT StreamInfo(DWORD *pdwFlags) {
      HRESULT hr = CStream::StreamInfo(pdwFlags);
      if (FAILED(hr))
         return hr;
      if (m_bHoldsBuffers)
         *pdwFlags |= DMO_INPUT_STREAMF_HOLDS_BUFFERS;
      return NOERROR;
   }
   HRESULT Init(INPUTSTREAMDESCRIPTOR *pDescriptor) {
      m_cFormats = pDescriptor->cFormats;
      m_pFormats = pDescriptor->pFormats;
      m_dwMinBufferSize = pDescriptor->dwMinBufferSize;
      m_bHoldsBuffers = pDescriptor->bHoldsBuffers;
      m_dwMaxLookahead = pDescriptor->dwMaxLookahead;

      // Just in case Init is called multiple times:
      // delete any preexisting stuff.
      if (m_pMediaBuffer) {
         m_pMediaBuffer->Release();
         m_pMediaBuffer = NULL;
      }
      if (m_pbResidual) {
         delete[] m_pbResidual;
         m_pbResidual = NULL;
      }

      m_cbResidual = 0;
      m_cbResidualBuffer = m_dwMinBufferSize * 2; // enough ?
      m_pbResidual = new BYTE[m_cbResidualBuffer];

      return NOERROR;
   }
   HRESULT InputStatus(DWORD *pdwStatus) {
       // objects that hold buffers must implement InputStatus themselves
      assert(!m_bHoldsBuffers);
      *pdwStatus = 0;
      if (!m_pMediaBuffer)
         *pdwStatus |= DMO_INPUT_STATUSF_ACCEPT_DATA;
      return NOERROR;
   }
   HRESULT Deliver(
      IMediaBuffer *pBuffer, // [in], must not be NULL
      DWORD dwFlags, // [in] - discontinuity, timestamp, etc.
      REFERENCE_TIME rtTimestamp, // [in], valid if flag set
      REFERENCE_TIME rtTimelength // [in], valid if flag set
   ) {
      if (!pBuffer)
         return E_POINTER;
       // objects that hold buffers must implement Deliver themselves
      assert(!m_bHoldsBuffers);
      DWORD dwStatus = 0;
      InputStatus(&dwStatus);
      if (!(dwStatus & DMO_INPUT_STATUSF_ACCEPT_DATA))
         return DMO_E_NOTACCEPTING;
      assert(!m_pMediaBuffer); // can't hold multiple buffers

      //Deal with the IMediaBuffer
      HRESULT hr;
      hr = pBuffer->GetBufferAndLength(&m_pData, &m_cbSize);
      if (FAILED(hr))
         return hr;

      if (!m_cbSize) // empty buffer
         return S_FALSE; // no data

      pBuffer->AddRef();
      m_pMediaBuffer = pBuffer;
      m_dwFlags = dwFlags;
      m_rtTimestamp = rtTimestamp;
      m_rtTimelength = rtTimelength;
      m_cbUsed = 0;
      return NOERROR;
   }

   //
   // Fetch data from the currently held IMediaBuffer plus any residual
   //
   HRESULT PrepareInputBuffer(INPUTBUFFER *pBuffer)
   {
      // Q.: do we even have any data to give it ?
      if (m_pMediaBuffer) {
         // Is there a residual we need to feed first ?
         if (m_cbResidual) {
            // Yes, prepend the residual to the new input

            // If we have used some of the input buffer by now, we
            // should have also used up any residual with that.
            assert(m_cbUsed == 0);

            // compute how many bytes total we are going to send
            pBuffer->cbSize = m_cbResidual
                                      + m_cbSize;

            // Make sure we have at least dwMinBufferSize bytes of data.
            // We really should - the input buffer alone ought to be at
            // least that big.
            assert(pBuffer->cbSize > m_dwMinBufferSize);

            // Is the residual buffer big enough to hold the residual plus
            // all of the new buffer ?
            if (pBuffer->cbSize <= m_cbResidualBuffer) {
               // Yes - wonderful, we can use the residual buffer
               memcpy(m_pbResidual + m_cbResidual,
                      m_pData,
                      m_cbSize);
               pBuffer->pData = m_pbResidual;
            }
            else {
               // No - allocate a sufficiently large temporary buffer.
               // This is supposed to be a rare case.
               m_pbTemp = new BYTE[pBuffer->cbSize];
               if (m_pbTemp == NULL)
                  return E_OUTOFMEMORY;
               // copy the residual
               memcpy(m_pbTemp,
                      m_pbResidual,
                      m_cbResidual);
               // append the new buffer
               memcpy(m_pbTemp + m_cbResidual,
                      m_pData,
                      m_cbSize);

               // set the buffer pointer to our temp buffer
               pBuffer->pData = m_pbTemp;
            }

            // is this the correct way to handle timestamps &
            // discontinuities when handling a residual ?
            pBuffer->dwFlags = 0;
         }
         else { // no residual
            pBuffer->pData = m_pData + m_cbUsed;
            pBuffer->cbSize = m_cbSize - m_cbUsed;
            pBuffer->dwFlags = m_dwFlags;
            pBuffer->rtTimestamp = m_rtTimestamp;
            pBuffer->rtTimelength= m_rtTimelength;
         }
         pBuffer->cbUsed = 0; // derived class should set this
         pBuffer->dwStatus = 0; // derived class should set this
      }
      else {
         pBuffer->pData = NULL;
         pBuffer->cbSize = 0;
      }
      return NOERROR;
   }

   //
   // Save any residual and release the IMediaBuffer as appropriate.
   // Returns TRUE if there is enough data left to call ProcesInput again.
   //
   BOOL PostProcessInputBuffer(INPUTBUFFER *pBuffer)
   {
      BOOL bRet = FALSE;
      // did we even give this stream anything ?
      if (m_pMediaBuffer) {
         // Yes, but did it eat any of it ?
         if (pBuffer->cbUsed) {
            // Did we even get past the residual
            if (pBuffer->cbUsed > m_cbResidual) {
               // Yes - reflect this in the current buffer's cbUsed.
               m_cbUsed += (pBuffer->cbUsed - m_cbResidual);
               m_cbResidual = 0;
            }
            else {
               // No - just subtract from the residual.
               // This is a rather silly case.
               m_cbResidual -= pBuffer->cbUsed;
               memmove(m_pbResidual,
                       m_pbResidual + pBuffer->cbUsed,
                       m_cbResidual);
            }
         }

         // Is there enough left to feed again the next time ?
         if ((m_cbSize - m_cbUsed <
              m_dwMinBufferSize)
              || (pBuffer->dwStatus & INPUT_STATUSF_RESIDUAL)) {
            // No - copy the residual and release the buffer
            memcpy(m_pbResidual,
                   m_pData + m_cbUsed,
                   m_cbSize - m_cbUsed);
            m_cbResidual
              = pBuffer->cbSize - pBuffer->cbUsed;
            m_pMediaBuffer->Release();
            m_pMediaBuffer = NULL;
         }
         else { // Yes - need another Process call to eat remaining input
            bRet = TRUE;
         }

         // Free any temporary buffer we may have used - rare case
         if (m_pbTemp) {
            delete[] m_pbTemp;
            m_pbTemp = NULL;
         }
      }
      return bRet;
   }
   HRESULT Discontinuity() {
      // implement
      // m_bDiscontinuity = TRUE;
      return NOERROR;
   }
   HRESULT SizeInfo(ULONG *pulSize,
                    ULONG *pulMaxLookahead,
                    ULONG *pulAlignment) {
      HRESULT hr = CStream::SizeInfo(pulSize, pulAlignment);
      if (FAILED(hr))
         return hr;

      if (m_bHoldsBuffers)
         *pulMaxLookahead = m_dwMaxLookahead;
      else
         *pulMaxLookahead = *pulSize;
      return NOERROR;
   }
};

// Output stream specific stuff
class COutputStream : public CStream {
public:
   BOOL m_bIncomplete;
   DWORD m_cbAlreadyUsed; // temp per-stream variable used during Process

   HRESULT Init(OUTPUTSTREAMDESCRIPTOR *pDescriptor) {
      m_cFormats = pDescriptor->cFormats;
      m_pFormats = pDescriptor->pFormats;
      m_dwMinBufferSize = pDescriptor->dwMinBufferSize;
      return NOERROR;
   }

   //
   // Initialize the OUTPUTBUFFER struct with info from the IMediaBuffer
   //
   HRESULT PrepareOutputBuffer(OUTPUTBUFFER *pBuffer, IMediaBuffer *pMediaBuffer, BOOL bNewInput)
   {
      //
      // See if the caller supplied an output buffer
      //
      if (pMediaBuffer == NULL) {
         // This is allowed to be NULL only if (1) the object did not set
         // the INCOMPLETE flag for this stream during the last Process
         // call, and (2) no new input data has been supplied to the object
         // since the last Process call.
         if (bNewInput)
            return E_POINTER;
         if (m_bIncomplete)
            return E_POINTER;

         // ok - initialize assuming no buffer
         pBuffer->cbSize = 0;
         pBuffer->pData = NULL;
      }
      else { // the IMediaBuffer is not NULL - deal with it
         HRESULT hr;
         hr = pMediaBuffer->GetMaxLength(&pBuffer->cbSize);
         if (FAILED(hr))
            return hr;

         hr = pMediaBuffer->GetBufferAndLength(
                 &(pBuffer->pData),
                 &(m_cbAlreadyUsed));
         if (FAILED(hr))
            return hr;

         // Check current size - should we even bother with this ?
         if (m_cbAlreadyUsed) {
            if (m_cbAlreadyUsed >= pBuffer->cbSize)
               return E_INVALIDARG; // buffer already full ?!?
            pBuffer->cbSize -= m_cbAlreadyUsed;
            pBuffer->pData += m_cbAlreadyUsed;
         }
      }

      // It is really the derived class's job to set these, but we
      // will be nice to it and initialize them anyway just in case.
      pBuffer->cbUsed = 0;
      pBuffer->dwFlags = 0;

      return NOERROR;
   }

   //
   // Copy the OUTPUTBUFFER back into the DMO_OUTPUT_DATA_BUFFER (yawn)
   //
   void PostProcessOutputBuffer(OUTPUTBUFFER *pBuffer, DMO_OUTPUT_DATA_BUFFER *pDMOBuffer, BOOL bForceIncomplete) {
      assert(pBuffer->cbUsed <= pBuffer->cbSize);
      if (pDMOBuffer->pBuffer)
         pDMOBuffer->pBuffer->SetLength(pBuffer->cbUsed + m_cbAlreadyUsed);
      pDMOBuffer->dwStatus = pBuffer->dwFlags;
      pDMOBuffer->rtTimestamp = pBuffer->rtTimestamp;
      pDMOBuffer->rtTimelength = pBuffer->rtTimelength;

      // Even if the derived class did not set INCOMPLETE, we may need to
      // set it anyway if some input buffer we are holding still has
      // enough data to call Process() again.
      if (bForceIncomplete)
         pDMOBuffer->dwStatus |= DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE;

      // remember this output stream's INCOMPLETE state
      if (pDMOBuffer->dwStatus & DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE)
         m_bIncomplete = TRUE;
      else
         m_bIncomplete = FALSE;
   }
};

// Code that goes at the beginning of every IMediaObject method
#define INPUT_STREAM_PROLOGUE \
    CDMOAutoLock l(&m_cs); \
    if (ulInputStreamIndex >= m_nInputStreams) \
       return DMO_E_INVALIDSTREAMINDEX; \
    CInputStream *pStream = &m_pInputStreams[ulInputStreamIndex]

#define OUTPUT_STREAM_PROLOGUE \
    CDMOAutoLock l(&m_cs); \
    if (ulOutputStreamIndex >= m_nOutputStreams) \
       return DMO_E_INVALIDSTREAMINDEX; \
    COutputStream *pStream = &m_pOutputStreams[ulOutputStreamIndex]


class CGenericDMO : public IMediaObject
{
public:
    CGenericDMO() {
#ifdef DMO_NOATL
       InitializeCriticalSection(&m_cs);
#endif
       m_nInputStreams = 0;
       m_nOutputStreams = 0;
    }
#ifdef DMO_NOATL
    ~CGenericDMO() {
       DeleteCriticalSection(&m_cs);
    }
#endif

public:
    //
    // Implement IMediaObject methods
    //
    STDMETHODIMP GetInputStreamInfo(ULONG ulInputStreamIndex, DWORD *pdwFlags)
    {
       INPUT_STREAM_PROLOGUE;
       return pStream->StreamInfo(pdwFlags);
    }
    STDMETHODIMP GetOutputStreamInfo(ULONG ulOutputStreamIndex, DWORD *pdwFlags)
    {
       OUTPUT_STREAM_PROLOGUE;
       return pStream->StreamInfo(pdwFlags);
    }
    STDMETHODIMP GetInputType(ULONG ulInputStreamIndex, ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
       INPUT_STREAM_PROLOGUE;
       return pStream->GetType(ulTypeIndex, pmt);
    }
    STDMETHODIMP GetOutputType(ULONG ulOutputStreamIndex, ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
       OUTPUT_STREAM_PROLOGUE;
       return pStream->GetType(ulTypeIndex, pmt);
    }
    STDMETHODIMP GetInputCurrentType(ULONG ulInputStreamIndex, DMO_MEDIA_TYPE *pmt) {
       INPUT_STREAM_PROLOGUE;
       return pStream->GetCurrentType(pmt);
    }
    STDMETHODIMP GetOutputCurrentType(ULONG ulOutputStreamIndex, DMO_MEDIA_TYPE *pmt) {
       OUTPUT_STREAM_PROLOGUE;
       return pStream->GetCurrentType(pmt);
    }
    STDMETHODIMP GetInputSizeInfo(ULONG ulInputStreamIndex, ULONG *pulSize, ULONG *pcbMaxLookahead, ULONG *pulAlignment) {
       INPUT_STREAM_PROLOGUE;
       return pStream->SizeInfo(pulSize, pcbMaxLookahead, pulAlignment);
    }
    STDMETHODIMP GetOutputSizeInfo(ULONG ulOutputStreamIndex, ULONG *pulSize, ULONG *pulAlignment) {
       OUTPUT_STREAM_PROLOGUE;
       return pStream->SizeInfo(pulSize, pulAlignment);
    }
    STDMETHODIMP SetInputType(ULONG ulInputStreamIndex, const DMO_MEDIA_TYPE *pmt, DWORD dwFlags) {
       INPUT_STREAM_PROLOGUE;
       return pStream->SetType(pmt, dwFlags);
    }
    STDMETHODIMP SetOutputType(ULONG ulOutputStreamIndex, const DMO_MEDIA_TYPE *pmt, DWORD dwFlags) {
       OUTPUT_STREAM_PROLOGUE;
       return pStream->SetType(pmt, dwFlags);
    }
    STDMETHODIMP GetInputStatus(
        ULONG ulInputStreamIndex,
        DWORD *pdwStatus
    ) {
       INPUT_STREAM_PROLOGUE;
       return pStream->InputStatus(pdwStatus);
    }
    STDMETHODIMP GetInputMaxLatency(unsigned long ulInputStreamIndex, REFERENCE_TIME *prtLatency) {
       // I don't know what to do with this right now.
       // Punt to the derived class ?
       return E_NOTIMPL;
    }
    STDMETHODIMP SetInputMaxLatency(unsigned long ulInputStreamIndex, REFERENCE_TIME rtLatency) {
       return E_NOTIMPL;
    }
    STDMETHODIMP ProcessInput(
        DWORD ulInputStreamIndex,
        IMediaBuffer *pBuffer, // [in], must not be NULL
        DWORD dwFlags, // [in] - discontinuity, timestamp, etc.
        REFERENCE_TIME rtTimestamp, // [in], valid if flag set
        REFERENCE_TIME rtTimelength // [in], valid if flag set
    ) {
       INPUT_STREAM_PROLOGUE;
       return pStream->Deliver(pBuffer, dwFlags, rtTimestamp, rtTimelength);
    }
    STDMETHODIMP Discontinuity(ULONG ulInputStreamIndex) {
       INPUT_STREAM_PROLOGUE;
       return pStream->Discontinuity();
    }

    STDMETHODIMP Flush()
    {
       CDMOAutoLock l(&m_cs);

       //  Flush all the streams
       ULONG i;
       for (i = 0; i < m_nInputStreams; i++) {
          m_pInputStreams[i].Flush();
       }
       for (i = 0; i < m_nOutputStreams; i++) {
          m_pOutputStreams[i].Flush();
       }
       return S_OK;
    }

    STDMETHODIMP AllocateStreamingResources() {return S_OK;}
    STDMETHODIMP FreeStreamingResources() {return S_OK;}

    STDMETHODIMP GetStreamCount(unsigned long *pulNumberOfInputStreams, unsigned long *pulNumberOfOutputStreams)
    {
        CDMOAutoLock l(&m_cs);
        if (pulNumberOfInputStreams == NULL ||
            pulNumberOfOutputStreams == NULL) {
            return E_POINTER;
        }
        *pulNumberOfInputStreams = m_nInputStreams;
        *pulNumberOfOutputStreams = m_nOutputStreams;
        return S_OK;
    }

    STDMETHODIMP ProcessOutput(
                    DWORD dwReserved,
                    DWORD ulOutputBufferCount,
                    DMO_OUTPUT_DATA_BUFFER *pOutputBuffers,
                    DWORD *pdwStatus)
    {
       CDMOAutoLock l(&m_cs);
       if (ulOutputBufferCount != m_nOutputStreams)
          return E_INVALIDARG;

       HRESULT hr;
       DWORD c;

       // Prepare the input buffers
       for (c = 0; c < m_nInputStreams; c++) {
          // objects that hold buffers must implement Process themselves
          assert(!m_pInputStreams[c].m_bHoldsBuffers);
          hr = m_pInputStreams[c].PrepareInputBuffer(&m_pInputBuffers[c]);
          if (FAILED(hr))
             return hr;
       }

       //
       // Prepare the output buffers
       //
       for (c = 0; c < m_nOutputStreams; c++) {
          hr = m_pOutputStreams[c].PrepareOutputBuffer(&m_pOutputBuffers[c], pOutputBuffers[c].pBuffer, m_bNewInput);
          if (FAILED(hr))
             return hr;
       }

       hr = DoProcess(m_pInputBuffers,m_pOutputBuffers);
       if (FAILED(hr))
          return hr; // don't just "return hr", do something !

       // post-process input buffers
       BOOL bSomeInputStillHasData = FALSE;
       for (c = 0; c < m_nInputStreams; c++) {
          if (m_pInputStreams[c].PostProcessInputBuffer(&m_pInputBuffers[c]))
             bSomeInputStillHasData = TRUE;
       }

       // post-process output buffers
       for (c = 0; c < m_nOutputStreams; c++) {
          m_pOutputStreams[c].PostProcessOutputBuffer(&m_pOutputBuffers[c],
                                                      &pOutputBuffers[c],
                                                      bSomeInputStillHasData);
       }

       m_bNewInput = FALSE;
       return NOERROR;
    }

protected:
    //
    // These are called by the derived class at initialization time
    //
    HRESULT CreateInputStreams(INPUTSTREAMDESCRIPTOR *pStreams, DWORD cStreams) {
       CDMOAutoLock l(&m_cs);
       if (pStreams == NULL) {
          return E_POINTER;
       }

       m_pInputStreams = new CInputStream[cStreams];

       if (m_pInputStreams == NULL) {
          return E_OUTOFMEMORY;
       }

       DWORD c;
       for (c = 0; c < cStreams; c++) {
          HRESULT hr = m_pInputStreams[c].Init(&(pStreams[c]));
          if (FAILED(hr)) {
             delete[] m_pInputStreams;
             return hr;
          }
       }

       m_pInputBuffers = new INPUTBUFFER[cStreams];
       if (!m_pInputBuffers) {
          delete[] m_pInputStreams;
          return E_OUTOFMEMORY;
       }

       m_nInputStreams = cStreams;
       return NOERROR;
    }
    HRESULT CreateOutputStreams(OUTPUTSTREAMDESCRIPTOR *pStreams, DWORD cStreams) {
       CDMOAutoLock l(&m_cs);
       if (pStreams == NULL) {
          return E_POINTER;
       }

       m_pOutputStreams = new COutputStream[cStreams];

       if (m_pOutputStreams == NULL) {
          return E_OUTOFMEMORY;
       }

       DWORD c;
       for (c = 0; c < cStreams; c++) {
          HRESULT hr = m_pOutputStreams[c].Init(&(pStreams[c]));
          if (FAILED(hr)) {
             delete[] m_pOutputStreams;
             return hr;
          }
       }
	
       m_pOutputBuffers = new OUTPUTBUFFER[cStreams];
       if (!m_pOutputBuffers) {
          delete[] m_pOutputStreams;
          return E_OUTOFMEMORY;
       }

       m_nOutputStreams = cStreams;
       return NOERROR;
    }

    virtual HRESULT DoProcess(INPUTBUFFER*, OUTPUTBUFFER *) = 0;

private:

    ULONG           m_nInputStreams;
    CInputStream*   m_pInputStreams;
    ULONG           m_nOutputStreams;
    COutputStream*  m_pOutputStreams;

    INPUTBUFFER*    m_pInputBuffers;
    OUTPUTBUFFER*   m_pOutputBuffers;

    BOOL m_bNewInput;
#ifdef DMO_NOATL
    CRITICAL_SECTION m_cs;
#else
    CComAutoCriticalSection m_cs;
#endif
};

#endif // __DMOBASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\base\wxlist.h ===
//------------------------------------------------------------------------------
// File: WXList.h
//
// Desc: DirectShow base classes - defines a non-MFC generic template list
//       class.
//
//@@BEGIN_MSINTERNAL
//
//	     December 1994
//
//@@END_MSINTERNAL
// Copyright (c) 1992-2001 Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


/* A generic list of pointers to objects.
   No storage management or copying is done on the objects pointed to.
   Objectives: avoid using MFC libraries in ndm kernel mode and
   provide a really useful list type.

   The class is thread safe in that separate threads may add and
   delete items in the list concurrently although the application
   must ensure that constructor and destructor access is suitably
   synchronised. An application can cause deadlock with operations
   which use two lists by simultaneously calling
   list1->Operation(list2) and list2->Operation(list1).  So don't!

   The names must not conflict with MFC classes as an application
   may use both.
   */

#ifndef __WXLIST__
#define __WXLIST__

   /* A POSITION represents (in some fashion that's opaque) a cursor
      on the list that can be set to identify any element.  NULL is
      a valid value and several operations regard NULL as the position
      "one step off the end of the list".  (In an n element list there
      are n+1 places to insert and NULL is that "n+1-th" value).
      The POSITION of an element in the list is only invalidated if
      that element is deleted.  Move operations may mean that what
      was a valid POSITION in one list is now a valid POSITION in
      a different list.

      Some operations which at first sight are illegal are allowed as
      harmless no-ops.  For instance RemoveHead is legal on an empty
      list and it returns NULL.  This allows an atomic way to test if
      there is an element there, and if so, get it.  The two operations
      AddTail and RemoveHead thus implement a MONITOR (See Hoare's paper).

      Single element operations return POSITIONs, non-NULL means it worked.
      whole list operations return a BOOL.  TRUE means it all worked.

      This definition is the same as the POSITION type for MFCs, so we must
      avoid defining it twice.
   */
#ifndef __AFX_H__
struct __POSITION { int unused; };
typedef __POSITION* POSITION;
#endif

const int DEFAULTCACHE = 10;    /* Default node object cache size */

/* A class representing one node in a list.
   Each node knows a pointer to it's adjacent nodes and also a pointer
   to the object that it looks after.
   All of these pointers can be retrieved or set through member functions.
*/
class CBaseList 
#ifdef DEBUG
    : public CBaseObject
#endif
{
    /* Making these classes inherit from CBaseObject does nothing
       functionally but it allows us to check there are no memory
       leaks in debug builds. 
    */

public:

#ifdef DEBUG
    class CNode : public CBaseObject {
#else
    class CNode {
#endif

        CNode *m_pPrev;         /* Previous node in the list */
        CNode *m_pNext;         /* Next node in the list */
        void *m_pObject;      /* Pointer to the object */

    public:

        /* Constructor - initialise the object's pointers */
        CNode()
#ifdef DEBUG
            : CBaseObject(NAME("List node"))
#endif
        {
        };


        /* Return the previous node before this one */
        CNode *Prev() const { return m_pPrev; };


        /* Return the next node after this one */
        CNode *Next() const { return m_pNext; };


        /* Set the previous node before this one */
        void SetPrev(CNode *p) { m_pPrev = p; };


        /* Set the next node after this one */
        void SetNext(CNode *p) { m_pNext = p; };


        /* Get the pointer to the object for this node */
        void *GetData() const { return m_pObject; };


        /* Set the pointer to the object for this node */
        void SetData(void *p) { m_pObject = p; };
    };

    class CNodeCache
    {
    public:
        CNodeCache(INT iCacheSize) : m_iCacheSize(iCacheSize),
                                     m_pHead(NULL),
                                     m_iUsed(0)
                                     {};
        ~CNodeCache() {
            CNode *pNode = m_pHead;
            while (pNode) {
                CNode *pCurrent = pNode;
                pNode = pNode->Next();
                delete pCurrent;
            }
        };
        void AddToCache(CNode *pNode)
        {
            if (m_iUsed < m_iCacheSize) {
                pNode->SetNext(m_pHead);
                m_pHead = pNode;
                m_iUsed++;
            } else {
                delete pNode;
            }
        };
        CNode *RemoveFromCache()
        {
            CNode *pNode = m_pHead;
            if (pNode != NULL) {
                m_pHead = pNode->Next();
                m_iUsed--;
                ASSERT(m_iUsed >= 0);
            } else {
                ASSERT(m_iUsed == 0);
            }
            return pNode;
        };
    private:
        INT m_iCacheSize;
        INT m_iUsed;
        CNode *m_pHead;
    };

protected:

    CNode* m_pFirst;    /* Pointer to first node in the list */
    CNode* m_pLast;     /* Pointer to the last node in the list */
    LONG m_Count;       /* Number of nodes currently in the list */

private:

    CNodeCache m_Cache; /* Cache of unused node pointers */

private:

    /* These override the default copy constructor and assignment
       operator for all list classes. They are in the private class
       declaration section so that anybody trying to pass a list
       object by value will generate a compile time error of
       "cannot access the private member function". If these were
       not here then the compiler will create default constructors
       and assignment operators which when executed first take a
       copy of all member variables and then during destruction
       delete them all. This must not be done for any heap
       allocated data.
    */
    CBaseList(const CBaseList &refList);
    CBaseList &operator=(const CBaseList &refList);

public:

    CBaseList(TCHAR *pName,
              INT iItems);

    CBaseList(TCHAR *pName);
#ifdef UNICODE
    CBaseList(CHAR *pName,
              INT iItems);

    CBaseList(CHAR *pName);
#endif
    ~CBaseList();

    /* Remove all the nodes from *this i.e. make the list empty */
    void RemoveAll();


    /* Return a cursor which identifies the first element of *this */
    POSITION GetHeadPositionI() const;


    /* Return a cursor which identifies the last element of *this */
    POSITION GetTailPositionI() const;


    /* Return the number of objects in *this */
    int GetCountI() const;

protected:
    /* Return the pointer to the object at rp,
       Update rp to the next node in *this
       but make it NULL if it was at the end of *this.
       This is a wart retained for backwards compatibility.
       GetPrev is not implemented.
       Use Next, Prev and Get separately.
    */
    void *GetNextI(POSITION& rp) const;


    /* Return a pointer to the object at p
       Asking for the object at NULL will return NULL harmlessly.
    */
    void *GetI(POSITION p) const;

public:
    /* return the next / prev position in *this
       return NULL when going past the end/start.
       Next(NULL) is same as GetHeadPosition()
       Prev(NULL) is same as GetTailPosition()
       An n element list therefore behaves like a n+1 element
       cycle with NULL at the start/end.

       !!WARNING!! - This handling of NULL is DIFFERENT from GetNext.

       Some reasons are:
       1. For a list of n items there are n+1 positions to insert
          These are conveniently encoded as the n POSITIONs and NULL.
       2. If you are keeping a list sorted (fairly common) and you
          search forward for an element to insert before and don't
          find it you finish up with NULL as the element before which
          to insert.  You then want that NULL to be a valid POSITION
          so that you can insert before it and you want that insertion
          point to mean the (n+1)-th one that doesn't have a POSITION.
          (symmetrically if you are working backwards through the list).
       3. It simplifies the algebra which the methods generate.
          e.g. AddBefore(p,x) is identical to AddAfter(Prev(p),x)
          in ALL cases.  All the other arguments probably are reflections
          of the algebraic point.
    */
    POSITION Next(POSITION pos) const
    {
        if (pos == NULL) {
            return (POSITION) m_pFirst;
        }
        CNode *pn = (CNode *) pos;
        return (POSITION) pn->Next();
    } //Next

    // See Next
    POSITION Prev(POSITION pos) const
    {
        if (pos == NULL) {
            return (POSITION) m_pLast;
        }
        CNode *pn = (CNode *) pos;
        return (POSITION) pn->Prev();
    } //Prev


    /* Return the first position in *this which holds the given
       pointer.  Return NULL if the pointer was not not found.
    */
protected:
    POSITION FindI( void * pObj) const;

    // ??? Should there be (or even should there be only)
    // ??? POSITION FindNextAfter(void * pObj, POSITION p)
    // ??? And of course FindPrevBefore too.
    // ??? List.Find(&Obj) then becomes List.FindNextAfter(&Obj, NULL)


    /* Remove the first node in *this (deletes the pointer to its
       object from the list, does not free the object itself).
       Return the pointer to its object.
       If *this was already empty it will harmlessly return NULL.
    */
    void *RemoveHeadI();


    /* Remove the last node in *this (deletes the pointer to its
       object from the list, does not free the object itself).
       Return the pointer to its object.
       If *this was already empty it will harmlessly return NULL.
    */
    void *RemoveTailI();


    /* Remove the node identified by p from the list (deletes the pointer
       to its object from the list, does not free the object itself).
       Asking to Remove the object at NULL will harmlessly return NULL.
       Return the pointer to the object removed.
    */
    void *RemoveI(POSITION p);

    /* Add single object *pObj to become a new last element of the list.
       Return the new tail position, NULL if it fails.
       If you are adding a COM objects, you might want AddRef it first.
       Other existing POSITIONs in *this are still valid
    */
    POSITION AddTailI(void * pObj);
public:


    /* Add all the elements in *pList to the tail of *this.
       This duplicates all the nodes in *pList (i.e. duplicates
       all its pointers to objects).  It does not duplicate the objects.
       If you are adding a list of pointers to a COM object into the list
       it's a good idea to AddRef them all  it when you AddTail it.
       Return TRUE if it all worked, FALSE if it didn't.
       If it fails some elements may have been added.
       Existing POSITIONs in *this are still valid

       If you actually want to MOVE the elements, use MoveToTail instead.
    */
    BOOL AddTail(CBaseList *pList);


    /* Mirror images of AddHead: */

    /* Add single object to become a new first element of the list.
       Return the new head position, NULL if it fails.
       Existing POSITIONs in *this are still valid
    */
protected:
    POSITION AddHeadI(void * pObj);
public:

    /* Add all the elements in *pList to the head of *this.
       Same warnings apply as for AddTail.
       Return TRUE if it all worked, FALSE if it didn't.
       If it fails some of the objects may have been added.

       If you actually want to MOVE the elements, use MoveToHead instead.
    */
    BOOL AddHead(CBaseList *pList);


    /* Add the object *pObj to *this after position p in *this.
       AddAfter(NULL,x) adds x to the start - equivalent to AddHead
       Return the position of the object added, NULL if it failed.
       Existing POSITIONs in *this are undisturbed, including p.
    */
protected:
    POSITION AddAfterI(POSITION p, void * pObj);
public:

    /* Add the list *pList to *this after position p in *this
       AddAfter(NULL,x) adds x to the start - equivalent to AddHead
       Return TRUE if it all worked, FALSE if it didn't.
       If it fails, some of the objects may be added
       Existing POSITIONs in *this are undisturbed, including p.
    */
    BOOL AddAfter(POSITION p, CBaseList *pList);


    /* Mirror images:
       Add the object *pObj to this-List after position p in *this.
       AddBefore(NULL,x) adds x to the end - equivalent to AddTail
       Return the position of the new object, NULL if it fails
       Existing POSITIONs in *this are undisturbed, including p.
    */
    protected:
    POSITION AddBeforeI(POSITION p, void * pObj);
    public:

    /* Add the list *pList to *this before position p in *this
       AddAfter(NULL,x) adds x to the start - equivalent to AddHead
       Return TRUE if it all worked, FALSE if it didn't.
       If it fails, some of the objects may be added
       Existing POSITIONs in *this are undisturbed, including p.
    */
    BOOL AddBefore(POSITION p, CBaseList *pList);


    /* Note that AddAfter(p,x) is equivalent to AddBefore(Next(p),x)
       even in cases where p is NULL or Next(p) is NULL.
       Similarly for mirror images etc.
       This may make it easier to argue about programs.
    */



    /* The following operations do not copy any elements.
       They move existing blocks of elements around by switching pointers.
       They are fairly efficient for long lists as for short lists.
       (Alas, the Count slows things down).

       They split the list into two parts.
       One part remains as the original list, the other part
       is appended to the second list.  There are eight possible
       variations:
       Split the list {after/before} a given element
       keep the {head/tail} portion in the original list
       append the rest to the {head/tail} of the new list.

       Since After is strictly equivalent to Before Next
       we are not in serious need of the Before/After variants.
       That leaves only four.

       If you are processing a list left to right and dumping
       the bits that you have processed into another list as
       you go, the Tail/Tail variant gives the most natural result.
       If you are processing in reverse order, Head/Head is best.

       By using NULL positions and empty lists judiciously either
       of the other two can be built up in two operations.

       The definition of NULL (see Next/Prev etc) means that
       degenerate cases include
          "move all elements to new list"
          "Split a list into two lists"
          "Concatenate two lists"
          (and quite a few no-ops)

       !!WARNING!! The type checking won't buy you much if you get list
       positions muddled up - e.g. use a POSITION that's in a different
       list and see what a mess you get!
    */

    /* Split *this after position p in *this
       Retain as *this the tail portion of the original *this
       Add the head portion to the tail end of *pList
       Return TRUE if it all worked, FALSE if it didn't.

       e.g.
          foo->MoveToTail(foo->GetHeadPosition(), bar);
              moves one element from the head of foo to the tail of bar
          foo->MoveToTail(NULL, bar);
              is a no-op, returns NULL
          foo->MoveToTail(foo->GetTailPosition, bar);
              concatenates foo onto the end of bar and empties foo.

       A better, except excessively long name might be
           MoveElementsFromHeadThroughPositionToOtherTail
    */
    BOOL MoveToTail(POSITION pos, CBaseList *pList);


    /* Mirror image:
       Split *this before position p in *this.
       Retain in *this the head portion of the original *this
       Add the tail portion to the start (i.e. head) of *pList

       e.g.
          foo->MoveToHead(foo->GetTailPosition(), bar);
              moves one element from the tail of foo to the head of bar
          foo->MoveToHead(NULL, bar);
              is a no-op, returns NULL
          foo->MoveToHead(foo->GetHeadPosition, bar);
              concatenates foo onto the start of bar and empties foo.
    */
    BOOL MoveToHead(POSITION pos, CBaseList *pList);


    /* Reverse the order of the [pointers to] objects in *this
    */
    void Reverse();


    /* set cursor to the position of each element of list in turn  */
    #define TRAVERSELIST(list, cursor)               \
    for ( cursor = (list).GetHeadPosition()           \
        ; cursor!=NULL                               \
        ; cursor = (list).Next(cursor)                \
        )


    /* set cursor to the position of each element of list in turn
       in reverse order
    */
    #define REVERSETRAVERSELIST(list, cursor)        \
    for ( cursor = (list).GetTailPosition()           \
        ; cursor!=NULL                               \
        ; cursor = (list).Prev(cursor)                \
        )

}; // end of class declaration

template<class OBJECT> class CGenericList : public CBaseList
{
public:
    CGenericList(TCHAR *pName,
                 INT iItems,
                 BOOL bLock = TRUE,
                 BOOL bAlert = FALSE) :
                     CBaseList(pName, iItems) {
        UNREFERENCED_PARAMETER(bAlert);
        UNREFERENCED_PARAMETER(bLock);
    };
    CGenericList(TCHAR *pName) :
                     CBaseList(pName) {
    };

    POSITION GetHeadPosition() const { return (POSITION)m_pFirst; }
    POSITION GetTailPosition() const { return (POSITION)m_pLast; }
    int GetCount() const { return m_Count; }

    OBJECT *GetNext(POSITION& rp) const { return (OBJECT *) GetNextI(rp); }

    OBJECT *Get(POSITION p) const { return (OBJECT *) GetI(p); }
    OBJECT *GetHead() const  { return Get(GetHeadPosition()); }

    OBJECT *RemoveHead() { return (OBJECT *) RemoveHeadI(); }

    OBJECT *RemoveTail() { return (OBJECT *) RemoveTailI(); }

    OBJECT *Remove(POSITION p) { return (OBJECT *) RemoveI(p); }
    POSITION AddBefore(POSITION p, OBJECT * pObj) { return AddBeforeI(p, pObj); }
    POSITION AddAfter(POSITION p, OBJECT * pObj)  { return AddAfterI(p, pObj); }
    POSITION AddHead(OBJECT * pObj) { return AddHeadI(pObj); }
    POSITION AddTail(OBJECT * pObj)  { return AddTailI(pObj); }
    BOOL AddTail(CGenericList<OBJECT> *pList)
            { return CBaseList::AddTail((CBaseList *) pList); }
    BOOL AddHead(CGenericList<OBJECT> *pList)
            { return CBaseList::AddHead((CBaseList *) pList); }
    BOOL AddAfter(POSITION p, CGenericList<OBJECT> *pList)
            { return CBaseList::AddAfter(p, (CBaseList *) pList); };
    BOOL AddBefore(POSITION p, CGenericList<OBJECT> *pList)
            { return CBaseList::AddBefore(p, (CBaseList *) pList); };
    POSITION Find( OBJECT * pObj) const { return FindI(pObj); }
}; // end of class declaration



/* These define the standard list types */

typedef CGenericList<CBaseObject> CBaseObjectList;
typedef CGenericList<IUnknown> CBaseInterfaceList;

#endif /* __WXLIST__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\base\wxutil.h ===
//------------------------------------------------------------------------------
// File: WXUtil.h
//
// Desc: DirectShow base classes - defines helper classes and functions for
//       building multimedia filters.
//
// Copyright (c) 1992-2001 Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __WXUTIL__
#define __WXUTIL__

// eliminate spurious "statement has no effect" warnings.
#pragma warning(disable: 4705)

// wrapper for whatever critical section we have
class CCritSec {

    // make copy constructor and assignment operator inaccessible

    CCritSec(const CCritSec &refCritSec);
    CCritSec &operator=(const CCritSec &refCritSec);

    CRITICAL_SECTION m_CritSec;

#ifdef DEBUG
public:
    DWORD   m_currentOwner;
    DWORD   m_lockCount;
    BOOL    m_fTrace;        // Trace this one
public:
    CCritSec();
    ~CCritSec();
    void Lock();
    void Unlock();
#else

public:
    CCritSec() {
        InitializeCriticalSection(&m_CritSec);
    };

    ~CCritSec() {
        DeleteCriticalSection(&m_CritSec);
    };

    void Lock() {
        EnterCriticalSection(&m_CritSec);
    };

    void Unlock() {
        LeaveCriticalSection(&m_CritSec);
    };
#endif
};

//
// To make deadlocks easier to track it is useful to insert in the
// code an assertion that says whether we own a critical section or
// not.  We make the routines that do the checking globals to avoid
// having different numbers of member functions in the debug and
// retail class implementations of CCritSec.  In addition we provide
// a routine that allows usage of specific critical sections to be
// traced.  This is NOT on by default - there are far too many.
//

#ifdef DEBUG
    BOOL WINAPI CritCheckIn(CCritSec * pcCrit);
    BOOL WINAPI CritCheckIn(const CCritSec * pcCrit);
    BOOL WINAPI CritCheckOut(CCritSec * pcCrit);
    BOOL WINAPI CritCheckOut(const CCritSec * pcCrit);
    void WINAPI DbgLockTrace(CCritSec * pcCrit, BOOL fTrace);
#else
    #define CritCheckIn(x) TRUE
    #define CritCheckOut(x) TRUE
    #define DbgLockTrace(pc, fT)
#endif


// locks a critical section, and unlocks it automatically
// when the lock goes out of scope
class CAutoLock {

    // make copy constructor and assignment operator inaccessible

    CAutoLock(const CAutoLock &refAutoLock);
    CAutoLock &operator=(const CAutoLock &refAutoLock);

protected:
    CCritSec * m_pLock;

public:
    CAutoLock(CCritSec * plock)
    {
        m_pLock = plock;
        m_pLock->Lock();
    };

    ~CAutoLock() {
        m_pLock->Unlock();
    };
};



// wrapper for event objects
class CAMEvent
{

    // make copy constructor and assignment operator inaccessible

    CAMEvent(const CAMEvent &refEvent);
    CAMEvent &operator=(const CAMEvent &refEvent);

protected:
    HANDLE m_hEvent;
public:
    CAMEvent(BOOL fManualReset = FALSE);
    ~CAMEvent();

    // Cast to HANDLE - we don't support this as an lvalue
    operator HANDLE () const { return m_hEvent; };

    void Set() {EXECUTE_ASSERT(SetEvent(m_hEvent));};
    BOOL Wait(DWORD dwTimeout = INFINITE) {
	return (WaitForSingleObject(m_hEvent, dwTimeout) == WAIT_OBJECT_0);
    };
    void Reset() { ResetEvent(m_hEvent); };
    BOOL Check() { return Wait(0); };
};


// wrapper for event objects that do message processing
// This adds ONE method to the CAMEvent object to allow sent
// messages to be processed while waiting

class CAMMsgEvent : public CAMEvent
{

public:

    // Allow SEND messages to be processed while waiting
    BOOL WaitMsg(DWORD dwTimeout = INFINITE);
};

// old name supported for the time being
#define CTimeoutEvent CAMEvent

// support for a worker thread

// simple thread class supports creation of worker thread, synchronization
// and communication. Can be derived to simplify parameter passing
class AM_NOVTABLE CAMThread {

    // make copy constructor and assignment operator inaccessible

    CAMThread(const CAMThread &refThread);
    CAMThread &operator=(const CAMThread &refThread);

    CAMEvent m_EventSend;
    CAMEvent m_EventComplete;

    DWORD m_dwParam;
    DWORD m_dwReturnVal;

protected:
    HANDLE m_hThread;

    // thread will run this function on startup
    // must be supplied by derived class
    virtual DWORD ThreadProc() = 0;

public:
    CAMThread();
    virtual ~CAMThread();

    CCritSec m_AccessLock;	// locks access by client threads
    CCritSec m_WorkerLock;	// locks access to shared objects

    // thread initially runs this. param is actually 'this'. function
    // just gets this and calls ThreadProc
    static DWORD WINAPI InitialThreadProc(LPVOID pv);

    // start thread running  - error if already running
    BOOL Create();

    // signal the thread, and block for a response
    //
    DWORD CallWorker(DWORD);

    // accessor thread calls this when done with thread (having told thread
    // to exit)
    void Close() {
        HANDLE hThread = (HANDLE)InterlockedExchangePointer(&m_hThread, 0);
        if (hThread) {
            WaitForSingleObject(hThread, INFINITE);
            CloseHandle(hThread);
        }
    };

    // ThreadExists
    // Return TRUE if the thread exists. FALSE otherwise
    BOOL ThreadExists(void) const
    {
        if (m_hThread == 0) {
            return FALSE;
        } else {
            return TRUE;
        }
    }

    // wait for the next request
    DWORD GetRequest();

    // is there a request?
    BOOL CheckRequest(DWORD * pParam);

    // reply to the request
    void Reply(DWORD);

    // If you want to do WaitForMultipleObjects you'll need to include
    // this handle in your wait list or you won't be responsive
    HANDLE GetRequestHandle() const { return m_EventSend; };

    // Find out what the request was
    DWORD GetRequestParam() const { return m_dwParam; };

    // call CoInitializeEx (COINIT_DISABLE_OLE1DDE) if
    // available. S_FALSE means it's not available.
    static HRESULT CoInitializeHelper();
};


// CQueue
//
// Implements a simple Queue ADT.  The queue contains a finite number of
// objects, access to which is controlled by a semaphore.  The semaphore
// is created with an initial count (N).  Each time an object is added
// a call to WaitForSingleObject is made on the semaphore's handle.  When
// this function returns a slot has been reserved in the queue for the new
// object.  If no slots are available the function blocks until one becomes
// available.  Each time an object is removed from the queue ReleaseSemaphore
// is called on the semaphore's handle, thus freeing a slot in the queue.
// If no objects are present in the queue the function blocks until an
// object has been added.

#define DEFAULT_QUEUESIZE   2

template <class T> class CQueue {
private:
    HANDLE          hSemPut;        // Semaphore controlling queue "putting"
    HANDLE          hSemGet;        // Semaphore controlling queue "getting"
    CRITICAL_SECTION CritSect;      // Thread seriallization
    int             nMax;           // Max objects allowed in queue
    int             iNextPut;       // Array index of next "PutMsg"
    int             iNextGet;       // Array index of next "GetMsg"
    T              *QueueObjects;   // Array of objects (ptr's to void)

    void Initialize(int n) {
        iNextPut = iNextGet = 0;
        nMax = n;
        InitializeCriticalSection(&CritSect);
        hSemPut = CreateSemaphore(NULL, n, n, NULL);
        hSemGet = CreateSemaphore(NULL, 0, n, NULL);
        QueueObjects = new T[n];
    }


public:
    CQueue(int n) {
        Initialize(n);
    }

    CQueue() {
        Initialize(DEFAULT_QUEUESIZE);
    }

    ~CQueue() {
        delete [] QueueObjects;
        DeleteCriticalSection(&CritSect);
        CloseHandle(hSemPut);
        CloseHandle(hSemGet);
    }

    T GetQueueObject() {
        int iSlot;
        T Object;
        LONG lPrevious;

        // Wait for someone to put something on our queue, returns straight
        // away is there is already an object on the queue.
        //
        WaitForSingleObject(hSemGet, INFINITE);

        EnterCriticalSection(&CritSect);
        iSlot = iNextGet++ % nMax;
        Object = QueueObjects[iSlot];
        LeaveCriticalSection(&CritSect);

        // Release anyone waiting to put an object onto our queue as there
        // is now space available in the queue.
        //
        ReleaseSemaphore(hSemPut, 1L, &lPrevious);
        return Object;
    }

    void PutQueueObject(T Object) {
        int iSlot;
        LONG lPrevious;

        // Wait for someone to get something from our queue, returns straight
        // away is there is already an empty slot on the queue.
        //
        WaitForSingleObject(hSemPut, INFINITE);

        EnterCriticalSection(&CritSect);
        iSlot = iNextPut++ % nMax;
        QueueObjects[iSlot] = Object;
        LeaveCriticalSection(&CritSect);

        // Release anyone waiting to remove an object from our queue as there
        // is now an object available to be removed.
        //
        ReleaseSemaphore(hSemGet, 1L, &lPrevious);
    }
};

// miscellaneous string conversion functions
// NOTE: as we need to use the same binaries on Win95 as on NT this code should
// be compiled WITHOUT unicode being defined.  Otherwise we will not pick up
// these internal routines and the binary will not run on Win95.

int WINAPIV wsprintfWInternal(LPWSTR, LPCWSTR, ...);

LPWSTR
WINAPI
lstrcpyWInternal(
    LPWSTR lpString1,
    LPCWSTR lpString2
    );
LPWSTR
WINAPI
lstrcpynWInternal(
    LPWSTR lpString1,
    LPCWSTR lpString2,
    int     iMaxLength
    );
int
WINAPI
lstrcmpWInternal(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    );
int
WINAPI
lstrcmpiWInternal(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    );
int
WINAPI
lstrlenWInternal(
    LPCWSTR lpString
    );

#ifndef UNICODE
#define wsprintfW wsprintfWInternal
#define lstrcpyW lstrcpyWInternal
#define lstrcpynW lstrcpynWInternal
#define lstrcmpW lstrcmpWInternal
#define lstrcmpiW lstrcmpiWInternal
#define lstrlenW lstrlenWInternal
#endif

extern "C"
void * __stdcall memmoveInternal(void *, const void *, size_t);

inline void * __cdecl memchrInternal(const void *buf, int chr, size_t cnt)
{
#ifdef _X86_
    void *pRet = NULL;

    _asm {
        cld                 // make sure we get the direction right
        mov     ecx, cnt    // num of bytes to scan
        mov     edi, buf    // pointer byte stream
        mov     eax, chr    // byte to scan for
        repne   scasb       // look for the byte in the byte stream
        jnz     exit_memchr // Z flag set if byte found
        dec     edi         // scasb always increments edi even when it
                            // finds the required byte
        mov     pRet, edi
exit_memchr:
    }
    return pRet;

#else
    while ( cnt && (*(unsigned char *)buf != (unsigned char)chr) ) {
        buf = (unsigned char *)buf + 1;
        cnt--;
    }

    return(cnt ? (void *)buf : NULL);
#endif
}

void WINAPI IntToWstr(int i, LPWSTR wstr);

#define WstrToInt(sz) _wtoi(sz)
#define atoiW(sz) _wtoi(sz)
#define atoiA(sz) atoi(sz)

// These are available to help managing bitmap VIDEOINFOHEADER media structures

extern const DWORD bits555[3];
extern const DWORD bits565[3];
extern const DWORD bits888[3];

// These help convert between VIDEOINFOHEADER and BITMAPINFO structures

STDAPI_(const GUID) GetTrueColorType(const BITMAPINFOHEADER *pbmiHeader);
STDAPI_(const GUID) GetBitmapSubtype(const BITMAPINFOHEADER *pbmiHeader);
STDAPI_(WORD) GetBitCount(const GUID *pSubtype);

// strmbase.lib implements this for compatibility with people who
// managed to link to this directly.  we don't want to advertise it.
//
// STDAPI_(/* T */ CHAR *) GetSubtypeName(const GUID *pSubtype);

STDAPI_(CHAR *) GetSubtypeNameA(const GUID *pSubtype);
STDAPI_(WCHAR *) GetSubtypeNameW(const GUID *pSubtype);

#ifdef UNICODE
#define GetSubtypeName GetSubtypeNameW
#else
#define GetSubtypeName GetSubtypeNameA
#endif

STDAPI_(LONG) GetBitmapFormatSize(const BITMAPINFOHEADER *pHeader);
STDAPI_(DWORD) GetBitmapSize(const BITMAPINFOHEADER *pHeader);
STDAPI_(BOOL) ContainsPalette(const VIDEOINFOHEADER *pVideoInfo);
STDAPI_(const RGBQUAD *) GetBitmapPalette(const VIDEOINFOHEADER *pVideoInfo);


// Compares two interfaces and returns TRUE if they are on the same object
BOOL WINAPI IsEqualObject(IUnknown *pFirst, IUnknown *pSecond);

// This is for comparing pins
#define EqualPins(pPin1, pPin2) IsEqualObject(pPin1, pPin2)


// Arithmetic helper functions

// Compute (a * b + rnd) / c
LONGLONG WINAPI llMulDiv(LONGLONG a, LONGLONG b, LONGLONG c, LONGLONG rnd);
LONGLONG WINAPI Int64x32Div32(LONGLONG a, LONG b, LONG c, LONG rnd);


// Avoids us dyna-linking to SysAllocString to copy BSTR strings
STDAPI WriteBSTR(BSTR * pstrDest, LPCWSTR szSrc);
STDAPI FreeBSTR(BSTR* pstr);

// Return a wide string - allocating memory for it
// Returns:
//    S_OK          - no error
//    E_POINTER     - ppszReturn == NULL
//    E_OUTOFMEMORY - can't allocate memory for returned string
STDAPI AMGetWideString(LPCWSTR pszString, LPWSTR *ppszReturn);

// Special wait for objects owning windows
DWORD WINAPI WaitDispatchingMessages(
    HANDLE hObject,
    DWORD dwWait,
    HWND hwnd = NULL,
    UINT uMsg = 0,
    HANDLE hEvent = NULL);

// HRESULT_FROM_WIN32 converts ERROR_SUCCESS to a success code, but in
// our use of HRESULT_FROM_WIN32, it typically means a function failed
// to call SetLastError(), and we still want a failure code.
//
#define AmHresultFromWin32(x) (MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, x))

// call GetLastError and return an HRESULT value that will fail the
// SUCCEEDED() macro.
HRESULT AmGetLastErrorToHResult(void);

// duplicate of ATL's CComPtr to avoid linker conflicts.

IUnknown* QzAtlComPtrAssign(IUnknown** pp, IUnknown* lp);

template <class T>
class QzCComPtr
{
public:
	typedef T _PtrClass;
	QzCComPtr() {p=NULL;}
	QzCComPtr(T* lp)
	{
		if ((p = lp) != NULL)
			p->AddRef();
	}
	QzCComPtr(const QzCComPtr<T>& lp)
	{
		if ((p = lp.p) != NULL)
			p->AddRef();
	}
	~QzCComPtr() {if (p) p->Release();}
	void Release() {if (p) p->Release(); p=NULL;}
	operator T*() {return (T*)p;}
	T& operator*() {ASSERT(p!=NULL); return *p; }
	//The assert on operator& usually indicates a bug.  If this is really
	//what is needed, however, take the address of the p member explicitly.
	T** operator&() { ASSERT(p==NULL); return &p; }
	T* operator->() { ASSERT(p!=NULL); return p; }
	T* operator=(T* lp){return (T*)QzAtlComPtrAssign((IUnknown**)&p, lp);}
	T* operator=(const QzCComPtr<T>& lp)
	{
		return (T*)QzAtlComPtrAssign((IUnknown**)&p, lp.p);
	}
#if _MSC_VER>1020
	bool operator!(){return (p == NULL);}
#else
	BOOL operator!(){return (p == NULL) ? TRUE : FALSE;}
#endif
	T* p;
};

MMRESULT CompatibleTimeSetEvent( UINT uDelay, UINT uResolution, LPTIMECALLBACK lpTimeProc, DWORD_PTR dwUser, UINT fuEvent );
bool TimeKillSynchronousFlagAvailable( void );

#endif /* __WXUTIL__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\base\wxlist.cpp ===
//------------------------------------------------------------------------------
// File: WXList.cpp
//
// Desc: DirectShow base classes - implements a non-MFC based generic list
//       template class.
//
//@@BEGIN_MSINTERNAL
//
//       December 1994
//
//@@END_MSINTERNAL
// Copyright (c) 1992-2001 Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


/* A generic list of pointers to objects.
   Objectives: avoid using MFC libraries in ndm kernel mode and
   provide a really useful list type.

   The class is thread safe in that separate threads may add and
   delete items in the list concurrently although the application
   must ensure that constructor and destructor access is suitably
   synchronised.

   The list name must not conflict with MFC classes as an
   application may use both

   The nodes form a doubly linked, NULL terminated chain with an anchor
   block (the list object per se) holding pointers to the first and last
   nodes and a count of the nodes.
   There is a node cache to reduce the allocation and freeing overhead.
   It optionally (determined at construction time) has an Event which is
   set whenever the list becomes non-empty and reset whenever it becomes
   empty.
   It optionally (determined at construction time) has a Critical Section
   which is entered during the important part of each operation.  (About
   all you can do outside it is some parameter checking).

   The node cache is a repository of nodes that are NOT in the list to speed
   up storage allocation.  Each list has its own cache to reduce locking and
   serialising.  The list accesses are serialised anyway for a given list - a
   common cache would mean that we would have to separately serialise access
   of all lists within the cache.  Because the cache only stores nodes that are
   not in the list, releasing the cache does not release any list nodes.  This
   means that list nodes can be copied or rechained from one list to another
   without danger of creating a dangling reference if the original cache goes
   away.

   Questionable design decisions:
   1. Retaining the warts for compatibility
   2. Keeping an element count -i.e. counting whenever we do anything
      instead of only when we want the count.
   3. Making the chain pointers NULL terminated.  If the list object
      itself looks just like a node and the list is kept as a ring then
      it reduces the number of special cases.  All inserts look the same.
*/


#include <streams.h>

/* set cursor to the position of each element of list in turn  */
#define INTERNALTRAVERSELIST(list, cursor)               \
for ( cursor = (list).GetHeadPositionI()           \
    ; cursor!=NULL                               \
    ; cursor = (list).Next(cursor)                \
    )


/* set cursor to the position of each element of list in turn
   in reverse order
*/
#define INTERNALREVERSETRAVERSELIST(list, cursor)        \
for ( cursor = (list).GetTailPositionI()           \
    ; cursor!=NULL                               \
    ; cursor = (list).Prev(cursor)                \
    )

/* Constructor calls a separate initialisation function that
   creates a node cache, optionally creates a lock object
   and optionally creates a signaling object.

   By default we create a locking object, a DEFAULTCACHE sized
   cache but no event object so the list cannot be used in calls
   to WaitForSingleObject
*/
CBaseList::CBaseList(TCHAR *pName,    // Descriptive list name
                     INT iItems) :    // Node cache size
#ifdef DEBUG
    CBaseObject(pName),
#endif
    m_pFirst(NULL),
    m_pLast(NULL),
    m_Count(0),
    m_Cache(iItems)
{
} // constructor

CBaseList::CBaseList(TCHAR *pName) :  // Descriptive list name
#ifdef DEBUG
    CBaseObject(pName),
#endif
    m_pFirst(NULL),
    m_pLast(NULL),
    m_Count(0),
    m_Cache(DEFAULTCACHE)
{
} // constructor

#ifdef UNICODE
CBaseList::CBaseList(CHAR *pName,    // Descriptive list name
                     INT iItems) :    // Node cache size
#ifdef DEBUG
    CBaseObject(pName),
#endif
    m_pFirst(NULL),
    m_pLast(NULL),
    m_Count(0),
    m_Cache(iItems)
{
} // constructor

CBaseList::CBaseList(CHAR *pName) :  // Descriptive list name
#ifdef DEBUG
    CBaseObject(pName),
#endif
    m_pFirst(NULL),
    m_pLast(NULL),
    m_Count(0),
    m_Cache(DEFAULTCACHE)
{
} // constructor

#endif

/* The destructor enumerates all the node objects in the list and
   in the cache deleting each in turn. We do not do any processing
   on the objects that the list holds (i.e. points to) so if they
   represent interfaces for example the creator of the list should
   ensure that each of them is released before deleting us
*/
CBaseList::~CBaseList()
{
    /* Delete all our list nodes */

    RemoveAll();

} // destructor

/* Remove all the nodes from the list but don't do anything
   with the objects that each node looks after (this is the
   responsibility of the creator).
   Aa a last act we reset the signalling event
   (if available) to indicate to clients that the list
   does not have any entries in it.
*/
void CBaseList::RemoveAll()
{
    /* Free up all the CNode objects NOTE we don't bother putting the
       deleted nodes into the cache as this method is only really called
       in serious times of change such as when we are being deleted at
       which point the cache will be deleted anway */

    CNode *pn = m_pFirst;
    while (pn) {
        CNode *op = pn;
        pn = pn->Next();
        delete op;
    }

    /* Reset the object count and the list pointers */

    m_Count = 0;
    m_pFirst = m_pLast = NULL;

} // RemoveAll



/* Return a position enumerator for the entire list.
   A position enumerator is a pointer to a node object cast to a
   transparent type so all we do is return the head/tail node
   pointer in the list.
   WARNING because the position is a pointer to a node there is
   an implicit assumption for users a the list class that after
   deleting an object from the list that any other position
   enumerators that you have may be invalid (since the node
   may be gone).
*/
POSITION CBaseList::GetHeadPositionI() const
{
    return (POSITION) m_pFirst;
} // GetHeadPosition



POSITION CBaseList::GetTailPositionI() const
{
    return (POSITION) m_pLast;
} // GetTailPosition



/* Get the number of objects in the list,
   Get the lock before accessing the count.
   Locking may not be entirely necessary but it has the side effect
   of making sure that all operations are complete before we get it.
   So for example if a list is being added to this list then that
   will have completed in full before we continue rather than seeing
   an intermediate albeit valid state
*/
int CBaseList::GetCountI() const
{
    return m_Count;
} // GetCount



/* Return the object at rp, update rp to the next object from
   the list or NULL if you have moved over the last object.
   You may still call this function once we return NULL but
   we will continue to return a NULL position value
*/
void *CBaseList::GetNextI(POSITION& rp) const
{
    /* have we reached the end of the list */

    if (rp == NULL) {
        return NULL;
    }

    /* Lock the object before continuing */

    void *pObject;

    /* Copy the original position then step on */

    CNode *pn = (CNode *) rp;
    ASSERT(pn != NULL);
    rp = (POSITION) pn->Next();

    /* Get the object at the original position from the list */

    pObject = pn->GetData();
    // ASSERT(pObject != NULL);    // NULL pointers in the list are allowed.
    return pObject;
} //GetNext



/* Return the object at p.
   Asking for the object at NULL ASSERTs then returns NULL
   The object is NOT locked.  The list is not being changed
   in any way.  If another thread is busy deleting the object
   then locking would only result in a change from one bad
   behaviour to another.
*/
void *CBaseList::GetI(POSITION p) const
{
    if (p == NULL) {
        return NULL;
    }

    CNode * pn = (CNode *) p;
    void *pObject = pn->GetData();
    // ASSERT(pObject != NULL);    // NULL pointers in the list are allowed.
    return pObject;
} //Get



/* Return the first position in the list which holds the given pointer.
   Return NULL if it's not found.
*/
POSITION CBaseList::FindI( void * pObj) const
{
    POSITION pn;
    INTERNALTRAVERSELIST(*this, pn){
        if (GetI(pn)==pObj) {
            return pn;
        }
    }
    return NULL;
} // Find



/* Remove the first node in the list (deletes the pointer to its object
   from the list, does not free the object itself).
   Return the pointer to its object or NULL if empty
*/
void *CBaseList::RemoveHeadI()
{
    /* All we do is get the head position and ask for that to be deleted.
       We could special case this since some of the code path checking
       in Remove() is redundant as we know there is no previous
       node for example but it seems to gain little over the
       added complexity
    */

    return RemoveI((POSITION)m_pFirst);
} // RemoveHead



/* Remove the last node in the list (deletes the pointer to its object
   from the list, does not free the object itself).
   Return the pointer to its object or NULL if empty
*/
void *CBaseList::RemoveTailI()
{
    /* All we do is get the tail position and ask for that to be deleted.
       We could special case this since some of the code path checking
       in Remove() is redundant as we know there is no previous
       node for example but it seems to gain little over the
       added complexity
    */

    return RemoveI((POSITION)m_pLast);
} // RemoveTail



/* Remove the pointer to the object in this position from the list.
   Deal with all the chain pointers
   Return a pointer to the object removed from the list.
   The node object that is freed as a result
   of this operation is added to the node cache where
   it can be used again.
   Remove(NULL) is a harmless no-op - but probably is a wart.
*/
void *CBaseList::RemoveI(POSITION pos)
{
    /* Lock the critical section before continuing */

    // ASSERT (pos!=NULL);     // Removing NULL is to be harmless!
    if (pos==NULL) return NULL;


    CNode *pCurrent = (CNode *) pos;
    ASSERT(pCurrent != NULL);

    /* Update the previous node */

    CNode *pNode = pCurrent->Prev();
    if (pNode == NULL) {
        m_pFirst = pCurrent->Next();
    } else {
        pNode->SetNext(pCurrent->Next());
    }

    /* Update the following node */

    pNode = pCurrent->Next();
    if (pNode == NULL) {
        m_pLast = pCurrent->Prev();
    } else {
        pNode->SetPrev(pCurrent->Prev());
    }

    /* Get the object this node was looking after */

    void *pObject = pCurrent->GetData();

    // ASSERT(pObject != NULL);    // NULL pointers in the list are allowed.

    /* Try and add the node object to the cache -
       a NULL return code from the cache means we ran out of room.
       The cache size is fixed by a constructor argument when the
       list is created and defaults to DEFAULTCACHE.
       This means that the cache will have room for this many
       node objects. So if you have a list of media samples
       and you know there will never be more than five active at
       any given time of them for example then override the default
       constructor
    */

    m_Cache.AddToCache(pCurrent);

    /* If the list is empty then reset the list event */

    --m_Count;
    ASSERT(m_Count >= 0);
    return pObject;
} // Remove



/* Add this object to the tail end of our list
   Return the new tail position.
*/

POSITION CBaseList::AddTailI(void *pObject)
{
    /* Lock the critical section before continuing */

    CNode *pNode;
    // ASSERT(pObject);   // NULL pointers in the list are allowed.

    /* If there is a node objects in the cache then use
       that otherwise we will have to create a new one */

    pNode = (CNode *) m_Cache.RemoveFromCache();
    if (pNode == NULL) {
        pNode = new CNode;
    }

    /* Check we have a valid object */

    if (pNode == NULL) {
        return NULL;
    }

    /* Initialise all the CNode object
       just in case it came from the cache
    */

    pNode->SetData(pObject);
    pNode->SetNext(NULL);
    pNode->SetPrev(m_pLast);

    if (m_pLast == NULL) {
        m_pFirst = pNode;
    } else {
        m_pLast->SetNext(pNode);
    }

    /* Set the new last node pointer and also increment the number
       of list entries, the critical section is unlocked when we
       exit the function
    */

    m_pLast = pNode;
    ++m_Count;

    return (POSITION) pNode;
} // AddTail(object)



/* Add this object to the head end of our list
   Return the new head position.
*/
POSITION CBaseList::AddHeadI(void *pObject)
{
    CNode *pNode;
    // ASSERT(pObject);  // NULL pointers in the list are allowed.

    /* If there is a node objects in the cache then use
       that otherwise we will have to create a new one */

    pNode = (CNode *) m_Cache.RemoveFromCache();
    if (pNode == NULL) {
        pNode = new CNode;
    }

    /* Check we have a valid object */

    if (pNode == NULL) {
        return NULL;
    }

    /* Initialise all the CNode object
       just in case it came from the cache
    */

    pNode->SetData(pObject);

    /* chain it in (set four pointers) */
    pNode->SetPrev(NULL);
    pNode->SetNext(m_pFirst);

    if (m_pFirst == NULL) {
        m_pLast = pNode;
    } else {
        m_pFirst->SetPrev(pNode);
    }
    m_pFirst = pNode;

    ++m_Count;

    return (POSITION) pNode;
} // AddHead(object)



/* Add all the elements in *pList to the tail of this list.
   Return TRUE if it all worked, FALSE if it didn't.
   If it fails some elements may have been added.
*/
BOOL CBaseList::AddTail(CBaseList *pList)
{
    /* lock the object before starting then enumerate
       each entry in the source list and add them one by one to
       our list (while still holding the object lock)
       Lock the other list too.
    */
    POSITION pos = pList->GetHeadPositionI();

    while (pos) {
       if (NULL == AddTailI(pList->GetNextI(pos))) {
           return FALSE;
       }
    }
    return TRUE;
} // AddTail(list)



/* Add all the elements in *pList to the head of this list.
   Return TRUE if it all worked, FALSE if it didn't.
   If it fails some elements may have been added.
*/
BOOL CBaseList::AddHead(CBaseList *pList)
{
    /* lock the object before starting then enumerate
       each entry in the source list and add them one by one to
       our list (while still holding the object lock)
       Lock the other list too.

       To avoid reversing the list, traverse it backwards.
    */

    POSITION pos;

    INTERNALREVERSETRAVERSELIST(*pList, pos) {
        if (NULL== AddHeadI(pList->GetI(pos))){
            return FALSE;
        }
    }
    return TRUE;
} // AddHead(list)



/* Add the object after position p
   p is still valid after the operation.
   AddAfter(NULL,x) adds x to the start - same as AddHead
   Return the position of the new object, NULL if it failed
*/
POSITION  CBaseList::AddAfterI(POSITION pos, void * pObj)
{
    if (pos==NULL)
        return AddHeadI(pObj);

    /* As someone else might be furkling with the list -
       Lock the critical section before continuing
    */
    CNode *pAfter = (CNode *) pos;
    ASSERT(pAfter != NULL);
    if (pAfter==m_pLast)
        return AddTailI(pObj);

    /* set pnode to point to a new node, preferably from the cache */

    CNode *pNode = (CNode *) m_Cache.RemoveFromCache();
    if (pNode == NULL) {
        pNode = new CNode;
    }

    /* Check we have a valid object */

    if (pNode == NULL) {
        return NULL;
    }

    /* Initialise all the CNode object
       just in case it came from the cache
    */

    pNode->SetData(pObj);

    /* It is to be added to the middle of the list - there is a before
       and after node.  Chain it after pAfter, before pBefore.
    */
    CNode * pBefore = pAfter->Next();
    ASSERT(pBefore != NULL);

    /* chain it in (set four pointers) */
    pNode->SetPrev(pAfter);
    pNode->SetNext(pBefore);
    pBefore->SetPrev(pNode);
    pAfter->SetNext(pNode);

    ++m_Count;

    return (POSITION) pNode;

} // AddAfter(object)



BOOL CBaseList::AddAfter(POSITION p, CBaseList *pList)
{
    POSITION pos;
    INTERNALTRAVERSELIST(*pList, pos) {
        /* p follows along the elements being added */
        p = AddAfterI(p, pList->GetI(pos));
        if (p==NULL) return FALSE;
    }
    return TRUE;
} // AddAfter(list)



/* Mirror images:
   Add the element or list after position p.
   p is still valid after the operation.
   AddBefore(NULL,x) adds x to the end - same as AddTail
*/
POSITION CBaseList::AddBeforeI(POSITION pos, void * pObj)
{
    if (pos==NULL)
        return AddTailI(pObj);

    /* set pnode to point to a new node, preferably from the cache */

    CNode *pBefore = (CNode *) pos;
    ASSERT(pBefore != NULL);
    if (pBefore==m_pFirst)
        return AddHeadI(pObj);

    CNode * pNode = (CNode *) m_Cache.RemoveFromCache();
    if (pNode == NULL) {
        pNode = new CNode;
    }

    /* Check we have a valid object */

    if (pNode == NULL) {
        return NULL;
    }

    /* Initialise all the CNode object
       just in case it came from the cache
    */

    pNode->SetData(pObj);

    /* It is to be added to the middle of the list - there is a before
       and after node.  Chain it after pAfter, before pBefore.
    */

    CNode * pAfter = pBefore->Prev();
    ASSERT(pAfter != NULL);

    /* chain it in (set four pointers) */
    pNode->SetPrev(pAfter);
    pNode->SetNext(pBefore);
    pBefore->SetPrev(pNode);
    pAfter->SetNext(pNode);

    ++m_Count;

    return (POSITION) pNode;

} // Addbefore(object)



BOOL CBaseList::AddBefore(POSITION p, CBaseList *pList)
{
    POSITION pos;
    INTERNALREVERSETRAVERSELIST(*pList, pos) {
        /* p follows along the elements being added */
        p = AddBeforeI(p, pList->GetI(pos));
        if (p==NULL) return FALSE;
    }
    return TRUE;
} // AddBefore(list)



/* Split *this after position p in *this
   Retain as *this the tail portion of the original *this
   Add the head portion to the tail end of *pList
   Return TRUE if it all worked, FALSE if it didn't.

   e.g.
      foo->MoveToTail(foo->GetHeadPosition(), bar);
          moves one element from the head of foo to the tail of bar
      foo->MoveToTail(NULL, bar);
          is a no-op
      foo->MoveToTail(foo->GetTailPosition, bar);
          concatenates foo onto the end of bar and empties foo.

   A better, except excessively long name might be
       MoveElementsFromHeadThroughPositionToOtherTail
*/
BOOL CBaseList::MoveToTail
        (POSITION pos, CBaseList *pList)
{
    /* Algorithm:
       Note that the elements (including their order) in the concatenation
       of *pList to the head of *this is invariant.
       1. Count elements to be moved
       2. Join *pList onto the head of this to make one long chain
       3. Set first/Last pointers in *this and *pList
       4. Break the chain at the new place
       5. Adjust counts
       6. Set/Reset any events
    */

    if (pos==NULL) return TRUE;  // no-op.  Eliminates special cases later.


    /* Make cMove the number of nodes to move */
    CNode * p = (CNode *)pos;
    int cMove = 0;            // number of nodes to move
    while(p!=NULL) {
       p = p->Prev();
       ++cMove;
    }


    /* Join the two chains together */
    if (pList->m_pLast!=NULL)
        pList->m_pLast->SetNext(m_pFirst);
    if (m_pFirst!=NULL)
        m_pFirst->SetPrev(pList->m_pLast);


    /* set first and last pointers */
    p = (CNode *)pos;

    if (pList->m_pFirst==NULL)
        pList->m_pFirst = m_pFirst;
    m_pFirst = p->Next();
    if (m_pFirst==NULL)
        m_pLast = NULL;
    pList->m_pLast = p;


    /* Break the chain after p to create the new pieces */
    if (m_pFirst!=NULL)
        m_pFirst->SetPrev(NULL);
    p->SetNext(NULL);


    /* Adjust the counts */
    m_Count -= cMove;
    pList->m_Count += cMove;

    return TRUE;

} // MoveToTail



/* Mirror image of MoveToTail:
   Split *this before position p in *this.
   Retain in *this the head portion of the original *this
   Add the tail portion to the start (i.e. head) of *pList
   Return TRUE if it all worked, FALSE if it didn't.

   e.g.
      foo->MoveToHead(foo->GetTailPosition(), bar);
          moves one element from the tail of foo to the head of bar
      foo->MoveToHead(NULL, bar);
          is a no-op
      foo->MoveToHead(foo->GetHeadPosition, bar);
          concatenates foo onto the start of bar and empties foo.
*/
BOOL CBaseList::MoveToHead
        (POSITION pos, CBaseList *pList)
{

    /* See the comments on the algorithm in MoveToTail */

    if (pos==NULL) return TRUE;  // no-op.  Eliminates special cases later.

    /* Make cMove the number of nodes to move */
    CNode * p = (CNode *)pos;
    int cMove = 0;            // number of nodes to move
    while(p!=NULL) {
       p = p->Next();
       ++cMove;
    }


    /* Join the two chains together */
    if (pList->m_pFirst!=NULL)
        pList->m_pFirst->SetPrev(m_pLast);
    if (m_pLast!=NULL)
        m_pLast->SetNext(pList->m_pFirst);


    /* set first and last pointers */
    p = (CNode *)pos;


    if (pList->m_pLast==NULL)
        pList->m_pLast = m_pLast;

    m_pLast = p->Prev();
    if (m_pLast==NULL)
        m_pFirst = NULL;
    pList->m_pFirst = p;


    /* Break the chain after p to create the new pieces */
    if (m_pLast!=NULL)
        m_pLast->SetNext(NULL);
    p->SetPrev(NULL);


    /* Adjust the counts */
    m_Count -= cMove;
    pList->m_Count += cMove;

    return TRUE;

} // MoveToHead



/* Reverse the order of the [pointers to] objects in *this
*/
void CBaseList::Reverse()
{
    /* algorithm:
       The obvious booby trap is that you flip pointers around and lose
       addressability to the node that you are going to process next.
       The easy way to avoid this is do do one chain at a time.

       Run along the forward chain,
       For each node, set the reverse pointer to the one ahead of us.
       The reverse chain is now a copy of the old forward chain, including
       the NULL termination.

       Run along the reverse chain (i.e. old forward chain again)
       For each node set the forward pointer of the node ahead to point back
       to the one we're standing on.
       The first node needs special treatment,
       it's new forward pointer is NULL.
       Finally set the First/Last pointers

    */
    CNode * p;

    // Yes we COULD use a traverse, but it would look funny!
    p = m_pFirst;
    while (p!=NULL) {
        CNode * q;
        q = p->Next();
        p->SetNext(p->Prev());
        p->SetPrev(q);
        p = q;
    }

    p = m_pFirst;
    m_pFirst = m_pLast;
    m_pLast = p;


#if 0     // old version

    if (m_pFirst==NULL) return;          // empty list
    if (m_pFirst->Next()==NULL) return;  // single node list


    /* run along forward chain */
    for ( p = m_pFirst
        ; p!=NULL
        ; p = p->Next()
        ){
        p->SetPrev(p->Next());
    }


    /* special case first element */
    m_pFirst->SetNext(NULL);     // fix the old first element


    /* run along new reverse chain i.e. old forward chain again */
    for ( p = m_pFirst           // start at the old first element
        ; p->Prev()!=NULL        // while there's a node still to be set
        ; p = p->Prev()          // work in the same direction as before
        ){
        p->Prev()->SetNext(p);
    }


    /* fix forward and reverse pointers
       - the triple XOR swap would work but all the casts look hideous */
    p = m_pFirst;
    m_pFirst = m_pLast;
    m_pLast = p;
#endif

} // Reverse
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\dmodev\include\dmoimpl.h ===
//------------------------------------------------------------------------------
// File: DMOImpl.h
//
// Desc: Classes to implement a DMO.
//
// Copyright (c) 2000, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef _dmoimpl_h_
#define _dmoimpl_h_

#ifdef _DEBUG
#include <crtdbg.h>
#endif

//  Class to implement a DMO
//
//
//       Assumes the number of input and output streams is fixed
//       (these are template parameters)
//
//       Provides following services:
//
//          Basic parameter checking and locking
//          Fully implements :
//                 GetStreamCount
//                 SetInputType
//                 SetOutputType
//                 GetCurrentInputType
//                 GetCurrentOutputType
//
//          Checks if all types are set before streaming
//          Automatically calls AllocateStreamingResources before streaming
//              if it's not been called already
//          Prevents streaming until the types on all non-optional streams
//              have been set
//
//
//  Derived class implements the following methods :
//
/*
   HRESULT InternalGetInputStreamInfo(DWORD dwInputStreamIndex, DWORD *pdwFlags);
   HRESULT InternalGetOutputStreamInfo(DWORD dwOutputStreamIndex, DWORD *pdwFlags);
   HRESULT InternalCheckInputType(DWORD dwInputStreamIndex, const DMO_MEDIA_TYPE *pmt);
   HRESULT InternalCheckOutputType(DWORD dwOutputStreamIndex, const DMO_MEDIA_TYPE *pmt);
   HRESULT InternalGetInputType(DWORD dwInputStreamIndex, DWORD dwTypeIndex,
                            DMO_MEDIA_TYPE *pmt);
   HRESULT InternalGetOutputType(DWORD dwOutputStreamIndex, DWORD dwTypeIndex,
                            DMO_MEDIA_TYPE *pmt);
   HRESULT InternalGetInputSizeInfo(DWORD dwInputStreamIndex, DWORD *pcbSize,
                            DWORD *pcbMaxLookahead, DWORD *pcbAlignment);
   HRESULT InternalGetOutputSizeInfo(DWORD dwOutputStreamIndex, DWORD *pcbSize,
                             DWORD *pcbAlignment);
   HRESULT InternalGetInputMaxLatency(DWORD dwInputStreamIndex, REFERENCE_TIME *prtMaxLatency);
   HRESULT InternalSetInputMaxLatency(DWORD dwInputStreamIndex, REFERENCE_TIME rtMaxLatency);
   HRESULT InternalFlush();
   HRESULT InternalDiscontinuity(DWORD dwInputStreamIndex);
   HRESULT InternalAllocateStreamingResources();
   HRESULT InternalFreeStreamingResources();
   HRESULT InternalProcessInput(DWORD dwInputStreamIndex, IMediaBuffer *pBuffer,
                               DWORD dwFlags, REFERENCE_TIME rtTimestamp,
                               REFERENCE_TIME rtTimelength);
   HRESULT InternalProcessOutput(DWORD dwFlags, DWORD cOutputBufferCount,
                               DMO_OUTPUT_DATA_BUFFER *pOutputBuffers,
                           DWORD *pdwStatus);
   HRESULT InternalAcceptingInput(DWORD dwInputStreamIndex);
   void Lock();
   void Unlock();

   Notes:
       The derived class is meant to do most work to initialize streaming
       in AllocateStreamingResources rather than when types are set.

       This centralizes the work to one
       clear place based on the types set for all streams.

       The derived class implements locking.

       The derived class implements the IUnknown methods

   Usage example (1 input and 1 output) :
   class CMyDMO : public IMediaObjectImpl<CMyDmo, 1, 1>,
                  ...
*/


#define INTERNAL_CALL(_T_, _X_) \
    static_cast<_T_ *>(this)->Internal##_X_

template <class _DERIVED_, int NUMBEROFINPUTS, int NUMBEROFOUTPUTS>
class IMediaObjectImpl : public IMediaObject
{
private:
    // Member variables
    struct {
        DWORD   fTypeSet:1;
        DWORD   fIncomplete:1;
        DMO_MEDIA_TYPE CurrentMediaType;
    } m_InputInfo[NUMBEROFINPUTS], m_OutputInfo[NUMBEROFOUTPUTS];

    bool m_fTypesSet;
    bool m_fFlushed;
    bool m_fResourcesAllocated;

protected:

    //  Helpers
    bool InputTypeSet(DWORD ulInputStreamIndex) const
    {
        _ASSERTE(ulInputStreamIndex < NUMBEROFINPUTS);
        return 0 != m_InputInfo[ulInputStreamIndex].fTypeSet;
    }

    bool OutputTypeSet(DWORD ulOutputStreamIndex) const
    {
        _ASSERTE(ulOutputStreamIndex < NUMBEROFOUTPUTS);
        return 0 != m_OutputInfo[ulOutputStreamIndex].fTypeSet;
    }
    const DMO_MEDIA_TYPE *InputType(DWORD ulInputStreamIndex)
    {
        if (!InputTypeSet(ulInputStreamIndex)) {
            return NULL;
        }
        return &m_InputInfo[ulInputStreamIndex].CurrentMediaType;
    }
    const DMO_MEDIA_TYPE *OutputType(DWORD ulOutputStreamIndex)
    {
        if (!OutputTypeSet(ulOutputStreamIndex)) {
            return NULL;
        }
        return &m_OutputInfo[ulOutputStreamIndex].CurrentMediaType;
    }


    class LockIt
    {
    public:
        LockIt(_DERIVED_ *p) : m_p(p)
        {
            static_cast<_DERIVED_ *>(m_p)->Lock();
        }
        ~LockIt()
        {
            static_cast<_DERIVED_ *>(m_p)->Unlock();
        }
        _DERIVED_ *const m_p;
    };

    bool CheckTypesSet()
    {
        m_fTypesSet = false;
        DWORD dw;
        for (dw = 0; dw < NUMBEROFINPUTS; dw++) {
            if (!InputTypeSet(dw)) {
                return false;
            }
        }
        for (dw = 0; dw < NUMBEROFOUTPUTS; dw++) {
            if (!OutputTypeSet(dw)) {
                //  Check if it's optional
                DWORD dwFlags;
#ifdef _DEBUG
                dwFlags = 0xFFFFFFFF;
#endif
                INTERNAL_CALL(_DERIVED_, GetOutputStreamInfo)(dw, &dwFlags);
                _ASSERTE(0 == (dwFlags & ~(DMO_OUTPUT_STREAMF_WHOLE_SAMPLES |
                                         DMO_OUTPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER |
                                         DMO_OUTPUT_STREAMF_FIXED_SAMPLE_SIZE |
                                         DMO_OUTPUT_STREAMF_DISCARDABLE |
                                         DMO_OUTPUT_STREAMF_OPTIONAL)));
                if (!(dwFlags & DMO_OUTPUT_STREAMF_OPTIONAL)) {
                    return false;
                }
            }
        }
        m_fTypesSet = true;
        return true;
    }


    IMediaObjectImpl() :
        m_fTypesSet(false),
        m_fFlushed(true),
        m_fResourcesAllocated(false)
    {
        ZeroMemory(&m_InputInfo, sizeof(m_InputInfo));
        ZeroMemory(&m_OutputInfo, sizeof(m_OutputInfo));
    }

    virtual ~IMediaObjectImpl() {
        DWORD dwCurrentType;

        for (dwCurrentType = 0; dwCurrentType < NUMBEROFINPUTS; dwCurrentType++) {
            if(InputTypeSet(dwCurrentType)) {
                MoFreeMediaType(&m_InputInfo[dwCurrentType].CurrentMediaType);
            }
        }

        for (dwCurrentType = 0; dwCurrentType < NUMBEROFOUTPUTS; dwCurrentType++) {
            if(OutputTypeSet(dwCurrentType)) {
                MoFreeMediaType(&m_OutputInfo[dwCurrentType].CurrentMediaType);
            }
        }
    }


    // IMediaObject methods


    //
    // IMediaObject methods
    //
    STDMETHODIMP GetStreamCount(unsigned long *pulNumberOfInputStreams, unsigned long *pulNumberOfOutputStreams)
    {
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (pulNumberOfInputStreams == NULL ||
            pulNumberOfOutputStreams == NULL) {
            return E_POINTER;
        }
        *pulNumberOfInputStreams  = NUMBEROFINPUTS;
        *pulNumberOfOutputStreams = NUMBEROFOUTPUTS;
        return S_OK;
    }
    STDMETHODIMP GetInputStreamInfo(ULONG ulStreamIndex, DWORD *pdwFlags)
    {
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (pdwFlags == NULL) {
            return E_POINTER;
        }
        HRESULT hr = INTERNAL_CALL(_DERIVED_, GetInputStreamInfo)(ulStreamIndex, pdwFlags);
        _ASSERTE(0 == (*pdwFlags & ~(DMO_INPUT_STREAMF_WHOLE_SAMPLES |
                                   DMO_INPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER |
                                   DMO_INPUT_STREAMF_FIXED_SAMPLE_SIZE |
                                   DMO_INPUT_STREAMF_HOLDS_BUFFERS)));
        return hr;
    }
    STDMETHODIMP GetOutputStreamInfo(ULONG ulStreamIndex, DWORD *pdwFlags)
    {
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (ulStreamIndex >= NUMBEROFOUTPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (pdwFlags == NULL) {
            return E_POINTER;
        }
        HRESULT hr = INTERNAL_CALL(_DERIVED_, GetOutputStreamInfo)(ulStreamIndex, pdwFlags);
        _ASSERTE(0 == (*pdwFlags & ~(DMO_OUTPUT_STREAMF_WHOLE_SAMPLES |
                                   DMO_OUTPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER |
                                   DMO_OUTPUT_STREAMF_FIXED_SAMPLE_SIZE |
                                   DMO_OUTPUT_STREAMF_DISCARDABLE |
                                   DMO_OUTPUT_STREAMF_OPTIONAL)));
        return hr;
    }
    STDMETHODIMP GetInputType(ULONG ulStreamIndex, ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        LockIt lck(static_cast<_DERIVED_ *>(this));
        return INTERNAL_CALL(_DERIVED_, GetInputType)(ulStreamIndex, ulTypeIndex, pmt);
    }
    STDMETHODIMP GetOutputType(ULONG ulStreamIndex, ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
        if (ulStreamIndex >= NUMBEROFOUTPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        LockIt lck(static_cast<_DERIVED_ *>(this));
        return INTERNAL_CALL(_DERIVED_, GetOutputType)(ulStreamIndex, ulTypeIndex, pmt);
    }
    STDMETHODIMP GetInputCurrentType(ULONG ulStreamIndex, DMO_MEDIA_TYPE *pmt) {
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (NULL == pmt) {
            return E_POINTER;
        }
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (InputTypeSet(ulStreamIndex))
            return MoCopyMediaType(pmt,
                                   &m_InputInfo[ulStreamIndex].CurrentMediaType);
        else
           return DMO_E_TYPE_NOT_SET;
    }
    STDMETHODIMP GetOutputCurrentType(ULONG ulStreamIndex, DMO_MEDIA_TYPE *pmt) {
        if (ulStreamIndex >= NUMBEROFOUTPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (NULL == pmt) {
            return E_POINTER;
        }
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (OutputTypeSet(ulStreamIndex))
            return MoCopyMediaType(pmt,
                                   &m_OutputInfo[ulStreamIndex].CurrentMediaType);
        else
           return DMO_E_TYPE_NOT_SET;
    }
    STDMETHODIMP GetInputSizeInfo(ULONG ulStreamIndex, ULONG *pulSize, ULONG *pcbMaxLookahead, ULONG *pulAlignment) {
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (NULL == pulSize || NULL == pulAlignment ||
            NULL == pcbMaxLookahead) {
            return E_POINTER;
        }
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (!InputTypeSet(ulStreamIndex)) {
           return DMO_E_TYPE_NOT_SET;
        }
        return INTERNAL_CALL(_DERIVED_, GetInputSizeInfo)(ulStreamIndex, pulSize, pcbMaxLookahead, pulAlignment);
    }
    STDMETHODIMP GetOutputSizeInfo(ULONG ulStreamIndex, ULONG *pulSize, ULONG *pulAlignment) {
        if (ulStreamIndex >= NUMBEROFOUTPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (NULL == pulSize || NULL == pulAlignment) {
            return E_POINTER;
        }
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (!m_fTypesSet || !OutputTypeSet(ulStreamIndex)) {
           return DMO_E_TYPE_NOT_SET;
        }
        return INTERNAL_CALL(_DERIVED_, GetOutputSizeInfo)(ulStreamIndex, pulSize, pulAlignment);
    }
    STDMETHODIMP SetInputType(ULONG ulStreamIndex, const DMO_MEDIA_TYPE *pmt, DWORD dwFlags) {
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (dwFlags & ~ (DMO_SET_TYPEF_CLEAR | DMO_SET_TYPEF_TEST_ONLY)) {
            return E_INVALIDARG;
        }

        LockIt lck(static_cast<_DERIVED_ *>(this));

        if (dwFlags & DMO_SET_TYPEF_CLEAR) {
            MoFreeMediaType(&m_InputInfo[ulStreamIndex].CurrentMediaType);
            m_InputInfo[ulStreamIndex].fTypeSet = FALSE;
            if (!CheckTypesSet()) {
                Flush();
                FreeStreamingResources();
            }
            return NOERROR;
        }
        if (NULL == pmt) {
            return E_POINTER;
        }
        HRESULT hr = INTERNAL_CALL(_DERIVED_, CheckInputType)(ulStreamIndex, pmt);
        if (FAILED(hr))
           return hr;

        if (dwFlags & DMO_SET_TYPEF_TEST_ONLY) {
           return NOERROR;
        }


        // actually set the type
        DMO_MEDIA_TYPE mtTemp;
        if (S_OK == MoCopyMediaType(&mtTemp, pmt)) {
            // Free any previous mediatype
            if (InputTypeSet(ulStreamIndex)) {
                MoFreeMediaType(&m_InputInfo[ulStreamIndex].CurrentMediaType);
            }
            m_InputInfo[ulStreamIndex].CurrentMediaType = mtTemp;
            m_InputInfo[ulStreamIndex].fTypeSet = TRUE;
            CheckTypesSet();
        } else {
            return E_OUTOFMEMORY;
        }

        return NOERROR;
    }

    STDMETHODIMP SetOutputType(ULONG ulStreamIndex, const DMO_MEDIA_TYPE *pmt, DWORD dwFlags) {
        if (ulStreamIndex >= NUMBEROFOUTPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (dwFlags & ~ (DMO_SET_TYPEF_CLEAR | DMO_SET_TYPEF_TEST_ONLY)) {
            return E_INVALIDARG;
        }

        LockIt lck(static_cast<_DERIVED_ *>(this));

        if (dwFlags & DMO_SET_TYPEF_CLEAR) {
            MoFreeMediaType(&m_OutputInfo[ulStreamIndex].CurrentMediaType);
            m_OutputInfo[ulStreamIndex].fTypeSet = FALSE;
            if (!CheckTypesSet()) {
                Flush();
                FreeStreamingResources();
            }
            return NOERROR;
        }
        if (NULL == pmt) {
            return E_POINTER;
        }
        HRESULT hr = INTERNAL_CALL(_DERIVED_, CheckOutputType)(ulStreamIndex, pmt);
        if (FAILED(hr)) {
           return hr;
        }

        if (dwFlags & DMO_SET_TYPEF_TEST_ONLY) {
           return NOERROR;
        }


        // actually set the type
        DMO_MEDIA_TYPE mtTemp;
        if (S_OK == MoCopyMediaType(&mtTemp, pmt)) {
            // Free any previous mediatype
            if (OutputTypeSet(ulStreamIndex)) {
                MoFreeMediaType(&m_OutputInfo[ulStreamIndex].CurrentMediaType);
            }
            m_OutputInfo[ulStreamIndex].CurrentMediaType = mtTemp;
            m_OutputInfo[ulStreamIndex].fTypeSet = TRUE;
            CheckTypesSet();
        } else {
            return E_OUTOFMEMORY;
        }

        return NOERROR;
    }
    STDMETHODIMP GetInputStatus(
        ULONG ulStreamIndex,
        DWORD *pdwStatus
    ) {
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (NULL == pdwStatus) {
            return E_POINTER;
        }
        *pdwStatus = 0;

        LockIt lck(static_cast<_DERIVED_ *>(this));

        if (!m_fTypesSet) {
            return DMO_E_TYPE_NOT_SET;
        }

        if (INTERNAL_CALL(_DERIVED_, AcceptingInput)(ulStreamIndex) == S_OK) {
           *pdwStatus |= DMO_INPUT_STATUSF_ACCEPT_DATA;
        }
        return NOERROR;
    }
    STDMETHODIMP GetInputMaxLatency(unsigned long ulStreamIndex, REFERENCE_TIME *prtLatency) {

        if (prtLatency == NULL) {
            return E_POINTER;
        }
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }

        LockIt lck(static_cast<_DERIVED_ *>(this));

        return INTERNAL_CALL(_DERIVED_, GetInputMaxLatency)(ulStreamIndex, prtLatency);
    }
    STDMETHODIMP SetInputMaxLatency(unsigned long ulStreamIndex, REFERENCE_TIME rtLatency) {
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }

        LockIt lck(static_cast<_DERIVED_ *>(this));

        return INTERNAL_CALL(_DERIVED_, SetInputMaxLatency)(ulStreamIndex, rtLatency);
    }
    STDMETHODIMP Discontinuity(ULONG ulStreamIndex) {
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }

        LockIt lck(static_cast<_DERIVED_ *>(this));

        if (!m_fTypesSet) {
            return DMO_E_TYPE_NOT_SET;
        }

        if (S_OK != INTERNAL_CALL(_DERIVED_, AcceptingInput)(ulStreamIndex)) {
            return DMO_E_NOTACCEPTING;
        }

        return INTERNAL_CALL(_DERIVED_, Discontinuity)(ulStreamIndex);
    }

    STDMETHODIMP Flush()
    {
        LockIt lck(static_cast<_DERIVED_ *>(this));

        if (!m_fTypesSet) {
            return S_OK;
        }
        if (m_fFlushed) {
            return S_OK;
        }
        HRESULT hr =  INTERNAL_CALL(_DERIVED_, Flush)();
        m_fFlushed = true;
        return hr;
    }

    STDMETHODIMP AllocateStreamingResources() {
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (!m_fTypesSet) {
            return DMO_E_TYPE_NOT_SET;
        }
        if (m_fResourcesAllocated) {
            return S_OK;
        }
        HRESULT hr = INTERNAL_CALL(_DERIVED_, AllocateStreamingResources)();
        if (SUCCEEDED(hr)) {
            m_fResourcesAllocated = true;
        }
        return hr;
    }
    STDMETHODIMP FreeStreamingResources()
    {
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (m_fResourcesAllocated) {
            m_fResourcesAllocated = false;
            INTERNAL_CALL(_DERIVED_, Flush)();
            return INTERNAL_CALL(_DERIVED_, FreeStreamingResources)();
        }
        return S_OK;
    }

    //
    // Processing methods - public entry points
    //
    STDMETHODIMP ProcessInput(
        DWORD ulStreamIndex,
        IMediaBuffer *pBuffer, // [in], must not be NULL
        DWORD dwFlags, // [in] - discontinuity, timestamp, etc.
        REFERENCE_TIME rtTimestamp, // [in], valid if flag set
        REFERENCE_TIME rtTimelength // [in], valid if flag set
    ) {
        if (!pBuffer) {
            return E_POINTER;
        }
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (dwFlags & ~(DMO_INPUT_DATA_BUFFERF_SYNCPOINT |
                        DMO_INPUT_DATA_BUFFERF_TIME |
                        DMO_INPUT_DATA_BUFFERF_TIMELENGTH)) {
            return E_INVALIDARG;
        }

        LockIt lck(static_cast<_DERIVED_ *>(this));

        //  Make sure all streams have media types set and resources are allocated
        HRESULT hr = AllocateStreamingResources();
        if (FAILED(hr)) {
            return hr;
        }
        if (INTERNAL_CALL(_DERIVED_, AcceptingInput)(ulStreamIndex) != S_OK) {
            return DMO_E_NOTACCEPTING;
        }

        m_fFlushed = false;

        return INTERNAL_CALL(_DERIVED_, ProcessInput)(
                                    ulStreamIndex,
                                    pBuffer,
                                    dwFlags,
                                    rtTimestamp,
                                    rtTimelength);
    }

    STDMETHODIMP ProcessOutput(
                    DWORD dwFlags,
                    DWORD ulOutputBufferCount,
                    DMO_OUTPUT_DATA_BUFFER *pOutputBuffers,
                    DWORD *pdwStatus)
    {
        if (pdwStatus == NULL) {
            return E_POINTER;
        }


        if (ulOutputBufferCount != NUMBEROFOUTPUTS || (dwFlags & ~DMO_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER)) {
           return E_INVALIDARG;
        }

        if (NUMBEROFOUTPUTS != 0 && pOutputBuffers == NULL) {
            return E_POINTER;
        }

        *pdwStatus = 0;

        LockIt lck(static_cast<_DERIVED_ *>(this));

        HRESULT hr = AllocateStreamingResources();
        if (FAILED(hr)) {
            return hr;
        }

        for (DWORD dw = 0; dw < NUMBEROFOUTPUTS; dw++) {
            pOutputBuffers[dw].dwStatus = 0;
        }

        hr = INTERNAL_CALL(_DERIVED_, ProcessOutput)(
                           dwFlags,
                           ulOutputBufferCount,
                           pOutputBuffers,
                           pdwStatus);

        // remember the DMO's incomplete status
        for (dw = 0; dw < NUMBEROFOUTPUTS; dw++) {
            if (pOutputBuffers[dw].dwStatus & DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE) {
                m_OutputInfo[dw].fIncomplete = TRUE;
            } else {
                m_OutputInfo[dw].fIncomplete = FALSE;
            }
        }

        return hr;
    }

    STDMETHODIMP DMOLock(LONG lLock)
    {
        if (lLock) {
            static_cast<_DERIVED_ *>(this)->Lock();
        } else {
            static_cast<_DERIVED_ *>(this)->Unlock();
        }
        return S_OK;
    }
};

#endif // _dmoimpl_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\dmodev\uuid\dmoguids.c ===
/* Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved. */
#include <initguid.h>
#include "dmoreg.h"
#include "dmodshow.h"
#include <mediaobj_i.c>
#include <medparam_i.c>
#include <dmodshow_i.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\dmodev\include\dmort.h ===
//------------------------------------------------------------------------------
// File: DMORt.h
//
// Desc: Miscellaneous runtime support for DirectShow Media Objects
//
// Copyright (c) 1999 - 2000, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __DMORT_H__
#define __DMORT_H__

//
// Mediatype helpers.  MoInitMediaType() goes with MoFreeMediaType(),
// MoCreateMediaType() goes with MoDeleteMediaType() - don't mix !
//



//
// Takes a pointer to an already allocated DMO_MEDIA_TYPE structure, allocates
// a format block of cbFormat bytes, and sets appropriate members of
// DMO_MEDIA_TYPE to point to the newly allocated format block.  Also
// initializes the IUnknown pointer inside DMO_MEDIA_TYPE to NULL.
//
// The format block allocated by MoInitMediaType must be freed by calling
// MoFreeMediaType().
//
STDAPI MoInitMediaType(DMO_MEDIA_TYPE *pmt, DWORD cbFormat);

//
// Frees the format block and releases any IUnknown, but does not free the
// DMO_MEDIA_TYPE structure itself.  Input parameter must point to an
// DMO_MEDIA_TYPE structure previously initialized by MoInitMediaType().
//
STDAPI MoFreeMediaType(DMO_MEDIA_TYPE *pmt);

//
// Copies the DMO_MEDIA_TYPE members.  Also duplicates the format block and
// the IUnknown pointer.  Both parameters must point to valid DMO_MEDIA_TYPE
// structures.  Target structure must be later freed using MoFreeMediaType().
//
STDAPI MoCopyMediaType(DMO_MEDIA_TYPE *pmtDest, const DMO_MEDIA_TYPE *pmtSrc);



//
// Allocates a new DMO_MEDIA_TYPE structure and initializes it just like
// MoInitMediaType.  I.e., this function allocates both the format block
// and the DMO_MEDIA_TYPE structure itself.  Pointer to DMO_MEDIA_TYPE is
// returned as *ppmt.
//
// DMO_MEDIA_TYPE structures allocated by MoCreateMediaType() must be freed
// by calling MoDeleteMediaType().
//
STDAPI MoCreateMediaType(DMO_MEDIA_TYPE **ppmt, DWORD cbFormat);

//
// Frees any format block, releases any IUnknown, and deletes the
// DMO_MEDIA_TYPE structure itself.  The input parameter must point to an
// DMO_MEDIA_TYPE structure previously allocated by MoCreateMediaType().
//
STDAPI MoDeleteMediaType(DMO_MEDIA_TYPE *pmt);

//
// Allocates a new DMO_MEDIA_TYPE structure and copies pmtSrc into it like
// MoCopyMediaType.  I.e., this function allocates a new DMO_MEDIA_TYPE struct
// as well as a new format block for the target mediatype.  Trager mediatype
// must later be freed using MoDeleteMediaType().
//
STDAPI MoDuplicateMediaType(DMO_MEDIA_TYPE **ppmtDest, const DMO_MEDIA_TYPE *pmtSrc);



#endif //__DMORT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\dmodev\include\mediaerr.h ===
//------------------------------------------------------------------------------
// File: MediaErr.h
//
// Desc: Shell error codes
//
// Copyright (c) 1999 - 2000, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef _MEDIAERR_H_
#define _MEDIAERR_H_

#define DMO_E_INVALIDSTREAMINDEX 0x80040201
#define DMO_E_INVALIDTYPE        0x80040202
#define DMO_E_TYPE_NOT_SET       0x80040203
#define DMO_E_NOTACCEPTING       0x80040204
#define DMO_E_TYPE_NOT_ACCEPTED  0x80040205
#define DMO_E_NO_MORE_ITEMS      0x80040206

#endif _MEDIAERR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\dmodev\include\mediabuf.h ===
//------------------------------------------------------------------------------
// File: MediaBuf.h
//
// Desc: Definition of CBaseMediaBuffer class.
//
// Copyright (c) 1999-2000, Microsoft Corporation. All rights reserved.
//------------------------------------------------------------------------------


#ifndef __MEDIABUF_H__
#define __MEDIABUF_H__

class CBaseMediaBuffer : public IMediaBuffer {
public:
   CBaseMediaBuffer() {}
   CBaseMediaBuffer(BYTE *pData, ULONG ulSize, ULONG ulData) :
      m_pData(pData), m_ulSize(ulSize), m_ulData(ulData), m_cRef(1) {}
   STDMETHODIMP_(ULONG) AddRef() {
      return InterlockedIncrement((long*)&m_cRef);
   }
   STDMETHODIMP_(ULONG) Release() {
      long l = InterlockedDecrement((long*)&m_cRef);
      if (l == 0)
         delete this;
      return l;
   }
   STDMETHODIMP QueryInterface(REFIID riid, void **ppv) {
      if (riid == IID_IUnknown) {
         AddRef();
         *ppv = (IUnknown*)this;
         return NOERROR;
      }
      else if (riid == IID_IMediaBuffer) {
         AddRef();
         *ppv = (IMediaBuffer*)this;
         return NOERROR;
      }
      else
         return E_NOINTERFACE;
   }
   STDMETHODIMP SetLength(DWORD ulLength) {m_ulData = ulLength; return NOERROR;}
   STDMETHODIMP GetMaxLength(DWORD *pcbMaxLength) {*pcbMaxLength = m_ulSize; return NOERROR;}
   STDMETHODIMP GetBufferAndLength(BYTE **ppBuffer, DWORD *pcbLength) {
      if (ppBuffer) *ppBuffer = m_pData;
      if (pcbLength) *pcbLength = m_ulData;
      return NOERROR;
   }
protected:
   BYTE *m_pData;
   ULONG m_ulSize;
   ULONG m_ulData;
   ULONG m_cRef;
};

#endif __MEDIABUF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\include\activecf.h ===
//------------------------------------------------------------------------------
// File: ActiveCf.h
//
// Desc: Contains the data formats for the transfer of VfW4 filters via the
//       clipboard.
//
// Copyright (c) 1992 - 2000, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#define CFSTR_VFW_FILTERLIST "Video for Windows 4 Filters"

typedef struct tagVFW_FILTERLIST{
    UINT  cFilters;                     // number of CLSIDs in aClsId
    CLSID aClsId[1];                    // ClsId of each filter
} VFW_FILTERLIST;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\dmodev\include\dmoreg.h ===
//------------------------------------------------------------------------------
// File: DMOReg.h
//
// Desc: 
//
// Copyright (c) 1999 - 2000, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __DMOREG_H__
#define __DMOREG_H__

#include "mediaobj.h"


// 57f2db8b-e6bb-4513-9d43-dcd2a6593125
DEFINE_GUID(DMOCATEGORY_AUDIO_DECODER, 0x57f2db8b,0xe6bb,0x4513,0x9d,0x43,0xdc,0xd2,0xa6,0x59,0x31,0x25);
// 33D9A761-90C8-11d0-BD43-00A0C911CE86
DEFINE_GUID(DMOCATEGORY_AUDIO_ENCODER, 0x33D9A761,0x90C8,0x11d0,0xBD,0x43,0x00,0xA0,0xC9,0x11,0xCE,0x86);
// 4a69b442-28be-4991-969c-b500adf5d8a8
DEFINE_GUID(DMOCATEGORY_VIDEO_DECODER, 0x4a69b442,0x28be,0x4991,0x96,0x9c,0xb5,0x00,0xad,0xf5,0xd8,0xa8);
// 33D9A760-90C8-11d0-BD43-00A0C911CE86
DEFINE_GUID(DMOCATEGORY_VIDEO_ENCODER, 0x33D9A760,0x90C8,0x11d0,0xBD,0x43,0x00,0xA0,0xC9,0x11,0xCE,0x86);
// f3602b3f-0592-48df-a4cd-674721e7ebeb
DEFINE_GUID(DMOCATEGORY_AUDIO_EFFECT, 0xf3602b3f,0x0592,0x48df,0xa4,0xcd,0x67,0x47,0x21,0xe7,0xeb,0xeb);
// d990ee14-776c-4723-be46-3da2f56f10b9
DEFINE_GUID(DMOCATEGORY_VIDEO_EFFECT, 0xd990ee14,0x776c,0x4723,0xbe,0x46,0x3d,0xa2,0xf5,0x6f,0x10,0xb9);
// f665aaba-3e09-4920-aa5f-219811148f09
DEFINE_GUID(DMOCATEGORY_AUDIO_CAPTURE_EFFECT, 0xf665aaba,0x3e09,0x4920,0xaa,0x5f,0x21,0x98,0x11,0x14,0x8f,0x09);

// Acoustic Echo Canceller {BF963D80-C559-11D0-8A2B-00A0C9255AC1}
// Matches KSNODETYPE_ACOUSTIC_ECHO_CANCEL in ksmedia.h
DEFINE_GUID(DMOCATEGORY_ACOUSTIC_ECHO_CANCEL, 0xBF963D80L, 0xC559, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1);

// Noise Supression {E07F903F-62FD-4e60-8CDD-DEA7236665B5}
// Matches KSNODETYPE_AUDIO_NOISE_SUPPRESS in post Windows ME DDK's ksmedia.h
DEFINE_GUID(DMOCATEGORY_AUDIO_NOISE_SUPPRESS, 0xe07f903f, 0x62fd, 0x4e60, 0x8c, 0xdd, 0xde, 0xa7, 0x23, 0x66, 0x65, 0xb5);

// Automatic Gain Control {E88C9BA0-C557-11D0-8A2B-00A0C9255AC1}
// Matches KSNODETYPE_AGC in ksmedia.h
DEFINE_GUID(DMOCATEGORY_AGC, 0xE88C9BA0L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1);

typedef struct _DMO_PARTIAL_MEDIATYPE {
   GUID type;
   GUID subtype;
} DMO_PARTIAL_MEDIATYPE, *PDMO_PARTIAL_MEDIATYPE;

enum DMO_REGISTER_FLAGS {
   DMO_REGISTERF_IS_KEYED = 0x00000001
};

enum DMO_ENUM_FLAGS {
   DMO_ENUMF_INCLUDE_KEYED = 0x00000001
};

STDAPI DMORegister(
   LPCWSTR szName,
   REFCLSID clsidDMO,
   REFGUID guidCategory,
   DWORD dwFlags, // DMO_REGISTERF_XXX
   //
   // Register all mediatypes supported by the object.  This carries no
   // information about which combinations of input/output types would
   // actually work.
   //
   DWORD cInTypes,
   const DMO_PARTIAL_MEDIATYPE *pInTypes,
   DWORD cOutTypes,
   const DMO_PARTIAL_MEDIATYPE *pOutTypes
);

STDAPI DMOUnregister(
   REFCLSID clsidDMO,
   REFGUID guidCategory // optional - GUID_NULL means unregister from all
);

STDAPI DMOEnum(
   REFGUID guidCategory, // GUID_NULL for "all"
   DWORD dwFlags, // DMO_ENUMF_XXX
   //
	// Enumerate only objects that support at least one of the specified input types
	// and at least one of the specified output types.  If no input types are specified,
	// enumerate objects regardless of what input types they support.  Same for
	// output types.
   //
   DWORD cInTypes,
   const DMO_PARTIAL_MEDIATYPE *pInTypes, // can be NULL only of ulInTypes = 0
   DWORD cOutTypes,
   const DMO_PARTIAL_MEDIATYPE *pOutTypes, // can be NULL only of ulOutTypes = 0
   //
   // Output parameter - this receives a pointer to the DMO CLSID enumerator
   //
   IEnumDMO **ppEnum
);

STDAPI DMOGetTypes(
   REFCLSID clsidDMO,
   unsigned long ulInputTypesRequested,
   unsigned long *pulInputTypesSupplied,
   DMO_PARTIAL_MEDIATYPE *pInputTypes,
   unsigned long ulOutputTypesRequested,
   unsigned long *pulOutputTypesSupplied,
   DMO_PARTIAL_MEDIATYPE *pOutputTypes
);

STDAPI DMOGetName(
   REFCLSID clsidDMO,
   WCHAR szName[80]
);
#endif //__DMOREG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\idl\uuids.h ===
//------------------------------------------------------------------------------
// File: uuids.h
//
// Desc: Contains the GUIDs for the MediaType type, subtype fields and format
//       types for standard media types, and also class ids for well-known
//       components.
//
// Copyright (c) 1992 - 2001, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


//
//  We want to use this list for generating strings for debugging too
//  so we redefine OUR_GUID_ENTRY depending on what we want to do
//
//  It is imperative that all entries in this file are declared using
//  OUR_GUID_ENTRY as that macro might have been defined in advance of
//  including this file.  See wxdebug.cpp in sdk\classes\base.
//

#ifndef OUR_GUID_ENTRY
    #define OUR_GUID_ENTRY(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8);
#endif


// -- to allow consistent labeling of Media types and subtypes --

#define MEDIATYPE_NULL       GUID_NULL
#define MEDIASUBTYPE_NULL    GUID_NULL

// -- Use this subtype if you don't have a use for a subtype for your type
// e436eb8e-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_None
OUR_GUID_ENTRY(MEDIASUBTYPE_None,
0xe436eb8e, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)


// -- major types ---


// 73646976-0000-0010-8000-00AA00389B71  'vids' == MEDIATYPE_Video
OUR_GUID_ENTRY(MEDIATYPE_Video,
0x73646976, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 73647561-0000-0010-8000-00AA00389B71  'auds' == MEDIATYPE_Audio
OUR_GUID_ENTRY(MEDIATYPE_Audio,
0x73647561, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 73747874-0000-0010-8000-00AA00389B71  'txts' == MEDIATYPE_Text
OUR_GUID_ENTRY(MEDIATYPE_Text,
0x73747874, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 7364696D-0000-0010-8000-00AA00389B71  'mids' == MEDIATYPE_Midi
OUR_GUID_ENTRY(MEDIATYPE_Midi,
0x7364696D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// e436eb83-524f-11ce-9f53-0020af0ba770            MEDIATYPE_Stream
OUR_GUID_ENTRY(MEDIATYPE_Stream,
0xe436eb83, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 73(s)76(v)61(a)69(i)-0000-0010-8000-00AA00389B71  'iavs' == MEDIATYPE_Interleaved
OUR_GUID_ENTRY(MEDIATYPE_Interleaved,
0x73766169, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 656c6966-0000-0010-8000-00AA00389B71  'file' == MEDIATYPE_File
OUR_GUID_ENTRY(MEDIATYPE_File,
0x656c6966, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 73636d64-0000-0010-8000-00AA00389B71  'scmd' == MEDIATYPE_ScriptCommand
OUR_GUID_ENTRY(MEDIATYPE_ScriptCommand,
0x73636d64, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 670AEA80-3A82-11d0-B79B-00AA003767A7            MEDIATYPE_AUXLine21Data
OUR_GUID_ENTRY(MEDIATYPE_AUXLine21Data,
0x670aea80, 0x3a82, 0x11d0, 0xb7, 0x9b, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// F72A76E1-EB0A-11D0-ACE4-0000C0CC16BA            MEDIATYPE_VBI
OUR_GUID_ENTRY(MEDIATYPE_VBI,
0xf72a76e1, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// 0482DEE3-7817-11cf-8a03-00aa006ecb65            MEDIATYPE_Timecode
OUR_GUID_ENTRY(MEDIATYPE_Timecode,
0x482dee3, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 74726c6d-0000-0010-8000-00AA00389B71  'lmrt' == MEDIATYPE_LMRT
OUR_GUID_ENTRY(MEDIATYPE_LMRT,
0x74726c6d, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 74726c6d-0000-0010-8000-00AA00389B71  'urls' == MEDIATYPE_URL_STREAM
OUR_GUID_ENTRY(MEDIATYPE_URL_STREAM,
0x736c7275, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// -- sub types ---

// 4C504C43-0000-0010-8000-00AA00389B71  'CLPL' == MEDIASUBTYPE_CLPL
OUR_GUID_ENTRY(MEDIASUBTYPE_CLPL,
0x4C504C43, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 56595559-0000-0010-8000-00AA00389B71  'YUYV' == MEDIASUBTYPE_YUYV
OUR_GUID_ENTRY(MEDIASUBTYPE_YUYV,
0x56595559, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 56555949-0000-0010-8000-00AA00389B71  'IYUV' == MEDIASUBTYPE_IYUV
OUR_GUID_ENTRY(MEDIASUBTYPE_IYUV,
0x56555949, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 39555659-0000-0010-8000-00AA00389B71  'YVU9' == MEDIASUBTYPE_YVU9
OUR_GUID_ENTRY(MEDIASUBTYPE_YVU9,
0x39555659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 31313459-0000-0010-8000-00AA00389B71  'Y411' == MEDIASUBTYPE_Y411
OUR_GUID_ENTRY(MEDIASUBTYPE_Y411,
0x31313459, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 50313459-0000-0010-8000-00AA00389B71  'Y41P' == MEDIASUBTYPE_Y41P
OUR_GUID_ENTRY(MEDIASUBTYPE_Y41P,
0x50313459, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 32595559-0000-0010-8000-00AA00389B71  'YUY2' == MEDIASUBTYPE_YUY2
OUR_GUID_ENTRY(MEDIASUBTYPE_YUY2,
0x32595559, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 55595659-0000-0010-8000-00AA00389B71  'YVYU' == MEDIASUBTYPE_YVYU
OUR_GUID_ENTRY(MEDIASUBTYPE_YVYU,
0x55595659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 59565955-0000-0010-8000-00AA00389B71  'UYVY' ==  MEDIASUBTYPE_UYVY
OUR_GUID_ENTRY(MEDIASUBTYPE_UYVY,
0x59565955, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 31313259-0000-0010-8000-00AA00389B71  'Y211' ==  MEDIASUBTYPE_Y211
OUR_GUID_ENTRY(MEDIASUBTYPE_Y211,
0x31313259, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 31313259-0000-0010-8000-00AA00389B71  'YV12' ==  MEDIASUBTYPE_YV12
OUR_GUID_ENTRY(MEDIASUBTYPE_YV12,
0x32315659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 524a4c43-0000-0010-8000-00AA00389B71  'CLJR' ==  MEDIASUBTYPE_CLJR
OUR_GUID_ENTRY(MEDIASUBTYPE_CLJR,
0x524a4c43, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 39304649-0000-0010-8000-00AA00389B71  'IF09' ==  MEDIASUBTYPE_IF09
OUR_GUID_ENTRY(MEDIASUBTYPE_IF09,
0x39304649, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 414c5043-0000-0010-8000-00AA00389B71  'CPLA' ==  MEDIASUBTYPE_CPLA
OUR_GUID_ENTRY(MEDIASUBTYPE_CPLA,
0x414c5043, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 47504A4D-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_MJPG
OUR_GUID_ENTRY(MEDIASUBTYPE_MJPG,
0x47504A4D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 4A4D5654-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_TVMJ
OUR_GUID_ENTRY(MEDIASUBTYPE_TVMJ,
0x4A4D5654, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 454B4157-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_WAKE
OUR_GUID_ENTRY(MEDIASUBTYPE_WAKE,
0x454B4157, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 43434643-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_CFCC
OUR_GUID_ENTRY(MEDIASUBTYPE_CFCC,
0x43434643, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 47504A49-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_IJPG
OUR_GUID_ENTRY(MEDIASUBTYPE_IJPG,
0x47504A49, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 6D756C50-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_Plum
OUR_GUID_ENTRY(MEDIASUBTYPE_Plum,
0x6D756C50, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// FAST DV-Master
// 53435644-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_DVCS
OUR_GUID_ENTRY(MEDIASUBTYPE_DVCS,
0x53435644, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// FAST DV-Master
// 44535644-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_DVSD
OUR_GUID_ENTRY(MEDIASUBTYPE_DVSD,
0x44535644, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// MIROVideo DV
// 4656444D-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_MDVF
OUR_GUID_ENTRY(MEDIASUBTYPE_MDVF,
0x4656444D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// e436eb78-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB1
// e436eb78-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB1
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB1,
0xe436eb78, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb79-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB4
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB4,
0xe436eb79, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7a-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB8
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB8,
0xe436eb7a, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7b-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB565
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB565,
0xe436eb7b, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7c-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB555
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB555,
0xe436eb7c, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7d-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB24
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB24,
0xe436eb7d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7e-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB32
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB32,
0xe436eb7e, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)


//
// RGB surfaces that contain per pixel alpha values.
//

// 297C55AF-E209-4cb3-B757-C76D6B9C88A8            MEDIASUBTYPE_ARGB1555
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB1555,
0x297c55af, 0xe209, 0x4cb3, 0xb7, 0x57, 0xc7, 0x6d, 0x6b, 0x9c, 0x88, 0xa8)

// 6E6415E6-5C24-425f-93CD-80102B3D1CCA            MEDIASUBTYPE_ARGB4444
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB4444,
0x6e6415e6, 0x5c24, 0x425f, 0x93, 0xcd, 0x80, 0x10, 0x2b, 0x3d, 0x1c, 0xca)

// 773c9ac0-3274-11d0-B724-00aa006c1A01            MEDIASUBTYPE_ARGB32
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB32,
0x773c9ac0, 0x3274, 0x11d0, 0xb7, 0x24, 0x0, 0xaa, 0x0, 0x6c, 0x1a, 0x1 )

// 56555941-0000-0010-8000-00AA00389B71  'AYUV' == MEDIASUBTYPE_AYUV
//
// See the DX-VA header and documentation for a description of this format.
//
OUR_GUID_ENTRY(MEDIASUBTYPE_AYUV,
0x56555941, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 34344941-0000-0010-8000-00AA00389B71  'AI44' == MEDIASUBTYPE_AI44
//
// See the DX-VA header and documentation for a description of this format.
//
OUR_GUID_ENTRY(MEDIASUBTYPE_AI44,
0x34344941, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 34344149-0000-0010-8000-00AA00389B71  'IA44' == MEDIASUBTYPE_IA44
//
// See the DX-VA header and documentation for a description of this format.
//
OUR_GUID_ENTRY(MEDIASUBTYPE_IA44,
0x34344149, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)


//
// DirectX7 D3D Render Target media subtypes.
//

// 32335237-0000-0010-8000-00AA00389B71  '7R32' == MEDIASUBTYPE_RGB32_D3D_DX7_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB32_D3D_DX7_RT,
0x32335237, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 36315237-0000-0010-8000-00AA00389B71  '7R16' == MEDIASUBTYPE_RGB16_D3D_DX7_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB16_D3D_DX7_RT,
0x36315237, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 38384137-0000-0010-8000-00AA00389B71  '7A88' == MEDIASUBTYPE_ARGB32_D3D_DX7_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB32_D3D_DX7_RT,
0x38384137, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 34344137-0000-0010-8000-00AA00389B71  '7A44' == MEDIASUBTYPE_ARGB4444_D3D_DX7_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB4444_D3D_DX7_RT,
0x34344137, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 35314137-0000-0010-8000-00AA00389B71  '7A15' == MEDIASUBTYPE_ARGB1555_D3D_DX7_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB1555_D3D_DX7_RT,
0x35314137, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)


#define MEDIASUBTYPE_HASALPHA(mt) ( ((mt).subtype == MEDIASUBTYPE_ARGB4444)            || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB32)              || \
                                    ((mt).subtype == MEDIASUBTYPE_AYUV)                || \
                                    ((mt).subtype == MEDIASUBTYPE_AI44)                || \
                                    ((mt).subtype == MEDIASUBTYPE_IA44)                || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB1555)            || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB32_D3D_DX7_RT)   || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB4444_D3D_DX7_RT) || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB1555_D3D_DX7_RT) )

#define MEDIASUBTYPE_D3D_DX7_RT(mt) (((mt).subtype == MEDIASUBTYPE_ARGB32_D3D_DX7_RT)   || \
                                     ((mt).subtype == MEDIASUBTYPE_ARGB4444_D3D_DX7_RT) || \
                                     ((mt).subtype == MEDIASUBTYPE_ARGB1555_D3D_DX7_RT) || \
                                     ((mt).subtype == MEDIASUBTYPE_RGB32_D3D_DX7_RT)    || \
                                     ((mt).subtype == MEDIASUBTYPE_RGB16_D3D_DX7_RT))


// e436eb7f-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_Overlay
OUR_GUID_ENTRY(MEDIASUBTYPE_Overlay,
0xe436eb7f, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb80-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEGPacket
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1Packet,
0xe436eb80, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb81-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1Payload
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1Payload,
0xe436eb81, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 00000050-0000-0010-8000-00AA00389B71         MEDIASUBTYPE_MPEG1AudioPayload
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1AudioPayload,
0x00000050, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71)

// e436eb82-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1SystemStream
OUR_GUID_ENTRY(MEDIATYPE_MPEG1SystemStream,
0xe436eb82, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// the next consecutive number is assigned to MEDIATYPE_Stream and appears higher up
// e436eb84-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1System
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1System,
0xe436eb84, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb85-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1VideoCD
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1VideoCD,
0xe436eb85, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb86-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1Video
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1Video,
0xe436eb86, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb87-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1Audio
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1Audio,
0xe436eb87, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb88-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_Avi
OUR_GUID_ENTRY(MEDIASUBTYPE_Avi,
0xe436eb88, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// {3DB80F90-9412-11d1-ADED-0000F8754B99}          MEDIASUBTYPE_Asf
OUR_GUID_ENTRY(MEDIASUBTYPE_Asf,
0x3db80f90, 0x9412, 0x11d1, 0xad, 0xed, 0x0, 0x0, 0xf8, 0x75, 0x4b, 0x99)

// e436eb89-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_QTMovie
OUR_GUID_ENTRY(MEDIASUBTYPE_QTMovie,
0xe436eb89, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 617a7072-0000-0010-8000-00AA00389B71         MEDIASUBTYPE_Rpza
OUR_GUID_ENTRY(MEDIASUBTYPE_QTRpza,
0x617a7072, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 20636d73-0000-0010-8000-00AA00389B71         MEDIASUBTYPE_Smc
OUR_GUID_ENTRY(MEDIASUBTYPE_QTSmc,
0x20636d73, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 20656c72-0000-0010-8000-00AA00389B71        MEDIASUBTYPE_Rle
OUR_GUID_ENTRY(MEDIASUBTYPE_QTRle,
0x20656c72, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 6765706a-0000-0010-8000-00AA00389B71        MEDIASUBTYPE_Jpeg
OUR_GUID_ENTRY(MEDIASUBTYPE_QTJpeg,
0x6765706a, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// e436eb8a-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_PCMAudio_Obsolete
OUR_GUID_ENTRY(MEDIASUBTYPE_PCMAudio_Obsolete,
0xe436eb8a, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 00000001-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_PCM
OUR_GUID_ENTRY(MEDIASUBTYPE_PCM,
0x00000001, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71)

// e436eb8b-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_WAVE
OUR_GUID_ENTRY(MEDIASUBTYPE_WAVE,
0xe436eb8b, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb8c-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_AU
OUR_GUID_ENTRY(MEDIASUBTYPE_AU,
0xe436eb8c, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb8d-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_AIFF
OUR_GUID_ENTRY(MEDIASUBTYPE_AIFF,
0xe436eb8d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 64(d)73(s)76(v)64(d)-0000-0010-8000-00AA00389B71  'dvsd' == MEDIASUBTYPE_dvsd
OUR_GUID_ENTRY(MEDIASUBTYPE_dvsd,
0x64737664, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 64(d)68(h)76(v)64(d)-0000-0010-8000-00AA00389B71  'dvhd' == MEDIASUBTYPE_dvhd
OUR_GUID_ENTRY(MEDIASUBTYPE_dvhd,
0x64687664, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 6c(l)73(s)76(v)64(d)-0000-0010-8000-00AA00389B71  'dvsl' == MEDIASUBTYPE_dvsl
OUR_GUID_ENTRY(MEDIASUBTYPE_dvsl,
0x6c737664, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 6E8D4A22-310C-11d0-B79A-00AA003767A7         MEDIASUBTYPE_Line21_BytePair
OUR_GUID_ENTRY(MEDIASUBTYPE_Line21_BytePair,
0x6e8d4a22, 0x310c, 0x11d0, 0xb7, 0x9a, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// 6E8D4A23-310C-11d0-B79A-00AA003767A7         MEDIASUBTYPE_Line21_GOPPacket
OUR_GUID_ENTRY(MEDIASUBTYPE_Line21_GOPPacket,
0x6e8d4a23, 0x310c, 0x11d0, 0xb7, 0x9a, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// 6E8D4A24-310C-11d0-B79A-00AA003767A7         MEDIASUBTYPE_Line21_VBIRawData
OUR_GUID_ENTRY(MEDIASUBTYPE_Line21_VBIRawData,
0x6e8d4a24, 0x310c, 0x11d0, 0xb7, 0x9a, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// F72A76E3-EB0A-11D0-ACE4-0000C0CC16BA         MEDIASUBTYPE_TELETEXT
OUR_GUID_ENTRY(MEDIASUBTYPE_TELETEXT,
0xf72a76e3, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// derived from WAVE_FORMAT_DRM
// 00000009-0000-0010-8000-00aa00389b71
OUR_GUID_ENTRY(MEDIASUBTYPE_DRM_Audio,
0x00000009, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// derived from WAVE_FORMAT_IEEE_FLOAT
// 00000003-0000-0010-8000-00aa00389b71
OUR_GUID_ENTRY(MEDIASUBTYPE_IEEE_FLOAT,
0x00000003, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// derived from WAVE_FORMAT_DOLBY_AC3_SPDIF
// 00000092-0000-0010-8000-00aa00389b71
OUR_GUID_ENTRY(MEDIASUBTYPE_DOLBY_AC3_SPDIF,
0x00000092, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// derived from WAVE_FORMAT_RAW_SPORT
// 00000240-0000-0010-8000-00aa00389b71
OUR_GUID_ENTRY(MEDIASUBTYPE_RAW_SPORT,
0x00000240, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// derived from wave format tag 0x241, call it SPDIF_TAG_241h for now
// 00000241-0000-0010-8000-00aa00389b71
OUR_GUID_ENTRY(MEDIASUBTYPE_SPDIF_TAG_241h,
0x00000241, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)



// DirectShow DSS definitions

// A0AF4F81-E163-11d0-BAD9-00609744111A
OUR_GUID_ENTRY(MEDIASUBTYPE_DssVideo,
0xa0af4f81, 0xe163, 0x11d0, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// A0AF4F82-E163-11d0-BAD9-00609744111A
OUR_GUID_ENTRY(MEDIASUBTYPE_DssAudio,
0xa0af4f82, 0xe163, 0x11d0, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// 5A9B6A40-1A22-11D1-BAD9-00609744111A
OUR_GUID_ENTRY(MEDIASUBTYPE_VPVideo,
0x5a9b6a40, 0x1a22, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// 5A9B6A41-1A22-11D1-BAD9-00609744111A
OUR_GUID_ENTRY(MEDIASUBTYPE_VPVBI,
0x5a9b6a41, 0x1a22, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// BF87B6E0-8C27-11d0-B3F0-00AA003761C5     Capture graph building
OUR_GUID_ENTRY(CLSID_CaptureGraphBuilder,
0xBF87B6E0, 0x8C27, 0x11d0, 0xB3, 0xF0, 0x0, 0xAA, 0x00, 0x37, 0x61, 0xC5)

// BF87B6E1-8C27-11d0-B3F0-00AA003761C5     New Capture graph building
OUR_GUID_ENTRY(CLSID_CaptureGraphBuilder2,
0xBF87B6E1, 0x8C27, 0x11d0, 0xB3, 0xF0, 0x0, 0xAA, 0x00, 0x37, 0x61, 0xC5)

// e436ebb0-524f-11ce-9f53-0020af0ba770            Prototype filtergraph
OUR_GUID_ENTRY(CLSID_ProtoFilterGraph,
0xe436ebb0, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436ebb1-524f-11ce-9f53-0020af0ba770            Reference clock
OUR_GUID_ENTRY(CLSID_SystemClock,
0xe436ebb1, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436ebb2-524f-11ce-9f53-0020af0ba770           Filter Mapper
OUR_GUID_ENTRY(CLSID_FilterMapper,
0xe436ebb2, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436ebb3-524f-11ce-9f53-0020af0ba770           Filter Graph
OUR_GUID_ENTRY(CLSID_FilterGraph,
0xe436ebb3, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436ebb8-524f-11ce-9f53-0020af0ba770           Filter Graph no thread
OUR_GUID_ENTRY(CLSID_FilterGraphNoThread,
0xe436ebb8, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e4bbd160-4269-11ce-838d-00aa0055595a           MPEG System stream
OUR_GUID_ENTRY(CLSID_MPEG1Doc,
0xe4bbd160, 0x4269, 0x11ce, 0x83, 0x8d, 0x0, 0xaa, 0x0, 0x55, 0x59, 0x5a)

// 701722e0-8ae3-11ce-a85c-00aa002feab5           MPEG file reader
OUR_GUID_ENTRY(CLSID_FileSource,
0x701722e0, 0x8ae3, 0x11ce, 0xa8, 0x5c, 0x00, 0xaa, 0x00, 0x2f, 0xea, 0xb5)

// 26C25940-4CA9-11ce-A828-00AA002FEAB5           Takes MPEG1 packets as input
OUR_GUID_ENTRY(CLSID_MPEG1PacketPlayer,
0x26c25940, 0x4ca9, 0x11ce, 0xa8, 0x28, 0x0, 0xaa, 0x0, 0x2f, 0xea, 0xb5)

// 336475d0-942a-11ce-a870-00aa002feab5           MPEG splitter
OUR_GUID_ENTRY(CLSID_MPEG1Splitter,
0x336475d0, 0x942a, 0x11ce, 0xa8, 0x70, 0x00, 0xaa, 0x00, 0x2f, 0xea, 0xb5)

// feb50740-7bef-11ce-9bd9-0000e202599c           MPEG video decoder
OUR_GUID_ENTRY(CLSID_CMpegVideoCodec,
0xfeb50740, 0x7bef, 0x11ce, 0x9b, 0xd9, 0x0, 0x0, 0xe2, 0x2, 0x59, 0x9c)

// 4a2286e0-7bef-11ce-9bd9-0000e202599c           MPEG audio decoder
OUR_GUID_ENTRY(CLSID_CMpegAudioCodec,
0x4a2286e0, 0x7bef, 0x11ce, 0x9b, 0xd9, 0x0, 0x0, 0xe2, 0x2, 0x59, 0x9c)

// e30629d3-27e5-11ce-875d-00608cb78066           Text renderer
OUR_GUID_ENTRY(CLSID_TextRender,
0xe30629d3, 0x27e5, 0x11ce, 0x87, 0x5d, 0x0, 0x60, 0x8c, 0xb7, 0x80, 0x66)



// {F8388A40-D5BB-11d0-BE5A-0080C706568E}
OUR_GUID_ENTRY(CLSID_InfTee,
0xf8388a40, 0xd5bb, 0x11d0, 0xbe, 0x5a, 0x0, 0x80, 0xc7, 0x6, 0x56, 0x8e)

// 1b544c20-fd0b-11ce-8c63-00aa0044b51e           Avi Stream Splitter
OUR_GUID_ENTRY(CLSID_AviSplitter,
0x1b544c20, 0xfd0b, 0x11ce, 0x8c, 0x63, 0x0, 0xaa, 0x00, 0x44, 0xb5, 0x1e)

// 1b544c21-fd0b-11ce-8c63-00aa0044b51e           Avi File Reader
OUR_GUID_ENTRY(CLSID_AviReader,
0x1b544c21, 0xfd0b, 0x11ce, 0x8c, 0x63, 0x0, 0xaa, 0x00, 0x44, 0xb5, 0x1e)

// 1b544c22-fd0b-11ce-8c63-00aa0044b51e           Vfw 2.0 Capture Driver
OUR_GUID_ENTRY(CLSID_VfwCapture,
0x1b544c22, 0xfd0b, 0x11ce, 0x8c, 0x63, 0x0, 0xaa, 0x00, 0x44, 0xb5, 0x1e)

OUR_GUID_ENTRY(CLSID_CaptureProperties,
0x1B544c22, 0xFD0B, 0x11ce, 0x8C, 0x63, 0x00, 0xAA, 0x00, 0x44, 0xB5, 0x1F)

//e436ebb4-524f-11ce-9f53-0020af0ba770            Control Distributor
OUR_GUID_ENTRY(CLSID_FGControl,
0xe436ebb4, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 44584800-F8EE-11ce-B2D4-00DD01101B85           .MOV reader (old)
OUR_GUID_ENTRY(CLSID_MOVReader,
0x44584800, 0xf8ee, 0x11ce, 0xb2, 0xd4, 0x00, 0xdd, 0x1, 0x10, 0x1b, 0x85)

// D51BD5A0-7548-11cf-A520-0080C77EF58A           QT Splitter
OUR_GUID_ENTRY(CLSID_QuickTimeParser,
0xd51bd5a0, 0x7548, 0x11cf, 0xa5, 0x20, 0x0, 0x80, 0xc7, 0x7e, 0xf5, 0x8a)

// FDFE9681-74A3-11d0-AFA7-00AA00B67A42           QT Decoder
OUR_GUID_ENTRY(CLSID_QTDec,
0xfdfe9681, 0x74a3, 0x11d0, 0xaf, 0xa7, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// D3588AB0-0781-11ce-B03A-0020AF0BA770           AVIFile-based reader
OUR_GUID_ENTRY(CLSID_AVIDoc,
0xd3588ab0, 0x0781, 0x11ce, 0xb0, 0x3a, 0x00, 0x20, 0xaf, 0xb, 0xa7, 0x70)

// 70e102b0-5556-11ce-97c0-00aa0055595a           Video renderer
OUR_GUID_ENTRY(CLSID_VideoRenderer,
0x70e102b0, 0x5556, 0x11ce, 0x97, 0xc0, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 1643e180-90f5-11ce-97d5-00aa0055595a           Colour space convertor
OUR_GUID_ENTRY(CLSID_Colour,
0x1643e180, 0x90f5, 0x11ce, 0x97, 0xd5, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 1da08500-9edc-11cf-bc10-00aa00ac74f6           VGA 16 color ditherer
OUR_GUID_ENTRY(CLSID_Dither,
0x1da08500, 0x9edc, 0x11cf, 0xbc, 0x10, 0x00, 0xaa, 0x00, 0xac, 0x74, 0xf6)

// 07167665-5011-11cf-BF33-00AA0055595A           Modex video renderer
OUR_GUID_ENTRY(CLSID_ModexRenderer,
0x7167665, 0x5011, 0x11cf, 0xbf, 0x33, 0x0, 0xaa, 0x0, 0x55, 0x59, 0x5a)

// e30629d1-27e5-11ce-875d-00608cb78066           Waveout audio renderer
OUR_GUID_ENTRY(CLSID_AudioRender,
0xe30629d1, 0x27e5, 0x11ce, 0x87, 0x5d, 0x0, 0x60, 0x8c, 0xb7, 0x80, 0x66)

// 05589faf-c356-11ce-bf01-00aa0055595a           Audio Renderer Property Page
OUR_GUID_ENTRY(CLSID_AudioProperties,
0x05589faf, 0xc356, 0x11ce, 0xbf, 0x01, 0x0, 0xaa, 0x0, 0x55, 0x59, 0x5a)

// 79376820-07D0-11cf-A24D-0020AFD79767           DSound audio renderer
OUR_GUID_ENTRY(CLSID_DSoundRender,
0x79376820, 0x07D0, 0x11CF, 0xA2, 0x4D, 0x0, 0x20, 0xAF, 0xD7, 0x97, 0x67)

// e30629d2-27e5-11ce-875d-00608cb78066           Wavein audio recorder
OUR_GUID_ENTRY(CLSID_AudioRecord,
0xe30629d2, 0x27e5, 0x11ce, 0x87, 0x5d, 0x0, 0x60, 0x8c, 0xb7, 0x80, 0x66)

// {2CA8CA52-3C3F-11d2-B73D-00C04FB6BD3D}         IAMAudioInputMixer property page
OUR_GUID_ENTRY(CLSID_AudioInputMixerProperties,
0x2ca8ca52, 0x3c3f, 0x11d2, 0xb7, 0x3d, 0x0, 0xc0, 0x4f, 0xb6, 0xbd, 0x3d)

// {CF49D4E0-1115-11ce-B03A-0020AF0BA770}         AVI Decoder
OUR_GUID_ENTRY(CLSID_AVIDec,
0xcf49d4e0, 0x1115, 0x11ce, 0xb0, 0x3a, 0x0, 0x20, 0xaf, 0xb, 0xa7, 0x70)

// {A888DF60-1E90-11cf-AC98-00AA004C0FA9}         AVI ICDraw* wrapper
OUR_GUID_ENTRY(CLSID_AVIDraw,
0xa888df60, 0x1e90, 0x11cf, 0xac, 0x98, 0x0, 0xaa, 0x0, 0x4c, 0xf, 0xa9)

// 6a08cf80-0e18-11cf-a24d-0020afd79767       ACM Wrapper
OUR_GUID_ENTRY(CLSID_ACMWrapper,
0x6a08cf80, 0x0e18, 0x11cf, 0xa2, 0x4d, 0x0, 0x20, 0xaf, 0xd7, 0x97, 0x67)

// {e436ebb5-524f-11ce-9f53-0020af0ba770}    Async File Reader
OUR_GUID_ENTRY(CLSID_AsyncReader,
0xe436ebb5, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// {e436ebb6-524f-11ce-9f53-0020af0ba770}    Async URL Reader
OUR_GUID_ENTRY(CLSID_URLReader,
0xe436ebb6, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// {e436ebb7-524f-11ce-9f53-0020af0ba770}    IPersistMoniker PID
OUR_GUID_ENTRY(CLSID_PersistMonikerPID,
0xe436ebb7, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// {D76E2820-1563-11cf-AC98-00AA004C0FA9}
OUR_GUID_ENTRY(CLSID_AVICo,
0xd76e2820, 0x1563, 0x11cf, 0xac, 0x98, 0x0, 0xaa, 0x0, 0x4c, 0xf, 0xa9)

// {8596E5F0-0DA5-11d0-BD21-00A0C911CE86}
OUR_GUID_ENTRY(CLSID_FileWriter,
0x8596e5f0, 0xda5, 0x11d0, 0xbd, 0x21, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// {E2510970-F137-11CE-8B67-00AA00A3F1A6}     AVI mux filter
OUR_GUID_ENTRY(CLSID_AviDest,
0xe2510970, 0xf137, 0x11ce, 0x8b, 0x67, 0x0, 0xaa, 0x0, 0xa3, 0xf1, 0xa6)

// {C647B5C0-157C-11d0-BD23-00A0C911CE86}
OUR_GUID_ENTRY(CLSID_AviMuxProptyPage,
0xc647b5c0, 0x157c, 0x11d0, 0xbd, 0x23, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// {0A9AE910-85C0-11d0-BD42-00A0C911CE86}
OUR_GUID_ENTRY(CLSID_AviMuxProptyPage1,
0xa9ae910, 0x85c0, 0x11d0, 0xbd, 0x42, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// {07b65360-c445-11ce-afde-00aa006c14f4}
OUR_GUID_ENTRY(CLSID_AVIMIDIRender,
0x07b65360, 0xc445, 0x11ce, 0xaf, 0xde, 0x00, 0xaa, 0x00, 0x6c, 0x14, 0xf4)

// {187463A0-5BB7-11d3-ACBE-0080C75E246E}    WMSDK-based ASF reader
OUR_GUID_ENTRY(CLSID_WMAsfReader,
0x187463a0, 0x5bb7, 0x11d3, 0xac, 0xbe, 0x0, 0x80, 0xc7, 0x5e, 0x24, 0x6e)

// {7c23220e-55bb-11d3-8b16-00c04fb6bd3d}    WMSDK-based ASF writer
OUR_GUID_ENTRY(CLSID_WMAsfWriter,
0x7c23220e, 0x55bb, 0x11d3, 0x8b, 0x16, 0x0, 0xc0, 0x4f, 0xb6, 0xbd, 0x3d)

//  {afb6c280-2c41-11d3-8a60-0000f81e0e4a}
OUR_GUID_ENTRY(CLSID_MPEG2Demultiplexer,
0xafb6c280, 0x2c41, 0x11d3, 0x8a, 0x60, 0x00, 0x00, 0xf8, 0x1e, 0x0e, 0x4a)

// {3ae86b20-7be8-11d1-abe6-00a0c905f375}
OUR_GUID_ENTRY(CLSID_MMSPLITTER,
0x3ae86b20, 0x7be8, 0x11d1, 0xab, 0xe6, 0x00, 0xa0, 0xc9, 0x05, 0xf3, 0x75)

// {2DB47AE5-CF39-43c2-B4D6-0CD8D90946F4}
OUR_GUID_ENTRY(CLSID_StreamBufferSink,
0x2db47ae5, 0xcf39, 0x43c2, 0xb4, 0xd6, 0xc, 0xd8, 0xd9, 0x9, 0x46, 0xf4)

// {C9F5FE02-F851-4eb5-99EE-AD602AF1E619}
OUR_GUID_ENTRY(CLSID_StreamBufferSource,
0xc9f5fe02, 0xf851, 0x4eb5, 0x99, 0xee, 0xad, 0x60, 0x2a, 0xf1, 0xe6, 0x19)

// {FA8A68B2-C864-4ba2-AD53-D3876A87494B}
OUR_GUID_ENTRY(CLSID_StreamBufferConfig,
0xfa8a68b2, 0xc864, 0x4ba2, 0xad, 0x53, 0xd3, 0x87, 0x6a, 0x87, 0x49, 0x4b)

// {6CFAD761-735D-4aa5-8AFC-AF91A7D61EBA}
OUR_GUID_ENTRY(CLSID_Mpeg2VideoStreamAnalyzer,
0x6cfad761, 0x735d, 0x4aa5, 0x8a, 0xfc, 0xaf, 0x91, 0xa7, 0xd6, 0x1e, 0xba)

// {CCAA63AC-1057-4778-AE92-1206AB9ACEE6}
OUR_GUID_ENTRY(CLSID_StreamBufferRecordingAttributes,
0xccaa63ac, 0x1057, 0x4778, 0xae, 0x92, 0x12, 0x6, 0xab, 0x9a, 0xce, 0xe6)

// {D682C4BA-A90A-42fe-B9E1-03109849C423}
OUR_GUID_ENTRY(CLSID_StreamBufferComposeRecording,
0xd682c4ba, 0xa90a, 0x42fe, 0xb9, 0xe1, 0x3, 0x10, 0x98, 0x49, 0xc4, 0x23)

// {B1B77C00-C3E4-11cf-AF79-00AA00B67A42}               DV video decoder
OUR_GUID_ENTRY(CLSID_DVVideoCodec,
0xb1b77c00, 0xc3e4, 0x11cf, 0xaf, 0x79, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {13AA3650-BB6F-11d0-AFB9-00AA00B67A42}               DV video encoder
OUR_GUID_ENTRY(CLSID_DVVideoEnc,
0x13aa3650, 0xbb6f, 0x11d0, 0xaf, 0xb9, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {4EB31670-9FC6-11cf-AF6E-00AA00B67A42}               DV splitter
OUR_GUID_ENTRY(CLSID_DVSplitter,
0x4eb31670, 0x9fc6, 0x11cf, 0xaf, 0x6e, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {129D7E40-C10D-11d0-AFB9-00AA00B67A42}               DV muxer
OUR_GUID_ENTRY(CLSID_DVMux,
0x129d7e40, 0xc10d, 0x11d0, 0xaf, 0xb9, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {060AF76C-68DD-11d0-8FC1-00C04FD9189D}
OUR_GUID_ENTRY(CLSID_SeekingPassThru,
0x60af76c, 0x68dd, 0x11d0, 0x8f, 0xc1, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d)

// 6E8D4A20-310C-11d0-B79A-00AA003767A7                 Line21 (CC) Decoder
OUR_GUID_ENTRY(CLSID_Line21Decoder,
0x6e8d4a20, 0x310c, 0x11d0, 0xb7, 0x9a, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// E4206432-01A1-4BEE-B3E1-3702C8EDC574                 Line21 (CC) Decoder v2
OUR_GUID_ENTRY(CLSID_Line21Decoder2,
0xe4206432, 0x01a1, 0x4bee, 0xb3, 0xe1, 0x37, 0x02, 0xc8, 0xed, 0xc5, 0x74)

// {CD8743A1-3736-11d0-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(CLSID_OverlayMixer,
0xcd8743a1, 0x3736, 0x11d0, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {814B9800-1C88-11d1-BAD9-00609744111A}
OUR_GUID_ENTRY(CLSID_VBISurfaces,
0x814b9800, 0x1c88, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// {70BC06E0-5666-11d3-A184-00105AEF9F33}               WST Teletext Decoder
OUR_GUID_ENTRY(CLSID_WSTDecoder,
0x70bc06e0, 0x5666, 0x11d3, 0xa1, 0x84, 0x0, 0x10, 0x5a, 0xef, 0x9f, 0x33)

// {301056D0-6DFF-11d2-9EEB-006008039E37}
OUR_GUID_ENTRY(CLSID_MjpegDec,
0x301056d0, 0x6dff, 0x11d2, 0x9e, 0xeb, 0x0, 0x60, 0x8, 0x3, 0x9e, 0x37)

// {B80AB0A0-7416-11d2-9EEB-006008039E37}
OUR_GUID_ENTRY(CLSID_MJPGEnc,
0xb80ab0a0, 0x7416, 0x11d2, 0x9e, 0xeb, 0x0, 0x60, 0x8, 0x3, 0x9e, 0x37)



// pnp objects and categories
// 62BE5D10-60EB-11d0-BD3B-00A0C911CE86                 ICreateDevEnum
OUR_GUID_ENTRY(CLSID_SystemDeviceEnum,
0x62BE5D10,0x60EB,0x11d0,0xBD,0x3B,0x00,0xA0,0xC9,0x11,0xCE,0x86)

// 4315D437-5B8C-11d0-BD3B-00A0C911CE86
OUR_GUID_ENTRY(CLSID_CDeviceMoniker,
0x4315D437,0x5B8C,0x11d0,0xBD,0x3B,0x00,0xA0,0xC9,0x11,0xCE,0x86)

// 860BB310-5D01-11d0-BD3B-00A0C911CE86                 Video capture category
OUR_GUID_ENTRY(CLSID_VideoInputDeviceCategory,
0x860BB310,0x5D01,0x11d0,0xBD,0x3B,0x00,0xA0,0xC9,0x11,0xCE,0x86)
OUR_GUID_ENTRY(CLSID_CVidCapClassManager,
0x860BB310,0x5D01,0x11d0,0xBD,0x3B,0x00,0xA0,0xC9,0x11,0xCE,0x86)

// 083863F1-70DE-11d0-BD40-00A0C911CE86                 Filter category
OUR_GUID_ENTRY(CLSID_LegacyAmFilterCategory,
0x083863F1,0x70DE,0x11d0,0xBD,0x40,0x00,0xA0,0xC9,0x11,0xCE,0x86)
OUR_GUID_ENTRY(CLSID_CQzFilterClassManager,
0x083863F1,0x70DE,0x11d0,0xBD,0x40,0x00,0xA0,0xC9,0x11,0xCE,0x86)

// 33D9A760-90C8-11d0-BD43-00A0C911CE86
OUR_GUID_ENTRY(CLSID_VideoCompressorCategory,
0x33d9a760, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)
OUR_GUID_ENTRY(CLSID_CIcmCoClassManager,
0x33d9a760, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// 33D9A761-90C8-11d0-BD43-00A0C911CE86
OUR_GUID_ENTRY(CLSID_AudioCompressorCategory,
0x33d9a761, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)
OUR_GUID_ENTRY(CLSID_CAcmCoClassManager,
0x33d9a761, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// 33D9A762-90C8-11d0-BD43-00A0C911CE86                 Audio source cateogry
OUR_GUID_ENTRY(CLSID_AudioInputDeviceCategory,
0x33d9a762, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)
OUR_GUID_ENTRY(CLSID_CWaveinClassManager,
0x33d9a762, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// E0F158E1-CB04-11d0-BD4E-00A0C911CE86                 Audio renderer category
OUR_GUID_ENTRY(CLSID_AudioRendererCategory,
0xe0f158e1, 0xcb04, 0x11d0, 0xbd, 0x4e, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)
OUR_GUID_ENTRY(CLSID_CWaveOutClassManager,
0xe0f158e1, 0xcb04, 0x11d0, 0xbd, 0x4e, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// 4EFE2452-168A-11d1-BC76-00C04FB9453B                 Midi renderer category
OUR_GUID_ENTRY(CLSID_MidiRendererCategory,
0x4EfE2452, 0x168A, 0x11d1, 0xBC, 0x76, 0x0, 0xc0, 0x4F, 0xB9, 0x45, 0x3B)
OUR_GUID_ENTRY(CLSID_CMidiOutClassManager,
0x4EfE2452, 0x168A, 0x11d1, 0xBC, 0x76, 0x0, 0xc0, 0x4F, 0xB9, 0x45, 0x3B)

// CC7BFB41-F175-11d1-A392-00E0291F3959     External Renderers Category
OUR_GUID_ENTRY(CLSID_TransmitCategory,
0xcc7bfb41, 0xf175, 0x11d1, 0xa3, 0x92, 0x0, 0xe0, 0x29, 0x1f, 0x39, 0x59)

// CC7BFB46-F175-11d1-A392-00E0291F3959     Device Control Filters
OUR_GUID_ENTRY(CLSID_DeviceControlCategory,
0xcc7bfb46, 0xf175, 0x11d1, 0xa3, 0x92, 0x0, 0xe0, 0x29, 0x1f, 0x39, 0x59)

// DA4E3DA0-D07D-11d0-BD50-00A0C911CE86
OUR_GUID_ENTRY(CLSID_ActiveMovieCategories,
0xda4e3da0, 0xd07d, 0x11d0, 0xbd, 0x50, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// 2721AE20-7E70-11D0-A5D6-28DB04C10000
OUR_GUID_ENTRY(CLSID_DVDHWDecodersCategory,
0x2721AE20, 0x7E70, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00)

// 7D22E920-5CA9-4787-8C2B-A6779BD11781     Encoder API encoder category
OUR_GUID_ENTRY(CLSID_MediaEncoderCategory,
0x7D22E920, 0x5CA9, 0x4787, 0x8C, 0x2B, 0xA6, 0x77, 0x9B, 0xD1, 0x17, 0x81)

// 236C9559-ADCE-4736-BF72-BAB34E392196     Encoder API multiplexer category
OUR_GUID_ENTRY(CLSID_MediaMultiplexerCategory,
0x236C9559, 0xADCE, 0x4736, 0xBF, 0x72, 0xBA, 0xB3, 0x4E, 0x39, 0x21, 0x96)

// CDA42200-BD88-11d0-BD4E-00A0C911CE86
OUR_GUID_ENTRY(CLSID_FilterMapper2,
0xcda42200, 0xbd88, 0x11d0, 0xbd, 0x4e, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)


// 1e651cc0-b199-11d0-8212-00c04fc32c45
OUR_GUID_ENTRY(CLSID_MemoryAllocator,
0x1e651cc0, 0xb199, 0x11d0, 0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45)

// CDBD8D00-C193-11d0-BD4E-00A0C911CE86
OUR_GUID_ENTRY(CLSID_MediaPropertyBag,
0xcdbd8d00, 0xc193, 0x11d0, 0xbd, 0x4e, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// FCC152B7-F372-11d0-8E00-00C04FD7C08B
OUR_GUID_ENTRY(CLSID_DvdGraphBuilder,
0xFCC152B7, 0xF372, 0x11d0, 0x8E, 0x00, 0x00, 0xC0, 0x4F, 0xD7, 0xC0, 0x8B)

// 9B8C4620-2C1A-11d0-8493-00A02438AD48
OUR_GUID_ENTRY(CLSID_DVDNavigator,
0x9b8c4620, 0x2c1a, 0x11d0, 0x84, 0x93, 0x0, 0xa0, 0x24, 0x38, 0xad, 0x48)

// f963c5cf-a659-4a93-9638-caf3cd277d13
OUR_GUID_ENTRY(CLSID_DVDState,
0xf963c5cf, 0xa659, 0x4a93, 0x96, 0x38, 0xca, 0xf3, 0xcd, 0x27, 0x7d, 0x13)

// CC58E280-8AA1-11d1-B3F1-00AA003761C5
OUR_GUID_ENTRY(CLSID_SmartTee,
0xcc58e280, 0x8aa1, 0x11d1, 0xb3, 0xf1, 0x0, 0xaa, 0x0, 0x37, 0x61, 0xc5)

// -- format types ---

// 0F6417D6-C318-11D0-A43F-00A0C9223196        FORMAT_None
OUR_GUID_ENTRY(FORMAT_None,
0x0F6417D6, 0xc318, 0x11d0, 0xa4, 0x3f, 0x00, 0xa0, 0xc9, 0x22, 0x31, 0x96)

// 05589f80-c356-11ce-bf01-00aa0055595a        FORMAT_VideoInfo
OUR_GUID_ENTRY(FORMAT_VideoInfo,
0x05589f80, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// F72A76A0-EB0A-11d0-ACE4-0000C0CC16BA        FORMAT_VideoInfo2
OUR_GUID_ENTRY(FORMAT_VideoInfo2,
0xf72a76A0, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// 05589f81-c356-11ce-bf01-00aa0055595a        FORMAT_WaveFormatEx
OUR_GUID_ENTRY(FORMAT_WaveFormatEx,
0x05589f81, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 05589f82-c356-11ce-bf01-00aa0055595a        FORMAT_MPEGVideo
OUR_GUID_ENTRY(FORMAT_MPEGVideo,
0x05589f82, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 05589f83-c356-11ce-bf01-00aa0055595a        FORMAT_MPEGStreams
OUR_GUID_ENTRY(FORMAT_MPEGStreams,
0x05589f83, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 05589f84-c356-11ce-bf01-00aa0055595a        FORMAT_DvInfo, DVINFO
OUR_GUID_ENTRY(FORMAT_DvInfo,
0x05589f84, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)


// -- Video related GUIDs ---


// 944d4c00-dd52-11ce-bf0e-00aa0055595a
OUR_GUID_ENTRY(CLSID_DirectDrawProperties,
0x944d4c00, 0xdd52, 0x11ce, 0xbf, 0x0e, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 59ce6880-acf8-11cf-b56e-0080c7c4b68a
OUR_GUID_ENTRY(CLSID_PerformanceProperties,
0x59ce6880, 0xacf8, 0x11cf, 0xb5, 0x6e, 0x00, 0x80, 0xc7, 0xc4, 0xb6, 0x8a)

// 418afb70-f8b8-11ce-aac6-0020af0b99a3
OUR_GUID_ENTRY(CLSID_QualityProperties,
0x418afb70, 0xf8b8, 0x11ce, 0xaa, 0xc6, 0x00, 0x20, 0xaf, 0x0b, 0x99, 0xa3)

// 61ded640-e912-11ce-a099-00aa00479a58
OUR_GUID_ENTRY(IID_IBaseVideoMixer,
0x61ded640, 0xe912, 0x11ce, 0xa0, 0x99, 0x00, 0xaa, 0x00, 0x47, 0x9a, 0x58)

// 36d39eb0-dd75-11ce-bf0e-00aa0055595a
OUR_GUID_ENTRY(IID_IDirectDrawVideo,
0x36d39eb0, 0xdd75, 0x11ce, 0xbf, 0x0e, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// bd0ecb0-f8e2-11ce-aac6-0020af0b99a3
OUR_GUID_ENTRY(IID_IQualProp,
0x1bd0ecb0, 0xf8e2, 0x11ce, 0xaa, 0xc6, 0x00, 0x20, 0xaf, 0x0b, 0x99, 0xa3)

// {CE292861-FC88-11d0-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(CLSID_VPObject,
0xce292861, 0xfc88, 0x11d0, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {CE292862-FC88-11d0-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IVPObject,
0xce292862, 0xfc88, 0x11d0, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {25DF12C1-3DE0-11d1-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IVPControl,
0x25df12c1, 0x3de0, 0x11d1, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {814B9801-1C88-11d1-BAD9-00609744111A}
OUR_GUID_ENTRY(CLSID_VPVBIObject,
0x814b9801, 0x1c88, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// {814B9802-1C88-11d1-BAD9-00609744111A}
OUR_GUID_ENTRY(IID_IVPVBIObject,
0x814b9802, 0x1c88, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// {BC29A660-30E3-11d0-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IVPConfig,
0xbc29a660, 0x30e3, 0x11d0, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {C76794A1-D6C5-11d0-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IVPNotify,
0xc76794a1, 0xd6c5, 0x11d0, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {EBF47183-8764-11d1-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IVPNotify2,
0xebf47183, 0x8764, 0x11d1, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)


// {EC529B00-1A1F-11D1-BAD9-00609744111A}
OUR_GUID_ENTRY(IID_IVPVBIConfig,
0xec529b00, 0x1a1f, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// {EC529B01-1A1F-11D1-BAD9-00609744111A}
OUR_GUID_ENTRY(IID_IVPVBINotify,
0xec529b01, 0x1a1f, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// {593CDDE1-0759-11d1-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IMixerPinConfig,
0x593cdde1, 0x759, 0x11d1, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {EBF47182-8764-11d1-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IMixerPinConfig2,
0xebf47182, 0x8764, 0x11d1, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)


// This is a real pain in the neck. The OLE GUIDs are separated out into a
// different file from the main header files. The header files can then be
// included multiple times and are protected with the following statements,
//
//      #ifndef __SOMETHING_DEFINED__
//      #define __SOMETHING_DEFINED__
//          all the header contents
//      #endif // __SOMETHING_DEFINED__
//
// When the actual GUIDs are to be defined (using initguid) the GUID header
// file can then be included to really define them just once. Unfortunately
// DirectDraw has the GUIDs defined in the main header file. So if the base
// classes bring in ddraw.h to get at the DirectDraw structures and so on
// nobody would then be able to really include ddraw.h to allocate the GUID
// memory structures because of the aforementioned header file protection
// Therefore the DirectDraw GUIDs are defined and allocated for real here

#ifndef __DDRAW_INCLUDED__
OUR_GUID_ENTRY(CLSID_DirectDraw,            0xD7B70EE0,0x4340,0x11CF,0xB0,0x63,0x00,0x20,0xAF,0xC2,0xCD,0x35)
OUR_GUID_ENTRY(CLSID_DirectDrawClipper,     0x593817A0,0x7DB3,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xb9,0x33,0x56)
OUR_GUID_ENTRY(IID_IDirectDraw,             0x6C14DB80,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
OUR_GUID_ENTRY(IID_IDirectDraw2,            0xB3A6F3E0,0x2B43,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xB9,0x33,0x56)
OUR_GUID_ENTRY(IID_IDirectDrawSurface,      0x6C14DB81,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
OUR_GUID_ENTRY(IID_IDirectDrawSurface2,     0x57805885,0x6eec,0x11cf,0x94,0x41,0xa8,0x23,0x03,0xc1,0x0e,0x27)
OUR_GUID_ENTRY(IID_IDirectDrawSurface3,     0xDA044E00,0x69B2,0x11D0,0xA1,0xD5,0x00,0xAA,0x00,0xB8,0xDF,0xBB)
OUR_GUID_ENTRY(IID_IDirectDrawSurface4,     0x0B2B8630,0xAD35,0x11D0,0x8E,0xA6,0x00,0x60,0x97,0x97,0xEA,0x5B)
OUR_GUID_ENTRY(IID_IDirectDrawSurface7,     0x06675a80,0x3b9b,0x11d2,0xb9,0x2f,0x00,0x60,0x97,0x97,0xea,0x5b)
OUR_GUID_ENTRY(IID_IDirectDrawPalette,      0x6C14DB84,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
OUR_GUID_ENTRY(IID_IDirectDrawClipper,      0x6C14DB85,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
OUR_GUID_ENTRY(IID_IDirectDrawColorControl, 0x4B9F0EE0,0x0D7E,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8)
#endif

#ifndef __DVP_INCLUDED__
OUR_GUID_ENTRY(IID_IDDVideoPortContainer,    0x6C142760,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
#endif

#ifndef __DDKM_INCLUDED__
OUR_GUID_ENTRY(IID_IDirectDrawKernel,        0x8D56C120,0x6A08,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8)
OUR_GUID_ENTRY(IID_IDirectDrawSurfaceKernel, 0x60755DA0,0x6A40,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8)
#endif

// 0618aa30-6bc4-11cf-bf36-00aa0055595a
OUR_GUID_ENTRY(CLSID_ModexProperties,
0x0618aa30, 0x6bc4, 0x11cf, 0xbf, 0x36, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// dd1d7110-7836-11cf-bf47-00aa0055595a
OUR_GUID_ENTRY(IID_IFullScreenVideo,
0xdd1d7110, 0x7836, 0x11cf, 0xbf, 0x47, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 53479470-f1dd-11cf-bc42-00aa00ac74f6
OUR_GUID_ENTRY(IID_IFullScreenVideoEx,
0x53479470, 0xf1dd, 0x11cf, 0xbc, 0x42, 0x00, 0xaa, 0x00, 0xac, 0x74, 0xf6)

// {101193C0-0BFE-11d0-AF91-00AA00B67A42}           DV decoder property
OUR_GUID_ENTRY(CLSID_DVDecPropertiesPage,
0x101193c0, 0xbfe, 0x11d0, 0xaf, 0x91, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {4150F050-BB6F-11d0-AFB9-00AA00B67A42}           DV encoder property
OUR_GUID_ENTRY(CLSID_DVEncPropertiesPage,
0x4150f050, 0xbb6f, 0x11d0, 0xaf, 0xb9, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {4DB880E0-C10D-11d0-AFB9-00AA00B67A42}           DV Muxer property
OUR_GUID_ENTRY(CLSID_DVMuxPropertyPage,
0x4db880e0, 0xc10d, 0x11d0, 0xaf, 0xb9, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)


// -- Direct Sound Audio related GUID ---

// 546F4260-D53E-11cf-B3F0-00AA003761C5
OUR_GUID_ENTRY(IID_IAMDirectSound,
0x546f4260, 0xd53e, 0x11cf, 0xb3, 0xf0, 0x0, 0xaa, 0x0, 0x37, 0x61, 0xc5)

// -- MPEG audio decoder properties

// {b45dd570-3c77-11d1-abe1-00a0c905f375}
OUR_GUID_ENTRY(IID_IMpegAudioDecoder,
0xb45dd570, 0x3c77, 0x11d1, 0xab, 0xe1, 0x00, 0xa0, 0xc9, 0x05, 0xf3, 0x75)

// --- Line21 Decoder interface GUID ---

// 6E8D4A21-310C-11d0-B79A-00AA003767A7            IID_IAMLine21Decoder
OUR_GUID_ENTRY(IID_IAMLine21Decoder,
0x6e8d4a21, 0x310c, 0x11d0, 0xb7, 0x9a, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// --- WST Decoder interface GUID ---

// C056DE21-75C2-11d3-A184-00105AEF9F33            IID_IAMWstDecoder
OUR_GUID_ENTRY(IID_IAMWstDecoder,
0xc056de21, 0x75c2, 0x11d3, 0xa1, 0x84, 0x0, 0x10, 0x5a, 0xef, 0x9f, 0x33)

// --- WST Decoder Property Page ---

// 04E27F80-91E4-11d3-A184-00105AEF9F33            WST Decoder Property Page
OUR_GUID_ENTRY(CLSID_WstDecoderPropertyPage,
0x4e27f80, 0x91e4, 0x11d3, 0xa1, 0x84, 0x0, 0x10, 0x5a, 0xef, 0x9f, 0x33)


// -- Analog video related GUIDs ---


// -- format types ---
// 0482DDE0-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(FORMAT_AnalogVideo,
0x482dde0, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)


// -- major type, Analog Video

// 0482DDE1-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIATYPE_AnalogVideo,
0x482dde1, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)


// -- Analog Video subtypes, NTSC

// 0482DDE2-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_NTSC_M,
0x482dde2, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// -- Analog Video subtypes, PAL

// 0482DDE5-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_B,
0x482dde5, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDE6-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_D,
0x482dde6, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDE7-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_G,
0x482dde7, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDE8-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_H,
0x482dde8, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDE9-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_I,
0x482dde9, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDEA-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_M,
0x482ddea, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDEB-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_N,
0x482ddeb, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDEC-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_N_COMBO,
0x482ddec, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// -- Analog Video subtypes, SECAM

// 0482DDF0-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_B,
0x482ddf0, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF1-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_D,
0x482ddf1, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF2-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_G,
0x482ddf2, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF3-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_H,
0x482ddf3, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF4-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_K,
0x482ddf4, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF5-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_K1,
0x482ddf5, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF6-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_L,
0x482ddf6, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)


// --  External audio related GUIDs ---

// -- major types, Analog Audio

// 0482DEE1-7817-11cf-8a03-00aa006ecb65
OUR_GUID_ENTRY(MEDIATYPE_AnalogAudio,
0x482dee1, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

//
// DirectShow's include file based on ksmedia.h from WDM DDK
//
#include "ksuuids.h"


// -- Well known time format GUIDs ---


// 00000000-0000-0000-0000-000000000000
OUR_GUID_ENTRY(TIME_FORMAT_NONE,
0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)

// 7b785570-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_FRAME,
0x7b785570, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)

// 7b785571-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_BYTE,
0x7b785571, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)

// 7b785572-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_SAMPLE,
0x7b785572, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)

// 7b785573-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_FIELD,
0x7b785573, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)


// 7b785574-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_MEDIA_TIME,
0x7b785574, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)


// for IKsPropertySet

// 9B00F101-1567-11d1-B3F1-00AA003761C5
OUR_GUID_ENTRY(AMPROPSETID_Pin,
0x9b00f101, 0x1567, 0x11d1, 0xb3, 0xf1, 0x0, 0xaa, 0x0, 0x37, 0x61, 0xc5)

// fb6c4281-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_CAPTURE,
0xfb6c4281, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4282-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_PREVIEW,
0xfb6c4282, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4283-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_ANALOGVIDEOIN,
0xfb6c4283, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4284-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_VBI,
0xfb6c4284, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4285-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_VIDEOPORT,
0xfb6c4285, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4286-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_NABTS,
0xfb6c4286, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4287-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_EDS,
0xfb6c4287, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4288-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_TELETEXT,
0xfb6c4288, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4289-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_CC,
0xfb6c4289, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c428a-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_STILL,
0xfb6c428a, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c428b-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_TIMECODE,
0xfb6c428b, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c428c-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_VIDEOPORT_VBI,
0xfb6c428c, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)


// the following special GUIDS are used by ICaptureGraphBuilder::FindInterface

// {AC798BE0-98E3-11d1-B3F1-00AA003761C5}
OUR_GUID_ENTRY(LOOK_UPSTREAM_ONLY,
0xac798be0, 0x98e3, 0x11d1, 0xb3, 0xf1, 0x0, 0xaa, 0x0, 0x37, 0x61, 0xc5)

// {AC798BE1-98E3-11d1-B3F1-00AA003761C5}
OUR_GUID_ENTRY(LOOK_DOWNSTREAM_ONLY,
0xac798be1, 0x98e3, 0x11d1, 0xb3, 0xf1, 0x0, 0xaa, 0x0, 0x37, 0x61, 0xc5)

// -------------------------------------------------------------------------
// KSProxy GUIDS
// -------------------------------------------------------------------------

// {266EEE41-6C63-11cf-8A03-00AA006ECB65}
OUR_GUID_ENTRY(CLSID_TVTunerFilterPropertyPage,
0x266eee41, 0x6c63, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// {71F96461-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_CrossbarFilterPropertyPage,
0x71f96461, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)

// {71F96463-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_TVAudioFilterPropertyPage,
0x71f96463, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)

// {71F96464-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_VideoProcAmpPropertyPage,
0x71f96464, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)

// {71F96465-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_CameraControlPropertyPage,
0x71f96465, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)

// {71F96466-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_AnalogVideoDecoderPropertyPage,
0x71f96466, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)

// {71F96467-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_VideoStreamConfigPropertyPage,
0x71f96467, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)

// {37E92A92-D9AA-11d2-BF84-8EF2B1555AED} Audio Renderer Advanced Property Page
OUR_GUID_ENTRY(CLSID_AudioRendererAdvancedProperties,
0x37e92a92, 0xd9aa, 0x11d2, 0xbf, 0x84, 0x8e, 0xf2, 0xb1, 0x55, 0x5a, 0xed)


// -------------------------------------------------------------------------
// VMR GUIDS
// -------------------------------------------------------------------------

// {B87BEB7B-8D29-423f-AE4D-6582C10175AC}
OUR_GUID_ENTRY(CLSID_VideoMixingRenderer,
0xB87BEB7B, 0x8D29, 0x423f, 0xAE, 0x4D, 0x65, 0x82, 0xC1, 0x01, 0x75, 0xAC)

// {6BC1CFFA-8FC1-4261-AC22-CFB4CC38DB50}
OUR_GUID_ENTRY(CLSID_VideoRendererDefault,
0x6BC1CFFA, 0x8FC1, 0x4261, 0xAC, 0x22, 0xCF, 0xB4, 0xCC, 0x38, 0xDB, 0x50)

// {99d54f63-1a69-41ae-aa4d-c976eb3f0713}
OUR_GUID_ENTRY(CLSID_AllocPresenter,
0x99d54f63, 0x1a69, 0x41ae, 0xaa, 0x4d, 0xc9, 0x76, 0xeb, 0x3f, 0x07, 0x13)

// {4444ac9e-242e-471b-a3c7-45dcd46352bc}
OUR_GUID_ENTRY(CLSID_AllocPresenterDDXclMode,
0x4444ac9e, 0x242e, 0x471b, 0xa3, 0xc7, 0x45, 0xdc, 0xd4, 0x63, 0x52, 0xbc)

// {6f26a6cd-967b-47fd-874a-7aed2c9d25a2}
OUR_GUID_ENTRY(CLSID_VideoPortManager,
0x6f26a6cd, 0x967b, 0x47fd, 0x87, 0x4a, 0x7a, 0xed, 0x2c, 0x9d, 0x25, 0xa2)

// -------------------------------------------------------------------------
// BDA Network Provider GUIDS
// -------------------------------------------------------------------------

// {0DAD2FDD-5FD7-11D3-8F50-00C04F7971E2}
OUR_GUID_ENTRY(CLSID_ATSCNetworkProvider,
0x0dad2fdd, 0x5fd7, 0x11d3, 0x8f, 0x50, 0x00, 0xc0, 0x4f, 0x79, 0x71, 0xe2)

// {E3444D16-5AC4-4386-88DF-13FD230E1DDA}
OUR_GUID_ENTRY(CLSID_ATSCNetworkPropertyPage,
0xe3444d16, 0x5ac4, 0x4386, 0x88, 0xdf, 0x13, 0xfd, 0x23, 0x0e, 0x1d, 0xda)

// {FA4B375A-45B4-4d45-8440-263957B11623}
OUR_GUID_ENTRY(CLSID_DVBSNetworkProvider,
0xfa4b375a, 0x45b4, 0x4d45, 0x84, 0x40, 0x26, 0x39, 0x57, 0xb1, 0x16, 0x23)


// -------------------------------------------------------------------------
// TVE Receiver filter guids
// -------------------------------------------------------------------------

// The CLSID used by the TVE Receiver filter
// {05500280-FAA5-4DF9-8246-BFC23AC5CEA8}
OUR_GUID_ENTRY(CLSID_DShowTVEFilter,
0x05500280, 0xFAA5, 0x4DF9, 0x82, 0x46, 0xBF, 0xC2, 0x3A, 0xC5, 0xCE, 0xA8)

// {05500281-FAA5-4DF9-8246-BFC23AC5CEA8}
OUR_GUID_ENTRY(CLSID_TVEFilterTuneProperties,
0x05500281, 0xFAA5, 0x4DF9, 0x82, 0x46, 0xBF, 0xC2, 0x3A, 0xC5, 0xCE, 0xA8)


// {05500282-FAA5-4DF9-8246-BFC23AC5CEA8}
OUR_GUID_ENTRY(CLSID_TVEFilterCCProperties,
0x05500282, 0xFAA5, 0x4DF9, 0x82, 0x46, 0xBF, 0xC2, 0x3A, 0xC5, 0xCE, 0xA8)

// {05500283-FAA5-4DF9-8246-BFC23AC5CEA8}
OUR_GUID_ENTRY(CLSID_TVEFilterStatsProperties,
0x05500283, 0xFAA5, 0x4DF9, 0x82, 0x46, 0xBF, 0xC2, 0x3A, 0xC5, 0xCE, 0xA8)

// -------------------------------------------------------------------------
// Defined ENCAPI parameter GUIDs
// -------------------------------------------------------------------------

// The CLSID for the IVideoEncoder proxy plug-in
// {B43C4EEC-8C32-4791-9102-508ADA5EE8E7}
OUR_GUID_ENTRY(CLSID_IVideoEncoderProxy,
0xb43c4eec, 0x8c32, 0x4791, 0x91, 0x2, 0x50, 0x8a, 0xda, 0x5e, 0xe8, 0xe7)

#ifndef __ENCODER_API_GUIDS__
#define __ENCODER_API_GUIDS__

// {49CC4C43-CA83-4ad4-A9AF-F3696AF666DF}
OUR_GUID_ENTRY(ENCAPIPARAM_BITRATE,
0x49cc4c43, 0xca83, 0x4ad4, 0xa9, 0xaf, 0xf3, 0x69, 0x6a, 0xf6, 0x66, 0xdf)

// {703F16A9-3D48-44a1-B077-018DFF915D19}
OUR_GUID_ENTRY(ENCAPIPARAM_PEAK_BITRATE,
0x703f16a9, 0x3d48, 0x44a1, 0xb0, 0x77, 0x1, 0x8d, 0xff, 0x91, 0x5d, 0x19)

// {EE5FB25C-C713-40d1-9D58-C0D7241E250F}
OUR_GUID_ENTRY(ENCAPIPARAM_BITRATE_MODE,
0xee5fb25c, 0xc713, 0x40d1, 0x9d, 0x58, 0xc0, 0xd7, 0x24, 0x1e, 0x25, 0xf)

#endif // __ENCODER_API_GUIDS__

#undef OUR_GUID_ENTRY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\include\amparse.h ===
//------------------------------------------------------------------------------
// File: AMParse.h
//
// Desc: Interface to the parser to get current time.  This is useful for
//       multifile playback.
//
// Copyright (c) 1996 - 2000, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __AMPARSE__
#define __AMPARSE__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


DEFINE_GUID(IID_IAMParse,
0xc47a3420, 0x005c, 0x11d2, 0x90, 0x38, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x98);

//
//  Parser interface - supported by MPEG-2 splitter filter
//
DECLARE_INTERFACE_(IAMParse, IUnknown) {
    STDMETHOD(GetParseTime) (THIS_
                             REFERENCE_TIME *prtCurrent
                            ) PURE;
    STDMETHOD(SetParseTime) (THIS_
                             REFERENCE_TIME rtCurrent
                            ) PURE;
    STDMETHOD(Flush) (THIS) PURE;
};

#ifdef __cplusplus
}
#endif // __cplusplus
#endif // __AMPARSE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\include\amaudio.h ===
//------------------------------------------------------------------------------
// File: AMAudio.h
//
// Desc: Audio related definitions and interfaces for ActiveMovie.
//
// Copyright (c) 1992 - 2000, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __AMAUDIO__
#define __AMAUDIO__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include <mmsystem.h>
#include <dsound.h>

// This is the interface the audio renderer supports to give the application
// access to the direct sound object and buffers it is using, to allow the
// application to use things like the 3D features of Direct Sound for the
// soundtrack of a movie being played with Active Movie

// be nice to our friends in C
#undef INTERFACE
#define INTERFACE IAMDirectSound

DECLARE_INTERFACE_(IAMDirectSound,IUnknown)
{
    /* IUnknown methods */

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /* IAMDirectSound methods */

    STDMETHOD(GetDirectSoundInterface)(THIS_ LPDIRECTSOUND *lplpds) PURE;
    STDMETHOD(GetPrimaryBufferInterface)(THIS_ LPDIRECTSOUNDBUFFER *lplpdsb) PURE;
    STDMETHOD(GetSecondaryBufferInterface)(THIS_ LPDIRECTSOUNDBUFFER *lplpdsb) PURE;
    STDMETHOD(ReleaseDirectSoundInterface)(THIS_ LPDIRECTSOUND lpds) PURE;
    STDMETHOD(ReleasePrimaryBufferInterface)(THIS_ LPDIRECTSOUNDBUFFER lpdsb) PURE;
    STDMETHOD(ReleaseSecondaryBufferInterface)(THIS_ LPDIRECTSOUNDBUFFER lpdsb) PURE;
    STDMETHOD(SetFocusWindow)(THIS_ HWND, BOOL) PURE ;
    STDMETHOD(GetFocusWindow)(THIS_ HWND *, BOOL*) PURE ;
};


#ifdef __cplusplus
}
#endif // __cplusplus
#endif // __AMAUDIO__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\include\amva.h ===
//------------------------------------------------------------------------------
// File: AMVA.h
//
// Desc: DirectShowMotionComp include file.
//
// Copyright (c) 1997 - 2000, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __AMVA_INCLUDED__
#define __AMVA_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif


#define AMVA_TYPEINDEX_OUTPUTFRAME 0xFFFFFFFF

//  Flags for QueryRenderStatus
#define AMVA_QUERYRENDERSTATUSF_READ     0x00000001  // Query for read
                                                     // set this bit to 0
                                                     // if query for update

typedef struct _tag_AMVAUncompBufferInfo
{
 DWORD                   dwMinNumSurfaces;           // IN   min number of surfaces to be allocated
 DWORD                   dwMaxNumSurfaces;           // IN   max number of surfaces to be allocated
 DDPIXELFORMAT           ddUncompPixelFormat;        // IN   pixel format of surfaces to be allocated
} AMVAUncompBufferInfo, *LPAMVAUncompBufferInfo;

typedef struct _tag_AMVAUncompDataInfo
{
    DWORD                   dwUncompWidth;              // [in]     width of uncompressed data
    DWORD                   dwUncompHeight;             // [in]     height of uncompressed data
    DDPIXELFORMAT           ddUncompPixelFormat;        // [in]     pixel-format of uncompressed data
} AMVAUncompDataInfo, *LPAMVAUncompDataInfo;

typedef struct _tag_AMVAInternalMemInfo
{
    DWORD                   dwScratchMemAlloc;          // [out]    amount of scratch memory will the hal allocate for its private use
} AMVAInternalMemInfo, *LPAMVAInternalMemInfo;


typedef struct _tag_AMVACompBufferInfo
{
    DWORD                   dwNumCompBuffers;           // [out]    number of buffers reqd for compressed data
    DWORD                   dwWidthToCreate;            // [out]    Width of surface to create
    DWORD                   dwHeightToCreate;           // [out]    Height of surface to create
    DWORD                   dwBytesToAllocate;          // [out]    Total number of bytes used by each surface
    DDSCAPS2                ddCompCaps;                 // [out]    caps to create surfaces to store compressed data
    DDPIXELFORMAT           ddPixelFormat;              // [out]    fourcc to create surfaces to store compressed data
} AMVACompBufferInfo, *LPAMVACompBufferInfo;


// Note that you are NOT allowed to store any pointer in pMiscData
typedef struct _tag_AMVABeginFrameInfo
{
    DWORD                dwDestSurfaceIndex;         // IN  destination buffer in which to decoding this frame
    LPVOID               pInputData;                 // IN  pointer to misc data
    DWORD                dwSizeInputData;            // IN  size of other misc data to begin frame
    LPVOID               pOutputData;                // OUT pointer to data which the VGA is going to fill
    DWORD                dwSizeOutputData;           // IN  size of data which the VGA is going to fill
} AMVABeginFrameInfo, *LPAMVABeginFrameInfo;

// Note that you are NOT allowed to store any pointer in pMiscData
typedef struct _tag_AMVAEndFrameInfo
{
    DWORD                   dwSizeMiscData;             // [in]     size of other misc data to begin frame
    LPVOID                  pMiscData;                  // [in]     pointer to misc data
} AMVAEndFrameInfo, *LPAMVAEndFrameInfo;

typedef struct _tag_AMVABUFFERINFO
{
    DWORD                   dwTypeIndex;                // [in]    Type of buffer
    DWORD                   dwBufferIndex;              // [in]    Buffer index
    DWORD                   dwDataOffset;               // [in]    offset of relevant data from the beginning of buffer
    DWORD                   dwDataSize;                 // [in]    size of relevant data
} AMVABUFFERINFO, *LPAMVABUFFERINFO;

#ifdef __cplusplus
};
#endif

#endif // _AMVA_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\include\atsmedia.h ===
//------------------------------------------------------------------------------
// File: ATSMedia.h
//
// Desc: Broadcast Driver Architecture Media Definitions for ATSC
//
// Copyright (c) 1996 - 2000, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#if !defined(_KSMEDIA_)
#error KSMEDIA.H must be included before BDAMEDIA.H
#endif // !defined(_KSMEDIA_)

#if !defined(_BDAMEDIA_)
#error BDAMEDIA.H must be included before ATSCMEDIA.H
#endif // !defined(_KSMEDIA_)

#if !defined(_ATSCMEDIA_)
#define _ATSCMEDIA_


//===========================================================================
//
//  ATSC Network Type
//
//===========================================================================

#define STATIC_BDANETWORKTYPE_ATSC\
    0x71985f51, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F51-1CA1-11d3-9CC8-00C04F7971E0", BDANETWORKTYPE_ATSC);
#define BDANETWORKTYPE_ATSC DEFINE_GUIDNAMED(BDANETWORKTYPE_ATSC)


#endif // _ATSCMEDIA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\include\audevcod.h ===
//------------------------------------------------------------------------------
// File: AudEvCod.h
//
// Desc: List of Audio device error event codes and the expected params.
//
// Copyright (c) 1999 - 2000, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------



#ifndef __AUDEVCOD__
#define __AUDEVCOD__


#define EC_SND_DEVICE_ERROR_BASE   0x0200

typedef enum _tagSND_DEVICE_ERROR {

    SNDDEV_ERROR_Open=1,
    SNDDEV_ERROR_Close=2,
    SNDDEV_ERROR_GetCaps=3,
    SNDDEV_ERROR_PrepareHeader=4,
    SNDDEV_ERROR_UnprepareHeader=5,
    SNDDEV_ERROR_Reset=6,
    SNDDEV_ERROR_Restart=7,
    SNDDEV_ERROR_GetPosition=8,
    SNDDEV_ERROR_Write=9,
    SNDDEV_ERROR_Pause=10,
    SNDDEV_ERROR_Stop=11,
    SNDDEV_ERROR_Start=12,
    SNDDEV_ERROR_AddBuffer=13,
    SNDDEV_ERROR_Query=14,

} SNDDEV_ERR;


// Sound device error event codes
// ==============================
//
// All audio device error events are always passed on to the application, and are
// never processed by the filter graph


#define EC_SNDDEV_IN_ERROR                    (EC_SND_DEVICE_ERROR_BASE + 0x00)
#define EC_SNDDEV_OUT_ERROR                   (EC_SND_DEVICE_ERROR_BASE + 0x01)
// Parameters: ( DWORD, DWORD)
// lParam1 is an enum SND_DEVICE_ERROR which notifies the app how the device was
// being accessed when the failure occurred.
//
// lParam2 is the error returned from the sound device call.
//

#endif // __AUDEVCOD__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\idl\ksuuids.h ===
//------------------------------------------------------------------------------
// File: ksuuids.h
//
// Desc: Contains the GUIDs for the MediaType type, subtype fields and format
//       types for DVD/MPEG2 media types.
//
// Copyright (c) 1992 - 2000, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


//
// --- MPEG 2 definitions ---
//

// 36523B13-8EE5-11d1-8CA3-0060B057664A
OUR_GUID_ENTRY(MEDIATYPE_MPEG2_PACK,
0x36523B13, 0x8EE5, 0x11d1, 0x8C, 0xA3, 0x00, 0x60, 0xB0, 0x57, 0x66, 0x4A)

// e06d8020-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIATYPE_MPEG2_PES,
0xe06d8020, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea)


#if 0
DEFINE_GUID(MEDIATYPE_CONTROL,
0xe06d8021, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
#endif // #if 0


// e06d8026-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG2_VIDEO,
0xe06d8026, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea)

// use MPEG2VIDEOINFO (defined below) with FORMAT_MPEG2_VIDEO
// e06d80e3-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(FORMAT_MPEG2_VIDEO,
0xe06d80e3, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea)

// F72A76A0-EB0A-11d0-ACE4-0000C0CC16BA       (FORMAT_VideoInfo2)
OUR_GUID_ENTRY(FORMAT_VIDEOINFO2,
0xf72a76A0L, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba)

// MPEG2 Other subtypes
// e06d8022-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG2_PROGRAM,
0xe06d8022, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d8023-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG2_TRANSPORT,
0xe06d8023, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// 138AA9A4-1EE2-4c5b-988E-19ABFDBC8A11
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG2_TRANSPORT_STRIDE,
0x138aa9a4, 0x1ee2, 0x4c5b, 0x98, 0x8e, 0x19, 0xab, 0xfd, 0xbc, 0x8a, 0x11)

// e06d802b-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG2_AUDIO,
0xe06d802b, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d802c-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DOLBY_AC3,
0xe06d802c, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d802d-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DVD_SUBPICTURE,
0xe06d802d, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d8032-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DVD_LPCM_AUDIO,
0xe06d8032, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d8033-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DTS,
0xe06d8033, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d8034-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_SDDS,
0xe06d8034, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// DVD-related mediatypes
// ED0B916A-044D-11d1-AA78-00C04FC31D60
OUR_GUID_ENTRY(MEDIATYPE_DVD_ENCRYPTED_PACK,
0xed0b916a, 0x044d, 0x11d1, 0xaa, 0x78, 0x00, 0xc0, 0x04f, 0xc3, 0x1d, 0x60)

// e06d802e-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIATYPE_DVD_NAVIGATION,
0xe06d802e, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d802f-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DVD_NAVIGATION_PCI,
0xe06d802f, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d8030-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DVD_NAVIGATION_DSI,
0xe06d8030, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d8031-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DVD_NAVIGATION_PROVIDER,
0xe06d8031, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

//
// DVD - MPEG2/AC3-related Formats
//
// e06d80e3-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(FORMAT_MPEG2Video,
0xe06d80e3, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d80e4-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(FORMAT_DolbyAC3,
0xe06d80e4, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d80e5-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(FORMAT_MPEG2Audio,
0xe06d80e5, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d80e6-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(FORMAT_DVD_LPCMAudio,
0xe06d80e6, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)


//
// KS Property Set Id (to communicate with the WDM Proxy filter) -- from
// ksmedia.h of WDM DDK.
//

// BFABE720-6E1F-11D0-BCF2-444553540000
OUR_GUID_ENTRY(AM_KSPROPSETID_AC3,
0xBFABE720, 0x6E1F, 0x11D0, 0xBC, 0xF2, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00)

// ac390460-43af-11d0-bd6a-003505c103a9
OUR_GUID_ENTRY(AM_KSPROPSETID_DvdSubPic,
0xac390460, 0x43af, 0x11d0, 0xbd, 0x6a, 0x00, 0x35, 0x05, 0xc1, 0x03, 0xa9)

// 0E8A0A40L-6AEF-11D0-9ED0-00A024CA19B3
OUR_GUID_ENTRY(AM_KSPROPSETID_CopyProt,
0x0E8A0A40, 0x6AEF, 0x11D0, 0x9E, 0xD0, 0x00, 0xA0, 0x24, 0xCA, 0x19, 0xB3)

// A503C5C0-1D1D-11d1-AD80-444553540000
OUR_GUID_ENTRY(AM_KSPROPSETID_TSRateChange,
0xa503c5c0, 0x1d1d, 0x11d1, 0xad, 0x80, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0)

// 3577EB09-9582-477f-B29C-B0C452A4FF9A
OUR_GUID_ENTRY(AM_KSPROPSETID_DVD_RateChange,
0x3577eb09, 0x9582, 0x477f, 0xb2, 0x9c, 0xb0, 0xc4, 0x52, 0xa4, 0xff, 0x9a)

// ae4720ae-aa71-42d8-b82a-fffdf58b76fd
OUR_GUID_ENTRY(AM_KSPROPSETID_DvdKaraoke,
0xae4720ae, 0xaa71, 0x42d8, 0xb8, 0x2a, 0xff, 0xfd, 0xf5, 0x8b, 0x76, 0xfd)

// c830acbd-ab07-492f-8852-45b6987c2979
OUR_GUID_ENTRY(AM_KSPROPSETID_FrameStep,
0xc830acbd, 0xab07, 0x492f, 0x88, 0x52, 0x45, 0xb6, 0x98, 0x7c, 0x29, 0x79)

//
// KS categories from ks.h and ksmedia.h
//
//

// 65E8773D-8F56-11D0-A3B9-00A0C9223196
OUR_GUID_ENTRY(AM_KSCATEGORY_CAPTURE,
0x65E8773DL, 0x8F56, 0x11D0, 0xA3, 0xB9, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// 65E8773E-8F56-11D0-A3B9-00A0C9223196
OUR_GUID_ENTRY(AM_KSCATEGORY_RENDER,
0x65E8773EL, 0x8F56, 0x11D0, 0xA3, 0xB9, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// 1E84C900-7E70-11D0-A5D6-28DB04C10000
OUR_GUID_ENTRY(AM_KSCATEGORY_DATACOMPRESSOR,
0x1E84C900L, 0x7E70, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00)

// 6994AD04-93EF-11D0-A3CC-00A0C9223196
OUR_GUID_ENTRY(AM_KSCATEGORY_AUDIO,
0x6994AD04L, 0x93EF, 0x11D0, 0xA3, 0xCC, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// 6994AD05-93EF-11D0-A3CC-00A0C9223196
OUR_GUID_ENTRY(AM_KSCATEGORY_VIDEO,
0x6994AD05L, 0x93EF, 0x11D0, 0xA3, 0xCC, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// a799a800-a46d-11d0-a18c-00a02401dcd4
OUR_GUID_ENTRY(AM_KSCATEGORY_TVTUNER,
0xa799a800L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4)

// a799a801-a46d-11d0-a18c-00a02401dcd4
OUR_GUID_ENTRY(AM_KSCATEGORY_CROSSBAR,
0xa799a801L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4)

// a799a802-a46d-11d0-a18c-00a02401dcd4
OUR_GUID_ENTRY(AM_KSCATEGORY_TVAUDIO,
0xa799a802L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4)


// 07dad660L-22f1-11d1-a9f4-00c04fbbde8f
OUR_GUID_ENTRY(AM_KSCATEGORY_VBICODEC,
0x07dad660L, 0x22f1, 0x11d1, 0xa9, 0xf4, 0x00, 0xc0, 0x4f, 0xbb, 0xde, 0x8f)


// 0A4252A0L-7E70-11D0-A5D6-28DB04C10000
OUR_GUID_ENTRY(AM_KSCATEGORY_SPLITTER,
0x0A4252A0L, 0x7E70, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00)


//
// guids needed to support IKsPin interface
//

// d3abc7e0l-9a61-11d0-a40d00a0c9223196
OUR_GUID_ENTRY(IID_IKsInterfaceHandler,
0xD3ABC7E0L, 0x9A61, 0x11D0, 0xA4, 0x0D, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// 5ffbaa02l-49a3-11d0-9f3600aa00a216a1
OUR_GUID_ENTRY(IID_IKsDataTypeHandler,
0x5FFBAA02L, 0x49A3, 0x11D0, 0x9F, 0x36, 0x00, 0xAA, 0x00, 0xA2, 0x16, 0xA1)

// b61178d1-a2d9-11cf-9e53-00aa00a216a1
OUR_GUID_ENTRY(IID_IKsPin,
0xb61178d1L, 0xa2d9, 0x11cf, 0x9e, 0x53, 0x00, 0xaa, 0x00, 0xa2, 0x16, 0xa1)

// 28F54685-06FD-11D2-B27A-00A0C9223196
OUR_GUID_ENTRY(IID_IKsControl,
0x28F54685L, 0x06FD, 0x11D2, 0xB2, 0x7A, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// CD5EBE6B-8B6E-11D1-8AE0-00A0C9223196
OUR_GUID_ENTRY(IID_IKsPinFactory,
0xCD5EBE6BL, 0x8B6E, 0x11D1, 0x8A, 0xE0, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// 1A8766A0-62CE-11CF-A5D6-28DB04C10000
OUR_GUID_ENTRY(AM_INTERFACESETID_Standard,
0x1A8766A0L, 0x62CE, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\include\amvideo.h ===
//------------------------------------------------------------------------------
// File: AMVideo.h
//
// Desc: Video related definitions and interfaces for ActiveMovie.
//
// Copyright (c) 1992 - 2000, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __AMVIDEO__
#define __AMVIDEO__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include <ddraw.h>


// This is an interface on the video renderer that provides information about
// DirectDraw with respect to its use by the renderer. For example it allows
// an application to get details of the surface and any hardware capabilities
// that are available. It also allows someone to adjust the surfaces that the
// renderer should use and furthermore even set the DirectDraw instance. We
// allow someone to set the DirectDraw instance because DirectDraw can only
// be opened once per process so it helps resolve conflicts. There is some
// duplication in this interface as the hardware/emulated/FOURCCs available
// can all be found through the IDirectDraw interface, this interface allows
// simple access to that information without calling the DirectDraw provider
// itself. The AMDDS prefix is ActiveMovie DirectDraw Switches abbreviated.

#define AMDDS_NONE 0x00             // No use for DCI/DirectDraw
#define AMDDS_DCIPS 0x01            // Use DCI primary surface
#define AMDDS_PS 0x02               // Use DirectDraw primary
#define AMDDS_RGBOVR 0x04           // RGB overlay surfaces
#define AMDDS_YUVOVR 0x08           // YUV overlay surfaces
#define AMDDS_RGBOFF 0x10           // RGB offscreen surfaces
#define AMDDS_YUVOFF 0x20           // YUV offscreen surfaces
#define AMDDS_RGBFLP 0x40           // RGB flipping surfaces
#define AMDDS_YUVFLP 0x80           // YUV flipping surfaces
#define AMDDS_ALL 0xFF              // ALL the previous flags
#define AMDDS_DEFAULT AMDDS_ALL     // Use all available surfaces

#define AMDDS_YUV (AMDDS_YUVOFF | AMDDS_YUVOVR | AMDDS_YUVFLP)
#define AMDDS_RGB (AMDDS_RGBOFF | AMDDS_RGBOVR | AMDDS_RGBFLP)
#define AMDDS_PRIMARY (AMDDS_DCIPS | AMDDS_PS)

// be nice to our friends in C
#undef INTERFACE
#define INTERFACE IDirectDrawVideo

DECLARE_INTERFACE_(IDirectDrawVideo, IUnknown)
{
    // IUnknown methods

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IDirectDrawVideo methods

    STDMETHOD(GetSwitches)(THIS_ DWORD *pSwitches) PURE;
    STDMETHOD(SetSwitches)(THIS_ DWORD Switches) PURE;
    STDMETHOD(GetCaps)(THIS_ DDCAPS *pCaps) PURE;
    STDMETHOD(GetEmulatedCaps)(THIS_ DDCAPS *pCaps) PURE;
    STDMETHOD(GetSurfaceDesc)(THIS_ DDSURFACEDESC *pSurfaceDesc) PURE;
    STDMETHOD(GetFourCCCodes)(THIS_ DWORD *pCount,DWORD *pCodes) PURE;
    STDMETHOD(SetDirectDraw)(THIS_ LPDIRECTDRAW pDirectDraw) PURE;
    STDMETHOD(GetDirectDraw)(THIS_ LPDIRECTDRAW *ppDirectDraw) PURE;
    STDMETHOD(GetSurfaceType)(THIS_ DWORD *pSurfaceType) PURE;
    STDMETHOD(SetDefault)(THIS) PURE;
    STDMETHOD(UseScanLine)(THIS_ long UseScanLine) PURE;
    STDMETHOD(CanUseScanLine)(THIS_ long *UseScanLine) PURE;
    STDMETHOD(UseOverlayStretch)(THIS_ long UseOverlayStretch) PURE;
    STDMETHOD(CanUseOverlayStretch)(THIS_ long *UseOverlayStretch) PURE;
    STDMETHOD(UseWhenFullScreen)(THIS_ long UseWhenFullScreen) PURE;
    STDMETHOD(WillUseFullScreen)(THIS_ long *UseWhenFullScreen) PURE;
};


// be nice to our friends in C
#undef INTERFACE
#define INTERFACE IQualProp

DECLARE_INTERFACE_(IQualProp, IUnknown)
{
    // IUnknown methods

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // Compare these with the functions in class CGargle in gargle.h

    STDMETHOD(get_FramesDroppedInRenderer)(THIS_ int *pcFrames) PURE;  // Out
    STDMETHOD(get_FramesDrawn)(THIS_ int *pcFramesDrawn) PURE;         // Out
    STDMETHOD(get_AvgFrameRate)(THIS_ int *piAvgFrameRate) PURE;       // Out
    STDMETHOD(get_Jitter)(THIS_ int *iJitter) PURE;                    // Out
    STDMETHOD(get_AvgSyncOffset)(THIS_ int *piAvg) PURE;               // Out
    STDMETHOD(get_DevSyncOffset)(THIS_ int *piDev) PURE;               // Out
};


// This interface allows an application or plug in distributor to control a
// full screen renderer. The Modex renderer supports this interface. When
// connected a renderer should load the display modes it has available
// The number of modes available can be obtained through CountModes. Then
// information on each individual mode is available by calling GetModeInfo
// and IsModeAvailable. An application may enable and disable any modes
// by calling the SetEnabled flag with OATRUE or OAFALSE (not C/C++ TRUE
// and FALSE values) - the current value may be queried by IsModeEnabled

// A more generic way of setting the modes enabled that is easier to use
// when writing applications is the clip loss factor. This defines the
// amount of video that can be lost when deciding which display mode to
// use. Assuming the decoder cannot compress the video then playing an
// MPEG file (say 352x288) into a 320x200 display will lose about 25% of
// the image. The clip loss factor specifies the upper range permissible.
// To allow typical MPEG video to be played in 320x200 it defaults to 25%

// be nice to our friends in C
#undef INTERFACE
#define INTERFACE IFullScreenVideo

DECLARE_INTERFACE_(IFullScreenVideo, IUnknown)
{
    // IUnknown methods

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IFullScreenVideo methods

    STDMETHOD(CountModes)(THIS_ long *pModes) PURE;
    STDMETHOD(GetModeInfo)(THIS_ long Mode,long *pWidth,long *pHeight,long *pDepth) PURE;
    STDMETHOD(GetCurrentMode)(THIS_ long *pMode) PURE;
    STDMETHOD(IsModeAvailable)(THIS_ long Mode) PURE;
    STDMETHOD(IsModeEnabled)(THIS_ long Mode) PURE;
    STDMETHOD(SetEnabled)(THIS_ long Mode,long bEnabled) PURE;
    STDMETHOD(GetClipFactor)(THIS_ long *pClipFactor) PURE;
    STDMETHOD(SetClipFactor)(THIS_ long ClipFactor) PURE;
    STDMETHOD(SetMessageDrain)(THIS_ HWND hwnd) PURE;
    STDMETHOD(GetMessageDrain)(THIS_ HWND *hwnd) PURE;
    STDMETHOD(SetMonitor)(THIS_ long Monitor) PURE;
    STDMETHOD(GetMonitor)(THIS_ long *Monitor) PURE;
    STDMETHOD(HideOnDeactivate)(THIS_ long Hide) PURE;
    STDMETHOD(IsHideOnDeactivate)(THIS) PURE;
    STDMETHOD(SetCaption)(THIS_ BSTR strCaption) PURE;
    STDMETHOD(GetCaption)(THIS_ BSTR *pstrCaption) PURE;
    STDMETHOD(SetDefault)(THIS) PURE;
};


// This adds the accelerator table capabilities in fullscreen. This is being
// added between the original runtime release and the full SDK release. We
// cannot just add the method to IFullScreenVideo as we don't want to force
// applications to have to ship the ActiveMovie support DLLs - this is very
// important to applications that plan on being downloaded over the Internet

// be nice to our friends in C
#undef INTERFACE
#define INTERFACE IFullScreenVideoEx

DECLARE_INTERFACE_(IFullScreenVideoEx, IFullScreenVideo)
{
    // IUnknown methods

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IFullScreenVideo methods

    STDMETHOD(CountModes)(THIS_ long *pModes) PURE;
    STDMETHOD(GetModeInfo)(THIS_ long Mode,long *pWidth,long *pHeight,long *pDepth) PURE;
    STDMETHOD(GetCurrentMode)(THIS_ long *pMode) PURE;
    STDMETHOD(IsModeAvailable)(THIS_ long Mode) PURE;
    STDMETHOD(IsModeEnabled)(THIS_ long Mode) PURE;
    STDMETHOD(SetEnabled)(THIS_ long Mode,long bEnabled) PURE;
    STDMETHOD(GetClipFactor)(THIS_ long *pClipFactor) PURE;
    STDMETHOD(SetClipFactor)(THIS_ long ClipFactor) PURE;
    STDMETHOD(SetMessageDrain)(THIS_ HWND hwnd) PURE;
    STDMETHOD(GetMessageDrain)(THIS_ HWND *hwnd) PURE;
    STDMETHOD(SetMonitor)(THIS_ long Monitor) PURE;
    STDMETHOD(GetMonitor)(THIS_ long *Monitor) PURE;
    STDMETHOD(HideOnDeactivate)(THIS_ long Hide) PURE;
    STDMETHOD(IsHideOnDeactivate)(THIS) PURE;
    STDMETHOD(SetCaption)(THIS_ BSTR strCaption) PURE;
    STDMETHOD(GetCaption)(THIS_ BSTR *pstrCaption) PURE;
    STDMETHOD(SetDefault)(THIS) PURE;

    // IFullScreenVideoEx

    STDMETHOD(SetAcceleratorTable)(THIS_ HWND hwnd,HACCEL hAccel) PURE;
    STDMETHOD(GetAcceleratorTable)(THIS_ HWND *phwnd,HACCEL *phAccel) PURE;
    STDMETHOD(KeepPixelAspectRatio)(THIS_ long KeepAspect) PURE;
    STDMETHOD(IsKeepPixelAspectRatio)(THIS_ long *pKeepAspect) PURE;
};


// The SDK base classes contain a base video mixer class. Video mixing in a
// software environment is tricky because we typically have multiple streams
// each sending data at unpredictable times. To work with this we defined a
// pin that is the lead pin, when data arrives on this pin we do a mix. As
// an alternative we may not want to have a lead pin but output samples at
// predefined spaces, like one every 1/15 of a second, this interfaces also
// supports that mode of operations (there is a working video mixer sample)

// be nice to our friends in C
#undef INTERFACE
#define INTERFACE IBaseVideoMixer

DECLARE_INTERFACE_(IBaseVideoMixer, IUnknown)
{
    STDMETHOD(SetLeadPin)(THIS_ int iPin) PURE;
    STDMETHOD(GetLeadPin)(THIS_ int *piPin) PURE;
    STDMETHOD(GetInputPinCount)(THIS_ int *piPinCount) PURE;
    STDMETHOD(IsUsingClock)(THIS_ int *pbValue) PURE;
    STDMETHOD(SetUsingClock)(THIS_ int bValue) PURE;
    STDMETHOD(GetClockPeriod)(THIS_ int *pbValue) PURE;
    STDMETHOD(SetClockPeriod)(THIS_ int bValue) PURE;
};

#define iPALETTE_COLORS 256     // Maximum colours in palette
#define iEGA_COLORS 16          // Number colours in EGA palette
#define iMASK_COLORS 3          // Maximum three components
#define iTRUECOLOR 16           // Minimum true colour device
#define iRED 0                  // Index position for RED mask
#define iGREEN 1                // Index position for GREEN mask
#define iBLUE 2                 // Index position for BLUE mask
#define iPALETTE 8              // Maximum colour depth using a palette
#define iMAXBITS 8              // Maximum bits per colour component


// Used for true colour images that also have a palette

typedef struct tag_TRUECOLORINFO {
    DWORD   dwBitMasks[iMASK_COLORS];
    RGBQUAD bmiColors[iPALETTE_COLORS];
} TRUECOLORINFO;


// The BITMAPINFOHEADER contains all the details about the video stream such
// as the actual image dimensions and their pixel depth. A source filter may
// also request that the sink take only a section of the video by providing a
// clipping rectangle in rcSource. In the worst case where the sink filter
// forgets to check this on connection it will simply render the whole thing
// which isn't a disaster. Ideally a sink filter will check the rcSource and
// if it doesn't support image extraction and the rectangle is not empty then
// it will reject the connection. A filter should use SetRectEmpty to reset a
// rectangle to all zeroes (and IsRectEmpty to later check the rectangle).
// The rcTarget specifies the destination rectangle for the video, for most
// source filters they will set this to all zeroes, a downstream filter may
// request that the video be placed in a particular area of the buffers it
// supplies in which case it will call QueryAccept with a non empty target

typedef struct tagVIDEOINFOHEADER {

    RECT            rcSource;          // The bit we really want to use
    RECT            rcTarget;          // Where the video should go
    DWORD           dwBitRate;         // Approximate bit data rate
    DWORD           dwBitErrorRate;    // Bit error rate for this stream
    REFERENCE_TIME  AvgTimePerFrame;   // Average time per frame (100ns units)

    BITMAPINFOHEADER bmiHeader;

} VIDEOINFOHEADER;

// make sure the pbmi is initialized before using these macros
#define TRUECOLOR(pbmi)  ((TRUECOLORINFO *)(((LPBYTE)&((pbmi)->bmiHeader)) \
					+ (pbmi)->bmiHeader.biSize))
#define COLORS(pbmi)	((RGBQUAD *)(((LPBYTE)&((pbmi)->bmiHeader)) 	\
					+ (pbmi)->bmiHeader.biSize))
#define BITMASKS(pbmi)	((DWORD *)(((LPBYTE)&((pbmi)->bmiHeader)) 	\
					+ (pbmi)->bmiHeader.biSize))

// All the image based filters use this to communicate their media types. It's
// centred principally around the BITMAPINFO. This structure always contains a
// BITMAPINFOHEADER followed by a number of other fields depending on what the
// BITMAPINFOHEADER contains. If it contains details of a palettised format it
// will be followed by one or more RGBQUADs defining the palette. If it holds
// details of a true colour format then it may be followed by a set of three
// DWORD bit masks that specify where the RGB data can be found in the image
// (For more information regarding BITMAPINFOs see the Win32 documentation)

// The rcSource and rcTarget fields are not for use by filters supplying the
// data. The destination (target) rectangle should be set to all zeroes. The
// source may also be zero filled or set with the dimensions of the video. So
// if the video is 352x288 pixels then set it to (0,0,352,288). These fields
// are mainly used by downstream filters that want to ask the source filter
// to place the image in a different position in an output buffer. So when
// using for example the primary surface the video renderer may ask a filter
// to place the video images in a destination position of (100,100,452,388)
// on the display since that's where the window is positioned on the display

// !!! WARNING !!!
// DO NOT use this structure unless you are sure that the BITMAPINFOHEADER
// has a normal biSize == sizeof(BITMAPINFOHEADER) !
// !!! WARNING !!!

typedef struct tagVIDEOINFO {

    RECT            rcSource;          // The bit we really want to use
    RECT            rcTarget;          // Where the video should go
    DWORD           dwBitRate;         // Approximate bit data rate
    DWORD           dwBitErrorRate;    // Bit error rate for this stream
    REFERENCE_TIME  AvgTimePerFrame;   // Average time per frame (100ns units)

    BITMAPINFOHEADER bmiHeader;

    union {
        RGBQUAD         bmiColors[iPALETTE_COLORS];     // Colour palette
        DWORD           dwBitMasks[iMASK_COLORS];       // True colour masks
        TRUECOLORINFO   TrueColorInfo;                  // Both of the above
    };

} VIDEOINFO;

// These macros define some standard bitmap format sizes

#define SIZE_EGA_PALETTE (iEGA_COLORS * sizeof(RGBQUAD))
#define SIZE_PALETTE (iPALETTE_COLORS * sizeof(RGBQUAD))
#define SIZE_MASKS (iMASK_COLORS * sizeof(DWORD))
#define SIZE_PREHEADER (FIELD_OFFSET(VIDEOINFOHEADER,bmiHeader))
#define SIZE_VIDEOHEADER (sizeof(BITMAPINFOHEADER) + SIZE_PREHEADER)
// !!! for abnormal biSizes
// #define SIZE_VIDEOHEADER(pbmi) ((pbmi)->bmiHeader.biSize + SIZE_PREHEADER)

// DIBSIZE calculates the number of bytes required by an image

#define WIDTHBYTES(bits) ((DWORD)(((bits)+31) & (~31)) / 8)
#define DIBWIDTHBYTES(bi) (DWORD)WIDTHBYTES((DWORD)(bi).biWidth * (DWORD)(bi).biBitCount)
#define _DIBSIZE(bi) (DIBWIDTHBYTES(bi) * (DWORD)(bi).biHeight)
#define DIBSIZE(bi) ((bi).biHeight < 0 ? (-1)*(_DIBSIZE(bi)) : _DIBSIZE(bi))

// This compares the bit masks between two VIDEOINFOHEADERs

#define BIT_MASKS_MATCH(pbmi1,pbmi2)                                \
    (((pbmi1)->dwBitMasks[iRED] == (pbmi2)->dwBitMasks[iRED]) &&        \
     ((pbmi1)->dwBitMasks[iGREEN] == (pbmi2)->dwBitMasks[iGREEN]) &&    \
     ((pbmi1)->dwBitMasks[iBLUE] == (pbmi2)->dwBitMasks[iBLUE]))

// These zero fill different parts of the VIDEOINFOHEADER structure

// Only use these macros for pbmi's with a normal BITMAPINFOHEADER biSize
#define RESET_MASKS(pbmi) (ZeroMemory((PVOID)(pbmi)->dwBitFields,SIZE_MASKS))
#define RESET_HEADER(pbmi) (ZeroMemory((PVOID)(pbmi),SIZE_VIDEOHEADER))
#define RESET_PALETTE(pbmi) (ZeroMemory((PVOID)(pbmi)->bmiColors,SIZE_PALETTE));

#if 0
// !!! This is the right way to do it, but may break existing code
#define RESET_MASKS(pbmi) (ZeroMemory((PVOID)(((LPBYTE)(pbmi)->bmiHeader) + \
			(pbmi)->bmiHeader.biSize,SIZE_MASKS)))
#define RESET_HEADER(pbmi) (ZeroMemory((PVOID)(pbmi), SIZE_PREHEADER +	    \
			sizeof(BITMAPINFOHEADER)))
#define RESET_PALETTE(pbmi) (ZeroMemory((PVOID)(((LPBYTE)(pbmi)->bmiHeader) + \
			(pbmi)->bmiHeader.biSize,SIZE_PALETTE))
#endif

// Other (hopefully) useful bits and bobs

#define PALETTISED(pbmi) ((pbmi)->bmiHeader.biBitCount <= iPALETTE)
#define PALETTE_ENTRIES(pbmi) ((DWORD) 1 << (pbmi)->bmiHeader.biBitCount)

// Returns the address of the BITMAPINFOHEADER from the VIDEOINFOHEADER
#define HEADER(pVideoInfo) (&(((VIDEOINFOHEADER *) (pVideoInfo))->bmiHeader))


// MPEG variant - includes a DWORD length followed by the
// video sequence header after the video header.
//
// The sequence header includes the sequence header start code and the
// quantization matrices associated with the first sequence header in the
// stream so is a maximum of 140 bytes long.

typedef struct tagMPEG1VIDEOINFO {

    VIDEOINFOHEADER hdr;                    // Compatible with VIDEOINFO
    DWORD           dwStartTimeCode;        // 25-bit Group of pictures time code
                                            // at start of data
    DWORD           cbSequenceHeader;       // Length in bytes of bSequenceHeader
    BYTE            bSequenceHeader[1];     // Sequence header including
                                            // quantization matrices if any
} MPEG1VIDEOINFO;

#define MAX_SIZE_MPEG1_SEQUENCE_INFO 140
#define SIZE_MPEG1VIDEOINFO(pv) (FIELD_OFFSET(MPEG1VIDEOINFO, bSequenceHeader[0]) + (pv)->cbSequenceHeader)
#define MPEG1_SEQUENCE_INFO(pv) ((const BYTE *)(pv)->bSequenceHeader)


// Analog video variant - Use this when the format is FORMAT_AnalogVideo
//
// rcSource defines the portion of the active video signal to use
// rcTarget defines the destination rectangle
//    both of the above are relative to the dwActiveWidth and dwActiveHeight fields
// dwActiveWidth is currently set to 720 for all formats (but could change for HDTV)
// dwActiveHeight is 483 for NTSC and 575 for PAL/SECAM  (but could change for HDTV)

typedef struct tagAnalogVideoInfo {
    RECT            rcSource;           // Width max is 720, height varies w/ TransmissionStd
    RECT            rcTarget;           // Where the video should go
    DWORD           dwActiveWidth;      // Always 720 (CCIR-601 active samples per line)
    DWORD           dwActiveHeight;     // 483 for NTSC, 575 for PAL/SECAM
    REFERENCE_TIME  AvgTimePerFrame;    // Normal ActiveMovie units (100 nS)
} ANALOGVIDEOINFO;

//
// AM_KSPROPSETID_FrameStep property set definitions
//
typedef enum {
        //  Step
	AM_PROPERTY_FRAMESTEP_STEP   = 0x01,
	AM_PROPERTY_FRAMESTEP_CANCEL = 0x02,

        //  S_OK for these 2 means we can - S_FALSE if we can't
        AM_PROPERTY_FRAMESTEP_CANSTEP = 0x03,
        AM_PROPERTY_FRAMESTEP_CANSTEPMULTIPLE = 0x04
} AM_PROPERTY_FRAMESTEP;

typedef struct _AM_FRAMESTEP_STEP
{
    //  1 means step 1 frame forward
    //  0 is invalid
    //  n (n > 1) means skip n - 1 frames and show the nth
    DWORD dwFramesToStep;
} AM_FRAMESTEP_STEP;

#ifdef __cplusplus
}
#endif // __cplusplus
#endif // __AMVIDEO__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\include\bdamedia.h ===
//------------------------------------------------------------------------------
// File: BDAMedia.h
//
// Desc: Broadcast Driver Architecture Multimedia Definitions.
//
// Copyright (c) 1996 - 2000, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#if !defined(_KSMEDIA_)
#error KSMEDIA.H must be included before BDAMEDIA.H
#endif // !defined(_KSMEDIA_)

#if !defined(_BDATYPES_)
#error BDATYPES.H must be included before BDAMEDIA.H
#endif // !defined(_BDATYPES_)

#if !defined(_BDAMEDIA_)
#define _BDAMEDIA_

#if defined(__cplusplus)
extern "C" {
#endif // defined(__cplusplus)



//===========================================================================
//
//  KSProperty Set Structure Definitions for BDA
//
//===========================================================================

typedef struct _KSP_BDA_NODE_PIN {
    KSPROPERTY      Property;
    ULONG           ulNodeType;
    ULONG           ulInputPinId;
    ULONG           ulOutputPinId;
} KSP_BDA_NODE_PIN, *PKSP_BDA_NODE_PIN;


typedef struct _KSM_BDA_PIN
{
    KSMETHOD    Method;
    union
    {
        ULONG       PinId;
        ULONG       PinType;
    };
    ULONG       Reserved;
} KSM_BDA_PIN, * PKSM_BDA_PIN;


typedef struct _KSM_BDA_PIN_PAIR
{
    KSMETHOD    Method;
    union
    {
        ULONG       InputPinId;
        ULONG       InputPinType;
    };
    union
    {
        ULONG       OutputPinId;
        ULONG       OutputPinType;
    };
} KSM_BDA_PIN_PAIR, * PKSM_BDA_PIN_PAIR;


typedef struct {
    KSP_NODE        Property;
    ULONG           EsPid;
} KSP_NODE_ESPID, *PKSP_NODE_ESPID;



//===========================================================================
//
//  BDA Data Range definitions.  Includes specifier definitions.
//
//===========================================================================

//  Antenna Signal Formats
//

typedef struct tagKS_DATARANGE_BDA_ANTENNA {
   KSDATARANGE                  DataRange;

   //   Antenna specifier can go here if required
   //
} KS_DATARANGE_BDA_ANTENNA, *PKS_DATARANGE_BDA_ANTENNA;



//  Transport Formats
//

typedef struct tagBDA_TRANSPORT_INFO {
    ULONG           ulcbPhyiscalPacket; // Size, in bytes, of a physical packet
                                        // (e.g. Satellite link payload size.
    ULONG           ulcbPhyiscalFrame;  // Size, in bytes, of each physical frame
                                        // 0 indicates no HW requirement
    ULONG           ulcbPhyiscalFrameAlignment; // Capture buffer alignment in bytes
                                                // 0 and 1 indicate no alignment requirements
    REFERENCE_TIME  AvgTimePerFrame; // Normal ActiveMovie units (100 nS)

} BDA_TRANSPORT_INFO, *PBDA_TRANSPORT_INFO;

typedef struct tagKS_DATARANGE_BDA_TRANSPORT {
   KSDATARANGE                  DataRange;
   BDA_TRANSPORT_INFO           BdaTransportInfo;

   //   Transport specifier can go here if required
   //
} KS_DATARANGE_BDA_TRANSPORT, *PKS_DATARANGE_BDA_TRANSPORT;


//===========================================================================
//  BDA Event Guids
//
//      These are sent by the IBroadcastEvent service on the graph.
//      To receive,
//          0) Implement IBroadcastEvent in your receiving object - this has one Method on it: Fire() 
//          1) QI the graphs service provider for SID_SBroadcastEventService
//                 for the IID_IBroadcastEvent object
//          2) OR create the event service (CLSID_BroadcastEventService) if not already there
//                 and register it
//          3) QI that object for it's IConnectionPoint interface (*pCP)
//          4) Advise your object on *pCP  (e.g. pCP->Advise(static_cast<IBroadCastEvent*>(this), &dwCookie)
//          5) Unadvise when done..
//          6) Implement IBroadcastEvent::Fire(GUID gEventID)
//             Check for relevant event below and deal with it appropriatly...
//===========================================================================

// {9D7E6235-4B7D-425d-A6D1-D717C33B9C4C}
#define STATIC_EVENTID_TuningChanged \
    0x9d7e6235, 0x4b7d, 0x425d, 0xa6, 0xd1, 0xd7, 0x17, 0xc3, 0x3b, 0x9c, 0x4c
DEFINE_GUIDSTRUCT("9D7E6235-4B7D-425d-A6D1-D717C33B9C4C", EVENTID_TuningChanged);
#define EVENTID_TuningChanged DEFINE_GUIDNAMED(EVENTID_TuningChanged)

// {2A65C528-2249-4070-AC16-00390CDFB2DD}
#define STATIC_EVENTID_CADenialCountChanged \
    0x2a65c528, 0x2249, 0x4070, 0xac, 0x16, 0x0, 0x39, 0xc, 0xdf, 0xb2, 0xdd
DEFINE_GUIDSTRUCT("2A65C528-2249-4070-AC16-00390CDFB2DD", EVENTID_CADenialCountChanged);
#define EVENTID_CADenialCountChanged DEFINE_GUIDNAMED(EVENTID_CADenialCountChanged)

// {6D9CFAF2-702D-4b01-8DFF-6892AD20D191}
#define STATIC_EVENTID_SignalStatusChanged \
    0x6d9cfaf2, 0x702d, 0x4b01, 0x8d, 0xff, 0x68, 0x92, 0xad, 0x20, 0xd1, 0x91
DEFINE_GUIDSTRUCT("6D9CFAF2-702D-4b01-8DFF-6892AD20D191", EVENTID_SignalStatusChanged);
#define EVENTID_SignalStatusChanged DEFINE_GUIDNAMED(EVENTID_SignalStatusChanged)

//===========================================================================
//
//  BDA Stream Format GUIDs
//
//===========================================================================

#define STATIC_KSDATAFORMAT_TYPE_BDA_ANTENNA\
    0x71985f41, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F41-1CA1-11d3-9CC8-00C04F7971E0", KSDATAFORMAT_TYPE_BDA_ANTENNA);
#define KSDATAFORMAT_TYPE_BDA_ANTENNA DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_BDA_ANTENNA)


#define STATIC_KSDATAFORMAT_SUBTYPE_BDA_MPEG2_TRANSPORT\
    0xf4aeb342, 0x0329, 0x4fdd, 0xa8, 0xfd, 0x4a, 0xff, 0x49, 0x26, 0xc9, 0x78
DEFINE_GUIDSTRUCT("F4AEB342-0329-4fdd-A8FD-4AFF4926C978", KSDATAFORMAT_SUBTYPE_BDA_MPEG2_TRANSPORT);
#define KSDATAFORMAT_SUBTYPE_BDA_MPEG2_TRANSPORT DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_BDA_MPEG2_TRANSPORT)


#define STATIC_KSDATAFORMAT_SPECIFIER_BDA_TRANSPORT\
    0x8deda6fd, 0xac5f, 0x4334, 0x8e, 0xcf, 0xa4, 0xba, 0x8f, 0xa7, 0xd0, 0xf0
DEFINE_GUIDSTRUCT("8DEDA6FD-AC5F-4334-8ECF-A4BA8FA7D0F0", KSDATAFORMAT_SPECIFIER_BDA_TRANSPORT);
#define KSDATAFORMAT_SPECIFIER_BDA_TRANSPORT DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_BDA_TRANSPORT)


#define STATIC_KSDATAFORMAT_TYPE_BDA_IF_SIGNAL\
    0x61be0b47, 0xa5eb, 0x499b, 0x9a, 0x85, 0x5b, 0x16, 0xc0, 0x7f, 0x12, 0x58
DEFINE_GUIDSTRUCT("61BE0B47-A5EB-499b-9A85-5B16C07F1258", KSDATAFORMAT_TYPE_BDA_IF_SIGNAL);
#define KSDATAFORMAT_TYPE_BDA_IF_SIGNAL DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_BDA_IF_SIGNAL)


#define STATIC_KSDATAFORMAT_TYPE_MPEG2_SECTIONS\
    0x455f176c, 0x4b06, 0x47ce, 0x9a, 0xef, 0x8c, 0xae, 0xf7, 0x3d, 0xf7, 0xb5
DEFINE_GUIDSTRUCT("455F176C-4B06-47CE-9AEF-8CAEF73DF7B5", KSDATAFORMAT_TYPE_MPEG2_SECTIONS);
#define KSDATAFORMAT_TYPE_MPEG2_SECTIONS DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_MPEG2_SECTIONS)


#define STATIC_KSDATAFORMAT_SUBTYPE_ATSC_SI\
    0xb3c7397c, 0xd303, 0x414d, 0xb3, 0x3c, 0x4e, 0xd2, 0xc9, 0xd2, 0x97, 0x33
DEFINE_GUIDSTRUCT("B3C7397C-D303-414D-B33C-4ED2C9D29733", KSDATAFORMAT_SUBTYPE_ATSC_SI);
#define KSDATAFORMAT_SUBTYPE_ATSC_SI DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_ATSC_SI)


#define STATIC_KSDATAFORMAT_SUBTYPE_DVB_SI\
    0xe9dd31a3, 0x221d, 0x4adb, 0x85, 0x32, 0x9a, 0xf3, 0x9, 0xc1, 0xa4, 0x8
DEFINE_GUIDSTRUCT("e9dd31a3-221d-4adb-8532-9af309c1a408", KSDATAFORMAT_SUBTYPE_DVB_SI);
#define KSDATAFORMAT_SUBTYPE_DVB_SI DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_DVB_SI)


#define STATIC_KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_PSIP\
    0x762e3f66, 0x336f, 0x48d1, 0xbf, 0x83, 0x2b, 0x0, 0x35, 0x2c, 0x11, 0xf0
DEFINE_GUIDSTRUCT("762E3F66-336F-48d1-BF83-2B00352C11F0", KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_PSIP);
#define KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_PSIP DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_PSIP)

#define STATIC_KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_OOB_PSIP\
    0x951727db, 0xd2ce, 0x4528, 0x96, 0xf6, 0x33, 0x1, 0xfa, 0xbb, 0x2d, 0xe0
DEFINE_GUIDSTRUCT("951727DB-D2CE-4528-96F6-3301FABB2DE0", KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_OOB_PSIP);
#define KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_OOB_PSIP DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_OOB_PSIP)

//===========================================================================
//
//  KSPinName Definitions for BDA
//
//===========================================================================

//  Pin name for a BDA transport pin
//
// {78216A81-CFA8-493e-9711-36A61C08BD9D}
//
#define STATIC_PINNAME_BDA_TRANSPORT \
    0x78216a81, 0xcfa8, 0x493e, 0x97, 0x11, 0x36, 0xa6, 0x1c, 0x8, 0xbd, 0x9d
DEFINE_GUIDSTRUCT("78216A81-CFA8-493e-9711-36A61C08BD9D", PINNAME_BDA_TRANSPORT);
#define PINNAME_BDA_TRANSPORT DEFINE_GUIDNAMED(PINNAME_BDA_TRANSPORT)


//  Pin name for a BDA analog video pin
//
// {5C0C8281-5667-486c-8482-63E31F01A6E9}
//
#define STATIC_PINNAME_BDA_ANALOG_VIDEO \
    0x5c0c8281, 0x5667, 0x486c, 0x84, 0x82, 0x63, 0xe3, 0x1f, 0x1, 0xa6, 0xe9
DEFINE_GUIDSTRUCT("5C0C8281-5667-486c-8482-63E31F01A6E9", PINNAME_BDA_ANALOG_VIDEO);
#define PINNAME_BDA_ANALOG_VIDEO DEFINE_GUIDNAMED(PINNAME_BDA_ANALOG_VIDEO)


//  Pin name for a BDA analog audio pin
//
// {D28A580A-9B1F-4b0c-9C33-9BF0A8EA636B}
//
#define STATIC_PINNAME_BDA_ANALOG_AUDIO \
    0xd28a580a, 0x9b1f, 0x4b0c, 0x9c, 0x33, 0x9b, 0xf0, 0xa8, 0xea, 0x63, 0x6b
DEFINE_GUIDSTRUCT("D28A580A-9B1F-4b0c-9C33-9BF0A8EA636B", PINNAME_BDA_ANALOG_AUDIO);
#define PINNAME_BDA_ANALOG_AUDIO DEFINE_GUIDNAMED(PINNAME_BDA_ANALOG_AUDIO)


//  Pin name for a BDA FM Radio pin
//
// {D2855FED-B2D3-4eeb-9BD0-193436A2F890}
//
#define STATIC_PINNAME_BDA_FM_RADIO \
    0xd2855fed, 0xb2d3, 0x4eeb, 0x9b, 0xd0, 0x19, 0x34, 0x36, 0xa2, 0xf8, 0x90
DEFINE_GUIDSTRUCT("D2855FED-B2D3-4eeb-9BD0-193436A2F890", PINNAME_BDA_FM_RADIO);
#define PINNAME_BDA_FM_RADIO DEFINE_GUIDNAMED(PINNAME_BDA_FM_RADIO)


//  Pin name for a BDA Intermediate Frequency pin
//
// {1A9D4A42-F3CD-48a1-9AEA-71DE133CBE14}
//
#define STATIC_PINNAME_BDA_IF_PIN \
    0x1a9d4a42, 0xf3cd, 0x48a1, 0x9a, 0xea, 0x71, 0xde, 0x13, 0x3c, 0xbe, 0x14
DEFINE_GUIDSTRUCT("1A9D4A42-F3CD-48a1-9AEA-71DE133CBE14", PINNAME_BDA_IF_PIN);
#define PINNAME_BDA_IF_PIN DEFINE_GUIDNAMED(PINNAME_BDA_IF_PIN)


//  Pin name for a BDA Open Cable PSIP pin
//
// {297BB104-E5C9-4ACE-B123-95C3CBB24D4F}
//
#define STATIC_PINNAME_BDA_OPENCABLE_PSIP_PIN \
    0x297bb104, 0xe5c9, 0x4ace, 0xb1, 0x23, 0x95, 0xc3, 0xcb, 0xb2, 0x4d, 0x4f
DEFINE_GUIDSTRUCT("297BB104-E5C9-4ACE-B123-95C3CBB24D4F", PINNAME_BDA_OPENCABLE_PSIP_PIN);
#define PINNAME_BDA_OPENCABLE_PSIP_PIN DEFINE_GUIDNAMED(PINNAME_BDA_OPENCABLE_PSIP_PIN)


//===========================================================================
//
//  KSProperty Set Definitions for BDA
//
//===========================================================================


//------------------------------------------------------------
//
//  BDA Network Ethernet Filter Property Set
//
// {71985F43-1CA1-11d3-9CC8-00C04F7971E0}
//
#define STATIC_KSPROPSETID_BdaEthernetFilter \
    0x71985f43, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F43-1CA1-11d3-9CC8-00C04F7971E0", KSPROPSETID_BdaEthernetFilter);
#define KSPROPSETID_BdaEthernetFilter DEFINE_GUIDNAMED(KSPROPSETID_BdaEthernetFilter)

typedef enum {
    KSPROPERTY_BDA_ETHERNET_FILTER_MULTICAST_LIST_SIZE = 0,
    KSPROPERTY_BDA_ETHERNET_FILTER_MULTICAST_LIST,
    KSPROPERTY_BDA_ETHERNET_FILTER_MULTICAST_MODE
} KSPROPERTY_BDA_ETHERNET_FILTER;

#define DEFINE_KSPROPERTY_ITEM_BDA_ETHERNET_FILTER_MULTICAST_LIST_SIZE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_ETHERNET_FILTER_MULTICAST_LIST_SIZE,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(ULONG),\
        FALSE,\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_ETHERNET_FILTER_MULTICAST_LIST(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_ETHERNET_FILTER_MULTICAST_LIST,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(BDA_ETHERNET_ADDRESS_LIST),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_ETHERNET_FILTER_MULTICAST_MODE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_ETHERNET_FILTER_MULTICAST_MODE,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(BDA_MULTICAST_MODE),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)



//------------------------------------------------------------
//
//  BDA Network IPv4 Filter Property Set
//
// {71985F44-1CA1-11d3-9CC8-00C04F7971E0}
//
#define STATIC_KSPROPSETID_BdaIPv4Filter \
    0x71985f44, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F44-1CA1-11d3-9CC8-00C04F7971E0", KSPROPSETID_BdaIPv4Filter);
#define KSPROPSETID_BdaIPv4Filter DEFINE_GUIDNAMED(KSPROPSETID_BdaIPv4Filter)

typedef enum {
    KSPROPERTY_BDA_IPv4_FILTER_MULTICAST_LIST_SIZE = 0,
    KSPROPERTY_BDA_IPv4_FILTER_MULTICAST_LIST,
    KSPROPERTY_BDA_IPv4_FILTER_MULTICAST_MODE
} KSPROPERTY_BDA_IPv4_FILTER;

#define DEFINE_KSPROPERTY_ITEM_BDA_IPv4_FILTER_MULTICAST_LIST_SIZE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_IPv4_FILTER_MULTICAST_LIST_SIZE,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(ULONG),\
        FALSE,\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_IPv4_FILTER_MULTICAST_LIST(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_IPv4_FILTER_MULTICAST_LIST,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(BDA_IPv4_ADDRESS_LIST),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_IPv4_FILTER_MULTICAST_MODE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_IPv4_FILTER_MULTICAST_MODE,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(BDA_MULTICAST_MODE),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)



//------------------------------------------------------------
//
//  BDA Network IPv6 Filter Property Set
//
// {E1785A74-2A23-4fb3-9245-A8F88017EF33}
//
#define STATIC_KSPROPSETID_BdaIPv6Filter \
    0xe1785a74, 0x2a23, 0x4fb3, 0x92, 0x45, 0xa8, 0xf8, 0x80, 0x17, 0xef, 0x33
DEFINE_GUIDSTRUCT("E1785A74-2A23-4fb3-9245-A8F88017EF33", KSPROPSETID_BdaIPv6Filter);
#define KSPROPSETID_BdaIPv6Filter DEFINE_GUIDNAMED(KSPROPSETID_BdaIPv6Filter)

typedef enum {
    KSPROPERTY_BDA_IPv6_FILTER_MULTICAST_LIST_SIZE = 0,
    KSPROPERTY_BDA_IPv6_FILTER_MULTICAST_LIST,
    KSPROPERTY_BDA_IPv6_FILTER_MULTICAST_MODE
} KSPROPERTY_BDA_IPv6_FILTER;

#define DEFINE_KSPROPERTY_ITEM_BDA_IPv6_FILTER_MULTICAST_LIST_SIZE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_IPv6_FILTER_MULTICAST_LIST_SIZE,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(ULONG),\
        FALSE,\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_IPv6_FILTER_MULTICAST_LIST(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_IPv6_FILTER_MULTICAST_LIST,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(BDA_IPv6_ADDRESS_LIST),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_IPv6_FILTER_MULTICAST_MODE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_IPv6_FILTER_MULTICAST_MODE,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(BDA_MULTICAST_MODE),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)


//------------------------------------------------------------
//
//
//  BDA Signal Statistics Property Set
//
//  Used to get signal statistics from a control node or a pin.
//  Set NodeId == -1 to get properties from the pin.
//
//  {1347D106-CF3A-428a-A5CB-AC0D9A2A4338}
//
#define STATIC_KSPROPSETID_BdaSignalStats \
    0x1347d106, 0xcf3a, 0x428a, 0xa5, 0xcb, 0xac, 0xd, 0x9a, 0x2a, 0x43, 0x38
DEFINE_GUIDSTRUCT("1347D106-CF3A-428a-A5CB-AC0D9A2A4338", KSPROPSETID_BdaSignalStats);
#define KSPROPSETID_BdaSignalStats DEFINE_GUIDNAMED(KSPROPSETID_BdaSignalStats)

typedef enum {
    KSPROPERTY_BDA_SIGNAL_STRENGTH = 0,
    KSPROPERTY_BDA_SIGNAL_QUALITY,
    KSPROPERTY_BDA_SIGNAL_PRESENT,
    KSPROPERTY_BDA_SIGNAL_LOCKED,
    KSPROPERTY_BDA_SAMPLE_TIME
} KSPROPERTY_BDA_SIGNAL_STATS;

//  OPTIONAL
//  Carrier strength in mDb (1/1000 of a DB).
//
//  A strength of 0 is nominal strength as expected for the given
//  type of broadcast network.
//
//  Sub-nominal strengths are reported as positive mDb
//
//  Super-nominal strengths are reported as negative mDb
//
#define DEFINE_KSPROPERTY_ITEM_BDA_SIGNAL_STRENGTH(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_SIGNAL_STRENGTH,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(LONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

//  OPTIONAL
//  Amount of data successfully extracted from the signal as a percent.
//
//  Signal Quality is usually reported by the demodulation node and is
//  a representation of how much of the original data could be extracted
//  from the signal.
//
//  In the case of Analog Signals, this percentage can be
//  computed by examining the timing of HSync and VSync as will as by
//  looking at information contained in HBlanking and VBlanking intervals.
//
//  In the case of Digital Signals, this percentage can be
//  computed by examining packet CRCs and FEC confidence values.
//
//  100 percent is ideal.
//  95 percent shows very little (almost unnoticable) artifacts when rendered.
//  90 percent contains few enough artifacts as to be easily viewable.
//  80 percent is the minimum level to be viewable.
//  60 percent is the minimum level to expect data services
//  (including EPG) to work.
//  20 percent indicates that the demodulator knows that a properly modulated
//  signal exists but can't produce enough data to be useful.
//
#define DEFINE_KSPROPERTY_ITEM_BDA_SIGNAL_QUALITY(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_SIGNAL_QUALITY,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(LONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

//  REQUIRED
//  True if a signal carrier is present.
//
//  Should be returned by the RF tuner node.
//
#define DEFINE_KSPROPERTY_ITEM_BDA_SIGNAL_PRESENT(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_SIGNAL_PRESENT,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(BOOL),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

//  REQUIRED
//  True if the signal can be locked.
//
//  Ususally represents PLL lock when returned by the RF Tuner Node.
//
//  Represents Signal Quality of at least 20% when returned by the
//  demodulator node.
//
#define DEFINE_KSPROPERTY_ITEM_BDA_SIGNAL_LOCKED(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_SIGNAL_LOCKED,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(BOOL),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

//  OPTIONAL
//  Indicates the sample time overwhich signal level and quality are
//  averaged.
//
//  Each time a signal statistics property is requested, the node should
//  report the average value for the last n milliseconds where n is the
//  value set by this property.  If no value is set or if the driver does
//  not support this property, the driver should default to 
//  100 millisecond sample times.
//
//  The driver may report values for the most recently completed sample
//  period.
//
#define DEFINE_KSPROPERTY_ITEM_BDA_SAMPLE_TIME(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_SAMPLE_TIME,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(LONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)



//------------------------------------------------------------
//
//
//  BDA Change Sync Method Set
//
// {FD0A5AF3-B41D-11d2-9C95-00C04F7971E0}
//
#define STATIC_KSMETHODSETID_BdaChangeSync \
    0xfd0a5af3, 0xb41d, 0x11d2, 0x9c, 0x95, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("FD0A5AF3-B41D-11d2-9C95-00C04F7971E0", KSMETHODSETID_BdaChangeSync);
#define KSMETHODSETID_BdaChangeSync DEFINE_GUIDNAMED(KSMETHODSETID_BdaChangeSync)

typedef enum {
    KSMETHOD_BDA_START_CHANGES = 0,
    KSMETHOD_BDA_CHECK_CHANGES,
    KSMETHOD_BDA_COMMIT_CHANGES,
    KSMETHOD_BDA_GET_CHANGE_STATE
} KSMETHOD_BDA_CHANGE_SYNC;

#define DEFINE_KSMETHOD_ITEM_BDA_START_CHANGES(MethodHandler, SupportHandler)\
    DEFINE_KSMETHOD_ITEM(\
        KSMETHOD_BDA_START_CHANGES,\
        KSMETHOD_TYPE_NONE,\
        (MethodHandler),\
        sizeof(KSMETHOD),\
        0,\
        SupportHandler)

#define DEFINE_KSMETHOD_ITEM_BDA_CHECK_CHANGES(MethodHandler, SupportHandler)\
    DEFINE_KSMETHOD_ITEM(\
        KSMETHOD_BDA_CHECK_CHANGES,\
        KSMETHOD_TYPE_NONE,\
        (MethodHandler),\
        sizeof(KSMETHOD),\
        0,\
        SupportHandler)

#define DEFINE_KSMETHOD_ITEM_BDA_COMMIT_CHANGES(MethodHandler, SupportHandler)\
    DEFINE_KSMETHOD_ITEM(\
        KSMETHOD_BDA_COMMIT_CHANGES,\
        KSMETHOD_TYPE_NONE,\
        (MethodHandler),\
        sizeof(KSMETHOD),\
        0,\
        SupportHandler)

#define DEFINE_KSMETHOD_ITEM_BDA_GET_CHANGE_STATE(MethodHandler, SupportHandler)\
    DEFINE_KSMETHOD_ITEM(\
        KSMETHOD_BDA_GET_CHANGE_STATE,\
        KSMETHOD_TYPE_READ,\
        (MethodHandler),\
        sizeof(KSMETHOD),\
        0,\
        SupportHandler)



//------------------------------------------------------------
//
//
//  BDA Device Configuration Method Set
//
// {71985F45-1CA1-11d3-9CC8-00C04F7971E0}
//
#define STATIC_KSMETHODSETID_BdaDeviceConfiguration \
    0x71985f45, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F45-1CA1-11d3-9CC8-00C04F7971E0", KSMETHODSETID_BdaDeviceConfiguration);
#define KSMETHODSETID_BdaDeviceConfiguration DEFINE_GUIDNAMED(KSMETHODSETID_BdaDeviceConfiguration)

typedef enum {
    KSMETHOD_BDA_CREATE_PIN_FACTORY = 0,
    KSMETHOD_BDA_DELETE_PIN_FACTORY,
    KSMETHOD_BDA_CREATE_TOPOLOGY
} KSMETHOD_BDA_DEVICE_CONFIGURATION;

#define DEFINE_KSMETHOD_ITEM_BDA_CREATE_PIN_FACTORY(MethodHandler, SupportHandler)\
    DEFINE_KSMETHOD_ITEM(\
        KSMETHOD_BDA_CREATE_PIN_FACTORY,\
        KSMETHOD_TYPE_READ,\
        (MethodHandler),\
        sizeof(KSM_BDA_PIN),\
        sizeof(ULONG),\
        SupportHandler)

#define DEFINE_KSMETHOD_ITEM_BDA_DELETE_PIN_FACTORY(MethodHandler, SupportHandler)\
    DEFINE_KSMETHOD_ITEM(\
        KSMETHOD_BDA_DELETE_PIN_FACTORY,\
        KSMETHOD_TYPE_NONE,\
        (MethodHandler),\
        sizeof(KSM_BDA_PIN),\
        0,\
        SupportHandler)

#define DEFINE_KSMETHOD_ITEM_BDA_CREATE_TOPOLOGY(MethodHandler, SupportHandler)\
    DEFINE_KSMETHOD_ITEM(\
        KSMETHOD_BDA_CREATE_TOPOLOGY,\
        KSMETHOD_TYPE_WRITE,\
        (MethodHandler),\
        sizeof(KSM_BDA_PIN_PAIR),\
        0,\
        SupportHandler)



//------------------------------------------------------------
//
//
//  BDA Topology Property Set
//
// {A14EE835-0A23-11d3-9CC7-00C04F7971E0}
//
#define STATIC_KSPROPSETID_BdaTopology \
    0xa14ee835, 0x0a23, 0x11d3, 0x9c, 0xc7, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("A14EE835-0A23-11d3-9CC7-00C04F7971E0", KSPROPSETID_BdaTopology);
#define KSPROPSETID_BdaTopology DEFINE_GUIDNAMED(KSPROPSETID_BdaTopology)

typedef enum {
    KSPROPERTY_BDA_NODE_TYPES,
    KSPROPERTY_BDA_PIN_TYPES,
    KSPROPERTY_BDA_TEMPLATE_CONNECTIONS,
    KSPROPERTY_BDA_NODE_METHODS,
    KSPROPERTY_BDA_NODE_PROPERTIES,
    KSPROPERTY_BDA_NODE_EVENTS,
    KSPROPERTY_BDA_CONTROLLING_PIN_ID,
    KSPROPERTY_BDA_NODE_DESCRIPTORS
 }KSPROPERTY_BDA_TOPOLOGY;

#define DEFINE_KSPROPERTY_ITEM_BDA_NODE_TYPES(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_NODE_TYPES,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        0,\
        FALSE,\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_PIN_TYPES(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_PIN_TYPES,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        0,\
        FALSE,\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_TEMPLATE_CONNECTIONS(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_TEMPLATE_CONNECTIONS,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof( BDA_TEMPLATE_CONNECTION),\
        FALSE,\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_NODE_METHODS(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_NODE_METHODS,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        0,\
        FALSE,\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_NODE_PROPERTIES(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_NODE_PROPERTIES,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        0,\
        FALSE,\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_NODE_EVENTS(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_NODE_EVENTS,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        0,\
        FALSE,\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_CONTROLLING_PIN_ID(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_CONTROLLING_PIN_ID,\
        (GetHandler),\
        sizeof(KSP_BDA_NODE_PIN),\
        sizeof( ULONG),\
        FALSE,\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_NODE_DESCRIPTORS(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_NODE_DESCRIPTORS,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        0,\
        FALSE,\
        NULL, 0, NULL, NULL, 0)



//------------------------------------------------------------
//
//
//  BDA Pin Control Property Set
//
// {0DED49D5-A8B7-4d5d-97A1-12B0C195874D}
//
#define STATIC_KSPROPSETID_BdaPinControl \
    0xded49d5, 0xa8b7, 0x4d5d, 0x97, 0xa1, 0x12, 0xb0, 0xc1, 0x95, 0x87, 0x4d
DEFINE_GUIDSTRUCT("0DED49D5-A8B7-4d5d-97A1-12B0C195874D", KSPROPSETID_BdaPinControl);
#define KSPROPSETID_BdaPinControl DEFINE_GUIDNAMED(KSPROPSETID_BdaPinControl)

typedef enum {
    KSPROPERTY_BDA_PIN_ID = 0,
    KSPROPERTY_BDA_PIN_TYPE
} KSPROPERTY_BDA_PIN_CONTROL;

#define DEFINE_KSPROPERTY_ITEM_BDA_PIN_ID(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_PIN_ID,\
        (GetHandler),\
        sizeof( KSPROPERTY),\
        sizeof( ULONG),\
        FALSE,\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_PIN_TYPE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_PIN_TYPE,\
        (GetHandler),\
        sizeof( KSPROPERTY),\
        sizeof( ULONG),\
        FALSE,\
        NULL, 0, NULL, NULL, 0)



//------------------------------------------------------------
//
//
//  BDA Pin Event Set
//
// {104781CD-50BD-40d5-95FB-087E0E86A591}
//
#define STATIC_KSEVENTSETID_BdaPinEvent \
    0x104781cd, 0x50bd, 0x40d5, 0x95, 0xfb, 0x08, 0x7e, 0xe, 0x86, 0xa5, 0x91
DEFINE_GUIDSTRUCT("104781CD-50BD-40d5-95FB-087E0E86A591", KSEVENTSETID_BdaPinEvent);
#define KSEVENTSETID_BdaPinEvent DEFINE_GUIDNAMED(KSEVENTSETID_BdaPinEvent)

typedef enum {
    KSEVENT_BDA_PIN_CONNECTED = 0,
    KSEVENT_BDA_PIN_DISCONNECTED
} KSPROPERTY_BDA_PIN_EVENT;

#define DEFINE_KSEVENT_ITEM_BDA_PIN_CONNECTED(AddHandler, RemoveHandler, SupportHandler)\
    DEFINE_KSEVENT_ITEM(\
        KSEVENT_BDA_PIN_CONNECTED,\
        sizeof( KSEVENTDATA), \
        0, \
        (AddHandler),\
        (RemoveHandler),\
        (SupportHandler)\
        )

#define DEFINE_KSEVENT_ITEM_BDA_PIN_DISCONNECTED(AddHandler, RemoveHandler, SupportHandler)\
    DEFINE_KSEVENT_ITEM(\
        KSEVENT_BDA_PIN_DISCONNECTED,\
        sizeof( KSEVENTDATA), \
        0, \
        (AddHandler),\
        (RemoveHandler),\
        (SupportHandler)\
        )



//------------------------------------------------------------
//
//
//  BDA Void Transform Property Set
//
// {71985F46-1CA1-11d3-9CC8-00C04F7971E0}
//
#define STATIC_KSPROPSETID_BdaVoidTransform \
    0x71985f46, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F46-1CA1-11d3-9CC8-00C04F7971E0", KSPROPSETID_BdaVoidTransform);
#define KSPROPSETID_BdaVoidTransform DEFINE_GUIDNAMED(KSPROPSETID_BdaVoidTransform)

typedef enum {
    KSPROPERTY_BDA_VOID_TRANSFORM_START = 0,
    KSPROPERTY_BDA_VOID_TRANSFORM_STOP
} KSPROPERTY_BDA_VOID_TRANSFORM;

#define DEFINE_KSPROPERTY_ITEM_BDA_VOID_TRANSFORM_START(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_VOID_TRANSFORM_START,\
        FALSE,\
        sizeof(KSPROPERTY),\
        0,\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_VOID_TRANSFORM_STOP(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_VOID_TRANSFORM_STOP,\
        FALSE,\
        sizeof(KSPROPERTY),\
        0,\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)



//------------------------------------------------------------
//
//
//  BDA Null Transform Property Set
//
// {DDF15B0D-BD25-11d2-9CA0-00C04F7971E0}
//
#define STATIC_KSPROPSETID_BdaNullTransform \
    0xddf15b0d, 0xbd25, 0x11d2, 0x9c, 0xa0, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("DDF15B0D-BD25-11d2-9CA0-00C04F7971E0", KSPROPSETID_BdaNullTransform);
#define KSPROPSETID_BdaNullTransform DEFINE_GUIDNAMED(KSPROPSETID_BdaNullTransform)

typedef enum {
    KSPROPERTY_BDA_NULL_TRANSFORM_START = 0,
    KSPROPERTY_BDA_NULL_TRANSFORM_STOP
} KSPROPERTY_BDA_NULL_TRANSFORM;

#define DEFINE_KSPROPERTY_ITEM_BDA_NULL_TRANSFORM_START(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_NULL_TRANSFORM_START,\
        FALSE,\
        sizeof(KSPROPERTY),\
        0,\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_NULL_TRANSFORM_STOP(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_NULL_TRANSFORM_STOP,\
        FALSE,\
        sizeof(KSPROPERTY),\
        0,\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)



//------------------------------------------------------------
//
//
//  BDA Frequency Filter Property Set
//
// {71985F47-1CA1-11d3-9CC8-00C04F7971E0}
//
#define STATIC_KSPROPSETID_BdaFrequencyFilter \
    0x71985f47, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F47-1CA1-11d3-9CC8-00C04F7971E0", KSPROPSETID_BdaFrequencyFilter);
#define KSPROPSETID_BdaFrequencyFilter DEFINE_GUIDNAMED(KSPROPSETID_BdaFrequencyFilter)

typedef enum {
    KSPROPERTY_BDA_RF_TUNER_FREQUENCY = 0,
    KSPROPERTY_BDA_RF_TUNER_POLARITY,
    KSPROPERTY_BDA_RF_TUNER_RANGE,
    KSPROPERTY_BDA_RF_TUNER_TRANSPONDER,
    KSPROPERTY_BDA_RF_TUNER_BANDWIDTH,
    KSPROPERTY_BDA_RF_TUNER_FREQUENCY_MULTIPLIER
} KSPROPERTY_BDA_FREQUENCY_FILTER;

#define DEFINE_KSPROPERTY_ITEM_BDA_RF_TUNER_FREQUENCY(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_RF_TUNER_FREQUENCY,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(ULONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_RF_TUNER_POLARITY(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_RF_TUNER_POLARITY,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(ULONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_RF_TUNER_RANGE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_RF_TUNER_RANGE,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(ULONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_RF_TUNER_TRANSPONDER(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_RF_TUNER_TRANSPONDER,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(ULONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_RF_TUNER_BANDWIDTH(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_RF_TUNER_BANDWIDTH,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(ULONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_RF_TUNER_FREQUENCY_MULTIPLIER(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_RF_TUNER_FREQUENCY_MULTIPLIER,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(ULONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)



//------------------------------------------------------------
//
//
//  BDA LNB Info Property Set
//
// {992CF102-49F9-4719-A664-C4F23E2408F4}
//
#define STATIC_KSPROPSETID_BdaLNBInfo \
    0x992cf102, 0x49f9, 0x4719, 0xa6, 0x64, 0xc4, 0xf2, 0x3e, 0x24, 0x8, 0xf4
DEFINE_GUIDSTRUCT("992CF102-49F9-4719-A664-C4F23E2408F4", KSPROPSETID_BdaLNBInfo);
#define KSPROPSETID_BdaLNBInfo DEFINE_GUIDNAMED(KSPROPSETID_BdaLNBInfo)

typedef enum {
    KSPROPERTY_BDA_LNB_LOF_LOW_BAND = 0,
    KSPROPERTY_BDA_LNB_LOF_HIGH_BAND,
    KSPROPERTY_BDA_LNB_SWITCH_FREQUENCY
} KSPROPERTY_BDA_LNB_INFO;

#define DEFINE_KSPROPERTY_ITEM_BDA_LNB_LOF_LOW_BAND(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_LNB_LOF_LOW_BAND,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(ULONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_LNB_LOF_HIGH_BAND(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_LNB_LOF_HIGH_BAND,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(ULONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_LNB_SWITCH_FREQUENCY(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_LNB_SWITCH_FREQUENCY,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(ULONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)



//------------------------------------------------------------
//
//
//  BDA Digital Demodulator Property Set
//
// {EF30F379-985B-4d10-B640-A79D5E04E1E0}
//
#define STATIC_KSPROPSETID_BdaDigitalDemodulator \
    0xef30f379, 0x985b, 0x4d10, 0xb6, 0x40, 0xa7, 0x9d, 0x5e, 0x4, 0xe1, 0xe0
DEFINE_GUIDSTRUCT("EF30F379-985B-4d10-B640-A79D5E04E1E0", KSPROPSETID_BdaDigitalDemodulator);
#define KSPROPSETID_BdaDigitalDemodulator DEFINE_GUIDNAMED(KSPROPSETID_BdaDigitalDemodulator)

typedef enum {
    KSPROPERTY_BDA_MODULATION_TYPE = 0,
    KSPROPERTY_BDA_INNER_FEC_TYPE,
    KSPROPERTY_BDA_INNER_FEC_RATE,
    KSPROPERTY_BDA_OUTER_FEC_TYPE,
    KSPROPERTY_BDA_OUTER_FEC_RATE,
    KSPROPERTY_BDA_SYMBOL_RATE,
    KSPROPERTY_BDA_SPECTRAL_INVERSION,
    KSPROPERTY_BDA_GUARD_INTERVAL,
    KSPROPERTY_BDA_TRANSMISSION_MODE
} KSPROPERTY_BDA_DIGITAL_DEMODULATOR;

#define DEFINE_KSPROPERTY_ITEM_BDA_MODULATION_TYPE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_MODULATION_TYPE,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(ModulationType),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_INNER_FEC_TYPE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_INNER_FEC_TYPE,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(FECMethod),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_INNER_FEC_RATE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_INNER_FEC_RATE,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(BinaryConvolutionCodeRate),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_OUTER_FEC_TYPE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_OUTER_FEC_TYPE,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(FECMethod),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_OUTER_FEC_RATE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_OUTER_FEC_RATE,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(BinaryConvolutionCodeRate),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_SYMBOL_RATE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_SYMBOL_RATE,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(ULONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_SPECTRAL_INVERSION(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_SPECTRAL_INVERSION,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(SpectralInversion),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_GUARD_INTERVAL(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_GUARD_INTERVAL,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(GuardInterval),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_TRANSMISSION_MODE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_TRANSMISSION_MODE,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(TransmissionMode),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)



//------------------------------------------------------------
//
//
//  BDA Autodemodulate Property Set
//
// {DDF15B12-BD25-11d2-9CA0-00C04F7971E0}
//
#define STATIC_KSPROPSETID_BdaAutodemodulate \
    0xddf15b12, 0xbd25, 0x11d2, 0x9c, 0xa0, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("DDF15B12-BD25-11d2-9CA0-00C04F7971E0", KSPROPSETID_BdaAutodemodulate);
#define KSPROPSETID_BdaAutodemodulate DEFINE_GUIDNAMED(KSPROPSETID_BdaAutodemodulate)

typedef enum {
    KSPROPERTY_BDA_AUTODEMODULATE_START = 0,
    KSPROPERTY_BDA_AUTODEMODULATE_STOP
} KSPROPERTY_BDA_AUTODEMODULATE;

#define DEFINE_KSPROPERTY_ITEM_BDA_AUTODEMODULATE_START(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_AUTODEMODULATE_START,\
        FALSE,\
        sizeof(KSP_NODE),\
        0,\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_AUTODEMODULATE_STOP(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_AUTODEMODULATE_STOP,\
        FALSE,\
        sizeof(KSP_NODE),\
        0,\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

//------------------------------------------------------------
//
//
//  BDA Table Section Property Set
//
// {516B99C5-971C-4aaf-B3F3-D9FDA8A15E16}
//

#define STATIC_KSPROPSETID_BdaTableSection \
    0x516b99c5, 0x971c, 0x4aaf, 0xb3, 0xf3, 0xd9, 0xfd, 0xa8, 0xa1, 0x5e, 0x16
DEFINE_GUIDSTRUCT("516B99C5-971C-4aaf-B3F3-D9FDA8A15E16", KSPROPSETID_BdaTableSection);
#define KSPROPSETID_BdaTableSection DEFINE_GUIDNAMED(KSPROPSETID_BdaTableSection)

typedef enum {
    KSPROPERTY_BDA_TABLE_SECTION = 0,
} KSPROPERTY_IDS_BDA_TABLE;

#define DEFINE_KSPROPERTY_ITEM_BDA_TABLE_SECTION(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_TABLE_SECTION,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(BDA_TABLE_SECTION),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)



//------------------------------------------------------------
//
//
//  BDA PID Filter Property Set
//
// {D0A67D65-08DF-4fec-8533-E5B550410B85}
//
#define STATIC_KSPROPSETID_BdaPIDFilter \
    0xd0a67d65, 0x8df, 0x4fec, 0x85, 0x33, 0xe5, 0xb5, 0x50, 0x41, 0xb, 0x85
DEFINE_GUIDSTRUCT("D0A67D65-08DF-4fec-8533-E5B550410B85", KSPROPSETID_BdaPIDFilter);
#define KSPROPSETID_BdaPIDFilter DEFINE_GUIDNAMED(KSPROPSETID_BdaPIDFilter)

typedef enum {
    KSPROPERTY_BDA_PIDFILTER_MAP_PIDS = 0,
    KSPROPERTY_BDA_PIDFILTER_UNMAP_PIDS,
    KSPROPERTY_BDA_PIDFILTER_LIST_PIDS
} KSPROPERTY_BDA_PIDFILTER;

#define DEFINE_KSPROPERTY_ITEM_BDA_PIDFILTER_MAP_PIDS(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_PIDFILTER_MAP_PIDS,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(BDA_PID_MAP),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_PIDFILTER_UNMAP_PIDS(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_PIDFILTER_UNMAP_PIDS,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(BDA_PID_UNMAP),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_PIDFILTER_LIST_PIDS(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_PIDFILTER_LIST_PIDS,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        0,\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)



//------------------------------------------------------------
//
//
//  BDA CA Property Set
//
// {B0693766-5278-4ec6-B9E1-3CE40560EF5A}
//
#define STATIC_KSPROPSETID_BdaCA \
    0xb0693766, 0x5278, 0x4ec6, 0xb9, 0xe1, 0x3c, 0xe4, 0x5, 0x60, 0xef, 0x5a
DEFINE_GUIDSTRUCT("B0693766-5278-4ec6-B9E1-3CE40560EF5A", KSPROPSETID_BdaCA);
#define KSPROPSETID_BdaCA DEFINE_GUIDNAMED(KSPROPSETID_BdaCA)

typedef enum {
    KSPROPERTY_BDA_ECM_MAP_STATUS = 0,
    KSPROPERTY_BDA_CA_MODULE_STATUS,
    KSPROPERTY_BDA_CA_SMART_CARD_STATUS,
    KSPROPERTY_BDA_CA_MODULE_UI,
    KSPROPERTY_BDA_CA_SET_PROGRAM_PIDS,
    KSPROPERTY_BDA_CA_REMOVE_PROGRAM
} KSPROPERTY_BDA_CA;

#define DEFINE_KSPROPERTY_ITEM_BDA_ECM_MAP_STATUS(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_ECM_MAP_STATUS,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(ULONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_CA_MODULE_STATUS(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_CA_MODULE_STATUS,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(ULONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_CA_SMART_CARD_STATUS(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_CA_SMART_CARD_STATUS,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(ULONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_CA_MODULE_UI(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_CA_MODULE_UI,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(BDA_CA_MODULE_UI),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_CA_SET_PROGRAM_PIDS(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_CA_SET_PROGRAM_PIDS,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(BDA_PROGRAM_PID_LIST),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_CA_REMOVE_PROGRAM(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_CA_REMOVE_PROGRAM,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(ULONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)



//------------------------------------------------------------
//
//
//  BDA CA Event Set
//
// {488C4CCC-B768-4129-8EB1-B00A071F9068}
//
#define STATIC_KSEVENTSETID_BdaCAEvent \
    0x488c4ccc, 0xb768, 0x4129, 0x8e, 0xb1, 0xb0, 0xa, 0x7, 0x1f, 0x90, 0x68
DEFINE_GUIDSTRUCT("488C4CCC-B768-4129-8EB1-B00A071F9068", KSEVENTSETID_BdaCAEvent);
#define KSEVENTSETID_BdaCAEvent DEFINE_GUIDNAMED(KSEVENTSETID_BdaCAEvent)

typedef enum {
    KSEVENT_BDA_PROGRAM_FLOW_STATUS_CHANGED = 0,
    KSEVENT_BDA_CA_MODULE_STATUS_CHANGED,
    KSEVENT_BDA_CA_SMART_CARD_STATUS_CHANGED,
    KSEVENT_BDA_CA_MODULE_UI_REQUESTED
} KSPROPERTY_BDA_CA_EVENT;

#define DEFINE_KSEVENT_BDA_PROGRAM_FLOW_STATUS_CHANGED(AddHandler, RemoveHandler, SupportHandler)\
    DEFINE_KSEVENT_ITEM(\
        KSEVENT_BDA_PROGRAM_FLOW_STATUS_CHANGED,\
        sizeof( KSEVENTDATA), \
        0, \
        (AddHandler),\
        (RemoveHandler),\
        (SupportHandler)\
        )

#define DEFINE_KSEVENT_BDA_CA_MODULE_STATUS_CHANGED(AddHandler, RemoveHandler, SupportHandler)\
    DEFINE_KSEVENT_ITEM(\
        KSEVENT_BDA_CA_MODULE_STATUS_CHANGED,\
        sizeof( KSEVENTDATA), \
        0, \
        (AddHandler),\
        (RemoveHandler),\
        (SupportHandler)\
        )

#define DEFINE_KSEVENT_BDA_CA_SMART_CARD_STATUS_CHANGED(AddHandler, RemoveHandler, SupportHandler)\
    DEFINE_KSEVENT_ITEM(\
        KSEVENT_BDA_CA_SMART_CARD_STATUS_CHANGED,\
        sizeof( KSEVENTDATA), \
        0, \
        (AddHandler),\
        (RemoveHandler),\
        (SupportHandler)\
        )

#define DEFINE_KSEVENT_BDA_CA_MODULE_UI_REQUESTED(AddHandler, RemoveHandler, SupportHandler)\
    DEFINE_KSEVENT_ITEM(\
        KSEVENT_BDA_CA_MODULE_UI_REQUESTED,\
        sizeof( KSEVENTDATA), \
        0, \
        (AddHandler),\
        (RemoveHandler),\
        (SupportHandler)\
        )


//===========================================================================
//
// BDA Filter Categories
//
//===========================================================================

#define STATIC_KSCATEGORY_BDA_RECEIVER_COMPONENT \
    0xFD0A5AF4, 0xB41D, 0x11d2, 0x9c, 0x95, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("FD0A5AF4-B41D-11d2-9C95-00C04F7971E0", KSCATEGORY_BDA_RECEIVER_COMPONENT);
#define KSCATEGORY_BDA_RECEIVER_COMPONENT DEFINE_GUIDNAMED(KSCATEGORY_BDA_RECEIVER_COMPONENT)


#define STATIC_KSCATEGORY_BDA_NETWORK_TUNER \
    0x71985f48, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F48-1CA1-11d3-9CC8-00C04F7971E0", KSCATEGORY_BDA_NETWORK_TUNER);
#define KSCATEGORY_BDA_NETWORK_TUNER DEFINE_GUIDNAMED(KSCATEGORY_BDA_NETWORK_TUNER)


#define STATIC_KSCATEGORY_BDA_NETWORK_EPG \
    0x71985f49, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F49-1CA1-11d3-9CC8-00C04F7971E0", KSCATEGORY_BDA_NETWORK_EPG);
#define KSCATEGORY_BDA_NETWORK_EPG DEFINE_GUIDNAMED(KSCATEGORY_BDA_NETWORK_EPG)


#define STATIC_KSCATEGORY_BDA_IP_SINK \
    0x71985f4aL, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x00, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F4A-1CA1-11d3-9CC8-00C04F7971E0", KSCATEGORY_BDA_IP_SINK);
#define KSCATEGORY_IP_SINK DEFINE_GUIDNAMED(KSCATEGORY_BDA_IP_SINK)


#define STATIC_KSCATEGORY_BDA_NETWORK_PROVIDER \
    0x71985f4b, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F4B-1CA1-11d3-9CC8-00C04F7971E0", KSCATEGORY_BDA_NETWORK_PROVIDER);
#define KSCATEGORY_BDA_NETWORK_PROVIDER DEFINE_GUIDNAMED(KSCATEGORY_BDA_NETWORK_PROVIDER)

// {A2E3074F-6C3D-11d3-B653-00C04F79498E}
#define STATIC_KSCATEGORY_BDA_TRANSPORT_INFORMATION \
        0xa2e3074f, 0x6c3d, 0x11d3, 0xb6, 0x53, 0x0, 0xc0, 0x4f, 0x79, 0x49, 0x8e
DEFINE_GUIDSTRUCT("A2E3074F-6C3D-11d3-B653-00C04F79498E", KSCATEGORY_BDA_TRANSPORT_INFORMATION);
#define KSCATEGORY_BDA_TRANSPORT_INFORMATION DEFINE_GUIDNAMED(KSCATEGORY_BDA_TRANSPORT_INFORMATION)

//===========================================================================
//
// BDA Node Categories
//
//===========================================================================


#define STATIC_KSNODE_BDA_RF_TUNER \
    0x71985f4c, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F4C-1CA1-11d3-9CC8-00C04F7971E0", KSNODE_BDA_RF_TUNER);
#define KSNODE_BDA_RF_TUNER DEFINE_GUIDNAMED(KSNODE_BDA_RF_TUNER)


#define STATIC_KSNODE_BDA_QAM_DEMODULATOR \
    0x71985f4d, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F4D-1CA1-11d3-9CC8-00C04F7971E0", KSNODE_BDA_QAM_DEMODULATOR);
#define KSNODE_BDA_QAM_DEMODULATOR DEFINE_GUIDNAMED(KSNODE_BDA_QAM_DEMODULATOR)


#define STATIC_KSNODE_BDA_QPSK_DEMODULATOR \
    0x6390c905, 0x27c1, 0x4d67, 0xbd, 0xb7, 0x77, 0xc5, 0xd, 0x7, 0x93, 0x0
DEFINE_GUIDSTRUCT("6390C905-27C1-4d67-BDB7-77C50D079300", KSNODE_BDA_QPSK_DEMODULATOR);
#define KSNODE_BDA_QPSK_DEMODULATOR DEFINE_GUIDNAMED(KSNODE_BDA_QPSK_DEMODULATOR)


#define STATIC_KSNODE_BDA_8VSB_DEMODULATOR \
    0x71985f4f, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F4F-1CA1-11d3-9CC8-00C04F7971E0", KSNODE_BDA_8VSB_DEMODULATOR);
#define KSNODE_BDA_8VSB_DEMODULATOR DEFINE_GUIDNAMED(KSNODE_BDA_8VSB_DEMODULATOR)


#define STATIC_KSNODE_BDA_COFDM_DEMODULATOR \
    0x2dac6e05, 0xedbe, 0x4b9c, 0xb3, 0x87, 0x1b, 0x6f, 0xad, 0x7d, 0x64, 0x95
DEFINE_GUIDSTRUCT("2DAC6E05-EDBE-4b9c-B387-1B6FAD7D6495", KSNODE_BDA_COFDM_DEMODULATOR);
#define KSNODE_BDA_COFDM_DEMODULATOR DEFINE_GUIDNAMED(KSNODE_BDA_COFDM_DEMODULATOR)


#define STATIC_KSNODE_BDA_OPENCABLE_POD \
    0xd83ef8fc, 0xf3b8, 0x45ab, 0x8b, 0x71, 0xec, 0xf7, 0xc3, 0x39, 0xde, 0xb4
DEFINE_GUIDSTRUCT("D83EF8FC-F3B8-45ab-8B71-ECF7C339DEB4", KSNODE_BDA_OPENCABLE_POD);
#define KSNODE_BDA_OPENCABLE_POD DEFINE_GUIDNAMED(KSNODE_BDA_OPENCABLE_POD)


#define STATIC_KSNODE_BDA_COMMON_CA_POD \
    0xd83ef8fc, 0xf3b8, 0x45ab, 0x8b, 0x71, 0xec, 0xf7, 0xc3, 0x39, 0xde, 0xb4
DEFINE_GUIDSTRUCT("D83EF8FC-F3B8-45ab-8B71-ECF7C339DEB4", KSNODE_BDA_COMMON_CA_POD);
#define KSNODE_BDA_COMMON_CA_POD DEFINE_GUIDNAMED(KSNODE_BDA_COMMON_CA_POD)


#define STATIC_KSNODE_BDA_PID_FILTER \
    0xf5412789, 0xb0a0, 0x44e1, 0xae, 0x4f, 0xee, 0x99, 0x9b, 0x1b, 0x7f, 0xbe
DEFINE_GUIDSTRUCT("F5412789-B0A0-44e1-AE4F-EE999B1B7FBE", KSNODE_BDA_PID_FILTER);
#define KSNODE_BDA_PID_FILTER DEFINE_GUIDNAMED(KSNODE_BDA_PID_FILTER)


#define STATIC_KSNODE_BDA_IP_SINK \
    0x71985f4e, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F4E-1CA1-11d3-9CC8-00C04F7971E0", KSNODE_BDA_IP_SINK);
#define KSNODE_IP_SINK DEFINE_GUIDNAMED(KSNODE_BDA_IP_SINK)


//===========================================================================
//
// IPSink PINNAME GUID
//
//===========================================================================

#define STATIC_PINNAME_IPSINK_INPUT \
    0x3fdffa70L, 0xac9a, 0x11d2, 0x8f, 0x17, 0x00, 0xc0, 0x4f, 0x79, 0x71, 0xe2
DEFINE_GUIDSTRUCT("3fdffa70-ac9a-11d2-8f17-00c04f7971e2", PINNAME_IPSINK_INPUT);
#define PINNAME_IPSINK_INPUT   DEFINE_GUIDNAMED(PINNAME_IPSINK_INPUT)


//===========================================================================
//
// BDA IPSink Categories/Types
//
//===========================================================================


#define STATIC_KSDATAFORMAT_TYPE_BDA_IP\
    0xe25f7b8e, 0xcccc, 0x11d2, 0x8f, 0x25, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe2
DEFINE_GUIDSTRUCT("e25f7b8e-cccc-11d2-8f25-00c04f7971e2", KSDATAFORMAT_TYPE_BDA_IP);
#define KSDATAFORMAT_TYPE_BDA_IP  DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_BDA_IP)

#define STATIC_KSDATAFORMAT_SUBTYPE_BDA_IP\
    0x5a9a213c, 0xdb08, 0x11d2, 0x8f, 0x32, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe2
DEFINE_GUIDSTRUCT("5a9a213c-db08-11d2-8f32-00c04f7971e2", KSDATAFORMAT_SUBTYPE_BDA_IP);
#define KSDATAFORMAT_SUBTYPE_BDA_IP  DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_BDA_IP)

#define STATIC_KSDATAFORMAT_SPECIFIER_BDA_IP\
    0x6b891420, 0xdb09, 0x11d2, 0x8f, 0x32, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe2
DEFINE_GUIDSTRUCT("6B891420-DB09-11d2-8F32-00C04F7971E2", KSDATAFORMAT_SPECIFIER_BDA_IP);
#define KSDATAFORMAT_SPECIFIER_BDA_IP  DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_BDA_IP)



#define STATIC_KSDATAFORMAT_TYPE_BDA_IP_CONTROL\
    0xdadd5799, 0x7d5b, 0x4b63, 0x80, 0xfb, 0xd1, 0x44, 0x2f, 0x26, 0xb6, 0x21
DEFINE_GUIDSTRUCT("DADD5799-7D5B-4b63-80FB-D1442F26B621", KSDATAFORMAT_TYPE_BDA_IP_CONTROL);
#define KSDATAFORMAT_TYPE_BDA_IP_CONTROL  DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_BDA_IP_CONTROL)

#define STATIC_KSDATAFORMAT_SUBTYPE_BDA_IP_CONTROL\
    0x499856e8, 0xe85b, 0x48ed, 0x9b, 0xea, 0x41, 0xd, 0xd, 0xd4, 0xef, 0x81
DEFINE_GUIDSTRUCT("499856E8-E85B-48ed-9BEA-410D0DD4EF81", KSDATAFORMAT_SUBTYPE_BDA_IP_CONTROL);
#define KSDATAFORMAT_SUBTYPE_BDA_IP_CONTROL  DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_BDA_IP_CONTROL)


//===========================================================================
//
// MPE PINNAME GUID
//
//===========================================================================

#define STATIC_PINNAME_MPE \
    0xc1b06d73L, 0x1dbb, 0x11d3, 0x8f, 0x46, 0x00, 0xC0, 0x4f, 0x79, 0x71, 0xE2
DEFINE_GUIDSTRUCT("C1B06D73-1DBB-11d3-8F46-00C04F7971E2", PINNAME_MPE);
#define PINNAME_MPE   DEFINE_GUIDNAMED(PINNAME_MPE)


/////////////////////////////////////////////////////////////
//
// BDA MPE Categories/Types
//
#define STATIC_KSDATAFORMAT_TYPE_MPE \
    0x455f176c, 0x4b06, 0x47ce, 0x9a, 0xef, 0x8c, 0xae, 0xf7, 0x3d, 0xf7, 0xb5
DEFINE_GUIDSTRUCT("455F176C-4B06-47ce-9AEF-8CAEF73DF7B5", KSDATAFORMAT_TYPE_MPE);
#define KSDATAFORMAT_TYPE_MPE  DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_MPE)


#if defined(__cplusplus)
}
#endif // defined(__cplusplus)

#endif // !defined(_BDAMEDIA_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\include\comlite.h ===
//------------------------------------------------------------------------------
// File: COMLite.h
//
// Desc: This header file is to provide a migration path for users of 
//       ActiveMovie betas 1 and 2.
//
// Copyright (c) 1992 - 2000, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef _INC_COMLITE_
#define _INC_COMLITE_

#define QzInitialize            CoInitialize
#define QzUninitialize          CoUninitialize
#define QzFreeUnusedLibraries   CoFreeUnusedLibraries

#define QzGetMalloc             CoGetMalloc
#define QzTaskMemAlloc          CoTaskMemAlloc
#define QzTaskMemRealloc        CoTaskMemRealloc
#define QzTaskMemFree           CoTaskMemFree
#define QzCreateFilterObject    CoCreateInstance
#define QzCLSIDFromString       CLSIDFromString
#define QzStringFromGUID2       StringFromGUID2

#endif  // _INC_COMLITE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\include\bdatypes.h ===
//------------------------------------------------------------------------------
// File: BDATypes.h
//
// Desc: Typedefs and enums needed by both the WDM drivers and the user mode
//       COM interfaces.
//
// Copyright (c) 1999 - 2000, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef _BDATYPES_

#define _BDATYPES_      1

/* Utility Macros */

#define MIN_DIMENSION   1


#ifdef __midl
#define V1_ENUM [v1_enum]
#else
#define V1_ENUM
#endif

//===========================================================================
//
//  BDA Topology Structures
//
//===========================================================================

typedef struct _BDA_TEMPLATE_CONNECTION
{
    ULONG   FromNodeType;
    ULONG   FromNodePinType;
    ULONG   ToNodeType;
    ULONG   ToNodePinType;
}BDA_TEMPLATE_CONNECTION, *PBDA_TEMPLATE_CONNECTION;


typedef struct _BDA_TEMPLATE_PIN_JOINT
{
    ULONG   uliTemplateConnection;
    ULONG   ulcInstancesMax;
}BDA_TEMPLATE_PIN_JOINT, *PBDA_TEMPLATE_PIN_JOINT;



//===========================================================================
//
//  BDA Events
//
//===========================================================================

//  In-band Event IDs
//
typedef enum {
    BDA_EVENT_SIGNAL_LOSS = 0,
    BDA_EVENT_SIGNAL_LOCK,
    BDA_EVENT_DATA_START,
    BDA_EVENT_DATA_STOP,
    BDA_EVENT_CHANNEL_ACQUIRED,
    BDA_EVENT_CHANNEL_LOST,
    BDA_EVENT_CHANNEL_SOURCE_CHANGED,
    BDA_EVENT_CHANNEL_ACTIVATED,
    BDA_EVENT_CHANNEL_DEACTIVATED,
    BDA_EVENT_SUBCHANNEL_ACQUIRED,
    BDA_EVENT_SUBCHANNEL_LOST,
    BDA_EVENT_SUBCHANNEL_SOURCE_CHANGED,
    BDA_EVENT_SUBCHANNEL_ACTIVATED,
    BDA_EVENT_SUBCHANNEL_DEACTIVATED,
    BDA_EVENT_ACCESS_GRANTED,
    BDA_EVENT_ACCESS_DENIED,
    BDA_EVENT_OFFER_EXTENDED,
    BDA_EVENT_PURCHASE_COMPLETED,
    BDA_EVENT_SMART_CARD_INSERTED,
    BDA_EVENT_SMART_CARD_REMOVED
} BDA_EVENT_ID, *PBDA_EVENT_ID;



//===========================================================================
//
//  KSSTREAM_HEADER extensions for BDA
//
//===========================================================================

typedef struct tagKS_BDA_FRAME_INFO {
    ULONG                   ExtendedHeaderSize; // Size of this extended header
    DWORD                   dwFrameFlags;  //
    ULONG                   ulEvent; //
    ULONG                   ulChannelNumber; //
    ULONG                   ulSubchannelNumber; //
    ULONG                   ulReason; //
} KS_BDA_FRAME_INFO, *PKS_BDA_FRAME_INFO;


//------------------------------------------------------------
//
//  BDA Network Ethernet Filter Property Set
//
// {71985F43-1CA1-11d3-9CC8-00C04F7971E0}
//
typedef struct _BDA_ETHERNET_ADDRESS {
    BYTE    rgbAddress[6];
} BDA_ETHERNET_ADDRESS, *PBDA_ETHERNET_ADDRESS;

typedef struct _BDA_ETHERNET_ADDRESS_LIST {
    ULONG               ulcAddresses;
    BDA_ETHERNET_ADDRESS    rgAddressl[MIN_DIMENSION];
} BDA_ETHERNET_ADDRESS_LIST, * PBDA_ETHERNET_ADDRESS_LIST;

typedef enum {
    BDA_PROMISCUOUS_MULTICAST = 0,
    BDA_FILTERED_MULTICAST,
    BDA_NO_MULTICAST
} BDA_MULTICAST_MODE, *PBDA_MULTICAST_MODE;


//------------------------------------------------------------
//
//  BDA Network IPv4 Filter Property Set
//
// {71985F44-1CA1-11d3-9CC8-00C04F7971E0}
//
typedef struct _BDA_IPv4_ADDRESS {
    BYTE    rgbAddress[4];
} BDA_IPv4_ADDRESS, *PBDA_IPv4_ADDRESS;

typedef struct _BDA_IPv4_ADDRESS_LIST {
    ULONG               ulcAddresses;
    BDA_IPv4_ADDRESS    rgAddressl[MIN_DIMENSION];
} BDA_IPv4_ADDRESS_LIST, * PBDA_IPv4_ADDRESS_LIST;


//------------------------------------------------------------
//
//  BDA Network IPv4 Filter Property Set
//
// {E1785A74-2A23-4fb3-9245-A8F88017EF33}
//
typedef struct _BDA_IPv6_ADDRESS {
    BYTE    rgbAddress[6];
} BDA_IPv6_ADDRESS, *PBDA_IPv6_ADDRESS;

typedef struct _BDA_IPv6_ADDRESS_LIST {
    ULONG               ulcAddresses;
    BDA_IPv6_ADDRESS    rgAddressl[MIN_DIMENSION];
} BDA_IPv6_ADDRESS_LIST, * PBDA_IPv6_ADDRESS_LIST;


//------------------------------------------------------------
//
//
//  BDA Signal Property Set
//
//  {D2F1644B-B409-11d2-BC69-00A0C9EE9E16}
//
typedef enum {
    BDA_SIGNAL_UNAVAILABLE = 0,
    BDA_SIGNAL_INACTIVE,
    BDA_SIGNAL_ACTIVE
} BDA_SIGNAL_STATE, * PBDA_SIGNAL_STATE;


//------------------------------------------------------------
//
//
//  BDA Change Sync Method Set
//
// {FD0A5AF3-B41D-11d2-9C95-00C04F7971E0}
//
typedef enum
{
    BDA_CHANGES_COMPLETE = 0,
    BDA_CHANGES_PENDING

} BDA_CHANGE_STATE, * PBDA_CHANGE_STATE;


//------------------------------------------------------------
//
//
//  BDA Device Configuration Method Set
//
// {71985F45-1CA1-11d3-9CC8-00C04F7971E0}
//


//------------------------------------------------------------
//
//
//  BDA Topology Property Set
//
// {A14EE835-0A23-11d3-9CC7-00C04F7971E0}
//

typedef struct _BDANODE_DESCRIPTOR
{
    ULONG               ulBdaNodeType;  // The node type as it is used
                                        // in the BDA template topology

    GUID                guidFunction;   // GUID from BdaMedia.h describing
                                        // the node's function (e.g.
                                        // KSNODE_BDA_RF_TUNER)

    GUID                guidName;       // GUID that can be use to look up
                                        // a displayable name for the node.
} BDANODE_DESCRIPTOR, *PBDANODE_DESCRIPTOR;


//------------------------------------------------------------
//
//
//  BDA Void Transform Property Set
//
// {71985F46-1CA1-11d3-9CC8-00C04F7971E0}
//


//------------------------------------------------------------
//
//
//  BDA Null Transform Property Set
//
// {DDF15B0D-BD25-11d2-9CA0-00C04F7971E0}
//


//------------------------------------------------------------
//
//
//  BDA Frequency Filter Property Set
//
// {71985F47-1CA1-11d3-9CC8-00C04F7971E0}
//


//------------------------------------------------------------
//
//
//  BDA Autodemodulate Property Set
//
// {DDF15B12-BD25-11d2-9CA0-00C04F7971E0}
//


//------------------------------------------------------------
//
//
//  BDA Table Section Property Set
//
// {516B99C5-971C-4aaf-B3F3-D9FDA8A15E16}
//

typedef struct _BDA_TABLE_SECTION
{
    ULONG               ulPrimarySectionId;
    ULONG               ulSecondarySectionId;
    ULONG               ulcbSectionLength;
    ULONG               argbSectionData[MIN_DIMENSION];
} BDA_TABLE_SECTION, *PBDA_TABLE_SECTION;


//------------------------------------------------------------
//
//
//  BDA PID Filter Property Set
//
// {D0A67D65-08DF-4fec-8533-E5B550410B85}
//

//---------------------------------------------------------------------
// From IEnumPIDMap interface
//---------------------------------------------------------------------

typedef enum {
    MEDIA_TRANSPORT_PACKET,         //  complete TS packet e.g. pass-through mode
    MEDIA_ELEMENTARY_STREAM,        //  PES payloads; audio/video only
    MEDIA_MPEG2_PSI,                //  PAT, PMT, CAT, Private
    MEDIA_TRANSPORT_PAYLOAD         //  gathered TS packet payloads (PES packets, etc...)
} MEDIA_SAMPLE_CONTENT ;

typedef struct {
    ULONG                   ulPID ;
    MEDIA_SAMPLE_CONTENT    MediaSampleContent ;
} PID_MAP ;

typedef struct _BDA_PID_MAP
{
    MEDIA_SAMPLE_CONTENT    MediaSampleContent;
    ULONG                   ulcPIDs;
    ULONG                   aulPIDs[MIN_DIMENSION];
} BDA_PID_MAP, *PBDA_PID_MAP;

typedef struct _BDA_PID_UNMAP
{
    ULONG               ulcPIDs;
    ULONG               aulPIDs[MIN_DIMENSION];
} BDA_PID_UNMAP, *PBDA_PID_UNMAP;


//------------------------------------------------------------
//
//
//  BDA CA Property Set
//
// {B0693766-5278-4ec6-B9E1-3CE40560EF5A}
//
typedef struct _BDA_CA_MODULE_UI
{
    ULONG   ulFormat;
    ULONG   ulbcDesc;
    ULONG   ulDesc[MIN_DIMENSION];
} BDA_CA_MODULE_UI, *PBDA_CA_MODULE_UI;

typedef struct _BDA_PROGRAM_PID_LIST
{
    ULONG   ulProgramNumber;
    ULONG   ulcPIDs;
    ULONG   ulPID[MIN_DIMENSION];
} BDA_PROGRAM_PID_LIST, *PBDA_PROGRAM_PID_LIST;


//------------------------------------------------------------
//
//
//  BDA CA Event Set
//
// {488C4CCC-B768-4129-8EB1-B00A071F9068}
//



//=============================================================
//
//
//  BDA Tuning Model enumerations
//
//
//=============================================================

// system type for particular DVB Tuning Space instance
typedef enum DVBSystemType {
    DVB_Cable,
    DVB_Terrestrial,
    DVB_Satellite,
} DVBSystemType;

//------------------------------------------------------------
//
//  BDA Channel Tune Request

V1_ENUM enum {
    BDA_UNDEFINED_CHANNEL = -1,
};


//------------------------------------------------------------
//
//  BDA Component(substream)
//

typedef V1_ENUM enum ComponentCategory
{
    CategoryNotSet = -1,
    CategoryOther = 0,
    CategoryVideo,
    CategoryAudio,
    CategoryText,
    CategoryData,
} ComponentCategory;

// Component Status
typedef enum ComponentStatus
{
    StatusActive,
    StatusInactive,
    StatusUnavailable,
} ComponentStatus;


//------------------------------------------------------------
//
//  BDA MPEG2 Component Type
//
// from the MPEG2 specification
typedef V1_ENUM enum MPEG2StreamType {
    BDA_UNITIALIZED_MPEG2STREAMTYPE = -1,
    Reserved1 = 0x0,
    ISO_IEC_11172_2_VIDEO   = Reserved1 + 1,
    ISO_IEC_13818_2_VIDEO   = ISO_IEC_11172_2_VIDEO + 1,
    ISO_IEC_11172_3_AUDIO   = ISO_IEC_13818_2_VIDEO + 1,
    ISO_IEC_13818_3_AUDIO   = ISO_IEC_11172_3_AUDIO + 1,
    ISO_IEC_13818_1_PRIVATE_SECTION = ISO_IEC_13818_3_AUDIO + 1,
    ISO_IEC_13818_1_PES     = ISO_IEC_13818_1_PRIVATE_SECTION + 1,
    ISO_IEC_13522_MHEG      = ISO_IEC_13818_1_PES + 1,
    ANNEX_A_DSM_CC          = ISO_IEC_13522_MHEG + 1,
    ITU_T_REC_H_222_1       = ANNEX_A_DSM_CC + 1,
    ISO_IEC_13818_6_TYPE_A  = ITU_T_REC_H_222_1 + 1,
    ISO_IEC_13818_6_TYPE_B  = ISO_IEC_13818_6_TYPE_A + 1,
    ISO_IEC_13818_6_TYPE_C  = ISO_IEC_13818_6_TYPE_B + 1,
    ISO_IEC_13818_6_TYPE_D  = ISO_IEC_13818_6_TYPE_C + 1,
    ISO_IEC_13818_1_AUXILIARY = ISO_IEC_13818_6_TYPE_D + 1,
    ISO_IEC_13818_1_RESERVED = ISO_IEC_13818_1_AUXILIARY + 1,
    USER_PRIVATE            = ISO_IEC_13818_1_RESERVED + 1
} MPEG2StreamType;

//------------------------------------------------------------
//
//  mpeg-2 transport stride format block; associated with media
//   types MEDIATYPE_Stream/MEDIASUBTYPE_MPEG2_TRANSPORT_STRIDE;
//   *all* format blocks associated with above media type *must*
//   start with the MPEG2_TRANSPORT_STRIDE structure
//

typedef struct _MPEG2_TRANSPORT_STRIDE {
    DWORD   dwOffset ;
    DWORD   dwPacketLength ;
    DWORD   dwStride ;
} MPEG2_TRANSPORT_STRIDE, *PMPEG2_TRANSPORT_STRIDE ;

//------------------------------------------------------------
//
//  BDA ATSC Component Type
//
//
// ATSC made AC3 Audio a descriptor instead of
// defining a user private stream type.
typedef enum ATSCComponentTypeFlags {
    // bit flags for various component type properties
    ATSCCT_AC3 = 0x00000001,
} ATSCComponentTypeFlags;


//------------------------------------------------------------
//
//  BDA Locators
//


typedef V1_ENUM enum BinaryConvolutionCodeRate {
    BDA_BCC_RATE_NOT_SET = -1,
    BDA_BCC_RATE_NOT_DEFINED = 0,
    BDA_BCC_RATE_1_2 = 1,   // 1/2
    BDA_BCC_RATE_2_3,   // 2/3
    BDA_BCC_RATE_3_4,   // 3/4
    BDA_BCC_RATE_3_5,
    BDA_BCC_RATE_4_5,
    BDA_BCC_RATE_5_6,   // 5/6
    BDA_BCC_RATE_5_11,
    BDA_BCC_RATE_7_8,   // 7/8
    BDA_BCC_RATE_MAX,
} BinaryConvolutionCodeRate;

typedef V1_ENUM enum FECMethod {
    BDA_FEC_METHOD_NOT_SET = -1,
    BDA_FEC_METHOD_NOT_DEFINED = 0,
    BDA_FEC_VITERBI = 1,          // FEC is a Viterbi Binary Convolution.
    BDA_FEC_RS_204_188,       // The FEC is Reed-Solomon 204/188 (outer FEC)
    BDA_FEC_MAX,
} FECMethod;

typedef V1_ENUM enum ModulationType {
    BDA_MOD_NOT_SET = -1,
    BDA_MOD_NOT_DEFINED = 0,
    BDA_MOD_16QAM = 1,
    BDA_MOD_32QAM,
    BDA_MOD_64QAM,
    BDA_MOD_80QAM,
    BDA_MOD_96QAM,
    BDA_MOD_112QAM,
    BDA_MOD_128QAM,
    BDA_MOD_160QAM,
    BDA_MOD_192QAM,
    BDA_MOD_224QAM,
    BDA_MOD_256QAM,
    BDA_MOD_320QAM,
    BDA_MOD_384QAM,
    BDA_MOD_448QAM,
    BDA_MOD_512QAM,
    BDA_MOD_640QAM,
    BDA_MOD_768QAM,
    BDA_MOD_896QAM,
    BDA_MOD_1024QAM,
    BDA_MOD_QPSK,
    BDA_MOD_BPSK,
    BDA_MOD_OQPSK,
    BDA_MOD_8VSB,
    BDA_MOD_16VSB,
    BDA_MOD_ANALOG_AMPLITUDE,  // std am
    BDA_MOD_ANALOG_FREQUENCY,  // std fm
    BDA_MOD_MAX,
} ModulationType;

typedef V1_ENUM enum SpectralInversion {
    BDA_SPECTRAL_INVERSION_NOT_SET = -1,
    BDA_SPECTRAL_INVERSION_NOT_DEFINED = 0,
    BDA_SPECTRAL_INVERSION_AUTOMATIC = 1,
    BDA_SPECTRAL_INVERSION_NORMAL,
    BDA_SPECTRAL_INVERSION_INVERTED,
    BDA_SPECTRAL_INVERSION_MAX
} SpectralInversion;

typedef V1_ENUM enum Polarisation {
    BDA_POLARISATION_NOT_SET = -1,
    BDA_POLARISATION_NOT_DEFINED = 0,
    BDA_POLARISATION_LINEAR_H = 1, // Linear horizontal polarisation
    BDA_POLARISATION_LINEAR_V, // Linear vertical polarisation
    BDA_POLARISATION_CIRCULAR_L, // Circular left polarisation
    BDA_POLARISATION_CIRCULAR_R, // Circular right polarisation
    BDA_POLARISATION_MAX,
} Polarisation;

typedef V1_ENUM enum GuardInterval {
    BDA_GUARD_NOT_SET = -1,
    BDA_GUARD_NOT_DEFINED = 0,
    BDA_GUARD_1_32 = 1, // Guard interval is 1/32
    BDA_GUARD_1_16, // Guard interval is 1/16
    BDA_GUARD_1_8, // Guard interval is 1/8
    BDA_GUARD_1_4, // Guard interval is 1/4
    BDA_GUARD_MAX,
} GuardInterval;

typedef V1_ENUM enum HierarchyAlpha {
    BDA_HALPHA_NOT_SET = -1,
    BDA_HALPHA_NOT_DEFINED = 0,
    BDA_HALPHA_1 = 1, // Hierarchy alpha is 1.
    BDA_HALPHA_2, // Hierarchy alpha is 2.
    BDA_HALPHA_4, // Hierarchy alpha is 4.
    BDA_HALPHA_MAX,
} HierarchyAlpha;

typedef V1_ENUM enum TransmissionMode {
    BDA_XMIT_MODE_NOT_SET = -1,
    BDA_XMIT_MODE_NOT_DEFINED = 0,
    BDA_XMIT_MODE_2K = 1, // Transmission uses 1705 carriers (use a 2K FFT)
    BDA_XMIT_MODE_8K, // Transmission uses 6817 carriers (use an 8K FFT)
    BDA_XMIT_MODE_MAX,
} TransmissionMode;

//  Settings for Tuner Frequency
//
#define BDA_FREQUENCY_NOT_SET       -1
#define BDA_FREQUENCY_NOT_DEFINED   0

//  Settings for Tuner Range
//
//  Tuner range refers to the setting of LNB High/Low as well as the
//  selection of a satellite on a multiple satellite switch.
//
#define BDA_RANGE_NOT_SET       -1
#define BDA_RANGE_NOT_DEFINED   0

//  Settings for Tuner Channel Bandwidth
//
#define BDA_CHAN_BANDWITH_NOT_SET       -1
#define BDA_CHAN_BANDWITH_NOT_DEFINED   0

//  Settings for Tuner Frequency Multiplier
//
#define BDA_FREQUENCY_MULTIPLIER_NOT_SET        -1
#define BDA_FREQUENCY_MULTIPLIER_NOT_DEFINED    0 

#endif // not defined _BDATYPES_

// end of file -- bdatypes.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\include\aviriff.h ===
//------------------------------------------------------------------------------
// File: AVIRIFF.h
//
// Desc: Structures and defines for the RIFF AVI file format extended to
//       handle very large/long files.
//
// Copyright (c) 1996 - 2000, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#pragma warning(disable: 4097 4511 4512 4514 4705)


#if !defined AVIRIFF_H
#define AVIRIFF_H

#if !defined NUMELMS
  #define NUMELMS(aa) (sizeof(aa)/sizeof((aa)[0]))
#endif

// all structures in this file are packed on word boundaries
//
#include <pshpack2.h>

/*
 * heres the general layout of an AVI riff file (new format)
 *
 * RIFF (3F??????) AVI       <- not more than 1 GB in size
 *     LIST (size) hdrl
 *         avih (0038)
 *         LIST (size) strl
 *             strh (0038)
 *             strf (????)
 *             indx (3ff8)   <- size may vary, should be sector sized
 *         LIST (size) strl
 *             strh (0038)
 *             strf (????)
 *             indx (3ff8)   <- size may vary, should be sector sized
 *         LIST (size) odml
 *             dmlh (????)
 *         JUNK (size)       <- fill to align to sector - 12
 *     LIST (7f??????) movi  <- aligned on sector - 12
 *         00dc (size)       <- sector aligned
 *         01wb (size)       <- sector aligned
 *         ix00 (size)       <- sector aligned
 *     idx1 (00??????)       <- sector aligned
 * RIFF (7F??????) AVIX
 *     JUNK (size)           <- fill to align to sector -12
 *     LIST (size) movi
 *         00dc (size)       <- sector aligned
 * RIFF (7F??????) AVIX      <- not more than 2GB in size
 *     JUNK (size)           <- fill to align to sector - 12
 *     LIST (size) movi
 *         00dc (size)       <- sector aligned
 *
 *-===================================================================*/

//
// structures for manipulating RIFF headers
//
#define FCC(ch4) ((((DWORD)(ch4) & 0xFF) << 24) |     \
                  (((DWORD)(ch4) & 0xFF00) << 8) |    \
                  (((DWORD)(ch4) & 0xFF0000) >> 8) |  \
                  (((DWORD)(ch4) & 0xFF000000) >> 24))

typedef struct _riffchunk {
   FOURCC fcc;
   DWORD  cb;
   } RIFFCHUNK, * LPRIFFCHUNK;
typedef struct _rifflist {
   FOURCC fcc;
   DWORD  cb;
   FOURCC fccListType;
   } RIFFLIST, * LPRIFFLIST;

#define RIFFROUND(cb) ((cb) + ((cb)&1))
#define RIFFNEXT(pChunk) (LPRIFFCHUNK)((LPBYTE)(pChunk) \
                          + sizeof(RIFFCHUNK) \
                          + RIFFROUND(((LPRIFFCHUNK)pChunk)->cb))


//
// ==================== avi header structures ===========================
//

// main header for the avi file (compatibility header)
//
#define ckidMAINAVIHEADER FCC('avih')
typedef struct _avimainheader {
    FOURCC fcc;                    // 'avih'
    DWORD  cb;                     // size of this structure -8
    DWORD  dwMicroSecPerFrame;     // frame display rate (or 0L)
    DWORD  dwMaxBytesPerSec;       // max. transfer rate
    DWORD  dwPaddingGranularity;   // pad to multiples of this size; normally 2K.
    DWORD  dwFlags;                // the ever-present flags
    #define AVIF_HASINDEX        0x00000010 // Index at end of file?
    #define AVIF_MUSTUSEINDEX    0x00000020
    #define AVIF_ISINTERLEAVED   0x00000100
    #define AVIF_TRUSTCKTYPE     0x00000800 // Use CKType to find key frames
    #define AVIF_WASCAPTUREFILE  0x00010000
    #define AVIF_COPYRIGHTED     0x00020000
    DWORD  dwTotalFrames;          // # frames in first movi list
    DWORD  dwInitialFrames;
    DWORD  dwStreams;
    DWORD  dwSuggestedBufferSize;
    DWORD  dwWidth;
    DWORD  dwHeight;
    DWORD  dwReserved[4];
    } AVIMAINHEADER;

#define ckidODML          FCC('odml')
#define ckidAVIEXTHEADER  FCC('dmlh')
typedef struct _aviextheader {
   FOURCC  fcc;                    // 'dmlh'
   DWORD   cb;                     // size of this structure -8
   DWORD   dwGrandFrames;          // total number of frames in the file
   DWORD   dwFuture[61];           // to be defined later
   } AVIEXTHEADER;

//
// structure of an AVI stream header riff chunk
//
#define ckidSTREAMLIST   FCC('strl')

#ifndef ckidSTREAMHEADER
#define ckidSTREAMHEADER FCC('strh')
#endif
typedef struct _avistreamheader {
   FOURCC fcc;          // 'strh'
   DWORD  cb;           // size of this structure - 8

   FOURCC fccType;      // stream type codes

   #ifndef streamtypeVIDEO
   #define streamtypeVIDEO FCC('vids')
   #define streamtypeAUDIO FCC('auds')
   #define streamtypeMIDI  FCC('mids')
   #define streamtypeTEXT  FCC('txts')
   #endif

   FOURCC fccHandler;
   DWORD  dwFlags;
   #define AVISF_DISABLED          0x00000001
   #define AVISF_VIDEO_PALCHANGES  0x00010000

   WORD   wPriority;
   WORD   wLanguage;
   DWORD  dwInitialFrames;
   DWORD  dwScale;
   DWORD  dwRate;       // dwRate/dwScale is stream tick rate in ticks/sec
   DWORD  dwStart;
   DWORD  dwLength;
   DWORD  dwSuggestedBufferSize;
   DWORD  dwQuality;
   DWORD  dwSampleSize;
   struct {
      short int left;
      short int top;
      short int right;
      short int bottom;
      }   rcFrame;
   } AVISTREAMHEADER;


//
// structure of an AVI stream format chunk
//
#ifndef ckidSTREAMFORMAT
#define ckidSTREAMFORMAT FCC('strf')
#endif
//
// avi stream formats are different for each stream type
//
// BITMAPINFOHEADER for video streams
// WAVEFORMATEX or PCMWAVEFORMAT for audio streams
// nothing for text streams
// nothing for midi streams


#pragma warning(disable:4200)
//
// structure of old style AVI index
//
#define ckidAVIOLDINDEX FCC('idx1')
typedef struct _avioldindex {
   FOURCC  fcc;        // 'idx1'
   DWORD   cb;         // size of this structure -8
   struct _avioldindex_entry {
      DWORD   dwChunkId;
      DWORD   dwFlags;

      #ifndef AVIIF_LIST
      #define AVIIF_LIST       0x00000001
      #define AVIIF_KEYFRAME   0x00000010
      #endif
     
      #define AVIIF_NO_TIME    0x00000100
      #define AVIIF_COMPRESSOR 0x0FFF0000  // unused?
      DWORD   dwOffset;    // offset of riff chunk header for the data
      DWORD   dwSize;      // size of the data (excluding riff header size)
      } aIndex[];          // size of this array
   } AVIOLDINDEX;


//
// ============ structures for timecode in an AVI file =================
//

#ifndef TIMECODE_DEFINED
#define TIMECODE_DEFINED

// defined
// timecode time structure
//
typedef union _timecode {
   struct {
      WORD   wFrameRate;
      WORD   wFrameFract;
      LONG   cFrames;
      };
   DWORDLONG  qw;
   } TIMECODE;

#endif // TIMECODE_DEFINED

#define TIMECODE_RATE_30DROP 0   // this MUST be zero

// struct for all the SMPTE timecode info
//
typedef struct _timecodedata {
   TIMECODE time;
   DWORD    dwSMPTEflags;
   DWORD    dwUser;
   } TIMECODEDATA;

// dwSMPTEflags masks/values
//
#define TIMECODE_SMPTE_BINARY_GROUP 0x07
#define TIMECODE_SMPTE_COLOR_FRAME  0x08

//
// ============ structures for new style AVI indexes =================
//

// index type codes
//
#define AVI_INDEX_OF_INDEXES       0x00
#define AVI_INDEX_OF_CHUNKS        0x01
#define AVI_INDEX_OF_TIMED_CHUNKS  0x02
#define AVI_INDEX_OF_SUB_2FIELD    0x03
#define AVI_INDEX_IS_DATA          0x80

// index subtype codes
//
#define AVI_INDEX_SUB_DEFAULT     0x00

// INDEX_OF_CHUNKS subtype codes
//
#define AVI_INDEX_SUB_2FIELD      0x01

// meta structure of all avi indexes
//
typedef struct _avimetaindex {
   FOURCC fcc;
   UINT   cb;
   WORD   wLongsPerEntry;
   BYTE   bIndexSubType;
   BYTE   bIndexType;
   DWORD  nEntriesInUse;
   DWORD  dwChunkId;
   DWORD  dwReserved[3];
   DWORD  adwIndex[];
   } AVIMETAINDEX;

#define STDINDEXSIZE 0x4000
#define NUMINDEX(wLongsPerEntry) ((STDINDEXSIZE-32)/4/(wLongsPerEntry))
#define NUMINDEXFILL(wLongsPerEntry) ((STDINDEXSIZE/4) - NUMINDEX(wLongsPerEntry))

// structure of a super index (INDEX_OF_INDEXES)
//
#define ckidAVISUPERINDEX FCC('indx')
typedef struct _avisuperindex {
   FOURCC   fcc;               // 'indx'
   UINT     cb;                // size of this structure
   WORD     wLongsPerEntry;    // ==4
   BYTE     bIndexSubType;     // ==0 (frame index) or AVI_INDEX_SUB_2FIELD 
   BYTE     bIndexType;        // ==AVI_INDEX_OF_INDEXES
   DWORD    nEntriesInUse;     // offset of next unused entry in aIndex
   DWORD    dwChunkId;         // chunk ID of chunks being indexed, (i.e. RGB8)
   DWORD    dwReserved[3];     // must be 0
   struct _avisuperindex_entry {
      DWORDLONG qwOffset;    // 64 bit offset to sub index chunk
      DWORD    dwSize;       // 32 bit size of sub index chunk
      DWORD    dwDuration;   // time span of subindex chunk (in stream ticks)
      } aIndex[NUMINDEX(4)];
   } AVISUPERINDEX;
#define Valid_SUPERINDEX(pi) (*(DWORD *)(&((pi)->wLongsPerEntry)) == (4 | (AVI_INDEX_OF_INDEXES << 24)))

// struct of a standard index (AVI_INDEX_OF_CHUNKS)
//
typedef struct _avistdindex_entry {
   DWORD dwOffset;       // 32 bit offset to data (points to data, not riff header)
   DWORD dwSize;         // 31 bit size of data (does not include size of riff header), bit 31 is deltaframe bit
   } AVISTDINDEX_ENTRY;
#define AVISTDINDEX_DELTAFRAME ( 0x80000000) // Delta frames have the high bit set
#define AVISTDINDEX_SIZEMASK   (~0x80000000)

typedef struct _avistdindex {
   FOURCC   fcc;               // 'indx' or '##ix'
   UINT     cb;                // size of this structure
   WORD     wLongsPerEntry;    // ==2
   BYTE     bIndexSubType;     // ==0
   BYTE     bIndexType;        // ==AVI_INDEX_OF_CHUNKS
   DWORD    nEntriesInUse;     // offset of next unused entry in aIndex
   DWORD    dwChunkId;         // chunk ID of chunks being indexed, (i.e. RGB8)
   DWORDLONG qwBaseOffset;     // base offset that all index intries are relative to
   DWORD    dwReserved_3;      // must be 0
   AVISTDINDEX_ENTRY aIndex[NUMINDEX(2)];
   } AVISTDINDEX;

// struct of a time variant standard index (AVI_INDEX_OF_TIMED_CHUNKS)
//
typedef struct _avitimedindex_entry {
   DWORD dwOffset;       // 32 bit offset to data (points to data, not riff header)
   DWORD dwSize;         // 31 bit size of data (does not include size of riff header) (high bit is deltaframe bit)
   DWORD dwDuration;     // how much time the chunk should be played (in stream ticks)
   } AVITIMEDINDEX_ENTRY;

typedef struct _avitimedindex {
   FOURCC   fcc;               // 'indx' or '##ix'
   UINT     cb;                // size of this structure
   WORD     wLongsPerEntry;    // ==3
   BYTE     bIndexSubType;     // ==0
   BYTE     bIndexType;        // ==AVI_INDEX_OF_TIMED_CHUNKS
   DWORD    nEntriesInUse;     // offset of next unused entry in aIndex
   DWORD    dwChunkId;         // chunk ID of chunks being indexed, (i.e. RGB8)
   DWORDLONG qwBaseOffset;     // base offset that all index intries are relative to
   DWORD    dwReserved_3;      // must be 0
   AVITIMEDINDEX_ENTRY aIndex[NUMINDEX(3)];
   DWORD adwTrailingFill[NUMINDEXFILL(3)]; // to align struct to correct size
   } AVITIMEDINDEX;

// structure of a timecode stream
//
typedef struct _avitimecodeindex {
   FOURCC   fcc;               // 'indx' or '##ix'
   UINT     cb;                // size of this structure
   WORD     wLongsPerEntry;    // ==4
   BYTE     bIndexSubType;     // ==0
   BYTE     bIndexType;        // ==AVI_INDEX_IS_DATA
   DWORD    nEntriesInUse;     // offset of next unused entry in aIndex
   DWORD    dwChunkId;         // 'time'
   DWORD    dwReserved[3];     // must be 0
   TIMECODEDATA aIndex[NUMINDEX(sizeof(TIMECODEDATA)/sizeof(LONG))];
   } AVITIMECODEINDEX;

// structure of a timecode discontinuity list (when wLongsPerEntry == 7)
//
typedef struct _avitcdlindex_entry {
    DWORD    dwTick;           // stream tick time that maps to this timecode value
    TIMECODE time;
    DWORD    dwSMPTEflags;
    DWORD    dwUser;
    TCHAR    szReelId[12];
    } AVITCDLINDEX_ENTRY;

typedef struct _avitcdlindex {
   FOURCC   fcc;               // 'indx' or '##ix'
   UINT     cb;                // size of this structure
   WORD     wLongsPerEntry;    // ==7 (must be 4 or more all 'tcdl' indexes
   BYTE     bIndexSubType;     // ==0
   BYTE     bIndexType;        // ==AVI_INDEX_IS_DATA
   DWORD    nEntriesInUse;     // offset of next unused entry in aIndex
   DWORD    dwChunkId;         // 'tcdl'
   DWORD    dwReserved[3];     // must be 0
   AVITCDLINDEX_ENTRY aIndex[NUMINDEX(7)];
   DWORD adwTrailingFill[NUMINDEXFILL(7)]; // to align struct to correct size
   } AVITCDLINDEX;

typedef struct _avifieldindex_chunk {
   FOURCC   fcc;               // 'ix##'
   DWORD    cb;                // size of this structure
   WORD     wLongsPerEntry;    // must be 3 (size of each entry in
                               // aIndex array)
   BYTE     bIndexSubType;     // AVI_INDEX_2FIELD
   BYTE     bIndexType;        // AVI_INDEX_OF_CHUNKS
   DWORD    nEntriesInUse;     //
   DWORD    dwChunkId;         // '##dc' or '##db'
   DWORDLONG qwBaseOffset;     // offsets in aIndex array are relative to this
   DWORD    dwReserved3;       // must be 0
   struct _avifieldindex_entry {
      DWORD    dwOffset;
      DWORD    dwSize;         // size of all fields
                               // (bit 31 set for NON-keyframes)
      DWORD    dwOffsetField2; // offset to second field
   } aIndex[  ];
} AVIFIELDINDEX, * PAVIFIELDINDEX;


#include <poppack.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\include\dvdevcod.h ===
//------------------------------------------------------------------------------
// File: DVDevCod.h
//
// Desc: List of standard DVD-Video event codes and the expected params.
//
// Copyright (c) 1992 - 2000, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------

#ifndef __DVDEVCOD__
#define __DVDEVCOD__


#define EC_DVDBASE                          0x0100

#ifndef EXCLUDE_DVDEVCODE_ENUMS

typedef enum _tagDVD_ERROR {
    DVD_ERROR_Unexpected=1,         // Something unexpected happened, perhaps content
                                    //   is incorrectly authored.  Playback is stopped.
    DVD_ERROR_CopyProtectFail=2,    // Key exchange for DVD copy protection failed. 
                                    //   Playback is stopped.
    DVD_ERROR_InvalidDVD1_0Disc=3,  // DVD-Video disc is incorrectly authored for v1.0 
                                    //   of spec. Playback is stopped.
    DVD_ERROR_InvalidDiscRegion=4,  // The Disc cannot be played because the disc is not
                                    // authored to play in system region.
                                    // The region mismatch may be fixable by 
                                    // changing the system region with dvdrgn.exe
    DVD_ERROR_LowParentalLevel=5,   // Player parental level is lower than the lowest parental
                                    //   level available in the DVD content. Playback is stopped.
    DVD_ERROR_MacrovisionFail=6,    // Macrovision Distribution Failed.
                                    // Playback is stopped.
    DVD_ERROR_IncompatibleSystemAndDecoderRegions=7,
                                    // No discs can be played because the system region
                                    // does not match the decoder region.
    DVD_ERROR_IncompatibleDiscAndDecoderRegions=8
                                    // The disc cannot be played because the disc is
                                    // not authored to be played in the decoder's region
} DVD_ERROR;

typedef enum _tagDVD_WARNING {
    DVD_WARNING_InvalidDVD1_0Disc=1,// DVD-Video disc is incorrectly authored. Playback
                                    //   can continue, but unexpected behavior may occur.
    DVD_WARNING_FormatNotSupported=2,// A decoder would not support the current format.  Playback
                                    //   of a stream (audio, video of SP) may not function.
                                    //   lParam2 contains the stream type (see AM_DVD_STREAM_FLAGS)
    DVD_WARNING_IllegalNavCommand=3,// The internal DVD navigation command processor attempted to 
                                    //   process an illegal command.
    DVD_WARNING_Open = 4,           // File Open Failed
    DVD_WARNING_Seek = 5,           // File Seek Failed
    DVD_WARNING_Read = 6            // File Read Failed
} DVD_WARNING;

typedef enum _tagDVD_PB_STOPPED {
    DVD_PB_STOPPED_Other=0,                 // The navigator stopped the playback (no reason available).
    DVD_PB_STOPPED_NoBranch=1,              // The nav completed the current pgc and there was no more video and
                                            // did not find any other branching instruction for subsequent playback.
    DVD_PB_STOPPED_NoFirstPlayDomain =2,    // The disc does not contain an initial startup program.
    DVD_PB_STOPPED_StopCommand = 3,         // The app issued a stop() command or a stop command was authored on the disc.
    DVD_PB_STOPPED_Reset=4,                 // The navigator was reset to the start of the disc (using ResetOnStop).
    DVD_PB_STOPPED_DiscEjected=5,           // The disc was ejected.
    DVD_PB_STOPPED_IllegalNavCommand = 6,   // An illegal nav command prevented playback from continuing.
    DVD_PB_STOPPED_PlayPeriodAutoStop = 7,  // PlayPeriod completed
    DVD_PB_STOPPED_PlayChapterAutoStop = 8, // PlayChapter completed
    DVD_PB_STOPPED_ParentalFailure = 9,     // A parental level failure prevented playback
    DVD_PB_STOPPED_RegionFailure = 10,      // A region failure prevented playback
    DVD_PB_STOPPED_MacrovisionFailure = 11, // A Macrovision failure prevented playback.
    DVD_PB_STOPPED_DiscReadError = 12,      // A read error prevented playback.
    DVD_PB_STOPPED_CopyProtectFailure = 13  // Copy protection failure.
} DVD_PB_STOPPED;


#endif

// DVD-Video event codes
// ======================
//
// All DVD-Video event are always passed on to the application, and are 
// never processed by the filter graph


#define EC_DVD_DOMAIN_CHANGE                    (EC_DVDBASE + 0x01)
// Parameters: ( DWORD, void ) 
// lParam1 is enum DVD_DOMAIN, and indicates the player's new domain
//
// Raised from following domains: all
//
// Signaled when ever the DVD player changes domains.


#define EC_DVD_TITLE_CHANGE                     (EC_DVDBASE + 0x02)
// Parameters: ( DWORD, void ) 
// lParam1 is the new title number.
//
// Raised from following domains: DVD_DOMAIN_Title
//
// Indicates when the current title number changes.  Title numbers
// range 1 to 99.  This indicates the TTN, which is the title number
// with respect to the whole disc, not the VTS_TTN which is the title
// number with respect to just a current VTS.


#define EC_DVD_CHAPTER_START                   (EC_DVDBASE + 0x03)
// Parameters: ( DWORD, void ) 
// lParam1 is the new chapter number (which is the program number for 
// One_Sequential_PGC_Titles).
//
// Raised from following domains: DVD_DOMAIN_Title
//
// Signales that DVD player started playback of a new program in the Title 
// domain.  This is only signaled for One_Sequential_PGC_Titles.


#define EC_DVD_AUDIO_STREAM_CHANGE              (EC_DVDBASE + 0x04)
// Parameters: ( DWORD, void ) 
// lParam1 is the new user audio stream number.
//
// Raised from following domains: all
//
// Signaled when ever the current user audio stream number changes for the main 
// title.  This can be changed automatically with a navigation command on disc
// as well as through IDVDAnnexJ.
// Audio stream numbers range from 0 to 7.  Stream 0xffffffff
// indicates that no stream is selected.

#define EC_DVD_SUBPICTURE_STREAM_CHANGE         (EC_DVDBASE + 0x05)
// Parameters: ( DWORD, BOOL ) 
// lParam1 is the new user subpicture stream number.
// lParam2 is the subpicture's on/off state (TRUE if on)
//
// Raised from following domains: all
//
// Signaled when ever the current user subpicture stream number changes for the main 
// title.  This can be changed automatically with a navigation command on disc
// as well as through IDVDAnnexJ.  
// Subpicture stream numbers range from 0 to 31.  Stream 0xffffffff
// indicates that no stream is selected.  

#define EC_DVD_ANGLE_CHANGE                     (EC_DVDBASE + 0x06)
// Parameters: ( DWORD, DWORD ) 
// lParam1 is the number of available angles.
// lParam2 is the current user angle number.
//
// Raised from following domains: all
//
// Signaled when ever either 
//   a) the number of available angles changes, or  
//   b) the current user angle number changes.
// Current angle number can be changed automatically with navigation command 
// on disc as well as through IDVDAnnexJ.
// When the number of available angles is 1, the current video is not multiangle.
// Angle numbers range from 1 to 9.


#define EC_DVD_BUTTON_CHANGE                    (EC_DVDBASE + 0x07)
// Parameters: ( DWORD, DWORD ) 
// lParam1 is the number of available buttons.
// lParam2 is the current selected button number.
//
// Raised from following domains: all
//
// Signaled when ever either 
//   a) the number of available buttons changes, or  
//   b) the current selected button number changes.
// The current selected button can be changed automatically with navigation 
// commands on disc as well as through IDVDAnnexJ.  
// Button numbers range from 1 to 36.  Selected button number 0 implies that
// no button is selected.  Note that these button numbers enumerate all 
// available button numbers, and do not always correspond to button numbers
// used for IDVDAnnexJ::ButtonSelectAndActivate since only a subset of buttons
// may be activated with ButtonSelectAndActivate.


#define EC_DVD_VALID_UOPS_CHANGE                (EC_DVDBASE + 0x08)
// Parameters: ( DWORD, void ) 
// lParam1 is a VALID_UOP_SOMTHING_OR_OTHER bit-field stuct which indicates
//   which IDVDAnnexJ commands are explicitly disable by the DVD disc.
//
// Raised from following domains: all
//
// Signaled when ever the available set of IDVDAnnexJ methods changes.  This
// only indicates which operations are explicited disabled by the content on 
// the DVD disc, and does not guarentee that it is valid to call methods 
// which are not disabled.  For example, if no buttons are currently present,
// IDVDAnnexJ::ButtonActivate() won't work, even though the buttons are not
// explicitly disabled. 


#define EC_DVD_STILL_ON                         (EC_DVDBASE + 0x09)
// Parameters: ( BOOL, DWORD ) 
// lParam1 == 0  -->  buttons are available, so StillOff won't work
// lParam1 == 1  -->  no buttons available, so StillOff will work
// lParam2 indicates the number of seconds the still will last, with 0xffffffff 
//   indicating an infinite still (wait till button or StillOff selected).
//
// Raised from following domains: all
//
// Signaled at the beginning of any still: PGC still, Cell Still, or VOBU Still.
// Note that all combinations of buttons and still are possible (buttons on with
// still on, buttons on with still off, button off with still on, button off
// with still off).

#define EC_DVD_STILL_OFF                         (EC_DVDBASE + 0x0a)
// Parameters: ( void, void ) 
//
//   Indicating that any still that is currently active
//   has been released.
//
// Raised from following domains: all
//
// Signaled at the end of any still: PGC still, Cell Still, or VOBU Still.
//

#define EC_DVD_CURRENT_TIME                     (EC_DVDBASE + 0x0b)
// Parameters: ( DWORD, BOOL ) 
// lParam1 is a DVD_TIMECODE which indicates the current 
//   playback time code in a BCD HH:MM:SS:FF format.
// lParam2 == 0  -->  time code is 25 frames/sec
// lParam2 == 1  -->  time code is 30 frames/sec (non-drop).
// lParam2 == 2  -->  time code is invalid (current playback time 
//                    cannot be determined for current title)
//
// Raised from following domains: DVD_DOMAIN_Title
//
// Signaled at the beginning of every VOBU, which occurs every .4 to 1.0 sec.
// This is only signaled for One_Sequential_PGC_Titles.


#define EC_DVD_ERROR                            (EC_DVDBASE + 0x0c)
// Parameters: ( DWORD, void) 
// lParam1 is an enum DVD_ERROR which notifies the app of some error condition.
//
// Raised from following domains: all
//

#define EC_DVD_WARNING                           (EC_DVDBASE + 0x0d)
// Parameters: ( DWORD, DWORD) 
// lParam1 is an enum DVD_WARNING which notifies the app of some warning condition.
// lParam2 contains more specific information about the warning (warning dependent)
//
// Raised from following domains: all
//

#define EC_DVD_CHAPTER_AUTOSTOP                  (EC_DVDBASE + 0x0e)
// Parameters: (BOOL, void)
// lParam1 is a BOOL which indicates the reason for the cancellation of ChapterPlayAutoStop
// lParam1 == 0 indicates successful completion of ChapterPlayAutoStop
// lParam1 == 1 indicates that ChapterPlayAutoStop is being cancelled as a result of another
//            IDVDControl call or the end of content has been reached & no more chapters
//            can be played.
//  Indicating that playback is stopped as a result of a call
//  to IDVDControl::ChapterPlayAutoStop()
//
// Raised from following domains : DVD_DOMAIN_TITLE
//

#define EC_DVD_NO_FP_PGC                         (EC_DVDBASE + 0x0f)
//  Parameters : (void, void)
//
//  Raised from the following domains : FP_DOM
//
//  Indicates that the DVD disc does not have a FP_PGC (First Play Program Chain)
//  and the DVD Navigator will not automatically load any PGC and start playback.
//

#define EC_DVD_PLAYBACK_RATE_CHANGE              (EC_DVDBASE + 0x10)
//  Parameters : (LONG, void)
//  lParam1 is a LONG indicating the new playback rate.
//  lParam1 < 0 indicates reverse playback mode.
//  lParam1 > 0 indicates forward playback mode
//  Value of lParam1 is the actual playback rate multiplied by 10000.
//  i.e. lParam1 = rate * 10000
//
//  Raised from the following domains : TT_DOM
//
//  Indicates that a rate change in playback has been initiated and the parameter
//  lParam1 indicates the new playback rate that is being used.
//

#define EC_DVD_PARENTAL_LEVEL_CHANGE            (EC_DVDBASE + 0x11)
//  Parameters : (LONG, void)
//  lParam1 is a LONG indicating the new parental level.
//
//  Raised from the following domains : VMGM_DOM
//
//  Indicates that an authored Nav command has changed the parental level
//  setting in the player.
//

#define EC_DVD_PLAYBACK_STOPPED                 (EC_DVDBASE + 0x12)
//  Parameters : (DWORD, void)
//
//  Raised from the following domains : All Domains
//
// Indicates that playback has been stopped as the Navigator has completed
// playback of the pgc and did not find any other branching instruction for
// subsequent playback.
//
//  The DWORD returns the reason for the completion of the playback.  See
//  The DVD_PB_STOPPED enumeration for details.
//

#define EC_DVD_ANGLES_AVAILABLE                 (EC_DVDBASE + 0x13)
//  Parameters : (BOOL, void)
//  lParam1 == 0 indicates that playback is not in an angle block and angles are
//             not available
//  lParam1 == 1 indicates that an angle block is being played back and angle changes
//             can be performed.
//
//  Indicates whether an angle block is being played and if angle changes can be 
//  performed. However, angle changes are not restricted to angle blocks and the
//  manifestation of the angle change can be seen only in an angle block.

#define EC_DVD_PLAYPERIOD_AUTOSTOP              (EC_DVDBASE + 0x14)
// Parameters: (void, void)
// Sent when the PlayPeriodInTitle completes or is cancelled
//
// Raised from following domains : DVD_DOMAIN_TITLE
//

#define EC_DVD_BUTTON_AUTO_ACTIVATED                 (EC_DVDBASE + 0x15)
// Parameters: (DWORD button, void)
// Sent when a button is automatically activated
//
// Raised from following domains : DVD_DOMAIN_MENU
//

#define EC_DVD_CMD_START                 (EC_DVDBASE + 0x16)
// Parameters: (CmdID, HRESULT)
// Sent when a command begins
//

#define EC_DVD_CMD_END                 (EC_DVDBASE + 0x17)
// Parameters: (CmdID, HRESULT)
// Sent when a command completes
//

#define EC_DVD_DISC_EJECTED                (EC_DVDBASE + 0x18)
// Parameters: none
// Sent when the nav detects that a disc was ejected and stops the playback
// The app does not need to take any action to stop the playback.
//

#define EC_DVD_DISC_INSERTED                (EC_DVDBASE + 0x19)
// Parameters: none
// Sent when the nav detects that a disc was inserted and the nav begins playback
// The app does not need to take any action to start the playback.
//

#define EC_DVD_CURRENT_HMSF_TIME                     (EC_DVDBASE + 0x1a)
// Parameters: ( ULONG, ULONG ) 
// lParam2 contains a union of the DVD_TIMECODE_FLAGS
// lParam1 contains a DVD_HMSF_TIMECODE.  Assign lParam1 to a ULONG then cast the
// ULONG as a DVD_HMSF_TIMECODE to use its values.
//
// Raised from following domains: DVD_DOMAIN_Title
//
// Signaled at the beginning of every VOBU, which occurs every .4 to 1.0 sec.

#define EC_DVD_KARAOKE_MODE                     (EC_DVDBASE + 0x1b)
// Parameters: ( BOOL, reserved ) 
// lParam1 is either TRUE (a karaoke track is being played) or FALSE (no karaoke data is being played).
//
#endif // __DVDEVCOD__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\include\dxva.h ===
//------------------------------------------------------------------------------
// File: DXVA.h
//
// Desc: DirectX Video Acceleration header file.
//
// Copyright (c) 1999 - 2002, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __DIRECTX_VA__
#define __DIRECTX_VA__

#ifdef __cplusplus
extern "C" {
#endif

DEFINE_GUID(DXVA_ModeNone,    0x1b81be00, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH261_A,  0x1b81be01, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH261_B,  0x1b81be02, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);

DEFINE_GUID(DXVA_ModeH263_A,  0x1b81be03, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH263_B,  0x1b81be04, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH263_C,  0x1b81be05, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH263_D,  0x1b81be06, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH263_E,  0x1b81be07, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH263_F,  0x1b81be08, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);

DEFINE_GUID(DXVA_ModeMPEG1_A, 0x1b81be09, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);

DEFINE_GUID(DXVA_ModeMPEG2_A, 0x1b81be0A, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeMPEG2_B, 0x1b81be0B, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeMPEG2_C, 0x1b81be0C, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeMPEG2_D, 0x1b81be0D, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeMPEG2_E, 0x1b81be0E, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);

DEFINE_GUID(DXVA_ModeWMV8_A,  0x1b81be80, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeWMV8_B,  0x1b81be81, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);

DEFINE_GUID(DXVA_ModeWMV9_A,  0x1b81be90, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeWMV9_B,  0x1b81be91, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeWMV9_Ai, 0x1b81be92, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeWMV9_Bi, 0x1b81be93, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);


DEFINE_GUID(DXVA_NoEncrypt,   0x1b81beD0, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);

#define DXVA_RESTRICTED_MODE_UNRESTRICTED        0xFFFF
#define DXVA_RESTRICTED_MODE_H261_A              1
#define DXVA_RESTRICTED_MODE_H261_B              2

#define DXVA_RESTRICTED_MODE_H263_A              3
#define DXVA_RESTRICTED_MODE_H263_B              4
#define DXVA_RESTRICTED_MODE_H263_C              5
#define DXVA_RESTRICTED_MODE_H263_D              6
#define DXVA_RESTRICTED_MODE_H263_E              7
#define DXVA_RESTRICTED_MODE_H263_F              8

#define DXVA_RESTRICTED_MODE_MPEG1_A             9

#define DXVA_RESTRICTED_MODE_MPEG2_A             0xA
#define DXVA_RESTRICTED_MODE_MPEG2_B             0xB
#define DXVA_RESTRICTED_MODE_MPEG2_C             0xC
#define DXVA_RESTRICTED_MODE_MPEG2_D             0xD
#define DXVA_RESTRICTED_MODE_MPEG2_E             0xE

#define DXVA_RESTRICTED_MODE_WMV8_A              0x80
#define DXVA_RESTRICTED_MODE_WMV8_B              0x81

#define DXVA_RESTRICTED_MODE_WMV9_A              0x90
#define DXVA_RESTRICTED_MODE_WMV9_B              0x91
#define DXVA_RESTRICTED_MODE_WMV9_Ai             0x92
#define DXVA_RESTRICTED_MODE_WMV9_Bi             0x93


#define DXVA_COMPBUFFER_TYPE_THAT_IS_NOT_USED    0
#define DXVA_PICTURE_DECODE_BUFFER               1
#define DXVA_MACROBLOCK_CONTROL_BUFFER           2
#define DXVA_RESIDUAL_DIFFERENCE_BUFFER          3
#define DXVA_DEBLOCKING_CONTROL_BUFFER           4
#define DXVA_INVERSE_QUANTIZATION_MATRIX_BUFFER  5
#define DXVA_SLICE_CONTROL_BUFFER                6
#define DXVA_BITSTREAM_DATA_BUFFER               7
#define DXVA_AYUV_BUFFER                         8
#define DXVA_IA44_SURFACE_BUFFER                 9
#define DXVA_DPXD_SURFACE_BUFFER                10
#define DXVA_HIGHLIGHT_BUFFER                   11
#define DXVA_DCCMD_SURFACE_BUFFER               12
#define DXVA_ALPHA_BLEND_COMBINATION_BUFFER     13
#define DXVA_PICTURE_RESAMPLE_BUFFER            14
#define DXVA_READ_BACK_BUFFER                   15

#define DXVA_NUM_TYPES_COMP_BUFFERS             16

/* values for bDXVA_Func */
#define DXVA_PICTURE_DECODING_FUNCTION        1
#define DXVA_ALPHA_BLEND_DATA_LOAD_FUNCTION   2
#define DXVA_ALPHA_BLEND_COMBINATION_FUNCTION 3
#define DXVA_PICTURE_RESAMPLE_FUNCTION        4

/* values returned from Execute command in absence of read-back */
#define DXVA_EXECUTE_RETURN_OK                  0
#define DXVA_EXECUTE_RETURN_DATA_ERROR_MINOR    1
#define DXVA_EXECUTE_RETURN_DATA_ERROR_SIGNIF   2
#define DXVA_EXECUTE_RETURN_DATA_ERROR_SEVERE   3
#define DXVA_EXECUTE_RETURN_OTHER_ERROR_SEVERE  4


#pragma pack(push, BeforeDXVApacking, 1)


typedef struct _DXVA_ConnectMode {
  GUID guidMode;
  WORD wRestrictedMode;
} DXVA_ConnectMode, *LPDXVA_ConnectMode;


typedef DWORD DXVA_ConfigQueryOrReplyFunc, *LPDXVA_ConfigQueryOrReplyFunc;

#define DXVA_QUERYORREPLYFUNCFLAG_DECODER_PROBE_QUERY     0xFFFFF1
#define DXVA_QUERYORREPLYFUNCFLAG_DECODER_LOCK_QUERY      0xFFFFF5
#define DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_OK_COPY     0xFFFFF8
#define DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_OK_PLUS     0xFFFFF9
#define DXVA_QUERYORREPLYFUNCFLAG_ACCEL_LOCK_OK_COPY      0xFFFFFC
#define DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_FALSE_PLUS  0xFFFFFB
#define DXVA_QUERYORREPLYFUNCFLAG_ACCEL_LOCK_FALSE_PLUS   0xFFFFFF

#define readDXVA_QueryOrReplyFuncFlag(ptr)        ((*(ptr)) >> 8)

#define readDXVA_QueryOrReplyFuncFlag_ACCEL(ptr)  (((*(ptr)) >> 11) & 1)
#define readDXVA_QueryOrReplyFuncFlag_LOCK(ptr)   (((*(ptr)) >> 10) & 1)
#define readDXVA_QueryOrReplyFuncFlag_BAD(ptr)    (((*(ptr)) >>  9) & 1)
#define readDXVA_QueryOrReplyFuncFlag_PLUS(ptr)   (((*(ptr)) >>  8) & 1)

#define readDXVA_QueryOrReplyFuncFunc(ptr)        ((*(ptr)) & 0xFF)

#define writeDXVA_QueryOrReplyFunc(ptr, flg, fnc) ((*(ptr)) = ((flg) << 8) | (fnc))

#define setDXVA_QueryOrReplyFuncFlag(ptr, flg) ((*(ptr)) |= ((flg) << 8))
#define setDXVA_QueryOrReplyFuncFunc(ptr, fnc) ((*(ptr)) |= (fnc));

typedef DWORD DXVA_EncryptProtocolFunc, *LPDXVA_EncryptProtocolFunc;

#define DXVA_ENCRYPTPROTOCOLFUNCFLAG_HOST    0xFFFF00
#define DXVA_ENCRYPTPROTOCOLFUNCFLAG_ACCEL   0xFFFF08

#define readDXVA_EncryptProtocolFuncFlag(ptr)        ((*(ptr)) >> 8)
#define readDXVA_EncryptProtocolFuncFlag_ACCEL(ptr)  (((*(ptr)) >> 11) & 1)

#define readDXVA_EncryptProtocolFuncFunc(ptr)        ((*(ptr)) & 0xFF)

#define writeDXVA_EncryptProtocolFunc(ptr, flg, fnc) ((*(ptr)) = ((flg) << 8) | (fnc))

#define setDXVA_EncryptProtocolFuncFlag(ptr, flg) ((*(ptr)) |= ((flg) << 8))
#define setDXVA_EncryptProtocolFuncFunc(ptr, fnc) ((*(ptr)) |= (fnc));

typedef struct _DXVA_EncryptProtocolHeader {
  DXVA_EncryptProtocolFunc dwFunction;
  DWORD ReservedBits[3];
  GUID  guidEncryptProtocol;
} DXVA_EncryptProtocolHeader, *LPDXVA_EncryptProtocolHeader;

typedef struct _DXVA_ConfigPictureDecode {

  // Operation Indicated
  DXVA_ConfigQueryOrReplyFunc dwFunction;

  // Alignment
  DWORD dwReservedBits[3];

  // Encryption GUIDs
  GUID guidConfigBitstreamEncryption;
  GUID guidConfigMBcontrolEncryption;
  GUID guidConfigResidDiffEncryption;

  // Bitstream Processing Indicator
  BYTE bConfigBitstreamRaw;

  // Macroblock Control Config
  BYTE bConfigMBcontrolRasterOrder;

  // Host Resid Diff Config
  BYTE bConfigResidDiffHost;
  BYTE bConfigSpatialResid8;
  BYTE bConfigResid8Subtraction;
  BYTE bConfigSpatialHost8or9Clipping;
  BYTE bConfigSpatialResidInterleaved;
  BYTE bConfigIntraResidUnsigned;

  // Accelerator Resid Diff Config
  BYTE bConfigResidDiffAccelerator;
  BYTE bConfigHostInverseScan;
  BYTE bConfigSpecificIDCT;
  BYTE bConfig4GroupedCoefs;
} DXVA_ConfigPictureDecode, *LPDXVA_ConfigPictureDecode;


/* Picture Decoding Parameters */

typedef struct _DXVA_PictureParameters {

  WORD wDecodedPictureIndex;
  WORD wDeblockedPictureIndex;

  WORD wForwardRefPictureIndex;
  WORD wBackwardRefPictureIndex;

  WORD wPicWidthInMBminus1;
  WORD wPicHeightInMBminus1;

  BYTE bMacroblockWidthMinus1;
  BYTE bMacroblockHeightMinus1;

  BYTE bBlockWidthMinus1;
  BYTE bBlockHeightMinus1;

  BYTE bBPPminus1;

  BYTE bPicStructure;
  BYTE bSecondField;
  BYTE bPicIntra;
  BYTE bPicBackwardPrediction;

  BYTE bBidirectionalAveragingMode;
  BYTE bMVprecisionAndChromaRelation;
  BYTE bChromaFormat;

  BYTE bPicScanFixed;
  BYTE bPicScanMethod;
  BYTE bPicReadbackRequests;

  BYTE bRcontrol;
  BYTE bPicSpatialResid8;
  BYTE bPicOverflowBlocks;
  BYTE bPicExtrapolation;

  BYTE bPicDeblocked;
  BYTE bPicDeblockConfined;
  BYTE bPic4MVallowed;
  BYTE bPicOBMC;
  BYTE bPicBinPB;
  BYTE bMV_RPS;

  BYTE bReservedBits;

  WORD wBitstreamFcodes;
  WORD wBitstreamPCEelements;
  BYTE bBitstreamConcealmentNeed;
  BYTE bBitstreamConcealmentMethod;

} DXVA_PictureParameters, *LPDXVA_PictureParameters;



/* Picture Resampling */

typedef struct _DXVA_PicResample {

  WORD  wPicResampleSourcePicIndex;
  WORD  wPicResampleDestPicIndex;

  WORD  wPicResampleRcontrol;
  BYTE  bPicResampleExtrapWidth;
  BYTE  bPicResampleExtrapHeight;

  DWORD dwPicResampleSourceWidth;
  DWORD dwPicResampleSourceHeight;

  DWORD dwPicResampleDestWidth;
  DWORD dwPicResampleDestHeight;

  DWORD dwPicResampleFullDestWidth;
  DWORD dwPicResampleFullDestHeight;

} DXVA_PicResample, *LPDXVA_PicResample;


#define DXVA_CHROMA_FORMAT_420 1
#define DXVA_CHROMA_FORMAT_422 2
#define DXVA_CHROMA_FORMAT_444 3

#define DXVA_PICTURE_STRUCTURE_TOP_FIELD    1
#define DXVA_PICTURE_STRUCTURE_BOTTOM_FIELD 2
#define DXVA_PICTURE_STRUCTURE_FRAME        3

#define DXVA_BIDIRECTIONAL_AVERAGING_MPEG2_ROUND 0
#define DXVA_BIDIRECTIONAL_AVERAGING_H263_TRUNC  1

#define DXVA_MV_PRECISION_AND_CHROMA_RELATION_MPEG2  0
#define DXVA_MV_PRECISION_AND_CHROMA_RELATION_H263   1
#define DXVA_MV_PRECISION_AND_CHROMA_RELATION_H261   2

#define DXVA_SCAN_METHOD_ZIG_ZAG              0
#define DXVA_SCAN_METHOD_ALTERNATE_VERTICAL   1
#define DXVA_SCAN_METHOD_ALTERNATE_HORIZONTAL 2
#define DXVA_SCAN_METHOD_ARBITRARY            3

#define DXVA_BITSTREAM_CONCEALMENT_NEED_UNLIKELY 0
#define DXVA_BITSTREAM_CONCEALMENT_NEED_MILD     1
#define DXVA_BITSTREAM_CONCEALMENT_NEED_LIKELY   2
#define DXVA_BITSTREAM_CONCEALMENT_NEED_SEVERE   3

#define DXVA_BITSTREAM_CONCEALMENT_METHOD_UNSPECIFIED 0
#define DXVA_BITSTREAM_CONCEALMENT_METHOD_INTRA       1
#define DXVA_BITSTREAM_CONCEALMENT_METHOD_FORWARD     2
#define DXVA_BITSTREAM_CONCEALMENT_METHOD_BACKWARD    3


/* Buffer Description Data */

typedef struct _DXVA_BufferDescription {
  DWORD dwTypeIndex;
  DWORD dwBufferIndex;
  DWORD dwDataOffset;
  DWORD dwDataSize;
  DWORD dwFirstMBaddress;
  DWORD dwNumMBsInBuffer;
  DWORD dwWidth;
  DWORD dwHeight;
  DWORD dwStride;
  DWORD dwReservedBits;
} DXVA_BufferDescription, *LPDXVA_BufferDescription;


/* Off-Host IDCT Coefficient Data Structures */

typedef struct _DXVA_TCoef4Group {
  BYTE  TCoefIDX[4];
  SHORT TCoefValue[4];
} DXVA_TCoef4Group, *LPDXVA_TCoef4Group;

typedef struct _DXVA_TCoefSingle {
  WORD  wIndexWithEOB;
  SHORT TCoefValue;
} DXVA_TCoefSingle, *LPDXVA_TCoefSingle;

/* Macros for Reading EOB and Index Values */

#define readDXVA_TCoefSingleIDX(ptr) ((ptr)->wIndexWithEOB >> 1)
#define readDXVA_TCoefSingleEOB(ptr) ((ptr)->wIndexWithEOB & 1)

/* Macro for Writing EOB and Index Values */

#define writeDXVA_TCoefSingleIndexWithEOB(ptr, idx, eob) ((ptr)->wIndexWithEOB = ((idx) << 1) | (eob))
#define setDXVA_TCoefSingleIDX(ptr, idx) ((ptr)->wIndexWithEOB |= ((idx) << 1))
#define setDXVA_TCoefSingleEOB(ptr)      ((ptr)->wIndexWithEOB |= 1)

/* Spatial-Domain Residual Difference Blocks */

#define DXVA_USUAL_BLOCK_WIDTH   8
#define DXVA_USUAL_BLOCK_HEIGHT  8
#define DXVA_USUAL_BLOCK_SIZE   (DXVA_USUAL_BLOCK_WIDTH * DXVA_USUAL_BLOCK_HEIGHT)

typedef SHORT       DXVA_Sample16[DXVA_USUAL_BLOCK_SIZE];
typedef signed char DXVA_Sample8 [DXVA_USUAL_BLOCK_SIZE];

/* Deblocking Filter Control Structure */

typedef BYTE DXVA_DeblockingEdgeControl;

typedef DXVA_DeblockingEdgeControl * LPDXVA_DeblockingEdgeControl;

/* Macros for Reading STRENGTH and FilterOn */

#define readDXVA_EdgeFilterStrength(ptr) ((*(ptr)) >> 1)
#define readDXVA_EdgeFilterOn(ptr)       ((*(ptr)) & 1)

/* Macro for Writing STRENGTH and FilterOn */

#define writeDXVA_DeblockingEdgeControl(ptr, str, fon) ((*(ptr)) = ((str) << 1) | (fon))
#define setDXVA_EdgeFilterStrength(ptr, str)           ((*(ptr)) |= ((str) << 1))
#define setDXVA_EdgeFilterOn(ptr)                      ((*(ptr)) |= 1)


/* Macroblock Control Command Data Structures */

typedef struct _DXVA_MVvalue {
  SHORT horz, vert;
} DXVA_MVvalue, *LPDXVA_MVvalue;


/* Inverse Quantization Matrices */

typedef struct _DXVA_QmatrixData {
  BYTE bNewQmatrix[4]; /* intra Y, inter Y, intra chroma, inter chroma */
  WORD Qmatrix[4][DXVA_USUAL_BLOCK_WIDTH * DXVA_USUAL_BLOCK_HEIGHT];
} DXVA_QmatrixData, *LPDXVA_QmatrixData;


/* Slice Control Buffer Data */

typedef struct _DXVA_SliceInfo {
  WORD  wHorizontalPosition;
  WORD  wVerticalPosition;
  DWORD dwSliceBitsInBuffer;
  DWORD dwSliceDataLocation;
  BYTE  bStartCodeBitOffset;
  BYTE  bReservedBits;
  WORD  wMBbitOffset;
  WORD  wNumberMBsInSlice;
  WORD  wQuantizerScaleCode;
  WORD  wBadSliceChopping;
} DXVA_SliceInfo, *LPDXVA_SliceInfo;


#define DXVA_NumMV_OBMC_off_BinPBwith4MV_off    4
#define DXVA_NumMV_OBMC_off_BinPBwith4MV_on  (4+1)
#define DXVA_NumMV_OBMC_on__BinPB_off         (10)
#define DXVA_NumMV_OBMC_on__BinPB_on          (11) /* not current standards */

#define DXVA_NumBlocksPerMB_420 (4+2+0)
#define DXVA_NumBlocksPerMB_422 (4+2+2)
#define DXVA_NumBlocksPerMB_444 (4+4+4)

/* Basic form for I pictures */
/* Host Residual Differences */
typedef struct _DXVA_MBctrl_I_HostResidDiff_1 {
  WORD  wMBaddress;
  WORD  wMBtype;
  DWORD dwMB_SNL;
  WORD  wPatternCode;
  WORD  wPC_Overflow; /* zero if not overflow format */
  DWORD dwReservedBits2;
} DXVA_MBctrl_I_HostResidDiff_1;

/* Basic form for I pictures */
/* Off-Host IDCT, 4:2:0 sampling */
typedef struct _DXVA_MBctrl_I_OffHostIDCT_1 {
  WORD  wMBaddress;
  WORD  wMBtype;
  DWORD dwMB_SNL;
  WORD  wPatternCode;
  BYTE  bNumCoef[DXVA_NumBlocksPerMB_420];
} DXVA_MBctrl_I_OffHostIDCT_1;

/* Basic form for P and B pictures */
/* Should also be used for concealment MVs in MPEG-2 I pictures */
/* Without OBMC, without BinPB and 4MV together, without MV RPS */
/* Host Residual Differences */
typedef struct _DXVA_MBctrl_P_HostResidDiff_1 {
  WORD         wMBaddress;
  WORD         wMBtype;
  DWORD        dwMB_SNL;
  WORD         wPatternCode;
  WORD         wPC_Overflow; /* zero if not overflow format */
  DWORD        dwReservedBits2;
  DXVA_MVvalue MVector[DXVA_NumMV_OBMC_off_BinPBwith4MV_off];
} DXVA_MBctrl_P_HostResidDiff_1;

/* Basic form for P and B pictures */
/* Without OBMC, without BinPB and 4MV together, without MV RPS */
/* Off-Host IDCT, 4:2:0 sampling */
typedef struct _DXVA_MBctrl_P_OffHostIDCT_1 {
  WORD         wMBaddress;
  WORD         wMBtype;
  DWORD        dwMB_SNL;
  WORD         wPatternCode;
  BYTE         bNumCoef[DXVA_NumBlocksPerMB_420];
  DXVA_MVvalue MVector[DXVA_NumMV_OBMC_off_BinPBwith4MV_off];
} DXVA_MBctrl_P_OffHostIDCT_1;

/* How to load alpha blending graphic data */
typedef struct _DXVA_ConfigAlphaLoad {

  // Operation Indicated
  DXVA_ConfigQueryOrReplyFunc dwFunction;

  // Alignment
  DWORD dwReservedBits[3];

  BYTE  bConfigDataType;
} DXVA_ConfigAlphaLoad, *LPDXVA_ConfigAlphaLoad;

#define DXVA_CONFIG_DATA_TYPE_IA44  0
#define DXVA_CONFIG_DATA_TYPE_AI44  1
#define DXVA_CONFIG_DATA_TYPE_DPXD  2
#define DXVA_CONFIG_DATA_TYPE_AYUV  3


/* How to combine alpha blending graphic data */
typedef struct _DXVA_ConfigAlphaCombine {

  // Operation Indicated
  DXVA_ConfigQueryOrReplyFunc dwFunction;

  // Alignment
  DWORD dwReservedBits[3];

  BYTE  bConfigBlendType;
  BYTE  bConfigPictureResizing;
  BYTE  bConfigOnlyUsePicDestRectArea;
  BYTE  bConfigGraphicResizing;
  BYTE  bConfigWholePlaneAlpha;

} DXVA_ConfigAlphaCombine, *LPDXVA_ConfigAlphaCombine;

#define DXVA_CONFIG_BLEND_TYPE_FRONT_BUFFER   0
#define DXVA_CONFIG_BLEND_TYPE_BACK_HARDWARE  1


/* AYUV sample for 16-entry YUV palette or graphic surface */

typedef struct _DXVA_AYUVsample2 {
  BYTE bCrValue;
  BYTE bCbValue;
  BYTE bY_Value;
  BYTE bSampleAlpha8;
} DXVA_AYUVsample2, *LPDXVA_AYUVsample2;

/* Macros for IA44 alpha blending surface samples */

typedef BYTE DXVA_IA44sample, *LPDXVA_IA44sample;

#define readDXVA_IA44index(ptr) (((*(ptr)) & 0xF0) >> 4)
#define readDXVA_IA44alpha(ptr)  ((*(ptr)) & 0x0F)

#define writeDXVA_IA44(ptr, idx, alpha) ((*(ptr)) = (((idx) << 4) | (alpha)))

#define setDXVA_IA44index(ptr, idx)    ((*(ptr)) |= ((idx) << 4))
#define setDXVA_IA44alpha(ptr, alpha)  ((*(ptr)) |= (alpha))

/* Macros for AI44 alpha blending surface samples */

typedef BYTE DXVA_AI44sample, *LPDXVA_AI44sample;

#define readDXVA_AI44index(ptr)  ((*(ptr)) & 0x0F)
#define readDXVA_AI44alpha(ptr) (((*(ptr)) & 0xF0) >> 4)

#define writeDXVA_AI44(ptr, idx, alpha) ((*(ptr)) = (((alpha) << 4) | (idx)))

#define setDXVA_AI44index(ptr, idx)    ((*(ptr)) |= (idx))
#define setDXVA_AI44alpha(ptr, alpha)  ((*(ptr)) |= ((alpha) << 4))


/* Highlight data structure */

typedef struct _DXVA_Highlight {
  WORD wHighlightActive;
  WORD wHighlightIndices;
  WORD wHighlightAlphas;
  RECT HighlightRect;
} DXVA_Highlight, *LPDXVA_Highlight;

typedef BYTE DXVA_DPXD,  *LPDXVA_DPXD;
typedef WORD DXVA_DCCMD, *LPDXVA_DCCMD;

/* Alpha blend combination */

typedef struct _DXVA_BlendCombination {
  WORD wPictureSourceIndex;
  WORD wBlendedDestinationIndex;
  RECT PictureSourceRect16thPel;
  RECT PictureDestinationRect;
  RECT GraphicSourceRect;
  RECT GraphicDestinationRect;
  WORD wBlendDelay;
  BYTE bBlendOn;
  BYTE bWholePlaneAlpha;
  DXVA_AYUVsample2 OutsideYUVcolor;
} DXVA_BlendCombination, *LPDXVA_BlendCombination;


#pragma pack(push, 16)


typedef DXVA_MBctrl_I_HostResidDiff_1 *
       LPDXVA_MBctrl_I_HostResidDiff_1;

typedef DXVA_MBctrl_I_OffHostIDCT_1 *
       LPDXVA_MBctrl_I_OffHostIDCT_1;

typedef DXVA_MBctrl_P_HostResidDiff_1 *
       LPDXVA_MBctrl_P_HostResidDiff_1;

typedef DXVA_MBctrl_P_OffHostIDCT_1 *
       LPDXVA_MBctrl_P_OffHostIDCT_1;


#pragma pack(pop)

/*
 * Other forms of pictures are constructed in the obvious way
 * from the above by adjusting the number of residual difference
 * blocks, the number of motion vectors per macroblock, etc.
 */

#define readDXVA_MBskipsFollowing(ptr)       (((ptr)->dwMB_SNL & 0xFF000000) >> 24)
#define readDXVA_MBdataLocation(ptr)         (((ptr)->dwMB_SNL & 0x00FFFFFF))

#define writeDXVA_MB_SNL(ptr, skips, dloc)   ((ptr)->dwMB_SNL = (((skips) << 24) | (dloc)))
#define setDXVA_MBskipsFollowing(ptr, skips) ((ptr)->dwMB_SNL |= ((skips) << 24))
#define setDXVA_MBdataLocation(ptr, dloc)    ((ptr)->dwMB_SNL |= (dloc))

#define readDXVA_MvertFieldSel_3(ptr)    (((ptr)->wMBtype & 0x8000) >> 15)
#define readDXVA_MvertFieldSel_2(ptr)    (((ptr)->wMBtype & 0x4000) >> 14)
#define readDXVA_MvertFieldSel_1(ptr)    (((ptr)->wMBtype & 0x2000) >> 13)
#define readDXVA_MvertFieldSel_0(ptr)    (((ptr)->wMBtype & 0x1000) >> 12)
#define readDXVA_ReservedBits(ptr)       (((ptr)->wMBtype & 0x0800) >> 11)
#define readDXVA_HostResidDiff(ptr)      (((ptr)->wMBtype & 0x0400) >> 10)
#define readDXVA_MotionType(ptr)         (((ptr)->wMBtype & 0x0300) >>  8)
#define readDXVA_MBscanMethod(ptr)       (((ptr)->wMBtype & 0x00C0) >>  6)
#define readDXVA_FieldResidual(ptr)      (((ptr)->wMBtype & 0x0020) >>  5)
#define readDXVA_H261LoopFilter(ptr)     (((ptr)->wMBtype & 0x0010) >>  4)
#define readDXVA_Motion4MV(ptr)          (((ptr)->wMBtype & 0x0008) >>  3)
#define readDXVA_MotionBackward(ptr)     (((ptr)->wMBtype & 0x0004) >>  2)
#define readDXVA_MotionForward(ptr)      (((ptr)->wMBtype & 0x0002) >>  1)
#define readDXVA_IntraMacroblock(ptr)    (((ptr)->wMBtype & 0x0001))

#define setDXVA_MvertFieldSel_3(ptr)     ((ptr)->wMBtype |= 0x8000)
#define setDXVA_MvertFieldSel_2(ptr)     ((ptr)->wMBtype |= 0x4000)
#define setDXVA_MvertFieldSel_1(ptr)     ((ptr)->wMBtype |= 0x2000)
#define setDXVA_MvertFieldSel_0(ptr)     ((ptr)->wMBtype |= 0x1000)
#define setDXVA_ReservedBits(ptr)        ((ptr)->wMBtype |= 0x0800)
#define setDXVA_HostResidDiff(ptr)       ((ptr)->wMBtype |= 0x0400)
#define setDXVA_MotionType(ptr, value)   ((ptr)->wMBtype |= ((value) << 8))
#define setDXVA_MBscanMethod(ptr, value) ((ptr)->wMBtype |= ((value) << 6))
#define setDXVA_FieldResidual(ptr)       ((ptr)->wMBtype |= 0x0020)
#define setDXVA_H261LoopFilter(ptr)      ((ptr)->wMBtype |= 0x0010)
#define setDXVA_Motion4MV(ptr)           ((ptr)->wMBtype |= 0x0008)
#define setDXVA_MotionBackward(ptr)      ((ptr)->wMBtype |= 0x0004)
#define setDXVA_MotionForward(ptr)       ((ptr)->wMBtype |= 0x0002)
#define setDXVA_IntraMacroblock(ptr)     ((ptr)->wMBtype |= 0x0001)

#define readDXVA_Y___0coded(ptr)        (((ptr)->wPatternCode & 0x0800) >> 11)
#define readDXVA_Y___1coded(ptr)        (((ptr)->wPatternCode & 0x0400) >> 10)
#define readDXVA_Y___2coded(ptr)        (((ptr)->wPatternCode & 0x0200) >>  9)
#define readDXVA_Y___3coded(ptr)        (((ptr)->wPatternCode & 0x0100) >>  8)
#define readDXVA_Cb__4coded(ptr)        (((ptr)->wPatternCode & 0x0080) >>  7)
#define readDXVA_Cr__5coded(ptr)        (((ptr)->wPatternCode & 0x0040) >>  6)
#define readDXVA_Cb__6coded(ptr)        (((ptr)->wPatternCode & 0x0020) >>  5)
#define readDXVA_Cr__7coded(ptr)        (((ptr)->wPatternCode & 0x0010) >>  4)
#define readDXVA_Cb__8coded(ptr)        (((ptr)->wPatternCode & 0x0008) >>  3)
#define readDXVA_Cb__9coded(ptr)        (((ptr)->wPatternCode & 0x0004) >>  2)
#define readDXVA_Cr_10coded(ptr)        (((ptr)->wPatternCode & 0x0002) >>  1)
#define readDXVA_Cr_11coded(ptr)        (((ptr)->wPatternCode & 0x0001))

#define readDXVA_Y___0oflow(ptr)        (((ptr)->wPC_Overflow & 0x0800) >> 11)
#define readDXVA_Y___1oflow(ptr)        (((ptr)->wPC_Overflow & 0x0400) >> 10)
#define readDXVA_Y___2oflow(ptr)        (((ptr)->wPC_Overflow & 0x0200) >>  9)
#define readDXVA_Y___3oflow(ptr)        (((ptr)->wPC_Overflow & 0x0100) >>  8)
#define readDXVA_Cb__4oflow(ptr)        (((ptr)->wPC_Overflow & 0x0080) >>  7)
#define readDXVA_Cr__5oflow(ptr)        (((ptr)->wPC_Overflow & 0x0040) >>  6)
#define readDXVA_Cb__6oflow(ptr)        (((ptr)->wPC_Overflow & 0x0020) >>  5)
#define readDXVA_Cr__7oflow(ptr)        (((ptr)->wPC_Overflow & 0x0010) >>  4)
#define readDXVA_Cb__8oflow(ptr)        (((ptr)->wPC_Overflow & 0x0008) >>  3)
#define readDXVA_Cb__9oflow(ptr)        (((ptr)->wPC_Overflow & 0x0004) >>  2)
#define readDXVA_Cr_10oflow(ptr)        (((ptr)->wPC_Overflow & 0x0002) >>  1)
#define readDXVA_Cr_11oflow(ptr)        (((ptr)->wPC_Overflow & 0x0001))

#pragma pack(pop, BeforeDXVApacking)



// -------------------------------------------------------------------------
//
// The definitions that follow describe the video de-interlace interface
// between the VMR and the graphics device driver.  This interface is not
// accessable via the IAMVideoAccelerator interface.
//
// -------------------------------------------------------------------------
//

typedef LONGLONG REFERENCE_TIME;

DEFINE_GUID(DXVA_DeinterlaceBobDevice,
    0x335aa36e,0x7884,0x43a4,0x9c,0x91,0x7f,0x87,0xfa,0xf3,0xe3,0x7e);

DEFINE_GUID(DXVA_DeinterlaceContainerDevice,
    0x0e85cb93,0x3046,0x4ff0,0xae,0xcc,0xd5,0x8c,0xb5,0xf0,0x35,0xfd);


#if !defined(VALID_POOL)
typedef DWORD D3DFORMAT;
enum {
    D3DPOOL_DEFAULT                 = 0,
    D3DPOOL_MANAGED                 = 1,
    D3DPOOL_SYSTEMMEM               = 2,
    D3DPOOL_SCRATCH                 = 3,
    D3DPOOL_LOCALVIDMEM             = 4,
    D3DPOOL_NONLOCALVIDMEM          = 5,
    D3DPOOL_FORCE_DWORD             = 0x7fffffff
};
#endif


// -------------------------------------------------------------------------
// data structures shared by User mode and Kernel mode.
// -------------------------------------------------------------------------
//

typedef enum _DXVA_SampleFormat {
    DXVA_SamplePreviousFrame = 1,
    DXVA_SampleProgressiveFrame = 2,
    DXVA_SampleFieldInterleavedEvenFirst = 3,
    DXVA_SampleFieldInterleavedOddFirst = 4,
    DXVA_SampleFieldSingleEven = 5,
    DXVA_SampleFieldSingleOdd = 6,
} DXVA_SampleFormat;

typedef struct _DXVA_Frequency {
    DWORD Numerator;
    DWORD Denominator;
} DXVA_Frequency;

typedef struct _DXVA_VideoDesc {
    DWORD               Size;
    DWORD               SampleWidth;
    DWORD               SampleHeight;
    DXVA_SampleFormat   SampleFormat;
    D3DFORMAT           d3dFormat;
    DXVA_Frequency      InputSampleFreq;
    DXVA_Frequency      OutputFrameFreq;
} DXVA_VideoDesc, *LPDXVA_VideoDesc;

typedef enum _DXVA_VideoProcessCaps {
    DXVA_VideoProcess_None       = 0x0000,
    DXVA_VideoProcess_YUV2RGB    = 0x0001,
    DXVA_VideoProcess_StretchX   = 0x0002,
    DXVA_VideoProcess_StretchY   = 0x0004,
    DXVA_VideoProcess_AlphaBlend = 0x0008
} DXVA_VideoProcessCaps;

typedef enum _DXVA_DeinterlaceTech {

    // the algorithm is unknown or proprietary
    DXVA_DeinterlaceTech_Unknown                = 0x0000,

    // the algorithm creates the missing lines by repeating
    // the line either above or below it - this method will look very jaggy and
    // isn't recommended
    DXVA_DeinterlaceTech_BOBLineReplicate       = 0x0001,


    // the algorithm creates the missing lines by vertically stretching each
    // video field by a factor of two.  Slight vertical adjustments are made to
    // ensure that the resulting image does not "bob" up and down.
    // The algorithm creates the missing lines by vertically stretching each
    // video field by a factor of two, for example by averaging two lines or
    // using a [-1, 9, 9, -1]/16 filter across four lines.
    // Slight vertical adjustments are made to ensure that the resulting image
    // does not "bob" up and down.
    DXVA_DeinterlaceTech_BOBVerticalStretch     = 0x0002,

    // the pixels in the missing line are recreated by a median filtering operation
    DXVA_DeinterlaceTech_MedianFiltering        = 0x0004,

    // the pixels in the missing line are recreated by an edge filter.
    // In this process, spatial directional filters are applied to determine
    // the orientation of edges in the picture content, and missing
    // pixels are created by filtering along (rather than across) the
    // detected edges.
    DXVA_DeinterlaceTech_EdgeFiltering          = 0x0010,

    // the pixels in the missing line are recreated by switching on a field by
    // field basis between using either spatial or temporal interpolation
    // depending on the amount of motion.
    DXVA_DeinterlaceTech_FieldAdaptive          = 0x0020,

    // the pixels in the missing line are recreated by switching on a pixel by pixel
    // basis between using either spatial or temporal interpolation depending on
    // the amount of motion..
    DXVA_DeinterlaceTech_PixelAdaptive          = 0x0040,

    // Motion Vector Steering  identifies objects within a sequence of video
    // fields.  The missing pixels are recreated after first aligning the
    // movement axes of the individual objects in the scene to make them
    // parallel with the time axis.
    DXVA_DeinterlaceTech_MotionVectorSteered      = 0x0080

} DXVA_DeinterlaceTech;

typedef struct _DXVA_VideoSample {
    REFERENCE_TIME      rtStart;
    REFERENCE_TIME      rtEnd;
    DXVA_SampleFormat   SampleFormat;
    VOID*               lpDDSSrcSurface;
} DXVA_VideoSample, *LPDXVA_VideoSample;

typedef struct _DXVA_DeinterlaceCaps {
    DWORD                   Size;
    DWORD                   NumPreviousOutputFrames;
    DWORD                   InputPool;
    DWORD                   NumForwardRefSamples;
    DWORD                   NumBackwardRefSamples;
    D3DFORMAT               d3dOutputFormat;
    DXVA_VideoProcessCaps   VideoProcessingCaps;
    DXVA_DeinterlaceTech    DeinterlaceTechnology;
} DXVA_DeinterlaceCaps, *LPDXVA_DeinterlaceCaps;




// -------------------------------------------------------------------------
// Data types used with RenderMoComp in kernel mode
// -------------------------------------------------------------------------
//

// Function codes for RenderMoComp

#define MAX_DEINTERLACE_SURFACES                        32

typedef struct _DXVA_DeinterlaceBlt {
    DWORD               Size;
    REFERENCE_TIME      rtTarget;
    RECT                DstRect;
    RECT                SrcRect;
    DWORD               NumSourceSurfaces;
    FLOAT               Alpha;
    DXVA_VideoSample    Source[MAX_DEINTERLACE_SURFACES];
} DXVA_DeinterlaceBlt;

#define DXVA_DeinterlaceBltFnCode                     0x01
// lpInput => DXVA_DeinterlaceBlt*
// lpOuput => NULL /* not currently used */


#define MAX_DEINTERLACE_DEVICE_GUIDS                    32
typedef struct _DXVA_DeinterlaceQueryAvailableModes {
    DWORD               Size;
    DWORD               NumGuids;
    GUID                Guids[MAX_DEINTERLACE_DEVICE_GUIDS];
} DXVA_DeinterlaceQueryAvailableModes;

#define DXVA_DeinterlaceQueryAvailableModesFnCode     0x01
// lpInput => DXVA_VideoDesc*
// lpOuput => DXVA_DeinterlaceQueryAvailableModes*


typedef struct _DXVA_DeinterlaceQueryModeCaps {
    DWORD               Size;
    GUID                Guid;
    DXVA_VideoDesc      VideoDesc;
} DXVA_DeinterlaceQueryModeCaps;

#define DXVA_DeinterlaceQueryModeCapsFnCode           0x02
// lpInput => DXVA_DeinterlaceQueryModeCaps*
// lpOuput => DXVA_DeinterlaceCaps*



#ifdef __cplusplus
}
#endif

#endif /* __DIRECTX_VA__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\include\dv.h ===
//------------------------------------------------------------------------------
// File: DV.h
//
// Desc: DV typedefs and defines.
//
// Copyright (c) 1997 - 2000, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef _DV_H_
#define _DV_H_

#define DV_DVSD_NTSC_FRAMESIZE	120000L
#define DV_DVSD_PAL_FRAMESIZE	144000L

#define DV_SMCHN	0x0000e000
#define DV_AUDIOMODE    0x00000f00
#define DV_AUDIOSMP	0x38000000

#define DV_AUDIOQU	0x07000000
#define DV_NTSCPAL	0x00200000
#define DV_STYPE	0x001f0000


//There are NTSC or PAL DV camcorders  
#define DV_NTSC		    0
#define DV_PAL		    1
//DV camcorder can output sd/hd/sl  
#define DV_SD		    0x00
#define DV_HD		    0x01
#define DV_SL		    0x02
//user can choice 12 bits or 16 bits audio from DV camcorder
#define DV_CAP_AUD16Bits    0x00
#define DV_CAP_AUD12Bits    0x01

#define SIZE_DVINFO	    0x20    

typedef struct Tag_DVAudInfo
{
	BYTE    bAudStyle[2];           
	//LSB 6 bits for starting DIF sequence number
	//MSB 2 bits: 0 for mon. 1: stereo in one 5/6 DIF sequences, 2: stereo audio in both 5/6 DIF sequences
	//example: 0x00: mon, audio in first 5/6 DIF sequence
	//                 0x05: mon, audio in 2nd 5 DIF sequence
	//                 0x15: stereo, audio only in 2nd 5 DIF sequence
	//                 0x10: stereo, audio only in 1st 5/6 DIF sequence
	//                 0x20: stereo, left ch in 1st 5/6 DIF sequence, right ch in 2nd 5/6 DIF sequence
	//                 0x26: stereo, rightch in 1st 6 DIF sequence, left ch in 2nd 6 DIF sequence
	BYTE    bAudQu[2];                      //qbits, only support 12, 16,           
		
	BYTE    bNumAudPin;                     //how many pin(language)
	WORD    wAvgSamplesPerPinPerFrm[2];     //samples size for one audio pin in one frame(which has 10 or 12 DIF sequence) 
	WORD    wBlkMode;                       //45 for NTSC, 54 for PAL
	WORD    wDIFMode;                       //5  for NTSC, 6 for PAL
	WORD    wBlkDiv;                        //15  for NTSC, 18 for PAL
} DVAudInfo;
	  
#endif // _DV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\include\dvdmedia.h ===
//------------------------------------------------------------------------------
// File: DVDMedia.h
//
// Desc: Contains typedefs and defines necessary for user mode (ring 3) DVD
//       filters and applications.
//
//       This should be included in the DirectShow SDK for user mode filters.
//       The types defined here should be kept in synch with ksmedia.h WDM 
//       DDK for kernel mode filters.
//
// Copyright (c) 1997 - 2000, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __DVDMEDIA_H__
#define __DVDMEDIA_H__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// -----------------------------------------------------------------------
// AC-3 definition for the AM_KSPROPSETID_AC3 property set
// -----------------------------------------------------------------------

typedef enum {
    AM_PROPERTY_AC3_ERROR_CONCEALMENT = 1,
    AM_PROPERTY_AC3_ALTERNATE_AUDIO = 2,
    AM_PROPERTY_AC3_DOWNMIX = 3,
    AM_PROPERTY_AC3_BIT_STREAM_MODE = 4,
    AM_PROPERTY_AC3_DIALOGUE_LEVEL = 5,
    AM_PROPERTY_AC3_LANGUAGE_CODE = 6,
    AM_PROPERTY_AC3_ROOM_TYPE = 7
} AM_PROPERTY_AC3;

typedef struct  {
    BOOL        fRepeatPreviousBlock;
    BOOL        fErrorInCurrentBlock;
} AM_AC3_ERROR_CONCEALMENT, *PAM_AC3_ERROR_CONCEALMENT;

typedef struct {
    BOOL    fStereo;
    ULONG   DualMode;
} AM_AC3_ALTERNATE_AUDIO, *PAM_AC3_ALTERNATE_AUDIO;

#define AM_AC3_ALTERNATE_AUDIO_1     1
#define AM_AC3_ALTERNATE_AUDIO_2     2
#define AM_AC3_ALTERNATE_AUDIO_BOTH  3

typedef struct {
    BOOL        fDownMix;
    BOOL        fDolbySurround;
} AM_AC3_DOWNMIX, *PAM_AC3_DOWNMIX;

typedef struct {
    LONG        BitStreamMode;
} AM_AC3_BIT_STREAM_MODE, *PAM_AC3_BIT_STREAM_MODE;

#define AM_AC3_SERVICE_MAIN_AUDIO            0
#define AM_AC3_SERVICE_NO_DIALOG             1
#define AM_AC3_SERVICE_VISUALLY_IMPAIRED     2
#define AM_AC3_SERVICE_HEARING_IMPAIRED      3
#define AM_AC3_SERVICE_DIALOG_ONLY           4
#define AM_AC3_SERVICE_COMMENTARY            5
#define AM_AC3_SERVICE_EMERGENCY_FLASH       6
#define AM_AC3_SERVICE_VOICE_OVER            7

typedef struct {
    ULONG   DialogueLevel;
} AM_AC3_DIALOGUE_LEVEL, *PAM_AC3_DIALOGUE_LEVEL;

typedef struct {
    BOOL    fLargeRoom;
} AM_AC3_ROOM_TYPE, *PAM_AC3_ROOM_TYPE;


// -----------------------------------------------------------------------
// subpicture definition for the AM_KSPROPSETID_DvdSubPic property set
// -----------------------------------------------------------------------

typedef enum {
    AM_PROPERTY_DVDSUBPIC_PALETTE = 0,
    AM_PROPERTY_DVDSUBPIC_HLI = 1,
    AM_PROPERTY_DVDSUBPIC_COMPOSIT_ON = 2  // TRUE for subpicture is displayed
} AM_PROPERTY_DVDSUBPIC;

typedef struct _AM_DVD_YUV {
    UCHAR   Reserved;
    UCHAR   Y;
    UCHAR   U;
    UCHAR   V;
} AM_DVD_YUV, *PAM_DVD_YUV;

typedef struct _AM_PROPERTY_SPPAL {
    AM_DVD_YUV sppal[16];
} AM_PROPERTY_SPPAL, *PAM_PROPERTY_SPPAL;

typedef struct _AM_COLCON {
    UCHAR emph1col:4;
    UCHAR emph2col:4;
    UCHAR backcol:4;
    UCHAR patcol:4;
    UCHAR emph1con:4;
    UCHAR emph2con:4;
    UCHAR backcon:4;
    UCHAR patcon:4;

} AM_COLCON, *PAM_COLCON;

typedef struct _AM_PROPERTY_SPHLI {
    USHORT     HLISS;      //
    USHORT     Reserved;
    ULONG      StartPTM;   // start presentation time in x/90000
    ULONG      EndPTM;     // end PTM in x/90000
    USHORT     StartX;
    USHORT     StartY;
    USHORT     StopX;
    USHORT     StopY;
    AM_COLCON  ColCon;     // color contrast description (4 bytes as given in HLI)
} AM_PROPERTY_SPHLI, *PAM_PROPERTY_SPHLI;

typedef BOOL AM_PROPERTY_COMPOSIT_ON, *PAM_PROPERTY_COMPOSIT_ON;



// -----------------------------------------------------------------------
// copy protection definitions
// -----------------------------------------------------------------------

// AM_UseNewCSSKey for the dwTypeSpecificFlags in IMediaSample2 to indicate
// the exact point in a stream after which to start applying a new CSS key.
// This is typically sent on an empty media sample just before attempting 
// to renegotiate a CSS key.
#define AM_UseNewCSSKey    0x1

//
// AM_KSPROPSETID_CopyProt property set definitions
//
typedef enum {
    AM_PROPERTY_DVDCOPY_CHLG_KEY = 0x01,
    AM_PROPERTY_DVDCOPY_DVD_KEY1 = 0x02,
    AM_PROPERTY_DVDCOPY_DEC_KEY2 = 0x03,
    AM_PROPERTY_DVDCOPY_TITLE_KEY = 0x04,
    AM_PROPERTY_COPY_MACROVISION = 0x05,
    AM_PROPERTY_DVDCOPY_REGION = 0x06,
    AM_PROPERTY_DVDCOPY_SET_COPY_STATE = 0x07,
    AM_PROPERTY_DVDCOPY_DISC_KEY = 0x80
} AM_PROPERTY_DVDCOPYPROT;

typedef struct _AM_DVDCOPY_CHLGKEY {
    BYTE ChlgKey[10];
    BYTE Reserved[2];
} AM_DVDCOPY_CHLGKEY, *PAM_DVDCOPY_CHLGKEY;

typedef struct _AM_DVDCOPY_BUSKEY {
    BYTE BusKey[5];
    BYTE Reserved[1];
} AM_DVDCOPY_BUSKEY, *PAM_DVDCOPY_BUSKEY;

typedef struct _AM_DVDCOPY_DISCKEY {
    BYTE DiscKey[2048];
} AM_DVDCOPY_DISCKEY, *PAM_DVDCOPY_DISCKEY;

typedef struct AM_DVDCOPY_TITLEKEY {
    ULONG KeyFlags;
    ULONG Reserved1[2];
    UCHAR TitleKey[6];
    UCHAR Reserved2[2];
} AM_DVDCOPY_TITLEKEY, *PAM_DVDCOPY_TITLEKEY;

typedef struct _AM_COPY_MACROVISION {
    ULONG MACROVISIONLevel;
} AM_COPY_MACROVISION, *PAM_COPY_MACROVISION;

typedef struct AM_DVDCOPY_SET_COPY_STATE {
    ULONG DVDCopyState;
} AM_DVDCOPY_SET_COPY_STATE, *PAM_DVDCOPY_SET_COPY_STATE;

typedef enum {
    AM_DVDCOPYSTATE_INITIALIZE = 0,
    AM_DVDCOPYSTATE_INITIALIZE_TITLE = 1,   // indicates we are starting a title
                                        // key copy protection sequence
    AM_DVDCOPYSTATE_AUTHENTICATION_NOT_REQUIRED = 2,
    AM_DVDCOPYSTATE_AUTHENTICATION_REQUIRED = 3,
    AM_DVDCOPYSTATE_DONE = 4
} AM_DVDCOPYSTATE;

typedef enum {
    AM_MACROVISION_DISABLED = 0,
    AM_MACROVISION_LEVEL1 = 1,
    AM_MACROVISION_LEVEL2 = 2,
    AM_MACROVISION_LEVEL3 = 3
} AM_COPY_MACROVISION_LEVEL, *PAM_COPY_MACROVISION_LEVEL;


// CSS region stucture
typedef struct _DVD_REGION {
    UCHAR CopySystem;
    UCHAR RegionData;
    UCHAR SystemRegion;
    UCHAR Reserved;
} DVD_REGION, *PDVD_REGION; 

//
// CGMS Copy Protection Flags
//

#define AM_DVD_CGMS_RESERVED_MASK      0x00000078

#define AM_DVD_CGMS_COPY_PROTECT_MASK  0x00000018
#define AM_DVD_CGMS_COPY_PERMITTED     0x00000000
#define AM_DVD_CGMS_COPY_ONCE          0x00000010
#define AM_DVD_CGMS_NO_COPY            0x00000018

#define AM_DVD_COPYRIGHT_MASK          0x00000040
#define AM_DVD_NOT_COPYRIGHTED         0x00000000
#define AM_DVD_COPYRIGHTED             0x00000040

#define AM_DVD_SECTOR_PROTECT_MASK     0x00000020
#define AM_DVD_SECTOR_NOT_PROTECTED    0x00000000
#define AM_DVD_SECTOR_PROTECTED        0x00000020


// -----------------------------------------------------------------------
// video format blocks
// -----------------------------------------------------------------------

enum AM_MPEG2Level {
    AM_MPEG2Level_Low = 1,
    AM_MPEG2Level_Main = 2,
    AM_MPEG2Level_High1440 = 3,
    AM_MPEG2Level_High = 4
};

enum AM_MPEG2Profile {
    AM_MPEG2Profile_Simple = 1,
    AM_MPEG2Profile_Main = 2,
    AM_MPEG2Profile_SNRScalable = 3,
    AM_MPEG2Profile_SpatiallyScalable = 4,
    AM_MPEG2Profile_High = 5
};

#define AMINTERLACE_IsInterlaced            0x00000001  // if 0, other interlace bits are irrelevent
#define AMINTERLACE_1FieldPerSample         0x00000002  // else 2 fields per media sample
#define AMINTERLACE_Field1First             0x00000004  // else Field 2 is first;  top field in PAL is field 1, top field in NTSC is field 2?
#define AMINTERLACE_UNUSED                  0x00000008  //
#define AMINTERLACE_FieldPatternMask        0x00000030  // use this mask with AMINTERLACE_FieldPat*
#define AMINTERLACE_FieldPatField1Only      0x00000000  // stream never contains a Field2
#define AMINTERLACE_FieldPatField2Only      0x00000010  // stream never contains a Field1
#define AMINTERLACE_FieldPatBothRegular     0x00000020  // There will be a Field2 for every Field1 (required for Weave?)
#define AMINTERLACE_FieldPatBothIrregular   0x00000030  // Random pattern of Field1s and Field2s
#define AMINTERLACE_DisplayModeMask         0x000000c0
#define AMINTERLACE_DisplayModeBobOnly      0x00000000
#define AMINTERLACE_DisplayModeWeaveOnly    0x00000040
#define AMINTERLACE_DisplayModeBobOrWeave   0x00000080

#define AMCOPYPROTECT_RestrictDuplication   0x00000001  // duplication of this stream should be restricted

#define AMMPEG2_DoPanScan           0x00000001  //if set, the MPEG-2 video decoder should crop output image 
                        //  based on pan-scan vectors in picture_display_extension 
                        //  and change the picture aspect ratio accordingly.
#define AMMPEG2_DVDLine21Field1     0x00000002  //if set, the MPEG-2 decoder must be able to produce an output 
                        //  pin for DVD style closed caption data found in GOP layer of field 1
#define AMMPEG2_DVDLine21Field2     0x00000004  //if set, the MPEG-2 decoder must be able to produce an output 
                        //  pin for DVD style closed caption data found in GOP layer of field 2
#define AMMPEG2_SourceIsLetterboxed 0x00000008  //if set, indicates that black bars have been encoded in the top 
                        //  and bottom of the video.
#define AMMPEG2_FilmCameraMode      0x00000010  //if set, indicates "film mode" used for 625/50 content.  If cleared,
                        //  indicates that "camera mode" was used.
#define AMMPEG2_LetterboxAnalogOut  0x00000020  //if set and this stream is sent to an analog output, it should 
                        //  be letterboxed.  Streams sent to VGA should be letterboxed only by renderers.
#define AMMPEG2_DSS_UserData        0x00000040  //if set, the MPEG-2 decoder must process DSS style user data
#define AMMPEG2_DVB_UserData        0x00000080  //if set, the MPEG-2 decoder must process DVB style user data
#define AMMPEG2_27MhzTimebase       0x00000100  //if set, the PTS,DTS timestamps advance at 27MHz rather than 90KHz

#define AMMPEG2_WidescreenAnalogOut 0x00000200  //if set and this stream is sent to an analog output, it should 
                        //  be in widescreen format (4x3 content should be centered on a 16x9 output).
                        //  Streams sent to VGA should be widescreened only by renderers.

// PRESENT in dwReserved1 field in VIDEOINFOHEADER2
#define AMCONTROL_USED              0x00000001 // Used to test if these flags are supported.  Set and test for AcceptMediaType.
                                                // If rejected, then you cannot use the AMCONTROL flags (send 0 for dwReserved1) 
#define AMCONTROL_PAD_TO_4x3        0x00000002 // if set means display the image in a 4x3 area 
#define AMCONTROL_PAD_TO_16x9       0x00000004 // if set means display the image in a 16x9 area 

typedef struct tagVIDEOINFOHEADER2 {
    RECT                rcSource;
    RECT                rcTarget;
    DWORD               dwBitRate;
    DWORD               dwBitErrorRate;
    REFERENCE_TIME      AvgTimePerFrame;
    DWORD               dwInterlaceFlags;   // use AMINTERLACE_* defines. Reject connection if undefined bits are not 0
    DWORD               dwCopyProtectFlags; // use AMCOPYPROTECT_* defines. Reject connection if undefined bits are not 0
    DWORD               dwPictAspectRatioX; // X dimension of picture aspect ratio, e.g. 16 for 16x9 display 
    DWORD               dwPictAspectRatioY; // Y dimension of picture aspect ratio, e.g.  9 for 16x9 display
    union {
        DWORD dwControlFlags;               // use AMCONTROL_* defines, use this from now on
        DWORD dwReserved1;                  // for backward compatiblity (was "must be 0";  connection rejected otherwise)
    };
    DWORD               dwReserved2;        // must be 0; reject connection otherwise
    BITMAPINFOHEADER    bmiHeader;
} VIDEOINFOHEADER2;

typedef struct tagMPEG2VIDEOINFO {
    VIDEOINFOHEADER2    hdr;
    DWORD               dwStartTimeCode;        //  ?? not used for DVD ??
    DWORD               cbSequenceHeader;       // is 0 for DVD (no sequence header)
    DWORD               dwProfile;              // use enum MPEG2Profile   
    DWORD               dwLevel;                // use enum MPEG2Level
    DWORD               dwFlags;                // use AMMPEG2_* defines.  Reject connection if undefined bits are not 0
    DWORD               dwSequenceHeader[1];    // DWORD instead of Byte for alignment purposes
                                                //   For MPEG-2, if a sequence_header is included, the sequence_extension 
                                                //   should also be included
} MPEG2VIDEOINFO;

#define SIZE_MPEG2VIDEOINFO(pv) (FIELD_OFFSET(MPEG2VIDEOINFO, dwSequenceHeader[0]) + (pv)->cbSequenceHeader)

// do not use
#define MPEG1_SEQUENCE_INFO(pv) ((const BYTE *)(pv)->bSequenceHeader)

// use this macro instead, the previous only works for MPEG1VIDEOINFO structures
#define MPEG2_SEQUENCE_INFO(pv) ((const BYTE *)(pv)->dwSequenceHeader)


//===================================================================================
// flags for dwTypeSpecificFlags in AM_SAMPLE2_PROPERTIES which define type specific
// data in IMediaSample2
//===================================================================================

#define AM_VIDEO_FLAG_FIELD_MASK        0x0003L // use this mask to check whether the sample is field1 or field2 or frame
#define AM_VIDEO_FLAG_INTERLEAVED_FRAME 0x0000L // the sample is a frame (remember to use AM_VIDEO_FLAG_FIELD_MASK when using this)
#define AM_VIDEO_FLAG_FIELD1            0x0001L // the sample is field1 (remember to use AM_VIDEO_FLAG_FIELD_MASK when using this)
#define AM_VIDEO_FLAG_FIELD2            0x0002L // the sample is the field2 (remember to use AM_VIDEO_FLAG_FIELD_MASK when using this)
#define AM_VIDEO_FLAG_FIELD1FIRST       0x0004L // if set means display field1 first, else display field2 first.
                                                // this bit is irrelavant for 1FieldPerSample mode
#define AM_VIDEO_FLAG_WEAVE             0x0008L // if set use bob display mode else weave
#define AM_VIDEO_FLAG_IPB_MASK          0x0030L // use this mask to check whether the sample is I, P or B
#define AM_VIDEO_FLAG_I_SAMPLE          0x0000L // I Sample (remember to use AM_VIDEO_FLAG_IPB_MASK when using this)
#define AM_VIDEO_FLAG_P_SAMPLE          0x0010L // P Sample (remember to use AM_VIDEO_FLAG_IPB_MASK when using this)
#define AM_VIDEO_FLAG_B_SAMPLE          0x0020L // B Sample (remember to use AM_VIDEO_FLAG_IPB_MASK when using this)
#define AM_VIDEO_FLAG_REPEAT_FIELD      0x0040L // if set means display the field which has been displayed first again after displaying 
                                                // both fields first. This bit is irrelavant for 1FieldPerSample mode

// -----------------------------------------------------------------------
// AM_KSPROPSETID_DvdKaraoke property set definitions
// -----------------------------------------------------------------------

typedef struct tagAM_DvdKaraokeData
{
    DWORD   dwDownmix;              // bitwise OR of AM_DvdKaraoke_Downmix flags
    DWORD   dwSpeakerAssignment;    // AM_DvdKaraoke_SpeakerAssignment
} AM_DvdKaraokeData;

typedef enum {
    AM_PROPERTY_DVDKARAOKE_ENABLE = 0,  // BOOL
    AM_PROPERTY_DVDKARAOKE_DATA = 1,
} AM_PROPERTY_DVDKARAOKE;

// -----------------------------------------------------------------------
// AM_KSPROPSETID_TSRateChange property set definitions for time stamp
// rate changes.
// -----------------------------------------------------------------------

typedef enum {
    AM_RATE_SimpleRateChange = 1,    // rw, use AM_SimpleRateChange
    AM_RATE_ExactRateChange  = 2,	 // rw, use AM_ExactRateChange
    AM_RATE_MaxFullDataRate  = 3,	 // r,  use AM_MaxFullDataRate
    AM_RATE_Step             = 4     // w,  use AM_Step
} AM_PROPERTY_TS_RATE_CHANGE;

// -------------------------------------------------------------------
// AM_KSPROPSETID_DVD_RateChange property set definitions for new DVD
// rate change scheme.
// -------------------------------------------------------------------

typedef enum {
    AM_RATE_ChangeRate       = 1,    // w,  use AM_DVD_ChangeRate
    AM_RATE_FullDataRateMax  = 2,	 // r,  use AM_MaxFullDataRate
    AM_RATE_ReverseDecode    = 3,    // r,  use LONG
    AM_RATE_DecoderPosition  = 4,    // r,  use AM_DVD_DecoderPosition
    AM_RATE_DecoderVersion   = 5     // r,  use LONG
} AM_PROPERTY_DVD_RATE_CHANGE;

typedef struct {
    // this is the simplest mechanism to set a time stamp rate change on
    // a filter (simplest for the person setting the rate change, harder
    // for the filter doing the rate change).  
    REFERENCE_TIME	StartTime;  //stream time at which to start this rate
    LONG		Rate;       //new rate * 10000 (decimal)
} AM_SimpleRateChange;

typedef struct {
    REFERENCE_TIME  OutputZeroTime; //input TS that maps to zero output TS
    LONG        Rate;       //new rate * 10000 (decimal)
} AM_ExactRateChange;

typedef LONG AM_MaxFullDataRate; //rate * 10000 (decimal)

typedef DWORD AM_Step; // number of frame to step

// New rate change property set, structs. enums etc.
typedef struct {
    REFERENCE_TIME	StartInTime;   // stream time (input) at which to start decoding at this rate
    REFERENCE_TIME	StartOutTime;  // reference time (output) at which to start showing at this rate
    LONG		    Rate;          // new rate * 10000 (decimal)
} AM_DVD_ChangeRate ;

typedef LONGLONG  AM_DVD_DecoderPosition ;

typedef enum {
    DVD_DIR_FORWARD  = 0,
    DVD_DIR_BACKWARD = 1
} DVD_PLAY_DIRECTION ;

#ifdef __cplusplus
}
#endif // __cplusplus
#endif // __DVDMEDIA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\include\errors.h ===
//------------------------------------------------------------------------------
// File: Errors.h
//
// Desc:  ActiveMovie error defines.
//
// Copyright (c) 1992 - 2000, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __ERRORS__
#define __ERRORS__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#ifndef _AMOVIE_
#define AMOVIEAPI   DECLSPEC_IMPORT
#else
#define AMOVIEAPI
#endif

// codes 0-01ff are reserved for OLE
#define VFW_FIRST_CODE   0x200
#define MAX_ERROR_TEXT_LEN 160

#include <VFWMSGS.H>                    // includes all message definitions

typedef BOOL (WINAPI* AMGETERRORTEXTPROCA)(HRESULT, char *, DWORD);
typedef BOOL (WINAPI* AMGETERRORTEXTPROCW)(HRESULT, WCHAR *, DWORD);

AMOVIEAPI DWORD WINAPI AMGetErrorTextA( HRESULT hr , char *pbuffer , DWORD MaxLen);
AMOVIEAPI DWORD WINAPI AMGetErrorTextW( HRESULT hr , WCHAR *pbuffer , DWORD MaxLen);


#ifdef UNICODE
#define AMGetErrorText  AMGetErrorTextW
typedef AMGETERRORTEXTPROCW AMGETERRORTEXTPROC;
#else
#define AMGetErrorText  AMGetErrorTextA
typedef AMGETERRORTEXTPROCA AMGETERRORTEXTPROC;
#endif

#ifdef __cplusplus
}
#endif // __cplusplus
#endif // __ERRORS__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\include\edevdefs.h ===
//------------------------------------------------------------------------------
// File: EDevDefs.h
//
// Desc: External Device (such as a VCR) control interface parameter and
//       value definitions.  
//
//       Note:  new constants added:  ED_BASE+800L -> ED_BASE+811L
//
// Copyright (c) 1992 - 2000, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __EDEVDEFS__
#define __EDEVDEFS__


#define ED_BASE		        		0x1000L

// this is used to tell the device communications object which
// physical communications port to use.
#define DEV_PORT_SIM	1
#define DEV_PORT_COM1	2	// standard serial ports
#define DEV_PORT_COM2	3
#define DEV_PORT_COM3	4
#define DEV_PORT_COM4	5
#define DEV_PORT_DIAQ	6	// Diaquest driver
#define DEV_PORT_ARTI	7	// ARTI driver
#define DEV_PORT_1394	8	// IEEE 1394 Bus
#define DEV_PORT_USB	9	// Universal Serial Bus
#define DEV_PORT_MIN	DEV_PORT_SIM
#define DEV_PORT_MAX	DEV_PORT_USB


//	IAMExtDevice Capability Items:  unless otherwise specified, these items return 
//	   OATRUE or OAFALSE.  All return values are in pdwValue unless otherwise specified:

#define ED_DEVCAP_CAN_RECORD			ED_BASE+1L
#define ED_DEVCAP_CAN_RECORD_STROBE		ED_BASE+2L	// for multitrack devices: 
													// switches currently recording tracks off 
													// and selected non-recording tracks into record
#define ED_DEVCAP_HAS_AUDIO			ED_BASE+3L
#define ED_DEVCAP_HAS_VIDEO			ED_BASE+4L
#define ED_DEVCAP_USES_FILES		ED_BASE+5L
#define ED_DEVCAP_CAN_SAVE			ED_BASE+6L

#define ED_DEVCAP_DEVICE_TYPE		ED_BASE+7L	// returns one of the following:
#define ED_DEVTYPE_VCR				ED_BASE+8L
#define ED_DEVTYPE_LASERDISK		ED_BASE+9L
#define ED_DEVTYPE_ATR 				ED_BASE+10L
#define ED_DEVTYPE_DDR				ED_BASE+11L
#define ED_DEVTYPE_ROUTER 			ED_BASE+12L
#define ED_DEVTYPE_KEYER 			ED_BASE+13L
#define ED_DEVTYPE_MIXER_VIDEO 		ED_BASE+14L
#define ED_DEVTYPE_DVE 				ED_BASE+15L
#define ED_DEVTYPE_WIPEGEN 			ED_BASE+16L
#define ED_DEVTYPE_MIXER_AUDIO 		ED_BASE+17L
#define ED_DEVTYPE_CG 				ED_BASE+18L
#define ED_DEVTYPE_TBC 				ED_BASE+19L
#define ED_DEVTYPE_TCG 				ED_BASE+20L
#define ED_DEVTYPE_GPI 				ED_BASE+21L
#define ED_DEVTYPE_JOYSTICK 		ED_BASE+22L
#define ED_DEVTYPE_KEYBOARD			ED_BASE+23L

// returns mfr-specific ID from external device.
#define ED_DEVCAP_EXTERNAL_DEVICE_ID	ED_BASE+24L

#define ED_DEVCAP_TIMECODE_READ		ED_BASE+25L
#define ED_DEVCAP_TIMECODE_WRITE	ED_BASE+26L
//	used for seekable non-timecode enabled devices
#define ED_DEVCAP_CTLTRK_READ		ED_BASE+27L
//	used for seekable non-timecode enabled devices
#define ED_DEVCAP_INDEX_READ		ED_BASE+28L

// returns device preroll time in current time format
#define ED_DEVCAP_PREROLL			ED_BASE+29L
// returns device postroll time in current time format
#define ED_DEVCAP_POSTROLL			ED_BASE+30L

// returns indication of devices synchronization accuracy.
#define ED_DEVCAP_SYNC_ACCURACY		ED_BASE+31L	// returns one of the following:
#define ED_SYNCACC_PRECISE			ED_BASE+32L
#define ED_SYNCACC_FRAME			ED_BASE+33L
#define ED_SYNCACC_ROUGH			ED_BASE+34L

// returns devices normal framerate.
#define ED_DEVCAP_NORMAL_RATE	ED_BASE+35L	// returns one of the following:
#define ED_RATE_24				ED_BASE+36L
#define ED_RATE_25				ED_BASE+37L
#define ED_RATE_2997			ED_BASE+38L
#define ED_RATE_30				ED_BASE+39L

#define ED_DEVCAP_CAN_PREVIEW	ED_BASE+40L
#define ED_DEVCAP_CAN_MONITOR_SOURCES	ED_BASE+41L

// indicates implementation allows testing of methods/parameters by
// setting the hi bit of a parm that makes sense - see individual methods
// for details.
#define ED_DEVCAP_CAN_TEST			ED_BASE+42L
	
// indicates device accepts video as an input.
#define ED_DEVCAP_VIDEO_INPUTS		ED_BASE+43L

// indicates device accepts audio as an input.
#define ED_DEVCAP_AUDIO_INPUTS		ED_BASE+44L

#define ED_DEVCAP_NEEDS_CALIBRATING	ED_BASE+45L

#define ED_DEVCAP_SEEK_TYPE			ED_BASE+46L	// returns one of the following:
#define ED_SEEK_PERFECT				ED_BASE+47L	// indicates device can execute seek 
												// within 1 video frames without signal 
												//	break (like a DDR)
#define ED_SEEK_FAST				ED_BASE+48L	// indicates device can move pretty quick 
												//  with short break in signal
#define ED_SEEK_SLOW				ED_BASE+49L	// seeks like a tape transport

#define ED_POWER_ON					ED_BASE+50L
#define ED_POWER_OFF				ED_BASE+51L
#define ED_POWER_STANDBY			ED_BASE+52L

#define ED_ACTIVE					ED_BASE+53L
#define ED_INACTIVE 				ED_BASE+54L
#define ED_ALL						ED_BASE+55L
#define ED_TEST						ED_BASE+56L

//	IAMExtTransport Capability Items:  unless otherwise specified, these items return 
//	   OATRUE or OAFALSE.  All return values are in pdwValue unless otherwise specified:

#define ED_TRANSCAP_CAN_EJECT			ED_BASE+100L
#define ED_TRANSCAP_CAN_BUMP_PLAY		ED_BASE+101L	// variable speed for synchronizing
#define ED_TRANSCAP_CAN_PLAY_BACKWARDS	ED_BASE+102L	// servo locked for use during an edit
#define ED_TRANSCAP_CAN_SET_EE			ED_BASE+103L	// show devices input on its output
#define ED_TRANSCAP_CAN_SET_PB			ED_BASE+104L	// show media playback on devices output
#define ED_TRANSCAP_CAN_DELAY_VIDEO_IN	ED_BASE+105L	// transport can do delayed-in video edits
#define ED_TRANSCAP_CAN_DELAY_VIDEO_OUT	ED_BASE+106L	// transport can do delayed-out video edits
#define ED_TRANSCAP_CAN_DELAY_AUDIO_IN	ED_BASE+107L	// transport can do delayed-in audio edits
#define ED_TRANSCAP_CAN_DELAY_AUDIO_OUT	ED_BASE+108L	// transport can do delayed-out audio edits
#define ED_TRANSCAP_FWD_VARIABLE_MAX	ED_BASE+109L	// max forward speed (multiple of play speed) 
														//  in pdblValue
#define ED_TRANSCAP_FWD_VARIABLE_MIN	ED_BASE+800L	// min forward speed (multiple of play speed) 
														//  in pdblValue
#define ED_TRANSCAP_REV_VARIABLE_MAX	ED_BASE+110L	// max reverse speed (multiple of play speed) in
														//  pdblValue
#define ED_TRANSCAP_REV_VARIABLE_MIN	ED_BASE+801L	// min reverse speed (multiple of play speed)
														//  in pdblValue
#define ED_TRANSCAP_FWD_SHUTTLE_MAX		ED_BASE+802L	// max forward speed in Shuttle mode (multiple
														//  of play speed) in pdblValue
#define ED_TRANSCAP_FWD_SHUTTLE_MIN		ED_BASE+803L	// min forward speed in Shuttle mode (multiple
														//  of play speed) in pdblValue
#define ED_TRANSCAP_REV_SHUTTLE_MAX		ED_BASE+804L	// max reverse speed in Shuttle mode (multiple
														//  of play speed) in pdblValue
#define ED_TRANSCAP_REV_SHUTTLE_MIN		ED_BASE+805L	// min reverse speed in Shuttle mode (multiple
														//  of play speed) in pdblValue
#define ED_TRANSCAP_NUM_AUDIO_TRACKS	ED_BASE+111L	// returns number of audio tracks
#define ED_TRANSCAP_LTC_TRACK			ED_BASE+112L	// returns track number of LTC timecode track.
														//  ED_ALL means no dedicated timecode track
#define ED_TRANSCAP_NEEDS_TBC			ED_BASE+113L	// devices output not stable
#define ED_TRANSCAP_NEEDS_CUEING		ED_BASE+114L	// device must be cued prior to performing edit
#define ED_TRANSCAP_CAN_INSERT			ED_BASE+115L
#define ED_TRANSCAP_CAN_ASSEMBLE		ED_BASE+116L
#define ED_TRANSCAP_FIELD_STEP			ED_BASE+117L	// device responds to Frame Advance command by 
														//  advancing one field
#define ED_TRANSCAP_CLOCK_INC_RATE		ED_BASE+118L	// VISCA command - keep for compatibility
#define ED_TRANSCAP_CAN_DETECT_LENGTH	ED_BASE+119L
#define ED_TRANSCAP_CAN_FREEZE			ED_BASE+120L
#define ED_TRANSCAP_HAS_TUNER			ED_BASE+121L
#define ED_TRANSCAP_HAS_TIMER			ED_BASE+122L
#define ED_TRANSCAP_HAS_CLOCK			ED_BASE+123L
#define ED_TRANSCAP_MULTIPLE_EDITS		ED_BASE+806L	// OATRUE means device/filter can support
														//  multiple edit events
#define ED_TRANSCAP_IS_MASTER			ED_BASE+807L	// OATRUE means device is the master clock
														//  for synchronizing (this sets timecode-to-
														//  reference clock offset for editing)
#define ED_TRANSCAP_HAS_DT				ED_BASE+814L	// OATRUE means device has Dynamic Tracking

//	IAMExtTransport Media States
#define ED_MEDIA_SPIN_UP			ED_BASE+130L
#define ED_MEDIA_SPIN_DOWN			ED_BASE+131L
#define ED_MEDIA_UNLOAD				ED_BASE+132L

//	IAMExtTransport Modes
#define	ED_MODE_PLAY				ED_BASE+200L
#define	ED_MODE_STOP				ED_BASE+201L
#define	ED_MODE_FREEZE				ED_BASE+202L	// really "pause"
#define	ED_MODE_THAW				ED_BASE+203L
#define	ED_MODE_FF					ED_BASE+204L
#define	ED_MODE_REW					ED_BASE+205L
#define	ED_MODE_RECORD				ED_BASE+206L
#define	ED_MODE_RECORD_STROBE		ED_BASE+207L
#define ED_MODE_RECORD_FREEZE		ED_BASE+808L	// never "put", only "get"
#define	ED_MODE_STEP				ED_BASE+208L	// same as "jog"
#define	ED_MODE_STEP_FWD			ED_BASE+208L	// same as ED_MODE_STEP
#define	ED_MODE_STEP_REV			ED_BASE+809L
#define	ED_MODE_SHUTTLE				ED_BASE+209L
#define	ED_MODE_EDIT_CUE			ED_BASE+210L
#define ED_MODE_VAR_SPEED			ED_BASE+211L
#define ED_MODE_PERFORM				ED_BASE+212L	// returned status only
#define	ED_MODE_LINK_ON				ED_BASE+280L
#define	ED_MODE_LINK_OFF			ED_BASE+281L
#define ED_MODE_NOTIFY_ENABLE		ED_BASE+810L
#define ED_MODE_NOTIFY_DISABLE		ED_BASE+811L
#define ED_MODE_SHOT_SEARCH			ED_BASE+812L

//	IAMTimecodeReader/Generator/Display defines
//
// Timecode Generator Mode params and values:
//
#define ED_TCG_TIMECODE_TYPE		ED_BASE+400L	// can be one of the following:
#define ED_TCG_SMPTE_LTC			ED_BASE+401L
#define ED_TCG_SMPTE_VITC			ED_BASE+402L
#define ED_TCG_MIDI_QF				ED_BASE+403L
#define ED_TCG_MIDI_FULL			ED_BASE+404L

#define ED_TCG_FRAMERATE			ED_BASE+405L	// can be one of the following:
#define ED_FORMAT_SMPTE_30			ED_BASE+406L
#define ED_FORMAT_SMPTE_30DROP		ED_BASE+407L
#define ED_FORMAT_SMPTE_25			ED_BASE+408L
#define ED_FORMAT_SMPTE_24			ED_BASE+409L

#define ED_TCG_SYNC_SOURCE			ED_BASE+410L	// can be one of the following:
#define ED_TCG_VIDEO				ED_BASE+411L
#define ED_TCG_READER				ED_BASE+412L
#define ED_TCG_FREE					ED_BASE+413L

#define ED_TCG_REFERENCE_SOURCE		ED_BASE+414L	// can have one these values:
													//	ED_TCG_FREE || ED_TCG_READER 
													//	(for regen/jamsync)

// TimeCodeReader Mode params and values:
#define ED_TCR_SOURCE			ED_BASE+416L	// can be one of the following:
// ED_TCG (already defined)
#define ED_TCR_LTC				ED_BASE+417L
#define ED_TCR_VITC				ED_BASE+418L
#define ED_TCR_CT				ED_BASE+419L	// Control Track
#define ED_TCR_FTC				ED_BASE+420L	// File TimeCode - for file-based devices
												//  that wish they were transports
// ED_MODE_NOTIFY_ENABLE can be OATRUE or OAFALSE (defined in transport mode
//  section of this file).  
#define ED_TCR_LAST_VALUE		ED_BASE+421L	// for notification mode - 
												//  successive calls to GetTimecode
												//  return the last read value
// TimeCode Display Mode params and values:
//
#define ED_TCD_SOURCE			ED_BASE+422L	// can be one of the following:
#define ED_TCR					ED_BASE+423L
#define ED_TCG					ED_BASE+424L

#define ED_TCD_SIZE				ED_BASE+425L	// can be one of the following:
#define ED_SMALL				ED_BASE+426L
#define ED_MED					ED_BASE+427L
#define ED_LARGE				ED_BASE+428L

#define ED_TCD_POSITION			ED_BASE+429L	// can be one of the following:
#define ED_TOP					0x0001
#define ED_MIDDLE				0x0002
#define ED_BOTTOM				0x0004			// ord  with
#define ED_LEFT					0x0100
#define ED_CENTER				0x0200
#define ED_RIGHT				0x0400

#define ED_TCD_INTENSITY		ED_BASE+436L	// can be one of the following:
#define ED_HIGH					ED_BASE+437L
#define ED_LOW					ED_BASE+438L

#define ED_TCD_TRANSPARENCY		ED_BASE+439L	// 0-4, 0 is opaque

#define ED_TCD_INVERT			ED_BASE+440L	// OATRUE=black on white
												// OAFALSE=white on black
//	IAMExtTransport defines
//
// Transport status, params and values
//

// IAMExtTransport Status items and and values:
#define ED_MODE					ED_BASE+500L	// see ED_MODE_xxx values above
#define	ED_ERROR				ED_BASE+501L
#define	ED_LOCAL				ED_BASE+502L
#define	ED_RECORD_INHIBIT		ED_BASE+503L
#define	ED_SERVO_LOCK			ED_BASE+504L
#define	ED_MEDIA_PRESENT		ED_BASE+505L
#define	ED_MEDIA_LENGTH			ED_BASE+506L
#define	ED_MEDIA_SIZE			ED_BASE+507L
#define	ED_MEDIA_TRACK_COUNT	ED_BASE+508L
#define	ED_MEDIA_TRACK_LENGTH	ED_BASE+509L
#define	ED_MEDIA_SIDE			ED_BASE+510L

#define	ED_MEDIA_TYPE			ED_BASE+511L	// can be one of the following:
#define	ED_MEDIA_VHS			ED_BASE+512L
#define	ED_MEDIA_SVHS			ED_BASE+513L
#define	ED_MEDIA_HI8			ED_BASE+514L
#define	ED_MEDIA_UMATIC			ED_BASE+515L
#define	ED_MEDIA_DVC			ED_BASE+516L
#define	ED_MEDIA_1_INCH			ED_BASE+517L
#define	ED_MEDIA_D1				ED_BASE+518L
#define	ED_MEDIA_D2				ED_BASE+519L
#define	ED_MEDIA_D3				ED_BASE+520L
#define	ED_MEDIA_D5				ED_BASE+521L
#define	ED_MEDIA_DBETA			ED_BASE+522L
#define	ED_MEDIA_BETA			ED_BASE+523L
#define	ED_MEDIA_8MM			ED_BASE+524L
#define	ED_MEDIA_DDR			ED_BASE+525L
#define	ED_MEDIA_SX				ED_BASE+813L
#define	ED_MEDIA_OTHER			ED_BASE+526L
#define	ED_MEDIA_CLV			ED_BASE+527L
#define	ED_MEDIA_CAV			ED_BASE+528L
#define ED_MEDIA_POSITION		ED_BASE+529L

#define ED_LINK_MODE			ED_BASE+530L	// OATRUE if transport controls
							 					// are linked to graph's RUN, 
							 					// STOP, and PAUSE methods

// IAMExtTransport Basic Parms
#define	ED_TRANSBASIC_TIME_FORMAT	ED_BASE+540L	// can be one of the following:
#define	ED_FORMAT_MILLISECONDS		ED_BASE+541L
#define	ED_FORMAT_FRAMES			ED_BASE+542L
#define ED_FORMAT_REFERENCE_TIME	ED_BASE+543L

#define	ED_FORMAT_HMSF				ED_BASE+547L
#define	ED_FORMAT_TMSF				ED_BASE+548L

#define	ED_TRANSBASIC_TIME_REFERENCE	ED_BASE+549L	// can be one of the following:
#define	ED_TIMEREF_TIMECODE			ED_BASE+550L
#define	ED_TIMEREF_CONTROL_TRACK	ED_BASE+551L
#define	ED_TIMEREF_INDEX			ED_BASE+552L

#define	ED_TRANSBASIC_SUPERIMPOSE		ED_BASE+553L	// enable/disable onscreen display
#define	ED_TRANSBASIC_END_STOP_ACTION	ED_BASE+554L	// can be one of: ED_MODE_STOP |
														//	ED_MODE_REWIND | ED_MODE_FREEZE
#define	ED_TRANSBASIC_RECORD_FORMAT	ED_BASE+555L	// can be one of the following:
#define	ED_RECORD_FORMAT_SP			ED_BASE+556L
#define	ED_RECORD_FORMAT_LP			ED_BASE+557L
#define	ED_RECORD_FORMAT_EP			ED_BASE+558L

#define	ED_TRANSBASIC_STEP_COUNT	ED_BASE+559L
#define	ED_TRANSBASIC_STEP_UNIT		ED_BASE+560L	// can be one of the following:
#define	ED_STEP_FIELD				ED_BASE+561L
#define	ED_STEP_FRAME				ED_BASE+562L
#define	ED_STEP_3_2					ED_BASE+563L

#define	ED_TRANSBASIC_PREROLL		ED_BASE+564L
#define	ED_TRANSBASIC_RECPREROLL	ED_BASE+565L
#define	ED_TRANSBASIC_POSTROLL		ED_BASE+566L
#define	ED_TRANSBASIC_EDIT_DELAY	ED_BASE+567L
#define	ED_TRANSBASIC_PLAYTC_DELAY	ED_BASE+568L
#define	ED_TRANSBASIC_RECTC_DELAY	ED_BASE+569L
#define ED_TRANSBASIC_EDIT_FIELD	ED_BASE+570L
#define	ED_TRANSBASIC_FRAME_SERVO	ED_BASE+571L
#define	ED_TRANSBASIC_CF_SERVO		ED_BASE+572L
#define	ED_TRANSBASIC_SERVO_REF		ED_BASE+573L	// can be one of the following:
#define	ED_REF_EXTERNAL				ED_BASE+574L
#define	ED_REF_INPUT				ED_BASE+575L
#define	ED_REF_INTERNAL				ED_BASE+576L
#define	ED_REF_AUTO					ED_BASE+577L

#define	ED_TRANSBASIC_WARN_GL		ED_BASE+578L
#define	ED_TRANSBASIC_SET_TRACKING	ED_BASE+579L	// can be one of the following:
#define	ED_TRACKING_PLUS			ED_BASE+580L
#define	ED_TRACKING_MINUS			ED_BASE+581L
#define	ED_TRACKING_RESET			ED_BASE+582L

#define	ED_TRANSBASIC_SET_FREEZE_TIMEOUT	ED_BASE+583L
#define	ED_TRANSBASIC_VOLUME_NAME		ED_BASE+584L
#define	ED_TRANSBASIC_BALLISTIC_1		ED_BASE+585L	// space for proprietary data
#define	ED_TRANSBASIC_BALLISTIC_2		ED_BASE+586L
#define	ED_TRANSBASIC_BALLISTIC_3		ED_BASE+587L
#define	ED_TRANSBASIC_BALLISTIC_4		ED_BASE+588L
#define	ED_TRANSBASIC_BALLISTIC_5		ED_BASE+589L
#define	ED_TRANSBASIC_BALLISTIC_6		ED_BASE+590L
#define	ED_TRANSBASIC_BALLISTIC_7		ED_BASE+591L
#define	ED_TRANSBASIC_BALLISTIC_8		ED_BASE+592L
#define	ED_TRANSBASIC_BALLISTIC_9		ED_BASE+593L
#define	ED_TRANSBASIC_BALLISTIC_10		ED_BASE+594L
#define	ED_TRANSBASIC_BALLISTIC_11		ED_BASE+595L
#define	ED_TRANSBASIC_BALLISTIC_12		ED_BASE+596L
#define	ED_TRANSBASIC_BALLISTIC_13		ED_BASE+597L
#define	ED_TRANSBASIC_BALLISTIC_14		ED_BASE+598L
#define	ED_TRANSBASIC_BALLISTIC_15		ED_BASE+599L
#define	ED_TRANSBASIC_BALLISTIC_16		ED_BASE+600L
#define	ED_TRANSBASIC_BALLISTIC_17		ED_BASE+601L
#define	ED_TRANSBASIC_BALLISTIC_18		ED_BASE+602L
#define	ED_TRANSBASIC_BALLISTIC_19		ED_BASE+603L
#define	ED_TRANSBASIC_BALLISTIC_20		ED_BASE+604L

// consumer VCR items
#define	ED_TRANSBASIC_SETCLOCK			ED_BASE+605L
#define	ED_TRANSBASIC_SET_COUNTER_FORMAT	ED_BASE+606L	// uses time format flags
#define	ED_TRANSBASIC_SET_COUNTER_VALUE	ED_BASE+607L

#define	ED_TRANSBASIC_SETTUNER_CH_UP	ED_BASE+608L
#define	ED_TRANSBASIC_SETTUNER_CH_DN	ED_BASE+609L
#define	ED_TRANSBASIC_SETTUNER_SK_UP	ED_BASE+610L
#define	ED_TRANSBASIC_SETTUNER_SK_DN	ED_BASE+611L
#define	ED_TRANSBASIC_SETTUNER_CH		ED_BASE+612L
#define	ED_TRANSBASIC_SETTUNER_NUM		ED_BASE+613L

#define	ED_TRANSBASIC_SETTIMER_EVENT	ED_BASE+614L
#define	ED_TRANSBASIC_SETTIMER_STARTDAY	ED_BASE+615L
#define	ED_TRANSBASIC_SETTIMER_STARTTIME	ED_BASE+616L
#define	ED_TRANSBASIC_SETTIMER_STOPDAY	ED_BASE+617L
#define	ED_TRANSBASIC_SETTIMER_STOPTIME	ED_BASE+618L

// IAMExtTransport video parameters
#define	ED_TRANSVIDEO_SET_OUTPUT	ED_BASE+630L	// can be one of the following:
#define	ED_E2E						ED_BASE+631L
#define	ED_PLAYBACK					ED_BASE+632L
#define	ED_OFF						ED_BASE+633L

#define	ED_TRANSVIDEO_SET_SOURCE	ED_BASE+634L

// IAMExtTransport audio parameters
#define	ED_TRANSAUDIO_ENABLE_OUTPUT	ED_BASE+640L	// can be the following:
#define	ED_AUDIO_ALL				0x10000000	//	or any of the following OR'd together
#define ED_AUDIO_1					0x0000001L
#define ED_AUDIO_2					0x0000002L
#define ED_AUDIO_3					0x0000004L
#define ED_AUDIO_4					0x0000008L
#define ED_AUDIO_5					0x0000010L
#define ED_AUDIO_6					0x0000020L
#define ED_AUDIO_7					0x0000040L
#define ED_AUDIO_8					0x0000080L
#define ED_AUDIO_9					0x0000100L
#define ED_AUDIO_10					0x0000200L
#define ED_AUDIO_11					0x0000400L
#define ED_AUDIO_12					0x0000800L
#define ED_AUDIO_13					0x0001000L
#define ED_AUDIO_14					0x0002000L
#define ED_AUDIO_15					0x0004000L
#define ED_AUDIO_16					0x0008000L
#define ED_AUDIO_17					0x0010000L
#define ED_AUDIO_18					0x0020000L
#define ED_AUDIO_19					0x0040000L
#define ED_AUDIO_20					0x0080000L
#define ED_AUDIO_21					0x0100000L
#define ED_AUDIO_22					0x0200000L
#define ED_AUDIO_23					0x0400000L
#define ED_AUDIO_24					0x0800000L
#define ED_VIDEO					0x2000000L	// for Edit props below

#define	ED_TRANSAUDIO_ENABLE_RECORD		ED_BASE+642L
#define	ED_TRANSAUDIO_ENABLE_SELSYNC	ED_BASE+643L
#define	ED_TRANSAUDIO_SET_SOURCE		ED_BASE+644L
#define	ED_TRANSAUDIO_SET_MONITOR		ED_BASE+645L


// Edit Property Set-related defs

// The following values reflect (and control) the state of an 
// edit property set
#define ED_INVALID		ED_BASE+652L
#define ED_EXECUTING	ED_BASE+653L
#define ED_REGISTER		ED_BASE+654L
#define ED_DELETE		ED_BASE+655L

// Edit property set parameters and values
#define ED_EDIT_HEVENT	ED_BASE+656L	// event handle to signal event 
										// completion
#define ED_EDIT_TEST	ED_BASE+657L	// returns OAFALSE if filter thinks
										//  edit can be done, OATRUE if not
#define ED_EDIT_IMMEDIATE	ED_BASE+658L	// OATRUE means start put the 
										// device into edit mode (editing
										// "on the fly") immediately upon
										//  execution of Mode(ED_MODE_EDIT_CUE)
#define ED_EDIT_MODE	ED_BASE+659L
// can be one of the following values:
#define ED_EDIT_MODE_ASSEMBLE		ED_BASE+660L
#define ED_EDIT_MODE_INSERT			ED_BASE+661L
#define ED_EDIT_MODE_CRASH_RECORD	ED_BASE+662L
#define ED_EDIT_MODE_BOOKMARK_TIME	ED_BASE+663L		// these two are for
#define ED_EDIT_MODE_BOOKMARK_CHAPTER	ED_BASE+664L	// laserdisks

#define ED_EDIT_MASTER	ED_BASE+666L	// OATRUE causes device 
										//  not to synchronize

#define ED_EDIT_TRACK		ED_BASE+667L
// can be one of the following possible OR'd values:
//	ED_VIDEO, ED_AUDIO_1 thru ED_AUDIO_24 (or ED_AUDIO_ALL)

#define ED_EDIT_SRC_INPOINT		ED_BASE+668L	// in current time format
#define ED_EDIT_SRC_OUTPOINT	ED_BASE+669L	// in current time format
#define ED_EDIT_REC_INPOINT		ED_BASE+670L	// in current time format
#define ED_EDIT_REC_OUTPOINT	ED_BASE+671L	// in current time format

#define ED_EDIT_REHEARSE_MODE	ED_BASE+672L
// can be one of the following possible values:
#define ED_EDIT_BVB		ED_BASE+673L	// means rehearse the edit with 
										//  "black-video-black"
#define ED_EDIT_VBV		ED_BASE+674L
#define ED_EDIT_VVV		ED_BASE+675L
#define ED_EDIT_PERFORM	ED_BASE+676L	// means perform the edit with no 
										//  rehearsal.

// Set this property to OATRUE to kill the edit if in progress
#define ED_EDIT_ABORT	ED_BASE+677L
// how long to wait for edit to complete
#define ED_EDIT_TIMEOUT	ED_BASE+678L		// in current time format

// This property causes the device to seek to a point specified by
// ED_EDIT_SEEK_MODE (see below).  NOTE: Only one event at a time can seek.
#define ED_EDIT_SEEK		ED_BASE+679L	// OATRUE means do it now.  
#define ED_EDIT_SEEK_MODE	ED_BASE+680L
//possible values:
#define ED_EDIT_SEEK_EDIT_IN	ED_BASE+681L	// seek to edit's inpoint
#define ED_EDIT_SEEK_EDIT_OUT	ED_BASE+682L	// seek to edit's outpoint
#define ED_EDIT_SEEK_PREROLL	ED_BASE+683L	// seek to edit's 
												//  inpoint-preroll
#define ED_EDIT_SEEK_PREROLL_CT	ED_BASE+684L	// seek to preroll point 
							// using control track (used for tapes with 
							// discontinuoustimecode before edit point: seek
							// to inpoint using timecode, then backup to 
							// preroll point using control track)
#define ED_EDIT_SEEK_BOOKMARK	ED_BASE+685L	// seek to bookmark (just like 
												//  timecode search)
// This property is used for multiple-VCR systems where each machine must
//  cue to a different location relative to the graph's reference clock.  The
//  basic idea is that an edit event is setup with an ED_EDIT_OFFSET property
//  that tells the VCR what offset to maintain between it's timecode (converted
//	to reference clock units) and the reference clock.
#define ED_EDIT_OFFSET	ED_BASE+686L		// in current time format

#define ED_EDIT_PREREAD	ED_BASE+815L		// OATRUE means device supports
											//  pre-read (recorder can also be
											//  player

//
// Some error codes:
// 
// device could be in local mode
#define ED_ERR_DEVICE_NOT_READY		ED_BASE+700L

#endif // __EDEVDEFS__

// eof edevdefs.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\include\il21dec.h ===
//------------------------------------------------------------------------------
// File: IL21Dec.h
//
// Desc: Line 21 Decoder related definitions and interfaces for ActiveMovie.
//
// Copyright (c) 1992 - 2000, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __IL21DEC__
#define __IL21DEC__


//
//  Some enum data types used as line 21 decoder params by the interface
//
typedef enum _AM_LINE21_CCLEVEL {  // should we use TC1, TC2 in stead?
    AM_L21_CCLEVEL_TC2 = 0
} AM_LINE21_CCLEVEL, *PAM_LINE21_CCLEVEL ;

typedef enum _AM_LINE21_CCSERVICE {
    AM_L21_CCSERVICE_None = 0,
    AM_L21_CCSERVICE_Caption1,
    AM_L21_CCSERVICE_Caption2,
    AM_L21_CCSERVICE_Text1,
    AM_L21_CCSERVICE_Text2,
    AM_L21_CCSERVICE_XDS,
    AM_L21_CCSERVICE_DefChannel = 10,
    AM_L21_CCSERVICE_Invalid
} AM_LINE21_CCSERVICE, *PAM_LINE21_CCSERVICE ;

typedef enum _AM_LINE21_CCSTATE {
    AM_L21_CCSTATE_Off = 0,
    AM_L21_CCSTATE_On
} AM_LINE21_CCSTATE, *PAM_LINE21_CCSTATE ;

typedef enum _AM_LINE21_CCSTYLE {
    AM_L21_CCSTYLE_None = 0,
    AM_L21_CCSTYLE_PopOn,
    AM_L21_CCSTYLE_PaintOn,
    AM_L21_CCSTYLE_RollUp
} AM_LINE21_CCSTYLE, *PAM_LINE21_CCSTYLE ;

typedef enum _AM_LINE21_DRAWBGMODE {
    AM_L21_DRAWBGMODE_Opaque,
    AM_L21_DRAWBGMODE_Transparent
} AM_LINE21_DRAWBGMODE, *PAM_LINE21_DRAWBGMODE ;


#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//
//  Line 21 Decoder standard COM interface
//
DECLARE_INTERFACE_(IAMLine21Decoder, IUnknown)
{
    public:
        //
        // Decoder options to be used by apps
        //

        // What is the decoder's level
        STDMETHOD(GetDecoderLevel)(THIS_ AM_LINE21_CCLEVEL *lpLevel) PURE ;  
        // supported level value is AM_L21Level_TC2 only
        // skipping the SetDecoderLevel( )

        // Which of the services is being currently used
        STDMETHOD(GetCurrentService)(THIS_ AM_LINE21_CCSERVICE *lpService) PURE ;  
        STDMETHOD(SetCurrentService)(THIS_ AM_LINE21_CCSERVICE Service) PURE ;  
        // supported service values are AM_L21Service_Caption1, 
        // AM_L21Service_Caption2, AM_L21Service_Text1, AM_L21Service_Text2, 
        // AM_L21Service_XDS, AM_L21Service_None)

        // Query/Set the service state (On/Off)
        // supported state values are AM_L21State_On and AM_L21State_Off
        STDMETHOD(GetServiceState)(THIS_ AM_LINE21_CCSTATE *lpState) PURE ;  
        STDMETHOD(SetServiceState)(THIS_ AM_LINE21_CCSTATE State) PURE ;  

        //
        // Output options to be used by downstream filters
        //

        // What size, bitdepth etc should the output video be
        STDMETHOD(GetOutputFormat)(THIS_ LPBITMAPINFOHEADER lpbmih) PURE ;
        // GetOutputFormat() method, if successful, returns 
        // 1.  S_FALSE if no output format has so far been defined by downstream filters
        // 2.  S_OK if an output format has already been defined by downstream filters
        STDMETHOD(SetOutputFormat)(THIS_ LPBITMAPINFO lpbmi) PURE ;

        // Specify physical color to be used in colorkeying the background 
        // for overlay mixing
        STDMETHOD(GetBackgroundColor)(THIS_ DWORD *pdwPhysColor) PURE ;
        STDMETHOD(SetBackgroundColor)(THIS_ DWORD dwPhysColor) PURE ;

        // Specify if whole output bitmap should be redrawn for each sample
        STDMETHOD(GetRedrawAlways)(THIS_ LPBOOL lpbOption) PURE ;
        STDMETHOD(SetRedrawAlways)(THIS_ BOOL bOption) PURE ;

        // Specify if the caption text background should be opaque/transparent
        STDMETHOD(GetDrawBackgroundMode)(THIS_ AM_LINE21_DRAWBGMODE *lpMode) PURE ;
        STDMETHOD(SetDrawBackgroundMode)(THIS_ AM_LINE21_DRAWBGMODE Mode) PURE ;
        // supported mode values are AM_L21_DrawBGMode_Opaque and
        // AM_L21_DrawBGMode_Transparent

} ;

#ifdef __cplusplus
}
#endif // __cplusplus
#endif // __IL21DEC__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\include\iwstdec.h ===
// WST Decoder related definitions and interfaces for ActiveMovie

#ifndef __IWSTDEC__
#define __IWSTDEC__

//
//  Some data types used as WST decoder parameters by the interface
//
typedef struct _AM_WST_PAGE {
	DWORD	dwPageNr ;
	DWORD	dwSubPageNr ;
	BYTE	*pucPageData;
} AM_WST_PAGE, *PAM_WST_PAGE ;

typedef enum _AM_WST_LEVEL {
	AM_WST_LEVEL_1_5 = 0
} AM_WST_LEVEL, *PAM_WST_LEVEL ;

typedef enum _AM_WST_SERVICE {
	AM_WST_SERVICE_None = 0,
	AM_WST_SERVICE_Text,
	AM_WST_SERVICE_IDS,
	AM_WST_SERVICE_Invalid
} AM_WST_SERVICE, *PAM_WST_SERVICE ;

typedef enum _AM_WST_STATE {
	AM_WST_STATE_Off = 0,
	AM_WST_STATE_On
} AM_WST_STATE, *PAM_WST_STATE ;

typedef enum _AM_WST_STYLE {
	AM_WST_STYLE_None = 0,
	AM_WST_STYLE_Invers
} AM_WST_STYLE, *PAM_WST_STYLE ;

typedef enum _AM_WST_DRAWBGMODE {
	AM_WST_DRAWBGMODE_Opaque,
	AM_WST_DRAWBGMODE_Transparent
} AM_WST_DRAWBGMODE, *PAM_WST_DRAWBGMODE ;


#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//
//  WST Decoder standard COM interface
//
DECLARE_INTERFACE_(IAMWstDecoder, IUnknown)
{
	public:
		//
		// Decoder options to be used by apps
		//

		// What is the decoder's level
		STDMETHOD(GetDecoderLevel)(THIS_ AM_WST_LEVEL *lpLevel) PURE ;  

//		STDMETHOD(SetDecoderLevel)(THIS_ AM_WST_LEVEL Level) PURE ;  

		// Which of the services is being currently used
		STDMETHOD(GetCurrentService)(THIS_ AM_WST_SERVICE *lpService) PURE ;  
//		STDMETHOD(SetCurrentService)(THIS_ AM_WST_SERVICE Service) PURE ;  

		// Query/Set the service state (On/Off)
		// supported state values are AM_WSTState_On and AM_WSTState_Off
		STDMETHOD(GetServiceState)(THIS_ AM_WST_STATE *lpState) PURE ;  
		STDMETHOD(SetServiceState)(THIS_ AM_WST_STATE State) PURE ;  

		//
		// Output options to be used by downstream filters
		//

		// What size, bitdepth etc should the output video be
		STDMETHOD(GetOutputFormat)(THIS_ LPBITMAPINFOHEADER lpbmih) PURE ;
		// GetOutputFormat() method, if successful, returns 
		// 1.  S_FALSE if no output format has so far been defined by downstream filters
		// 2.  S_OK if an output format has already been defined by downstream filters
		STDMETHOD(SetOutputFormat)(THIS_ LPBITMAPINFO lpbmi) PURE ;

		// Specify physical color to be used in colorkeying the background 
		// for overlay mixing
		STDMETHOD(GetBackgroundColor)(THIS_ DWORD *pdwPhysColor) PURE ;
		STDMETHOD(SetBackgroundColor)(THIS_ DWORD dwPhysColor) PURE ;

		// Specify if whole output bitmap should be redrawn for each sample
		STDMETHOD(GetRedrawAlways)(THIS_ LPBOOL lpbOption) PURE ;
		STDMETHOD(SetRedrawAlways)(THIS_ BOOL bOption) PURE ;

		// Specify if the caption text background should be opaque/transparent
		STDMETHOD(GetDrawBackgroundMode)(THIS_ AM_WST_DRAWBGMODE *lpMode) PURE ;
		STDMETHOD(SetDrawBackgroundMode)(THIS_ AM_WST_DRAWBGMODE Mode) PURE ;
		// supported mode values are AM_WST_DrawBGMode_Opaque and
		// AM_WST_DrawBGMode_Transparent

		STDMETHOD(SetAnswerMode)(THIS_ BOOL bAnswer) PURE ;
		STDMETHOD(GetAnswerMode)(THIS_ BOOL* pbAnswer) PURE ;

		STDMETHOD(SetHoldPage)(THIS_ BOOL bHoldPage) PURE ;
		STDMETHOD(GetHoldPage)(THIS_ BOOL* pbHoldPage) PURE ;

		STDMETHOD(GetCurrentPage)(THIS_ PAM_WST_PAGE pWstPage) PURE;
		STDMETHOD(SetCurrentPage)(THIS_ AM_WST_PAGE WstPage) PURE;

} ;

#ifdef __cplusplus
}
#endif // __cplusplus
#endif // __IWSTDEC__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\include\evcode.h ===
//------------------------------------------------------------------------------
// File: EvCode.h
//
// Desc: List of standard Quartz event codes and the expected params.
//
// Copyright (c) 1992 - 2000, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


// Event codes are broken into two groups
//   -- system event codes
//   -- extension event codes
// All system event codes are below EC_USER

#define EC_SYSTEMBASE                       0x00
#define EC_USER                             0x8000

// System-defined event codes
// ==========================
//
// There are three types of system-defined event codes:
//
// 1.  Those which are always passed through to the application
//     (To be collected by calls to GetEvent or within WaitForCompletion.)
//     (e.g. EC_ERRORABORT, EC_USERABORT.)
//
// 2.  Those which are pure internal and will never be passed to
//     the application.  (e.g. EC_SHUTDOWN)
//
// 3.  Those which have default handling.  Default handing implies that
//     the event is not passed to the application.  However, default
//     handling may be canceled by calling
//     IMediaEvent::CancelDefaultHandling.  If the default handling is
//     cancelled in this way, then the message will be delivered to the
//     application and the application must action it appropriately.
//     Default handling can be restored by calling RestoreDefaultHandling.
//
// We will refer to these events as application, internal and defaulted
// events respectively.
//
// System-defined events may have interface pointers, BSTR's, etc passed
// as parameters.  It is therefore essential that, for any message
// retrieved using GetEvent, a matching call to FreeEventParams is made
// to ensure that relevant interfaces are released and storage freed.
// Failure to call FreeEventParams will result in memory leaks, if not
// worse.
//
// Filters sending these messages to the filter graph should not AddRef()
// any interfaces that they may pass as parameters.  The filter graph
// manager will AddRef them if required.  E.g. if the event is to be queued
// for the application or queued to a worker thread.

// Each event listed below is immediately followed by a parameter list
// detailing the types of the parameters associated with the message,
// and an indication of whether the message is an application, internal
// or defaulted message.  This is then followed by a short description.
// The use of "void" in the parameter list implies that the parameter is not
// used.  Such parameters should be zero.

// Other defined EC_ regions:
// DVD event codes              0x0100 - 0x0150 (dvdevcod.h)
// audio device event codes     0x0200 - 0x0250 (audevcod.h)
// WindowsMedia SDK-originated events 0x0251 - 0x0300 (see below)
// MSVIDCTL                     0x0301 - 0x0325 (msvidctl.idl)
// stream buffer engine (PVR)   0x0326 - 0x0350 (sbe.idl)

#define EC_COMPLETE                         0x01
// ( HRESULT, void ) : defaulted (special)
// Signals the completed playback of a stream within the graph.  This message
// is sent by renderers when they receive end-of-stream.  The default handling
// of this message results in a _SINGLE_ EC_COMPLETE being sent to the
// application when ALL of the individual renderers have signaled EC_COMPLETE
// to the filter graph.  If the default handing is canceled, the application
// will see all of the individual EC_COMPLETEs.


#define EC_USERABORT                        0x02
// ( void, void ) : application
// In some sense, the user has requested that playback be terminated.
// This message is typically sent by renderers that render into a
// window if the user closes the window into which it was rendering.
// It is up to the application to decide if playback should actually
// be stopped.


#define EC_ERRORABORT                       0x03
// ( HRESULT, void ) : application
// Operation aborted because of error


#define EC_TIME                             0x04
// ( DWORD, DWORD ) : application
// The requested reference time occurred.  (This event is currently not used).
// lParam1 is low dword of ref time, lParam2 is high dword of reftime.


#define EC_REPAINT                          0x05
// ( IPin * (could be NULL), void ) : defaulted
// A repaint is required - lParam1 contains the (IPin *) that needs the data
// to be sent again. Default handling is: if the output pin which the IPin is
// attached  to supports the IMediaEventSink interface then it will be called
// with the EC_REPAINT first.  If that fails then normal repaint processing is
// done by the filter graph.


// Stream error notifications
#define EC_STREAM_ERROR_STOPPED             0x06
#define EC_STREAM_ERROR_STILLPLAYING        0x07
// ( HRESULT, DWORD ) : application
// lParam 1 is major code, lParam2 is minor code, either may be zero.


#define EC_ERROR_STILLPLAYING               0x08
// ( HRESULT, void ) : application
// The filter graph manager may issue Run's to the graph asynchronously.
// If such a Run fails, EC_ERROR_STILLPLAYING is issued to notify the
// application of the failure.  The state of the underlying filters
// at such a time will be indeterminate - they will all have been asked
// to run, but some are almost certainly not.


#define EC_PALETTE_CHANGED                  0x09
// ( void, void ) : application
// notify application that the video palette has changed


#define EC_VIDEO_SIZE_CHANGED               0x0A
// ( DWORD, void ) : application
// Sent by video renderers.
// Notifies the application that the native video size has changed.
// LOWORD of the DWORD is the new width, HIWORD is the new height.


#define EC_QUALITY_CHANGE                   0x0B
// ( void, void ) : application
// Notify application that playback degradation has occurred


#define EC_SHUTTING_DOWN                    0x0C
// ( void, void ) : internal
// This message is sent by the filter graph manager to any plug-in
// distributors which support IMediaEventSink to notify them that
// the filter graph is starting to shutdown.


#define EC_CLOCK_CHANGED                    0x0D
// ( void, void ) : application
// Notify application that the clock has changed.
// (i.e. SetSyncSource has been called on the filter graph and has been
// distributed successfully to the filters in the graph.)


#define EC_PAUSED                           0x0E
// ( HRESULT, void ) : application
// Notify application the previous pause request has completed


#define EC_OPENING_FILE                     0x10
#define EC_BUFFERING_DATA                   0x11
// ( BOOL, void ) : application
// lParam1 == 1   --> starting to open file or buffer data
// lParam1 == 0   --> not opening or buffering any more
// (This event does not appear to be used by ActiveMovie.)


#define EC_FULLSCREEN_LOST                  0x12
// ( void, IBaseFilter * ) : application
// Sent by full screen renderers when switched away from full screen.
// IBaseFilter may be NULL.


#define EC_ACTIVATE                         0x13
// ( BOOL, IBaseFilter * ) : internal
// Sent by video renderers when they lose or gain activation.
// lParam1 is set to 1 if gained or 0 if lost
// lParam2 is the IBaseFilter* for the filter that is sending the message
// Used for sound follows focus and full-screen switching


#define EC_NEED_RESTART                     0x14
// ( void, void ) : defaulted
// Sent by renderers when they regain a resource (e.g. audio renderer).
// Causes a restart by Pause/put_Current/Run (if running).


#define EC_WINDOW_DESTROYED                 0x15
// ( IBaseFilter *, void ) : internal
// Sent by video renderers when the window has been destroyed. Handled
// by the filter graph / distributor telling the resource manager.
// lParam1 is the IBaseFilter* of the filter whose window is being destroyed


#define EC_DISPLAY_CHANGED                  0x16
// ( IPin *, void ) : internal
// Sent by renderers when they detect a display change. the filter graph
// will arrange for the graph to be stopped and the pin send in lParam1
// to be reconnected. by being reconnected it allows a renderer to reset
// and connect with a more appropriate format for the new display mode
// lParam1 contains an (IPin *) that should be reconnected by the graph


#define EC_STARVATION                       0x17
// ( void, void ) : defaulted
// Sent by a filter when it detects starvation. Default handling (only when
// running) is for the graph to be paused until all filters enter the
// paused state and then run. Normally this would be sent by a parser or source
// filter when too little data is arriving.


#define EC_OLE_EVENT                        0x18
// ( BSTR, BSTR ) : application
// Sent by a filter to pass a text string to the application.
// Conventionally, the first string is a type, and the second a parameter.


#define EC_NOTIFY_WINDOW                    0x19
// ( HWND, void ) : internal
// Pass the window handle around during pin connection.

#define EC_STREAM_CONTROL_STOPPED           0x1A
// ( IPin * pSender, DWORD dwCookie )
// Notification that an earlier call to IAMStreamControl::StopAt
// has now take effect.  Calls to the method can be marked
// with a cookie which is passed back in the second parameter,
// allowing applications to easily tie together request
// and completion notifications.
//
// NB: IPin will point to the pin that actioned the Stop.  This
// may not be the pin that the StopAt was sent to.

#define EC_STREAM_CONTROL_STARTED           0x1B
// ( IPin * pSender, DWORD dwCookie )
// Notification that an earlier call to IAMStreamControl::StartAt
// has now take effect.  Calls to the method can be marked
// with a cookie which is passed back in the second parameter,
// allowing applications to easily tie together request
// and completion notifications.
//
// NB: IPin will point to the pin that actioned the Start.  This
// may not be the pin that the StartAt was sent to.

#define EC_END_OF_SEGMENT                   0x1C
//
// ( const REFERENCE_TIME *pStreamTimeAtEndOfSegment, DWORD dwSegmentNumber )
//
// pStreamTimeAtEndOfSegment
//     pointer to the accumulated stream clock
//     time since the start of the segment - this is directly computable
//     as the sum of the previous and current segment durations (Stop - Start)
//     and the rate applied to each segment
//     The source add this time to the time within each segment to get
//     a total elapsed time
//
// dwSegmentNumber
//     Segment number - starts at 0
//
// Notifies that a segment end has been reached when the
// AM_SEEKING_Segment flags was set for IMediaSeeking::SetPositions
// Passes in an IMediaSeeking interface to allow the next segment
// to be defined by the application

#define EC_SEGMENT_STARTED                  0x1D
//
// ( const REFERENCE_TIME *pStreamTimeAtStartOfSegment, DWORD dwSegmentNumber)
//
// pStreamTimeAtStartOfSegment
//     pointer to the accumulated stream clock
//     time since the start of the segment - this is directly computable
//     as the sum of the previous segment durations (Stop - Start)
//     and the rate applied to each segment
//
// dwSegmentNumber
//     Segment number - starts at 0
//
// Notifies that a new segment has been started.
// This is sent synchronously by any entity that will issue
// EC_END_OF_SEGMENT when a new segment is started
// (See IMediaSeeking::SetPositions - AM_SEEKING_Segment flag)
// It is used to compute how many EC_END_OF_SEGMENT notifications
// to expect at the end of a segment and as a consitency check


#define EC_LENGTH_CHANGED                  0x1E
// (void, void)
// sent to indicate that the length of the "file" has changed

#define EC_DEVICE_LOST                     0x1f
// (IUnknown, 0)
//
// request window notification when the device is available again
// (through WM_DEVICECHANGED messages registered with
// RegisterDeviceNotification; see IAMDeviceRemoval interface)

#define EC_STEP_COMPLETE                      0x24
// (BOOL bCacelled, void)
// Step request complete
// if bCancelled is TRUE the step was cancelled.  This can happen
// if the application issued some control request or because there
// was a mode change etc etc

// Event code 25 is reserved for future use.

#define EC_TIMECODE_AVAILABLE           0x30
// Sent by filter supporting timecode
// Param1 has a pointer to the sending object
// Param2 has the device ID of the sending object

#define EC_EXTDEVICE_MODE_CHANGE        0x31
// Sent by filter supporting IAMExtDevice
// Param1 has the new mode
// Param2 has the device ID of the sending object

#define EC_STATE_CHANGE                    0x32
// ( FILTER_STATE, BOOL bInternal)
// Used to notify the application of any state changes in the filter graph.
// lParam1  is of type enum FILTER_STATE (defined in strmif.h) and indicates
//          the state of the filter graph.
//
// lParam2 == 0 indicates that the previous state change request has completed
//              & a change in application state.
// lParam2 == 1 reserved for future use to indicate internal state changes.


#define EC_GRAPH_CHANGED                        0x50
// Sent by filter to notify interesting graph changes

#define EC_CLOCK_UNSET                      0x51
// ( void, void ) : application
// Used to notify the filter graph to unset the current graph clock.
// Has the affect of forcing the filter graph to reestablish the graph clock
// on the next Pause/Run (note that this is only used by ksproxy, when the pin
// of a clock providing filter is disconnected)

#define EC_VMR_RENDERDEVICE_SET                 0x53
// (Render_Device type, void)
// Identifies the type of rendering mechanism the VMR
// is using to display video.  Types used include:
#define VMR_RENDER_DEVICE_OVERLAY       0x01
#define VMR_RENDER_DEVICE_VIDMEM        0x02
#define VMR_RENDER_DEVICE_SYSMEM        0x04


#define EC_VMR_SURFACE_FLIPPED          0x54
// (hr - Flip return code, void)
// Identifies the VMR's allocator-presenter has called the DDraw flip api on
// the surface being presented.   This allows the VMR to keep its DX-VA table
// of DDraw surfaces in sync with DDraws flipping chain.

#define EC_VMR_RECONNECTION_FAILED      0x55
// (hr - ReceiveConnection return code, void)
// Identifies that an upstream decoder tried to perform a dynamic format
// change and the VMR was unable to accept the new format.



//------------------------------------------
//
//  BDA events:
//
//      Event code 0x80 through 0x8f are reserved for BDA
//


//------------------------------------------
//
// WindowsMedia SDK filter-specific events:
//
//
// Note that for EC_WMT_EVENT events the wmsdk-based filters use the following structure for
// passing event parameters to the app:
#ifndef AM_WMT_EVENT_DATA_DEFINED
#define AM_WMT_EVENT_DATA_DEFINED
typedef struct {
    HRESULT hrStatus;        // status code
    void * pData;            // event data
} AM_WMT_EVENT_DATA;
#endif
//
#define EC_WMT_EVENT_BASE                  0x0251
//
#define EC_WMT_INDEX_EVENT                  EC_WMT_EVENT_BASE
// WindowsMedia SDK-originated file indexing status, sent by WMSDK-based filters
//
// lParam1 is one of the enum WMT_STATUS messages listed below, sent by the WindowsMedia SDK
// lParam2 is specific to the lParam event
//
//     the following WMT_STATUS messages are sent for this event:
//         WMT_STARTED        - lParam2 is 0
//         WMT_CLOSED         - lParam2 is 0
//         WMT_INDEX_PROGRESS - lParam2 is a DWORD containing the progress percent complete
//
#define EC_WMT_EVENT                        EC_WMT_EVENT_BASE+1
// WindowsMedia SDK-originated event, sent by WMSDK-based filters
//
// lParam1 is one of the enum WMT_STATUS messages listed below, sent by the WindowsMedia SDK
// lParam2 is a pointer an AM_WMT_EVENT_DATA structure where,
//                          hrStatus is the status code sent by the wmsdk
//                          pData is specific to the lParam1 event
//
//     the following WMT_STATUS messages are sent by the WMSDK Reader filter for this event:
//         WMT_NO_RIGHTS        - pData is a pointer to a WCHAR string containing a challenge URL
//         WMT_ACQUIRE_LICENSE  - lParam2 is a pointer to a WM_GET_LICENSE_DATA struct
//         WMT_NO_RIGHTS_EX     - lParam2 is a pointer to a WM_GET_LICENSE_DATA struct
//         WMT_NEEDS_INDIVIDUALIZATION - lParam2 is NULL
//         WMT_INDIVIDUALIZE    - lParam2 is a pointer to a WM_INDIVIDUALIZE_STATUS struct
//
// end WMSDK-originated events
//-----------------------------------------


#define EC_BUILT                            0x300
// Sent to notify transition from unbuilt to built state


#define EC_UNBUILT                          0x301
// Sent to notify transtion from built to unbuilt state
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\include\mpegtype.h ===
//------------------------------------------------------------------------------
// File: MPEGType.h
//
// Desc: MPEG system stream compound type definition
//
// Copyright (c) 1996 - 2000, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __MPEGTYPE__
#define __MPEGTYPE__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//
//  AM_MPEGSYSTEMTYPE defines the format block contents for
//  data of type MEDIATYPE_MPEG1System when the format
//  block GUID is FORMAT_MPEG1System
//
//  The format block consists of elements of type
//  AM_MPEGSYSTEMTYPE up to the length of the format block
//  Each format block is 8-byte aligned from the start of
//  the format block
//

typedef struct tagAM_MPEGSTREAMTYPE
{
    DWORD             dwStreamId;     // Stream id of stream to process
    DWORD             dwReserved;     // 8-byte alignment
    AM_MEDIA_TYPE     mt;             // Type for substream - pbFormat is NULL
    BYTE              bFormat[1];     // Format data
} AM_MPEGSTREAMTYPE;

typedef struct tagAM_MPEGSYSTEMTYPE
{
    DWORD             dwBitRate;      // Bits per second
    DWORD             cStreams;       // Number of streams
    AM_MPEGSTREAMTYPE Streams[1];
} AM_MPEGSYSTEMTYPE;

//
//  Helper macros for AM_MPEGSTREAMTYPE
//
#define AM_MPEGSTREAMTYPE_ELEMENTLENGTH(pStreamType)  \
    FIELD_OFFSET(AM_MPEGSTREAMTYPE, bFormat[(pStreamType)->mt.cbFormat])
#define AM_MPEGSTREAMTYPE_NEXT(pStreamType)           \
    ((AM_MPEGSTREAMTYPE *)((PBYTE)(pStreamType) +     \
     ((AM_MPEGSTREAMTYPE_ELEMENTLENGTH(pStreamType) + 7) & ~7)))

//
// IMpegAudioDecoder
//

// Values for DualMode
#define AM_MPEG_AUDIO_DUAL_MERGE 0
#define AM_MPEG_AUDIO_DUAL_LEFT  1
#define AM_MPEG_AUDIO_DUAL_RIGHT 2

DECLARE_INTERFACE_(IMpegAudioDecoder, IUnknown) {

    STDMETHOD(get_FrequencyDivider) (THIS_
                           unsigned long *pDivider   /* [out] */
                           ) PURE;

    STDMETHOD(put_FrequencyDivider) (THIS_
                           unsigned long Divider     /* [in] */
                           ) PURE;

    STDMETHOD(get_DecoderAccuracy) (THIS_
                           unsigned long *pAccuracy  /* [out] */
                           ) PURE;

    STDMETHOD(put_DecoderAccuracy) (THIS_
                           unsigned long Accuracy    /* [in] */
                           ) PURE;

    STDMETHOD(get_Stereo) (THIS_
                           unsigned long *pStereo    /* [out] */
                           ) PURE;

    STDMETHOD(put_Stereo) (THIS_
                           unsigned long Stereo      /* [in] */
                           ) PURE;

    STDMETHOD(get_DecoderWordSize) (THIS_
                           unsigned long *pWordSize  /* [out] */
                           ) PURE;

    STDMETHOD(put_DecoderWordSize) (THIS_
                           unsigned long WordSize    /* [in] */
                           ) PURE;

    STDMETHOD(get_IntegerDecode) (THIS_
                           unsigned long *pIntDecode /* [out] */
                           ) PURE;

    STDMETHOD(put_IntegerDecode) (THIS_
                           unsigned long IntDecode   /* [in] */
                           ) PURE;

    STDMETHOD(get_DualMode) (THIS_
                           unsigned long *pIntDecode /* [out] */
                           ) PURE;

    STDMETHOD(put_DualMode) (THIS_
                           unsigned long IntDecode   /* [in] */
                           ) PURE;

    STDMETHOD(get_AudioFormat) (THIS_
                           MPEG1WAVEFORMAT *lpFmt    /* [out] */
                           ) PURE;
};

#ifdef __cplusplus
}
#endif // __cplusplus
#endif // __MPEGTYPE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\include\mpconfig.h ===
//------------------------------------------------------------------------------
// File: MPConfig.h
//
// Desc: 
//
// Copyright (c) 1997 - 2000, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __IMPConfig__
#define __IMPConfig__

#ifdef __cplusplus
extern "C" {
#endif

typedef enum _AM_ASPECT_RATIO_MODE
{
    AM_ARMODE_STRETCHED,	    // don't do any aspect ratio correction
    AM_ARMODE_LETTER_BOX,	    // letter box the video, paint background color in the excess region
    AM_ARMODE_CROP,		    // crop the video to the right aspect ratio
    AM_ARMODE_STRETCHED_AS_PRIMARY  // follow whatever the primary stream does (in terms of the mode as well as pict-aspect-ratio values)
} AM_ASPECT_RATIO_MODE;


DECLARE_INTERFACE_(IMixerPinConfig, IUnknown)
{
    // this function sets the position of the stream in the display window, assuming 
    // that the window coordinates are {0, 0, 10000, 10000}. Thus giving arguments
    // (0, 0, 5000, 5000) will put the stream in the top-left quarter. Any value greater
    // than 10000 is invalid.
    STDMETHOD (SetRelativePosition)(THIS_ 
				    IN DWORD dwLeft,
				    IN DWORD dwTop,
				    IN DWORD dwRight,
				    IN DWORD dwBottom
				   ) PURE;

    // this function gets the position of the stream in the display window, assuming 
    // that the window coordinates are {0, 0, 10000, 10000}. Thus if the values returned
    // are (0, 0, 5000, 5000), then it means that the stream is in the top-left quarter. 
    STDMETHOD (GetRelativePosition)(THIS_ 
				    OUT DWORD *pdwLeft,
				    OUT DWORD *pdwTop,
				    OUT DWORD *pdwRight,
				    OUT DWORD *pdwBottom
				   ) PURE;

    // this function sets the ZOrder of the stream. The ZOrder of 0 is the closest
    // to the eyes of the user, and increasing values imply greater distance.
    STDMETHOD (SetZOrder)(THIS_ 
			  IN DWORD dwZOrder
			 ) PURE;


    // this function gets the ZOrder of the stream. The ZOrder of 0 is the closest
    // to the eyes of the user, and increasing values imply greater distance.
    STDMETHOD (GetZOrder)(THIS_ 
			  OUT DWORD *pdwZOrder
			 ) PURE;

    // this function sets the colorkey being used by the stream. Setting this value on the 
    // primary stream sets the destination colorkey being used by the overlay surface. Setting
    // this value on the secondary pin makes sense only if the stream is transparent. By default
    // the destination colorkey is used as the colorkey for all transparent (secondary) streams.
    STDMETHOD (SetColorKey)(THIS_ 
			    IN COLORKEY *pColorKey
			   ) PURE;

    // this function gets the colorkey being used by the stream. Getting this value on the 
    // primary stream gets the destination colorkey being used by the overlay surface. Getting
    // this value on the secondary pin returns the colorkey being used by that particular stream.
    // When using this method, you are allowed to pass NULL for either pColorKey or pColor but 
    // not both.
    STDMETHOD (GetColorKey)(THIS_ 
			    OUT COLORKEY *pColorKey,
			    OUT DWORD *pColor
			   ) PURE;

    // this function sets the blending parameter which in turn defines, how the secondary stream 
    // is going to be blended with the primary stream. A value of 0 makes the secondary stream 
    // invisible, a value of 255 makes the primary stream invisible (in that region only ofcourse),
    // and any value inbetween, say x, blends the secondary and primary streams in the ratio x : (255-x).
    // If no value is set, the default is 255.
    // Any value less than 0 or greater than 255 is invalid. Calling this function on the primary
    // stream would result in a return value of E_UNEXPECTED.
    STDMETHOD (SetBlendingParameter)(THIS_ 
				     IN DWORD dwBlendingParameter
				    ) PURE;

    // this function gets the blending parameter which in turn defines, how the secondary stream 
    // is currently being blended with the primary stream. 
    STDMETHOD (GetBlendingParameter)(THIS_ 
				     OUT DWORD *pdwBlendingParameter
				    ) PURE;


    // this function is used to set the Aspect Ratio Correction mode on the pin. 
    // If the mode is set to letter box, black color is painted on the excess region 
    STDMETHOD (SetAspectRatioMode)(THIS_ 
				   IN AM_ASPECT_RATIO_MODE amAspectRatioMode
				  ) PURE;

    // this function is used to get the Aspect Ratio Correction mode on the pin.  
    STDMETHOD (GetAspectRatioMode)(THIS_ 
				   OUT AM_ASPECT_RATIO_MODE* pamAspectRatioMode
				  ) PURE;

    // this function sets the stream to be transparent. That means that the stream is not going
    // to occupy the whole of the rectangle (specified by SetRelativePosition), some of the region
    // is going to be transparent i.e. the stream underneath, is going to see through.
    // Calling this function on the primary stream would result in a return value of E_UNEXPECTED.
    STDMETHOD (SetStreamTransparent)(THIS_ 
				     IN BOOL bStreamTransparent
				    ) PURE;

    // this function is used to tell whether the stream is transparent or not. 
    STDMETHOD (GetStreamTransparent)(THIS_ 
				     OUT BOOL *pbStreamTransparent
				    ) PURE;
};


DECLARE_INTERFACE_(IMixerPinConfig2, IMixerPinConfig)
{
    // this functions sets the color-controls, if the vga chip supports it.
    STDMETHOD (SetOverlaySurfaceColorControls)(THIS_ 
					       IN LPDDCOLORCONTROL pColorControl
					      ) PURE;

    // this functions gets the color-controls. It also returns the capability of the vga hardware 
    // in the dwFlags value of the struct.
    STDMETHOD (GetOverlaySurfaceColorControls)(THIS_ 
					       OUT LPDDCOLORCONTROL pColorControl
					      ) PURE;
};

#ifdef __cplusplus
}
#endif


#endif // #define __IMPConfig__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\include\tune.h ===
//------------------------------------------------------------------------------
// File: Tune.h
//
// Desc: Additional infrastructure to extend the tuner.idl.  Works nicely
//       from C++.
//
// Copyright (c) 1999 - 2001, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#pragma once

#ifndef TUNE_H
#define TUNE_H

#include <tuner.h>

namespace BDATuningModel {

const long DEFAULT_MIN_CHANNEL = 2;
const long DEFAULT_MAX_CHANNEL = 999;
const long DEFAULT_MIN_FREQUENCY = 535;  //bottom us am
const long DEFAULT_MAX_FREQUENCY = 108000; // top us fm
const long DEFAULT_ANALOG_TUNER_COUNTRY_CODE = 1; //usa
const TunerInputType DEFAULT_ANALOG_TUNER_INPUT_TYPE = TunerInputCable; //usa

typedef CComQIPtr<ITuningSpaceContainer> PQTuningSpaceContainer;
typedef CComQIPtr<ITuningSpace> PQTuningSpace;
typedef CComQIPtr<IAnalogRadioTuningSpace> PQAnalogRadioTuningSpace;
typedef CComQIPtr<IAnalogTVTuningSpace> PQAnalogTVTuningSpace;
typedef CComQIPtr<IATSCTuningSpace> PQATSCTuningSpace;
typedef CComQIPtr<ITuneRequest> PQTuneRequest;
typedef CComQIPtr<IChannelTuneRequest> PQChannelTuneRequest;
typedef CComQIPtr<IATSCChannelTuneRequest> PQATSCChannelTuneRequest;
typedef CComQIPtr<ILocator> PQLocator;
typedef CComQIPtr<IATSCLocator> PQATSCLocator;
typedef CComQIPtr<IDVBTuningSpace> PQDVBTuningSpace;
typedef CComQIPtr<IDVBTuneRequest> PQDVBTuneRequest;
typedef CComQIPtr<IDVBSLocator> PQDVBSLocator;
typedef CComQIPtr<IDVBTLocator> PQDVBTLocator;
typedef CComQIPtr<IAuxInTuningSpace> PQAuxInTuningSpace;

// tuning space container
class TNTuningSpaceContainer : public PQTuningSpaceContainer {
     TNTuningSpaceContainer() {}
     TNTuningSpaceContainer(const PQTuningSpaceContainer &a) : PQTuningSpaceContainer(a) {}
     TNTuningSpaceContainer(ITuningSpace *p) : PQTuningSpaceContainer(p) {}
     TNTuningSpaceContainer(IUnknown *p) : PQTuningSpaceContainer(p) {}
     TNTuningSpaceContainer(const TNTuningSpaceContainer &a) : PQTuningSpaceContainer(a) {}
     TNTuningSpaceContainer& operator=(TNTuningSpaceContainer& rhs) {
        PQTuningSpaceContainer::operator=(rhs);
        return *this;
    }

};

// tuning spaces
template<class TUNINGSPACETYPE, class TUNEREQUESTTYPE> class TNTuningSpaceHelper : public TUNINGSPACETYPE {
public:
    TNTuningSpaceHelper() {}
    TNTuningSpaceHelper(const TUNINGSPACETYPE &a) : TUNINGSPACETYPE(a) {}
    TNTuningSpaceHelper(ITuningSpace *p) : TUNINGSPACETYPE(p) {}
    TNTuningSpaceHelper(IUnknown *p) : TUNINGSPACETYPE(p) {}
    TNTuningSpaceHelper(const TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE> &a) : TUNINGSPACETYPE(a) {}
    TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& rhs) {
        TUNINGSPACETYPE::operator=(rhs);
        return *this;
    }
    TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(TUNINGSPACETYPE& rhs) {
        TUNINGSPACETYPE::operator=(rhs);
        return *this;
    }
    TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(IUnknown *rhs) {
        TUNINGSPACETYPE::operator=(rhs);
        return *this;
    }
    TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(ITuningSpace *rhs) {
        TUNINGSPACETYPE::operator=(rhs);
        return *this;
    }
    bool  operator==(TUNINGSPACETYPE& rhs) {
        CComBSTR rhsname;
        HRESULT hr = rhs->get_UniqueName(&rhsname);
        if (FAILED(hr)) {
            return false;
        }
        CComBSTR name;
        hr = (*this)->get_UniqueName(&name);
        if (FAILED(hr)) {
            return false;
        }
        return name == rhsname;
    }
    bool  operator!=(TUNINGSPACETYPE& rhs) {
        return !operator==(rhs);
    }
    PQTuneRequest CreateTuneRequest() {
        PQTuneRequest p;
        HRESULT hr = (*this)->CreateTuneRequest(&p);
        if (FAILED(hr)) {
            return PQTuneRequest();
        }
        return p;
    }

    PQLocator Locator() {
        _ASSERT(*this);
        PQLocator ts;
        HRESULT hr = (*this)->get_DefaultLocator(&ts);
        if (FAILED(hr)) {
            return PQLocator();
        }
        return ts;
    }

    HRESULT Locator(PQLocator& l) {
        _ASSERT(*this);
        return (*this)->put_Locator(l);
    }

    void Clone() {
        PQTuningSpace t;
        HRESULT hr = (*this)->Clone(&t);
        if (FAILED(hr) || !t) {
            Release();  // clone failed, clear ourselves
            return;
        }
        TUNINGSPACETYPE::operator=(t);
    }

};

typedef TNTuningSpaceHelper<PQTuningSpace, PQTuneRequest> TNTuningSpace;

template<class TUNINGSPACETYPE, class TUNEREQUESTTYPE> class TNAnalogRadioTuningSpaceHelper : public TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE> {
public:
     TNAnalogRadioTuningSpaceHelper() {}
     TNAnalogRadioTuningSpaceHelper(const TUNINGSPACETYPE &a) : TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>(a) {}
     TNAnalogRadioTuningSpaceHelper(IUnknown *p) : TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>(p) {}
     TNAnalogRadioTuningSpaceHelper(const TNAnalogRadioTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE> &a) : TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>(a) {}
     TNAnalogRadioTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(TNAnalogRadioTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& rhs) {
        TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>::operator=(rhs);
        return *this;
     }
     template<class TS, class TR> TNAnalogRadioTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(TNTuningSpaceHelper<TS, TR>& rhs) {
        TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>::operator=(TUNINGSPACETYPE(rhs));
        return *this;
     }
     TNAnalogRadioTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(TUNINGSPACETYPE& rhs) {
        TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>::operator=(rhs);
        return *this;
    }
     TNAnalogRadioTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(IUnknown* rhs) {
        TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>::operator=(rhs);
        return *this;
    }
    long MaxFrequency() {
        _ASSERT(*this);
        long freq;
        HRESULT hr = (*this)->get_MaxFrequency(&freq);
        if (FAILED(hr)) {
            freq = DEFAULT_MAX_FREQUENCY;
        }
        return freq;
    }
    HRESULT MaxFrequency(long freq) {
        _ASSERT(*this);
        return (*this)->put_MaxFrequency(freq);
    }
    long MinFrequency() {
        _ASSERT(*this);
        long freq;
        HRESULT hr = (*this)->get_MinFrequency(&freq);
        if (FAILED(hr)) {
            freq = DEFAULT_MIN_FREQUENCY;
        }
        return freq;
    }
    HRESULT MinFrequency(long freq) {
        _ASSERT(*this);
        return (*this)->put_MinFrequency(freq);
    }
};
typedef TNAnalogRadioTuningSpaceHelper<PQAnalogRadioTuningSpace, PQChannelTuneRequest> TNAnalogRadioTuningSpace;

template<class TUNINGSPACETYPE, class TUNEREQUESTTYPE> class TNAnalogTVTuningSpaceHelper : public TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE> {
public:
    TNAnalogTVTuningSpaceHelper() {}
    TNAnalogTVTuningSpaceHelper(const TUNINGSPACETYPE &a) : TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>(a) {}
    TNAnalogTVTuningSpaceHelper(IUnknown *p) : TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>(p) {}
    TNAnalogTVTuningSpaceHelper(const TNAnalogTVTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE> &a) : TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>(a) {}
    TNAnalogTVTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(TNAnalogTVTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& rhs) {
        TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>::operator=(rhs);
        return *this;
    }
    template<class TS, class TR> TNAnalogTVTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(TNTuningSpaceHelper<TS, TR>& rhs) {
        TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>::operator=(TUNINGSPACETYPE(rhs));
        return *this;
    }
    TNAnalogTVTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(TUNINGSPACETYPE& rhs) {
        TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>::operator=(rhs);
        return *this;
    }
    TNAnalogTVTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(IUnknown* rhs) {
        TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>::operator=(rhs);
        return *this;
    }
    TunerInputType InputType() {
        _ASSERT(*this);
        TunerInputType ti;
        HRESULT hr = (*this)->get_InputType(&ti);
        if (FAILED(hr)) {
            ti = DEFAULT_ANALOG_TUNER_INPUT_TYPE;
        }
        return ti;
    }
    HRESULT InputType(TunerInputType ti) {
        _ASSERT(*this);
        return (*this)->put_InputType(&ti);
    }
    long CountryCode() {
        _ASSERT(*this);
        long cc;
        HRESULT hr = (*this)->get_CountryCode(&cc);
        if (FAILED(hr)) {
            cc = DEFAULT_ANALOG_TUNER_INPUT_TYPE;
        }
        return cc;
    }
    HRESULT CountryCode(long cc) {
        _ASSERT(*this);
        return (*this)->put_CountryCode(cc);
    }
    long MinChannel() {
        _ASSERT(*this);
        long chan;
        HRESULT hr = (*this)->get_MinChannel(&chan);
        if (FAILED(hr)) {
            chan = DEFAULT_MIN_CHANNEL;
        }
        return chan;
    }
    HRESULT MinChannel(long chan) {
        _ASSERT(*this);
        return (*this)->put_MinChannel(chan);
    }
    long MaxChannel() {
        _ASSERT(*this);
        long chan;
        HRESULT hr = (*this)->get_MaxChannel(&chan);
        if (FAILED(hr)) {
            chan = DEFAULT_MAX_CHANNEL;
        }
        return chan;
    }
    HRESULT MaxChannel(long chan) {
        _ASSERT(*this);
        return (*this)->put_MaxChannel(chan);
    }
};
typedef TNAnalogTVTuningSpaceHelper<PQAnalogTVTuningSpace, PQChannelTuneRequest> TNAnalogTVTuningSpace;

template<class TUNINGSPACETYPE, class TUNEREQUESTTYPE> class TNAuxInTuningSpaceHelper : public TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE> {
public:
    TNAuxInTuningSpaceHelper() {}
    TNAuxInTuningSpaceHelper(const TUNINGSPACETYPE &a) : TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>(a) {}
    TNAuxInTuningSpaceHelper(IUnknown *p) : TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>(p) {}
    TNAuxInTuningSpaceHelper(const TNAuxInTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE> &a) : TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>(a) {}
    TNAuxInTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(TNAuxInTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& rhs) {
        TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>::operator=(rhs);
        return *this;
    }
    template<class TS, class TR> TNAuxInTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(TNTuningSpaceHelper<TS, TR>& rhs) {
        TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>::operator=(TUNINGSPACETYPE(rhs));
        return *this;
    }
    TNAuxInTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(TUNINGSPACETYPE& rhs) {
        TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>::operator=(rhs);
        return *this;
    }
    TNAuxInTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(IUnknown* rhs) {
        TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>::operator=(rhs);
        return *this;
    }
};
typedef TNAuxInTuningSpaceHelper<PQAuxInTuningSpace, PQChannelTuneRequest> TNAuxInTuningSpace;

template<class TUNINGSPACETYPE, class TUNEREQUESTTYPE> class TNATSCTuningSpaceHelper : public TNAnalogTVTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE> {
public:
    TNATSCTuningSpaceHelper() {}
    TNATSCTuningSpaceHelper(const TUNINGSPACETYPE &a) : TNAnalogTVTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>(a) {}
    TNATSCTuningSpaceHelper(IUnknown *p) : TNAnalogTVTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>(p) {}
    TNATSCTuningSpaceHelper(const TNATSCTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE> &a) : TNAnalogTVTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>(a) {}

    TNATSCTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(TNATSCTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& rhs) {
        TNAnalogTVTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>::operator=(rhs);
        return *this;
    }
    template<class TS, class TR> TNATSCTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(TNTuningSpaceHelper<TS, TR>& rhs) {
        TNAnalogTVTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>::operator=(TUNINGSPACETYPE(rhs));
        return *this;
    }
    TNATSCTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(TUNINGSPACETYPE& rhs) {
        TNAnalogTVTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>::operator=(rhs);
        return *this;
    }
    TNATSCTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(IUnknown* rhs) {
        TNAnalogTVTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>::operator=(rhs);
        return *this;
    }
    long MinMinorChannel() {
        _ASSERT(*this);
        long chan;
        HRESULT hr = (*this)->get_MinMinorChannel(&chan);
        if (FAILED(hr)) {
            chan = DEFAULT_MIN_CHANNEL;
        }
        return chan;
    }
    HRESULT MinMinorChannel(long chan) {
        _ASSERT(*this);
        return (*this)->put_MinMinorChannel(chan);
    }

    long MaxMinorChannel() {
        _ASSERT(*this);
        long chan;
        HRESULT hr = (*this)->get_MaxMinorChannel(&chan);
        if (FAILED(hr)) {
            chan = DEFAULT_MAX_CHANNEL;
        }
        return chan;
    }
    HRESULT MaxMinorChannel(long chan) {
        _ASSERT(*this);
        return (*this)->put_MaxMinorChannel(chan);
    }
    long MinPhysicalChannel() {
        _ASSERT(*this);
        long chan;
        HRESULT hr = (*this)->get_MinPhysicalChannel(&chan);
        if (FAILED(hr)) {
            chan = DEFAULT_MIN_CHANNEL;
        }
        return chan;
    }
    HRESULT MinPhysicalChannel(long chan) {
        _ASSERT(*this);
        return (*this)->put_MinPhysicalChannel(chan);
    }

    long MaxPhysicalChannel() {
        _ASSERT(*this);
        long chan;
        HRESULT hr = (*this)->get_MaxPhysicalChannel(&chan);
        if (FAILED(hr)) {
            chan = DEFAULT_MAX_CHANNEL;
        }
        return chan;
    }

    HRESULT MaxPhysicalChannel(long chan) {
        _ASSERT(*this);
        return (*this)->put_MaxPhysicalChannel(chan);
    }
};
typedef TNATSCTuningSpaceHelper<PQATSCTuningSpace, PQATSCChannelTuneRequest> TNATSCTuningSpace;

// dvb tuning space
template<class TUNINGSPACETYPE, class TUNEREQUESTTYPE> class TNDVBTuningSpaceHelper : public TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE> {
public:
     TNDVBTuningSpaceHelper() {}
     TNDVBTuningSpaceHelper(const TUNINGSPACETYPE &a) : TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>(a) {}
     TNDVBTuningSpaceHelper(IUnknown *p) : TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>(p) {}
     TNDVBTuningSpaceHelper(const TNDVBTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE> &a) : TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>(a) {}
     TNDVBTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(TNDVBTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& rhs) {
        TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>::operator=(rhs);
        return *this;
     }
     template<class TS, class TR> TNDVBTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(TNTuningSpaceHelper<TS, TR>& rhs) {
        TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>::operator=(TUNINGSPACETYPE(rhs));
        return *this;
     }
     TNDVBTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(TUNINGSPACETYPE& rhs) {
        TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>::operator=(rhs);
        return *this;
    }
     TNDVBTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>& operator=(IUnknown* rhs) {
        TNTuningSpaceHelper<TUNINGSPACETYPE, TUNEREQUESTTYPE>::operator=(rhs);
        return *this;
    }
    DVBSystemType SystemType() const {
        DVBSystemType st;
        HRESULT hr = (*this)->get_SystemType(&st);
        if (FAILED(hr)) {
            return DVB_Cable;
        }
        return st;
    }
    HRESULT SystemType(DVBSystemType st) {
        _ASSERT(*this);
        return (*this)->put_SystemType(st);
    }
};
typedef TNDVBTuningSpaceHelper<PQDVBTuningSpace, PQDVBTuneRequest> TNDVBTuningSpace;

// locators
template<class LOCATORTYPE> class TNLocatorHelper : public LOCATORTYPE {
public:
     TNLocatorHelper() {}
     TNLocatorHelper(const LOCATORTYPE &a) : LOCATORTYPE(a) {}
     TNLocatorHelper(IUnknown *p) : LOCATORTYPE(p) {}
     TNLocatorHelper(const TNLocatorHelper<LOCATORTYPE> &a) : LOCATORTYPE(a) {}
     TNLocatorHelper(ILocator *p) : LOCATORTYPE(p) {}
     TNLocatorHelper<LOCATORTYPE>& operator=(TNLocatorHelper<LOCATORTYPE>& rhs) {
        LOCATORTYPE::operator=(rhs);
        return *this;
    }
     TNLocatorHelper<LOCATORTYPE>& operator=(LOCATORTYPE& rhs) {
        LOCATORTYPE::operator=(rhs);
        return *this;
    }
     TNLocatorHelper<LOCATORTYPE>& operator=(ILocator* rhs) {
        LOCATORTYPE::operator=(rhs);
        return *this;
    }
     TNLocatorHelper<LOCATORTYPE>& operator=(IUnknown* rhs) {
        LOCATORTYPE::operator=(rhs);
        return *this;
    }

    void Clone() {
        PQLocator t;
        HRESULT hr = (*this)->Clone(&t);
        if (FAILED(hr) || !t) {
            Release();  // clone failed, clear ourselves
            return;
        }
        LOCATORTYPE::operator=(t);
    }

    long CarrierFrequency() {
        _ASSERT(*this);
        long f;
        HRESULT hr = (*this)->get_CarrierFrequency(&f);
        if (FAILED(hr)) {
            return -1;
        }
        return f;
    }
    HRESULT CarrierFrequency(long f) {
        _ASSERT(*this);
        return (*this)->put_CarrierFrequency(f);
    }

    FECMethod InnerFEC() {
        _ASSERT(*this);
        FECMethod f;
        HRESULT hr = (*this)->get_InnerFEC(&f);
        if (FAILED(hr)) {
            return BDA_FEC_METHOD_NOT_SET;
        }
        return f;
    }
    HRESULT InnerFEC(FECMethod f) {
        _ASSERT(*this);
        return (*this)->put_InnerFEC(f);
    }
    BinaryConvolutionCodeRate InnerFECRate() {
        _ASSERT(*this);
        BinaryConvolutionCodeRate f;
        HRESULT hr = (*this)->get_InnerFECRate(&f);
        if (FAILED(hr)) {
            return BDA_BCC_RATE_NOT_SET;
        }
        return f;
    }
    HRESULT InnerFECRate(BinaryConvolutionCodeRate f) {
        _ASSERT(*this);
        return (*this)->put_InnerFECRate(f);
    }
    FECMethod OuterFEC() {
        _ASSERT(*this);
        FECMethod f;
        HRESULT hr = (*this)->get_OuterFEC(&f);
        if (FAILED(hr)) {
            return BDA_FEC_METHOD_NOT_SET;
        }
        return f;
    }
    HRESULT OuterFEC(FECMethod f) {
        _ASSERT(*this);
        return (*this)->put_OuterFEC(f);
    }
    BinaryConvolutionCodeRate OuterFECRate() {
        _ASSERT(*this);
        BinaryConvolutionCodeRate f;
        HRESULT hr = (*this)->get_OuterFECRate(&f);
        if (FAILED(hr)) {
            return BDA_BCC_RATE_NOT_SET;
        }
        return f;
    }
    HRESULT OuterFECRate(BinaryConvolutionCodeRate f) {
        _ASSERT(*this);
        return (*this)->put_OuterFECRate(f);
    }
    ModulationType Modulation() {
        _ASSERT(*this);
        ModulationType f;
        HRESULT hr = (*this)->get_Modulation(&f);
        if (FAILED(hr)) {
            return BDA_MOD_NOT_SET;
        }
        return f;
    }
    HRESULT Modulation(ModulationType f) {
        _ASSERT(*this);
        return (*this)->put_Modulation(f);
    }

    long SymbolRate() {
        _ASSERT(*this);
        long f;
        HRESULT hr = (*this)->get_SymbolRate(&f);
        if (FAILED(hr)) {
            return -1;
        }
        return f;
    }
    HRESULT SymbolRate(long f) {
        _ASSERT(*this);
        return (*this)->put_SymbolRate(f);
    }

};
typedef TNLocatorHelper<PQLocator> TNLocator;

template<class LOCATORTYPE> class TNATSCLocatorHelper : public TNLocatorHelper<LOCATORTYPE> {
public:
    TNATSCLocatorHelper() {}
    TNATSCLocatorHelper(const LOCATORTYPE &a) : TNLocatorHelper<LOCATORTYPE>(a) {}
    TNATSCLocatorHelper(IUnknown *p) : TNLocatorHelper<LOCATORTYPE>(p) {}
    TNATSCLocatorHelper(const TNATSCLocatorHelper<LOCATORTYPE> &a) : TNLocatorHelper<LOCATORTYPE>(a) {}
    TNATSCLocatorHelper(IATSCLocator *p) : TNLocatorHelper<LOCATORTYPE>(p) {}
    TNATSCLocatorHelper(const TNLocatorHelper<LOCATORTYPE> &a) : TNLocatorHelper<LOCATORTYPE>(a) {}
    TNATSCLocatorHelper<LOCATORTYPE>& operator=(TNATSCLocatorHelper<LOCATORTYPE>& rhs) {
        TNLocatorHelper<LOCATORTYPE>::operator=(rhs);
        return *this;
    }
    TNATSCLocatorHelper<LOCATORTYPE>& operator=(TNLocatorHelper<LOCATORTYPE>& rhs) {
        TNLocatorHelper<LOCATORTYPE>::operator=(rhs);
        return *this;
    }
    TNATSCLocatorHelper<LOCATORTYPE>& operator=(LOCATORTYPE& rhs) {
        TNLocatorHelper<LOCATORTYPE>::operator=(rhs);
        return *this;
    }
    TNATSCLocatorHelper<LOCATORTYPE>& operator=(IATSCLocator* rhs) {
        TNLocatorHelper<LOCATORTYPE>::operator=(rhs);
        return *this;
    }
    TNATSCLocatorHelper<LOCATORTYPE>& operator=(IUnknown* rhs) {
        TNLocatorHelper<LOCATORTYPE>::operator=(rhs);
        return *this;
    }

    long PhysicalChannel() {
        _ASSERT(*this);
        long pc;
        HRESULT hr = (*this)->get_PhysicalChannel(&pc);
        if (FAILED(hr)) {
            return -1;
        }
        return pc;
    }
    HRESULT PhysicalChannel(long pc) {
        _ASSERT(*this);
        return (*this)->put_PhysicalChannel(pc);
    }

    long TSID() {
        _ASSERT(*this);
        long pc;
        HRESULT hr = (*this)->get_TSID(&pc);
        if (FAILED(hr)) {
            return -1;
        }
        return pc;
    }
    HRESULT TSID(long pc) {
        _ASSERT(*this);
        return (*this)->put_TSID(pc);
    }

    long ProgramNumber() {
        _ASSERT(*this);
        long pc;
        HRESULT hr = (*this)->get_ProgramNumber(&pc);
        if (FAILED(hr)) {
            return -1;
        }
        return pc;
    }
    HRESULT ProgramNumber(long pc) {
        _ASSERT(*this);
        return (*this)->put_ProgramNumber(pc);
    }
};
typedef TNATSCLocatorHelper<PQATSCLocator> TNATSCLocator;

// tune requests
template<class TUNEREQUESTTYPE, class LOCATORTYPE> class TNTuneRequestHelper : public TUNEREQUESTTYPE {
public:
     TNTuneRequestHelper() {}
     TNTuneRequestHelper(const TUNEREQUESTTYPE &a) : TUNEREQUESTTYPE(a) {}
     TNTuneRequestHelper(IUnknown *p) : TUNEREQUESTTYPE(p) {}
     TNTuneRequestHelper(const TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE> &a) : TUNEREQUESTTYPE(a) {}
     TNTuneRequestHelper(ITuneRequest *p) : TUNEREQUESTTYPE(p) {}
     TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& operator=(TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& rhs) {
        TUNEREQUESTTYPE::operator=(rhs);
        return *this;
    }
     TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& operator=(TUNEREQUESTTYPE& rhs) {
        TUNEREQUESTTYPE::operator=(rhs);
        return *this;
    }
     TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& operator=(ITuneRequest* rhs) {
        TUNEREQUESTTYPE::operator=(rhs);
        return *this;
    }
     TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& operator=(IUnknown* rhs) {
        TUNEREQUESTTYPE::operator=(rhs);
        return *this;
    }
    // this function creates a new instance of the base ITuneRequest* and copies
    // all the values of the current ITuneRequest and sets this to the new one
    // this provides the value semantics needed by the network providers
    void Clone() {
        PQTuneRequest t;
        HRESULT hr = (*this)->Clone(&t);
        if (FAILED(hr) || !t) {
            Release();  // clone failed, clear ourselves
            return;
        }
        TUNEREQUESTTYPE::operator=(t);
    }

    PQTuningSpace TuningSpace() {
        _ASSERT(*this);
        PQTuningSpace ts;
        HRESULT hr = (*this)->get_TuningSpace(&ts);
        if (FAILED(hr)) {
            return PQTuningSpace();
        }
        return ts;
    }

    LOCATORTYPE Locator() {
        _ASSERT(*this);
        PQLocator pc;
        HRESULT hr = (*this)->get_Locator(&pc);
        if (FAILED(hr)) {
            return PQLocator().p;
        }
        return pc.p;
    }
    HRESULT Locator(LOCATORTYPE& pc) {
        _ASSERT(*this);
        return (*this)->put_Locator(pc);
    }
};

typedef TNTuneRequestHelper<PQTuneRequest, PQLocator> TNTuneRequest;

template<class TUNEREQUESTTYPE, class LOCATORTYPE> class TNChannelTuneRequestHelper : public TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE> {
public:
     TNChannelTuneRequestHelper() {}
     TNChannelTuneRequestHelper(const TNTuneRequest &a) : TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>(a) {}
     TNChannelTuneRequestHelper(IChannelTuneRequest *p) : TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>(p) {}
     TNChannelTuneRequestHelper(IUnknown *p) : TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>(p) {}
     TNChannelTuneRequestHelper(const TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE> &a) : TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>(a) {}
     TNChannelTuneRequestHelper(const TNChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE> &a) : TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>(a) {}
     TNChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& operator=(TNChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& rhs) {
        TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>::operator=(rhs);
        return *this;
    }
    template<class TR, class LOC> TNChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& operator=(TNTuneRequestHelper<TR, LOC>& rhs) {
        TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>::operator=(TUNEREQUESTTYPE(rhs));
        return *this;
    }
     TNChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& operator=(TUNEREQUESTTYPE& rhs) {
        TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>::operator=(rhs);
        return *this;
    }
     TNChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& operator=(IChannelTuneRequest* rhs) {
        TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>::operator=(rhs);
        return *this;
    }
     TNChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& operator=(IUnknown* rhs) {
        TUNEREQUESTTYPE::operator=(rhs);
        return *this;
    }
    long Channel() {
        _ASSERT(*this);
        long c;
        HRESULT hr = (*this)->get_Channel(&c);
        if (FAILED(hr)) {
            return -1;
        }
        return c;
    }
    HRESULT Channel(long c) {
        _ASSERT(*this);
        return (*this)->put_Channel(c);
    }
};

typedef TNChannelTuneRequestHelper<PQChannelTuneRequest, PQLocator> TNChannelTuneRequest;

template<class TUNEREQUESTTYPE, class LOCATORTYPE> class TNATSCChannelTuneRequestHelper : public TNChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE> {
public:
    TNATSCChannelTuneRequestHelper() {}
    TNATSCChannelTuneRequestHelper(const TNTuneRequest &a) : TNChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>(a) {}
    TNATSCChannelTuneRequestHelper(IATSCChannelTuneRequest *p) : TNChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>(p) {}
    TNATSCChannelTuneRequestHelper(IUnknown *p) : TNChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>(p) {}
    TNATSCChannelTuneRequestHelper(const TNChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE> &a) : TNChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>(a) {}
    TNATSCChannelTuneRequestHelper(const TNATSCChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE> &a) : TNChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>(a) {}
    TNATSCChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& operator=(TNATSCChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& rhs) {
        TNChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>::operator=(rhs);
        return *this;
    }
    template<class TR, class LOC>TNATSCChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& operator=(TNTuneRequestHelper<TR, LOC>& rhs) {
        TNChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>::operator=(TR(rhs));
        return *this;
    }
    TNATSCChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& operator=(TUNEREQUESTTYPE& rhs) {
        TNChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>::operator=(rhs);
        return *this;
    }
    TNATSCChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& operator=(IATSCChannelTuneRequest *rhs) {
        TNChannelTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>::operator=(rhs);
        return *this;
    }
    TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& operator=(IUnknown* rhs) {
        TUNEREQUESTTYPE::operator=(rhs);
        return *this;
    }
    long MinorChannel() {
        _ASSERT(*this);
        long mc;
        HRESULT hr = (*this)->get_MinorChannel(&mc);
        if (FAILED(hr)) {
            return -1;
        }
        return mc;
    }
    HRESULT MinorChannel(long mc) {
        _ASSERT(*this);
        return (*this)->put_MinorChannel(mc);
    }
};
typedef TNATSCChannelTuneRequestHelper<PQATSCChannelTuneRequest, PQATSCLocator> TNATSCChannelTuneRequest;

template<class TUNEREQUESTTYPE, class LOCATORTYPE> class TNDVBTuneRequestHelper : public TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE> {
public:
     TNDVBTuneRequestHelper() {}
     TNDVBTuneRequestHelper(const TNTuneRequest &a) : TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>(a) {}
     TNDVBTuneRequestHelper(IDVBTuneRequest *p) : TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>(p) {}
     TNDVBTuneRequestHelper(IUnknown *p) : TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>(p) {}
     TNDVBTuneRequestHelper(const TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE> &a) : TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>(a) {}
     TNDVBTuneRequestHelper(const TNDVBTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE> &a) : TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>(a) {}
     TNDVBTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& operator=(TNDVBTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& rhs) {
        TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>::operator=(rhs);
        return *this;
    }
    template<class TR, class LOC> TNDVBTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& operator=(TNTuneRequestHelper<TR, LOC>& rhs) {
        TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>::operator=(TUNEREQUESTTYPE(rhs));
        return *this;
    }
     TNDVBTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& operator=(TUNEREQUESTTYPE& rhs) {
        TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>::operator=(rhs);
        return *this;
    }
     TNDVBTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& operator=(IDVBTuneRequest* rhs) {
        TNTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>::operator=(rhs);
        return *this;
    }
     TNDVBTuneRequestHelper<TUNEREQUESTTYPE, LOCATORTYPE>& operator=(IUnknown* rhs) {
        TUNEREQUESTTYPE::operator=(rhs);
        return *this;
    }
    long ONID() {
        _ASSERT(*this);
        long c;
        HRESULT hr = (*this)->get_ONID(&c);
        if (FAILED(hr)) {
            return -1;
        }
        return c;
    }
    HRESULT ONID(long c) {
        _ASSERT(*this);
        return (*this)->put_ONID(c);
    }
    long TSID() {
        _ASSERT(*this);
        long c;
        HRESULT hr = (*this)->get_TSID(&c);
        if (FAILED(hr)) {
            return -1;
        }
        return c;
    }
    HRESULT TSID(long c) {
        _ASSERT(*this);
        return (*this)->put_TSID(c);
    }
    long SID() {
        _ASSERT(*this);
        long c;
        HRESULT hr = (*this)->get_SID(&c);
        if (FAILED(hr)) {
            return -1;
        }
        return c;
    }
    HRESULT SID(long c) {
        _ASSERT(*this);
        return (*this)->put_SID(c);
    }
};
typedef TNDVBTuneRequestHelper<PQDVBTuneRequest, PQLocator> TNDVBTuneRequest;
}; // namespace

#ifndef NO_DEFAULT_BDATUNINGMODEL_NAMESPACE
using namespace BDATuningModel;
#endif

#endif
// end of file - tune.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\include\vpconfig.h ===
//------------------------------------------------------------------------------
// File: VPConfig.h
//
// Desc: An interface exposed by the decoder to help it and the filter
//       configuring the videoport to communicate.
//
// Copyright (c) 1992 - 2000, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __IVPConfig__
#define __IVPConfig__

#ifdef __cplusplus
extern "C" {
#endif

// IVPBaseConfig
DECLARE_INTERFACE_(IVPBaseConfig, IUnknown)
{
public:

    // gets the various connection information structures (guid, portwidth)
    // in an array of structures. If the pointer to the array is NULL, first 
    // parameter returns the total number of formats supported.
    STDMETHOD (GetConnectInfo)(THIS_
			       IN OUT LPDWORD pdwNumConnectInfo,
			       IN OUT LPDDVIDEOPORTCONNECT pddVPConnectInfo
			      ) PURE;

    // sets the connection entry chosen (0, 1, .. ,(dwNumProposedEntries-1))
    STDMETHOD (SetConnectInfo)(THIS_
			       IN DWORD dwChosenEntry
			      ) PURE;

    // gets various data parameters, includes dimensionnal info
    STDMETHOD (GetVPDataInfo)(THIS_
			      IN OUT LPAMVPDATAINFO pamvpDataInfo
			     ) PURE;

    // retrives maximum pixels per second rate expected for a given 
    // format and a given scaling factor. If decoder does not support 
    // those scaling factors, then it gives the rate and the nearest 
    // scaling factors.
    STDMETHOD (GetMaxPixelRate)(THIS_
				IN OUT LPAMVPSIZE pamvpSize,
				OUT LPDWORD pdwMaxPixelsPerSecond
			       ) PURE;

    // informs the callee of the videoformats supported by the videoport
    STDMETHOD (InformVPInputFormats)(THIS_
				     IN DWORD dwNumFormats,
				     IN LPDDPIXELFORMAT pDDPixelFormats
				    ) PURE;

    // gets the various formats supported by the decoder in an array
    // of structures. If the pointer to the array is NULL, first parameter
    // returns the total number of formats supported.
    STDMETHOD (GetVideoFormats)(THIS_
				IN OUT LPDWORD pdwNumFormats,
				IN OUT LPDDPIXELFORMAT pddPixelFormats
			       ) PURE;

    // sets the format entry chosen (0, 1, .. ,(dwNumProposedEntries-1))
    STDMETHOD (SetVideoFormat)(THIS_
			       IN DWORD dwChosenEntry
			      ) PURE;

    // asks the decoder to treat even fields like odd fields and visa versa
    STDMETHOD (SetInvertPolarity)(THIS_
				 ) PURE;

    // the mixer uses this function to determine if the callee wants
    // the vpmixer to use its overlay surface and if so to get a pointer to it
    STDMETHOD (GetOverlaySurface)(THIS_
				  OUT LPDIRECTDRAWSURFACE* ppddOverlaySurface
				 ) PURE;

    // sets the direct draw kernel handle
    STDMETHOD (SetDirectDrawKernelHandle)(THIS_
					  IN ULONG_PTR dwDDKernelHandle
					 ) PURE;

    // sets the video port id
    STDMETHOD (SetVideoPortID)(THIS_
			       IN DWORD dwVideoPortID
			      ) PURE;

    // sets the direct draw surface kernel handle
    STDMETHOD (SetDDSurfaceKernelHandles)(THIS_
					  IN DWORD cHandles,
					  IN ULONG_PTR *rgDDKernelHandles
					 ) PURE;

    // Tells driver about surface created on its behalf by ovmixer/vbisurf and 
    // returned from videoport/ddraw. Should always return NOERROR or E_NOIMPL. 
    // dwPitch is the pitch of the surface (distance in pixels between the start 
    // pixels of two consecutive lines of the surface). (dwXOrigin, dwYOrigin) 
    // are the (X, Y) coordinates of the pixel at which valid data starts.  
    STDMETHOD (SetSurfaceParameters)(THIS_
                    IN DWORD dwPitch,
                    IN DWORD dwXOrigin,
                    IN DWORD dwYOrigin
                    ) PURE;
};

// IVPConfig
DECLARE_INTERFACE_(IVPConfig, IVPBaseConfig)
{
public:
	// the mixer uses this function to determine if the callee wants
	// the mixer to decimate VIDEO data at its own descrition
	STDMETHOD (IsVPDecimationAllowed)(THIS_
					  OUT LPBOOL pbIsDecimationAllowed
					 ) PURE;

	// sets the scaling factors. If decoder does not support these,
	// then it sets the values to the nearest factors it can support
	STDMETHOD (SetScalingFactors)(THIS_
				      IN LPAMVPSIZE pamvpSize
				     ) PURE;
};

// IVPVBIConfig
DECLARE_INTERFACE_(IVPVBIConfig, IVPBaseConfig)
{
public:
};

#ifdef __cplusplus
}
#endif


#endif // __IVPConfig__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\idl\danimid.h ===
// Copyright (C) Microsoft Corporation, 1998
//
// IDs for DANIM Events
//
// Just follow the template when adding either DISPIDs or new interfaces.
//

#ifndef __DANIMDISPID_H__
#define __DANIMDISPID_H__

// Base offset:

#define DISPID_BASE                                             0x00000000

// Interface offsets:
#define DAVIEWERCONTROL_OFFSET                                  0x1000
#define DAVIEW_OFFSET                                           0x2000

// Interface bases:
#define DISPID_DANIMEVENT_BASE                                  (DISPID_BASE + DAVIEWERCONTROL_OFFSET)
#define DISPID_VIEWEVENT_BASE                                   (DISPID_BASE + DAVIEW_OFFSET)

// DAVIEWERCONTROL DISPIDs:
#define DISPID_DANIMEVENT_START                          (DISPID_DANIMEVENT_BASE + 0x01)
#define DISPID_DANIMEVENT_MOUSEUP                        (DISPID_DANIMEVENT_BASE + 0x02)
#define DISPID_DANIMEVENT_MOUSEDOWN                      (DISPID_DANIMEVENT_BASE + 0x03)
#define DISPID_DANIMEVENT_MOUSEMOVE                      (DISPID_DANIMEVENT_BASE + 0x04)
#define DISPID_DANIMEVENT_CLICK                          (DISPID_DANIMEVENT_BASE + 0x05)
#define DISPID_DANIMEVENT_KEYPRESS                       (DISPID_DANIMEVENT_BASE + 0x06)
#define DISPID_DANIMEVENT_KEYUP                          (DISPID_DANIMEVENT_BASE + 0x07)
#define DISPID_DANIMEVENT_KEYDOWN                        (DISPID_DANIMEVENT_BASE + 0x08)
#define DISPID_DANIMEVENT_ERROR                          (DISPID_DANIMEVENT_BASE + 0x09)
#define DISPID_DANIMEVENT_STOP                           (DISPID_DANIMEVENT_BASE + 0x0A)
#define DISPID_DANIMEVENT_PAUSE                          (DISPID_DANIMEVENT_BASE + 0x0B)
#define DISPID_DANIMEVENT_RESUME                         (DISPID_DANIMEVENT_BASE + 0x0C)

//VIEW DISPIDS
#define DISPID_VIEWEVENT_START                                  (DISPID_VIEWEVENT_BASE + 0x01)
#define DISPID_VIEWEVENT_STOP                                   (DISPID_VIEWEVENT_BASE + 0x02)
#define DISPID_VIEWEVENT_ONMOUSEMOVE                            (DISPID_VIEWEVENT_BASE + 0x03)
#define DISPID_VIEWEVENT_ONMOUSEBUTTON                          (DISPID_VIEWEVENT_BASE + 0x04)
#define DISPID_VIEWEVENT_ONKEY                                  (DISPID_VIEWEVENT_BASE + 0x05)
#define DISPID_VIEWEVENT_ONFOCUS                                (DISPID_VIEWEVENT_BASE + 0x06)
#define DISPID_VIEWEVENT_PAUSE                                  (DISPID_VIEWEVENT_BASE + 0x07)
#define DISPID_VIEWEVENT_RESUME                                 (DISPID_VIEWEVENT_BASE + 0x08)
#define DISPID_VIEWEVENT_ERROR                                  (DISPID_VIEWEVENT_BASE + 0x09)

#endif  //__DANIMDISPID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\include\vpnotify.h ===
//------------------------------------------------------------------------------
// File: VPNotify.h
//
// Desc: 
//
// Copyright (c) 1997 - 2000, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __IVPNotify__
#define __IVPNotify__

#ifdef __cplusplus
extern "C" {
#endif

// interface IVPBaseNotify
DECLARE_INTERFACE_(IVPBaseNotify, IUnknown)
{
public:
	// this function initializes the reconnection to the decoder. 
	STDMETHOD (RenegotiateVPParameters)(THIS_
					   ) PURE;

};

// interface IVPNotify
DECLARE_INTERFACE_(IVPNotify, IVPBaseNotify)
{
public:
    // function to set the mode (bob, weave etc)
    STDMETHOD (SetDeinterlaceMode)(THIS_ 
				   IN AMVP_MODE mode
				  ) PURE;

    // function to get the mode (bob, weave etc)
    STDMETHOD (GetDeinterlaceMode)(THIS_ 
				   OUT AMVP_MODE *pMode
				  ) PURE;
};

// interface IVPNotify
DECLARE_INTERFACE_(IVPNotify2, IVPNotify)
{
public:
// function to set the mode (bob, weave etc)
    STDMETHOD (SetVPSyncMaster)(THIS_ 
				   IN BOOL bVPSyncMaster
				  ) PURE;

    // function to get the mode (bob, weave etc)
    STDMETHOD (GetVPSyncMaster)(THIS_ 
				   OUT BOOL *pbVPSyncMaster
				  ) PURE;

    /*
    // this function sets the directdraw surface that the mixer is supposed to use.
    STDMETHOD (SetDirectDrawSurface)(THIS_ 
				  IN LPDIRECTDRAWSURFACE pDirectDrawSurface
				 ) PURE;

    // this function gets the directdraw surface that the mixer is using
    STDMETHOD (GetDirectDrawSurface)(THIS_ 
				  OUT LPDIRECTDRAWSURFACE *ppDirectDrawSurface
				 ) PURE;

    // this functions sets the color-controls, if the chip supports it.
    STDMETHOD (SetVPColorControls)(THIS_ 
				 IN LPDDCOLORCONTROL pColorControl
				) PURE;

    // this functions also returns the capability of the hardware in the dwFlags
    // value of the struct.
    STDMETHOD (GetVPColorControls)(THIS_ 
				 OUT LPDDCOLORCONTROL *ppColorControl
				) PURE;
    */
};


// interface IVPVBINotify
DECLARE_INTERFACE_(IVPVBINotify, IVPBaseNotify)
{
public:
};

#ifdef __cplusplus
}
#endif


#endif // __IVPNotify__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\include\vptype.h ===
//------------------------------------------------------------------------------
// File: VPType.h
//
// Desc: This file includes all the data structures defined for the IVPConfig
//       interface.
//
// Copyright (c) 1997 - 2000, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __IVPType__
#define __IVPType__

#ifdef __cplusplus
extern "C" {
#endif

    // enum to specify the criterion, which the vpmixer is supposed to use
    // in order to select the video format
    typedef enum _AMVP_SELECT_FORMAT_BY
    {
	AMVP_DO_NOT_CARE,
	AMVP_BEST_BANDWIDTH,
	AMVP_INPUT_SAME_AS_OUTPUT
    } AMVP_SELECT_FORMAT_BY;

    // enum to specify the various mode
    typedef enum _AMVP_MODE
    {	
	AMVP_MODE_WEAVE,
	AMVP_MODE_BOBINTERLEAVED,
	AMVP_MODE_BOBNONINTERLEAVED,
	AMVP_MODE_SKIPEVEN,
	AMVP_MODE_SKIPODD
    } AMVP_MODE;

    // struct to specify the width and height. The context could be anything
    // such as scaling cropping etc.
    typedef struct _AMVPSIZE
    {
	DWORD			dwWidth;				// the width
	DWORD			dwHeight;				// the height
    } AMVPSIZE, *LPAMVPSIZE;

    // struct to specify the dimensional characteristics of the input stream
    typedef struct _AMVPDIMINFO
    {
	DWORD			dwFieldWidth;				// Field height of the data
	DWORD			dwFieldHeight;				// Field width of the data
	DWORD			dwVBIWidth;				// Width of the VBI data
	DWORD			dwVBIHeight;				// Height of the VBI data
	RECT			rcValidRegion;				// The vaild rectangle, used for cropping
    } AMVPDIMINFO, *LPAMVPDIMINFO;

    // struct to specify the various data specific characteristics of the input stream
    typedef struct _AMVPDATAINFO
    {
	DWORD			dwSize;					// Size of the struct
	DWORD			dwMicrosecondsPerField;			// Time taken by each field
	AMVPDIMINFO		amvpDimInfo;				// Dimensional Information 
	DWORD			dwPictAspectRatioX;			// X dimension of Picture Aspect Ratio
	DWORD			dwPictAspectRatioY;			// Y dimension of Picture Aspect Ratio
	BOOL			bEnableDoubleClock;			// Videoport should enable double clocking
	BOOL			bEnableVACT;				// Videoport should use an external VACT signal
	BOOL			bDataIsInterlaced;			// Indicates that the signal is interlaced
	LONG			lHalfLinesOdd;				// number of halflines in the odd field
	BOOL			bFieldPolarityInverted;			// Device inverts the polarity by default
	DWORD			dwNumLinesInVREF;			// Number of lines of data in VREF 
	LONG			lHalfLinesEven;				// number of halflines in the even field
	DWORD			dwReserved1;				// Reserved for future use
    } AMVPDATAINFO, *LPAMVPDATAINFO; 


#ifdef __cplusplus
}
#endif

#endif // __IVPType__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\proxy\dlldatax.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

//EXTERN_PROXY_FILE( amstream )
//EXTERN_PROXY_FILE( austream )
//EXTERN_PROXY_FILE( ddstream )
//EXTERN_PROXY_FILE( mmstream )
EXTERN_PROXY_FILE( strmif )

PROXYFILE_LIST_START
/* Start of list */
//  REFERENCE_PROXY_FILE( amstream ),
//  REFERENCE_PROXY_FILE( austream ),
//  REFERENCE_PROXY_FILE( ddstream ),
//  REFERENCE_PROXY_FILE( mmstream ),
    REFERENCE_PROXY_FILE( strmif ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\uuid\amstrmid.c ===
/* Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved. */
#define INITGUID
#include <guiddef.h>

DEFINE_GUID(MSPID_PrimaryVideo, /* A35FF56A-9FDA-11d0-8FDF-00C04FD9189D */
0xa35ff56a, 0x9fda, 0x11d0, 0x8f, 0xdf, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);
DEFINE_GUID(MSPID_PrimaryAudio, /* A35FF56B-9FDA-11d0-8FDF-00C04FD9189D */
0xa35ff56b, 0x9fda, 0x11d0, 0x8f, 0xdf, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);
DEFINE_GUID(CLSID_AMDirectDrawStream, /* 49c47ce4-9ba4-11d0-8212-00c04fc32c45 */
0x49c47ce4, 0x9ba4, 0x11d0, 0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45);
DEFINE_GUID(CLSID_AMAudioStream, /* 8496e040-af4c-11d0-8212-00c04fc32c45 */
0x8496e040, 0xaf4c, 0x11d0, 0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45);
DEFINE_GUID(CLSID_AMAudioData, /* f2468580-af8a-11d0-8212-00c04fc32c45 */
0xf2468580, 0xaf8a, 0x11d0, 0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45);
DEFINE_GUID(CLSID_AMMediaTypeStream, /* CF0F2F7C-F7BF-11d0-900D-00C04FD9189D */
0xcf0f2f7c, 0xf7bf, 0x11d0, 0x90, 0xd, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\uuid\strmiids.c ===
/* Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved. */
#define INITGUID
#include <guiddef.h>

#include <uuids.h>

// control.odl should really be converted to control.idl and the generated
// control_i.c can then be added to sources.  Instead, we just manually
// dump the DEFINE_GUIDs here because we can't include control.h under INITGUID
// without dragging in all of the windows type information
//
DEFINE_GUID(LIBID_QuartzTypeLib,0x56A868B0L,0x0AD4,0x11CE,0xB0,0x3A,0x00,0x20,0xAF,0x0B,0xA7,0x70);
DEFINE_GUID(IID_IAMCollection,0x56A868B9L,0x0AD4,0x11CE,0xB0,0x3A,0x00,0x20,0xAF,0x0B,0xA7,0x70);
DEFINE_GUID(IID_IMediaControl,0x56A868B1L,0x0AD4,0x11CE,0xB0,0x3A,0x00,0x20,0xAF,0x0B,0xA7,0x70);
DEFINE_GUID(IID_IMediaEvent,0x56A868B6L,0x0AD4,0x11CE,0xB0,0x3A,0x00,0x20,0xAF,0x0B,0xA7,0x70);
DEFINE_GUID(IID_IMediaEventEx,0x56A868C0L,0x0AD4,0x11CE,0xB0,0x3A,0x00,0x20,0xAF,0x0B,0xA7,0x70);
DEFINE_GUID(IID_IMediaPosition,0x56A868B2L,0x0AD4,0x11CE,0xB0,0x3A,0x00,0x20,0xAF,0x0B,0xA7,0x70);
DEFINE_GUID(IID_IBasicAudio,0x56A868B3L,0x0AD4,0x11CE,0xB0,0x3A,0x00,0x20,0xAF,0x0B,0xA7,0x70);
DEFINE_GUID(IID_IVideoWindow,0x56A868B4L,0x0AD4,0x11CE,0xB0,0x3A,0x00,0x20,0xAF,0x0B,0xA7,0x70);
DEFINE_GUID(IID_IBasicVideo,0x56A868B5L,0x0AD4,0x11CE,0xB0,0x3A,0x00,0x20,0xAF,0x0B,0xA7,0x70);
DEFINE_GUID(IID_IBasicVideo2,0x329BB360L,0xF6EA,0x11D1,0x90,0x38,0x00,0xA0,0xC9,0x69,0x72,0x98);
DEFINE_GUID(IID_IDeferredCommand,0x56A868B8L,0x0AD4,0x11CE,0xB0,0x3A,0x00,0x20,0xAF,0x0B,0xA7,0x70);
DEFINE_GUID(IID_IQueueCommand,0x56A868B7L,0x0AD4,0x11CE,0xB0,0x3A,0x00,0x20,0xAF,0x0B,0xA7,0x70);
DEFINE_GUID(CLSID_FilgraphManager,0xE436EBB3L,0x524F,0x11CE,0x9F,0x53,0x00,0x20,0xAF,0x0B,0xA7,0x70);
DEFINE_GUID(IID_IFilterInfo,0x56A868BAL,0x0AD4,0x11CE,0xB0,0x3A,0x00,0x20,0xAF,0x0B,0xA7,0x70);
DEFINE_GUID(IID_IRegFilterInfo,0x56A868BBL,0x0AD4,0x11CE,0xB0,0x3A,0x00,0x20,0xAF,0x0B,0xA7,0x70);
DEFINE_GUID(IID_IMediaTypeInfo,0x56A868BCL,0x0AD4,0x11CE,0xB0,0x3A,0x00,0x20,0xAF,0x0B,0xA7,0x70);
DEFINE_GUID(IID_IPinInfo,0x56A868BDL,0x0AD4,0x11CE,0xB0,0x3A,0x00,0x20,0xAF,0x0B,0xA7,0x70);
DEFINE_GUID(IID_IAMStats,0xBC9BCF80L,0xDCD2,0x11D2,0xAB,0xF6,0x00,0xA0,0xC9,0x05,0xF3,0x75);

#include <amstream_i.c>
#include <austream_i.c>
#include <ddstream_i.c>
#include <mmstream_i.c>
#include <qedit_i.c>
#include <strmif_i.c>
#include <regbag_i.c>
#include <tuner_i.c>
#ifndef TUNING_MODEL_ONLY
#include <segment_i.c>
#endif
#include <msvidctl_i.c>
#include <bdaiface_i.c>
#include <bdatif_i.c>
#include <sbe_i.c>
#include <videoacc_i.c>
#include <tvratings_i.c>
#include <encdec_i.c>
#include <mixerocx_i.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\idl\datimeid.h ===
// Copyright (C) Microsoft Corporation, 1998
//
// IDs for HTML+TIME
//
// Just follow the template when adding either DISPIDs or new interfaces.
//

#ifndef __TIMEDISPID_H__
#define __TIMEDISPID_H__

// Base offset:

//
// need to reposition our IDs low for Trident
//

#define DISPID_BASE                                             0x00000000

// Interface offsets:
#define TIMEELEMENT_OFFSET                                      0x0100
#define TIMEBODYELEMENT_OFFSET                                  0x0200
#define TIMEDAELEMENT_OFFSET                                    0x0300
#define TIMEMEDIAELEMENT_OFFSET                                 0x0400
#define TIMEFACTORY_OFFSET                                      0x0500
#define TIMECOLLECTION_OFFSET                                   0x0600
#define TIMECOLLECTION_RESERVED_OFFSET                          0x0700
#define TIMEMEDIAPLAYER_OFFSET                                  0x0800
#define TIMEMEDIAPLAYEREVENTS_OFFSET                            0x0900

#define DISPID_TIME_MIN                                         0x0001
#define DISPID_TIME_MAX                                         0x270F

// Interface bases:
#define DISPID_TIMEELEMENT_BASE                                 (DISPID_BASE + TIMEELEMENT_OFFSET)
#define DISPID_TIMEBODYELEMENT_BASE                             (DISPID_BASE + TIMEBODYELEMENT_OFFSET)
#define DISPID_TIMEDAELEMENT_BASE                               (DISPID_BASE + TIMEDAELEMENT_OFFSET)
#define DISPID_TIMEMEDIAELEMENT_BASE                            (DISPID_BASE + TIMEMEDIAELEMENT_OFFSET)
#define DISPID_TIMEFACTORY_BASE                                 (DISPID_BASE + TIMEFACTORY_OFFSET)
#define DISPID_TIMECOLLECTION_BASE                              (DISPID_BASE + TIMECOLLECTION_OFFSET)
#define DISPID_TIMECOLLECTION_RESERVED_BASE                     (DISPID_BASE + TIMECOLLECTION_RESERVED_OFFSET)
#define DISPID_TIMEMEDIAPLAYER_BASE                             (DISPID_BASE + TIMEMEDIAPLAYER_OFFSET)
#define DISPID_TIMEMEDIAPLAYEREVENTS_BASE                       (DISPID_BASE + TIMEMEDIAPLAYEREVENTS_OFFSET)

// Collection Reserve (for expando's and ordinal's)
#define DISPID_COLLECTION_RESERVED_MIN                          DISPID_TIMECOLLECTION_RESERVED_BASE
#define DISPID_COLLECTION_RESERVED_MAX                          0x0000007FF

// ITIMEElement DISPIDs:
#define DISPID_TIMEELEMENT_BEGIN                                (DISPID_TIMEELEMENT_BASE + 0x01)
#define DISPID_TIMEELEMENT_BEGINWITH                            (DISPID_TIMEELEMENT_BASE + 0x02)
#define DISPID_TIMEELEMENT_BEGINAFTER                           (DISPID_TIMEELEMENT_BASE + 0x03)
#define DISPID_TIMEELEMENT_BEGINEVENT                           (DISPID_TIMEELEMENT_BASE + 0x04)
#define DISPID_TIMEELEMENT_DUR                                  (DISPID_TIMEELEMENT_BASE + 0x05)
#define DISPID_TIMEELEMENT_END                                  (DISPID_TIMEELEMENT_BASE + 0x06)
#define DISPID_TIMEELEMENT_ENDWITH                              (DISPID_TIMEELEMENT_BASE + 0x07)
#define DISPID_TIMEELEMENT_ENDEVENT                             (DISPID_TIMEELEMENT_BASE + 0x08)
#define DISPID_TIMEELEMENT_ENDSYNC                              (DISPID_TIMEELEMENT_BASE + 0x09)
#define DISPID_TIMEELEMENT_REPEAT                               (DISPID_TIMEELEMENT_BASE + 0x0a)
#define DISPID_TIMEELEMENT_REPEATDUR                            (DISPID_TIMEELEMENT_BASE + 0x0b)
#define DISPID_TIMEELEMENT_TIMEACTION                           (DISPID_TIMEELEMENT_BASE + 0x0c)
#define DISPID_TIMEELEMENT_BEGINELEMENT                         (DISPID_TIMEELEMENT_BASE + 0x0d)
#define DISPID_TIMEELEMENT_ENDELEMENT                           (DISPID_TIMEELEMENT_BASE + 0x0e)
#define DISPID_TIMEELEMENT_PAUSE                                (DISPID_TIMEELEMENT_BASE + 0x0f)
#define DISPID_TIMEELEMENT_RESUME                               (DISPID_TIMEELEMENT_BASE + 0x10)
#define DISPID_TIMEELEMENT_CUE                                  (DISPID_TIMEELEMENT_BASE + 0x11)
#define DISPID_TIMEELEMENT_TIMELINE                             (DISPID_TIMEELEMENT_BASE + 0x12)
#define DISPID_TIMEELEMENT_CURRTIME                             (DISPID_TIMEELEMENT_BASE + 0x13)
#define DISPID_TIMEELEMENT_LOCALTIME                            (DISPID_TIMEELEMENT_BASE + 0x14)
#define DISPID_TIMEELEMENT_CURRSTATE                            (DISPID_TIMEELEMENT_BASE + 0x15)
#define DISPID_TIMEELEMENT_SYNCBEHAVIOR                         (DISPID_TIMEELEMENT_BASE + 0x16)
#define DISPID_TIMEELEMENT_SYNCTOLERANCE                        (DISPID_TIMEELEMENT_BASE + 0x17)
#define DISPID_TIMEELEMENT_PARENTTIMEELEMENT                    (DISPID_TIMEELEMENT_BASE + 0x19)
#define DISPID_TIMEELEMENT_ALLTIMEELEMENTS                      (DISPID_TIMEELEMENT_BASE + 0x1a)
#define DISPID_TIMEELEMENT_CHILDRENTIMEELEMENTS                 (DISPID_TIMEELEMENT_BASE + 0x1b)
#define DISPID_TIMEELEMENT_ALLTIMEINTERFACES                    (DISPID_TIMEELEMENT_BASE + 0x1c)
#define DISPID_TIMEELEMENT_CHILDRENTIMEINTERFACES               (DISPID_TIMEELEMENT_BASE + 0x1d)
#define DISPID_TIMEELEMENT_ACCELERATE                           (DISPID_TIMEELEMENT_BASE + 0x1e)
#define DISPID_TIMEELEMENT_DECELERATE                           (DISPID_TIMEELEMENT_BASE + 0x1f)
#define DISPID_TIMEELEMENT_AUTOREVERSE                          (DISPID_TIMEELEMENT_BASE + 0x20)
#define DISPID_TIMEELEMENT_EVENTRESTART                         (DISPID_TIMEELEMENT_BASE + 0x21)
#define DISPID_TIMEELEMENT_ENDHOLD                              (DISPID_TIMEELEMENT_BASE + 0x22)
#define DISPID_TIMEELEMENT_TIMELINEBEHAVIOR                     (DISPID_TIMEELEMENT_BASE + 0x23)
#define DISPID_TIMEELEMENT_PROGRESSBEHAVIOR                     (DISPID_TIMEELEMENT_BASE + 0x24)
#define DISPID_TIMEELEMENT_ONOFFBEHAVIOR                        (DISPID_TIMEELEMENT_BASE + 0x25)

// ITIMEBodyElement DISPIDs:
#define DISPID_TIMEBODYELEMENT_TIMESTARTRULE                    (DISPID_TIMEBODYELEMENT_BASE + 0x01)
#define DISPID_TIMEBODYELEMENT_ADDTIMEDAELEMENT                 (DISPID_TIMEBODYELEMENT_BASE + 0x02)
#define DISPID_TIMEBODYELEMENT_REMOVETIMEDAELEMENT              (DISPID_TIMEBODYELEMENT_BASE + 0x03)

// ITIMEDAElement DISPIDs:
#define DISPID_TIMEDAELEMENT_IMAGE                              (DISPID_TIMEDAELEMENT_BASE + 0x01)
#define DISPID_TIMEDAELEMENT_SOUND                              (DISPID_TIMEDAELEMENT_BASE + 0x02)
#define DISPID_TIMEDAELEMENT_RENDERMODE                         (DISPID_TIMEDAELEMENT_BASE + 0x03)
#define DISPID_TIMEDAELEMENT_ADDDABEHAVIOR                      (DISPID_TIMEDAELEMENT_BASE + 0x04)
#define DISPID_TIMEDAELEMENT_REMOVEDABEHAVIOR                   (DISPID_TIMEDAELEMENT_BASE + 0x05)
#define DISPID_TIMEDAELEMENT_STATICS                            (DISPID_TIMEDAELEMENT_BASE + 0x06)
#define DISPID_TIMEDAELEMENT_RENDEROBJECT                       (DISPID_TIMEDAELEMENT_BASE + 0x07)

// ITIMEMediaElement DISPIDs:
#define DISPID_TIMEMEDIAELEMENT_SRC                             (DISPID_TIMEMEDIAELEMENT_BASE + 0x01)
#define DISPID_TIMEMEDIAELEMENT_IMG                             (DISPID_TIMEMEDIAELEMENT_BASE + 0x02)
#define DISPID_TIMEMEDIAELEMENT_PLAYER                          (DISPID_TIMEMEDIAELEMENT_BASE + 0x03)
#define DISPID_TIMEMEDIAELEMENT_SRCTYPE                         (DISPID_TIMEMEDIAELEMENT_BASE + 0x04)
#define DISPID_TIMEMEDIAELEMENT_PLAYEROBJECT                    (DISPID_TIMEMEDIAELEMENT_BASE + 0x05)
#define DISPID_TIMEMEDIAELEMENT_CLOCKSOURCE                     (DISPID_TIMEMEDIAELEMENT_BASE + 0x06)
#define DISPID_TIMEMEDIAELEMENT_CLIPBEGIN                       (DISPID_TIMEMEDIAELEMENT_BASE + 0x07)
#define DISPID_TIMEMEDIAELEMENT_CLIPEND                         (DISPID_TIMEMEDIAELEMENT_BASE + 0x08)

// ITIMEFactory DISPIDs:
#define DISPID_TIMEFACTORY_CREATETIMEELEMENT                    (DISPID_TIMEFACTORY_BASE + 0x01)
#define DISPID_TIMEFACTORY_CREATETIMEELEMENTBODY                (DISPID_TIMEFACTORY_BASE + 0x02)
#define DISPID_TIMEFACTORY_CREATETIMEDAELEMENT                  (DISPID_TIMEFACTORY_BASE + 0x03)
#define DISPID_TIMEFACTORY_CREATETIMEMEDIAELEMENT               (DISPID_TIMEFACTORY_BASE + 0x04)

//
// ITIMEElementCollection
//
#define DISPID_TIMEELEMENTCOLLECTION_LENGTH                     (DISPID_TIMECOLLECTION_BASE + 0x01)
#define DISPID_TIMEELEMENTCOLLECTION__NEWENUM                   (DISPID_NEWENUM)
#define DISPID_TIMEELEMENTCOLLECTION_ITEM                       (DISPID_VALUE)
#define DISPID_TIMEELEMENTCOLLECTION_TAGS                       (DISPID_TIMECOLLECTION_BASE + 0x02)

//
// ITIMEMediaPlayer
//
#define DISPID_TIMEMEDIAPLAYER_CLIPBEGIN                        (DISPID_TIMEMEDIAPLAYER_BASE + 0x01)
#define DISPID_TIMEMEDIAPLAYER_CLIPEND                          (DISPID_TIMEMEDIAPLAYER_BASE + 0x02)
#define DISPID_TIMEMEDIAPLAYER_BEGIN                            (DISPID_TIMEMEDIAPLAYER_BASE + 0x03)
#define DISPID_TIMEMEDIAPLAYER_END                              (DISPID_TIMEMEDIAPLAYER_BASE + 0x04)
#define DISPID_TIMEMEDIAPLAYER_RESUME                           (DISPID_TIMEMEDIAPLAYER_BASE + 0x05)
#define DISPID_TIMEMEDIAPLAYER_PAUSE                            (DISPID_TIMEMEDIAPLAYER_BASE + 0x06)
#define DISPID_TIMEMEDIAPLAYER_TICK                             (DISPID_TIMEMEDIAPLAYER_BASE + 0x07)
#define DISPID_TIMEMEDIAPLAYER_CURRENTTIME                      (DISPID_TIMEMEDIAPLAYER_BASE + 0x08)
#define DISPID_TIMEMEDIAPLAYER_SRC                              (DISPID_TIMEMEDIAPLAYER_BASE + 0x09)
#define DISPID_TIMEMEDIAPLAYER_INIT                             (DISPID_TIMEMEDIAPLAYER_BASE + 0x0A)
#define DISPID_TIMEMEDIAPLAYER_REPEAT                           (DISPID_TIMEMEDIAPLAYER_BASE + 0x0B)
#define DISPID_TIMEMEDIAPLAYER_CUE                              (DISPID_TIMEMEDIAPLAYER_BASE + 0x0C)

//
// ITIMEMediaPlayer
//
#define DISPID_TIMEMEDIAPLAYEREVENTS_ONBEGIN                    (DISPID_TIMEMEDIAPLAYEREVENTS_BASE + 0x01)
#define DISPID_TIMEMEDIAPLAYEREVENTS_ONEND                      (DISPID_TIMEMEDIAPLAYEREVENTS_BASE + 0x02)
#define DISPID_TIMEMEDIAPLAYEREVENTS_ONRESUME                   (DISPID_TIMEMEDIAPLAYEREVENTS_BASE + 0x03)
#define DISPID_TIMEMEDIAPLAYEREVENTS_ONPAUSE                    (DISPID_TIMEMEDIAPLAYEREVENTS_BASE + 0x04)
#define DISPID_TIMEMEDIAPLAYEREVENTS_ONMEDIAREADY               (DISPID_TIMEMEDIAPLAYEREVENTS_BASE + 0x05)
#define DISPID_TIMEMEDIAPLAYEREVENTS_ONMEDIASLIP                (DISPID_TIMEMEDIAPLAYEREVENTS_BASE + 0x06)
#define DISPID_TIMEMEDIAPLAYEREVENTS_ONMEDIALOADFAILED          (DISPID_TIMEMEDIAPLAYEREVENTS_BASE + 0x07)
#define DISPID_TIMEMEDIAPLAYEREVENTS_READYSTATECHANGE           (DISPID_READYSTATECHANGE)

#endif  //__TIMEDISPID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\dshowdev\proxy\strmifp.c ===
#include <strmif_p.c>

 
/* [local] */ HRESULT STDMETHODCALLTYPE IKsPropertySet_Set_Proxy( 
    IKsPropertySet __RPC_FAR * This,
    /* [in] */ REFGUID guidPropSet,
    /* [in] */ DWORD dwPropID,
    /* [size_is][in] */ LPVOID pInstanceData,
    /* [in] */ DWORD cbInstanceData,
    /* [size_is][in] */ LPVOID pPropData,
    /* [in] */ DWORD cbPropData)
{
    return IKsPropertySet_RemoteSet_Proxy(This, guidPropSet, dwPropID,
                                          (LPBYTE) pInstanceData, cbInstanceData,
                                          (LPBYTE) pPropData, cbPropData);
}


/* [call_as] */ HRESULT STDMETHODCALLTYPE IKsPropertySet_Set_Stub( 
    IKsPropertySet __RPC_FAR * This,
    /* [in] */ REFGUID guidPropSet,
    /* [in] */ DWORD dwPropID,
    /* [size_is][in] */ byte __RPC_FAR *pInstanceData,
    /* [in] */ DWORD cbInstanceData,
    /* [size_is][in] */ byte __RPC_FAR *pPropData,
    /* [in] */ DWORD cbPropData)
{
    return This->lpVtbl->Set(This, guidPropSet, dwPropID,
                             (LPVOID) pInstanceData, cbInstanceData,
                             (LPVOID) pPropData, cbPropData);
}


/* [local] */ HRESULT STDMETHODCALLTYPE IKsPropertySet_Get_Proxy( 
    IKsPropertySet __RPC_FAR * This,
    /* [in] */ REFGUID guidPropSet,
    /* [in] */ DWORD dwPropID,
    /* [size_is][in] */ LPVOID pInstanceData,
    /* [in] */ DWORD cbInstanceData,
    /* [size_is][out] */ LPVOID pPropData,
    /* [in] */ DWORD cbPropData,
    /* [out] */ DWORD __RPC_FAR *pcbReturned)
{
    return IKsPropertySet_RemoteGet_Proxy(This, guidPropSet, dwPropID,
                                          (LPBYTE) pInstanceData, cbInstanceData,
                                          (LPBYTE) pPropData, cbPropData, pcbReturned);
}



/* [call_as] */ HRESULT STDMETHODCALLTYPE IKsPropertySet_Get_Stub( 
    IKsPropertySet __RPC_FAR * This,
    /* [in] */ REFGUID guidPropSet,
    /* [in] */ DWORD dwPropID,
    /* [size_is][in] */ byte __RPC_FAR *pInstanceData,
    /* [in] */ DWORD cbInstanceData,
    /* [size_is][out] */ byte __RPC_FAR *pPropData,
    /* [in] */ DWORD cbPropData,
    /* [out] */ DWORD __RPC_FAR *pcbReturned)
{
    return This->lpVtbl->Get(This, guidPropSet, dwPropID,
                             (LPVOID) pInstanceData, cbInstanceData,
                             (LPVOID) pPropData, cbPropData, pcbReturned);
}


HRESULT STDMETHODCALLTYPE ICaptureGraphBuilder_FindInterface_Proxy( 
    ICaptureGraphBuilder __RPC_FAR * This,
    /* [unique][in] */ const GUID __RPC_FAR *pCategory,
    /* [in] */ IBaseFilter __RPC_FAR *pf,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppint)
{
    return ICaptureGraphBuilder_RemoteFindInterface_Proxy(This, pCategory, pf, riid,
                                                           (IUnknown **) ppint);

}

HRESULT STDMETHODCALLTYPE ICaptureGraphBuilder_FindInterface_Stub( 
    ICaptureGraphBuilder __RPC_FAR * This,
    /* [unique][in] */ const GUID __RPC_FAR *pCategory,
    /* [in] */ IBaseFilter __RPC_FAR *pf,
    /* [in] */ REFIID riid,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppint)
{
    return This->lpVtbl->FindInterface(This, pCategory, pf, riid,(void **) ppint);

}

HRESULT STDMETHODCALLTYPE ICaptureGraphBuilder2_FindInterface_Proxy( 
    ICaptureGraphBuilder2 __RPC_FAR * This,
    /* [unique][in] */ const GUID __RPC_FAR *pCategory,
    /* [unique][in] */ const GUID __RPC_FAR *pType,
    /* [in] */ IBaseFilter __RPC_FAR *pf,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppint)
{
    return ICaptureGraphBuilder2_RemoteFindInterface_Proxy(This, pCategory, pType, pf, riid,
                                                           (IUnknown **) ppint);
}

HRESULT STDMETHODCALLTYPE ICaptureGraphBuilder2_FindInterface_Stub( 
    ICaptureGraphBuilder2 __RPC_FAR * This,
    /* [unique][in] */ const GUID __RPC_FAR *pCategory,
    /* [unique][in] */ const GUID __RPC_FAR *pType,
    /* [in] */ IBaseFilter __RPC_FAR *pf,
    /* [in] */ REFIID riid,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppint)
{
    return This->lpVtbl->FindInterface(This, pCategory, pType, pf, riid, (void **) ppint);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\inc\daerror.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 *
 * Contains all the DirectAnimation error codes
 *
 *******************************************************************************/


#ifndef _DAERROR_H
#define _DAERROR_H

#include <winerror.h>

#define FACILITY_DIRECTANIMATION    FACILITY_ITF
#define DAERR_CODE_BEGIN            0x1000

#define DA_MAKE_HRESULT(i)          MAKE_HRESULT(SEVERITY_ERROR,            \
                                                 FACILITY_DIRECTANIMATION,  \
                                                 (DAERR_CODE_BEGIN + i))


// BEGIN - View specific error codes.
#define DAERR_VIEW_LOCKED               DA_MAKE_HRESULT(10)
#define DAERR_VIEW_TARGET_NOT_SET       DA_MAKE_HRESULT(11)
#define DAERR_VIEW_SURFACE_BUSY         DA_MAKE_HRESULT(12)
// End   - View specific error codes.

    
// BEGIN - DXTransform specific error codes.
#define DAERR_DXTRANSFORM_UNSUPPORTED_OPERATION               DA_MAKE_HRESULT(20)
// End   - DXTransform specific error codes.

    
#endif /* _DAERROR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\inc\makefile.inc ===
###############################################################################
###############################################################################
##
## Makefile.inc
##
## Update this file with all your public headers.  Also update "sources".
##
## !!! NOTE !!!
## If a version of your header also exists in private\windows\inc or
## private\iedev\inc, then you will also need to update the section below
## entitled "Conflicting headers" with your file(s)
## 
###############################################################################
###############################################################################

FILES = $(O)\daerror.h
        
PublishHeaders: $(FILES)


###############################################################################
## Conflicting headers
###############################################################################


##// end Conflicting headers

clean:
    -del /Q $(FILES)

#
# DX Transform header files
#

#
# DA Headers
#
$(SDK_INC_PATH)\daerror.h : .\daerror.h

.SUFFIXES:.h .cpp .c .idl .x

{}.x{$(O)}.h:
    hsplit -o $@ nul -bt2 BEGIN_MSINTERNAL END_MSINTERNAL -c @@ $?

{}.cpp{$(O)}.cpp:
    copy $? $@

{}.c{$(O)}.c:
    copy $? $@

{}.h{$(O)}.h:
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\media\makefile.inc ===
processedfiles: \
    $(O)\mmsystem.h \
    $(O)\mmsysp.h   \
    $(O)\mmddk.h    \
    $(O)\mmddkp.h   \
    $(O)\msacm.h

#
# mmsystem.h, mmsystem.x, mmsysp.h, mmsysp.x
#

$(O)\mmsystem.x $(O)\mmsysp.x: mmsystem.w
    hsplit -e -s -o $(O)\mmsystem.y nul -lt2 inc -bt2 begin_inc end_inc -ltb hinc -btb begin_hinc end_hinc mmsystem.w
    hsplit -e -n -o $(O)\mmsystem.x $(O)\mmsysp.x $(O)\mmsystem.y

$(O)\mmsystem.h: $(O)\mmsystem.x
    wcshdr < $? > $@

$(O)\mmsysp.h:  $(O)\mmsysp.x
    wcshdr < $? > $@

#
# mmddk.h, mmddkp.h
#

$(O)\mmddk.h: mmddk.h
    hsplit -lt2 Internal -e -o $@ nul mmddk.h
    
$(O)\mmddkp.h: mmddk.h
    copy $? $@

#
# msacm.h
#
$(O)\msacm.h: msacm.w
    hsplit -lt2 Internal -e -o $@ nul msacm.w
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\dxmdev\lib\guids.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       guids.c
//
//  Contents:   Random GUIDs
//
//  Classes:
//
//  Functions:
//
//  History:    6-12-96   twillie  Created
//
//----------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

typedef struct
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} CLSID, IID, GUID, CATID, SID;


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\reality\makefile.inc ===
processedfiles: \
    $(O)\d3drm.h    \
    $(O)\d3prm.h    \
    $(O)\d3drmdef.h \
    $(O)\d3prmdef.h \
    $(O)\d3drmobj.h \
    $(O)\d3prmobj.h \
    $(O)\d3drmvis.h \
    $(O)\d3prmvis.h \
    $(O)\d3drmwin.h \
    $(O)\d3prmwin.h 

$(O)\d3drm.h : d3drm.x
    hsplit -o $@ nul -bt2 BEGIN_MSINTERNAL END_MSINTERNAL -c @@ d3drm.x

$(O)\d3prm.h : d3drm.x
    copy $? $@
    
$(O)\d3drmdef.h : d3drmdef.x
    hsplit -o $@ nul -bt2 BEGIN_MSINTERNAL END_MSINTERNAL -c @@ d3drmdef.x

$(O)\d3prmdef.h: d3drmdef.x
    copy $? $@

$(O)\d3drmobj.h : d3drmobj.x
    hsplit -o $@ nul -bt2 BEGIN_MSINTERNAL END_MSINTERNAL -c @@ d3drmobj.x

$(O)\d3prmobj.h: d3drmobj.x
    copy $? $@

$(O)\d3drmvis.h : d3drmvis.x
    hsplit -o $@ nul -bt2 BEGIN_MSINTERNAL END_MSINTERNAL -c @@ d3drmvis.x

$(O)\d3prmvis.h: d3drmvis.x
    copy $? $@

$(O)\d3drmwin.h : d3drmwin.x
    hsplit -o $@ nul -bt2 BEGIN_MSINTERNAL END_MSINTERNAL -c @@ d3drmwin.x

$(O)\d3prmwin.h: d3drmwin.x
    copy $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\media\mmddk.h ===
/****************************************************************************/
/*                                                                          */
/*      MMDDK.H - Include file for Multimedia Device Development Kit        */
/*                                                                          */
/*      Note: You must include the WINDOWS.H and MMSYSTEM.H header files    */
/*            before including this file.                                   */
/*                                                                          */
/*      Copyright (c) 1990-1998, Microsoft Corp.  All rights reserved.      */
/*                                                                          */
/****************************************************************************/

#ifndef _INC_MMDDK
#define _INC_MMDDK

#include "pshpack1.h"   // Assume byte packing throughout

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/*    If defined, the following flags inhibit inclusion
 *    of the indicated items:
 *
 *        MMNOMIDIDEV         - MIDI support
 *        MMNOWAVEDEV         - Waveform support
 *        MMNOAUXDEV          - Auxiliary output support
 *        MMNOMIXERDEV        - Mixer support
 *        MMNOTIMERDEV        - Timer support
 *        MMNOJOYDEV          - Joystick support
 *        MMNOMCIDEV          - MCI support
 *        MMNOTASKDEV         - Task support
 */
#ifdef MMNOTIMER
  #define MMNOTIMERDEV
#endif
#ifdef MMNOWAVE
  #define MMNOWAVEDEV
#endif
#ifdef MMNOMIDI
  #define MMNOMIDIDEV
#endif
#ifdef MMNOAUX
  #define MMNOAUXDEV
#endif
#ifdef MMNOJOY
  #define MMNOJOYDEV
#endif
#ifdef MMNOMMIO
  #define MMNOMMIODEV
#endif
#ifdef MMNOMCI
  #define MMNOMCIDEV
#endif

#ifdef  NOMIDIDEV       /* ;Internal */
#define MMNOMIDIDEV     /* ;Internal */
#endif              /* ;Internal */
#ifdef  NOWAVEDEV       /* ;Internal */
#define MMNOWAVEDEV     /* ;Internal */
#endif              /* ;Internal */
#ifdef  NOAUXDEV        /* ;Internal */
#define MMNOAUXDEV      /* ;Internal */
#endif              /* ;Internal */
#ifdef  NOTIMERDEV      /* ;Internal */
#define MMNOTIMERDEV        /* ;Internal */
#endif              /* ;Internal */
#ifdef  NOJOYDEV        /* ;Internal */
#define MMNOJOYDEV      /* ;Internal */
#endif              /* ;Internal */
#ifdef  NOMCIDEV        /* ;Internal */
#define MMNOMCIDEV      /* ;Internal */
#endif              /* ;Internal */
#ifdef  NOTASKDEV       /* ;Internal */
#define MMNOTASKDEV     /* ;Internal */
#endif              /* ;Internal */

/***************************************************************************

                       Helper functions for drivers

***************************************************************************/

#ifndef NODRIVERS
#define DRV_LOAD               0x0001
#define DRV_ENABLE             0x0002
#define DRV_OPEN               0x0003
#define DRV_CLOSE              0x0004
#define DRV_DISABLE            0x0005
#define DRV_FREE               0x0006
#define DRV_CONFIGURE          0x0007
#define DRV_QUERYCONFIGURE     0x0008
#define DRV_INSTALL            0x0009
#define DRV_REMOVE             0x000A

#define DRV_RESERVED           0x0800
#define DRV_USER               0x4000

#define DRIVERS_SECTION  TEXT("DRIVERS32")     // Section name for installed drivers
#define MCI_SECTION      TEXT("MCI32")         // Section name for installed MCI drivers

#endif /* !NODRIVERS */

#define DCB_NOSWITCH   0x0008           // don't switch stacks for callback
#define DCB_TYPEMASK   0x0007           // callback type mask
#define DCB_NULL       0x0000           // unknown callback type

// flags for wFlags parameter of DriverCallback()
#define DCB_WINDOW     0x0001           // dwCallback is a HWND
#define DCB_TASK       0x0002           // dwCallback is a HTASK
#define DCB_FUNCTION   0x0003           // dwCallback is a FARPROC
#define DCB_EVENT      0x0005           // dwCallback is an EVENT

BOOL APIENTRY DriverCallback(DWORD_PTR dwCallback, DWORD dwFlags,
    HDRVR hDevice, DWORD dwMsg, DWORD_PTR dwUser, DWORD_PTR dwParam1, DWORD_PTR dwParam2);

// generic prototype for audio device driver entry-point functions
// midMessage(), modMessage(), widMessage(), wodMessage(), auxMessage()
//typedef DWORD (SOUNDDEVMSGPROC)(WORD, WORD, DWORD, DWORD, DWORD);
//typedef SOUNDDEVMSGPROC FAR *LPSOUNDDEVMSGPROC;

#define DRVM_INIT               100
#define DRVM_EXIT               101
#define DRVM_DISABLE            102
#define DRVM_ENABLE             103


// message base for driver specific messages.
//
#ifndef DRVM_MAPPER
#define DRVM_MAPPER             (0x2000)
#endif
#define DRVM_USER               0x4000
#define DRVM_MAPPER_STATUS      (DRVM_MAPPER+0)
#define DRVM_MAPPER_RECONFIGURE (DRVM_MAPPER+1)
#define	DRVM_MAPPER_QUERYDEST	                  (DRVM_MAPPER+20) /* ;Internal */
#define DRVM_MAPPER_PREFERRED_GET                 (DRVM_MAPPER+21)
#define DRVM_MAPPER_PREFERRED_SET                 (DRVM_MAPPER+22) /* ;Internal */
#define DRVM_MAPPER_CONSOLEVOICECOM_GET           (DRVM_MAPPER+23)
#define DRVM_MAPPER_CONSOLEVOICECOM_SET           (DRVM_MAPPER+24) /* ;Internal */

#define DRV_QUERYDRVENTRY            (DRV_RESERVED + 1)         /* ;Internal */
#define DRV_QUERYDEVNODE             (DRV_RESERVED + 2)
#define DRV_QUERYNAME                (DRV_RESERVED + 3)         /* ;Internal */
#define DRV_QUERYDRIVERIDS           (DRV_RESERVED + 4)         /* ;Internal */
#define DRV_QUERYMAPPABLE            (DRV_RESERVED + 5)
#define DRV_QUERYMAPID               (DRV_RESERVED + 6)         /* ;Internal */
#define DRV_QUERYNUMPORTS            (DRV_RESERVED + 8)         /* ;Internal */
#define DRV_QUERYMODULE              (DRV_RESERVED + 9)
#define DRV_QUERYFILENAME            (DRV_RESERVED + 10)        /* ;Internal */
#define DRV_PNPINSTALL               (DRV_RESERVED + 11)
#define DRV_QUERYDEVICEINTERFACE     (DRV_RESERVED + 12)
#define DRV_QUERYDEVICEINTERFACESIZE (DRV_RESERVED + 13)
#define DRV_QUERYSTRINGID            (DRV_RESERVED + 14)
#define DRV_QUERYSTRINGIDSIZE        (DRV_RESERVED + 15)
#define DRV_QUERYIDFROMSTRINGID      (DRV_RESERVED + 16)

//
// DRVM_MAPPER_PREFERRED_GET flags
//
#define DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY   0x00000001



//
// messages that have IOCTL format
//    dw1 = NULL or handle
//    dw2 = NULL or ptr to DRVM_IOCTL_DATA
//    return is MMRESULT
//
#define DRVM_IOCTL                0x100
#define DRVM_ADD_THRU             (DRVM_IOCTL+1)
#define DRVM_REMOVE_THRU          (DRVM_IOCTL+2)
#define DRVM_IOCTL_LAST           (DRVM_IOCTL+5)

typedef struct {
    DWORD  dwSize; // size of this structure (inclusive)
    DWORD  dwCmd;  // IOCTL command code, 0x80000000 and above reserved for system
    } DRVM_IOCTL_DATA, FAR * LPDRVM_IOCTL_DATA;

// command code ranges for dwCmd field of DRVM_IOCTL message
// codes from 0 to 0x7FFFFFFF are user defined
// codes from 0x80000000 to 0xFFFFFFFF are reserved for future
// definition by microsoft
//
#define DRVM_IOCTL_CMD_USER   0x00000000L
#define DRVM_IOCTL_CMD_SYSTEM 0x80000000L

// device ID for 386 AUTODMA VxD
#define VADMAD_Device_ID    0X0444

/* PnP version of media device caps */
typedef struct {
    DWORD	cbSize;
    LPVOID	pCaps;
} MDEVICECAPSEX;

#ifndef MMNOWAVEDEV
/****************************************************************************

                       Waveform device driver support

****************************************************************************/

#define WODM_INIT      DRVM_INIT
#define WIDM_INIT      DRVM_INIT

// waveform input and output device open information structure
typedef struct waveopendesc_tag {
    HWAVE          hWave;             // handle
    LPWAVEFORMAT   lpFormat;          // format of wave data
    DWORD_PTR      dwCallback;        // callback
    DWORD_PTR      dwInstance;        // app's private instance information
    UINT           uMappedDeviceID;   // device to map to if WAVE_MAPPED set
    DWORD_PTR      dnDevNode;         /* if device is PnP */
} WAVEOPENDESC;
typedef WAVEOPENDESC FAR *LPWAVEOPENDESC;

// messages sent to wodMessage() entry-point function
#define WODM_GETNUMDEVS       3
#define WODM_GETDEVCAPS       4
#define WODM_OPEN             5
#define WODM_CLOSE            6
#define WODM_PREPARE          7
#define WODM_UNPREPARE        8
#define WODM_WRITE            9
#define WODM_PAUSE            10
#define WODM_RESTART          11
#define WODM_RESET            12
#define WODM_GETPOS           13
#define WODM_GETPITCH         14
#define WODM_SETPITCH         15
#define WODM_GETVOLUME        16
#define WODM_SETVOLUME        17
#define WODM_GETPLAYBACKRATE  18
#define WODM_SETPLAYBACKRATE  19
#define WODM_BREAKLOOP        20
#define WODM_PREFERRED        21
// #if (WINVER >= 0x030B)
#define WODM_MAPPER_STATUS              (DRVM_MAPPER_STATUS + 0)
#define WAVEOUT_MAPPER_STATUS_DEVICE    0
#define WAVEOUT_MAPPER_STATUS_MAPPED    1
#define WAVEOUT_MAPPER_STATUS_FORMAT    2
// #endif /* WINVER >= 0x030B */
#define WODM_BUSY             21

// messages sent to widMessage() entry-point function
#define WIDM_GETNUMDEVS  50
#define WIDM_GETDEVCAPS  51
#define WIDM_OPEN        52
#define WIDM_CLOSE       53
#define WIDM_PREPARE     54
#define WIDM_UNPREPARE   55
#define WIDM_ADDBUFFER   56
#define WIDM_START       57
#define WIDM_STOP        58
#define WIDM_RESET       59
#define WIDM_GETPOS      60
#define WIDM_PREFERRED   61
// #if (WINVER >= 0x030B)
#define WIDM_MAPPER_STATUS              (DRVM_MAPPER_STATUS + 0)
#define WAVEIN_MAPPER_STATUS_DEVICE     0
#define WAVEIN_MAPPER_STATUS_MAPPED     1
#define WAVEIN_MAPPER_STATUS_FORMAT     2
// #endif /* WINVER >= 0x30B */

#endif // ifndef MMNOWAVEDEV


#ifndef MMNOMIDIDEV
/****************************************************************************

                          MIDI device driver support

****************************************************************************/

#define MODM_USER      DRVM_USER
#define MIDM_USER      DRVM_USER
#define MODM_MAPPER    DRVM_MAPPER
#define MIDM_MAPPER    DRVM_MAPPER

#define MODM_INIT      DRVM_INIT
#define MIDM_INIT      DRVM_INIT

#ifndef MMNOMIDI   // This protects the definition of HMIDI in WINMM.H
                   // Win 3.1 works the same way
typedef struct midiopenstrmid_tag {
    DWORD          dwStreamID;
    UINT           uDeviceID;
} MIDIOPENSTRMID;
// MIDI input and output device open information structure
typedef struct midiopendesc_tag {
    HMIDI          hMidi;             // handle
    DWORD_PTR      dwCallback;        // callback
    DWORD_PTR      dwInstance;        // app's private instance information
    DWORD_PTR      dnDevNode;         // DevNode
    DWORD          cIds;              // If stream open, # stream ids
    MIDIOPENSTRMID rgIds[1];          // Array of device ID's (actually [cIds])
} MIDIOPENDESC;
typedef MIDIOPENDESC FAR *LPMIDIOPENDESC;
#endif // MMNOMIDI


/* Flags for MODM_OPEN */
#define MIDI_IO_PACKED      0x00000000L     /* Compatibility mode */
#define MIDI_IO_COOKED      0x00000002L

// messages sent to modMessage() entry-point function
#define MODM_GETNUMDEVS     1
#define MODM_GETDEVCAPS     2
#define MODM_OPEN           3
#define MODM_CLOSE          4
#define MODM_PREPARE        5
#define MODM_UNPREPARE      6
#define MODM_DATA           7
#define MODM_LONGDATA       8
#define MODM_RESET          9
#define MODM_GETVOLUME      10
#define MODM_SETVOLUME      11
#define MODM_CACHEPATCHES       12
#define MODM_CACHEDRUMPATCHES   13

#if (WINVER >= 0x400)
#define MODM_STRMDATA               14
#define MODM_GETPOS                 17
#define MODM_PAUSE                  18
#define MODM_RESTART                19
#define MODM_STOP                   20
#define MODM_PROPERTIES             21
#define MODM_PREFERRED              22
#define MODM_RECONFIGURE            (MODM_USER+0x0768)
#endif


// messages sent to midMessage() entry-point function
#define MIDM_GETNUMDEVS  53
#define MIDM_GETDEVCAPS  54
#define MIDM_OPEN        55
#define MIDM_CLOSE       56
#define MIDM_PREPARE     57
#define MIDM_UNPREPARE   58
#define MIDM_ADDBUFFER   59
#define MIDM_START       60
#define MIDM_STOP        61
#define MIDM_RESET       62

#endif // ifndef MMNOMIDIDEV


#ifndef MMNOAUXDEV
/****************************************************************************

                    Auxiliary audio device driver support

****************************************************************************/

#define AUXM_INIT      DRVM_INIT

// messages sent to auxMessage() entry-point function
#define AUXDM_GETNUMDEVS    3
#define AUXDM_GETDEVCAPS    4
#define AUXDM_GETVOLUME     5
#define AUXDM_SETVOLUME     6

#endif // ifndef MMNOAUXDEV

// #if (WINVER >= 0x030B)
#ifndef MMNOMIXERDEV

//
//  mixer device open information structure
//
//
typedef struct tMIXEROPENDESC
{
    HMIXER          hmx;            // handle that will be used
    LPVOID          pReserved0;     // reserved--driver should ignore
    DWORD_PTR       dwCallback;     // callback
    DWORD_PTR       dwInstance;     // app's private instance information
    DWORD_PTR       dnDevNode;      // if device is PnP

} MIXEROPENDESC, *PMIXEROPENDESC, FAR *LPMIXEROPENDESC;



//
//
//
//
#define MXDM_INIT                   100
#define MXDM_USER                   DRV_USER

#define MXDM_BASE                   (1)
#define MXDM_GETNUMDEVS             (MXDM_BASE + 0)
#define MXDM_GETDEVCAPS             (MXDM_BASE + 1)
#define MXDM_OPEN                   (MXDM_BASE + 2)
#define MXDM_CLOSE                  (MXDM_BASE + 3)
#define MXDM_GETLINEINFO            (MXDM_BASE + 4)
#define MXDM_GETLINECONTROLS        (MXDM_BASE + 5)
#define MXDM_GETCONTROLDETAILS      (MXDM_BASE + 6)
#define MXDM_SETCONTROLDETAILS      (MXDM_BASE + 7)

#endif // MMNOMIXERDEV
// #endif /* ifdef WINVER >= 0x030B */

#if !defined(MMNOTIMERDEV)
/****************************************************************************

                        Timer device driver support

****************************************************************************/

typedef struct timerevent_tag {
    WORD                wDelay;         // delay required
    WORD                wResolution;    // resolution required
    LPTIMECALLBACK      lpFunction;     // ptr to callback function
    DWORD               dwUser;         // user DWORD
    WORD                wFlags;         // defines how to program event
    WORD                wReserved1;     // structure packing
} TIMEREVENT;
typedef TIMEREVENT FAR *LPTIMEREVENT;

// messages sent to tddMessage() function
#define TDD_KILLTIMEREVENT  (DRV_RESERVED+0)  // indices into a table of
#define TDD_SETTIMEREVENT   (DRV_RESERVED+4)  // functions; thus offset by
#define TDD_GETSYSTEMTIME   (DRV_RESERVED+8)  // four each time...
#define TDD_GETDEVCAPS      (DRV_RESERVED+12) // room for future expansion
#define TDD_BEGINMINPERIOD  (DRV_RESERVED+16) // room for future expansion
#define TDD_ENDMINPERIOD    (DRV_RESERVED+20) // room for future expansion

#endif // ifndef MMNOTIMERDEV


#ifndef MMNOJOYDEV
/****************************************************************************

                       Joystick device driver support

****************************************************************************/

/* RegisterWindowMessage with this to get msg id of config changes */
#define JOY_CONFIGCHANGED_MSGSTRING     "MSJSTICK_VJOYD_MSGSTR"

/* pre-defined joystick types */
#define JOY_HW_NONE                     0
#define JOY_HW_CUSTOM                   1
#define JOY_HW_2A_2B_GENERIC            2
#define JOY_HW_2A_4B_GENERIC            3
#define JOY_HW_2B_GAMEPAD               4
#define JOY_HW_2B_FLIGHTYOKE            5
#define JOY_HW_2B_FLIGHTYOKETHROTTLE    6
#define JOY_HW_3A_2B_GENERIC            7
#define JOY_HW_3A_4B_GENERIC            8
#define JOY_HW_4B_GAMEPAD               9
#define JOY_HW_4B_FLIGHTYOKE            10
#define JOY_HW_4B_FLIGHTYOKETHROTTLE    11
#define JOY_HW_LASTENTRY                12

/* calibration flags */
#define JOY_ISCAL_XY            0x00000001l     /* XY are calibrated */
#define JOY_ISCAL_Z             0x00000002l     /* Z is calibrated */
#define JOY_ISCAL_R             0x00000004l     /* R is calibrated */
#define JOY_ISCAL_U             0x00000008l     /* U is calibrated */
#define JOY_ISCAL_V             0x00000010l     /* V is calibrated */
#define JOY_ISCAL_POV           0x00000020l     /* POV is calibrated */

/* point of view constants */
#define JOY_POV_NUMDIRS          4
#define JOY_POVVAL_FORWARD       0
#define JOY_POVVAL_BACKWARD      1
#define JOY_POVVAL_LEFT          2
#define JOY_POVVAL_RIGHT         3

/* Specific settings for joystick hardware */
#define JOY_HWS_HASZ            0x00000001l     /* has Z info? */
#define JOY_HWS_HASPOV          0x00000002l     /* point of view hat present */
#define JOY_HWS_POVISBUTTONCOMBOS 0x00000004l   /* pov done through combo of buttons */
#define JOY_HWS_POVISPOLL       0x00000008l     /* pov done through polling */
#define JOY_HWS_ISYOKE          0x00000010l     /* joystick is a flight yoke */
#define JOY_HWS_ISGAMEPAD       0x00000020l     /* joystick is a game pad */
#define JOY_HWS_ISCARCTRL       0x00000040l     /* joystick is a car controller */
/* X defaults to J1 X axis */
#define JOY_HWS_XISJ1Y          0x00000080l     /* X is on J1 Y axis */
#define JOY_HWS_XISJ2X          0x00000100l     /* X is on J2 X axis */
#define JOY_HWS_XISJ2Y          0x00000200l     /* X is on J2 Y axis */
/* Y defaults to J1 Y axis */
#define JOY_HWS_YISJ1X          0x00000400l     /* Y is on J1 X axis */
#define JOY_HWS_YISJ2X          0x00000800l     /* Y is on J2 X axis */
#define JOY_HWS_YISJ2Y          0x00001000l     /* Y is on J2 Y axis */
/* Z defaults to J2 Y axis */
#define JOY_HWS_ZISJ1X          0x00002000l     /* Z is on J1 X axis */
#define JOY_HWS_ZISJ1Y          0x00004000l     /* Z is on J1 Y axis */
#define JOY_HWS_ZISJ2X          0x00008000l     /* Z is on J2 X axis */
/* POV defaults to J2 Y axis, if it is not button based */
#define JOY_HWS_POVISJ1X        0x00010000l     /* pov done through J1 X axis */
#define JOY_HWS_POVISJ1Y        0x00020000l     /* pov done through J1 Y axis */
#define JOY_HWS_POVISJ2X        0x00040000l     /* pov done through J2 X axis */
/* R defaults to J2 X axis */
#define JOY_HWS_HASR            0x00080000l     /* has R (4th axis) info */
#define JOY_HWS_RISJ1X          0x00100000l     /* R done through J1 X axis */
#define JOY_HWS_RISJ1Y          0x00200000l     /* R done through J1 Y axis */
#define JOY_HWS_RISJ2Y          0x00400000l     /* R done through J2 X axis */
/* U & V for future hardware */
#define JOY_HWS_HASU            0x00800000l     /* has U (5th axis) info */
#define JOY_HWS_HASV            0x01000000l     /* has V (6th axis) info */

/* Usage settings */
#define JOY_US_HASRUDDER        0x00000001l     /* joystick configured with rudder */
#define JOY_US_PRESENT          0x00000002l     /* is joystick actually present? */
#define JOY_US_ISOEM            0x00000004l     /* joystick is an OEM defined type */

/* struct for storing x,y, z, and rudder values */
typedef struct joypos_tag {
    DWORD       dwX;
    DWORD       dwY;
    DWORD       dwZ;
    DWORD       dwR;
    DWORD       dwU;
    DWORD       dwV;
} JOYPOS, FAR *LPJOYPOS;

/* struct for storing ranges */
typedef struct joyrange_tag {
    JOYPOS      jpMin;
    JOYPOS      jpMax;
    JOYPOS      jpCenter;
} JOYRANGE,FAR *LPJOYRANGE;

typedef struct joyreguservalues_tag {
    DWORD       dwTimeOut;      /* value at which to timeout joystick polling */
    JOYRANGE    jrvRanges;      /* range of values app wants returned for axes */
    JOYPOS      jpDeadZone;     /* area around center to be considered
                                   as "dead". specified as a percentage
                                   (0-100). Only X & Y handled by system driver */
} JOYREGUSERVALUES, FAR *LPJOYREGUSERVALUES;

typedef struct joyreghwsettings_tag {
    DWORD       dwFlags;
    DWORD       dwNumButtons;           /* number of buttons */
} JOYREGHWSETTINGS, FAR *LPJOYHWSETTINGS;

/* range of values returned by the hardware (filled in by calibration) */
typedef struct joyreghwvalues_tag {
    JOYRANGE    jrvHardware;            /* values returned by hardware */
    DWORD       dwPOVValues[JOY_POV_NUMDIRS];/* POV values returned by hardware */
    DWORD       dwCalFlags;             /* what has been calibrated */
} JOYREGHWVALUES, FAR *LPJOYREGHWVALUES;

/* hardware configuration */
typedef struct joyreghwconfig_tag {
    JOYREGHWSETTINGS    hws;            /* hardware settings */
    DWORD               dwUsageSettings;/* usage settings */
    JOYREGHWVALUES      hwv;            /* values returned by hardware */
    DWORD               dwType;         /* type of joystick */
    DWORD               dwReserved;     /* reserved for OEM drivers */
} JOYREGHWCONFIG, FAR *LPJOYREGHWCONFIG;

// joystick calibration info structure
typedef struct joycalibrate_tag {
    WORD    wXbase;
    WORD    wXdelta;
    WORD    wYbase;
    WORD    wYdelta;
    WORD    wZbase;
    WORD    wZdelta;
} JOYCALIBRATE;
typedef JOYCALIBRATE FAR *LPJOYCALIBRATE;

// prototype for joystick message function
typedef DWORD (JOYDEVMSGPROC)(DWORD, UINT, LONG, LONG);
typedef JOYDEVMSGPROC FAR *LPJOYDEVMSGPROC;

// messages sent to joystick driver's DriverProc() function
#define JDD_GETNUMDEVS          (DRV_RESERVED + 0x0001)
#define JDD_GETDEVCAPS          (DRV_RESERVED + 0x0002)
#define JDD_GETPOS              (DRV_RESERVED + 0x0101)
#define JDD_SETCALIBRATION      (DRV_RESERVED + 0x0102)
#define JDD_CONFIGCHANGED       (DRV_RESERVED + 0x0103)
#define JDD_GETPOSEX            (DRV_RESERVED + 0x0104)

#endif // ifndef MMNOJOYDEV

#ifndef MAKELRESULT
#define MAKELRESULT(low, high)   ((LRESULT)MAKELONG(low, high))
#endif//MAKELRESULT


#ifndef MMNOMCIDEV
/****************************************************************************

                        MCI device driver support

****************************************************************************/


// internal MCI messages
#define MCI_OPEN_DRIVER             0x0801
#define MCI_CLOSE_DRIVER            0x0802

#define MAKEMCIRESOURCE(wRet, wRes) MAKELRESULT((wRet), (wRes))

// string return values only used with MAKEMCIRESOURCE
#define MCI_FALSE                       (MCI_STRING_OFFSET + 19)
#define MCI_TRUE                        (MCI_STRING_OFFSET + 20)

// resource string return values
#define MCI_FORMAT_RETURN_BASE          MCI_FORMAT_MILLISECONDS_S
#define MCI_FORMAT_MILLISECONDS_S       (MCI_STRING_OFFSET + 21)
#define MCI_FORMAT_HMS_S                (MCI_STRING_OFFSET + 22)
#define MCI_FORMAT_MSF_S                (MCI_STRING_OFFSET + 23)
#define MCI_FORMAT_FRAMES_S             (MCI_STRING_OFFSET + 24)
#define MCI_FORMAT_SMPTE_24_S           (MCI_STRING_OFFSET + 25)
#define MCI_FORMAT_SMPTE_25_S           (MCI_STRING_OFFSET + 26)
#define MCI_FORMAT_SMPTE_30_S           (MCI_STRING_OFFSET + 27)
#define MCI_FORMAT_SMPTE_30DROP_S       (MCI_STRING_OFFSET + 28)
#define MCI_FORMAT_BYTES_S              (MCI_STRING_OFFSET + 29)
#define MCI_FORMAT_SAMPLES_S            (MCI_STRING_OFFSET + 30)
#define MCI_FORMAT_TMSF_S               (MCI_STRING_OFFSET + 31)

#define MCI_VD_FORMAT_TRACK_S           (MCI_VD_OFFSET + 5)

#define WAVE_FORMAT_PCM_S               (MCI_WAVE_OFFSET + 0)
#define WAVE_MAPPER_S                   (MCI_WAVE_OFFSET + 1)

#define MCI_SEQ_MAPPER_S                (MCI_SEQ_OFFSET + 5)
#define MCI_SEQ_FILE_S                  (MCI_SEQ_OFFSET + 6)
#define MCI_SEQ_MIDI_S                  (MCI_SEQ_OFFSET + 7)
#define MCI_SEQ_SMPTE_S                 (MCI_SEQ_OFFSET + 8)
#define MCI_SEQ_FORMAT_SONGPTR_S        (MCI_SEQ_OFFSET + 9)
#define MCI_SEQ_NONE_S                  (MCI_SEQ_OFFSET + 10)
#define MIDIMAPPER_S                    (MCI_SEQ_OFFSET + 11)

#define MCI_TABLE_NOT_PRESENT   ((UINT)-1)
// parameters for internal version of MCI_OPEN message sent from
// mciOpenDevice() to the driver
typedef struct {
    MCIDEVICEID wDeviceID;             // device ID
    LPCWSTR     lpstrParams;           // parameter string for entry in SYSTEM.INI
    UINT        wCustomCommandTable;   // custom command table ((-1) if none)
                                       // filled in by the driver
    UINT        wType;                 // driver type
                                       // filled in by the driver
} MCI_OPEN_DRIVER_PARMS;
typedef MCI_OPEN_DRIVER_PARMS FAR * LPMCI_OPEN_DRIVER_PARMS;

// maximum length of an MCI device type
#define MCI_MAX_DEVICE_TYPE_LENGTH 80

// flags for mciSendCommandInternal() which direct mciSendString() how to
// interpret the return value
#define MCI_RESOURCE_RETURNED       0x00010000  // resource ID
#define MCI_COLONIZED3_RETURN       0x00020000  // colonized ID, 3 bytes data
#define MCI_COLONIZED4_RETURN       0x00040000  // colonized ID, 4 bytes data
#define MCI_INTEGER_RETURNED        0x00080000  // integer conversion needed
#define MCI_RESOURCE_DRIVER         0x00100000  // driver owns returned resource

// invalid command table ID
#define MCI_NO_COMMAND_TABLE    ((UINT)(-1))

// command table information type tags
#define MCI_COMMAND_HEAD        0
#define MCI_STRING              1
#define MCI_INTEGER             2
#define MCI_END_COMMAND         3
#define MCI_RETURN              4
#define MCI_FLAG                5
#define MCI_END_COMMAND_LIST    6
#define MCI_RECT                7
#define MCI_CONSTANT            8
#define MCI_END_CONSTANT        9
#define MCI_HWND               10
#define MCI_HPAL               11
#define MCI_HDC                12

// function prototypes for MCI driver functions
DWORD_PTR APIENTRY mciGetDriverData(MCIDEVICEID wDeviceID);
BOOL      APIENTRY mciSetDriverData(MCIDEVICEID wDeviceID, DWORD_PTR dwData);
UINT      APIENTRY mciDriverYield (MCIDEVICEID wDeviceID);
BOOL      APIENTRY mciDriverNotify (HANDLE hwndCallback, MCIDEVICEID wDeviceID,
    UINT uStatus);
UINT  APIENTRY mciLoadCommandResource(HANDLE hInstance,
    LPCWSTR lpResName, UINT wType);
BOOL  APIENTRY mciFreeCommandResource(UINT wTable);

#endif // ifndef MMNOMCIDEV


#ifndef MMNOTASKDEV
/*****************************************************************************

                               Task support

*****************************************************************************/

// error return values
#define TASKERR_NOTASKSUPPORT 1
#define TASKERR_OUTOFMEMORY   2

// task support function prototypes
#ifdef  BUILDDLL                                            /* ;Internal */
typedef VOID (FAR PASCAL TASKCALLBACK) (DWORD_PTR dwInst);  /* ;Internal */
#else                                                       /* ;Internal */
typedef VOID (TASKCALLBACK) (DWORD_PTR dwInst);
#endif  // ifdef BUILDDLL                                   /* ;Internal */

typedef TASKCALLBACK FAR *LPTASKCALLBACK;

UINT    APIENTRY mmTaskCreate(LPTASKCALLBACK lpfn, HANDLE FAR * lph, DWORD_PTR dwInst);
VOID    APIENTRY mmTaskBlock(DWORD h);
BOOL    APIENTRY mmTaskSignal(DWORD h);
VOID    APIENTRY mmTaskYield(VOID);
DWORD   APIENTRY mmGetCurrentTask(VOID);

#endif // endif MMNOTASKDEV

#define MMDDKINC

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#include "poppack.h"        /* Revert to default packing */

#endif /* _INC_MMDDK */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\wmdm\idl\wmdm.c ===
const CLSID CLSID_MediaDevMgr = {0x25BAAD81,0x3560,0x11D3,{0x84,0x71,0x00,0xC0,0x4F,0x79,0xDB,0xC0}};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\media\mmdet.h ===
/*++

    Copyright (c) 1997 Microsoft Corporation

Module Name:

    mmdet.h

Abstract:
    MM detection module header, borrowed from KyleB's net detection base

Author:

    bryanw 18-Oct-1997

--*/


#ifndef _MMDET_H_
#define _MMDET_H_

#define DEVIDSTR_SB                 TEXT( "*PNPb000" ) // Sound Blaster wave
#define DEVIDSTR_SB2                TEXT( "*PNPb001" ) // Sound Blaster 2 wave
#define DEVIDSTR_SBPRO              TEXT( "*PNPb002" ) // Sound Blaster Pro wave
#define DEVIDSTR_SB16               TEXT( "*PNPb003" ) // Sound Blaster 16 wave
#define DEVIDSTR_MV                 TEXT( "*PNPb004" ) // Media Vision Thunder Board
#define DEVIDSTR_ADLIB              TEXT( "*PNPb005" ) // Adlib
#define DEVIDSTR_MPU401             TEXT( "*PNPb006" ) // MPU-401 midi
#define DEVIDSTR_SNDSYS             TEXT( "*PNPb007" ) // Windows Sound System
#define DEVIDSTR_CPQBA              TEXT( "*PNPb008" ) // Compaq Business Audio
                                                     
#define DEVIDSTR_PAS16              TEXT( "*PNPb00d" ) // PAS-16 variations
#define DEVIDSTR_PAS16_WITH_SCSI    TEXT( "*PNPb00e" ) // PAS-16 + SCSI
#define DEVIDSTR_PAS_ORIGINAL       TEXT( "*PNPb018" ) // MV Pro Audio Spectrum (original)
#define DEVIDSTR_PAS_PLUS           TEXT( "*PNPb019" ) // PAS Plus variations

#define DEVIDSTR_OPTI82C928         TEXT( "*PNPb01a" )
#define DEVIDSTR_OPTI82C929         TEXT( "*PNPb01b" )
#define DEVIDSTR_OPTI82C930         TEXT( "*PNPb01c" )
                                                     
#define DEVIDSTR_PA3D               TEXT( "*PNPb00b" ) // Media Vision ProAudio3D
#define DEVIDSTR_MQMPU401           TEXT( "*PNPb00c" ) // MusicQuest MPU-401 midi
#define DEVIDSTR_JAZZ               TEXT( "*PNPb00f" ) // Media Vision OEM Jazz-16
#define DEVIDSTR_VXP500             TEXT( "*PNPb010" ) // Auravision VxP500 based video cap.
#define DEVIDSTR_ADLIBOPL3          TEXT( "*PNPb020" ) // Adlib OPL3 midi
#define DEVIDSTR_GAMEPORT           TEXT( "*PNPb02f" ) // Game port

#define DEVIDSTR_AZTECH_PRO16           TEXT( "*AZT1608" )
#define DEVIDSTR_AZTECH_NOVA16          TEXT( "*AZT1605" )
#define DEVIDSTR_AZTECH_WASHINGTON16    TEXT( "*AZT2316" )
                                                        
#define DEVIDSTR_ESS4881                TEXT( "*ESS4881" )
#define DEVIDSTR_ESS6881                TEXT( "*ESS6881" )
#define DEVIDSTR_ESS1481                TEXT( "*ESS1481" )
#define DEVIDSTR_ESS1681                TEXT( "*ESS1681" )
#define DEVIDSTR_ESS1781                TEXT( "*ESS1781" )
#define DEVIDSTR_ESS1881                TEXT( "*ESS1881" )

ULONG
WINAPI
MmDetectAdapters(
    IN HDEVINFO DeviceInfoSet,
    IN DI_FUNCTION InstallFunction
    );
    
typedef
ULONG
(*PFNMMDETECTADAPTERS)(
    IN HDEVINFO DeviceInfoSet,
    IN DI_FUNCTION InstallFunction
    );

#if (!defined( _NTDDK_ ) && !defined( NT_INCLUDED ))
typedef ULONG INTERFACE_TYPE,*PINTERFACE_TYPE;
#endif
typedef
VOID 
(*PFNMMDETECTIRQCALLBACK)(
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG BusNumber,
    IN ULONG Context
    );

USHORT
WINAPI
MmDetectIRQ( 
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG BusNumber,
    IN USHORT InterruptMask,
    IN PFNMMDETECTIRQCALLBACK SetInterrupt,
    IN PFNMMDETECTIRQCALLBACK ClearInterrupt,
    IN ULONG Context 
    );
    
#if (defined( _CFGMGR32_H_ ))
ULONG
WINAPI
MmRegisterDetectedDevice( 
    IN HDEVINFO DeviceInfoSet,
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG BusNumber,
    IN PTSTR DeviceId,
    IN PMEM_RESOURCE MemResources,
    IN int MemResourceCount,
    IN PIO_RESOURCE IoResources,
    IN int IoResourceCount,
    IN PIRQ_RESOURCE IrqResources,
    IN int IrqResourceCount,
    IN PDMA_RESOURCE DmaResources,
    IN int DmaResourceCount
    );
    
VOID
WINAPI    
MmAvoidDetectedResources( 
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG BusNumber,
    IN PMEM_RESOURCE MemResources,
    IN int MemResourceCount,
    IN PIO_RESOURCE IoResources,
    IN int IoResourceCount,
    IN PIRQ_RESOURCE IrqResources,
    IN int IrqResourceCount,
    IN PDMA_RESOURCE DmaResources,
    IN int DmaResourceCount
    );
    
#endif    

#endif // _MMDET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\media\mmcommon.h ===
/***************************************************************************
 *  mmcommon.h
 *
 *  Copyright (c) Microsoft Corporation 1996. All rights reserved
 *
 *  private include file for definitions common to the NT project
 *
 *  History
 *
 *  16  Feb 96 - NoelC created
 *
 ***************************************************************************/

/***************************************************************************


 Common definitions needed for wx86


 ***************************************************************************/

#define WOD_MESSAGE          "wodMessage"
#define WID_MESSAGE          "widMessage"
#define MOD_MESSAGE          "modMessage"
#define MID_MESSAGE          "midMessage"
#define AUX_MESSAGE          "auxMessage"


#define MMDRVI_TYPE          0x000F  /* low 4 bits give driver type */
#define MMDRVI_WAVEIN        0x0001
#define MMDRVI_WAVEOUT       0x0002
#define MMDRVI_MIDIIN        0x0003
#define MMDRVI_MIDIOUT       0x0004
#define MMDRVI_AUX           0x0005
#define MMDRVI_MIDISTRM      0x0006

#define MMDRVI_MAPPER        0x8000  /* install this driver as the mapper */
#define MMDRVI_HDRV          0x4000  /* hDriver is a installable driver   */
#define MMDRVI_REMOVE        0x2000  /* remove the driver                 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\media\synth.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects


Copyright (c) 1992  Microsoft Corporation

Module Name:

    synth.h

Abstract:

    This include file defines constants and types for
    the Microsoft midi synthesizer driver

    This header file is shared between the low level driver and the
    kernel mode driver.

Author:

    Robin Speed (RobinSp) 20-Oct-92

Revision History:

--*/

#define STR_DRIVERNAME L"synth"
#define STR_MV_DRIVERNAME L"mvopl3"
#define STR_OPL3_DEVICENAME L"\\Device\\opl3.mid"
#define STR_ADLIB_DEVICENAME L"\\Device\\adlib.mid"

/*
 *  Stucture for passing synth data
 *  Why on earth isn't there a type for sharing short data?
 */

 typedef struct {
     unsigned short IoPort;
     unsigned short PortData;
 } SYNTH_DATA, *PSYNTH_DATA;

/* positions within FM */
#define AD_LSI                          (0x000)
#define AD_LSI2                         (0x101)
#define AD_TIMER1                       (0x001)
#define AD_TIMER2                       (0x002)
#define AD_MASK                         (0x004)
#define AD_CONNECTION                   (0x104)
#define AD_NEW                          (0x105)
#define AD_NTS                          (0x008)
#define AD_MULT                         (0x020)
#define AD_MULT2                        (0x120)
#define AD_LEVEL                        (0x040)
#define AD_LEVEL2                       (0x140)
#define AD_AD                           (0x060)
#define AD_AD2                          (0x160)
#define AD_SR                           (0x080)
#define AD_SR2                          (0x180)
#define AD_FNUMBER                      (0x0a0)
#define AD_FNUMBER2                     (0x1a0)
#define AD_BLOCK                        (0x0b0)
#define AD_BLOCK2                       (0x1b0)
#define AD_DRUM                         (0x0bd)
#define AD_FEEDBACK                     (0x0c0)
#define AD_FEEDBACK2                    (0x1c0)
#define AD_WAVE                         (0x0e0)
#define AD_WAVE2                        (0x1e0)

/*
**  Special IOCTL
*/

#define IOCTL_MIDI_SET_OPL3_MODE CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x000A, METHOD_BUFFERED, FILE_WRITE_ACCESS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\wmdm\idl\wmdm.h ===
EXTERN_C const CLSID CLSID_MediaDevMgr;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\media\soundcfg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects


Copyright (c) 1990  Microsoft Corporation

Module Name:

    soundcfg.h

Abstract:

    This include file defines common strings and values for sound driver
	configuration.

Author:

    Robin Speed (RobinSp) 17-Oct-92

Revision History:
--*/

#define SOUND_REG_PORT (L"Port")
#define SOUND_REG_DMACHANNEL (L"DmaChannel")
#define SOUND_REG_INTERRUPT (L"Interrupt")
#define SOUND_REG_INPUTSOURCE (L"Input Source")
#define SOUND_REG_DMABUFFERSIZE (L"Dma Buffer Size")
#define SOUND_REG_CONFIGERROR (L"Configuration Error")
#define SOUND_REG_LOADTYPE (L"Load Type")
#define SOUND_REG_PNPDEVICE (L"PnP Device")

    //
    //  Values for Load Type
    //

    #define SOUND_LOADTYPE_NORMAL  0x00
    #define SOUND_LOADTYPE_CONFIG  0x01  // Fail load but return config data

#define SOUND_REG_SYNTH_TYPE (L"Synth Type")

    //
    //  Values for synth type
    //

    #define SOUND_SYNTH_TYPE_ADLIB  0x01
    #define SOUND_SYNTH_TYPE_OPL3   0x02
    #define SOUND_SYNTH_TYPE_NONE   0x03

#define SOUND_MIXER_SETTINGS_NAME (L"Mixer Settings")


//
// Errors
//

#define SOUND_CONFIG_ERROR      0x00000000
#define SOUND_CONFIG_OK         0xFFFFFFFF
#define SOUND_CONFIG_NOCARD     0x00000001
#define SOUND_CONFIG_BADINT     0x00000002
#define SOUND_CONFIG_BADDMA     0x00000003
#define SOUND_CONFIG_BADCARD    0x00000004
#define SOUND_CONFIG_RESOURCE   0x00000005

#define SOUND_CONFIG_BADPORT    0x00000006
#define SOUND_CONFIG_PORT_INUSE 0x00000007
#define SOUND_CONFIG_DMA_INUSE  0x00000008
#define SOUND_CONFIG_INT_INUSE  0x00000009

#define SOUND_CONFIG_NOINT      0x0000000A
#define SOUND_CONFIG_NODMA      0x0000000B


#define PARMS_SUBKEY                  L"Parameters"
#define SOUND_DEVICES_SUBKEY          L"Devices"
#define SOUND_DRIVER_PARMS            L"DriverParameters"

#define REG_VALUENAME_LEFTMASTER      L"LeftMasterVolumeAtten"
#define REG_VALUENAME_RIGHTMASTER     L"RightMasterVolumeAtten"
#define REG_VALUENAME_LEFTLINEIN      L"LeftLineInAtten"
#define REG_VALUENAME_RIGHTLINEIN     L"RightLineInAtten"
#define REG_VALUENAME_LEFTDAC         L"LeftDACAtten"
#define REG_VALUENAME_RIGHTDAC        L"RightDACAtten"
#define REG_VALUENAME_LEFTMICMIX      L"LeftMicMixAtten"
#define REG_VALUENAME_RIGHTMICMIX     L"RightMicMixAtten"
#define REG_VALUENAME_LEFTADC         L"LeftADCAtten"
#define REG_VALUENAME_RIGHTADC        L"RightADCAtten"
#define REG_VALUENAME_LEFTSYNTH       L"LeftSynthAtten"
#define REG_VALUENAME_RIGHTSYNTH      L"RightSynthAtten"


//
// Input source selection
//

#define INPUT_LINEIN            0
#define INPUT_AUX               1
#define INPUT_MIC               2
#define INPUT_OUTPUT            3

//
// Default volume settings on initial install
//

#define DEF_ADC_VOLUME    0x24000000
#define DEF_DAC_VOLUME    0x24000000
#define DEF_SYNTH_VOLUME  0x24000000
#define DEF_AUX_VOLUME    0x24000000
#define DEF_MICMIX_VOLUME 0x00000000

/****************************************************************************

 Device Types

 ***************************************************************************/

//
// Device type flags used in the local info structure
//

#define WAVE_IN             0x01    // Wave in device
#define WAVE_OUT            0x02    // Wave out device
#define MIDI_IN             0x03    // Midi in device
#define MIDI_OUT            0x04    // Midi out device
#define AUX_DEVICE          0x05    // aux device
#define MIXER_DEVICE        0x06    // Mixer device
#define SYNTH_DEVICE        0x07    // Synth device (adlib or opl3)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\wmsdk\inc\asferr.h ===
///////////////////////////////////////////////////////////////////////////
//
// ASFErr.h - definition of ASF HRESULT codes
//
//  Microsoft Windows Media Technology
//  Copyright (C) Microsoft Corporation, 1999 - 2001.  All Rights Reserved.
//
// This file is generated by the MC tool from ASFErr.mc
//

#ifndef _ASFERR_H
#define _ASFERR_H


#define STATUS_SEVERITY(hr)  (((hr) >> 30) & 0x3)


///////////////////////////////////////////////////////////////////////////
//
// Advanced Streaming Format (ASF) Errors (2000 - 2999)
//
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_NS                      0xD


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: ASF_E_BUFFEROVERRUN
//
// MessageText:
//
//  An attempt was made to seek or position past the end of a buffer.%0
//
#define ASF_E_BUFFEROVERRUN              0xC00D07D0L

//
// MessageId: ASF_E_BUFFERTOOSMALL
//
// MessageText:
//
//  The supplied input or output buffer was too small.%0
//
#define ASF_E_BUFFERTOOSMALL             0xC00D07D1L

//
// MessageId: ASF_E_BADLANGUAGEID
//
// MessageText:
//
//  The language ID was not found.%0
//
#define ASF_E_BADLANGUAGEID              0xC00D07D2L

//
// MessageId: ASF_E_NOPAYLOADLENGTH
//
// MessageText:
//
//  The multiple payload packet is missing the payload length.%0
//
#define ASF_E_NOPAYLOADLENGTH            0xC00D07DBL

//
// MessageId: ASF_E_TOOMANYPAYLOADS
//
// MessageText:
//
//  The packet contains too many payloads.%0
//
#define ASF_E_TOOMANYPAYLOADS            0xC00D07DCL

//
// MessageId: ASF_E_PACKETCONTENTTOOLARGE
//
// MessageText:
//
//  ASF_E_PACKETCONTENTTOOLARGE
//
#define ASF_E_PACKETCONTENTTOOLARGE      0xC00D07DEL

//
// MessageId: ASF_E_UNKNOWNPACKETSIZE
//
// MessageText:
//
//  Expecting a fixed packet size but min. and max. are not equal.%0
//
#define ASF_E_UNKNOWNPACKETSIZE          0xC00D07E0L

//
// MessageId: ASF_E_INVALIDHEADER
//
// MessageText:
//
//  ASF_E_INVALIDHEADER
//
#define ASF_E_INVALIDHEADER              0xC00D07E2L

//
// MessageId: ASF_E_NOCLOCKOBJECT
//
// MessageText:
//
//  The object does not have a valid clock object.%0
//
#define ASF_E_NOCLOCKOBJECT              0xC00D07E6L

//
// MessageId: ASF_E_UNKNOWNCLOCKTYPE
//
// MessageText:
//
//  ASF_E_UNKNOWNCLOCKTYPE
//
#define ASF_E_UNKNOWNCLOCKTYPE           0xC00D07EBL

//
// MessageId: ASF_E_OPAQUEPACKET
//
// MessageText:
//
//  An attempt was made to restore or access an opaque packet.%0
//
#define ASF_E_OPAQUEPACKET               0xC00D07EDL

//
// MessageId: ASF_E_WRONGVERSION
//
// MessageText:
//
//  ASF_E_WRONGVERSION
//
#define ASF_E_WRONGVERSION               0xC00D07EEL

//
// MessageId: ASF_E_OVERFLOW
//
// MessageText:
//
//  An attempt was made to store a value which was larger than then destination's maximum value.%0
//
#define ASF_E_OVERFLOW                   0xC00D07EFL

//
// MessageId: ASF_E_NOTFOUND
//
// MessageText:
//
//  The object was not found.%0
//
#define ASF_E_NOTFOUND                   0xC00D07F0L

//
// Someone else is using MessageIds 2033 & 2034, so we skip them
// 
// 2033 = NS_E_NOTHING_TO_DO
// 2034 = NS_E_NO_MULTICAST

//
// MessageId: ASF_E_OBJECTTOOBIG
//
// MessageText:
//
//  The object is too large to be processed in the requested manner.%0
//
#define ASF_E_OBJECTTOOBIG               0xC00D07F3L

//
// MessageId: ASF_E_UNEXPECTEDVALUE
//
// MessageText:
//
//  A value was not set as expected.%0
//
#define ASF_E_UNEXPECTEDVALUE            0xC00D07F4L

//
// MessageId: ASF_E_INVALIDSTATE
//
// MessageText:
//
//  The request is not valid in the object's current state.%0
//
#define ASF_E_INVALIDSTATE               0xC00D07F5L

//
// MessageId: ASF_E_NOLIBRARY
//
// MessageText:
//
//  This object does not have a valid library pointer; it was not properly created or it has been Shutdown().%0
//
#define ASF_E_NOLIBRARY                  0xC00D07F6L

//
// MessageId: ASF_E_ALREADYINITIALIZED
//
// MessageText:
//
//  This object has already been initialized; the setting cannot be changed.%0
//
#define ASF_E_ALREADYINITIALIZED         0xC00D07F7L

//
// MessageId: ASF_E_INVALIDINIT
//
// MessageText:
//
//  This object has not been initialized properly; that operation cannot be performed.%0
//
#define ASF_E_INVALIDINIT                0xC00D07F8L

//
// MessageId: ASF_E_NOHEADEROBJECT
//
// MessageText:
//
//  The ASF Header object could not be found.%0
//
#define ASF_E_NOHEADEROBJECT             0xC00D07F9L

//
// MessageId: ASF_E_NODATAOBJECT
//
// MessageText:
//
//  The ASF Data object could not be found.%0
//
#define ASF_E_NODATAOBJECT               0xC00D07FAL

//
// MessageId: ASF_E_NOINDEXOBJECT
//
// MessageText:
//
//  The ASF Index object could not be found.%0
//
#define ASF_E_NOINDEXOBJECT              0xC00D07FBL

//
// MessageId: ASF_E_NOSTREAMPROPS
//
// MessageText:
//
//  A Stream Properties object with the correct stream number could not be found.%0
//
#define ASF_E_NOSTREAMPROPS              0xC00D07FCL

//
// MessageId: ASF_E_NOFILEPROPS
//
// MessageText:
//
//  The File Properties object could not be found.%0
//
#define ASF_E_NOFILEPROPS                0xC00D07FDL

//
// MessageId: ASF_E_NOLANGUAGELIST
//
// MessageText:
//
//  The Language List object could not be found.%0
//
#define ASF_E_NOLANGUAGELIST             0xC00D07FEL

//
// MessageId: ASF_E_NOINDEXPARAMETERS
//
// MessageText:
//
//  The Index Parameters object could not be found.%0
//
#define ASF_E_NOINDEXPARAMETERS          0xC00D07FFL

//
// MessageId: ASF_E_UNSUPPORTEDERRORCONCEALMENT
//
// MessageText:
//
//  The requested error concealment strategy is not supported by this component.%0
//
#define ASF_E_UNSUPPORTEDERRORCONCEALMENT 0xC00D0800L

//
// MessageId: ASF_E_INVALIDFLAGS
//
// MessageText:
//
//  The flags for this object or set of objects are not properly set.%0
//
#define ASF_E_INVALIDFLAGS               0xC00D0801L

//
// MessageId: ASF_E_BADDATADESCRIPTOR
//
// MessageText:
//
//  One or more data descriptors is not properly set.%0
//
#define ASF_E_BADDATADESCRIPTOR          0xC00D0802L

//
// MessageId: ASF_E_BADINDEXTIMEINTERVAL
//
// MessageText:
//
//  The index has an invalid time interval (probably zero).%0
//
#define ASF_E_BADINDEXTIMEINTERVAL       0xC00D0803L

//
// MessageId: ASF_E_INVALIDTIME
//
// MessageText:
//
//  The given time value is not valid.%0
//
#define ASF_E_INVALIDTIME                0xC00D0804L

//
// MessageId: ASF_E_INVALIDINDEX
//
// MessageText:
//
//  The given index value is not valid.%0
//
#define ASF_E_INVALIDINDEX               0xC00D0805L

//
// MessageId: ASF_E_STREAMNUMBERINUSE
//
// MessageText:
//
//  The specified stream number is already in use.%0
//
#define ASF_E_STREAMNUMBERINUSE          0xC00D0806L

//
// MessageId: ASF_E_BADMEDIATYPE
//
// MessageText:
//
//  The specified media type does not work with this component.%0
//
#define ASF_E_BADMEDIATYPE               0xC00D0807L

//
// MessageId: ASF_E_WRITEFAILED
//
// MessageText:
//
//  The object could not be written as specified.%0
//
#define ASF_E_WRITEFAILED                0xC00D0808L

//
// MessageId: ASF_E_NOTENOUGHDESCRIPTORS
//
// MessageText:
//
//  The given data unit requires a larger number of descriptors to be fully parsed.%0
//
#define ASF_E_NOTENOUGHDESCRIPTORS       0xC00D0809L

//
// MessageId: ASF_E_INDEXBLOCKUNLOADED
//
// MessageText:
//
//  The index entries for the specified index block have been unloaded from memory and are not available.%0
//
#define ASF_E_INDEXBLOCKUNLOADED         0xC00D080AL

//
// MessageId: ASF_E_NOTENOUGHBANDWIDTH
//
// MessageText:
//
//  The specified bandwidth is not large enough.%0
//
#define ASF_E_NOTENOUGHBANDWIDTH         0xC00D080BL

//
// MessageId: ASF_E_EXCEEDEDMAXIMUMOBJECTSIZE
//
// MessageText:
//
//  The object has exceeded its maximum size.%0
//
#define ASF_E_EXCEEDEDMAXIMUMOBJECTSIZE  0xC00D080CL

//
// MessageId: ASF_E_BADDATAUNIT
//
// MessageText:
//
//  The given data unit is corrupted, badly formatted, or otherwise not valid.%0
//
#define ASF_E_BADDATAUNIT                0xC00D080DL

//
// MessageId: ASF_E_HEADERSIZE
//
// MessageText:
//
//  The ASF header has exceeded the specified maximum size.%0
//
#define ASF_E_HEADERSIZE                 0xC00D080EL


///////////////////////////////////////////////////////////////////////////
//
// Advanced Streaming Format (ASF) Success Codes (2000 - 2999)
//

//
// MessageId: ASF_S_OPAQUEPACKET
//
// MessageText:
//
//  ASF_S_OPAQUEPACKET
//
#define ASF_S_OPAQUEPACKET               0x000D07F0L


///////////////////////////////////////////////////////////////////////////
//
// Advanced Streaming Format (ASF) Warnings (2000 - 2999)
//


#endif // _ASFERR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\wmsdk\inc\cleandrm.h ===
//////////////////////////////////////////////////////////////////////
//
// CleanDRM.h
//
//////////////////////////////////////////////////////////////////////

#ifndef _CLEANDRM_H_
#define _CLEANDRM_H_

#ifdef  __cplusplus
extern "C" {
#endif  


/////////////////////////////////////////////////////////////////////
//
// CleanDRM
//
// szLogFile: Full path to file to log information to.
//            Set to NULL to not log any information.
//
HRESULT __stdcall CleanDRM( LPCSTR szLogFile );


#ifdef  __cplusplus
}
#endif  

#endif // _CLEANDRM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\wmsdk\inc\key.c ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

//
// Note: This certificate is only meant to allow the project to compile.
// To interact with the WMDM, you need to obtain a valid certificate from Microsoft.
//

#include <wtypes.h>

BYTE abPVK[] = {
        0x00
};
BYTE abCert[] = {
        0x00
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\wmsdk\inc\des.h ===
//-----------------------------------------------------------------------------
//
// File:   des.h
//
// Microsoft Digital Rights Management
// Copyright (C) Microsoft Corporation, 1999-2001. All Rights Reserved
//
// Description:
//
//-----------------------------------------------------------------------------

#ifndef __DES_H__
#define __DES_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _destable {
    unsigned long   keytab[16][2];
} DESTable;

#define DES_TABLESIZE   (sizeof(DESTable))
#define DES_BLOCKLEN    (8)
#define DES_KEYSIZE     (8)

typedef struct _desxtable {
    unsigned char inWhitening[8];
    unsigned char outWhitening[8];
    DESTable desTable;
} DESXTable;

#define DESX_TABLESIZE  (sizeof(DESXTable))
#define DESX_BLOCKLEN   (8)
#define DESX_KEYSIZE    (24)

/* In deskey.c:

     Fill in the DESTable struct with the decrypt and encrypt
     key expansions.

     Assumes that the second parameter points to DES_BLOCKLEN
     bytes of key.

*/

void RSA32API deskey(DESTable *,unsigned char *);

/* In desport.c:

     Encrypt or decrypt with the key in DESTable

*/

void RSA32API des(BYTE *pbOut, BYTE *pbIn, void *key, int op);

//
// set the parity on the DES key to be odd
// NOTE : must be called before deskey
// key must be cbKey number of bytes
//
void RSA32API desparityonkey(BYTE *pbKey, DWORD cbKey);

//
// reduce the DES key to a 40 bit key
// NOTE : must be called before deskey
// key must be 8 bytes
//
void RSA32API desreducekey(BYTE *key);

// Expand 40 bit DES key to 64 and check weakness
// same as desreducekey except expands instead of weakening keys
void RSA32API deskeyexpand(BYTE *pbKey, BYTE *pbExpanded_key);


void
RSA32API
desexpand128to192(
    BYTE *pbKey,        // input 128bit or 192bit buffer
    BYTE *pbExpandedKey // output buffer (must be 192bit wide if pbKey == pbExpandedKey
    );

// DES-X routines

// initialize desX key struct.  key size is 24 bytes
void RSA32API desxkey(DESXTable *k, BYTE *key);

void RSA32API desx(BYTE *pbOut, BYTE *pbIn, void *keyin, int op);


extern int Asmversion;  /* 1 if we're linked with an asm version, 0 if C */

#ifdef __cplusplus
}
#endif

#endif // __DES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\wmsdk\inc\key.h ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

#include <wtypes.h>

extern BYTE abPVK[];
extern BYTE abCert[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\wmsdk\inc\drmexternals.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Wed Aug 08 01:15:17 2001
 */
/* Compiler settings for .\drmexternals.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __drmexternals_h__
#define __drmexternals_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IDRMStatusCallback_FWD_DEFINED__
#define __IDRMStatusCallback_FWD_DEFINED__
typedef interface IDRMStatusCallback IDRMStatusCallback;
#endif 	/* __IDRMStatusCallback_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_drmexternals_0000 */
/* [local] */ 

static const WCHAR *g_wszWMDRM_RIGHT_PLAYBACK                = L"Play";
static const WCHAR *g_wszWMDRM_RIGHT_COPY_TO_CD              = L"Print.redbook";
static const WCHAR *g_wszWMDRM_RIGHT_COPY_TO_SDMI_DEVICE     = L"Transfer.SDMI";
static const WCHAR *g_wszWMDRM_RIGHT_COPY_TO_NON_SDMI_DEVICE = L"Transfer.NONSDMI";
static const WCHAR *g_wszWMDRM_RIGHT_BACKUP                  = L"Backup";
static const WCHAR *g_wszWMDRM_ActionAllowed                = L"ActionAllowed.";
static const WCHAR *g_wszWMDRM_LicenseState                 = L"LicenseStateData.";
static const WCHAR *g_wszWMDRM_DRMHeader                    = L"DRMHeader.";
static const WCHAR *g_wszWMDRM_IsDRM                             = L"IsDRM";
static const WCHAR *g_wszWMDRM_IsDRMCached                       = L"IsDRMCached";
static const WCHAR *g_wszWMDRM_ActionAllowed_Playback            = L"ActionAllowed.Play";
static const WCHAR *g_wszWMDRM_ActionAllowed_CopyToCD            = L"ActionAllowed.Print.redbook";
static const WCHAR *g_wszWMDRM_ActionAllowed_CopyToSDMIDevice    = L"ActionAllowed.Transfer.SDMI";
static const WCHAR *g_wszWMDRM_ActionAllowed_CopyToNonSDMIDevice = L"ActionAllowed.Transfer.NONSDMI";
static const WCHAR *g_wszWMDRM_ActionAllowed_Backup              = L"ActionAllowed.Backup";
static const WCHAR *g_wszWMDRM_LicenseState_Playback             = L"LicenseStateData.Play";
static const WCHAR *g_wszWMDRM_LicenseState_CopyToCD             = L"LicenseStateData.Print.redbook";
static const WCHAR *g_wszWMDRM_LicenseState_CopyToSDMIDevice     = L"LicenseStateData.Transfer.SDMI";
static const WCHAR *g_wszWMDRM_LicenseState_CopyToNonSDMIDevice  = L"LicenseStateData.Transfer.NONSDMI";
typedef 
enum DRM_LICENSE_STATE_CATEGORY
    {	WM_DRM_LICENSE_STATE_NORIGHT	= 0,
	WM_DRM_LICENSE_STATE_UNLIM	= WM_DRM_LICENSE_STATE_NORIGHT + 1,
	WM_DRM_LICENSE_STATE_COUNT	= WM_DRM_LICENSE_STATE_UNLIM + 1,
	WM_DRM_LICENSE_STATE_FROM	= WM_DRM_LICENSE_STATE_COUNT + 1,
	WM_DRM_LICENSE_STATE_UNTIL	= WM_DRM_LICENSE_STATE_FROM + 1,
	WM_DRM_LICENSE_STATE_FROM_UNTIL	= WM_DRM_LICENSE_STATE_UNTIL + 1,
	WM_DRM_LICENSE_STATE_COUNT_FROM	= WM_DRM_LICENSE_STATE_FROM_UNTIL + 1,
	WM_DRM_LICENSE_STATE_COUNT_UNTIL	= WM_DRM_LICENSE_STATE_COUNT_FROM + 1,
	WM_DRM_LICENSE_STATE_COUNT_FROM_UNTIL	= WM_DRM_LICENSE_STATE_COUNT_UNTIL + 1,
	WM_DRM_LICENSE_STATE_EXPIRATION_AFTER_FIRSTUSE	= WM_DRM_LICENSE_STATE_COUNT_FROM_UNTIL + 1
    }	DRM_LICENSE_STATE_CATEGORY;

typedef struct  _DRM_LICENSE_STATE_DATA
    {
    DWORD dwStreamId;
    DRM_LICENSE_STATE_CATEGORY dwCategory;
    DWORD dwNumCounts;
    DWORD dwCount[ 4 ];
    DWORD dwNumDates;
    FILETIME datetime[ 4 ];
    DWORD dwVague;
    }	DRM_LICENSE_STATE_DATA;

typedef 
enum DRM_HTTP_STATUS
    {	HTTP_NOTINITIATED	= 0,
	HTTP_CONNECTING	= HTTP_NOTINITIATED + 1,
	HTTP_REQUESTING	= HTTP_CONNECTING + 1,
	HTTP_RECEIVING	= HTTP_REQUESTING + 1,
	HTTP_COMPLETED	= HTTP_RECEIVING + 1
    }	DRM_HTTP_STATUS;

typedef 
enum DRM_INDIVIDUALIZATION_STATUS
    {	INDI_UNDEFINED	= 0,
	INDI_BEGIN	= 0x1,
	INDI_SUCCEED	= 0x2,
	INDI_FAIL	= 0x4,
	INDI_CANCEL	= 0x8,
	INDI_DOWNLOAD	= 0x10,
	INDI_INSTALL	= 0x20
    }	DRM_INDIVIDUALIZATION_STATUS;

typedef struct  _WMIndividualizeStatus
    {
    HRESULT hr;
    DRM_INDIVIDUALIZATION_STATUS enIndiStatus;
    LPSTR pszIndiRespUrl;
    DWORD dwHTTPRequest;
    DRM_HTTP_STATUS enHTTPStatus;
    DWORD dwHTTPReadProgress;
    DWORD dwHTTPReadTotal;
    }	WM_INDIVIDUALIZE_STATUS;

typedef struct  _WMGetLicenseData
    {
    DWORD dwSize;
    HRESULT hr;
    WCHAR __RPC_FAR *wszURL;
    WCHAR __RPC_FAR *wszLocalFilename;
    BYTE __RPC_FAR *pbPostData;
    DWORD dwPostDataSize;
    }	WM_GET_LICENSE_DATA;

typedef 
enum MSDRM_STATUS
    {	DRM_ERROR	= 0,
	DRM_INFORMATION	= 1,
	DRM_BACKUPRESTORE_BEGIN	= 2,
	DRM_BACKUPRESTORE_END	= 3,
	DRM_BACKUPRESTORE_CONNECTING	= 4,
	DRM_BACKUPRESTORE_DISCONNECTING	= 5,
	DRM_ERROR_WITHURL	= 6,
	DRM_RESTRICTED_LICENSE	= 7,
	DRM_NEEDS_INDIVIDUALIZATION	= 8
    }	MSDRM_STATUS;

typedef 
enum DRM_ATTR_DATATYPE
    {	DRM_TYPE_DWORD	= 0,
	DRM_TYPE_STRING	= 1,
	DRM_TYPE_BINARY	= 2,
	DRM_TYPE_BOOL	= 3,
	DRM_TYPE_QWORD	= 4,
	DRM_TYPE_WORD	= 5,
	DRM_TYPE_GUID	= 6
    }	DRM_ATTR_DATATYPE;


#define DRM_BACKUP_OVERWRITE         ((DWORD) 0x00000001)
#define DRM_RESTORE_INDIVIDUALIZE    ((DWORD) 0x00000002)


extern RPC_IF_HANDLE __MIDL_itf_drmexternals_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_drmexternals_0000_v0_0_s_ifspec;

#ifndef __IDRMStatusCallback_INTERFACE_DEFINED__
#define __IDRMStatusCallback_INTERFACE_DEFINED__

/* interface IDRMStatusCallback */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDRMStatusCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("08548704-75B1-4982-9B26-FB385DEE741D")
    IDRMStatusCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnStatus( 
            /* [in] */ MSDRM_STATUS Status,
            /* [in] */ HRESULT hr,
            /* [in] */ DRM_ATTR_DATATYPE dwType,
            /* [in] */ BYTE __RPC_FAR *pValue,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDRMStatusCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDRMStatusCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDRMStatusCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDRMStatusCallback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStatus )( 
            IDRMStatusCallback __RPC_FAR * This,
            /* [in] */ MSDRM_STATUS Status,
            /* [in] */ HRESULT hr,
            /* [in] */ DRM_ATTR_DATATYPE dwType,
            /* [in] */ BYTE __RPC_FAR *pValue,
            /* [in] */ void __RPC_FAR *pvContext);
        
        END_INTERFACE
    } IDRMStatusCallbackVtbl;

    interface IDRMStatusCallback
    {
        CONST_VTBL struct IDRMStatusCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDRMStatusCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDRMStatusCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDRMStatusCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDRMStatusCallback_OnStatus(This,Status,hr,dwType,pValue,pvContext)	\
    (This)->lpVtbl -> OnStatus(This,Status,hr,dwType,pValue,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDRMStatusCallback_OnStatus_Proxy( 
    IDRMStatusCallback __RPC_FAR * This,
    /* [in] */ MSDRM_STATUS Status,
    /* [in] */ HRESULT hr,
    /* [in] */ DRM_ATTR_DATATYPE dwType,
    /* [in] */ BYTE __RPC_FAR *pValue,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IDRMStatusCallback_OnStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDRMStatusCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_drmexternals_0110 */
/* [local] */ 

#define DRM_ENCRYPT_CONTENT_ASFv1  0x1001
#define DRM_ENCRYPT_CONTENT_ASFv2  0x1002
typedef struct  _DRMBUF
    {
    unsigned long len;
    char __RPC_FAR *buf;
    }	DRMBUF;

typedef struct _DRMBUF __RPC_FAR *PDRMBUF;



extern RPC_IF_HANDLE __MIDL_itf_drmexternals_0110_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_drmexternals_0110_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\wmsdk\inc\sac.h ===
#ifndef __SAC_H__
#define __SAC_H__

typedef DWORD HMAC;

#define RSA_KEY_LEN 64
#define SAC_SESSION_KEYLEN 8

#define SAC_PROTOCOL_WMDM 1
#define SAC_PROTOCOL_V1 2

#define SAC_CERT_X509 1
#define SAC_CERT_V1 2

typedef struct __MACINFO
{
	BOOL fUsed;
	BYTE abMacState[36];
} MACINFO;

#endif //__SAC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\wmsdk\inc\wmdm.c ===
const CLSID CLSID_MediaDevMgr = {0x25BAAD81,0x3560,0x11D3,{0x84,0x71,0x00,0xC0,0x4F,0x79,0xDB,0xC0}};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\wmsdk\inc\wmdm.h ===
EXTERN_C const CLSID CLSID_MediaDevMgr;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\wmsdk\inc\scserver.h ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

#ifndef _CSECURECHANNELSERVER_H_2AD99357_6FD2_11d3_8497_00C04F79DBC0
#define _CSECURECHANNELSERVER_H_2AD99357_6FD2_11d3_8497_00C04F79DBC0

#include "wtypes.h"

#ifdef USE_X509
#include "rsa.h"
#endif

#ifdef USE_X509
#include "x509cert.h"
#endif

#include "sac.h"

class CSecureChannelServer
{
public:
	   CSecureChannelServer();
       ~CSecureChannelServer();
       HRESULT SetCertificate(DWORD dwFlags,
		                      BYTE *pbAppCert, 
                              DWORD dwCertLen, 
                              BYTE *pbAppPVK,
                              DWORD dwPVKLen);
       HRESULT SACAuth(DWORD dwProtocolID,
                       DWORD dwPass,
                       BYTE *pbDataIn,
                       DWORD dwDataInLen,
                       BYTE **ppbDataOut,
                       DWORD *pdwDataOutLen);
       HRESULT SACGetProtocols(DWORD **ppdwProtocols,
                               DWORD *pdwProtocolCount);
       HRESULT EncryptParam(BYTE *pbData,
                            DWORD dwDataLen);
       HRESULT DecryptParam(BYTE *pbData,
                           DWORD dwDataLen);
       HRESULT MACInit(HMAC *phMAC);
       HRESULT MACUpdate(HMAC hMAC,
                         BYTE *pbData,
                         DWORD dwDataLen);
       HRESULT MACFinal(HMAC hMAC,
                        BYTE abData[SAC_MAC_LEN]); 
	   HRESULT GetAppSec(DWORD *pdwLocalAppSec, DWORD *pdwRemoteAppSec);
	   HRESULT SetSessionKey(BYTE *pbSPSessionKey);
	   HRESULT GetSessionKey(BYTE *pbSPSessionKey);
       HRESULT GetRemoteAppCert(BYTE *pbAppCert, DWORD* pdwCertLen);
	   BOOL fIsAuthenticated();
private:
	   BOOL m_fAuthenticated;
       BYTE *m_pbAppCert;
       DWORD m_dwCertLen;
	   BYTE *m_pbRemoteCert;
	   DWORD m_dwRemoteCertLen;
       BYTE *m_pbAppPVK;
       DWORD m_dwPVKLen; 
       BYTE *m_pbSessionKey;
       DWORD m_dwSessionKeyLen;
       BYTE m_abCallerChallenge[4];
       BYTE m_abIssuedChallenge[4];
	   BOOL m_TableInit;
       unsigned long m_DesTable[32];

#ifdef USE_X509
       CX509Cert m_CertObj;
#endif
	   DWORD m_dwCertFlags;
	   MACINFO aMacInfo[20];
	   BYTE m_abMacKey[64];
	   BOOL m_fMacKeyInit;
       CRITICAL_SECTION m_CS;      
       HRESULT Protocol1(DWORD dwPass,
                         BYTE *pbDataIn,
                         DWORD dwDataInLen,
                         BYTE **ppbDataOut,
                         DWORD *pdwDataOutLen);

       HRESULT Protocol2(DWORD dwPass,
                         BYTE *pbDataIn,
                         DWORD dwDataInLen,
                         BYTE **ppbDataOut,
                         DWORD *pdwDataOutLen);
};

#endif // _CSECURECHANNELSERVER_H_2AD99357-6FD2-11d3-8497-00C04F79DBC0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\wmsdk\inc\sha.h ===
//-----------------------------------------------------------------------------
//
// File:   sha.h
//
// Microsoft Digital Rights Management
// Copyright (C) Microsoft Corporation, 1999-2001. All Rights Reserved
//
// Description:
//
//-----------------------------------------------------------------------------

#ifndef RSA32API
#define RSA32API __stdcall
#endif

/* Copyright (C) RSA Data Security, Inc. created 1993.  This is an
   unpublished work protected as such under copyright law.  This work
   contains proprietary, confidential, and trade secret information of
   RSA Data Security, Inc.  Use, disclosure or reproduction without the
   express written authorization of RSA Data Security, Inc. is
   prohibited.
 */

#ifndef _SHA_H_
#define _SHA_H_ 1

#ifdef __cplusplus
extern "C" {
#endif

#define A_SHA_DIGEST_LEN 20

typedef struct {
    DWORD       FinishFlag;
    BYTE        HashVal[A_SHA_DIGEST_LEN];
    DWORD state[5];                             /* state (ABCDE) */
    DWORD count[2];                             /* number of bytes, msb first */
    unsigned char buffer[64];                   /* input buffer */
} A_SHA_CTX;

void RSA32API A_SHAInit(A_SHA_CTX *);
void RSA32API A_SHAUpdate(A_SHA_CTX *, unsigned char *, unsigned int);
void RSA32API A_SHAFinal(A_SHA_CTX *, unsigned char [A_SHA_DIGEST_LEN]);

//
// versions that don't internally byteswap (NoSwap version), for apps like
// the RNG that don't need hash compatibility - perf increase helps.
//

void RSA32API A_SHAUpdateNS(A_SHA_CTX *, unsigned char *, unsigned int);
void RSA32API A_SHAFinalNS(A_SHA_CTX *, unsigned char [A_SHA_DIGEST_LEN]);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\wmsdk\inc\mswmdm.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Wed Aug 08 01:15:08 2001
 */
/* Compiler settings for .\mswmdm.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __mswmdm_h__
#define __mswmdm_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IWMDeviceManager_FWD_DEFINED__
#define __IWMDeviceManager_FWD_DEFINED__
typedef interface IWMDeviceManager IWMDeviceManager;
#endif 	/* __IWMDeviceManager_FWD_DEFINED__ */


#ifndef __IWMDeviceManager2_FWD_DEFINED__
#define __IWMDeviceManager2_FWD_DEFINED__
typedef interface IWMDeviceManager2 IWMDeviceManager2;
#endif 	/* __IWMDeviceManager2_FWD_DEFINED__ */


#ifndef __IWMDMStorageGlobals_FWD_DEFINED__
#define __IWMDMStorageGlobals_FWD_DEFINED__
typedef interface IWMDMStorageGlobals IWMDMStorageGlobals;
#endif 	/* __IWMDMStorageGlobals_FWD_DEFINED__ */


#ifndef __IWMDMStorage_FWD_DEFINED__
#define __IWMDMStorage_FWD_DEFINED__
typedef interface IWMDMStorage IWMDMStorage;
#endif 	/* __IWMDMStorage_FWD_DEFINED__ */


#ifndef __IWMDMStorage2_FWD_DEFINED__
#define __IWMDMStorage2_FWD_DEFINED__
typedef interface IWMDMStorage2 IWMDMStorage2;
#endif 	/* __IWMDMStorage2_FWD_DEFINED__ */


#ifndef __IWMDMOperation_FWD_DEFINED__
#define __IWMDMOperation_FWD_DEFINED__
typedef interface IWMDMOperation IWMDMOperation;
#endif 	/* __IWMDMOperation_FWD_DEFINED__ */


#ifndef __IWMDMOperation2_FWD_DEFINED__
#define __IWMDMOperation2_FWD_DEFINED__
typedef interface IWMDMOperation2 IWMDMOperation2;
#endif 	/* __IWMDMOperation2_FWD_DEFINED__ */


#ifndef __IWMDMProgress_FWD_DEFINED__
#define __IWMDMProgress_FWD_DEFINED__
typedef interface IWMDMProgress IWMDMProgress;
#endif 	/* __IWMDMProgress_FWD_DEFINED__ */


#ifndef __IWMDMProgress2_FWD_DEFINED__
#define __IWMDMProgress2_FWD_DEFINED__
typedef interface IWMDMProgress2 IWMDMProgress2;
#endif 	/* __IWMDMProgress2_FWD_DEFINED__ */


#ifndef __IWMDMDevice_FWD_DEFINED__
#define __IWMDMDevice_FWD_DEFINED__
typedef interface IWMDMDevice IWMDMDevice;
#endif 	/* __IWMDMDevice_FWD_DEFINED__ */


#ifndef __IWMDMDevice2_FWD_DEFINED__
#define __IWMDMDevice2_FWD_DEFINED__
typedef interface IWMDMDevice2 IWMDMDevice2;
#endif 	/* __IWMDMDevice2_FWD_DEFINED__ */


#ifndef __IWMDMEnumDevice_FWD_DEFINED__
#define __IWMDMEnumDevice_FWD_DEFINED__
typedef interface IWMDMEnumDevice IWMDMEnumDevice;
#endif 	/* __IWMDMEnumDevice_FWD_DEFINED__ */


#ifndef __IWMDMDeviceControl_FWD_DEFINED__
#define __IWMDMDeviceControl_FWD_DEFINED__
typedef interface IWMDMDeviceControl IWMDMDeviceControl;
#endif 	/* __IWMDMDeviceControl_FWD_DEFINED__ */


#ifndef __IWMDMEnumStorage_FWD_DEFINED__
#define __IWMDMEnumStorage_FWD_DEFINED__
typedef interface IWMDMEnumStorage IWMDMEnumStorage;
#endif 	/* __IWMDMEnumStorage_FWD_DEFINED__ */


#ifndef __IWMDMStorageControl_FWD_DEFINED__
#define __IWMDMStorageControl_FWD_DEFINED__
typedef interface IWMDMStorageControl IWMDMStorageControl;
#endif 	/* __IWMDMStorageControl_FWD_DEFINED__ */


#ifndef __IWMDMStorageControl2_FWD_DEFINED__
#define __IWMDMStorageControl2_FWD_DEFINED__
typedef interface IWMDMStorageControl2 IWMDMStorageControl2;
#endif 	/* __IWMDMStorageControl2_FWD_DEFINED__ */


#ifndef __IWMDMObjectInfo_FWD_DEFINED__
#define __IWMDMObjectInfo_FWD_DEFINED__
typedef interface IWMDMObjectInfo IWMDMObjectInfo;
#endif 	/* __IWMDMObjectInfo_FWD_DEFINED__ */


#ifndef __IWMDMRevoked_FWD_DEFINED__
#define __IWMDMRevoked_FWD_DEFINED__
typedef interface IWMDMRevoked IWMDMRevoked;
#endif 	/* __IWMDMRevoked_FWD_DEFINED__ */


#ifndef __IMDServiceProvider_FWD_DEFINED__
#define __IMDServiceProvider_FWD_DEFINED__
typedef interface IMDServiceProvider IMDServiceProvider;
#endif 	/* __IMDServiceProvider_FWD_DEFINED__ */


#ifndef __IMDServiceProvider2_FWD_DEFINED__
#define __IMDServiceProvider2_FWD_DEFINED__
typedef interface IMDServiceProvider2 IMDServiceProvider2;
#endif 	/* __IMDServiceProvider2_FWD_DEFINED__ */


#ifndef __IMDSPEnumDevice_FWD_DEFINED__
#define __IMDSPEnumDevice_FWD_DEFINED__
typedef interface IMDSPEnumDevice IMDSPEnumDevice;
#endif 	/* __IMDSPEnumDevice_FWD_DEFINED__ */


#ifndef __IMDSPDevice_FWD_DEFINED__
#define __IMDSPDevice_FWD_DEFINED__
typedef interface IMDSPDevice IMDSPDevice;
#endif 	/* __IMDSPDevice_FWD_DEFINED__ */


#ifndef __IMDSPDevice2_FWD_DEFINED__
#define __IMDSPDevice2_FWD_DEFINED__
typedef interface IMDSPDevice2 IMDSPDevice2;
#endif 	/* __IMDSPDevice2_FWD_DEFINED__ */


#ifndef __IMDSPDeviceControl_FWD_DEFINED__
#define __IMDSPDeviceControl_FWD_DEFINED__
typedef interface IMDSPDeviceControl IMDSPDeviceControl;
#endif 	/* __IMDSPDeviceControl_FWD_DEFINED__ */


#ifndef __IMDSPEnumStorage_FWD_DEFINED__
#define __IMDSPEnumStorage_FWD_DEFINED__
typedef interface IMDSPEnumStorage IMDSPEnumStorage;
#endif 	/* __IMDSPEnumStorage_FWD_DEFINED__ */


#ifndef __IMDSPStorage_FWD_DEFINED__
#define __IMDSPStorage_FWD_DEFINED__
typedef interface IMDSPStorage IMDSPStorage;
#endif 	/* __IMDSPStorage_FWD_DEFINED__ */


#ifndef __IMDSPStorage2_FWD_DEFINED__
#define __IMDSPStorage2_FWD_DEFINED__
typedef interface IMDSPStorage2 IMDSPStorage2;
#endif 	/* __IMDSPStorage2_FWD_DEFINED__ */


#ifndef __IMDSPStorageGlobals_FWD_DEFINED__
#define __IMDSPStorageGlobals_FWD_DEFINED__
typedef interface IMDSPStorageGlobals IMDSPStorageGlobals;
#endif 	/* __IMDSPStorageGlobals_FWD_DEFINED__ */


#ifndef __IMDSPObjectInfo_FWD_DEFINED__
#define __IMDSPObjectInfo_FWD_DEFINED__
typedef interface IMDSPObjectInfo IMDSPObjectInfo;
#endif 	/* __IMDSPObjectInfo_FWD_DEFINED__ */


#ifndef __IMDSPObject_FWD_DEFINED__
#define __IMDSPObject_FWD_DEFINED__
typedef interface IMDSPObject IMDSPObject;
#endif 	/* __IMDSPObject_FWD_DEFINED__ */


#ifndef __IMDSPRevoked_FWD_DEFINED__
#define __IMDSPRevoked_FWD_DEFINED__
typedef interface IMDSPRevoked IMDSPRevoked;
#endif 	/* __IMDSPRevoked_FWD_DEFINED__ */


#ifndef __ISCPSecureAuthenticate_FWD_DEFINED__
#define __ISCPSecureAuthenticate_FWD_DEFINED__
typedef interface ISCPSecureAuthenticate ISCPSecureAuthenticate;
#endif 	/* __ISCPSecureAuthenticate_FWD_DEFINED__ */


#ifndef __ISCPSecureQuery_FWD_DEFINED__
#define __ISCPSecureQuery_FWD_DEFINED__
typedef interface ISCPSecureQuery ISCPSecureQuery;
#endif 	/* __ISCPSecureQuery_FWD_DEFINED__ */


#ifndef __ISCPSecureQuery2_FWD_DEFINED__
#define __ISCPSecureQuery2_FWD_DEFINED__
typedef interface ISCPSecureQuery2 ISCPSecureQuery2;
#endif 	/* __ISCPSecureQuery2_FWD_DEFINED__ */


#ifndef __ISCPSecureExchange_FWD_DEFINED__
#define __ISCPSecureExchange_FWD_DEFINED__
typedef interface ISCPSecureExchange ISCPSecureExchange;
#endif 	/* __ISCPSecureExchange_FWD_DEFINED__ */


#ifndef __IComponentAuthenticate_FWD_DEFINED__
#define __IComponentAuthenticate_FWD_DEFINED__
typedef interface IComponentAuthenticate IComponentAuthenticate;
#endif 	/* __IComponentAuthenticate_FWD_DEFINED__ */


#ifndef __MediaDevMgrClassFactory_FWD_DEFINED__
#define __MediaDevMgrClassFactory_FWD_DEFINED__

#ifdef __cplusplus
typedef class MediaDevMgrClassFactory MediaDevMgrClassFactory;
#else
typedef struct MediaDevMgrClassFactory MediaDevMgrClassFactory;
#endif /* __cplusplus */

#endif 	/* __MediaDevMgrClassFactory_FWD_DEFINED__ */


#ifndef __MediaDevMgr_FWD_DEFINED__
#define __MediaDevMgr_FWD_DEFINED__

#ifdef __cplusplus
typedef class MediaDevMgr MediaDevMgr;
#else
typedef struct MediaDevMgr MediaDevMgr;
#endif /* __cplusplus */

#endif 	/* __MediaDevMgr_FWD_DEFINED__ */


#ifndef __WMDMDevice_FWD_DEFINED__
#define __WMDMDevice_FWD_DEFINED__

#ifdef __cplusplus
typedef class WMDMDevice WMDMDevice;
#else
typedef struct WMDMDevice WMDMDevice;
#endif /* __cplusplus */

#endif 	/* __WMDMDevice_FWD_DEFINED__ */


#ifndef __WMDMStorage_FWD_DEFINED__
#define __WMDMStorage_FWD_DEFINED__

#ifdef __cplusplus
typedef class WMDMStorage WMDMStorage;
#else
typedef struct WMDMStorage WMDMStorage;
#endif /* __cplusplus */

#endif 	/* __WMDMStorage_FWD_DEFINED__ */


#ifndef __WMDMStorageGlobal_FWD_DEFINED__
#define __WMDMStorageGlobal_FWD_DEFINED__

#ifdef __cplusplus
typedef class WMDMStorageGlobal WMDMStorageGlobal;
#else
typedef struct WMDMStorageGlobal WMDMStorageGlobal;
#endif /* __cplusplus */

#endif 	/* __WMDMStorageGlobal_FWD_DEFINED__ */


#ifndef __WMDMDeviceEnum_FWD_DEFINED__
#define __WMDMDeviceEnum_FWD_DEFINED__

#ifdef __cplusplus
typedef class WMDMDeviceEnum WMDMDeviceEnum;
#else
typedef struct WMDMDeviceEnum WMDMDeviceEnum;
#endif /* __cplusplus */

#endif 	/* __WMDMDeviceEnum_FWD_DEFINED__ */


#ifndef __WMDMStorageEnum_FWD_DEFINED__
#define __WMDMStorageEnum_FWD_DEFINED__

#ifdef __cplusplus
typedef class WMDMStorageEnum WMDMStorageEnum;
#else
typedef struct WMDMStorageEnum WMDMStorageEnum;
#endif /* __cplusplus */

#endif 	/* __WMDMStorageEnum_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_mswmdm_0000 */
/* [local] */ 

typedef struct  _tWAVEFORMATEX
    {
    WORD wFormatTag;
    WORD nChannels;
    DWORD nSamplesPerSec;
    DWORD nAvgBytesPerSec;
    WORD nBlockAlign;
    WORD wBitsPerSample;
    WORD cbSize;
    }	_WAVEFORMATEX;

typedef struct  _tagBITMAPINFOHEADER
    {
    DWORD biSize;
    LONG biWidth;
    LONG biHeight;
    WORD biPlanes;
    WORD biBitCount;
    DWORD biCompression;
    DWORD biSizeImage;
    LONG biXPelsPerMeter;
    LONG biYPelsPerMeter;
    DWORD biClrUsed;
    DWORD biClrImportant;
    }	_BITMAPINFOHEADER;

typedef struct  _tagVIDEOINFOHEADER
    {
    RECT rcSource;
    RECT rcTarget;
    DWORD dwBitRate;
    DWORD dwBitErrorRate;
    LONGLONG AvgTimePerFrame;
    _BITMAPINFOHEADER bmiHeader;
    }	_VIDEOINFOHEADER;

typedef struct  _tagWMFILECAPABILITIES
    {
    LPWSTR pwszMimeType;
    DWORD dwReserved;
    }	WMFILECAPABILITIES;

typedef struct  __OPAQUECOMMAND
    {
    GUID guidCommand;
    DWORD dwDataLen;
    /* [size_is] */ BYTE __RPC_FAR *pData;
    BYTE abMAC[ 20 ];
    }	OPAQUECOMMAND;

#define WMDMID_LENGTH  128
typedef struct  __WMDMID
    {
    UINT cbSize;
    DWORD dwVendorID;
    BYTE pID[ 128 ];
    UINT SerialNumberLength;
    }	WMDMID;

typedef struct __WMDMID __RPC_FAR *PWMDMID;

typedef struct  _WMDMDATETIME
    {
    WORD wYear;
    WORD wMonth;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    }	WMDMDATETIME;

typedef struct _WMDMDATETIME __RPC_FAR *PWMDMDATETIME;

typedef struct  __WMDMRIGHTS
    {
    UINT cbSize;
    DWORD dwContentType;
    DWORD fuFlags;
    DWORD fuRights;
    DWORD dwAppSec;
    DWORD dwPlaybackCount;
    WMDMDATETIME ExpirationDate;
    }	WMDMRIGHTS;

typedef struct __WMDMRIGHTS __RPC_FAR *PWMDMRIGHTS;

#define WMDM_MAC_LENGTH 8
// WMDM HRESULTS
#define WMDM_E_BUSY                             0x80045000L
#define WMDM_E_INTERFACEDEAD                    0x80045001L
#define WMDM_E_INVALIDTYPE                      0x80045002L
#define WMDM_E_PROCESSFAILED                    0x80045003L
#define WMDM_E_NOTSUPPORTED                     0x80045004L
#define WMDM_E_NOTCERTIFIED                     0x80045005L
#define WMDM_E_NORIGHTS                         0x80045006L
#define WMDM_E_CALL_OUT_OF_SEQUENCE             0x80045007L
#define WMDM_E_BUFFERTOOSMALL                   0x80045008L
#define WMDM_E_MOREDATA                         0x80045009L
#define WMDM_E_MAC_CHECK_FAILED                 0x8004500AL
#define WMDM_E_USER_CANCELLED                   0x8004500BL
#define WMDM_E_SDMI_TRIGGER                     0x8004500CL
#define WMDM_E_SDMI_NOMORECOPIES                0x8004500DL
#define WMDM_E_REVOKED                          0x8004500EL
// Revocation Flags
#define WMDM_WMDM_REVOKED                       0x00000001
#define WMDM_APP_REVOKED                        0x00000002
#define WMDM_SP_REVOKED                         0x00000004
#define WMDM_SCP_REVOKED                        0x00000008
// GetFormatSupport2 Flags
#define WMDM_GET_FORMAT_SUPPORT_AUDIO           0x00000001
#define WMDM_GET_FORMAT_SUPPORT_VIDEO           0x00000002
#define WMDM_GET_FORMAT_SUPPORT_FILE            0x00000004
// MDMRIGHTS Flags
#define WMDM_RIGHTS_PLAYBACKCOUNT               0x00000001
#define WMDM_RIGHTS_EXPIRATIONDATE              0x00000002
#define WMDM_RIGHTS_GROUPID                     0x00000004
#define WMDM_RIGHTS_FREESERIALIDS               0x00000008
#define WMDM_RIGHTS_NAMEDSERIALIDS              0x00000010
// Device Type Flags
#define WMDM_DEVICE_TYPE_PLAYBACK               0x00000001
#define WMDM_DEVICE_TYPE_RECORD                 0x00000002
#define WMDM_DEVICE_TYPE_DECODE                 0x00000004
#define WMDM_DEVICE_TYPE_ENCODE                 0x00000008
#define WMDM_DEVICE_TYPE_STORAGE                0x00000010
#define WMDM_DEVICE_TYPE_VIRTUAL                0x00000020
#define WMDM_DEVICE_TYPE_SDMI                   0x00000040
#define WMDM_DEVICE_TYPE_NONSDMI                0x00000080
#define WMDM_DEVICE_TYPE_NONREENTRANT           0x00000100
#define WMDM_DEVICE_TYPE_FILELISTRESYNC         0x00000200
// Device Power Source Flags
#define WMDM_POWER_CAP_BATTERY                  0x00000001
#define WMDM_POWER_CAP_EXTERNAL                 0x00000002
#define WMDM_POWER_IS_BATTERY                   0x00000004
#define WMDM_POWER_IS_EXTERNAL                  0x00000008
#define WMDM_POWER_PERCENT_AVAILABLE            0x00000010
// Device Status Flags
#define WMDM_STATUS_READY                       0x00000001
#define WMDM_STATUS_BUSY                        0x00000002
#define WMDM_STATUS_DEVICE_NOTPRESENT           0x00000004
#define WMDM_STATUS_DEVICECONTROL_PLAYING       0x00000008
#define WMDM_STATUS_DEVICECONTROL_RECORDING     0x00000010
#define WMDM_STATUS_DEVICECONTROL_PAUSED        0x00000020
#define WMDM_STATUS_DEVICECONTROL_REMOTE        0x00000040
#define WMDM_STATUS_DEVICECONTROL_STREAM        0x00000080
#define WMDM_STATUS_STORAGE_NOTPRESENT          0x00000100
#define WMDM_STATUS_STORAGE_INITIALIZING        0x00000200
#define WMDM_STATUS_STORAGE_BROKEN              0x00000400
#define WMDM_STATUS_STORAGE_NOTSUPPORTED        0x00000800
#define WMDM_STATUS_STORAGE_UNFORMATTED         0x00001000
#define WMDM_STATUS_STORAGECONTROL_INSERTING    0x00002000
#define WMDM_STATUS_STORAGECONTROL_DELETING     0x00004000
#define WMDM_STATUS_STORAGECONTROL_APPENDING    0x00008000
#define WMDM_STATUS_STORAGECONTROL_MOVING       0x00010000
#define WMDM_STATUS_STORAGECONTROL_READING      0x00020000
// Device Capabilities Flags
#define WMDM_DEVICECAP_CANPLAY                  0x00000001
#define WMDM_DEVICECAP_CANSTREAMPLAY            0x00000002
#define WMDM_DEVICECAP_CANRECORD                0x00000004
#define WMDM_DEVICECAP_CANSTREAMRECORD          0x00000008
#define WMDM_DEVICECAP_CANPAUSE                 0x00000010
#define WMDM_DEVICECAP_CANRESUME                0x00000020
#define WMDM_DEVICECAP_CANSTOP                  0x00000040
#define WMDM_DEVICECAP_CANSEEK                  0x00000080
// WMDM Seek Flags
#define WMDM_SEEK_REMOTECONTROL                 0x00000001
#define WMDM_SEEK_STREAMINGAUDIO                0x00000002
// Storage Attributes Flags
#define WMDM_STORAGE_ATTR_FILESYSTEM            0x00000001
#define WMDM_STORAGE_ATTR_REMOVABLE             0x00000002
#define WMDM_STORAGE_ATTR_NONREMOVABLE          0x00000004
#define WMDM_FILE_ATTR_FOLDER                   0x00000008
#define WMDM_FILE_ATTR_LINK                     0x00000010
#define WMDM_FILE_ATTR_FILE                     0x00000020
#define WMDM_FILE_ATTR_VIDEO                    0x00000040
#define WMDM_STORAGE_ATTR_FOLDERS               0x00000100
#define WMDM_FILE_ATTR_AUDIO                    0x00001000
#define WMDM_FILE_ATTR_DATA                     0x00002000
#define WMDM_FILE_ATTR_CANPLAY                  0x00004000
#define WMDM_FILE_ATTR_CANDELETE                0x00008000
#define WMDM_FILE_ATTR_CANMOVE                  0x00010000
#define WMDM_FILE_ATTR_CANRENAME                0x00020000
#define WMDM_FILE_ATTR_CANREAD                  0x00040000
#define WMDM_FILE_ATTR_MUSIC                    0x00080000
#define WMDM_FILE_CREATE_OVERWRITE              0x00100000
#define WMDM_FILE_ATTR_AUDIOBOOK                0x00200000
#define WMDM_FILE_ATTR_HIDDEN                   0x00400000
#define WMDM_FILE_ATTR_SYSTEM                   0x00800000
#define WMDM_FILE_ATTR_READONLY                 0x01000000
#define WMDM_STORAGE_ATTR_HAS_FOLDERS           0x02000000
#define WMDM_STORAGE_ATTR_HAS_FILES             0x04000000
#define WMDM_STORAGE_IS_DEFAULT                 0x08000000
#define WMDM_STORAGE_CONTAINS_DEFAULT           0x10000000
// Storage Capabilities Flags
#define WMDM_STORAGECAP_FOLDERSINROOT           0x00000001
#define WMDM_STORAGECAP_FILESINROOT             0x00000002
#define WMDM_STORAGECAP_FOLDERSINFOLDERS        0x00000004
#define WMDM_STORAGECAP_FILESINFOLDERS          0x00000008
#define WMDM_STORAGECAP_FOLDERLIMITEXISTS       0x00000010
#define WMDM_STORAGECAP_FILELIMITEXISTS         0x00000020
// WMDM Mode Flags
#define WMDM_MODE_BLOCK                         0x00000001
#define WMDM_MODE_THREAD                        0x00000002
#define WMDM_CONTENT_FILE                       0x00000004
#define WMDM_CONTENT_FOLDER                     0x00000008
#define WMDM_CONTENT_OPERATIONINTERFACE         0x00000010
#define WMDM_MODE_QUERY                         0x00000020
#define WMDM_MODE_PROGRESS                      0x00000040
#define WMDM_MODE_TRANSFER_PROTECTED            0x00000080
#define WMDM_MODE_TRANSFER_UNPROTECTED          0x00000100
#define WMDM_STORAGECONTROL_INSERTBEFORE        0x00000200
#define WMDM_STORAGECONTROL_INSERTAFTER         0x00000400
#define WMDM_STORAGECONTROL_INSERTINTO          0x00000800
#define WMDM_MODE_RECURSIVE                     0x00001000
// WMDM Rights Flags
// NON_SDMI = !SDMI_PROTECTED
// SDMI = SDMI_VALIDATED
#define WMDM_RIGHTS_PLAY_ON_PC                  0x00000001
#define WMDM_RIGHTS_COPY_TO_NON_SDMI_DEVICE     0x00000002
#define WMDM_RIGHTS_COPY_TO_CD                  0x00000008
#define WMDM_RIGHTS_COPY_TO_SDMI_DEVICE         0x00000010
// WMDM Seek Flags
#define WMDM_SEEK_BEGIN                         0x00000001
#define WMDM_SEEK_CURRENT                       0x00000002
#define WMDM_SEEK_END                           0x00000008











extern RPC_IF_HANDLE __MIDL_itf_mswmdm_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mswmdm_0000_v0_0_s_ifspec;

#ifndef __IWMDeviceManager_INTERFACE_DEFINED__
#define __IWMDeviceManager_INTERFACE_DEFINED__

/* interface IWMDeviceManager */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IWMDeviceManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A00-33ED-11d3-8470-00C04F79DBC0")
    IWMDeviceManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRevision( 
            /* [out] */ DWORD __RPC_FAR *pdwRevision) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeviceCount( 
            /* [out] */ DWORD __RPC_FAR *pdwCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumDevices( 
            /* [out] */ IWMDMEnumDevice __RPC_FAR *__RPC_FAR *ppEnumDevice) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDeviceManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDeviceManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDeviceManager __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDeviceManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRevision )( 
            IWMDeviceManager __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwRevision);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDeviceCount )( 
            IWMDeviceManager __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumDevices )( 
            IWMDeviceManager __RPC_FAR * This,
            /* [out] */ IWMDMEnumDevice __RPC_FAR *__RPC_FAR *ppEnumDevice);
        
        END_INTERFACE
    } IWMDeviceManagerVtbl;

    interface IWMDeviceManager
    {
        CONST_VTBL struct IWMDeviceManagerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDeviceManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDeviceManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDeviceManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDeviceManager_GetRevision(This,pdwRevision)	\
    (This)->lpVtbl -> GetRevision(This,pdwRevision)

#define IWMDeviceManager_GetDeviceCount(This,pdwCount)	\
    (This)->lpVtbl -> GetDeviceCount(This,pdwCount)

#define IWMDeviceManager_EnumDevices(This,ppEnumDevice)	\
    (This)->lpVtbl -> EnumDevices(This,ppEnumDevice)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDeviceManager_GetRevision_Proxy( 
    IWMDeviceManager __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwRevision);


void __RPC_STUB IWMDeviceManager_GetRevision_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDeviceManager_GetDeviceCount_Proxy( 
    IWMDeviceManager __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwCount);


void __RPC_STUB IWMDeviceManager_GetDeviceCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDeviceManager_EnumDevices_Proxy( 
    IWMDeviceManager __RPC_FAR * This,
    /* [out] */ IWMDMEnumDevice __RPC_FAR *__RPC_FAR *ppEnumDevice);


void __RPC_STUB IWMDeviceManager_EnumDevices_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDeviceManager_INTERFACE_DEFINED__ */


#ifndef __IWMDeviceManager2_INTERFACE_DEFINED__
#define __IWMDeviceManager2_INTERFACE_DEFINED__

/* interface IWMDeviceManager2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IWMDeviceManager2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("923E5249-8731-4c5b-9B1C-B8B60B6E46AF")
    IWMDeviceManager2 : public IWMDeviceManager
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDeviceFromPnPName( 
            /* [string][in] */ LPCWSTR pwszPnPName,
            /* [out] */ IWMDMDevice __RPC_FAR *__RPC_FAR *ppDevice) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDeviceManager2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDeviceManager2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDeviceManager2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDeviceManager2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRevision )( 
            IWMDeviceManager2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwRevision);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDeviceCount )( 
            IWMDeviceManager2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumDevices )( 
            IWMDeviceManager2 __RPC_FAR * This,
            /* [out] */ IWMDMEnumDevice __RPC_FAR *__RPC_FAR *ppEnumDevice);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDeviceFromPnPName )( 
            IWMDeviceManager2 __RPC_FAR * This,
            /* [string][in] */ LPCWSTR pwszPnPName,
            /* [out] */ IWMDMDevice __RPC_FAR *__RPC_FAR *ppDevice);
        
        END_INTERFACE
    } IWMDeviceManager2Vtbl;

    interface IWMDeviceManager2
    {
        CONST_VTBL struct IWMDeviceManager2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDeviceManager2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDeviceManager2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDeviceManager2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDeviceManager2_GetRevision(This,pdwRevision)	\
    (This)->lpVtbl -> GetRevision(This,pdwRevision)

#define IWMDeviceManager2_GetDeviceCount(This,pdwCount)	\
    (This)->lpVtbl -> GetDeviceCount(This,pdwCount)

#define IWMDeviceManager2_EnumDevices(This,ppEnumDevice)	\
    (This)->lpVtbl -> EnumDevices(This,ppEnumDevice)


#define IWMDeviceManager2_GetDeviceFromPnPName(This,pwszPnPName,ppDevice)	\
    (This)->lpVtbl -> GetDeviceFromPnPName(This,pwszPnPName,ppDevice)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDeviceManager2_GetDeviceFromPnPName_Proxy( 
    IWMDeviceManager2 __RPC_FAR * This,
    /* [string][in] */ LPCWSTR pwszPnPName,
    /* [out] */ IWMDMDevice __RPC_FAR *__RPC_FAR *ppDevice);


void __RPC_STUB IWMDeviceManager2_GetDeviceFromPnPName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDeviceManager2_INTERFACE_DEFINED__ */


#ifndef __IWMDMStorageGlobals_INTERFACE_DEFINED__
#define __IWMDMStorageGlobals_INTERFACE_DEFINED__

/* interface IWMDMStorageGlobals */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IWMDMStorageGlobals;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A07-33ED-11d3-8470-00C04F79DBC0")
    IWMDMStorageGlobals : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCapabilities( 
            /* [out] */ DWORD __RPC_FAR *pdwCapabilities) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSerialNumber( 
            /* [out] */ PWMDMID pSerialNum,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTotalSize( 
            /* [out] */ DWORD __RPC_FAR *pdwTotalSizeLow,
            /* [out] */ DWORD __RPC_FAR *pdwTotalSizeHigh) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTotalFree( 
            /* [out] */ DWORD __RPC_FAR *pdwFreeLow,
            /* [out] */ DWORD __RPC_FAR *pdwFreeHigh) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTotalBad( 
            /* [out] */ DWORD __RPC_FAR *pdwBadLow,
            /* [out] */ DWORD __RPC_FAR *pdwBadHigh) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ DWORD __RPC_FAR *pdwStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ UINT fuMode,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDMStorageGlobalsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDMStorageGlobals __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDMStorageGlobals __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDMStorageGlobals __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCapabilities )( 
            IWMDMStorageGlobals __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwCapabilities);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSerialNumber )( 
            IWMDMStorageGlobals __RPC_FAR * This,
            /* [out] */ PWMDMID pSerialNum,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTotalSize )( 
            IWMDMStorageGlobals __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwTotalSizeLow,
            /* [out] */ DWORD __RPC_FAR *pdwTotalSizeHigh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTotalFree )( 
            IWMDMStorageGlobals __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwFreeLow,
            /* [out] */ DWORD __RPC_FAR *pdwFreeHigh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTotalBad )( 
            IWMDMStorageGlobals __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwBadLow,
            /* [out] */ DWORD __RPC_FAR *pdwBadHigh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatus )( 
            IWMDMStorageGlobals __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IWMDMStorageGlobals __RPC_FAR * This,
            /* [in] */ UINT fuMode,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress);
        
        END_INTERFACE
    } IWMDMStorageGlobalsVtbl;

    interface IWMDMStorageGlobals
    {
        CONST_VTBL struct IWMDMStorageGlobalsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDMStorageGlobals_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDMStorageGlobals_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDMStorageGlobals_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDMStorageGlobals_GetCapabilities(This,pdwCapabilities)	\
    (This)->lpVtbl -> GetCapabilities(This,pdwCapabilities)

#define IWMDMStorageGlobals_GetSerialNumber(This,pSerialNum,abMac)	\
    (This)->lpVtbl -> GetSerialNumber(This,pSerialNum,abMac)

#define IWMDMStorageGlobals_GetTotalSize(This,pdwTotalSizeLow,pdwTotalSizeHigh)	\
    (This)->lpVtbl -> GetTotalSize(This,pdwTotalSizeLow,pdwTotalSizeHigh)

#define IWMDMStorageGlobals_GetTotalFree(This,pdwFreeLow,pdwFreeHigh)	\
    (This)->lpVtbl -> GetTotalFree(This,pdwFreeLow,pdwFreeHigh)

#define IWMDMStorageGlobals_GetTotalBad(This,pdwBadLow,pdwBadHigh)	\
    (This)->lpVtbl -> GetTotalBad(This,pdwBadLow,pdwBadHigh)

#define IWMDMStorageGlobals_GetStatus(This,pdwStatus)	\
    (This)->lpVtbl -> GetStatus(This,pdwStatus)

#define IWMDMStorageGlobals_Initialize(This,fuMode,pProgress)	\
    (This)->lpVtbl -> Initialize(This,fuMode,pProgress)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDMStorageGlobals_GetCapabilities_Proxy( 
    IWMDMStorageGlobals __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwCapabilities);


void __RPC_STUB IWMDMStorageGlobals_GetCapabilities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMStorageGlobals_GetSerialNumber_Proxy( 
    IWMDMStorageGlobals __RPC_FAR * This,
    /* [out] */ PWMDMID pSerialNum,
    /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);


void __RPC_STUB IWMDMStorageGlobals_GetSerialNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMStorageGlobals_GetTotalSize_Proxy( 
    IWMDMStorageGlobals __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwTotalSizeLow,
    /* [out] */ DWORD __RPC_FAR *pdwTotalSizeHigh);


void __RPC_STUB IWMDMStorageGlobals_GetTotalSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMStorageGlobals_GetTotalFree_Proxy( 
    IWMDMStorageGlobals __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwFreeLow,
    /* [out] */ DWORD __RPC_FAR *pdwFreeHigh);


void __RPC_STUB IWMDMStorageGlobals_GetTotalFree_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMStorageGlobals_GetTotalBad_Proxy( 
    IWMDMStorageGlobals __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwBadLow,
    /* [out] */ DWORD __RPC_FAR *pdwBadHigh);


void __RPC_STUB IWMDMStorageGlobals_GetTotalBad_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMStorageGlobals_GetStatus_Proxy( 
    IWMDMStorageGlobals __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwStatus);


void __RPC_STUB IWMDMStorageGlobals_GetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMStorageGlobals_Initialize_Proxy( 
    IWMDMStorageGlobals __RPC_FAR * This,
    /* [in] */ UINT fuMode,
    /* [in] */ IWMDMProgress __RPC_FAR *pProgress);


void __RPC_STUB IWMDMStorageGlobals_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDMStorageGlobals_INTERFACE_DEFINED__ */


#ifndef __IWMDMStorage_INTERFACE_DEFINED__
#define __IWMDMStorage_INTERFACE_DEFINED__

/* interface IWMDMStorage */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IWMDMStorage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A06-33ED-11d3-8470-00C04F79DBC0")
    IWMDMStorage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetAttributes( 
            /* [in] */ DWORD dwAttributes,
            /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStorageGlobals( 
            /* [out] */ IWMDMStorageGlobals __RPC_FAR *__RPC_FAR *ppStorageGlobals) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributes( 
            /* [out] */ DWORD __RPC_FAR *pdwAttributes,
            /* [out] */ _WAVEFORMATEX __RPC_FAR *pFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [size_is][string][out] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDate( 
            /* [out] */ PWMDMDATETIME pDateTimeUTC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSize( 
            /* [out] */ DWORD __RPC_FAR *pdwSizeLow,
            /* [out] */ DWORD __RPC_FAR *pdwSizeHigh) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRights( 
            /* [size_is][size_is][out] */ PWMDMRIGHTS __RPC_FAR *ppRights,
            /* [out] */ UINT __RPC_FAR *pnRightsCount,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumStorage( 
            /* [out] */ IWMDMEnumStorage __RPC_FAR *__RPC_FAR *pEnumStorage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendOpaqueCommand( 
            /* [out][in] */ OPAQUECOMMAND __RPC_FAR *pCommand) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDMStorageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDMStorage __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDMStorage __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDMStorage __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAttributes )( 
            IWMDMStorage __RPC_FAR * This,
            /* [in] */ DWORD dwAttributes,
            /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStorageGlobals )( 
            IWMDMStorage __RPC_FAR * This,
            /* [out] */ IWMDMStorageGlobals __RPC_FAR *__RPC_FAR *ppStorageGlobals);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttributes )( 
            IWMDMStorage __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwAttributes,
            /* [out] */ _WAVEFORMATEX __RPC_FAR *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IWMDMStorage __RPC_FAR * This,
            /* [size_is][string][out] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDate )( 
            IWMDMStorage __RPC_FAR * This,
            /* [out] */ PWMDMDATETIME pDateTimeUTC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSize )( 
            IWMDMStorage __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwSizeLow,
            /* [out] */ DWORD __RPC_FAR *pdwSizeHigh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRights )( 
            IWMDMStorage __RPC_FAR * This,
            /* [size_is][size_is][out] */ PWMDMRIGHTS __RPC_FAR *ppRights,
            /* [out] */ UINT __RPC_FAR *pnRightsCount,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumStorage )( 
            IWMDMStorage __RPC_FAR * This,
            /* [out] */ IWMDMEnumStorage __RPC_FAR *__RPC_FAR *pEnumStorage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendOpaqueCommand )( 
            IWMDMStorage __RPC_FAR * This,
            /* [out][in] */ OPAQUECOMMAND __RPC_FAR *pCommand);
        
        END_INTERFACE
    } IWMDMStorageVtbl;

    interface IWMDMStorage
    {
        CONST_VTBL struct IWMDMStorageVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDMStorage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDMStorage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDMStorage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDMStorage_SetAttributes(This,dwAttributes,pFormat)	\
    (This)->lpVtbl -> SetAttributes(This,dwAttributes,pFormat)

#define IWMDMStorage_GetStorageGlobals(This,ppStorageGlobals)	\
    (This)->lpVtbl -> GetStorageGlobals(This,ppStorageGlobals)

#define IWMDMStorage_GetAttributes(This,pdwAttributes,pFormat)	\
    (This)->lpVtbl -> GetAttributes(This,pdwAttributes,pFormat)

#define IWMDMStorage_GetName(This,pwszName,nMaxChars)	\
    (This)->lpVtbl -> GetName(This,pwszName,nMaxChars)

#define IWMDMStorage_GetDate(This,pDateTimeUTC)	\
    (This)->lpVtbl -> GetDate(This,pDateTimeUTC)

#define IWMDMStorage_GetSize(This,pdwSizeLow,pdwSizeHigh)	\
    (This)->lpVtbl -> GetSize(This,pdwSizeLow,pdwSizeHigh)

#define IWMDMStorage_GetRights(This,ppRights,pnRightsCount,abMac)	\
    (This)->lpVtbl -> GetRights(This,ppRights,pnRightsCount,abMac)

#define IWMDMStorage_EnumStorage(This,pEnumStorage)	\
    (This)->lpVtbl -> EnumStorage(This,pEnumStorage)

#define IWMDMStorage_SendOpaqueCommand(This,pCommand)	\
    (This)->lpVtbl -> SendOpaqueCommand(This,pCommand)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDMStorage_SetAttributes_Proxy( 
    IWMDMStorage __RPC_FAR * This,
    /* [in] */ DWORD dwAttributes,
    /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat);


void __RPC_STUB IWMDMStorage_SetAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMStorage_GetStorageGlobals_Proxy( 
    IWMDMStorage __RPC_FAR * This,
    /* [out] */ IWMDMStorageGlobals __RPC_FAR *__RPC_FAR *ppStorageGlobals);


void __RPC_STUB IWMDMStorage_GetStorageGlobals_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMStorage_GetAttributes_Proxy( 
    IWMDMStorage __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwAttributes,
    /* [out] */ _WAVEFORMATEX __RPC_FAR *pFormat);


void __RPC_STUB IWMDMStorage_GetAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMStorage_GetName_Proxy( 
    IWMDMStorage __RPC_FAR * This,
    /* [size_is][string][out] */ LPWSTR pwszName,
    /* [in] */ UINT nMaxChars);


void __RPC_STUB IWMDMStorage_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMStorage_GetDate_Proxy( 
    IWMDMStorage __RPC_FAR * This,
    /* [out] */ PWMDMDATETIME pDateTimeUTC);


void __RPC_STUB IWMDMStorage_GetDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMStorage_GetSize_Proxy( 
    IWMDMStorage __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwSizeLow,
    /* [out] */ DWORD __RPC_FAR *pdwSizeHigh);


void __RPC_STUB IWMDMStorage_GetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMStorage_GetRights_Proxy( 
    IWMDMStorage __RPC_FAR * This,
    /* [size_is][size_is][out] */ PWMDMRIGHTS __RPC_FAR *ppRights,
    /* [out] */ UINT __RPC_FAR *pnRightsCount,
    /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);


void __RPC_STUB IWMDMStorage_GetRights_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMStorage_EnumStorage_Proxy( 
    IWMDMStorage __RPC_FAR * This,
    /* [out] */ IWMDMEnumStorage __RPC_FAR *__RPC_FAR *pEnumStorage);


void __RPC_STUB IWMDMStorage_EnumStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMStorage_SendOpaqueCommand_Proxy( 
    IWMDMStorage __RPC_FAR * This,
    /* [out][in] */ OPAQUECOMMAND __RPC_FAR *pCommand);


void __RPC_STUB IWMDMStorage_SendOpaqueCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDMStorage_INTERFACE_DEFINED__ */


#ifndef __IWMDMStorage2_INTERFACE_DEFINED__
#define __IWMDMStorage2_INTERFACE_DEFINED__

/* interface IWMDMStorage2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IWMDMStorage2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1ED5A144-5CD5-4683-9EFF-72CBDB2D9533")
    IWMDMStorage2 : public IWMDMStorage
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStorage( 
            /* [string][in] */ LPCWSTR pszStorageName,
            /* [out] */ IWMDMStorage __RPC_FAR *__RPC_FAR *ppStorage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAttributes2( 
            /* [in] */ DWORD dwAttributes,
            /* [in] */ DWORD dwAttributesEx,
            /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat,
            /* [in] */ _VIDEOINFOHEADER __RPC_FAR *pVideoFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributes2( 
            /* [out] */ DWORD __RPC_FAR *pdwAttributes,
            /* [out] */ DWORD __RPC_FAR *pdwAttributesEx,
            /* [out] */ _WAVEFORMATEX __RPC_FAR *pAudioFormat,
            /* [out] */ _VIDEOINFOHEADER __RPC_FAR *pVideoFormat) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDMStorage2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDMStorage2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDMStorage2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDMStorage2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAttributes )( 
            IWMDMStorage2 __RPC_FAR * This,
            /* [in] */ DWORD dwAttributes,
            /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStorageGlobals )( 
            IWMDMStorage2 __RPC_FAR * This,
            /* [out] */ IWMDMStorageGlobals __RPC_FAR *__RPC_FAR *ppStorageGlobals);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttributes )( 
            IWMDMStorage2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwAttributes,
            /* [out] */ _WAVEFORMATEX __RPC_FAR *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IWMDMStorage2 __RPC_FAR * This,
            /* [size_is][string][out] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDate )( 
            IWMDMStorage2 __RPC_FAR * This,
            /* [out] */ PWMDMDATETIME pDateTimeUTC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSize )( 
            IWMDMStorage2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwSizeLow,
            /* [out] */ DWORD __RPC_FAR *pdwSizeHigh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRights )( 
            IWMDMStorage2 __RPC_FAR * This,
            /* [size_is][size_is][out] */ PWMDMRIGHTS __RPC_FAR *ppRights,
            /* [out] */ UINT __RPC_FAR *pnRightsCount,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumStorage )( 
            IWMDMStorage2 __RPC_FAR * This,
            /* [out] */ IWMDMEnumStorage __RPC_FAR *__RPC_FAR *pEnumStorage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendOpaqueCommand )( 
            IWMDMStorage2 __RPC_FAR * This,
            /* [out][in] */ OPAQUECOMMAND __RPC_FAR *pCommand);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStorage )( 
            IWMDMStorage2 __RPC_FAR * This,
            /* [string][in] */ LPCWSTR pszStorageName,
            /* [out] */ IWMDMStorage __RPC_FAR *__RPC_FAR *ppStorage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAttributes2 )( 
            IWMDMStorage2 __RPC_FAR * This,
            /* [in] */ DWORD dwAttributes,
            /* [in] */ DWORD dwAttributesEx,
            /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat,
            /* [in] */ _VIDEOINFOHEADER __RPC_FAR *pVideoFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttributes2 )( 
            IWMDMStorage2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwAttributes,
            /* [out] */ DWORD __RPC_FAR *pdwAttributesEx,
            /* [out] */ _WAVEFORMATEX __RPC_FAR *pAudioFormat,
            /* [out] */ _VIDEOINFOHEADER __RPC_FAR *pVideoFormat);
        
        END_INTERFACE
    } IWMDMStorage2Vtbl;

    interface IWMDMStorage2
    {
        CONST_VTBL struct IWMDMStorage2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDMStorage2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDMStorage2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDMStorage2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDMStorage2_SetAttributes(This,dwAttributes,pFormat)	\
    (This)->lpVtbl -> SetAttributes(This,dwAttributes,pFormat)

#define IWMDMStorage2_GetStorageGlobals(This,ppStorageGlobals)	\
    (This)->lpVtbl -> GetStorageGlobals(This,ppStorageGlobals)

#define IWMDMStorage2_GetAttributes(This,pdwAttributes,pFormat)	\
    (This)->lpVtbl -> GetAttributes(This,pdwAttributes,pFormat)

#define IWMDMStorage2_GetName(This,pwszName,nMaxChars)	\
    (This)->lpVtbl -> GetName(This,pwszName,nMaxChars)

#define IWMDMStorage2_GetDate(This,pDateTimeUTC)	\
    (This)->lpVtbl -> GetDate(This,pDateTimeUTC)

#define IWMDMStorage2_GetSize(This,pdwSizeLow,pdwSizeHigh)	\
    (This)->lpVtbl -> GetSize(This,pdwSizeLow,pdwSizeHigh)

#define IWMDMStorage2_GetRights(This,ppRights,pnRightsCount,abMac)	\
    (This)->lpVtbl -> GetRights(This,ppRights,pnRightsCount,abMac)

#define IWMDMStorage2_EnumStorage(This,pEnumStorage)	\
    (This)->lpVtbl -> EnumStorage(This,pEnumStorage)

#define IWMDMStorage2_SendOpaqueCommand(This,pCommand)	\
    (This)->lpVtbl -> SendOpaqueCommand(This,pCommand)


#define IWMDMStorage2_GetStorage(This,pszStorageName,ppStorage)	\
    (This)->lpVtbl -> GetStorage(This,pszStorageName,ppStorage)

#define IWMDMStorage2_SetAttributes2(This,dwAttributes,dwAttributesEx,pFormat,pVideoFormat)	\
    (This)->lpVtbl -> SetAttributes2(This,dwAttributes,dwAttributesEx,pFormat,pVideoFormat)

#define IWMDMStorage2_GetAttributes2(This,pdwAttributes,pdwAttributesEx,pAudioFormat,pVideoFormat)	\
    (This)->lpVtbl -> GetAttributes2(This,pdwAttributes,pdwAttributesEx,pAudioFormat,pVideoFormat)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDMStorage2_GetStorage_Proxy( 
    IWMDMStorage2 __RPC_FAR * This,
    /* [string][in] */ LPCWSTR pszStorageName,
    /* [out] */ IWMDMStorage __RPC_FAR *__RPC_FAR *ppStorage);


void __RPC_STUB IWMDMStorage2_GetStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMStorage2_SetAttributes2_Proxy( 
    IWMDMStorage2 __RPC_FAR * This,
    /* [in] */ DWORD dwAttributes,
    /* [in] */ DWORD dwAttributesEx,
    /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat,
    /* [in] */ _VIDEOINFOHEADER __RPC_FAR *pVideoFormat);


void __RPC_STUB IWMDMStorage2_SetAttributes2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMStorage2_GetAttributes2_Proxy( 
    IWMDMStorage2 __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwAttributes,
    /* [out] */ DWORD __RPC_FAR *pdwAttributesEx,
    /* [out] */ _WAVEFORMATEX __RPC_FAR *pAudioFormat,
    /* [out] */ _VIDEOINFOHEADER __RPC_FAR *pVideoFormat);


void __RPC_STUB IWMDMStorage2_GetAttributes2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDMStorage2_INTERFACE_DEFINED__ */


#ifndef __IWMDMOperation_INTERFACE_DEFINED__
#define __IWMDMOperation_INTERFACE_DEFINED__

/* interface IWMDMOperation */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IWMDMOperation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A0B-33ED-11d3-8470-00C04F79DBC0")
    IWMDMOperation : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BeginRead( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginWrite( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectName( 
            /* [size_is][string][out] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetObjectName( 
            /* [size_is][string][in] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectAttributes( 
            /* [out] */ DWORD __RPC_FAR *pdwAttributes,
            /* [out] */ _WAVEFORMATEX __RPC_FAR *pFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetObjectAttributes( 
            /* [in] */ DWORD dwAttributes,
            /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectTotalSize( 
            /* [out] */ DWORD __RPC_FAR *pdwSize,
            /* [out] */ DWORD __RPC_FAR *pdwSizeHigh) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetObjectTotalSize( 
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwSizeHigh) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TransferObjectData( 
            /* [size_is][out][in] */ BYTE __RPC_FAR *pData,
            /* [out][in] */ DWORD __RPC_FAR *pdwSize,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE End( 
            /* [in] */ HRESULT __RPC_FAR *phCompletionCode,
            /* [in] */ IUnknown __RPC_FAR *pNewObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDMOperationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDMOperation __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDMOperation __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDMOperation __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginRead )( 
            IWMDMOperation __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginWrite )( 
            IWMDMOperation __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectName )( 
            IWMDMOperation __RPC_FAR * This,
            /* [size_is][string][out] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetObjectName )( 
            IWMDMOperation __RPC_FAR * This,
            /* [size_is][string][in] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectAttributes )( 
            IWMDMOperation __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwAttributes,
            /* [out] */ _WAVEFORMATEX __RPC_FAR *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetObjectAttributes )( 
            IWMDMOperation __RPC_FAR * This,
            /* [in] */ DWORD dwAttributes,
            /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectTotalSize )( 
            IWMDMOperation __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwSize,
            /* [out] */ DWORD __RPC_FAR *pdwSizeHigh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetObjectTotalSize )( 
            IWMDMOperation __RPC_FAR * This,
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwSizeHigh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TransferObjectData )( 
            IWMDMOperation __RPC_FAR * This,
            /* [size_is][out][in] */ BYTE __RPC_FAR *pData,
            /* [out][in] */ DWORD __RPC_FAR *pdwSize,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *End )( 
            IWMDMOperation __RPC_FAR * This,
            /* [in] */ HRESULT __RPC_FAR *phCompletionCode,
            /* [in] */ IUnknown __RPC_FAR *pNewObject);
        
        END_INTERFACE
    } IWMDMOperationVtbl;

    interface IWMDMOperation
    {
        CONST_VTBL struct IWMDMOperationVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDMOperation_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDMOperation_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDMOperation_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDMOperation_BeginRead(This)	\
    (This)->lpVtbl -> BeginRead(This)

#define IWMDMOperation_BeginWrite(This)	\
    (This)->lpVtbl -> BeginWrite(This)

#define IWMDMOperation_GetObjectName(This,pwszName,nMaxChars)	\
    (This)->lpVtbl -> GetObjectName(This,pwszName,nMaxChars)

#define IWMDMOperation_SetObjectName(This,pwszName,nMaxChars)	\
    (This)->lpVtbl -> SetObjectName(This,pwszName,nMaxChars)

#define IWMDMOperation_GetObjectAttributes(This,pdwAttributes,pFormat)	\
    (This)->lpVtbl -> GetObjectAttributes(This,pdwAttributes,pFormat)

#define IWMDMOperation_SetObjectAttributes(This,dwAttributes,pFormat)	\
    (This)->lpVtbl -> SetObjectAttributes(This,dwAttributes,pFormat)

#define IWMDMOperation_GetObjectTotalSize(This,pdwSize,pdwSizeHigh)	\
    (This)->lpVtbl -> GetObjectTotalSize(This,pdwSize,pdwSizeHigh)

#define IWMDMOperation_SetObjectTotalSize(This,dwSize,dwSizeHigh)	\
    (This)->lpVtbl -> SetObjectTotalSize(This,dwSize,dwSizeHigh)

#define IWMDMOperation_TransferObjectData(This,pData,pdwSize,abMac)	\
    (This)->lpVtbl -> TransferObjectData(This,pData,pdwSize,abMac)

#define IWMDMOperation_End(This,phCompletionCode,pNewObject)	\
    (This)->lpVtbl -> End(This,phCompletionCode,pNewObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDMOperation_BeginRead_Proxy( 
    IWMDMOperation __RPC_FAR * This);


void __RPC_STUB IWMDMOperation_BeginRead_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMOperation_BeginWrite_Proxy( 
    IWMDMOperation __RPC_FAR * This);


void __RPC_STUB IWMDMOperation_BeginWrite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMOperation_GetObjectName_Proxy( 
    IWMDMOperation __RPC_FAR * This,
    /* [size_is][string][out] */ LPWSTR pwszName,
    /* [in] */ UINT nMaxChars);


void __RPC_STUB IWMDMOperation_GetObjectName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMOperation_SetObjectName_Proxy( 
    IWMDMOperation __RPC_FAR * This,
    /* [size_is][string][in] */ LPWSTR pwszName,
    /* [in] */ UINT nMaxChars);


void __RPC_STUB IWMDMOperation_SetObjectName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMOperation_GetObjectAttributes_Proxy( 
    IWMDMOperation __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwAttributes,
    /* [out] */ _WAVEFORMATEX __RPC_FAR *pFormat);


void __RPC_STUB IWMDMOperation_GetObjectAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMOperation_SetObjectAttributes_Proxy( 
    IWMDMOperation __RPC_FAR * This,
    /* [in] */ DWORD dwAttributes,
    /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat);


void __RPC_STUB IWMDMOperation_SetObjectAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMOperation_GetObjectTotalSize_Proxy( 
    IWMDMOperation __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwSize,
    /* [out] */ DWORD __RPC_FAR *pdwSizeHigh);


void __RPC_STUB IWMDMOperation_GetObjectTotalSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMOperation_SetObjectTotalSize_Proxy( 
    IWMDMOperation __RPC_FAR * This,
    /* [in] */ DWORD dwSize,
    /* [in] */ DWORD dwSizeHigh);


void __RPC_STUB IWMDMOperation_SetObjectTotalSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMOperation_TransferObjectData_Proxy( 
    IWMDMOperation __RPC_FAR * This,
    /* [size_is][out][in] */ BYTE __RPC_FAR *pData,
    /* [out][in] */ DWORD __RPC_FAR *pdwSize,
    /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);


void __RPC_STUB IWMDMOperation_TransferObjectData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMOperation_End_Proxy( 
    IWMDMOperation __RPC_FAR * This,
    /* [in] */ HRESULT __RPC_FAR *phCompletionCode,
    /* [in] */ IUnknown __RPC_FAR *pNewObject);


void __RPC_STUB IWMDMOperation_End_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDMOperation_INTERFACE_DEFINED__ */


#ifndef __IWMDMOperation2_INTERFACE_DEFINED__
#define __IWMDMOperation2_INTERFACE_DEFINED__

/* interface IWMDMOperation2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IWMDMOperation2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("33445B48-7DF7-425c-AD8F-0FC6D82F9F75")
    IWMDMOperation2 : public IWMDMOperation
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetObjectAttributes2( 
            /* [in] */ DWORD dwAttributes,
            /* [in] */ DWORD dwAttributesEx,
            /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat,
            /* [in] */ _VIDEOINFOHEADER __RPC_FAR *pVideoFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectAttributes2( 
            /* [out] */ DWORD __RPC_FAR *pdwAttributes,
            /* [out] */ DWORD __RPC_FAR *pdwAttributesEx,
            /* [out] */ _WAVEFORMATEX __RPC_FAR *pAudioFormat,
            /* [out] */ _VIDEOINFOHEADER __RPC_FAR *pVideoFormat) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDMOperation2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDMOperation2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDMOperation2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDMOperation2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginRead )( 
            IWMDMOperation2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginWrite )( 
            IWMDMOperation2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectName )( 
            IWMDMOperation2 __RPC_FAR * This,
            /* [size_is][string][out] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetObjectName )( 
            IWMDMOperation2 __RPC_FAR * This,
            /* [size_is][string][in] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectAttributes )( 
            IWMDMOperation2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwAttributes,
            /* [out] */ _WAVEFORMATEX __RPC_FAR *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetObjectAttributes )( 
            IWMDMOperation2 __RPC_FAR * This,
            /* [in] */ DWORD dwAttributes,
            /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectTotalSize )( 
            IWMDMOperation2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwSize,
            /* [out] */ DWORD __RPC_FAR *pdwSizeHigh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetObjectTotalSize )( 
            IWMDMOperation2 __RPC_FAR * This,
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwSizeHigh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TransferObjectData )( 
            IWMDMOperation2 __RPC_FAR * This,
            /* [size_is][out][in] */ BYTE __RPC_FAR *pData,
            /* [out][in] */ DWORD __RPC_FAR *pdwSize,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *End )( 
            IWMDMOperation2 __RPC_FAR * This,
            /* [in] */ HRESULT __RPC_FAR *phCompletionCode,
            /* [in] */ IUnknown __RPC_FAR *pNewObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetObjectAttributes2 )( 
            IWMDMOperation2 __RPC_FAR * This,
            /* [in] */ DWORD dwAttributes,
            /* [in] */ DWORD dwAttributesEx,
            /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat,
            /* [in] */ _VIDEOINFOHEADER __RPC_FAR *pVideoFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectAttributes2 )( 
            IWMDMOperation2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwAttributes,
            /* [out] */ DWORD __RPC_FAR *pdwAttributesEx,
            /* [out] */ _WAVEFORMATEX __RPC_FAR *pAudioFormat,
            /* [out] */ _VIDEOINFOHEADER __RPC_FAR *pVideoFormat);
        
        END_INTERFACE
    } IWMDMOperation2Vtbl;

    interface IWMDMOperation2
    {
        CONST_VTBL struct IWMDMOperation2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDMOperation2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDMOperation2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDMOperation2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDMOperation2_BeginRead(This)	\
    (This)->lpVtbl -> BeginRead(This)

#define IWMDMOperation2_BeginWrite(This)	\
    (This)->lpVtbl -> BeginWrite(This)

#define IWMDMOperation2_GetObjectName(This,pwszName,nMaxChars)	\
    (This)->lpVtbl -> GetObjectName(This,pwszName,nMaxChars)

#define IWMDMOperation2_SetObjectName(This,pwszName,nMaxChars)	\
    (This)->lpVtbl -> SetObjectName(This,pwszName,nMaxChars)

#define IWMDMOperation2_GetObjectAttributes(This,pdwAttributes,pFormat)	\
    (This)->lpVtbl -> GetObjectAttributes(This,pdwAttributes,pFormat)

#define IWMDMOperation2_SetObjectAttributes(This,dwAttributes,pFormat)	\
    (This)->lpVtbl -> SetObjectAttributes(This,dwAttributes,pFormat)

#define IWMDMOperation2_GetObjectTotalSize(This,pdwSize,pdwSizeHigh)	\
    (This)->lpVtbl -> GetObjectTotalSize(This,pdwSize,pdwSizeHigh)

#define IWMDMOperation2_SetObjectTotalSize(This,dwSize,dwSizeHigh)	\
    (This)->lpVtbl -> SetObjectTotalSize(This,dwSize,dwSizeHigh)

#define IWMDMOperation2_TransferObjectData(This,pData,pdwSize,abMac)	\
    (This)->lpVtbl -> TransferObjectData(This,pData,pdwSize,abMac)

#define IWMDMOperation2_End(This,phCompletionCode,pNewObject)	\
    (This)->lpVtbl -> End(This,phCompletionCode,pNewObject)


#define IWMDMOperation2_SetObjectAttributes2(This,dwAttributes,dwAttributesEx,pFormat,pVideoFormat)	\
    (This)->lpVtbl -> SetObjectAttributes2(This,dwAttributes,dwAttributesEx,pFormat,pVideoFormat)

#define IWMDMOperation2_GetObjectAttributes2(This,pdwAttributes,pdwAttributesEx,pAudioFormat,pVideoFormat)	\
    (This)->lpVtbl -> GetObjectAttributes2(This,pdwAttributes,pdwAttributesEx,pAudioFormat,pVideoFormat)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDMOperation2_SetObjectAttributes2_Proxy( 
    IWMDMOperation2 __RPC_FAR * This,
    /* [in] */ DWORD dwAttributes,
    /* [in] */ DWORD dwAttributesEx,
    /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat,
    /* [in] */ _VIDEOINFOHEADER __RPC_FAR *pVideoFormat);


void __RPC_STUB IWMDMOperation2_SetObjectAttributes2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMOperation2_GetObjectAttributes2_Proxy( 
    IWMDMOperation2 __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwAttributes,
    /* [out] */ DWORD __RPC_FAR *pdwAttributesEx,
    /* [out] */ _WAVEFORMATEX __RPC_FAR *pAudioFormat,
    /* [out] */ _VIDEOINFOHEADER __RPC_FAR *pVideoFormat);


void __RPC_STUB IWMDMOperation2_GetObjectAttributes2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDMOperation2_INTERFACE_DEFINED__ */


#ifndef __IWMDMProgress_INTERFACE_DEFINED__
#define __IWMDMProgress_INTERFACE_DEFINED__

/* interface IWMDMProgress */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IWMDMProgress;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A0C-33ED-11d3-8470-00C04F79DBC0")
    IWMDMProgress : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Begin( 
            /* [in] */ DWORD dwEstimatedTicks) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Progress( 
            /* [in] */ DWORD dwTranspiredTicks) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE End( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDMProgressVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDMProgress __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDMProgress __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDMProgress __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Begin )( 
            IWMDMProgress __RPC_FAR * This,
            /* [in] */ DWORD dwEstimatedTicks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Progress )( 
            IWMDMProgress __RPC_FAR * This,
            /* [in] */ DWORD dwTranspiredTicks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *End )( 
            IWMDMProgress __RPC_FAR * This);
        
        END_INTERFACE
    } IWMDMProgressVtbl;

    interface IWMDMProgress
    {
        CONST_VTBL struct IWMDMProgressVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDMProgress_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDMProgress_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDMProgress_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDMProgress_Begin(This,dwEstimatedTicks)	\
    (This)->lpVtbl -> Begin(This,dwEstimatedTicks)

#define IWMDMProgress_Progress(This,dwTranspiredTicks)	\
    (This)->lpVtbl -> Progress(This,dwTranspiredTicks)

#define IWMDMProgress_End(This)	\
    (This)->lpVtbl -> End(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDMProgress_Begin_Proxy( 
    IWMDMProgress __RPC_FAR * This,
    /* [in] */ DWORD dwEstimatedTicks);


void __RPC_STUB IWMDMProgress_Begin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMProgress_Progress_Proxy( 
    IWMDMProgress __RPC_FAR * This,
    /* [in] */ DWORD dwTranspiredTicks);


void __RPC_STUB IWMDMProgress_Progress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMProgress_End_Proxy( 
    IWMDMProgress __RPC_FAR * This);


void __RPC_STUB IWMDMProgress_End_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDMProgress_INTERFACE_DEFINED__ */


#ifndef __IWMDMProgress2_INTERFACE_DEFINED__
#define __IWMDMProgress2_INTERFACE_DEFINED__

/* interface IWMDMProgress2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IWMDMProgress2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3A43F550-B383-4e92-B04A-E6BBC660FEFC")
    IWMDMProgress2 : public IWMDMProgress
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE End2( 
            /* [in] */ HRESULT hrCompletionCode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDMProgress2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDMProgress2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDMProgress2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDMProgress2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Begin )( 
            IWMDMProgress2 __RPC_FAR * This,
            /* [in] */ DWORD dwEstimatedTicks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Progress )( 
            IWMDMProgress2 __RPC_FAR * This,
            /* [in] */ DWORD dwTranspiredTicks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *End )( 
            IWMDMProgress2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *End2 )( 
            IWMDMProgress2 __RPC_FAR * This,
            /* [in] */ HRESULT hrCompletionCode);
        
        END_INTERFACE
    } IWMDMProgress2Vtbl;

    interface IWMDMProgress2
    {
        CONST_VTBL struct IWMDMProgress2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDMProgress2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDMProgress2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDMProgress2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDMProgress2_Begin(This,dwEstimatedTicks)	\
    (This)->lpVtbl -> Begin(This,dwEstimatedTicks)

#define IWMDMProgress2_Progress(This,dwTranspiredTicks)	\
    (This)->lpVtbl -> Progress(This,dwTranspiredTicks)

#define IWMDMProgress2_End(This)	\
    (This)->lpVtbl -> End(This)


#define IWMDMProgress2_End2(This,hrCompletionCode)	\
    (This)->lpVtbl -> End2(This,hrCompletionCode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDMProgress2_End2_Proxy( 
    IWMDMProgress2 __RPC_FAR * This,
    /* [in] */ HRESULT hrCompletionCode);


void __RPC_STUB IWMDMProgress2_End2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDMProgress2_INTERFACE_DEFINED__ */


#ifndef __IWMDMDevice_INTERFACE_DEFINED__
#define __IWMDMDevice_INTERFACE_DEFINED__

/* interface IWMDMDevice */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IWMDMDevice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A02-33ED-11d3-8470-00C04F79DBC0")
    IWMDMDevice : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [size_is][string][out] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetManufacturer( 
            /* [size_is][string][out] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersion( 
            /* [out] */ DWORD __RPC_FAR *pdwVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ DWORD __RPC_FAR *pdwType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSerialNumber( 
            /* [out] */ PWMDMID pSerialNumber,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPowerSource( 
            /* [out] */ DWORD __RPC_FAR *pdwPowerSource,
            /* [out] */ DWORD __RPC_FAR *pdwPercentRemaining) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ DWORD __RPC_FAR *pdwStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeviceIcon( 
            /* [out] */ ULONG __RPC_FAR *hIcon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumStorage( 
            /* [out] */ IWMDMEnumStorage __RPC_FAR *__RPC_FAR *ppEnumStorage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFormatSupport( 
            /* [size_is][size_is][out] */ _WAVEFORMATEX __RPC_FAR *__RPC_FAR *ppFormatEx,
            /* [out] */ UINT __RPC_FAR *pnFormatCount,
            /* [size_is][size_is][out] */ LPWSTR __RPC_FAR *__RPC_FAR *pppwszMimeType,
            /* [out] */ UINT __RPC_FAR *pnMimeTypeCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendOpaqueCommand( 
            /* [out][in] */ OPAQUECOMMAND __RPC_FAR *pCommand) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDMDeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDMDevice __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDMDevice __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDMDevice __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IWMDMDevice __RPC_FAR * This,
            /* [size_is][string][out] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetManufacturer )( 
            IWMDMDevice __RPC_FAR * This,
            /* [size_is][string][out] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVersion )( 
            IWMDMDevice __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwVersion);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IWMDMDevice __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSerialNumber )( 
            IWMDMDevice __RPC_FAR * This,
            /* [out] */ PWMDMID pSerialNumber,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPowerSource )( 
            IWMDMDevice __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwPowerSource,
            /* [out] */ DWORD __RPC_FAR *pdwPercentRemaining);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatus )( 
            IWMDMDevice __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDeviceIcon )( 
            IWMDMDevice __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *hIcon);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumStorage )( 
            IWMDMDevice __RPC_FAR * This,
            /* [out] */ IWMDMEnumStorage __RPC_FAR *__RPC_FAR *ppEnumStorage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFormatSupport )( 
            IWMDMDevice __RPC_FAR * This,
            /* [size_is][size_is][out] */ _WAVEFORMATEX __RPC_FAR *__RPC_FAR *ppFormatEx,
            /* [out] */ UINT __RPC_FAR *pnFormatCount,
            /* [size_is][size_is][out] */ LPWSTR __RPC_FAR *__RPC_FAR *pppwszMimeType,
            /* [out] */ UINT __RPC_FAR *pnMimeTypeCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendOpaqueCommand )( 
            IWMDMDevice __RPC_FAR * This,
            /* [out][in] */ OPAQUECOMMAND __RPC_FAR *pCommand);
        
        END_INTERFACE
    } IWMDMDeviceVtbl;

    interface IWMDMDevice
    {
        CONST_VTBL struct IWMDMDeviceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDMDevice_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDMDevice_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDMDevice_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDMDevice_GetName(This,pwszName,nMaxChars)	\
    (This)->lpVtbl -> GetName(This,pwszName,nMaxChars)

#define IWMDMDevice_GetManufacturer(This,pwszName,nMaxChars)	\
    (This)->lpVtbl -> GetManufacturer(This,pwszName,nMaxChars)

#define IWMDMDevice_GetVersion(This,pdwVersion)	\
    (This)->lpVtbl -> GetVersion(This,pdwVersion)

#define IWMDMDevice_GetType(This,pdwType)	\
    (This)->lpVtbl -> GetType(This,pdwType)

#define IWMDMDevice_GetSerialNumber(This,pSerialNumber,abMac)	\
    (This)->lpVtbl -> GetSerialNumber(This,pSerialNumber,abMac)

#define IWMDMDevice_GetPowerSource(This,pdwPowerSource,pdwPercentRemaining)	\
    (This)->lpVtbl -> GetPowerSource(This,pdwPowerSource,pdwPercentRemaining)

#define IWMDMDevice_GetStatus(This,pdwStatus)	\
    (This)->lpVtbl -> GetStatus(This,pdwStatus)

#define IWMDMDevice_GetDeviceIcon(This,hIcon)	\
    (This)->lpVtbl -> GetDeviceIcon(This,hIcon)

#define IWMDMDevice_EnumStorage(This,ppEnumStorage)	\
    (This)->lpVtbl -> EnumStorage(This,ppEnumStorage)

#define IWMDMDevice_GetFormatSupport(This,ppFormatEx,pnFormatCount,pppwszMimeType,pnMimeTypeCount)	\
    (This)->lpVtbl -> GetFormatSupport(This,ppFormatEx,pnFormatCount,pppwszMimeType,pnMimeTypeCount)

#define IWMDMDevice_SendOpaqueCommand(This,pCommand)	\
    (This)->lpVtbl -> SendOpaqueCommand(This,pCommand)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDMDevice_GetName_Proxy( 
    IWMDMDevice __RPC_FAR * This,
    /* [size_is][string][out] */ LPWSTR pwszName,
    /* [in] */ UINT nMaxChars);


void __RPC_STUB IWMDMDevice_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMDevice_GetManufacturer_Proxy( 
    IWMDMDevice __RPC_FAR * This,
    /* [size_is][string][out] */ LPWSTR pwszName,
    /* [in] */ UINT nMaxChars);


void __RPC_STUB IWMDMDevice_GetManufacturer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMDevice_GetVersion_Proxy( 
    IWMDMDevice __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwVersion);


void __RPC_STUB IWMDMDevice_GetVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMDevice_GetType_Proxy( 
    IWMDMDevice __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwType);


void __RPC_STUB IWMDMDevice_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMDevice_GetSerialNumber_Proxy( 
    IWMDMDevice __RPC_FAR * This,
    /* [out] */ PWMDMID pSerialNumber,
    /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);


void __RPC_STUB IWMDMDevice_GetSerialNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMDevice_GetPowerSource_Proxy( 
    IWMDMDevice __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwPowerSource,
    /* [out] */ DWORD __RPC_FAR *pdwPercentRemaining);


void __RPC_STUB IWMDMDevice_GetPowerSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMDevice_GetStatus_Proxy( 
    IWMDMDevice __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwStatus);


void __RPC_STUB IWMDMDevice_GetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMDevice_GetDeviceIcon_Proxy( 
    IWMDMDevice __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *hIcon);


void __RPC_STUB IWMDMDevice_GetDeviceIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMDevice_EnumStorage_Proxy( 
    IWMDMDevice __RPC_FAR * This,
    /* [out] */ IWMDMEnumStorage __RPC_FAR *__RPC_FAR *ppEnumStorage);


void __RPC_STUB IWMDMDevice_EnumStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMDevice_GetFormatSupport_Proxy( 
    IWMDMDevice __RPC_FAR * This,
    /* [size_is][size_is][out] */ _WAVEFORMATEX __RPC_FAR *__RPC_FAR *ppFormatEx,
    /* [out] */ UINT __RPC_FAR *pnFormatCount,
    /* [size_is][size_is][out] */ LPWSTR __RPC_FAR *__RPC_FAR *pppwszMimeType,
    /* [out] */ UINT __RPC_FAR *pnMimeTypeCount);


void __RPC_STUB IWMDMDevice_GetFormatSupport_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMDevice_SendOpaqueCommand_Proxy( 
    IWMDMDevice __RPC_FAR * This,
    /* [out][in] */ OPAQUECOMMAND __RPC_FAR *pCommand);


void __RPC_STUB IWMDMDevice_SendOpaqueCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDMDevice_INTERFACE_DEFINED__ */


#ifndef __IWMDMDevice2_INTERFACE_DEFINED__
#define __IWMDMDevice2_INTERFACE_DEFINED__

/* interface IWMDMDevice2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IWMDMDevice2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E34F3D37-9D67-4fc1-9252-62D28B2F8B55")
    IWMDMDevice2 : public IWMDMDevice
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStorage( 
            /* [string][in] */ LPCWSTR pszStorageName,
            /* [out] */ IWMDMStorage __RPC_FAR *__RPC_FAR *ppStorage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFormatSupport2( 
            /* [in] */ DWORD dwFlags,
            /* [size_is][size_is][out] */ _WAVEFORMATEX __RPC_FAR *__RPC_FAR *ppAudioFormatEx,
            /* [ref][out] */ UINT __RPC_FAR *pnAudioFormatCount,
            /* [size_is][size_is][out] */ _VIDEOINFOHEADER __RPC_FAR *__RPC_FAR *ppVideoFormatEx,
            /* [ref][out] */ UINT __RPC_FAR *pnVideoFormatCount,
            /* [size_is][size_is][out] */ WMFILECAPABILITIES __RPC_FAR *__RPC_FAR *ppFileType,
            /* [ref][out] */ UINT __RPC_FAR *pnFileTypeCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSpecifyPropertyPages( 
            /* [ref][out] */ ISpecifyPropertyPages __RPC_FAR *__RPC_FAR *ppSpecifyPropPages,
            /* [size_is][size_is][ref][out] */ IUnknown __RPC_FAR *__RPC_FAR *__RPC_FAR *pppUnknowns,
            /* [ref][out] */ ULONG __RPC_FAR *pcUnks) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPnPName( 
            /* [size_is][out] */ LPWSTR pwszPnPName,
            /* [in] */ UINT nMaxChars) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDMDevice2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDMDevice2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDMDevice2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDMDevice2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IWMDMDevice2 __RPC_FAR * This,
            /* [size_is][string][out] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetManufacturer )( 
            IWMDMDevice2 __RPC_FAR * This,
            /* [size_is][string][out] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVersion )( 
            IWMDMDevice2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwVersion);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IWMDMDevice2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSerialNumber )( 
            IWMDMDevice2 __RPC_FAR * This,
            /* [out] */ PWMDMID pSerialNumber,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPowerSource )( 
            IWMDMDevice2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwPowerSource,
            /* [out] */ DWORD __RPC_FAR *pdwPercentRemaining);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatus )( 
            IWMDMDevice2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDeviceIcon )( 
            IWMDMDevice2 __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *hIcon);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumStorage )( 
            IWMDMDevice2 __RPC_FAR * This,
            /* [out] */ IWMDMEnumStorage __RPC_FAR *__RPC_FAR *ppEnumStorage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFormatSupport )( 
            IWMDMDevice2 __RPC_FAR * This,
            /* [size_is][size_is][out] */ _WAVEFORMATEX __RPC_FAR *__RPC_FAR *ppFormatEx,
            /* [out] */ UINT __RPC_FAR *pnFormatCount,
            /* [size_is][size_is][out] */ LPWSTR __RPC_FAR *__RPC_FAR *pppwszMimeType,
            /* [out] */ UINT __RPC_FAR *pnMimeTypeCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendOpaqueCommand )( 
            IWMDMDevice2 __RPC_FAR * This,
            /* [out][in] */ OPAQUECOMMAND __RPC_FAR *pCommand);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStorage )( 
            IWMDMDevice2 __RPC_FAR * This,
            /* [string][in] */ LPCWSTR pszStorageName,
            /* [out] */ IWMDMStorage __RPC_FAR *__RPC_FAR *ppStorage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFormatSupport2 )( 
            IWMDMDevice2 __RPC_FAR * This,
            /* [in] */ DWORD dwFlags,
            /* [size_is][size_is][out] */ _WAVEFORMATEX __RPC_FAR *__RPC_FAR *ppAudioFormatEx,
            /* [ref][out] */ UINT __RPC_FAR *pnAudioFormatCount,
            /* [size_is][size_is][out] */ _VIDEOINFOHEADER __RPC_FAR *__RPC_FAR *ppVideoFormatEx,
            /* [ref][out] */ UINT __RPC_FAR *pnVideoFormatCount,
            /* [size_is][size_is][out] */ WMFILECAPABILITIES __RPC_FAR *__RPC_FAR *ppFileType,
            /* [ref][out] */ UINT __RPC_FAR *pnFileTypeCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSpecifyPropertyPages )( 
            IWMDMDevice2 __RPC_FAR * This,
            /* [ref][out] */ ISpecifyPropertyPages __RPC_FAR *__RPC_FAR *ppSpecifyPropPages,
            /* [size_is][size_is][ref][out] */ IUnknown __RPC_FAR *__RPC_FAR *__RPC_FAR *pppUnknowns,
            /* [ref][out] */ ULONG __RPC_FAR *pcUnks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPnPName )( 
            IWMDMDevice2 __RPC_FAR * This,
            /* [size_is][out] */ LPWSTR pwszPnPName,
            /* [in] */ UINT nMaxChars);
        
        END_INTERFACE
    } IWMDMDevice2Vtbl;

    interface IWMDMDevice2
    {
        CONST_VTBL struct IWMDMDevice2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDMDevice2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDMDevice2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDMDevice2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDMDevice2_GetName(This,pwszName,nMaxChars)	\
    (This)->lpVtbl -> GetName(This,pwszName,nMaxChars)

#define IWMDMDevice2_GetManufacturer(This,pwszName,nMaxChars)	\
    (This)->lpVtbl -> GetManufacturer(This,pwszName,nMaxChars)

#define IWMDMDevice2_GetVersion(This,pdwVersion)	\
    (This)->lpVtbl -> GetVersion(This,pdwVersion)

#define IWMDMDevice2_GetType(This,pdwType)	\
    (This)->lpVtbl -> GetType(This,pdwType)

#define IWMDMDevice2_GetSerialNumber(This,pSerialNumber,abMac)	\
    (This)->lpVtbl -> GetSerialNumber(This,pSerialNumber,abMac)

#define IWMDMDevice2_GetPowerSource(This,pdwPowerSource,pdwPercentRemaining)	\
    (This)->lpVtbl -> GetPowerSource(This,pdwPowerSource,pdwPercentRemaining)

#define IWMDMDevice2_GetStatus(This,pdwStatus)	\
    (This)->lpVtbl -> GetStatus(This,pdwStatus)

#define IWMDMDevice2_GetDeviceIcon(This,hIcon)	\
    (This)->lpVtbl -> GetDeviceIcon(This,hIcon)

#define IWMDMDevice2_EnumStorage(This,ppEnumStorage)	\
    (This)->lpVtbl -> EnumStorage(This,ppEnumStorage)

#define IWMDMDevice2_GetFormatSupport(This,ppFormatEx,pnFormatCount,pppwszMimeType,pnMimeTypeCount)	\
    (This)->lpVtbl -> GetFormatSupport(This,ppFormatEx,pnFormatCount,pppwszMimeType,pnMimeTypeCount)

#define IWMDMDevice2_SendOpaqueCommand(This,pCommand)	\
    (This)->lpVtbl -> SendOpaqueCommand(This,pCommand)


#define IWMDMDevice2_GetStorage(This,pszStorageName,ppStorage)	\
    (This)->lpVtbl -> GetStorage(This,pszStorageName,ppStorage)

#define IWMDMDevice2_GetFormatSupport2(This,dwFlags,ppAudioFormatEx,pnAudioFormatCount,ppVideoFormatEx,pnVideoFormatCount,ppFileType,pnFileTypeCount)	\
    (This)->lpVtbl -> GetFormatSupport2(This,dwFlags,ppAudioFormatEx,pnAudioFormatCount,ppVideoFormatEx,pnVideoFormatCount,ppFileType,pnFileTypeCount)

#define IWMDMDevice2_GetSpecifyPropertyPages(This,ppSpecifyPropPages,pppUnknowns,pcUnks)	\
    (This)->lpVtbl -> GetSpecifyPropertyPages(This,ppSpecifyPropPages,pppUnknowns,pcUnks)

#define IWMDMDevice2_GetPnPName(This,pwszPnPName,nMaxChars)	\
    (This)->lpVtbl -> GetPnPName(This,pwszPnPName,nMaxChars)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDMDevice2_GetStorage_Proxy( 
    IWMDMDevice2 __RPC_FAR * This,
    /* [string][in] */ LPCWSTR pszStorageName,
    /* [out] */ IWMDMStorage __RPC_FAR *__RPC_FAR *ppStorage);


void __RPC_STUB IWMDMDevice2_GetStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMDevice2_GetFormatSupport2_Proxy( 
    IWMDMDevice2 __RPC_FAR * This,
    /* [in] */ DWORD dwFlags,
    /* [size_is][size_is][out] */ _WAVEFORMATEX __RPC_FAR *__RPC_FAR *ppAudioFormatEx,
    /* [ref][out] */ UINT __RPC_FAR *pnAudioFormatCount,
    /* [size_is][size_is][out] */ _VIDEOINFOHEADER __RPC_FAR *__RPC_FAR *ppVideoFormatEx,
    /* [ref][out] */ UINT __RPC_FAR *pnVideoFormatCount,
    /* [size_is][size_is][out] */ WMFILECAPABILITIES __RPC_FAR *__RPC_FAR *ppFileType,
    /* [ref][out] */ UINT __RPC_FAR *pnFileTypeCount);


void __RPC_STUB IWMDMDevice2_GetFormatSupport2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMDevice2_GetSpecifyPropertyPages_Proxy( 
    IWMDMDevice2 __RPC_FAR * This,
    /* [ref][out] */ ISpecifyPropertyPages __RPC_FAR *__RPC_FAR *ppSpecifyPropPages,
    /* [size_is][size_is][ref][out] */ IUnknown __RPC_FAR *__RPC_FAR *__RPC_FAR *pppUnknowns,
    /* [ref][out] */ ULONG __RPC_FAR *pcUnks);


void __RPC_STUB IWMDMDevice2_GetSpecifyPropertyPages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMDevice2_GetPnPName_Proxy( 
    IWMDMDevice2 __RPC_FAR * This,
    /* [size_is][out] */ LPWSTR pwszPnPName,
    /* [in] */ UINT nMaxChars);


void __RPC_STUB IWMDMDevice2_GetPnPName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDMDevice2_INTERFACE_DEFINED__ */


#ifndef __IWMDMEnumDevice_INTERFACE_DEFINED__
#define __IWMDMEnumDevice_INTERFACE_DEFINED__

/* interface IWMDMEnumDevice */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IWMDMEnumDevice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A01-33ED-11d3-8470-00C04F79DBC0")
    IWMDMEnumDevice : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IWMDMDevice __RPC_FAR *__RPC_FAR *ppDevice,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IWMDMEnumDevice __RPC_FAR *__RPC_FAR *ppEnumDevice) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDMEnumDeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDMEnumDevice __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDMEnumDevice __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDMEnumDevice __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IWMDMEnumDevice __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IWMDMDevice __RPC_FAR *__RPC_FAR *ppDevice,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IWMDMEnumDevice __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IWMDMEnumDevice __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IWMDMEnumDevice __RPC_FAR * This,
            /* [out] */ IWMDMEnumDevice __RPC_FAR *__RPC_FAR *ppEnumDevice);
        
        END_INTERFACE
    } IWMDMEnumDeviceVtbl;

    interface IWMDMEnumDevice
    {
        CONST_VTBL struct IWMDMEnumDeviceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDMEnumDevice_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDMEnumDevice_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDMEnumDevice_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDMEnumDevice_Next(This,celt,ppDevice,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,ppDevice,pceltFetched)

#define IWMDMEnumDevice_Skip(This,celt,pceltFetched)	\
    (This)->lpVtbl -> Skip(This,celt,pceltFetched)

#define IWMDMEnumDevice_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IWMDMEnumDevice_Clone(This,ppEnumDevice)	\
    (This)->lpVtbl -> Clone(This,ppEnumDevice)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDMEnumDevice_Next_Proxy( 
    IWMDMEnumDevice __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IWMDMDevice __RPC_FAR *__RPC_FAR *ppDevice,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IWMDMEnumDevice_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMEnumDevice_Skip_Proxy( 
    IWMDMEnumDevice __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IWMDMEnumDevice_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMEnumDevice_Reset_Proxy( 
    IWMDMEnumDevice __RPC_FAR * This);


void __RPC_STUB IWMDMEnumDevice_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMEnumDevice_Clone_Proxy( 
    IWMDMEnumDevice __RPC_FAR * This,
    /* [out] */ IWMDMEnumDevice __RPC_FAR *__RPC_FAR *ppEnumDevice);


void __RPC_STUB IWMDMEnumDevice_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDMEnumDevice_INTERFACE_DEFINED__ */


#ifndef __IWMDMDeviceControl_INTERFACE_DEFINED__
#define __IWMDMDeviceControl_INTERFACE_DEFINED__

/* interface IWMDMDeviceControl */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IWMDMDeviceControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A04-33ED-11d3-8470-00C04F79DBC0")
    IWMDMDeviceControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ DWORD __RPC_FAR *pdwStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCapabilities( 
            /* [out] */ DWORD __RPC_FAR *pdwCapabilitiesMask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Play( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Record( 
            /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Seek( 
            /* [in] */ UINT fuMode,
            /* [in] */ int nOffset) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDMDeviceControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDMDeviceControl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDMDeviceControl __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDMDeviceControl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatus )( 
            IWMDMDeviceControl __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCapabilities )( 
            IWMDMDeviceControl __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwCapabilitiesMask);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Play )( 
            IWMDMDeviceControl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Record )( 
            IWMDMDeviceControl __RPC_FAR * This,
            /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Pause )( 
            IWMDMDeviceControl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Resume )( 
            IWMDMDeviceControl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Stop )( 
            IWMDMDeviceControl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Seek )( 
            IWMDMDeviceControl __RPC_FAR * This,
            /* [in] */ UINT fuMode,
            /* [in] */ int nOffset);
        
        END_INTERFACE
    } IWMDMDeviceControlVtbl;

    interface IWMDMDeviceControl
    {
        CONST_VTBL struct IWMDMDeviceControlVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDMDeviceControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDMDeviceControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDMDeviceControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDMDeviceControl_GetStatus(This,pdwStatus)	\
    (This)->lpVtbl -> GetStatus(This,pdwStatus)

#define IWMDMDeviceControl_GetCapabilities(This,pdwCapabilitiesMask)	\
    (This)->lpVtbl -> GetCapabilities(This,pdwCapabilitiesMask)

#define IWMDMDeviceControl_Play(This)	\
    (This)->lpVtbl -> Play(This)

#define IWMDMDeviceControl_Record(This,pFormat)	\
    (This)->lpVtbl -> Record(This,pFormat)

#define IWMDMDeviceControl_Pause(This)	\
    (This)->lpVtbl -> Pause(This)

#define IWMDMDeviceControl_Resume(This)	\
    (This)->lpVtbl -> Resume(This)

#define IWMDMDeviceControl_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#define IWMDMDeviceControl_Seek(This,fuMode,nOffset)	\
    (This)->lpVtbl -> Seek(This,fuMode,nOffset)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDMDeviceControl_GetStatus_Proxy( 
    IWMDMDeviceControl __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwStatus);


void __RPC_STUB IWMDMDeviceControl_GetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMDeviceControl_GetCapabilities_Proxy( 
    IWMDMDeviceControl __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwCapabilitiesMask);


void __RPC_STUB IWMDMDeviceControl_GetCapabilities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMDeviceControl_Play_Proxy( 
    IWMDMDeviceControl __RPC_FAR * This);


void __RPC_STUB IWMDMDeviceControl_Play_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMDeviceControl_Record_Proxy( 
    IWMDMDeviceControl __RPC_FAR * This,
    /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat);


void __RPC_STUB IWMDMDeviceControl_Record_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMDeviceControl_Pause_Proxy( 
    IWMDMDeviceControl __RPC_FAR * This);


void __RPC_STUB IWMDMDeviceControl_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMDeviceControl_Resume_Proxy( 
    IWMDMDeviceControl __RPC_FAR * This);


void __RPC_STUB IWMDMDeviceControl_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMDeviceControl_Stop_Proxy( 
    IWMDMDeviceControl __RPC_FAR * This);


void __RPC_STUB IWMDMDeviceControl_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMDeviceControl_Seek_Proxy( 
    IWMDMDeviceControl __RPC_FAR * This,
    /* [in] */ UINT fuMode,
    /* [in] */ int nOffset);


void __RPC_STUB IWMDMDeviceControl_Seek_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDMDeviceControl_INTERFACE_DEFINED__ */


#ifndef __IWMDMEnumStorage_INTERFACE_DEFINED__
#define __IWMDMEnumStorage_INTERFACE_DEFINED__

/* interface IWMDMEnumStorage */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IWMDMEnumStorage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A05-33ED-11d3-8470-00C04F79DBC0")
    IWMDMEnumStorage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IWMDMStorage __RPC_FAR *__RPC_FAR *ppStorage,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IWMDMEnumStorage __RPC_FAR *__RPC_FAR *ppEnumStorage) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDMEnumStorageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDMEnumStorage __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDMEnumStorage __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDMEnumStorage __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IWMDMEnumStorage __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IWMDMStorage __RPC_FAR *__RPC_FAR *ppStorage,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IWMDMEnumStorage __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IWMDMEnumStorage __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IWMDMEnumStorage __RPC_FAR * This,
            /* [out] */ IWMDMEnumStorage __RPC_FAR *__RPC_FAR *ppEnumStorage);
        
        END_INTERFACE
    } IWMDMEnumStorageVtbl;

    interface IWMDMEnumStorage
    {
        CONST_VTBL struct IWMDMEnumStorageVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDMEnumStorage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDMEnumStorage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDMEnumStorage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDMEnumStorage_Next(This,celt,ppStorage,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,ppStorage,pceltFetched)

#define IWMDMEnumStorage_Skip(This,celt,pceltFetched)	\
    (This)->lpVtbl -> Skip(This,celt,pceltFetched)

#define IWMDMEnumStorage_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IWMDMEnumStorage_Clone(This,ppEnumStorage)	\
    (This)->lpVtbl -> Clone(This,ppEnumStorage)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDMEnumStorage_Next_Proxy( 
    IWMDMEnumStorage __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IWMDMStorage __RPC_FAR *__RPC_FAR *ppStorage,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IWMDMEnumStorage_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMEnumStorage_Skip_Proxy( 
    IWMDMEnumStorage __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IWMDMEnumStorage_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMEnumStorage_Reset_Proxy( 
    IWMDMEnumStorage __RPC_FAR * This);


void __RPC_STUB IWMDMEnumStorage_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMEnumStorage_Clone_Proxy( 
    IWMDMEnumStorage __RPC_FAR * This,
    /* [out] */ IWMDMEnumStorage __RPC_FAR *__RPC_FAR *ppEnumStorage);


void __RPC_STUB IWMDMEnumStorage_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDMEnumStorage_INTERFACE_DEFINED__ */


#ifndef __IWMDMStorageControl_INTERFACE_DEFINED__
#define __IWMDMStorageControl_INTERFACE_DEFINED__

/* interface IWMDMStorageControl */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IWMDMStorageControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A08-33ED-11d3-8470-00C04F79DBC0")
    IWMDMStorageControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Insert( 
            /* [in] */ UINT fuMode,
            /* [unique][in] */ LPWSTR pwszFile,
            /* [in] */ IWMDMOperation __RPC_FAR *pOperation,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress,
            /* [out] */ IWMDMStorage __RPC_FAR *__RPC_FAR *ppNewObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ UINT fuMode,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Rename( 
            /* [in] */ UINT fuMode,
            /* [in] */ LPWSTR pwszNewName,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Read( 
            /* [in] */ UINT fuMode,
            /* [unique][in] */ LPWSTR pwszFile,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress,
            /* [in] */ IWMDMOperation __RPC_FAR *pOperation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Move( 
            /* [in] */ UINT fuMode,
            /* [in] */ IWMDMStorage __RPC_FAR *pTargetObject,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDMStorageControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDMStorageControl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDMStorageControl __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDMStorageControl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Insert )( 
            IWMDMStorageControl __RPC_FAR * This,
            /* [in] */ UINT fuMode,
            /* [unique][in] */ LPWSTR pwszFile,
            /* [in] */ IWMDMOperation __RPC_FAR *pOperation,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress,
            /* [out] */ IWMDMStorage __RPC_FAR *__RPC_FAR *ppNewObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IWMDMStorageControl __RPC_FAR * This,
            /* [in] */ UINT fuMode,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Rename )( 
            IWMDMStorageControl __RPC_FAR * This,
            /* [in] */ UINT fuMode,
            /* [in] */ LPWSTR pwszNewName,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Read )( 
            IWMDMStorageControl __RPC_FAR * This,
            /* [in] */ UINT fuMode,
            /* [unique][in] */ LPWSTR pwszFile,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress,
            /* [in] */ IWMDMOperation __RPC_FAR *pOperation);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Move )( 
            IWMDMStorageControl __RPC_FAR * This,
            /* [in] */ UINT fuMode,
            /* [in] */ IWMDMStorage __RPC_FAR *pTargetObject,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress);
        
        END_INTERFACE
    } IWMDMStorageControlVtbl;

    interface IWMDMStorageControl
    {
        CONST_VTBL struct IWMDMStorageControlVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDMStorageControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDMStorageControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDMStorageControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDMStorageControl_Insert(This,fuMode,pwszFile,pOperation,pProgress,ppNewObject)	\
    (This)->lpVtbl -> Insert(This,fuMode,pwszFile,pOperation,pProgress,ppNewObject)

#define IWMDMStorageControl_Delete(This,fuMode,pProgress)	\
    (This)->lpVtbl -> Delete(This,fuMode,pProgress)

#define IWMDMStorageControl_Rename(This,fuMode,pwszNewName,pProgress)	\
    (This)->lpVtbl -> Rename(This,fuMode,pwszNewName,pProgress)

#define IWMDMStorageControl_Read(This,fuMode,pwszFile,pProgress,pOperation)	\
    (This)->lpVtbl -> Read(This,fuMode,pwszFile,pProgress,pOperation)

#define IWMDMStorageControl_Move(This,fuMode,pTargetObject,pProgress)	\
    (This)->lpVtbl -> Move(This,fuMode,pTargetObject,pProgress)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDMStorageControl_Insert_Proxy( 
    IWMDMStorageControl __RPC_FAR * This,
    /* [in] */ UINT fuMode,
    /* [unique][in] */ LPWSTR pwszFile,
    /* [in] */ IWMDMOperation __RPC_FAR *pOperation,
    /* [in] */ IWMDMProgress __RPC_FAR *pProgress,
    /* [out] */ IWMDMStorage __RPC_FAR *__RPC_FAR *ppNewObject);


void __RPC_STUB IWMDMStorageControl_Insert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMStorageControl_Delete_Proxy( 
    IWMDMStorageControl __RPC_FAR * This,
    /* [in] */ UINT fuMode,
    /* [in] */ IWMDMProgress __RPC_FAR *pProgress);


void __RPC_STUB IWMDMStorageControl_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMStorageControl_Rename_Proxy( 
    IWMDMStorageControl __RPC_FAR * This,
    /* [in] */ UINT fuMode,
    /* [in] */ LPWSTR pwszNewName,
    /* [in] */ IWMDMProgress __RPC_FAR *pProgress);


void __RPC_STUB IWMDMStorageControl_Rename_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMStorageControl_Read_Proxy( 
    IWMDMStorageControl __RPC_FAR * This,
    /* [in] */ UINT fuMode,
    /* [unique][in] */ LPWSTR pwszFile,
    /* [in] */ IWMDMProgress __RPC_FAR *pProgress,
    /* [in] */ IWMDMOperation __RPC_FAR *pOperation);


void __RPC_STUB IWMDMStorageControl_Read_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMStorageControl_Move_Proxy( 
    IWMDMStorageControl __RPC_FAR * This,
    /* [in] */ UINT fuMode,
    /* [in] */ IWMDMStorage __RPC_FAR *pTargetObject,
    /* [in] */ IWMDMProgress __RPC_FAR *pProgress);


void __RPC_STUB IWMDMStorageControl_Move_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDMStorageControl_INTERFACE_DEFINED__ */


#ifndef __IWMDMStorageControl2_INTERFACE_DEFINED__
#define __IWMDMStorageControl2_INTERFACE_DEFINED__

/* interface IWMDMStorageControl2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IWMDMStorageControl2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("972C2E88-BD6C-4125-8E09-84F837E637B6")
    IWMDMStorageControl2 : public IWMDMStorageControl
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Insert2( 
            /* [in] */ UINT fuMode,
            /* [unique][in] */ LPWSTR pwszFileSource,
            /* [unique][in] */ LPWSTR pwszFileDest,
            /* [in] */ IWMDMOperation __RPC_FAR *pOperation,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress,
            /* [in] */ IUnknown __RPC_FAR *pUnknown,
            /* [unique][out][in] */ IWMDMStorage __RPC_FAR *__RPC_FAR *ppNewObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDMStorageControl2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDMStorageControl2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDMStorageControl2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDMStorageControl2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Insert )( 
            IWMDMStorageControl2 __RPC_FAR * This,
            /* [in] */ UINT fuMode,
            /* [unique][in] */ LPWSTR pwszFile,
            /* [in] */ IWMDMOperation __RPC_FAR *pOperation,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress,
            /* [out] */ IWMDMStorage __RPC_FAR *__RPC_FAR *ppNewObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IWMDMStorageControl2 __RPC_FAR * This,
            /* [in] */ UINT fuMode,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Rename )( 
            IWMDMStorageControl2 __RPC_FAR * This,
            /* [in] */ UINT fuMode,
            /* [in] */ LPWSTR pwszNewName,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Read )( 
            IWMDMStorageControl2 __RPC_FAR * This,
            /* [in] */ UINT fuMode,
            /* [unique][in] */ LPWSTR pwszFile,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress,
            /* [in] */ IWMDMOperation __RPC_FAR *pOperation);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Move )( 
            IWMDMStorageControl2 __RPC_FAR * This,
            /* [in] */ UINT fuMode,
            /* [in] */ IWMDMStorage __RPC_FAR *pTargetObject,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Insert2 )( 
            IWMDMStorageControl2 __RPC_FAR * This,
            /* [in] */ UINT fuMode,
            /* [unique][in] */ LPWSTR pwszFileSource,
            /* [unique][in] */ LPWSTR pwszFileDest,
            /* [in] */ IWMDMOperation __RPC_FAR *pOperation,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress,
            /* [in] */ IUnknown __RPC_FAR *pUnknown,
            /* [unique][out][in] */ IWMDMStorage __RPC_FAR *__RPC_FAR *ppNewObject);
        
        END_INTERFACE
    } IWMDMStorageControl2Vtbl;

    interface IWMDMStorageControl2
    {
        CONST_VTBL struct IWMDMStorageControl2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDMStorageControl2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDMStorageControl2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDMStorageControl2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDMStorageControl2_Insert(This,fuMode,pwszFile,pOperation,pProgress,ppNewObject)	\
    (This)->lpVtbl -> Insert(This,fuMode,pwszFile,pOperation,pProgress,ppNewObject)

#define IWMDMStorageControl2_Delete(This,fuMode,pProgress)	\
    (This)->lpVtbl -> Delete(This,fuMode,pProgress)

#define IWMDMStorageControl2_Rename(This,fuMode,pwszNewName,pProgress)	\
    (This)->lpVtbl -> Rename(This,fuMode,pwszNewName,pProgress)

#define IWMDMStorageControl2_Read(This,fuMode,pwszFile,pProgress,pOperation)	\
    (This)->lpVtbl -> Read(This,fuMode,pwszFile,pProgress,pOperation)

#define IWMDMStorageControl2_Move(This,fuMode,pTargetObject,pProgress)	\
    (This)->lpVtbl -> Move(This,fuMode,pTargetObject,pProgress)


#define IWMDMStorageControl2_Insert2(This,fuMode,pwszFileSource,pwszFileDest,pOperation,pProgress,pUnknown,ppNewObject)	\
    (This)->lpVtbl -> Insert2(This,fuMode,pwszFileSource,pwszFileDest,pOperation,pProgress,pUnknown,ppNewObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDMStorageControl2_Insert2_Proxy( 
    IWMDMStorageControl2 __RPC_FAR * This,
    /* [in] */ UINT fuMode,
    /* [unique][in] */ LPWSTR pwszFileSource,
    /* [unique][in] */ LPWSTR pwszFileDest,
    /* [in] */ IWMDMOperation __RPC_FAR *pOperation,
    /* [in] */ IWMDMProgress __RPC_FAR *pProgress,
    /* [in] */ IUnknown __RPC_FAR *pUnknown,
    /* [unique][out][in] */ IWMDMStorage __RPC_FAR *__RPC_FAR *ppNewObject);


void __RPC_STUB IWMDMStorageControl2_Insert2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDMStorageControl2_INTERFACE_DEFINED__ */


#ifndef __IWMDMObjectInfo_INTERFACE_DEFINED__
#define __IWMDMObjectInfo_INTERFACE_DEFINED__

/* interface IWMDMObjectInfo */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IWMDMObjectInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A09-33ED-11d3-8470-00C04F79DBC0")
    IWMDMObjectInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPlayLength( 
            /* [out] */ DWORD __RPC_FAR *pdwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPlayLength( 
            /* [in] */ DWORD dwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPlayOffset( 
            /* [out] */ DWORD __RPC_FAR *pdwOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPlayOffset( 
            /* [in] */ DWORD dwOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTotalLength( 
            /* [out] */ DWORD __RPC_FAR *pdwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLastPlayPosition( 
            /* [out] */ DWORD __RPC_FAR *pdwLastPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLongestPlayPosition( 
            /* [out] */ DWORD __RPC_FAR *pdwLongestPos) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDMObjectInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDMObjectInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDMObjectInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDMObjectInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPlayLength )( 
            IWMDMObjectInfo __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPlayLength )( 
            IWMDMObjectInfo __RPC_FAR * This,
            /* [in] */ DWORD dwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPlayOffset )( 
            IWMDMObjectInfo __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwOffset);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPlayOffset )( 
            IWMDMObjectInfo __RPC_FAR * This,
            /* [in] */ DWORD dwOffset);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTotalLength )( 
            IWMDMObjectInfo __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastPlayPosition )( 
            IWMDMObjectInfo __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwLastPos);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLongestPlayPosition )( 
            IWMDMObjectInfo __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwLongestPos);
        
        END_INTERFACE
    } IWMDMObjectInfoVtbl;

    interface IWMDMObjectInfo
    {
        CONST_VTBL struct IWMDMObjectInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDMObjectInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDMObjectInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDMObjectInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDMObjectInfo_GetPlayLength(This,pdwLength)	\
    (This)->lpVtbl -> GetPlayLength(This,pdwLength)

#define IWMDMObjectInfo_SetPlayLength(This,dwLength)	\
    (This)->lpVtbl -> SetPlayLength(This,dwLength)

#define IWMDMObjectInfo_GetPlayOffset(This,pdwOffset)	\
    (This)->lpVtbl -> GetPlayOffset(This,pdwOffset)

#define IWMDMObjectInfo_SetPlayOffset(This,dwOffset)	\
    (This)->lpVtbl -> SetPlayOffset(This,dwOffset)

#define IWMDMObjectInfo_GetTotalLength(This,pdwLength)	\
    (This)->lpVtbl -> GetTotalLength(This,pdwLength)

#define IWMDMObjectInfo_GetLastPlayPosition(This,pdwLastPos)	\
    (This)->lpVtbl -> GetLastPlayPosition(This,pdwLastPos)

#define IWMDMObjectInfo_GetLongestPlayPosition(This,pdwLongestPos)	\
    (This)->lpVtbl -> GetLongestPlayPosition(This,pdwLongestPos)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDMObjectInfo_GetPlayLength_Proxy( 
    IWMDMObjectInfo __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwLength);


void __RPC_STUB IWMDMObjectInfo_GetPlayLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMObjectInfo_SetPlayLength_Proxy( 
    IWMDMObjectInfo __RPC_FAR * This,
    /* [in] */ DWORD dwLength);


void __RPC_STUB IWMDMObjectInfo_SetPlayLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMObjectInfo_GetPlayOffset_Proxy( 
    IWMDMObjectInfo __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwOffset);


void __RPC_STUB IWMDMObjectInfo_GetPlayOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMObjectInfo_SetPlayOffset_Proxy( 
    IWMDMObjectInfo __RPC_FAR * This,
    /* [in] */ DWORD dwOffset);


void __RPC_STUB IWMDMObjectInfo_SetPlayOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMObjectInfo_GetTotalLength_Proxy( 
    IWMDMObjectInfo __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwLength);


void __RPC_STUB IWMDMObjectInfo_GetTotalLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMObjectInfo_GetLastPlayPosition_Proxy( 
    IWMDMObjectInfo __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwLastPos);


void __RPC_STUB IWMDMObjectInfo_GetLastPlayPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMObjectInfo_GetLongestPlayPosition_Proxy( 
    IWMDMObjectInfo __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwLongestPos);


void __RPC_STUB IWMDMObjectInfo_GetLongestPlayPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDMObjectInfo_INTERFACE_DEFINED__ */


#ifndef __IWMDMRevoked_INTERFACE_DEFINED__
#define __IWMDMRevoked_INTERFACE_DEFINED__

/* interface IWMDMRevoked */
/* [ref][uuid][object] */ 


EXTERN_C const IID IID_IWMDMRevoked;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EBECCEDB-88EE-4e55-B6A4-8D9F07D696AA")
    IWMDMRevoked : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRevocationURL( 
            /* [size_is][size_is][string][out][in] */ LPWSTR __RPC_FAR *ppwszRevocationURL,
            /* [out][in] */ DWORD __RPC_FAR *pdwBufferLen,
            /* [out] */ DWORD __RPC_FAR *pdwRevokedBitFlag) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDMRevokedVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDMRevoked __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDMRevoked __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDMRevoked __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRevocationURL )( 
            IWMDMRevoked __RPC_FAR * This,
            /* [size_is][size_is][string][out][in] */ LPWSTR __RPC_FAR *ppwszRevocationURL,
            /* [out][in] */ DWORD __RPC_FAR *pdwBufferLen,
            /* [out] */ DWORD __RPC_FAR *pdwRevokedBitFlag);
        
        END_INTERFACE
    } IWMDMRevokedVtbl;

    interface IWMDMRevoked
    {
        CONST_VTBL struct IWMDMRevokedVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDMRevoked_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDMRevoked_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDMRevoked_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDMRevoked_GetRevocationURL(This,ppwszRevocationURL,pdwBufferLen,pdwRevokedBitFlag)	\
    (This)->lpVtbl -> GetRevocationURL(This,ppwszRevocationURL,pdwBufferLen,pdwRevokedBitFlag)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDMRevoked_GetRevocationURL_Proxy( 
    IWMDMRevoked __RPC_FAR * This,
    /* [size_is][size_is][string][out][in] */ LPWSTR __RPC_FAR *ppwszRevocationURL,
    /* [out][in] */ DWORD __RPC_FAR *pdwBufferLen,
    /* [out] */ DWORD __RPC_FAR *pdwRevokedBitFlag);


void __RPC_STUB IWMDMRevoked_GetRevocationURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDMRevoked_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mswmdm_0229 */
/* [local] */ 

// Open Mode Flags
#define MDSP_READ                               0x00000001
#define MDSP_WRITE                              0x00000002
// Seek Flags
#define MDSP_SEEK_BOF                           0x00000001
#define MDSP_SEEK_CUR                           0x00000002
#define MDSP_SEEK_EOF                           0x00000004











extern RPC_IF_HANDLE __MIDL_itf_mswmdm_0229_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mswmdm_0229_v0_0_s_ifspec;

#ifndef __IMDServiceProvider_INTERFACE_DEFINED__
#define __IMDServiceProvider_INTERFACE_DEFINED__

/* interface IMDServiceProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMDServiceProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A10-33ED-11d3-8470-00C04F79DBC0")
    IMDServiceProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDeviceCount( 
            /* [out] */ DWORD __RPC_FAR *pdwCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumDevices( 
            /* [out] */ IMDSPEnumDevice __RPC_FAR *__RPC_FAR *ppEnumDevice) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMDServiceProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMDServiceProvider __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMDServiceProvider __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMDServiceProvider __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDeviceCount )( 
            IMDServiceProvider __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumDevices )( 
            IMDServiceProvider __RPC_FAR * This,
            /* [out] */ IMDSPEnumDevice __RPC_FAR *__RPC_FAR *ppEnumDevice);
        
        END_INTERFACE
    } IMDServiceProviderVtbl;

    interface IMDServiceProvider
    {
        CONST_VTBL struct IMDServiceProviderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMDServiceProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMDServiceProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMDServiceProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMDServiceProvider_GetDeviceCount(This,pdwCount)	\
    (This)->lpVtbl -> GetDeviceCount(This,pdwCount)

#define IMDServiceProvider_EnumDevices(This,ppEnumDevice)	\
    (This)->lpVtbl -> EnumDevices(This,ppEnumDevice)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMDServiceProvider_GetDeviceCount_Proxy( 
    IMDServiceProvider __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwCount);


void __RPC_STUB IMDServiceProvider_GetDeviceCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDServiceProvider_EnumDevices_Proxy( 
    IMDServiceProvider __RPC_FAR * This,
    /* [out] */ IMDSPEnumDevice __RPC_FAR *__RPC_FAR *ppEnumDevice);


void __RPC_STUB IMDServiceProvider_EnumDevices_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMDServiceProvider_INTERFACE_DEFINED__ */


#ifndef __IMDServiceProvider2_INTERFACE_DEFINED__
#define __IMDServiceProvider2_INTERFACE_DEFINED__

/* interface IMDServiceProvider2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMDServiceProvider2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B2FA24B7-CDA3-4694-9862-413AE1A34819")
    IMDServiceProvider2 : public IMDServiceProvider
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDeviceFromPnPName( 
            /* [string][in] */ LPCWSTR pwszPnPName,
            /* [out] */ IMDSPDevice __RPC_FAR *__RPC_FAR *ppDevice) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMDServiceProvider2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMDServiceProvider2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMDServiceProvider2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMDServiceProvider2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDeviceCount )( 
            IMDServiceProvider2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumDevices )( 
            IMDServiceProvider2 __RPC_FAR * This,
            /* [out] */ IMDSPEnumDevice __RPC_FAR *__RPC_FAR *ppEnumDevice);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDeviceFromPnPName )( 
            IMDServiceProvider2 __RPC_FAR * This,
            /* [string][in] */ LPCWSTR pwszPnPName,
            /* [out] */ IMDSPDevice __RPC_FAR *__RPC_FAR *ppDevice);
        
        END_INTERFACE
    } IMDServiceProvider2Vtbl;

    interface IMDServiceProvider2
    {
        CONST_VTBL struct IMDServiceProvider2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMDServiceProvider2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMDServiceProvider2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMDServiceProvider2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMDServiceProvider2_GetDeviceCount(This,pdwCount)	\
    (This)->lpVtbl -> GetDeviceCount(This,pdwCount)

#define IMDServiceProvider2_EnumDevices(This,ppEnumDevice)	\
    (This)->lpVtbl -> EnumDevices(This,ppEnumDevice)


#define IMDServiceProvider2_GetDeviceFromPnPName(This,pwszPnPName,ppDevice)	\
    (This)->lpVtbl -> GetDeviceFromPnPName(This,pwszPnPName,ppDevice)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMDServiceProvider2_GetDeviceFromPnPName_Proxy( 
    IMDServiceProvider2 __RPC_FAR * This,
    /* [string][in] */ LPCWSTR pwszPnPName,
    /* [out] */ IMDSPDevice __RPC_FAR *__RPC_FAR *ppDevice);


void __RPC_STUB IMDServiceProvider2_GetDeviceFromPnPName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMDServiceProvider2_INTERFACE_DEFINED__ */


#ifndef __IMDSPEnumDevice_INTERFACE_DEFINED__
#define __IMDSPEnumDevice_INTERFACE_DEFINED__

/* interface IMDSPEnumDevice */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMDSPEnumDevice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A11-33ED-11d3-8470-00C04F79DBC0")
    IMDSPEnumDevice : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IMDSPDevice __RPC_FAR *__RPC_FAR *ppDevice,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IMDSPEnumDevice __RPC_FAR *__RPC_FAR *ppEnumDevice) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMDSPEnumDeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMDSPEnumDevice __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMDSPEnumDevice __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMDSPEnumDevice __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IMDSPEnumDevice __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IMDSPDevice __RPC_FAR *__RPC_FAR *ppDevice,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IMDSPEnumDevice __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IMDSPEnumDevice __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IMDSPEnumDevice __RPC_FAR * This,
            /* [out] */ IMDSPEnumDevice __RPC_FAR *__RPC_FAR *ppEnumDevice);
        
        END_INTERFACE
    } IMDSPEnumDeviceVtbl;

    interface IMDSPEnumDevice
    {
        CONST_VTBL struct IMDSPEnumDeviceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMDSPEnumDevice_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMDSPEnumDevice_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMDSPEnumDevice_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMDSPEnumDevice_Next(This,celt,ppDevice,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,ppDevice,pceltFetched)

#define IMDSPEnumDevice_Skip(This,celt,pceltFetched)	\
    (This)->lpVtbl -> Skip(This,celt,pceltFetched)

#define IMDSPEnumDevice_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IMDSPEnumDevice_Clone(This,ppEnumDevice)	\
    (This)->lpVtbl -> Clone(This,ppEnumDevice)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMDSPEnumDevice_Next_Proxy( 
    IMDSPEnumDevice __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IMDSPDevice __RPC_FAR *__RPC_FAR *ppDevice,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IMDSPEnumDevice_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPEnumDevice_Skip_Proxy( 
    IMDSPEnumDevice __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IMDSPEnumDevice_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPEnumDevice_Reset_Proxy( 
    IMDSPEnumDevice __RPC_FAR * This);


void __RPC_STUB IMDSPEnumDevice_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPEnumDevice_Clone_Proxy( 
    IMDSPEnumDevice __RPC_FAR * This,
    /* [out] */ IMDSPEnumDevice __RPC_FAR *__RPC_FAR *ppEnumDevice);


void __RPC_STUB IMDSPEnumDevice_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMDSPEnumDevice_INTERFACE_DEFINED__ */


#ifndef __IMDSPDevice_INTERFACE_DEFINED__
#define __IMDSPDevice_INTERFACE_DEFINED__

/* interface IMDSPDevice */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMDSPDevice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A12-33ED-11d3-8470-00C04F79DBC0")
    IMDSPDevice : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [size_is][string][out] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetManufacturer( 
            /* [size_is][string][out] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersion( 
            /* [out] */ DWORD __RPC_FAR *pdwVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ DWORD __RPC_FAR *pdwType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSerialNumber( 
            /* [out] */ PWMDMID pSerialNumber,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPowerSource( 
            /* [out] */ DWORD __RPC_FAR *pdwPowerSource,
            /* [out] */ DWORD __RPC_FAR *pdwPercentRemaining) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ DWORD __RPC_FAR *pdwStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeviceIcon( 
            /* [out] */ ULONG __RPC_FAR *hIcon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumStorage( 
            /* [out] */ IMDSPEnumStorage __RPC_FAR *__RPC_FAR *ppEnumStorage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFormatSupport( 
            /* [size_is][size_is][out] */ _WAVEFORMATEX __RPC_FAR *__RPC_FAR *pFormatEx,
            /* [out] */ UINT __RPC_FAR *pnFormatCount,
            /* [size_is][size_is][out] */ LPWSTR __RPC_FAR *__RPC_FAR *pppwszMimeType,
            /* [out] */ UINT __RPC_FAR *pnMimeTypeCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendOpaqueCommand( 
            /* [out][in] */ OPAQUECOMMAND __RPC_FAR *pCommand) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMDSPDeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMDSPDevice __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMDSPDevice __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMDSPDevice __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IMDSPDevice __RPC_FAR * This,
            /* [size_is][string][out] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetManufacturer )( 
            IMDSPDevice __RPC_FAR * This,
            /* [size_is][string][out] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVersion )( 
            IMDSPDevice __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwVersion);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IMDSPDevice __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSerialNumber )( 
            IMDSPDevice __RPC_FAR * This,
            /* [out] */ PWMDMID pSerialNumber,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPowerSource )( 
            IMDSPDevice __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwPowerSource,
            /* [out] */ DWORD __RPC_FAR *pdwPercentRemaining);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatus )( 
            IMDSPDevice __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDeviceIcon )( 
            IMDSPDevice __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *hIcon);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumStorage )( 
            IMDSPDevice __RPC_FAR * This,
            /* [out] */ IMDSPEnumStorage __RPC_FAR *__RPC_FAR *ppEnumStorage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFormatSupport )( 
            IMDSPDevice __RPC_FAR * This,
            /* [size_is][size_is][out] */ _WAVEFORMATEX __RPC_FAR *__RPC_FAR *pFormatEx,
            /* [out] */ UINT __RPC_FAR *pnFormatCount,
            /* [size_is][size_is][out] */ LPWSTR __RPC_FAR *__RPC_FAR *pppwszMimeType,
            /* [out] */ UINT __RPC_FAR *pnMimeTypeCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendOpaqueCommand )( 
            IMDSPDevice __RPC_FAR * This,
            /* [out][in] */ OPAQUECOMMAND __RPC_FAR *pCommand);
        
        END_INTERFACE
    } IMDSPDeviceVtbl;

    interface IMDSPDevice
    {
        CONST_VTBL struct IMDSPDeviceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMDSPDevice_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMDSPDevice_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMDSPDevice_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMDSPDevice_GetName(This,pwszName,nMaxChars)	\
    (This)->lpVtbl -> GetName(This,pwszName,nMaxChars)

#define IMDSPDevice_GetManufacturer(This,pwszName,nMaxChars)	\
    (This)->lpVtbl -> GetManufacturer(This,pwszName,nMaxChars)

#define IMDSPDevice_GetVersion(This,pdwVersion)	\
    (This)->lpVtbl -> GetVersion(This,pdwVersion)

#define IMDSPDevice_GetType(This,pdwType)	\
    (This)->lpVtbl -> GetType(This,pdwType)

#define IMDSPDevice_GetSerialNumber(This,pSerialNumber,abMac)	\
    (This)->lpVtbl -> GetSerialNumber(This,pSerialNumber,abMac)

#define IMDSPDevice_GetPowerSource(This,pdwPowerSource,pdwPercentRemaining)	\
    (This)->lpVtbl -> GetPowerSource(This,pdwPowerSource,pdwPercentRemaining)

#define IMDSPDevice_GetStatus(This,pdwStatus)	\
    (This)->lpVtbl -> GetStatus(This,pdwStatus)

#define IMDSPDevice_GetDeviceIcon(This,hIcon)	\
    (This)->lpVtbl -> GetDeviceIcon(This,hIcon)

#define IMDSPDevice_EnumStorage(This,ppEnumStorage)	\
    (This)->lpVtbl -> EnumStorage(This,ppEnumStorage)

#define IMDSPDevice_GetFormatSupport(This,pFormatEx,pnFormatCount,pppwszMimeType,pnMimeTypeCount)	\
    (This)->lpVtbl -> GetFormatSupport(This,pFormatEx,pnFormatCount,pppwszMimeType,pnMimeTypeCount)

#define IMDSPDevice_SendOpaqueCommand(This,pCommand)	\
    (This)->lpVtbl -> SendOpaqueCommand(This,pCommand)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMDSPDevice_GetName_Proxy( 
    IMDSPDevice __RPC_FAR * This,
    /* [size_is][string][out] */ LPWSTR pwszName,
    /* [in] */ UINT nMaxChars);


void __RPC_STUB IMDSPDevice_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPDevice_GetManufacturer_Proxy( 
    IMDSPDevice __RPC_FAR * This,
    /* [size_is][string][out] */ LPWSTR pwszName,
    /* [in] */ UINT nMaxChars);


void __RPC_STUB IMDSPDevice_GetManufacturer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPDevice_GetVersion_Proxy( 
    IMDSPDevice __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwVersion);


void __RPC_STUB IMDSPDevice_GetVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPDevice_GetType_Proxy( 
    IMDSPDevice __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwType);


void __RPC_STUB IMDSPDevice_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPDevice_GetSerialNumber_Proxy( 
    IMDSPDevice __RPC_FAR * This,
    /* [out] */ PWMDMID pSerialNumber,
    /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);


void __RPC_STUB IMDSPDevice_GetSerialNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPDevice_GetPowerSource_Proxy( 
    IMDSPDevice __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwPowerSource,
    /* [out] */ DWORD __RPC_FAR *pdwPercentRemaining);


void __RPC_STUB IMDSPDevice_GetPowerSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPDevice_GetStatus_Proxy( 
    IMDSPDevice __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwStatus);


void __RPC_STUB IMDSPDevice_GetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPDevice_GetDeviceIcon_Proxy( 
    IMDSPDevice __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *hIcon);


void __RPC_STUB IMDSPDevice_GetDeviceIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPDevice_EnumStorage_Proxy( 
    IMDSPDevice __RPC_FAR * This,
    /* [out] */ IMDSPEnumStorage __RPC_FAR *__RPC_FAR *ppEnumStorage);


void __RPC_STUB IMDSPDevice_EnumStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPDevice_GetFormatSupport_Proxy( 
    IMDSPDevice __RPC_FAR * This,
    /* [size_is][size_is][out] */ _WAVEFORMATEX __RPC_FAR *__RPC_FAR *pFormatEx,
    /* [out] */ UINT __RPC_FAR *pnFormatCount,
    /* [size_is][size_is][out] */ LPWSTR __RPC_FAR *__RPC_FAR *pppwszMimeType,
    /* [out] */ UINT __RPC_FAR *pnMimeTypeCount);


void __RPC_STUB IMDSPDevice_GetFormatSupport_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPDevice_SendOpaqueCommand_Proxy( 
    IMDSPDevice __RPC_FAR * This,
    /* [out][in] */ OPAQUECOMMAND __RPC_FAR *pCommand);


void __RPC_STUB IMDSPDevice_SendOpaqueCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMDSPDevice_INTERFACE_DEFINED__ */


#ifndef __IMDSPDevice2_INTERFACE_DEFINED__
#define __IMDSPDevice2_INTERFACE_DEFINED__

/* interface IMDSPDevice2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMDSPDevice2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("420D16AD-C97D-4e00-82AA-00E9F4335DDD")
    IMDSPDevice2 : public IMDSPDevice
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStorage( 
            /* [string][in] */ LPCWSTR pszStorageName,
            /* [out] */ IMDSPStorage __RPC_FAR *__RPC_FAR *ppStorage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFormatSupport2( 
            /* [in] */ DWORD dwFlags,
            /* [size_is][size_is][out] */ _WAVEFORMATEX __RPC_FAR *__RPC_FAR *ppAudioFormatEx,
            /* [ref][out] */ UINT __RPC_FAR *pnAudioFormatCount,
            /* [size_is][size_is][out] */ _VIDEOINFOHEADER __RPC_FAR *__RPC_FAR *ppVideoFormatEx,
            /* [ref][out] */ UINT __RPC_FAR *pnVideoFormatCount,
            /* [size_is][size_is][out] */ WMFILECAPABILITIES __RPC_FAR *__RPC_FAR *ppFileType,
            /* [ref][out] */ UINT __RPC_FAR *pnFileTypeCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSpecifyPropertyPages( 
            /* [ref][out] */ ISpecifyPropertyPages __RPC_FAR *__RPC_FAR *ppSpecifyPropPages,
            /* [size_is][size_is][ref][out] */ IUnknown __RPC_FAR *__RPC_FAR *__RPC_FAR *pppUnknowns,
            /* [ref][out] */ ULONG __RPC_FAR *pcUnks) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPnPName( 
            /* [size_is][out] */ LPWSTR pwszPnPName,
            /* [in] */ UINT nMaxChars) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMDSPDevice2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMDSPDevice2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMDSPDevice2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMDSPDevice2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IMDSPDevice2 __RPC_FAR * This,
            /* [size_is][string][out] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetManufacturer )( 
            IMDSPDevice2 __RPC_FAR * This,
            /* [size_is][string][out] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVersion )( 
            IMDSPDevice2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwVersion);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IMDSPDevice2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSerialNumber )( 
            IMDSPDevice2 __RPC_FAR * This,
            /* [out] */ PWMDMID pSerialNumber,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPowerSource )( 
            IMDSPDevice2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwPowerSource,
            /* [out] */ DWORD __RPC_FAR *pdwPercentRemaining);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatus )( 
            IMDSPDevice2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDeviceIcon )( 
            IMDSPDevice2 __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *hIcon);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumStorage )( 
            IMDSPDevice2 __RPC_FAR * This,
            /* [out] */ IMDSPEnumStorage __RPC_FAR *__RPC_FAR *ppEnumStorage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFormatSupport )( 
            IMDSPDevice2 __RPC_FAR * This,
            /* [size_is][size_is][out] */ _WAVEFORMATEX __RPC_FAR *__RPC_FAR *pFormatEx,
            /* [out] */ UINT __RPC_FAR *pnFormatCount,
            /* [size_is][size_is][out] */ LPWSTR __RPC_FAR *__RPC_FAR *pppwszMimeType,
            /* [out] */ UINT __RPC_FAR *pnMimeTypeCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendOpaqueCommand )( 
            IMDSPDevice2 __RPC_FAR * This,
            /* [out][in] */ OPAQUECOMMAND __RPC_FAR *pCommand);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStorage )( 
            IMDSPDevice2 __RPC_FAR * This,
            /* [string][in] */ LPCWSTR pszStorageName,
            /* [out] */ IMDSPStorage __RPC_FAR *__RPC_FAR *ppStorage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFormatSupport2 )( 
            IMDSPDevice2 __RPC_FAR * This,
            /* [in] */ DWORD dwFlags,
            /* [size_is][size_is][out] */ _WAVEFORMATEX __RPC_FAR *__RPC_FAR *ppAudioFormatEx,
            /* [ref][out] */ UINT __RPC_FAR *pnAudioFormatCount,
            /* [size_is][size_is][out] */ _VIDEOINFOHEADER __RPC_FAR *__RPC_FAR *ppVideoFormatEx,
            /* [ref][out] */ UINT __RPC_FAR *pnVideoFormatCount,
            /* [size_is][size_is][out] */ WMFILECAPABILITIES __RPC_FAR *__RPC_FAR *ppFileType,
            /* [ref][out] */ UINT __RPC_FAR *pnFileTypeCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSpecifyPropertyPages )( 
            IMDSPDevice2 __RPC_FAR * This,
            /* [ref][out] */ ISpecifyPropertyPages __RPC_FAR *__RPC_FAR *ppSpecifyPropPages,
            /* [size_is][size_is][ref][out] */ IUnknown __RPC_FAR *__RPC_FAR *__RPC_FAR *pppUnknowns,
            /* [ref][out] */ ULONG __RPC_FAR *pcUnks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPnPName )( 
            IMDSPDevice2 __RPC_FAR * This,
            /* [size_is][out] */ LPWSTR pwszPnPName,
            /* [in] */ UINT nMaxChars);
        
        END_INTERFACE
    } IMDSPDevice2Vtbl;

    interface IMDSPDevice2
    {
        CONST_VTBL struct IMDSPDevice2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMDSPDevice2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMDSPDevice2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMDSPDevice2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMDSPDevice2_GetName(This,pwszName,nMaxChars)	\
    (This)->lpVtbl -> GetName(This,pwszName,nMaxChars)

#define IMDSPDevice2_GetManufacturer(This,pwszName,nMaxChars)	\
    (This)->lpVtbl -> GetManufacturer(This,pwszName,nMaxChars)

#define IMDSPDevice2_GetVersion(This,pdwVersion)	\
    (This)->lpVtbl -> GetVersion(This,pdwVersion)

#define IMDSPDevice2_GetType(This,pdwType)	\
    (This)->lpVtbl -> GetType(This,pdwType)

#define IMDSPDevice2_GetSerialNumber(This,pSerialNumber,abMac)	\
    (This)->lpVtbl -> GetSerialNumber(This,pSerialNumber,abMac)

#define IMDSPDevice2_GetPowerSource(This,pdwPowerSource,pdwPercentRemaining)	\
    (This)->lpVtbl -> GetPowerSource(This,pdwPowerSource,pdwPercentRemaining)

#define IMDSPDevice2_GetStatus(This,pdwStatus)	\
    (This)->lpVtbl -> GetStatus(This,pdwStatus)

#define IMDSPDevice2_GetDeviceIcon(This,hIcon)	\
    (This)->lpVtbl -> GetDeviceIcon(This,hIcon)

#define IMDSPDevice2_EnumStorage(This,ppEnumStorage)	\
    (This)->lpVtbl -> EnumStorage(This,ppEnumStorage)

#define IMDSPDevice2_GetFormatSupport(This,pFormatEx,pnFormatCount,pppwszMimeType,pnMimeTypeCount)	\
    (This)->lpVtbl -> GetFormatSupport(This,pFormatEx,pnFormatCount,pppwszMimeType,pnMimeTypeCount)

#define IMDSPDevice2_SendOpaqueCommand(This,pCommand)	\
    (This)->lpVtbl -> SendOpaqueCommand(This,pCommand)


#define IMDSPDevice2_GetStorage(This,pszStorageName,ppStorage)	\
    (This)->lpVtbl -> GetStorage(This,pszStorageName,ppStorage)

#define IMDSPDevice2_GetFormatSupport2(This,dwFlags,ppAudioFormatEx,pnAudioFormatCount,ppVideoFormatEx,pnVideoFormatCount,ppFileType,pnFileTypeCount)	\
    (This)->lpVtbl -> GetFormatSupport2(This,dwFlags,ppAudioFormatEx,pnAudioFormatCount,ppVideoFormatEx,pnVideoFormatCount,ppFileType,pnFileTypeCount)

#define IMDSPDevice2_GetSpecifyPropertyPages(This,ppSpecifyPropPages,pppUnknowns,pcUnks)	\
    (This)->lpVtbl -> GetSpecifyPropertyPages(This,ppSpecifyPropPages,pppUnknowns,pcUnks)

#define IMDSPDevice2_GetPnPName(This,pwszPnPName,nMaxChars)	\
    (This)->lpVtbl -> GetPnPName(This,pwszPnPName,nMaxChars)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMDSPDevice2_GetStorage_Proxy( 
    IMDSPDevice2 __RPC_FAR * This,
    /* [string][in] */ LPCWSTR pszStorageName,
    /* [out] */ IMDSPStorage __RPC_FAR *__RPC_FAR *ppStorage);


void __RPC_STUB IMDSPDevice2_GetStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPDevice2_GetFormatSupport2_Proxy( 
    IMDSPDevice2 __RPC_FAR * This,
    /* [in] */ DWORD dwFlags,
    /* [size_is][size_is][out] */ _WAVEFORMATEX __RPC_FAR *__RPC_FAR *ppAudioFormatEx,
    /* [ref][out] */ UINT __RPC_FAR *pnAudioFormatCount,
    /* [size_is][size_is][out] */ _VIDEOINFOHEADER __RPC_FAR *__RPC_FAR *ppVideoFormatEx,
    /* [ref][out] */ UINT __RPC_FAR *pnVideoFormatCount,
    /* [size_is][size_is][out] */ WMFILECAPABILITIES __RPC_FAR *__RPC_FAR *ppFileType,
    /* [ref][out] */ UINT __RPC_FAR *pnFileTypeCount);


void __RPC_STUB IMDSPDevice2_GetFormatSupport2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPDevice2_GetSpecifyPropertyPages_Proxy( 
    IMDSPDevice2 __RPC_FAR * This,
    /* [ref][out] */ ISpecifyPropertyPages __RPC_FAR *__RPC_FAR *ppSpecifyPropPages,
    /* [size_is][size_is][ref][out] */ IUnknown __RPC_FAR *__RPC_FAR *__RPC_FAR *pppUnknowns,
    /* [ref][out] */ ULONG __RPC_FAR *pcUnks);


void __RPC_STUB IMDSPDevice2_GetSpecifyPropertyPages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPDevice2_GetPnPName_Proxy( 
    IMDSPDevice2 __RPC_FAR * This,
    /* [size_is][out] */ LPWSTR pwszPnPName,
    /* [in] */ UINT nMaxChars);


void __RPC_STUB IMDSPDevice2_GetPnPName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMDSPDevice2_INTERFACE_DEFINED__ */


#ifndef __IMDSPDeviceControl_INTERFACE_DEFINED__
#define __IMDSPDeviceControl_INTERFACE_DEFINED__

/* interface IMDSPDeviceControl */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMDSPDeviceControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A14-33ED-11d3-8470-00C04F79DBC0")
    IMDSPDeviceControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDCStatus( 
            /* [out] */ DWORD __RPC_FAR *pdwStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCapabilities( 
            /* [out] */ DWORD __RPC_FAR *pdwCapabilitiesMask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Play( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Record( 
            /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Seek( 
            /* [in] */ UINT fuMode,
            /* [in] */ int nOffset) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMDSPDeviceControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMDSPDeviceControl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMDSPDeviceControl __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMDSPDeviceControl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDCStatus )( 
            IMDSPDeviceControl __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCapabilities )( 
            IMDSPDeviceControl __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwCapabilitiesMask);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Play )( 
            IMDSPDeviceControl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Record )( 
            IMDSPDeviceControl __RPC_FAR * This,
            /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Pause )( 
            IMDSPDeviceControl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Resume )( 
            IMDSPDeviceControl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Stop )( 
            IMDSPDeviceControl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Seek )( 
            IMDSPDeviceControl __RPC_FAR * This,
            /* [in] */ UINT fuMode,
            /* [in] */ int nOffset);
        
        END_INTERFACE
    } IMDSPDeviceControlVtbl;

    interface IMDSPDeviceControl
    {
        CONST_VTBL struct IMDSPDeviceControlVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMDSPDeviceControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMDSPDeviceControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMDSPDeviceControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMDSPDeviceControl_GetDCStatus(This,pdwStatus)	\
    (This)->lpVtbl -> GetDCStatus(This,pdwStatus)

#define IMDSPDeviceControl_GetCapabilities(This,pdwCapabilitiesMask)	\
    (This)->lpVtbl -> GetCapabilities(This,pdwCapabilitiesMask)

#define IMDSPDeviceControl_Play(This)	\
    (This)->lpVtbl -> Play(This)

#define IMDSPDeviceControl_Record(This,pFormat)	\
    (This)->lpVtbl -> Record(This,pFormat)

#define IMDSPDeviceControl_Pause(This)	\
    (This)->lpVtbl -> Pause(This)

#define IMDSPDeviceControl_Resume(This)	\
    (This)->lpVtbl -> Resume(This)

#define IMDSPDeviceControl_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#define IMDSPDeviceControl_Seek(This,fuMode,nOffset)	\
    (This)->lpVtbl -> Seek(This,fuMode,nOffset)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMDSPDeviceControl_GetDCStatus_Proxy( 
    IMDSPDeviceControl __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwStatus);


void __RPC_STUB IMDSPDeviceControl_GetDCStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPDeviceControl_GetCapabilities_Proxy( 
    IMDSPDeviceControl __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwCapabilitiesMask);


void __RPC_STUB IMDSPDeviceControl_GetCapabilities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPDeviceControl_Play_Proxy( 
    IMDSPDeviceControl __RPC_FAR * This);


void __RPC_STUB IMDSPDeviceControl_Play_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPDeviceControl_Record_Proxy( 
    IMDSPDeviceControl __RPC_FAR * This,
    /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat);


void __RPC_STUB IMDSPDeviceControl_Record_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPDeviceControl_Pause_Proxy( 
    IMDSPDeviceControl __RPC_FAR * This);


void __RPC_STUB IMDSPDeviceControl_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPDeviceControl_Resume_Proxy( 
    IMDSPDeviceControl __RPC_FAR * This);


void __RPC_STUB IMDSPDeviceControl_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPDeviceControl_Stop_Proxy( 
    IMDSPDeviceControl __RPC_FAR * This);


void __RPC_STUB IMDSPDeviceControl_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPDeviceControl_Seek_Proxy( 
    IMDSPDeviceControl __RPC_FAR * This,
    /* [in] */ UINT fuMode,
    /* [in] */ int nOffset);


void __RPC_STUB IMDSPDeviceControl_Seek_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMDSPDeviceControl_INTERFACE_DEFINED__ */


#ifndef __IMDSPEnumStorage_INTERFACE_DEFINED__
#define __IMDSPEnumStorage_INTERFACE_DEFINED__

/* interface IMDSPEnumStorage */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMDSPEnumStorage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A15-33ED-11d3-8470-00C04F79DBC0")
    IMDSPEnumStorage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IMDSPStorage __RPC_FAR *__RPC_FAR *ppStorage,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IMDSPEnumStorage __RPC_FAR *__RPC_FAR *ppEnumStorage) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMDSPEnumStorageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMDSPEnumStorage __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMDSPEnumStorage __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMDSPEnumStorage __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IMDSPEnumStorage __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IMDSPStorage __RPC_FAR *__RPC_FAR *ppStorage,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IMDSPEnumStorage __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IMDSPEnumStorage __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IMDSPEnumStorage __RPC_FAR * This,
            /* [out] */ IMDSPEnumStorage __RPC_FAR *__RPC_FAR *ppEnumStorage);
        
        END_INTERFACE
    } IMDSPEnumStorageVtbl;

    interface IMDSPEnumStorage
    {
        CONST_VTBL struct IMDSPEnumStorageVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMDSPEnumStorage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMDSPEnumStorage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMDSPEnumStorage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMDSPEnumStorage_Next(This,celt,ppStorage,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,ppStorage,pceltFetched)

#define IMDSPEnumStorage_Skip(This,celt,pceltFetched)	\
    (This)->lpVtbl -> Skip(This,celt,pceltFetched)

#define IMDSPEnumStorage_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IMDSPEnumStorage_Clone(This,ppEnumStorage)	\
    (This)->lpVtbl -> Clone(This,ppEnumStorage)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMDSPEnumStorage_Next_Proxy( 
    IMDSPEnumStorage __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IMDSPStorage __RPC_FAR *__RPC_FAR *ppStorage,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IMDSPEnumStorage_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPEnumStorage_Skip_Proxy( 
    IMDSPEnumStorage __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IMDSPEnumStorage_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPEnumStorage_Reset_Proxy( 
    IMDSPEnumStorage __RPC_FAR * This);


void __RPC_STUB IMDSPEnumStorage_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPEnumStorage_Clone_Proxy( 
    IMDSPEnumStorage __RPC_FAR * This,
    /* [out] */ IMDSPEnumStorage __RPC_FAR *__RPC_FAR *ppEnumStorage);


void __RPC_STUB IMDSPEnumStorage_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMDSPEnumStorage_INTERFACE_DEFINED__ */


#ifndef __IMDSPStorage_INTERFACE_DEFINED__
#define __IMDSPStorage_INTERFACE_DEFINED__

/* interface IMDSPStorage */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMDSPStorage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A16-33ED-11d3-8470-00C04F79DBC0")
    IMDSPStorage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetAttributes( 
            /* [in] */ DWORD dwAttributes,
            /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStorageGlobals( 
            /* [out] */ IMDSPStorageGlobals __RPC_FAR *__RPC_FAR *ppStorageGlobals) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributes( 
            /* [out] */ DWORD __RPC_FAR *pdwAttributes,
            /* [out] */ _WAVEFORMATEX __RPC_FAR *pFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [size_is][string][out] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDate( 
            /* [out] */ PWMDMDATETIME pDateTimeUTC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSize( 
            /* [out] */ DWORD __RPC_FAR *pdwSizeLow,
            /* [out] */ DWORD __RPC_FAR *pdwSizeHigh) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRights( 
            /* [size_is][size_is][out] */ PWMDMRIGHTS __RPC_FAR *ppRights,
            /* [out] */ UINT __RPC_FAR *pnRightsCount,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateStorage( 
            /* [in] */ DWORD dwAttributes,
            /* [unique][in] */ _WAVEFORMATEX __RPC_FAR *pFormat,
            /* [in] */ LPWSTR pwszName,
            /* [out] */ IMDSPStorage __RPC_FAR *__RPC_FAR *ppNewStorage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumStorage( 
            /* [out] */ IMDSPEnumStorage __RPC_FAR *__RPC_FAR *ppEnumStorage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendOpaqueCommand( 
            /* [out][in] */ OPAQUECOMMAND __RPC_FAR *pCommand) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMDSPStorageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMDSPStorage __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMDSPStorage __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMDSPStorage __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAttributes )( 
            IMDSPStorage __RPC_FAR * This,
            /* [in] */ DWORD dwAttributes,
            /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStorageGlobals )( 
            IMDSPStorage __RPC_FAR * This,
            /* [out] */ IMDSPStorageGlobals __RPC_FAR *__RPC_FAR *ppStorageGlobals);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttributes )( 
            IMDSPStorage __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwAttributes,
            /* [out] */ _WAVEFORMATEX __RPC_FAR *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IMDSPStorage __RPC_FAR * This,
            /* [size_is][string][out] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDate )( 
            IMDSPStorage __RPC_FAR * This,
            /* [out] */ PWMDMDATETIME pDateTimeUTC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSize )( 
            IMDSPStorage __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwSizeLow,
            /* [out] */ DWORD __RPC_FAR *pdwSizeHigh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRights )( 
            IMDSPStorage __RPC_FAR * This,
            /* [size_is][size_is][out] */ PWMDMRIGHTS __RPC_FAR *ppRights,
            /* [out] */ UINT __RPC_FAR *pnRightsCount,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateStorage )( 
            IMDSPStorage __RPC_FAR * This,
            /* [in] */ DWORD dwAttributes,
            /* [unique][in] */ _WAVEFORMATEX __RPC_FAR *pFormat,
            /* [in] */ LPWSTR pwszName,
            /* [out] */ IMDSPStorage __RPC_FAR *__RPC_FAR *ppNewStorage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumStorage )( 
            IMDSPStorage __RPC_FAR * This,
            /* [out] */ IMDSPEnumStorage __RPC_FAR *__RPC_FAR *ppEnumStorage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendOpaqueCommand )( 
            IMDSPStorage __RPC_FAR * This,
            /* [out][in] */ OPAQUECOMMAND __RPC_FAR *pCommand);
        
        END_INTERFACE
    } IMDSPStorageVtbl;

    interface IMDSPStorage
    {
        CONST_VTBL struct IMDSPStorageVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMDSPStorage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMDSPStorage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMDSPStorage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMDSPStorage_SetAttributes(This,dwAttributes,pFormat)	\
    (This)->lpVtbl -> SetAttributes(This,dwAttributes,pFormat)

#define IMDSPStorage_GetStorageGlobals(This,ppStorageGlobals)	\
    (This)->lpVtbl -> GetStorageGlobals(This,ppStorageGlobals)

#define IMDSPStorage_GetAttributes(This,pdwAttributes,pFormat)	\
    (This)->lpVtbl -> GetAttributes(This,pdwAttributes,pFormat)

#define IMDSPStorage_GetName(This,pwszName,nMaxChars)	\
    (This)->lpVtbl -> GetName(This,pwszName,nMaxChars)

#define IMDSPStorage_GetDate(This,pDateTimeUTC)	\
    (This)->lpVtbl -> GetDate(This,pDateTimeUTC)

#define IMDSPStorage_GetSize(This,pdwSizeLow,pdwSizeHigh)	\
    (This)->lpVtbl -> GetSize(This,pdwSizeLow,pdwSizeHigh)

#define IMDSPStorage_GetRights(This,ppRights,pnRightsCount,abMac)	\
    (This)->lpVtbl -> GetRights(This,ppRights,pnRightsCount,abMac)

#define IMDSPStorage_CreateStorage(This,dwAttributes,pFormat,pwszName,ppNewStorage)	\
    (This)->lpVtbl -> CreateStorage(This,dwAttributes,pFormat,pwszName,ppNewStorage)

#define IMDSPStorage_EnumStorage(This,ppEnumStorage)	\
    (This)->lpVtbl -> EnumStorage(This,ppEnumStorage)

#define IMDSPStorage_SendOpaqueCommand(This,pCommand)	\
    (This)->lpVtbl -> SendOpaqueCommand(This,pCommand)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMDSPStorage_SetAttributes_Proxy( 
    IMDSPStorage __RPC_FAR * This,
    /* [in] */ DWORD dwAttributes,
    /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat);


void __RPC_STUB IMDSPStorage_SetAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPStorage_GetStorageGlobals_Proxy( 
    IMDSPStorage __RPC_FAR * This,
    /* [out] */ IMDSPStorageGlobals __RPC_FAR *__RPC_FAR *ppStorageGlobals);


void __RPC_STUB IMDSPStorage_GetStorageGlobals_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPStorage_GetAttributes_Proxy( 
    IMDSPStorage __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwAttributes,
    /* [out] */ _WAVEFORMATEX __RPC_FAR *pFormat);


void __RPC_STUB IMDSPStorage_GetAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPStorage_GetName_Proxy( 
    IMDSPStorage __RPC_FAR * This,
    /* [size_is][string][out] */ LPWSTR pwszName,
    /* [in] */ UINT nMaxChars);


void __RPC_STUB IMDSPStorage_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPStorage_GetDate_Proxy( 
    IMDSPStorage __RPC_FAR * This,
    /* [out] */ PWMDMDATETIME pDateTimeUTC);


void __RPC_STUB IMDSPStorage_GetDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPStorage_GetSize_Proxy( 
    IMDSPStorage __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwSizeLow,
    /* [out] */ DWORD __RPC_FAR *pdwSizeHigh);


void __RPC_STUB IMDSPStorage_GetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPStorage_GetRights_Proxy( 
    IMDSPStorage __RPC_FAR * This,
    /* [size_is][size_is][out] */ PWMDMRIGHTS __RPC_FAR *ppRights,
    /* [out] */ UINT __RPC_FAR *pnRightsCount,
    /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);


void __RPC_STUB IMDSPStorage_GetRights_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPStorage_CreateStorage_Proxy( 
    IMDSPStorage __RPC_FAR * This,
    /* [in] */ DWORD dwAttributes,
    /* [unique][in] */ _WAVEFORMATEX __RPC_FAR *pFormat,
    /* [in] */ LPWSTR pwszName,
    /* [out] */ IMDSPStorage __RPC_FAR *__RPC_FAR *ppNewStorage);


void __RPC_STUB IMDSPStorage_CreateStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPStorage_EnumStorage_Proxy( 
    IMDSPStorage __RPC_FAR * This,
    /* [out] */ IMDSPEnumStorage __RPC_FAR *__RPC_FAR *ppEnumStorage);


void __RPC_STUB IMDSPStorage_EnumStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPStorage_SendOpaqueCommand_Proxy( 
    IMDSPStorage __RPC_FAR * This,
    /* [out][in] */ OPAQUECOMMAND __RPC_FAR *pCommand);


void __RPC_STUB IMDSPStorage_SendOpaqueCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMDSPStorage_INTERFACE_DEFINED__ */


#ifndef __IMDSPStorage2_INTERFACE_DEFINED__
#define __IMDSPStorage2_INTERFACE_DEFINED__

/* interface IMDSPStorage2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMDSPStorage2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0A5E07A5-6454-4451-9C36-1C6AE7E2B1D6")
    IMDSPStorage2 : public IMDSPStorage
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStorage( 
            /* [string][in] */ LPCWSTR pszStorageName,
            /* [out] */ IMDSPStorage __RPC_FAR *__RPC_FAR *ppStorage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateStorage2( 
            /* [in] */ DWORD dwAttributes,
            /* [in] */ DWORD dwAttributesEx,
            /* [unique][in] */ _WAVEFORMATEX __RPC_FAR *pAudioFormat,
            /* [unique][in] */ _VIDEOINFOHEADER __RPC_FAR *pVideoFormat,
            /* [in] */ LPWSTR pwszName,
            /* [in] */ ULONGLONG qwFileSize,
            /* [out] */ IMDSPStorage __RPC_FAR *__RPC_FAR *ppNewStorage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAttributes2( 
            /* [in] */ DWORD dwAttributes,
            /* [in] */ DWORD dwAttributesEx,
            /* [in] */ _WAVEFORMATEX __RPC_FAR *pAudioFormat,
            /* [in] */ _VIDEOINFOHEADER __RPC_FAR *pVideoFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributes2( 
            /* [out] */ DWORD __RPC_FAR *pdwAttributes,
            /* [out] */ DWORD __RPC_FAR *pdwAttributesEx,
            /* [out] */ _WAVEFORMATEX __RPC_FAR *pAudioFormat,
            /* [out] */ _VIDEOINFOHEADER __RPC_FAR *pVideoFormat) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMDSPStorage2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMDSPStorage2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMDSPStorage2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMDSPStorage2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAttributes )( 
            IMDSPStorage2 __RPC_FAR * This,
            /* [in] */ DWORD dwAttributes,
            /* [in] */ _WAVEFORMATEX __RPC_FAR *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStorageGlobals )( 
            IMDSPStorage2 __RPC_FAR * This,
            /* [out] */ IMDSPStorageGlobals __RPC_FAR *__RPC_FAR *ppStorageGlobals);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttributes )( 
            IMDSPStorage2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwAttributes,
            /* [out] */ _WAVEFORMATEX __RPC_FAR *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IMDSPStorage2 __RPC_FAR * This,
            /* [size_is][string][out] */ LPWSTR pwszName,
            /* [in] */ UINT nMaxChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDate )( 
            IMDSPStorage2 __RPC_FAR * This,
            /* [out] */ PWMDMDATETIME pDateTimeUTC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSize )( 
            IMDSPStorage2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwSizeLow,
            /* [out] */ DWORD __RPC_FAR *pdwSizeHigh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRights )( 
            IMDSPStorage2 __RPC_FAR * This,
            /* [size_is][size_is][out] */ PWMDMRIGHTS __RPC_FAR *ppRights,
            /* [out] */ UINT __RPC_FAR *pnRightsCount,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateStorage )( 
            IMDSPStorage2 __RPC_FAR * This,
            /* [in] */ DWORD dwAttributes,
            /* [unique][in] */ _WAVEFORMATEX __RPC_FAR *pFormat,
            /* [in] */ LPWSTR pwszName,
            /* [out] */ IMDSPStorage __RPC_FAR *__RPC_FAR *ppNewStorage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumStorage )( 
            IMDSPStorage2 __RPC_FAR * This,
            /* [out] */ IMDSPEnumStorage __RPC_FAR *__RPC_FAR *ppEnumStorage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendOpaqueCommand )( 
            IMDSPStorage2 __RPC_FAR * This,
            /* [out][in] */ OPAQUECOMMAND __RPC_FAR *pCommand);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStorage )( 
            IMDSPStorage2 __RPC_FAR * This,
            /* [string][in] */ LPCWSTR pszStorageName,
            /* [out] */ IMDSPStorage __RPC_FAR *__RPC_FAR *ppStorage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateStorage2 )( 
            IMDSPStorage2 __RPC_FAR * This,
            /* [in] */ DWORD dwAttributes,
            /* [in] */ DWORD dwAttributesEx,
            /* [unique][in] */ _WAVEFORMATEX __RPC_FAR *pAudioFormat,
            /* [unique][in] */ _VIDEOINFOHEADER __RPC_FAR *pVideoFormat,
            /* [in] */ LPWSTR pwszName,
            /* [in] */ ULONGLONG qwFileSize,
            /* [out] */ IMDSPStorage __RPC_FAR *__RPC_FAR *ppNewStorage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAttributes2 )( 
            IMDSPStorage2 __RPC_FAR * This,
            /* [in] */ DWORD dwAttributes,
            /* [in] */ DWORD dwAttributesEx,
            /* [in] */ _WAVEFORMATEX __RPC_FAR *pAudioFormat,
            /* [in] */ _VIDEOINFOHEADER __RPC_FAR *pVideoFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttributes2 )( 
            IMDSPStorage2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwAttributes,
            /* [out] */ DWORD __RPC_FAR *pdwAttributesEx,
            /* [out] */ _WAVEFORMATEX __RPC_FAR *pAudioFormat,
            /* [out] */ _VIDEOINFOHEADER __RPC_FAR *pVideoFormat);
        
        END_INTERFACE
    } IMDSPStorage2Vtbl;

    interface IMDSPStorage2
    {
        CONST_VTBL struct IMDSPStorage2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMDSPStorage2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMDSPStorage2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMDSPStorage2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMDSPStorage2_SetAttributes(This,dwAttributes,pFormat)	\
    (This)->lpVtbl -> SetAttributes(This,dwAttributes,pFormat)

#define IMDSPStorage2_GetStorageGlobals(This,ppStorageGlobals)	\
    (This)->lpVtbl -> GetStorageGlobals(This,ppStorageGlobals)

#define IMDSPStorage2_GetAttributes(This,pdwAttributes,pFormat)	\
    (This)->lpVtbl -> GetAttributes(This,pdwAttributes,pFormat)

#define IMDSPStorage2_GetName(This,pwszName,nMaxChars)	\
    (This)->lpVtbl -> GetName(This,pwszName,nMaxChars)

#define IMDSPStorage2_GetDate(This,pDateTimeUTC)	\
    (This)->lpVtbl -> GetDate(This,pDateTimeUTC)

#define IMDSPStorage2_GetSize(This,pdwSizeLow,pdwSizeHigh)	\
    (This)->lpVtbl -> GetSize(This,pdwSizeLow,pdwSizeHigh)

#define IMDSPStorage2_GetRights(This,ppRights,pnRightsCount,abMac)	\
    (This)->lpVtbl -> GetRights(This,ppRights,pnRightsCount,abMac)

#define IMDSPStorage2_CreateStorage(This,dwAttributes,pFormat,pwszName,ppNewStorage)	\
    (This)->lpVtbl -> CreateStorage(This,dwAttributes,pFormat,pwszName,ppNewStorage)

#define IMDSPStorage2_EnumStorage(This,ppEnumStorage)	\
    (This)->lpVtbl -> EnumStorage(This,ppEnumStorage)

#define IMDSPStorage2_SendOpaqueCommand(This,pCommand)	\
    (This)->lpVtbl -> SendOpaqueCommand(This,pCommand)


#define IMDSPStorage2_GetStorage(This,pszStorageName,ppStorage)	\
    (This)->lpVtbl -> GetStorage(This,pszStorageName,ppStorage)

#define IMDSPStorage2_CreateStorage2(This,dwAttributes,dwAttributesEx,pAudioFormat,pVideoFormat,pwszName,qwFileSize,ppNewStorage)	\
    (This)->lpVtbl -> CreateStorage2(This,dwAttributes,dwAttributesEx,pAudioFormat,pVideoFormat,pwszName,qwFileSize,ppNewStorage)

#define IMDSPStorage2_SetAttributes2(This,dwAttributes,dwAttributesEx,pAudioFormat,pVideoFormat)	\
    (This)->lpVtbl -> SetAttributes2(This,dwAttributes,dwAttributesEx,pAudioFormat,pVideoFormat)

#define IMDSPStorage2_GetAttributes2(This,pdwAttributes,pdwAttributesEx,pAudioFormat,pVideoFormat)	\
    (This)->lpVtbl -> GetAttributes2(This,pdwAttributes,pdwAttributesEx,pAudioFormat,pVideoFormat)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMDSPStorage2_GetStorage_Proxy( 
    IMDSPStorage2 __RPC_FAR * This,
    /* [string][in] */ LPCWSTR pszStorageName,
    /* [out] */ IMDSPStorage __RPC_FAR *__RPC_FAR *ppStorage);


void __RPC_STUB IMDSPStorage2_GetStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPStorage2_CreateStorage2_Proxy( 
    IMDSPStorage2 __RPC_FAR * This,
    /* [in] */ DWORD dwAttributes,
    /* [in] */ DWORD dwAttributesEx,
    /* [unique][in] */ _WAVEFORMATEX __RPC_FAR *pAudioFormat,
    /* [unique][in] */ _VIDEOINFOHEADER __RPC_FAR *pVideoFormat,
    /* [in] */ LPWSTR pwszName,
    /* [in] */ ULONGLONG qwFileSize,
    /* [out] */ IMDSPStorage __RPC_FAR *__RPC_FAR *ppNewStorage);


void __RPC_STUB IMDSPStorage2_CreateStorage2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPStorage2_SetAttributes2_Proxy( 
    IMDSPStorage2 __RPC_FAR * This,
    /* [in] */ DWORD dwAttributes,
    /* [in] */ DWORD dwAttributesEx,
    /* [in] */ _WAVEFORMATEX __RPC_FAR *pAudioFormat,
    /* [in] */ _VIDEOINFOHEADER __RPC_FAR *pVideoFormat);


void __RPC_STUB IMDSPStorage2_SetAttributes2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPStorage2_GetAttributes2_Proxy( 
    IMDSPStorage2 __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwAttributes,
    /* [out] */ DWORD __RPC_FAR *pdwAttributesEx,
    /* [out] */ _WAVEFORMATEX __RPC_FAR *pAudioFormat,
    /* [out] */ _VIDEOINFOHEADER __RPC_FAR *pVideoFormat);


void __RPC_STUB IMDSPStorage2_GetAttributes2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMDSPStorage2_INTERFACE_DEFINED__ */


#ifndef __IMDSPStorageGlobals_INTERFACE_DEFINED__
#define __IMDSPStorageGlobals_INTERFACE_DEFINED__

/* interface IMDSPStorageGlobals */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMDSPStorageGlobals;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A17-33ED-11d3-8470-00C04F79DBC0")
    IMDSPStorageGlobals : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCapabilities( 
            /* [out] */ DWORD __RPC_FAR *pdwCapabilities) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSerialNumber( 
            /* [out] */ PWMDMID pSerialNum,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTotalSize( 
            /* [out] */ DWORD __RPC_FAR *pdwTotalSizeLow,
            /* [out] */ DWORD __RPC_FAR *pdwTotalSizeHigh) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTotalFree( 
            /* [out] */ DWORD __RPC_FAR *pdwFreeLow,
            /* [out] */ DWORD __RPC_FAR *pdwFreeHigh) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTotalBad( 
            /* [out] */ DWORD __RPC_FAR *pdwBadLow,
            /* [out] */ DWORD __RPC_FAR *pdwBadHigh) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ DWORD __RPC_FAR *pdwStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ UINT fuMode,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDevice( 
            /* [out] */ IMDSPDevice __RPC_FAR *__RPC_FAR *ppDevice) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRootStorage( 
            /* [out] */ IMDSPStorage __RPC_FAR *__RPC_FAR *ppRoot) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMDSPStorageGlobalsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMDSPStorageGlobals __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMDSPStorageGlobals __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMDSPStorageGlobals __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCapabilities )( 
            IMDSPStorageGlobals __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwCapabilities);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSerialNumber )( 
            IMDSPStorageGlobals __RPC_FAR * This,
            /* [out] */ PWMDMID pSerialNum,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTotalSize )( 
            IMDSPStorageGlobals __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwTotalSizeLow,
            /* [out] */ DWORD __RPC_FAR *pdwTotalSizeHigh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTotalFree )( 
            IMDSPStorageGlobals __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwFreeLow,
            /* [out] */ DWORD __RPC_FAR *pdwFreeHigh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTotalBad )( 
            IMDSPStorageGlobals __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwBadLow,
            /* [out] */ DWORD __RPC_FAR *pdwBadHigh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatus )( 
            IMDSPStorageGlobals __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IMDSPStorageGlobals __RPC_FAR * This,
            /* [in] */ UINT fuMode,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDevice )( 
            IMDSPStorageGlobals __RPC_FAR * This,
            /* [out] */ IMDSPDevice __RPC_FAR *__RPC_FAR *ppDevice);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRootStorage )( 
            IMDSPStorageGlobals __RPC_FAR * This,
            /* [out] */ IMDSPStorage __RPC_FAR *__RPC_FAR *ppRoot);
        
        END_INTERFACE
    } IMDSPStorageGlobalsVtbl;

    interface IMDSPStorageGlobals
    {
        CONST_VTBL struct IMDSPStorageGlobalsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMDSPStorageGlobals_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMDSPStorageGlobals_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMDSPStorageGlobals_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMDSPStorageGlobals_GetCapabilities(This,pdwCapabilities)	\
    (This)->lpVtbl -> GetCapabilities(This,pdwCapabilities)

#define IMDSPStorageGlobals_GetSerialNumber(This,pSerialNum,abMac)	\
    (This)->lpVtbl -> GetSerialNumber(This,pSerialNum,abMac)

#define IMDSPStorageGlobals_GetTotalSize(This,pdwTotalSizeLow,pdwTotalSizeHigh)	\
    (This)->lpVtbl -> GetTotalSize(This,pdwTotalSizeLow,pdwTotalSizeHigh)

#define IMDSPStorageGlobals_GetTotalFree(This,pdwFreeLow,pdwFreeHigh)	\
    (This)->lpVtbl -> GetTotalFree(This,pdwFreeLow,pdwFreeHigh)

#define IMDSPStorageGlobals_GetTotalBad(This,pdwBadLow,pdwBadHigh)	\
    (This)->lpVtbl -> GetTotalBad(This,pdwBadLow,pdwBadHigh)

#define IMDSPStorageGlobals_GetStatus(This,pdwStatus)	\
    (This)->lpVtbl -> GetStatus(This,pdwStatus)

#define IMDSPStorageGlobals_Initialize(This,fuMode,pProgress)	\
    (This)->lpVtbl -> Initialize(This,fuMode,pProgress)

#define IMDSPStorageGlobals_GetDevice(This,ppDevice)	\
    (This)->lpVtbl -> GetDevice(This,ppDevice)

#define IMDSPStorageGlobals_GetRootStorage(This,ppRoot)	\
    (This)->lpVtbl -> GetRootStorage(This,ppRoot)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMDSPStorageGlobals_GetCapabilities_Proxy( 
    IMDSPStorageGlobals __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwCapabilities);


void __RPC_STUB IMDSPStorageGlobals_GetCapabilities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPStorageGlobals_GetSerialNumber_Proxy( 
    IMDSPStorageGlobals __RPC_FAR * This,
    /* [out] */ PWMDMID pSerialNum,
    /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);


void __RPC_STUB IMDSPStorageGlobals_GetSerialNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPStorageGlobals_GetTotalSize_Proxy( 
    IMDSPStorageGlobals __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwTotalSizeLow,
    /* [out] */ DWORD __RPC_FAR *pdwTotalSizeHigh);


void __RPC_STUB IMDSPStorageGlobals_GetTotalSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPStorageGlobals_GetTotalFree_Proxy( 
    IMDSPStorageGlobals __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwFreeLow,
    /* [out] */ DWORD __RPC_FAR *pdwFreeHigh);


void __RPC_STUB IMDSPStorageGlobals_GetTotalFree_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPStorageGlobals_GetTotalBad_Proxy( 
    IMDSPStorageGlobals __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwBadLow,
    /* [out] */ DWORD __RPC_FAR *pdwBadHigh);


void __RPC_STUB IMDSPStorageGlobals_GetTotalBad_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPStorageGlobals_GetStatus_Proxy( 
    IMDSPStorageGlobals __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwStatus);


void __RPC_STUB IMDSPStorageGlobals_GetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPStorageGlobals_Initialize_Proxy( 
    IMDSPStorageGlobals __RPC_FAR * This,
    /* [in] */ UINT fuMode,
    /* [in] */ IWMDMProgress __RPC_FAR *pProgress);


void __RPC_STUB IMDSPStorageGlobals_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPStorageGlobals_GetDevice_Proxy( 
    IMDSPStorageGlobals __RPC_FAR * This,
    /* [out] */ IMDSPDevice __RPC_FAR *__RPC_FAR *ppDevice);


void __RPC_STUB IMDSPStorageGlobals_GetDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPStorageGlobals_GetRootStorage_Proxy( 
    IMDSPStorageGlobals __RPC_FAR * This,
    /* [out] */ IMDSPStorage __RPC_FAR *__RPC_FAR *ppRoot);


void __RPC_STUB IMDSPStorageGlobals_GetRootStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMDSPStorageGlobals_INTERFACE_DEFINED__ */


#ifndef __IMDSPObjectInfo_INTERFACE_DEFINED__
#define __IMDSPObjectInfo_INTERFACE_DEFINED__

/* interface IMDSPObjectInfo */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMDSPObjectInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A19-33ED-11d3-8470-00C04F79DBC0")
    IMDSPObjectInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPlayLength( 
            /* [out] */ DWORD __RPC_FAR *pdwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPlayLength( 
            /* [in] */ DWORD dwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPlayOffset( 
            /* [out] */ DWORD __RPC_FAR *pdwOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPlayOffset( 
            /* [in] */ DWORD dwOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTotalLength( 
            /* [out] */ DWORD __RPC_FAR *pdwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLastPlayPosition( 
            /* [out] */ DWORD __RPC_FAR *pdwLastPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLongestPlayPosition( 
            /* [out] */ DWORD __RPC_FAR *pdwLongestPos) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMDSPObjectInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMDSPObjectInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMDSPObjectInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMDSPObjectInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPlayLength )( 
            IMDSPObjectInfo __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPlayLength )( 
            IMDSPObjectInfo __RPC_FAR * This,
            /* [in] */ DWORD dwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPlayOffset )( 
            IMDSPObjectInfo __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwOffset);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPlayOffset )( 
            IMDSPObjectInfo __RPC_FAR * This,
            /* [in] */ DWORD dwOffset);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTotalLength )( 
            IMDSPObjectInfo __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastPlayPosition )( 
            IMDSPObjectInfo __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwLastPos);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLongestPlayPosition )( 
            IMDSPObjectInfo __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwLongestPos);
        
        END_INTERFACE
    } IMDSPObjectInfoVtbl;

    interface IMDSPObjectInfo
    {
        CONST_VTBL struct IMDSPObjectInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMDSPObjectInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMDSPObjectInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMDSPObjectInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMDSPObjectInfo_GetPlayLength(This,pdwLength)	\
    (This)->lpVtbl -> GetPlayLength(This,pdwLength)

#define IMDSPObjectInfo_SetPlayLength(This,dwLength)	\
    (This)->lpVtbl -> SetPlayLength(This,dwLength)

#define IMDSPObjectInfo_GetPlayOffset(This,pdwOffset)	\
    (This)->lpVtbl -> GetPlayOffset(This,pdwOffset)

#define IMDSPObjectInfo_SetPlayOffset(This,dwOffset)	\
    (This)->lpVtbl -> SetPlayOffset(This,dwOffset)

#define IMDSPObjectInfo_GetTotalLength(This,pdwLength)	\
    (This)->lpVtbl -> GetTotalLength(This,pdwLength)

#define IMDSPObjectInfo_GetLastPlayPosition(This,pdwLastPos)	\
    (This)->lpVtbl -> GetLastPlayPosition(This,pdwLastPos)

#define IMDSPObjectInfo_GetLongestPlayPosition(This,pdwLongestPos)	\
    (This)->lpVtbl -> GetLongestPlayPosition(This,pdwLongestPos)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMDSPObjectInfo_GetPlayLength_Proxy( 
    IMDSPObjectInfo __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwLength);


void __RPC_STUB IMDSPObjectInfo_GetPlayLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPObjectInfo_SetPlayLength_Proxy( 
    IMDSPObjectInfo __RPC_FAR * This,
    /* [in] */ DWORD dwLength);


void __RPC_STUB IMDSPObjectInfo_SetPlayLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPObjectInfo_GetPlayOffset_Proxy( 
    IMDSPObjectInfo __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwOffset);


void __RPC_STUB IMDSPObjectInfo_GetPlayOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPObjectInfo_SetPlayOffset_Proxy( 
    IMDSPObjectInfo __RPC_FAR * This,
    /* [in] */ DWORD dwOffset);


void __RPC_STUB IMDSPObjectInfo_SetPlayOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPObjectInfo_GetTotalLength_Proxy( 
    IMDSPObjectInfo __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwLength);


void __RPC_STUB IMDSPObjectInfo_GetTotalLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPObjectInfo_GetLastPlayPosition_Proxy( 
    IMDSPObjectInfo __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwLastPos);


void __RPC_STUB IMDSPObjectInfo_GetLastPlayPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPObjectInfo_GetLongestPlayPosition_Proxy( 
    IMDSPObjectInfo __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwLongestPos);


void __RPC_STUB IMDSPObjectInfo_GetLongestPlayPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMDSPObjectInfo_INTERFACE_DEFINED__ */


#ifndef __IMDSPObject_INTERFACE_DEFINED__
#define __IMDSPObject_INTERFACE_DEFINED__

/* interface IMDSPObject */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMDSPObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A18-33ED-11d3-8470-00C04F79DBC0")
    IMDSPObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ UINT fuMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Read( 
            /* [size_is][out] */ BYTE __RPC_FAR *pData,
            /* [out][in] */ DWORD __RPC_FAR *pdwSize,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Write( 
            /* [size_is][in] */ BYTE __RPC_FAR *pData,
            /* [out][in] */ DWORD __RPC_FAR *pdwSize,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ UINT fuMode,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Seek( 
            /* [in] */ UINT fuFlags,
            /* [in] */ DWORD dwOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Rename( 
            /* [in] */ LPWSTR pwszNewName,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Move( 
            /* [in] */ UINT fuMode,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress,
            /* [in] */ IMDSPStorage __RPC_FAR *pTarget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMDSPObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMDSPObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMDSPObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMDSPObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IMDSPObject __RPC_FAR * This,
            /* [in] */ UINT fuMode);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Read )( 
            IMDSPObject __RPC_FAR * This,
            /* [size_is][out] */ BYTE __RPC_FAR *pData,
            /* [out][in] */ DWORD __RPC_FAR *pdwSize,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Write )( 
            IMDSPObject __RPC_FAR * This,
            /* [size_is][in] */ BYTE __RPC_FAR *pData,
            /* [out][in] */ DWORD __RPC_FAR *pdwSize,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IMDSPObject __RPC_FAR * This,
            /* [in] */ UINT fuMode,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Seek )( 
            IMDSPObject __RPC_FAR * This,
            /* [in] */ UINT fuFlags,
            /* [in] */ DWORD dwOffset);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Rename )( 
            IMDSPObject __RPC_FAR * This,
            /* [in] */ LPWSTR pwszNewName,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Move )( 
            IMDSPObject __RPC_FAR * This,
            /* [in] */ UINT fuMode,
            /* [in] */ IWMDMProgress __RPC_FAR *pProgress,
            /* [in] */ IMDSPStorage __RPC_FAR *pTarget);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IMDSPObject __RPC_FAR * This);
        
        END_INTERFACE
    } IMDSPObjectVtbl;

    interface IMDSPObject
    {
        CONST_VTBL struct IMDSPObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMDSPObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMDSPObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMDSPObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMDSPObject_Open(This,fuMode)	\
    (This)->lpVtbl -> Open(This,fuMode)

#define IMDSPObject_Read(This,pData,pdwSize,abMac)	\
    (This)->lpVtbl -> Read(This,pData,pdwSize,abMac)

#define IMDSPObject_Write(This,pData,pdwSize,abMac)	\
    (This)->lpVtbl -> Write(This,pData,pdwSize,abMac)

#define IMDSPObject_Delete(This,fuMode,pProgress)	\
    (This)->lpVtbl -> Delete(This,fuMode,pProgress)

#define IMDSPObject_Seek(This,fuFlags,dwOffset)	\
    (This)->lpVtbl -> Seek(This,fuFlags,dwOffset)

#define IMDSPObject_Rename(This,pwszNewName,pProgress)	\
    (This)->lpVtbl -> Rename(This,pwszNewName,pProgress)

#define IMDSPObject_Move(This,fuMode,pProgress,pTarget)	\
    (This)->lpVtbl -> Move(This,fuMode,pProgress,pTarget)

#define IMDSPObject_Close(This)	\
    (This)->lpVtbl -> Close(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMDSPObject_Open_Proxy( 
    IMDSPObject __RPC_FAR * This,
    /* [in] */ UINT fuMode);


void __RPC_STUB IMDSPObject_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPObject_Read_Proxy( 
    IMDSPObject __RPC_FAR * This,
    /* [size_is][out] */ BYTE __RPC_FAR *pData,
    /* [out][in] */ DWORD __RPC_FAR *pdwSize,
    /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);


void __RPC_STUB IMDSPObject_Read_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPObject_Write_Proxy( 
    IMDSPObject __RPC_FAR * This,
    /* [size_is][in] */ BYTE __RPC_FAR *pData,
    /* [out][in] */ DWORD __RPC_FAR *pdwSize,
    /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);


void __RPC_STUB IMDSPObject_Write_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPObject_Delete_Proxy( 
    IMDSPObject __RPC_FAR * This,
    /* [in] */ UINT fuMode,
    /* [in] */ IWMDMProgress __RPC_FAR *pProgress);


void __RPC_STUB IMDSPObject_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPObject_Seek_Proxy( 
    IMDSPObject __RPC_FAR * This,
    /* [in] */ UINT fuFlags,
    /* [in] */ DWORD dwOffset);


void __RPC_STUB IMDSPObject_Seek_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPObject_Rename_Proxy( 
    IMDSPObject __RPC_FAR * This,
    /* [in] */ LPWSTR pwszNewName,
    /* [in] */ IWMDMProgress __RPC_FAR *pProgress);


void __RPC_STUB IMDSPObject_Rename_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPObject_Move_Proxy( 
    IMDSPObject __RPC_FAR * This,
    /* [in] */ UINT fuMode,
    /* [in] */ IWMDMProgress __RPC_FAR *pProgress,
    /* [in] */ IMDSPStorage __RPC_FAR *pTarget);


void __RPC_STUB IMDSPObject_Move_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMDSPObject_Close_Proxy( 
    IMDSPObject __RPC_FAR * This);


void __RPC_STUB IMDSPObject_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMDSPObject_INTERFACE_DEFINED__ */


#ifndef __IMDSPRevoked_INTERFACE_DEFINED__
#define __IMDSPRevoked_INTERFACE_DEFINED__

/* interface IMDSPRevoked */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMDSPRevoked;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A4E8F2D4-3F31-464d-B53D-4FC335998184")
    IMDSPRevoked : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRevocationURL( 
            /* [size_is][size_is][string][out][in] */ LPWSTR __RPC_FAR *ppwszRevocationURL,
            /* [out][in] */ DWORD __RPC_FAR *pdwBufferLen) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMDSPRevokedVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMDSPRevoked __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMDSPRevoked __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMDSPRevoked __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRevocationURL )( 
            IMDSPRevoked __RPC_FAR * This,
            /* [size_is][size_is][string][out][in] */ LPWSTR __RPC_FAR *ppwszRevocationURL,
            /* [out][in] */ DWORD __RPC_FAR *pdwBufferLen);
        
        END_INTERFACE
    } IMDSPRevokedVtbl;

    interface IMDSPRevoked
    {
        CONST_VTBL struct IMDSPRevokedVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMDSPRevoked_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMDSPRevoked_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMDSPRevoked_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMDSPRevoked_GetRevocationURL(This,ppwszRevocationURL,pdwBufferLen)	\
    (This)->lpVtbl -> GetRevocationURL(This,ppwszRevocationURL,pdwBufferLen)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMDSPRevoked_GetRevocationURL_Proxy( 
    IMDSPRevoked __RPC_FAR * This,
    /* [size_is][size_is][string][out][in] */ LPWSTR __RPC_FAR *ppwszRevocationURL,
    /* [out][in] */ DWORD __RPC_FAR *pdwBufferLen);


void __RPC_STUB IMDSPRevoked_GetRevocationURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMDSPRevoked_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mswmdm_0242 */
/* [local] */ 

// SCP Data Flags
#define WMDM_SCP_EXAMINE_EXTENSION                 0x00000001L
#define WMDM_SCP_EXAMINE_DATA                      0x00000002L
#define WMDM_SCP_DECIDE_DATA                       0x00000008L
#define WMDM_SCP_PROTECTED_OUTPUT                  0x00000010L
#define WMDM_SCP_UNPROTECTED_OUTPUT                0x00000020L
#define WMDM_SCP_RIGHTS_DATA                       0x00000040L
// SCP Transfer Flags
#define WMDM_SCP_TRANSFER_OBJECTDATA               0x00000020L
#define WMDM_SCP_NO_MORE_CHANGES                   0x00000040L





extern RPC_IF_HANDLE __MIDL_itf_mswmdm_0242_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mswmdm_0242_v0_0_s_ifspec;

#ifndef __ISCPSecureAuthenticate_INTERFACE_DEFINED__
#define __ISCPSecureAuthenticate_INTERFACE_DEFINED__

/* interface ISCPSecureAuthenticate */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISCPSecureAuthenticate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A0F-33ED-11d3-8470-00C04F79DBC0")
    ISCPSecureAuthenticate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSecureQuery( 
            /* [out] */ ISCPSecureQuery __RPC_FAR *__RPC_FAR *ppSecureQuery) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISCPSecureAuthenticateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISCPSecureAuthenticate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISCPSecureAuthenticate __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISCPSecureAuthenticate __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSecureQuery )( 
            ISCPSecureAuthenticate __RPC_FAR * This,
            /* [out] */ ISCPSecureQuery __RPC_FAR *__RPC_FAR *ppSecureQuery);
        
        END_INTERFACE
    } ISCPSecureAuthenticateVtbl;

    interface ISCPSecureAuthenticate
    {
        CONST_VTBL struct ISCPSecureAuthenticateVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISCPSecureAuthenticate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISCPSecureAuthenticate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISCPSecureAuthenticate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISCPSecureAuthenticate_GetSecureQuery(This,ppSecureQuery)	\
    (This)->lpVtbl -> GetSecureQuery(This,ppSecureQuery)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISCPSecureAuthenticate_GetSecureQuery_Proxy( 
    ISCPSecureAuthenticate __RPC_FAR * This,
    /* [out] */ ISCPSecureQuery __RPC_FAR *__RPC_FAR *ppSecureQuery);


void __RPC_STUB ISCPSecureAuthenticate_GetSecureQuery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISCPSecureAuthenticate_INTERFACE_DEFINED__ */


#ifndef __ISCPSecureQuery_INTERFACE_DEFINED__
#define __ISCPSecureQuery_INTERFACE_DEFINED__

/* interface ISCPSecureQuery */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISCPSecureQuery;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A0D-33ED-11d3-8470-00C04F79DBC0")
    ISCPSecureQuery : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDataDemands( 
            /* [out] */ UINT __RPC_FAR *pfuFlags,
            /* [out] */ DWORD __RPC_FAR *pdwMinRightsData,
            /* [out] */ DWORD __RPC_FAR *pdwMinExamineData,
            /* [out] */ DWORD __RPC_FAR *pdwMinDecideData,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExamineData( 
            /* [in] */ UINT fuFlags,
            /* [unique][string][in] */ LPWSTR pwszExtension,
            /* [size_is][in] */ BYTE __RPC_FAR *pData,
            /* [in] */ DWORD dwSize,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MakeDecision( 
            /* [in] */ UINT fuFlags,
            /* [size_is][in] */ BYTE __RPC_FAR *pData,
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwAppSec,
            /* [size_is][in] */ BYTE __RPC_FAR *pbSPSessionKey,
            /* [in] */ DWORD dwSessionKeyLen,
            /* [in] */ IMDSPStorageGlobals __RPC_FAR *pStorageGlobals,
            /* [out] */ ISCPSecureExchange __RPC_FAR *__RPC_FAR *ppExchange,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRights( 
            /* [size_is][in] */ BYTE __RPC_FAR *pData,
            /* [in] */ DWORD dwSize,
            /* [size_is][in] */ BYTE __RPC_FAR *pbSPSessionKey,
            /* [in] */ DWORD dwSessionKeyLen,
            /* [in] */ IMDSPStorageGlobals __RPC_FAR *pStgGlobals,
            /* [size_is][size_is][out] */ PWMDMRIGHTS __RPC_FAR *ppRights,
            /* [out] */ UINT __RPC_FAR *pnRightsCount,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISCPSecureQueryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISCPSecureQuery __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISCPSecureQuery __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISCPSecureQuery __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDataDemands )( 
            ISCPSecureQuery __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pfuFlags,
            /* [out] */ DWORD __RPC_FAR *pdwMinRightsData,
            /* [out] */ DWORD __RPC_FAR *pdwMinExamineData,
            /* [out] */ DWORD __RPC_FAR *pdwMinDecideData,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExamineData )( 
            ISCPSecureQuery __RPC_FAR * This,
            /* [in] */ UINT fuFlags,
            /* [unique][string][in] */ LPWSTR pwszExtension,
            /* [size_is][in] */ BYTE __RPC_FAR *pData,
            /* [in] */ DWORD dwSize,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MakeDecision )( 
            ISCPSecureQuery __RPC_FAR * This,
            /* [in] */ UINT fuFlags,
            /* [size_is][in] */ BYTE __RPC_FAR *pData,
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwAppSec,
            /* [size_is][in] */ BYTE __RPC_FAR *pbSPSessionKey,
            /* [in] */ DWORD dwSessionKeyLen,
            /* [in] */ IMDSPStorageGlobals __RPC_FAR *pStorageGlobals,
            /* [out] */ ISCPSecureExchange __RPC_FAR *__RPC_FAR *ppExchange,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRights )( 
            ISCPSecureQuery __RPC_FAR * This,
            /* [size_is][in] */ BYTE __RPC_FAR *pData,
            /* [in] */ DWORD dwSize,
            /* [size_is][in] */ BYTE __RPC_FAR *pbSPSessionKey,
            /* [in] */ DWORD dwSessionKeyLen,
            /* [in] */ IMDSPStorageGlobals __RPC_FAR *pStgGlobals,
            /* [size_is][size_is][out] */ PWMDMRIGHTS __RPC_FAR *ppRights,
            /* [out] */ UINT __RPC_FAR *pnRightsCount,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        END_INTERFACE
    } ISCPSecureQueryVtbl;

    interface ISCPSecureQuery
    {
        CONST_VTBL struct ISCPSecureQueryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISCPSecureQuery_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISCPSecureQuery_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISCPSecureQuery_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISCPSecureQuery_GetDataDemands(This,pfuFlags,pdwMinRightsData,pdwMinExamineData,pdwMinDecideData,abMac)	\
    (This)->lpVtbl -> GetDataDemands(This,pfuFlags,pdwMinRightsData,pdwMinExamineData,pdwMinDecideData,abMac)

#define ISCPSecureQuery_ExamineData(This,fuFlags,pwszExtension,pData,dwSize,abMac)	\
    (This)->lpVtbl -> ExamineData(This,fuFlags,pwszExtension,pData,dwSize,abMac)

#define ISCPSecureQuery_MakeDecision(This,fuFlags,pData,dwSize,dwAppSec,pbSPSessionKey,dwSessionKeyLen,pStorageGlobals,ppExchange,abMac)	\
    (This)->lpVtbl -> MakeDecision(This,fuFlags,pData,dwSize,dwAppSec,pbSPSessionKey,dwSessionKeyLen,pStorageGlobals,ppExchange,abMac)

#define ISCPSecureQuery_GetRights(This,pData,dwSize,pbSPSessionKey,dwSessionKeyLen,pStgGlobals,ppRights,pnRightsCount,abMac)	\
    (This)->lpVtbl -> GetRights(This,pData,dwSize,pbSPSessionKey,dwSessionKeyLen,pStgGlobals,ppRights,pnRightsCount,abMac)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISCPSecureQuery_GetDataDemands_Proxy( 
    ISCPSecureQuery __RPC_FAR * This,
    /* [out] */ UINT __RPC_FAR *pfuFlags,
    /* [out] */ DWORD __RPC_FAR *pdwMinRightsData,
    /* [out] */ DWORD __RPC_FAR *pdwMinExamineData,
    /* [out] */ DWORD __RPC_FAR *pdwMinDecideData,
    /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);


void __RPC_STUB ISCPSecureQuery_GetDataDemands_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISCPSecureQuery_ExamineData_Proxy( 
    ISCPSecureQuery __RPC_FAR * This,
    /* [in] */ UINT fuFlags,
    /* [unique][string][in] */ LPWSTR pwszExtension,
    /* [size_is][in] */ BYTE __RPC_FAR *pData,
    /* [in] */ DWORD dwSize,
    /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);


void __RPC_STUB ISCPSecureQuery_ExamineData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISCPSecureQuery_MakeDecision_Proxy( 
    ISCPSecureQuery __RPC_FAR * This,
    /* [in] */ UINT fuFlags,
    /* [size_is][in] */ BYTE __RPC_FAR *pData,
    /* [in] */ DWORD dwSize,
    /* [in] */ DWORD dwAppSec,
    /* [size_is][in] */ BYTE __RPC_FAR *pbSPSessionKey,
    /* [in] */ DWORD dwSessionKeyLen,
    /* [in] */ IMDSPStorageGlobals __RPC_FAR *pStorageGlobals,
    /* [out] */ ISCPSecureExchange __RPC_FAR *__RPC_FAR *ppExchange,
    /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);


void __RPC_STUB ISCPSecureQuery_MakeDecision_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISCPSecureQuery_GetRights_Proxy( 
    ISCPSecureQuery __RPC_FAR * This,
    /* [size_is][in] */ BYTE __RPC_FAR *pData,
    /* [in] */ DWORD dwSize,
    /* [size_is][in] */ BYTE __RPC_FAR *pbSPSessionKey,
    /* [in] */ DWORD dwSessionKeyLen,
    /* [in] */ IMDSPStorageGlobals __RPC_FAR *pStgGlobals,
    /* [size_is][size_is][out] */ PWMDMRIGHTS __RPC_FAR *ppRights,
    /* [out] */ UINT __RPC_FAR *pnRightsCount,
    /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);


void __RPC_STUB ISCPSecureQuery_GetRights_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISCPSecureQuery_INTERFACE_DEFINED__ */


#ifndef __ISCPSecureQuery2_INTERFACE_DEFINED__
#define __ISCPSecureQuery2_INTERFACE_DEFINED__

/* interface ISCPSecureQuery2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISCPSecureQuery2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EBE17E25-4FD7-4632-AF46-6D93D4FCC72E")
    ISCPSecureQuery2 : public ISCPSecureQuery
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE MakeDecision2( 
            /* [in] */ UINT fuFlags,
            /* [size_is][in] */ BYTE __RPC_FAR *pData,
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwAppSec,
            /* [size_is][in] */ BYTE __RPC_FAR *pbSPSessionKey,
            /* [in] */ DWORD dwSessionKeyLen,
            /* [in] */ IMDSPStorageGlobals __RPC_FAR *pStorageGlobals,
            /* [size_is][in] */ BYTE __RPC_FAR *pAppCertApp,
            /* [in] */ DWORD dwAppCertAppLen,
            /* [size_is][in] */ BYTE __RPC_FAR *pAppCertSP,
            /* [in] */ DWORD dwAppCertSPLen,
            /* [size_is][size_is][string][out][in] */ LPWSTR __RPC_FAR *pszRevocationURL,
            /* [ref][out][in] */ DWORD __RPC_FAR *pdwRevocationURLLen,
            /* [out] */ DWORD __RPC_FAR *pdwRevocationBitFlag,
            /* [unique][out][in] */ ULONGLONG __RPC_FAR *pqwFileSize,
            /* [in] */ IUnknown __RPC_FAR *pUnknown,
            /* [out] */ ISCPSecureExchange __RPC_FAR *__RPC_FAR *ppExchange,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISCPSecureQuery2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISCPSecureQuery2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISCPSecureQuery2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISCPSecureQuery2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDataDemands )( 
            ISCPSecureQuery2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pfuFlags,
            /* [out] */ DWORD __RPC_FAR *pdwMinRightsData,
            /* [out] */ DWORD __RPC_FAR *pdwMinExamineData,
            /* [out] */ DWORD __RPC_FAR *pdwMinDecideData,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExamineData )( 
            ISCPSecureQuery2 __RPC_FAR * This,
            /* [in] */ UINT fuFlags,
            /* [unique][string][in] */ LPWSTR pwszExtension,
            /* [size_is][in] */ BYTE __RPC_FAR *pData,
            /* [in] */ DWORD dwSize,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MakeDecision )( 
            ISCPSecureQuery2 __RPC_FAR * This,
            /* [in] */ UINT fuFlags,
            /* [size_is][in] */ BYTE __RPC_FAR *pData,
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwAppSec,
            /* [size_is][in] */ BYTE __RPC_FAR *pbSPSessionKey,
            /* [in] */ DWORD dwSessionKeyLen,
            /* [in] */ IMDSPStorageGlobals __RPC_FAR *pStorageGlobals,
            /* [out] */ ISCPSecureExchange __RPC_FAR *__RPC_FAR *ppExchange,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRights )( 
            ISCPSecureQuery2 __RPC_FAR * This,
            /* [size_is][in] */ BYTE __RPC_FAR *pData,
            /* [in] */ DWORD dwSize,
            /* [size_is][in] */ BYTE __RPC_FAR *pbSPSessionKey,
            /* [in] */ DWORD dwSessionKeyLen,
            /* [in] */ IMDSPStorageGlobals __RPC_FAR *pStgGlobals,
            /* [size_is][size_is][out] */ PWMDMRIGHTS __RPC_FAR *ppRights,
            /* [out] */ UINT __RPC_FAR *pnRightsCount,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MakeDecision2 )( 
            ISCPSecureQuery2 __RPC_FAR * This,
            /* [in] */ UINT fuFlags,
            /* [size_is][in] */ BYTE __RPC_FAR *pData,
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwAppSec,
            /* [size_is][in] */ BYTE __RPC_FAR *pbSPSessionKey,
            /* [in] */ DWORD dwSessionKeyLen,
            /* [in] */ IMDSPStorageGlobals __RPC_FAR *pStorageGlobals,
            /* [size_is][in] */ BYTE __RPC_FAR *pAppCertApp,
            /* [in] */ DWORD dwAppCertAppLen,
            /* [size_is][in] */ BYTE __RPC_FAR *pAppCertSP,
            /* [in] */ DWORD dwAppCertSPLen,
            /* [size_is][size_is][string][out][in] */ LPWSTR __RPC_FAR *pszRevocationURL,
            /* [ref][out][in] */ DWORD __RPC_FAR *pdwRevocationURLLen,
            /* [out] */ DWORD __RPC_FAR *pdwRevocationBitFlag,
            /* [unique][out][in] */ ULONGLONG __RPC_FAR *pqwFileSize,
            /* [in] */ IUnknown __RPC_FAR *pUnknown,
            /* [out] */ ISCPSecureExchange __RPC_FAR *__RPC_FAR *ppExchange,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        END_INTERFACE
    } ISCPSecureQuery2Vtbl;

    interface ISCPSecureQuery2
    {
        CONST_VTBL struct ISCPSecureQuery2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISCPSecureQuery2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISCPSecureQuery2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISCPSecureQuery2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISCPSecureQuery2_GetDataDemands(This,pfuFlags,pdwMinRightsData,pdwMinExamineData,pdwMinDecideData,abMac)	\
    (This)->lpVtbl -> GetDataDemands(This,pfuFlags,pdwMinRightsData,pdwMinExamineData,pdwMinDecideData,abMac)

#define ISCPSecureQuery2_ExamineData(This,fuFlags,pwszExtension,pData,dwSize,abMac)	\
    (This)->lpVtbl -> ExamineData(This,fuFlags,pwszExtension,pData,dwSize,abMac)

#define ISCPSecureQuery2_MakeDecision(This,fuFlags,pData,dwSize,dwAppSec,pbSPSessionKey,dwSessionKeyLen,pStorageGlobals,ppExchange,abMac)	\
    (This)->lpVtbl -> MakeDecision(This,fuFlags,pData,dwSize,dwAppSec,pbSPSessionKey,dwSessionKeyLen,pStorageGlobals,ppExchange,abMac)

#define ISCPSecureQuery2_GetRights(This,pData,dwSize,pbSPSessionKey,dwSessionKeyLen,pStgGlobals,ppRights,pnRightsCount,abMac)	\
    (This)->lpVtbl -> GetRights(This,pData,dwSize,pbSPSessionKey,dwSessionKeyLen,pStgGlobals,ppRights,pnRightsCount,abMac)


#define ISCPSecureQuery2_MakeDecision2(This,fuFlags,pData,dwSize,dwAppSec,pbSPSessionKey,dwSessionKeyLen,pStorageGlobals,pAppCertApp,dwAppCertAppLen,pAppCertSP,dwAppCertSPLen,pszRevocationURL,pdwRevocationURLLen,pdwRevocationBitFlag,pqwFileSize,pUnknown,ppExchange,abMac)	\
    (This)->lpVtbl -> MakeDecision2(This,fuFlags,pData,dwSize,dwAppSec,pbSPSessionKey,dwSessionKeyLen,pStorageGlobals,pAppCertApp,dwAppCertAppLen,pAppCertSP,dwAppCertSPLen,pszRevocationURL,pdwRevocationURLLen,pdwRevocationBitFlag,pqwFileSize,pUnknown,ppExchange,abMac)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISCPSecureQuery2_MakeDecision2_Proxy( 
    ISCPSecureQuery2 __RPC_FAR * This,
    /* [in] */ UINT fuFlags,
    /* [size_is][in] */ BYTE __RPC_FAR *pData,
    /* [in] */ DWORD dwSize,
    /* [in] */ DWORD dwAppSec,
    /* [size_is][in] */ BYTE __RPC_FAR *pbSPSessionKey,
    /* [in] */ DWORD dwSessionKeyLen,
    /* [in] */ IMDSPStorageGlobals __RPC_FAR *pStorageGlobals,
    /* [size_is][in] */ BYTE __RPC_FAR *pAppCertApp,
    /* [in] */ DWORD dwAppCertAppLen,
    /* [size_is][in] */ BYTE __RPC_FAR *pAppCertSP,
    /* [in] */ DWORD dwAppCertSPLen,
    /* [size_is][size_is][string][out][in] */ LPWSTR __RPC_FAR *pszRevocationURL,
    /* [ref][out][in] */ DWORD __RPC_FAR *pdwRevocationURLLen,
    /* [out] */ DWORD __RPC_FAR *pdwRevocationBitFlag,
    /* [unique][out][in] */ ULONGLONG __RPC_FAR *pqwFileSize,
    /* [in] */ IUnknown __RPC_FAR *pUnknown,
    /* [out] */ ISCPSecureExchange __RPC_FAR *__RPC_FAR *ppExchange,
    /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);


void __RPC_STUB ISCPSecureQuery2_MakeDecision2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISCPSecureQuery2_INTERFACE_DEFINED__ */


#ifndef __ISCPSecureExchange_INTERFACE_DEFINED__
#define __ISCPSecureExchange_INTERFACE_DEFINED__

/* interface ISCPSecureExchange */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISCPSecureExchange;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCB3A0E-33ED-11d3-8470-00C04F79DBC0")
    ISCPSecureExchange : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE TransferContainerData( 
            /* [size_is][in] */ BYTE __RPC_FAR *pData,
            /* [in] */ DWORD dwSize,
            /* [out] */ UINT __RPC_FAR *pfuReadyFlags,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ObjectData( 
            /* [size_is][out] */ BYTE __RPC_FAR *pData,
            /* [out][in] */ DWORD __RPC_FAR *pdwSize,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TransferComplete( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISCPSecureExchangeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISCPSecureExchange __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISCPSecureExchange __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISCPSecureExchange __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TransferContainerData )( 
            ISCPSecureExchange __RPC_FAR * This,
            /* [size_is][in] */ BYTE __RPC_FAR *pData,
            /* [in] */ DWORD dwSize,
            /* [out] */ UINT __RPC_FAR *pfuReadyFlags,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ObjectData )( 
            ISCPSecureExchange __RPC_FAR * This,
            /* [size_is][out] */ BYTE __RPC_FAR *pData,
            /* [out][in] */ DWORD __RPC_FAR *pdwSize,
            /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TransferComplete )( 
            ISCPSecureExchange __RPC_FAR * This);
        
        END_INTERFACE
    } ISCPSecureExchangeVtbl;

    interface ISCPSecureExchange
    {
        CONST_VTBL struct ISCPSecureExchangeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISCPSecureExchange_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISCPSecureExchange_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISCPSecureExchange_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISCPSecureExchange_TransferContainerData(This,pData,dwSize,pfuReadyFlags,abMac)	\
    (This)->lpVtbl -> TransferContainerData(This,pData,dwSize,pfuReadyFlags,abMac)

#define ISCPSecureExchange_ObjectData(This,pData,pdwSize,abMac)	\
    (This)->lpVtbl -> ObjectData(This,pData,pdwSize,abMac)

#define ISCPSecureExchange_TransferComplete(This)	\
    (This)->lpVtbl -> TransferComplete(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISCPSecureExchange_TransferContainerData_Proxy( 
    ISCPSecureExchange __RPC_FAR * This,
    /* [size_is][in] */ BYTE __RPC_FAR *pData,
    /* [in] */ DWORD dwSize,
    /* [out] */ UINT __RPC_FAR *pfuReadyFlags,
    /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);


void __RPC_STUB ISCPSecureExchange_TransferContainerData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISCPSecureExchange_ObjectData_Proxy( 
    ISCPSecureExchange __RPC_FAR * This,
    /* [size_is][out] */ BYTE __RPC_FAR *pData,
    /* [out][in] */ DWORD __RPC_FAR *pdwSize,
    /* [out][in] */ BYTE __RPC_FAR abMac[ 8 ]);


void __RPC_STUB ISCPSecureExchange_ObjectData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISCPSecureExchange_TransferComplete_Proxy( 
    ISCPSecureExchange __RPC_FAR * This);


void __RPC_STUB ISCPSecureExchange_TransferComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISCPSecureExchange_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mswmdm_0246 */
/* [local] */ 

#define SAC_MAC_LEN 8


extern RPC_IF_HANDLE __MIDL_itf_mswmdm_0246_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mswmdm_0246_v0_0_s_ifspec;

#ifndef __IComponentAuthenticate_INTERFACE_DEFINED__
#define __IComponentAuthenticate_INTERFACE_DEFINED__

/* interface IComponentAuthenticate */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IComponentAuthenticate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A9889C00-6D2B-11d3-8496-00C04F79DBC0")
    IComponentAuthenticate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SACAuth( 
            /* [in] */ DWORD dwProtocolID,
            /* [in] */ DWORD dwPass,
            /* [size_is][in] */ BYTE __RPC_FAR *pbDataIn,
            /* [in] */ DWORD dwDataInLen,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbDataOut,
            /* [out] */ DWORD __RPC_FAR *pdwDataOutLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SACGetProtocols( 
            /* [size_is][size_is][out] */ DWORD __RPC_FAR *__RPC_FAR *ppdwProtocols,
            /* [out] */ DWORD __RPC_FAR *pdwProtocolCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComponentAuthenticateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IComponentAuthenticate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IComponentAuthenticate __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IComponentAuthenticate __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SACAuth )( 
            IComponentAuthenticate __RPC_FAR * This,
            /* [in] */ DWORD dwProtocolID,
            /* [in] */ DWORD dwPass,
            /* [size_is][in] */ BYTE __RPC_FAR *pbDataIn,
            /* [in] */ DWORD dwDataInLen,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbDataOut,
            /* [out] */ DWORD __RPC_FAR *pdwDataOutLen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SACGetProtocols )( 
            IComponentAuthenticate __RPC_FAR * This,
            /* [size_is][size_is][out] */ DWORD __RPC_FAR *__RPC_FAR *ppdwProtocols,
            /* [out] */ DWORD __RPC_FAR *pdwProtocolCount);
        
        END_INTERFACE
    } IComponentAuthenticateVtbl;

    interface IComponentAuthenticate
    {
        CONST_VTBL struct IComponentAuthenticateVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComponentAuthenticate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComponentAuthenticate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComponentAuthenticate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComponentAuthenticate_SACAuth(This,dwProtocolID,dwPass,pbDataIn,dwDataInLen,ppbDataOut,pdwDataOutLen)	\
    (This)->lpVtbl -> SACAuth(This,dwProtocolID,dwPass,pbDataIn,dwDataInLen,ppbDataOut,pdwDataOutLen)

#define IComponentAuthenticate_SACGetProtocols(This,ppdwProtocols,pdwProtocolCount)	\
    (This)->lpVtbl -> SACGetProtocols(This,ppdwProtocols,pdwProtocolCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IComponentAuthenticate_SACAuth_Proxy( 
    IComponentAuthenticate __RPC_FAR * This,
    /* [in] */ DWORD dwProtocolID,
    /* [in] */ DWORD dwPass,
    /* [size_is][in] */ BYTE __RPC_FAR *pbDataIn,
    /* [in] */ DWORD dwDataInLen,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbDataOut,
    /* [out] */ DWORD __RPC_FAR *pdwDataOutLen);


void __RPC_STUB IComponentAuthenticate_SACAuth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IComponentAuthenticate_SACGetProtocols_Proxy( 
    IComponentAuthenticate __RPC_FAR * This,
    /* [size_is][size_is][out] */ DWORD __RPC_FAR *__RPC_FAR *ppdwProtocols,
    /* [out] */ DWORD __RPC_FAR *pdwProtocolCount);


void __RPC_STUB IComponentAuthenticate_SACGetProtocols_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComponentAuthenticate_INTERFACE_DEFINED__ */



#ifndef __MSWMDMLib_LIBRARY_DEFINED__
#define __MSWMDMLib_LIBRARY_DEFINED__

/* library MSWMDMLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_MSWMDMLib;

EXTERN_C const CLSID CLSID_MediaDevMgrClassFactory;

#ifdef __cplusplus

class DECLSPEC_UUID("50040C1D-BDBF-4924-B873-F14D6C5BFD66")
MediaDevMgrClassFactory;
#endif

EXTERN_C const CLSID CLSID_MediaDevMgr;

#ifdef __cplusplus

class DECLSPEC_UUID("25BAAD81-3560-11D3-8471-00C04F79DBC0")
MediaDevMgr;
#endif

EXTERN_C const CLSID CLSID_WMDMDevice;

#ifdef __cplusplus

class DECLSPEC_UUID("807B3CDF-357A-11d3-8471-00C04F79DBC0")
WMDMDevice;
#endif

EXTERN_C const CLSID CLSID_WMDMStorage;

#ifdef __cplusplus

class DECLSPEC_UUID("807B3CE0-357A-11d3-8471-00C04F79DBC0")
WMDMStorage;
#endif

EXTERN_C const CLSID CLSID_WMDMStorageGlobal;

#ifdef __cplusplus

class DECLSPEC_UUID("807B3CE1-357A-11d3-8471-00C04F79DBC0")
WMDMStorageGlobal;
#endif

EXTERN_C const CLSID CLSID_WMDMDeviceEnum;

#ifdef __cplusplus

class DECLSPEC_UUID("430E35AF-3971-11D3-8474-00C04F79DBC0")
WMDMDeviceEnum;
#endif

EXTERN_C const CLSID CLSID_WMDMStorageEnum;

#ifdef __cplusplus

class DECLSPEC_UUID("EB401A3B-3AF7-11d3-8474-00C04F79DBC0")
WMDMStorageEnum;
#endif
#endif /* __MSWMDMLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\wmsdk\inc\mswmdm_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0164 */
/* at Wed Aug 08 01:15:08 2001
 */
/* Compiler settings for .\mswmdm.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IWMDeviceManager = {0x1DCB3A00,0x33ED,0x11d3,{0x84,0x70,0x00,0xC0,0x4F,0x79,0xDB,0xC0}};


const IID IID_IWMDeviceManager2 = {0x923E5249,0x8731,0x4c5b,{0x9B,0x1C,0xB8,0xB6,0x0B,0x6E,0x46,0xAF}};


const IID IID_IWMDMStorageGlobals = {0x1DCB3A07,0x33ED,0x11d3,{0x84,0x70,0x00,0xC0,0x4F,0x79,0xDB,0xC0}};


const IID IID_IWMDMStorage = {0x1DCB3A06,0x33ED,0x11d3,{0x84,0x70,0x00,0xC0,0x4F,0x79,0xDB,0xC0}};


const IID IID_IWMDMStorage2 = {0x1ED5A144,0x5CD5,0x4683,{0x9E,0xFF,0x72,0xCB,0xDB,0x2D,0x95,0x33}};


const IID IID_IWMDMOperation = {0x1DCB3A0B,0x33ED,0x11d3,{0x84,0x70,0x00,0xC0,0x4F,0x79,0xDB,0xC0}};


const IID IID_IWMDMOperation2 = {0x33445B48,0x7DF7,0x425c,{0xAD,0x8F,0x0F,0xC6,0xD8,0x2F,0x9F,0x75}};


const IID IID_IWMDMProgress = {0x1DCB3A0C,0x33ED,0x11d3,{0x84,0x70,0x00,0xC0,0x4F,0x79,0xDB,0xC0}};


const IID IID_IWMDMProgress2 = {0x3A43F550,0xB383,0x4e92,{0xB0,0x4A,0xE6,0xBB,0xC6,0x60,0xFE,0xFC}};


const IID IID_IWMDMDevice = {0x1DCB3A02,0x33ED,0x11d3,{0x84,0x70,0x00,0xC0,0x4F,0x79,0xDB,0xC0}};


const IID IID_IWMDMDevice2 = {0xE34F3D37,0x9D67,0x4fc1,{0x92,0x52,0x62,0xD2,0x8B,0x2F,0x8B,0x55}};


const IID IID_IWMDMEnumDevice = {0x1DCB3A01,0x33ED,0x11d3,{0x84,0x70,0x00,0xC0,0x4F,0x79,0xDB,0xC0}};


const IID IID_IWMDMDeviceControl = {0x1DCB3A04,0x33ED,0x11d3,{0x84,0x70,0x00,0xC0,0x4F,0x79,0xDB,0xC0}};


const IID IID_IWMDMEnumStorage = {0x1DCB3A05,0x33ED,0x11d3,{0x84,0x70,0x00,0xC0,0x4F,0x79,0xDB,0xC0}};


const IID IID_IWMDMStorageControl = {0x1DCB3A08,0x33ED,0x11d3,{0x84,0x70,0x00,0xC0,0x4F,0x79,0xDB,0xC0}};


const IID IID_IWMDMStorageControl2 = {0x972C2E88,0xBD6C,0x4125,{0x8E,0x09,0x84,0xF8,0x37,0xE6,0x37,0xB6}};


const IID IID_IWMDMObjectInfo = {0x1DCB3A09,0x33ED,0x11d3,{0x84,0x70,0x00,0xC0,0x4F,0x79,0xDB,0xC0}};


const IID IID_IWMDMRevoked = {0xEBECCEDB,0x88EE,0x4e55,{0xB6,0xA4,0x8D,0x9F,0x07,0xD6,0x96,0xAA}};


const IID IID_IMDServiceProvider = {0x1DCB3A10,0x33ED,0x11d3,{0x84,0x70,0x00,0xC0,0x4F,0x79,0xDB,0xC0}};


const IID IID_IMDServiceProvider2 = {0xB2FA24B7,0xCDA3,0x4694,{0x98,0x62,0x41,0x3A,0xE1,0xA3,0x48,0x19}};


const IID IID_IMDSPEnumDevice = {0x1DCB3A11,0x33ED,0x11d3,{0x84,0x70,0x00,0xC0,0x4F,0x79,0xDB,0xC0}};


const IID IID_IMDSPDevice = {0x1DCB3A12,0x33ED,0x11d3,{0x84,0x70,0x00,0xC0,0x4F,0x79,0xDB,0xC0}};


const IID IID_IMDSPDevice2 = {0x420D16AD,0xC97D,0x4e00,{0x82,0xAA,0x00,0xE9,0xF4,0x33,0x5D,0xDD}};


const IID IID_IMDSPDeviceControl = {0x1DCB3A14,0x33ED,0x11d3,{0x84,0x70,0x00,0xC0,0x4F,0x79,0xDB,0xC0}};


const IID IID_IMDSPEnumStorage = {0x1DCB3A15,0x33ED,0x11d3,{0x84,0x70,0x00,0xC0,0x4F,0x79,0xDB,0xC0}};


const IID IID_IMDSPStorage = {0x1DCB3A16,0x33ED,0x11d3,{0x84,0x70,0x00,0xC0,0x4F,0x79,0xDB,0xC0}};


const IID IID_IMDSPStorage2 = {0x0A5E07A5,0x6454,0x4451,{0x9C,0x36,0x1C,0x6A,0xE7,0xE2,0xB1,0xD6}};


const IID IID_IMDSPStorageGlobals = {0x1DCB3A17,0x33ED,0x11d3,{0x84,0x70,0x00,0xC0,0x4F,0x79,0xDB,0xC0}};


const IID IID_IMDSPObjectInfo = {0x1DCB3A19,0x33ED,0x11d3,{0x84,0x70,0x00,0xC0,0x4F,0x79,0xDB,0xC0}};


const IID IID_IMDSPObject = {0x1DCB3A18,0x33ED,0x11d3,{0x84,0x70,0x00,0xC0,0x4F,0x79,0xDB,0xC0}};


const IID IID_IMDSPRevoked = {0xA4E8F2D4,0x3F31,0x464d,{0xB5,0x3D,0x4F,0xC3,0x35,0x99,0x81,0x84}};


const IID IID_ISCPSecureAuthenticate = {0x1DCB3A0F,0x33ED,0x11d3,{0x84,0x70,0x00,0xC0,0x4F,0x79,0xDB,0xC0}};


const IID IID_ISCPSecureQuery = {0x1DCB3A0D,0x33ED,0x11d3,{0x84,0x70,0x00,0xC0,0x4F,0x79,0xDB,0xC0}};


const IID IID_ISCPSecureQuery2 = {0xEBE17E25,0x4FD7,0x4632,{0xAF,0x46,0x6D,0x93,0xD4,0xFC,0xC7,0x2E}};


const IID IID_ISCPSecureExchange = {0x1DCB3A0E,0x33ED,0x11d3,{0x84,0x70,0x00,0xC0,0x4F,0x79,0xDB,0xC0}};


const IID IID_IComponentAuthenticate = {0xA9889C00,0x6D2B,0x11d3,{0x84,0x96,0x00,0xC0,0x4F,0x79,0xDB,0xC0}};


const IID LIBID_MSWMDMLib = {0x6EC6C744,0x355F,0x11D3,{0x84,0x70,0x00,0xC0,0x4F,0x79,0xDB,0xC0}};


const CLSID CLSID_MediaDevMgrClassFactory = {0x50040C1D,0xBDBF,0x4924,{0xB8,0x73,0xF1,0x4D,0x6C,0x5B,0xFD,0x66}};


const CLSID CLSID_MediaDevMgr = {0x25BAAD81,0x3560,0x11D3,{0x84,0x71,0x00,0xC0,0x4F,0x79,0xDB,0xC0}};


const CLSID CLSID_WMDMDevice = {0x807B3CDF,0x357A,0x11d3,{0x84,0x71,0x00,0xC0,0x4F,0x79,0xDB,0xC0}};


const CLSID CLSID_WMDMStorage = {0x807B3CE0,0x357A,0x11d3,{0x84,0x71,0x00,0xC0,0x4F,0x79,0xDB,0xC0}};


const CLSID CLSID_WMDMStorageGlobal = {0x807B3CE1,0x357A,0x11d3,{0x84,0x71,0x00,0xC0,0x4F,0x79,0xDB,0xC0}};


const CLSID CLSID_WMDMDeviceEnum = {0x430E35AF,0x3971,0x11D3,{0x84,0x74,0x00,0xC0,0x4F,0x79,0xDB,0xC0}};


const CLSID CLSID_WMDMStorageEnum = {0xEB401A3B,0x3AF7,0x11d3,{0x84,0x74,0x00,0xC0,0x4F,0x79,0xDB,0xC0}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\wmsdk\inc\scclient.h ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

#ifndef _CSECURECHANNELCLIENT_H_2AD99356_6FD2_11d3_8497_00C04F79DBC0
#define _CSECURECHANNELCLIENT_H_2AD99356_6FD2_11d3_8497_00C04F79DBC0

#include "wtypes.h"

#ifdef USE_X509
#include "rsa.h"
#endif

#ifdef USE_X509
#include "x509cert.h"
#endif

#include "sac.h"

class CSecureChannelClient
{
public:
       CSecureChannelClient();
       ~CSecureChannelClient();
       HRESULT SetCertificate(DWORD dwFlags,
		                      BYTE *pbAppCert, 
                              DWORD dwCertLen, 
                              BYTE *pbAppPVK,
                              DWORD dwPVKLen);
       void SetInterface(IComponentAuthenticate *pComponentAuth);
       HRESULT Authenticate(DWORD dwProtocolID);
       HRESULT EncryptParam(BYTE *pbData,
                            DWORD dwDataLen);
       HRESULT DecryptParam(BYTE *pbData,
                           DWORD dwDataLen);
       HRESULT MACInit(HMAC *phMAC);
       HRESULT MACUpdate(HMAC hMAC,
                         BYTE *pbData,
                         DWORD dwDataLen);
       HRESULT MACFinal(HMAC hMAC,
                        BYTE abData[SAC_MAC_LEN]);
	   HRESULT GetAppSec(DWORD *pdwLocalAppSec, DWORD *pdwRemoteAppSec);
	   HRESULT SetSessionKey(BYTE *pbSPSessionKey);
	   HRESULT GetSessionKey(BYTE *pbSPSessionKey);
       HRESULT GetRemoteAppCert(BYTE *pbAppCert, DWORD* pdwCertLen);
	   BOOL fIsAuthenticated();
private:
       BOOL m_fAuthenticated;
       BYTE *m_pbAppCert;
       DWORD m_dwCertLen;
	   BYTE *m_pbRemoteCert;
	   DWORD m_dwRemoteCertLen;
       BYTE *m_pbAppPVK;
       DWORD m_dwPVKLen; 
       BYTE *m_pbSessionKey;
       DWORD m_dwSessionKeyLen;
	   BOOL m_TableInit;
       unsigned long m_DesTable[32];
       IComponentAuthenticate *m_pAuth;
	   DWORD m_dwCertFlags;
#ifdef USE_X509
       CX509Cert m_CertObj;
#endif
	   MACINFO aMacInfo[20];
	   BYTE m_abMacKey[64];
	   BOOL m_fMacKeyInit;
       CRITICAL_SECTION m_CS;
       HRESULT Protocol1();
	   HRESULT Protocol2();
};

#endif // _CSECURECHANNELCLIENT_H_2AD99356-6FD2-11d3-8497-00C04F79DBC0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\wmsdk\inc\wmsdk.h ===
//============================================================================
//
//  Microsoft Windows Media Technology
//  Copyright (C) Microsoft Corporation, 1999 - 2001.  All Rights Reserved.
//
//  File:        wmsdk.h
//
//  Description: WMSDK global include file
//
//============================================================================

#include "wmsdkidl.h"
#include "asferr.h"
#include "nserror.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\wmsdk\inc\wmdmlog_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0164 */
/* at Wed Aug 08 01:15:10 2001
 */
/* Compiler settings for .\wmdmlog.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IWMDMLogger = {0x110A3200,0x5A79,0x11d3,{0x8D,0x78,0x44,0x45,0x53,0x54,0x00,0x00}};


const IID LIBID_WMDMLogLib = {0x110A3201,0x5A79,0x11d3,{0x8D,0x78,0x44,0x45,0x53,0x54,0x00,0x00}};


const CLSID CLSID_WMDMLogger = {0x110A3202,0x5A79,0x11d3,{0x8D,0x78,0x44,0x45,0x53,0x54,0x00,0x00}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\wmsdk\inc\wmdmlog.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Wed Aug 08 01:15:10 2001
 */
/* Compiler settings for .\wmdmlog.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmdmlog_h__
#define __wmdmlog_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IWMDMLogger_FWD_DEFINED__
#define __IWMDMLogger_FWD_DEFINED__
typedef interface IWMDMLogger IWMDMLogger;
#endif 	/* __IWMDMLogger_FWD_DEFINED__ */


#ifndef __WMDMLogger_FWD_DEFINED__
#define __WMDMLogger_FWD_DEFINED__

#ifdef __cplusplus
typedef class WMDMLogger WMDMLogger;
#else
typedef struct WMDMLogger WMDMLogger;
#endif /* __cplusplus */

#endif 	/* __WMDMLogger_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_wmdmlog_0000 */
/* [local] */ 

#define WMDM_LOG_SEV_INFO             0x00000001 
#define WMDM_LOG_SEV_WARN             0x00000002 
#define WMDM_LOG_SEV_ERROR            0x00000004 
#define WMDM_LOG_NOTIMESTAMP          0x00000010 


extern RPC_IF_HANDLE __MIDL_itf_wmdmlog_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmdmlog_0000_v0_0_s_ifspec;

#ifndef __IWMDMLogger_INTERFACE_DEFINED__
#define __IWMDMLogger_INTERFACE_DEFINED__

/* interface IWMDMLogger */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IWMDMLogger;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("110A3200-5A79-11d3-8D78-444553540000")
    IWMDMLogger : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsEnabled( 
            /* [out] */ BOOL __RPC_FAR *pfEnabled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Enable( 
            /* [in] */ BOOL fEnable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLogFileName( 
            /* [size_is][string][out] */ LPSTR pszFilename,
            /* [in] */ UINT nMaxChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLogFileName( 
            /* [string][in] */ LPSTR pszFilename) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LogString( 
            /* [in] */ DWORD dwFlags,
            /* [string][in] */ LPSTR pszSrcName,
            /* [string][in] */ LPSTR pszLog) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LogDword( 
            /* [in] */ DWORD dwFlags,
            /* [string][in] */ LPSTR pszSrcName,
            /* [string][in] */ LPSTR pszLogFormat,
            /* [in] */ DWORD dwLog) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSizeParams( 
            /* [out] */ LPDWORD pdwMaxSize,
            /* [out] */ LPDWORD pdwShrinkToSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSizeParams( 
            /* [in] */ DWORD dwMaxSize,
            /* [in] */ DWORD dwShrinkToSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDMLoggerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDMLogger __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDMLogger __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDMLogger __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsEnabled )( 
            IWMDMLogger __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfEnabled);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Enable )( 
            IWMDMLogger __RPC_FAR * This,
            /* [in] */ BOOL fEnable);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLogFileName )( 
            IWMDMLogger __RPC_FAR * This,
            /* [size_is][string][out] */ LPSTR pszFilename,
            /* [in] */ UINT nMaxChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLogFileName )( 
            IWMDMLogger __RPC_FAR * This,
            /* [string][in] */ LPSTR pszFilename);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LogString )( 
            IWMDMLogger __RPC_FAR * This,
            /* [in] */ DWORD dwFlags,
            /* [string][in] */ LPSTR pszSrcName,
            /* [string][in] */ LPSTR pszLog);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LogDword )( 
            IWMDMLogger __RPC_FAR * This,
            /* [in] */ DWORD dwFlags,
            /* [string][in] */ LPSTR pszSrcName,
            /* [string][in] */ LPSTR pszLogFormat,
            /* [in] */ DWORD dwLog);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IWMDMLogger __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSizeParams )( 
            IWMDMLogger __RPC_FAR * This,
            /* [out] */ LPDWORD pdwMaxSize,
            /* [out] */ LPDWORD pdwShrinkToSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSizeParams )( 
            IWMDMLogger __RPC_FAR * This,
            /* [in] */ DWORD dwMaxSize,
            /* [in] */ DWORD dwShrinkToSize);
        
        END_INTERFACE
    } IWMDMLoggerVtbl;

    interface IWMDMLogger
    {
        CONST_VTBL struct IWMDMLoggerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDMLogger_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDMLogger_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDMLogger_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDMLogger_IsEnabled(This,pfEnabled)	\
    (This)->lpVtbl -> IsEnabled(This,pfEnabled)

#define IWMDMLogger_Enable(This,fEnable)	\
    (This)->lpVtbl -> Enable(This,fEnable)

#define IWMDMLogger_GetLogFileName(This,pszFilename,nMaxChars)	\
    (This)->lpVtbl -> GetLogFileName(This,pszFilename,nMaxChars)

#define IWMDMLogger_SetLogFileName(This,pszFilename)	\
    (This)->lpVtbl -> SetLogFileName(This,pszFilename)

#define IWMDMLogger_LogString(This,dwFlags,pszSrcName,pszLog)	\
    (This)->lpVtbl -> LogString(This,dwFlags,pszSrcName,pszLog)

#define IWMDMLogger_LogDword(This,dwFlags,pszSrcName,pszLogFormat,dwLog)	\
    (This)->lpVtbl -> LogDword(This,dwFlags,pszSrcName,pszLogFormat,dwLog)

#define IWMDMLogger_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IWMDMLogger_GetSizeParams(This,pdwMaxSize,pdwShrinkToSize)	\
    (This)->lpVtbl -> GetSizeParams(This,pdwMaxSize,pdwShrinkToSize)

#define IWMDMLogger_SetSizeParams(This,dwMaxSize,dwShrinkToSize)	\
    (This)->lpVtbl -> SetSizeParams(This,dwMaxSize,dwShrinkToSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDMLogger_IsEnabled_Proxy( 
    IWMDMLogger __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfEnabled);


void __RPC_STUB IWMDMLogger_IsEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMLogger_Enable_Proxy( 
    IWMDMLogger __RPC_FAR * This,
    /* [in] */ BOOL fEnable);


void __RPC_STUB IWMDMLogger_Enable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMLogger_GetLogFileName_Proxy( 
    IWMDMLogger __RPC_FAR * This,
    /* [size_is][string][out] */ LPSTR pszFilename,
    /* [in] */ UINT nMaxChars);


void __RPC_STUB IWMDMLogger_GetLogFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMLogger_SetLogFileName_Proxy( 
    IWMDMLogger __RPC_FAR * This,
    /* [string][in] */ LPSTR pszFilename);


void __RPC_STUB IWMDMLogger_SetLogFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMLogger_LogString_Proxy( 
    IWMDMLogger __RPC_FAR * This,
    /* [in] */ DWORD dwFlags,
    /* [string][in] */ LPSTR pszSrcName,
    /* [string][in] */ LPSTR pszLog);


void __RPC_STUB IWMDMLogger_LogString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMLogger_LogDword_Proxy( 
    IWMDMLogger __RPC_FAR * This,
    /* [in] */ DWORD dwFlags,
    /* [string][in] */ LPSTR pszSrcName,
    /* [string][in] */ LPSTR pszLogFormat,
    /* [in] */ DWORD dwLog);


void __RPC_STUB IWMDMLogger_LogDword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMLogger_Reset_Proxy( 
    IWMDMLogger __RPC_FAR * This);


void __RPC_STUB IWMDMLogger_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMLogger_GetSizeParams_Proxy( 
    IWMDMLogger __RPC_FAR * This,
    /* [out] */ LPDWORD pdwMaxSize,
    /* [out] */ LPDWORD pdwShrinkToSize);


void __RPC_STUB IWMDMLogger_GetSizeParams_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDMLogger_SetSizeParams_Proxy( 
    IWMDMLogger __RPC_FAR * This,
    /* [in] */ DWORD dwMaxSize,
    /* [in] */ DWORD dwShrinkToSize);


void __RPC_STUB IWMDMLogger_SetSizeParams_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDMLogger_INTERFACE_DEFINED__ */



#ifndef __WMDMLogLib_LIBRARY_DEFINED__
#define __WMDMLogLib_LIBRARY_DEFINED__

/* library WMDMLogLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_WMDMLogLib;

EXTERN_C const CLSID CLSID_WMDMLogger;

#ifdef __cplusplus

class DECLSPEC_UUID("110A3202-5A79-11d3-8D78-444553540000")
WMDMLogger;
#endif
#endif /* __WMDMLogLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\reality\misc\memalloc.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memalloc.h
 *  Content:	header file for memory allocation
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   06-apr-95	craige	initial implementation
 *   22-may-95	craige	added MemAlloc16
 *   12-jun-95	craige	added MemReAlloc
 *   26-jun-95  craige  added GetPtr16
 *   26-jul-95  toddla  added MemSize and fixed MemReAlloc
 *
 ***************************************************************************/
#ifndef __MEMALLOC_INCLUDED__
#define __MEMALLOC_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif
extern void MemFini( void );
extern void MemState( void );
extern BOOL MemInit( void );
extern void MemFree( LPVOID lptr );
extern SIZE_T __cdecl MemSize( LPVOID lptr );
extern LPVOID __cdecl MemAlloc( UINT size );
extern LPVOID __cdecl MemReAlloc( LPVOID ptr, UINT size );
extern LPVOID __cdecl MemAlloc16( UINT size, DWORD FAR *p16 );
extern LPVOID GetPtr16( LPVOID ptr );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\wmsdk\inc\wmsdkidl.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Wed Aug 08 01:15:12 2001
 */
/* Compiler settings for .\wmsdkidl.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmsdkidl_h__
#define __wmsdkidl_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IWMMediaProps_FWD_DEFINED__
#define __IWMMediaProps_FWD_DEFINED__
typedef interface IWMMediaProps IWMMediaProps;
#endif 	/* __IWMMediaProps_FWD_DEFINED__ */


#ifndef __IWMVideoMediaProps_FWD_DEFINED__
#define __IWMVideoMediaProps_FWD_DEFINED__
typedef interface IWMVideoMediaProps IWMVideoMediaProps;
#endif 	/* __IWMVideoMediaProps_FWD_DEFINED__ */


#ifndef __IWMWriter_FWD_DEFINED__
#define __IWMWriter_FWD_DEFINED__
typedef interface IWMWriter IWMWriter;
#endif 	/* __IWMWriter_FWD_DEFINED__ */


#ifndef __IWMInputMediaProps_FWD_DEFINED__
#define __IWMInputMediaProps_FWD_DEFINED__
typedef interface IWMInputMediaProps IWMInputMediaProps;
#endif 	/* __IWMInputMediaProps_FWD_DEFINED__ */


#ifndef __IWMPropertyVault_FWD_DEFINED__
#define __IWMPropertyVault_FWD_DEFINED__
typedef interface IWMPropertyVault IWMPropertyVault;
#endif 	/* __IWMPropertyVault_FWD_DEFINED__ */


#ifndef __IWMReader_FWD_DEFINED__
#define __IWMReader_FWD_DEFINED__
typedef interface IWMReader IWMReader;
#endif 	/* __IWMReader_FWD_DEFINED__ */


#ifndef __IWMOutputMediaProps_FWD_DEFINED__
#define __IWMOutputMediaProps_FWD_DEFINED__
typedef interface IWMOutputMediaProps IWMOutputMediaProps;
#endif 	/* __IWMOutputMediaProps_FWD_DEFINED__ */


#ifndef __IWMStatusCallback_FWD_DEFINED__
#define __IWMStatusCallback_FWD_DEFINED__
typedef interface IWMStatusCallback IWMStatusCallback;
#endif 	/* __IWMStatusCallback_FWD_DEFINED__ */


#ifndef __IWMReaderCallback_FWD_DEFINED__
#define __IWMReaderCallback_FWD_DEFINED__
typedef interface IWMReaderCallback IWMReaderCallback;
#endif 	/* __IWMReaderCallback_FWD_DEFINED__ */


#ifndef __IWMCredentialCallback_FWD_DEFINED__
#define __IWMCredentialCallback_FWD_DEFINED__
typedef interface IWMCredentialCallback IWMCredentialCallback;
#endif 	/* __IWMCredentialCallback_FWD_DEFINED__ */


#ifndef __IWMMetadataEditor_FWD_DEFINED__
#define __IWMMetadataEditor_FWD_DEFINED__
typedef interface IWMMetadataEditor IWMMetadataEditor;
#endif 	/* __IWMMetadataEditor_FWD_DEFINED__ */


#ifndef __IWMMetadataEditor2_FWD_DEFINED__
#define __IWMMetadataEditor2_FWD_DEFINED__
typedef interface IWMMetadataEditor2 IWMMetadataEditor2;
#endif 	/* __IWMMetadataEditor2_FWD_DEFINED__ */


#ifndef __IWMHeaderInfo_FWD_DEFINED__
#define __IWMHeaderInfo_FWD_DEFINED__
typedef interface IWMHeaderInfo IWMHeaderInfo;
#endif 	/* __IWMHeaderInfo_FWD_DEFINED__ */


#ifndef __IWMHeaderInfo2_FWD_DEFINED__
#define __IWMHeaderInfo2_FWD_DEFINED__
typedef interface IWMHeaderInfo2 IWMHeaderInfo2;
#endif 	/* __IWMHeaderInfo2_FWD_DEFINED__ */


#ifndef __IWMProfileManager_FWD_DEFINED__
#define __IWMProfileManager_FWD_DEFINED__
typedef interface IWMProfileManager IWMProfileManager;
#endif 	/* __IWMProfileManager_FWD_DEFINED__ */


#ifndef __IWMProfileManager2_FWD_DEFINED__
#define __IWMProfileManager2_FWD_DEFINED__
typedef interface IWMProfileManager2 IWMProfileManager2;
#endif 	/* __IWMProfileManager2_FWD_DEFINED__ */


#ifndef __IWMProfile_FWD_DEFINED__
#define __IWMProfile_FWD_DEFINED__
typedef interface IWMProfile IWMProfile;
#endif 	/* __IWMProfile_FWD_DEFINED__ */


#ifndef __IWMProfile2_FWD_DEFINED__
#define __IWMProfile2_FWD_DEFINED__
typedef interface IWMProfile2 IWMProfile2;
#endif 	/* __IWMProfile2_FWD_DEFINED__ */


#ifndef __IWMStreamConfig_FWD_DEFINED__
#define __IWMStreamConfig_FWD_DEFINED__
typedef interface IWMStreamConfig IWMStreamConfig;
#endif 	/* __IWMStreamConfig_FWD_DEFINED__ */


#ifndef __IWMPacketSize_FWD_DEFINED__
#define __IWMPacketSize_FWD_DEFINED__
typedef interface IWMPacketSize IWMPacketSize;
#endif 	/* __IWMPacketSize_FWD_DEFINED__ */


#ifndef __IWMStreamList_FWD_DEFINED__
#define __IWMStreamList_FWD_DEFINED__
typedef interface IWMStreamList IWMStreamList;
#endif 	/* __IWMStreamList_FWD_DEFINED__ */


#ifndef __IWMMutualExclusion_FWD_DEFINED__
#define __IWMMutualExclusion_FWD_DEFINED__
typedef interface IWMMutualExclusion IWMMutualExclusion;
#endif 	/* __IWMMutualExclusion_FWD_DEFINED__ */


#ifndef __IWMWriterAdvanced_FWD_DEFINED__
#define __IWMWriterAdvanced_FWD_DEFINED__
typedef interface IWMWriterAdvanced IWMWriterAdvanced;
#endif 	/* __IWMWriterAdvanced_FWD_DEFINED__ */


#ifndef __IWMWriterAdvanced2_FWD_DEFINED__
#define __IWMWriterAdvanced2_FWD_DEFINED__
typedef interface IWMWriterAdvanced2 IWMWriterAdvanced2;
#endif 	/* __IWMWriterAdvanced2_FWD_DEFINED__ */


#ifndef __IWMWriterPostViewCallback_FWD_DEFINED__
#define __IWMWriterPostViewCallback_FWD_DEFINED__
typedef interface IWMWriterPostViewCallback IWMWriterPostViewCallback;
#endif 	/* __IWMWriterPostViewCallback_FWD_DEFINED__ */


#ifndef __IWMWriterPostView_FWD_DEFINED__
#define __IWMWriterPostView_FWD_DEFINED__
typedef interface IWMWriterPostView IWMWriterPostView;
#endif 	/* __IWMWriterPostView_FWD_DEFINED__ */


#ifndef __IWMWriterSink_FWD_DEFINED__
#define __IWMWriterSink_FWD_DEFINED__
typedef interface IWMWriterSink IWMWriterSink;
#endif 	/* __IWMWriterSink_FWD_DEFINED__ */


#ifndef __IWMRegisterCallback_FWD_DEFINED__
#define __IWMRegisterCallback_FWD_DEFINED__
typedef interface IWMRegisterCallback IWMRegisterCallback;
#endif 	/* __IWMRegisterCallback_FWD_DEFINED__ */


#ifndef __IWMWriterFileSink_FWD_DEFINED__
#define __IWMWriterFileSink_FWD_DEFINED__
typedef interface IWMWriterFileSink IWMWriterFileSink;
#endif 	/* __IWMWriterFileSink_FWD_DEFINED__ */


#ifndef __IWMWriterFileSink2_FWD_DEFINED__
#define __IWMWriterFileSink2_FWD_DEFINED__
typedef interface IWMWriterFileSink2 IWMWriterFileSink2;
#endif 	/* __IWMWriterFileSink2_FWD_DEFINED__ */


#ifndef __IWMWriterNetworkSink_FWD_DEFINED__
#define __IWMWriterNetworkSink_FWD_DEFINED__
typedef interface IWMWriterNetworkSink IWMWriterNetworkSink;
#endif 	/* __IWMWriterNetworkSink_FWD_DEFINED__ */


#ifndef __IWMClientConnections_FWD_DEFINED__
#define __IWMClientConnections_FWD_DEFINED__
typedef interface IWMClientConnections IWMClientConnections;
#endif 	/* __IWMClientConnections_FWD_DEFINED__ */


#ifndef __IWMReaderAdvanced_FWD_DEFINED__
#define __IWMReaderAdvanced_FWD_DEFINED__
typedef interface IWMReaderAdvanced IWMReaderAdvanced;
#endif 	/* __IWMReaderAdvanced_FWD_DEFINED__ */


#ifndef __IWMReaderAdvanced2_FWD_DEFINED__
#define __IWMReaderAdvanced2_FWD_DEFINED__
typedef interface IWMReaderAdvanced2 IWMReaderAdvanced2;
#endif 	/* __IWMReaderAdvanced2_FWD_DEFINED__ */


#ifndef __IWMReaderAdvanced3_FWD_DEFINED__
#define __IWMReaderAdvanced3_FWD_DEFINED__
typedef interface IWMReaderAdvanced3 IWMReaderAdvanced3;
#endif 	/* __IWMReaderAdvanced3_FWD_DEFINED__ */


#ifndef __IWMReaderAllocatorEx_FWD_DEFINED__
#define __IWMReaderAllocatorEx_FWD_DEFINED__
typedef interface IWMReaderAllocatorEx IWMReaderAllocatorEx;
#endif 	/* __IWMReaderAllocatorEx_FWD_DEFINED__ */


#ifndef __IWMReaderTypeNegotiation_FWD_DEFINED__
#define __IWMReaderTypeNegotiation_FWD_DEFINED__
typedef interface IWMReaderTypeNegotiation IWMReaderTypeNegotiation;
#endif 	/* __IWMReaderTypeNegotiation_FWD_DEFINED__ */


#ifndef __IWMReaderCallbackAdvanced_FWD_DEFINED__
#define __IWMReaderCallbackAdvanced_FWD_DEFINED__
typedef interface IWMReaderCallbackAdvanced IWMReaderCallbackAdvanced;
#endif 	/* __IWMReaderCallbackAdvanced_FWD_DEFINED__ */


#ifndef __IWMDRMReader_FWD_DEFINED__
#define __IWMDRMReader_FWD_DEFINED__
typedef interface IWMDRMReader IWMDRMReader;
#endif 	/* __IWMDRMReader_FWD_DEFINED__ */


#ifndef __IWMReaderNetworkConfig_FWD_DEFINED__
#define __IWMReaderNetworkConfig_FWD_DEFINED__
typedef interface IWMReaderNetworkConfig IWMReaderNetworkConfig;
#endif 	/* __IWMReaderNetworkConfig_FWD_DEFINED__ */


#ifndef __IWMReaderStreamClock_FWD_DEFINED__
#define __IWMReaderStreamClock_FWD_DEFINED__
typedef interface IWMReaderStreamClock IWMReaderStreamClock;
#endif 	/* __IWMReaderStreamClock_FWD_DEFINED__ */


#ifndef __IWMIndexer_FWD_DEFINED__
#define __IWMIndexer_FWD_DEFINED__
typedef interface IWMIndexer IWMIndexer;
#endif 	/* __IWMIndexer_FWD_DEFINED__ */


#ifndef __IWMLicenseBackup_FWD_DEFINED__
#define __IWMLicenseBackup_FWD_DEFINED__
typedef interface IWMLicenseBackup IWMLicenseBackup;
#endif 	/* __IWMLicenseBackup_FWD_DEFINED__ */


#ifndef __IWMLicenseRestore_FWD_DEFINED__
#define __IWMLicenseRestore_FWD_DEFINED__
typedef interface IWMLicenseRestore IWMLicenseRestore;
#endif 	/* __IWMLicenseRestore_FWD_DEFINED__ */


#ifndef __IWMBackupRestoreProps_FWD_DEFINED__
#define __IWMBackupRestoreProps_FWD_DEFINED__
typedef interface IWMBackupRestoreProps IWMBackupRestoreProps;
#endif 	/* __IWMBackupRestoreProps_FWD_DEFINED__ */


#ifndef __IWMCodecInfo_FWD_DEFINED__
#define __IWMCodecInfo_FWD_DEFINED__
typedef interface IWMCodecInfo IWMCodecInfo;
#endif 	/* __IWMCodecInfo_FWD_DEFINED__ */


#ifndef __IWMCodecInfo2_FWD_DEFINED__
#define __IWMCodecInfo2_FWD_DEFINED__
typedef interface IWMCodecInfo2 IWMCodecInfo2;
#endif 	/* __IWMCodecInfo2_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "wmsbuffer.h"
#include "drmexternals.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_wmsdkidl_0000 */
/* [local] */ 

//=========================================================================
//
// Microsoft Windows Media Technologies
// Copyright (C) Microsoft Corporation, 1999 - 2001.  All Rights Reserved.
//
//=========================================================================
typedef unsigned __int64 QWORD;

































////////////////////////////////////////////////////////////////
//
// These are the special case attributes that give information 
// about the Windows Media file.
//
static const DWORD g_dwWMSpecialAttributes = 15;
static const WCHAR *g_wszWMDuration = L"Duration";
static const WCHAR *g_wszWMBitrate = L"Bitrate";
static const WCHAR *g_wszWMSeekable = L"Seekable";
static const WCHAR *g_wszWMStridable = L"Stridable";
static const WCHAR *g_wszWMBroadcast = L"Broadcast";
static const WCHAR *g_wszWMProtected = L"Is_Protected";
static const WCHAR *g_wszWMTrusted = L"Is_Trusted";
static const WCHAR *g_wszWMSignature_Name = L"Signature_Name";
static const WCHAR *g_wszWMHasAudio = L"HasAudio";
static const WCHAR *g_wszWMHasImage = L"HasImage";
static const WCHAR *g_wszWMHasScript = L"HasScript";
static const WCHAR *g_wszWMHasVideo = L"HasVideo";
static const WCHAR *g_wszWMCurrentBitrate = L"CurrentBitrate";
static const WCHAR *g_wszWMOptimalBitrate = L"OptimalBitrate";
static const WCHAR *g_wszWMHasAttachedImages = L"HasAttachedImages";

////////////////////////////////////////////////////////////////
//
// The content description object supports 5 basic attributes.
//
static const DWORD g_dwWMContentAttributes = 5;
static const WCHAR *g_wszWMTitle = L"Title";
static const WCHAR *g_wszWMAuthor = L"Author";
static const WCHAR *g_wszWMDescription = L"Description";
static const WCHAR *g_wszWMRating = L"Rating";
static const WCHAR *g_wszWMCopyright = L"Copyright";

////////////////////////////////////////////////////////////////
//
// These attributes are used to set DRM properties.
//
static const WCHAR *g_wszWMUse_DRM = L"Use_DRM";
static const WCHAR *g_wszWMDRM_Flags = L"DRM_Flags";
static const WCHAR *g_wszWMDRM_Level = L"DRM_Level";

////////////////////////////////////////////////////////////////
//
// These are the additional attributes defined in the WM attribute
// namespace that give information about the content.
//
static const WCHAR *g_wszWMAlbumTitle = L"WM/AlbumTitle";
static const WCHAR *g_wszWMTrack = L"WM/Track";
static const WCHAR *g_wszWMPromotionURL = L"WM/PromotionURL";
static const WCHAR *g_wszWMAlbumCoverURL = L"WM/AlbumCoverURL";
static const WCHAR *g_wszWMGenre = L"WM/Genre";
static const WCHAR *g_wszWMYear = L"WM/Year";
static const WCHAR *g_wszWMGenreID = L"WM/GenreID";
static const WCHAR *g_wszWMMCDI = L"WM/MCDI";
static const WCHAR *g_wszWMComposer = L"WM/Composer";
static const WCHAR *g_wszWMLyrics = L"WM/Lyrics";
static const WCHAR *g_wszWMTrackNumber = L"WM/TrackNumber";
static const WCHAR *g_wszWMToolName = L"WM/ToolName";
static const WCHAR *g_wszWMToolVersion = L"WM/ToolVersion";

////////////////////////////////////////////////////////////////
//
// These optional attributes may be used to give information 
// about the branding of the content.
//
static const WCHAR *g_wszWMBannerImageType = L"BannerImageType";
static const WCHAR *g_wszWMBannerImageData = L"BannerImageData";
static const WCHAR *g_wszWMBannerImageURL = L"BannerImageURL";
static const WCHAR *g_wszWMCopyrightURL = L"CopyrightURL";
////////////////////////////////////////////////////////////////
//
// The NSC file supports the following attributes.
//
static const DWORD g_dwWMNSCAttributes = 5;
static const WCHAR *g_wszWMNSCName = L"NSC_Name";
static const WCHAR *g_wszWMNSCAddress = L"NSC_Address";
static const WCHAR *g_wszWMNSCPhone = L"NSC_Phone";
static const WCHAR *g_wszWMNSCEmail = L"NSC_Email";
static const WCHAR *g_wszWMNSCDescription = L"NSC_Description";

////////////////////////////////////////////////////////////////
//
// These are setting names for use in Get/SetOutputSetting
//
static const WCHAR *g_wszEarlyDataDelivery = L"EarlyDataDelivery";
static const WCHAR *g_wszJustInTimeDecode = L"JustInTimeDecode";
static const WCHAR *g_wszSingleOutputBuffer = L"SingleOutputBuffer";
static const WCHAR *g_wszSoftwareScaling = L"SoftwareScaling";
static const WCHAR *g_wszDeliverOnReceive = L"DeliverOnReceive";
static const WCHAR *g_wszScrambledAudio = L"ScrambledAudio";

////////////////////////////////////////////////////////////////
//
// These are setting names for use in Get/SetInputSetting
//
static const WCHAR *g_wszDeinterlaceMode = L"DeinterlaceMode";

////////////////////////////////////////////////////////////////
//
// All known IWMPropertyVault property names
//
static const WCHAR *g_wszOriginalSourceFormatTag = L"_SOURCEFORMATTAG";

////////////////////////////////////////////////////////////////
//
// Flags that can be passed into the Start method of IWMReader
//
#define WM_START_CURRENTPOSITION     ( ( QWORD )-1 )

#define WM_BACKUP_OVERWRITE    ((DWORD) 0x00000001)
#define WM_RESTORE_INDIVIDUALIZE    ((DWORD) 0x00000002)
#define WAVE_FORMAT_DRM            0x0009

enum __MIDL___MIDL_itf_wmsdkidl_0000_0001
    {	WM_SF_CLEANPOINT	= 0x1,
	WM_SF_DISCONTINUITY	= 0x2,
	WM_SF_DATALOSS	= 0x4
    };

enum __MIDL___MIDL_itf_wmsdkidl_0000_0002
    {	WM_SFEX_NOTASYNCPOINT	= 0x2,
	WM_SFEX_DATALOSS	= 0x4
    };
typedef 
enum WMT_STATUS
    {	WMT_ERROR	= 0,
	WMT_OPENED	= 1,
	WMT_BUFFERING_START	= 2,
	WMT_BUFFERING_STOP	= 3,
	WMT_EOF	= 4,
	WMT_END_OF_FILE	= 4,
	WMT_END_OF_SEGMENT	= 5,
	WMT_END_OF_STREAMING	= 6,
	WMT_LOCATING	= 7,
	WMT_CONNECTING	= 8,
	WMT_NO_RIGHTS	= 9,
	WMT_MISSING_CODEC	= 10,
	WMT_STARTED	= 11,
	WMT_STOPPED	= 12,
	WMT_CLOSED	= 13,
	WMT_STRIDING	= 14,
	WMT_TIMER	= 15,
	WMT_INDEX_PROGRESS	= 16,
	WMT_SAVEAS_START	= 17,
	WMT_SAVEAS_STOP	= 18,
	WMT_NEW_SOURCEFLAGS	= 19,
	WMT_NEW_METADATA	= 20,
	WMT_BACKUPRESTORE_BEGIN	= 21,
	WMT_SOURCE_SWITCH	= 22,
	WMT_ACQUIRE_LICENSE	= 23,
	WMT_INDIVIDUALIZE	= 24,
	WMT_NEEDS_INDIVIDUALIZATION	= 25,
	WMT_NO_RIGHTS_EX	= 26,
	WMT_BACKUPRESTORE_END	= 27,
	WMT_BACKUPRESTORE_CONNECTING	= 28,
	WMT_BACKUPRESTORE_DISCONNECTING	= 29,
	WMT_ERROR_WITHURL	= 30,
	WMT_RESTRICTED_LICENSE	= 31,
	WMT_CLIENT_CONNECT	= 32,
	WMT_CLIENT_DISCONNECT	= 33
    }	WMT_STATUS;

typedef 
enum WMT_RIGHTS
    {	WMT_RIGHT_PLAYBACK	= 0x1,
	WMT_RIGHT_COPY_TO_NON_SDMI_DEVICE	= 0x2,
	WMT_RIGHT_COPY_TO_CD	= 0x8,
	WMT_RIGHT_COPY_TO_SDMI_DEVICE	= 0x10,
	WMT_RIGHT_ONE_TIME	= 0x20,
	WMT_RIGHT_SDMI_TRIGGER	= 0x10000,
	WMT_RIGHT_SDMI_NOMORECOPIES	= 0x20000
    }	WMT_RIGHTS;

typedef 
enum WMT_STREAM_SELECTION
    {	WMT_OFF	= 0,
	WMT_CLEANPOINT_ONLY	= 1,
	WMT_ON	= 2
    }	WMT_STREAM_SELECTION;

typedef 
enum WMT_ATTR_DATATYPE
    {	WMT_TYPE_DWORD	= 0,
	WMT_TYPE_STRING	= 1,
	WMT_TYPE_BINARY	= 2,
	WMT_TYPE_BOOL	= 3,
	WMT_TYPE_QWORD	= 4,
	WMT_TYPE_WORD	= 5,
	WMT_TYPE_GUID	= 6
    }	WMT_ATTR_DATATYPE;

typedef 
enum WMT_ATTR_IMAGETYPE
    {	WMT_IMAGETYPE_BITMAP	= 1,
	WMT_IMAGETYPE_JPEG	= 2,
	WMT_IMAGETYPE_GIF	= 3
    }	WMT_ATTR_IMAGETYPE;

typedef 
enum WMT_VERSION
    {	WMT_VER_4_0	= 0x40000,
	WMT_VER_7_0	= 0x70000
    }	WMT_VERSION;

typedef 
enum WMT_NET_PROTOCOL
    {	WMT_PROTOCOL_HTTP	= 0
    }	WMT_NET_PROTOCOL;

typedef 
enum WMT_PLAY_MODE
    {	WMT_PLAY_MODE_AUTOSELECT	= 0,
	WMT_PLAY_MODE_LOCAL	= 1,
	WMT_PLAY_MODE_DOWNLOAD	= 2,
	WMT_PLAY_MODE_STREAMING	= 3
    }	WMT_PLAY_MODE;

typedef 
enum WMT_PROXY_SETTINGS
    {	WMT_PROXY_SETTING_NONE	= 0,
	WMT_PROXY_SETTING_MANUAL	= 1,
	WMT_PROXY_SETTING_AUTO	= 2,
	WMT_PROXY_SETTING_BROWSER	= 3
    }	WMT_PROXY_SETTINGS;

typedef 
enum WMT_CODEC_INFO_TYPE
    {	WMT_CODECINFO_AUDIO	= 0,
	WMT_CODECINFO_VIDEO	= 1,
	WMT_CODECINFO_UNKNOWN	= 0xffffffff
    }	WMT_CODEC_INFO_TYPE;


enum __MIDL___MIDL_itf_wmsdkidl_0000_0003
    {	WM_DM_NOTINTERLACED	= 0,
	WM_DM_DEINTERLACE_NORMAL	= 1,
	WM_DM_DEINTERLACE_HALFSIZE	= 2,
	WM_DM_DEINTERLACE_HALFSIZEDOUBLERATE	= 3,
	WM_DM_DEINTERLACE_INVERSETELECINE	= 4,
	WM_DM_DEINTERLACE_VERTICALHALFSIZEDOUBLERATE	= 5
    };
typedef 
enum tagWMT_OFFSET_FORMAT
    {	WMT_OFFSET_FORMAT_100NS	= 0,
	WMT_OFFSET_FORMAT_SMPTE	= WMT_OFFSET_FORMAT_100NS + 1,
	WMT_OFFSET_FORMAT_FRAME_NUMBERS	= WMT_OFFSET_FORMAT_SMPTE + 1,
	WMT_OFFSET_FORMAT_PLAYLIST_OFFSET	= WMT_OFFSET_FORMAT_FRAME_NUMBERS + 1
    }	WMT_OFFSET_FORMAT;

typedef struct  _WMWriterStatistics
    {
    QWORD qwSampleCount;
    QWORD qwByteCount;
    QWORD qwDroppedSampleCount;
    QWORD qwDroppedByteCount;
    DWORD dwCurrentBitrate;
    DWORD dwAverageBitrate;
    DWORD dwExpectedBitrate;
    DWORD dwCurrentSampleRate;
    DWORD dwAverageSampleRate;
    DWORD dwExpectedSampleRate;
    }	WM_WRITER_STATISTICS;

typedef struct  _WMReaderStatistics
    {
    DWORD cbSize;
    DWORD dwBandwidth;
    DWORD cPacketsReceived;
    DWORD cPacketsRecovered;
    DWORD cPacketsLost;
    WORD wQuality;
    }	WM_READER_STATISTICS;

typedef struct  _WMReaderClientInfo
    {
    DWORD cbSize;
    WCHAR __RPC_FAR *wszLang;
    WCHAR __RPC_FAR *wszBrowserUserAgent;
    WCHAR __RPC_FAR *wszBrowserWebPage;
    QWORD qwReserved;
    LPARAM __RPC_FAR *pReserved;
    WCHAR __RPC_FAR *wszHostExe;
    QWORD qwHostVersion;
    }	WM_READER_CLIENTINFO;

typedef struct  _WMClientProperties
    {
    DWORD dwIPAddress;
    DWORD dwPort;
    }	WM_CLIENT_PROPERTIES;

typedef struct  _WMPortNumberRange
    {
    WORD wPortBegin;
    WORD wPortEnd;
    }	WM_PORT_NUMBER_RANGE;

typedef struct  _WM_LICENSE_STATE_DATA
    {
    DWORD dwSize;
    DWORD dwNumStates;
    DRM_LICENSE_STATE_DATA stateData[ 1 ];
    }	WM_LICENSE_STATE_DATA;

typedef struct  _WMMediaType
    {
    GUID majortype;
    GUID subtype;
    BOOL bFixedSizeSamples;
    BOOL bTemporalCompression;
    ULONG lSampleSize;
    GUID formattype;
    IUnknown __RPC_FAR *pUnk;
    ULONG cbFormat;
    /* [size_is] */ BYTE __RPC_FAR *pbFormat;
    }	WM_MEDIA_TYPE;

typedef struct tagWMVIDEOINFOHEADER
{
    //
    // The bit we really want to use.
    //
    RECT rcSource;

    //
    // Where the video should go.
    //
    RECT rcTarget;

    //
    // Approximate bit data rate.
    //
    DWORD dwBitRate;

    //
    // Bit error rate for this stream.
    //
    DWORD dwBitErrorRate;

    //
    // Average time per frame (100ns units).
    //
    LONGLONG AvgTimePerFrame;

    BITMAPINFOHEADER bmiHeader;
} WMVIDEOINFOHEADER;
typedef struct tagWMSCRIPTFORMAT
{
    GUID    scriptType; 
} WMSCRIPTFORMAT;
// 00000000-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_Base 
EXTERN_GUID(WMMEDIASUBTYPE_Base, 
0x00000000, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 73646976-0000-0010-8000-00AA00389B71  'vids' == WMMEDIATYPE_Video 
EXTERN_GUID(WMMEDIATYPE_Video, 
0x73646976, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// e436eb78-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB1 
EXTERN_GUID(WMMEDIASUBTYPE_RGB1, 
0xe436eb78, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); 
// e436eb79-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB4 
EXTERN_GUID(WMMEDIASUBTYPE_RGB4, 
0xe436eb79, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); 
// e436eb7a-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB8 
EXTERN_GUID(WMMEDIASUBTYPE_RGB8, 
0xe436eb7a, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); 
// e436eb7b-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB565 
EXTERN_GUID(WMMEDIASUBTYPE_RGB565, 
0xe436eb7b, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); 
// e436eb7c-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB555 
EXTERN_GUID(WMMEDIASUBTYPE_RGB555, 
0xe436eb7c, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); 
// e436eb7d-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB24 
EXTERN_GUID(WMMEDIASUBTYPE_RGB24, 
0xe436eb7d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); 
// e436eb7e-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB32 
EXTERN_GUID(WMMEDIASUBTYPE_RGB32, 
0xe436eb7e, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); 
// 30323449-0000-0010-8000-00AA00389B71  'YV12' ==  MEDIASUBTYPE_I420 
EXTERN_GUID(WMMEDIASUBTYPE_I420, 
0x30323449, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 56555949-0000-0010-8000-00AA00389B71  'YV12' ==  MEDIASUBTYPE_IYUV 
EXTERN_GUID(WMMEDIASUBTYPE_IYUV, 
0x56555949, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 31313259-0000-0010-8000-00AA00389B71  'YV12' ==  MEDIASUBTYPE_YV12 
EXTERN_GUID(WMMEDIASUBTYPE_YV12, 
0x32315659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 32595559-0000-0010-8000-00AA00389B71  'YUY2' == MEDIASUBTYPE_YUY2 
EXTERN_GUID(WMMEDIASUBTYPE_YUY2, 
0x32595559, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 59565955-0000-0010-8000-00AA00389B71  'UYVY' ==  MEDIASUBTYPE_UYVY 
EXTERN_GUID(WMMEDIASUBTYPE_UYVY, 
0x59565955, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 55595659-0000-0010-8000-00AA00389B71  'YVYU' == MEDIASUBTYPE_YVYU 
EXTERN_GUID(WMMEDIASUBTYPE_YVYU, 
0x55595659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 39555659-0000-0010-8000-00AA00389B71  'YVU9' == MEDIASUBTYPE_YVU9 
EXTERN_GUID(WMMEDIASUBTYPE_YVU9, 
0x39555659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 3334504D-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_MP43 
EXTERN_GUID(WMMEDIASUBTYPE_MP43, 
0x3334504D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 5334504D-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_MP4S 
EXTERN_GUID(WMMEDIASUBTYPE_MP4S, 
0x5334504D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 31564D57-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WMV1 
EXTERN_GUID(WMMEDIASUBTYPE_WMV1, 
0x31564D57, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 32564D57-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WMV2 
EXTERN_GUID(WMMEDIASUBTYPE_WMV2, 
0x32564D57, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 3153534D-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_MSS1 
EXTERN_GUID(WMMEDIASUBTYPE_MSS1, 
0x3153534D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 73647561-0000-0010-8000-00AA00389B71  'auds' == WMMEDIATYPE_Audio 
EXTERN_GUID(WMMEDIATYPE_Audio, 
0x73647561, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 00000001-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_PCM 
EXTERN_GUID(WMMEDIASUBTYPE_PCM, 
0x00000001, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 00000009-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_DRM 
EXTERN_GUID(WMMEDIASUBTYPE_DRM, 
0x00000009, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 00000161-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WMAudioV7 
EXTERN_GUID(WMMEDIASUBTYPE_WMAudioV7, 
0x00000161, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 00000161-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WMAudioV2 
EXTERN_GUID(WMMEDIASUBTYPE_WMAudioV2, 
0x00000161, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 00000130-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_ACELPnet 
EXTERN_GUID(WMMEDIASUBTYPE_ACELPnet, 
0x00000130, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 73636d64-0000-0010-8000-00AA00389B71  'scmd' == MEDIATYPE_Script 
EXTERN_GUID(WMMEDIATYPE_Script, 
0x73636d64, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 34A50FD8-8AA5-4386-81FE-A0EFE0488E31            WMMEDIATYPE_Image 
EXTERN_GUID(WMMEDIATYPE_Image, 
0x34a50fd8, 0x8aa5, 0x4386, 0x81, 0xfe, 0xa0, 0xef, 0xe0, 0x48, 0x8e, 0x31); 
// 05589f80-c356-11ce-bf01-00aa0055595a        WMFORMAT_VideoInfo 
EXTERN_GUID(WMFORMAT_VideoInfo, 
0x05589f80, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a); 
// 05589f81-c356-11ce-bf01-00aa0055595a        WMFORMAT_WaveFormatEx 
EXTERN_GUID(WMFORMAT_WaveFormatEx, 
0x05589f81, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a); 
// 5C8510F2-DEBE-4ca7-BBA5-F07A104F8DFF        WMFORMAT_Script 
EXTERN_GUID(WMFORMAT_Script, 
0x5c8510f2, 0xdebe, 0x4ca7, 0xbb, 0xa5, 0xf0, 0x7a, 0x10, 0x4f, 0x8d, 0xff); 
// 82f38a70-c29f-11d1-97ad-00a0c95ea850        WMSCRIPTTYPE_TwoStrings 
EXTERN_GUID( WMSCRIPTTYPE_TwoStrings, 
0x82f38a70,0xc29f,0x11d1,0x97,0xad,0x00,0xa0,0xc9,0x5e,0xa8,0x50); 
EXTERN_GUID( IID_IWMMediaProps,         0x96406bce,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMVideoMediaProps,    0x96406bcf,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMWriter,             0x96406bd4,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMInputMediaProps,    0x96406bd5,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMReader,             0x96406bd6,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMOutputMediaProps,   0x96406bd7,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMStatusCallback,     0x6d7cdc70,0x9888,0x11d3,0x8e,0xdc,0x00,0xc0,0x4f,0x61,0x09,0xcf );
EXTERN_GUID( IID_IWMReaderCallback,     0x96406bd8,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMCredentialCallback, 0x342e0eb7,0xe651,0x450c,0x97,0x5b,0x2a,0xce,0x2c,0x90,0xc4,0x8e );
EXTERN_GUID( IID_IWMMetadataEditor,     0x96406bd9,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMMetadataEditor2,    0x203cffe3,0x2e18,0x4fdf,0xb5,0x9d,0x6e,0x71,0x53,0x05,0x34,0xcf );
EXTERN_GUID( IID_IWMHeaderInfo,         0x96406bda,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMHeaderInfo2,        0x15cf9781,0x454e,0x482e,0xb3,0x93,0x85,0xfa,0xe4,0x87,0xa8,0x10 );
EXTERN_GUID( IID_IWMProfileManager,     0xd16679f2,0x6ca0,0x472d,0x8d,0x31,0x2f,0x5d,0x55,0xae,0xe1,0x55 );
EXTERN_GUID( IID_IWMProfileManager2,    0x7a924e51,0x73c1,0x494d,0x80,0x19,0x23,0xd3,0x7e,0xd9,0xb8,0x9a );
EXTERN_GUID( IID_IWMProfile,            0x96406bdb,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMProfile2,           0x07e72d33,0xd94e,0x4be7,0x88,0x43,0x60,0xae,0x5f,0xf7,0xe5,0xf5 );
EXTERN_GUID( IID_IWMStreamConfig,       0x96406bdc,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMStreamList,         0x96406bdd,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMMutualExclusion,    0x96406bde,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMWriterAdvanced,     0x96406be3,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMWriterAdvanced2,    0x962dc1ec,0xc046,0x4db8,0x9c,0xc7,0x26,0xce,0xae,0x50,0x08,0x17 );
EXTERN_GUID( IID_IWMWriterSink,         0x96406be4,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMWriterFileSink,     0x96406be5,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMWriterFileSink2,    0x14282ba7,0x4aef,0x4205,0x8c,0xe5,0xc2,0x29,0x03,0x5a,0x05,0xbc );
EXTERN_GUID( IID_IWMWriterNetworkSink,  0x96406be7,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMClientConnections,  0x73c66010,0xa299,0x41df,0xb1,0xf0,0xcc,0xf0,0x3b,0x09,0xc1,0xc6 );
EXTERN_GUID( IID_IWMReaderAdvanced,     0x96406bea,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMReaderAdvanced2,    0xae14a945,0xb90c,0x4d0d,0x91,0x27,0x80,0xd6,0x65,0xf7,0xd7,0x3e );
EXTERN_GUID( IID_IWMReaderAdvanced3,    0x5dc0674b,0xf04b,0x4a4e,0x9f,0x2a,0xb1,0xaf,0xde,0x2c,0x81,0x00 );
EXTERN_GUID( IID_IWMDRMReader,          0xd2827540,0x3ee7,0x432c,0xb1,0x4c,0xdc,0x17,0xf0,0x85,0xd3,0xb3 );
EXTERN_GUID( IID_IWMReaderCallbackAdvanced, 0x96406beb,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMReaderNetworkConfig,0x96406bec,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMReaderStreamClock,  0x96406bed,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMIndexer,            0x6d7cdc71,0x9888,0x11d3,0x8e,0xdc,0x00,0xc0,0x4f,0x61,0x09,0xcf );
EXTERN_GUID( IID_IWMReaderAllocatorEx,  0x9f762fa7,0xa22e,0x428d,0x93,0xc9,0xac,0x82,0xf3,0xaa,0xfe,0x5a );
EXTERN_GUID( IID_IWMReaderTypeNegotiation, 0xfdbe5592,0x81a1,0x41ea,0x93,0xbd,0x73,0x5c,0xad,0x1a,0xdc,0x5 );
EXTERN_GUID( IID_IWMLicenseBackup,      0x05E5AC9F,0x3FB6,0x4508,0xBB,0x43,0xA4,0x06,0x7B,0xA1,0xEB,0xE8);
EXTERN_GUID( IID_IWMLicenseRestore,     0xC70B6334,0xa22e,0x4efb,0xA2,0x45,0x15,0xE6,0x5A,0x00,0x4A,0x13);
EXTERN_GUID( IID_IWMBackupRestoreProps, 0x3C8E0DA6,0x996F,0x4ff3,0xA1,0xAF,0x48,0x38,0xF9,0x37,0x7e,0x2e);
EXTERN_GUID( IID_IWMPacketSize,         0xcdfb97ab,0x188f,0x40b3,0xb6,0x43,0x5b,0x79,0x03,0x97,0x5c,0x59);
EXTERN_GUID( IID_IWMRegisterCallback,   0xcf4b1f99,0x4de2,0x4e49,0xa3,0x63,0x25,0x27,0x40,0xd9,0x9b,0xc1);
EXTERN_GUID( IID_IWMWriterPostView,     0x81e20ce4,0x75ef,0x491a,0x80,0x04,0xfc,0x53,0xc4,0x5b,0xdc,0x3e);
EXTERN_GUID( IID_IWMWriterPostViewCallback, 0xd9d6549d,0xa193,0x4f24,0xb3,0x08,0x03,0x12,0x3d,0x9b,0x7f,0x8d);
EXTERN_GUID( IID_IWMCodecInfo,          0xa970f41e,0x34de,0x4a98,0xb3,0xba,0xe4,0xb3,0xca,0x75,0x28,0xf0);
EXTERN_GUID( IID_IWMCodecInfo2,         0xaa65e273,0xb686,0x4056,0x91,0xec,0xdd,0x76,0x8d,0x4d,0xf7,0x10);
EXTERN_GUID( IID_IWMPropertyVault,      0x72995A79,0x5090,0x42a4,0x9C,0x8C,0xD9,0xD0,0xB6,0xD3,0x4B,0xE5 );
EXTERN_GUID( CLSID_WMMUTEX_Bitrate, 0xD6E22A01,0x35DA,0x11D1,0x90,0x34,0x00,0xA0,0xC9,0x03,0x49,0xBE );
#define WM_MAX_VIDEO_STREAMS            0x00c
HRESULT STDMETHODCALLTYPE WMCreateCertificate( IUnknown** pUnkCert );
HRESULT STDMETHODCALLTYPE WMCreateWriter( IUnknown* pUnkCert, IWMWriter **ppWriter );
HRESULT STDMETHODCALLTYPE WMCreateReader( IUnknown* pUnkCert, DWORD dwRights, IWMReader **ppReader );
HRESULT STDMETHODCALLTYPE WMCreateEditor( IWMMetadataEditor **ppEditor );
HRESULT STDMETHODCALLTYPE WMCreateIndexer( IWMIndexer **ppIndexer );
HRESULT STDMETHODCALLTYPE WMCreateBackupRestorer( IUnknown *pCallback, IWMLicenseBackup **ppBackup );
HRESULT STDMETHODCALLTYPE WMCreateProfileManager( IWMProfileManager **ppProfileManager );
HRESULT STDMETHODCALLTYPE WMCreateWriterFileSink( IWMWriterFileSink **ppSink );
HRESULT STDMETHODCALLTYPE WMCreateWriterNetworkSink( IWMWriterNetworkSink **ppSink );


extern RPC_IF_HANDLE __MIDL_itf_wmsdkidl_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmsdkidl_0000_v0_0_s_ifspec;

#ifndef __IWMMediaProps_INTERFACE_DEFINED__
#define __IWMMediaProps_INTERFACE_DEFINED__

/* interface IWMMediaProps */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMMediaProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BCE-2B2B-11d3-B36B-00C04F6108FF")
    IWMMediaProps : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ GUID __RPC_FAR *pguidType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMediaType( 
            /* [out] */ WM_MEDIA_TYPE __RPC_FAR *pType,
            /* [out][in] */ DWORD __RPC_FAR *pcbType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMediaType( 
            /* [in] */ WM_MEDIA_TYPE __RPC_FAR *pType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMMediaPropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMMediaProps __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMMediaProps __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMMediaProps __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IWMMediaProps __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pguidType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMediaType )( 
            IWMMediaProps __RPC_FAR * This,
            /* [out] */ WM_MEDIA_TYPE __RPC_FAR *pType,
            /* [out][in] */ DWORD __RPC_FAR *pcbType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMediaType )( 
            IWMMediaProps __RPC_FAR * This,
            /* [in] */ WM_MEDIA_TYPE __RPC_FAR *pType);
        
        END_INTERFACE
    } IWMMediaPropsVtbl;

    interface IWMMediaProps
    {
        CONST_VTBL struct IWMMediaPropsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMMediaProps_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMMediaProps_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMMediaProps_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMMediaProps_GetType(This,pguidType)	\
    (This)->lpVtbl -> GetType(This,pguidType)

#define IWMMediaProps_GetMediaType(This,pType,pcbType)	\
    (This)->lpVtbl -> GetMediaType(This,pType,pcbType)

#define IWMMediaProps_SetMediaType(This,pType)	\
    (This)->lpVtbl -> SetMediaType(This,pType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMMediaProps_GetType_Proxy( 
    IWMMediaProps __RPC_FAR * This,
    /* [out] */ GUID __RPC_FAR *pguidType);


void __RPC_STUB IWMMediaProps_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMMediaProps_GetMediaType_Proxy( 
    IWMMediaProps __RPC_FAR * This,
    /* [out] */ WM_MEDIA_TYPE __RPC_FAR *pType,
    /* [out][in] */ DWORD __RPC_FAR *pcbType);


void __RPC_STUB IWMMediaProps_GetMediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMMediaProps_SetMediaType_Proxy( 
    IWMMediaProps __RPC_FAR * This,
    /* [in] */ WM_MEDIA_TYPE __RPC_FAR *pType);


void __RPC_STUB IWMMediaProps_SetMediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMMediaProps_INTERFACE_DEFINED__ */


#ifndef __IWMVideoMediaProps_INTERFACE_DEFINED__
#define __IWMVideoMediaProps_INTERFACE_DEFINED__

/* interface IWMVideoMediaProps */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMVideoMediaProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BCF-2B2B-11d3-B36B-00C04F6108FF")
    IWMVideoMediaProps : public IWMMediaProps
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMaxKeyFrameSpacing( 
            /* [out] */ LONGLONG __RPC_FAR *pllTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMaxKeyFrameSpacing( 
            /* [in] */ LONGLONG llTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetQuality( 
            /* [out] */ DWORD __RPC_FAR *pdwQuality) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetQuality( 
            /* [in] */ DWORD dwQuality) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMVideoMediaPropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMVideoMediaProps __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMVideoMediaProps __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMVideoMediaProps __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IWMVideoMediaProps __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pguidType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMediaType )( 
            IWMVideoMediaProps __RPC_FAR * This,
            /* [out] */ WM_MEDIA_TYPE __RPC_FAR *pType,
            /* [out][in] */ DWORD __RPC_FAR *pcbType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMediaType )( 
            IWMVideoMediaProps __RPC_FAR * This,
            /* [in] */ WM_MEDIA_TYPE __RPC_FAR *pType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxKeyFrameSpacing )( 
            IWMVideoMediaProps __RPC_FAR * This,
            /* [out] */ LONGLONG __RPC_FAR *pllTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMaxKeyFrameSpacing )( 
            IWMVideoMediaProps __RPC_FAR * This,
            /* [in] */ LONGLONG llTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetQuality )( 
            IWMVideoMediaProps __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwQuality);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetQuality )( 
            IWMVideoMediaProps __RPC_FAR * This,
            /* [in] */ DWORD dwQuality);
        
        END_INTERFACE
    } IWMVideoMediaPropsVtbl;

    interface IWMVideoMediaProps
    {
        CONST_VTBL struct IWMVideoMediaPropsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMVideoMediaProps_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMVideoMediaProps_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMVideoMediaProps_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMVideoMediaProps_GetType(This,pguidType)	\
    (This)->lpVtbl -> GetType(This,pguidType)

#define IWMVideoMediaProps_GetMediaType(This,pType,pcbType)	\
    (This)->lpVtbl -> GetMediaType(This,pType,pcbType)

#define IWMVideoMediaProps_SetMediaType(This,pType)	\
    (This)->lpVtbl -> SetMediaType(This,pType)


#define IWMVideoMediaProps_GetMaxKeyFrameSpacing(This,pllTime)	\
    (This)->lpVtbl -> GetMaxKeyFrameSpacing(This,pllTime)

#define IWMVideoMediaProps_SetMaxKeyFrameSpacing(This,llTime)	\
    (This)->lpVtbl -> SetMaxKeyFrameSpacing(This,llTime)

#define IWMVideoMediaProps_GetQuality(This,pdwQuality)	\
    (This)->lpVtbl -> GetQuality(This,pdwQuality)

#define IWMVideoMediaProps_SetQuality(This,dwQuality)	\
    (This)->lpVtbl -> SetQuality(This,dwQuality)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMVideoMediaProps_GetMaxKeyFrameSpacing_Proxy( 
    IWMVideoMediaProps __RPC_FAR * This,
    /* [out] */ LONGLONG __RPC_FAR *pllTime);


void __RPC_STUB IWMVideoMediaProps_GetMaxKeyFrameSpacing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMVideoMediaProps_SetMaxKeyFrameSpacing_Proxy( 
    IWMVideoMediaProps __RPC_FAR * This,
    /* [in] */ LONGLONG llTime);


void __RPC_STUB IWMVideoMediaProps_SetMaxKeyFrameSpacing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMVideoMediaProps_GetQuality_Proxy( 
    IWMVideoMediaProps __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwQuality);


void __RPC_STUB IWMVideoMediaProps_GetQuality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMVideoMediaProps_SetQuality_Proxy( 
    IWMVideoMediaProps __RPC_FAR * This,
    /* [in] */ DWORD dwQuality);


void __RPC_STUB IWMVideoMediaProps_SetQuality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMVideoMediaProps_INTERFACE_DEFINED__ */


#ifndef __IWMWriter_INTERFACE_DEFINED__
#define __IWMWriter_INTERFACE_DEFINED__

/* interface IWMWriter */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BD4-2B2B-11d3-B36B-00C04F6108FF")
    IWMWriter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetProfileByID( 
            /* [in] */ REFGUID guidProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProfile( 
            /* [in] */ IWMProfile __RPC_FAR *pProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputFilename( 
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInputCount( 
            /* [out] */ DWORD __RPC_FAR *pcInputs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInputProps( 
            /* [in] */ DWORD dwInputNum,
            /* [out] */ IWMInputMediaProps __RPC_FAR *__RPC_FAR *ppInput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInputProps( 
            /* [in] */ DWORD dwInputNum,
            /* [in] */ IWMInputMediaProps __RPC_FAR *pInput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInputFormatCount( 
            /* [in] */ DWORD dwInputNumber,
            /* [out] */ DWORD __RPC_FAR *pcFormats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInputFormat( 
            /* [in] */ DWORD dwInputNumber,
            /* [in] */ DWORD dwFormatNumber,
            /* [out] */ IWMInputMediaProps __RPC_FAR *__RPC_FAR *pProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginWriting( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndWriting( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateSample( 
            /* [in] */ DWORD dwSampleSize,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteSample( 
            /* [in] */ DWORD dwInputNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Flush( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMWriter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMWriter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMWriter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProfileByID )( 
            IWMWriter __RPC_FAR * This,
            /* [in] */ REFGUID guidProfile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProfile )( 
            IWMWriter __RPC_FAR * This,
            /* [in] */ IWMProfile __RPC_FAR *pProfile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOutputFilename )( 
            IWMWriter __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInputCount )( 
            IWMWriter __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcInputs);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInputProps )( 
            IWMWriter __RPC_FAR * This,
            /* [in] */ DWORD dwInputNum,
            /* [out] */ IWMInputMediaProps __RPC_FAR *__RPC_FAR *ppInput);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetInputProps )( 
            IWMWriter __RPC_FAR * This,
            /* [in] */ DWORD dwInputNum,
            /* [in] */ IWMInputMediaProps __RPC_FAR *pInput);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInputFormatCount )( 
            IWMWriter __RPC_FAR * This,
            /* [in] */ DWORD dwInputNumber,
            /* [out] */ DWORD __RPC_FAR *pcFormats);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInputFormat )( 
            IWMWriter __RPC_FAR * This,
            /* [in] */ DWORD dwInputNumber,
            /* [in] */ DWORD dwFormatNumber,
            /* [out] */ IWMInputMediaProps __RPC_FAR *__RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginWriting )( 
            IWMWriter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndWriting )( 
            IWMWriter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateSample )( 
            IWMWriter __RPC_FAR * This,
            /* [in] */ DWORD dwSampleSize,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppSample);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteSample )( 
            IWMWriter __RPC_FAR * This,
            /* [in] */ DWORD dwInputNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Flush )( 
            IWMWriter __RPC_FAR * This);
        
        END_INTERFACE
    } IWMWriterVtbl;

    interface IWMWriter
    {
        CONST_VTBL struct IWMWriterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriter_SetProfileByID(This,guidProfile)	\
    (This)->lpVtbl -> SetProfileByID(This,guidProfile)

#define IWMWriter_SetProfile(This,pProfile)	\
    (This)->lpVtbl -> SetProfile(This,pProfile)

#define IWMWriter_SetOutputFilename(This,pwszFilename)	\
    (This)->lpVtbl -> SetOutputFilename(This,pwszFilename)

#define IWMWriter_GetInputCount(This,pcInputs)	\
    (This)->lpVtbl -> GetInputCount(This,pcInputs)

#define IWMWriter_GetInputProps(This,dwInputNum,ppInput)	\
    (This)->lpVtbl -> GetInputProps(This,dwInputNum,ppInput)

#define IWMWriter_SetInputProps(This,dwInputNum,pInput)	\
    (This)->lpVtbl -> SetInputProps(This,dwInputNum,pInput)

#define IWMWriter_GetInputFormatCount(This,dwInputNumber,pcFormats)	\
    (This)->lpVtbl -> GetInputFormatCount(This,dwInputNumber,pcFormats)

#define IWMWriter_GetInputFormat(This,dwInputNumber,dwFormatNumber,pProps)	\
    (This)->lpVtbl -> GetInputFormat(This,dwInputNumber,dwFormatNumber,pProps)

#define IWMWriter_BeginWriting(This)	\
    (This)->lpVtbl -> BeginWriting(This)

#define IWMWriter_EndWriting(This)	\
    (This)->lpVtbl -> EndWriting(This)

#define IWMWriter_AllocateSample(This,dwSampleSize,ppSample)	\
    (This)->lpVtbl -> AllocateSample(This,dwSampleSize,ppSample)

#define IWMWriter_WriteSample(This,dwInputNum,cnsSampleTime,dwFlags,pSample)	\
    (This)->lpVtbl -> WriteSample(This,dwInputNum,cnsSampleTime,dwFlags,pSample)

#define IWMWriter_Flush(This)	\
    (This)->lpVtbl -> Flush(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriter_SetProfileByID_Proxy( 
    IWMWriter __RPC_FAR * This,
    /* [in] */ REFGUID guidProfile);


void __RPC_STUB IWMWriter_SetProfileByID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_SetProfile_Proxy( 
    IWMWriter __RPC_FAR * This,
    /* [in] */ IWMProfile __RPC_FAR *pProfile);


void __RPC_STUB IWMWriter_SetProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_SetOutputFilename_Proxy( 
    IWMWriter __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwszFilename);


void __RPC_STUB IWMWriter_SetOutputFilename_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_GetInputCount_Proxy( 
    IWMWriter __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcInputs);


void __RPC_STUB IWMWriter_GetInputCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_GetInputProps_Proxy( 
    IWMWriter __RPC_FAR * This,
    /* [in] */ DWORD dwInputNum,
    /* [out] */ IWMInputMediaProps __RPC_FAR *__RPC_FAR *ppInput);


void __RPC_STUB IWMWriter_GetInputProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_SetInputProps_Proxy( 
    IWMWriter __RPC_FAR * This,
    /* [in] */ DWORD dwInputNum,
    /* [in] */ IWMInputMediaProps __RPC_FAR *pInput);


void __RPC_STUB IWMWriter_SetInputProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_GetInputFormatCount_Proxy( 
    IWMWriter __RPC_FAR * This,
    /* [in] */ DWORD dwInputNumber,
    /* [out] */ DWORD __RPC_FAR *pcFormats);


void __RPC_STUB IWMWriter_GetInputFormatCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_GetInputFormat_Proxy( 
    IWMWriter __RPC_FAR * This,
    /* [in] */ DWORD dwInputNumber,
    /* [in] */ DWORD dwFormatNumber,
    /* [out] */ IWMInputMediaProps __RPC_FAR *__RPC_FAR *pProps);


void __RPC_STUB IWMWriter_GetInputFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_BeginWriting_Proxy( 
    IWMWriter __RPC_FAR * This);


void __RPC_STUB IWMWriter_BeginWriting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_EndWriting_Proxy( 
    IWMWriter __RPC_FAR * This);


void __RPC_STUB IWMWriter_EndWriting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_AllocateSample_Proxy( 
    IWMWriter __RPC_FAR * This,
    /* [in] */ DWORD dwSampleSize,
    /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppSample);


void __RPC_STUB IWMWriter_AllocateSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_WriteSample_Proxy( 
    IWMWriter __RPC_FAR * This,
    /* [in] */ DWORD dwInputNum,
    /* [in] */ QWORD cnsSampleTime,
    /* [in] */ DWORD dwFlags,
    /* [in] */ INSSBuffer __RPC_FAR *pSample);


void __RPC_STUB IWMWriter_WriteSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_Flush_Proxy( 
    IWMWriter __RPC_FAR * This);


void __RPC_STUB IWMWriter_Flush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriter_INTERFACE_DEFINED__ */


#ifndef __IWMInputMediaProps_INTERFACE_DEFINED__
#define __IWMInputMediaProps_INTERFACE_DEFINED__

/* interface IWMInputMediaProps */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMInputMediaProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BD5-2B2B-11d3-B36B-00C04F6108FF")
    IWMInputMediaProps : public IWMMediaProps
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetConnectionName( 
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGroupName( 
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMInputMediaPropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMInputMediaProps __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMInputMediaProps __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMInputMediaProps __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IWMInputMediaProps __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pguidType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMediaType )( 
            IWMInputMediaProps __RPC_FAR * This,
            /* [out] */ WM_MEDIA_TYPE __RPC_FAR *pType,
            /* [out][in] */ DWORD __RPC_FAR *pcbType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMediaType )( 
            IWMInputMediaProps __RPC_FAR * This,
            /* [in] */ WM_MEDIA_TYPE __RPC_FAR *pType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConnectionName )( 
            IWMInputMediaProps __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGroupName )( 
            IWMInputMediaProps __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchName);
        
        END_INTERFACE
    } IWMInputMediaPropsVtbl;

    interface IWMInputMediaProps
    {
        CONST_VTBL struct IWMInputMediaPropsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMInputMediaProps_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMInputMediaProps_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMInputMediaProps_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMInputMediaProps_GetType(This,pguidType)	\
    (This)->lpVtbl -> GetType(This,pguidType)

#define IWMInputMediaProps_GetMediaType(This,pType,pcbType)	\
    (This)->lpVtbl -> GetMediaType(This,pType,pcbType)

#define IWMInputMediaProps_SetMediaType(This,pType)	\
    (This)->lpVtbl -> SetMediaType(This,pType)


#define IWMInputMediaProps_GetConnectionName(This,pwszName,pcchName)	\
    (This)->lpVtbl -> GetConnectionName(This,pwszName,pcchName)

#define IWMInputMediaProps_GetGroupName(This,pwszName,pcchName)	\
    (This)->lpVtbl -> GetGroupName(This,pwszName,pcchName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMInputMediaProps_GetConnectionName_Proxy( 
    IWMInputMediaProps __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszName,
    /* [out][in] */ WORD __RPC_FAR *pcchName);


void __RPC_STUB IWMInputMediaProps_GetConnectionName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMInputMediaProps_GetGroupName_Proxy( 
    IWMInputMediaProps __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszName,
    /* [out][in] */ WORD __RPC_FAR *pcchName);


void __RPC_STUB IWMInputMediaProps_GetGroupName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMInputMediaProps_INTERFACE_DEFINED__ */


#ifndef __IWMPropertyVault_INTERFACE_DEFINED__
#define __IWMPropertyVault_INTERFACE_DEFINED__

/* interface IWMPropertyVault */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMPropertyVault;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("72995A79-5090-42a4-9C8C-D9D0B6D34BE5")
    IWMPropertyVault : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPropertyCount( 
            /* [in] */ DWORD __RPC_FAR *pdwCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyByName( 
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ DWORD __RPC_FAR *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE pType,
            /* [in] */ BYTE __RPC_FAR *pValue,
            /* [in] */ DWORD dwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyByIndex( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ LPWSTR pszName,
            /* [out][in] */ DWORD __RPC_FAR *pdwNameLen,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ DWORD __RPC_FAR *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CopyPropertiesFrom( 
            /* [in] */ IWMPropertyVault __RPC_FAR *pIWMPropertyVault) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPropertyVaultVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPropertyVault __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPropertyVault __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPropertyVault __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyCount )( 
            IWMPropertyVault __RPC_FAR * This,
            /* [in] */ DWORD __RPC_FAR *pdwCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyByName )( 
            IWMPropertyVault __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ DWORD __RPC_FAR *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProperty )( 
            IWMPropertyVault __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE pType,
            /* [in] */ BYTE __RPC_FAR *pValue,
            /* [in] */ DWORD dwSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyByIndex )( 
            IWMPropertyVault __RPC_FAR * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ LPWSTR pszName,
            /* [out][in] */ DWORD __RPC_FAR *pdwNameLen,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ DWORD __RPC_FAR *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CopyPropertiesFrom )( 
            IWMPropertyVault __RPC_FAR * This,
            /* [in] */ IWMPropertyVault __RPC_FAR *pIWMPropertyVault);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clear )( 
            IWMPropertyVault __RPC_FAR * This);
        
        END_INTERFACE
    } IWMPropertyVaultVtbl;

    interface IWMPropertyVault
    {
        CONST_VTBL struct IWMPropertyVaultVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPropertyVault_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPropertyVault_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPropertyVault_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPropertyVault_GetPropertyCount(This,pdwCount)	\
    (This)->lpVtbl -> GetPropertyCount(This,pdwCount)

#define IWMPropertyVault_GetPropertyByName(This,pszName,pType,pValue,pdwSize)	\
    (This)->lpVtbl -> GetPropertyByName(This,pszName,pType,pValue,pdwSize)

#define IWMPropertyVault_SetProperty(This,pszName,pType,pValue,dwSize)	\
    (This)->lpVtbl -> SetProperty(This,pszName,pType,pValue,dwSize)

#define IWMPropertyVault_GetPropertyByIndex(This,dwIndex,pszName,pdwNameLen,pType,pValue,pdwSize)	\
    (This)->lpVtbl -> GetPropertyByIndex(This,dwIndex,pszName,pdwNameLen,pType,pValue,pdwSize)

#define IWMPropertyVault_CopyPropertiesFrom(This,pIWMPropertyVault)	\
    (This)->lpVtbl -> CopyPropertiesFrom(This,pIWMPropertyVault)

#define IWMPropertyVault_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMPropertyVault_GetPropertyCount_Proxy( 
    IWMPropertyVault __RPC_FAR * This,
    /* [in] */ DWORD __RPC_FAR *pdwCount);


void __RPC_STUB IWMPropertyVault_GetPropertyCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPropertyVault_GetPropertyByName_Proxy( 
    IWMPropertyVault __RPC_FAR * This,
    /* [in] */ LPCWSTR pszName,
    /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
    /* [out] */ BYTE __RPC_FAR *pValue,
    /* [out][in] */ DWORD __RPC_FAR *pdwSize);


void __RPC_STUB IWMPropertyVault_GetPropertyByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPropertyVault_SetProperty_Proxy( 
    IWMPropertyVault __RPC_FAR * This,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ WMT_ATTR_DATATYPE pType,
    /* [in] */ BYTE __RPC_FAR *pValue,
    /* [in] */ DWORD dwSize);


void __RPC_STUB IWMPropertyVault_SetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPropertyVault_GetPropertyByIndex_Proxy( 
    IWMPropertyVault __RPC_FAR * This,
    /* [in] */ DWORD dwIndex,
    /* [out] */ LPWSTR pszName,
    /* [out][in] */ DWORD __RPC_FAR *pdwNameLen,
    /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
    /* [out] */ BYTE __RPC_FAR *pValue,
    /* [out][in] */ DWORD __RPC_FAR *pdwSize);


void __RPC_STUB IWMPropertyVault_GetPropertyByIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPropertyVault_CopyPropertiesFrom_Proxy( 
    IWMPropertyVault __RPC_FAR * This,
    /* [in] */ IWMPropertyVault __RPC_FAR *pIWMPropertyVault);


void __RPC_STUB IWMPropertyVault_CopyPropertiesFrom_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPropertyVault_Clear_Proxy( 
    IWMPropertyVault __RPC_FAR * This);


void __RPC_STUB IWMPropertyVault_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPropertyVault_INTERFACE_DEFINED__ */


#ifndef __IWMReader_INTERFACE_DEFINED__
#define __IWMReader_INTERFACE_DEFINED__

/* interface IWMReader */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BD6-2B2B-11d3-B36B-00C04F6108FF")
    IWMReader : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ const WCHAR __RPC_FAR *pwszURL,
            /* [in] */ IWMReaderCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputCount( 
            /* [out] */ DWORD __RPC_FAR *pcOutputs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputProps( 
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ IWMOutputMediaProps __RPC_FAR *__RPC_FAR *ppOutput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputProps( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ IWMOutputMediaProps __RPC_FAR *pOutput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputFormatCount( 
            /* [in] */ DWORD dwOutputNumber,
            /* [out] */ DWORD __RPC_FAR *pcFormats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputFormat( 
            /* [in] */ DWORD dwOutputNumber,
            /* [in] */ DWORD dwFormatNumber,
            /* [out] */ IWMOutputMediaProps __RPC_FAR *__RPC_FAR *ppProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Start( 
            /* [in] */ QWORD cnsStart,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReader __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReader __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IWMReader __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszURL,
            /* [in] */ IWMReaderCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IWMReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutputCount )( 
            IWMReader __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcOutputs);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutputProps )( 
            IWMReader __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ IWMOutputMediaProps __RPC_FAR *__RPC_FAR *ppOutput);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOutputProps )( 
            IWMReader __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ IWMOutputMediaProps __RPC_FAR *pOutput);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutputFormatCount )( 
            IWMReader __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNumber,
            /* [out] */ DWORD __RPC_FAR *pcFormats);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutputFormat )( 
            IWMReader __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNumber,
            /* [in] */ DWORD dwFormatNumber,
            /* [out] */ IWMOutputMediaProps __RPC_FAR *__RPC_FAR *ppProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Start )( 
            IWMReader __RPC_FAR * This,
            /* [in] */ QWORD cnsStart,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Stop )( 
            IWMReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Pause )( 
            IWMReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Resume )( 
            IWMReader __RPC_FAR * This);
        
        END_INTERFACE
    } IWMReaderVtbl;

    interface IWMReader
    {
        CONST_VTBL struct IWMReaderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReader_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReader_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReader_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReader_Open(This,pwszURL,pCallback,pvContext)	\
    (This)->lpVtbl -> Open(This,pwszURL,pCallback,pvContext)

#define IWMReader_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define IWMReader_GetOutputCount(This,pcOutputs)	\
    (This)->lpVtbl -> GetOutputCount(This,pcOutputs)

#define IWMReader_GetOutputProps(This,dwOutputNum,ppOutput)	\
    (This)->lpVtbl -> GetOutputProps(This,dwOutputNum,ppOutput)

#define IWMReader_SetOutputProps(This,dwOutputNum,pOutput)	\
    (This)->lpVtbl -> SetOutputProps(This,dwOutputNum,pOutput)

#define IWMReader_GetOutputFormatCount(This,dwOutputNumber,pcFormats)	\
    (This)->lpVtbl -> GetOutputFormatCount(This,dwOutputNumber,pcFormats)

#define IWMReader_GetOutputFormat(This,dwOutputNumber,dwFormatNumber,ppProps)	\
    (This)->lpVtbl -> GetOutputFormat(This,dwOutputNumber,dwFormatNumber,ppProps)

#define IWMReader_Start(This,cnsStart,cnsDuration,fRate,pvContext)	\
    (This)->lpVtbl -> Start(This,cnsStart,cnsDuration,fRate,pvContext)

#define IWMReader_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#define IWMReader_Pause(This)	\
    (This)->lpVtbl -> Pause(This)

#define IWMReader_Resume(This)	\
    (This)->lpVtbl -> Resume(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReader_Open_Proxy( 
    IWMReader __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwszURL,
    /* [in] */ IWMReaderCallback __RPC_FAR *pCallback,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReader_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_Close_Proxy( 
    IWMReader __RPC_FAR * This);


void __RPC_STUB IWMReader_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_GetOutputCount_Proxy( 
    IWMReader __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcOutputs);


void __RPC_STUB IWMReader_GetOutputCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_GetOutputProps_Proxy( 
    IWMReader __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [out] */ IWMOutputMediaProps __RPC_FAR *__RPC_FAR *ppOutput);


void __RPC_STUB IWMReader_GetOutputProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_SetOutputProps_Proxy( 
    IWMReader __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ IWMOutputMediaProps __RPC_FAR *pOutput);


void __RPC_STUB IWMReader_SetOutputProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_GetOutputFormatCount_Proxy( 
    IWMReader __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNumber,
    /* [out] */ DWORD __RPC_FAR *pcFormats);


void __RPC_STUB IWMReader_GetOutputFormatCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_GetOutputFormat_Proxy( 
    IWMReader __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNumber,
    /* [in] */ DWORD dwFormatNumber,
    /* [out] */ IWMOutputMediaProps __RPC_FAR *__RPC_FAR *ppProps);


void __RPC_STUB IWMReader_GetOutputFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_Start_Proxy( 
    IWMReader __RPC_FAR * This,
    /* [in] */ QWORD cnsStart,
    /* [in] */ QWORD cnsDuration,
    /* [in] */ float fRate,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReader_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_Stop_Proxy( 
    IWMReader __RPC_FAR * This);


void __RPC_STUB IWMReader_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_Pause_Proxy( 
    IWMReader __RPC_FAR * This);


void __RPC_STUB IWMReader_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_Resume_Proxy( 
    IWMReader __RPC_FAR * This);


void __RPC_STUB IWMReader_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReader_INTERFACE_DEFINED__ */


#ifndef __IWMOutputMediaProps_INTERFACE_DEFINED__
#define __IWMOutputMediaProps_INTERFACE_DEFINED__

/* interface IWMOutputMediaProps */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMOutputMediaProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BD7-2B2B-11d3-B36B-00C04F6108FF")
    IWMOutputMediaProps : public IWMMediaProps
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStreamGroupName( 
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConnectionName( 
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMOutputMediaPropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMOutputMediaProps __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMOutputMediaProps __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMOutputMediaProps __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IWMOutputMediaProps __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pguidType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMediaType )( 
            IWMOutputMediaProps __RPC_FAR * This,
            /* [out] */ WM_MEDIA_TYPE __RPC_FAR *pType,
            /* [out][in] */ DWORD __RPC_FAR *pcbType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMediaType )( 
            IWMOutputMediaProps __RPC_FAR * This,
            /* [in] */ WM_MEDIA_TYPE __RPC_FAR *pType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamGroupName )( 
            IWMOutputMediaProps __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConnectionName )( 
            IWMOutputMediaProps __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchName);
        
        END_INTERFACE
    } IWMOutputMediaPropsVtbl;

    interface IWMOutputMediaProps
    {
        CONST_VTBL struct IWMOutputMediaPropsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMOutputMediaProps_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMOutputMediaProps_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMOutputMediaProps_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMOutputMediaProps_GetType(This,pguidType)	\
    (This)->lpVtbl -> GetType(This,pguidType)

#define IWMOutputMediaProps_GetMediaType(This,pType,pcbType)	\
    (This)->lpVtbl -> GetMediaType(This,pType,pcbType)

#define IWMOutputMediaProps_SetMediaType(This,pType)	\
    (This)->lpVtbl -> SetMediaType(This,pType)


#define IWMOutputMediaProps_GetStreamGroupName(This,pwszName,pcchName)	\
    (This)->lpVtbl -> GetStreamGroupName(This,pwszName,pcchName)

#define IWMOutputMediaProps_GetConnectionName(This,pwszName,pcchName)	\
    (This)->lpVtbl -> GetConnectionName(This,pwszName,pcchName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMOutputMediaProps_GetStreamGroupName_Proxy( 
    IWMOutputMediaProps __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszName,
    /* [out][in] */ WORD __RPC_FAR *pcchName);


void __RPC_STUB IWMOutputMediaProps_GetStreamGroupName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMOutputMediaProps_GetConnectionName_Proxy( 
    IWMOutputMediaProps __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszName,
    /* [out][in] */ WORD __RPC_FAR *pcchName);


void __RPC_STUB IWMOutputMediaProps_GetConnectionName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMOutputMediaProps_INTERFACE_DEFINED__ */


#ifndef __IWMStatusCallback_INTERFACE_DEFINED__
#define __IWMStatusCallback_INTERFACE_DEFINED__

/* interface IWMStatusCallback */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMStatusCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6d7cdc70-9888-11d3-8edc-00c04f6109cf")
    IWMStatusCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnStatus( 
            /* [in] */ WMT_STATUS Status,
            /* [in] */ HRESULT hr,
            /* [in] */ WMT_ATTR_DATATYPE dwType,
            /* [in] */ BYTE __RPC_FAR *pValue,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMStatusCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMStatusCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMStatusCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMStatusCallback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStatus )( 
            IWMStatusCallback __RPC_FAR * This,
            /* [in] */ WMT_STATUS Status,
            /* [in] */ HRESULT hr,
            /* [in] */ WMT_ATTR_DATATYPE dwType,
            /* [in] */ BYTE __RPC_FAR *pValue,
            /* [in] */ void __RPC_FAR *pvContext);
        
        END_INTERFACE
    } IWMStatusCallbackVtbl;

    interface IWMStatusCallback
    {
        CONST_VTBL struct IWMStatusCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMStatusCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMStatusCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMStatusCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMStatusCallback_OnStatus(This,Status,hr,dwType,pValue,pvContext)	\
    (This)->lpVtbl -> OnStatus(This,Status,hr,dwType,pValue,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMStatusCallback_OnStatus_Proxy( 
    IWMStatusCallback __RPC_FAR * This,
    /* [in] */ WMT_STATUS Status,
    /* [in] */ HRESULT hr,
    /* [in] */ WMT_ATTR_DATATYPE dwType,
    /* [in] */ BYTE __RPC_FAR *pValue,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMStatusCallback_OnStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMStatusCallback_INTERFACE_DEFINED__ */


#ifndef __IWMReaderCallback_INTERFACE_DEFINED__
#define __IWMReaderCallback_INTERFACE_DEFINED__

/* interface IWMReaderCallback */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BD8-2B2B-11d3-B36B-00C04F6108FF")
    IWMReaderCallback : public IWMStatusCallback
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnSample( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReaderCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReaderCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReaderCallback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStatus )( 
            IWMReaderCallback __RPC_FAR * This,
            /* [in] */ WMT_STATUS Status,
            /* [in] */ HRESULT hr,
            /* [in] */ WMT_ATTR_DATATYPE dwType,
            /* [in] */ BYTE __RPC_FAR *pValue,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnSample )( 
            IWMReaderCallback __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample,
            /* [in] */ void __RPC_FAR *pvContext);
        
        END_INTERFACE
    } IWMReaderCallbackVtbl;

    interface IWMReaderCallback
    {
        CONST_VTBL struct IWMReaderCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderCallback_OnStatus(This,Status,hr,dwType,pValue,pvContext)	\
    (This)->lpVtbl -> OnStatus(This,Status,hr,dwType,pValue,pvContext)


#define IWMReaderCallback_OnSample(This,dwOutputNum,cnsSampleTime,cnsSampleDuration,dwFlags,pSample,pvContext)	\
    (This)->lpVtbl -> OnSample(This,dwOutputNum,cnsSampleTime,cnsSampleDuration,dwFlags,pSample,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderCallback_OnSample_Proxy( 
    IWMReaderCallback __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ QWORD cnsSampleTime,
    /* [in] */ QWORD cnsSampleDuration,
    /* [in] */ DWORD dwFlags,
    /* [in] */ INSSBuffer __RPC_FAR *pSample,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderCallback_OnSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderCallback_INTERFACE_DEFINED__ */


#ifndef __IWMCredentialCallback_INTERFACE_DEFINED__
#define __IWMCredentialCallback_INTERFACE_DEFINED__

/* interface IWMCredentialCallback */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMCredentialCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("342e0eb7-e651-450c-975b-2ace2c90c48e")
    IWMCredentialCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AcquireCredentials( 
            /* [in] */ WCHAR __RPC_FAR *pwszRealm,
            /* [in] */ WCHAR __RPC_FAR *pwszSite,
            /* [size_is][out][in] */ WCHAR __RPC_FAR *pwszUser,
            /* [in] */ DWORD cchUser,
            /* [size_is][out][in] */ WCHAR __RPC_FAR *pwszPassword,
            /* [in] */ DWORD cchPassword,
            /* [in] */ HRESULT hrStatus,
            /* [out][in] */ DWORD __RPC_FAR *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMCredentialCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMCredentialCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMCredentialCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMCredentialCallback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AcquireCredentials )( 
            IWMCredentialCallback __RPC_FAR * This,
            /* [in] */ WCHAR __RPC_FAR *pwszRealm,
            /* [in] */ WCHAR __RPC_FAR *pwszSite,
            /* [size_is][out][in] */ WCHAR __RPC_FAR *pwszUser,
            /* [in] */ DWORD cchUser,
            /* [size_is][out][in] */ WCHAR __RPC_FAR *pwszPassword,
            /* [in] */ DWORD cchPassword,
            /* [in] */ HRESULT hrStatus,
            /* [out][in] */ DWORD __RPC_FAR *pdwFlags);
        
        END_INTERFACE
    } IWMCredentialCallbackVtbl;

    interface IWMCredentialCallback
    {
        CONST_VTBL struct IWMCredentialCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMCredentialCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMCredentialCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMCredentialCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMCredentialCallback_AcquireCredentials(This,pwszRealm,pwszSite,pwszUser,cchUser,pwszPassword,cchPassword,hrStatus,pdwFlags)	\
    (This)->lpVtbl -> AcquireCredentials(This,pwszRealm,pwszSite,pwszUser,cchUser,pwszPassword,cchPassword,hrStatus,pdwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMCredentialCallback_AcquireCredentials_Proxy( 
    IWMCredentialCallback __RPC_FAR * This,
    /* [in] */ WCHAR __RPC_FAR *pwszRealm,
    /* [in] */ WCHAR __RPC_FAR *pwszSite,
    /* [size_is][out][in] */ WCHAR __RPC_FAR *pwszUser,
    /* [in] */ DWORD cchUser,
    /* [size_is][out][in] */ WCHAR __RPC_FAR *pwszPassword,
    /* [in] */ DWORD cchPassword,
    /* [in] */ HRESULT hrStatus,
    /* [out][in] */ DWORD __RPC_FAR *pdwFlags);


void __RPC_STUB IWMCredentialCallback_AcquireCredentials_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMCredentialCallback_INTERFACE_DEFINED__ */


#ifndef __IWMMetadataEditor_INTERFACE_DEFINED__
#define __IWMMetadataEditor_INTERFACE_DEFINED__

/* interface IWMMetadataEditor */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMMetadataEditor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BD9-2B2B-11d3-B36B-00C04F6108FF")
    IWMMetadataEditor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Flush( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMMetadataEditorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMMetadataEditor __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMMetadataEditor __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMMetadataEditor __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IWMMetadataEditor __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IWMMetadataEditor __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Flush )( 
            IWMMetadataEditor __RPC_FAR * This);
        
        END_INTERFACE
    } IWMMetadataEditorVtbl;

    interface IWMMetadataEditor
    {
        CONST_VTBL struct IWMMetadataEditorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMMetadataEditor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMMetadataEditor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMMetadataEditor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMMetadataEditor_Open(This,pwszFilename)	\
    (This)->lpVtbl -> Open(This,pwszFilename)

#define IWMMetadataEditor_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define IWMMetadataEditor_Flush(This)	\
    (This)->lpVtbl -> Flush(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMMetadataEditor_Open_Proxy( 
    IWMMetadataEditor __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwszFilename);


void __RPC_STUB IWMMetadataEditor_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMMetadataEditor_Close_Proxy( 
    IWMMetadataEditor __RPC_FAR * This);


void __RPC_STUB IWMMetadataEditor_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMMetadataEditor_Flush_Proxy( 
    IWMMetadataEditor __RPC_FAR * This);


void __RPC_STUB IWMMetadataEditor_Flush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMMetadataEditor_INTERFACE_DEFINED__ */


#ifndef __IWMMetadataEditor2_INTERFACE_DEFINED__
#define __IWMMetadataEditor2_INTERFACE_DEFINED__

/* interface IWMMetadataEditor2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMMetadataEditor2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("203CFFE3-2E18-4fdf-B59D-6E71530534CF")
    IWMMetadataEditor2 : public IWMMetadataEditor
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OpenEx( 
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename,
            /* [in] */ DWORD dwDesiredAccess,
            /* [in] */ DWORD dwShareMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMMetadataEditor2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMMetadataEditor2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMMetadataEditor2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMMetadataEditor2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IWMMetadataEditor2 __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IWMMetadataEditor2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Flush )( 
            IWMMetadataEditor2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenEx )( 
            IWMMetadataEditor2 __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename,
            /* [in] */ DWORD dwDesiredAccess,
            /* [in] */ DWORD dwShareMode);
        
        END_INTERFACE
    } IWMMetadataEditor2Vtbl;

    interface IWMMetadataEditor2
    {
        CONST_VTBL struct IWMMetadataEditor2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMMetadataEditor2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMMetadataEditor2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMMetadataEditor2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMMetadataEditor2_Open(This,pwszFilename)	\
    (This)->lpVtbl -> Open(This,pwszFilename)

#define IWMMetadataEditor2_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define IWMMetadataEditor2_Flush(This)	\
    (This)->lpVtbl -> Flush(This)


#define IWMMetadataEditor2_OpenEx(This,pwszFilename,dwDesiredAccess,dwShareMode)	\
    (This)->lpVtbl -> OpenEx(This,pwszFilename,dwDesiredAccess,dwShareMode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMMetadataEditor2_OpenEx_Proxy( 
    IWMMetadataEditor2 __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwszFilename,
    /* [in] */ DWORD dwDesiredAccess,
    /* [in] */ DWORD dwShareMode);


void __RPC_STUB IWMMetadataEditor2_OpenEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMMetadataEditor2_INTERFACE_DEFINED__ */


#ifndef __IWMHeaderInfo_INTERFACE_DEFINED__
#define __IWMHeaderInfo_INTERFACE_DEFINED__

/* interface IWMHeaderInfo */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMHeaderInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BDA-2B2B-11d3-B36B-00C04F6108FF")
    IWMHeaderInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAttributeCount( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ WORD __RPC_FAR *pcAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributeByIndex( 
            /* [in] */ WORD wIndex,
            /* [out][in] */ WORD __RPC_FAR *pwStreamNum,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchNameLen,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributeByName( 
            /* [out][in] */ WORD __RPC_FAR *pwStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAttribute( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMarkerCount( 
            /* [out] */ WORD __RPC_FAR *pcMarkers) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMarker( 
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR __RPC_FAR *pwszMarkerName,
            /* [out][in] */ WORD __RPC_FAR *pcchMarkerNameLen,
            /* [out] */ QWORD __RPC_FAR *pcnsMarkerTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddMarker( 
            /* [in] */ WCHAR __RPC_FAR *pwszMarkerName,
            /* [in] */ QWORD cnsMarkerTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveMarker( 
            /* [in] */ WORD wIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScriptCount( 
            /* [out] */ WORD __RPC_FAR *pcScripts) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScript( 
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR __RPC_FAR *pwszType,
            /* [out][in] */ WORD __RPC_FAR *pcchTypeLen,
            /* [out] */ WCHAR __RPC_FAR *pwszCommand,
            /* [out][in] */ WORD __RPC_FAR *pcchCommandLen,
            /* [out] */ QWORD __RPC_FAR *pcnsScriptTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddScript( 
            /* [in] */ WCHAR __RPC_FAR *pwszType,
            /* [in] */ WCHAR __RPC_FAR *pwszCommand,
            /* [in] */ QWORD cnsScriptTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveScript( 
            /* [in] */ WORD wIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMHeaderInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMHeaderInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMHeaderInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttributeCount )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WORD __RPC_FAR *pcAttributes);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttributeByIndex )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [in] */ WORD wIndex,
            /* [out][in] */ WORD __RPC_FAR *pwStreamNum,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchNameLen,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttributeByName )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [out][in] */ WORD __RPC_FAR *pwStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAttribute )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMarkerCount )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pcMarkers);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMarker )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR __RPC_FAR *pwszMarkerName,
            /* [out][in] */ WORD __RPC_FAR *pcchMarkerNameLen,
            /* [out] */ QWORD __RPC_FAR *pcnsMarkerTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddMarker )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [in] */ WCHAR __RPC_FAR *pwszMarkerName,
            /* [in] */ QWORD cnsMarkerTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveMarker )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [in] */ WORD wIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScriptCount )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pcScripts);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScript )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR __RPC_FAR *pwszType,
            /* [out][in] */ WORD __RPC_FAR *pcchTypeLen,
            /* [out] */ WCHAR __RPC_FAR *pwszCommand,
            /* [out][in] */ WORD __RPC_FAR *pcchCommandLen,
            /* [out] */ QWORD __RPC_FAR *pcnsScriptTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddScript )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [in] */ WCHAR __RPC_FAR *pwszType,
            /* [in] */ WCHAR __RPC_FAR *pwszCommand,
            /* [in] */ QWORD cnsScriptTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveScript )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [in] */ WORD wIndex);
        
        END_INTERFACE
    } IWMHeaderInfoVtbl;

    interface IWMHeaderInfo
    {
        CONST_VTBL struct IWMHeaderInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMHeaderInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMHeaderInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMHeaderInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMHeaderInfo_GetAttributeCount(This,wStreamNum,pcAttributes)	\
    (This)->lpVtbl -> GetAttributeCount(This,wStreamNum,pcAttributes)

#define IWMHeaderInfo_GetAttributeByIndex(This,wIndex,pwStreamNum,pwszName,pcchNameLen,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetAttributeByIndex(This,wIndex,pwStreamNum,pwszName,pcchNameLen,pType,pValue,pcbLength)

#define IWMHeaderInfo_GetAttributeByName(This,pwStreamNum,pszName,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetAttributeByName(This,pwStreamNum,pszName,pType,pValue,pcbLength)

#define IWMHeaderInfo_SetAttribute(This,wStreamNum,pszName,Type,pValue,cbLength)	\
    (This)->lpVtbl -> SetAttribute(This,wStreamNum,pszName,Type,pValue,cbLength)

#define IWMHeaderInfo_GetMarkerCount(This,pcMarkers)	\
    (This)->lpVtbl -> GetMarkerCount(This,pcMarkers)

#define IWMHeaderInfo_GetMarker(This,wIndex,pwszMarkerName,pcchMarkerNameLen,pcnsMarkerTime)	\
    (This)->lpVtbl -> GetMarker(This,wIndex,pwszMarkerName,pcchMarkerNameLen,pcnsMarkerTime)

#define IWMHeaderInfo_AddMarker(This,pwszMarkerName,cnsMarkerTime)	\
    (This)->lpVtbl -> AddMarker(This,pwszMarkerName,cnsMarkerTime)

#define IWMHeaderInfo_RemoveMarker(This,wIndex)	\
    (This)->lpVtbl -> RemoveMarker(This,wIndex)

#define IWMHeaderInfo_GetScriptCount(This,pcScripts)	\
    (This)->lpVtbl -> GetScriptCount(This,pcScripts)

#define IWMHeaderInfo_GetScript(This,wIndex,pwszType,pcchTypeLen,pwszCommand,pcchCommandLen,pcnsScriptTime)	\
    (This)->lpVtbl -> GetScript(This,wIndex,pwszType,pcchTypeLen,pwszCommand,pcchCommandLen,pcnsScriptTime)

#define IWMHeaderInfo_AddScript(This,pwszType,pwszCommand,cnsScriptTime)	\
    (This)->lpVtbl -> AddScript(This,pwszType,pwszCommand,cnsScriptTime)

#define IWMHeaderInfo_RemoveScript(This,wIndex)	\
    (This)->lpVtbl -> RemoveScript(This,wIndex)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMHeaderInfo_GetAttributeCount_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [out] */ WORD __RPC_FAR *pcAttributes);


void __RPC_STUB IWMHeaderInfo_GetAttributeCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_GetAttributeByIndex_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [in] */ WORD wIndex,
    /* [out][in] */ WORD __RPC_FAR *pwStreamNum,
    /* [out] */ WCHAR __RPC_FAR *pwszName,
    /* [out][in] */ WORD __RPC_FAR *pcchNameLen,
    /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
    /* [out] */ BYTE __RPC_FAR *pValue,
    /* [out][in] */ WORD __RPC_FAR *pcbLength);


void __RPC_STUB IWMHeaderInfo_GetAttributeByIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_GetAttributeByName_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [out][in] */ WORD __RPC_FAR *pwStreamNum,
    /* [in] */ LPCWSTR pszName,
    /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
    /* [out] */ BYTE __RPC_FAR *pValue,
    /* [out][in] */ WORD __RPC_FAR *pcbLength);


void __RPC_STUB IWMHeaderInfo_GetAttributeByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_SetAttribute_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ WMT_ATTR_DATATYPE Type,
    /* [in] */ const BYTE __RPC_FAR *pValue,
    /* [in] */ WORD cbLength);


void __RPC_STUB IWMHeaderInfo_SetAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_GetMarkerCount_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [out] */ WORD __RPC_FAR *pcMarkers);


void __RPC_STUB IWMHeaderInfo_GetMarkerCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_GetMarker_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [in] */ WORD wIndex,
    /* [out] */ WCHAR __RPC_FAR *pwszMarkerName,
    /* [out][in] */ WORD __RPC_FAR *pcchMarkerNameLen,
    /* [out] */ QWORD __RPC_FAR *pcnsMarkerTime);


void __RPC_STUB IWMHeaderInfo_GetMarker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_AddMarker_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [in] */ WCHAR __RPC_FAR *pwszMarkerName,
    /* [in] */ QWORD cnsMarkerTime);


void __RPC_STUB IWMHeaderInfo_AddMarker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_RemoveMarker_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [in] */ WORD wIndex);


void __RPC_STUB IWMHeaderInfo_RemoveMarker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_GetScriptCount_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [out] */ WORD __RPC_FAR *pcScripts);


void __RPC_STUB IWMHeaderInfo_GetScriptCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_GetScript_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [in] */ WORD wIndex,
    /* [out] */ WCHAR __RPC_FAR *pwszType,
    /* [out][in] */ WORD __RPC_FAR *pcchTypeLen,
    /* [out] */ WCHAR __RPC_FAR *pwszCommand,
    /* [out][in] */ WORD __RPC_FAR *pcchCommandLen,
    /* [out] */ QWORD __RPC_FAR *pcnsScriptTime);


void __RPC_STUB IWMHeaderInfo_GetScript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_AddScript_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [in] */ WCHAR __RPC_FAR *pwszType,
    /* [in] */ WCHAR __RPC_FAR *pwszCommand,
    /* [in] */ QWORD cnsScriptTime);


void __RPC_STUB IWMHeaderInfo_AddScript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_RemoveScript_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [in] */ WORD wIndex);


void __RPC_STUB IWMHeaderInfo_RemoveScript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMHeaderInfo_INTERFACE_DEFINED__ */


#ifndef __IWMHeaderInfo2_INTERFACE_DEFINED__
#define __IWMHeaderInfo2_INTERFACE_DEFINED__

/* interface IWMHeaderInfo2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMHeaderInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("15CF9781-454E-482e-B393-85FAE487A810")
    IWMHeaderInfo2 : public IWMHeaderInfo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCodecInfoCount( 
            /* [out] */ DWORD __RPC_FAR *pcCodecInfos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodecInfo( 
            /* [in] */ DWORD wIndex,
            /* [out][in] */ WORD __RPC_FAR *pcchName,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchDescription,
            /* [out] */ WCHAR __RPC_FAR *pwszDescription,
            /* [out] */ WMT_CODEC_INFO_TYPE __RPC_FAR *pCodecType,
            /* [out][in] */ WORD __RPC_FAR *pcbCodecInfo,
            /* [out] */ BYTE __RPC_FAR *pbCodecInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMHeaderInfo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMHeaderInfo2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMHeaderInfo2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttributeCount )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WORD __RPC_FAR *pcAttributes);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttributeByIndex )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ WORD wIndex,
            /* [out][in] */ WORD __RPC_FAR *pwStreamNum,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchNameLen,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttributeByName )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [out][in] */ WORD __RPC_FAR *pwStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAttribute )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMarkerCount )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pcMarkers);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMarker )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR __RPC_FAR *pwszMarkerName,
            /* [out][in] */ WORD __RPC_FAR *pcchMarkerNameLen,
            /* [out] */ QWORD __RPC_FAR *pcnsMarkerTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddMarker )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ WCHAR __RPC_FAR *pwszMarkerName,
            /* [in] */ QWORD cnsMarkerTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveMarker )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ WORD wIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScriptCount )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pcScripts);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScript )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR __RPC_FAR *pwszType,
            /* [out][in] */ WORD __RPC_FAR *pcchTypeLen,
            /* [out] */ WCHAR __RPC_FAR *pwszCommand,
            /* [out][in] */ WORD __RPC_FAR *pcchCommandLen,
            /* [out] */ QWORD __RPC_FAR *pcnsScriptTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddScript )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ WCHAR __RPC_FAR *pwszType,
            /* [in] */ WCHAR __RPC_FAR *pwszCommand,
            /* [in] */ QWORD cnsScriptTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveScript )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ WORD wIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecInfoCount )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcCodecInfos);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecInfo )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ DWORD wIndex,
            /* [out][in] */ WORD __RPC_FAR *pcchName,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchDescription,
            /* [out] */ WCHAR __RPC_FAR *pwszDescription,
            /* [out] */ WMT_CODEC_INFO_TYPE __RPC_FAR *pCodecType,
            /* [out][in] */ WORD __RPC_FAR *pcbCodecInfo,
            /* [out] */ BYTE __RPC_FAR *pbCodecInfo);
        
        END_INTERFACE
    } IWMHeaderInfo2Vtbl;

    interface IWMHeaderInfo2
    {
        CONST_VTBL struct IWMHeaderInfo2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMHeaderInfo2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMHeaderInfo2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMHeaderInfo2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMHeaderInfo2_GetAttributeCount(This,wStreamNum,pcAttributes)	\
    (This)->lpVtbl -> GetAttributeCount(This,wStreamNum,pcAttributes)

#define IWMHeaderInfo2_GetAttributeByIndex(This,wIndex,pwStreamNum,pwszName,pcchNameLen,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetAttributeByIndex(This,wIndex,pwStreamNum,pwszName,pcchNameLen,pType,pValue,pcbLength)

#define IWMHeaderInfo2_GetAttributeByName(This,pwStreamNum,pszName,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetAttributeByName(This,pwStreamNum,pszName,pType,pValue,pcbLength)

#define IWMHeaderInfo2_SetAttribute(This,wStreamNum,pszName,Type,pValue,cbLength)	\
    (This)->lpVtbl -> SetAttribute(This,wStreamNum,pszName,Type,pValue,cbLength)

#define IWMHeaderInfo2_GetMarkerCount(This,pcMarkers)	\
    (This)->lpVtbl -> GetMarkerCount(This,pcMarkers)

#define IWMHeaderInfo2_GetMarker(This,wIndex,pwszMarkerName,pcchMarkerNameLen,pcnsMarkerTime)	\
    (This)->lpVtbl -> GetMarker(This,wIndex,pwszMarkerName,pcchMarkerNameLen,pcnsMarkerTime)

#define IWMHeaderInfo2_AddMarker(This,pwszMarkerName,cnsMarkerTime)	\
    (This)->lpVtbl -> AddMarker(This,pwszMarkerName,cnsMarkerTime)

#define IWMHeaderInfo2_RemoveMarker(This,wIndex)	\
    (This)->lpVtbl -> RemoveMarker(This,wIndex)

#define IWMHeaderInfo2_GetScriptCount(This,pcScripts)	\
    (This)->lpVtbl -> GetScriptCount(This,pcScripts)

#define IWMHeaderInfo2_GetScript(This,wIndex,pwszType,pcchTypeLen,pwszCommand,pcchCommandLen,pcnsScriptTime)	\
    (This)->lpVtbl -> GetScript(This,wIndex,pwszType,pcchTypeLen,pwszCommand,pcchCommandLen,pcnsScriptTime)

#define IWMHeaderInfo2_AddScript(This,pwszType,pwszCommand,cnsScriptTime)	\
    (This)->lpVtbl -> AddScript(This,pwszType,pwszCommand,cnsScriptTime)

#define IWMHeaderInfo2_RemoveScript(This,wIndex)	\
    (This)->lpVtbl -> RemoveScript(This,wIndex)


#define IWMHeaderInfo2_GetCodecInfoCount(This,pcCodecInfos)	\
    (This)->lpVtbl -> GetCodecInfoCount(This,pcCodecInfos)

#define IWMHeaderInfo2_GetCodecInfo(This,wIndex,pcchName,pwszName,pcchDescription,pwszDescription,pCodecType,pcbCodecInfo,pbCodecInfo)	\
    (This)->lpVtbl -> GetCodecInfo(This,wIndex,pcchName,pwszName,pcchDescription,pwszDescription,pCodecType,pcbCodecInfo,pbCodecInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMHeaderInfo2_GetCodecInfoCount_Proxy( 
    IWMHeaderInfo2 __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcCodecInfos);


void __RPC_STUB IWMHeaderInfo2_GetCodecInfoCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo2_GetCodecInfo_Proxy( 
    IWMHeaderInfo2 __RPC_FAR * This,
    /* [in] */ DWORD wIndex,
    /* [out][in] */ WORD __RPC_FAR *pcchName,
    /* [out] */ WCHAR __RPC_FAR *pwszName,
    /* [out][in] */ WORD __RPC_FAR *pcchDescription,
    /* [out] */ WCHAR __RPC_FAR *pwszDescription,
    /* [out] */ WMT_CODEC_INFO_TYPE __RPC_FAR *pCodecType,
    /* [out][in] */ WORD __RPC_FAR *pcbCodecInfo,
    /* [out] */ BYTE __RPC_FAR *pbCodecInfo);


void __RPC_STUB IWMHeaderInfo2_GetCodecInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMHeaderInfo2_INTERFACE_DEFINED__ */


#ifndef __IWMProfileManager_INTERFACE_DEFINED__
#define __IWMProfileManager_INTERFACE_DEFINED__

/* interface IWMProfileManager */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMProfileManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d16679f2-6ca0-472d-8d31-2f5d55aee155")
    IWMProfileManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateEmptyProfile( 
            /* [in] */ WMT_VERSION dwVersion,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadProfileByID( 
            /* [in] */ REFGUID guidProfile,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadProfileByData( 
            /* [in] */ const WCHAR __RPC_FAR *pwszProfile,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveProfile( 
            /* [in] */ IWMProfile __RPC_FAR *pIWMProfile,
            /* [in] */ WCHAR __RPC_FAR *pwszProfile,
            /* [out][in] */ DWORD __RPC_FAR *pdwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSystemProfileCount( 
            /* [out] */ DWORD __RPC_FAR *pcProfiles) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadSystemProfile( 
            /* [in] */ DWORD dwProfileIndex,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMProfileManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMProfileManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMProfileManager __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMProfileManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateEmptyProfile )( 
            IWMProfileManager __RPC_FAR * This,
            /* [in] */ WMT_VERSION dwVersion,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadProfileByID )( 
            IWMProfileManager __RPC_FAR * This,
            /* [in] */ REFGUID guidProfile,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadProfileByData )( 
            IWMProfileManager __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszProfile,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveProfile )( 
            IWMProfileManager __RPC_FAR * This,
            /* [in] */ IWMProfile __RPC_FAR *pIWMProfile,
            /* [in] */ WCHAR __RPC_FAR *pwszProfile,
            /* [out][in] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSystemProfileCount )( 
            IWMProfileManager __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcProfiles);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadSystemProfile )( 
            IWMProfileManager __RPC_FAR * This,
            /* [in] */ DWORD dwProfileIndex,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);
        
        END_INTERFACE
    } IWMProfileManagerVtbl;

    interface IWMProfileManager
    {
        CONST_VTBL struct IWMProfileManagerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMProfileManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMProfileManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMProfileManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMProfileManager_CreateEmptyProfile(This,dwVersion,ppProfile)	\
    (This)->lpVtbl -> CreateEmptyProfile(This,dwVersion,ppProfile)

#define IWMProfileManager_LoadProfileByID(This,guidProfile,ppProfile)	\
    (This)->lpVtbl -> LoadProfileByID(This,guidProfile,ppProfile)

#define IWMProfileManager_LoadProfileByData(This,pwszProfile,ppProfile)	\
    (This)->lpVtbl -> LoadProfileByData(This,pwszProfile,ppProfile)

#define IWMProfileManager_SaveProfile(This,pIWMProfile,pwszProfile,pdwLength)	\
    (This)->lpVtbl -> SaveProfile(This,pIWMProfile,pwszProfile,pdwLength)

#define IWMProfileManager_GetSystemProfileCount(This,pcProfiles)	\
    (This)->lpVtbl -> GetSystemProfileCount(This,pcProfiles)

#define IWMProfileManager_LoadSystemProfile(This,dwProfileIndex,ppProfile)	\
    (This)->lpVtbl -> LoadSystemProfile(This,dwProfileIndex,ppProfile)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMProfileManager_CreateEmptyProfile_Proxy( 
    IWMProfileManager __RPC_FAR * This,
    /* [in] */ WMT_VERSION dwVersion,
    /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);


void __RPC_STUB IWMProfileManager_CreateEmptyProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfileManager_LoadProfileByID_Proxy( 
    IWMProfileManager __RPC_FAR * This,
    /* [in] */ REFGUID guidProfile,
    /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);


void __RPC_STUB IWMProfileManager_LoadProfileByID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfileManager_LoadProfileByData_Proxy( 
    IWMProfileManager __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwszProfile,
    /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);


void __RPC_STUB IWMProfileManager_LoadProfileByData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfileManager_SaveProfile_Proxy( 
    IWMProfileManager __RPC_FAR * This,
    /* [in] */ IWMProfile __RPC_FAR *pIWMProfile,
    /* [in] */ WCHAR __RPC_FAR *pwszProfile,
    /* [out][in] */ DWORD __RPC_FAR *pdwLength);


void __RPC_STUB IWMProfileManager_SaveProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfileManager_GetSystemProfileCount_Proxy( 
    IWMProfileManager __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcProfiles);


void __RPC_STUB IWMProfileManager_GetSystemProfileCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfileManager_LoadSystemProfile_Proxy( 
    IWMProfileManager __RPC_FAR * This,
    /* [in] */ DWORD dwProfileIndex,
    /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);


void __RPC_STUB IWMProfileManager_LoadSystemProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMProfileManager_INTERFACE_DEFINED__ */


#ifndef __IWMProfileManager2_INTERFACE_DEFINED__
#define __IWMProfileManager2_INTERFACE_DEFINED__

/* interface IWMProfileManager2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMProfileManager2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7A924E51-73C1-494d-8019-23D37ED9B89A")
    IWMProfileManager2 : public IWMProfileManager
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSystemProfileVersion( 
            WMT_VERSION __RPC_FAR *pdwVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSystemProfileVersion( 
            WMT_VERSION dwVersion) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMProfileManager2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMProfileManager2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMProfileManager2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMProfileManager2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateEmptyProfile )( 
            IWMProfileManager2 __RPC_FAR * This,
            /* [in] */ WMT_VERSION dwVersion,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadProfileByID )( 
            IWMProfileManager2 __RPC_FAR * This,
            /* [in] */ REFGUID guidProfile,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadProfileByData )( 
            IWMProfileManager2 __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszProfile,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveProfile )( 
            IWMProfileManager2 __RPC_FAR * This,
            /* [in] */ IWMProfile __RPC_FAR *pIWMProfile,
            /* [in] */ WCHAR __RPC_FAR *pwszProfile,
            /* [out][in] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSystemProfileCount )( 
            IWMProfileManager2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcProfiles);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadSystemProfile )( 
            IWMProfileManager2 __RPC_FAR * This,
            /* [in] */ DWORD dwProfileIndex,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSystemProfileVersion )( 
            IWMProfileManager2 __RPC_FAR * This,
            WMT_VERSION __RPC_FAR *pdwVersion);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSystemProfileVersion )( 
            IWMProfileManager2 __RPC_FAR * This,
            WMT_VERSION dwVersion);
        
        END_INTERFACE
    } IWMProfileManager2Vtbl;

    interface IWMProfileManager2
    {
        CONST_VTBL struct IWMProfileManager2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMProfileManager2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMProfileManager2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMProfileManager2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMProfileManager2_CreateEmptyProfile(This,dwVersion,ppProfile)	\
    (This)->lpVtbl -> CreateEmptyProfile(This,dwVersion,ppProfile)

#define IWMProfileManager2_LoadProfileByID(This,guidProfile,ppProfile)	\
    (This)->lpVtbl -> LoadProfileByID(This,guidProfile,ppProfile)

#define IWMProfileManager2_LoadProfileByData(This,pwszProfile,ppProfile)	\
    (This)->lpVtbl -> LoadProfileByData(This,pwszProfile,ppProfile)

#define IWMProfileManager2_SaveProfile(This,pIWMProfile,pwszProfile,pdwLength)	\
    (This)->lpVtbl -> SaveProfile(This,pIWMProfile,pwszProfile,pdwLength)

#define IWMProfileManager2_GetSystemProfileCount(This,pcProfiles)	\
    (This)->lpVtbl -> GetSystemProfileCount(This,pcProfiles)

#define IWMProfileManager2_LoadSystemProfile(This,dwProfileIndex,ppProfile)	\
    (This)->lpVtbl -> LoadSystemProfile(This,dwProfileIndex,ppProfile)


#define IWMProfileManager2_GetSystemProfileVersion(This,pdwVersion)	\
    (This)->lpVtbl -> GetSystemProfileVersion(This,pdwVersion)

#define IWMProfileManager2_SetSystemProfileVersion(This,dwVersion)	\
    (This)->lpVtbl -> SetSystemProfileVersion(This,dwVersion)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMProfileManager2_GetSystemProfileVersion_Proxy( 
    IWMProfileManager2 __RPC_FAR * This,
    WMT_VERSION __RPC_FAR *pdwVersion);


void __RPC_STUB IWMProfileManager2_GetSystemProfileVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfileManager2_SetSystemProfileVersion_Proxy( 
    IWMProfileManager2 __RPC_FAR * This,
    WMT_VERSION dwVersion);


void __RPC_STUB IWMProfileManager2_SetSystemProfileVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMProfileManager2_INTERFACE_DEFINED__ */


#ifndef __IWMProfile_INTERFACE_DEFINED__
#define __IWMProfile_INTERFACE_DEFINED__

/* interface IWMProfile */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMProfile;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BDB-2B2B-11d3-B36B-00C04F6108FF")
    IWMProfile : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetVersion( 
            /* [out] */ WMT_VERSION __RPC_FAR *pdwVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ DWORD __RPC_FAR *pcchName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetName( 
            /* [in] */ const WCHAR __RPC_FAR *pwszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescription( 
            /* [out] */ WCHAR __RPC_FAR *pwszDescription,
            /* [out][in] */ DWORD __RPC_FAR *pcchName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDescription( 
            /* [in] */ const WCHAR __RPC_FAR *pwszDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamCount( 
            /* [out] */ DWORD __RPC_FAR *pcStreams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStream( 
            /* [in] */ DWORD dwStreamIndex,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamByNumber( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveStream( 
            /* [in] */ IWMStreamConfig __RPC_FAR *pConfig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveStreamByNumber( 
            /* [in] */ WORD wStreamNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddStream( 
            /* [in] */ IWMStreamConfig __RPC_FAR *pConfig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReconfigStream( 
            /* [in] */ IWMStreamConfig __RPC_FAR *pConfig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateNewStream( 
            /* [in] */ REFGUID guidStreamType,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMutualExclusionCount( 
            /* [out] */ DWORD __RPC_FAR *pcME) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMutualExclusion( 
            /* [in] */ DWORD dwMEIndex,
            /* [out] */ IWMMutualExclusion __RPC_FAR *__RPC_FAR *ppME) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveMutualExclusion( 
            /* [in] */ IWMMutualExclusion __RPC_FAR *pME) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddMutualExclusion( 
            /* [in] */ IWMMutualExclusion __RPC_FAR *pME) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateNewMutualExclusion( 
            /* [out] */ IWMMutualExclusion __RPC_FAR *__RPC_FAR *ppME) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMProfileVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMProfile __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMProfile __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVersion )( 
            IWMProfile __RPC_FAR * This,
            /* [out] */ WMT_VERSION __RPC_FAR *pdwVersion);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IWMProfile __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ DWORD __RPC_FAR *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetName )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDescription )( 
            IWMProfile __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszDescription,
            /* [out][in] */ DWORD __RPC_FAR *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDescription )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszDescription);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamCount )( 
            IWMProfile __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcStreams);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStream )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ DWORD dwStreamIndex,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamByNumber )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveStream )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ IWMStreamConfig __RPC_FAR *pConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveStreamByNumber )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddStream )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ IWMStreamConfig __RPC_FAR *pConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReconfigStream )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ IWMStreamConfig __RPC_FAR *pConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateNewStream )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ REFGUID guidStreamType,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMutualExclusionCount )( 
            IWMProfile __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMutualExclusion )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ DWORD dwMEIndex,
            /* [out] */ IWMMutualExclusion __RPC_FAR *__RPC_FAR *ppME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveMutualExclusion )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ IWMMutualExclusion __RPC_FAR *pME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddMutualExclusion )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ IWMMutualExclusion __RPC_FAR *pME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateNewMutualExclusion )( 
            IWMProfile __RPC_FAR * This,
            /* [out] */ IWMMutualExclusion __RPC_FAR *__RPC_FAR *ppME);
        
        END_INTERFACE
    } IWMProfileVtbl;

    interface IWMProfile
    {
        CONST_VTBL struct IWMProfileVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMProfile_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMProfile_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMProfile_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMProfile_GetVersion(This,pdwVersion)	\
    (This)->lpVtbl -> GetVersion(This,pdwVersion)

#define IWMProfile_GetName(This,pwszName,pcchName)	\
    (This)->lpVtbl -> GetName(This,pwszName,pcchName)

#define IWMProfile_SetName(This,pwszName)	\
    (This)->lpVtbl -> SetName(This,pwszName)

#define IWMProfile_GetDescription(This,pwszDescription,pcchName)	\
    (This)->lpVtbl -> GetDescription(This,pwszDescription,pcchName)

#define IWMProfile_SetDescription(This,pwszDescription)	\
    (This)->lpVtbl -> SetDescription(This,pwszDescription)

#define IWMProfile_GetStreamCount(This,pcStreams)	\
    (This)->lpVtbl -> GetStreamCount(This,pcStreams)

#define IWMProfile_GetStream(This,dwStreamIndex,ppConfig)	\
    (This)->lpVtbl -> GetStream(This,dwStreamIndex,ppConfig)

#define IWMProfile_GetStreamByNumber(This,wStreamNum,ppConfig)	\
    (This)->lpVtbl -> GetStreamByNumber(This,wStreamNum,ppConfig)

#define IWMProfile_RemoveStream(This,pConfig)	\
    (This)->lpVtbl -> RemoveStream(This,pConfig)

#define IWMProfile_RemoveStreamByNumber(This,wStreamNum)	\
    (This)->lpVtbl -> RemoveStreamByNumber(This,wStreamNum)

#define IWMProfile_AddStream(This,pConfig)	\
    (This)->lpVtbl -> AddStream(This,pConfig)

#define IWMProfile_ReconfigStream(This,pConfig)	\
    (This)->lpVtbl -> ReconfigStream(This,pConfig)

#define IWMProfile_CreateNewStream(This,guidStreamType,ppConfig)	\
    (This)->lpVtbl -> CreateNewStream(This,guidStreamType,ppConfig)

#define IWMProfile_GetMutualExclusionCount(This,pcME)	\
    (This)->lpVtbl -> GetMutualExclusionCount(This,pcME)

#define IWMProfile_GetMutualExclusion(This,dwMEIndex,ppME)	\
    (This)->lpVtbl -> GetMutualExclusion(This,dwMEIndex,ppME)

#define IWMProfile_RemoveMutualExclusion(This,pME)	\
    (This)->lpVtbl -> RemoveMutualExclusion(This,pME)

#define IWMProfile_AddMutualExclusion(This,pME)	\
    (This)->lpVtbl -> AddMutualExclusion(This,pME)

#define IWMProfile_CreateNewMutualExclusion(This,ppME)	\
    (This)->lpVtbl -> CreateNewMutualExclusion(This,ppME)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMProfile_GetVersion_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [out] */ WMT_VERSION __RPC_FAR *pdwVersion);


void __RPC_STUB IWMProfile_GetVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_GetName_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszName,
    /* [out][in] */ DWORD __RPC_FAR *pcchName);


void __RPC_STUB IWMProfile_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_SetName_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwszName);


void __RPC_STUB IWMProfile_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_GetDescription_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszDescription,
    /* [out][in] */ DWORD __RPC_FAR *pcchName);


void __RPC_STUB IWMProfile_GetDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_SetDescription_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwszDescription);


void __RPC_STUB IWMProfile_SetDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_GetStreamCount_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcStreams);


void __RPC_STUB IWMProfile_GetStreamCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_GetStream_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ DWORD dwStreamIndex,
    /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig);


void __RPC_STUB IWMProfile_GetStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_GetStreamByNumber_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig);


void __RPC_STUB IWMProfile_GetStreamByNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_RemoveStream_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ IWMStreamConfig __RPC_FAR *pConfig);


void __RPC_STUB IWMProfile_RemoveStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_RemoveStreamByNumber_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ WORD wStreamNum);


void __RPC_STUB IWMProfile_RemoveStreamByNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_AddStream_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ IWMStreamConfig __RPC_FAR *pConfig);


void __RPC_STUB IWMProfile_AddStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_ReconfigStream_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ IWMStreamConfig __RPC_FAR *pConfig);


void __RPC_STUB IWMProfile_ReconfigStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_CreateNewStream_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ REFGUID guidStreamType,
    /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig);


void __RPC_STUB IWMProfile_CreateNewStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_GetMutualExclusionCount_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcME);


void __RPC_STUB IWMProfile_GetMutualExclusionCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_GetMutualExclusion_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ DWORD dwMEIndex,
    /* [out] */ IWMMutualExclusion __RPC_FAR *__RPC_FAR *ppME);


void __RPC_STUB IWMProfile_GetMutualExclusion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_RemoveMutualExclusion_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ IWMMutualExclusion __RPC_FAR *pME);


void __RPC_STUB IWMProfile_RemoveMutualExclusion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_AddMutualExclusion_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ IWMMutualExclusion __RPC_FAR *pME);


void __RPC_STUB IWMProfile_AddMutualExclusion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_CreateNewMutualExclusion_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [out] */ IWMMutualExclusion __RPC_FAR *__RPC_FAR *ppME);


void __RPC_STUB IWMProfile_CreateNewMutualExclusion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMProfile_INTERFACE_DEFINED__ */


#ifndef __IWMProfile2_INTERFACE_DEFINED__
#define __IWMProfile2_INTERFACE_DEFINED__

/* interface IWMProfile2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMProfile2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("07E72D33-D94E-4be7-8843-60AE5FF7E5F5")
    IWMProfile2 : public IWMProfile
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProfileID( 
            /* [out] */ GUID __RPC_FAR *pguidID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMProfile2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMProfile2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMProfile2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVersion )( 
            IWMProfile2 __RPC_FAR * This,
            /* [out] */ WMT_VERSION __RPC_FAR *pdwVersion);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IWMProfile2 __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ DWORD __RPC_FAR *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetName )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDescription )( 
            IWMProfile2 __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszDescription,
            /* [out][in] */ DWORD __RPC_FAR *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDescription )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszDescription);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamCount )( 
            IWMProfile2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcStreams);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStream )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ DWORD dwStreamIndex,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamByNumber )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveStream )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ IWMStreamConfig __RPC_FAR *pConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveStreamByNumber )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddStream )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ IWMStreamConfig __RPC_FAR *pConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReconfigStream )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ IWMStreamConfig __RPC_FAR *pConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateNewStream )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ REFGUID guidStreamType,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMutualExclusionCount )( 
            IWMProfile2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMutualExclusion )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ DWORD dwMEIndex,
            /* [out] */ IWMMutualExclusion __RPC_FAR *__RPC_FAR *ppME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveMutualExclusion )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ IWMMutualExclusion __RPC_FAR *pME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddMutualExclusion )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ IWMMutualExclusion __RPC_FAR *pME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateNewMutualExclusion )( 
            IWMProfile2 __RPC_FAR * This,
            /* [out] */ IWMMutualExclusion __RPC_FAR *__RPC_FAR *ppME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProfileID )( 
            IWMProfile2 __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pguidID);
        
        END_INTERFACE
    } IWMProfile2Vtbl;

    interface IWMProfile2
    {
        CONST_VTBL struct IWMProfile2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMProfile2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMProfile2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMProfile2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMProfile2_GetVersion(This,pdwVersion)	\
    (This)->lpVtbl -> GetVersion(This,pdwVersion)

#define IWMProfile2_GetName(This,pwszName,pcchName)	\
    (This)->lpVtbl -> GetName(This,pwszName,pcchName)

#define IWMProfile2_SetName(This,pwszName)	\
    (This)->lpVtbl -> SetName(This,pwszName)

#define IWMProfile2_GetDescription(This,pwszDescription,pcchName)	\
    (This)->lpVtbl -> GetDescription(This,pwszDescription,pcchName)

#define IWMProfile2_SetDescription(This,pwszDescription)	\
    (This)->lpVtbl -> SetDescription(This,pwszDescription)

#define IWMProfile2_GetStreamCount(This,pcStreams)	\
    (This)->lpVtbl -> GetStreamCount(This,pcStreams)

#define IWMProfile2_GetStream(This,dwStreamIndex,ppConfig)	\
    (This)->lpVtbl -> GetStream(This,dwStreamIndex,ppConfig)

#define IWMProfile2_GetStreamByNumber(This,wStreamNum,ppConfig)	\
    (This)->lpVtbl -> GetStreamByNumber(This,wStreamNum,ppConfig)

#define IWMProfile2_RemoveStream(This,pConfig)	\
    (This)->lpVtbl -> RemoveStream(This,pConfig)

#define IWMProfile2_RemoveStreamByNumber(This,wStreamNum)	\
    (This)->lpVtbl -> RemoveStreamByNumber(This,wStreamNum)

#define IWMProfile2_AddStream(This,pConfig)	\
    (This)->lpVtbl -> AddStream(This,pConfig)

#define IWMProfile2_ReconfigStream(This,pConfig)	\
    (This)->lpVtbl -> ReconfigStream(This,pConfig)

#define IWMProfile2_CreateNewStream(This,guidStreamType,ppConfig)	\
    (This)->lpVtbl -> CreateNewStream(This,guidStreamType,ppConfig)

#define IWMProfile2_GetMutualExclusionCount(This,pcME)	\
    (This)->lpVtbl -> GetMutualExclusionCount(This,pcME)

#define IWMProfile2_GetMutualExclusion(This,dwMEIndex,ppME)	\
    (This)->lpVtbl -> GetMutualExclusion(This,dwMEIndex,ppME)

#define IWMProfile2_RemoveMutualExclusion(This,pME)	\
    (This)->lpVtbl -> RemoveMutualExclusion(This,pME)

#define IWMProfile2_AddMutualExclusion(This,pME)	\
    (This)->lpVtbl -> AddMutualExclusion(This,pME)

#define IWMProfile2_CreateNewMutualExclusion(This,ppME)	\
    (This)->lpVtbl -> CreateNewMutualExclusion(This,ppME)


#define IWMProfile2_GetProfileID(This,pguidID)	\
    (This)->lpVtbl -> GetProfileID(This,pguidID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMProfile2_GetProfileID_Proxy( 
    IWMProfile2 __RPC_FAR * This,
    /* [out] */ GUID __RPC_FAR *pguidID);


void __RPC_STUB IWMProfile2_GetProfileID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMProfile2_INTERFACE_DEFINED__ */


#ifndef __IWMStreamConfig_INTERFACE_DEFINED__
#define __IWMStreamConfig_INTERFACE_DEFINED__

/* interface IWMStreamConfig */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMStreamConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BDC-2B2B-11d3-B36B-00C04F6108FF")
    IWMStreamConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStreamType( 
            /* [out] */ GUID __RPC_FAR *pguidStreamType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamNumber( 
            /* [out] */ WORD __RPC_FAR *pwStreamNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStreamNumber( 
            /* [in] */ WORD wStreamNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamName( 
            /* [out] */ WCHAR __RPC_FAR *pwszStreamName,
            /* [out][in] */ WORD __RPC_FAR *pcchStreamName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStreamName( 
            /* [in] */ WCHAR __RPC_FAR *pwszStreamName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConnectionName( 
            /* [out] */ WCHAR __RPC_FAR *pwszInputName,
            /* [out][in] */ WORD __RPC_FAR *pcchInputName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConnectionName( 
            /* [in] */ WCHAR __RPC_FAR *pwszInputName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBitrate( 
            /* [out] */ DWORD __RPC_FAR *pdwBitrate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBitrate( 
            /* [in] */ DWORD pdwBitrate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBufferWindow( 
            /* [out] */ DWORD __RPC_FAR *pmsBufferWindow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBufferWindow( 
            /* [in] */ DWORD msBufferWindow) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMStreamConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMStreamConfig __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMStreamConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamType )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pguidStreamType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamNumber )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pwStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStreamNumber )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamName )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszStreamName,
            /* [out][in] */ WORD __RPC_FAR *pcchStreamName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStreamName )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [in] */ WCHAR __RPC_FAR *pwszStreamName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConnectionName )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszInputName,
            /* [out][in] */ WORD __RPC_FAR *pcchInputName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetConnectionName )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [in] */ WCHAR __RPC_FAR *pwszInputName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBitrate )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwBitrate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBitrate )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [in] */ DWORD pdwBitrate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferWindow )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pmsBufferWindow);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBufferWindow )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [in] */ DWORD msBufferWindow);
        
        END_INTERFACE
    } IWMStreamConfigVtbl;

    interface IWMStreamConfig
    {
        CONST_VTBL struct IWMStreamConfigVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMStreamConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMStreamConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMStreamConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMStreamConfig_GetStreamType(This,pguidStreamType)	\
    (This)->lpVtbl -> GetStreamType(This,pguidStreamType)

#define IWMStreamConfig_GetStreamNumber(This,pwStreamNum)	\
    (This)->lpVtbl -> GetStreamNumber(This,pwStreamNum)

#define IWMStreamConfig_SetStreamNumber(This,wStreamNum)	\
    (This)->lpVtbl -> SetStreamNumber(This,wStreamNum)

#define IWMStreamConfig_GetStreamName(This,pwszStreamName,pcchStreamName)	\
    (This)->lpVtbl -> GetStreamName(This,pwszStreamName,pcchStreamName)

#define IWMStreamConfig_SetStreamName(This,pwszStreamName)	\
    (This)->lpVtbl -> SetStreamName(This,pwszStreamName)

#define IWMStreamConfig_GetConnectionName(This,pwszInputName,pcchInputName)	\
    (This)->lpVtbl -> GetConnectionName(This,pwszInputName,pcchInputName)

#define IWMStreamConfig_SetConnectionName(This,pwszInputName)	\
    (This)->lpVtbl -> SetConnectionName(This,pwszInputName)

#define IWMStreamConfig_GetBitrate(This,pdwBitrate)	\
    (This)->lpVtbl -> GetBitrate(This,pdwBitrate)

#define IWMStreamConfig_SetBitrate(This,pdwBitrate)	\
    (This)->lpVtbl -> SetBitrate(This,pdwBitrate)

#define IWMStreamConfig_GetBufferWindow(This,pmsBufferWindow)	\
    (This)->lpVtbl -> GetBufferWindow(This,pmsBufferWindow)

#define IWMStreamConfig_SetBufferWindow(This,msBufferWindow)	\
    (This)->lpVtbl -> SetBufferWindow(This,msBufferWindow)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMStreamConfig_GetStreamType_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [out] */ GUID __RPC_FAR *pguidStreamType);


void __RPC_STUB IWMStreamConfig_GetStreamType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_GetStreamNumber_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [out] */ WORD __RPC_FAR *pwStreamNum);


void __RPC_STUB IWMStreamConfig_GetStreamNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_SetStreamNumber_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [in] */ WORD wStreamNum);


void __RPC_STUB IWMStreamConfig_SetStreamNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_GetStreamName_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszStreamName,
    /* [out][in] */ WORD __RPC_FAR *pcchStreamName);


void __RPC_STUB IWMStreamConfig_GetStreamName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_SetStreamName_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [in] */ WCHAR __RPC_FAR *pwszStreamName);


void __RPC_STUB IWMStreamConfig_SetStreamName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_GetConnectionName_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszInputName,
    /* [out][in] */ WORD __RPC_FAR *pcchInputName);


void __RPC_STUB IWMStreamConfig_GetConnectionName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_SetConnectionName_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [in] */ WCHAR __RPC_FAR *pwszInputName);


void __RPC_STUB IWMStreamConfig_SetConnectionName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_GetBitrate_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwBitrate);


void __RPC_STUB IWMStreamConfig_GetBitrate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_SetBitrate_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [in] */ DWORD pdwBitrate);


void __RPC_STUB IWMStreamConfig_SetBitrate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_GetBufferWindow_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pmsBufferWindow);


void __RPC_STUB IWMStreamConfig_GetBufferWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_SetBufferWindow_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [in] */ DWORD msBufferWindow);


void __RPC_STUB IWMStreamConfig_SetBufferWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMStreamConfig_INTERFACE_DEFINED__ */


#ifndef __IWMPacketSize_INTERFACE_DEFINED__
#define __IWMPacketSize_INTERFACE_DEFINED__

/* interface IWMPacketSize */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMPacketSize;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CDFB97AB-188F-40b3-B643-5B7903975C59")
    IWMPacketSize : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMaxPacketSize( 
            /* [out] */ DWORD __RPC_FAR *pdwMaxPacketSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMaxPacketSize( 
            /* [in] */ DWORD dwMaxPacketSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPacketSizeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPacketSize __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPacketSize __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPacketSize __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxPacketSize )( 
            IWMPacketSize __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwMaxPacketSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMaxPacketSize )( 
            IWMPacketSize __RPC_FAR * This,
            /* [in] */ DWORD dwMaxPacketSize);
        
        END_INTERFACE
    } IWMPacketSizeVtbl;

    interface IWMPacketSize
    {
        CONST_VTBL struct IWMPacketSizeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPacketSize_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPacketSize_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPacketSize_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPacketSize_GetMaxPacketSize(This,pdwMaxPacketSize)	\
    (This)->lpVtbl -> GetMaxPacketSize(This,pdwMaxPacketSize)

#define IWMPacketSize_SetMaxPacketSize(This,dwMaxPacketSize)	\
    (This)->lpVtbl -> SetMaxPacketSize(This,dwMaxPacketSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMPacketSize_GetMaxPacketSize_Proxy( 
    IWMPacketSize __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwMaxPacketSize);


void __RPC_STUB IWMPacketSize_GetMaxPacketSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPacketSize_SetMaxPacketSize_Proxy( 
    IWMPacketSize __RPC_FAR * This,
    /* [in] */ DWORD dwMaxPacketSize);


void __RPC_STUB IWMPacketSize_SetMaxPacketSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPacketSize_INTERFACE_DEFINED__ */


#ifndef __IWMStreamList_INTERFACE_DEFINED__
#define __IWMStreamList_INTERFACE_DEFINED__

/* interface IWMStreamList */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMStreamList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BDD-2B2B-11d3-B36B-00C04F6108FF")
    IWMStreamList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStreams( 
            /* [out] */ WORD __RPC_FAR *pwStreamNumArray,
            /* [out][in] */ WORD __RPC_FAR *pcStreams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddStream( 
            /* [in] */ WORD wStreamNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveStream( 
            /* [in] */ WORD wStreamNum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMStreamListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMStreamList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMStreamList __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMStreamList __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreams )( 
            IWMStreamList __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pwStreamNumArray,
            /* [out][in] */ WORD __RPC_FAR *pcStreams);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddStream )( 
            IWMStreamList __RPC_FAR * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveStream )( 
            IWMStreamList __RPC_FAR * This,
            /* [in] */ WORD wStreamNum);
        
        END_INTERFACE
    } IWMStreamListVtbl;

    interface IWMStreamList
    {
        CONST_VTBL struct IWMStreamListVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMStreamList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMStreamList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMStreamList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMStreamList_GetStreams(This,pwStreamNumArray,pcStreams)	\
    (This)->lpVtbl -> GetStreams(This,pwStreamNumArray,pcStreams)

#define IWMStreamList_AddStream(This,wStreamNum)	\
    (This)->lpVtbl -> AddStream(This,wStreamNum)

#define IWMStreamList_RemoveStream(This,wStreamNum)	\
    (This)->lpVtbl -> RemoveStream(This,wStreamNum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMStreamList_GetStreams_Proxy( 
    IWMStreamList __RPC_FAR * This,
    /* [out] */ WORD __RPC_FAR *pwStreamNumArray,
    /* [out][in] */ WORD __RPC_FAR *pcStreams);


void __RPC_STUB IWMStreamList_GetStreams_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamList_AddStream_Proxy( 
    IWMStreamList __RPC_FAR * This,
    /* [in] */ WORD wStreamNum);


void __RPC_STUB IWMStreamList_AddStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamList_RemoveStream_Proxy( 
    IWMStreamList __RPC_FAR * This,
    /* [in] */ WORD wStreamNum);


void __RPC_STUB IWMStreamList_RemoveStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMStreamList_INTERFACE_DEFINED__ */


#ifndef __IWMMutualExclusion_INTERFACE_DEFINED__
#define __IWMMutualExclusion_INTERFACE_DEFINED__

/* interface IWMMutualExclusion */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMMutualExclusion;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BDE-2B2B-11d3-B36B-00C04F6108FF")
    IWMMutualExclusion : public IWMStreamList
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ GUID __RPC_FAR *pguidType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetType( 
            /* [in] */ REFGUID guidType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMMutualExclusionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMMutualExclusion __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMMutualExclusion __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMMutualExclusion __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreams )( 
            IWMMutualExclusion __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pwStreamNumArray,
            /* [out][in] */ WORD __RPC_FAR *pcStreams);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddStream )( 
            IWMMutualExclusion __RPC_FAR * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveStream )( 
            IWMMutualExclusion __RPC_FAR * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IWMMutualExclusion __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pguidType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetType )( 
            IWMMutualExclusion __RPC_FAR * This,
            /* [in] */ REFGUID guidType);
        
        END_INTERFACE
    } IWMMutualExclusionVtbl;

    interface IWMMutualExclusion
    {
        CONST_VTBL struct IWMMutualExclusionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMMutualExclusion_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMMutualExclusion_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMMutualExclusion_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMMutualExclusion_GetStreams(This,pwStreamNumArray,pcStreams)	\
    (This)->lpVtbl -> GetStreams(This,pwStreamNumArray,pcStreams)

#define IWMMutualExclusion_AddStream(This,wStreamNum)	\
    (This)->lpVtbl -> AddStream(This,wStreamNum)

#define IWMMutualExclusion_RemoveStream(This,wStreamNum)	\
    (This)->lpVtbl -> RemoveStream(This,wStreamNum)


#define IWMMutualExclusion_GetType(This,pguidType)	\
    (This)->lpVtbl -> GetType(This,pguidType)

#define IWMMutualExclusion_SetType(This,guidType)	\
    (This)->lpVtbl -> SetType(This,guidType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMMutualExclusion_GetType_Proxy( 
    IWMMutualExclusion __RPC_FAR * This,
    /* [out] */ GUID __RPC_FAR *pguidType);


void __RPC_STUB IWMMutualExclusion_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMMutualExclusion_SetType_Proxy( 
    IWMMutualExclusion __RPC_FAR * This,
    /* [in] */ REFGUID guidType);


void __RPC_STUB IWMMutualExclusion_SetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMMutualExclusion_INTERFACE_DEFINED__ */


#ifndef __IWMWriterAdvanced_INTERFACE_DEFINED__
#define __IWMWriterAdvanced_INTERFACE_DEFINED__

/* interface IWMWriterAdvanced */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterAdvanced;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BE3-2B2B-11d3-B36B-00C04F6108FF")
    IWMWriterAdvanced : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSinkCount( 
            /* [out] */ DWORD __RPC_FAR *pcSinks) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSink( 
            /* [in] */ DWORD dwSinkNum,
            /* [out] */ IWMWriterSink __RPC_FAR *__RPC_FAR *ppSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddSink( 
            /* [in] */ IWMWriterSink __RPC_FAR *pSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveSink( 
            /* [in] */ IWMWriterSink __RPC_FAR *pSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteStreamSample( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ DWORD msSampleSendTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLiveSource( 
            BOOL fIsLiveSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsRealTime( 
            /* [out] */ BOOL __RPC_FAR *pfRealTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWriterTime( 
            /* [out] */ QWORD __RPC_FAR *pcnsCurrentTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatistics( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ WM_WRITER_STATISTICS __RPC_FAR *pStats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSyncTolerance( 
            /* [in] */ DWORD msWindow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSyncTolerance( 
            /* [out] */ DWORD __RPC_FAR *pmsWindow) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterAdvancedVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMWriterAdvanced __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMWriterAdvanced __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSinkCount )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcSinks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSink )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [in] */ DWORD dwSinkNum,
            /* [out] */ IWMWriterSink __RPC_FAR *__RPC_FAR *ppSink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddSink )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [in] */ IWMWriterSink __RPC_FAR *pSink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveSink )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [in] */ IWMWriterSink __RPC_FAR *pSink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteStreamSample )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ DWORD msSampleSendTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLiveSource )( 
            IWMWriterAdvanced __RPC_FAR * This,
            BOOL fIsLiveSource);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsRealTime )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfRealTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWriterTime )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [out] */ QWORD __RPC_FAR *pcnsCurrentTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatistics )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WM_WRITER_STATISTICS __RPC_FAR *pStats);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSyncTolerance )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [in] */ DWORD msWindow);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSyncTolerance )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pmsWindow);
        
        END_INTERFACE
    } IWMWriterAdvancedVtbl;

    interface IWMWriterAdvanced
    {
        CONST_VTBL struct IWMWriterAdvancedVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterAdvanced_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterAdvanced_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterAdvanced_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterAdvanced_GetSinkCount(This,pcSinks)	\
    (This)->lpVtbl -> GetSinkCount(This,pcSinks)

#define IWMWriterAdvanced_GetSink(This,dwSinkNum,ppSink)	\
    (This)->lpVtbl -> GetSink(This,dwSinkNum,ppSink)

#define IWMWriterAdvanced_AddSink(This,pSink)	\
    (This)->lpVtbl -> AddSink(This,pSink)

#define IWMWriterAdvanced_RemoveSink(This,pSink)	\
    (This)->lpVtbl -> RemoveSink(This,pSink)

#define IWMWriterAdvanced_WriteStreamSample(This,wStreamNum,cnsSampleTime,msSampleSendTime,cnsSampleDuration,dwFlags,pSample)	\
    (This)->lpVtbl -> WriteStreamSample(This,wStreamNum,cnsSampleTime,msSampleSendTime,cnsSampleDuration,dwFlags,pSample)

#define IWMWriterAdvanced_SetLiveSource(This,fIsLiveSource)	\
    (This)->lpVtbl -> SetLiveSource(This,fIsLiveSource)

#define IWMWriterAdvanced_IsRealTime(This,pfRealTime)	\
    (This)->lpVtbl -> IsRealTime(This,pfRealTime)

#define IWMWriterAdvanced_GetWriterTime(This,pcnsCurrentTime)	\
    (This)->lpVtbl -> GetWriterTime(This,pcnsCurrentTime)

#define IWMWriterAdvanced_GetStatistics(This,wStreamNum,pStats)	\
    (This)->lpVtbl -> GetStatistics(This,wStreamNum,pStats)

#define IWMWriterAdvanced_SetSyncTolerance(This,msWindow)	\
    (This)->lpVtbl -> SetSyncTolerance(This,msWindow)

#define IWMWriterAdvanced_GetSyncTolerance(This,pmsWindow)	\
    (This)->lpVtbl -> GetSyncTolerance(This,pmsWindow)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_GetSinkCount_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcSinks);


void __RPC_STUB IWMWriterAdvanced_GetSinkCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_GetSink_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    /* [in] */ DWORD dwSinkNum,
    /* [out] */ IWMWriterSink __RPC_FAR *__RPC_FAR *ppSink);


void __RPC_STUB IWMWriterAdvanced_GetSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_AddSink_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    /* [in] */ IWMWriterSink __RPC_FAR *pSink);


void __RPC_STUB IWMWriterAdvanced_AddSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_RemoveSink_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    /* [in] */ IWMWriterSink __RPC_FAR *pSink);


void __RPC_STUB IWMWriterAdvanced_RemoveSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_WriteStreamSample_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ QWORD cnsSampleTime,
    /* [in] */ DWORD msSampleSendTime,
    /* [in] */ QWORD cnsSampleDuration,
    /* [in] */ DWORD dwFlags,
    /* [in] */ INSSBuffer __RPC_FAR *pSample);


void __RPC_STUB IWMWriterAdvanced_WriteStreamSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_SetLiveSource_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    BOOL fIsLiveSource);


void __RPC_STUB IWMWriterAdvanced_SetLiveSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_IsRealTime_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfRealTime);


void __RPC_STUB IWMWriterAdvanced_IsRealTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_GetWriterTime_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    /* [out] */ QWORD __RPC_FAR *pcnsCurrentTime);


void __RPC_STUB IWMWriterAdvanced_GetWriterTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_GetStatistics_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [out] */ WM_WRITER_STATISTICS __RPC_FAR *pStats);


void __RPC_STUB IWMWriterAdvanced_GetStatistics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_SetSyncTolerance_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    /* [in] */ DWORD msWindow);


void __RPC_STUB IWMWriterAdvanced_SetSyncTolerance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_GetSyncTolerance_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pmsWindow);


void __RPC_STUB IWMWriterAdvanced_GetSyncTolerance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterAdvanced_INTERFACE_DEFINED__ */


#ifndef __IWMWriterAdvanced2_INTERFACE_DEFINED__
#define __IWMWriterAdvanced2_INTERFACE_DEFINED__

/* interface IWMWriterAdvanced2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterAdvanced2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("962dc1ec-c046-4db8-9cc7-26ceae500817")
    IWMWriterAdvanced2 : public IWMWriterAdvanced
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetInputSetting( 
            /* [in] */ DWORD dwInputNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInputSetting( 
            /* [in] */ DWORD dwInputNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterAdvanced2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMWriterAdvanced2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMWriterAdvanced2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSinkCount )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcSinks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSink )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [in] */ DWORD dwSinkNum,
            /* [out] */ IWMWriterSink __RPC_FAR *__RPC_FAR *ppSink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddSink )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [in] */ IWMWriterSink __RPC_FAR *pSink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveSink )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [in] */ IWMWriterSink __RPC_FAR *pSink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteStreamSample )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ DWORD msSampleSendTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLiveSource )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            BOOL fIsLiveSource);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsRealTime )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfRealTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWriterTime )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [out] */ QWORD __RPC_FAR *pcnsCurrentTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatistics )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WM_WRITER_STATISTICS __RPC_FAR *pStats);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSyncTolerance )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [in] */ DWORD msWindow);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSyncTolerance )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pmsWindow);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInputSetting )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [in] */ DWORD dwInputNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetInputSetting )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [in] */ DWORD dwInputNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength);
        
        END_INTERFACE
    } IWMWriterAdvanced2Vtbl;

    interface IWMWriterAdvanced2
    {
        CONST_VTBL struct IWMWriterAdvanced2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterAdvanced2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterAdvanced2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterAdvanced2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterAdvanced2_GetSinkCount(This,pcSinks)	\
    (This)->lpVtbl -> GetSinkCount(This,pcSinks)

#define IWMWriterAdvanced2_GetSink(This,dwSinkNum,ppSink)	\
    (This)->lpVtbl -> GetSink(This,dwSinkNum,ppSink)

#define IWMWriterAdvanced2_AddSink(This,pSink)	\
    (This)->lpVtbl -> AddSink(This,pSink)

#define IWMWriterAdvanced2_RemoveSink(This,pSink)	\
    (This)->lpVtbl -> RemoveSink(This,pSink)

#define IWMWriterAdvanced2_WriteStreamSample(This,wStreamNum,cnsSampleTime,msSampleSendTime,cnsSampleDuration,dwFlags,pSample)	\
    (This)->lpVtbl -> WriteStreamSample(This,wStreamNum,cnsSampleTime,msSampleSendTime,cnsSampleDuration,dwFlags,pSample)

#define IWMWriterAdvanced2_SetLiveSource(This,fIsLiveSource)	\
    (This)->lpVtbl -> SetLiveSource(This,fIsLiveSource)

#define IWMWriterAdvanced2_IsRealTime(This,pfRealTime)	\
    (This)->lpVtbl -> IsRealTime(This,pfRealTime)

#define IWMWriterAdvanced2_GetWriterTime(This,pcnsCurrentTime)	\
    (This)->lpVtbl -> GetWriterTime(This,pcnsCurrentTime)

#define IWMWriterAdvanced2_GetStatistics(This,wStreamNum,pStats)	\
    (This)->lpVtbl -> GetStatistics(This,wStreamNum,pStats)

#define IWMWriterAdvanced2_SetSyncTolerance(This,msWindow)	\
    (This)->lpVtbl -> SetSyncTolerance(This,msWindow)

#define IWMWriterAdvanced2_GetSyncTolerance(This,pmsWindow)	\
    (This)->lpVtbl -> GetSyncTolerance(This,pmsWindow)


#define IWMWriterAdvanced2_GetInputSetting(This,dwInputNum,pszName,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetInputSetting(This,dwInputNum,pszName,pType,pValue,pcbLength)

#define IWMWriterAdvanced2_SetInputSetting(This,dwInputNum,pszName,Type,pValue,cbLength)	\
    (This)->lpVtbl -> SetInputSetting(This,dwInputNum,pszName,Type,pValue,cbLength)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterAdvanced2_GetInputSetting_Proxy( 
    IWMWriterAdvanced2 __RPC_FAR * This,
    /* [in] */ DWORD dwInputNum,
    /* [in] */ LPCWSTR pszName,
    /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
    /* [out] */ BYTE __RPC_FAR *pValue,
    /* [out][in] */ WORD __RPC_FAR *pcbLength);


void __RPC_STUB IWMWriterAdvanced2_GetInputSetting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced2_SetInputSetting_Proxy( 
    IWMWriterAdvanced2 __RPC_FAR * This,
    /* [in] */ DWORD dwInputNum,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ WMT_ATTR_DATATYPE Type,
    /* [in] */ const BYTE __RPC_FAR *pValue,
    /* [in] */ WORD cbLength);


void __RPC_STUB IWMWriterAdvanced2_SetInputSetting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterAdvanced2_INTERFACE_DEFINED__ */


#ifndef __IWMWriterPostViewCallback_INTERFACE_DEFINED__
#define __IWMWriterPostViewCallback_INTERFACE_DEFINED__

/* interface IWMWriterPostViewCallback */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterPostViewCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D9D6549D-A193-4f24-B308-03123D9B7F8D")
    IWMWriterPostViewCallback : public IWMStatusCallback
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnPostViewSample( 
            /* [in] */ WORD wStreamNumber,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateForPostView( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterPostViewCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMWriterPostViewCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMWriterPostViewCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMWriterPostViewCallback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStatus )( 
            IWMWriterPostViewCallback __RPC_FAR * This,
            /* [in] */ WMT_STATUS Status,
            /* [in] */ HRESULT hr,
            /* [in] */ WMT_ATTR_DATATYPE dwType,
            /* [in] */ BYTE __RPC_FAR *pValue,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnPostViewSample )( 
            IWMWriterPostViewCallback __RPC_FAR * This,
            /* [in] */ WORD wStreamNumber,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateForPostView )( 
            IWMWriterPostViewCallback __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ void __RPC_FAR *pvContext);
        
        END_INTERFACE
    } IWMWriterPostViewCallbackVtbl;

    interface IWMWriterPostViewCallback
    {
        CONST_VTBL struct IWMWriterPostViewCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterPostViewCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterPostViewCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterPostViewCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterPostViewCallback_OnStatus(This,Status,hr,dwType,pValue,pvContext)	\
    (This)->lpVtbl -> OnStatus(This,Status,hr,dwType,pValue,pvContext)


#define IWMWriterPostViewCallback_OnPostViewSample(This,wStreamNumber,cnsSampleTime,cnsSampleDuration,dwFlags,pSample,pvContext)	\
    (This)->lpVtbl -> OnPostViewSample(This,wStreamNumber,cnsSampleTime,cnsSampleDuration,dwFlags,pSample,pvContext)

#define IWMWriterPostViewCallback_AllocateForPostView(This,wStreamNum,cbBuffer,ppBuffer,pvContext)	\
    (This)->lpVtbl -> AllocateForPostView(This,wStreamNum,cbBuffer,ppBuffer,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterPostViewCallback_OnPostViewSample_Proxy( 
    IWMWriterPostViewCallback __RPC_FAR * This,
    /* [in] */ WORD wStreamNumber,
    /* [in] */ QWORD cnsSampleTime,
    /* [in] */ QWORD cnsSampleDuration,
    /* [in] */ DWORD dwFlags,
    /* [in] */ INSSBuffer __RPC_FAR *pSample,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMWriterPostViewCallback_OnPostViewSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostViewCallback_AllocateForPostView_Proxy( 
    IWMWriterPostViewCallback __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ DWORD cbBuffer,
    /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMWriterPostViewCallback_AllocateForPostView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterPostViewCallback_INTERFACE_DEFINED__ */


#ifndef __IWMWriterPostView_INTERFACE_DEFINED__
#define __IWMWriterPostView_INTERFACE_DEFINED__

/* interface IWMWriterPostView */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterPostView;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("81E20CE4-75EF-491a-8004-FC53C45BDC3E")
    IWMWriterPostView : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetPostViewCallback( 
            IWMWriterPostViewCallback __RPC_FAR *pCallback,
            void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetReceivePostViewSamples( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ BOOL fReceivePostViewSamples) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReceivePostViewSamples( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ BOOL __RPC_FAR *pfReceivePostViewSamples) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPostViewProps( 
            /* [in] */ WORD wStreamNumber,
            /* [out] */ IWMMediaProps __RPC_FAR *__RPC_FAR *ppOutput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPostViewProps( 
            /* [in] */ WORD wStreamNumber,
            /* [in] */ IWMMediaProps __RPC_FAR *pOutput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPostViewFormatCount( 
            /* [in] */ WORD wStreamNumber,
            /* [out] */ DWORD __RPC_FAR *pcFormats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPostViewFormat( 
            /* [in] */ WORD wStreamNumber,
            /* [in] */ DWORD dwFormatNumber,
            /* [out] */ IWMMediaProps __RPC_FAR *__RPC_FAR *ppProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAllocateForPostView( 
            /* [in] */ WORD wStreamNumber,
            /* [in] */ BOOL fAllocate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllocateForPostView( 
            /* [in] */ WORD wStreamNumber,
            /* [out] */ BOOL __RPC_FAR *pfAllocate) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterPostViewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMWriterPostView __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMWriterPostView __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMWriterPostView __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPostViewCallback )( 
            IWMWriterPostView __RPC_FAR * This,
            IWMWriterPostViewCallback __RPC_FAR *pCallback,
            void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetReceivePostViewSamples )( 
            IWMWriterPostView __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ BOOL fReceivePostViewSamples);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetReceivePostViewSamples )( 
            IWMWriterPostView __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ BOOL __RPC_FAR *pfReceivePostViewSamples);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPostViewProps )( 
            IWMWriterPostView __RPC_FAR * This,
            /* [in] */ WORD wStreamNumber,
            /* [out] */ IWMMediaProps __RPC_FAR *__RPC_FAR *ppOutput);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPostViewProps )( 
            IWMWriterPostView __RPC_FAR * This,
            /* [in] */ WORD wStreamNumber,
            /* [in] */ IWMMediaProps __RPC_FAR *pOutput);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPostViewFormatCount )( 
            IWMWriterPostView __RPC_FAR * This,
            /* [in] */ WORD wStreamNumber,
            /* [out] */ DWORD __RPC_FAR *pcFormats);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPostViewFormat )( 
            IWMWriterPostView __RPC_FAR * This,
            /* [in] */ WORD wStreamNumber,
            /* [in] */ DWORD dwFormatNumber,
            /* [out] */ IWMMediaProps __RPC_FAR *__RPC_FAR *ppProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAllocateForPostView )( 
            IWMWriterPostView __RPC_FAR * This,
            /* [in] */ WORD wStreamNumber,
            /* [in] */ BOOL fAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllocateForPostView )( 
            IWMWriterPostView __RPC_FAR * This,
            /* [in] */ WORD wStreamNumber,
            /* [out] */ BOOL __RPC_FAR *pfAllocate);
        
        END_INTERFACE
    } IWMWriterPostViewVtbl;

    interface IWMWriterPostView
    {
        CONST_VTBL struct IWMWriterPostViewVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterPostView_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterPostView_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterPostView_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterPostView_SetPostViewCallback(This,pCallback,pvContext)	\
    (This)->lpVtbl -> SetPostViewCallback(This,pCallback,pvContext)

#define IWMWriterPostView_SetReceivePostViewSamples(This,wStreamNum,fReceivePostViewSamples)	\
    (This)->lpVtbl -> SetReceivePostViewSamples(This,wStreamNum,fReceivePostViewSamples)

#define IWMWriterPostView_GetReceivePostViewSamples(This,wStreamNum,pfReceivePostViewSamples)	\
    (This)->lpVtbl -> GetReceivePostViewSamples(This,wStreamNum,pfReceivePostViewSamples)

#define IWMWriterPostView_GetPostViewProps(This,wStreamNumber,ppOutput)	\
    (This)->lpVtbl -> GetPostViewProps(This,wStreamNumber,ppOutput)

#define IWMWriterPostView_SetPostViewProps(This,wStreamNumber,pOutput)	\
    (This)->lpVtbl -> SetPostViewProps(This,wStreamNumber,pOutput)

#define IWMWriterPostView_GetPostViewFormatCount(This,wStreamNumber,pcFormats)	\
    (This)->lpVtbl -> GetPostViewFormatCount(This,wStreamNumber,pcFormats)

#define IWMWriterPostView_GetPostViewFormat(This,wStreamNumber,dwFormatNumber,ppProps)	\
    (This)->lpVtbl -> GetPostViewFormat(This,wStreamNumber,dwFormatNumber,ppProps)

#define IWMWriterPostView_SetAllocateForPostView(This,wStreamNumber,fAllocate)	\
    (This)->lpVtbl -> SetAllocateForPostView(This,wStreamNumber,fAllocate)

#define IWMWriterPostView_GetAllocateForPostView(This,wStreamNumber,pfAllocate)	\
    (This)->lpVtbl -> GetAllocateForPostView(This,wStreamNumber,pfAllocate)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterPostView_SetPostViewCallback_Proxy( 
    IWMWriterPostView __RPC_FAR * This,
    IWMWriterPostViewCallback __RPC_FAR *pCallback,
    void __RPC_FAR *pvContext);


void __RPC_STUB IWMWriterPostView_SetPostViewCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostView_SetReceivePostViewSamples_Proxy( 
    IWMWriterPostView __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ BOOL fReceivePostViewSamples);


void __RPC_STUB IWMWriterPostView_SetReceivePostViewSamples_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostView_GetReceivePostViewSamples_Proxy( 
    IWMWriterPostView __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [out] */ BOOL __RPC_FAR *pfReceivePostViewSamples);


void __RPC_STUB IWMWriterPostView_GetReceivePostViewSamples_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostView_GetPostViewProps_Proxy( 
    IWMWriterPostView __RPC_FAR * This,
    /* [in] */ WORD wStreamNumber,
    /* [out] */ IWMMediaProps __RPC_FAR *__RPC_FAR *ppOutput);


void __RPC_STUB IWMWriterPostView_GetPostViewProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostView_SetPostViewProps_Proxy( 
    IWMWriterPostView __RPC_FAR * This,
    /* [in] */ WORD wStreamNumber,
    /* [in] */ IWMMediaProps __RPC_FAR *pOutput);


void __RPC_STUB IWMWriterPostView_SetPostViewProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostView_GetPostViewFormatCount_Proxy( 
    IWMWriterPostView __RPC_FAR * This,
    /* [in] */ WORD wStreamNumber,
    /* [out] */ DWORD __RPC_FAR *pcFormats);


void __RPC_STUB IWMWriterPostView_GetPostViewFormatCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostView_GetPostViewFormat_Proxy( 
    IWMWriterPostView __RPC_FAR * This,
    /* [in] */ WORD wStreamNumber,
    /* [in] */ DWORD dwFormatNumber,
    /* [out] */ IWMMediaProps __RPC_FAR *__RPC_FAR *ppProps);


void __RPC_STUB IWMWriterPostView_GetPostViewFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostView_SetAllocateForPostView_Proxy( 
    IWMWriterPostView __RPC_FAR * This,
    /* [in] */ WORD wStreamNumber,
    /* [in] */ BOOL fAllocate);


void __RPC_STUB IWMWriterPostView_SetAllocateForPostView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostView_GetAllocateForPostView_Proxy( 
    IWMWriterPostView __RPC_FAR * This,
    /* [in] */ WORD wStreamNumber,
    /* [out] */ BOOL __RPC_FAR *pfAllocate);


void __RPC_STUB IWMWriterPostView_GetAllocateForPostView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterPostView_INTERFACE_DEFINED__ */


#ifndef __IWMWriterSink_INTERFACE_DEFINED__
#define __IWMWriterSink_INTERFACE_DEFINED__

/* interface IWMWriterSink */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BE4-2B2B-11d3-B36B-00C04F6108FF")
    IWMWriterSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnHeader( 
            /* [in] */ INSSBuffer __RPC_FAR *pHeader) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsRealTime( 
            /* [out] */ BOOL __RPC_FAR *pfRealTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateDataUnit( 
            /* [in] */ DWORD cbDataUnit,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppDataUnit) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDataUnit( 
            /* [in] */ INSSBuffer __RPC_FAR *pDataUnit) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnEndWriting( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMWriterSink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMWriterSink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMWriterSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnHeader )( 
            IWMWriterSink __RPC_FAR * This,
            /* [in] */ INSSBuffer __RPC_FAR *pHeader);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsRealTime )( 
            IWMWriterSink __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfRealTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateDataUnit )( 
            IWMWriterSink __RPC_FAR * This,
            /* [in] */ DWORD cbDataUnit,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnDataUnit )( 
            IWMWriterSink __RPC_FAR * This,
            /* [in] */ INSSBuffer __RPC_FAR *pDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnEndWriting )( 
            IWMWriterSink __RPC_FAR * This);
        
        END_INTERFACE
    } IWMWriterSinkVtbl;

    interface IWMWriterSink
    {
        CONST_VTBL struct IWMWriterSinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterSink_OnHeader(This,pHeader)	\
    (This)->lpVtbl -> OnHeader(This,pHeader)

#define IWMWriterSink_IsRealTime(This,pfRealTime)	\
    (This)->lpVtbl -> IsRealTime(This,pfRealTime)

#define IWMWriterSink_AllocateDataUnit(This,cbDataUnit,ppDataUnit)	\
    (This)->lpVtbl -> AllocateDataUnit(This,cbDataUnit,ppDataUnit)

#define IWMWriterSink_OnDataUnit(This,pDataUnit)	\
    (This)->lpVtbl -> OnDataUnit(This,pDataUnit)

#define IWMWriterSink_OnEndWriting(This)	\
    (This)->lpVtbl -> OnEndWriting(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterSink_OnHeader_Proxy( 
    IWMWriterSink __RPC_FAR * This,
    /* [in] */ INSSBuffer __RPC_FAR *pHeader);


void __RPC_STUB IWMWriterSink_OnHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterSink_IsRealTime_Proxy( 
    IWMWriterSink __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfRealTime);


void __RPC_STUB IWMWriterSink_IsRealTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterSink_AllocateDataUnit_Proxy( 
    IWMWriterSink __RPC_FAR * This,
    /* [in] */ DWORD cbDataUnit,
    /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppDataUnit);


void __RPC_STUB IWMWriterSink_AllocateDataUnit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterSink_OnDataUnit_Proxy( 
    IWMWriterSink __RPC_FAR * This,
    /* [in] */ INSSBuffer __RPC_FAR *pDataUnit);


void __RPC_STUB IWMWriterSink_OnDataUnit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterSink_OnEndWriting_Proxy( 
    IWMWriterSink __RPC_FAR * This);


void __RPC_STUB IWMWriterSink_OnEndWriting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterSink_INTERFACE_DEFINED__ */


#ifndef __IWMRegisterCallback_INTERFACE_DEFINED__
#define __IWMRegisterCallback_INTERFACE_DEFINED__

/* interface IWMRegisterCallback */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMRegisterCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CF4B1F99-4DE2-4e49-A363-252740D99BC1")
    IWMRegisterCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Advise( 
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unadvise( 
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMRegisterCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMRegisterCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMRegisterCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMRegisterCallback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Advise )( 
            IWMRegisterCallback __RPC_FAR * This,
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Unadvise )( 
            IWMRegisterCallback __RPC_FAR * This,
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext);
        
        END_INTERFACE
    } IWMRegisterCallbackVtbl;

    interface IWMRegisterCallback
    {
        CONST_VTBL struct IWMRegisterCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMRegisterCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMRegisterCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMRegisterCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMRegisterCallback_Advise(This,pCallback,pvContext)	\
    (This)->lpVtbl -> Advise(This,pCallback,pvContext)

#define IWMRegisterCallback_Unadvise(This,pCallback,pvContext)	\
    (This)->lpVtbl -> Unadvise(This,pCallback,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMRegisterCallback_Advise_Proxy( 
    IWMRegisterCallback __RPC_FAR * This,
    /* [in] */ IWMStatusCallback __RPC_FAR *pCallback,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMRegisterCallback_Advise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMRegisterCallback_Unadvise_Proxy( 
    IWMRegisterCallback __RPC_FAR * This,
    /* [in] */ IWMStatusCallback __RPC_FAR *pCallback,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMRegisterCallback_Unadvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMRegisterCallback_INTERFACE_DEFINED__ */


#ifndef __IWMWriterFileSink_INTERFACE_DEFINED__
#define __IWMWriterFileSink_INTERFACE_DEFINED__

/* interface IWMWriterFileSink */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterFileSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BE5-2B2B-11d3-B36B-00C04F6108FF")
    IWMWriterFileSink : public IWMWriterSink
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterFileSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMWriterFileSink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMWriterFileSink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMWriterFileSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnHeader )( 
            IWMWriterFileSink __RPC_FAR * This,
            /* [in] */ INSSBuffer __RPC_FAR *pHeader);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsRealTime )( 
            IWMWriterFileSink __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfRealTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateDataUnit )( 
            IWMWriterFileSink __RPC_FAR * This,
            /* [in] */ DWORD cbDataUnit,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnDataUnit )( 
            IWMWriterFileSink __RPC_FAR * This,
            /* [in] */ INSSBuffer __RPC_FAR *pDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnEndWriting )( 
            IWMWriterFileSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IWMWriterFileSink __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename);
        
        END_INTERFACE
    } IWMWriterFileSinkVtbl;

    interface IWMWriterFileSink
    {
        CONST_VTBL struct IWMWriterFileSinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterFileSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterFileSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterFileSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterFileSink_OnHeader(This,pHeader)	\
    (This)->lpVtbl -> OnHeader(This,pHeader)

#define IWMWriterFileSink_IsRealTime(This,pfRealTime)	\
    (This)->lpVtbl -> IsRealTime(This,pfRealTime)

#define IWMWriterFileSink_AllocateDataUnit(This,cbDataUnit,ppDataUnit)	\
    (This)->lpVtbl -> AllocateDataUnit(This,cbDataUnit,ppDataUnit)

#define IWMWriterFileSink_OnDataUnit(This,pDataUnit)	\
    (This)->lpVtbl -> OnDataUnit(This,pDataUnit)

#define IWMWriterFileSink_OnEndWriting(This)	\
    (This)->lpVtbl -> OnEndWriting(This)


#define IWMWriterFileSink_Open(This,pwszFilename)	\
    (This)->lpVtbl -> Open(This,pwszFilename)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterFileSink_Open_Proxy( 
    IWMWriterFileSink __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwszFilename);


void __RPC_STUB IWMWriterFileSink_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterFileSink_INTERFACE_DEFINED__ */


#ifndef __IWMWriterFileSink2_INTERFACE_DEFINED__
#define __IWMWriterFileSink2_INTERFACE_DEFINED__

/* interface IWMWriterFileSink2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterFileSink2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("14282BA7-4AEF-4205-8CE5-C229035A05BC")
    IWMWriterFileSink2 : public IWMWriterFileSink
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Start( 
            /* [in] */ QWORD cnsStartTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( 
            /* [in] */ QWORD cnsStopTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsStopped( 
            /* [out] */ BOOL __RPC_FAR *pfStopped) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFileDuration( 
            /* [out] */ QWORD __RPC_FAR *pcnsDuration) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFileSize( 
            /* [out] */ QWORD __RPC_FAR *pcbFile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsClosed( 
            /* [out] */ BOOL __RPC_FAR *pfClosed) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterFileSink2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMWriterFileSink2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMWriterFileSink2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnHeader )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [in] */ INSSBuffer __RPC_FAR *pHeader);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsRealTime )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfRealTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateDataUnit )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [in] */ DWORD cbDataUnit,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnDataUnit )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [in] */ INSSBuffer __RPC_FAR *pDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnEndWriting )( 
            IWMWriterFileSink2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Start )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [in] */ QWORD cnsStartTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Stop )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [in] */ QWORD cnsStopTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsStopped )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfStopped);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFileDuration )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [out] */ QWORD __RPC_FAR *pcnsDuration);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFileSize )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [out] */ QWORD __RPC_FAR *pcbFile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IWMWriterFileSink2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsClosed )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfClosed);
        
        END_INTERFACE
    } IWMWriterFileSink2Vtbl;

    interface IWMWriterFileSink2
    {
        CONST_VTBL struct IWMWriterFileSink2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterFileSink2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterFileSink2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterFileSink2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterFileSink2_OnHeader(This,pHeader)	\
    (This)->lpVtbl -> OnHeader(This,pHeader)

#define IWMWriterFileSink2_IsRealTime(This,pfRealTime)	\
    (This)->lpVtbl -> IsRealTime(This,pfRealTime)

#define IWMWriterFileSink2_AllocateDataUnit(This,cbDataUnit,ppDataUnit)	\
    (This)->lpVtbl -> AllocateDataUnit(This,cbDataUnit,ppDataUnit)

#define IWMWriterFileSink2_OnDataUnit(This,pDataUnit)	\
    (This)->lpVtbl -> OnDataUnit(This,pDataUnit)

#define IWMWriterFileSink2_OnEndWriting(This)	\
    (This)->lpVtbl -> OnEndWriting(This)


#define IWMWriterFileSink2_Open(This,pwszFilename)	\
    (This)->lpVtbl -> Open(This,pwszFilename)


#define IWMWriterFileSink2_Start(This,cnsStartTime)	\
    (This)->lpVtbl -> Start(This,cnsStartTime)

#define IWMWriterFileSink2_Stop(This,cnsStopTime)	\
    (This)->lpVtbl -> Stop(This,cnsStopTime)

#define IWMWriterFileSink2_IsStopped(This,pfStopped)	\
    (This)->lpVtbl -> IsStopped(This,pfStopped)

#define IWMWriterFileSink2_GetFileDuration(This,pcnsDuration)	\
    (This)->lpVtbl -> GetFileDuration(This,pcnsDuration)

#define IWMWriterFileSink2_GetFileSize(This,pcbFile)	\
    (This)->lpVtbl -> GetFileSize(This,pcbFile)

#define IWMWriterFileSink2_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define IWMWriterFileSink2_IsClosed(This,pfClosed)	\
    (This)->lpVtbl -> IsClosed(This,pfClosed)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterFileSink2_Start_Proxy( 
    IWMWriterFileSink2 __RPC_FAR * This,
    /* [in] */ QWORD cnsStartTime);


void __RPC_STUB IWMWriterFileSink2_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterFileSink2_Stop_Proxy( 
    IWMWriterFileSink2 __RPC_FAR * This,
    /* [in] */ QWORD cnsStopTime);


void __RPC_STUB IWMWriterFileSink2_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterFileSink2_IsStopped_Proxy( 
    IWMWriterFileSink2 __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfStopped);


void __RPC_STUB IWMWriterFileSink2_IsStopped_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterFileSink2_GetFileDuration_Proxy( 
    IWMWriterFileSink2 __RPC_FAR * This,
    /* [out] */ QWORD __RPC_FAR *pcnsDuration);


void __RPC_STUB IWMWriterFileSink2_GetFileDuration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterFileSink2_GetFileSize_Proxy( 
    IWMWriterFileSink2 __RPC_FAR * This,
    /* [out] */ QWORD __RPC_FAR *pcbFile);


void __RPC_STUB IWMWriterFileSink2_GetFileSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterFileSink2_Close_Proxy( 
    IWMWriterFileSink2 __RPC_FAR * This);


void __RPC_STUB IWMWriterFileSink2_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterFileSink2_IsClosed_Proxy( 
    IWMWriterFileSink2 __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfClosed);


void __RPC_STUB IWMWriterFileSink2_IsClosed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterFileSink2_INTERFACE_DEFINED__ */


#ifndef __IWMWriterNetworkSink_INTERFACE_DEFINED__
#define __IWMWriterNetworkSink_INTERFACE_DEFINED__

/* interface IWMWriterNetworkSink */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterNetworkSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BE7-2B2B-11d3-B36B-00C04F6108FF")
    IWMWriterNetworkSink : public IWMWriterSink
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetMaximumClients( 
            /* [in] */ DWORD dwMaxClients) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaximumClients( 
            /* [out] */ DWORD __RPC_FAR *pdwMaxClients) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNetworkProtocol( 
            /* [in] */ WMT_NET_PROTOCOL protocol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNetworkProtocol( 
            /* [out] */ WMT_NET_PROTOCOL __RPC_FAR *pProtocol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHostURL( 
            /* [out] */ WCHAR __RPC_FAR *pwszURL,
            /* [out][in] */ DWORD __RPC_FAR *pcchURL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [out][in] */ DWORD __RPC_FAR *pdwPortNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterNetworkSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMWriterNetworkSink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMWriterNetworkSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnHeader )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [in] */ INSSBuffer __RPC_FAR *pHeader);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsRealTime )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfRealTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateDataUnit )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [in] */ DWORD cbDataUnit,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnDataUnit )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [in] */ INSSBuffer __RPC_FAR *pDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnEndWriting )( 
            IWMWriterNetworkSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMaximumClients )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [in] */ DWORD dwMaxClients);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaximumClients )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwMaxClients);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetNetworkProtocol )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [in] */ WMT_NET_PROTOCOL protocol);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNetworkProtocol )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [out] */ WMT_NET_PROTOCOL __RPC_FAR *pProtocol);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHostURL )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszURL,
            /* [out][in] */ DWORD __RPC_FAR *pcchURL);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [out][in] */ DWORD __RPC_FAR *pdwPortNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Disconnect )( 
            IWMWriterNetworkSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IWMWriterNetworkSink __RPC_FAR * This);
        
        END_INTERFACE
    } IWMWriterNetworkSinkVtbl;

    interface IWMWriterNetworkSink
    {
        CONST_VTBL struct IWMWriterNetworkSinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterNetworkSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterNetworkSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterNetworkSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterNetworkSink_OnHeader(This,pHeader)	\
    (This)->lpVtbl -> OnHeader(This,pHeader)

#define IWMWriterNetworkSink_IsRealTime(This,pfRealTime)	\
    (This)->lpVtbl -> IsRealTime(This,pfRealTime)

#define IWMWriterNetworkSink_AllocateDataUnit(This,cbDataUnit,ppDataUnit)	\
    (This)->lpVtbl -> AllocateDataUnit(This,cbDataUnit,ppDataUnit)

#define IWMWriterNetworkSink_OnDataUnit(This,pDataUnit)	\
    (This)->lpVtbl -> OnDataUnit(This,pDataUnit)

#define IWMWriterNetworkSink_OnEndWriting(This)	\
    (This)->lpVtbl -> OnEndWriting(This)


#define IWMWriterNetworkSink_SetMaximumClients(This,dwMaxClients)	\
    (This)->lpVtbl -> SetMaximumClients(This,dwMaxClients)

#define IWMWriterNetworkSink_GetMaximumClients(This,pdwMaxClients)	\
    (This)->lpVtbl -> GetMaximumClients(This,pdwMaxClients)

#define IWMWriterNetworkSink_SetNetworkProtocol(This,protocol)	\
    (This)->lpVtbl -> SetNetworkProtocol(This,protocol)

#define IWMWriterNetworkSink_GetNetworkProtocol(This,pProtocol)	\
    (This)->lpVtbl -> GetNetworkProtocol(This,pProtocol)

#define IWMWriterNetworkSink_GetHostURL(This,pwszURL,pcchURL)	\
    (This)->lpVtbl -> GetHostURL(This,pwszURL,pcchURL)

#define IWMWriterNetworkSink_Open(This,pdwPortNum)	\
    (This)->lpVtbl -> Open(This,pdwPortNum)

#define IWMWriterNetworkSink_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define IWMWriterNetworkSink_Close(This)	\
    (This)->lpVtbl -> Close(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterNetworkSink_SetMaximumClients_Proxy( 
    IWMWriterNetworkSink __RPC_FAR * This,
    /* [in] */ DWORD dwMaxClients);


void __RPC_STUB IWMWriterNetworkSink_SetMaximumClients_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterNetworkSink_GetMaximumClients_Proxy( 
    IWMWriterNetworkSink __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwMaxClients);


void __RPC_STUB IWMWriterNetworkSink_GetMaximumClients_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterNetworkSink_SetNetworkProtocol_Proxy( 
    IWMWriterNetworkSink __RPC_FAR * This,
    /* [in] */ WMT_NET_PROTOCOL protocol);


void __RPC_STUB IWMWriterNetworkSink_SetNetworkProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterNetworkSink_GetNetworkProtocol_Proxy( 
    IWMWriterNetworkSink __RPC_FAR * This,
    /* [out] */ WMT_NET_PROTOCOL __RPC_FAR *pProtocol);


void __RPC_STUB IWMWriterNetworkSink_GetNetworkProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterNetworkSink_GetHostURL_Proxy( 
    IWMWriterNetworkSink __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszURL,
    /* [out][in] */ DWORD __RPC_FAR *pcchURL);


void __RPC_STUB IWMWriterNetworkSink_GetHostURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterNetworkSink_Open_Proxy( 
    IWMWriterNetworkSink __RPC_FAR * This,
    /* [out][in] */ DWORD __RPC_FAR *pdwPortNum);


void __RPC_STUB IWMWriterNetworkSink_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterNetworkSink_Disconnect_Proxy( 
    IWMWriterNetworkSink __RPC_FAR * This);


void __RPC_STUB IWMWriterNetworkSink_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterNetworkSink_Close_Proxy( 
    IWMWriterNetworkSink __RPC_FAR * This);


void __RPC_STUB IWMWriterNetworkSink_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterNetworkSink_INTERFACE_DEFINED__ */


#ifndef __IWMClientConnections_INTERFACE_DEFINED__
#define __IWMClientConnections_INTERFACE_DEFINED__

/* interface IWMClientConnections */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMClientConnections;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("73C66010-A299-41df-B1F0-CCF03B09C1C6")
    IWMClientConnections : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClientCount( 
            /* [out] */ DWORD __RPC_FAR *pcClients) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClientProperties( 
            /* [in] */ DWORD dwClientNum,
            /* [out] */ WM_CLIENT_PROPERTIES __RPC_FAR *pClientProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMClientConnectionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMClientConnections __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMClientConnections __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMClientConnections __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClientCount )( 
            IWMClientConnections __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcClients);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClientProperties )( 
            IWMClientConnections __RPC_FAR * This,
            /* [in] */ DWORD dwClientNum,
            /* [out] */ WM_CLIENT_PROPERTIES __RPC_FAR *pClientProperties);
        
        END_INTERFACE
    } IWMClientConnectionsVtbl;

    interface IWMClientConnections
    {
        CONST_VTBL struct IWMClientConnectionsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMClientConnections_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMClientConnections_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMClientConnections_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMClientConnections_GetClientCount(This,pcClients)	\
    (This)->lpVtbl -> GetClientCount(This,pcClients)

#define IWMClientConnections_GetClientProperties(This,dwClientNum,pClientProperties)	\
    (This)->lpVtbl -> GetClientProperties(This,dwClientNum,pClientProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMClientConnections_GetClientCount_Proxy( 
    IWMClientConnections __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcClients);


void __RPC_STUB IWMClientConnections_GetClientCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMClientConnections_GetClientProperties_Proxy( 
    IWMClientConnections __RPC_FAR * This,
    /* [in] */ DWORD dwClientNum,
    /* [out] */ WM_CLIENT_PROPERTIES __RPC_FAR *pClientProperties);


void __RPC_STUB IWMClientConnections_GetClientProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMClientConnections_INTERFACE_DEFINED__ */


#ifndef __IWMReaderAdvanced_INTERFACE_DEFINED__
#define __IWMReaderAdvanced_INTERFACE_DEFINED__

/* interface IWMReaderAdvanced */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderAdvanced;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BEA-2B2B-11d3-B36B-00C04F6108FF")
    IWMReaderAdvanced : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetUserProvidedClock( 
            /* [in] */ BOOL fUserClock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUserProvidedClock( 
            /* [out] */ BOOL __RPC_FAR *pfUserClock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeliverTime( 
            /* [in] */ QWORD cnsTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetManualStreamSelection( 
            /* [in] */ BOOL fSelection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetManualStreamSelection( 
            /* [out] */ BOOL __RPC_FAR *pfSelection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStreamsSelected( 
            /* [in] */ WORD cStreamCount,
            /* [in] */ WORD __RPC_FAR *pwStreamNumbers,
            /* [in] */ WMT_STREAM_SELECTION __RPC_FAR *pSelections) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamSelected( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ WMT_STREAM_SELECTION __RPC_FAR *pSelection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetReceiveSelectionCallbacks( 
            /* [in] */ BOOL fGetCallbacks) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReceiveSelectionCallbacks( 
            /* [in] */ BOOL __RPC_FAR *pfGetCallbacks) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetReceiveStreamSamples( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ BOOL fReceiveStreamSamples) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReceiveStreamSamples( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ BOOL __RPC_FAR *pfReceiveStreamSamples) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAllocateForOutput( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ BOOL fAllocate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllocateForOutput( 
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ BOOL __RPC_FAR *pfAllocate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAllocateForStream( 
            /* [in] */ WORD dwStreamNum,
            /* [in] */ BOOL fAllocate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllocateForStream( 
            /* [in] */ WORD dwSreamNum,
            /* [out] */ BOOL __RPC_FAR *pfAllocate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatistics( 
            /* [in] */ WM_READER_STATISTICS __RPC_FAR *pStatistics) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClientInfo( 
            /* [in] */ WM_READER_CLIENTINFO __RPC_FAR *pClientInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxOutputSampleSize( 
            /* [in] */ DWORD dwOutput,
            /* [out] */ DWORD __RPC_FAR *pcbMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxStreamSampleSize( 
            /* [in] */ WORD wStream,
            /* [out] */ DWORD __RPC_FAR *pcbMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyLateDelivery( 
            QWORD cnsLateness) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderAdvancedVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReaderAdvanced __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReaderAdvanced __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetUserProvidedClock )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ BOOL fUserClock);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetUserProvidedClock )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfUserClock);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeliverTime )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ QWORD cnsTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetManualStreamSelection )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ BOOL fSelection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetManualStreamSelection )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfSelection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStreamsSelected )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ WORD cStreamCount,
            /* [in] */ WORD __RPC_FAR *pwStreamNumbers,
            /* [in] */ WMT_STREAM_SELECTION __RPC_FAR *pSelections);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamSelected )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WMT_STREAM_SELECTION __RPC_FAR *pSelection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetReceiveSelectionCallbacks )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ BOOL fGetCallbacks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetReceiveSelectionCallbacks )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ BOOL __RPC_FAR *pfGetCallbacks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetReceiveStreamSamples )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ BOOL fReceiveStreamSamples);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetReceiveStreamSamples )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ BOOL __RPC_FAR *pfReceiveStreamSamples);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAllocateForOutput )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ BOOL fAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllocateForOutput )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ BOOL __RPC_FAR *pfAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAllocateForStream )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ WORD dwStreamNum,
            /* [in] */ BOOL fAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllocateForStream )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ WORD dwSreamNum,
            /* [out] */ BOOL __RPC_FAR *pfAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatistics )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ WM_READER_STATISTICS __RPC_FAR *pStatistics);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetClientInfo )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ WM_READER_CLIENTINFO __RPC_FAR *pClientInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxOutputSampleSize )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ DWORD dwOutput,
            /* [out] */ DWORD __RPC_FAR *pcbMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxStreamSampleSize )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ WORD wStream,
            /* [out] */ DWORD __RPC_FAR *pcbMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NotifyLateDelivery )( 
            IWMReaderAdvanced __RPC_FAR * This,
            QWORD cnsLateness);
        
        END_INTERFACE
    } IWMReaderAdvancedVtbl;

    interface IWMReaderAdvanced
    {
        CONST_VTBL struct IWMReaderAdvancedVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderAdvanced_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderAdvanced_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderAdvanced_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderAdvanced_SetUserProvidedClock(This,fUserClock)	\
    (This)->lpVtbl -> SetUserProvidedClock(This,fUserClock)

#define IWMReaderAdvanced_GetUserProvidedClock(This,pfUserClock)	\
    (This)->lpVtbl -> GetUserProvidedClock(This,pfUserClock)

#define IWMReaderAdvanced_DeliverTime(This,cnsTime)	\
    (This)->lpVtbl -> DeliverTime(This,cnsTime)

#define IWMReaderAdvanced_SetManualStreamSelection(This,fSelection)	\
    (This)->lpVtbl -> SetManualStreamSelection(This,fSelection)

#define IWMReaderAdvanced_GetManualStreamSelection(This,pfSelection)	\
    (This)->lpVtbl -> GetManualStreamSelection(This,pfSelection)

#define IWMReaderAdvanced_SetStreamsSelected(This,cStreamCount,pwStreamNumbers,pSelections)	\
    (This)->lpVtbl -> SetStreamsSelected(This,cStreamCount,pwStreamNumbers,pSelections)

#define IWMReaderAdvanced_GetStreamSelected(This,wStreamNum,pSelection)	\
    (This)->lpVtbl -> GetStreamSelected(This,wStreamNum,pSelection)

#define IWMReaderAdvanced_SetReceiveSelectionCallbacks(This,fGetCallbacks)	\
    (This)->lpVtbl -> SetReceiveSelectionCallbacks(This,fGetCallbacks)

#define IWMReaderAdvanced_GetReceiveSelectionCallbacks(This,pfGetCallbacks)	\
    (This)->lpVtbl -> GetReceiveSelectionCallbacks(This,pfGetCallbacks)

#define IWMReaderAdvanced_SetReceiveStreamSamples(This,wStreamNum,fReceiveStreamSamples)	\
    (This)->lpVtbl -> SetReceiveStreamSamples(This,wStreamNum,fReceiveStreamSamples)

#define IWMReaderAdvanced_GetReceiveStreamSamples(This,wStreamNum,pfReceiveStreamSamples)	\
    (This)->lpVtbl -> GetReceiveStreamSamples(This,wStreamNum,pfReceiveStreamSamples)

#define IWMReaderAdvanced_SetAllocateForOutput(This,dwOutputNum,fAllocate)	\
    (This)->lpVtbl -> SetAllocateForOutput(This,dwOutputNum,fAllocate)

#define IWMReaderAdvanced_GetAllocateForOutput(This,dwOutputNum,pfAllocate)	\
    (This)->lpVtbl -> GetAllocateForOutput(This,dwOutputNum,pfAllocate)

#define IWMReaderAdvanced_SetAllocateForStream(This,dwStreamNum,fAllocate)	\
    (This)->lpVtbl -> SetAllocateForStream(This,dwStreamNum,fAllocate)

#define IWMReaderAdvanced_GetAllocateForStream(This,dwSreamNum,pfAllocate)	\
    (This)->lpVtbl -> GetAllocateForStream(This,dwSreamNum,pfAllocate)

#define IWMReaderAdvanced_GetStatistics(This,pStatistics)	\
    (This)->lpVtbl -> GetStatistics(This,pStatistics)

#define IWMReaderAdvanced_SetClientInfo(This,pClientInfo)	\
    (This)->lpVtbl -> SetClientInfo(This,pClientInfo)

#define IWMReaderAdvanced_GetMaxOutputSampleSize(This,dwOutput,pcbMax)	\
    (This)->lpVtbl -> GetMaxOutputSampleSize(This,dwOutput,pcbMax)

#define IWMReaderAdvanced_GetMaxStreamSampleSize(This,wStream,pcbMax)	\
    (This)->lpVtbl -> GetMaxStreamSampleSize(This,wStream,pcbMax)

#define IWMReaderAdvanced_NotifyLateDelivery(This,cnsLateness)	\
    (This)->lpVtbl -> NotifyLateDelivery(This,cnsLateness)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetUserProvidedClock_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ BOOL fUserClock);


void __RPC_STUB IWMReaderAdvanced_SetUserProvidedClock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetUserProvidedClock_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfUserClock);


void __RPC_STUB IWMReaderAdvanced_GetUserProvidedClock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_DeliverTime_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ QWORD cnsTime);


void __RPC_STUB IWMReaderAdvanced_DeliverTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetManualStreamSelection_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ BOOL fSelection);


void __RPC_STUB IWMReaderAdvanced_SetManualStreamSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetManualStreamSelection_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfSelection);


void __RPC_STUB IWMReaderAdvanced_GetManualStreamSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetStreamsSelected_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WORD cStreamCount,
    /* [in] */ WORD __RPC_FAR *pwStreamNumbers,
    /* [in] */ WMT_STREAM_SELECTION __RPC_FAR *pSelections);


void __RPC_STUB IWMReaderAdvanced_SetStreamsSelected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetStreamSelected_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [out] */ WMT_STREAM_SELECTION __RPC_FAR *pSelection);


void __RPC_STUB IWMReaderAdvanced_GetStreamSelected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetReceiveSelectionCallbacks_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ BOOL fGetCallbacks);


void __RPC_STUB IWMReaderAdvanced_SetReceiveSelectionCallbacks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetReceiveSelectionCallbacks_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ BOOL __RPC_FAR *pfGetCallbacks);


void __RPC_STUB IWMReaderAdvanced_GetReceiveSelectionCallbacks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetReceiveStreamSamples_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ BOOL fReceiveStreamSamples);


void __RPC_STUB IWMReaderAdvanced_SetReceiveStreamSamples_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetReceiveStreamSamples_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [out] */ BOOL __RPC_FAR *pfReceiveStreamSamples);


void __RPC_STUB IWMReaderAdvanced_GetReceiveStreamSamples_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetAllocateForOutput_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ BOOL fAllocate);


void __RPC_STUB IWMReaderAdvanced_SetAllocateForOutput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetAllocateForOutput_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [out] */ BOOL __RPC_FAR *pfAllocate);


void __RPC_STUB IWMReaderAdvanced_GetAllocateForOutput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetAllocateForStream_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WORD dwStreamNum,
    /* [in] */ BOOL fAllocate);


void __RPC_STUB IWMReaderAdvanced_SetAllocateForStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetAllocateForStream_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WORD dwSreamNum,
    /* [out] */ BOOL __RPC_FAR *pfAllocate);


void __RPC_STUB IWMReaderAdvanced_GetAllocateForStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetStatistics_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WM_READER_STATISTICS __RPC_FAR *pStatistics);


void __RPC_STUB IWMReaderAdvanced_GetStatistics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetClientInfo_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WM_READER_CLIENTINFO __RPC_FAR *pClientInfo);


void __RPC_STUB IWMReaderAdvanced_SetClientInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetMaxOutputSampleSize_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ DWORD dwOutput,
    /* [out] */ DWORD __RPC_FAR *pcbMax);


void __RPC_STUB IWMReaderAdvanced_GetMaxOutputSampleSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetMaxStreamSampleSize_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WORD wStream,
    /* [out] */ DWORD __RPC_FAR *pcbMax);


void __RPC_STUB IWMReaderAdvanced_GetMaxStreamSampleSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_NotifyLateDelivery_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    QWORD cnsLateness);


void __RPC_STUB IWMReaderAdvanced_NotifyLateDelivery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderAdvanced_INTERFACE_DEFINED__ */


#ifndef __IWMReaderAdvanced2_INTERFACE_DEFINED__
#define __IWMReaderAdvanced2_INTERFACE_DEFINED__

/* interface IWMReaderAdvanced2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderAdvanced2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ae14a945-b90c-4d0d-9127-80d665f7d73e")
    IWMReaderAdvanced2 : public IWMReaderAdvanced
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetPlayMode( 
            /* [in] */ WMT_PLAY_MODE Mode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPlayMode( 
            /* [out] */ WMT_PLAY_MODE __RPC_FAR *pMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBufferProgress( 
            /* [out] */ DWORD __RPC_FAR *pdwPercent,
            /* [out] */ QWORD __RPC_FAR *pcnsBuffering) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDownloadProgress( 
            /* [out] */ DWORD __RPC_FAR *pdwPercent,
            /* [out] */ QWORD __RPC_FAR *pqwBytesDownloaded,
            /* [out] */ QWORD __RPC_FAR *pcnsDownload) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSaveAsProgress( 
            /* [out] */ DWORD __RPC_FAR *pdwPercent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveFileAs( 
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProtocolName( 
            /* [out] */ WCHAR __RPC_FAR *pwszProtocol,
            /* [out][in] */ DWORD __RPC_FAR *pcchProtocol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartAtMarker( 
            /* [in] */ WORD wMarkerIndex,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputSetting( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputSetting( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Preroll( 
            /* [in] */ QWORD cnsStart,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLogClientID( 
            /* [in] */ BOOL fLogClientID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLogClientID( 
            /* [out] */ BOOL __RPC_FAR *pfLogClientID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopBuffering( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenStream( 
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [in] */ IWMReaderCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderAdvanced2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReaderAdvanced2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReaderAdvanced2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetUserProvidedClock )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ BOOL fUserClock);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetUserProvidedClock )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfUserClock);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeliverTime )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ QWORD cnsTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetManualStreamSelection )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ BOOL fSelection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetManualStreamSelection )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfSelection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStreamsSelected )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD cStreamCount,
            /* [in] */ WORD __RPC_FAR *pwStreamNumbers,
            /* [in] */ WMT_STREAM_SELECTION __RPC_FAR *pSelections);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamSelected )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WMT_STREAM_SELECTION __RPC_FAR *pSelection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetReceiveSelectionCallbacks )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ BOOL fGetCallbacks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetReceiveSelectionCallbacks )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ BOOL __RPC_FAR *pfGetCallbacks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetReceiveStreamSamples )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ BOOL fReceiveStreamSamples);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetReceiveStreamSamples )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ BOOL __RPC_FAR *pfReceiveStreamSamples);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAllocateForOutput )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ BOOL fAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllocateForOutput )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ BOOL __RPC_FAR *pfAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAllocateForStream )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD dwStreamNum,
            /* [in] */ BOOL fAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllocateForStream )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD dwSreamNum,
            /* [out] */ BOOL __RPC_FAR *pfAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatistics )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WM_READER_STATISTICS __RPC_FAR *pStatistics);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetClientInfo )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WM_READER_CLIENTINFO __RPC_FAR *pClientInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxOutputSampleSize )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ DWORD dwOutput,
            /* [out] */ DWORD __RPC_FAR *pcbMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxStreamSampleSize )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD wStream,
            /* [out] */ DWORD __RPC_FAR *pcbMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NotifyLateDelivery )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            QWORD cnsLateness);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPlayMode )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WMT_PLAY_MODE Mode);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPlayMode )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [out] */ WMT_PLAY_MODE __RPC_FAR *pMode);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferProgress )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwPercent,
            /* [out] */ QWORD __RPC_FAR *pcnsBuffering);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDownloadProgress )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwPercent,
            /* [out] */ QWORD __RPC_FAR *pqwBytesDownloaded,
            /* [out] */ QWORD __RPC_FAR *pcnsDownload);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSaveAsProgress )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwPercent);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveFileAs )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProtocolName )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszProtocol,
            /* [out][in] */ DWORD __RPC_FAR *pcchProtocol);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartAtMarker )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD wMarkerIndex,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutputSetting )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOutputSetting )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Preroll )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ QWORD cnsStart,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLogClientID )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ BOOL fLogClientID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLogClientID )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfLogClientID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StopBuffering )( 
            IWMReaderAdvanced2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenStream )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [in] */ IWMReaderCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext);
        
        END_INTERFACE
    } IWMReaderAdvanced2Vtbl;

    interface IWMReaderAdvanced2
    {
        CONST_VTBL struct IWMReaderAdvanced2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderAdvanced2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderAdvanced2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderAdvanced2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderAdvanced2_SetUserProvidedClock(This,fUserClock)	\
    (This)->lpVtbl -> SetUserProvidedClock(This,fUserClock)

#define IWMReaderAdvanced2_GetUserProvidedClock(This,pfUserClock)	\
    (This)->lpVtbl -> GetUserProvidedClock(This,pfUserClock)

#define IWMReaderAdvanced2_DeliverTime(This,cnsTime)	\
    (This)->lpVtbl -> DeliverTime(This,cnsTime)

#define IWMReaderAdvanced2_SetManualStreamSelection(This,fSelection)	\
    (This)->lpVtbl -> SetManualStreamSelection(This,fSelection)

#define IWMReaderAdvanced2_GetManualStreamSelection(This,pfSelection)	\
    (This)->lpVtbl -> GetManualStreamSelection(This,pfSelection)

#define IWMReaderAdvanced2_SetStreamsSelected(This,cStreamCount,pwStreamNumbers,pSelections)	\
    (This)->lpVtbl -> SetStreamsSelected(This,cStreamCount,pwStreamNumbers,pSelections)

#define IWMReaderAdvanced2_GetStreamSelected(This,wStreamNum,pSelection)	\
    (This)->lpVtbl -> GetStreamSelected(This,wStreamNum,pSelection)

#define IWMReaderAdvanced2_SetReceiveSelectionCallbacks(This,fGetCallbacks)	\
    (This)->lpVtbl -> SetReceiveSelectionCallbacks(This,fGetCallbacks)

#define IWMReaderAdvanced2_GetReceiveSelectionCallbacks(This,pfGetCallbacks)	\
    (This)->lpVtbl -> GetReceiveSelectionCallbacks(This,pfGetCallbacks)

#define IWMReaderAdvanced2_SetReceiveStreamSamples(This,wStreamNum,fReceiveStreamSamples)	\
    (This)->lpVtbl -> SetReceiveStreamSamples(This,wStreamNum,fReceiveStreamSamples)

#define IWMReaderAdvanced2_GetReceiveStreamSamples(This,wStreamNum,pfReceiveStreamSamples)	\
    (This)->lpVtbl -> GetReceiveStreamSamples(This,wStreamNum,pfReceiveStreamSamples)

#define IWMReaderAdvanced2_SetAllocateForOutput(This,dwOutputNum,fAllocate)	\
    (This)->lpVtbl -> SetAllocateForOutput(This,dwOutputNum,fAllocate)

#define IWMReaderAdvanced2_GetAllocateForOutput(This,dwOutputNum,pfAllocate)	\
    (This)->lpVtbl -> GetAllocateForOutput(This,dwOutputNum,pfAllocate)

#define IWMReaderAdvanced2_SetAllocateForStream(This,dwStreamNum,fAllocate)	\
    (This)->lpVtbl -> SetAllocateForStream(This,dwStreamNum,fAllocate)

#define IWMReaderAdvanced2_GetAllocateForStream(This,dwSreamNum,pfAllocate)	\
    (This)->lpVtbl -> GetAllocateForStream(This,dwSreamNum,pfAllocate)

#define IWMReaderAdvanced2_GetStatistics(This,pStatistics)	\
    (This)->lpVtbl -> GetStatistics(This,pStatistics)

#define IWMReaderAdvanced2_SetClientInfo(This,pClientInfo)	\
    (This)->lpVtbl -> SetClientInfo(This,pClientInfo)

#define IWMReaderAdvanced2_GetMaxOutputSampleSize(This,dwOutput,pcbMax)	\
    (This)->lpVtbl -> GetMaxOutputSampleSize(This,dwOutput,pcbMax)

#define IWMReaderAdvanced2_GetMaxStreamSampleSize(This,wStream,pcbMax)	\
    (This)->lpVtbl -> GetMaxStreamSampleSize(This,wStream,pcbMax)

#define IWMReaderAdvanced2_NotifyLateDelivery(This,cnsLateness)	\
    (This)->lpVtbl -> NotifyLateDelivery(This,cnsLateness)


#define IWMReaderAdvanced2_SetPlayMode(This,Mode)	\
    (This)->lpVtbl -> SetPlayMode(This,Mode)

#define IWMReaderAdvanced2_GetPlayMode(This,pMode)	\
    (This)->lpVtbl -> GetPlayMode(This,pMode)

#define IWMReaderAdvanced2_GetBufferProgress(This,pdwPercent,pcnsBuffering)	\
    (This)->lpVtbl -> GetBufferProgress(This,pdwPercent,pcnsBuffering)

#define IWMReaderAdvanced2_GetDownloadProgress(This,pdwPercent,pqwBytesDownloaded,pcnsDownload)	\
    (This)->lpVtbl -> GetDownloadProgress(This,pdwPercent,pqwBytesDownloaded,pcnsDownload)

#define IWMReaderAdvanced2_GetSaveAsProgress(This,pdwPercent)	\
    (This)->lpVtbl -> GetSaveAsProgress(This,pdwPercent)

#define IWMReaderAdvanced2_SaveFileAs(This,pwszFilename)	\
    (This)->lpVtbl -> SaveFileAs(This,pwszFilename)

#define IWMReaderAdvanced2_GetProtocolName(This,pwszProtocol,pcchProtocol)	\
    (This)->lpVtbl -> GetProtocolName(This,pwszProtocol,pcchProtocol)

#define IWMReaderAdvanced2_StartAtMarker(This,wMarkerIndex,cnsDuration,fRate,pvContext)	\
    (This)->lpVtbl -> StartAtMarker(This,wMarkerIndex,cnsDuration,fRate,pvContext)

#define IWMReaderAdvanced2_GetOutputSetting(This,dwOutputNum,pszName,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetOutputSetting(This,dwOutputNum,pszName,pType,pValue,pcbLength)

#define IWMReaderAdvanced2_SetOutputSetting(This,dwOutputNum,pszName,Type,pValue,cbLength)	\
    (This)->lpVtbl -> SetOutputSetting(This,dwOutputNum,pszName,Type,pValue,cbLength)

#define IWMReaderAdvanced2_Preroll(This,cnsStart,cnsDuration,fRate)	\
    (This)->lpVtbl -> Preroll(This,cnsStart,cnsDuration,fRate)

#define IWMReaderAdvanced2_SetLogClientID(This,fLogClientID)	\
    (This)->lpVtbl -> SetLogClientID(This,fLogClientID)

#define IWMReaderAdvanced2_GetLogClientID(This,pfLogClientID)	\
    (This)->lpVtbl -> GetLogClientID(This,pfLogClientID)

#define IWMReaderAdvanced2_StopBuffering(This)	\
    (This)->lpVtbl -> StopBuffering(This)

#define IWMReaderAdvanced2_OpenStream(This,pStream,pCallback,pvContext)	\
    (This)->lpVtbl -> OpenStream(This,pStream,pCallback,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_SetPlayMode_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [in] */ WMT_PLAY_MODE Mode);


void __RPC_STUB IWMReaderAdvanced2_SetPlayMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_GetPlayMode_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [out] */ WMT_PLAY_MODE __RPC_FAR *pMode);


void __RPC_STUB IWMReaderAdvanced2_GetPlayMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_GetBufferProgress_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwPercent,
    /* [out] */ QWORD __RPC_FAR *pcnsBuffering);


void __RPC_STUB IWMReaderAdvanced2_GetBufferProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_GetDownloadProgress_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwPercent,
    /* [out] */ QWORD __RPC_FAR *pqwBytesDownloaded,
    /* [out] */ QWORD __RPC_FAR *pcnsDownload);


void __RPC_STUB IWMReaderAdvanced2_GetDownloadProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_GetSaveAsProgress_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwPercent);


void __RPC_STUB IWMReaderAdvanced2_GetSaveAsProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_SaveFileAs_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwszFilename);


void __RPC_STUB IWMReaderAdvanced2_SaveFileAs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_GetProtocolName_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszProtocol,
    /* [out][in] */ DWORD __RPC_FAR *pcchProtocol);


void __RPC_STUB IWMReaderAdvanced2_GetProtocolName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_StartAtMarker_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [in] */ WORD wMarkerIndex,
    /* [in] */ QWORD cnsDuration,
    /* [in] */ float fRate,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderAdvanced2_StartAtMarker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_GetOutputSetting_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ LPCWSTR pszName,
    /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
    /* [out] */ BYTE __RPC_FAR *pValue,
    /* [out][in] */ WORD __RPC_FAR *pcbLength);


void __RPC_STUB IWMReaderAdvanced2_GetOutputSetting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_SetOutputSetting_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ WMT_ATTR_DATATYPE Type,
    /* [in] */ const BYTE __RPC_FAR *pValue,
    /* [in] */ WORD cbLength);


void __RPC_STUB IWMReaderAdvanced2_SetOutputSetting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_Preroll_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [in] */ QWORD cnsStart,
    /* [in] */ QWORD cnsDuration,
    /* [in] */ float fRate);


void __RPC_STUB IWMReaderAdvanced2_Preroll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_SetLogClientID_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [in] */ BOOL fLogClientID);


void __RPC_STUB IWMReaderAdvanced2_SetLogClientID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_GetLogClientID_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfLogClientID);


void __RPC_STUB IWMReaderAdvanced2_GetLogClientID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_StopBuffering_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This);


void __RPC_STUB IWMReaderAdvanced2_StopBuffering_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_OpenStream_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [in] */ IStream __RPC_FAR *pStream,
    /* [in] */ IWMReaderCallback __RPC_FAR *pCallback,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderAdvanced2_OpenStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderAdvanced2_INTERFACE_DEFINED__ */


#ifndef __IWMReaderAdvanced3_INTERFACE_DEFINED__
#define __IWMReaderAdvanced3_INTERFACE_DEFINED__

/* interface IWMReaderAdvanced3 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderAdvanced3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5DC0674B-F04B-4a4e-9F2A-B1AFDE2C8100")
    IWMReaderAdvanced3 : public IWMReaderAdvanced2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StopNetStreaming( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartAtPosition( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ void __RPC_FAR *pvOffsetStart,
            /* [in] */ void __RPC_FAR *pvDuration,
            /* [in] */ WMT_OFFSET_FORMAT dwOffsetFormat,
            /* [in] */ float fRate,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderAdvanced3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReaderAdvanced3 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReaderAdvanced3 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetUserProvidedClock )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ BOOL fUserClock);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetUserProvidedClock )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfUserClock);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeliverTime )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ QWORD cnsTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetManualStreamSelection )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ BOOL fSelection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetManualStreamSelection )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfSelection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStreamsSelected )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ WORD cStreamCount,
            /* [in] */ WORD __RPC_FAR *pwStreamNumbers,
            /* [in] */ WMT_STREAM_SELECTION __RPC_FAR *pSelections);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamSelected )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WMT_STREAM_SELECTION __RPC_FAR *pSelection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetReceiveSelectionCallbacks )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ BOOL fGetCallbacks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetReceiveSelectionCallbacks )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ BOOL __RPC_FAR *pfGetCallbacks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetReceiveStreamSamples )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ BOOL fReceiveStreamSamples);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetReceiveStreamSamples )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ BOOL __RPC_FAR *pfReceiveStreamSamples);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAllocateForOutput )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ BOOL fAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllocateForOutput )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ BOOL __RPC_FAR *pfAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAllocateForStream )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ WORD dwStreamNum,
            /* [in] */ BOOL fAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllocateForStream )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ WORD dwSreamNum,
            /* [out] */ BOOL __RPC_FAR *pfAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatistics )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ WM_READER_STATISTICS __RPC_FAR *pStatistics);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetClientInfo )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ WM_READER_CLIENTINFO __RPC_FAR *pClientInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxOutputSampleSize )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ DWORD dwOutput,
            /* [out] */ DWORD __RPC_FAR *pcbMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxStreamSampleSize )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ WORD wStream,
            /* [out] */ DWORD __RPC_FAR *pcbMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NotifyLateDelivery )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            QWORD cnsLateness);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPlayMode )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ WMT_PLAY_MODE Mode);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPlayMode )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [out] */ WMT_PLAY_MODE __RPC_FAR *pMode);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferProgress )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwPercent,
            /* [out] */ QWORD __RPC_FAR *pcnsBuffering);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDownloadProgress )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwPercent,
            /* [out] */ QWORD __RPC_FAR *pqwBytesDownloaded,
            /* [out] */ QWORD __RPC_FAR *pcnsDownload);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSaveAsProgress )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwPercent);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveFileAs )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProtocolName )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszProtocol,
            /* [out][in] */ DWORD __RPC_FAR *pcchProtocol);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartAtMarker )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ WORD wMarkerIndex,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutputSetting )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOutputSetting )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Preroll )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ QWORD cnsStart,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLogClientID )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ BOOL fLogClientID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLogClientID )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfLogClientID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StopBuffering )( 
            IWMReaderAdvanced3 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenStream )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [in] */ IWMReaderCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StopNetStreaming )( 
            IWMReaderAdvanced3 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartAtPosition )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ void __RPC_FAR *pvOffsetStart,
            /* [in] */ void __RPC_FAR *pvDuration,
            /* [in] */ WMT_OFFSET_FORMAT dwOffsetFormat,
            /* [in] */ float fRate,
            /* [in] */ void __RPC_FAR *pvContext);
        
        END_INTERFACE
    } IWMReaderAdvanced3Vtbl;

    interface IWMReaderAdvanced3
    {
        CONST_VTBL struct IWMReaderAdvanced3Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderAdvanced3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderAdvanced3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderAdvanced3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderAdvanced3_SetUserProvidedClock(This,fUserClock)	\
    (This)->lpVtbl -> SetUserProvidedClock(This,fUserClock)

#define IWMReaderAdvanced3_GetUserProvidedClock(This,pfUserClock)	\
    (This)->lpVtbl -> GetUserProvidedClock(This,pfUserClock)

#define IWMReaderAdvanced3_DeliverTime(This,cnsTime)	\
    (This)->lpVtbl -> DeliverTime(This,cnsTime)

#define IWMReaderAdvanced3_SetManualStreamSelection(This,fSelection)	\
    (This)->lpVtbl -> SetManualStreamSelection(This,fSelection)

#define IWMReaderAdvanced3_GetManualStreamSelection(This,pfSelection)	\
    (This)->lpVtbl -> GetManualStreamSelection(This,pfSelection)

#define IWMReaderAdvanced3_SetStreamsSelected(This,cStreamCount,pwStreamNumbers,pSelections)	\
    (This)->lpVtbl -> SetStreamsSelected(This,cStreamCount,pwStreamNumbers,pSelections)

#define IWMReaderAdvanced3_GetStreamSelected(This,wStreamNum,pSelection)	\
    (This)->lpVtbl -> GetStreamSelected(This,wStreamNum,pSelection)

#define IWMReaderAdvanced3_SetReceiveSelectionCallbacks(This,fGetCallbacks)	\
    (This)->lpVtbl -> SetReceiveSelectionCallbacks(This,fGetCallbacks)

#define IWMReaderAdvanced3_GetReceiveSelectionCallbacks(This,pfGetCallbacks)	\
    (This)->lpVtbl -> GetReceiveSelectionCallbacks(This,pfGetCallbacks)

#define IWMReaderAdvanced3_SetReceiveStreamSamples(This,wStreamNum,fReceiveStreamSamples)	\
    (This)->lpVtbl -> SetReceiveStreamSamples(This,wStreamNum,fReceiveStreamSamples)

#define IWMReaderAdvanced3_GetReceiveStreamSamples(This,wStreamNum,pfReceiveStreamSamples)	\
    (This)->lpVtbl -> GetReceiveStreamSamples(This,wStreamNum,pfReceiveStreamSamples)

#define IWMReaderAdvanced3_SetAllocateForOutput(This,dwOutputNum,fAllocate)	\
    (This)->lpVtbl -> SetAllocateForOutput(This,dwOutputNum,fAllocate)

#define IWMReaderAdvanced3_GetAllocateForOutput(This,dwOutputNum,pfAllocate)	\
    (This)->lpVtbl -> GetAllocateForOutput(This,dwOutputNum,pfAllocate)

#define IWMReaderAdvanced3_SetAllocateForStream(This,dwStreamNum,fAllocate)	\
    (This)->lpVtbl -> SetAllocateForStream(This,dwStreamNum,fAllocate)

#define IWMReaderAdvanced3_GetAllocateForStream(This,dwSreamNum,pfAllocate)	\
    (This)->lpVtbl -> GetAllocateForStream(This,dwSreamNum,pfAllocate)

#define IWMReaderAdvanced3_GetStatistics(This,pStatistics)	\
    (This)->lpVtbl -> GetStatistics(This,pStatistics)

#define IWMReaderAdvanced3_SetClientInfo(This,pClientInfo)	\
    (This)->lpVtbl -> SetClientInfo(This,pClientInfo)

#define IWMReaderAdvanced3_GetMaxOutputSampleSize(This,dwOutput,pcbMax)	\
    (This)->lpVtbl -> GetMaxOutputSampleSize(This,dwOutput,pcbMax)

#define IWMReaderAdvanced3_GetMaxStreamSampleSize(This,wStream,pcbMax)	\
    (This)->lpVtbl -> GetMaxStreamSampleSize(This,wStream,pcbMax)

#define IWMReaderAdvanced3_NotifyLateDelivery(This,cnsLateness)	\
    (This)->lpVtbl -> NotifyLateDelivery(This,cnsLateness)


#define IWMReaderAdvanced3_SetPlayMode(This,Mode)	\
    (This)->lpVtbl -> SetPlayMode(This,Mode)

#define IWMReaderAdvanced3_GetPlayMode(This,pMode)	\
    (This)->lpVtbl -> GetPlayMode(This,pMode)

#define IWMReaderAdvanced3_GetBufferProgress(This,pdwPercent,pcnsBuffering)	\
    (This)->lpVtbl -> GetBufferProgress(This,pdwPercent,pcnsBuffering)

#define IWMReaderAdvanced3_GetDownloadProgress(This,pdwPercent,pqwBytesDownloaded,pcnsDownload)	\
    (This)->lpVtbl -> GetDownloadProgress(This,pdwPercent,pqwBytesDownloaded,pcnsDownload)

#define IWMReaderAdvanced3_GetSaveAsProgress(This,pdwPercent)	\
    (This)->lpVtbl -> GetSaveAsProgress(This,pdwPercent)

#define IWMReaderAdvanced3_SaveFileAs(This,pwszFilename)	\
    (This)->lpVtbl -> SaveFileAs(This,pwszFilename)

#define IWMReaderAdvanced3_GetProtocolName(This,pwszProtocol,pcchProtocol)	\
    (This)->lpVtbl -> GetProtocolName(This,pwszProtocol,pcchProtocol)

#define IWMReaderAdvanced3_StartAtMarker(This,wMarkerIndex,cnsDuration,fRate,pvContext)	\
    (This)->lpVtbl -> StartAtMarker(This,wMarkerIndex,cnsDuration,fRate,pvContext)

#define IWMReaderAdvanced3_GetOutputSetting(This,dwOutputNum,pszName,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetOutputSetting(This,dwOutputNum,pszName,pType,pValue,pcbLength)

#define IWMReaderAdvanced3_SetOutputSetting(This,dwOutputNum,pszName,Type,pValue,cbLength)	\
    (This)->lpVtbl -> SetOutputSetting(This,dwOutputNum,pszName,Type,pValue,cbLength)

#define IWMReaderAdvanced3_Preroll(This,cnsStart,cnsDuration,fRate)	\
    (This)->lpVtbl -> Preroll(This,cnsStart,cnsDuration,fRate)

#define IWMReaderAdvanced3_SetLogClientID(This,fLogClientID)	\
    (This)->lpVtbl -> SetLogClientID(This,fLogClientID)

#define IWMReaderAdvanced3_GetLogClientID(This,pfLogClientID)	\
    (This)->lpVtbl -> GetLogClientID(This,pfLogClientID)

#define IWMReaderAdvanced3_StopBuffering(This)	\
    (This)->lpVtbl -> StopBuffering(This)

#define IWMReaderAdvanced3_OpenStream(This,pStream,pCallback,pvContext)	\
    (This)->lpVtbl -> OpenStream(This,pStream,pCallback,pvContext)


#define IWMReaderAdvanced3_StopNetStreaming(This)	\
    (This)->lpVtbl -> StopNetStreaming(This)

#define IWMReaderAdvanced3_StartAtPosition(This,wStreamNum,pvOffsetStart,pvDuration,dwOffsetFormat,fRate,pvContext)	\
    (This)->lpVtbl -> StartAtPosition(This,wStreamNum,pvOffsetStart,pvDuration,dwOffsetFormat,fRate,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderAdvanced3_StopNetStreaming_Proxy( 
    IWMReaderAdvanced3 __RPC_FAR * This);


void __RPC_STUB IWMReaderAdvanced3_StopNetStreaming_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced3_StartAtPosition_Proxy( 
    IWMReaderAdvanced3 __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ void __RPC_FAR *pvOffsetStart,
    /* [in] */ void __RPC_FAR *pvDuration,
    /* [in] */ WMT_OFFSET_FORMAT dwOffsetFormat,
    /* [in] */ float fRate,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderAdvanced3_StartAtPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderAdvanced3_INTERFACE_DEFINED__ */


#ifndef __IWMReaderAllocatorEx_INTERFACE_DEFINED__
#define __IWMReaderAllocatorEx_INTERFACE_DEFINED__

/* interface IWMReaderAllocatorEx */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderAllocatorEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9F762FA7-A22E-428d-93C9-AC82F3AAFE5A")
    IWMReaderAllocatorEx : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AllocateForStreamEx( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ DWORD dwFlags,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateForOutputEx( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ DWORD dwFlags,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderAllocatorExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReaderAllocatorEx __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReaderAllocatorEx __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReaderAllocatorEx __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateForStreamEx )( 
            IWMReaderAllocatorEx __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ DWORD dwFlags,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateForOutputEx )( 
            IWMReaderAllocatorEx __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ DWORD dwFlags,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ void __RPC_FAR *pvContext);
        
        END_INTERFACE
    } IWMReaderAllocatorExVtbl;

    interface IWMReaderAllocatorEx
    {
        CONST_VTBL struct IWMReaderAllocatorExVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderAllocatorEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderAllocatorEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderAllocatorEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderAllocatorEx_AllocateForStreamEx(This,wStreamNum,cbBuffer,ppBuffer,dwFlags,cnsSampleTime,cnsSampleDuration,pvContext)	\
    (This)->lpVtbl -> AllocateForStreamEx(This,wStreamNum,cbBuffer,ppBuffer,dwFlags,cnsSampleTime,cnsSampleDuration,pvContext)

#define IWMReaderAllocatorEx_AllocateForOutputEx(This,dwOutputNum,cbBuffer,ppBuffer,dwFlags,cnsSampleTime,cnsSampleDuration,pvContext)	\
    (This)->lpVtbl -> AllocateForOutputEx(This,dwOutputNum,cbBuffer,ppBuffer,dwFlags,cnsSampleTime,cnsSampleDuration,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderAllocatorEx_AllocateForStreamEx_Proxy( 
    IWMReaderAllocatorEx __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ DWORD cbBuffer,
    /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
    /* [in] */ DWORD dwFlags,
    /* [in] */ QWORD cnsSampleTime,
    /* [in] */ QWORD cnsSampleDuration,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderAllocatorEx_AllocateForStreamEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAllocatorEx_AllocateForOutputEx_Proxy( 
    IWMReaderAllocatorEx __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ DWORD cbBuffer,
    /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
    /* [in] */ DWORD dwFlags,
    /* [in] */ QWORD cnsSampleTime,
    /* [in] */ QWORD cnsSampleDuration,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderAllocatorEx_AllocateForOutputEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderAllocatorEx_INTERFACE_DEFINED__ */


#ifndef __IWMReaderTypeNegotiation_INTERFACE_DEFINED__
#define __IWMReaderTypeNegotiation_INTERFACE_DEFINED__

/* interface IWMReaderTypeNegotiation */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderTypeNegotiation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FDBE5592-81A1-41ea-93BD-735CAD1ADC05")
    IWMReaderTypeNegotiation : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE TryOutputProps( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ IWMOutputMediaProps __RPC_FAR *pOutput) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderTypeNegotiationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReaderTypeNegotiation __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReaderTypeNegotiation __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReaderTypeNegotiation __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TryOutputProps )( 
            IWMReaderTypeNegotiation __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ IWMOutputMediaProps __RPC_FAR *pOutput);
        
        END_INTERFACE
    } IWMReaderTypeNegotiationVtbl;

    interface IWMReaderTypeNegotiation
    {
        CONST_VTBL struct IWMReaderTypeNegotiationVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderTypeNegotiation_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderTypeNegotiation_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderTypeNegotiation_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderTypeNegotiation_TryOutputProps(This,dwOutputNum,pOutput)	\
    (This)->lpVtbl -> TryOutputProps(This,dwOutputNum,pOutput)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderTypeNegotiation_TryOutputProps_Proxy( 
    IWMReaderTypeNegotiation __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ IWMOutputMediaProps __RPC_FAR *pOutput);


void __RPC_STUB IWMReaderTypeNegotiation_TryOutputProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderTypeNegotiation_INTERFACE_DEFINED__ */


#ifndef __IWMReaderCallbackAdvanced_INTERFACE_DEFINED__
#define __IWMReaderCallbackAdvanced_INTERFACE_DEFINED__

/* interface IWMReaderCallbackAdvanced */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderCallbackAdvanced;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BEB-2B2B-11d3-B36B-00C04F6108FF")
    IWMReaderCallbackAdvanced : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnStreamSample( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnTime( 
            /* [in] */ QWORD cnsCurrentTime,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnStreamSelection( 
            /* [in] */ WORD wStreamCount,
            /* [in] */ WORD __RPC_FAR *pStreamNumbers,
            /* [in] */ WMT_STREAM_SELECTION __RPC_FAR *pSelections,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnOutputPropsChanged( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ WM_MEDIA_TYPE __RPC_FAR *pMediaType,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateForStream( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateForOutput( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderCallbackAdvancedVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStreamSample )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnTime )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This,
            /* [in] */ QWORD cnsCurrentTime,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStreamSelection )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This,
            /* [in] */ WORD wStreamCount,
            /* [in] */ WORD __RPC_FAR *pStreamNumbers,
            /* [in] */ WMT_STREAM_SELECTION __RPC_FAR *pSelections,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnOutputPropsChanged )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ WM_MEDIA_TYPE __RPC_FAR *pMediaType,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateForStream )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateForOutput )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ void __RPC_FAR *pvContext);
        
        END_INTERFACE
    } IWMReaderCallbackAdvancedVtbl;

    interface IWMReaderCallbackAdvanced
    {
        CONST_VTBL struct IWMReaderCallbackAdvancedVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderCallbackAdvanced_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderCallbackAdvanced_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderCallbackAdvanced_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderCallbackAdvanced_OnStreamSample(This,wStreamNum,cnsSampleTime,cnsSampleDuration,dwFlags,pSample,pvContext)	\
    (This)->lpVtbl -> OnStreamSample(This,wStreamNum,cnsSampleTime,cnsSampleDuration,dwFlags,pSample,pvContext)

#define IWMReaderCallbackAdvanced_OnTime(This,cnsCurrentTime,pvContext)	\
    (This)->lpVtbl -> OnTime(This,cnsCurrentTime,pvContext)

#define IWMReaderCallbackAdvanced_OnStreamSelection(This,wStreamCount,pStreamNumbers,pSelections,pvContext)	\
    (This)->lpVtbl -> OnStreamSelection(This,wStreamCount,pStreamNumbers,pSelections,pvContext)

#define IWMReaderCallbackAdvanced_OnOutputPropsChanged(This,dwOutputNum,pMediaType,pvContext)	\
    (This)->lpVtbl -> OnOutputPropsChanged(This,dwOutputNum,pMediaType,pvContext)

#define IWMReaderCallbackAdvanced_AllocateForStream(This,wStreamNum,cbBuffer,ppBuffer,pvContext)	\
    (This)->lpVtbl -> AllocateForStream(This,wStreamNum,cbBuffer,ppBuffer,pvContext)

#define IWMReaderCallbackAdvanced_AllocateForOutput(This,dwOutputNum,cbBuffer,ppBuffer,pvContext)	\
    (This)->lpVtbl -> AllocateForOutput(This,dwOutputNum,cbBuffer,ppBuffer,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderCallbackAdvanced_OnStreamSample_Proxy( 
    IWMReaderCallbackAdvanced __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ QWORD cnsSampleTime,
    /* [in] */ QWORD cnsSampleDuration,
    /* [in] */ DWORD dwFlags,
    /* [in] */ INSSBuffer __RPC_FAR *pSample,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderCallbackAdvanced_OnStreamSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderCallbackAdvanced_OnTime_Proxy( 
    IWMReaderCallbackAdvanced __RPC_FAR * This,
    /* [in] */ QWORD cnsCurrentTime,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderCallbackAdvanced_OnTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderCallbackAdvanced_OnStreamSelection_Proxy( 
    IWMReaderCallbackAdvanced __RPC_FAR * This,
    /* [in] */ WORD wStreamCount,
    /* [in] */ WORD __RPC_FAR *pStreamNumbers,
    /* [in] */ WMT_STREAM_SELECTION __RPC_FAR *pSelections,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderCallbackAdvanced_OnStreamSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderCallbackAdvanced_OnOutputPropsChanged_Proxy( 
    IWMReaderCallbackAdvanced __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ WM_MEDIA_TYPE __RPC_FAR *pMediaType,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderCallbackAdvanced_OnOutputPropsChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderCallbackAdvanced_AllocateForStream_Proxy( 
    IWMReaderCallbackAdvanced __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ DWORD cbBuffer,
    /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderCallbackAdvanced_AllocateForStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderCallbackAdvanced_AllocateForOutput_Proxy( 
    IWMReaderCallbackAdvanced __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ DWORD cbBuffer,
    /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderCallbackAdvanced_AllocateForOutput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderCallbackAdvanced_INTERFACE_DEFINED__ */


#ifndef __IWMDRMReader_INTERFACE_DEFINED__
#define __IWMDRMReader_INTERFACE_DEFINED__

/* interface IWMDRMReader */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMDRMReader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D2827540-3EE7-432c-B14C-DC17F085D3B3")
    IWMDRMReader : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AcquireLicense( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelLicenseAcquisition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Individualize( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelIndividualization( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MonitorLicenseAcquisition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelMonitorLicenseAcquisition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDRMProperty( 
            /* [in] */ LPCWSTR pwstrName,
            /* [in] */ WMT_ATTR_DATATYPE dwType,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDRMProperty( 
            /* [in] */ LPCWSTR pwstrName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pdwType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out] */ WORD __RPC_FAR *pcbLength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDRMReaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDRMReader __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDRMReader __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDRMReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AcquireLicense )( 
            IWMDRMReader __RPC_FAR * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CancelLicenseAcquisition )( 
            IWMDRMReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Individualize )( 
            IWMDRMReader __RPC_FAR * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CancelIndividualization )( 
            IWMDRMReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MonitorLicenseAcquisition )( 
            IWMDRMReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CancelMonitorLicenseAcquisition )( 
            IWMDRMReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDRMProperty )( 
            IWMDRMReader __RPC_FAR * This,
            /* [in] */ LPCWSTR pwstrName,
            /* [in] */ WMT_ATTR_DATATYPE dwType,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDRMProperty )( 
            IWMDRMReader __RPC_FAR * This,
            /* [in] */ LPCWSTR pwstrName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pdwType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out] */ WORD __RPC_FAR *pcbLength);
        
        END_INTERFACE
    } IWMDRMReaderVtbl;

    interface IWMDRMReader
    {
        CONST_VTBL struct IWMDRMReaderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDRMReader_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDRMReader_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDRMReader_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDRMReader_AcquireLicense(This,dwFlags)	\
    (This)->lpVtbl -> AcquireLicense(This,dwFlags)

#define IWMDRMReader_CancelLicenseAcquisition(This)	\
    (This)->lpVtbl -> CancelLicenseAcquisition(This)

#define IWMDRMReader_Individualize(This,dwFlags)	\
    (This)->lpVtbl -> Individualize(This,dwFlags)

#define IWMDRMReader_CancelIndividualization(This)	\
    (This)->lpVtbl -> CancelIndividualization(This)

#define IWMDRMReader_MonitorLicenseAcquisition(This)	\
    (This)->lpVtbl -> MonitorLicenseAcquisition(This)

#define IWMDRMReader_CancelMonitorLicenseAcquisition(This)	\
    (This)->lpVtbl -> CancelMonitorLicenseAcquisition(This)

#define IWMDRMReader_SetDRMProperty(This,pwstrName,dwType,pValue,cbLength)	\
    (This)->lpVtbl -> SetDRMProperty(This,pwstrName,dwType,pValue,cbLength)

#define IWMDRMReader_GetDRMProperty(This,pwstrName,pdwType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetDRMProperty(This,pwstrName,pdwType,pValue,pcbLength)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDRMReader_AcquireLicense_Proxy( 
    IWMDRMReader __RPC_FAR * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IWMDRMReader_AcquireLicense_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMReader_CancelLicenseAcquisition_Proxy( 
    IWMDRMReader __RPC_FAR * This);


void __RPC_STUB IWMDRMReader_CancelLicenseAcquisition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMReader_Individualize_Proxy( 
    IWMDRMReader __RPC_FAR * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IWMDRMReader_Individualize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMReader_CancelIndividualization_Proxy( 
    IWMDRMReader __RPC_FAR * This);


void __RPC_STUB IWMDRMReader_CancelIndividualization_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMReader_MonitorLicenseAcquisition_Proxy( 
    IWMDRMReader __RPC_FAR * This);


void __RPC_STUB IWMDRMReader_MonitorLicenseAcquisition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMReader_CancelMonitorLicenseAcquisition_Proxy( 
    IWMDRMReader __RPC_FAR * This);


void __RPC_STUB IWMDRMReader_CancelMonitorLicenseAcquisition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMReader_SetDRMProperty_Proxy( 
    IWMDRMReader __RPC_FAR * This,
    /* [in] */ LPCWSTR pwstrName,
    /* [in] */ WMT_ATTR_DATATYPE dwType,
    /* [in] */ const BYTE __RPC_FAR *pValue,
    /* [in] */ WORD cbLength);


void __RPC_STUB IWMDRMReader_SetDRMProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMReader_GetDRMProperty_Proxy( 
    IWMDRMReader __RPC_FAR * This,
    /* [in] */ LPCWSTR pwstrName,
    /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pdwType,
    /* [out] */ BYTE __RPC_FAR *pValue,
    /* [out] */ WORD __RPC_FAR *pcbLength);


void __RPC_STUB IWMDRMReader_GetDRMProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDRMReader_INTERFACE_DEFINED__ */


#ifndef __IWMReaderNetworkConfig_INTERFACE_DEFINED__
#define __IWMReaderNetworkConfig_INTERFACE_DEFINED__

/* interface IWMReaderNetworkConfig */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderNetworkConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BEC-2B2B-11d3-B36B-00C04F6108FF")
    IWMReaderNetworkConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetBufferingTime( 
            /* [out] */ QWORD __RPC_FAR *pcnsBufferingTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBufferingTime( 
            /* [in] */ QWORD cnsBufferingTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUDPPortRanges( 
            /* [out] */ WM_PORT_NUMBER_RANGE __RPC_FAR *pRangeArray,
            /* [out][in] */ DWORD __RPC_FAR *pcRanges) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUDPPortRanges( 
            /* [in] */ WM_PORT_NUMBER_RANGE __RPC_FAR *pRangeArray,
            /* [in] */ DWORD cRanges) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProxySettings( 
            LPCWSTR pwszProtocol,
            WMT_PROXY_SETTINGS __RPC_FAR *pProxySetting) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProxySettings( 
            LPCWSTR pwszProtocol,
            WMT_PROXY_SETTINGS ProxySetting) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProxyHostName( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ WCHAR __RPC_FAR *pwszHostName,
            /* [out][in] */ DWORD __RPC_FAR *pcchHostName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProxyHostName( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ LPCWSTR pwszHostName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProxyPort( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ DWORD __RPC_FAR *pdwPort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProxyPort( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ DWORD dwPort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProxyExceptionList( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ WCHAR __RPC_FAR *pwszExceptionList,
            /* [out][in] */ DWORD __RPC_FAR *pcchExceptionList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProxyExceptionList( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ LPCWSTR pwszExceptionList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProxyBypassForLocal( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ BOOL __RPC_FAR *pfBypassForLocal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProxyBypassForLocal( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ BOOL fBypassForLocal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetForceRerunAutoProxyDetection( 
            /* [out] */ BOOL __RPC_FAR *pfForceRerunDetection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetForceRerunAutoProxyDetection( 
            /* [in] */ BOOL fForceRerunDetection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnableMulticast( 
            /* [out] */ BOOL __RPC_FAR *pfEnableMulticast) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnableMulticast( 
            /* [in] */ BOOL fEnableMulticast) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnableHTTP( 
            /* [out] */ BOOL __RPC_FAR *pfEnableHTTP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnableHTTP( 
            /* [in] */ BOOL fEnableHTTP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnableUDP( 
            /* [out] */ BOOL __RPC_FAR *pfEnableUDP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnableUDP( 
            /* [in] */ BOOL fEnableUDP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnableTCP( 
            /* [out] */ BOOL __RPC_FAR *pfEnableTCP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnableTCP( 
            /* [in] */ BOOL fEnableTCP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetProtocolRollover( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConnectionBandwidth( 
            /* [out] */ DWORD __RPC_FAR *pdwConnectionBandwidth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConnectionBandwidth( 
            /* [in] */ DWORD dwConnectionBandwidth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNumProtocolsSupported( 
            /* [out] */ DWORD __RPC_FAR *pcProtocols) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSupportedProtocolName( 
            /* [in] */ DWORD dwProtocolNum,
            /* [out] */ WCHAR __RPC_FAR *pwszProtocolName,
            /* [out][in] */ DWORD __RPC_FAR *pcchProtocolName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddLoggingUrl( 
            /* [in] */ LPCWSTR pwszUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLoggingUrl( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ LPWSTR pwszUrl,
            /* [out][in] */ DWORD __RPC_FAR *pcchUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLoggingUrlCount( 
            /* [out] */ DWORD __RPC_FAR *pdwUrlCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetLoggingUrlList( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderNetworkConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReaderNetworkConfig __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReaderNetworkConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferingTime )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ QWORD __RPC_FAR *pcnsBufferingTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBufferingTime )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ QWORD cnsBufferingTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetUDPPortRanges )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ WM_PORT_NUMBER_RANGE __RPC_FAR *pRangeArray,
            /* [out][in] */ DWORD __RPC_FAR *pcRanges);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetUDPPortRanges )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ WM_PORT_NUMBER_RANGE __RPC_FAR *pRangeArray,
            /* [in] */ DWORD cRanges);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProxySettings )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            LPCWSTR pwszProtocol,
            WMT_PROXY_SETTINGS __RPC_FAR *pProxySetting);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProxySettings )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            LPCWSTR pwszProtocol,
            WMT_PROXY_SETTINGS ProxySetting);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProxyHostName )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ WCHAR __RPC_FAR *pwszHostName,
            /* [out][in] */ DWORD __RPC_FAR *pcchHostName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProxyHostName )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ LPCWSTR pwszHostName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProxyPort )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ DWORD __RPC_FAR *pdwPort);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProxyPort )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ DWORD dwPort);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProxyExceptionList )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ WCHAR __RPC_FAR *pwszExceptionList,
            /* [out][in] */ DWORD __RPC_FAR *pcchExceptionList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProxyExceptionList )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ LPCWSTR pwszExceptionList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProxyBypassForLocal )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ BOOL __RPC_FAR *pfBypassForLocal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProxyBypassForLocal )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ BOOL fBypassForLocal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetForceRerunAutoProxyDetection )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfForceRerunDetection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetForceRerunAutoProxyDetection )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ BOOL fForceRerunDetection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEnableMulticast )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfEnableMulticast);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEnableMulticast )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ BOOL fEnableMulticast);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEnableHTTP )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfEnableHTTP);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEnableHTTP )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ BOOL fEnableHTTP);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEnableUDP )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfEnableUDP);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEnableUDP )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ BOOL fEnableUDP);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEnableTCP )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfEnableTCP);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEnableTCP )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ BOOL fEnableTCP);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetProtocolRollover )( 
            IWMReaderNetworkConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConnectionBandwidth )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwConnectionBandwidth);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetConnectionBandwidth )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ DWORD dwConnectionBandwidth);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNumProtocolsSupported )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcProtocols);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSupportedProtocolName )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ DWORD dwProtocolNum,
            /* [out] */ WCHAR __RPC_FAR *pwszProtocolName,
            /* [out][in] */ DWORD __RPC_FAR *pcchProtocolName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddLoggingUrl )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszUrl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLoggingUrl )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ LPWSTR pwszUrl,
            /* [out][in] */ DWORD __RPC_FAR *pcchUrl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLoggingUrlCount )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwUrlCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetLoggingUrlList )( 
            IWMReaderNetworkConfig __RPC_FAR * This);
        
        END_INTERFACE
    } IWMReaderNetworkConfigVtbl;

    interface IWMReaderNetworkConfig
    {
        CONST_VTBL struct IWMReaderNetworkConfigVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderNetworkConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderNetworkConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderNetworkConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderNetworkConfig_GetBufferingTime(This,pcnsBufferingTime)	\
    (This)->lpVtbl -> GetBufferingTime(This,pcnsBufferingTime)

#define IWMReaderNetworkConfig_SetBufferingTime(This,cnsBufferingTime)	\
    (This)->lpVtbl -> SetBufferingTime(This,cnsBufferingTime)

#define IWMReaderNetworkConfig_GetUDPPortRanges(This,pRangeArray,pcRanges)	\
    (This)->lpVtbl -> GetUDPPortRanges(This,pRangeArray,pcRanges)

#define IWMReaderNetworkConfig_SetUDPPortRanges(This,pRangeArray,cRanges)	\
    (This)->lpVtbl -> SetUDPPortRanges(This,pRangeArray,cRanges)

#define IWMReaderNetworkConfig_GetProxySettings(This,pwszProtocol,pProxySetting)	\
    (This)->lpVtbl -> GetProxySettings(This,pwszProtocol,pProxySetting)

#define IWMReaderNetworkConfig_SetProxySettings(This,pwszProtocol,ProxySetting)	\
    (This)->lpVtbl -> SetProxySettings(This,pwszProtocol,ProxySetting)

#define IWMReaderNetworkConfig_GetProxyHostName(This,pwszProtocol,pwszHostName,pcchHostName)	\
    (This)->lpVtbl -> GetProxyHostName(This,pwszProtocol,pwszHostName,pcchHostName)

#define IWMReaderNetworkConfig_SetProxyHostName(This,pwszProtocol,pwszHostName)	\
    (This)->lpVtbl -> SetProxyHostName(This,pwszProtocol,pwszHostName)

#define IWMReaderNetworkConfig_GetProxyPort(This,pwszProtocol,pdwPort)	\
    (This)->lpVtbl -> GetProxyPort(This,pwszProtocol,pdwPort)

#define IWMReaderNetworkConfig_SetProxyPort(This,pwszProtocol,dwPort)	\
    (This)->lpVtbl -> SetProxyPort(This,pwszProtocol,dwPort)

#define IWMReaderNetworkConfig_GetProxyExceptionList(This,pwszProtocol,pwszExceptionList,pcchExceptionList)	\
    (This)->lpVtbl -> GetProxyExceptionList(This,pwszProtocol,pwszExceptionList,pcchExceptionList)

#define IWMReaderNetworkConfig_SetProxyExceptionList(This,pwszProtocol,pwszExceptionList)	\
    (This)->lpVtbl -> SetProxyExceptionList(This,pwszProtocol,pwszExceptionList)

#define IWMReaderNetworkConfig_GetProxyBypassForLocal(This,pwszProtocol,pfBypassForLocal)	\
    (This)->lpVtbl -> GetProxyBypassForLocal(This,pwszProtocol,pfBypassForLocal)

#define IWMReaderNetworkConfig_SetProxyBypassForLocal(This,pwszProtocol,fBypassForLocal)	\
    (This)->lpVtbl -> SetProxyBypassForLocal(This,pwszProtocol,fBypassForLocal)

#define IWMReaderNetworkConfig_GetForceRerunAutoProxyDetection(This,pfForceRerunDetection)	\
    (This)->lpVtbl -> GetForceRerunAutoProxyDetection(This,pfForceRerunDetection)

#define IWMReaderNetworkConfig_SetForceRerunAutoProxyDetection(This,fForceRerunDetection)	\
    (This)->lpVtbl -> SetForceRerunAutoProxyDetection(This,fForceRerunDetection)

#define IWMReaderNetworkConfig_GetEnableMulticast(This,pfEnableMulticast)	\
    (This)->lpVtbl -> GetEnableMulticast(This,pfEnableMulticast)

#define IWMReaderNetworkConfig_SetEnableMulticast(This,fEnableMulticast)	\
    (This)->lpVtbl -> SetEnableMulticast(This,fEnableMulticast)

#define IWMReaderNetworkConfig_GetEnableHTTP(This,pfEnableHTTP)	\
    (This)->lpVtbl -> GetEnableHTTP(This,pfEnableHTTP)

#define IWMReaderNetworkConfig_SetEnableHTTP(This,fEnableHTTP)	\
    (This)->lpVtbl -> SetEnableHTTP(This,fEnableHTTP)

#define IWMReaderNetworkConfig_GetEnableUDP(This,pfEnableUDP)	\
    (This)->lpVtbl -> GetEnableUDP(This,pfEnableUDP)

#define IWMReaderNetworkConfig_SetEnableUDP(This,fEnableUDP)	\
    (This)->lpVtbl -> SetEnableUDP(This,fEnableUDP)

#define IWMReaderNetworkConfig_GetEnableTCP(This,pfEnableTCP)	\
    (This)->lpVtbl -> GetEnableTCP(This,pfEnableTCP)

#define IWMReaderNetworkConfig_SetEnableTCP(This,fEnableTCP)	\
    (This)->lpVtbl -> SetEnableTCP(This,fEnableTCP)

#define IWMReaderNetworkConfig_ResetProtocolRollover(This)	\
    (This)->lpVtbl -> ResetProtocolRollover(This)

#define IWMReaderNetworkConfig_GetConnectionBandwidth(This,pdwConnectionBandwidth)	\
    (This)->lpVtbl -> GetConnectionBandwidth(This,pdwConnectionBandwidth)

#define IWMReaderNetworkConfig_SetConnectionBandwidth(This,dwConnectionBandwidth)	\
    (This)->lpVtbl -> SetConnectionBandwidth(This,dwConnectionBandwidth)

#define IWMReaderNetworkConfig_GetNumProtocolsSupported(This,pcProtocols)	\
    (This)->lpVtbl -> GetNumProtocolsSupported(This,pcProtocols)

#define IWMReaderNetworkConfig_GetSupportedProtocolName(This,dwProtocolNum,pwszProtocolName,pcchProtocolName)	\
    (This)->lpVtbl -> GetSupportedProtocolName(This,dwProtocolNum,pwszProtocolName,pcchProtocolName)

#define IWMReaderNetworkConfig_AddLoggingUrl(This,pwszUrl)	\
    (This)->lpVtbl -> AddLoggingUrl(This,pwszUrl)

#define IWMReaderNetworkConfig_GetLoggingUrl(This,dwIndex,pwszUrl,pcchUrl)	\
    (This)->lpVtbl -> GetLoggingUrl(This,dwIndex,pwszUrl,pcchUrl)

#define IWMReaderNetworkConfig_GetLoggingUrlCount(This,pdwUrlCount)	\
    (This)->lpVtbl -> GetLoggingUrlCount(This,pdwUrlCount)

#define IWMReaderNetworkConfig_ResetLoggingUrlList(This)	\
    (This)->lpVtbl -> ResetLoggingUrlList(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetBufferingTime_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ QWORD __RPC_FAR *pcnsBufferingTime);


void __RPC_STUB IWMReaderNetworkConfig_GetBufferingTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetBufferingTime_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ QWORD cnsBufferingTime);


void __RPC_STUB IWMReaderNetworkConfig_SetBufferingTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetUDPPortRanges_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ WM_PORT_NUMBER_RANGE __RPC_FAR *pRangeArray,
    /* [out][in] */ DWORD __RPC_FAR *pcRanges);


void __RPC_STUB IWMReaderNetworkConfig_GetUDPPortRanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetUDPPortRanges_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ WM_PORT_NUMBER_RANGE __RPC_FAR *pRangeArray,
    /* [in] */ DWORD cRanges);


void __RPC_STUB IWMReaderNetworkConfig_SetUDPPortRanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetProxySettings_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    LPCWSTR pwszProtocol,
    WMT_PROXY_SETTINGS __RPC_FAR *pProxySetting);


void __RPC_STUB IWMReaderNetworkConfig_GetProxySettings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetProxySettings_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    LPCWSTR pwszProtocol,
    WMT_PROXY_SETTINGS ProxySetting);


void __RPC_STUB IWMReaderNetworkConfig_SetProxySettings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetProxyHostName_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [out] */ WCHAR __RPC_FAR *pwszHostName,
    /* [out][in] */ DWORD __RPC_FAR *pcchHostName);


void __RPC_STUB IWMReaderNetworkConfig_GetProxyHostName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetProxyHostName_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [in] */ LPCWSTR pwszHostName);


void __RPC_STUB IWMReaderNetworkConfig_SetProxyHostName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetProxyPort_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [out] */ DWORD __RPC_FAR *pdwPort);


void __RPC_STUB IWMReaderNetworkConfig_GetProxyPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetProxyPort_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [in] */ DWORD dwPort);


void __RPC_STUB IWMReaderNetworkConfig_SetProxyPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetProxyExceptionList_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [out] */ WCHAR __RPC_FAR *pwszExceptionList,
    /* [out][in] */ DWORD __RPC_FAR *pcchExceptionList);


void __RPC_STUB IWMReaderNetworkConfig_GetProxyExceptionList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetProxyExceptionList_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [in] */ LPCWSTR pwszExceptionList);


void __RPC_STUB IWMReaderNetworkConfig_SetProxyExceptionList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetProxyBypassForLocal_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [out] */ BOOL __RPC_FAR *pfBypassForLocal);


void __RPC_STUB IWMReaderNetworkConfig_GetProxyBypassForLocal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetProxyBypassForLocal_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [in] */ BOOL fBypassForLocal);


void __RPC_STUB IWMReaderNetworkConfig_SetProxyBypassForLocal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetForceRerunAutoProxyDetection_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfForceRerunDetection);


void __RPC_STUB IWMReaderNetworkConfig_GetForceRerunAutoProxyDetection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetForceRerunAutoProxyDetection_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ BOOL fForceRerunDetection);


void __RPC_STUB IWMReaderNetworkConfig_SetForceRerunAutoProxyDetection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetEnableMulticast_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfEnableMulticast);


void __RPC_STUB IWMReaderNetworkConfig_GetEnableMulticast_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetEnableMulticast_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ BOOL fEnableMulticast);


void __RPC_STUB IWMReaderNetworkConfig_SetEnableMulticast_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetEnableHTTP_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfEnableHTTP);


void __RPC_STUB IWMReaderNetworkConfig_GetEnableHTTP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetEnableHTTP_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ BOOL fEnableHTTP);


void __RPC_STUB IWMReaderNetworkConfig_SetEnableHTTP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetEnableUDP_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfEnableUDP);


void __RPC_STUB IWMReaderNetworkConfig_GetEnableUDP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetEnableUDP_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ BOOL fEnableUDP);


void __RPC_STUB IWMReaderNetworkConfig_SetEnableUDP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetEnableTCP_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfEnableTCP);


void __RPC_STUB IWMReaderNetworkConfig_GetEnableTCP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetEnableTCP_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ BOOL fEnableTCP);


void __RPC_STUB IWMReaderNetworkConfig_SetEnableTCP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_ResetProtocolRollover_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This);


void __RPC_STUB IWMReaderNetworkConfig_ResetProtocolRollover_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetConnectionBandwidth_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwConnectionBandwidth);


void __RPC_STUB IWMReaderNetworkConfig_GetConnectionBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetConnectionBandwidth_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ DWORD dwConnectionBandwidth);


void __RPC_STUB IWMReaderNetworkConfig_SetConnectionBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetNumProtocolsSupported_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcProtocols);


void __RPC_STUB IWMReaderNetworkConfig_GetNumProtocolsSupported_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetSupportedProtocolName_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ DWORD dwProtocolNum,
    /* [out] */ WCHAR __RPC_FAR *pwszProtocolName,
    /* [out][in] */ DWORD __RPC_FAR *pcchProtocolName);


void __RPC_STUB IWMReaderNetworkConfig_GetSupportedProtocolName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_AddLoggingUrl_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszUrl);


void __RPC_STUB IWMReaderNetworkConfig_AddLoggingUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetLoggingUrl_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ DWORD dwIndex,
    /* [out] */ LPWSTR pwszUrl,
    /* [out][in] */ DWORD __RPC_FAR *pcchUrl);


void __RPC_STUB IWMReaderNetworkConfig_GetLoggingUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetLoggingUrlCount_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwUrlCount);


void __RPC_STUB IWMReaderNetworkConfig_GetLoggingUrlCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_ResetLoggingUrlList_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This);


void __RPC_STUB IWMReaderNetworkConfig_ResetLoggingUrlList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderNetworkConfig_INTERFACE_DEFINED__ */


#ifndef __IWMReaderStreamClock_INTERFACE_DEFINED__
#define __IWMReaderStreamClock_INTERFACE_DEFINED__

/* interface IWMReaderStreamClock */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderStreamClock;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BED-2B2B-11d3-B36B-00C04F6108FF")
    IWMReaderStreamClock : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTime( 
            /* [in] */ QWORD __RPC_FAR *pcnsNow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTimer( 
            /* [in] */ QWORD cnsWhen,
            /* [in] */ void __RPC_FAR *pvParam,
            /* [out] */ DWORD __RPC_FAR *pdwTimerId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE KillTimer( 
            /* [in] */ DWORD dwTimerId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderStreamClockVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReaderStreamClock __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReaderStreamClock __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReaderStreamClock __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTime )( 
            IWMReaderStreamClock __RPC_FAR * This,
            /* [in] */ QWORD __RPC_FAR *pcnsNow);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTimer )( 
            IWMReaderStreamClock __RPC_FAR * This,
            /* [in] */ QWORD cnsWhen,
            /* [in] */ void __RPC_FAR *pvParam,
            /* [out] */ DWORD __RPC_FAR *pdwTimerId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *KillTimer )( 
            IWMReaderStreamClock __RPC_FAR * This,
            /* [in] */ DWORD dwTimerId);
        
        END_INTERFACE
    } IWMReaderStreamClockVtbl;

    interface IWMReaderStreamClock
    {
        CONST_VTBL struct IWMReaderStreamClockVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderStreamClock_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderStreamClock_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderStreamClock_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderStreamClock_GetTime(This,pcnsNow)	\
    (This)->lpVtbl -> GetTime(This,pcnsNow)

#define IWMReaderStreamClock_SetTimer(This,cnsWhen,pvParam,pdwTimerId)	\
    (This)->lpVtbl -> SetTimer(This,cnsWhen,pvParam,pdwTimerId)

#define IWMReaderStreamClock_KillTimer(This,dwTimerId)	\
    (This)->lpVtbl -> KillTimer(This,dwTimerId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderStreamClock_GetTime_Proxy( 
    IWMReaderStreamClock __RPC_FAR * This,
    /* [in] */ QWORD __RPC_FAR *pcnsNow);


void __RPC_STUB IWMReaderStreamClock_GetTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderStreamClock_SetTimer_Proxy( 
    IWMReaderStreamClock __RPC_FAR * This,
    /* [in] */ QWORD cnsWhen,
    /* [in] */ void __RPC_FAR *pvParam,
    /* [out] */ DWORD __RPC_FAR *pdwTimerId);


void __RPC_STUB IWMReaderStreamClock_SetTimer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderStreamClock_KillTimer_Proxy( 
    IWMReaderStreamClock __RPC_FAR * This,
    /* [in] */ DWORD dwTimerId);


void __RPC_STUB IWMReaderStreamClock_KillTimer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderStreamClock_INTERFACE_DEFINED__ */


#ifndef __IWMIndexer_INTERFACE_DEFINED__
#define __IWMIndexer_INTERFACE_DEFINED__

/* interface IWMIndexer */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMIndexer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6d7cdc71-9888-11d3-8edc-00c04f6109cf")
    IWMIndexer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StartIndexing( 
            /* [in] */ const WCHAR __RPC_FAR *pwszURL,
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMIndexerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMIndexer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMIndexer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMIndexer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartIndexing )( 
            IWMIndexer __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszURL,
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Cancel )( 
            IWMIndexer __RPC_FAR * This);
        
        END_INTERFACE
    } IWMIndexerVtbl;

    interface IWMIndexer
    {
        CONST_VTBL struct IWMIndexerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMIndexer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMIndexer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMIndexer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMIndexer_StartIndexing(This,pwszURL,pCallback,pvContext)	\
    (This)->lpVtbl -> StartIndexing(This,pwszURL,pCallback,pvContext)

#define IWMIndexer_Cancel(This)	\
    (This)->lpVtbl -> Cancel(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMIndexer_StartIndexing_Proxy( 
    IWMIndexer __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwszURL,
    /* [in] */ IWMStatusCallback __RPC_FAR *pCallback,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMIndexer_StartIndexing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMIndexer_Cancel_Proxy( 
    IWMIndexer __RPC_FAR * This);


void __RPC_STUB IWMIndexer_Cancel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMIndexer_INTERFACE_DEFINED__ */


#ifndef __IWMLicenseBackup_INTERFACE_DEFINED__
#define __IWMLicenseBackup_INTERFACE_DEFINED__

/* interface IWMLicenseBackup */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMLicenseBackup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("05E5AC9F-3FB6-4508-BB43-A4067BA1EBE8")
    IWMLicenseBackup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BackupLicenses( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelLicenseBackup( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMLicenseBackupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMLicenseBackup __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMLicenseBackup __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMLicenseBackup __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BackupLicenses )( 
            IWMLicenseBackup __RPC_FAR * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CancelLicenseBackup )( 
            IWMLicenseBackup __RPC_FAR * This);
        
        END_INTERFACE
    } IWMLicenseBackupVtbl;

    interface IWMLicenseBackup
    {
        CONST_VTBL struct IWMLicenseBackupVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMLicenseBackup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMLicenseBackup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMLicenseBackup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMLicenseBackup_BackupLicenses(This,dwFlags,pCallback)	\
    (This)->lpVtbl -> BackupLicenses(This,dwFlags,pCallback)

#define IWMLicenseBackup_CancelLicenseBackup(This)	\
    (This)->lpVtbl -> CancelLicenseBackup(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMLicenseBackup_BackupLicenses_Proxy( 
    IWMLicenseBackup __RPC_FAR * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IWMStatusCallback __RPC_FAR *pCallback);


void __RPC_STUB IWMLicenseBackup_BackupLicenses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMLicenseBackup_CancelLicenseBackup_Proxy( 
    IWMLicenseBackup __RPC_FAR * This);


void __RPC_STUB IWMLicenseBackup_CancelLicenseBackup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMLicenseBackup_INTERFACE_DEFINED__ */


#ifndef __IWMLicenseRestore_INTERFACE_DEFINED__
#define __IWMLicenseRestore_INTERFACE_DEFINED__

/* interface IWMLicenseRestore */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMLicenseRestore;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C70B6334-0544-4efb-A245-15E65A004A13")
    IWMLicenseRestore : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RestoreLicenses( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelLicenseRestore( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMLicenseRestoreVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMLicenseRestore __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMLicenseRestore __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMLicenseRestore __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RestoreLicenses )( 
            IWMLicenseRestore __RPC_FAR * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CancelLicenseRestore )( 
            IWMLicenseRestore __RPC_FAR * This);
        
        END_INTERFACE
    } IWMLicenseRestoreVtbl;

    interface IWMLicenseRestore
    {
        CONST_VTBL struct IWMLicenseRestoreVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMLicenseRestore_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMLicenseRestore_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMLicenseRestore_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMLicenseRestore_RestoreLicenses(This,dwFlags,pCallback)	\
    (This)->lpVtbl -> RestoreLicenses(This,dwFlags,pCallback)

#define IWMLicenseRestore_CancelLicenseRestore(This)	\
    (This)->lpVtbl -> CancelLicenseRestore(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMLicenseRestore_RestoreLicenses_Proxy( 
    IWMLicenseRestore __RPC_FAR * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IWMStatusCallback __RPC_FAR *pCallback);


void __RPC_STUB IWMLicenseRestore_RestoreLicenses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMLicenseRestore_CancelLicenseRestore_Proxy( 
    IWMLicenseRestore __RPC_FAR * This);


void __RPC_STUB IWMLicenseRestore_CancelLicenseRestore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMLicenseRestore_INTERFACE_DEFINED__ */


#ifndef __IWMBackupRestoreProps_INTERFACE_DEFINED__
#define __IWMBackupRestoreProps_INTERFACE_DEFINED__

/* interface IWMBackupRestoreProps */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMBackupRestoreProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3C8E0DA6-996F-4ff3-A1AF-4838F9377E2E")
    IWMBackupRestoreProps : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPropCount( 
            /* [out] */ WORD __RPC_FAR *pcProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropByIndex( 
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchNameLen,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropByName( 
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProp( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveProp( 
            /* [in] */ LPCWSTR pcwszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAllProps( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMBackupRestorePropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMBackupRestoreProps __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMBackupRestoreProps __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMBackupRestoreProps __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropCount )( 
            IWMBackupRestoreProps __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pcProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropByIndex )( 
            IWMBackupRestoreProps __RPC_FAR * This,
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchNameLen,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropByName )( 
            IWMBackupRestoreProps __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProp )( 
            IWMBackupRestoreProps __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveProp )( 
            IWMBackupRestoreProps __RPC_FAR * This,
            /* [in] */ LPCWSTR pcwszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveAllProps )( 
            IWMBackupRestoreProps __RPC_FAR * This);
        
        END_INTERFACE
    } IWMBackupRestorePropsVtbl;

    interface IWMBackupRestoreProps
    {
        CONST_VTBL struct IWMBackupRestorePropsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMBackupRestoreProps_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMBackupRestoreProps_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMBackupRestoreProps_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMBackupRestoreProps_GetPropCount(This,pcProps)	\
    (This)->lpVtbl -> GetPropCount(This,pcProps)

#define IWMBackupRestoreProps_GetPropByIndex(This,wIndex,pwszName,pcchNameLen,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetPropByIndex(This,wIndex,pwszName,pcchNameLen,pType,pValue,pcbLength)

#define IWMBackupRestoreProps_GetPropByName(This,pszName,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetPropByName(This,pszName,pType,pValue,pcbLength)

#define IWMBackupRestoreProps_SetProp(This,pszName,Type,pValue,cbLength)	\
    (This)->lpVtbl -> SetProp(This,pszName,Type,pValue,cbLength)

#define IWMBackupRestoreProps_RemoveProp(This,pcwszName)	\
    (This)->lpVtbl -> RemoveProp(This,pcwszName)

#define IWMBackupRestoreProps_RemoveAllProps(This)	\
    (This)->lpVtbl -> RemoveAllProps(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMBackupRestoreProps_GetPropCount_Proxy( 
    IWMBackupRestoreProps __RPC_FAR * This,
    /* [out] */ WORD __RPC_FAR *pcProps);


void __RPC_STUB IWMBackupRestoreProps_GetPropCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMBackupRestoreProps_GetPropByIndex_Proxy( 
    IWMBackupRestoreProps __RPC_FAR * This,
    /* [in] */ WORD wIndex,
    /* [out] */ WCHAR __RPC_FAR *pwszName,
    /* [out][in] */ WORD __RPC_FAR *pcchNameLen,
    /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
    /* [out] */ BYTE __RPC_FAR *pValue,
    /* [out][in] */ WORD __RPC_FAR *pcbLength);


void __RPC_STUB IWMBackupRestoreProps_GetPropByIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMBackupRestoreProps_GetPropByName_Proxy( 
    IWMBackupRestoreProps __RPC_FAR * This,
    /* [in] */ LPCWSTR pszName,
    /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
    /* [out] */ BYTE __RPC_FAR *pValue,
    /* [out][in] */ WORD __RPC_FAR *pcbLength);


void __RPC_STUB IWMBackupRestoreProps_GetPropByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMBackupRestoreProps_SetProp_Proxy( 
    IWMBackupRestoreProps __RPC_FAR * This,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ WMT_ATTR_DATATYPE Type,
    /* [in] */ const BYTE __RPC_FAR *pValue,
    /* [in] */ WORD cbLength);


void __RPC_STUB IWMBackupRestoreProps_SetProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMBackupRestoreProps_RemoveProp_Proxy( 
    IWMBackupRestoreProps __RPC_FAR * This,
    /* [in] */ LPCWSTR pcwszName);


void __RPC_STUB IWMBackupRestoreProps_RemoveProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMBackupRestoreProps_RemoveAllProps_Proxy( 
    IWMBackupRestoreProps __RPC_FAR * This);


void __RPC_STUB IWMBackupRestoreProps_RemoveAllProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMBackupRestoreProps_INTERFACE_DEFINED__ */


#ifndef __IWMCodecInfo_INTERFACE_DEFINED__
#define __IWMCodecInfo_INTERFACE_DEFINED__

/* interface IWMCodecInfo */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMCodecInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A970F41E-34DE-4a98-B3BA-E4B3CA7528F0")
    IWMCodecInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCodecInfoCount( 
            /* [in] */ REFGUID guidType,
            /* [out] */ DWORD __RPC_FAR *pcCodecs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodecFormatCount( 
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [out] */ DWORD __RPC_FAR *pcFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodecFormat( 
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [in] */ DWORD dwFormatIndex,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppIStreamConfig) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMCodecInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMCodecInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMCodecInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMCodecInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecInfoCount )( 
            IWMCodecInfo __RPC_FAR * This,
            /* [in] */ REFGUID guidType,
            /* [out] */ DWORD __RPC_FAR *pcCodecs);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecFormatCount )( 
            IWMCodecInfo __RPC_FAR * This,
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [out] */ DWORD __RPC_FAR *pcFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecFormat )( 
            IWMCodecInfo __RPC_FAR * This,
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [in] */ DWORD dwFormatIndex,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppIStreamConfig);
        
        END_INTERFACE
    } IWMCodecInfoVtbl;

    interface IWMCodecInfo
    {
        CONST_VTBL struct IWMCodecInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMCodecInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMCodecInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMCodecInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMCodecInfo_GetCodecInfoCount(This,guidType,pcCodecs)	\
    (This)->lpVtbl -> GetCodecInfoCount(This,guidType,pcCodecs)

#define IWMCodecInfo_GetCodecFormatCount(This,guidType,dwCodecIndex,pcFormat)	\
    (This)->lpVtbl -> GetCodecFormatCount(This,guidType,dwCodecIndex,pcFormat)

#define IWMCodecInfo_GetCodecFormat(This,guidType,dwCodecIndex,dwFormatIndex,ppIStreamConfig)	\
    (This)->lpVtbl -> GetCodecFormat(This,guidType,dwCodecIndex,dwFormatIndex,ppIStreamConfig)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMCodecInfo_GetCodecInfoCount_Proxy( 
    IWMCodecInfo __RPC_FAR * This,
    /* [in] */ REFGUID guidType,
    /* [out] */ DWORD __RPC_FAR *pcCodecs);


void __RPC_STUB IWMCodecInfo_GetCodecInfoCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMCodecInfo_GetCodecFormatCount_Proxy( 
    IWMCodecInfo __RPC_FAR * This,
    /* [in] */ REFGUID guidType,
    /* [in] */ DWORD dwCodecIndex,
    /* [out] */ DWORD __RPC_FAR *pcFormat);


void __RPC_STUB IWMCodecInfo_GetCodecFormatCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMCodecInfo_GetCodecFormat_Proxy( 
    IWMCodecInfo __RPC_FAR * This,
    /* [in] */ REFGUID guidType,
    /* [in] */ DWORD dwCodecIndex,
    /* [in] */ DWORD dwFormatIndex,
    /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppIStreamConfig);


void __RPC_STUB IWMCodecInfo_GetCodecFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMCodecInfo_INTERFACE_DEFINED__ */


#ifndef __IWMCodecInfo2_INTERFACE_DEFINED__
#define __IWMCodecInfo2_INTERFACE_DEFINED__

/* interface IWMCodecInfo2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMCodecInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AA65E273-B686-4056-91EC-DD768D4DF710")
    IWMCodecInfo2 : public IWMCodecInfo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCodecName( 
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [out] */ WCHAR __RPC_FAR *wszName,
            /* [out] */ DWORD __RPC_FAR *pcchName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodecFormatDesc( 
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [in] */ DWORD dwFormatIndex,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppIStreamConfig,
            /* [out] */ WCHAR __RPC_FAR *wszDesc,
            /* [out][in] */ DWORD __RPC_FAR *pcchDesc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMCodecInfo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMCodecInfo2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMCodecInfo2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMCodecInfo2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecInfoCount )( 
            IWMCodecInfo2 __RPC_FAR * This,
            /* [in] */ REFGUID guidType,
            /* [out] */ DWORD __RPC_FAR *pcCodecs);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecFormatCount )( 
            IWMCodecInfo2 __RPC_FAR * This,
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [out] */ DWORD __RPC_FAR *pcFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecFormat )( 
            IWMCodecInfo2 __RPC_FAR * This,
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [in] */ DWORD dwFormatIndex,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppIStreamConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecName )( 
            IWMCodecInfo2 __RPC_FAR * This,
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [out] */ WCHAR __RPC_FAR *wszName,
            /* [out] */ DWORD __RPC_FAR *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecFormatDesc )( 
            IWMCodecInfo2 __RPC_FAR * This,
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [in] */ DWORD dwFormatIndex,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppIStreamConfig,
            /* [out] */ WCHAR __RPC_FAR *wszDesc,
            /* [out][in] */ DWORD __RPC_FAR *pcchDesc);
        
        END_INTERFACE
    } IWMCodecInfo2Vtbl;

    interface IWMCodecInfo2
    {
        CONST_VTBL struct IWMCodecInfo2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMCodecInfo2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMCodecInfo2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMCodecInfo2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMCodecInfo2_GetCodecInfoCount(This,guidType,pcCodecs)	\
    (This)->lpVtbl -> GetCodecInfoCount(This,guidType,pcCodecs)

#define IWMCodecInfo2_GetCodecFormatCount(This,guidType,dwCodecIndex,pcFormat)	\
    (This)->lpVtbl -> GetCodecFormatCount(This,guidType,dwCodecIndex,pcFormat)

#define IWMCodecInfo2_GetCodecFormat(This,guidType,dwCodecIndex,dwFormatIndex,ppIStreamConfig)	\
    (This)->lpVtbl -> GetCodecFormat(This,guidType,dwCodecIndex,dwFormatIndex,ppIStreamConfig)


#define IWMCodecInfo2_GetCodecName(This,guidType,dwCodecIndex,wszName,pcchName)	\
    (This)->lpVtbl -> GetCodecName(This,guidType,dwCodecIndex,wszName,pcchName)

#define IWMCodecInfo2_GetCodecFormatDesc(This,guidType,dwCodecIndex,dwFormatIndex,ppIStreamConfig,wszDesc,pcchDesc)	\
    (This)->lpVtbl -> GetCodecFormatDesc(This,guidType,dwCodecIndex,dwFormatIndex,ppIStreamConfig,wszDesc,pcchDesc)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMCodecInfo2_GetCodecName_Proxy( 
    IWMCodecInfo2 __RPC_FAR * This,
    /* [in] */ REFGUID guidType,
    /* [in] */ DWORD dwCodecIndex,
    /* [out] */ WCHAR __RPC_FAR *wszName,
    /* [out] */ DWORD __RPC_FAR *pcchName);


void __RPC_STUB IWMCodecInfo2_GetCodecName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMCodecInfo2_GetCodecFormatDesc_Proxy( 
    IWMCodecInfo2 __RPC_FAR * This,
    /* [in] */ REFGUID guidType,
    /* [in] */ DWORD dwCodecIndex,
    /* [in] */ DWORD dwFormatIndex,
    /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppIStreamConfig,
    /* [out] */ WCHAR __RPC_FAR *wszDesc,
    /* [out][in] */ DWORD __RPC_FAR *pcchDesc);


void __RPC_STUB IWMCodecInfo2_GetCodecFormatDesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMCodecInfo2_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\reality\misc\dpf.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpf.c
 *  Content:    debugging printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   06-jan-95  craige  initial implementation
 *   03-mar-95  craige  added dprintf2
 *   31-mar-95  craige  add DPFInit to read WIN.INI for [DirectDraw] section;
 *                      added dprintf3
 *   01-apr-95  craige  happy fun joy updated header file
 *   06-apr-95  craige  made stand-alone
 *   18-jun-95  craige  use negative dpf level to display ONLY that level
 *   06-dec-95  jeffno  Changed dprintf to use c-standard variable argument
 *                      list techniques. Also added abs for NT
 *   06-feb-96  colinmc added simple assertion mechanism for DirectDraw
 *   15-apr-96  kipo    added msinternal
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#ifdef NEW_DPF
    #include "newdpf.c"
#else   //use old debug:

    #undef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN
    #include <windows.h>
    #include "dpf.h"
    #include <stdarg.h>

    #ifdef DEBUG

    #define USE_DDASSERT

    extern char * __pszDpfName;

    #ifndef START_STR
	#define START_STR       "DDRAW: "
    #endif
    #ifndef PROF_SECT
	#define PROF_SECT       "DirectDraw"
    #endif

    #define END_STR             "\r\n"

    HWND                hWndListBox;
    LONG                lDebugLevel = 0;

    /*
     * dumpStr
     */
    static void dumpStr( LPSTR str )
    {
	OutputDebugString( str );

	#ifdef DPF_HWND
	    if( hWndListBox != NULL )
	    {
		if( !IsWindow( hWndListBox ) )
		{
		    hWndListBox = NULL;
		}
	    }
	    if( hWndListBox != NULL )
	    {
		UINT    sel;
		int     len;
		len = strlen( str );
		if( len > 0 )
		{
		    if( str[len-1] == '\r' || str[len-1] == '\n' )
		    {
			str[len-1] = 0;
		    }
		    if( len > 1 )
		    {
			if( str[len-2] == '\r' || str[len-2] == '\n' )
			{
			    str[len-2] = 0;
			}
		    }
		}
		SendMessage( hWndListBox, LB_ADDSTRING, 0, (LONG) (LPSTR) str );
		sel = (UINT) SendMessage( hWndListBox, LB_GETCOUNT, 0, 0L );
		if( sel != LB_ERR )
		{
		    SendMessage( hWndListBox, LB_SETCURSEL, sel-1, 0L );
		}
	    }
	#endif

    } /* dumpStr */

    /*
     * dprintf
     */
    void cdecl dprintf( UINT lvl, LPSTR szFormat, ...)
    {
	char    str[256];
	//char  str2[256];

	BOOL    allow = FALSE;
	va_list ap;
	va_start(ap,szFormat);


	if( lDebugLevel < 0 )
	{
	    if(  (UINT) -lDebugLevel == lvl )
	    {
		allow = TRUE;
	    }
	}
	else if( (UINT) lDebugLevel >= lvl )
	{
	    allow = TRUE;
	}

	if( allow )
	{
	    wsprintf ((LPSTR)str, "%s:", __pszDpfName);
	    wvsprintf( str+lstrlen( str ), szFormat, ap);   //(LPVOID)(&szFormat+1) );

	    lstrcat( (LPSTR) str, END_STR );
	    dumpStr( str );
	}

	va_end(ap);
    } /* dprintf */

    /*
     * DPFInit
     */
    void DPFInit( void )
    {
	lDebugLevel = GetProfileInt( __pszDpfName, "debug", 0 );

    } /* DPFInit */

    #ifdef USE_DDASSERT

    /*
     * NOTE: I don't want to get into error checking for buffer overflows when
     * trying to issue an assertion failure message. So instead I just allocate
     * a buffer that is "bug enough" (I know, I know...)
     */
    #define ASSERT_BUFFER_SIZE   512
    #define ASSERT_BANNER_STRING "************************************************************"
    #define ASSERT_BREAK_SECTION "BreakOnAssert"
    #define ASSERT_BREAK_DEFAULT FALSE
    #define ASSERT_MESSAGE_LEVEL 0

    void _DDAssert( LPCSTR szFile, int nLine, LPCSTR szCondition )
    {
	char buffer[ASSERT_BUFFER_SIZE];

	/*
	 * Build the debug stream message.
	 */
	wsprintf( buffer, "ASSERTION FAILED! File %s Line %d: %s", szFile, nLine, szCondition );

	/*
	 * Actually issue the message. These messages are considered error level
	 * so they all go out at error level priority.
	 */
	dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );
	dprintf( ASSERT_MESSAGE_LEVEL, buffer );
	dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );

	/*
	 * Should we drop into the debugger?
	 */
	if( GetProfileInt( __pszDpfName, ASSERT_BREAK_SECTION, ASSERT_BREAK_DEFAULT ) )
	{
	    /*
	     * Into the debugger we go...
	     */
	    DEBUG_BREAK();
	}
    }

    #endif /* USE_DDASSERT */

    #endif
#endif //use new dpf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\reality\misc\lists.h ===
/* Copyright (c) 1997  Microsoft Corporation */
/* See the .C test code at the end of this file for examples of how to use
   this stuff.
*/
#ifndef	_LISTS_H
#define	_LISTS_H

#if __cplusplus
extern "C" {
#endif

#define LIST_ROOT(name, type) struct name {struct type *Root;}

#define LIST_MEMBER(type) struct { struct type **Prev; struct type *Next;}
/* Note!  Prev is the ADDRESS of the previous next element ptr */

#define LIST_INSERT_ROOT(root,element,field)\
{   if(((element)->field.Next = (root)->Root) != 0)\
	(root)->Root->field.Prev = &(element)->field.Next;\
    (root)->Root = (element);\
    (element)->field.Prev = &(root)->Root;\
}

#define LIST_DELETE(element,field)\
{\
    if((element)->field.Next)\
	(element)->field.Next->field.Prev = (element)->field.Prev;\
    *(element)->field.Prev = (element)->field.Next;\
    (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define	LIST_INITIALIZE(root)\
{\
    (root)->Root = 0;\
}

#define LIST_INITIALIZE_MEMBER(element,field)\
{   (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define LIST_ORPHAN_MEMBER(element,field) (!((element)->field.Prev))

#define LIST_FIRST(root) (root)->Root
#define LIST_NEXT(element,field) (element)->field.Next



#define	TAIL_QUEUE_INITIALIZE(root)\
{\
    (root)->First = NULL;\
    (root)->Last = &(root)->First;\
}

#define TAIL_QUEUE_ROOT(name,type)\
struct name\
{   struct type *First;\
    struct type **Last;\
}/* NOTE!  This is the address of the last Next pointer. */


#define TAIL_QUEUE_MEMBER(type)\
struct\
{   struct type *Next;\
    struct type **Prev;	/* NOTE!  Address of previous Next element ptr */\
}

#define TAIL_QUEUE_INSERT_END(root,element,field)\
{   (element)->field.Prev = (root)->Last;\
    (element)->field.Next = 0;\
    *(root)->Last = (element);\
    (root)->Last = &(element)->field.Next;\
}

#define TAIL_QUEUE_DELETE(root,element,field)\
{\
    if (((element)->field.Next) != NULL)\
	(element)->field.Next->field.Prev = (element)->field.Prev;\
    else\
	(root)->Last = (element)->field.Prev;\
    *(element)->field.Prev = (element)->field.Next;\
    (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define TAIL_QUEUE_FIRST(root) (root)->First
#define TAIL_QUEUE_NEXT(element,field) (element)->field.Next



#define CIRCLE_QUEUE_ROOT(name,type)\
struct name\
{   struct type *Last;\
    struct type *First;\
}

#define CIRCLE_QUEUE_MEMBER(type)\
struct\
{   struct type *Prev;\
    struct type *Next;\
}

#define	CIRCLE_QUEUE_INITIALIZE(root,type)\
{   (root)->Last = (type *)(root);\
    (root)->First = (type *)(root);\
}

#define CIRCLE_QUEUE_INITIALIZE_MEMBER(element,field)\
{ (element)->field.Next = (element)->field.Prev = 0;\
}

#define CIRCLE_QUEUE_INSERT_END(root,type,element,field)\
{   (element)->field.Prev = (root)->Last;\
    (element)->field.Next = (type *)(root);\
    if((root)->First != (type *)(root))\
	(root)->Last->field.Next = (element);\
    else\
	(root)->First = (element);\
    (root)->Last = (element);\
}

#define CIRCLE_QUEUE_INSERT_ROOT(root,type,element,field)\
{   (element)->field.Prev = (type *)(root);\
    (element)->field.Next = (root)->First;\
    if ((root)->Last != (void *)(root))\
	(root)->First->field.Prev = (element);\
    else\
	(root)->Last = (element);\
    (root)->First = (element);\
}

#define CIRCLE_QUEUE_INSERT_PREVIOUS(root,current_element,element,field)\
{   (element)->field.Prev = (current_element)->field.Prev;\
    (element)->field.Next = (current_element);\
    if ((current_element)->field.Prev != (void *)(root))\
	(current_element)->field.Prev->field.Next = (element);\
    else\
	(root)->First = (element);\
    (current_element)->field.Prev = (element);\
}

#define	CIRCLE_QUEUE_DELETE(root,element,field)\
{   if((element)->field.Next != (void *)(root))\
	(element)->field.Next->field.Prev = (element)->field.Prev;\
    else\
	(root)->Last = (element)->field.Prev;\
    if((element)->field.Prev != (void *)(root))\
	(element)->field.Prev->field.Next = (element)->field.Next;\
    else\
	(root)->First = (element)->field.Next;\
    (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define CIRCLE_QUEUE_FIRST(root)\
((root)->First == (void *) (root)? 0: (root)->First)

#define CIRCLE_QUEUE_LAST(root)\
((root)->Last == (void *) (root)? 0: (root)->Last)

#define CIRCLE_QUEUE_NEXT(root,element,field)\
((void *) (element)->field.Next == (void *) (root)? 0: (element)->field.Next)

#define CIRCLE_QUEUE_PREVIOUS(root,element,field)\
((element)->field.Prev == (void *) (root)? 0: (element)->field.Prev)

#if 0
/*
Test code.  Strip it out, put it in a .C (or .CPP) file and compile it as a
console app to test this stuff. It should run without any assertion failures.

Also, use this as example code.
*/

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#include "lists.h"

void TestList(void)
{
    struct Foo
    {
	int a;
	LIST_MEMBER(Foo) ListStuff;
	int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    LIST_ROOT(sRoot, Foo) MyListRoot;

    fputs("Testing LIST.\n",stdout);

    LIST_INITIALIZE(&MyListRoot);

    LIST_INITIALIZE_MEMBER(&MyFoo1,ListStuff);
    MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;

    LIST_INITIALIZE_MEMBER(&MyFoo2,ListStuff);
    MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;

    LIST_INITIALIZE_MEMBER(&MyFoo3,ListStuff);
    MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;
    assert(LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));

    LIST_INSERT_ROOT(&MyListRoot,&MyFoo3,ListStuff);
    assert(!LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo2,ListStuff);
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo1,ListStuff);

    assert(!LIST_ORPHAN_MEMBER(&MyFoo1,ListStuff));
    assert(!LIST_ORPHAN_MEMBER(&MyFoo2,ListStuff));
    assert(!LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));

    pFoo = LIST_FIRST(&MyListRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x2A);
    assert(pFoo->b == 0x2B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo == 0);

    /* Delete member 2. */
    pFoo = LIST_FIRST(&MyListRoot);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x2B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Make sure that there are only members 1 and 3 in the list now. */
    pFoo = LIST_FIRST(&MyListRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Delete member 3. */
    pFoo = LIST_FIRST(&MyListRoot);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x3B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Delete member 1. */
    pFoo = LIST_FIRST(&MyListRoot);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);
    assert(LIST_FIRST(&MyListRoot) == 0);

    LIST_INSERT_ROOT(&MyListRoot,&MyFoo2,ListStuff);
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo1,ListStuff);
    
    /* Delete member 1 while there are other members in the list. */
    pFoo = LIST_FIRST(&MyListRoot);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);
    assert(LIST_FIRST(&MyListRoot) == &MyFoo2);

    assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
    assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
    assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);

    fputs("List passed.\n", stdout);
}

void TestTailQueue(void)
{
    struct Foo
    {
	int a;
	TAIL_QUEUE_MEMBER(Foo) TQStuff;
	int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    TAIL_QUEUE_ROOT(sRoot, Foo) MyTQRoot;

    fputs("Testing TAIL_QUEUE.\n",stdout);

    TAIL_QUEUE_INITIALIZE(&MyTQRoot);
    MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;
    MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;
    MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;

    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo1,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo2,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo3,TQStuff);

    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x2A);
    assert(pFoo->b == 0x2B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo == 0);

    /* Delete member 2. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x2B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Make sure that there are only members 1 and 3 in the list now. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Delete member 3. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x3B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Delete member 1. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);
    assert(TAIL_QUEUE_FIRST(&MyTQRoot) == 0);

    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo1,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo2,TQStuff);
    
    /* Delete member 1 while there are other members in the list. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);
    assert(TAIL_QUEUE_FIRST(&MyTQRoot) == &MyFoo2);

    assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
    assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
    assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);

    fputs("Tail Queue passed.\n", stdout);
}
void TestCircleQueue(void)
{
    enum {END,ROOT,PREVIOUS,DONE} WhichInsert = END;
    int i;
    struct Foo
    {
	int a;
	CIRCLE_QUEUE_MEMBER(Foo) CQStuff;
	int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    CIRCLE_QUEUE_ROOT(sRoot, Foo) MyCQRoot;

    fputs("Testing CIRCLE_QUEUE.\n",stdout);

    while(WhichInsert != DONE)
    {
	CIRCLE_QUEUE_INITIALIZE(&MyCQRoot,Foo);
	MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;
	MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;
	MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;
    
	switch(WhichInsert)
	{
	case END:
	    CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo1,CQStuff);
	    CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo2,CQStuff);
	    CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo3,CQStuff);
	    WhichInsert = ROOT;
	    break;
	case ROOT:
	    CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo3,CQStuff);
	    CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo2,CQStuff);
	    CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo1,CQStuff);
	    WhichInsert = PREVIOUS;
	    break;
	case PREVIOUS:
	    CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo3,CQStuff);
	    CIRCLE_QUEUE_INSERT_PREVIOUS(&MyCQRoot,&MyFoo3,&MyFoo2,CQStuff);
	    CIRCLE_QUEUE_INSERT_PREVIOUS(&MyCQRoot,&MyFoo2,&MyFoo1,CQStuff);
	    WhichInsert = DONE;
	    break;
	default:
	    assert(0);
	}

        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        assert(pFoo);
        assert(pFoo->a == 0x1A);
        assert(pFoo->b == 0x1B);
    
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x2A);
        assert(pFoo->b == 0x2B);
    
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x3A);
        assert(pFoo->b == 0x3B);
    
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo == 0);

	pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
	assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,pFoo,CQStuff) == 0);
	pFoo = CIRCLE_QUEUE_LAST(&MyCQRoot);
	assert(pFoo == &MyFoo3);
	assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,pFoo,CQStuff) == &MyFoo2);
	assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,&MyFoo2,CQStuff) == &MyFoo1);
    
        /* Delete member 2. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x2B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
    
        /* Make sure that there are only members 1 and 3 in the list now. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        assert(pFoo);
        assert(pFoo->a == 0x1A);
        assert(pFoo->b == 0x1B);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x3A);
        assert(pFoo->b == 0x3B);
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
    
        /* Delete member 3. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x3B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
    
        /* Delete member 1. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x1B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
        assert(CIRCLE_QUEUE_FIRST(&MyCQRoot) == 0);
    
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo1,CQStuff);
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo2,CQStuff);
        
        /* Delete member 1 while there are other members in the list. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x1B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
        assert(CIRCLE_QUEUE_FIRST(&MyCQRoot) == &MyFoo2);
    
        assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
        assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
        assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);
    }

    fputs("Circle Queue passed.\n", stdout);
}

int main()
{
    TestList();
    TestTailQueue();
    TestCircleQueue();
    fputs("All tests passed.", stdout);
    return EXIT_SUCCESS;
}
#endif /* End of test code. */

#if __cplusplus
}
#endif

#endif // !_LISTS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\published\wmsdk\inc\wmsysprf.h ===
//============================================================================
//
//  Microsoft Windows Media Technology
//  Copyright (C) Microsoft Corporation, 1999 - 2001.  All Rights Reserved.
//
//  File:        wmsysprf.prx
//
//  Description: This file contains the GUIDs of the system profiles.
//
//============================================================================

///////////////////////////////////////////////////////////////////////////////

/* fd7f47f1-72a6-45a4-80f0-3aecefc32c07 */
EXTERN_GUID( WMProfile_V40_DialUpMBR, 
             0xfd7f47f1,
             0x72a6,
             0x45a4,
             0x80, 0xf0, 0x3a, 0xec, 0xef, 0xc3, 0x2c, 0x07 );

///////////////////////////////////////////////////////////////////////////////

/* 82cd3321-a94a-4ffc-9c2b-092c10ca16e7 */
EXTERN_GUID( WMProfile_V40_IntranetMBR, 
             0x82cd3321,
             0xa94a,
             0x4ffc,
             0x9c, 0x2b, 0x09, 0x2c, 0x10, 0xca, 0x16, 0xe7 );

///////////////////////////////////////////////////////////////////////////////

/* 5a1c2206-dc5e-4186-beb2-4c5a994b132e */
EXTERN_GUID( WMProfile_V40_2856100MBR, 
             0x5a1c2206,
             0xdc5e,
             0x4186,
             0xbe, 0xb2, 0x4c, 0x5a, 0x99, 0x4b, 0x13, 0x2e );

///////////////////////////////////////////////////////////////////////////////

/* D508978A-11A0-4d15-B0DA-ACDC99D4F890 */
EXTERN_GUID( WMProfile_V40_6VoiceAudio,
             0xD508978A,
             0x11A0,
             0x4d15,
             0xb0, 0xda, 0xac, 0xdc, 0x99, 0xd4, 0xf8, 0x90 );

///////////////////////////////////////////////////////////////////////////////

/* 0f4be81f-d57d-41e1-b2e3-2fad986bfec2 */
EXTERN_GUID( WMProfile_V40_16AMRadio, 
             0x0f4be81f,
             0xd57d,
             0x41e1,
             0xb2, 0xe3, 0x2f, 0xad, 0x98, 0x6b, 0xfe, 0xc2 );

///////////////////////////////////////////////////////////////////////////////

/* 7fa57fc8-6ea4-4645-8abf-b6e5a8f814a1 */
EXTERN_GUID( WMProfile_V40_288FMRadioMono, 
             0x7fa57fc8,
             0x6ea4,
             0x4645,
             0x8a, 0xbf, 0xb6, 0xe5, 0xa8, 0xf8, 0x14, 0xa1 );

///////////////////////////////////////////////////////////////////////////////

/* 22fcf466-aa40-431f-a289-06d0ea1a1e40 */
EXTERN_GUID( WMProfile_V40_288FMRadioStereo, 
             0x22fcf466,
             0xaa40,
             0x431f,
             0xa2, 0x89, 0x06, 0xd0, 0xea, 0x1a, 0x1e, 0x40 );

///////////////////////////////////////////////////////////////////////////////

/* e8026f87-e905-4594-a3c7-00d00041d1d9 */
EXTERN_GUID( WMProfile_V40_56DialUpStereo, 
             0xe8026f87,
             0xe905,
             0x4594,
             0xa3, 0xc7, 0x00, 0xd0, 0x00, 0x41, 0xd1, 0xd9 );

///////////////////////////////////////////////////////////////////////////////

/* 4820b3f7-cbec-41dc-9391-78598714c8e5 */
EXTERN_GUID( WMProfile_V40_64Audio, 
             0x4820b3f7,
             0xcbec,
             0x41dc,
             0x93, 0x91, 0x78, 0x59, 0x87, 0x14, 0xc8, 0xe5 );

///////////////////////////////////////////////////////////////////////////////

/* 0efa0ee3-9e64-41e2-837f-3c0038f327ba */
EXTERN_GUID( WMProfile_V40_96Audio, 
             0x0efa0ee3,
             0x9e64,
             0x41e2,
             0x83, 0x7f, 0x3c, 0x00, 0x38, 0xf3, 0x27, 0xba );

///////////////////////////////////////////////////////////////////////////////

/* 93ddbe12-13dc-4e32-a35e-40378e34279a */
EXTERN_GUID( WMProfile_V40_128Audio, 
             0x93ddbe12,
             0x13dc,
             0x4e32,
             0xa3, 0x5e, 0x40, 0x37, 0x8e, 0x34, 0x27, 0x9a );

///////////////////////////////////////////////////////////////////////////////

/* bb2bc274-0eb6-4da9-b550-ecf7f2b9948f */
EXTERN_GUID( WMProfile_V40_288VideoVoice, 
             0xbb2bc274,
             0x0eb6,
             0x4da9,
             0xb5, 0x50, 0xec, 0xf7, 0xf2, 0xb9, 0x94, 0x8f );

///////////////////////////////////////////////////////////////////////////////

/* ac617f2d-6cbe-4e84-8e9a-ce151a12a354 */
EXTERN_GUID( WMProfile_V40_288VideoAudio, 
             0xac617f2d,
             0x6cbe,
             0x4e84,
             0x8e, 0x9a, 0xce, 0x15, 0x1a, 0x12, 0xa3, 0x54 );

///////////////////////////////////////////////////////////////////////////////

/* abf2f00d-d555-4815-94ce-8275f3a70bfe */
EXTERN_GUID( WMProfile_V40_288VideoWebServer, 
             0xabf2f00d,
             0xd555,
             0x4815,
             0x94, 0xce, 0x82, 0x75, 0xf3, 0xa7, 0x0b, 0xfe );

///////////////////////////////////////////////////////////////////////////////

/* e21713bb-652f-4dab-99de-71e04400270f */
EXTERN_GUID( WMProfile_V40_56DialUpVideo, 
             0xe21713bb,
             0x652f,
             0x4dab,
             0x99, 0xde, 0x71, 0xe0, 0x44, 0x00, 0x27, 0x0f );

///////////////////////////////////////////////////////////////////////////////

/* b756ff10-520f-4749-a399-b780e2fc9250 */
EXTERN_GUID( WMProfile_V40_56DialUpVideoWebServer, 
             0xb756ff10,
             0x520f,
             0x4749,
             0xa3, 0x99, 0xb7, 0x80, 0xe2, 0xfc, 0x92, 0x50 );

///////////////////////////////////////////////////////////////////////////////

/* 8f99ddd8-6684-456b-a0a3-33e1316895f0 */
EXTERN_GUID( WMProfile_V40_100Video, 
             0x8f99ddd8,
             0x6684,
             0x456b,
             0xa0, 0xa3, 0x33, 0xe1, 0x31, 0x68, 0x95, 0xf0 );

///////////////////////////////////////////////////////////////////////////////

/* 541841c3-9339-4f7b-9a22-b11540894e42 */
EXTERN_GUID( WMProfile_V40_250Video, 
             0x541841c3,
             0x9339,
             0x4f7b,
             0x9a, 0x22, 0xb1, 0x15, 0x40, 0x89, 0x4e, 0x42 );

///////////////////////////////////////////////////////////////////////////////

/* 70440e6d-c4ef-4f84-8cd0-d5c28686e784 */
EXTERN_GUID( WMProfile_V40_512Video, 
             0x70440e6d,
             0xc4ef,
             0x4f84,
             0x8c, 0xd0, 0xd5, 0xc2, 0x86, 0x86, 0xe7, 0x84 );

///////////////////////////////////////////////////////////////////////////////

/* b4482a4c-cc17-4b07-a94e-9818d5e0f13f */
EXTERN_GUID( WMProfile_V40_1MBVideo, 
             0xb4482a4c,
             0xcc17,
             0x4b07,
             0xa9, 0x4e, 0x98, 0x18, 0xd5, 0xe0, 0xf1, 0x3f );

///////////////////////////////////////////////////////////////////////////////

/* 55374ac0-309b-4396-b88f-e6e292113f28 */
EXTERN_GUID( WMProfile_V40_3MBVideo, 
             0x55374ac0,
             0x309b,
             0x4396,
             0xb8, 0x8f, 0xe6, 0xe2, 0x92, 0x11, 0x3f, 0x28 );

///////////////////////////////////////////////////////////////////////////////

/* 5B16E74B-4068-45b5-B80E-7BF8C80D2C2F */
EXTERN_GUID( WMProfile_V70_DialUpMBR, 
             0x5b16e74b,
             0x4068,
             0x45b5,
             0xb8, 0xe, 0x7b, 0xf8, 0xc8, 0xd, 0x2c, 0x2f );

///////////////////////////////////////////////////////////////////////////////

/* 045880DC-34B6-4ca9-A326-73557ED143F3 */
EXTERN_GUID( WMProfile_V70_IntranetMBR, 
             0x45880dc,
             0x34b6,
             0x4ca9,
             0xa3, 0x26, 0x73, 0x55, 0x7e, 0xd1, 0x43, 0xf3 );

///////////////////////////////////////////////////////////////////////////////

/* 07DF7A25-3FE2-4a5b-8B1E-348B0721CA70 */
EXTERN_GUID( WMProfile_V70_2856100MBR, 
             0x7df7a25,
             0x3fe2,
             0x4a5b,
             0x8b, 0x1e, 0x34, 0x8b, 0x7, 0x21, 0xca, 0x70 );

///////////////////////////////////////////////////////////////////////////////

/* B952F38E-7DBC-4533-A9CA-B00B1C6E9800 */
EXTERN_GUID( WMProfile_V70_288VideoVoice, 
             0xb952f38e,
             0x7dbc,
             0x4533,
             0xa9, 0xca, 0xb0, 0xb, 0x1c, 0x6e, 0x98, 0x0 );

///////////////////////////////////////////////////////////////////////////////

/* 58BBA0EE-896A-4948-9953-85B736F83947 */
EXTERN_GUID( WMProfile_V70_288VideoAudio, 
             0x58bba0ee,
             0x896a,
             0x4948,
             0x99, 0x53, 0x85, 0xb7, 0x36, 0xf8, 0x39, 0x47 );

///////////////////////////////////////////////////////////////////////////////

/* 70A32E2B-E2DF-4ebd-9105-D9CA194A2D50 */
EXTERN_GUID( WMProfile_V70_288VideoWebServer, 
             0x70a32e2b,
             0xe2df,
             0x4ebd,
             0x91, 0x5, 0xd9, 0xca, 0x19, 0x4a, 0x2d, 0x50 );

///////////////////////////////////////////////////////////////////////////////

/* DEF99E40-57BC-4ab3-B2D1-B6E3CAF64257 */
EXTERN_GUID( WMProfile_V70_56VideoWebServer, 
             0xdef99e40,
             0x57bc,
             0x4ab3,
             0xb2, 0xd1, 0xb6, 0xe3, 0xca, 0xf6, 0x42, 0x57 );

///////////////////////////////////////////////////////////////////////////////

/* C2B7A7E9-7B8E-4992-A1A1-068217A3B311 */
EXTERN_GUID( WMProfile_V70_64VideoISDN,
             0xc2b7a7e9,
             0x7b8e,
             0x4992,
             0xa1, 0xa1, 0x06, 0x82, 0x17, 0xa3, 0xb3, 0x11 );

///////////////////////////////////////////////////////////////////////////////

/* D9F3C932-5EA9-4c6d-89B4-2686E515426E */
EXTERN_GUID( WMProfile_V70_100Video, 
             0xd9f3c932,
             0x5ea9,
             0x4c6d,
             0x89, 0xb4, 0x26, 0x86, 0xe5, 0x15, 0x42, 0x6e );

///////////////////////////////////////////////////////////////////////////////

/* AFE69B3A-403F-4a1b-8007-0E21CFB3DF84 */
EXTERN_GUID( WMProfile_V70_256Video,
             0xafe69b3a,
             0x403f,
             0x4a1b,
             0x80, 0x7, 0xe, 0x21, 0xcf, 0xb3, 0xdf, 0x84 );

///////////////////////////////////////////////////////////////////////////////

/* F3D45FBB-8782-44df-97C6-8678E2F9B13D */
EXTERN_GUID( WMProfile_V70_384Video,
             0xf3d45fbb,
             0x8782,
             0x44df,
             0x97, 0xc6, 0x86, 0x78, 0xe2, 0xf9, 0xb1, 0x3d );

///////////////////////////////////////////////////////////////////////////////

/* 0326EBB6-F76E-4964-B0DB-E729978D35EE */
EXTERN_GUID( WMProfile_V70_768Video, 
             0x326ebb6,
             0xf76e,
             0x4964,
             0xb0, 0xdb, 0xe7, 0x29, 0x97, 0x8d, 0x35, 0xee );

///////////////////////////////////////////////////////////////////////////////

/* 0B89164A-5490-4686-9E37-5A80884E5146 */
EXTERN_GUID( WMProfile_V70_1500Video, 
             0xb89164a,
             0x5490,
             0x4686,
             0x9e, 0x37, 0x5a, 0x80, 0x88, 0x4e, 0x51, 0x46 );

///////////////////////////////////////////////////////////////////////////////

/* AA980124-BF10-4e4f-9AFD-4329A7395CFF */
EXTERN_GUID( WMProfile_V70_2000Video,
             0xaa980124,
             0xbf10,
             0x4e4f, 
             0x9a, 0xfd, 0x43, 0x29, 0xa7, 0x39, 0x5c, 0xff );

///////////////////////////////////////////////////////////////////////////////

/* 7A747920-2449-4d76-99CB-FDB0C90484D4 */
EXTERN_GUID( WMProfile_V70_700FilmContentVideo,
             0x7a747920,
             0x2449,
             0x4d76,
             0x99, 0xcb, 0xfd, 0xb0, 0xc9, 0x4, 0x84, 0xd4 );

///////////////////////////////////////////////////////////////////////////////

/* F6A5F6DF-EE3F-434c-A433-523CE55F516B */
EXTERN_GUID( WMProfile_V70_1500FilmContentVideo,
             0xf6a5f6df,
             0xee3f,
             0x434c,
             0xa4, 0x33, 0x52, 0x3c, 0xe5, 0x5f, 0x51, 0x6b );

///////////////////////////////////////////////////////////////////////////////

/* EABA9FBF-B64F-49b3-AA0C-73FBDD150AD0 */
EXTERN_GUID( WMProfile_V70_6VoiceAudio, 
             0xeaba9fbf,
             0xb64f,
             0x49b3,
             0xaa, 0xc, 0x73, 0xfb, 0xdd, 0x15, 0xa, 0xd0 );

///////////////////////////////////////////////////////////////////////////////

/* C012A833-A03B-44a5-96DC-ED95CC65582D */
EXTERN_GUID( WMProfile_V70_288FMRadioMono, 
             0xc012a833,
             0xa03b,
             0x44a5,
             0x96, 0xdc, 0xed, 0x95, 0xcc, 0x65, 0x58, 0x2d );

///////////////////////////////////////////////////////////////////////////////

/* E96D67C9-1A39-4dc4-B900-B1184DC83620 */
EXTERN_GUID( WMProfile_V70_288FMRadioStereo, 
             0xe96d67c9,
             0x1a39,
             0x4dc4,
             0xb9, 0x0, 0xb1, 0x18, 0x4d, 0xc8, 0x36, 0x20 );

///////////////////////////////////////////////////////////////////////////////

/* 674EE767-0949-4fac-875E-F4C9C292013B */
EXTERN_GUID( WMProfile_V70_56DialUpStereo,
             0x674ee767,
             0x949,
             0x4fac,
             0x87, 0x5e, 0xf4, 0xc9, 0xc2, 0x92, 0x1, 0x3b );

///////////////////////////////////////////////////////////////////////////////

/* 91DEA458-9D60-4212-9C59-D40919C939E4 */
EXTERN_GUID( WMProfile_V70_64AudioISDN,
             0x91dea458,
             0x9d60,
             0x4212,
             0x9c, 0x59, 0xd4, 0x09, 0x19, 0xc9, 0x39, 0xe4 );

///////////////////////////////////////////////////////////////////////////////

/* B29CFFC6-F131-41db-B5E8-99D8B0B945F4 */
EXTERN_GUID( WMProfile_V70_64Audio, 
             0xb29cffc6,
             0xf131,
             0x41db,
             0xb5, 0xe8, 0x99, 0xd8, 0xb0, 0xb9, 0x45, 0xf4 );

///////////////////////////////////////////////////////////////////////////////

/* A9D4B819-16CC-4a59-9F37-693DBB0302D6 */
EXTERN_GUID( WMProfile_V70_96Audio, 
             0xa9d4b819,
             0x16cc,
             0x4a59,
             0x9f, 0x37, 0x69, 0x3d, 0xbb, 0x3, 0x2, 0xd6 );

///////////////////////////////////////////////////////////////////////////////

/* C64CF5DA-DF45-40d3-8027-DE698D68DC66 */
EXTERN_GUID( WMProfile_V70_128Audio, 
             0xc64cf5da,
             0xdf45,
             0x40d3,
             0x80, 0x27, 0xde, 0x69, 0x8d, 0x68, 0xdc, 0x66 );

///////////////////////////////////////////////////////////////////////////////

/* F55EA573-4C02-42b5-9026-A8260C438A9F */
EXTERN_GUID( WMProfile_V70_225VideoPDA, 
             0xf55ea573,
             0x4c02,
             0x42b5,
             0x90, 0x26, 0xa8, 0x26, 0xc, 0x43, 0x8a, 0x9f );

///////////////////////////////////////////////////////////////////////////////

/* 0F472967-E3C6-4797-9694-F0304C5E2F17 */
EXTERN_GUID( WMProfile_V70_150VideoPDA, 
             0xf472967,
             0xe3c6,
             0x4797,
             0x96, 0x94, 0xf0, 0x30, 0x4c, 0x5e, 0x2f, 0x17 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\reality\misc\dpf.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpf.h
 *  Content:    header file for debug printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   06-apr-95  craige  initial implementation
 *   06-feb-96  colinmc added simple assertion mechanism for DirectDraw
 *   15-apr-96  kipo    added msinternal
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#ifdef NEW_DPF
#include "newdpf.h"
#else

    #ifndef __DPF_INCLUDED__
    #define __DPF_INCLUDED__

    #ifdef __cplusplus
    extern "C" {
    #endif

    #ifdef WINNT
	#undef DEBUG
	#ifdef DBG
	    #define DEBUG
	#endif
    #endif

    extern void cdecl dprintf( UINT lvl, LPSTR szFormat, ...);
    extern void DPFInit( void );
    #ifdef DEBUG
	#define DPF_DECLARE(szName) char * __pszDpfName=szName
	#define DPFINIT()   DPFInit()
	#define DPF         dprintf
	#define DPF_ERR(a)  dprintf( 0, DPF_MODNAME ": " a );
	extern HWND hWndListBox;
	#if defined( _WIN32 ) && !defined(WINNT)
	    #define DEBUG_BREAK()       _try { _asm { int 3 } } _except (EXCEPTION_EXECUTE_HANDLER) {;}
	#else
	    #define DEBUG_BREAK()       DebugBreak()
	#endif
	#define USE_DDASSERT
    #else
	#pragma warning(disable:4002)
	#define DPF_DECLARE(szName)
	#define DPFINIT()
	#define DPF()
	#define DPF_ERR(a)
	#define DEBUG_BREAK()
    #endif

    #if defined(DEBUG) && defined(USE_DDASSERT)

    extern void _DDAssert(LPCSTR szFile, int nLine, LPCSTR szCondition);

    #define DDASSERT(condition) if (!(condition)) _DDAssert(__FILE__, __LINE__, #condition)

    #else  /* DEBUG && USE_DDASSERT */

    #define DDASSERT(condition)

    #endif /* DEBUG && USE_DDASSERT */

    #ifdef _WIN32

    #ifdef DEBUG
	__inline DWORD clockrate() {LARGE_INTEGER li; QueryPerformanceFrequency(&li); return li.LowPart;}
	__inline DWORD clock()     {LARGE_INTEGER li; QueryPerformanceCounter(&li);   return li.LowPart;}

	#define TIMEVAR(t)    DWORD t ## T; DWORD t ## N
	#define TIMEZERO(t)   t ## T = 0, t ## N = 0
	#define TIMESTART(t)  t ## T -= clock(), t ## N ++
	#define TIMESTOP(t)   t ## T += clock()
	#define TIMEFMT(t)    ((DWORD)(t) / clockrate()), (((DWORD)(t) * 1000 / clockrate())%1000)
	#define TIMEOUT(t)    if (t ## N) DPF(1, #t ": %ld calls, %ld.%03ld sec (%ld.%03ld)", t ## N, TIMEFMT(t ## T), TIMEFMT(t ## T / t ## N))
    #else
	#define TIMEVAR(t)
	#define TIMEZERO(t)
	#define TIMESTART(t)
	#define TIMESTOP(t)
	#define TIMEFMT(t)
	#define TIMEOUT(t)
    #endif

    #endif
    #ifdef __cplusplus
    }
    #endif

    #endif
#endif //use new dpf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\common.inc ===
EXT_INC_PATH = $(WMDMROOT)\Dependencies\Inc;

!IF $(FREEBUILD)
EXT_LIB_PATH = $(WMDMROOT)\Dependencies\lib\$(TARGET_DIRECTORY)
!ELSE
EXT_LIB_PATH = $(WMDMROOT)\Dependencies\lib\$(TARGET_DIRECTORY)
!ENDIF

WMDM_INC_PATH = $(WMDMROOT)\Common\include;$(WMDMROOT)\Common\include\ver;
WMDM_LIB_PATH = $(WMDMROOT)\Common\lib\$(TARGET_DIRECTORY)

WMDMOUTDIR = $(_OBJ_DIR)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\reality\misc\memalloc.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memalloc.c
 *  Content:    allocates memory
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   20-jan-95  craige  initial implementation
 *   27-feb-95  craige  don't call HeapFree with NULL, it is a huge time sink
 *   29-mar-95  craige  memory tracker
 *   01-apr-95  craige  happy fun joy updated header file
 *   06-apr-95  craige  made stand-alone
 *   22-may-95  craige  added MemAlloc16
 *   12-jun-95  craige  added MemReAlloc
 *   18-jun-95  craige  deadlock joy: don't take DLL csect here
 *   26-jul-95  toddla  added MemSize and fixed MemReAlloc
 *   29-feb-96  colinmc added optional debugging code to blat a a specific
 *                      bit pattern over freed memory
 *   08-oct-96	ketand	change debug message to give a total for the terminating
 *			process
 *
 ***************************************************************************/
#undef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include "memalloc.h"
#include "dpf.h"

#define FREE_MEMORY_PATTERN 0xDEADBEEFUL

#ifdef WIN95
    #ifdef NOSHARED
	#define HEAP_SHARED     0
    #else
	#define HEAP_SHARED     0x04000000      // put heap in shared memory
    #endif
#else
    #define HEAP_SHARED         0
#endif

static HANDLE   hHeap = NULL;           // handle to shared heap for this DLL

/*
 * memory track struct and list
 */
#ifdef DEBUG
#define MCOOKIE 0xbaaabaaa
#define MCOOKIE_FREE    0xbabababa
typedef struct _MEMTRACK
{
    DWORD               dwCookie;
    struct _MEMTRACK    FAR *lpNext;
    struct _MEMTRACK    FAR *lpPrev;
    DWORD               dwSize;
    LPVOID              lpAddr;
    DWORD               dwPid;
} MEMTRACK, FAR *LPMEMTRACK;

static LPMEMTRACK       lpHead;
static LPMEMTRACK       lpTail;
static LONG             lAllocCount;

#define DEBUG_TRACK( lptr, first ) \
    if( lptr == NULL ) \
    { \
	DPF( 1, "Alloc of size %u FAILED!", size ); \
    } \
    else \
    { \
	LPMEMTRACK      pmt; \
	pmt = (LPMEMTRACK) lptr; \
	pmt->dwSize = size - sizeof( MEMTRACK ); \
	pmt->dwCookie = MCOOKIE; \
	pmt->lpAddr = _ReturnAddress(); \
	pmt->dwPid = GetCurrentProcessId(); \
	if( lpHead == NULL ) \
	{ \
	    lpHead = lpTail = pmt; \
	} \
	else \
	{ \
	    lpTail->lpNext = pmt; \
	    pmt->lpPrev = lpTail; \
	    lpTail = pmt; \
	} \
	lptr = (LPVOID) (((LPBYTE) lptr) + sizeof( MEMTRACK )); \
	lAllocCount++; \
    }

#define DEBUG_TRACK_UPDATE_SIZE( s ) s += sizeof( MEMTRACK );

#else

#define DEBUG_TRACK( lptr, first )
#define DEBUG_TRACK_UPDATE_SIZE( size )

#endif


#if defined( WIN95 ) && defined( WANT_MEM16 )

extern DWORD _stdcall MapLS( LPVOID ); // flat -> 16:16
extern void _stdcall UnMapLS( DWORD ); // unmap 16:16

typedef struct SELLIST {
    struct SELLIST      *link;
    LPBYTE              base;
    WORD                sel;
} SELLIST, *LPSELLIST;

static LPSELLIST        lpSelList;

/*
 * MemAlloc16
 *
 * Allocate some memory, and return a 16:16 pointer to that memory
 *
 * NOTE: ASSUMES WE ARE IN THE DLL CRITICAL SECTION!
 */
LPVOID __cdecl MemAlloc16( UINT size, LPDWORD p16 )
{
    LPBYTE              lptr;
    LPSELLIST           psel;
    DWORD               diff;

    DEBUG_TRACK_UPDATE_SIZE( size );
    lptr = HeapAlloc( hHeap, HEAP_ZERO_MEMORY, size );
    DEBUG_TRACK( lptr, size );
    if( lptr == NULL )
    {
	return NULL;
    }

    /*
     * try to find an existing selector that maps this area
     */
    psel = lpSelList;
    while( psel != NULL )
    {
	if( psel->base <= lptr )
	{
	    diff = lptr - psel->base;
	    if( diff+size < 0xf000 )
	    {
		*p16 = ((DWORD)psel->sel << 16l) + diff;
		return lptr;
	    }
	}
	psel = psel->link;
    }

    /*
     * no selector found, create a new one
     */
    psel = HeapAlloc( hHeap, HEAP_ZERO_MEMORY, sizeof( SELLIST ));
    if( psel == NULL )
    {
	return NULL;
    }
    psel->sel = HIWORD( MapLS( lptr ) );
    DPF( 2, "$$$$$$ New selector allocated: %04x", psel->sel );
    psel->base = lptr;
    psel->link = lpSelList;
    lpSelList = psel;
    *p16 = ((DWORD) psel->sel) << 16l;

    return lptr;

} /* MemAlloc16 */

/*
 * GetPtr16
 */
LPVOID GetPtr16( LPVOID ptr )
{
    DWORD       diff;
    DWORD       p16;
    LPSELLIST   psel;
    LPBYTE      lptr;

    lptr = ptr;

    psel = lpSelList;
    while( psel != NULL )
    {
	if( psel->base <= lptr )
	{
	    diff = lptr - psel->base;
	    if( diff <= 0xf000 )
	    {
		p16 = ((DWORD)psel->sel << 16l) + diff;
		return (LPVOID) p16;
	    }
	}
	psel = psel->link;
    }
    DPF( 1, "ERROR: NO 16:16 PTR for %08lx", lptr );
    return NULL;

} /* GetPtr16 */

/*
 * freeSelectors
 */
static void freeSelectors( void )
{
    LPSELLIST           psel;
    LPSELLIST           link;

    psel = lpSelList;
    while( psel != NULL )
    {
	link = psel->link;
	DPF( 2, "$$$$$$ Freeing selector %04x", psel->sel );
	UnMapLS( ((DWORD)psel->sel) << 16l );
	HeapFree( hHeap, 0, psel );
	psel = link;
    }
    lpSelList = NULL;

} /* freeSelectors */
#endif

/*
 * MemAlloc - allocate memory from our global pool
 */
LPVOID __cdecl MemAlloc( UINT size )
{
    LPBYTE lptr;

    DEBUG_TRACK_UPDATE_SIZE( size );
    lptr = HeapAlloc( hHeap, HEAP_ZERO_MEMORY, size );
    DEBUG_TRACK( lptr, size );

    return lptr;

} /* MemAlloc */

/*
 * MemSize - return size of object
 */
SIZE_T __cdecl MemSize( LPVOID lptr )
{
#ifdef DEBUG
    if (lptr)
    {
	LPMEMTRACK  pmt;
	lptr = (LPVOID) (((LPBYTE)lptr) - sizeof( MEMTRACK ));
	pmt = lptr;
	return pmt->dwSize;
    }
#endif
    return HeapSize(hHeap, 0, lptr);

} /* MemSize */

/*
 * MemFree - free memory from our global pool
 */
void MemFree( LPVOID lptr )
{
    if( lptr != NULL )
    {
	#ifdef DEBUG
	{
	    /*
	     * get real pointer and unlink from chain
	     */
	    LPMEMTRACK  pmt;
	    lptr = (LPVOID) (((LPBYTE)lptr) - sizeof( MEMTRACK ));
	    pmt = lptr;

	    if( pmt->dwCookie == MCOOKIE_FREE )
	    {
		DPF( 1, "FREE OF FREED MEMORY! ptr=%08lx", pmt );
		DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx", pmt, pmt->dwSize, pmt->lpAddr );
	    }
	    else if( pmt->dwCookie != MCOOKIE )
	    {
		DPF( 1, "INVALID FREE! cookie=%08lx, ptr = %08lx", pmt->dwCookie, lptr );
		DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx", pmt, pmt->dwSize, pmt->lpAddr );
	    }
	    else
	    {
		pmt->dwCookie = MCOOKIE_FREE;
		if( pmt == lpHead && pmt == lpTail )
		{
		    lpHead = NULL;
		    lpTail = NULL;
		}
		else if( pmt == lpHead )
		{
		    lpHead = pmt->lpNext;
		    lpHead->lpPrev = NULL;
		}
		else if( pmt == lpTail )
		{
		    lpTail = pmt->lpPrev;
		    lpTail->lpNext = NULL;
		}
		else
		{
		    pmt->lpPrev->lpNext = pmt->lpNext;
		    pmt->lpNext->lpPrev = pmt->lpPrev;
		}

		#ifdef FILL_ON_MEMFREE
		{
		    LPDWORD lpMem;
		    DWORD   dwPat;
		    DWORD   dwSize;

		    dwSize = pmt->dwSize;
		    lpMem = (LPDWORD)( (LPBYTE)lptr + sizeof( MEMTRACK ) );
		    while (dwSize >= sizeof(DWORD))
		    {
			*lpMem++ = FREE_MEMORY_PATTERN;
			dwSize -= sizeof(DWORD);
		    }
		    if (dwSize != 0UL)
		    {
			dwPat = FREE_MEMORY_PATTERN;
			memcpy(lpMem, &dwPat, dwSize);
		    }
		}
		#endif
	    }
	    lAllocCount--;
	    if( lAllocCount < 0 )
	    {
		DPF( 1, "Too Many Frees!\n" );
	    }
	}
	#endif

	HeapFree( hHeap, 0, lptr );

    }

} /* MemFree */

/*
 * MemReAlloc
 */
LPVOID __cdecl MemReAlloc( LPVOID lptr, UINT size )
{
    LPVOID new;

    DEBUG_TRACK_UPDATE_SIZE( size );
    #ifdef DEBUG
	if( lptr != NULL )
	{
	    LPMEMTRACK  pmt;
	    lptr = (LPVOID) (((LPBYTE)lptr) - sizeof( MEMTRACK ));
	    pmt = lptr;
	    if( pmt->dwCookie != MCOOKIE )
	    {
		DPF( 1, "INVALID REALLOC! cookie=%08lx, ptr = %08lx", pmt->dwCookie, lptr );
		DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx", pmt, pmt->dwSize, pmt->lpAddr );
	    }
	}
    #endif

    new = HeapReAlloc( hHeap, HEAP_ZERO_MEMORY, lptr, size );

    #ifdef DEBUG
    if (new != NULL)
    {
	LPMEMTRACK pmt = new;

	pmt->dwSize = size - sizeof( MEMTRACK );

	if( lptr == (LPVOID)lpHead )
	    lpHead = pmt;
	else
	    pmt->lpPrev->lpNext = pmt;

	if( lptr == (LPVOID)lpTail )
	    lpTail = pmt;
	else
	    pmt->lpNext->lpPrev = pmt;

	new = (LPVOID) (((LPBYTE)new) + sizeof(MEMTRACK));
    }
    #endif
    return new;

} /* MemReAlloc */

/*
 * MemInit - initialize the heap manager
 */
BOOL MemInit( void )
{
    if( hHeap == NULL )
    {
	hHeap = HeapCreate( HEAP_SHARED, 0x2000, 0 );
	if( hHeap == NULL )
	{
	    return FALSE;
	}
    }
    #ifdef DEBUG
	lAllocCount = 0;
	lpHead = NULL;
	lpTail = NULL;
    #endif
    return TRUE;

} /* MemInit */

#ifdef DEBUG
/*
 * MemState - finished with our heap manager
 */
void MemState( void )
{
    DPF( 2, "MemState" );
    if( lAllocCount != 0 )
    {
	DPF( 1, "Memory still allocated!  Alloc count = %ld", lAllocCount );
	DPF( 1, "Current Process (pid) = %08lx", GetCurrentProcessId() );
    }
#ifdef DEBUG
    if (GetProfileInt( "Direct3DRM", "disablememorydump", 0 ))
	return;
#endif
    if( lpHead != NULL )
    {
	LPMEMTRACK      pmt;
	DWORD		dwTotal = 0;
	DWORD		pidCurrent = GetCurrentProcessId();
	pmt = lpHead;
	while( pmt != NULL )
	{
	    if( pidCurrent == pmt->dwPid )
		dwTotal += pmt->dwSize;
	    DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx (pid=%08lx)", pmt, pmt->dwSize, pmt->lpAddr, pmt->dwPid );
	    pmt = pmt->lpNext;
	}
	DPF ( 1, "Total Memory Unfreed From Current Process = %ld bytes", dwTotal );
    }
} /* MemState */
#endif

/*
 * MemFini - finished with our heap manager
 */
void MemFini( void )
{
    DPF( 2, "MemFini!" );
    #ifdef DEBUG
	MemState();
    #endif
    #if defined( WIN95 ) && defined( WANT_MEM16 )
	freeSelectors();
    #endif
    if( hHeap )
    {
	HeapDestroy( hHeap );
	hHeap = NULL;
    }
} /* MemFini */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\apps\proghelp\operationhelper.h ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

//
// OperationHelper.h : Declaration of the COperationHelper
//

#ifndef __OPERATIONHELPER_H_
#define __OPERATIONHELPER_H_

#include "progRC.h"       // main symbols


enum EWMDMOperation
{
    E_OPERATION_NOTHING = 0, 
    E_OPERATION_SENDING, 
    E_OPERATION_RECEIVING, 
};

class CSecureChannelClient;
/////////////////////////////////////////////////////////////////////////////
// COperationHelper
class ATL_NO_VTABLE COperationHelper : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<COperationHelper, &CLSID_OperationHelper>,
	public IWMDMOperationHelper,
    public IWMDMOperation
{
private:
    EWMDMOperation  m_eStatus;
    TCHAR           m_pszFileName[MAX_PATH];
    HANDLE          m_hFile;
    CSecureChannelClient*   m_pSACClient;


public:
	COperationHelper();
	~COperationHelper();

DECLARE_REGISTRY_RESOURCEID(IDR_WMDMOPERATIONHELPER)
DECLARE_NOT_AGGREGATABLE(COperationHelper)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(COperationHelper)
	COM_INTERFACE_ENTRY(IWMDMOperationHelper)
    COM_INTERFACE_ENTRY(IWMDMOperation)
END_COM_MAP()

// IWMDMOperationHelper
public:
	STDMETHOD (SetFileName)(/*[in]*/ BSTR pszFileName);

// IWMDMOperation
public:
	STDMETHOD (SetSAC)(void* pSACClient );
	STDMETHOD (BeginWrite)();
	STDMETHOD (BeginRead)();
    STDMETHOD (GetObjectName)(LPWSTR pwszName, UINT nMaxChars);
    STDMETHOD (SetObjectName)(LPWSTR pwszName, UINT nMaxChars);
    STDMETHOD (GetObjectAttributes)(DWORD *pdwAttributes, _WAVEFORMATEX *pFormat);
    STDMETHOD (SetObjectAttributes)(DWORD dwAttributes, _WAVEFORMATEX *pFormat);
    STDMETHOD (GetObjectTotalSize)(DWORD *pdwSize, DWORD* pdwHighSize);
    STDMETHOD (SetObjectTotalSize)(DWORD dwSize, DWORD dwHighSize);
    STDMETHOD (TransferObjectData)(BYTE *pData, DWORD *pdwSize, BYTE abMac[]);	
    STDMETHOD (End)(HRESULT *phCompletionCode,IUnknown *pNewObject);
};

#endif //__OPERATIONHELPER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\apps\proghelp\operationhelper.cpp ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

//
// OperationHelper.cpp : Implementation of COperationHelper
//

#include "progPCH.h"
#include "ProgHelp.h"
#include "Sac.h"
#include "SCClient.h"
#include "OperationHelper.h"
#include "StrSafe.h"
//
// Constructor/Destructor
//

COperationHelper::COperationHelper()
{
    m_eStatus = E_OPERATION_NOTHING;
    m_hFile = INVALID_HANDLE_VALUE;
    memset( m_pszFileName, __T('\0'), MAX_PATH * sizeof( TCHAR ) ); //memset is fine; sizeof arg1 == sizeof arg3
    m_pSACClient = NULL;
}

COperationHelper::~COperationHelper()
{
    if( m_hFile != INVALID_HANDLE_VALUE ) 
    {
        CloseHandle(m_hFile);
    }
}

//
// IWMDMOperation
//

// IWMDMOperation::BeginRead
// 
HRESULT COperationHelper::BeginRead()
{
//    m_eStatus = E_OPERATION_RECEIVING;

	return E_NOTIMPL;
}

// IWMDMOperation::BeginWrite
// Start sending data 
HRESULT COperationHelper::BeginWrite()
{
    m_eStatus = E_OPERATION_SENDING;

    if( _tcslen( m_pszFileName ) == 0 ) 
    {
        return E_FAIL;
    }

    m_hFile = CreateFile(   m_pszFileName,      // file name
                            GENERIC_READ,       // access mode
                            FILE_SHARE_READ,    // share mode
                            NULL,               // SD
                            OPEN_EXISTING,      // how to create
                            FILE_ATTRIBUTE_NORMAL, // file attributes
                            NULL );             // handle to template file



    if( m_hFile == INVALID_HANDLE_VALUE ) 
    {
        return E_FAIL;
    }

	return S_OK; 
}

// IWMDMOperation::GetObjectName
//
HRESULT COperationHelper::GetObjectName(LPWSTR pwszName, UINT nMaxChars)
{
	USES_CONVERSION;
    TCHAR* pszNoPath;

    if (pwszName == NULL)
    {
        return E_POINTER;
    }
    if (nMaxChars == 0)
    {
        return E_INVALIDARG;
    }

    if( m_pszFileName == NULL || _tcslen( m_pszFileName ) == 0 ) 
    {
        return E_FAIL;
    }

    pszNoPath = _tcsrchr( m_pszFileName, __T('\\') );
    if( pszNoPath == NULL ) pszNoPath = m_pszFileName;
    else pszNoPath++;

    WCHAR* wcp = A2W(pszNoPath);

    return HRESULT_CODE(StringCchCopyW(pwszName, nMaxChars, wcp));
}

// IWMDMOperation::SetObjectName
//
HRESULT COperationHelper::SetObjectName(LPWSTR pwszName, UINT nMaxChars)
{
	return E_NOTIMPL;

}

// IWMDMOperation::GetObjectAttributes
//
HRESULT COperationHelper::GetObjectAttributes(DWORD *pdwAttributes, _WAVEFORMATEX *pFormat)
{
	DWORD dwAttrib;
	USES_CONVERSION;

    if( pdwAttributes == NULL ) return E_INVALIDARG;
    if( _tcslen( m_pszFileName ) == 0 ) return E_FAIL;

	dwAttrib = GetFileAttributes(m_pszFileName);

    *pdwAttributes = 0;
	if( dwAttrib & FILE_ATTRIBUTE_DIRECTORY ) 
		*pdwAttributes |= WMDM_FILE_ATTR_FOLDER;
	else 
		*pdwAttributes |= WMDM_FILE_ATTR_FILE;
	*pdwAttributes |= WMDM_FILE_CREATE_OVERWRITE;

    return S_OK;
}

// IWMDMOperation::SetObjectAttributes
//
HRESULT COperationHelper::SetObjectAttributes(DWORD dwAttributes, _WAVEFORMATEX *pFormat)
{
	return E_NOTIMPL;
}


// IWMDMOperation::GetObjectTotalSize
//
HRESULT COperationHelper::GetObjectTotalSize(DWORD *pdwSize, DWORD *pdwHighSize)
{
    if( pdwSize == NULL || m_hFile == INVALID_HANDLE_VALUE ) 
    {
        return E_INVALIDARG;
    }

	*pdwSize = GetFileSize(m_hFile, pdwHighSize );
	return S_OK;
}

// IWMDMOperation::SetObjectTotalSize
//
HRESULT COperationHelper::SetObjectTotalSize(DWORD dwSize, DWORD dwHighSize)
{
	return E_NOTIMPL;
}

// IWMDMOperation::TransferObjectData
//
HRESULT COperationHelper::TransferObjectData(BYTE *pData,DWORD *pdwSize, BYTE *pbMac)
{
    DWORD   dwReadLen;
    DWORD   dwMacVerifyLen = WMDM_MAC_LENGTH;
    DWORD   dwMacLen = WMDM_MAC_LENGTH;

    if( pData == NULL || pdwSize == NULL || pbMac == NULL ) 
    {
        return E_INVALIDARG;
    }

    if( m_eStatus != E_OPERATION_SENDING && m_eStatus != E_OPERATION_RECEIVING ) 
    {
        return E_FAIL;
    }

    // Sending
    if( m_eStatus == E_OPERATION_SENDING )
    {
        if( m_pSACClient == NULL ) 
        {
            return E_FAIL;
        }

        dwReadLen = *pdwSize;
        if( ReadFile(m_hFile, pData, dwReadLen, pdwSize, NULL) == FALSE ) 
        {
            return E_FAIL;
        }

        HMAC hMAC;

        // Create the MAC to return to caller
        m_pSACClient->MACInit(&hMAC);
        m_pSACClient->MACUpdate(hMAC, (BYTE*)(pData), *pdwSize);
        m_pSACClient->MACUpdate(hMAC, (BYTE*)(pdwSize), sizeof(DWORD));
        m_pSACClient->MACFinal(hMAC, (BYTE*)pbMac);
        m_pSACClient->EncryptParam((BYTE*)(pData), *pdwSize);
    }
    // Receiving
    else 
    {
        return E_NOTIMPL;
    }

	return S_OK;
}

// IWMDMOperation::End
//
HRESULT COperationHelper::End(HRESULT *phCompletionCode, IUnknown *pNewObject)
{
    m_eStatus = E_OPERATION_NOTHING;

	CloseHandle(m_hFile);
    m_hFile = INVALID_HANDLE_VALUE;

    return S_OK;
}

//
// IWMDMOperation
//

// IWMDMOperation::SetFileName
//
STDMETHODIMP COperationHelper::SetFileName(LPWSTR pwszFileName)
{
	USES_CONVERSION;
	
    if (pwszFileName == NULL)
    {
        return E_POINTER;
    }
    if (pwszFileName[0] == L'\0')
    {
        return E_INVALIDARG;
    }
    return HRESULT_CODE(StringCbCopy(m_pszFileName, sizeof(m_pszFileName), W2T(pwszFileName)));
}


// IWMDMOperation::SetSAC
// Passing pointer to CSecureChannelClient object
STDMETHODIMP COperationHelper::SetSAC( void* pSACClient)
{
    if( pSACClient == NULL  ) 
    {
        return E_INVALIDARG;
    }
    if( m_pSACClient != NULL ) 
    {
        return E_FAIL;
    }
    
    m_pSACClient = (CSecureChannelClient*)pSACClient;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\apps\proghelp\proghelp.cpp ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

//
// ProgHelp.cpp : Implementation of DLL Exports.
//


#include "progPCH.h"
#include "progRC.h"
#include <initguid.h>
#include "ProgHelp.h"

#include "ProgHelp_i.c"
#include "ProgressHelper.h"
#include "OperationHelper.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_ProgressHelper, CProgressHelper)
OBJECT_ENTRY(CLSID_OperationHelper, COperationHelper)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_PROGHELPLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\apps\proghelp\progrc.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ProgHelp.rc
//
#define IDS_PROJNAME                    100
#define IDR_WMDMPROGRESSHELPER          101
#define IDR_WMDMOPERATIONHELPER         102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\apps\proghelp\progpch.h ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

//
// progpch.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently
//

#if !defined(AFX_STDAFX_H__8297A5A8_5113_11D3_B276_00C04F8EC221__INCLUDED_)
#define AFX_STDAFX_H__8297A5A8_5113_11D3_B276_00C04F8EC221__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_FREE_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__8297A5A8_5113_11D3_B276_00C04F8EC221__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\apps\proghelp\progpch.cpp ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

// progpch.cpp : source file that includes just the standard includes
//  progpch.pch will be the pre-compiled header
//  progpch.obj will contain the pre-compiled type information

#include "progPCH.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include "WMDMProgressHelper.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\apps\proghelp\verinfo.h ===
#ifndef _MAC
/////////////////////////////////////////////////////////////////////////////
//
// Version
//


#include <wmdm_ver.h>
    
#define VER_WMDM_FILE_FILETYPE                VFT_DLL
#define VER_WMDM_FILE_FILEDESCRIPTION_STR     "WMDMProgressHelper Module\0"
#define VER_WMDM_FILE_INTERNALNAME_STR        "ProgHelp.DLL\0"
#define VER_WMDM_FILE_OLEREGISTER
#include <wmdm_ver.ver>


#endif    // !_MAC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\apps\proghelp\progresshelper.h ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

//
// ProgressHelper.h : Declaration of the CProgressHelper
//

#ifndef __PROGRESSHELPER_H_
#define __PROGRESSHELPER_H_

#include "progRC.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
//
// CProgressHelper
//
class ATL_NO_VTABLE CProgressHelper : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CProgressHelper, &CLSID_ProgressHelper>,
	public IWMDMProgress,
	public IWMDMProgressHelper
{

	HWND           m_hwnd;
	UINT           m_uMsg;
	PROGRESSNOTIFY m_progressnotify;
	BOOL           m_fCancelled;

public:
	CProgressHelper();
	~CProgressHelper();

DECLARE_REGISTRY_RESOURCEID(IDR_WMDMPROGRESSHELPER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CProgressHelper)
	COM_INTERFACE_ENTRY(IWMDMProgressHelper)
	COM_INTERFACE_ENTRY(IWMDMProgress)
END_COM_MAP()

public:

	// IWMDMProgress
    STDMETHOD (Begin)( DWORD dwEstimatedTicks );
    STDMETHOD (Progress)( DWORD dwTranspiredTicks );
    STDMETHOD (End)();

	// IWMDMProgressHelper
	STDMETHOD (SetNotification)( HWND hwnd, UINT uMsg );
	STDMETHOD (Cancel)( VOID );
};

#endif //__PROGRESSHELPER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\apps\wmdmapp\apppch.cpp ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

//
// This workspace contains two projects -
// 1. ProgHelp which implements the Progress Interface 
// 2. The Sample application WmdmApp. 
//
//  ProgHelp.dll needs to be registered first for the SampleApp to run.


// apppch.cpp : source file that includes just the standard includes
// apppch.pch will be the pre-compiled header
// apppch.obj will contain the pre-compiled type information

#include "appPCH.h"

// TODO: reference any additional headers you need in apppch.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\apps\proghelp\progresshelper.cpp ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

//
// ProgressHelper.cpp : Implementation of CProgressHelper
//

#include "progPCH.h"
#include "ProgHelp.h"
#include "ProgressHelper.h"
#include <stdio.h>

//
// Constructor/Destructor
//

CProgressHelper::CProgressHelper()
{
	m_hwnd = 0;
	m_uMsg = 0;

	FillMemory( &m_progressnotify, sizeof(m_progressnotify), 0 );

	m_fCancelled = FALSE;
}

CProgressHelper::~CProgressHelper()
{
}


//
// IWMDMProgress methods
//

HRESULT CProgressHelper::Begin( DWORD dwEstimatedTicks )
{
	// Check notification values
	//
	if( !m_hwnd || !m_uMsg )
	{
		return E_FAIL;
	}

	// Check if the user has cancelled this operation
	//
	if( m_fCancelled )
	{
		return WMDM_E_USER_CANCELLED;
	}

	// Populate the notify structure with the valid values
	//
	m_progressnotify.dwMsg        = SFM_BEGIN;
	m_progressnotify.dwTotalTicks = dwEstimatedTicks;

	// Send the message to the notification window
	//
	SendMessage( m_hwnd, m_uMsg, 0, (LPARAM)&m_progressnotify );

	return S_OK;
}

HRESULT CProgressHelper::Progress( DWORD dwTranspiredTicks )
{
	// Check notification values
	//
	if( !m_hwnd || !m_uMsg )
	{
		return E_FAIL;
	}

	// Check if the user has cancelled this operation
	//
	if( m_fCancelled )
	{
		return WMDM_E_USER_CANCELLED;
	}

	// Populate the notify structure with the valid values
	//
	m_progressnotify.dwMsg          = SFM_PROGRESS;
	m_progressnotify.dwCurrentTicks = dwTranspiredTicks;

	// Send the message to the notification window
	//
	SendMessage( m_hwnd, m_uMsg, 0, (LPARAM)&m_progressnotify );

	return S_OK;
}

HRESULT CProgressHelper::End()
{
	// Check notification values
	//
	if( !m_hwnd || !m_uMsg )
	{
		return E_FAIL;
	}

	// Check if the user has cancelled this operation
	//
	if( m_fCancelled )
	{
		return WMDM_E_USER_CANCELLED;
	}

	// Populate the notify structure with the valid values
	//
	m_progressnotify.dwMsg          = SFM_END;
	m_progressnotify.dwCurrentTicks = m_progressnotify.dwTotalTicks;

	// Send the message to the notification window
	//
	SendMessage( m_hwnd, m_uMsg, 0, (LPARAM)&m_progressnotify );

	return S_OK;
}

//
// IWMDMProgressHelper methods
//

HRESULT CProgressHelper::SetNotification( HWND hwnd, UINT uMsg )
{
	if( !hwnd || !uMsg || uMsg < WM_USER )
	{
		return E_INVALIDARG;
	}

	m_hwnd = hwnd;
	m_uMsg = uMsg;

	return S_OK;
}

HRESULT CProgressHelper::Cancel( void )
{
	m_fCancelled = TRUE;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\apps\wmdmapp\apppch.h ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

// This workspace contains two projects -
// 1. ProgHelp which implements the Progress Interface 
// 2. The Sample application WmdmApp. 
//
//  ProgHelp.dll needs to be registered first for the SampleApp to run.


// apppch.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__EFE21268_E11A_11D2_99F9_00C04F72D6CF__INCLUDED_)
#define AFX_STDAFX_H__EFE21268_E11A_11D2_99F9_00C04F72D6CF__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// Insert your headers here
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

#ifndef STRICT
#define STRICT
#endif

#define INC_OLE2        // WIN32, get ole2 from windows.h


#include <windows.h>
#include <windowsx.h>
#include <shlobj.h>
#include <shellapi.h>

// TODO: reference additional headers your program requires here

#include "util.h"
#include "appRC.h"

#include "mswmdm.h"
#include "itemdata.h"
#include "wmdevmgr.h"

#include "status.h"
#include "progress.h"
#include "devices.h"
#include "devfiles.h"
#include "wmdmapp.h"
#include "Properties.h"

#define STRSAFE_NO_DEPRECATE
#include "StrSafe.h"
#include <crtdbg.h>
//
//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.


#endif // !defined(AFX_STDAFX_H__EFE21268_E11A_11D2_99F9_00C04F72D6CF__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\apps\wmdmapp\apprc.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wmdmapp.rc
//
#define IDI_ICON                        101
#define IDS_APP_TITLE                   101
#define IDR_MENU                        139
#define IDD_DEVICES                     140
#define IDD_DEVICEFILES                 141
#define IDI_DEVICE                      143
#define IDD_PROGRESS                    144
#define IDD_WORKING                     145
#define IDD_PROPERTIES_DEVICE           146
#define IDD_PROPERTIES_STORAGE          147
#define IDR_CONTEXT_MENU                148
#define IDS_REG_ROOT                    201
#define IDS_REG_PATH_BASE               201
#define IDS_REG_KEY_XPOS                251
#define IDS_REG_KEY_YPOS                252
#define IDS_REG_KEY_WIDTH               253
#define IDS_REG_KEY_HEIGHT              254
#define IDS_DEF_WIDTH                   301
#define IDS_DEF_HEIGHT                  302
#define IDS_COLSIZE_1                   501
#define IDS_COLSIZE_2                   502
#define IDS_COLSIZE_3                   503
#define IDS_COLNAME_1                   551
#define IDS_COLNAME_2                   552
#define IDS_COLNAME_3                   553
#define IDS_SB_DEVICE_ONE               701
#define IDS_SB_DEVICE_MANY              702
#define IDS_SB_DEVICEFILES_ONE          703
#define IDS_SB_DEVICEFILES_MANY         704
#define IDS_SB_DEVICEFILES_FREE         705
#define IDS_SB_DEVICEFILES_USED         706
#define IDS_STATUS_EMPTY                707
#define IDS_PROGRESS_COUNT              708
#define IDS_PROGRESS_BYTECOUNT          709
#define IDS_BYTESSIZE_NOCOMMA           801
#define IDS_KBSIZE_NOCOMMA              802
#define IDS_KBSIZE_COMMA                803
#define IDS_MBSIZE_NOCOMMA              804
#define IDS_MBSIZE_COMMA                805
#define IDS_MBSIZE_DECIMAL              806
#define IDS_REVOKED_CAPTION             900
#define IDS_APP_UPDATE_URL              901
#define IDS_APP_REVOKED                 902
#define IDS_COMPONENT_REVOKED           903
#define IDS_PROPERTIES_CAPTION          904
#define IDC_LV_DEVICEFILES              1007
#define IDC_LV_DEVICES                  1008
#define IDC_PB_PROGRESS                 1009
#define IDC_ST_OPERATION                1010
#define IDC_ST_DETAILS                  1011
#define IDC_ST_COUNTER                  1012
#define IDC_ST_BYTECOUNTER              1013
#define IDC_SERIALID                    1014
#define IDC_SERIALID_STRING             1015
#define IDC_MANUFACTURER                1016
#define IDC_DEVICE_TYPE                 1017
#define IDC_ATTRIBUTES                  1018
#define IDC_POWER_CAP                   1018
#define IDC_CAPABILITIES                1019
#define IDC_POWER_IS                    1019
#define IDC_VERSION                     1021
#define IDC_DEVICE_STATUS               1022
#define IDM_DELETE                      32777
#define IDM_DEVICE_RESET                32783
#define IDM_CLOSE                       32784
#define IDM_REFRESH                     32785
#define IDM_OPTIONS_USE_OPERATION_INTERFACE 32786
#define IDM_PROPERTIES                  32787
#define IDC_STATIC                      -1
#define Status                          65535

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        149
#define _APS_NEXT_COMMAND_VALUE         32788
#define _APS_NEXT_CONTROL_VALUE         1020
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\apps\wmdmapp\devfiles.h ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

//
// This workspace contains two projects -
// 1. ProgHelp which implements the Progress Interface 
// 2. The Sample application WmdmApp. 
//
//  ProgHelp.dll needs to be registered first for the SampleApp to run.


//
//	devfiles.h
//

#ifndef		_DEVFILES_H_
#define		_DEVFILES_H_

#include "WMDMProgressHelper.h"
#include "WMDMOperationHelper.h"

///////////////////////////////////////////////////////////////////////////////
// 
class CDevFiles
{
	HWND    m_hwndDevFiles;
	HWND    m_hwndDevFiles_LV;

	INT     m_iFolderIcon;

	BOOL InitImageList( void );
	BOOL InitColumns( void );
	BOOL SendFilesToDevice( LPSTR pszFiles, UINT uNumFiles );

public:

	DWORD   m_dwTotalTicks;
	DWORD   m_dwWorkingTicks;

	CProgress            m_cProgress;
	IWMDMProgressHelper *m_pProgHelp;

	WNDPROC m_wndprocDevFiles_LV;

	// constructors/destructors
	CDevFiles();
	~CDevFiles();

	// operations
	BOOL Create( HWND hwndParent );
	VOID Destroy( void );

	HWND GetHwnd( void );
	HWND GetHwnd_LV( void );

	INT  GetSelectedItems( INT nItems[], INT *pnSelItems );
	VOID UpdateStatusBar( void );
	BOOL AddItem( CItemData *pItemData );
	BOOL RemoveItem( INT nItem );
	VOID RemoveAllItems( void );

	VOID OnSize( LPRECT prcMain );
	BOOL OnDropFiles( HWND hWnd, WPARAM wParam, LPARAM lParam );
    BOOL OkToDelete();
};


#endif		// _DEVFILES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\apps\wmdmapp\devfiles.cpp ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

//
// This workspace contains two projects -
// 1. ProgHelp which implements the Progress Interface 
// 2. The Sample application WmdmApp. 
//
//  ProgHelp.dll needs to be registered first for the SampleApp to run.



// Includes
//
#include "appPCH.h"

// Constants
//
#define DEVFILES_LV_NUMCOLS     3
#define DEVFILES_COL_MARGIN     3

#define SMALL_IMAGE_WIDTH       16

const CLSID CLSID_WMDMProgressHelper    = {0x8297A5B4,0x5113,0x11D3,{0xB2,0x76,0x00,0xC0,0x4F,0x8E,0xC2,0x21}};
const IID   IID_IWMDMProgressHelper     = {0x1DCB3A10,0x33ED,0x11d3,{0x84,0x70,0x00,0xC0,0x4F,0x79,0xDB,0xC5}};

const CLSID CLSID_WMDMOperationHelper   = {0x9FB01A67,0xA11E,0x4653,{0x8E,0xD6,0xB5,0xCE,0x73,0xCD,0xA3,0xE3}};
const IID   IID_IWMDMOperationHelper    = {0x41216997,0xC4D9,0x445A,{0xA3,0x88,0x39,0x3D,0x2B,0x85,0xA0,0xE5}};

// Macros
//

// Local functions
//
INT_PTR CALLBACK DevFiles_DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK WndProc_DevFiles_LV(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

// Local Variables
//
	
/////////////////////////////////////////////////////////////////////
//
// Function implementations
//
CDevFiles::CDevFiles()
{
	m_hwndDevFiles       = NULL;
	m_hwndDevFiles_LV    = NULL;

	m_iFolderIcon        = 0;

	m_dwTotalTicks       = 0;
	m_dwWorkingTicks     = 0;

	m_pProgHelp          = NULL;

	m_wndprocDevFiles_LV = NULL;

	CoInitialize( NULL );
}

CDevFiles::~CDevFiles()
{
	CoUninitialize();
}


HWND CDevFiles::GetHwnd( void )
{
	return m_hwndDevFiles;
}

HWND CDevFiles::GetHwnd_LV( void )
{
	return m_hwndDevFiles_LV;
}


BOOL CDevFiles::Create( HWND hwndParent )
{
	BOOL fRet = FALSE;

	// Create the Device Files dialog
	//
	m_hwndDevFiles = CreateDialogParam(
		g_hInst,
    	MAKEINTRESOURCE( IDD_DEVICEFILES ),
    	hwndParent,
		DevFiles_DlgProc,
		(LPARAM)this
	);
	ExitOnNull( m_hwndDevFiles );

	// Get a handle to the ListView control of the Device Files dialog
	//
	m_hwndDevFiles_LV = GetDlgItem( m_hwndDevFiles, IDC_LV_DEVICEFILES );

	// Set the user data to be this CDevFiles class pointer
	//
	SetWindowLongPtr( m_hwndDevFiles_LV, GWLP_USERDATA, (LPARAM)this );

	// Subclass the listview
	//
	m_wndprocDevFiles_LV = (WNDPROC) SetWindowLongPtr(
		m_hwndDevFiles_LV,
		GWLP_WNDPROC,
		(LONG_PTR)WndProc_DevFiles_LV
	);

	// Initialize image list
	//
	ExitOnFalse( InitImageList() );

	// Initialize columns
	//
	ExitOnFalse( InitColumns() );

	// Handle Drag and Dropped files
	//
	DragAcceptFiles( m_hwndDevFiles, TRUE );

	// Show the window
	//
	ShowWindow( m_hwndDevFiles, SW_SHOW );

	fRet = TRUE;

lExit:

	return fRet;
}


VOID CDevFiles::Destroy( void )
{
	// Remove all the item from the listview control
	//
	RemoveAllItems();

	// Destroy the window
	//
	if( m_hwndDevFiles )
	{
		DestroyWindow( m_hwndDevFiles );
	}
}


BOOL CDevFiles::InitImageList( void )
{
	BOOL             fRet            = FALSE;
	HRESULT          hr;
	IMalloc         *pMalloc         = NULL;
	LPITEMIDLIST     pidl            = NULL;
	HIMAGELIST       hShellImageList = NULL;
	SHFILEINFO       si;
	CHAR             szWinPath[MAX_PATH+1];
        UINT             nRet;

	// Get the index of the folder icon
	//
	nRet = GetWindowsDirectory( szWinPath, sizeof(szWinPath)/sizeof(szWinPath[0]) );
        if (nRet == 0 || nRet > sizeof(szWinPath)/sizeof(szWinPath[0]))
        {
            // Failed to get the windows directory
            goto lExit;
        }

	// Get a shell ID list for the desktop folder
	//
	hr = SHGetSpecialFolderLocation( g_hwndMain, CSIDL_DESKTOP, &pidl );
	ExitOnFail( hr );

	// Get the shell's small icon image list and set that to be the listview's image list
	//
	hShellImageList = (HIMAGELIST) SHGetFileInfo(
		(LPCTSTR)pidl, 0,
		&si, sizeof(si),
		SHGFI_PIDL | SHGFI_SYSICONINDEX | SHGFI_SMALLICON 
	);
	if( hShellImageList )
	{
		ListView_SetImageList( m_hwndDevFiles_LV, hShellImageList, LVSIL_SMALL );
	}
        
	// Get the shell's normal icon image list and set that to be the listview's image list
	//
	hShellImageList = (HIMAGELIST) SHGetFileInfo(
		(LPCTSTR)pidl, 0,
		&si, sizeof(si),
		SHGFI_PIDL | SHGFI_SYSICONINDEX
	);
	if( hShellImageList )
	{
		ListView_SetImageList( m_hwndDevFiles_LV, hShellImageList, LVSIL_NORMAL );
	}

	SHGetFileInfo( szWinPath, 0, &si, sizeof(si), SHGFI_SYSICONINDEX );
	m_iFolderIcon = si.iIcon;

	// Everything went Ok
	//
	fRet = TRUE;

lExit:

	// Free the pointer to the shell's ID list
	//
        if (pidl)
        {
            hr = SHGetMalloc( &pMalloc );
            if( SUCCEEDED(hr) && pMalloc )
            {
                    pMalloc->Free( pidl );
            }
        }

	return fRet;
}


BOOL CDevFiles::InitColumns( void )
{
	LVCOLUMN lvcol;
	INT      i;
	char     szCol[MAX_PATH];

	//
	// Add the report-view columns to the listview
	// The column names and starting sizes are stored in the resource string table
	//

	lvcol.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
	lvcol.fmt  = LVCFMT_LEFT;

	for( i=0; i < DEVFILES_LV_NUMCOLS; i++ )
	{
		// Get the column size
		//
		LoadString( g_hInst, IDS_COLSIZE_1+i, szCol, sizeof(szCol) );
		lvcol.cx = atoi( szCol );
	
		// Get the column name
		//
		LoadString( g_hInst, IDS_COLNAME_1+i, szCol, sizeof(szCol) );
		lvcol.pszText = szCol;
	
		// Add the column the the listview
		//
		ListView_InsertColumn( m_hwndDevFiles_LV, i, &lvcol );
	}

	return TRUE;
}


VOID CDevFiles::OnSize( LPRECT prcMain )
{
	INT   nX, nY, nW, nH;
	RECT  rcMain;
	RECT  rcDevice;

	GetWindowRect( g_hwndMain, &rcMain );
	GetWindowRect( g_cDevices.GetHwnd(), &rcDevice );

	nX = (rcDevice.right - rcMain.left) - 2*GetSystemMetrics( SM_CXEDGE );
	nY = 0;
	nW = prcMain->right - prcMain->left - nX;
	nH = prcMain->bottom - prcMain->top;

	SetWindowPos( m_hwndDevFiles,    NULL, nX, nY, nW,    nH, SWP_NOZORDER );
	SetWindowPos( m_hwndDevFiles_LV, NULL,  0,  0, nW, nH-22, SWP_NOZORDER );
}


BOOL CDevFiles::SendFilesToDevice( LPSTR pszFiles, UINT uNumFiles )
{
	BOOL       fRet        = FALSE;
	WCHAR      wszName[MAX_PATH];
	CHAR       szName[MAX_PATH];
	LPSTR      psz;
	DWORD      dwTotalSize = 0L;
	UINT       uFile;
	HRESULT    hr;
	HTREEITEM  hItem;
	CItemData *pItemData;
	IWMDMStorageControl *pStorageControl = NULL;
	IWMDMStorage        *pNewObject      = NULL;
	IWMDMStorage        *pInStorage      = NULL;
	IWMDMProgress       *pProgress       = NULL;
	IWMDMOperation      *pOperation      = NULL;
	IWMDMOperationHelper    *pOperationHelper = NULL;      
    IWMDMRevoked        *pRevoked = NULL;
    LPWSTR      pwszRevokedURL = NULL;
    DWORD       dwRevokedURLLen = 0;
    DWORD       dwRevokedBitFlag;

	// Get the selected device/storage
	//
	hItem = g_cDevices.GetSelectedItem( NULL );
	ExitOnNull( hItem );

	// Get the itemdata class associated with the hItem and 
	// retrieve the IWMDMStorage for it
	//
	pItemData = (CItemData *) TreeView_GetLParam( g_cDevices.GetHwnd_TV(), hItem );
	ExitOnNull( pItemData );

	pInStorage = ( pItemData->m_fIsDevice ? pItemData->m_pRootStorage : pItemData->m_pStorage );
	ExitOnNull( pInStorage );

	// Tally the file sizes
	//
	psz = pszFiles;
	for( uFile = 0; uFile < uNumFiles; uFile++ )
	{
		dwTotalSize += GetTheFileSize( psz );

		psz += lstrlen(psz) + 1;
	}

	// Create the progress dialog
	//
	ExitOnFalse( m_cProgress.Create(g_hwndMain) );

	m_cProgress.SetOperation( "Sending Files..." );
	m_cProgress.SetCount( 0, uNumFiles );
	m_cProgress.SetRange( 0, 100 );
	m_dwTotalTicks   = dwTotalSize;
	m_dwWorkingTicks = 0;

	// Create the progress interface
	//
	hr = CoCreateInstance(
		CLSID_WMDMProgressHelper,
		NULL, CLSCTX_ALL,
		IID_IWMDMProgress,
		(void**)&pProgress
	);
	ExitOnFail( hr );

	pProgress->AddRef();

	hr = pProgress->QueryInterface(
		IID_IWMDMProgressHelper,
		reinterpret_cast<void**> (&m_pProgHelp)
	);
	ExitOnFail( hr );

	m_pProgHelp->SetNotification( m_hwndDevFiles, WM_DRM_PROGRESS );

    // Setup for copy using operation interface.
    if( g_bUseOperationInterface )
    {
	    // Create the progress interface
	    //
	    hr = CoCreateInstance(
		                    CLSID_WMDMOperationHelper,
		                    NULL, CLSCTX_INPROC_SERVER,
		                    IID_IWMDMOperationHelper,
		                    (void**)&pOperationHelper );
	    ExitOnFail( hr );

	    hr = pOperationHelper->QueryInterface(
		                        IID_IWMDMOperation,
		                        reinterpret_cast<void**> (&pOperation) );
	    ExitOnFail( hr );

        // Pass the SecureChannelClient as a pointer to the ProgHelper object. 
        // The object is inproc so it should be safe to pass pointers 
        pOperationHelper->SetSAC( (void*)g_cWmdm.m_pSAC );
    }

    

	// Acquire the storage control interface
	//
	hr = pInStorage->QueryInterface(
		IID_IWMDMStorageControl,
		reinterpret_cast<void**>(&pStorageControl)
	);
	ExitOnFail( hr );

	// Loop through the files, transfering each one
	//
	psz = pszFiles;
	for( uFile = 0; uFile < uNumFiles && !m_cProgress.IsCancelled(); uFile++ )
	{
		hr = StringCchCopy(szName, sizeof(szName)/sizeof(szName[0]), psz);

		if (FAILED(hr))
		{
			fRet = FALSE;
			break;
		}
		
		if (!MultiByteToWideChar(
			CP_ACP, 0,
			szName, -1,
			wszName, sizeof(wszName)/sizeof(wszName[0])
		))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());		
			fRet = FALSE;
			break;
		}
		// Set progress bar stats for this file
		//
		m_cProgress.IncCount();
		StripPath( szName );
		m_cProgress.SetDetails( szName );
		m_cProgress.Show( TRUE );

		UiYield();

		pNewObject = NULL;

        // Copy using operation interface.
        if( g_bUseOperationInterface )
        {
            // @@@@ The implementation treats the argument as a WCHAR*, not a
            // BSTR, so this is ok. The simplest solution is to change the 
            // interface definition to WCHAR*. Will that cause any harm? 
            // (Interface appears to be a private one.)
            //
            // The alternative is to call SysAllocString. The issue with
            // this approach is handling errors. Also SysAllocString inexplicably
            // returns NULL when *wszName = 0. Can that happen?
            //
            pOperationHelper->SetFileName( wszName );

            hr = pStorageControl->Insert(
			        WMDM_MODE_BLOCK | WMDM_CONTENT_FILE | WMDM_CONTENT_OPERATIONINTERFACE,
			        NULL,
			        pOperation,
			        pProgress,
			        &pNewObject );
        }
        else
        {
    	    hr = pStorageControl->Insert(
			        WMDM_MODE_BLOCK | WMDM_CONTENT_FILE,
			        wszName,
			        NULL,
			        pProgress,
			        &pNewObject );
        }

        // Handle the case where one of the needed components was revoked
        if( hr == WMDM_E_REVOKED )
        {
            char pszCaption[MAX_PATH];
            char pszErrorMsg[MAX_PATH];  

            // Hide progress window before displaying error messages
        	m_cProgress.Show( FALSE );

            // Get Revocation interface from WMDM
            hr = pStorageControl->QueryInterface( IID_IWMDMRevoked, (void**)&pRevoked );
            if( hr != S_OK || pRevoked == NULL )
            {
                // Latest version of WMDM not avalible on machine?
                fRet = FALSE;
                break;
            }

            // Get revocation information from WMDM
            hr = pRevoked->GetRevocationURL( &pwszRevokedURL, &dwRevokedURLLen, &dwRevokedBitFlag );
            if( FAILED(hr) )
            {
                fRet = FALSE;
                break;
            }
            
            // The application has been revoked
            if( dwRevokedBitFlag & WMDM_APP_REVOKED )
            {
                LoadString( g_hInst, IDS_REVOKED_CAPTION, pszCaption, sizeof(pszCaption) );
                LoadString( g_hInst, IDS_APP_REVOKED, pszErrorMsg, sizeof(pszErrorMsg) );

                ::MessageBoxA( g_hwndMain, pszErrorMsg, pszCaption, MB_OK );
            }
            // A component needed for the transfer has been revoked, give the user 
            // a chance to look for an update on the internet.
            else
            {
                LoadString( g_hInst, IDS_REVOKED_CAPTION, pszCaption, sizeof(pszCaption) );
                LoadString( g_hInst, IDS_COMPONENT_REVOKED, pszErrorMsg, sizeof(pszErrorMsg) );
                if( ::MessageBoxA( g_hwndMain, pszErrorMsg, pszCaption, MB_YESNO ) == IDYES )
                {
                    ShellExecuteW(g_hwndMain, L"open", pwszRevokedURL, NULL, NULL, SW_SHOWNORMAL); 
                }
            }
            CoTaskMemFree( pwszRevokedURL );
            break;
        }      
       
        if( SUCCEEDED(hr) && pNewObject )
		{
			CItemData *pStorageItem = new CItemData;
			
			if( pStorageItem )
			{
				hr = pStorageItem->Init( pNewObject );

				if( SUCCEEDED(hr) )
				{
					g_cDevFiles.AddItem( pStorageItem );
				}
				else
				{
					delete pStorageItem;
				}
			}

			pNewObject->Release();
		}

		psz += lstrlen(psz) + 1;
	}

	// Make sure the dialog is hidden and then destroy it
	//
	m_cProgress.SetPos( -1 );
	m_cProgress.Show( FALSE );
	m_cProgress.Destroy();

	// refresh the device/devicefiles display
	g_cDevices.UpdateSelection( NULL, FALSE );

lExit:
    if( pOperationHelper )
    {
        pOperationHelper->Release();
    }
    if( pOperation )
    {
        pOperation->Release();
    }
	if( pStorageControl )
	{
		pStorageControl->Release();
	}
    if( pRevoked )
    {
        pRevoked->Release();
    }

	if( m_pProgHelp )
	{
		m_pProgHelp->Release();
		m_pProgHelp = NULL;
	}

	if( pProgress )
	{
		pProgress->Release();
	}

	return fRet;
}


BOOL CDevFiles::OnDropFiles( HWND hWnd, WPARAM wParam, LPARAM lParam )
{
	LPSTR  lpsz      = NULL;
	HANDLE hDrop     = (HANDLE) wParam;
	UINT   uNumFiles;

	// Turn the drop list into a double-zero-terminated list of strings
	//
	lpsz = DropListToBuffer( (HDROP)hDrop, LTB_NULL_TERM, &uNumFiles );
	ExitOnNull( lpsz );

	// Send those files to the selected device
	//
	SendFilesToDevice( lpsz, uNumFiles );

lExit:

	// Close the dragdrop operation
	//
	DragFinish( (HDROP)hDrop );

	if( lpsz )
	{
		MemFree( lpsz );
	}

	return 0;   // return zero if we process this message
}


VOID CDevFiles::RemoveAllItems( void )
{
	INT    i;
	INT    nCount;

	nCount = ListView_GetItemCount( m_hwndDevFiles_LV );

	// Remove the items one at a time, from the bottom up
	//
	for( i=nCount-1; i >= 0; i-- )
	{
		RemoveItem( i );
	}
}

BOOL CDevFiles::RemoveItem( INT nItem )
{
	CItemData *pStorage;

	pStorage = (CItemData *) ListView_GetLParam( m_hwndDevFiles_LV, nItem );

	if( pStorage )
	{
		delete pStorage;
	}

	return ListView_DeleteItem( m_hwndDevFiles_LV, nItem );
}

BOOL CDevFiles::AddItem( CItemData *pStorage )
{
	LVITEM lvitem;
	INT    nItem;
	CHAR   sz[MAX_PATH];
	INT    m_iSysFolderIcon = 0;

	// Set the icon index.
	// If the storage is a folder, use the folder icon, otherwise
	// use the icon associated with that file type.
	//
    if( pStorage->m_dwAttributes & WMDM_FILE_ATTR_FOLDER )
    {
        lvitem.iImage = m_iFolderIcon;
    }
    else
    {
		TCHAR szType[MAX_PATH];
        
		lvitem.iImage = GetShellIconIndex(
			pStorage->m_szName,
			szType, sizeof(szType)/sizeof(szType[0])
		);
    }

	lvitem.mask     = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
	lvitem.iItem    = 10000;
	lvitem.iSubItem = 0;
	lvitem.pszText  = pStorage->m_szName;
	lvitem.lParam   = (LPARAM)pStorage;

	// Insert the item into the listview
	//
	nItem = ListView_InsertItem( m_hwndDevFiles_LV, &lvitem ); 
	if( -1 == nItem )
	{
		return FALSE;
	}

	// Set the size field blank for a folder, or for the file size for a file
	//
	ListView_SetItemText(
		m_hwndDevFiles_LV,
		nItem,
		1,
		( (pStorage->m_dwAttributes & WMDM_FILE_ATTR_FOLDER) ? " " : FormatBytesToSz(pStorage->m_dwSizeLow, 0, 1, sz, sizeof(sz)) )
	);

	// Set the description field to be the display date
	//
	{
		SYSTEMTIME systime;

		// Copy the WMDMDATETIME fields to a SYSTEMTIME structure for manipulation
		//
		systime.wYear         = pStorage->m_DateTime.wYear;
		systime.wMonth        = pStorage->m_DateTime.wMonth;
		systime.wDayOfWeek    = 0;
		systime.wDay          = pStorage->m_DateTime.wDay;
		systime.wHour         = pStorage->m_DateTime.wHour;
		systime.wMinute       = pStorage->m_DateTime.wMinute;
		systime.wSecond       = pStorage->m_DateTime.wSecond;
		systime.wMilliseconds = 0;

		ListView_SetItemText(
			m_hwndDevFiles_LV,
			nItem,
			2,
			FormatSystemTimeToSz( &systime, sz, sizeof(sz) )
		);
	}

	// Update the status bar with the changes resulting from the insertion of this item
	//
	UpdateStatusBar();

	return TRUE;
}

VOID CDevFiles::UpdateStatusBar( void )
{
	INT       nCount;
	UINT      uStrID;
	HTREEITEM hItem = g_cDevices.GetSelectedItem( NULL );

	if( NULL == hItem )
	{
		// If no device is selected, blank out the pane specifying the number of files
		//
		g_cStatus.SetTextSz( SB_PANE_DEVFILES, "" );
	}
	else
	{
		// If a device is selected, set the statusbar pane that shows the number of files
		//
		nCount = ListView_GetItemCount( m_hwndDevFiles_LV );

		// Get the grammatically-appropriate format string to use
		//
		if( nCount == 0 )
		{
			uStrID = IDS_SB_DEVICEFILES_MANY;
		}
		else if( nCount == 1 )
		{
			uStrID = IDS_SB_DEVICEFILES_ONE;
		}
		else
		{
			uStrID = IDS_SB_DEVICEFILES_MANY;
		}

		// Set the text of the pane
		//
		g_cStatus.SetTextFormatted( SB_PANE_DEVFILES, uStrID, nCount, NULL );
	}
}


INT CDevFiles::GetSelectedItems( INT nItems[], INT *pnSelItems )
{
	INT nRet         = -1;
	INT nNumSelItems = ListView_GetSelectedCount( m_hwndDevFiles_LV );
	INT nNumItems    = ListView_GetItemCount( m_hwndDevFiles_LV );
	INT nItemRoom    = *pnSelItems;
	INT i;
	INT iIndex;

	// Initialize return parameters
	//
	*pnSelItems = nNumSelItems;

	// If there isn't enough room for all the selected items, or if there
	// aren't any selected items, return -1.
	// The space needed is already in the nSelItems OUT param.
	//
	if( nItemRoom < nNumSelItems || 0 == nNumSelItems )
	{
		return -1;
	}

	// Loop thru all the items to determine whether or not they are
	// selected.  Fill in the OUT array with the ones that are.
	//
	for( i=0, iIndex=0; i < nNumItems; i++ )
	{
		UINT uState = ListView_GetItemState( m_hwndDevFiles_LV, i, LVIS_SELECTED | LVIS_FOCUSED );

		if( uState & LVIS_SELECTED )
		{
			nItems[iIndex++] = i;

			if( uState & LVIS_FOCUSED )
			{
				// Remember which item has focus, so it can be returned to the caller
				//
				nRet = i;
			}
		}
	}

	// If there are selected items, but nothing has focus, use the first selected item
	//
	if( nRet == -1 && nNumSelItems > 0 )
	{
		nRet = nItems[0];
	}

	return nRet;
}

// Is it ok to delete the currently selected files?
BOOL CDevFiles::OkToDelete()
{
    INT nNumItems    = ListView_GetItemCount( GetHwnd_LV() );
	CItemData *pStorage = NULL;

	// Loop thru all the items to determine whether or not they are
	// selected. Enable delete if any selected file can be deleted.
	//
	for( int iIndex=0; iIndex < nNumItems; iIndex++ )
	{
		if( ListView_GetItemState( GetHwnd_LV(), iIndex, LVIS_SELECTED ) )
        {
        	pStorage = (CItemData *) ListView_GetLParam( GetHwnd_LV(), iIndex );
            if( pStorage && (pStorage->m_dwAttributes & WMDM_FILE_ATTR_CANDELETE) )
                return TRUE;
        }
	}

    return FALSE;
}

/////////////////////////////////////////////////////////////////////
//
// Non-C++ functions
//


INT_PTR CALLBACK DevFiles_DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{   
	WORD              wId         = LOWORD((DWORD)wParam);
	WORD              wNotifyCode = HIWORD((DWORD)wParam);
	static CDevFiles *cDevFiles   = NULL;
	static HWND       hwndLV      = NULL;

    switch( uMsg )
    {
	case WM_INITDIALOG:
		cDevFiles = (CDevFiles *)lParam;
		hwndLV    = GetDlgItem( hWnd, IDC_LV_DEVICEFILES );
		break;

	case WM_NOTIFY:
		{
			LPNMLISTVIEW pnmv  = (LPNMLISTVIEW) lParam;
			UINT         uCode = pnmv->hdr.code;

			switch( uCode )
			{
			case LVN_BEGINDRAG:
				SendMessage( hwndLV, uMsg, wParam, lParam );
				break;
			
			default:
				break;
			}
		}
		break;

	case WM_DRM_PROGRESS:
		{
			PROGRESSNOTIFY *pNotify = (PROGRESSNOTIFY *)lParam;

			switch( pNotify->dwMsg )
			{
			case SFM_BEGIN:
				break;

			case SFM_PROGRESS:
				{
					DWORD dwTicks = cDevFiles->m_dwWorkingTicks + pNotify->dwCurrentTicks;

					cDevFiles->m_cProgress.SetPos(
						(INT)( dwTicks*100/cDevFiles->m_dwTotalTicks )
					);
					cDevFiles->m_cProgress.SetBytes(
						dwTicks,
						cDevFiles->m_dwTotalTicks
					);
				}
				break;

			case SFM_END:
				cDevFiles->m_dwWorkingTicks += pNotify->dwTotalTicks;
				break;
			}

			UiYield();

			// If the user cancelled the operation, tell the progress interface
			//
			if( cDevFiles->m_cProgress.IsCancelled() )
			{
				// Notify progress interface
				//
				cDevFiles->m_pProgHelp->Cancel();
			}
		}
		break;

	default:
		break;
	}
	
	return 0;
}    


LRESULT CALLBACK WndProc_DevFiles_LV(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{   
	static CDevFiles *cDevFiles   = NULL;
	WORD              wId         = LOWORD((DWORD)wParam);
	WORD              wNotifyCode = HIWORD((DWORD)wParam);

	if( NULL == cDevFiles )
	{
		cDevFiles = (CDevFiles *) GetWindowLongPtr( hWnd, GWLP_USERDATA );
	}

    switch( uMsg )
    {
    case WM_DROPFILES:
		return cDevFiles->OnDropFiles( hWnd, wParam, lParam );

	case WM_KEYDOWN:
		if( wParam == VK_DELETE )
		{
			SendMessage( g_hwndMain, WM_DRM_DELETEITEM, 0, 0 );
			return 0;
		}
		break;

    case WM_CONTEXTMENU :
    {
        HMENU  hMenuAll;
        HMENU  hMenuStorage;

        hMenuAll = LoadMenu(g_hInst, MAKEINTRESOURCE(IDR_CONTEXT_MENU));
        hMenuStorage = GetSubMenu(hMenuAll, 1);

        // Enable/disable delete
        if( !cDevFiles->OkToDelete() )
        {
            EnableMenuItem( hMenuStorage, IDM_DELETE, MF_BYCOMMAND | MF_GRAYED );
        }

        TrackPopupMenu( hMenuStorage,
                        TPM_LEFTALIGN | TPM_RIGHTBUTTON,
                        LOWORD(lParam),
                        HIWORD(lParam),
                        0,
                        hWnd,
                        NULL);

        DestroyMenu(hMenuAll);
        break;
    }

    case WM_COMMAND :
    {
        switch (wParam)
        {
            case IDM_PROPERTIES :
            {         
                // Display propeties dialog for this storage
    	        INT nNumItems    = ListView_GetItemCount( hWnd );
	            CItemData *pStorage = NULL;

	            // Get the storage of the item with focus.
	            //
	            for( int iIndex=0; iIndex < nNumItems; iIndex++ )
	            {
		            if( ListView_GetItemState( hWnd, iIndex, LVIS_FOCUSED ) )
                    {
        	            pStorage = (CItemData *) ListView_GetLParam( hWnd, iIndex );
                        break;
                    }
	            }
    
                // Display the properties dialog
                if( pStorage )
                {
                    DialogBoxParam( g_hInst,
                                    MAKEINTRESOURCE(IDD_PROPERTIES_STORAGE),
                                    g_hwndMain,
                                    StorageProp_DlgProc, 
                                    (LPARAM)pStorage );
                }
                break;
            }
            case IDM_DELETE :
            {         
                // Pass delete message on to main window
                PostMessage( g_hwndMain, uMsg, wParam, lParam );
            }
        }
    }

	default:
		break;
    }

	return CallWindowProc( cDevFiles->m_wndprocDevFiles_LV, hWnd, uMsg, wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\apps\wmdmapp\devices.cpp ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

//
// This workspace contains two projects -
// 1. ProgHelp which implements the Progress Interface 
// 2. The Sample application WmdmApp. 
//
//  ProgHelp.dll needs to be registered first for the SampleApp to run.


// Includes
//
#include "appPCH.h"

// Local variables
//

// Constants
//
#define MIN_DEVICEWND_W             200 

// Macros
//

// Local functions
//
INT_PTR CALLBACK Device_DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);


/////////////////////////////////////////////////////////////////////
//
// Function implementations
//
CDevices::CDevices()
{
	m_hwndDevices        = NULL;
	m_hwndDevices_TV     = NULL;

	m_himlSmall          = NULL;
}


CDevices::~CDevices()
{
}


HWND CDevices::GetHwnd( void )
{
	return m_hwndDevices;
}


HWND CDevices::GetHwnd_TV( void )
{
	return m_hwndDevices_TV;
}


BOOL CDevices::Create( HWND hwndParent )
{
	BOOL fRet = FALSE;

	// Create the Devices dialog
	//
	m_hwndDevices = CreateDialogParam(
		g_hInst,
    	MAKEINTRESOURCE( IDD_DEVICES ),
    	hwndParent,
		Device_DlgProc,
		(LPARAM)this
	);
	ExitOnNull( m_hwndDevices );

	m_hwndDevices_TV = GetDlgItem( m_hwndDevices, IDC_LV_DEVICES );

	// Initialize image list
	//
	ExitOnFalse( InitImageList() );

	// Show the window
	//
	ShowWindow( m_hwndDevices, SW_SHOW );

	fRet = TRUE;

lExit:

	return fRet;
}


VOID CDevices::Destroy( void )
{
	RemoveAllItems();

	if( m_hwndDevices )
	{
		DestroyWindow( m_hwndDevices );
	}

	if( m_himlSmall )
	{
		ImageList_Destroy( m_himlSmall );
	}
}


VOID CDevices::OnSize( LPRECT prcMain )
{
	INT  nW, nH;

	nW = max( (prcMain->right - prcMain->left)/4, MIN_DEVICEWND_W );
	nH = prcMain->bottom - prcMain->top;

	SetWindowPos( m_hwndDevices,    NULL, -4, 0,    nW,    nH, SWP_NOZORDER );
	SetWindowPos( m_hwndDevices_TV, NULL,  0, 0, nW-10, nH-27, SWP_NOZORDER );
}


BOOL CDevices::InitImageList( void )
{
	BOOL       fRet = FALSE;
	HICON      hIcon;

	// Init Small image list
	//
	m_himlSmall = ImageList_Create(
		GetSystemMetrics(SM_CXSMICON),
		GetSystemMetrics(SM_CYSMICON),
		ILC_COLOR32 | ILC_MASK, 
		-1, 0
	);
	ExitOnNull( m_himlSmall );

	// Load icons and add them to the image list
	//
	hIcon = LoadIcon( g_hInst, MAKEINTRESOURCE(IDI_DEVICE) );
	if( hIcon != NULL )
	{
		ImageList_AddIcon( m_himlSmall, hIcon );
	}
	
	// Add the shell folder icons to the image lsit
	//
	{
		CHAR       szWinPath[MAX_PATH+1];
		SHFILEINFO si;
                UINT       nRet;

                nRet = GetWindowsDirectory( szWinPath, sizeof(szWinPath)/sizeof(szWinPath[0]) );
                if (nRet > 0 && nRet <= sizeof(szWinPath)/sizeof(szWinPath[0]))
                {
                    SHGetFileInfo( szWinPath, 0, &si, sizeof(si), SHGFI_SYSICONINDEX | SHGFI_SMALLICON | SHGFI_ICON );
                    hIcon = si.hIcon;
                    ImageList_AddIcon( m_himlSmall, hIcon );

                    SHGetFileInfo( szWinPath, 0, &si, sizeof(si), SHGFI_SMALLICON | SHGFI_ICON | SHGFI_OPENICON );
                    hIcon = si.hIcon;
                    ImageList_AddIcon( m_himlSmall, hIcon );
                }
                else
                {
                    // @@@@ Do we bail out or is ok to go on?
                    // goto lExit;
                }
	}

	// Set the image list for the tree view
	//
	TreeView_SetImageList( m_hwndDevices_TV, m_himlSmall, TVSIL_NORMAL );

	// Everything went Ok
	//
	fRet = TRUE;

lExit:

	return fRet;
}


VOID CDevices::RemoveAllItems( void )
{
	HTREEITEM hItem;

	// Get Root item
	//
	hItem = TreeView_GetRoot( m_hwndDevices_TV );
	if( hItem )
	{
		do
		{
			// Remove all children of this device
			//
			INT nChildren = RemoveChildren( hItem );

			// Get the device class associated with this item
			//
			CItemData *pItemData = (CItemData *) TreeView_GetLParam( m_hwndDevices_TV, hItem );

			// Release device class
			//
			if( pItemData )
			{
				delete pItemData;

				TreeView_SetLParam( m_hwndDevices_TV, hItem, (LPARAM)NULL );
			}

			hItem = TreeView_GetNextSibling( m_hwndDevices_TV, hItem );

		} while( hItem != NULL ); 
	}

	// Then delete all the items from the list
	//
	TreeView_DeleteAllItems( m_hwndDevices_TV );
}


INT CDevices::RemoveChildren( HTREEITEM hItem )
{
	BOOL      nChildren = 0;
	HTREEITEM hNextItem;

	hNextItem = TreeView_GetChild( m_hwndDevices_TV, hItem );
	if( hNextItem )
	{
		do
		{
			nChildren++;

			// Remove all children of this device
			//
			nChildren += RemoveChildren( hNextItem );

			// Get the storage class associated with this item
			//
			CItemData *pItemData = (CItemData *) TreeView_GetLParam( m_hwndDevices_TV, hNextItem );

			// Release storage class
			//
			if( pItemData )
			{
				delete pItemData;

				TreeView_SetLParam( m_hwndDevices_TV, hNextItem, (LPARAM)NULL );
			}

			hNextItem = TreeView_GetNextSibling( m_hwndDevices_TV, hNextItem );

		} while( hNextItem != NULL ); 
	}

	return nChildren;
}


BOOL CDevices::AddItem( CItemData *pItemData )
{
	BOOL           fRet      = TRUE;
	HTREEITEM      hItem;
	TVINSERTSTRUCT tvis;

	// Set up the item information
	//
	tvis.hParent             = TVI_ROOT;
	tvis.hInsertAfter        = TVI_SORT;

	tvis.item.mask           = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM | TVIF_CHILDREN;
	tvis.item.pszText        = pItemData->m_szName;
	tvis.item.iImage         = I_IMAGECALLBACK;
	tvis.item.iSelectedImage = I_IMAGECALLBACK;
	tvis.item.lParam         = (LPARAM)pItemData;
	tvis.item.cChildren      = 0;

	// Add the item
	//
	hItem = TreeView_InsertItem( m_hwndDevices_TV, &tvis ); 
	if( NULL == hItem )
	{
		return FALSE;
	}

	// If there are children, update the item
	//
	if( HasSubFolders(hItem) )
	{
		tvis.item.mask      = TVIF_HANDLE | TVIF_CHILDREN;
		tvis.item.hItem     = hItem;
		tvis.item.cChildren = 1;
		
		TreeView_SetItem( m_hwndDevices_TV, &(tvis.item) ); 
	}

	return fRet;
}


INT CDevices::AddChildren( HTREEITEM hItem, BOOL fDeviceItem )
{
	INT               nChildren    = 0;
	HRESULT           hr;
	IWMDMEnumStorage *pEnumStorage;

	// Get the storage enumerator associated with the hItem and 
	//
	CItemData *pItemData = (CItemData *) TreeView_GetLParam( m_hwndDevices_TV, hItem );
	ExitOnNull( pItemData );

	pEnumStorage = pItemData->m_pEnumStorage;
	ExitOnNull( pEnumStorage );

	// Reset the storage enumerator
	//
	hr = pEnumStorage->Reset();
	ExitOnFail( hr );

	// Add the appropriate list of files to the ListView
	//
	while( TRUE )
	{
		IWMDMStorage *pWmdmStorage;
		CItemData    *pItemStorage;
		ULONG         ulFetched;

		hr = pEnumStorage->Next( 1, &pWmdmStorage, &ulFetched );
		if( hr != S_OK )
		{
			break;
		}
		if( ulFetched != 1 )
		{
			ExitOnFail( hr = E_UNEXPECTED );
		}

		pItemStorage = new CItemData;
		if( pItemStorage )
		{
			hr = pItemStorage->Init( pWmdmStorage );
			
			if( SUCCEEDED(hr) && pItemStorage->m_dwAttributes & WMDM_FILE_ATTR_FOLDER )
			{
				HTREEITEM      hNewItem;
				TVINSERTSTRUCT tvis;

				// Set up the item information
				//
				tvis.hParent             = hItem;
				tvis.hInsertAfter        = TVI_SORT;

				tvis.item.mask           = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM | TVIF_CHILDREN;
				tvis.item.pszText        = pItemStorage->m_szName;
				tvis.item.iImage         = I_IMAGECALLBACK;
				tvis.item.iSelectedImage = I_IMAGECALLBACK;
				tvis.item.lParam         = (LPARAM)pItemStorage;
				tvis.item.cChildren      = 0;

				// Add the item
				//
				hNewItem = TreeView_InsertItem( m_hwndDevices_TV, &tvis ); 
				if( hNewItem )
				{
					nChildren++;

					// If there are children, update the item
					//
					if( HasSubFolders(hNewItem) )
					{
						tvis.item.mask      = TVIF_HANDLE | TVIF_CHILDREN;
						tvis.item.hItem     = hNewItem;
						tvis.item.cChildren = 1;
						
						TreeView_SetItem( m_hwndDevices_TV, &(tvis.item) ); 
					}
				}
				else
				{
					delete pItemStorage;
				}
			}
			else
			{
				delete pItemStorage;
			}
		}

		pWmdmStorage->Release();
	}

lExit:

	return nChildren;
}


BOOL CDevices::HasSubFolders( HTREEITEM hItem )
{
	BOOL fRet = FALSE;

	// Get the storage enumeration interface from the item
	//
	CItemData *pItemData = (CItemData *) TreeView_GetLParam( m_hwndDevices_TV, hItem );
	ExitOnNull( pItemData );

	// If the item is a device or has the has-subfolders attribute set,
	// then return TRUE.  Otherwise, return FALSE
	//
	if( pItemData->m_fIsDevice )
	{
		fRet = TRUE;
	}
	else if( pItemData->m_dwAttributes & WMDM_STORAGE_ATTR_HAS_FOLDERS )
	{
		fRet = TRUE;
	}
	else
	{
		fRet = FALSE;
	}

lExit:

	return fRet;
}


HTREEITEM CDevices::GetSelectedItem( LPARAM *pLParam )
{
	HTREEITEM hItem = TreeView_GetSelection( m_hwndDevices_TV );

	if( hItem )
	{
		// Return the lParam value of the item that is selected
		//
		if( pLParam )
		{
			*pLParam = TreeView_GetLParam( m_hwndDevices_TV, hItem );
		}
	}

	return hItem;
}


BOOL CDevices::SetSelectedItem( HTREEITEM hItem )
{
	return TreeView_SelectItem( m_hwndDevices_TV, hItem );
}


BOOL CDevices::UpdateSelection( HTREEITEM hItem, BOOL fDirty )
{
	BOOL              fRet         = FALSE;
	HRESULT           hr;
	IWMDMEnumStorage *pEnumStorage = NULL;

	// If hItem is NULL, then use the currently-selected item.
	// If no item is selected, use the first device.
	//
	if( NULL == hItem )
	{
		hItem = GetSelectedItem( NULL );

		if( NULL == hItem )
		{
			hItem = TreeView_GetRoot( m_hwndDevices_TV );

			// If there are no devices, just exit
			//
			ExitOnNull( hItem );
		}
	}

	if( fDirty )
	{
		// Remove all current files
		//
		g_cDevFiles.RemoveAllItems();

		// Get the storage enumeration interface from the item
		//
		CItemData *pItemData = (CItemData *) TreeView_GetLParam( m_hwndDevices_TV, hItem );
		ExitOnNull( pItemData );

		pEnumStorage = pItemData->m_pEnumStorage;
		ExitOnNull( pEnumStorage );

		// Reset the storage enumerator
		//
		hr = pEnumStorage->Reset();
		ExitOnFail( hr );

		// Add the appropriate list of files to the ListView
		//
		while( TRUE )
		{
			IWMDMStorage *pWmdmStorage;
			CItemData    *pItemStorage;
			ULONG         ulFetched;

			hr = pEnumStorage->Next( 1, &pWmdmStorage, &ulFetched );
			if( hr != S_OK )
			{
				break;
			}
			if( ulFetched != 1 )
			{
				ExitOnFail( hr = E_UNEXPECTED );
			}

			pItemStorage = new CItemData;
			if( pItemStorage )
			{
				hr = pItemStorage->Init( pWmdmStorage );
				if( SUCCEEDED(hr) )
				{
					g_cDevFiles.AddItem( pItemStorage );
				}
				else
				{
					delete pItemStorage;
				}

				UiYield();
			}

			pWmdmStorage->Release();
		}

		SetSelectedItem( hItem );
	}

	// Update the device portion of the status bar
	//
	UpdateStatusBar();

	// Update the file portion of the status bar
	//
	g_cDevFiles.UpdateStatusBar();

	fRet = TRUE;

lExit:

	return fRet;
}


INT CDevices::GetDeviceCount( VOID )
{
	INT       nCount = 0;
	HTREEITEM hItem;

	// Count Root items
	//
	for(
		hItem = TreeView_GetRoot( m_hwndDevices_TV );
		hItem != NULL;
		hItem = TreeView_GetNextSibling( m_hwndDevices_TV, hItem )
	)
	{
		nCount++;
	}

	return nCount;
}


CItemData *CDevices::GetRootDevice( HTREEITEM hItem )
{
	HTREEITEM hRootItem;

	while( TRUE )
	{
		hRootItem = hItem;

		hItem = TreeView_GetParent( m_hwndDevices_TV, hRootItem );

		if( hItem == NULL )
		{
			break;
		}
	}

	return (CItemData *) TreeView_GetLParam( m_hwndDevices_TV, hRootItem );
}


VOID CDevices::UpdateStatusBar( VOID )
{
	INT        nCount;
	HRESULT    hr;
	UINT       uStrID;
	HTREEITEM  hItem;
	CItemData *pItemDevice;
	DWORD      dwMemUsed;
	char       szSpaceKB[MAX_PATH];

	// Set the statusbar pane that shows the number of devices
	//
	nCount = GetDeviceCount();

	if( nCount == 0 )
	{
		uStrID = IDS_SB_DEVICE_MANY;
	}
	else if( nCount == 1 )
	{
		uStrID = IDS_SB_DEVICE_ONE;
	}
	else
	{
		uStrID = IDS_SB_DEVICE_MANY;
	}

	g_cStatus.SetTextFormatted( SB_PANE_DEVICE, uStrID, nCount, NULL );

	// If there is a selected device in the list, set the status for
	// the space free and used
	//
	hItem = GetSelectedItem( NULL );
	if( NULL == hItem )
	{
		// Empty the space used and free 
		//
		g_cStatus.SetTextSz( SB_PANE_DEVFILES_USED, "" );
		g_cStatus.SetTextSz( SB_PANE_DEVFILES_FREE, "" );
	}
	else
	{
		pItemDevice = GetRootDevice( hItem );
		ExitOnNull( pItemDevice );

		hr = pItemDevice->Refresh();
		ExitOnFail( hr );

		dwMemUsed = pItemDevice->m_dwMemSizeKB - pItemDevice->m_dwMemFreeKB - pItemDevice->m_dwMemBadKB;

		// Set the space used
		//
		g_cStatus.SetTextFormatted(
			SB_PANE_DEVFILES_USED,
			IDS_SB_DEVICEFILES_USED,
			-1,
			FormatBytesToSz(dwMemUsed, 0, 1024, szSpaceKB, sizeof(szSpaceKB))
		);
		// Set the space free
		//
		g_cStatus.SetTextFormatted(
			SB_PANE_DEVFILES_FREE,
			IDS_SB_DEVICEFILES_FREE,
			-1,
			FormatBytesToSz(pItemDevice->m_dwMemFreeKB, 0, 1024, szSpaceKB, sizeof(szSpaceKB))
		);
	}

lExit:

	return;
}


/////////////////////////////////////////////////////////////////////
//
// Local function implementations
//

INT_PTR CALLBACK Device_DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	WORD              wId                  = LOWORD((DWORD)wParam);
	WORD              wNotifyCode          = HIWORD((DWORD)wParam);
	static CDevices  *cDevices             = NULL;
	static HWND       hwndTV               = NULL;
	static BOOL       fSelChangeInProgress = FALSE;

	switch( uMsg )
	{
	case WM_INITDIALOG:
		cDevices = (CDevices *)lParam;
		hwndTV   = GetDlgItem( hWnd, IDC_LV_DEVICES );
		break;

	case WM_NOTIFY:
		{
			LPNMTREEVIEW pnmtv = (LPNMTREEVIEW)lParam;
			HWND    hwndCtl    = pnmtv->hdr.hwndFrom;
			UINT    uCode      = pnmtv->hdr.code;

			// check for item changes in the device listview.
			// if an item has changed its selected state, then update the files listview
			//
			if( hwndCtl != hwndTV )
			{
				break;
			}
			
			switch( uCode )
			{
			case TVN_SELCHANGED:
				if( pnmtv->itemNew.state & LVIS_SELECTED )
				{
					HTREEITEM  hItem       = (HTREEITEM) pnmtv->itemNew.hItem;
					CItemData *pItemDevice = (CItemData *) TreeView_GetLParam( hwndTV, hItem );

					// Check for NULL.  Without this, we crash when refreshing the display.
					// All pDevice values have been cleared, and we get this message as the
					// devices are being removed from the tree view as the selection moves 
					// from the device being removed, to the next in the list
					if( NULL != pItemDevice )
					{
						// Serialize the device changes, so that we finish changing devices
						// before another change begins
						if( !fSelChangeInProgress )
						{
							fSelChangeInProgress = TRUE;

							PostMessage( hWnd, WM_DRM_UPDATEDEVICE, (WPARAM)hItem, 0 );

							fSelChangeInProgress = FALSE;
						}
					}
				}
				break;

			case TVN_GETDISPINFO:
				{
					LPNMTVDISPINFO  lptvdi = (LPNMTVDISPINFO) lParam;
					INT             nImage;
					CItemData      *pItemData = (CItemData *) TreeView_GetLParam( hwndTV, lptvdi->item.hItem );

					if( NULL != pItemData )
					{
						if( pItemData->m_fIsDevice )
						{
							nImage = 0;
						}
						else
						{
							nImage = ( (lptvdi->item.state & TVIS_EXPANDED) ? 2 : 1 );
						}
						if( TVIF_IMAGE & lptvdi->item.mask )
						{
							lptvdi->item.iImage = nImage;
						}
						if( TVIF_SELECTEDIMAGE & lptvdi->item.mask )
						{
							lptvdi->item.iSelectedImage = nImage;
						}
					}
				}
				break;

			case TVN_ITEMEXPANDING:
				if( TVE_EXPAND & pnmtv->action )
				{
					// If the item has not been expanded once already,
					// add all its children
					//
					if( !(pnmtv->itemNew.state & TVIS_EXPANDEDONCE) )
					{
						BOOL fDeviceItem;

						fDeviceItem = ( NULL == TreeView_GetParent(hwndTV, pnmtv->itemNew.hItem) );

						cDevices->AddChildren( pnmtv->itemNew.hItem, fDeviceItem );
					}
				}
				else if( TVE_COLLAPSE & pnmtv->action )
				{
					// Do nothing
				}
				break;

			default:
				break;
			}
		}
		break;

      
    // Display the context menu for this device
    case WM_CONTEXTMENU :
    {
        HMENU  hMenuLoad;
        HMENU  hMenu;

        hMenuLoad = LoadMenu(g_hInst, MAKEINTRESOURCE(IDR_CONTEXT_MENU));
        hMenu = GetSubMenu(hMenuLoad, 0);

        TrackPopupMenu( hMenu,
                        TPM_LEFTALIGN | TPM_RIGHTBUTTON,
                        LOWORD(lParam),
                        HIWORD(lParam),
                        0,
                        hWnd,
                        NULL);

        DestroyMenu(hMenuLoad);
        break;
    }
    case WM_COMMAND :
    {
        // Show properties dialog for device
        if( wParam == IDM_PROPERTIES )
        {         
            HTREEITEM   hTree;
            CItemData*  pItemData;

            // Get selected item
            hTree = TreeView_GetSelection( cDevices->GetHwnd_TV() );
            if( hTree )
            {
                // Get item data of selected item
                pItemData = (CItemData *) TreeView_GetLParam( hwndTV, hTree );
                if( pItemData ) 
                {
                    if( pItemData->m_fIsDevice )
                    {
                        // Show the device property dialog
                        DialogBoxParam( g_hInst,
                                        MAKEINTRESOURCE(IDD_PROPERTIES_DEVICE),
                                        g_hwndMain,
                                        DeviceProp_DlgProc, 
                                        (LPARAM)pItemData );
                    }
                    else
                    {
                        // Show the device property dialog
                        DialogBoxParam( g_hInst,
                                        MAKEINTRESOURCE(IDD_PROPERTIES_STORAGE),
                                        g_hwndMain,
                                        StorageProp_DlgProc, 
                                        (LPARAM)pItemData );
                    }
                }
            }
        }
        break;
    }

	case WM_DRM_UPDATEDEVICE:
		cDevices->UpdateSelection( (HTREEITEM)wParam, TRUE );
		break;

	default:
		break;
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\apps\wmdmapp\devices.h ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

// This workspace contains two projects -
// 1. ProgHelp which implements the Progress Interface 
// 2. The Sample application WmdmApp. 
//
//  ProgHelp.dll needs to be registered first for the SampleApp to run.

///////////////////////////////////////////////////////////////////////////////
//
//	devices.h
//
///////////////////////////////////////////////////////////////////////////////

#ifndef		_DEVICES_H_
#define		_DEVICES_H_


class CDevices
{
	HWND    m_hwndDevices;
	HWND    m_hwndDevices_TV;

	HIMAGELIST m_himlSmall;

	BOOL InitImageList( void );

public:

	// Constructors/destructors
	//
	CDevices();
	~CDevices();

	// Operations
	//
	BOOL Create( HWND hwndParent );
	VOID Destroy( void );

	HWND GetHwnd( void );
	HWND GetHwnd_TV( void );

	HTREEITEM GetSelectedItem( LPARAM *pLParam );
	BOOL SetSelectedItem( HTREEITEM hItem );
	INT  GetDeviceCount( VOID );
	CItemData *GetRootDevice( HTREEITEM hItem );
	BOOL HasSubFolders( HTREEITEM hItem );

	VOID UpdateStatusBar( void );
	BOOL UpdateSelection( HTREEITEM hItem, BOOL fDirty );
	
	BOOL AddItem( CItemData *pItemData );
	INT  AddChildren( HTREEITEM hItem, BOOL fDeviceItem );
	VOID RemoveAllItems( VOID );
	INT  RemoveChildren( HTREEITEM hItem );

	VOID OnSize( LPRECT prcMain );
};


#endif		// _DEVICES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\apps\wmdmapp\key.c ===
// This file contains 2 keys, a revoked and an unrevoked one.
// The right key will be included in the compile using the _REVOKED compile setting. 
// This file is internal to microsoft and is not shipped. 

#include <wtypes.h>

// This key is not revoked
#ifndef _REVOKED
const BYTE abPVK[] = {
	0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 
	0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 
	0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 
	0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 
	0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 
	0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 
	0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 
	0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 
	0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 
	0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 
	0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 
	0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 
	0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 
	0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 
	0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 
	0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 
	0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 
	0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 
	0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 
	0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 
	0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 
	0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 
	0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 
	0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 
	0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 
	0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 
	0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 
	0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 
	0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 
	0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 
	0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 
	0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 
	0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 
	0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 
	0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 
	0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 
	0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 
	0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 
	0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 
	0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 
	0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 
	0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 
	0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 
	0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 
	0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 
	0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 
	0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 
	0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 
	0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 
	0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 
	0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 
	0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 
	0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 
	0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 
	0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 
	0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 
	0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 
	0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 
	0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 
	0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 
	0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 
	0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 
	0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 
	0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 
	0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 
	0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 
	0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 
	0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 
	0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 
	0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 
	0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 
	0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 
	0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 
	0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 
	0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 
	0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 
	0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 
	0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 
	0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 
	0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 
	0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 
	0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 
	0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 
	0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 
	0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 
	0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 
	0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 
	0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 
	0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 
	0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 
	0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 
	0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 
	0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 
	0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 
	0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 
	0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 
	0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 
	0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 
	0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 
	0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 
	0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 
	0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 
	0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 
	0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 
	0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 
	0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 
	0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 
	0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 
	0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 
	0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 
	0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 
	0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 
	0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 
	0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 
	0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 
	0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 
	0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 
	0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 
	0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 
	0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 
	0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 
	0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 
	0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 
	0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 
	0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 
	0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 
	0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 
	0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 
	0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 
	0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 
	0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 
	0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 
	0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 
	0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 
	0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 
	0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 
	0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 
	0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 
	0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 
	0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 
	0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 
	0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 
	0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 
	0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 
	0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 
	0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 
	0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 
	0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 
	0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 
	0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 
	0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 
	0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 
	0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 
	0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 
	0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 
	0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 
	0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 
	0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 
	0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 
	0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 
	0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 
	0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 
	0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 
	0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 
	0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 
	0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 
	0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 
	0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 
	0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 
	0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 
	0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 
	0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 
	0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 
	0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 
	0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 
	0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 
	0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 
	0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 
	0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 
	0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 
	0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 
	0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 
	0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 
	0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 
	0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 
	0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 
	0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 
	0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 
	0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 
	0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 
	0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 
	0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 
	0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 
	0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 
	0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 
	0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 
	0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 
	0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 
	0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 
	0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 
	0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 
	0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 
	0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 
	0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 
	0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 
	0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 
	0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 
	0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 
	0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 
	0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 
	0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 
	0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 
	0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 
	0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 
	0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 
	0x9E, 0xC4, 0xC5, 0xD5, 0x7D, 0xC3, 0xC1, 0x22, 
	0x1A, 0x0A, 0xE5, 0x57, 0xCF, 0x05, 0x5F, 0x76, 
	0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 
	0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 
	0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 
	0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 
	0x3E, 0x1A, 0x5D, 0xBF, 0x9C, 0x17, 0x3E, 0x7D, 
	0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 
	0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 
	0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 
	0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 
	0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 
	0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 
	0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 
	0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 
	0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 
	0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 
	0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 
	0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 
	0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 
	0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 
	0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 
	0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 
	0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 
	0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 
	0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 
	0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 
	0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 
	0x07, 0xCD, 0xA6, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 
	0x22, 0x1A, 0x65, 0x0A, 0xB1, 0xCF, 0xD8, 0x5F, 
	0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 
	0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 
	0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 
	0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 
	0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 
	0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 
	0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 
	0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 
	0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 
	0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 
	0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 
	0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 
	0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0x74, 
	0xDC, 0xF3, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 
	0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 
	0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 
	0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 
	0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 
	0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 
	0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 
	0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 
	0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 
	0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 
	0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 
	0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 
	0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 
	0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 
	0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 
	0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 
	0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 
	0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 
	0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 
	0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 
	0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 
	0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 
	0xCF, 0x70, 0x96, 0xAC, 0x81, 0xEA, 0x61, 0x48, 
	0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 
	0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 
	0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 
	0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 
	0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 
	0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 
	0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 
	0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 
	0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 
	0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 
	0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 
	0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 
	0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 
	0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 
	0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0x2C, 0xE7, 0xA8, 
	0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 
	0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 
	0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 
	0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 
	0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 
	0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 
	0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 
	0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 
	0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 
	0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 
	0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 
	0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 
	0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 
	0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 
	0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 
	0xBF, 0xD1, 0x2D, 0xA5, 0x51, 0xEA, 0xFC, 0x04, 
	0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 
	0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0x6D, 0xA1, 0x23, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 
	0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 
	0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 
	0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 
	0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 
	0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 
	0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 
	0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 
	0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 
	0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 
	0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 
	0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0x58, 0xE8, 0x94, 
	0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 
	0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 
	0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 
	0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 
	0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 
	0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 
	0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 
	0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 
	0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 
	0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 
	0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 
	0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 
	0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 
	0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 
	0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 
	0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 
	0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 
	0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 
	0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 
	0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 
	0x72, 0x22, 0x7F, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 
	0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 
	0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 
	0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 
	0x4D, 0xF0, 0x7A, 0x98, 0x51, 0x49, 0xA2, 0x91, 
	0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 
	0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 
	0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 
	0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 
	0x14, 0x48, 0x07, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 
	0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 
	0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 
	0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 
	0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 
	0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 
	0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 
	0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 
	0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 
	0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 
	0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 
	0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 
	0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 
	0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 
	0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 
	0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 
	0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 
	0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 
	0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 
	0xDE, 0xB2, 0xBF, 0xD1, 0x26, 0x2D, 0x37, 0xEA, 
	0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 
	0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 
	0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 
	0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 
	0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 
	0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 
	0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 
	0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 
	0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 
	0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 
	0x57, 0xC8, 0x56, 0x3E, 0xB5, 0x07, 0x9C, 0x17, 
	0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 
	0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 
	0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 
	0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 
	0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 
	0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 
	0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 
	0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 
	0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 
	0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 
	0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 
	0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 
	0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 
	0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 
	0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 
	0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 
	0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 
	0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 
	0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 
	0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 
	0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 
	0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 
	0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 
	0x04, 0xB0, 0x03, 0x59, 0x4E, 0x26, 0x3F, 0x78, 
	0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 
	0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 
	0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 
	0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 
	0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 
	0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 
	0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 
	0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 
	0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 
	0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 
	0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 
	0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 
	0x64, 0xFA, 0x65, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 
	0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 
	0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 
	0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 
	0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 
	0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 
	0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 
	0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 
	0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 
	0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 
	0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 
	0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 
	0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 
	0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 
	0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 
	0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 
	0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x71, 0x75, 
	0xAC, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 
	0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 
	0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 
	0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 
	0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 
	0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 
	0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 
	0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 
	0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 
	0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 
	0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 
	0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 
	0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 
	0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 
	0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 
	0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 
	0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 
	0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x42, 
	0x61, 0x1C, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 
	0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 
	0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 
	0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 
	0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 
	0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 
	0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 
	0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 
	0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 
	0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0x95, 
	0x32, 0x86, 0x72, 0x41, 0x37, 0xC8, 0xCB, 0x9D, 
	0x31, 0xBE, 0x6C, 0xF7, 0xB1, 0xCA, 0x62, 0x6B, 
	0x39, 0x3D, 0xF1, 0xA4, 0x06, 0x1F, 0x2E, 0xC2, 
	0xCF, 0x96, 0xD5, 0x7F, 0xEC, 0x5F, 0x4A, 0x8D, 
	0xDB, 0x0F, 0x60, 0x8B, 0x1A, 0x36, 0xB8, 0x74, 
	0x54, 0xF1, 0x47, 0x96, 0x04, 0xB5, 0xCB, 0xC7, 
	0x08, 0x5F, 0x55, 0xB5, 0x84, 0x75, 0xA3, 0x70, 
	0x4E, 0xC2, 0xA7, 0x8A, 0x9D, 0x7F, 0x6F, 0x0F, 
	0x9C, 0xE7, 0x09, 0x9F, 0xE1, 0xAA, 0x61, 0x94, 
	0xAB, 0xA6, 0xE8, 0xA5, 0xD0, 0x23, 0x7A, 0x46, 
	0xCF, 0xFD, 0x6E, 0x40, 0xD0, 0x2D, 0xA3, 0xEC, 
	0x9F, 0x71, 0xE5, 0x2D, 0x79, 0x7E, 0xC9, 0xB3, 
	0xE8, 0xAB, 0x97, 0xF9, 0x26, 0x87, 0x39, 0xAF, 
	0x19, 0x12, 0xA8, 0x44, 0x48, 0x84, 0xB1, 0x68, 
	0x8F, 0xB1, 0x05, 0x26, 0x8D, 0x00, 0xB7, 0x61, 
	0x31, 0x74, 0x1E, 0xF3, 0x24, 0xFE, 0x00, 0x14
};
const BYTE abCert[] = {
	0x00, 0x01, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
	0x7C, 0xF1, 0xF9, 0x82, 0xE5, 0xD6, 0xE9, 0x75, 
	0xAA, 0xBC, 0x33, 0x87, 0x3A, 0xBB, 0xE5, 0x18, 
	0xFB, 0x7C, 0x47, 0x68, 0x24, 0x6B, 0xE3, 0x3B, 
	0x7D, 0xC6, 0x7D, 0x94, 0xA4, 0xB1, 0x88, 0x8D, 
	0x85, 0x77, 0x2B, 0x78, 0xAE, 0x81, 0x53, 0x29, 
	0x69, 0xFD, 0x67, 0xD3, 0x95, 0x72, 0xE2, 0x58, 
	0xCB, 0xD3, 0x23, 0xFE, 0xC2, 0xC9, 0x6E, 0xCD, 
	0x7A, 0x8A, 0xFC, 0x22, 0x62, 0x0B, 0xB8, 0xD4, 
	0x68, 0x23, 0x7A, 0x3C, 0xFB, 0x43, 0xA8, 0x01, 
	0xA4, 0x10, 0x61, 0x75, 0x19, 0xDC, 0x38, 0x25, 
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x03, 0xE8, 
	0x00, 0x00, 0x00, 0x02
};

#else

// This is the revoked key and AppCert
const BYTE abPVK[] = {
	0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 
	0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 
	0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 
	0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 
	0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 
	0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 
	0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 
	0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 
	0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 
	0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 
	0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 
	0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 
	0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 
	0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 
	0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 
	0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 
	0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 
	0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 
	0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 
	0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 
	0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 
	0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 
	0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 
	0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 
	0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 
	0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 
	0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 
	0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 
	0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 
	0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 
	0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 
	0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 
	0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 
	0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 
	0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 
	0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 
	0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 
	0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 
	0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 
	0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 
	0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 
	0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 
	0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 
	0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 
	0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 
	0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 
	0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 
	0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 
	0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 
	0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 
	0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 
	0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 
	0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 
	0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 
	0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 
	0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 
	0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 
	0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 
	0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 
	0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 
	0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 
	0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 
	0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 
	0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 
	0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 
	0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 
	0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 
	0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 
	0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 
	0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 
	0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 
	0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 
	0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 
	0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 
	0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 
	0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 
	0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 
	0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 
	0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 
	0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 
	0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 
	0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 
	0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 
	0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 
	0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 
	0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 
	0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 
	0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 
	0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 
	0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 
	0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 
	0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 
	0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 
	0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 
	0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 
	0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 
	0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 
	0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 
	0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 
	0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 
	0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 
	0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 
	0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 
	0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 
	0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 
	0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 
	0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 
	0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 
	0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 
	0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 
	0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 
	0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 
	0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 
	0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 
	0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 
	0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 
	0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 
	0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 
	0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 
	0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 
	0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 
	0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 
	0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 
	0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 
	0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 
	0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 
	0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 
	0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 
	0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 
	0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 
	0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 
	0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 
	0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 
	0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 
	0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 
	0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 
	0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 
	0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 
	0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 
	0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 
	0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 
	0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 
	0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 
	0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 
	0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 
	0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 
	0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 
	0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 
	0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 
	0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 
	0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 
	0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 
	0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 
	0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 
	0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 
	0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 
	0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 
	0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 
	0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 
	0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 
	0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 
	0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 
	0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 
	0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 
	0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 
	0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 
	0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 
	0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 
	0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 
	0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 
	0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 
	0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 
	0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 
	0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 
	0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 
	0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 
	0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 
	0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 
	0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 
	0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 
	0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 
	0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 
	0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 
	0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 
	0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 
	0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 
	0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 
	0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 
	0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 
	0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 
	0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 
	0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 
	0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 
	0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 
	0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 
	0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 
	0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 
	0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 
	0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 
	0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 
	0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 
	0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 
	0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 
	0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 
	0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 
	0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 
	0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 
	0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 
	0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 
	0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 
	0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 
	0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 
	0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 
	0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 
	0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 
	0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 
	0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 
	0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 
	0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 
	0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 
	0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 
	0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 
	0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 
	0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 
	0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 
	0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 
	0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 
	0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 
	0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 
	0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 
	0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 
	0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 
	0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 
	0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 
	0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 
	0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 
	0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 
	0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 
	0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 
	0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 
	0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 
	0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 
	0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 
	0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 
	0xEA, 0x61, 0x14, 0x48, 0xB0, 0x3E, 0x45, 0xEB, 
	0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 
	0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 
	0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 
	0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 
	0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 
	0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 
	0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 
	0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 
	0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 
	0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 
	0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 
	0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 
	0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 
	0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 
	0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 
	0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 
	0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 
	0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 
	0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x26, 0x2D, 
	0x09, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 
	0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 
	0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 
	0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 
	0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 
	0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 
	0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 
	0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 
	0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 
	0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 
	0x0B, 0x91, 0x57, 0xC8, 0x56, 0x3E, 0xF8, 0x07, 
	0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 
	0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 
	0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 
	0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 
	0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 
	0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 
	0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 
	0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 
	0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 
	0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 
	0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 
	0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 
	0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 
	0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 
	0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 
	0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 
	0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 
	0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 
	0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 
	0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 
	0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 
	0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 
	0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 
	0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x4E, 0x26, 
	0x81, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 
	0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 
	0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 
	0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 
	0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 
	0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 
	0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 
	0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 
	0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 
	0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 
	0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 
	0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 
	0x75, 0xE5, 0x64, 0xFA, 0x8C, 0xCF, 0x96, 0xD3, 
	0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 
	0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 
	0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 
	0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 
	0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 
	0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 
	0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 
	0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 
	0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 
	0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 
	0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 
	0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 
	0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 
	0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 
	0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 
	0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 
	0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x22, 
	0x81, 0x1B, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 
	0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 
	0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 
	0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 
	0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 
	0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 
	0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 
	0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 
	0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 
	0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 
	0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 
	0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 
	0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 
	0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 
	0x17, 0x3E, 0x7D, 0x58, 0x4C, 0x0B, 0x3A, 0x05, 
	0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 
	0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 
	0x81, 0xEA, 0x61, 0x48, 0x54, 0x8F, 0xDD, 0x45, 
	0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 
	0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 
	0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 
	0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 
	0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 
	0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 
	0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 
	0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 
	0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 
	0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 
	0x43, 0x70, 0x90, 0x4E, 0x0D, 0x37, 0xFD, 0x62, 
	0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 
	0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 
	0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 
	0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 
	0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 
	0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 
	0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 
	0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 
	0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 
	0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 
	0xAC, 0x29, 0x01, 0x27, 0x24, 0x5E, 0x02, 0x67, 
	0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 
	0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 
	0x9E, 0xC4, 0xC5, 0xD5, 0x7D, 0xC3, 0xCB, 0x22, 
	0x1A, 0x0A, 0xE5, 0x57, 0xCF, 0xAB, 0x5F, 0x76, 
	0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 
	0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 
	0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 
	0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 
	0x3E, 0x1A, 0x5D, 0x0E, 0x9C, 0x17, 0x3E, 0x7D, 
	0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 
	0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 
	0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 
	0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 
	0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 
	0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 
	0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 
	0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 
	0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 
	0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 
	0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 
	0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 
	0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 
	0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 
	0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 
	0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 
	0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 
	0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 
	0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 
	0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 
	0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 
	0x07, 0xCD, 0x22, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 
	0x22, 0x1A, 0x65, 0x0A, 0xAE, 0xCF, 0xD8, 0x5F, 
	0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 
	0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 
	0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 
	0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 
	0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 
	0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 
	0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 
	0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 
	0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 
	0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 
	0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 
	0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 
	0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0x74, 
	0xDC, 0x97, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 
	0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 
	0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 
	0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 
	0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 
	0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 
	0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 
	0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 
	0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 
	0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 
	0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 
	0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 
	0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 
	0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 
	0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 
	0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 
	0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 
	0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 
	0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 
	0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 
	0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 
	0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 
	0xCF, 0x70, 0x96, 0xD9, 0x81, 0xEA, 0x61, 0x48, 
	0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 
	0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 
	0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 
	0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 
	0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 
	0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 
	0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 
	0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 
	0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 
	0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 
	0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 
	0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 
	0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 
	0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 
	0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0x2C, 0xE7, 0x5D, 
	0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 
	0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 
	0xB0, 0x03, 0x59, 0x26, 0x3F, 0x15, 0xB4, 0xDC, 
	0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 
	0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 
	0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 
	0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 
	0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 
	0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0x95, 0x32, 
	0x86, 0x72, 0x41, 0x37, 0xC8, 0xCB, 0x9D, 0x31, 
	0xBE, 0x6C, 0xF7, 0xB1, 0xCA, 0x62, 0xD4, 0x69, 
	0x37, 0x70, 0x8A, 0x87, 0x2F, 0x1D, 0xDA, 0x7D, 
	0x58, 0x8A, 0x7D, 0x9F, 0xDC, 0xE2, 0x8E, 0x51, 
	0xE3, 0x73, 0x04, 0xF8, 0x54, 0xC1, 0x10, 0xBA, 
	0x97, 0xFE, 0xF0, 0x58, 0xEC, 0xB5, 0x8D, 0x06, 
	0x7C, 0xD0, 0x79, 0x58, 0x22, 0xB3, 0x3F, 0xED, 
	0xAA, 0x00, 0x29, 0x89, 0x9F, 0x7B, 0x0E, 0xD3, 
	0x49, 0x89, 0x79, 0x6D, 0x41, 0xCF, 0x30, 0x07, 
	0x23, 0x90, 0x96, 0xEF, 0xFF, 0x44, 0x9F, 0x61, 
	0xF5, 0x16, 0x31, 0x88, 0xD7, 0xDE, 0x5D, 0xE0, 
	0x8F, 0xE2, 0xA2, 0x9C, 0x8A, 0x97, 0xB8, 0x02, 
	0x93, 0x1E, 0xCD, 0xF0, 0x12, 0xFE, 0x87, 0x2A, 
	0x55, 0x6C, 0x9B, 0x0E, 0xAD, 0xA4, 0xEC, 0xA1, 
	0xD4, 0x84, 0xB6, 0x30, 0xFD, 0x93, 0x4F, 0x03, 
	0x34, 0x17, 0xE2, 0x71, 0x68, 0x44, 0xFD, 0xD0, 
	0x13, 0x25, 0x92, 0x61, 0x58, 0x7F, 0x55, 0xF6, 
	0x11, 0x67, 0xB7, 0x24, 0x6F, 0x50, 0x59, 0x77, 
	0x90, 0x1E, 0xFE, 0x26, 0x56, 0x9E, 0xCE, 0xEE, 
	0x16, 0xFA, 0x26, 0xEE, 0x6B, 0x3E, 0x05, 0xC4, 
	0x23, 0x76, 0x7D, 0x64, 0x7F, 0x5B, 0xBD, 0x7E, 
	0x4C, 0x65, 0xCF, 0xD7, 0x60, 0x0E, 0xCA, 0xBA, 
	0xAE, 0x1B, 0x0E, 0x15, 0xD5, 0x7E, 0x88, 0x28, 
	0x59, 0x68, 0x9F, 0xA1, 0x1C, 0x6E, 0x1A, 0xC2, 
	0x92, 0x6D, 0x7F, 0x90, 0x53, 0xFD, 0xD5, 0x42, 
	0x2A, 0x3B, 0xEE, 0x41, 0xD0, 0x2F, 0xA1, 0x89, 
	0x69, 0xE6, 0xF5, 0x7F, 0xC8, 0x4F, 0xB1, 0xBA, 
	0x72, 0xEF, 0xBD, 0xBA, 0xA8, 0x54, 0x38, 0x9B, 
	0xF9, 0xF5, 0xBA, 0x25, 0xA4, 0xB4, 0xA5, 0x20, 
	0x9F, 0x86, 0x9D, 0x17, 0x7D, 0xD7, 0x00, 0x14
};

const BYTE abCert[] = {
	0x00, 0x01, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
	0x52, 0x54, 0xF3, 0xCA, 0x33, 0x87, 0x2B, 0xF8, 
	0xD4, 0x59, 0x9D, 0x31, 0x23, 0x78, 0x16, 0x48, 
	0x04, 0x0B, 0x48, 0x17, 0xC4, 0xF1, 0xA7, 0x57, 
	0xB4, 0x87, 0xF8, 0xA8, 0x43, 0x6F, 0x71, 0x73, 
	0x71, 0x03, 0xCA, 0x47, 0x92, 0xF6, 0xED, 0x1C, 
	0x5C, 0x20, 0x19, 0x8D, 0x2A, 0xB8, 0x98, 0xDA, 
	0xDF, 0xAD, 0x85, 0xF7, 0x9A, 0x68, 0x92, 0x5E, 
	0x86, 0x3B, 0x72, 0x40, 0xFD, 0xF3, 0x73, 0xE4, 
	0xCB, 0xF5, 0xBB, 0x9F, 0x91, 0xEF, 0xE0, 0x25, 
	0x4F, 0x9C, 0x82, 0x97, 0xFA, 0xD2, 0x9D, 0x15, 
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x03, 0xE8, 
	0x00, 0x00, 0x00, 0x1A
};

#endif // _REVOKED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\apps\wmdmapp\progress.cpp ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

//
// This workspace contains two projects -
// 1. ProgHelp which implements the Progress Interface 
// 2. The Sample application WmdmApp. 
//
//  ProgHelp.dll needs to be registered first for the SampleApp to run.


// Includes
//
#include "appPCH.h"

// Local functions
//
INT_PTR CALLBACK Progress_DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

/////////////////////////////////////////////////////////////////////
//
// Function implementations
//

CProgress::CProgress (void )
{
	m_hwndProgress   = NULL;

	m_nCurrentNum    = 0;
	m_nTotalNum      = 0;

	m_dwCurrentBytes = 0;
	m_dwTotalBytes   = 0;

	m_fCancelled     = FALSE;
}

CProgress::~CProgress( void )
{
	m_hwndProgress = NULL;
}


BOOL CProgress::Show( BOOL fShow )
{
	// If showing the dialog, center it relative to its parent
	//
	if( fShow )
	{
		CenterWindow( m_hwndProgress, GetParent(m_hwndProgress) );

		// enable the cancel button
		EnableWindow( GetDlgItem(m_hwndProgress, IDCANCEL), TRUE );
	}

	// Show/Hide the window
	//
	ShowWindow( m_hwndProgress, (fShow ? SW_SHOW : SW_HIDE) );

	if( fShow )
	{
		BringWndToTop( GetParent(m_hwndProgress) );
		BringWndToTop( m_hwndProgress );
	}

	return TRUE;
}


BOOL CProgress::IsCancelled( void )
{
	return m_fCancelled;
}


BOOL CProgress::Cancel( void )
{
	BOOL fWasAlreadyCancelled = m_fCancelled;

	m_fCancelled = TRUE;

	EnableWindow( GetDlgItem(m_hwndProgress, IDCANCEL), FALSE );

	return fWasAlreadyCancelled;
}


INT_PTR CALLBACK Progress_DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	static CProgress *pThis = NULL;

	switch( uMsg )
	{
	case WM_INITDIALOG:
		pThis = (CProgress *)lParam;
		break;

	case WM_COMMAND:
		if( IDCANCEL == LOWORD(wParam) )
		{
			pThis->Cancel();
		}
		break;

	default:
		break;
	}

	return 0;
}    


BOOL CProgress::Create( HWND hwndParent )
{
	BOOL fRet = FALSE;

	if( m_hwndProgress )
	{
		Destroy();
	}

	m_hwndProgress = CreateDialogParam(
		g_hInst,
    	MAKEINTRESOURCE( IDD_PROGRESS ),
    	hwndParent,
		Progress_DlgProc,
		(LPARAM)this
	);
	if( NULL == m_hwndProgress )
	{
		return FALSE;
	}

	// Hide the window initially
	//
	ShowWindow( m_hwndProgress, SW_HIDE );

	m_fCancelled = FALSE;

	fRet = TRUE;

	return fRet;
}


VOID CProgress::Destroy( void )
{
	if( m_hwndProgress )
	{
		DestroyWindow( m_hwndProgress );
	}
}


BOOL CProgress::SetRange( INT nMin, INT nMax )
{
	HWND hwnd = GetDlgItem( m_hwndProgress, IDC_PB_PROGRESS );

	SendMessage( hwnd, PBM_SETRANGE, (WPARAM)0, (LPARAM)MAKELPARAM(nMin,nMax) );

	return TRUE;
}

BOOL CProgress::SetOperation( LPSTR lpsz )
{
	HWND hwnd = GetDlgItem( m_hwndProgress, IDC_ST_OPERATION );

	SetWindowText( hwnd, lpsz );

	return TRUE;
}

BOOL CProgress::SetDetails( LPSTR lpsz )
{
	HWND hwnd = GetDlgItem( m_hwndProgress, IDC_ST_DETAILS );

	SetWindowText( hwnd, lpsz );

	return TRUE;
}


BOOL CProgress::SetCount( INT nCurrentNum, INT nTotalNum )
{
	HWND hwnd = GetDlgItem( m_hwndProgress, IDC_ST_COUNTER );
	char szFormat[MAX_PATH];
	char szCount[MAX_PATH];
	
	if( (DWORD)-1 != nCurrentNum )
	{
		m_nCurrentNum = nCurrentNum;
	}
	if( (DWORD)-1 != nTotalNum )
	{
		m_nTotalNum = nTotalNum;
	}

	if( nCurrentNum == -1 && nTotalNum == -1 )
	{
		SetWindowText( hwnd, "" );
	}
	else
	{
		LoadString( g_hInst, IDS_PROGRESS_COUNT, szFormat, sizeof(szFormat) );

		wsprintf( szCount, szFormat, nCurrentNum, nTotalNum );

		SetWindowText( hwnd, szCount );
	}
	
	return TRUE;
}

BOOL CProgress::IncCount( INT nIncrement )
{
	SetCount( m_nCurrentNum + nIncrement, m_nTotalNum );

	return TRUE;
}

BOOL CProgress::SetPos( INT nPos )
{
	HWND hwnd = GetDlgItem( m_hwndProgress, IDC_PB_PROGRESS );

	if( -1 == nPos )
	{
		// get the top limit
		nPos = (INT)SendMessage( hwnd, PBM_GETRANGE, (WPARAM)(BOOL)FALSE, (LPARAM)0 );
	}

	// set the position
	SendMessage( hwnd, PBM_SETPOS, (WPARAM)nPos, (LPARAM)0 );

	return TRUE;
}

BOOL CProgress::IncPos( INT nIncrement )
{
	HWND hwnd = GetDlgItem( m_hwndProgress, IDC_PB_PROGRESS );

	// increment the position
	SendMessage( hwnd, PBM_DELTAPOS, (WPARAM)nIncrement, (LPARAM)0 );

	return TRUE;
}


BOOL CProgress::SetBytes( DWORD dwCurrentNum, DWORD dwTotalNum )
{
	HWND hwnd = GetDlgItem( m_hwndProgress, IDC_ST_BYTECOUNTER );
	char szFormat[MAX_PATH];
	char szCount[MAX_PATH];

	if( (DWORD)-1 != dwCurrentNum )
	{
		m_dwCurrentBytes = dwCurrentNum;
	}
	if( (DWORD)-1 != dwTotalNum )
	{
		m_dwTotalBytes   = dwTotalNum;
	}

	if( dwCurrentNum == -1 && dwTotalNum == -1 )
	{
		SetWindowText( hwnd, "" );
	}
	else
	{
		LoadString( g_hInst, IDS_PROGRESS_BYTECOUNT, szFormat, sizeof(szFormat) );

		wsprintf( szCount, szFormat, m_dwCurrentBytes/1024, m_dwTotalBytes/1024 );

		SetWindowText( hwnd, szCount );
	}
	
	return TRUE;
}

BOOL CProgress::IncBytes( DWORD dwIncrement )
{
	SetBytes( m_dwCurrentBytes + dwIncrement, m_dwTotalBytes );

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\apps\wmdmapp\itemdata.h ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

//
// This workspace contains two projects -
// 1. ProgHelp which implements the Progress Interface 
// 2. The Sample application WmdmApp. 
//
//  ProgHelp.dll needs to be registered first for the SampleApp to run.


//
// ItemData.h: Interface for the CItemData class.
//

#if !defined(AFX_ITEMDATA_H__1C17A70D_4382_11D3_B269_00C04F8EC221__INCLUDED_)
#define AFX_ITEMDATA_H__1C17A70D_4382_11D3_B269_00C04F8EC221__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


class CItemData
{   
public:

	// Flag indicating a device or storage item
	//
	BOOL                 m_fIsDevice;

	// Shared device/storage members
	//
	IWMDMStorageGlobals *m_pStorageGlobals;
	IWMDMEnumStorage    *m_pEnumStorage;

	CHAR                 m_szName[MAX_PATH];

	// Device-only members
	//
	IWMDMDevice         *m_pDevice;
	IWMDMStorage        *m_pRootStorage;
    DWORD                m_dwType;
    WMDMID               m_SerialNumber;
    CHAR                 m_szMfr[MAX_PATH];
    DWORD                m_dwVersion;
	DWORD                m_dwPowerSource;
	DWORD                m_dwPercentRemaining;
	HICON                m_hIcon;
	DWORD                m_dwMemSizeKB;
	DWORD                m_dwMemBadKB;
	DWORD                m_dwMemFreeKB;
	BOOL                 m_fExtraCertified;

	// Storage-only members
	//
	IWMDMStorage        *m_pStorage;
	DWORD                m_dwAttributes;
	_WAVEFORMATEX        m_Format;
	WMDMDATETIME         m_DateTime;
	DWORD                m_dwSizeLow;
	DWORD                m_dwSizeHigh;

	// Methods
	//
	CItemData();
	virtual ~CItemData();

	HRESULT Init( IWMDMDevice *pDevice );
	HRESULT Init( IWMDMStorage *pStorage );

	HRESULT Refresh( void );
};

#endif // !defined(AFX_ITEMDATA_H__1C17A70D_4382_11D3_B269_00C04F8EC221__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\apps\wmdmapp\itemdata.cpp ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

// This workspace contains two projects -
// 1. ProgHelp which implements the Progress Interface 
// 2. The Sample application WmdmApp. 
//
//  ProgHelp.dll needs to be registered first for the SampleApp to run.


//
// ItemData.cpp: implementation of the CItemData class
//

// Includes
//
#include "appPCH.h"
#include "SCClient.h"
// Opaque Command to get extended certification information
//
// GUID = {C39BF696-B776-459c-A13A-4B7116AB9F09}
//
static const GUID guidCertInfoEx = 
{ 0xc39bf696, 0xb776, 0x459c, { 0xa1, 0x3a, 0x4b, 0x71, 0x16, 0xab, 0x9f, 0x9 } };

typedef struct
{
	HRESULT hr;
	DWORD   cbCert;
	BYTE    pbCert[1];

} CERTINFOEX;

static const BYTE bCertInfoEx_App[] =
{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09 };

static const BYTE bCertInfoEx_SP[] =
{ 0x09, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00,
  0x09, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00 };

//
// Construction/Destruction
//

CItemData::CItemData()
{
	m_fIsDevice          = TRUE;

	// Shared device/storage members
	//
	m_pStorageGlobals    = NULL;
	m_pEnumStorage       = NULL;

	m_szName[0]          = 0;

	// Device-only members
	//
	m_pDevice            = NULL;
	m_pRootStorage       = NULL;
    m_dwType             = 0;
	FillMemory( (void *)&m_SerialNumber, sizeof(m_SerialNumber), 0 );
    m_szMfr[0]           = 0;
    m_dwVersion          = 0;
	m_dwPowerSource      = 0;
	m_dwPercentRemaining = 0;
	m_hIcon              = NULL;
	m_dwMemSizeKB        = 0;
	m_dwMemBadKB         = 0;
	m_dwMemFreeKB        = 0;
	m_fExtraCertified    = FALSE;

	// Storage-only members
	//
	m_pStorage           = NULL;
	m_dwAttributes       = 0;
	FillMemory( (void *)&m_Format, sizeof(m_Format), 0 );
	FillMemory( (void *)&m_DateTime, sizeof(m_DateTime), 0 );
	m_dwSizeLow          = 0;
	m_dwSizeHigh         = 0;
}

CItemData::~CItemData()
{
	if( m_hIcon )
	{
		DestroyIcon( m_hIcon );
		m_hIcon = NULL;
	}

	SafeRelease( m_pStorageGlobals );
	SafeRelease( m_pEnumStorage );
	SafeRelease( m_pRootStorage );
	SafeRelease( m_pStorage );
	SafeRelease( m_pDevice );
}

//////////////////////////////////////////////////////////////////////
//
// Class methods
//
//////////////////////////////////////////////////////////////////////

HRESULT CItemData::Init( IWMDMDevice *pDevice )
{
	HRESULT hr;
	WCHAR   wsz[MAX_PATH];
	ULONG   ulFetched;

	// This is a device object
	//
	m_fIsDevice = TRUE;

	//
	// Shared device/storage members
	//

	// Get the RootStorage, SotrageGlobals, and EnumStorage interfaces
	//
	m_pRootStorage    = NULL;
	m_pEnumStorage    = NULL;
	m_pStorageGlobals = NULL;

	{
		IWMDMEnumStorage *pEnumRootStorage;

		hr = pDevice->EnumStorage( &pEnumRootStorage );
		ExitOnFalse( SUCCEEDED( hr ) && pEnumRootStorage );

		hr = pEnumRootStorage->Next( 1, &m_pRootStorage, &ulFetched );
		ExitOnFalse( SUCCEEDED( hr ) && m_pRootStorage );

		hr = m_pRootStorage->GetStorageGlobals( &m_pStorageGlobals );
		ExitOnFalse( SUCCEEDED( hr ) && m_pStorageGlobals );

		hr = m_pRootStorage->EnumStorage( &m_pEnumStorage );
		ExitOnFalse( SUCCEEDED( hr ) && m_pEnumStorage );

		pEnumRootStorage->Release();
	}

	// Get device name
	//
	hr = pDevice->GetName( wsz, sizeof(wsz)/sizeof(WCHAR) - 1 );
	if( FAILED(hr) )
	{
		lstrcpy( m_szName, "" );
	}
	else
	{
	    WideCharToMultiByte(
		    CP_ACP, 0L,
		    wsz, -1,
		    m_szName, sizeof(m_szName),
		    NULL, NULL
	    );
	}


	//
	// Device-only members
	//

	// Set the device pointer and addref it
	//
	m_pDevice = pDevice;
	m_pDevice->AddRef();

	// Get device type
	//
    hr = pDevice->GetType( &m_dwType );
	if( FAILED(hr) )
	{
		m_dwType = 0L;
	}

	/// Get device serial number
	//
	BYTE abMAC[SAC_MAC_LEN];
	BYTE abMACVerify[SAC_MAC_LEN];
	HMAC hMACVerify;

    hr = pDevice->GetSerialNumber( &m_SerialNumber, (BYTE*)abMAC );
 	if( SUCCEEDED(hr) )
	{
		g_cWmdm.m_pSAC->MACInit(&hMACVerify);
		g_cWmdm.m_pSAC->MACUpdate(hMACVerify, (BYTE*)(&m_SerialNumber), sizeof(m_SerialNumber));
		g_cWmdm.m_pSAC->MACFinal(hMACVerify, (BYTE*)abMACVerify);
		if( memcmp(abMACVerify, abMAC, sizeof(abMAC)) != 0 )
		{
			hr = E_FAIL;
		}
	}
	if( FAILED(hr) )
	{
		FillMemory( (void *)&m_SerialNumber, sizeof(m_SerialNumber), 0 );
	}

	// Get device manufacturer
	//
    hr = pDevice->GetManufacturer( wsz, sizeof(wsz)/sizeof(WCHAR) - 1 );
	if( FAILED(hr) )
	{
		lstrcpy( m_szMfr, "" );
	}
	else
	{
	    WideCharToMultiByte(
		    CP_ACP, 0L,
		    wsz, -1,
		    m_szMfr, sizeof(m_szMfr),
		    NULL, NULL
	    );
	}

	// Get device version
	//
	hr = pDevice->GetVersion( &m_dwVersion );
	if( FAILED(hr) )
	{
		m_dwVersion = (DWORD)-1;
	}

	// Get power source and power remaining
	//
    hr = pDevice->GetPowerSource( &m_dwPowerSource, &m_dwPercentRemaining );
	if( FAILED(hr) ) 
	{
		m_dwPowerSource      = 0;
		m_dwPercentRemaining = 0;
	}

	// Get device icon
	//
    hr = pDevice->GetDeviceIcon( (ULONG *)&m_hIcon );
	if( FAILED(hr) )
	{
		m_hIcon = NULL;
	}

	// Get the total, free, and bad space on the storage
	//
	{
		DWORD dwLow;
		DWORD dwHigh;

		m_dwMemSizeKB = 0;
		hr = m_pStorageGlobals->GetTotalSize( &dwLow, &dwHigh );
		if( SUCCEEDED(hr) )
		{
			INT64 nSize = ( (INT64)dwHigh << 32 | (INT64)dwLow ) >> 10;

			m_dwMemSizeKB = (DWORD)nSize;
		}

		m_dwMemBadKB = 0;
		hr = m_pStorageGlobals->GetTotalBad( &dwLow, &dwHigh );
		if( SUCCEEDED(hr) )
		{
			INT64 nSize = ( (INT64)dwHigh << 32 | (INT64)dwLow ) >> 10;

			m_dwMemBadKB = (DWORD)nSize;
		}

		m_dwMemFreeKB = 0;
		hr = m_pStorageGlobals->GetTotalFree( &dwLow, &dwHigh );
		if( SUCCEEDED(hr) )
		{
			INT64 nSize = ( (INT64)dwHigh << 32 | (INT64)dwLow ) >> 10;

			m_dwMemFreeKB = (DWORD)nSize;
		}
	}

	// Call opaque command to exchange extended authentication info
	//
	{
		HMAC           hMAC;
		OPAQUECOMMAND  Command;
		CERTINFOEX    *pCertInfoEx;
		DWORD          cbData_App   = sizeof( bCertInfoEx_App )/sizeof( bCertInfoEx_App[0] );
		DWORD          cbData_SP    = sizeof( bCertInfoEx_SP )/sizeof( bCertInfoEx_SP[0] );
		DWORD          cbData_Send  = sizeof( CERTINFOEX ) + cbData_App;

		// Fill out opaque command structure
		//
		memcpy( &(Command.guidCommand), &guidCertInfoEx, sizeof(GUID) );

		Command.pData = (BYTE *)CoTaskMemAlloc( cbData_Send );
		if( !Command.pData )
		{
			ExitOnFail( hr = E_OUTOFMEMORY );
		}
		Command.dwDataLen = cbData_Send;

		// Map the data in the opaque command to a CERTINFOEX structure, and
		// fill in the cert info to send
		//
		pCertInfoEx = (CERTINFOEX *)Command.pData;

		pCertInfoEx->hr     = S_OK;
		pCertInfoEx->cbCert = cbData_App;
		memcpy( pCertInfoEx->pbCert, bCertInfoEx_App, cbData_App );

		// Compute MAC
		//
		g_cWmdm.m_pSAC->MACInit( &hMAC );
		g_cWmdm.m_pSAC->MACUpdate( hMAC, (BYTE*)(&(Command.guidCommand)), sizeof(GUID) );
		g_cWmdm.m_pSAC->MACUpdate( hMAC, (BYTE*)(&(Command.dwDataLen)), sizeof(Command.dwDataLen) );
		if( Command.pData )
		{
			g_cWmdm.m_pSAC->MACUpdate( hMAC, Command.pData, Command.dwDataLen );
		}
		g_cWmdm.m_pSAC->MACFinal( hMAC, Command.abMAC );

		// Send the command
		//
		hr = pDevice->SendOpaqueCommand( &Command );
		if( SUCCEEDED(hr) )
		{
		    BYTE abMACVerify2[ WMDM_MAC_LENGTH ];

			// Compute MAC
			//
			g_cWmdm.m_pSAC->MACInit( &hMAC );
			g_cWmdm.m_pSAC->MACUpdate( hMAC, (BYTE*)(&(Command.guidCommand)), sizeof(GUID) );
			g_cWmdm.m_pSAC->MACUpdate( hMAC, (BYTE*)(&(Command.dwDataLen)), sizeof(Command.dwDataLen) );
			if( Command.pData )
			{
				g_cWmdm.m_pSAC->MACUpdate( hMAC, Command.pData, Command.dwDataLen );
			}
			g_cWmdm.m_pSAC->MACFinal( hMAC, abMACVerify2 );

			// Verify MAC matches
			//
			if( memcmp(abMACVerify2, Command.abMAC, WMDM_MAC_LENGTH) == 0 )
			{
				// Map the data in the opaque command to a CERTINFOEX structure
				//
				pCertInfoEx = (CERTINFOEX *)Command.pData;

				// In this simple extended authentication scheme, the callee must
				// provide the exact cert info
				//
				if( (pCertInfoEx->cbCert != cbData_SP) ||
					(memcmp(pCertInfoEx->pbCert, bCertInfoEx_SP, cbData_SP) == 0) )
				{
					m_fExtraCertified = TRUE;
				}
			}
		}

		if( Command.pData )
		{
			CoTaskMemFree( Command.pData );
		}
	}

	//
	// Storage-only members (pointers/handles only)
	//

	m_pStorage = NULL;

	// 
	// Successful init
	//

	hr = S_OK;

lExit:

	return hr;
}

HRESULT CItemData::Init( IWMDMStorage *pStorage )
{
    HRESULT hr;
	WCHAR   wsz[MAX_PATH];

	// This is a storage object
	//
	m_fIsDevice = FALSE;

	//
	// Shared device/storage members
	//

	// Get a pointer to the StorageGlobals interface
	//
    hr = pStorage->GetStorageGlobals( &m_pStorageGlobals );
	ExitOnFail( hr );

	// Get the storage attributes
	//
	hr = pStorage->GetAttributes( &m_dwAttributes, &m_Format );
	if( FAILED(hr) )
	{
		m_dwAttributes = 0;
	}

	// Get a pointer to the EnumStorage interface
	//
	if( m_dwAttributes & WMDM_FILE_ATTR_FOLDER )
	{
	    hr = pStorage->EnumStorage( &m_pEnumStorage );
		ExitOnFail( hr );
	}
	else
	{
		m_pEnumStorage = NULL;
	}

	// Get the storage name
	//
	hr = pStorage->GetName( wsz, sizeof(wsz)/sizeof(WCHAR) - 1 );
	if( FAILED(hr) )
	{
		lstrcpy( m_szName, "" );
	}
	else
	{
	    WideCharToMultiByte(
		    CP_ACP, 0L,
		    wsz, -1,
		    m_szName, sizeof(m_szName),
		    NULL, NULL
	    );
	}

	/// Get storage serial number
	//
	BYTE abMAC[SAC_MAC_LEN];
	BYTE abMACVerify[SAC_MAC_LEN];
	HMAC hMAC;

    hr = m_pStorageGlobals->GetSerialNumber( &m_SerialNumber, (BYTE*)abMAC );
 	if( SUCCEEDED(hr) )
	{
		g_cWmdm.m_pSAC->MACInit(&hMAC);
		g_cWmdm.m_pSAC->MACUpdate(hMAC, (BYTE*)(&m_SerialNumber), sizeof(m_SerialNumber));
		g_cWmdm.m_pSAC->MACFinal(hMAC, (BYTE*)abMACVerify);
		if( memcmp(abMACVerify, abMAC, sizeof(abMAC)) != 0 )
		{
			hr = E_FAIL;
		}
	}
	if( FAILED(hr) )
	{
		FillMemory( (void *)&m_SerialNumber, sizeof(m_SerialNumber), 0 );
	}



	//
	// Device-only members (pointers/handles only)
	//

	m_pDevice         = NULL;
	m_pRootStorage    = NULL;
	m_hIcon           = NULL;
	m_fExtraCertified = FALSE;

	//
	// Storage-only members
	//

	// Save the WMDM storage pointer
	//
    m_pStorage = pStorage;
    m_pStorage->AddRef();

	// Get the storage date
	//
    hr = pStorage->GetDate( &m_DateTime );
	if( FAILED(hr) )
	{
		FillMemory( (void *)&m_DateTime, sizeof(m_DateTime), 0 );
	}

	// If the stoarge is a file, get its size
	// If the storage is a folder, set the size to zero
	//
	m_dwSizeLow  = 0;
	m_dwSizeHigh = 0;
	if( !(m_dwAttributes & WMDM_FILE_ATTR_FOLDER) )
	{
	    hr = pStorage->GetSize( &m_dwSizeLow, &m_dwSizeHigh );
	}

	// 
	// Successful init
	//

	hr = S_OK;

lExit:

	return hr;
}

HRESULT CItemData::Refresh( void )
{
	HRESULT hr;

	// Only valid for a device
	//
	if( !m_fIsDevice )
	{
		ExitOnFail( hr = E_UNEXPECTED );
	}

	// Get power source and power remaining
	//
    hr = m_pDevice->GetPowerSource( &m_dwPowerSource, &m_dwPercentRemaining );
	if( FAILED(hr) ) 
	{
		m_dwPowerSource      = 0;
		m_dwPercentRemaining = 0;
	}

	// Get the total, free, and bad space on the storage
	//
	{
		DWORD dwLow;
		DWORD dwHigh;

		m_dwMemSizeKB = 0;
		hr = m_pStorageGlobals->GetTotalSize( &dwLow, &dwHigh );
		if( SUCCEEDED(hr) )
		{
			INT64 nSize = ( (INT64)dwHigh << 32 | (INT64)dwLow ) >> 10;

			m_dwMemSizeKB = (DWORD)nSize;
		}

		m_dwMemBadKB = 0;
		hr = m_pStorageGlobals->GetTotalBad( &dwLow, &dwHigh );
		if( SUCCEEDED(hr) )
		{
			INT64 nSize = ( (INT64)dwHigh << 32 | (INT64)dwLow ) >> 10;

			m_dwMemBadKB = (DWORD)nSize;
		}

		m_dwMemFreeKB = 0;
		hr = m_pStorageGlobals->GetTotalFree( &dwLow, &dwHigh );
		if( SUCCEEDED(hr) )
		{
			INT64 nSize = ( (INT64)dwHigh << 32 | (INT64)dwLow ) >> 10;

			m_dwMemFreeKB = (DWORD)nSize;
		}
	}

	hr = S_OK;

lExit:

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\apps\wmdmapp\properties.cpp ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

//
// This workspace contains two projects -
// 1. ProgHelp which implements the Progress Interface 
// 2. The Sample application WmdmApp. 
//
//  ProgHelp.dll needs to be registered first for the SampleApp to run.


// Includes
//
#include "appPCH.h"

// Update serial id in device/storage dialog
void UpdateSerialId( HWND hDlg, CItemData* pDevice )
{
    char*  pszSerial;
    char*  pszSerialStep;
    int    iMaxStringLength;
    BOOL   bSerialIsString = TRUE;     // Should we also show the serial id as a string?

    if( pDevice == NULL || hDlg == 0 ) return;

    // No serial ?
    if( pDevice->m_SerialNumber.SerialNumberLength == 0 )
    {
        SetDlgItemText( hDlg, IDC_SERIALID, "<none>" );
        return;
    }

    // Get serial # of device as a string
    iMaxStringLength = pDevice->m_SerialNumber.SerialNumberLength * sizeof("FF ") +1;
    pszSerial = new char[iMaxStringLength];
    pszSerialStep = pszSerial;
    for( UINT uIndex = 0; uIndex < pDevice->m_SerialNumber.SerialNumberLength; uIndex ++ )
    {
        // Add one byte at the time to the serial id string
        pszSerialStep += wsprintf( pszSerialStep, "%X ", pDevice->m_SerialNumber.pID[uIndex] );

        if( !isprint( pDevice->m_SerialNumber.pID[uIndex] ) )
        {
            bSerialIsString = FALSE;
        }
    }
    SetDlgItemText( hDlg, IDC_SERIALID, pszSerial );

    // If the serial id is a string show it as a string
    if( bSerialIsString && (pDevice->m_SerialNumber.SerialNumberLength > 0) )
    {
        SetDlgItemText( hDlg, IDC_SERIALID_STRING, (char*)pDevice->m_SerialNumber.pID );
    }

    delete [] pszSerial;
}

// Update manufacturer value in device dialog
void UpdateManufacturer( HWND hDlg, CItemData* pDevice )
{
    SetDlgItemText( hDlg, IDC_MANUFACTURER, pDevice->m_szMfr );
}

// Update device type value in device dialog
void UpdateDeviceType( HWND hDlg, CItemData* pDevice  )
{
    char    pszType[MAX_PATH];

    static SType_String sDeviceTypeStringArray[] = {
        { WMDM_DEVICE_TYPE_PLAYBACK, "Playback" },
        { WMDM_DEVICE_TYPE_RECORD,   "Record" },
        { WMDM_DEVICE_TYPE_DECODE,   "Decode" },
        { WMDM_DEVICE_TYPE_ENCODE,   "Encode" },
        { WMDM_DEVICE_TYPE_STORAGE,  "Storage" },
        { WMDM_DEVICE_TYPE_VIRTUAL,  "Virtual" },
        { WMDM_DEVICE_TYPE_SDMI,     "Sdmi" },
        { WMDM_DEVICE_TYPE_NONSDMI,  "non-sdmi" },
        { 0, NULL },
    };
    
    // Add all the types reported by the device to the string.
    pszType[0] = '\0';
    for( int iIndex = 0; sDeviceTypeStringArray[iIndex].dwType != 0; iIndex++ )
    {
        // Is this bit set, if it is then add the type as a string
        if( sDeviceTypeStringArray[iIndex].dwType & pDevice->m_dwType )
        {
            if( strlen(pszType) )
            {
                strcat( pszType, ", " );
            }
            strcat( pszType, sDeviceTypeStringArray[iIndex].pszString );
        }
    }

    SetDlgItemText( hDlg, IDC_DEVICE_TYPE, ((strlen(pszType)) ? pszType : "<none>") );
}

// Update icon in device dialog
void UpdateDeviceIcon( HWND hDlg, CItemData* pDevice )
{
	HICON      hIcon;

	hIcon = LoadIcon( g_hInst, MAKEINTRESOURCE( IDI_DEVICE ) );
    ::SendMessage(hDlg, WM_SETICON, FALSE, (LPARAM)hIcon );
}


// Update status property in device/storage dialog box
void UpdateStatus( HWND hDlg, CItemData* pDevice )
{
    char    pszStatus[MAX_PATH];

    static SType_String sDeviceTypeStringArray[] = {
        { WMDM_STATUS_READY                   , "Ready" },
        { WMDM_STATUS_BUSY                    , "Busy" },
        { WMDM_STATUS_DEVICE_NOTPRESENT       , "Device not present" },
        { WMDM_STATUS_STORAGE_NOTPRESENT      , "Storage not present" },
        { WMDM_STATUS_STORAGE_INITIALIZING    , "Storage initializing" },
        { WMDM_STATUS_STORAGE_BROKEN          , "Storage broken" },
        { WMDM_STATUS_STORAGE_NOTSUPPORTED    , "Storage not supported" },
        { WMDM_STATUS_STORAGE_UNFORMATTED     , "Storage unformatted" },
        { WMDM_STATUS_STORAGECONTROL_INSERTING, "Storagecontrol inserting" },
        { WMDM_STATUS_STORAGECONTROL_DELETING , "Storagecontrol deleting" },
        { WMDM_STATUS_STORAGECONTROL_MOVING   , "Storagecontrol moving" },
        { WMDM_STATUS_STORAGECONTROL_READING  , "Storagecontrol reading" },
        { 0, NULL },
    };
    
    // Add all the types reported by the device to the string.
    pszStatus[0] = '\0';
    for( int iIndex = 0; sDeviceTypeStringArray[iIndex].dwType != 0; iIndex++ )
    {
        // Is this bit set, if it is then add the type as a string
        if( sDeviceTypeStringArray[iIndex].dwType & pDevice->m_dwType )
        {
            if( strlen(pszStatus) )
            {
                strcat( pszStatus, ", " );
            }
            strcat( pszStatus, sDeviceTypeStringArray[iIndex].pszString );
        }
    }

    SetDlgItemText( hDlg, IDC_DEVICE_STATUS, ((strlen(pszStatus)) ? pszStatus : "<none>") );
}

// Update device status property in device dialog box
void UpdateDeviceVersion( HWND hDlg, CItemData* pDevice )
{   
    if( pDevice->m_dwVersion == (DWORD)-1 )
    {
        SetDlgItemText( hDlg, IDC_VERSION, "<not supported>");
    }
    else
    {
        SetDlgItemInt( hDlg, IDC_VERSION, pDevice->m_dwVersion, FALSE );
    }
}

// Update device status property in device dialog box
void UpdatePowerSource( HWND hDlg, CItemData* pDevice )
{
    char    pszPowerSource[MAX_PATH];
    char    pszPowerIs[MAX_PATH];

    // Update capabileties
    if( (pDevice->m_dwPowerSource & WMDM_POWER_CAP_BATTERY) &&
        (pDevice->m_dwPowerSource & WMDM_POWER_CAP_EXTERNAL) )
    {
        SetDlgItemText( hDlg, IDC_POWER_CAP, "Bateries and external");
    }
    else if(pDevice->m_dwPowerSource & WMDM_POWER_CAP_BATTERY)
    {
        SetDlgItemText( hDlg, IDC_POWER_CAP, "Bateries");
    }
    else if(pDevice->m_dwPowerSource & WMDM_POWER_CAP_EXTERNAL)
    {
        SetDlgItemText( hDlg, IDC_POWER_CAP, "External");
    }
    else
    {
        SetDlgItemText( hDlg, IDC_POWER_CAP, "<non reported>");
    }

    // Update current power source string
    if( (pDevice->m_dwPowerSource & WMDM_POWER_CAP_BATTERY) &&
        (pDevice->m_dwPowerSource & WMDM_POWER_CAP_EXTERNAL) )
    {
        strcpy( pszPowerSource, "Bateries and external");
    }
    else if(pDevice->m_dwPowerSource & WMDM_POWER_CAP_BATTERY)
    {
        strcpy( pszPowerSource,  "Bateries");
    }
    else if(pDevice->m_dwPowerSource & WMDM_POWER_CAP_EXTERNAL)
    {
        strcpy( pszPowerSource,  "External");
    }
    else
    {
        strcpy( pszPowerSource,  "<non reported>");
    }
    
    wsprintf( pszPowerIs, "%s (%d%% remaning)", pszPowerSource, pDevice->m_dwPercentRemaining );
    SetDlgItemText( hDlg, IDC_POWER_IS, pszPowerIs );
}


// Update dialog caption
void UpdateCaption( HWND hDlg, CItemData* pDevice )
{
    char    pszWndCaption[2*MAX_PATH];
	char    pszFormat[MAX_PATH];

    // Set window caption
	LoadString( g_hInst, IDS_PROPERTIES_CAPTION, pszFormat, sizeof(pszFormat) );
	if (SUCCEEDED(StringCbPrintf(pszWndCaption, sizeof(pszWndCaption), pszFormat, pDevice->m_szName)))
	{
	    SetWindowText( hDlg, pszWndCaption );
	}
}

// Procedure for device property dialog box
INT_PTR CALLBACK DeviceProp_DlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg) 
    {
        case WM_INITDIALOG:
        {
            CItemData*  pItem = (CItemData*)lParam;
            if( pItem == NULL ) return FALSE;

            UpdateSerialId( hDlg, pItem );
            UpdateManufacturer( hDlg, pItem );
            UpdateDeviceType( hDlg, pItem );
            UpdateDeviceIcon( hDlg, pItem );
            UpdateDeviceVersion( hDlg, pItem );
            UpdatePowerSource( hDlg, pItem  );
            UpdateStatus( hDlg, pItem  );
            UpdateCaption( hDlg, pItem );
            CenterWindow(hDlg, g_hwndMain );
            return TRUE;
        }
        case WM_COMMAND:
            if( GET_WM_COMMAND_ID(wParam, lParam) == IDOK ||
                GET_WM_COMMAND_ID(wParam, lParam) == IDCANCEL) 
            {
                EndDialog(hDlg, GET_WM_COMMAND_ID(wParam, lParam));
                return TRUE;
            }
            break;

        default:
            return FALSE;
    }
    return FALSE;
}


// Storage properties
//

// Update storage attributes values in storage properties dialog
void UpdateAttributes( HWND hDlg, CItemData* pDevice )
{
    char    pszAttr[MAX_PATH];

    static SType_String sTypeStringArray[] = {
        { WMDM_STORAGE_ATTR_FILESYSTEM   , "Filesystem" },
        { WMDM_STORAGE_ATTR_REMOVABLE    , "Removable" },
        { WMDM_STORAGE_ATTR_NONREMOVABLE , "Nonremovable" },
        { WMDM_STORAGE_ATTR_FOLDERS      , "Folders" },
        { WMDM_STORAGE_ATTR_HAS_FOLDERS  , "Has folders" },
        { WMDM_STORAGE_ATTR_HAS_FILES    , "Has files" },
        { WMDM_FILE_ATTR_FOLDER          , "Folder" },
        { WMDM_FILE_ATTR_LINK            , "Link" },
        { WMDM_FILE_ATTR_FILE            , "File" },
        { WMDM_FILE_ATTR_AUDIO           , "Audio" },
        { WMDM_FILE_ATTR_DATA            , "Data" },
        { WMDM_FILE_ATTR_MUSIC           , "Music" },
        { WMDM_FILE_ATTR_AUDIOBOOK       , "Audiobook" },
        { WMDM_FILE_ATTR_HIDDEN          , "Hidden" },
        { WMDM_FILE_ATTR_SYSTEM          , "System" },
        { WMDM_FILE_ATTR_READONLY        , "Readonly" },
        { 0, NULL },
    };

    // Add all the attributes reported by the device as to the string.
    pszAttr[0] = '\0';
    for( int iIndex = 0; sTypeStringArray[iIndex].dwType != 0; iIndex++ )
    {
        // Is this bit set, if it is then add the attribute as a string
        if( sTypeStringArray[iIndex].dwType & pDevice->m_dwAttributes )
        {
            if( strlen(pszAttr) )
            {
                strcat( pszAttr, ", " );
            }
            strcat( pszAttr, sTypeStringArray[iIndex].pszString );
        }
    }

    SetDlgItemText( hDlg, IDC_ATTRIBUTES, (strlen(pszAttr) ? pszAttr : "<none>") );

}

// Update storage capabilities values in storage properties dialog
void UpdateCapabilities( HWND hDlg, CItemData* pDevice )
{
    char    pszCap[MAX_PATH];

    static SType_String sTypeStringArray[] = {
        { WMDM_FILE_ATTR_CANPLAY         , "Play" },
        { WMDM_FILE_ATTR_CANDELETE       , "Delete" },
        { WMDM_FILE_ATTR_CANMOVE         , "Move" },
        { WMDM_FILE_ATTR_CANRENAME       , "Rename" },
        { WMDM_FILE_ATTR_CANREAD         , "Read" },
        { 0, NULL },
    };

    // Add all the attributes reported by the device as to the string.
    pszCap[0] = '\0';
    for( int iIndex = 0; sTypeStringArray[iIndex].dwType != 0; iIndex++ )
    {
        // Is this bit set, if it is then add the capability as a string
        if( sTypeStringArray[iIndex].dwType & pDevice->m_dwAttributes )
        {
            if( strlen(pszCap) )
            {
                strcat( pszCap, ", " );
            }
            strcat( pszCap, sTypeStringArray[iIndex].pszString );
        }
    }

    SetDlgItemText( hDlg, IDC_CAPABILITIES, (strlen(pszCap) ? pszCap : "<none>") );
}

// Add the storage icon to the storage properties dialog
void UpdateStorageIcon( HWND hDlg, CItemData* pDevice )
{
	HICON   hIcon;
    BOOL    bIsDirectory;

    bIsDirectory = pDevice->m_dwAttributes & WMDM_FILE_ATTR_FOLDER;
    hIcon = GetShellIcon( pDevice->m_szName, bIsDirectory );
    ::SendMessage(hDlg, WM_SETICON, FALSE, (LPARAM)hIcon );
}

// Procedure for storage property dialog box
INT_PTR CALLBACK StorageProp_DlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg) 
    {
        case WM_INITDIALOG:
        {
            CItemData*  pItem = (CItemData*)lParam;
            if( pItem == NULL ) return FALSE;

            UpdateSerialId( hDlg, pItem );
            UpdateAttributes( hDlg, (CItemData*)lParam );
            UpdateCapabilities( hDlg, (CItemData*)lParam );
            UpdateStorageIcon( hDlg, (CItemData*)lParam );
            UpdateStatus( hDlg, pItem );
            UpdateCaption( hDlg, pItem );
            CenterWindow(hDlg, g_hwndMain );
            return TRUE;
        }
        case WM_COMMAND:
            if( GET_WM_COMMAND_ID(wParam, lParam) == IDOK ||
                GET_WM_COMMAND_ID(wParam, lParam) == IDCANCEL) 
            {
                EndDialog(hDlg, GET_WM_COMMAND_ID(wParam, lParam));
                return TRUE;
            }
            break;

        default:
            return FALSE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\apps\wmdmapp\progress.h ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

// This workspace contains two projects -
// 1. ProgHelp which implements the Progress Interface 
// 2. The Sample application WmdmApp. 
//
//  ProgHelp.dll needs to be registered first for the SampleApp to run.


//
//	progress.h
//

#ifndef		_PROGRESS_H_
#define		_PROGRESS_H_

// dependencies

///////////////////////////////////////////////////////////////////////////////
// rio class
class CProgress
{
	// directory block
	HWND  m_hwndProgress;

	INT   m_nCurrentNum;
	INT   m_nTotalNum;

	DWORD m_dwCurrentBytes;
	DWORD m_dwTotalBytes;

	BOOL  m_fCancelled;

public:

	// constructors/destructors
	CProgress();
	~CProgress();

	// operations
	BOOL Create( HWND hwndParent );
	VOID Destroy( void );
	BOOL Show( BOOL fShow );

	BOOL SetOperation( LPSTR lpsz );
	BOOL SetDetails( LPSTR lpsz );

	BOOL SetRange( INT nMin, INT nMax );
	BOOL SetPos( INT nPos );
	BOOL IncPos( INT nIncrement );

	BOOL SetCount( INT nCurrentNum, INT nTotalNum );
	BOOL IncCount( INT nIncrement = 1 );
	
	BOOL SetBytes( DWORD dwCurrentNum, DWORD dwTotalNum );
	BOOL IncBytes( DWORD dwIncrement );
	
	BOOL Cancel( void );
	BOOL IsCancelled( void );
};


#endif		// _PROGRESS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\apps\wmdmapp\properties.h ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

// This workspace contains two projects -
// 1. ProgHelp which implements the Progress Interface 
// 2. The Sample application WmdmApp. 
//
//  ProgHelp.dll needs to be registered first for the SampleApp to run.


//
//	Properties.h
//

#ifndef		_PROPETIES_H_
#define		_PROPETIES_H_

struct SType_String
{
    DWORD   dwType;
    char*   pszString;
};

INT_PTR CALLBACK DeviceProp_DlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK StorageProp_DlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);

#endif		// _PROPETIES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\apps\wmdmapp\status.cpp ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

//
// This workspace contains two projects -
// 1. ProgHelp which implements the Progress Interface 
// 2. The Sample application WmdmApp. 
//
//  ProgHelp.dll needs to be registered first for the SampleApp to run.


// Includes
//
#include "appPCH.h"

/////////////////////////////////////////////////////////////////////
//
// Function implementations
//

CStatus::CStatus (void )
{
	m_hwndStatusBar = NULL;
}

CStatus::~CStatus (void )
{
	m_hwndStatusBar = NULL;
}

HWND CStatus::GetHwnd( void )
{
	return m_hwndStatusBar;
}

BOOL CStatus::Create( HWND hwndParent )
{
	BOOL fRet = FALSE;

	// Create the statusbar window
	//
	m_hwndStatusBar = CreateWindow( 
		STATUSCLASSNAME,
		"", 
		WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE, 
		0, 0, 0, 0, 
		hwndParent, NULL, g_hInst, NULL 
	); 
	ExitOnNull( m_hwndStatusBar );

	// Show the window
	//
	ShowWindow( m_hwndStatusBar, SW_SHOW );

	fRet = TRUE;

lExit:

	return fRet;
}


VOID CStatus::OnSize( LPRECT prcMain )
{
	INT   anWidth[SB_NUM_PANES];
	DWORD dwW = prcMain->right - prcMain->left;
	RECT  rcMain;
	RECT  rcDevice;

	GetWindowRect( g_hwndMain, &rcMain );
	GetWindowRect( g_cDevices.GetHwnd(), &rcDevice );

	anWidth[0] = (INT) ( rcDevice.right - rcMain.left -7 );
	anWidth[1] = anWidth[0] + (INT) ( dwW - anWidth[0] ) / 3;
	anWidth[2] = anWidth[1] + (INT) ( dwW - anWidth[0] ) / 3;
	anWidth[3] = -1;

	SendMessage( m_hwndStatusBar, SB_SETPARTS, (WPARAM)SB_NUM_PANES, (LPARAM)anWidth );
		
	SendMessage( m_hwndStatusBar, WM_SIZE, (WPARAM)0, (LPARAM)0 );

	SetWindowPos( m_hwndStatusBar, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE );
}


VOID CStatus::SetTextSz( INT nPane, LPSTR lpsz )
{
	WPARAM wParam = (WPARAM) (nPane | 0L);
	LPARAM lParam = (LPARAM) lpsz;

	if( m_hwndStatusBar )
	{
		SendMessage( m_hwndStatusBar, SB_SETTEXT, wParam, lParam );
	}
}


VOID CStatus::SetTextFormatted( INT nPane, UINT uStrID, INT nData, LPSTR pszData )
{
	char szFormat[MAX_PATH];

	if( 0 == uStrID )
	{
		uStrID = IDS_STATUS_EMPTY;    // use default
	}

	LoadString( g_hInst, uStrID, szFormat, sizeof(szFormat) );

	if( -1 == nData && NULL == pszData )
	{
		g_cStatus.SetTextSz( nPane, szFormat );
	}
	else
	{
		CHAR sz[MAX_PATH];
		HRESULT hr;
		
		if( -1 == nData )
		{
			hr = StringCbPrintf( sz, sizeof(sz), szFormat, pszData );
		}
		else
		{
			hr = StringCbPrintf( sz, sizeof(sz), szFormat, nData );
		}

		if (SUCCEEDED(hr))
		{
			g_cStatus.SetTextSz( nPane, sz );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\apps\wmdmapp\status.h ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

//
// This workspace contains two projects -
// 1. ProgHelp which implements the Progress Interface 
// 2. The Sample application WmdmApp. 
//
//  ProgHelp.dll needs to be registered first for the SampleApp to run.


//
//	status.h
//

#ifndef		_STATUS_H_
#define		_STATUS_H_

///////////////////////////////////////////////////////////////////////////////
// 
//
class CStatus
{
	// directory block
	HWND m_hwndStatusBar;

public:

	// constructors/destructors
	CStatus();
	~CStatus();

	// operations
	BOOL Create( HWND hwndParent );

	HWND GetHwnd( void );

	VOID OnSize( LPRECT prcMain );
	VOID SetTextSz( INT nPane, LPSTR lpsz );
	VOID SetTextFormatted( INT nPane, UINT uStrID, INT nData, LPSTR pszData );
};


#endif		// _STATUS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\apps\wmdmapp\verinfo.h ===
#ifndef _MAC
/////////////////////////////////////////////////////////////////////////////
//
// Version
//


#include <wmdm_ver.h>
    
#define VER_WMDM_FILE_FILETYPE                VFT_APP
#define VER_WMDM_FILE_FILEDESCRIPTION_STR     "WMDM Sample Application\0"
#define VER_WMDM_FILE_INTERNALNAME_STR        "WMDMApp.EXE\0"
#define VER_WMDM_FILE_OLEREGISTER
#include <wmdm_ver.ver>


#endif    // !_MAC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\apps\wmdmapp\util.h ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

//
// This workspace contains two projects -
// 1. ProgHelp which implements the Progress Interface 
// 2. The Sample application WmdmApp. 
//
//  ProgHelp.dll needs to be registered first for the SampleApp to run.


#ifndef _UTIL_H
#define _UTIL_H

// Macros
//
#define MemAlloc( dw )        LocalAlloc( LPTR, dw )
#define MemFree( lpv )        { LocalFree( lpv ); lpv = NULL; }

#define ExitOnTrue( f )       if( f ) goto lExit;
#define ExitOnFalse( f )      if( !(f) ) goto lExit;
#define ExitOnNull( x )       if( (x) == NULL ) goto lExit;
#define ExitOnFail( hr )      if( FAILED(hr) ) goto lExit;

#define FailOnTrue( f )       if( f ) goto lErr;
#define FailOnFalse( f )      if( !(f) ) goto lErr;
#define FailOnNull( x )       if( (x) == NULL ) goto lErr;
#define FailOnFail( hr )      if( FAILED(hr) ) goto lErr;

#define SafeRelease( i )      { if( (i) ) i->Release(); i = NULL; }

// Flags for DropListToBuffer
//
typedef enum {
	LTB_NULL_TERM  = 0,
	LTB_SPACE_SEP  = 1,
} LIST_TYPE;

// Util functions
//
BOOL  CenterWindow( HWND hwnd, HWND hwndRef );
VOID  BringWndToTop( HWND hwnd );

DWORD GetTheFileSize( LPSTR pszFile );

VOID  StripPath( LPSTR szFullPath );
LPSTR GetFileName( LPSTR szFullPath );

WPARAM DoMsgLoop( BOOL fForever );
VOID   UiYield( void );

LPSTR DropListToBuffer( HDROP hDrop, LIST_TYPE listType, UINT *uNumObjs );

VOID  SetRegistryParams( HINSTANCE hInst, HKEY hkeyRoot );
VOID  WriteRegDword(LPSTR szPath, LPSTR szKey, DWORD dwValue);
VOID  WriteRegDword_StrTbl(UINT uPathID,	UINT uKeyID, DWORD dwValue);
VOID  WriteRegStr(LPSTR szPath, LPSTR szKey, LPSTR szValue);
VOID  WriteRegStr_StrTbl(UINT uPathID, UINT uKeyID, LPSTR szValue);
DWORD GetRegDword(LPSTR szPath,	LPSTR szKey, DWORD dwDefault, BOOL bStore);
DWORD GetRegDword_StrTbl(UINT uPathID, UINT uKeyID, DWORD dwDefault, BOOL bStore);
LPSTR GetRegStr(LPSTR szPath, LPSTR szKey, LPSTR szDefault, BOOL bStore);
LPSTR GetRegStr_StrTbl(UINT uPathID, UINT uKeyID, LPSTR szDefault, BOOL bStore);
LPSTR GetRegStr_StrTblDefault(UINT uPathID,	UINT uKeyID, UINT uDefaultID, BOOL bStore);

HANDLE WaitForMutex( LPSTR pszMutexName, DWORD dwRetryTime, DWORD dwTimeout );

LPSTR FormatBytesToSz( DWORD dwLowBytes, DWORD dwHighBytes, DWORD dwMultiplier, LPSTR psz, size_t cbMax);
LPSTR FormatBytesToKB_Sz( DWORD dwBytes, LPSTR pszKB, size_t cbMax );
LPSTR FormatKBToKB_Sz( DWORD dwKB, LPSTR pszKB, size_t cbMax );
LPSTR FormatKBToMB_Sz( DWORD dwKB, LPSTR pszMB, size_t cbMax );
LPSTR FormatSystemTimeToSz( SYSTEMTIME *pSysTime, LPSTR pszDateTime, DWORD cchMax );

LPARAM ListView_GetLParam( HWND hwndListView, INT nItem );
LPARAM TreeView_GetLParam( HWND hwndTreeView, HTREEITEM hItem );
BOOL   TreeView_SetLParam( HWND hwndTreeView, HTREEITEM hItem, LPARAM lParam );

INT GetShellIconIndex( LPCSTR pszItemName, LPTSTR szTypeBuffer, UINT cMaxChars );
HICON GetShellIcon( LPCSTR pszItemName, BOOL bDirectory );

#endif  // _UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\apps\wmdmapp\util.cpp ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

//
// This workspace contains two projects -
// 1. ProgHelp which implements the Progress Interface 
// 2. The Sample application WmdmApp. 
//
//  ProgHelp.dll needs to be registered first for the SampleApp to run.


// Includes
//
#include "appPCH.h"

// Reg function variables
//
static HINSTANCE _hInst         = NULL;
static HKEY      _hkeyRoot      = NULL;


DWORD GetTheFileSize( LPSTR pszFile )
{
	DWORD  dwSize = 0xFFFFFFFF;
	HANDLE hFile;

	hFile = CreateFile(
		pszFile,
		GENERIC_READ,
		FILE_SHARE_READ,
		NULL,
		OPEN_EXISTING,
		FILE_FLAG_SEQUENTIAL_SCAN,
		NULL
	);
	if( INVALID_HANDLE_VALUE != hFile )
	{
		dwSize = GetFileSize( hFile, NULL );

		CloseHandle( hFile );
	}

	return dwSize;
}


//
//
// Registry functions
//
//

VOID SetRegistryParams( HINSTANCE hInst, HKEY hkeyRoot )
{
	_hInst    = hInst;
	_hkeyRoot = hkeyRoot;
}


DWORD GetRegDword_StrTbl(
	UINT  uPathID,
	UINT  uKeyID,
	DWORD dwDefault,
	BOOL  bStore
)
{
	CHAR szPath[MAX_PATH];
	CHAR szKey[MAX_PATH];

	LoadString( _hInst, uPathID, szPath, sizeof(szPath) );
	LoadString( _hInst, uKeyID, szKey, sizeof(szKey) );

	return GetRegDword(
		szPath,
		szKey,
		dwDefault,
		bStore
	);
}


DWORD GetRegDword(
	LPSTR szPath,
	LPSTR szKey,
	DWORD dwDefault,
	BOOL  bStore
)
{
	DWORD	dwRetCode;
	HKEY	hkey;
	DWORD	dwDisp;
	DWORD	dwData;
	DWORD	dwLen  = sizeof(DWORD);

	dwRetCode = RegCreateKeyEx(
		_hkeyRoot, 
		szPath, 
		0,
		NULL,
		REG_OPTION_NON_VOLATILE, 
		KEY_ALL_ACCESS,
		NULL,
		&hkey,
		&dwDisp
	);

	if( dwRetCode != ERROR_SUCCESS )
		return dwDefault;

	dwRetCode = RegQueryValueEx(
		hkey, 
		szKey, 
		NULL,
		NULL, 
		(LPBYTE)&dwData, 
		&dwLen
	);

	if( dwRetCode != ERROR_SUCCESS )
	{
		if( bStore && hkey != NULL )
		{
			// Store default in the registry
			RegSetValueEx(
				hkey, 
				szKey, 
				0L, 
				REG_DWORD, 
				(CONST BYTE *)&dwDefault, 
				dwLen
			);
		}

		dwData = dwDefault;
	}

	RegCloseKey( hkey );

	return dwData;
}

LPSTR GetRegStr_StrTblDefault(
	UINT uPathID,
	UINT uKeyID,
	UINT uDefaultID,
	BOOL bStore
)
{
	CHAR szPath[MAX_PATH];
	CHAR szKey[MAX_PATH];
	CHAR szDefault[MAX_PATH];

	LoadString( _hInst, uPathID, szPath, sizeof(szPath) );
	LoadString( _hInst, uKeyID, szKey, sizeof(szKey) );
	LoadString( _hInst, uDefaultID, szDefault, sizeof(szDefault) );

	return GetRegStr(
		szPath,
		szKey,
		szDefault,
		bStore
	);
}


LPSTR GetRegStr_StrTbl(
	UINT  uPathID,
	UINT  uKeyID,
	LPSTR szDefault,
	BOOL  bStore
)
{
	CHAR szPath[MAX_PATH];
	CHAR szKey[MAX_PATH];

	LoadString( _hInst, uPathID, szPath, sizeof(szPath) );
	LoadString( _hInst, uKeyID, szKey, sizeof(szKey) );

	return GetRegStr(
		szPath,
		szKey,
		szDefault,
		bStore
	);
}


LPSTR GetRegStr(
	LPSTR szPath,
	LPSTR szKey,
	LPSTR szDefault,
	BOOL  bStore
)
{
	HKEY   hkey;
	BOOL   bFound          = FALSE;
	DWORD  dwRetCode;
	DWORD  dwDisp;
	CHAR   szTmp[MAX_PATH];
	DWORD  dwSzLen         = sizeof(szTmp);
	LPVOID lpvValue;

	dwRetCode = RegCreateKeyEx(
		_hkeyRoot, 
		szPath, 
		0, 
		NULL,
		REG_OPTION_NON_VOLATILE, 
		KEY_ALL_ACCESS, 
		NULL,
		&hkey,
		&dwDisp
	);
	
	if( dwRetCode == ERROR_SUCCESS ) 
	{
		// We've opened the key, now find the value for szKey
		dwRetCode = RegQueryValueEx(
			hkey, 
			szKey, 
			NULL, 
			NULL, 
			(LPBYTE)szTmp, 
			&dwSzLen
		);

		bFound = ( dwRetCode == ERROR_SUCCESS );
	}

	if( !bFound )
	{
		if( szDefault == NULL )
			return NULL;
		
		// use default
		dwSzLen = lstrlen(szDefault);

		if( bStore && hkey != NULL )
		{
			// Store default in the registry
			RegSetValueEx(
				hkey, 
				szKey, 
				0L, 
				REG_SZ, 
				(CONST BYTE *)szDefault, 
				dwSzLen
			);
		}
	}

	lpvValue = (LPVOID) MemAlloc( dwSzLen + 1 );
	if( lpvValue == NULL )
	{
		return NULL;
	}

	lstrcpyn((char *)lpvValue, bFound? szTmp : szDefault, dwSzLen+1); //allocated dwSzLen+1 bytes, where length of szDefault and szTemp <= dwSzLen 

	if( hkey != NULL )
	{
		RegCloseKey( hkey );
	}

	return (LPSTR)lpvValue;
}


VOID WriteRegDword_StrTbl(
	UINT  uPathID,
	UINT  uKeyID,
	DWORD dwValue
)
{
	CHAR szPath[MAX_PATH];
	CHAR szKey[MAX_PATH];

	LoadString( _hInst, uPathID, szPath, sizeof(szPath) );
	LoadString( _hInst, uKeyID, szKey, sizeof(szKey) );

	WriteRegDword(
		szPath,
		szKey,
		dwValue
	);
}


VOID WriteRegDword(
	LPSTR szPath,
	LPSTR szKey,
	DWORD dwValue
)
{
	HKEY  hkey;
	DWORD dwRetCode;
	DWORD dwDisp;

	dwRetCode = RegCreateKeyEx(
		_hkeyRoot, 
		szPath, 
		0, 
		NULL,
		REG_OPTION_NON_VOLATILE, 
		KEY_ALL_ACCESS, 
		NULL,
		&hkey,
		&dwDisp
	);
	
	if( dwRetCode == ERROR_SUCCESS ) 
	{
		RegSetValueEx(
			hkey,
			szKey,
			0,
			REG_DWORD,
			(LPBYTE)&dwValue,
			sizeof(DWORD)
		);

		RegCloseKey( hkey );
	}
}


VOID WriteRegStr_StrTbl(
	UINT  uPathID,
	UINT  uKeyID,
	LPSTR szValue
)
{
	CHAR szPath[MAX_PATH];
	CHAR szKey[MAX_PATH];

	LoadString( _hInst, uPathID, szPath, sizeof(szPath) );
	LoadString( _hInst, uKeyID, szKey, sizeof(szKey) );

	WriteRegStr(
		szPath,
		szKey,
		szValue
	);
}


VOID WriteRegStr(
	LPSTR szPath,
	LPSTR szKey,
	LPSTR szValue
)
{
	HKEY   hkey;
	DWORD  dwRetCode;
	DWORD  dwDisp;

	dwRetCode = RegCreateKeyEx(
		_hkeyRoot, 
		szPath, 
		0, 
		NULL,
		REG_OPTION_NON_VOLATILE, 
		KEY_ALL_ACCESS, 
		NULL,
		&hkey,
		&dwDisp
	);
	
	if( dwRetCode == ERROR_SUCCESS ) 
	{
		RegSetValueEx(
			hkey,
			szKey,
			0,
			REG_SZ,
			(LPBYTE)szValue,
			lstrlen(szValue)+1
		);

		RegCloseKey( hkey );
	}
}


VOID StripPath( LPSTR szFullPath )
{
	LPSTR lpc = GetFileName( szFullPath );

	if( !lpc || lpc == szFullPath )
		return;

	lstrcpy( szFullPath, lpc ); //dest is a substring of source, hence OK
}


LPSTR GetFileName( LPSTR lpszFullPath )
{
    LPSTR lpszFileName;
    
 	if( !lpszFullPath )
	{
		return NULL;
	}

    for( lpszFileName = lpszFullPath; *lpszFullPath; lpszFullPath = AnsiNext(lpszFullPath) )
	{
        if( *lpszFullPath == '\\' )
		{
            lpszFileName = lpszFullPath + 1;
		}
    }
 
    return lpszFileName;

}


WPARAM DoMsgLoop( BOOL fForever )
{
	MSG msg;

	while( TRUE )
	{
		if( PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE) )
		{
			if( !GetMessage(&msg, NULL, 0, 0) )
			{
				break;
			}

			// Make sure all keyboard input gets posted to the main app window
			// in case it wants to handle it.
			//
			if( msg.message == WM_CHAR && msg.hwnd != g_hwndMain )
				PostMessage( g_hwndMain, msg.message, msg.wParam, msg.lParam );

			if( msg.message == WM_KEYDOWN && msg.hwnd != g_hwndMain )
				PostMessage( g_hwndMain, msg.message, msg.wParam, msg.lParam );

			TranslateMessage( &msg );
			DispatchMessage( &msg );
		}
		
		else if( fForever )
		{
			WaitMessage();
		}

		else
		{
			return 0;
		}
	}

    return msg.wParam;
}

LPSTR DropListToBuffer( HDROP hDrop, LIST_TYPE listType, UINT *uNumObjs )
{
	INT   i;
	LPSTR lpszFiles = NULL;
	LPSTR lpsz      = NULL;
	INT   nLen      = 0;
    INT   nObjs     = DragQueryFile( hDrop, 0xFFFFFFFF, NULL, 0 );

	// count the size needed for the files list
	for( i=0; i < nObjs; i++ )
	{
		// + 1 for the null terminator, + 2 for the pair of double quotes
        nLen += DragQueryFile( hDrop, i, NULL, 0 ) + 1;

		// need room for the pair of double quotes
		if( listType == LTB_SPACE_SEP )
			nLen += 2;
	}
	nLen++;

	// allocate the files list buffer
	lpszFiles = (LPSTR) MemAlloc( nLen );
	lpsz      = lpszFiles;
	if( !lpszFiles )
		return NULL;

	// Populate the files list with the dropped file/folder names.
	for( i=0; i < nObjs; i++ )
	{
		if( listType == LTB_SPACE_SEP )
			*lpsz++ = '\"';
        
		nLen = DragQueryFile( hDrop, i, lpsz, MAX_PATH );
		lpsz += nLen;
	
		if( listType == LTB_SPACE_SEP )
			*lpsz++ = '\"';

		if( listType == LTB_SPACE_SEP && i != nObjs-1 )
			*lpsz++ = ' ';
		else if( listType == LTB_NULL_TERM )
			*lpsz++ = 0;
    }
	// append null terminator
	*lpsz = 0;

	if( uNumObjs )
	{
		*uNumObjs = (UINT) nObjs;
	}

	return lpszFiles;
}


BOOL CenterWindow( HWND hwnd, HWND hwndRef )
{
	RECT rc;
	RECT rcRef;

	if( !hwnd )
		return FALSE;

	if( !GetClientRect(hwnd, &rc) )
		return FALSE;

	if( !GetWindowRect((hwndRef ? hwndRef : GetDesktopWindow()), &rcRef) )
		return FALSE;

	SetWindowPos(
		hwnd,
		NULL,
		rcRef.left + (rcRef.right - rcRef.left - rc.right)/2,
		rcRef.top  + (rcRef.bottom - rcRef.top - rc.bottom)/2,
		0, 0,
		SWP_NOSIZE | SWP_NOZORDER
	);	

	return TRUE;
}


VOID BringWndToTop( HWND hwnd )
{
	BringWindowToTop( hwnd );

	SetForegroundWindow( hwnd );

	SetWindowPos(
		hwnd,
		HWND_TOPMOST,
		0, 0, 0, 0,
		SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW
	);
	UpdateWindow( hwnd );

	SetWindowPos(
		hwnd,
		HWND_NOTOPMOST,
		0, 0, 0, 0,
		SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW
	);
	SetWindowPos(
		hwnd,
		HWND_TOP,
		0, 0, 0, 0,
		SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW
	);
	UpdateWindow( hwnd );

	ShowWindow( hwnd, SW_SHOWNORMAL );
}


HANDLE WaitForMutex( LPSTR pszMutexName, DWORD dwRetryTime, DWORD dwTimeout )
{
	HANDLE hMutex      = NULL;
	DWORD  dwStartTime = GetTickCount();

	// wait for the mutex to open up
	while( TRUE )
	{
		hMutex = CreateMutex( NULL, TRUE, pszMutexName );

		if( hMutex )
		{
			if( GetLastError() == ERROR_ALREADY_EXISTS )
			{
				// someone else has the mutex, so wait
				ReleaseMutex( hMutex );
				CloseHandle( hMutex );
			}
			else
			{
				// got mutex
				break;
			}

			// check for timeout if one was specified
			if( dwTimeout != (DWORD)-1 )
			{
				if( GetTickCount() > dwStartTime + dwTimeout )
				{
					hMutex = NULL;
					break;
				}
			}
		}

		// Wait for dwRetryTime clock ticks to try again
		//
		{
			DWORD dwStartWait = GetTickCount();
			DWORD dwEndWait   = dwStartWait + dwRetryTime;

			while( GetTickCount() <= dwEndWait )
			{
				DoMsgLoop( FALSE );
			}
		}
	}

	return hMutex;
}

LPSTR FormatBytesToSz(
	DWORD dwLowBytes,
	DWORD dwHighBytes,
	DWORD dwMultiplier,
	LPSTR psz, size_t cbMax
)
{
	INT64 nBytes = ( (INT64)dwHighBytes << 32 | (INT64)dwLowBytes ) * dwMultiplier;

	_ASSERT (psz != NULL && cbMax > 0);
	// Insert a comma if the size is big enough
	//
	if( nBytes < 1024 )
	{
		char szFormat[MAX_PATH];

		LoadString( _hInst, IDS_BYTESSIZE_NOCOMMA, szFormat, sizeof(szFormat) );

		dwLowBytes = (DWORD)nBytes;
		StringCbPrintf(psz, cbMax, szFormat, dwLowBytes); //not checking return value of this function as the out string is for display only
													//and the fn will always null terminate the string

		return psz;
	}
	else if( nBytes < 1024*1024 )
	{
		dwLowBytes = (DWORD)(nBytes / 1024 );

		return FormatKBToKB_Sz( dwLowBytes, psz, cbMax );
	}
	else
	{
		dwLowBytes = (DWORD)(nBytes / 1024 );

		return FormatKBToMB_Sz( dwLowBytes, psz, cbMax );
	}
}

LPSTR FormatBytesToKB_Sz( DWORD dwBytes, LPSTR pszKB, size_t cbMax )
{
	// Insert a comma if the size is big enough
	//
	_ASSERT (pszKB != NULL && cbMax > 0);
	
	if( dwBytes >= 1024 )
	{
		return FormatKBToKB_Sz( dwBytes/1024, pszKB, cbMax );
	}
	else
	{
		char szFormat[MAX_PATH];

		LoadString( _hInst, IDS_BYTESSIZE_NOCOMMA, szFormat, sizeof(szFormat) );
		StringCbPrintf(pszKB, cbMax, szFormat, dwBytes); //not checking return value of this function as the out string is for display only
													//and the fn will always null terminate the string

		return pszKB;
	}
}


LPSTR FormatKBToKB_Sz( DWORD dwKB, LPSTR pszKB, size_t cbMax )
{
	char  szFormat[MAX_PATH];

	// Insert a comma if the size is big enough
	//
	_ASSERT (pszKB != NULL && cbMax > 0);
	
	if( dwKB < 1000 )
	{
		LoadString( _hInst, IDS_KBSIZE_NOCOMMA, szFormat, sizeof(szFormat) );
		StringCbPrintf(pszKB, cbMax, szFormat, dwKB); //not checking return value of this function as the out string is for display only
													//and the fn will always null terminate the string
	}
	else
	{
		LoadString( _hInst, IDS_KBSIZE_COMMA, szFormat, sizeof(szFormat) );
		StringCbPrintf(pszKB, cbMax, szFormat, dwKB/1000, dwKB%1000); //not checking return value of this function as the out string is for display only
													//and the fn will always null terminate the string
	}

	return pszKB;
}


LPSTR FormatKBToMB_Sz( DWORD dwKB, LPSTR pszMB, size_t cbMax )
{
	char  szFormat[MAX_PATH];
	DWORD dwMB = dwKB / 1024;

	_ASSERT (pszKB != NULL && cbMax > 0);

	// Insert a comma if the size is big enough
	//
	if( dwMB < 100 )
	{
		LoadString( _hInst, IDS_MBSIZE_DECIMAL, szFormat, sizeof(szFormat) );
		StringCbPrintf(pszMB, cbMax, szFormat, dwKB/1024, dwKB%1024/100); //not checking return value of this function as the out string is for display only
													//and the fn will always null terminate the string
	}
	else if( dwMB < 1000 )
	{
		LoadString( _hInst, IDS_MBSIZE_NOCOMMA, szFormat, sizeof(szFormat) );
		StringCbPrintf(pszMB, cbMax, szFormat, dwMB); //not checking return value of this function as the out string is for display only
													//and the fn will always null terminate the string
	}
	else
	{
		LoadString( _hInst, IDS_MBSIZE_COMMA, szFormat, sizeof(szFormat) );
		StringCbPrintf(pszMB, cbMax, szFormat, dwMB/1000, dwMB%1000 ); //not checking return value of this function as the out string is for display only
													//and the fn will always null terminate the string
	}

	return pszMB;
}


LPSTR FormatSystemTimeToSz( SYSTEMTIME *pSysTime, LPSTR pszDateTime, DWORD cchMax )
{
	INT        nRet;
	SYSTEMTIME st;
	FILETIME   ftUTC;
	FILETIME   ftLocal;

	// Convert the UTC time to FILETIME
	//
	SystemTimeToFileTime( pSysTime, &ftUTC );

	// Convert the UTC FILETIME to a local FILETIME
	//
	FileTimeToLocalFileTime( &ftUTC, &ftLocal );

	// Convert the local FILETIME back to a SYSTEMTIME
	//
	FileTimeToSystemTime( &ftLocal, &st );

	// Get a user-displayable string for the SYSTEMTIME
	//
	nRet = GetDateFormat(
		LOCALE_USER_DEFAULT,
		0,
		&st,
		NULL,
		pszDateTime,
		cchMax
	);
	if( nRet > 0 )
	{
		*(pszDateTime + nRet - 1) = ' ';

		nRet = GetTimeFormat(
			LOCALE_USER_DEFAULT,
			TIME_NOSECONDS,
			&st,
			NULL,
			pszDateTime + nRet,
			cchMax - nRet
		);
	}

	if( 0 == nRet )
	{
		*pszDateTime = 0;
	}

	return pszDateTime;
}


LPARAM ListView_GetLParam( HWND hwndListView, INT nItem )
{
	LVITEM lvitem;

	lvitem.mask     = LVIF_PARAM;
	lvitem.iSubItem = 0;
	lvitem.iItem    = nItem;

	ListView_GetItem( hwndListView, &lvitem );

	return ( lvitem.lParam );
}


LPARAM TreeView_GetLParam( HWND hwndTreeView, HTREEITEM hItem )
{
	TVITEM tvitem;

	tvitem.mask     = TVIF_PARAM | TVIF_HANDLE;
	tvitem.hItem    = hItem;

	TreeView_GetItem( hwndTreeView, &tvitem );

	return ( tvitem.lParam );
}


BOOL TreeView_SetLParam( HWND hwndTreeView, HTREEITEM hItem, LPARAM lParam )
{
	TVITEM tvi;

	// Set up the item information
	//
	tvi.mask      = TVIF_HANDLE | TVIF_PARAM;
	tvi.hItem     = hItem;
	tvi.lParam    = lParam;

	// Set the lParam
	//
	return TreeView_SetItem( hwndTreeView, &tvi ); 
}


VOID UiYield( void )
{
	DoMsgLoop( FALSE );
}


INT GetShellIconIndex( LPCSTR pszItemName, LPTSTR szTypeBuffer, UINT cMaxChars )
{
    int         iIndex = -1;
    HANDLE      hFile  = INVALID_HANDLE_VALUE;
    SHFILEINFO  si;
    CHAR        szTempFile[MAX_PATH];
	static CHAR szTempPath[MAX_PATH];
	int			iRetVal = 1;

    if( 0 == szTempPath[0] )
    {
        // Temporary paths used to get icon indices
        //
        iRetVal = GetTempPath( sizeof(szTempPath), szTempPath );
    }

	//if these functions fail, the return index will remain -1 and no icon will be displayed, which is not disasterous
	if (iRetVal && SUCCEEDED(StringCbPrintf (szTempFile, sizeof(szTempFile), "%s~%s", szTempPath, pszItemName)))
	{

	    hFile = CreateFile(
			szTempFile,
			GENERIC_WRITE, 0, NULL,
			CREATE_ALWAYS,
			FILE_FLAG_DELETE_ON_CLOSE,
			NULL
		);
	   
	    SHGetFileInfo(
			szTempFile, 0,
			&si, sizeof(si),
			SHGFI_SYSICONINDEX | SHGFI_TYPENAME
		);

	    if( szTypeBuffer )
	    {
			StringCchCopy(szTypeBuffer, cMaxChars, si.szTypeName);
	    }

	    iIndex = si.iIcon;

	    if( INVALID_HANDLE_VALUE != hFile )
	    {
	        CloseHandle( hFile );
	    }
	}

    return( iIndex );
}

HICON GetShellIcon( LPCSTR pszItemName, BOOL bDirectory )
{
    HICON       hIcon = 0;
    HANDLE      hFile  = INVALID_HANDLE_VALUE;
    SHFILEINFO  sfi;
    CHAR        szTempFile[MAX_PATH];
	static CHAR szTempPath[MAX_PATH];
    DWORD_PTR   bOk;
	int			iRetVal = 1;

    if( 0 == szTempPath[0] )
    {
        // Temporary paths used to get icons
        //
        iRetVal = GetTempPath( sizeof(szTempPath), szTempPath );
    }

	if (iRetVal)
	{
	    if( bDirectory )
	    {
	        // Get the icon for the temp directory
	        strcpy( szTempFile, szTempPath ); //copying into same length string, hence OK
	    }
	    else 
	    {
	        // Create a new file with this name and get it's icon.
	        StringCbPrintf(szTempFile, sizeof(szTempFile), "%s~%s", szTempPath, pszItemName);
	        hFile = CreateFile( szTempFile,
			                    GENERIC_WRITE, 0, NULL,
			                    CREATE_ALWAYS,
			                    FILE_FLAG_DELETE_ON_CLOSE,
			                    NULL );
	    }

	   
	    bOk = SHGetFileInfo(szTempFile, 
	                        0,
	                        &sfi, 
	                        sizeof(SHFILEINFO), 
	                        SHGFI_ICON | SHGFI_SMALLICON);

	    if( INVALID_HANDLE_VALUE != hFile )
	    {
	        CloseHandle( hFile );
	    }
	}

    return ((bOk) ? sfi.hIcon : 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\common\include\key.c ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

//
// Note: This certificate is only meant to allow the project to compile.
// To interact with the WMDM, you need to obtain a valid certificate from Microsoft.
//

#include <wtypes.h>

BYTE abPVK[] = {
        0x00
};
BYTE abCert[] = {
        0x00
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\common\include\key.h ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

#include <wtypes.h>

extern BYTE abPVK[];
extern BYTE abCert[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\apps\wmdmapp\wmdevmgr.cpp ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

//
// This workspace contains two projects -
// 1. ProgHelp which implements the Progress Interface 
// 2. The Sample application WmdmApp. 
//
//  ProgHelp.dll needs to be registered first for the SampleApp to run.


//
// WMDM.cpp: implementation of the CWMDM class.
//

// Includes
//
#include "appPCH.h"
#include "mswmdm_i.c"
#include "sac.h"
#include "SCClient.h"

#include "key.c"

//////////////////////////////////////////////////////////////////////
//
// Construction/Destruction
//
//////////////////////////////////////////////////////////////////////

CWMDM::CWMDM()
{
	HRESULT hr;
    IComponentAuthenticate *pAuth = NULL;

	// Initialize member variables
	//
	m_pSAC        = NULL;
	m_pWMDevMgr   = NULL;
	m_pEnumDevice = NULL;

	// Acquire the authentication interface of WMDM
	//
    hr = CoCreateInstance(
		CLSID_MediaDevMgr,
		NULL,
		CLSCTX_INPROC_SERVER,
		IID_IComponentAuthenticate,
		(void**)&pAuth
	);
	ExitOnFail( hr );

	// Create the client authentication object
	//
	m_pSAC = new CSecureChannelClient;
	ExitOnNull( m_pSAC );

	// Select the cert and the associated private key into the SAC
	//
	hr = m_pSAC->SetCertificate(
		SAC_CERT_V1,
		(BYTE *)abCert, sizeof(abCert),
		(BYTE *)abPVK,  sizeof(abPVK)
	);
	ExitOnFail( hr );
            
	// Select the authentication interface into the SAC
	//
	m_pSAC->SetInterface( pAuth );

	// Authenticate with the V1 protocol
	//
    hr = m_pSAC->Authenticate( SAC_PROTOCOL_V1 );
	ExitOnFail( hr );

	// Authenticated succeeded, so we can use the WMDM functionality.
	// Acquire an interface to the top-level WMDM interface.
	//
    hr = pAuth->QueryInterface( IID_IWMDeviceManager, (void**)&m_pWMDevMgr );
	ExitOnFail( hr );

	// Get a pointer the the interface to use to enumerate devices
	//
	hr = m_pWMDevMgr->EnumDevices( &m_pEnumDevice );
	ExitOnFail( hr );

	hr = S_OK;

lExit:

	m_hrInit = hr;
}

CWMDM::~CWMDM()
{
	// Release the device enumeration interface
	//
	if( m_pEnumDevice )
	{
		m_pEnumDevice->Release();
	}

	// Release the top-level WMDM interface
	//
	if( m_pWMDevMgr )
	{
		m_pWMDevMgr->Release();
	}

	// Release the SAC
	//
	if( m_pSAC )
	{
		delete m_pSAC;
	}
}

//////////////////////////////////////////////////////////////////////
//
// Class methods
//
//////////////////////////////////////////////////////////////////////

HRESULT CWMDM::Init( void )
{
	return m_hrInit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\apps\wmdmapp\wmdevmgr.h ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

//
// This workspace contains two projects -
// 1. ProgHelp which implements the Progress Interface 
// 2. The Sample application WmdmApp. 
//
//  ProgHelp.dll needs to be registered first for the SampleApp to run.


//
// WMDM.h: interface for the CWMDM class.
//

#if !defined(AFX_WMDM_H__0C17A708_4382_11D3_B269_00C04F8EC221__INCLUDED_)
#define AFX_WMDM_H__0C17A708_4382_11D3_B269_00C04F8EC221__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "sac.h"
#include "SCClient.h"


class CWMDM
{
	HRESULT                m_hrInit;

public:

	CWMDM( void );
	virtual ~CWMDM( void );

	HRESULT Init( void );

	CSecureChannelClient  *m_pSAC; 

	IWMDeviceManager      *m_pWMDevMgr;
	IWMDMEnumDevice       *m_pEnumDevice;
};

#endif // !defined(AFX_WMDM_H__0C17A708_4382_11D3_B269_00C04F8EC221__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\apps\wmdmapp\wmdmapp.cpp ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

//
// This workspace contains two projects -
// 1. ProgHelp which implements the Progress Interface 
// 2. The Sample application WmdmApp. 
//
//  ProgHelp.dll needs to be registered first for the SampleApp to run.

// Includes
//
#include "appPCH.h"
#include "appRC.h"

// Constants
//
#define _szWNDCLASS_MAIN            "DrmXferAppWnd_Main"
#define _szMUTEX_APP                "DrmXferApplication_Mutex"

#define MIN_MAINWND_W               400
#define SHOWBUFFER                  10

// Macros
//

// Global variables
//
HINSTANCE g_hInst                   = NULL;
HWND      g_hwndMain                = NULL;

CStatus   g_cStatus;
CDevices  g_cDevices;
CDevFiles g_cDevFiles;
CWMDM     g_cWmdm;
BOOL      g_bUseOperationInterface = FALSE;

// Local variables
//
static HANDLE _hMutexDrmXfer        = NULL;

// Local functions
//
static VOID _CleanUp( void );
static VOID _InitSize( void );
static VOID _OnSize( HWND hwnd, WPARAM wParam, LPARAM lParam );
static VOID _OnMove( HWND hwnd, WPARAM wParam, LPARAM lParam );

static BOOL _InitWindow( void );
static BOOL _RegisterWindowClass( void );
static BOOL _UsePrevInstance( void );

// Local non-static functions
//
int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow );
BOOL CALLBACK MainWndProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );

// Command handlers
//
#define _nNUM_HANDLERS            5

typedef VOID (*HandleFunc) ( WPARAM wParam, LPARAM lParam );

static VOID _OnDeviceReset( WPARAM wParam, LPARAM lParam );
static VOID _OnDeviceClose( WPARAM wParam, LPARAM lParam );
static VOID _OnViewRefresh( WPARAM wParam, LPARAM lParam );
static VOID _OnFileDelete( WPARAM wParam, LPARAM lParam );
static VOID _OnOptionsUseOperationInterface( WPARAM wParam, LPARAM lParam );

struct {
	UINT        uID;
	HandleFunc  pfnHandler;
} 
_handlers[ _nNUM_HANDLERS ] =
{
	{ IDM_DEVICE_RESET,  _OnDeviceReset  },
	{ IDM_CLOSE,         _OnDeviceClose  },
	{ IDM_REFRESH,       _OnViewRefresh  },
	{ IDM_DELETE,        _OnFileDelete   },
	{ IDM_OPTIONS_USE_OPERATION_INTERFACE,        _OnOptionsUseOperationInterface  },
};


// 
//
int WINAPI WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
	WPARAM wParam;
    
	g_hInst = hInstance;

	InitCommonControls();

	if( _UsePrevInstance() )
	{
		return 0;
	}

	// Initialize COM
	//
	ExitOnFail( CoInitialize(NULL) );

	// Initialize registry
	//
	SetRegistryParams( g_hInst, HKEY_LOCAL_MACHINE );

	// Initialize the local environment and windows
	//
	ExitOnFalse( _RegisterWindowClass() );
	ExitOnFalse( _InitWindow() );

	// Initialize the WMDM
	//
	ExitOnFail( g_cWmdm.Init());

	// Enter message pump until app is closed
	//
	wParam = DoMsgLoop( TRUE );
	
	// Uninitialize COM
	//
	CoFreeUnusedLibraries();
	CoUninitialize();

	return (int)wParam;

lExit:
	
	return 0;
}


LRESULT CALLBACK WndProc_Main(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{   
	WORD wId         = LOWORD( (DWORD)wParam );
	WORD wNotifyCode = HIWORD( (DWORD)wParam );

    switch( uMsg )
    {
	case WM_CREATE:
		PostMessage( hWnd, WM_DRM_INIT, 0, 0 );
		break;

	case WM_DRM_INIT:
		_OnViewRefresh( 0, 0 );
		break;

	case WM_DRM_DELETEITEM:
		_OnFileDelete( 0, 0 );
		break;

	case WM_COMMAND:
        // Menu item selected
		if( BN_CLICKED == wNotifyCode || 0 == wNotifyCode || 1 == wNotifyCode )
		{
			INT i;

			for( i=0; i < _nNUM_HANDLERS; i++ )
			{
				if( wId == _handlers[i].uID )
				{
					(*_handlers[i].pfnHandler)( wParam, lParam );
					return 0;
				}
			}
		}
		break;

	case WM_ENDSESSION:
		if( (BOOL)wParam )
		{
			// shutting down
			_CleanUp();
		}
		break;

	case WM_SIZE:
		_OnSize( hWnd, wParam, lParam );
		return 0;

	case WM_SYSCOMMAND:
		if( SC_MAXIMIZE == wParam )
		{
			_OnSize( hWnd, wParam, lParam );
			return 0;
		}
		break;

	case WM_CLOSE:
		_CleanUp();
		PostQuitMessage( 0 );
		break;

	case WM_MOVE:
		_OnMove( hWnd, wParam, lParam );
		return 0;

	case WM_KEYDOWN:
		if( wParam == VK_F5 )
		{
			_OnViewRefresh( 0, 0 );
			return 0;
		}
		break;

	case WM_GETMINMAXINFO:
		{
			LPMINMAXINFO lpmmi = (LPMINMAXINFO) lParam; 

			lpmmi->ptMinTrackSize.x = MIN_MAINWND_W;
		}
		return 0;

	case WM_INITMENU:
        // Enable/disable 'Delete' - command
        EnableMenuItem( (HMENU)wParam, IDM_DELETE, MF_BYCOMMAND | 
                (g_cDevFiles.OkToDelete()) ? MF_ENABLED : MF_GRAYED );
        break;

	default:
		break;
    }

	return DefWindowProc( hWnd, uMsg, wParam, lParam );
}    


VOID _OnViewRefresh( WPARAM wParam, LPARAM lParam )
{
	HRESULT  hr;
	HCURSOR  hCursorPrev;

	// Show a wait cursor
	//
	hCursorPrev = SetCursor( LoadCursor(NULL, IDC_WAIT) );

	// Remove all current files
	//
	g_cDevFiles.RemoveAllItems();

	// Process messages to allow UI to refresh
	//
	UiYield();

	// Remove all devices
	//
	g_cDevices.RemoveAllItems();

	// Reset the device enumerator
	//
	hr = g_cWmdm.m_pEnumDevice->Reset();
	ExitOnFail( hr );

	// Loop through all devices and add them to the list
	//
	while( TRUE )
	{
		IWMDMDevice *pWmdmDevice;
		CItemData   *pItemDevice;
		ULONG        ulFetched;

		hr = g_cWmdm.m_pEnumDevice->Next( 1, &pWmdmDevice, &ulFetched );
		if( hr != S_OK )
		{
			break;
		}
		if( ulFetched != 1 )
		{
			ExitOnFail( hr = E_UNEXPECTED );
		}

		pItemDevice = new CItemData;
		if( pItemDevice )
		{
			hr = pItemDevice->Init( pWmdmDevice );
			if( SUCCEEDED(hr) )
			{
				g_cDevices.AddItem( pItemDevice );
			}
			else
			{
				delete pItemDevice;
			}
		}

		pWmdmDevice->Release();
	}

	// Update the device portion of the status bar
	//
	g_cDevices.UpdateStatusBar();

	// Update the file portion of the status bar
	//
	g_cDevFiles.UpdateStatusBar();

	// Use the default selection
	//
	g_cDevices.UpdateSelection( NULL, FALSE );

	// Return cursor to previous state
	//
	SetCursor( hCursorPrev );

lExit:

	return;
}

VOID _OnDeviceReset( WPARAM wParam, LPARAM lParam )
{
	CProgress  cProgress;
	CItemData *pItemDevice;
	HRESULT    hr;
	HTREEITEM  hItem;
		
	// Get the selected device to reset
	//
	hItem = g_cDevices.GetSelectedItem( (LPARAM *)&pItemDevice );
	ExitOnNull( hItem );
	ExitOnNull( pItemDevice );

	// You can only format devices, not individual folders
	//
	ExitOnFalse( pItemDevice->m_fIsDevice );

	// Create a progress dialog
	//
	ExitOnFalse( cProgress.Create(g_hwndMain) );

	// Set operation progress values
	//
	cProgress.SetOperation( "Initializing Device..." );
	cProgress.SetDetails( pItemDevice->m_szName );
	cProgress.SetRange( 0, 100 );
	cProgress.SetCount( -1, -1 );
	cProgress.SetBytes( -1, -1 );
	cProgress.Show( TRUE );

	hr = pItemDevice->m_pStorageGlobals->Initialize( WMDM_MODE_BLOCK, NULL );

	cProgress.Show( FALSE );
	cProgress.Destroy();

lExit:

	// Refresh the display
	//
	g_cDevices.UpdateSelection( NULL, FALSE );
}


VOID _OnFileDelete( WPARAM wParam, LPARAM lParam )
{
	CProgress cProgress;
	HRESULT   hr;
	INT       i;
	INT      *pnSelItems = NULL;
	INT       nNumSel;

	// Get the number of selected items.
	// Exit if there are no items selected.
	//
	nNumSel = 0;
	g_cDevFiles.GetSelectedItems( pnSelItems, &nNumSel );
	ExitOnTrue( 0 == nNumSel );

	// Allocate space to hold them the selected items
	//
	pnSelItems = new INT[ nNumSel ];
	ExitOnNull( pnSelItems );

	// Get the selected file(s) to delete
	//
	ExitOnTrue( -1 == g_cDevFiles.GetSelectedItems(pnSelItems, &nNumSel) );

	// Create a progress dialog
	//
	ExitOnFalse( cProgress.Create(g_hwndMain) );

	// Set operation progress values
	//
	cProgress.SetOperation( "Deleting Files..." );
	cProgress.SetRange( 0, nNumSel );
	cProgress.SetCount( 0, nNumSel );
	cProgress.SetBytes( -1, -1 );

	for( i=nNumSel-1; i >= 0; i-- )
	{
		CItemData *pStorage;

		// Get the storage object for the current item to delete
		//
		pStorage = (CItemData *)ListView_GetLParam( g_cDevFiles.GetHwnd_LV(), pnSelItems[i] );

		if( NULL != pStorage )
		{
			IWMDMStorageControl *pStorageControl;
		
			// Set the name of the object and show the progress dialog
			//
			cProgress.SetDetails( pStorage->m_szName );
			cProgress.IncCount();
			cProgress.IncPos( 1 );
			cProgress.Show( TRUE );

			hr = pStorage->m_pStorage->QueryInterface(
				IID_IWMDMStorageControl,
				reinterpret_cast<void**>(&pStorageControl)
			);
			if( SUCCEEDED(hr) )
			{
				hr = pStorageControl->Delete( WMDM_MODE_BLOCK, NULL );

				if( SUCCEEDED(hr) )
				{
					ListView_DeleteItem( g_cDevFiles.GetHwnd_LV(), pnSelItems[i] );
				}

				pStorageControl->Release();
			}
		}
	}

	cProgress.Show( FALSE );
	cProgress.Destroy();

lExit:

	if( pnSelItems )
	{
		delete [] pnSelItems;
	}

	// Refresh the device/devicefiles display
	//
	g_cDevices.UpdateSelection( NULL, FALSE );
}

VOID _OnDeviceClose( WPARAM wParam, LPARAM lParam )
{
	PostMessage( g_hwndMain, WM_CLOSE, (WPARAM)0, (LPARAM)0 );
}

// 
VOID _OnOptionsUseOperationInterface( WPARAM wParam, LPARAM lParam )
{
    HMENU   hMainMenu;
    HMENU   hOptionsMenu;

    // Remember new state
	g_bUseOperationInterface = !g_bUseOperationInterface;

    // Check uncheck menu
    hMainMenu = GetMenu(g_hwndMain);
    hOptionsMenu = GetSubMenu( hMainMenu, 1 );

    CheckMenuItem( hOptionsMenu, IDM_OPTIONS_USE_OPERATION_INTERFACE, 
                        MF_BYCOMMAND |
	            		(g_bUseOperationInterface ? MF_CHECKED : MF_UNCHECKED));
}



BOOL _InitWindow( void )
{
	BOOL fRet = FALSE;
	CHAR szApp[MAX_PATH];

	LoadString( g_hInst, IDS_APP_TITLE, szApp, sizeof(szApp) );

	g_hwndMain = CreateWindowEx(
		0L,
		_szWNDCLASS_MAIN,
    	szApp,
		WS_MINIMIZEBOX | WS_MAXIMIZEBOX | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | DS_3DLOOK | WS_CLIPCHILDREN,
		0, 0, 0, 0,
    	NULL, NULL, g_hInst, NULL
	);
	ExitOnNull( g_hwndMain );

	ExitOnFalse( g_cDevices.Create(g_hwndMain) );

	ExitOnFalse( g_cDevFiles.Create(g_hwndMain) );

	ExitOnFalse( g_cStatus.Create(g_hwndMain) );

	_InitSize();

	// Show the window
	//
	ShowWindow( g_hwndMain, SW_SHOW );

	fRet = TRUE;

lExit:

	return fRet;
}


BOOL _RegisterWindowClass (void)
{
    WNDCLASS  wc;

    wc.style          = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc    = WndProc_Main;
    wc.cbClsExtra     = 0;
	wc.cbWndExtra     = DLGWINDOWEXTRA;
    wc.hInstance      = g_hInst;
    wc.hIcon          = LoadIcon( g_hInst, MAKEINTRESOURCE(IDI_ICON) );
    wc.hCursor        = LoadCursor( NULL, IDC_ARROW );
    wc.hbrBackground  = (HBRUSH)(COLOR_BTNFACE + 1);
    wc.lpszMenuName   = MAKEINTRESOURCE( IDR_MENU );
    wc.lpszClassName  = _szWNDCLASS_MAIN;

    return RegisterClass( &wc );
}


VOID _CleanUp( void )
{
	if( _hMutexDrmXfer )
	{
		ReleaseMutex( _hMutexDrmXfer );
		CloseHandle( _hMutexDrmXfer );
	}

	g_cDevices.Destroy();

	g_cDevFiles.Destroy();
}


BOOL _UsePrevInstance( void )
{
	HWND  hwnd;
	DWORD dwErr;

	// Look for the mutex created by another instance of this app
	//
	_hMutexDrmXfer = CreateMutex( NULL, TRUE, _szMUTEX_APP );

	dwErr = GetLastError();

	if( !_hMutexDrmXfer )
	{
		// The function failed... don't use this instance
		//
		return TRUE;
	}

	// If mutex didn't exist, don't use a previous instance
	//
	if( dwErr != ERROR_ALREADY_EXISTS )
	{
		return FALSE;
	}

	hwnd = FindWindow( _szWNDCLASS_MAIN, NULL );

	if( !hwnd )
	{
		// Mutex exists, but the window doesn't?
		//
		ReleaseMutex( _hMutexDrmXfer );
		CloseHandle( _hMutexDrmXfer );

		return TRUE;
	}

	// Show main window that already exists
	//
	BringWndToTop( hwnd );

	return TRUE;
}


INT _GetRegSize( UINT uStrID_RegPath, UINT uStrID_DefVal )
{
	DWORD dwRet;

	dwRet = GetRegDword_StrTbl(
		IDS_REG_PATH_BASE,
		uStrID_RegPath,
		(DWORD)-1,
		FALSE
	);

	if( (DWORD)-1 == dwRet && -1 != uStrID_DefVal )
	{
		char szDef[32];

		LoadString( g_hInst, uStrID_DefVal, szDef, sizeof(szDef) );
		dwRet = (DWORD)atoi( szDef );
	}

	return (INT) dwRet;
}


VOID _InitSize( void )
{
	INT nX, nY, nW, nH;

	//
	// Get the window position values from the registry
	//
	nX = _GetRegSize( IDS_REG_KEY_XPOS,   (UINT)-1 );
	nY = _GetRegSize( IDS_REG_KEY_YPOS,   (UINT)-1 );
	nW = _GetRegSize( IDS_REG_KEY_WIDTH,  IDS_DEF_WIDTH  );
	nH = _GetRegSize( IDS_REG_KEY_HEIGHT, IDS_DEF_HEIGHT );

	// if the position didn't exist in the registry or
	// the position is off the screen ( +/- nSHOWBUFFER )
	// then center the window, otherwise use the position
	if( nX == -1 || nY == -1
		|| nX + nW < SHOWBUFFER
		|| nX + SHOWBUFFER > GetSystemMetrics(SM_CXSCREEN)
		|| nY + nH < SHOWBUFFER
		|| nY + SHOWBUFFER > GetSystemMetrics(SM_CYSCREEN)
	)
	{
		SetWindowPos( g_hwndMain, NULL, 0, 0, nW, nH, SWP_NOMOVE | SWP_NOZORDER );
		CenterWindow( g_hwndMain, NULL );
	}
	else
	{
		SetWindowPos( g_hwndMain, NULL, nX, nY, nW, nH, SWP_NOZORDER );
	}
}

VOID _OnSize( HWND hwnd, WPARAM wParam, LPARAM lParam )
{
	WINDOWPLACEMENT wndpl;

	wndpl.length = sizeof( WINDOWPLACEMENT );

	if( GetWindowPlacement(hwnd, &wndpl) )
	{
		DWORD dwW = wndpl.rcNormalPosition.right - wndpl.rcNormalPosition.left;
		DWORD dwH = wndpl.rcNormalPosition.bottom - wndpl.rcNormalPosition.top;
		RECT  rcMain;

		WriteRegDword_StrTbl( IDS_REG_PATH_BASE, IDS_REG_KEY_WIDTH,  dwW );
		WriteRegDword_StrTbl( IDS_REG_PATH_BASE, IDS_REG_KEY_HEIGHT, dwH );

		GetClientRect( hwnd, &rcMain );

		// set the position and size of the device window
		//
		g_cDevices.OnSize( &rcMain );

		// set the position and size of the device files window
		//
		g_cDevFiles.OnSize( &rcMain );

		// set the position of the status bar
		//
		g_cStatus.OnSize( &rcMain );

	}
}

VOID _OnMove( HWND hwnd, WPARAM wParam, LPARAM lParam )
{
	WINDOWPLACEMENT wndpl;

	if( hwnd != g_hwndMain )
	{
		return;
	}

	wndpl.length = sizeof(WINDOWPLACEMENT);

	if( GetWindowPlacement(hwnd, &wndpl) )
	{
		WriteRegDword_StrTbl(
			IDS_REG_PATH_BASE,
			IDS_REG_KEY_XPOS,
			wndpl.rcNormalPosition.left
		);
		WriteRegDword_StrTbl(
			IDS_REG_PATH_BASE,
			IDS_REG_KEY_YPOS,
			wndpl.rcNormalPosition.top
		);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\apps\wmdmapp\wmdmapp.h ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

//
// This workspace contains two projects -
// 1. ProgHelp which implements the Progress Interface 
// 2. The Sample application WmdmApp. 
//
//  ProgHelp.dll needs to be registered first for the SampleApp to run.


#ifndef _WMDMAPP_H
#define _WMDMAPP_H

// User-defined windows messages
//
#define WM_DRM_UPDATEDEVICE         ( WM_USER + 200 )
#define WM_DRM_INIT                 ( WM_USER + 201 )
#define WM_DRM_DELETEITEM           ( WM_USER + 202 )
#define WM_DRM_PROGRESS             ( WM_USER + 300 )

// Status Bar panes
//
#define SB_NUM_PANES             4
#define SB_PANE_DEVICE           0
#define SB_PANE_DEVFILES         1
#define SB_PANE_DEVFILES_FREE    2
#define SB_PANE_DEVFILES_USED    3

// Global variables
//
extern HINSTANCE g_hInst;
extern HWND      g_hwndMain;

extern CStatus   g_cStatus;
extern CDevices  g_cDevices;
extern CDevFiles g_cDevFiles;
extern CWMDM     g_cWmdm;
extern BOOL      g_bUseOperationInterface;

#endif // _WMDMAPP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\common\include\serialnumber.h ===
//-----------------------------------------------------------------------------
//
// File:   SerialNumber.h
//
// Microsoft Digital Rights Management
// Copyright (C) Microsoft Corporation, 1998 - 1999, All Rights Reserved
//
// Description:
//
//-----------------------------------------------------------------------------


#ifndef __SERIALNUMBER_H__
#define __SERIALNUMBER_H__

#pragma once

#ifndef WMDMID_LENGTH

    // Also defined in WMDM.idl
    #define WMDMID_LENGTH  128
    typedef struct  __WMDMID
        {
        UINT cbSize;
        DWORD dwVendorID;
        BYTE pID[ WMDMID_LENGTH ];
	    UINT SerialNumberLength;
    } WMDMID, *PWMDMID;

#endif

HRESULT __stdcall UtilGetSerialNumber(WCHAR *wcsDeviceName, PWMDMID pSerialNumber, BOOL fCreate);
HRESULT __stdcall UtilGetManufacturer(LPWSTR pDeviceName, LPWSTR *ppwszName, UINT nMaxChars);
HRESULT __stdcall UtilStartStopService(bool fStartService);
#endif // __SERIALNUMBER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\common\include\widestr.h ===
//////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
// File: widestr.h	-- defines WIDESTR and WIDECHAR macros for cross
//					   platform code development.	
//	
// This file is intended to be included in all files where the
// the unicode string prefix L"str" or L'c' is replaced by
// WIDESTR("str") or WIDECHAR('c') respectively.
//	
// Raj Nakkiran. Nov 1,2000
//
// Revisions:
//	
//////////////////////////////////////////////////////////////////////////

#ifndef __WIDESTR_H__
#define	__WIDESTR_H__

//
//	For Cross platform code, win2linux library provides
//	two-byte unicode support on all platforms. This is
//	true even in plaforms like linux/GCC where native
//	unicode is 4-bytes.
//
#ifdef XPLAT

#include "win2linux.h"

#else	// ! XPLAT	

#ifndef WIDESTR
#define	WIDESTR(x)	L##x		/* XPLAT */
#endif

#ifndef WIDECHAR
#define	WIDECHAR(x)	L##x		/* XPLAT */
#endif

#endif	// ! XPLAT	

#endif	// __WIDESTR_H__  EOF.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\common\include\serialid.h ===
//-----------------------------------------------------------------------------
//
// File:   serialid.h
//
// Microsoft Digital Rights Management
// Copyright (C) Microsoft Corporation, 1998 - 1999, All Rights Reserved
//
// Description:
//
//-----------------------------------------------------------------------------

#ifndef __SERIALID_H__
#define __SERIALID_H__

#include "objbase.h"

#define MDSP_PMID_SOFT  0
#define MDSP_PMID_SANDISK 1
#define MDSP_PMID_IOMEGA  2

#ifdef USE_PREBETA
#define WMDMID_LENGTH  20
typedef struct  __WMDMID
    {
    UINT cbSize;
    DWORD dwVendorID;
    BYTE pID[ WMDMID_LENGTH ];
} WMDMID, *PWMDMID;
#else
#define WMDMID_LENGTH  128
typedef struct  __WMDMID
    {
    UINT cbSize;
    DWORD dwVendorID;
    BYTE pID[ WMDMID_LENGTH ];
	UINT SerialNumberLength;
} WMDMID, *PWMDMID;
#endif

typedef struct _CEUTILGETSERIALNUMBERDATA {
	WCHAR wcsMediaPath[MAX_PATH];
	ULONG SerialNumberLength;
	ULONG Result;
	ULONG Reserved[2];
	BYTE  SerialNumberData[WMDMID_LENGTH];
} CEUTILGETSERIALNUMBERDATA, *PCEUTILGETSERIALNUMBERDATA;

#ifndef VWIN32_DIOC_DOS_IOCTL
#define VWIN32_DIOC_DOS_IOCTL 1

typedef struct _DIOC_REGISTERS {
  DWORD reg_EBX;
  DWORD reg_EDX;
  DWORD reg_ECX;
  DWORD reg_EAX;
  DWORD reg_EDI;
  DWORD reg_ESI;
  DWORD reg_Flags;
}DIOC_REGISTERS, *PDIOC_REGISTERS;

#endif

#define WIN9X_IOCTL_GET_MEDIA_SERIAL_NUMBER	0x81  
#define DEFAULT_MEDIA_SERIAL_NUMBER_LENGTH 80    

typedef struct _MEDIA_SERIAL_NUMBER_DATA {
    ULONG SerialNumberLength;            // offset 00
    ULONG Result;                        // offset 04  
    ULONG Reserved[2];                   // offset 08  
    UCHAR SerialNumberData[1];           // offset 16
} MEDIA_SERIAL_NUMBER_DATA, *PMEDIA_SERIAL_NUMBER_DATA;  


// Diasable warning 4200
// nonstandard extension used : zero-sized array in struct/union
#pragma warning(disable: 4200)

//
// Struct returned for MEDIA_SERIAL_NUMBER
//
typedef struct _GET_MEDIA_SERIAL_NUMBER_RESPONSE_DATA 
{
    UCHAR DataLength[2];
    UCHAR Format    : 4;
    UCHAR Reserved1 : 4;
    UCHAR Reserved2;
    UCHAR Data[0];          // variable length structure
} GET_MEDIA_SERIAL_NUMBER_RESPONSE_DATA, *PGET_MEDIA_SERIAL_NUMBER_RESPONSE_DATA;

// Turn on warning 4200 again
#pragma warning(default: 4200)


HRESULT __stdcall UtilGetSerialNumber(WCHAR *wcsDeviceName, PWMDMID pSerialNumber, BOOL fCreate);
HRESULT __stdcall CeUtilGetSerialNumber(WCHAR *wcsDeviceName, PWMDMID pSerialNumber, HANDLE hExit, ULONG fReserved);
HRESULT __stdcall CeGetDiskFreeSpaceEx(LPCWSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\common\include\wmdmutil.h ===
//-----------------------------------------------------------------------------
//
// File:   drmutil.h
//
// Microsoft Digital Rights Management
// Copyright (C) 1998-1999 Microsoft Corporation, All Rights Reserved
//
// Description:
//
//-----------------------------------------------------------------------------

#ifndef __WMDM_REVOKED_UTIL_H__
#define __WMDM_REVOKED_UTIL_H__

#include <license.h>
#include <wtypes.h>

DWORD   GetSubjectIDFromAppCert( APPCERT appcert );
BOOL    IsMicrosoftRevocationURL( LPWSTR pszRevocationURL );
HRESULT BuildRevocationURL( DWORD* pdwSubjectIDs, 
                            LPWSTR* ppwszRevocationURL,
                            DWORD*  pdwBufferLen );

#endif // __WMDM_REVOKED_UTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\common\include\drmerr.h ===
//----------------------------------------------------------------------------
// File: drmerr.h
//
// Copyright (C) 1997-1999 Microsoft Corporation, All rights reserved.
//
// Description
// Includes some helpful define and macros for error flow control.
//
// Author: dongi
//----------------------------------------------------------------------------

#ifndef __DRMERR_H__
#define __DRMERR_H__


// ----------------- BEGIN HACK ----------------------------------------
// author: Davidme (though I don't want the credit!)
// date:   Sept 16, 1998
//
// The problem is that the CORg macros depend on using the Error label
// and ADO defines the symbol Error in adoint.h.  So any code that wants
// to use both this file and ADO breaks.  The hack is to fool adoint.h
// to not define the Error symbol.  This should not affect any C++ code
// that uses adoint.h since the Error symbol is defined in adoint.h only
// if the __cplusplus is not defined.
//
// The easy workaround if you get the error below is to #include this file
// before including adoint.h.
//
// Hopefully this hack is less intrusive than the previous one!

#ifdef _ADOINT_H_
#error Name collision with ADO's Error symbol and this file's use of the Error label.  To fix this problem,\
 define __Error_FWD_DEFINED__ before including adoint.h or include this header file before including adoint.h.
#else
#define __Error_FWD_DEFINED__
#endif  // _ADOINT_H_

// ----------------- END HACK ------------------------------------------


#include <wtypes.h>

/*----------------------------------------------------------------------------
	Some hungarian style definitions
 ----------------------------------------------------------------------------*/


#define	fFalse		0
#define fTrue		1

#define hrOK		HRESULT(S_OK)
#define hrTrue		HRESULT(S_OK)
#define hrFalse		ResultFromScode(S_FALSE)
#define hrFail		ResultFromScode(E_FAIL)
#define hrNotImpl	ResultFromScode(E_NOTIMPL)
#define hrNoInterface	ResultFromScode(E_NOINTERFACE)
#define hrNoMem	ResultFromScode(E_OUTOFMEMORY)
#define hrAbort		ResultFromScode(E_ABORT)
#define hrInvalidArg	ResultFromScode(E_INVALIDARG)

#define MSCSAssert(f) ((void)0)

#define HRESULT_FROM_ADO_ERROR(hr)   ((hr == S_OK) ? S_OK : ((HRESULT) (hr | 0x80000000)) )


/*----------------------------------------------------------------------------
	CORg style error handling
	(Historicaly stands for Check OLE Result and Goto)
 ----------------------------------------------------------------------------*/

#define DebugMessage(a,b,c) //TODO: Define it in terms of _CrtDbgRetport or _RPTF

#define _UNITEXT(quote) L##quote
#define UNITEXT(quote) _UNITEXT(quote)

#define	CPRg(p)\
	do\
		{\
		if (!(p))\
			{\
			hr = hrNoMem;\
            DebugMessage(__FILE__, __LINE__, hr);\
			goto Error;\
			}\
		}\
	while (fFalse)

#define	CHRg(hResult) CORg(hResult)

#define	CORg(hResult)\
	do\
		{\
		hr = (hResult);\
        if (FAILED(hr))\
            {\
            DebugMessage(__FILE__, __LINE__, hr);\
            goto Error;\
            }\
		}\
	while (fFalse)

#define	CADORg(hResult)\
	do\
		{\
		hr = (hResult);\
        if (hr!=S_OK && hr!=S_FALSE)\
            {\
            hr = HRESULT_FROM_ADO_ERROR(hr);\
            DebugMessage(__FILE__, __LINE__, hr);\
            goto Error;\
            }\
		}\
	while (fFalse)

#define	CORgl(label, hResult)\
	do\
		{\
		hr = (hResult);\
        if (FAILED(hr))\
            {\
            DebugMessage(__FILE__, __LINE__, hr);\
            goto label;\
            }\
		}\
	while (fFalse)

#define	CWRg(fResult)\
	{\
	if (!(fResult))\
		{\
        hr = GetLastError();\
	    if (!(hr & 0xFFFF0000)) hr = HRESULT_FROM_WIN32(hr);\
        DebugMessage(__FILE__, __LINE__, hr);\
		goto Error;\
		}\
	}

#define	CWRgl(label, fResult)\
	{\
	if (!(fResult))\
		{\
        hr = GetLastError();\
		if (!(hr & 0xFFFF0000)) hr = HRESULT_FROM_WIN32(hr);\
        DebugMessage(__FILE__, __LINE__, hr);\
		goto label;\
		}\
	}

#define	CFRg(fResult)\
	{\
	if (!(fResult))\
		{\
		hr = hrFail;\
        DebugMessage(__FILE__, __LINE__, hr);\
		goto Error;\
		}\
	}

#define	CFRgl(label, fResult)\
	{\
	if (!(fResult))\
		{\
		hr = hrFail;\
        DebugMessage(__FILE__, __LINE__, hr);\
		goto label;\
		}\
	}

#define	CARg(p)\
	do\
		{\
		if (!(p))\
			{\
			hr = hrInvalidArg;\
	        DebugMessage(__FILE__, __LINE__, hr);\
			goto Error;\
			}\
		}\
	while (fFalse)



//+---------------------------------------------------------------------------
//
//  The custom _Assert we formerly used has been replaced with one that calls
//  the C run-time _CrtDbgReport method (same as _ASSERTE).  If your project
//  doesn't link with the C run-time for some reason, you must provide your own
//  definition for _Assert before including this header file.
//
//  I recommend using the _Assert macro and not _ASSERTE because you can replace
//  the implementation later by defining your own before including this header.
//
//  IMPORTANT: If your code runs as a service or is an object that runs in a
//      service, you should use the INSTALL_ASSERT_EVENTLOG_HOOK macro to
//      install a handler that turns off the default functionality of popping
//      up a message box when an assertion occurs in favor of logging it to
//      the EventLog and debug console and then kicking you into the debugger.
//      This way your service won't hang trying to pop up a window.
//
//  History:    09/17/98    davidme     switched to using this CRT implementation
//
//----------------------------------------------------------------------------


#ifndef _Assert
#ifdef _DEBUG

#include <crtdbg.h>
#define _Assert(f)          _ASSERTE(f)     // use crtdbg's ASSERT
int AssertEventlogHook( int, char *, int * );
#define INSTALL_ASSERT_EVENTLOG_HOOK    _CrtSetReportHook(AssertEventlogHook);

#else   // _DEBUG

#define _Assert(f)          ((void)0)
#define INSTALL_ASSERT_EVENTLOG_HOOK

#endif // _DEBUG
#endif // _Assert


#endif // __MSCSERR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\common\include\ver\wmdm_build_ver.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2001
//
//  File:       mmsverp.h
//
//  Description: ******TO BE MODIFIED BY THE OFFICIAL BUILDER ONLY*****
//
//               This file contains the build number part of the version for
//               WMDM binaries
//--------------------------------------------------------------------------


//TO BE MODIFIED BY THE BUILDER ONLY

#define VER_WMDM_PRODUCTBUILD            18
#define VER_WMDM_PRODUCTBUILD_STR        "18\0"          //trailing \0 for NULL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\common\include\ver\wmdm_ver.h ===
//+----------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       mmsverp.h
//
//  Description: This file contains common definitions for verion definitions
//               for WMDM binaries.
//+----------------------------------------------------------------------------

#include <winver.h>
#include <wmdm_build_ver.h>

// WMDM version information 
// Version: 1.0.0.BUILD
// Meaning: Major.Minor.Update.Build

#define VER_WMDM_PRODUCTVERSION_STR	 "8.0.1." VER_WMDM_PRODUCTBUILD_STR
#define VER_WMDM_PRODUCTVERSION	8,0,1,VER_WMDM_PRODUCTBUILD 

#define VER_WMDM_PRODUCTNAME_STR        "Windows Media Device Manager\0"
#define VER_WMDM_COMPANYNAME_STR        "Microsoft Corporation\0"
#define VER_WMDM_LEGALCOPYRIGHT_YEARS   "1999-2001\0"
#define VER_WMDM_LEGALCOPYRIGHT_STR     "Copyright (C) Microsoft Corp.\0"
#define VER_WMDM_FILEOS                 VOS_NT_WINDOWS32

#ifdef EXPORT_CONTROLLED

#ifdef EXPORT
#define EXPORT_TAG  " (Export Version)\0"
#else
#define EXPORT_TAG  " (Domestic Use Only)\0"
#endif

#else           /* Not Export Controlled */

#define EXPORT_TAG

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\common\include\wmsstd.h ===
#ifndef __WMSSTD_H__
#define __WMSSTD_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <windows.h>
#include <string.h>
#include <tchar.h>
#include <winnls.h>

/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// GENERIC MACROS //////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

#define MAX(a, b) (max((a), (b)))
#define MIN(a, b) (min((a), (b)))

#define MAKEULONGLONG(a, b) ((ULONGLONG)(((DWORD)(a)) | ((ULONGLONG)((DWORD)(b))) << 32))
#define MAKEUINT64(a, b)    MAKEULONGLONG((a),(b))
#define MAKEQWORD(a, b)     MAKEULONGLONG((a),(b))
#define LODWORD(l)          ((DWORD)(l))
#define HIDWORD(l)          ((DWORD)(((ULONGLONG)(l) >> 32) & 0xFFFFFFFF))

#if !defined(COUNTOF)                   // macro to obtain the storage size of an array.
#define COUNTOF( x )        ( sizeof(x) / sizeof( (x)[0] ) )
#endif

/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// WINSOCK MACROS //////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

#define NTOHULL(ull)        MAKEULONGLONG(ntohl(LODWORD((ull))), ntohl(HIDWORD((ull))))
#define HTONULL(ull)        MAKEULONGLONG(htonl(LODWORD((ull))), htonl(HIDWORD((ull))))


/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////// TYPES ///////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

typedef ULONGLONG           QWORD;
typedef QWORD               *LPQWORD;

#ifndef _WIN64

typedef ULONG               ULONG_PTR;
typedef LONG                LONG_PTR;

#endif // _WIN64


/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// COMMENT MACROS //////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

#define PUBLIC      
#define PROTECTED
#define PRIVATE 
#define STATIC
#define VIRTUAL


/////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////// DEBUG/RETAIL MACROS ////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

#if DBG

#define Debug(s)            s   // Statement/declaration included only if DBG
#define Retail(s)               // Statement/declaration included only if !DBG
#define DebugOrRetail(d, r) d   // d if DBG; r if !DBG

#else // !DBG

#define Debug(s)                // Statement/declaration included only if DBG
#define Retail(s)           s   // Statement/declaration included only if !DBG
#define DebugOrRetail(d, r) r   // d if DBG; r if !DBG

#endif // !DBG


/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// STRING MACROS ///////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

#if UNICODE
#define Unicode(s)          (s)
#define Ansi(s)
#define UnicodeOrAnsi(u, a) (u)
#define AnsiOrUnicode(a, u) (u)
#else
#define Unicode(s)
#define Ansi(s)             (s)
#define UnicodeOrAnsi(u, a) (a)
#define AnsiOrUnicode(a, u) (a)
#endif


#define WcharToAchar(a, w, l)       \
            WideCharToMultiByte(    \
                CP_ACP,             \
                0,                  \
                (w),                \
                -1,                 \
                (a),                \
                (l),                \
                NULL,               \
                NULL                \
                )

#define AcharToWchar(w, a, l)       \
            MultiByteToWideChar(    \
                CP_ACP,             \
                0,                  \
                (a),                \
                -1,                 \
                (w),                \
                (l)                 \
                )

#define WcharToTchar(t, w, l) UnicodeOrAnsi(wcscpy((t), (w)), WcharToAchar((t), (w), (l)))
#define WcharToTcharEx(t, w, l, p) UnicodeOrAnsi((p) = (w), (WcharToAchar((t), (w), (l)), (p) = (t)))
#define TcharToWchar(w, t, l) UnicodeOrAnsi(wcscpy((w), (t)), AcharToWchar((w), (t), (l)))
#define TcharToWcharEx(w, t, l, p) UnicodeOrAnsi((p) = (t), (AcharToWchar((w), (t), (l)), (p) = (w)))

#define AcharToTchar(t, a, l) AnsiOrUnicode(strcpy((t), (a)), AcharToWchar((t), (a), (l)))
#define AcharToTcharEx(t, a, l, p) AnsiOrUnicode((p) = (a), (AcharToWchar((t), (a), (l)), (p) = (t)))
#define TcharToAchar(a, t, l) AnsiOrUnicode(strcpy((a), (t)), WcharToAchar((a), (t), (l)))
#define TcharToAcharEx(a, t, l, p) AnsiOrUnicode((p) = (t), (WcharToAchar((a), (t), (l)), (p) = (a)))


/////////////////////////////////////////////////////////////////////////////////////////
//////////////////////// REFCOUNT AND SAFE_* MACROS /////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

#ifdef INC_REF
#undef INC_REF
#endif
#ifdef DEC_REF
#undef DEC_REF
#endif

#ifdef SINGLE_THREADED
    #define INC_REF(u) (++u)
    #define DEC_REF(u) (--u)
#else // !SINGLE_THREADED
    #define INC_REF(u) InterlockedIncrement((LONG*)&u)
    #define DEC_REF(u) InterlockedDecrement((LONG*)&u)
#endif // SINGLE_THREADED

#ifndef _REF_ASSERT
    #ifdef NO_DEBUG_SYNCHRO
        #define _REF_ASSERT(x) 
    #else // !NO_DEBUG_SYNCHRO
        #ifdef USE_MFC
            #define _REF_ASSERT(x) ASSERT(x)
        #else // !USE_MFC
            #include <assert.h>
            #define _REF_ASSERT(x) assert(x)
        #endif // USE_MFC
    #endif // NO_DEBUG_SYNCHRO
#endif

#ifdef WIN32
#define YIELD(hwnd,reps) (void)0
#else
#define YIELD(hwnd,reps) \
        {MSG msg;int n=(int)(reps);while( n-- && PeekMessage( &msg, hwnd, 0, 0, PM_REMOVE ) ){TranslateMessage( &msg );DispatchMessage( &msg );}}
#endif

#define SAFE_ADDREF(p)              if( NULL != p ) { ( p )->AddRef(); }
#define SAFE_DELETE(p)              if( NULL != p ) { delete p; p = NULL; }
#define SAFE_ARRAY_DELETE(p)        if( NULL != p ) { delete [] p; p = NULL; }
#define SAFE_RELEASE(p)             if( NULL != p ) { ( p )->Release(); p = NULL; }
#define SAFE_SHUTRELEASE(p)         if( NULL != p ) { ( p )->Shutdown(); ( p )->Release(); p = NULL; }
#define SAFE_COTASKMEMFREE(p)       if( NULL != p ) { CoTaskMemFree( p ); p = NULL; }
#define SAFE_SYSFREESTRING(p)       if( NULL != p ) { SysFreeString( p ); p = NULL; }
#define SAFE_ARRAYDELETE(p)         if( NULL != p ) { delete [] p; p = NULL; }
#define SAFE_CLOSEHANDLE( h )       if( NULL != h ) { CloseHandle( h ); h = NULL; }
#define SAFE_CLOSEFILEHANDLE( h )   if( INVALID_HANDLE_VALUE != h ) { CloseHandle( h ); h = INVALID_HANDLE_VALUE; }
#define SAFE_GLOBALFREE(p)          if( NULL != p ) { GlobalFree( p ); p = NULL; }

//
// Ref-count safe assignment of 'src' to 'dst'
//
#define SAFE_REPLACEREF( dst, src )   \
    { \
        if( NULL != ( src ) ) \
        { \
            ( src )->AddRef( ); \
        } \
        if( NULL != ( dst ) ) \
        { \
            ( dst )->Release( ); \
        } \
        dst = src; \
    }

/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////// OUTPARAMETER VALIDATION AND INITIALIZATION //////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

#ifdef __tagVARIANT
inline HRESULT ValidateOutPtr( VARIANT* pDest, VARIANT& /*bogus*/ )
{
    if( reinterpret_cast< VARIANT* >( NULL ) == pDest )
    {
        return( E_POINTER );
    }
    ::VariantClear( pDest );
    return( S_OK );
}
#endif

template< class Tptr, class T > HRESULT ValidateOutPtr( Tptr& pVal, T&/* bogus*/ )
{
    if( reinterpret_cast< Tptr >( NULL ) == pVal )
    {
        return( E_POINTER );
    }
    *pVal = static_cast< T >( 0 );
    return( S_OK );
}

// Validate a pointer argument and initialize it if valid.
#define VALIDOUT_PTR( pVal ) \
{ \
    HRESULT hr = ValidateOutPtr( pVal, *pVal ); \
    if( FAILED( hr ) ) \
    { \
        return( hr ); \
    } \
}

/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////// UTILITY MACROS//////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

#define ARRAYSIZE(x) (sizeof(x)/sizeof(x[0]))


#endif // __WMSSTD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\common\serialnumber\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    makefile.inc.

!ENDIF


AddIoReady:
    call AddIoReady.bat
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\common\serialnumber\aspi32.cpp ===
// Aspi32Util.cpp: implementation of the Aspi32Util class.
//
//////////////////////////////////////////////////////////////////////

#include "Aspi32.h"
#include "serialid.h"
#include "winioctl.h"

#ifndef VWIN32_DIOC_DOS_IOCTL
#define VWIN32_DIOC_DOS_IOCTL 1

typedef struct _DIOC_REGISTERS {
  DWORD reg_EBX;
  DWORD reg_EDX;
  DWORD reg_ECX;
  DWORD reg_EAX;
  DWORD reg_EDI;
  DWORD reg_ESI;
  DWORD reg_Flags;
}DIOC_REGISTERS, *PDIOC_REGISTERS;

#endif

// Intel x86 processor status fla
#define CARRY_FLAG  0x1

#pragma pack(1)
typedef struct _DRIVE_MAP_INFO {    
    BYTE	AllocationLength;
    BYTE	InfoLength;
    BYTE	Flags;
    BYTE	Int13Unit;
    DWORD	AssociatedDriveMap;
    BYTE    PartitionStartRBA[8];
} DRIVE_MAP_INFO, *PDRIVE_MAP_INFO;
#pragma pack()


typedef struct _DEV_REGVALUES {
	char DeviceDesc[MAX_PATH];
	int  SCSITargetID;
	int  SCSILUN;
} DEV_REGVALUES, *PDEV_REGVALUES;

#ifdef _DEBUG
char g_msg[MAX_PATH];
#endif
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
extern BOOL IsWinNT();

Aspi32Util::Aspi32Util()
{
	char szTmp[MAX_PATH];

	m_NumAdapters=0;	

	GetSystemDirectoryA(szTmp, MAX_PATH);
	strcat(szTmp, "\\wnaspi32.dll");

	m_hd = LoadLibraryA(szTmp);

	if( m_hd ) 
	{
		m_funGetASPI32SupportInfo = (P_GASI)GetProcAddress (m_hd,"GetASPI32SupportInfo");
		m_funSendASPI32Command = (P_SAC)GetProcAddress (m_hd,"SendASPI32Command");
	} else {
		m_funGetASPI32SupportInfo = NULL;
		m_funSendASPI32Command = NULL;
	}
}

Aspi32Util::~Aspi32Util()
{
	if( m_hd ) FreeLibrary(m_hd);
}

BOOL CompactString(char *src, char token)
{
	int len, iSrc=0, iDst=0, flag=0;
	char *dst=NULL;

	len=strlen(src);

	if( len < 1 ) return FALSE;

	dst = new char [len];

	if( !dst ) return FALSE;

    while( *(src+iSrc) )
	{
		if( flag && (token != *(src+iSrc)) )
		{
			flag=0;
		}

		if( token == *(src+iSrc) )
		{
			flag=1;
		}

		if( !flag )
		{ 
          *(dst+iDst) = *(src+iSrc);
		  iDst++;
		}

        iSrc++;
	}

	*(dst+iDst)=0;
    
	strcpy(src, dst);

	if( dst )
		delete [] dst;
	return TRUE;
}

// reminder: this is a win9x only solution
BOOL Aspi32Util::ASPI32_GetScsiDiskForParallelReader(char *szDL, SCSI_ADDRESS *pScsiAddr)
{
	BOOL bRet=FALSE;
	char szVIDKeyName[MAX_PATH], szPIDKeyName[MAX_PATH];
	char szTmpKeyName[3*MAX_PATH], szOrgDL[4], szTmpDL[4], szTmpClass[32];
    DWORD dwKeyNameLen=MAX_PATH, dwDLSize=4;
    DWORD nKeySCSI, nKeySCSISub1, dwType;
    int  nRegFound=0;
    PDEV_REGVALUES ppDevReg[16];
	int i, nMatches=0;
    BYTE pBuf[MAX_PATH];

	HKEY hKeySCSI=NULL, hKeySCSISub1=NULL, hKeySCSISub2=NULL;
	
	if( IsWinNT() ) return FALSE;

	if( !szDL || !pScsiAddr ) 
	{
		bRet=FALSE; 
		goto Error;
	}

	if( szDL[0] < 0x41 || szDL[0] > 0x7A ||
		(szDL[0]>0x5A && szDL[0] < 0x61 ) )
	{
		bRet=FALSE;
		goto Error;
	}

	ZeroMemory(ppDevReg, 16*sizeof(PDEV_REGVALUES));

	szOrgDL[0] = szDL[0];
	szOrgDL[1] = 0;
	strcpy(szTmpKeyName, "Enum\\SCSI");
    if( ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szTmpKeyName, NULL, KEY_QUERY_VALUE, &hKeySCSI) )
	{
		nKeySCSI=0;
		dwKeyNameLen=MAX_PATH;
		while( !bRet && ERROR_SUCCESS == RegEnumKeyEx(hKeySCSI, nKeySCSI, szVIDKeyName, &dwKeyNameLen, 0, NULL, NULL, NULL) )
		{
			strcpy(szTmpKeyName, "Enum\\SCSI\\");
			strcat(szTmpKeyName, szVIDKeyName);
			if( ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szTmpKeyName, NULL, KEY_QUERY_VALUE, &hKeySCSISub1) )
			{
				nKeySCSISub1=0;
				dwKeyNameLen=MAX_PATH;
				while( !bRet && ERROR_SUCCESS == RegEnumKeyEx(hKeySCSISub1, nKeySCSISub1, szPIDKeyName, &dwKeyNameLen, 0, NULL, NULL, NULL) )
				{
  					
                    strcpy(szTmpKeyName, "Enum\\SCSI\\");
					strcat(szTmpKeyName, szVIDKeyName);
					strcat(szTmpKeyName, "\\");
					strcat(szTmpKeyName, szPIDKeyName);
					if( ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szTmpKeyName, NULL, KEY_QUERY_VALUE, &hKeySCSISub2) )
					{
						dwDLSize=4;
						dwType=REG_SZ;
						if( ERROR_SUCCESS == RegQueryValueEx(hKeySCSISub2, "CurrentDriveLetterAssignment", 0, &dwType,(LPBYTE)(&szTmpDL[0]), &dwDLSize) )
						{
							szTmpDL[1]=0;
							if( !stricmp(szOrgDL, szTmpDL) )
							{
                                // Match found, copy info here
								ppDevReg[nRegFound] = new DEV_REGVALUES;

								if( !ppDevReg[nRegFound] ) 
								{
									bRet=TRUE; // break the loop
								} else {
									// Get SCSITargetID
									dwType=REG_SZ;
									dwDLSize=32;
           							if( ERROR_SUCCESS == RegQueryValueEx(hKeySCSISub2, "SCSITargetID", 0, &dwType,(LPBYTE)(&szTmpClass[0]), &dwDLSize) )
									{
										ppDevReg[nRegFound]->SCSITargetID = atoi(szTmpClass);
									} else  ppDevReg[nRegFound]->SCSITargetID = 0;
									// Get SCSILUN
									dwType=REG_SZ;
									dwDLSize=32;
          							if( ERROR_SUCCESS == RegQueryValueEx(hKeySCSISub2, "SCSILUN", 0, &dwType,(LPBYTE)(&szTmpClass[0]), &dwDLSize) )
									{
										ppDevReg[nRegFound]->SCSILUN = atoi(szTmpClass);
									} else  ppDevReg[nRegFound]->SCSITargetID = 0;
									// Get DeviceDesc
									dwType=REG_SZ;
									dwDLSize=MAX_PATH;
          							if( ERROR_SUCCESS != RegQueryValueEx(hKeySCSISub2, "DeviceDesc", 0, &dwType,(LPBYTE)(&ppDevReg[nRegFound]->DeviceDesc[0]), &dwDLSize) )
									{
										ppDevReg[nRegFound]->DeviceDesc[0] = 0;
									}									
									nRegFound++;
								} // end of else
							} // end of If match
						} 
						if( hKeySCSISub2 ) { RegCloseKey(hKeySCSISub2); hKeySCSISub2=NULL; }
					} // End of OpenKey Sub2
					nKeySCSISub1++;
					dwKeyNameLen=MAX_PATH;
				} // End of While EnumKey under Sub1
                if( hKeySCSISub1 ) { RegCloseKey(hKeySCSISub1); hKeySCSISub1=NULL; }
			} // End of OpenKey Sub1
  			nKeySCSI++;
			dwKeyNameLen=MAX_PATH;
		} // End of While EnumKey under SCSI 
		if( hKeySCSI ) { RegCloseKey(hKeySCSI); hKeySCSI=NULL; }
	} // End of OpenKey SCSI
    

	nMatches=0;
	if( nRegFound > 0 )
	{	
		bRet=FALSE;

		BYTE nHA, nMaxHA=8;
		
        for(i=0; (i<nRegFound)&&(!bRet); i++)
		{
			CompactString(ppDevReg[i]->DeviceDesc, 0x20);
			   for(nHA=0; (nHA<nMaxHA)&&(!bRet); nHA++)
			   {
				  if( ASPI32_GetDeviceDesc(nHA, ppDevReg[i]->SCSITargetID, ppDevReg[i]->SCSILUN, pBuf) )
				  {
                     CompactString((char *)pBuf, 0x20);
					 if( !stricmp(ppDevReg[i]->DeviceDesc, (char *)pBuf) )
					 {                     
						// m_scsiAddress.PortNumber = nHA;
						pScsiAddr->PortNumber = nHA;
						pScsiAddr->TargetId = (UCHAR) ppDevReg[i]->SCSITargetID;
						pScsiAddr->Length = sizeof(SCSI_ADDRESS);
						pScsiAddr->PathId = 0;
						pScsiAddr->Lun = (UCHAR) ppDevReg[i]->SCSILUN;
						nMatches ++; // bRet=TRUE;
					}
				  }  
			   } // end of for nHA
			
		} // end of for nRegFound
	} else {
		bRet=FALSE;
	}

	if( nMatches == 1 ) 
		bRet=TRUE;
	else 
		bRet=FALSE;
Error:
	if( nRegFound )
	{
		for(i=0; i<nRegFound; i++)
		{
			delete ppDevReg[i];
		}
	}
	return bRet;
}

BOOL Aspi32Util::ASPI32_GetDeviceDesc(int nHaId, int tid, int LUN, LPBYTE pBuf)
{
    BOOL fResult=FALSE;
	static SRB_ExecSCSICmd ExecSRB;
	int nDeviceDescOffset=0x8, nDeviceDescLength;

	if ((m_hASPICompletionEvent = CreateEvent(NULL,FALSE,FALSE,NULL)) == NULL)
		return FALSE;
	
	ExecSRB.SRB_Cmd = SC_EXEC_SCSI_CMD;
	ExecSRB.SRB_HaId = (BYTE) nHaId;             //adapter id 0?
	ExecSRB.SRB_Flags = SRB_DIR_IN | SRB_DIR_SCSI;
	ExecSRB.SRB_Target = (BYTE) tid;             //target id 0?
	ExecSRB.SRB_BufPointer = m_pInquiryBuffer;
	ExecSRB.SRB_Lun = 0;
	ExecSRB.SRB_BufLen = 256;
	ExecSRB.SRB_SenseLen = SENSE_LEN;
	ExecSRB.SRB_CDBLen = 6;
	ExecSRB.CDBByte[0]= SCSI_INQUIRY; //12h
	ExecSRB.CDBByte[1]= 0;			//must set EVPB bit
	ExecSRB.CDBByte[2]= 0;
	ExecSRB.CDBByte[3]= 0;
	ExecSRB.CDBByte[4]= 0xFF;
	ExecSRB.CDBByte[5]= 0;
	ExecSRB.SRB_PostProc = m_hASPICompletionEvent;
	ExecSRB.SRB_Flags |= SRB_EVENT_NOTIFY;
	ExecSRB.SRB_Status = SS_PENDING;

	m_dwASPIStatus = m_funSendASPI32Command(&ExecSRB);

	// Block on event till signaled
	if ( ExecSRB.SRB_Status == SS_PENDING )
    {
	   m_dwASPIEventStatus = WaitForSingleObject(m_hASPICompletionEvent, 1000);
    }


	// Reset event to non-signaled state.
    ResetEvent(m_hASPICompletionEvent);

	if( ExecSRB.SRB_Status == SS_COMP )			
	{
        nDeviceDescLength=strlen((char *)(m_pInquiryBuffer+nDeviceDescOffset));
        CopyMemory(pBuf, m_pInquiryBuffer+nDeviceDescOffset, nDeviceDescLength+1) ;
		fResult=TRUE;
	}

	if( m_hASPICompletionEvent )  CloseHandle(m_hASPICompletionEvent);

	return fResult;
}

BOOL Aspi32Util::DoSCSIPassThrough(LPSTR szDriveLetter, PWMDMID pSN, BOOL bMedia )
{
    BOOL fRet = FALSE;

	if( !szDriveLetter || !pSN ) 
		return FALSE;

	if(!m_hd) return FALSE;


	if ( m_funGetASPI32SupportInfo && m_funSendASPI32Command )
	{	
		//must issue this command first
		m_dwASPIStatus = m_funGetASPI32SupportInfo();
 
		switch ( HIBYTE(LOWORD(m_dwASPIStatus)) )
		{
			case SS_COMP:
			/*
			 * ASPI for Win32 is properly initialized
			 */
			m_NumAdapters = LOBYTE(LOWORD(m_dwASPIStatus));
			break;
			default:
			  return FALSE;
		}
		
        if( GetScsiAddress(szDriveLetter, m_NumAdapters) )
		{
            if( bMedia )
            {
			    if ( GetMediaSerialNumber(m_scsiAddress.PortNumber, 
				                          m_scsiAddress.TargetId, pSN ) ) 
			    {
				    fRet = TRUE;
//				    memcpy(pSN->pID, &(m_pInquiryBuffer[4]), m_pInquiryBuffer[3]);
//				    pSN->SerialNumberLength = m_pInquiryBuffer[3];
				    pSN->dwVendorID = MDSP_PMID_SANDISK;
			    }
            }
            else
            {
			    if ( GetDeviceSerialNumber(m_scsiAddress.PortNumber, 
				                           m_scsiAddress.TargetId, pSN ) ) 
			    {
				    fRet = TRUE;
//				    memcpy(pSN->pID, &(m_pInquiryBuffer[4]), m_pInquiryBuffer[3]);
//				    pSN->SerialNumberLength = m_pInquiryBuffer[3];
				    pSN->dwVendorID = MDSP_PMID_SANDISK;
			    }
            }
		} 
	} 

	return fRet;	
}

// Try to get the serial numer on Win9x usign SCSI_PASS_THROUGH and the 
// old 'bad' device serial number command
BOOL Aspi32Util::GetDeviceSerialNumber(int nHaId, int tid, PWMDMID pSN )
{
    BOOL fResult=FALSE;
	static SRB_ExecSCSICmd ExecSRB;
    DWORD   dwMaxDataLen = WMDMID_LENGTH + 4;

	if ((m_hASPICompletionEvent = CreateEvent(NULL,FALSE,FALSE,NULL)) == NULL)
		return FALSE;
	
	ExecSRB.SRB_Cmd = SC_EXEC_SCSI_CMD;
	ExecSRB.SRB_HaId = (BYTE) nHaId;             //adapter id 0?
	ExecSRB.SRB_Flags = SRB_DIR_IN | SRB_DIR_SCSI;
	ExecSRB.SRB_Target = (BYTE) tid;             //target id 0?
	ExecSRB.SRB_BufPointer = m_pInquiryBuffer;
	ExecSRB.SRB_Lun = 0;
	ExecSRB.SRB_BufLen = dwMaxDataLen;
	ExecSRB.SRB_SenseLen = SENSE_LEN;
	ExecSRB.SRB_CDBLen = 6;
	ExecSRB.CDBByte[0]= SCSI_INQUIRY;   /* Command - SCSIOP_INQUIRY */;
	ExecSRB.CDBByte[1]= 0x01;			/* Request - VitalProductData */
	ExecSRB.CDBByte[2]= 0x80;           /* VPD page 80 - serial number page */;
	ExecSRB.CDBByte[3]= 0x00;
	ExecSRB.CDBByte[4]= 0xff;           /*255*/
	ExecSRB.CDBByte[5]= 0x00;
	ExecSRB.SRB_PostProc = m_hASPICompletionEvent;
	ExecSRB.SRB_Flags |= SRB_EVENT_NOTIFY;
	ExecSRB.SRB_Status = SS_PENDING;

	m_dwASPIStatus = m_funSendASPI32Command(&ExecSRB);

	
	// Block on event till signaled                   */ 
	if ( ExecSRB.SRB_Status == SS_PENDING )
    {
	   m_dwASPIEventStatus = WaitForSingleObject(m_hASPICompletionEvent, 1000);
    }
    ResetEvent(m_hASPICompletionEvent);

    // Got the S/N number, copy if to out parameter
	if( ExecSRB.SRB_Status == SS_COMP && 
        m_pInquiryBuffer[3] > 0 && 
        m_pInquiryBuffer[3] < dwMaxDataLen ) 
	{
        pSN->SerialNumberLength = m_pInquiryBuffer[3];
        memcpy( pSN->pID, &m_pInquiryBuffer[4], pSN->SerialNumberLength );
		fResult=TRUE;
	}

	if( m_hASPICompletionEvent )  CloseHandle(m_hASPICompletionEvent);

	return fResult;
}
	


#define ASPI_OFFSETOF(t,f)   ((DWORD)(DWORD_PTR)(&((t*)0)->f))

// Try to get the serial numer on Win9x usign SCSI_PASS_THROUGH and the 
// 'new' media serial number command
BOOL Aspi32Util::GetMediaSerialNumber(int nHaId, int tid, PWMDMID pSN )
{
    BOOL    fResult=FALSE;
	SRB_ExecSCSICmd ExecSRB;
    BYTE    pSerialNumberSize[4];
    DWORD   dwSerialNumberSize;
    BYTE*   pSerialNumberBuffer = NULL;
    ULONG   cbBufferLength;
    DWORD   dwMaxDataLen = WMDMID_LENGTH + 4;

	if ((m_hASPICompletionEvent = CreateEvent(NULL,FALSE,FALSE,NULL)) == NULL)
        return FALSE;
	
    cbBufferLength = ASPI_OFFSETOF(GET_MEDIA_SERIAL_NUMBER_RESPONSE_DATA, Data);

    // Set up command to get the size of the serial number
	ZeroMemory(&ExecSRB, sizeof(SRB_ExecSCSICmd));
	ExecSRB.SRB_Cmd     = SC_EXEC_SCSI_CMD;
	ExecSRB.SRB_HaId    = (BYTE) nHaId;             //adapter id 0?
	ExecSRB.SRB_Flags   = SRB_DIR_IN | SRB_DIR_SCSI;
	ExecSRB.SRB_Target  = (BYTE) tid;             //target id 0?
	ExecSRB.SRB_BufPointer = pSerialNumberSize;
	ExecSRB.SRB_Lun     = 0;
	ExecSRB.SRB_BufLen  = 4;
	ExecSRB.SRB_SenseLen= SENSE_LEN;
	ExecSRB.SRB_CDBLen  = 12;
	ExecSRB.CDBByte[0]  = 0xa4; // command
	ExecSRB.CDBByte[7]  = 0x10; // key class
    ExecSRB.CDBByte[8]  = (UCHAR)(cbBufferLength >> 8);   // high bits alloc length
	ExecSRB.CDBByte[9]  = (UCHAR)(cbBufferLength & 0xff); // low bits alloc length

	ExecSRB.SRB_PostProc = m_hASPICompletionEvent;
	ExecSRB.SRB_Flags   |= SRB_EVENT_NOTIFY;
	ExecSRB.SRB_Status  = SS_PENDING;

	// ** Block on event till signaled
	m_dwASPIStatus = m_funSendASPI32Command(&ExecSRB);

	if ( ExecSRB.SRB_Status == SS_PENDING )
    {
	   m_dwASPIEventStatus = WaitForSingleObject(m_hASPICompletionEvent, 10000);
    }
    ResetEvent(m_hASPICompletionEvent);

    // Allocate buffer to get serial number
    dwSerialNumberSize = (pSerialNumberSize[0] * 256) + pSerialNumberSize[1];

    // Serial number to big for our out structure
    if( dwSerialNumberSize > WMDMID_LENGTH )
    {
        goto Error;
    }

    pSerialNumberBuffer = new BYTE[dwSerialNumberSize + 4];
    if( pSerialNumberBuffer == NULL ) goto Error;

    // Set up command to get the serial number
    // Set up command to get the size of the serial number
	ZeroMemory(&ExecSRB, sizeof(SRB_ExecSCSICmd));
	ExecSRB.SRB_Cmd     = SC_EXEC_SCSI_CMD;
	ExecSRB.SRB_HaId    = (BYTE) nHaId;             //adapter id 0?
	ExecSRB.SRB_Flags   = SRB_DIR_IN | SRB_DIR_SCSI;
	ExecSRB.SRB_Target  = (BYTE) tid;             //target id 0?
    ExecSRB.SRB_BufPointer = pSerialNumberBuffer;
    ExecSRB.SRB_BufLen  = dwSerialNumberSize + 4;
	ExecSRB.SRB_Lun     = 0;
	ExecSRB.SRB_SenseLen= SENSE_LEN;
	ExecSRB.SRB_CDBLen  = 12;
	ExecSRB.CDBByte[0]  = 0xa4; // command
	ExecSRB.CDBByte[7]  = 0x10; // key class
    ExecSRB.CDBByte[8]  = (UCHAR)(cbBufferLength >> 8);   // high bits alloc length
	ExecSRB.CDBByte[9]  = (UCHAR)(cbBufferLength & 0xff); // low bits alloc length

	ExecSRB.SRB_PostProc = m_hASPICompletionEvent;
	ExecSRB.SRB_Flags   |= SRB_EVENT_NOTIFY;
	ExecSRB.SRB_Status  = SS_PENDING;


	// ** Block on event till signaled
	m_dwASPIStatus = m_funSendASPI32Command(&ExecSRB);

	if ( ExecSRB.SRB_Status == SS_PENDING )
    {
	   m_dwASPIEventStatus = WaitForSingleObject(m_hASPICompletionEvent, 10000);
    }
    ResetEvent(m_hASPICompletionEvent);

    // Got the S/N number, copy if to out parameter
	if( ExecSRB.SRB_Status == SS_COMP ) 
	{
        pSN->SerialNumberLength = (pSerialNumberBuffer[0] * 256) + pSerialNumberBuffer[1];
        memcpy( pSN->pID, &pSerialNumberBuffer[4], pSN->SerialNumberLength );
		fResult=TRUE;
	}

Error:
	if( m_hASPICompletionEvent )  CloseHandle(m_hASPICompletionEvent);
    if( pSerialNumberBuffer ) delete [] pSerialNumberBuffer;

	return fResult;
}
	

BOOL Aspi32Util::ASPI32_GetDiskInfo(int nHaId, int tid, int *pnInt13Unit)
{
    // Reminder: this only works on Win9x
    SRB_GetDiskInfo *MySRB = NULL;
    BOOL bRet=FALSE;

    MySRB = (SRB_GetDiskInfo *) new BYTE[128];
    if (!MySRB) return FALSE;

    MySRB->SRB_Cmd = SC_GET_DISK_INFO;
    MySRB->SRB_HaId    = (BYTE) nHaId;
    MySRB->SRB_Flags    = 0;
    MySRB->SRB_Hdr_Rsvd   = 0;
    MySRB->SRB_Target    = (BYTE) tid;
    MySRB->SRB_Lun    = 0;

    m_dwASPIStatus = m_funSendASPI32Command( (LPSRB)MySRB );

    Sleep(32);

    if( m_dwASPIStatus == SS_COMP )
    {
        *pnInt13Unit = (int)(MySRB->SRB_Int13HDriveInfo);
        bRet=TRUE;
    } 

    delete [] MySRB;
    return bRet;
}


BOOL Aspi32Util::ASPI32_GetDevType(int nHaId, int tid, int *pnDevType)
{
    SRB_GDEVBlock MySRB;

    MySRB.SRB_Cmd    = SC_GET_DEV_TYPE;
    MySRB.SRB_HaId   = (BYTE) nHaId;
    MySRB.SRB_Flags   = 0;
    MySRB.SRB_Hdr_Rsvd  = 0;
    MySRB.SRB_Target   = (BYTE) tid;
    MySRB.SRB_Lun   = 0;

    m_dwASPIStatus  = m_funSendASPI32Command ( (LPSRB) &MySRB );

    Sleep(32);

    if( m_dwASPIStatus == SS_COMP )
    {
        *pnDevType = (int)(MySRB.SRB_DeviceType);
        return TRUE;
    } 
    else  return FALSE;
}

BOOL Aspi32Util::ASPI32_GetHostAdapter(int nHaId, LPSTR szIdentifier)
{
    BYTE szTmp[32];

    SRB_HAInquiry MySRB;
    BOOL fRet = FALSE;
    MySRB.SRB_Cmd     = SC_HA_INQUIRY;
    MySRB.SRB_HaId    = (BYTE) nHaId;
    MySRB.SRB_Flags    = 0;
    MySRB.SRB_Hdr_Rsvd   = 0;
    m_dwASPIStatus = m_funSendASPI32Command ( (LPSRB) &MySRB );

    Sleep(32);

    if( MySRB.SRB_Status == SS_COMP )
    {
        memcpy(szTmp, MySRB.HA_Identifier, sizeof(MySRB.HA_Identifier) );
        szTmp[7] = 0;
        if( szIdentifier ) strcpy(szIdentifier, (char *)szTmp);

        LCID lcid = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
                                        SORT_DEFAULT);

        // if( !lstrcmpiA((LPCSTR)szTmp, "EPCFWNT") ||
	//         !lstrcmpiA((LPCSTR)szTmp, "EPCFW9x") ||
	//         !lstrcmpiA((LPCSTR)szTmp, "EPATHD")  ||
	//         !lstrcmpiA((LPCSTR)szTmp, "imgmate") )
        if (CompareStringA(lcid, NORM_IGNORECASE, (LPCSTR)szTmp, -1, "EPCFWNT", -1) == CSTR_EQUAL ||
            CompareStringA(lcid, NORM_IGNORECASE, (LPCSTR)szTmp, -1, "EPCFW9x", -1) == CSTR_EQUAL ||
            CompareStringA(lcid, NORM_IGNORECASE, (LPCSTR)szTmp, -1, "EPATHD", -1) == CSTR_EQUAL ||
            CompareStringA(lcid, NORM_IGNORECASE, (LPCSTR)szTmp, -1, "imgmate", -1) == CSTR_EQUAL)
        {
	        fRet = TRUE;
        }
    } 

    return fRet;
}



BOOL Aspi32Util::GetScsiAddress(LPSTR szDL, int nMaxHA)
{
	BOOL bRet=FALSE;

	if( IsWinNT() )
	{
		char szName[256];
	    HANDLE hDriver;
		DWORD returned;


		wsprintf(szName,"\\\\.\\%c:", szDL[0]);

		hDriver = CreateFile(szName,
							 GENERIC_READ, 
							 FILE_SHARE_READ | FILE_SHARE_WRITE,
							 0, 					// Default security
							 OPEN_EXISTING,
							 0,  
							 0);					// No template
	
		// If the open failed, print out the error code
		if(hDriver == INVALID_HANDLE_VALUE) 
		{
			return FALSE;
		}

		bRet = DeviceIoControl(hDriver,
                         IOCTL_SCSI_GET_ADDRESS,
                         NULL,
                         0,
                         &m_scsiAddress,
                         sizeof(SCSI_ADDRESS),
                         &returned,
                         FALSE);
	
		CloseHandle(hDriver);
	} // end of if IsWinNT()
    else 
	{
		HANDLE h;
        int iDrive;
		DWORD           cb;
		DIOC_REGISTERS  reg;
		DRIVE_MAP_INFO  dmi;

		h = CreateFileA("\\\\.\\VWIN32", 0, 0, 0, 0,
				FILE_FLAG_DELETE_ON_CLOSE, 0);

		if (h != INVALID_HANDLE_VALUE)
		{

			iDrive = *CharUpper(szDL)-'A'+1;
            dmi.AllocationLength = sizeof(DRIVE_MAP_INFO);
			dmi.InfoLength = sizeof(DRIVE_MAP_INFO);

            reg.reg_EBX   = iDrive;       // BL = drive number (1-based)

            //
            // ISSUE: The following code will not work on 64-bit systems.
            //        The conditional is only to get the code to compiler.
            //

#if defined(_WIN64)
            reg.reg_EDX   = (DWORD)(DWORD_PTR)&dmi;  // DS:EDX -> DPB
#else
            reg.reg_EDX   = (DWORD)&dmi;  // DS:EDX -> DPB
#endif
            reg.reg_ECX   = 0x086F;       // CX = Get DPB
            reg.reg_EAX   = 0x440D;       // AX = Ioctl
			reg.reg_Flags = CARRY_FLAG;   // assume failure

			// Make sure both DeviceIoControl and Int 21h succeeded.
			if (DeviceIoControl (h, VWIN32_DIOC_DOS_IOCTL, &reg,
                              sizeof(reg), &reg, sizeof(reg),
                              &cb, 0)
				&& !(reg.reg_Flags & CARRY_FLAG))
			{
				bRet = TRUE;
			}
			CloseHandle(h);
		}

		if( bRet ) // Search for marching nHA & tid
		{
			bRet=FALSE;
		
			if( dmi.Int13Unit != 0xFF )
			{
				int nHA, tid, nInt13Unit;
				for(nHA=0; (nHA<nMaxHA)&&(!bRet); nHA++)
				{
					for(tid=0; (tid<15)&&(!bRet); tid++)
					{
						if( ASPI32_GetDiskInfo(nHA, tid, &nInt13Unit) )
						{
							if( nInt13Unit == dmi.Int13Unit )
							{
								m_scsiAddress.PortNumber = (BYTE) nHA;
								m_scsiAddress.TargetId = (BYTE) tid;
								m_scsiAddress.Length = sizeof(SCSI_ADDRESS);
								m_scsiAddress.PathId = 0;
								m_scsiAddress.Lun = 0;
								bRet=TRUE;
							}
						}
					} // end of for tid
				} // end of for nHA
			} else {
				bRet=ASPI32_GetScsiDiskForParallelReader(szDL, &m_scsiAddress);
				Sleep(32);
			}
		} 
	}
	return bRet;
}



BOOL Aspi32Util::GetDeviceManufacturer(LPSTR szDriveLetter, LPSTR pszBuf)
{
    BOOL fRet = FALSE;

	if( !szDriveLetter || !pszBuf ) 
		return FALSE;

	if(!m_hd) return FALSE;


	if ( m_funGetASPI32SupportInfo && m_funSendASPI32Command )
	{	
		//must issue this command first
		m_dwASPIStatus = m_funGetASPI32SupportInfo();
 
		switch ( HIBYTE(LOWORD(m_dwASPIStatus)) )
		{
			case SS_COMP:
			/*
			 * ASPI for Win32 is properly initialized
			 */
			m_NumAdapters = LOBYTE(LOWORD(m_dwASPIStatus));
			break;
			default:
			  return FALSE;
		}
		

        if( GetScsiAddress(szDriveLetter, m_NumAdapters) )
		{
			if ( ASPI32_GetHostAdapter(m_scsiAddress.PortNumber, pszBuf) ) 
			{
				fRet = TRUE;
			}
		} 
	} 

	return fRet;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\common\serialnumber\scsidefs.h ===
#ifndef __SCSIDEFS_H__
#define __SCSIDEFS_H__

/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

//***************************************************************************
//
// Name: 			SCSIDEFS.H
//
// Description:	SCSI definitions ('C' Language)
//
//***************************************************************************

//***************************************************************************
//							%%% TARGET STATUS VALUES %%%
//***************************************************************************
#define STATUS_GOOD		0x00		// Status Good
#define STATUS_CHKCOND	0x02		// Check Condition
#define STATUS_CONDMET	0x04		// Condition Met
#define STATUS_BUSY		0x08		// Busy
#define STATUS_INTERM	0x10		// Intermediate
#define STATUS_INTCDMET	0x14		// Intermediate-condition met
#define STATUS_RESCONF	0x18		// Reservation conflict
#define STATUS_COMTERM	0x22		// Command Terminated
#define STATUS_QFULL		0x28		// Queue full

//***************************************************************************
//						%%% SCSI MISCELLANEOUS EQUATES %%%
//***************************************************************************
#define MAXLUN				7			// Maximum Logical Unit Id
#define MAXTARG			7			// Maximum Target Id
#define MAX_SCSI_LUNS	64			// Maximum Number of SCSI LUNs
#define MAX_NUM_HA		8			// Maximum Number of SCSI HA's

//---------------------------------------------------------------------------
//
//							%%% SCSI COMMAND OPCODES %%%
//
//---------------------------------------------------------------------------

//***************************************************************************
//				 %%% Commands for all Device Types %%%
//***************************************************************************
#define SCSI_CHANGE_DEF	0x40		// Change Definition (Optional)
#define SCSI_COMPARE		0x39		// Compare (O)
#define SCSI_COPY			0x18		// Copy (O)
#define SCSI_COP_VERIFY	0x3A		// Copy and Verify (O)
#define SCSI_INQUIRY		0x12		// Inquiry (MANDATORY)
#define SCSI_LOG_SELECT	0x4C		// Log Select (O)
#define SCSI_LOG_SENSE	0x4D		// Log Sense (O)
#define SCSI_MODE_SEL6	0x15		// Mode Select 6-byte (Device Specific)
#define SCSI_MODE_SEL10	0x55		// Mode Select 10-byte (Device Specific)
#define SCSI_MODE_SEN6	0x1A		// Mode Sense 6-byte (Device Specific)
#define SCSI_MODE_SEN10	0x5A		// Mode Sense 10-byte (Device Specific)
#define SCSI_READ_BUFF	0x3C		// Read Buffer (O)
#define SCSI_REQ_SENSE	0x03		// Request Sense (MANDATORY)
#define SCSI_SEND_DIAG	0x1D		// Send Diagnostic (O)
#define SCSI_TST_U_RDY	0x00		// Test Unit Ready (MANDATORY)
#define SCSI_WRITE_BUFF	0x3B		// Write Buffer (O)

//***************************************************************************
//			  %%% Commands Unique to Direct Access Devices %%%
//***************************************************************************
#define SCSI_COMPARE		0x39		// Compare (O)
#define SCSI_FORMAT		0x04		// Format Unit (MANDATORY)
#define SCSI_LCK_UN_CAC	0x36		// Lock Unlock Cache (O)
#define SCSI_PREFETCH	0x34		// Prefetch (O)
#define SCSI_MED_REMOVL	0x1E		// Prevent/Allow medium Removal (O)
#define SCSI_READ6		0x08		// Read 6-byte (MANDATORY)
#define SCSI_READ10		0x28		// Read 10-byte (MANDATORY)
#define SCSI_RD_CAPAC	0x25		// Read Capacity (MANDATORY)
#define SCSI_RD_DEFECT	0x37		// Read Defect Data (O)
#define SCSI_READ_LONG	0x3E		// Read Long (O)
#define SCSI_REASS_BLK	0x07		// Reassign Blocks (O)
#define SCSI_RCV_DIAG	0x1C		// Receive Diagnostic Results (O)
#define SCSI_RELEASE	0x17		// Release Unit (MANDATORY)
#define SCSI_REZERO		0x01		// Rezero Unit (O)
#define SCSI_SRCH_DAT_E	0x31		// Search Data Equal (O)
#define SCSI_SRCH_DAT_H	0x30		// Search Data High (O)
#define SCSI_SRCH_DAT_L	0x32		// Search Data Low (O)
#define SCSI_SEEK6		0x0B		// Seek 6-Byte (O)
#define SCSI_SEEK10		0x2B		// Seek 10-Byte (O)
#define SCSI_SEND_DIAG	0x1D		// Send Diagnostics (MANDATORY)
#define SCSI_SET_LIMIT	0x33		// Set Limits (O)
#define SCSI_START_STP	0x1B		// Start/Stop Unit (O)
#define SCSI_SYNC_CACHE	0x35		// Synchronize Cache (O)
#define SCSI_VERIFY		0x2F		// Verify (O)
#define SCSI_WRITE6		0x0A		// Write 6-Byte (MANDATORY)
#define SCSI_WRITE10	0x2A		// Write 10-Byte (MANDATORY)
#define SCSI_WRT_VERIFY	0x2E		// Write and Verify (O)
#define SCSI_WRITE_LONG	0x3F		// Write Long (O)
#define SCSI_WRITE_SAME	0x41		// Write Same (O)

//***************************************************************************
//			%%% Commands Unique to Sequential Access Devices %%%
//***************************************************************************
#define SCSI_ERASE		0x19		// Erase (MANDATORY)
#define SCSI_LOAD_UN	0x1b		// Load/Unload (O)
#define SCSI_LOCATE		0x2B		// Locate (O)
#define SCSI_RD_BLK_LIM	0x05		// Read Block Limits (MANDATORY)
#define SCSI_READ_POS	0x34		// Read Position (O)
#define SCSI_READ_REV	0x0F		// Read Reverse (O)
#define SCSI_REC_BF_DAT	0x14		// Recover Buffer Data (O)
#define SCSI_RESERVE	0x16		// Reserve Unit (MANDATORY)
#define SCSI_REWIND		0x01		// Rewind (MANDATORY)
#define SCSI_SPACE		0x11		// Space (MANDATORY)
#define SCSI_VERIFY_T	0x13		// Verify (Tape) (O)
#define SCSI_WRT_FILE	0x10		// Write Filemarks (MANDATORY)

//***************************************************************************
//				  %%% Commands Unique to Printer Devices %%%
//***************************************************************************
#define SCSI_PRINT		0x0A		// Print (MANDATORY)
#define SCSI_SLEW_PNT	0x0B		// Slew and Print (O)
#define SCSI_STOP_PNT	0x1B		// Stop Print (O)
#define SCSI_SYNC_BUFF	0x10		// Synchronize Buffer (O)

//***************************************************************************
//				 %%% Commands Unique to Processor Devices %%%
//***************************************************************************
#define SCSI_RECEIVE	0x08		// Receive (O)
#define SCSI_SEND		0x0A		// Send (O)

//***************************************************************************
//				%%% Commands Unique to Write-Once Devices %%%
//***************************************************************************
#define SCSI_MEDIUM_SCN	0x38	// Medium Scan (O)
#define SCSI_SRCHDATE10	0x31	// Search Data Equal 10-Byte (O)
#define SCSI_SRCHDATE12	0xB1	// Search Data Equal 12-Byte (O)
#define SCSI_SRCHDATH10	0x30	// Search Data High 10-Byte (O)
#define SCSI_SRCHDATH12	0xB0	// Search Data High 12-Byte (O)
#define SCSI_SRCHDATL10	0x32	// Search Data Low 10-Byte (O)
#define SCSI_SRCHDATL12	0xB2	// Search Data Low 12-Byte (O)
#define SCSI_SET_LIM_10	0x33	// Set Limits 10-Byte (O)
#define SCSI_SET_LIM_12	0xB3	// Set Limits 10-Byte (O)
#define SCSI_VERIFY10	0x2F	// Verify 10-Byte (O)
#define SCSI_VERIFY12	0xAF	// Verify 12-Byte (O)
#define SCSI_WRITE12	0xAA	// Write 12-Byte (O)
#define SCSI_WRT_VER10	0x2E	// Write and Verify 10-Byte (O)
#define SCSI_WRT_VER12	0xAE	// Write and Verify 12-Byte (O)

//***************************************************************************
//				  %%% Commands Unique to CD-ROM Devices %%%
//***************************************************************************
#define SCSI_PLAYAUD_10	0x45	// Play Audio 10-Byte (O)
#define SCSI_PLAYAUD_12	0xA5	// Play Audio 12-Byte 12-Byte (O)
#define SCSI_PLAYAUDMSF	0x47	// Play Audio MSF (O)
#define SCSI_PLAYA_TKIN	0x48	// Play Audio Track/Index (O)
#define SCSI_PLYTKREL10	0x49	// Play Track Relative 10-Byte (O)
#define SCSI_PLYTKREL12	0xA9	// Play Track Relative 12-Byte (O)
#define SCSI_READCDCAP	0x25	// Read CD-ROM Capacity (MANDATORY)
#define SCSI_READHEADER	0x44	// Read Header (O)
#define SCSI_SUBCHANNEL	0x42	// Read Subchannel (O)
#define SCSI_READ_TOC	0x43	// Read TOC (O)

//***************************************************************************
//				  %%% Commands Unique to Scanner Devices %%%
//***************************************************************************
#define SCSI_GETDBSTAT	0x34	// Get Data Buffer Status (O)
#define SCSI_GETWINDOW	0x25	// Get Window (O)
#define SCSI_OBJECTPOS	0x31	// Object Postion (O)
#define SCSI_SCAN		0x1B	// Scan (O)
#define SCSI_SETWINDOW	0x24	// Set Window (MANDATORY)

//***************************************************************************
//			 %%% Commands Unique to Optical Memory Devices %%%
//***************************************************************************
#define SCSI_UpdateBlk	0x3D	// Update Block (O)

//***************************************************************************
//			 %%% Commands Unique to Medium Changer Devices %%%
//***************************************************************************
#define SCSI_EXCHMEDIUM	0xA6	// Exchange Medium (O)
#define SCSI_INITELSTAT	0x07	// Initialize Element Status (O)
#define SCSI_POSTOELEM	0x2B	// Position to Element (O)
#define SCSI_REQ_VE_ADD	0xB5	// Request Volume Element Address (O)
#define SCSI_SENDVOLTAG	0xB6	// Send Volume Tag (O)

//***************************************************************************
//			  %%% Commands Unique to Communication Devices %%%
//***************************************************************************
#define SCSI_GET_MSG_6	0x08	// Get Message 6-Byte (MANDATORY)
#define SCSI_GET_MSG_10	0x28	// Get Message 10-Byte (O)
#define SCSI_GET_MSG_12	0xA8	// Get Message 12-Byte (O)
#define SCSI_SND_MSG_6	0x0A	// Send Message 6-Byte (MANDATORY)
#define SCSI_SND_MSG_10	0x2A	// Send Message 10-Byte (O)
#define SCSI_SND_MSG_12	0xAA	// Send Message 12-Byte (O)

//---------------------------------------------------------------------------
//
//					  %%% END OF SCSI COMMAND OPCODES %%%
//
//---------------------------------------------------------------------------

//***************************************************************************
//						%%% Request Sense Data Format %%%
//***************************************************************************
typedef struct {

	BYTE	ErrorCode;				// Error Code (70H or 71H)
	BYTE	SegmentNum;				// Number of current segment descriptor
	BYTE	SenseKey;				// Sense Key(See bit definitions too)
	BYTE	InfoByte0;				// Information MSB
	BYTE	InfoByte1;				// Information MID
	BYTE	InfoByte2;				// Information MID
	BYTE	InfoByte3;				// Information LSB
	BYTE	AddSenLen;				// Additional Sense Length
	BYTE	ComSpecInf0;			// Command Specific Information MSB
	BYTE	ComSpecInf1;			// Command Specific Information MID
	BYTE	ComSpecInf2;			// Command Specific Information MID
	BYTE	ComSpecInf3;			// Command Specific Information LSB
	BYTE	AddSenseCode;			// Additional Sense Code
	BYTE	AddSenQual;				// Additional Sense Code Qualifier
	BYTE	FieldRepUCode;			// Field Replaceable Unit Code
	BYTE	SenKeySpec15;			// Sense Key Specific 15th byte
	BYTE	SenKeySpec16;			// Sense Key Specific 16th byte
	BYTE	SenKeySpec17;			// Sense Key Specific 17th byte
	BYTE	AddSenseBytes;			// Additional Sense Bytes

} SENSE_DATA_FMT;

//***************************************************************************
//						 %%% REQUEST SENSE ERROR CODE %%%
//***************************************************************************
#define SERROR_CURRENT	0x70	// Current Errors
#define SERROR_DEFERED	0x71	// Deferred Errors

//***************************************************************************
//					 %%% REQUEST SENSE BIT DEFINITIONS %%%
//***************************************************************************
#define SENSE_VALID		0x80	// Byte 0 Bit 7
#define SENSE_FILEMRK	0x80	// Byte 2 Bit 7
#define SENSE_EOM		0x40	// Byte 2 Bit 6
#define SENSE_ILI		0x20	// Byte 2 Bit 5

//***************************************************************************
//				 %%% REQUEST SENSE SENSE KEY DEFINITIONS %%%
//***************************************************************************
#define KEY_NOSENSE		0x00	// No Sense
#define KEY_RECERROR	0x01	// Recovered Error
#define KEY_NOTREADY	0x02	// Not Ready
#define KEY_MEDIUMERR	0x03	// Medium Error
#define KEY_HARDERROR	0x04	// Hardware Error
#define KEY_ILLGLREQ	0x05	// Illegal Request
#define KEY_UNITATT		0x06	// Unit Attention
#define KEY_DATAPROT	0x07	// Data Protect
#define KEY_BLANKCHK	0x08	// Blank Check
#define KEY_VENDSPEC	0x09	// Vendor Specific
#define KEY_COPYABORT	0x0A	// Copy Abort
#define KEY_EQUAL		0x0C	// Equal (Search)
#define KEY_VOLOVRFLW	0x0D	// Volume Overflow
#define KEY_MISCOMP		0x0E	// Miscompare (Search)
#define KEY_RESERVED	0x0F	// Reserved

//***************************************************************************
//				  %%% PERIPHERAL DEVICE TYPE DEFINITIONS %%%
//***************************************************************************
#define DTYPE_DASD		0x00	// Disk Device
#define DTYPE_SEQD		0x01	// Tape Device
#define DTYPE_PRNT		0x02	// Printer
#define DTYPE_PROC		0x03	// Processor
#define DTYPE_WORM		0x04	// Write-once read-multiple
#define DTYPE_CROM		0x05	// CD-ROM device
#define DTYPE_SCAN		0x06	// Scanner device
#define DTYPE_OPTI		0x07	// Optical memory device
#define DTYPE_JUKE		0x08	// Medium Changer device
#define DTYPE_COMM		0x09	// Communications device
#define DTYPE_RESL		0x0A	// Reserved (low)
#define DTYPE_RESH		0x1E	// Reserved (high)
#define DTYPE_UNKNOWN	0x1F	// Unknown or no device type

//***************************************************************************
//				  %%% ANSI APPROVED VERSION DEFINITIONS %%%
//***************************************************************************
#define ANSI_MAYBE		0x0	// Device may or may not be ANSI approved stand
#define ANSI_SCSI1		0x1	// Device complies to ANSI X3.131-1986 (SCSI-1)
#define ANSI_SCSI2		0x2	// Device complies to SCSI-2
#define ANSI_RESLO		0x3	// Reserved (low)
#define ANSI_RESHI		0x7	// Reserved (high)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\common\serialnumber\aspi32.h ===
//-----------------------------------------------------------------------------
//
// File:   aspi32.h
//
// Microsoft Digital Rights Management
// Copyright (C) Microsoft Corporation, 1998 - 1999, All Rights Reserved
//
// Description: interface for the Aspi32Util class
//
//-----------------------------------------------------------------------------

// #include "stdafx.h"
#include "windows.h"
#include "scsidefs.h"
#include "wnaspi32.h"
#include "ntddscsi.h"
#include "serialid.h"

#if !defined(AFX_ASPI32UTIL_H__AEAF6F94_44A2_11D3_BE1D_00C04F79EC6B__INCLUDED_)
#define AFX_ASPI32UTIL_H__AEAF6F94_44A2_11D3_BE1D_00C04F79EC6B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

typedef DWORD (__cdecl *P_SAC)(LPSRB);
typedef DWORD (__cdecl *P_GASI)(VOID);

class Aspi32Util  
{
public:
	Aspi32Util();
	virtual ~Aspi32Util();

    BOOL ASPI32_GetScsiDiskForParallelReader(char *szDL, SCSI_ADDRESS *pScsiAddr);
	BOOL ASPI32_GetDeviceDesc(int nHaId, int tid, int LUN, LPBYTE pBuf);
	BOOL GetDeviceManufacturer(LPSTR szDriveLetter, LPSTR pBuf);
	BOOL GetScsiAddress(LPSTR szDL, int nMaxHA);

	BOOL ASPI32_GetHostAdapter(int nHaId, LPSTR szIdentifier);
	BOOL ASPI32_GetDevType(int nHaId, int tid, int *pnDevType);
	BOOL ASPI32_GetDiskInfo(int nHaId, int tid, int *pnInt13Unit);
    BOOL DoSCSIPassThrough(LPSTR szDriveLetter, PWMDMID pSN, BOOL bMedia );
    BOOL GetDeviceSerialNumber(int nHaId, int tid, PWMDMID pSN );
    BOOL GetMediaSerialNumber(int nHaId, int tid, PWMDMID pSN );

// Attributes
	DWORD           m_dwASPIStatus;
	DWORD           m_dwASPIEventStatus;
	HANDLE          m_hASPICompletionEvent;
	unsigned char   m_pInquiryBuffer[256];
	BYTE            m_NumAdapters;
    SCSI_ADDRESS    m_scsiAddress;
	P_SAC           m_funSendASPI32Command;
    P_GASI          m_funGetASPI32SupportInfo;
	HINSTANCE       m_hd;
};

#endif // !defined(AFX_ASPI32UTIL_H__AEAF6F94_44A2_11D3_BE1D_00C04F79EC6B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\common\serialnumber\serialid.cpp ===
//-----------------------------------------------------------------------------
//
// File:   serialid.cpp
//
// Microsoft Digital Rights Management
// Copyright (C) Microsoft Corporation, 1998 - 1999, All Rights Reserved
//
// Description:
//
//-----------------------------------------------------------------------------
#include <windows.h>
#include <stddef.h>

#include "drmerr.h"
#include "aspi32.h"
#include "serialid.h"
#include "spti.h"
//#include "KBDevice.h"
#include <crtdbg.h>

HRESULT __stdcall UtilStartStopService(bool fStartService);


// #define WRITE_TO_LOG_FILE

#if defined(DBG) || defined(WRITE_TO_LOG_FILE)
#include <stdio.h>
#endif

void DebugMsg(const char* pszFormat, ...)
{
#if defined(DBG) || defined(WRITE_TO_LOG_FILE)
    char buf[1024];
    sprintf(buf, "[Serial Number Library](%lu): ", GetCurrentThreadId());
        va_list arglist;
        va_start(arglist, pszFormat);
    vsprintf(&buf[strlen(buf)], pszFormat, arglist);
        va_end(arglist);
    strcat(buf, "\n");

#if defined(DBG)
    OutputDebugString(buf);
#endif

#if defined(WRITE_TO_LOG_FILE)
    FILE* fp = fopen("c:\\WmdmService.txt", "a");
    if (fp)
    {
        fprintf(fp, buf);
        fclose(fp);
    }
#endif

#endif
}

#ifdef USE_IOREADY
    #ifndef __Using_iomegaReady_Lib__
        #define __Using_iomegaReady_Lib__
    #endif
    #include "ioReadyMin.h"
#endif

#define WCS_PMID_SOFT L"media.id"


BOOL IsWinNT()
{
    OSVERSIONINFO osvi;
    BOOL bRet=FALSE;

    ZeroMemory(&osvi, sizeof(OSVERSIONINFO));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if ( ! GetVersionEx ( (OSVERSIONINFO *) &osvi) )
        return FALSE;

    switch ( osvi.dwPlatformId )
    {
    case VER_PLATFORM_WIN32_NT:
        bRet=TRUE;
        break;

    case VER_PLATFORM_WIN32_WINDOWS:
        bRet=FALSE;
        break;

    case VER_PLATFORM_WIN32s:
        bRet=FALSE;
        break;
    }

    return bRet; 
}

BOOL IsAdministrator(DWORD& dwLastError)
{
    dwLastError = ERROR_SUCCESS;
    if ( IsWinNT() )
    {
/*		typedef SC_HANDLE (*T_POSCM)(LPCTSTR,LPCTSTR,DWORD);

        T_POSCM p_OpenSCM=NULL;

        p_OpenSCM = (T_POSCM)GetProcAddress(GetModuleHandle("advapi32.dll"), "OpenSCManagerA");
        
        if( !p_OpenSCM )
        {
            return FALSE;
        }
*/
        SC_HANDLE hSCM = OpenSCManagerA(NULL, // local machine
                                        NULL, // ServicesActive database
                                        SC_MANAGER_ALL_ACCESS); // full access
        if ( !hSCM )
        {
            dwLastError = GetLastError();
            if (dwLastError == ERROR_ACCESS_DENIED)
            {
                dwLastError = ERROR_SUCCESS;
            }
            return FALSE;
        }
        else
        {
            CloseServiceHandle(hSCM);
            return TRUE;
        }
    }
    else // On Win9x, everybody is admin
    {
        return TRUE;
    }
}

UINT __stdcall UtilGetDriveType(LPSTR szDL)
{
    return GetDriveTypeA(szDL);
}

BOOL IsIomegaDrive(DWORD dwDriveNum)
{
    BOOL bRet=FALSE;

#ifdef USE_IOREADY
    if (dwDriveNum >= 26)
    {
        return bRet;
    }

    ioReady::Drive *pDrive = NULL;
    pDrive = new ioReady::Drive((int) dwDriveNum);
    if ( pDrive )
    {
        if ( pDrive->isIomegaDrive() )
            bRet=TRUE;
        delete pDrive;
    }
#endif 
    DebugMsg("IsIomegaDrive returning %u", bRet);

    return bRet;
}


BOOL GetIomegaDiskSerialNumber(DWORD dwDriveNum, PWMDMID pSN)
{
    BOOL bRet=FALSE;

#ifdef USE_IOREADY
    if (dwDriveNum >= 26)
    {
        return bRet;
    }

    ioReady::Drive *pDrive = NULL;
    char *pszSerial = NULL;
    pDrive = new ioReady::Drive((int) dwDriveNum);
    if ( pDrive )
    {
        if ( pDrive->isIomegaDrive() )
        {
            ioReady::Disk &refDisk = pDrive->getDisk();
            pszSerial = (char *)refDisk.getMediaSerialNumber();
            if ( pszSerial[0] )
            {
                ZeroMemory(pSN->pID, WMDMID_LENGTH);
                if (ioReady::ct_nSerialNumberLength <= sizeof(pSN->pID))
                {
                    CopyMemory(pSN->pID, pszSerial, ioReady::ct_nSerialNumberLength);
                    pSN->SerialNumberLength = ioReady::ct_nSerialNumberLength;
                    pSN->dwVendorID = MDSP_PMID_IOMEGA;
                    bRet = TRUE;
                }
            }
        }
    }
    delete pDrive;
#endif
    return bRet;
}

HRESULT __stdcall UtilGetManufacturer(LPWSTR pDeviceName, LPWSTR *ppwszName, UINT nMaxChars)
{
    HRESULT hr=S_OK;

    CARg(pDeviceName);
    CARg(ppwszName);

    CPRg(nMaxChars>16); // ensure enough buffer size

    DWORD dwDriveNum;

    // We use only the first char of pDeviceName and expect it to 
    // be a drive letter. The rest of pDeviceName is not validated.
    // Perhaps it should, but we don't want to break our clients.
    if (pDeviceName[0] >= L'A' && pDeviceName[0] <= L'Z')
    {
        dwDriveNum = pDeviceName[0] - L'A';
    }
    else if (pDeviceName[0] >= L'a' && pDeviceName[0] <= L'z')
    {
        dwDriveNum = pDeviceName[0] - L'a';
    }
    else
    {
        hr = E_INVALIDARG;
        goto Error;
    }


    if ( IsIomegaDrive(dwDriveNum) )
        wcscpy(*ppwszName, L"Iomega");
    else
    {
        wcscpy(*ppwszName, L"Unknown");
        WMDMID snData;
        snData.cbSize = sizeof(WMDMID);
        if ( S_OK==UtilGetSerialNumber(pDeviceName, &snData, FALSE) )
        {
            switch ( snData.dwVendorID )
            {
            case 1:
                wcscpy(*ppwszName, L"SanDisk");
                break;
            case 2:
                wcscpy(*ppwszName, L"Iomega");
                break;
            }
        }
    }
    Error:
    return hr;
}

#include <winioctl.h>

// This is defined in the Whistler platform SDK.
#ifndef IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER
    #define IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER  CTL_CODE( \
        IOCTL_STORAGE_BASE, 0x304, METHOD_BUFFERED, FILE_ANY_ACCESS ) 
#endif

HRESULT GetMSNWithNtIoctl(LPCWSTR wcsDevice, PWMDMID pSN)
{
    HRESULT hr=S_OK;
    HANDLE  hDevice = INVALID_HANDLE_VALUE;
    BOOL    bResult;
    MEDIA_SERIAL_NUMBER_DATA  MSNGetSize;  
    MEDIA_SERIAL_NUMBER_DATA* pMSN = NULL;  // Buffer to hold the serial number
    DWORD   dwBufferSize;                   // Size of pMSNNt buffer
    ULONG       i;
    DWORD   dwRet = 0;                      // Bytes returned

    CARg(pSN);

    DebugMsg("Entering GetMSNWithNtIoctl");

    hDevice = CreateFileW(  wcsDevice, 
                            GENERIC_READ, 
                            FILE_SHARE_READ|FILE_SHARE_WRITE, 
                            NULL,
                            OPEN_EXISTING, 
                            FILE_ATTRIBUTE_NORMAL | 
                            SECURITY_SQOS_PRESENT | SECURITY_ANONYMOUS, 
                            NULL);
    CWRg(hDevice != INVALID_HANDLE_VALUE);

    DebugMsg("GetMSNWithNtIoctl: CreateFile ok");
    
    // Get size of buffer we need to allocate
    bResult = DeviceIoControl(  hDevice, 
                                IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER, 
                                NULL, 
                                0, 
                                (LPVOID)&MSNGetSize, 
                                sizeof(MEDIA_SERIAL_NUMBER_DATA), 
                                &dwRet, 
                                NULL);

    // Handle expected buffer overrun error 
    if ( !bResult )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        // Error 'more data is available' is an expected error code
        if ( hr == HRESULT_FROM_WIN32(ERROR_MORE_DATA) )
        {
            hr = S_OK;
        }
        else goto Error;
    }

    DebugMsg("GetMSNWithNtIoctl: DeviceIoControl1 ok");

    if (dwRet < RTL_SIZEOF_THROUGH_FIELD(MEDIA_SERIAL_NUMBER_DATA, SerialNumberLength))
    {
        DebugMsg("GetMSNWithNtIoctl: DeviceIoControl1 dwRet bad: %u, expected >= %u", 
                 dwRet, RTL_SIZEOF_THROUGH_FIELD(MEDIA_SERIAL_NUMBER_DATA, SerialNumberLength));
        hr = E_INVALIDARG;
        goto Error;
    }

    // No serial number?
    if ( MSNGetSize.SerialNumberLength == 0 )
    {
        DebugMsg("GetMSNWithNtIoctl: DeviceIoControl1: MSNGetSize.SerialNumberLength == 0");
        hr = E_FAIL;
        goto Error;
    }
    // The WMDMID structure we are using can only handle 128 bytes long serial numbers
    if ( MSNGetSize.SerialNumberLength  > WMDMID_LENGTH )
    {
        DebugMsg("GetMSNWithNtIoctl: DeviceIoControl1: MSNGetSize.SerialNumberLength > WMDMID_LENGTH");
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto Error;
    }

    // Allocate buffer and call to get the serial number
    dwBufferSize = sizeof(MEDIA_SERIAL_NUMBER_DATA) + MSNGetSize.SerialNumberLength;
    pMSN = (MEDIA_SERIAL_NUMBER_DATA*) new BYTE[dwBufferSize];
    if ( pMSN == NULL )
    {
        DebugMsg("GetMSNWithNtIoctl: Out of memory allocating %u bytes", dwBufferSize);
        hr = E_OUTOFMEMORY;
        goto Error;
    }
    bResult = DeviceIoControl(  hDevice, 
                                IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER, 
                                NULL, 
                                0, 
                                (LPVOID)pMSN, 
                                dwBufferSize, 
                                &dwRet, 
                                NULL);
    if ( !bResult )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DebugMsg("GetMSNWithNtIoctl: DeviceIoControl2 failed, hr = 0x%x", hr);
        goto Error;
    }
    if (dwRet < FIELD_OFFSET(MEDIA_SERIAL_NUMBER_DATA, SerialNumberData) + pMSN->SerialNumberLength)
    {
        hr = E_INVALIDARG;
        DebugMsg("GetMSNWithNtIoctl: DeviceIoControl1: MSNGetSize.SerialNumberLength == 0");
        goto Error;
    }
    if (pMSN->SerialNumberLength > sizeof(pSN->pID))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        DebugMsg("GetMSNWithNtIoctl: DeviceIoControl2: MSNGetSize.SerialNumberLength > WMDMID_LENGTH");
        goto Error;
    }

    // Copy serial number to out structure
    memcpy( pSN->pID, pMSN->SerialNumberData, pMSN->SerialNumberLength );
    pSN->SerialNumberLength = pMSN->SerialNumberLength;

    // Check result
    pSN->dwVendorID = MDSP_PMID_SANDISK;
    if ( pSN->SerialNumberLength > 24 )
    {
        char szVID[4];
        for ( i=0; i<3; i++ )
        {
            szVID[i]=(pSN->pID[18+i]);
        }
        szVID[i]=0;

        LCID lcid = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
                                        SORT_DEFAULT);

        // if ( !lstrcmpiA(szVID, "ZIP") || 
        //      !lstrcmpiA(szVID, "JAZ") ||
        //      !lstrcmpiA(szVID, "CLI") )
        if (CompareStringA(lcid, NORM_IGNORECASE, szVID, -1, "ZIP", -1) == CSTR_EQUAL ||
            CompareStringA(lcid, NORM_IGNORECASE, szVID, -1, "JAZ", -1) == CSTR_EQUAL ||
            CompareStringA(lcid, NORM_IGNORECASE, szVID, -1, "CLI", -1) == CSTR_EQUAL)
        {
            pSN->dwVendorID = MDSP_PMID_IOMEGA;
        }
    }


    if ( (pSN->dwVendorID==MDSP_PMID_IOMEGA) && (pSN->SerialNumberLength>19) )
    {
        pSN->SerialNumberLength = 19;
        pSN->pID[18] = 0;
    }
    DebugMsg("GetMSNWithNtIoctl ok, pSN->SerialNumberLength = %u", pSN->SerialNumberLength);

    Error:
    if ( hDevice != INVALID_HANDLE_VALUE )   CloseHandle(hDevice);
    if ( pMSN )      delete [] pMSN;
    return hr;
}


HRESULT GetMSNWith9xIoctl(char chDriveLetter, PWMDMID pSN, DWORD dwCode, DWORD dwIOCTL )
{
    HRESULT hr=S_OK;
    HANDLE  hDevice=INVALID_HANDLE_VALUE;
    BOOL    bResult;
    MEDIA_SERIAL_NUMBER_DATA  MSNGetSize;  
    MEDIA_SERIAL_NUMBER_DATA* pMSN = NULL;  // Buffer to hold the serial number
    ULONG  uBufferSize;                     // Size of pMSN
    DWORD   dwRet = 0;                      // Bytes returned

//    _ASSERT( dwCode == 0x440D || 
//             dwCode == 0x4404 );
//    _ASSERT( (dwIOCTL == (0x0800 | 0x75)) || 
//             (dwIOCTL == WIN9X_IOCTL_GET_MEDIA_SERIAL_NUMBER) );
    CARg(pSN);

    hDevice = CreateFile("\\\\.\\VWIN32",0,0,NULL,OPEN_EXISTING,FILE_FLAG_DELETE_ON_CLOSE,0);

    CFRg(hDevice != INVALID_HANDLE_VALUE);  

    DIOC_REGISTERS  reg;
    DWORD       cb;
    WORD        drv;

    drv = (chDriveLetter >= 'a' ) ? (chDriveLetter-'a') : (chDriveLetter-'A');

    // Call first to get serial number size
    {
        MSNGetSize.SerialNumberLength = 0;
        reg.reg_EAX = dwCode;       //create the ioctl
        reg.reg_EBX = drv;
        reg.reg_EBX++;
        reg.reg_ECX = dwIOCTL;  // BUGBUG, needs definition of 0x75

        //
        // ISSUE: The following code will not work on 64-bit systems.
        //        The conditional is only to get the code to compiler.
        //

#if defined(_WIN64)
        reg.reg_EDX = (DWORD)(DWORD_PTR)&MSNGetSize;
#else
        reg.reg_EDX = (DWORD)&MSNGetSize;
#endif
        reg.reg_Flags = 0x0001;

        bResult = DeviceIoControl(  hDevice, 
                                    VWIN32_DIOC_DOS_IOCTL,
                                    &reg,
                                    sizeof(DIOC_REGISTERS),
                                    &reg,
                                    sizeof(DIOC_REGISTERS),
                                    &cb,
                                    NULL );

        // Check for errors
        if ( bResult && !(reg.reg_Flags&0x0001) )
        {
            if ( (MSNGetSize.Result != ERROR_SUCCESS) && 
                 (MSNGetSize.Result != ERROR_MORE_DATA ) )
            {
                hr = HRESULT_FROM_WIN32(MSNGetSize.Result);
                goto Error;
            }
        }

        // No serial number?
        if ( MSNGetSize.SerialNumberLength == 0 )
        {
            hr = E_FAIL;
            goto Error;
        }

        // Max serial number size is 128 byte right now
        if ( MSNGetSize.SerialNumberLength > WMDMID_LENGTH )
        {
            hr = E_FAIL;
            goto Error;
        }

        // Allocate buffer to get serial number
        uBufferSize = MSNGetSize.SerialNumberLength + sizeof(MEDIA_SERIAL_NUMBER_DATA);
        pMSN = (MEDIA_SERIAL_NUMBER_DATA*) new BYTE[uBufferSize];
        if ( pMSN == NULL )
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        }
    }


    // Call again to accually get the serial number
    {
        pMSN->SerialNumberLength = uBufferSize;
        reg.reg_EAX = dwCode;       //create the ioctl
        reg.reg_EBX = drv;
        reg.reg_EBX++;
        reg.reg_ECX = dwIOCTL; // BUGBUG, needs definition of 0x75

        //
        // ISSUE: The following code will not work on 64-bit systems.
        //        The conditional is only to get the code to compiler.
        //

#if defined(_WIN64)
        reg.reg_EDX = (DWORD)0;
#else
        reg.reg_EDX = (DWORD)pMSN;
#endif
        reg.reg_Flags = 0x0001;

        bResult = DeviceIoControl(  hDevice, 
                                    VWIN32_DIOC_DOS_IOCTL,
                                    &reg,
                                    sizeof(DIOC_REGISTERS),
                                    &reg,
                                    sizeof(DIOC_REGISTERS),
                                    &cb,
                                    NULL );

        // Check for errors
        if ( bResult && !(reg.reg_Flags&0x0001) )
        {
            if ( (pMSN->Result != ERROR_SUCCESS) )
            {
                hr = HRESULT_FROM_WIN32(pMSN->Result);
                goto Error;
            }
        }
    }

    // Copy serial number to out structure 
    // and 'figure out' vendor
    {
        memcpy( pSN->pID, pMSN->SerialNumberData, pMSN->SerialNumberLength );
        pSN->SerialNumberLength = pMSN->SerialNumberLength;

        pSN->dwVendorID = MDSP_PMID_SANDISK;
        if ( pSN->SerialNumberLength > 24 )
        {
            char   szVID[4];
            ULONG   i;

            for ( i=0; i<3; i++ )
            {
                szVID[i]=(pSN->pID[18+i]);
            }
            szVID[i]=0;
            LCID lcid = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
                                            SORT_DEFAULT);

            // if ( !lstrcmpiA(szVID, "ZIP") || 
            //      !lstrcmpiA(szVID, "JAZ") ||
            //      !lstrcmpiA(szVID, "CLI") )
            if (CompareStringA(lcid, NORM_IGNORECASE, szVID, -1, "ZIP", -1) == CSTR_EQUAL ||
                CompareStringA(lcid, NORM_IGNORECASE, szVID, -1, "JAZ", -1) == CSTR_EQUAL ||
                CompareStringA(lcid, NORM_IGNORECASE, szVID, -1, "CLI", -1) == CSTR_EQUAL)
            {
                pSN->dwVendorID = MDSP_PMID_IOMEGA;
            }
        }

        if ( (pSN->dwVendorID==MDSP_PMID_IOMEGA) && (pSN->SerialNumberLength>19) )
        {
            pSN->SerialNumberLength = 19;
            pSN->pID[18] = 0;
        }
    }

    Error:
    if ( hDevice != INVALID_HANDLE_VALUE )   CloseHandle(hDevice);
    if ( pMSN )      delete [] pMSN;
    return hr;
}

HRESULT GetDeviceSNwithNTScsiPassThrough(LPCWSTR wszDevice, PWMDMID pSN)
{
    HRESULT hr=S_OK;
    HANDLE  fileHandle=INVALID_HANDLE_VALUE;
    UCHAR   buffer[2048];
    BOOL    status;
    ULONG   returned, length, i, bufOffset;
    SCSI_PASS_THROUGH_WITH_BUFFERS sptwb;
    PSCSI_ADAPTER_BUS_INFO  adapterInfo;
    PSCSI_INQUIRY_DATA inquiryData;

    DebugMsg("Entering GetDeviceSNwithNTScsiPassThrough");

    ZeroMemory(pSN, sizeof(WMDMID));
    fileHandle = CreateFileW(wszDevice,
                             GENERIC_WRITE | GENERIC_READ,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_EXISTING,
                             SECURITY_SQOS_PRESENT | SECURITY_ANONYMOUS,
                             NULL);

    CWRg(fileHandle != INVALID_HANDLE_VALUE);

    DebugMsg("GetDeviceSNwithNTScsiPassThrough: CreateFile ok");

    status = DeviceIoControl(fileHandle,
                             IOCTL_SCSI_GET_INQUIRY_DATA,
                             NULL,
                             0,
                             buffer,
                             sizeof(buffer),
                             &returned,
                             FALSE);
    // CWRg(status);
    // We use IOCTL_SCSI_GET_INQUIRY_DATA to get the disk's SCSI address, if 
    // this fails, it is not on a SCSI bus so the SCSI address will be all zeros
    if ( status )
    {
        DebugMsg("GetDeviceSNwithNTScsiPassThrough: DeviceIoControl1 ok");

        if (returned < sizeof(SCSI_ADAPTER_BUS_INFO))
        {
            DebugMsg("GetDeviceSNwithNTScsiPassThrough: DeviceIoControl1 returned = %u < sizeof(SCSI_ADAPTER_BUS_INFO) = %u",
                     returned, sizeof(SCSI_ADAPTER_BUS_INFO));
            hr = E_INVALIDARG;
            goto Error;
        }
        adapterInfo = (PSCSI_ADAPTER_BUS_INFO) buffer;
        CFRg(adapterInfo->NumberOfBuses>0);
        if (returned < adapterInfo->BusData[0].InquiryDataOffset + sizeof(SCSI_INQUIRY_DATA))
        {
            hr = E_INVALIDARG;
            DebugMsg("GetDeviceSNwithNTScsiPassThrough: DeviceIoControl1 returned = %u < adapterInfo->BusData[0].InquiryDataOffset (%u) + sizeof(SCSI_INQUIRY_DATA) (%u)",
                     returned, adapterInfo->BusData[0].InquiryDataOffset, sizeof(SCSI_INQUIRY_DATA));
            goto Error;
        }
        inquiryData = (PSCSI_INQUIRY_DATA) (buffer +
                                            adapterInfo->BusData[0].InquiryDataOffset); // we know card readers has only one bus
    }

    ZeroMemory(&sptwb,sizeof(sptwb));

    sptwb.spt.Length = sizeof(SCSI_PASS_THROUGH);
    sptwb.spt.PathId = (status?inquiryData->PathId:0);
    sptwb.spt.TargetId = (status?inquiryData->TargetId:0);
    sptwb.spt.Lun = (status?inquiryData->Lun:0);
    sptwb.spt.CdbLength = CDB6GENERIC_LENGTH;
    sptwb.spt.SenseInfoLength = 24;
    sptwb.spt.DataIn = SCSI_IOCTL_DATA_IN;
    sptwb.spt.DataTransferLength = 256 /*256*/;
    sptwb.spt.TimeOutValue = 2;
    sptwb.spt.DataBufferOffset =
    offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS,ucDataBuf);
    sptwb.spt.SenseInfoOffset = 
    offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS,ucSenseBuf);
    sptwb.spt.Cdb[0] = 0x12     /* Command - SCSIOP_INQUIRY */;
    sptwb.spt.Cdb[1] = 0x01;    /* Request - VitalProductData */
    sptwb.spt.Cdb[2] = 0x80     /* VPD page 80 - serial number page */;
    sptwb.spt.Cdb[3] = 0;
    sptwb.spt.Cdb[4] = 0xff     /*255*/;
    sptwb.spt.Cdb[5] = 0;

    length = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS,ucDataBuf) +
             sptwb.spt.DataTransferLength;

    status = DeviceIoControl(fileHandle,
                             IOCTL_SCSI_PASS_THROUGH,
                             &sptwb,
                             sizeof(SCSI_PASS_THROUGH),
                             &sptwb,
                             length,
                             &returned,
                             FALSE); 
    CWRg(status);

    // CFRg(sptwb.ucDataBuf[3]>0);

    // Keep or remove this @@@@
    if (returned < offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS,ucDataBuf) + 4)
    {
        hr = E_INVALIDARG;
        DebugMsg("GetDeviceSNwithNTScsiPassThrough: DeviceIoControl2 returned = %u < offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS,ucDataBuf) + 4 = %u",
                    returned, offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS,ucDataBuf) + 4);
        goto Error;
    }

    // Here there is a difference between Parallel and USB Unit:
    // Since the Parallel Unit is an emulation of SCSI disk, it doesn't follow SCSI spec.
    pSN->SerialNumberLength=0;
    pSN->dwVendorID=0;
    if ( sptwb.ucDataBuf[3] == 0 ) // this is the SanDisk USB device
    {
        pSN->SerialNumberLength = 20;
        // Keep or remove this @@@@
        if (returned < offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS,ucDataBuf) + 5)
        {
            hr = E_INVALIDARG;
            DebugMsg("GetDeviceSNwithNTScsiPassThrough: DeviceIoControl2 returned = %u < offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS,ucDataBuf) + 5 = %u",
                        returned, offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS,ucDataBuf) + 5);
            goto Error;
        }
        if ( sptwb.ucDataBuf[4] > 0 )
        {
            if ((DWORD) (sptwb.ucDataBuf[4]) + 5 >= (DWORD) (pSN->SerialNumberLength))
            {
                bufOffset=(sptwb.ucDataBuf[4]+5)-(pSN->SerialNumberLength);
            }
            else
            {
                hr = E_INVALIDARG;
                goto Error;
            }
        }
        else
        {  // There are 50K ImageMate III devices that read like this
            bufOffset=36;
        }
    }
    else if ( sptwb.ucDataBuf[3] > 0 )
    {
        pSN->SerialNumberLength = sptwb.ucDataBuf[3];
        bufOffset=4;
    }

    DebugMsg("GetDeviceSNwithNTScsiPassThrough: DeviceIoControl2 pSN->SerialNumberLength = %u",
             pSN->SerialNumberLength);
    // The WMDMID structure we are using can only handle 128 bytes long serial numbers
    if ( pSN->SerialNumberLength > WMDMID_LENGTH )
    {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        DebugMsg("GetDeviceSNwithNTScsiPassThrough: DeviceIoControl2 pSN->SerialNumberLength > WMDMID_LENGTH = %u", WMDMID_LENGTH);
        goto Error;
    }

    // Keep or remove this @@@@
    if (returned < offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS,ucDataBuf) + bufOffset + pSN->SerialNumberLength)
    {
        hr = E_INVALIDARG;
        DebugMsg("GetDeviceSNwithNTScsiPassThrough: DeviceIoControl2 returned = %u < offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS,ucDataBuf) (=%u) + bufOffset (=%u) + pSN->SerialNumberLength) (=%u) = %u",
                    returned, offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS,ucDataBuf), bufOffset, pSN->SerialNumberLength,
                    offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS,ucDataBuf) + bufOffset + pSN->SerialNumberLength);
        goto Error;
    }

    for ( i=0; i<pSN->SerialNumberLength; i++ )
    {
        pSN->pID[i] = sptwb.ucDataBuf[bufOffset+i];
        if ( !(pSN->dwVendorID) && pSN->pID[i] && pSN->pID[i] != 0x20 )
            pSN->dwVendorID = MDSP_PMID_SANDISK;
    }

    if ( !(pSN->dwVendorID) )
        hr=S_FALSE;
    else
        hr=S_OK;

    Error:
    if ( fileHandle != INVALID_HANDLE_VALUE )
        CloseHandle(fileHandle);
    DebugMsg("GetDeviceSNwithNTScsiPassThrough: returning hr = 0x%x", hr);
    return hr;
}


HRESULT GetMediaSerialNumberFromNTService(DWORD dwDN, PWMDMID pSN)
{
    HANDLE      hPipe = INVALID_HANDLE_VALUE; 
    BYTE        ubBuf[256]; 
    BOOL        fSuccess; 
    DWORD       cbRead, cbWritten; 
    WCHAR       wszPipename[64] = L"\\\\.\\pipe\\WMDMPMSPpipe"; 
    DWORD       dwErr;
    PMEDIA_SERIAL_NUMBER_DATA pMSN;
    HRESULT     hr;
    BOOL        bStarted = 0;

    if (dwDN >= 26)
    {
        _ASSERTE(dwDN < 26);
        hr = E_INVALIDARG;
        goto ErrorExit;
    }

    // Try to open a named pipe; wait for it, if necessary.   	
    for ( DWORD dwTriesLeft = 3; dwTriesLeft; dwTriesLeft -- )
    {
        // Set the impersonation level to the lowest one that works.
        // The real server impersonates us to validate the drive type.
        // SECURITY_ANONYMOUS is enough for this as long as the drive
        // specified is of the form x: (i.e., is not an ms-dos device name
        // in the DosDevices directory)
        hPipe = CreateFileW(
                          wszPipename, 
                          GENERIC_READ |GENERIC_WRITE, 
                          0, 
                          NULL, 
                          OPEN_EXISTING, 
                          SECURITY_SQOS_PRESENT | SECURITY_ANONYMOUS,
                          NULL
                          );   

        // Break if the pipe handle is valid. 
        if ( hPipe != INVALID_HANDLE_VALUE )
        {
            // Success 
            fSuccess=TRUE;
            break; 
        }

        // If all pipe instances are busy or if server has not yet created
        // the first instance of the named pipe, wait for a while and retry.
        // Else, exit.
        dwErr=GetLastError();
        DebugMsg("GetMediaSerialNumberFromNTService(): CreateFile on drive %u failed, last err = %u, Tries left = %u, bStarted = %d",
                 dwDN, dwErr, dwTriesLeft, bStarted);
        if ( dwErr != ERROR_PIPE_BUSY && dwErr != ERROR_FILE_NOT_FOUND)
        {
            fSuccess=FALSE;
            break;
        }
        if (dwErr == ERROR_FILE_NOT_FOUND && !bStarted)
        {
            dwTriesLeft++;      // Don't count this iteration
            bStarted = 1;

            // We start the service here because the service now
            // times out sfter a period of inactivity.
            // We ignore errors. If the start fails, we'll
            // timeout anyway. (If we did respond to errors, note
            // that the service may already be running and that 
            // shuld not be considered an error.)
            UtilStartStopService(TRUE);

            // Wait for service to start
            for (DWORD i = 2; i > 0; i--)
            {
                Sleep(1000);
                if (WaitNamedPipeW(wszPipename, 0))
                {
                    // Service is up and running and a pipe instance
                    // is available
                    break;
                }
                else
                {
                    // Either the service has not yet started or no
                    // pipe instance is available. Just keep going.
                }
            }

            // Even if the wait for the named pipe failed,
            // go on. We'll try once more below and bail out.
        }

        // All pipe instances are busy (or the service is starting), 
        // so wait for 1 second. 
        // Note: Do not use NMPWAIT_USE_DEFAULT_WAIT since the
        // server of this named pipe may be spoofing our server
        // and may have the set the default very high.
        if ( ! WaitNamedPipeW(wszPipename, 1000) )
        {
            fSuccess=FALSE;
            break;
        }
    } // end of for loop 

    if ( !fSuccess )
    {
        hr=HRESULT_FROM_WIN32(ERROR_CANTOPEN);
        goto ErrorExit;
    }


    ZeroMemory(ubBuf, sizeof(ubBuf));
    pMSN = (PMEDIA_SERIAL_NUMBER_DATA)ubBuf;
    // pMSN->SerialNumberLength = 128;
    pMSN->Reserved[1] = dwDN;

    DWORD cbTotalWritten = 0;

    do
    {
        fSuccess = WriteFile(
                        hPipe,                  // pipe handle 
                        ubBuf + cbTotalWritten, // message 
                        sizeof(*pMSN)- cbTotalWritten, // +128, // message length 
                        &cbWritten,             // bytes written 
                        NULL                    // not overlapped 
                        );                  

        if ( !fSuccess) // || cbWritten != sizeof(*pMSN))
        {
            hr=HRESULT_FROM_WIN32(ERROR_CANTWRITE); 
            goto ErrorExit;
        }
        cbTotalWritten += cbWritten;
        _ASSERTE(cbTotalWritten <= sizeof(*pMSN));
    }
    while (cbTotalWritten < sizeof(*pMSN));

    DWORD cbTotalRead = 0;
    DWORD cbTotalToRead;
    do 
    {
        // Read from the pipe. 
        fSuccess = ReadFile(
                           hPipe,      // pipe handle 
                           ubBuf + cbTotalRead, // buffer to receive reply 
                           sizeof(ubBuf) - cbTotalRead, // size of buffer 
                           &cbRead,    // number of bytes read 
                           NULL        // not overlapped 
                           );    

        // This is a byte mode pipe, not a message mode one, so we 
        // do not expect ERROR_MORE_DATA. Anyway, let this be as is.
        if ( !fSuccess && (dwErr=GetLastError()) != ERROR_MORE_DATA )
        {
            break; 
        }
        cbTotalRead += cbRead;
        _ASSERTE(cbTotalRead <= sizeof(ubBuf));

        // We expect at least FIELD_OFFSET(MEDIA_SERIAL_NUMBER_DATA, SerialNumberData)
        // bytes in the response
        cbTotalToRead = FIELD_OFFSET(MEDIA_SERIAL_NUMBER_DATA, SerialNumberData);
        if (cbTotalRead >= cbTotalToRead)
        {
            pMSN = (PMEDIA_SERIAL_NUMBER_DATA)ubBuf;
            if ( ERROR_SUCCESS == pMSN->Result )
            {
                cbTotalToRead += pMSN->SerialNumberLength;
            }
            else
            {
                cbTotalToRead = sizeof(MEDIA_SERIAL_NUMBER_DATA);
            }
            // Server should write exactly cbTotalToRead bytes.
            // We should not have read any more because
            // we wrote only 1 request. (If we write >1 request, we may 
            // get responses to both request.) 
            _ASSERTE(cbTotalRead <= cbTotalToRead);

            if (cbTotalToRead > sizeof(ubBuf))
            {
                // We don't expect this. Server bad?
                fSuccess = FALSE;
                break;
            }
        }
        else
        {
            // cbTotalToRead does not have to be changed
        }

    } while ( !fSuccess || cbTotalRead < cbTotalToRead);  // repeat loop if ERROR_MORE_DATA 

    if ( fSuccess )
    {
        pMSN = (PMEDIA_SERIAL_NUMBER_DATA)ubBuf;

        if ( ERROR_SUCCESS == pMSN->Result &&
             pMSN->SerialNumberLength <= sizeof(pSN->pID))
        {
            CopyMemory(pSN->pID, pMSN->SerialNumberData, pMSN->SerialNumberLength);
            pSN->SerialNumberLength = pMSN->SerialNumberLength;
            pSN->dwVendorID = pMSN->Reserved[1];
            pSN->cbSize = sizeof(*pSN);
            hr=S_OK;
        }
        else if (pMSN->Result != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(pMSN->Result);
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        }
    }
    else
    {
        hr=HRESULT_FROM_WIN32(ERROR_CANTREAD);
    }

    ErrorExit:

    if ( hPipe != INVALID_HANDLE_VALUE )
        CloseHandle(hPipe);

    return hr;
}


HRESULT UtilGetHardSN(WCHAR *wcsDeviceName, DWORD dwDriveNum, PWMDMID pSN)
{
    HRESULT hr=S_OK;
    ULONG i;

    DebugMsg("Entering UtilGetHardSN, drivenum %u", dwDriveNum);
    CARg(pSN);

    DWORD dwLastError;

    if ( IsAdministrator(dwLastError) )
    {
        // Convert device name to an ascii char - done only on Win9x
        char szTmp[MAX_PATH];
        *szTmp = 0;

        // Following only for NT. If we have a DOS device name, use it.
        // Else, open the drive letter.
        WCHAR  wcsDriveName[] = L"\\\\.\\?:";
        
        if (dwDriveNum >= 26)
        {
            _ASSERTE(dwDriveNum < 26);
            hr = E_INVALIDARG;
            goto Error;
        }
        LPCWSTR wcsDeviceToOpen = wcsDriveName;
        wcsDriveName[4] = (WCHAR) (dwDriveNum + L'A');

        // Try IOCTL calls 
        if ( IsWinNT() )
        {
            // NT, try IOCTL_GET_MEDIA_SERIAL_NUMBER method first
            hr = GetMSNWithNtIoctl(wcsDeviceToOpen, pSN);
        }
        else
        {
            if ( WideCharToMultiByte(CP_ACP, NULL, wcsDeviceName, -1, szTmp, sizeof(szTmp), NULL, NULL) == 0 )
            {
                hr = E_INVALIDARG;
                goto Error;
            }
            // Try two other IOCTL calls on Win9x
            hr = GetMSNWith9xIoctl( szTmp[0], pSN, 0x440D, (0x0800 | 0x75) );
            if ( FAILED(hr) )
            {
                hr = GetMSNWith9xIoctl( szTmp[0], pSN, 0x4404, WIN9X_IOCTL_GET_MEDIA_SERIAL_NUMBER );
            }
        }

        // Try Iomega
        if ( FAILED(hr) )
        {
            if ( IsIomegaDrive(dwDriveNum) )
            {
                if ( GetIomegaDiskSerialNumber(dwDriveNum, pSN) )
                {
                    hr=S_OK;
                }
                else
                {
                    hr = E_FAIL;
                    goto Error;
                }
            }
        }

        // Try new SCSI_PASS_THROUGH "Get Media Serial Number" command
        if ( FAILED(hr) )
        {
            if ( IsWinNT() )
            {
                // This was pulled because it was not standardized.
                // hr = GetMediaSNwithNTScsiPassThrough(szTmp, pSN);
            }
            else
            {
                // @@@@ Remove this as well?
                Aspi32Util  a32u;
                if ( a32u.DoSCSIPassThrough(szTmp, pSN, TRUE ) )
                {
                    hr=S_OK;
                }
                else
                {
                    hr = E_FAIL;
                }
            }
        }

        // Last chance, try old 'bad' 
        // SCSI_PASS_THROUGH "Get Device Serial Number" command
        if ( FAILED(hr) )
        {

//            // We are using the DEVICE serial number as a MEDIA serial number.
//            // This violates the SCSI spec. We are only keeping this functionality 
//            // for the devices we know that needs it.
//            if( CheckForKBDevice( szTmp[0] ) == FALSE )
//            {
//                hr = E_FAIL;
//                goto Error;
//            }

            if ( IsWinNT() )
            {
                CHRg(GetDeviceSNwithNTScsiPassThrough(wcsDeviceToOpen, pSN));
            }
            else
            {
                Aspi32Util  a32u;
                CFRg( a32u.DoSCSIPassThrough(szTmp, pSN, FALSE ) );
            }
        }
    }
    else if (dwLastError != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(dwLastError);
        goto Error;
    }
    else // If on NT and nonAdmin, try use PMSP Service
    {
        hr = GetMediaSerialNumberFromNTService(dwDriveNum, pSN);
        if (FAILED(hr))
        {
            goto Error;
        }
    }

    // put sanity check here
    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    for ( i=0; i<(pSN->SerialNumberLength); i++ )
    {
        if ( pSN->pID[i] && pSN->pID[i] != 0x20 )
        {
            hr = S_OK;
            break;
        }
    }
    Error:
    DebugMsg("Leaving UtilGetHardSN, hr = 0x%x");
    return hr;
}

// fCreate is an unused parameter. Ir was used in an obsolete code path that 
// has been deleted
HRESULT __stdcall UtilGetSerialNumber(WCHAR *wcsDeviceName, PWMDMID pSerialNumber, BOOL fCreate)
{
    HRESULT hr = E_FAIL;

    DebugMsg("Entering UtilGetSerialNumber");

    if (!pSerialNumber || !wcsDeviceName)
    {
        return E_INVALIDARG;
    }

    DWORD dwDriveNum;

    // We use only the first char of pDeviceName and expect it to 
    // be a drive letter. The rest of pDeviceName is not validated.
    // Perhaps it should, but we don't want to break our clients.
    if (wcsDeviceName[0] >= L'A' && wcsDeviceName[0] <= L'Z')
    {
        dwDriveNum = wcsDeviceName[0] - L'A';
    }
    else if (wcsDeviceName[0] >= L'a' && wcsDeviceName[0] <= L'z')
    {
        dwDriveNum = wcsDeviceName[0] - L'a';
    }
    else
    {
        hr = E_INVALIDARG;
        goto Error;
    }

    pSerialNumber->cbSize = sizeof(WMDMID);
    hr = UtilGetHardSN(wcsDeviceName, dwDriveNum, pSerialNumber);

    if ( FAILED( hr ) )
    {
        if ( hr != HRESULT_FROM_WIN32(ERROR_INVALID_DATA) )
        {
            pSerialNumber->SerialNumberLength = 0;
            pSerialNumber->dwVendorID = 0;
            ZeroMemory(pSerialNumber->pID, sizeof(pSerialNumber->pID));
            hr = HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
        }
        // hr = S_FALSE;
    }

Error:
    DebugMsg("Leaving UtilGetSerialNumber, hr = 0x%x", hr);
    return hr;
}

HRESULT __stdcall UtilStartStopService(bool fStartService)
{
    HRESULT hr = S_OK;
    SERVICE_STATUS    ServiceStatus;

    DWORD dwLastError;

    if ( IsAdministrator(dwLastError) )
    {
        //  
        // We are on Win 9x machine or NT machine with admin previleges. In
        // either case, we don't want to run the service.
        //  
        DebugMsg("UtilStartStopService(): fStartService = %d, returning S_OK (IsAdmin returned TRUE)",
                fStartService);
        return S_OK;
    }
    else
    {
        // We ignore dwLastError
    }

    // open the service control manager
    SC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    SC_HANDLE hService = NULL;

    if ( !hSCM )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DebugMsg("UtilStartStopService(): fStartService = %d, OpenSCManager failed, last err (as hr) = 0x%x",
                fStartService, hr);
        goto Error;
    }

    // open the service
    hService = OpenService(hSCM,
                           "WmdmPmSp",
                           (fStartService? SERVICE_START : SERVICE_STOP) | SERVICE_QUERY_STATUS);

    if ( !hService )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DebugMsg("UtilStartStopService(): fStartService = %d, OpenService failed, last err (as hr) = 0x%x",
                fStartService, hr);
        goto Error;
    }

    if ( !QueryServiceStatus( hService, &ServiceStatus ) )
    {

        hr = HRESULT_FROM_WIN32(GetLastError());
        DebugMsg("UtilStartStopService(): fStartService = %d, QueryServiceStatus failed, last err (as hr) = 0x%x",
                fStartService, hr);
        goto Error;
    }

    if ( fStartService && ServiceStatus.dwCurrentState != SERVICE_RUNNING)
    {
        // start the service
        if(!StartService(hService, 0, NULL) )
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DebugMsg("UtilStartStopService(): fStartService = %d, StartService failed, last err (as hr) = 0x%x",
                    fStartService, hr);
            goto Error;
        }     
    }

    if(!fStartService && ServiceStatus.dwCurrentState != SERVICE_STOP)
    {
        // stop the service.
        if(!ControlService(hService, SERVICE_CONTROL_STOP, &ServiceStatus))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DebugMsg("UtilStartStopService(): fStartService = %d, ControlService failed, last err (as hr) = 0x%x",
                    fStartService, hr);
            goto Error;            
        }
    }

Error:
    if ( hService )
    { 
        CloseServiceHandle(hService);
    }
    if ( hSCM )
    {
        CloseServiceHandle(hSCM);
    }
    DebugMsg("UtilStartStopService(): fStartService = %d, returning hr = 0x%x",
             fStartService, hr);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\common\serialnumber\ioreadymin.h ===
//////////////////////////////////////////////////////////////////
// ioReadyMin.h
//
// The include file for minimum IomegaReady 3.0.  
//
// Copyright (C) 1998 Iomega Corp.
//
//////////////////////////////////////////////////////////////////

#ifndef __iomegaReady_h__
#define __iomegaReady_h__

#if defined(macintosh) || defined(_MAC)
	#define IOREADY_MAC 1
	#define IOREADY_WIN 0
#endif

#if defined(_WIN32) || defined(_MSC_VER)
	#define IOREADY_MAC 0
	#define IOREADY_WIN 1
#endif

#ifdef DllInterface
#undef DllInterface
#endif

#if IOREADY_WIN

#ifndef _WINDOWS_
#pragma message ( __FILE__  ":  error: include <windows.h> before including \"ioReadyMin.h\"")
#endif // _WINDOWS_

#ifdef __Building_iomegaReady_Dll__
	#define DllInterface __declspec( dllexport )
	#define STRICT 1
#elif defined __Building_iomegaReady_Lib__
	#define DllInterface
	#define STRICT 1 
	bool InitializeIoReady();
#elif defined __Using_iomegaReady_Lib__
	#define DllInterface
	bool InitializeIoReady();
#else
	#define DllInterface __declspec( dllimport )
#endif

#pragma warning(disable:4786)		// disable function name truncation warning
#pragma warning(disable:4251)		// disable dll interface warning

#else // IOREADY_MAC

#define DllInterface

#endif // IOREADY_WIN/IOREADY_MAC block

#if IOREADY_MAC

typedef UInt32 CRITICAL_SECTION;
typedef PicHandle HBITMAP;
typedef Handle HICON;
typedef Handle HANDLE;
typedef RGBColor COLORREF;
typedef HFileInfo WIN32_FIND_DATA;

typedef void*  LPVOID;
typedef bool   BOOL;
typedef UInt8  BYTE;
typedef UInt16 WORD;
typedef UInt32 DWORD;
typedef UInt64 QWord;

#define MAX_PATH 32

extern void InitializeCriticalSection(CRITICAL_SECTION*);
extern void DeleteCriticalSection(CRITICAL_SECTION*);
extern void EnterCriticalSection(CRITICAL_SECTION*);
extern void LeaveCriticalSection(CRITICAL_SECTION*);

#endif // IOREADY_MAC


#pragma pack( push, ioReadyPack, 8 )

//////////////////////////////////////////////////////////////////
// ioReady namespace
//
namespace ioReady {

//////////////////////////////////////////////////////////////////
// forward class declarations 
//
class DllInterface Drive;
class DllInterface Disk;
class DllInterface Adapter;
class DriveImp;
class DiskImp;
class CoreOSImp;
class AdapterInfo;

/////////////////////////////////////////////////////////////////
// constants for ioReady
//
const int ct_nMaxFamilyLength = 128;		// max for family description strings
const int ct_nSerialNumberLength = 19;		// min needed for getMediaSerialNumber, includes space for NULL
const int ct_nExtendedSerialNumberLength = 41;		
											// min needed for getExtendedMediaSerialNumber, includes space for NULL
const int ct_nMaxAdapterAttributes = 3;		// current max number of attributes
const int ct_nAdapterAttributeLength = 64;	// min needed for getAttribute strings

//////////////////////////////////////////////////////////////////
// Enumerations
//
// Any drives added must be added as bit flags
// Enumed this way so the DriveArray, etc objects can take as argument
// Future use Iomega value is now 0x00E0
//
enum EDriveFamily
{
	eAnyFamily			= 0xFFFF,
	eIomegaFamily		= 0x00FF,
	eInvalidFamily		= 0x0000,
	eZip				= 0x0001,
	eJaz				= 0x0002,
	eClik				= 0x0004,
	ePacifica			= 0x0008,
	eOtherIomegaFamily	= 0x0010,
	eFloppyFamily		= 0x0100,
	eHardDriveFamily	= 0x0200,
	eCDRomFamily		= 0x0400,
	eNetworkFamily		= 0x0800,
	eGenericFamily		= 0x1000,
	eRemovableFamily	= 0x2000,
	eRamFamily			= 0x4000,
	eIomegaCDFamily		= 0x8000
};

enum EDriveSubFamily
{
	eInvalidSubFamily=0, eZip100=1, eZip250=2, eJaz1=3, 
	eJaz2=4, eClik40=5, ePacifica2=6, eOtherIomegaSubFamily=7,
	eHardDriveSubFamily=8, eRemovableSubFamily=9, eFloppySubFamily=10, 
	eCDRomSubFamily=11, eNetworkSubFamily=12, eGenericSubFamily=13, 
	eRamSubFamily=14, eIomegaCDSubFamily=15
};

enum EDriveModel
{
	eInvalidModel=0, eZip100Plus=1, eZip100Scsi=2, 
	eZip100PPort=3, eZip100Atapi=4, eZip100IDE=5, eJaz1Scsi=6, 
	eJaz2Scsi=7, eClik40Atapi=8, ePacifica2GScsi=9, eOtherIomegaModel=10, 
	eHardDriveModel=11, eRemovableModel=12, eFloppyModel=13, eCDRomModel=14, 
	eNetworkModel=15, eGenericModel=16, eZip250PPort=17, eZip250Scsi=18,
	eZip250Atapi=19, eRamModel=20, eClik40PPort=21, eZip100Usb=22,
	eZipCDModel=23, eClik40PCCard=24, eZip250Usb=25, eZip250PCCard=26,
	eClik40USB = 27
};

enum EMediaType
{
	eInvalidDisk=0, eNoDiskInserted=1, eZip100Disk=2, 
	eJaz1Disk=3, eJaz2Disk=4, eHardDisk=5, eNetworkDisk=6, eFloppyDisk=7, 
	eRemovableDisk=8, eCDRomDisk=9, eGenericDisk=10, eOtherIomegaDisk=11, 
	eZip250Disk=12, eClik40Disk=13, ePacifica2GDisk=14, eRamDisk=15,
	eZipCDDisk=16, ePacifica1GDisk=17
};

enum EAdapter
{
	eUnknownAdapter=0, eParallelPort=1, eScsi=2, eAtapi=3, eIDE=4, eUSB=5, e1394=6, ePCCard=7
};

//////////////////////////////////////////////////////////////////
// error enums
//
enum EError
{
	eNoError =0, eNotImplemented=1, eNotApplicable=2, eNoDisk=3, 
	eWrongDiskType=4, eNotFormatted=5, eReadWriteProtectedError=6, eWriteProtectedError=7, 
	eDiskErrorReading=8, eDiskErrorWriting=9, eOSLockAlreadyOnDisk=10, 
	eDriveInUse=11, eCritical=12, eQuickVerifyFormatNotAllowed=13, 
	eSurfaceVerifyFormatNotAllowed=14, eNeedsSurfaceVerifyFormat=15, eStringLengthExceeded=16, 
	eLowMemory=17, eCannotDelete=18, eCannotMakeRemovable=19, 
	eUserCancel=20, eInvalidStateChange=21, eIncorrectPassword=22, 
	eOutOfRange=23, ePasswordRequired=24, eNotRemovable=25,
	ePasswordTooLong=26, eProtected=27, eSystemDisk=28, eBootDisk=29,
	eUnableCopySystemFiles=30, eUnableLabelVolume=31, eIssueFormatFailed=32,
	eFormatInProgress=33, eInvalidParameter=34, eEjectInProgress=35
};

//////////////////////////////////////////////////////////////////
// Drive class
//
class DllInterface Drive 
{

public:
	Drive( int drvNum );
	Drive( char c );
	~Drive();

	// identification functions
	int getDrvNum();
	bool isIomegaDrive();
	bool isIomegaCDDrive();

	// more identification functions
	EDriveFamily	getFamily();
	EDriveSubFamily getSubFamily();
	EDriveModel		getModel();
	const char *getFamilyText( );
	const char *getSubFamilyText( );
	const char *getModelText( );
	
	// disk functions
	bool  hasDisk();
	Disk& getDisk();


protected:
	DriveImp* m_pImp;

private:
	// helper function for constructors
	void create( int drvNum );	
	void createIomegaDrive( CoreOSImp *pCore );
	void createIomegaDrive( CoreOSImp *pCore, char *szInquiry );
	void createNonIomegaDrive( CoreOSImp *pCore );
	

	Drive &operator=( const Drive &drive);	// no assignment operator
	Drive( const Drive & );					// no copy constructor
};


//////////////////////////////////////////////////////////////////
// DiskIface class
//		Interface only, not exported, pure virtual class
//
class DllInterface DiskIface
{
public:
	// disk identification functions
	virtual EMediaType getMediaType() = 0;
	virtual const char *getMediaSerialNumber() = 0; 

};


//////////////////////////////////////////////////////////////////
// Disk class
//
class DllInterface Disk : public DiskIface
{
public:
	~Disk();

	// disk identification functions
	EMediaType getMediaType();						
	const char *getMediaSerialNumber( );					// unique serial number
	const char *getExtendedMediaSerialNumber();				// longer unique serial number

protected:
	// user accesses through getDisk()
	Disk( DriveImp *pDriveImp );

private:
	// state functions
	void updateDiskPresence();
	void updateDiskIdentity();

	DriveImp *m_pDriveImp;
	DiskImp  *m_pImp;

	Disk &operator=( const Disk &disk);		// no assignment operator
	Disk( const Disk & );					// no copy constructor

	friend class DriveImp;
};


//////////////////////////////////////////////////////////////////
// Adapter class
//
class AttribListImp;
	
class DllInterface Adapter
{
public:
	virtual ~Adapter();

	EAdapter getType();
	const char *getName( );		
	const char *getMiniportDriverName( );

	virtual bool getAttribute( int index, char *szLabel, char *szValue, int nLength );
	virtual int  getAttributeCount();

	static Adapter *createAdapter( EAdapter eType, AdapterInfo& attrib );

protected:
	// user access Adapter through getAdapter call
	Adapter( EAdapter eAdapter, const char *szName );

	virtual void initializeAttributes();

	EAdapter m_eType;

	char *m_pszName;
	char *m_pszMiniportDriverName;
	AttribListImp *m_pAttribList;
	bool m_bAttrInitialized;

private:
	Adapter& operator=( const Adapter& adapter);	// no assignment operator
	Adapter( const Adapter& );						// no copy constructor

	friend void Drive::createIomegaDrive( CoreOSImp *pCore );
	friend class DriveImp;
};

//////////////////////////////////////////////////////////////////
// ScsiAdapter class
//
class DllInterface ScsiAdapter : public Adapter 
{
public:
	int getScsiId(); 

protected:
	// user access Adapter through getAdapter call
	ScsiAdapter( EAdapter eAdapter, const char *szName, int nScsiId );
	virtual void initializeAttributes();

private:
	int m_nScsiId;

	friend class Adapter;
};


} // end of ioReady namespace

#pragma pack( pop, ioReadyPack )

#endif // __iomegaReady_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\common\serialnumber\wnaspi32.h ===
#ifndef __WNASPI32_H__
#define __WNASPI32_H__

/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

//***************************************************************************
//
// Name: 	      WNASPI32.H
//
// Description:	ASPI for Win32 definitions ('C' Language)
//
//***************************************************************************

#ifdef __cplusplus
extern "C" {
#endif

typedef void *LPSRB;
typedef void (*PFNPOST)();

DWORD __cdecl SendASPI32Command    (LPSRB);
DWORD __cdecl GetASPI32SupportInfo (VOID);

#define SENSE_LEN					14			// Default sense buffer length
#define SRB_DIR_SCSI				0x00		// Direction determined by SCSI 															// command
#define SRB_DIR_IN					0x08		// Transfer from SCSI target to 															// host
#define SRB_DIR_OUT					0x10		// Transfer from host to SCSI 															// target
#define SRB_POSTING					0x01		// Enable ASPI posting
#define SRB_EVENT_NOTIFY            0x40        // Enable ASPI event notification
#define SRB_ENABLE_RESIDUAL_COUNT	0x04		// Enable residual byte count 															// reporting
#define SRB_DATA_SG_LIST			0x02		// Data buffer points to 																	// scatter-gather list
#define WM_ASPIPOST					0x4D42		// ASPI Post message
//***************************************************************************
//						 %%% ASPI Command Definitions %%%
//***************************************************************************
#define SC_HA_INQUIRY				0x00		// Host adapter inquiry
#define SC_GET_DEV_TYPE				0x01		// Get device type
#define SC_EXEC_SCSI_CMD			0x02		// Execute SCSI command
#define SC_ABORT_SRB				0x03		// Abort an SRB
#define SC_RESET_DEV				0x04		// SCSI bus device reset
#define SC_GET_DISK_INFO			0x06		// Get Disk information

//***************************************************************************
//								  %%% SRB Status %%%
//***************************************************************************
#define SS_PENDING			0x00		// SRB being processed
#define SS_COMP				0x01		// SRB completed without error
#define SS_ABORTED			0x02		// SRB aborted
#define SS_ABORT_FAIL		0x03		// Unable to abort SRB
#define SS_ERR 				0x04		// SRB completed with error

#define SS_INVALID_CMD		0x80		// Invalid ASPI command
#define SS_INVALID_HA		0x81		// Invalid host adapter number
#define SS_NO_DEVICE		0x82		// SCSI device not installed
							
#define SS_INVALID_SRB		0xE0		// Invalid parameter set in SRB
#define SS_FAILED_INIT		0xE4		// ASPI for windows failed init
#define SS_ASPI_IS_BUSY		0xE5		// No resources available to execute cmd
#define SS_BUFFER_TO_BIG	0xE6		// Buffer size to big to handle!

//***************************************************************************
//							%%% Host Adapter Status %%%
//***************************************************************************
#define HASTAT_OK					0x00	// Host adapter did not detect an 															// error
#define HASTAT_SEL_TO				0x11	// Selection Timeout
#define HASTAT_DO_DU				0x12	// Data overrun data underrun
#define HASTAT_BUS_FREE				0x13	// Unexpected bus free
#define HASTAT_PHASE_ERR			0x14	// Target bus phase sequence 																// failure
#define HASTAT_TIMEOUT				0x09	// Timed out while SRB was 																	waiting to beprocessed.
#define HASTAT_COMMAND_TIMEOUT 		0x0B	// While processing the SRB, the
															// adapter timed out.
#define HASTAT_MESSAGE_REJECT		0x0D	// While processing SRB, the 																// adapter received a MESSAGE 															// REJECT.
#define HASTAT_BUS_RESET			0x0E	// A bus reset was detected.
#define HASTAT_PARITY_ERROR			0x0F	// A parity error was detected.
#define HASTAT_REQUEST_SENSE_FAILED	0x10	// The adapter failed in issuing
														//   REQUEST SENSE.

//***************************************************************************
//			 %%% SRB - HOST ADAPTER INQUIRY - SC_HA_INQUIRY %%%
//***************************************************************************
typedef struct {
	BYTE	SRB_Cmd;				// ASPI command code = SC_HA_INQUIRY
	BYTE	SRB_Status;				// ASPI command status byte
	BYTE	SRB_HaId;				// ASPI host adapter number
	BYTE	SRB_Flags;				// ASPI request flags
	DWORD	SRB_Hdr_Rsvd;			// Reserved, MUST = 0
	BYTE	HA_Count;				// Number of host adapters present
	BYTE	HA_SCSI_ID;				// SCSI ID of host adapter
	BYTE	HA_ManagerId[16];		// String describing the manager
	BYTE	HA_Identifier[16];		// String describing the host adapter
	BYTE	HA_Unique[16];			// Host Adapter Unique parameters
	WORD	HA_Rsvd1;

} SRB_HAInquiry, *PSRB_HAInquiry;

//***************************************************************************
//			  %%% SRB - GET DEVICE TYPE - SC_GET_DEV_TYPE %%%
//***************************************************************************
typedef struct {

	BYTE	SRB_Cmd;				// ASPI command code = SC_GET_DEV_TYPE
	BYTE	SRB_Status;				// ASPI command status byte
	BYTE	SRB_HaId;				// ASPI host adapter number
	BYTE	SRB_Flags;				// Reserved
	DWORD	SRB_Hdr_Rsvd;			// Reserved
	BYTE	SRB_Target;				// Target's SCSI ID
	BYTE	SRB_Lun;				// Target's LUN number
	BYTE	SRB_DeviceType;			// Target's peripheral device type
	BYTE	SRB_Rsvd1;

} SRB_GDEVBlock, *PSRB_GDEVBlock;

//***************************************************************************
//		  %%% SRB - EXECUTE SCSI COMMAND - SC_EXEC_SCSI_CMD %%%
//***************************************************************************

typedef struct {
	BYTE	SRB_Cmd;				// ASPI command code = SC_EXEC_SCSI_CMD
	BYTE	SRB_Status;				// ASPI command status byte
	BYTE	SRB_HaId;				// ASPI host adapter number
	BYTE	SRB_Flags;				// ASPI request flags
	DWORD	SRB_Hdr_Rsvd;			// Reserved
	BYTE	SRB_Target;				// Target's SCSI ID
	BYTE	SRB_Lun;				// Target's LUN number
	WORD 	SRB_Rsvd1;				// Reserved for Alignment
	DWORD	SRB_BufLen;				// Data Allocation Length
	BYTE	*SRB_BufPointer;		// Data Buffer Pointer
	BYTE	SRB_SenseLen;			// Sense Allocation Length 	
	BYTE	SRB_CDBLen;				// CDB Length
	BYTE	SRB_HaStat;				// Host Adapter Status
	BYTE	SRB_TargStat;			// Target Status
	void	*SRB_PostProc;			// Post routine
	void	*SRB_Rsvd2;				// Reserved
	BYTE	SRB_Rsvd3[16];			// Reserved for alignment
	BYTE	CDBByte[16];			// SCSI CDB
	BYTE	SenseArea[SENSE_LEN+2];	// Request Sense buffer

} SRB_ExecSCSICmd, *PSRB_ExecSCSICmd;

//***************************************************************************
//				  %%% SRB - ABORT AN SRB - SC_ABORT_SRB %%%
//***************************************************************************
typedef struct {

	BYTE	SRB_Cmd;				// ASPI command code = SC_EXEC_SCSI_CMD
	BYTE	SRB_Status;				// ASPI command status byte
	BYTE	SRB_HaId;				// ASPI host adapter number
	BYTE	SRB_Flags;				// Reserved
	DWORD	SRB_Hdr_Rsvd;			// Reserved
	void	*SRB_ToAbort;			// Pointer to SRB to abort

} SRB_Abort, *PSRB_Abort;

//***************************************************************************
//				%%% SRB - BUS DEVICE RESET - SC_RESET_DEV %%%
//***************************************************************************
typedef struct {

	BYTE	SRB_Cmd;				// ASPI command code = SC_EXEC_SCSI_CMD
	BYTE	SRB_Status;				// ASPI command status byte
	BYTE	SRB_HaId;				// ASPI host adapter number
	BYTE	SRB_Flags;				// Reserved
	DWORD	SRB_Hdr_Rsvd;			// Reserved
	BYTE	SRB_Target;				// Target's SCSI ID
	BYTE	SRB_Lun;				// Target's LUN number
	BYTE 	SRB_Rsvd1[12];			// Reserved for Alignment
	BYTE	SRB_HaStat;				// Host Adapter Status
	BYTE	SRB_TargStat;			// Target Status
	void 	*SRB_PostProc;			// Post routine
	void	*SRB_Rsvd2;				// Reserved
	BYTE	SRB_Rsvd3[16];			// Reserved
	BYTE	CDBByte[16];			// SCSI CDB

} SRB_BusDeviceReset, *PSRB_BusDeviceReset;

//***************************************************************************
//				%%% SRB - GET DISK INFORMATION - SC_GET_DISK_INFO %%%
//***************************************************************************
typedef struct {

	BYTE	SRB_Cmd;				// ASPI command code = SC_EXEC_SCSI_CMD
	BYTE	SRB_Status;				// ASPI command status byte
	BYTE	SRB_HaId;				// ASPI host adapter number
	BYTE	SRB_Flags;				// Reserved
	DWORD	SRB_Hdr_Rsvd;			// Reserved
	BYTE	SRB_Target;				// Target's SCSI ID
	BYTE	SRB_Lun;				// Target's LUN number
	BYTE 	SRB_DriveFlags;			// Driver flags
	BYTE	SRB_Int13HDriveInfo;	// Host Adapter Status
	BYTE	SRB_Heads;				// Preferred number of heads translation
	BYTE	SRB_Sectors;			// Preferred number of sectors translation
	BYTE	SRB_Rsvd1[10];			// Reserved
} SRB_GetDiskInfo, *PSRB_GetDiskInfo;


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\common\serialnumber\spti.h ===
typedef struct _SCSI_PASS_THROUGH_WITH_BUFFERS {
    SCSI_PASS_THROUGH spt;
    ULONG             Filler;      // realign buffers to double word boundary
    UCHAR             ucSenseBuf[32];
    UCHAR             ucDataBuf[512];
    } SCSI_PASS_THROUGH_WITH_BUFFERS, *PSCSI_PASS_THROUGH_WITH_BUFFERS;

typedef struct _SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER {
    SCSI_PASS_THROUGH_DIRECT sptd;
    ULONG             Filler;      // realign buffer to double word boundary
    UCHAR             ucSenseBuf[32];
    } SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER, *PSCSI_PASS_THROUGH_DIRECT_WITH_BUFFER;

VOID
PrintError(ULONG);

VOID
PrintDataBuffer(PUCHAR, ULONG);

VOID
PrintInquiryData(PCHAR /*PVOID*/);

PUCHAR
AllocateAlignedBuffer(ULONG, ULONG);

VOID
PrintStatusResults(BOOLEAN, DWORD, PSCSI_PASS_THROUGH_WITH_BUFFERS, ULONG);

VOID
PrintSenseInfo(PSCSI_PASS_THROUGH_WITH_BUFFERS);

//
// Command Descriptor Block constants.
//

#define CDB6GENERIC_LENGTH                   6
#define CDB10GENERIC_LENGTH                  10
#define CDB12GENERIC_LENGTH                  12

#define SENSE_BUFFER_SIZE                   18

#define SETBITON                             1
#define SETBITOFF                            0
//
// Mode Sense/Select page constants.
//

#define MODE_PAGE_ERROR_RECOVERY        0x01
#define MODE_PAGE_DISCONNECT            0x02
#define MODE_PAGE_FORMAT_DEVICE         0x03
#define MODE_PAGE_RIGID_GEOMETRY        0x04
#define MODE_PAGE_FLEXIBILE             0x05
#define MODE_PAGE_VERIFY_ERROR          0x07
#define MODE_PAGE_CACHING               0x08
#define MODE_PAGE_PERIPHERAL            0x09
#define MODE_PAGE_CONTROL               0x0A
#define MODE_PAGE_MEDIUM_TYPES          0x0B
#define MODE_PAGE_NOTCH_PARTITION       0x0C
#define MODE_SENSE_RETURN_ALL           0x3f
#define MODE_SENSE_CURRENT_VALUES       0x00
#define MODE_SENSE_CHANGEABLE_VALUES    0x40
#define MODE_SENSE_DEFAULT_VAULES       0x80
#define MODE_SENSE_SAVED_VALUES         0xc0
#define MODE_PAGE_DEVICE_CONFIG         0x10
#define MODE_PAGE_MEDIUM_PARTITION      0x11
#define MODE_PAGE_DATA_COMPRESS         0x0f

//
// SCSI CDB operation codes
//

#define SCSIOP_TEST_UNIT_READY     0x00
#define SCSIOP_REZERO_UNIT         0x01
#define SCSIOP_REWIND              0x01
#define SCSIOP_REQUEST_BLOCK_ADDR  0x02
#define SCSIOP_REQUEST_SENSE       0x03
#define SCSIOP_FORMAT_UNIT         0x04
#define SCSIOP_READ_BLOCK_LIMITS   0x05
#define SCSIOP_REASSIGN_BLOCKS     0x07
#define SCSIOP_READ6               0x08
#define SCSIOP_RECEIVE             0x08
#define SCSIOP_WRITE6              0x0A
#define SCSIOP_PRINT               0x0A
#define SCSIOP_SEND                0x0A
#define SCSIOP_SEEK6               0x0B
#define SCSIOP_TRACK_SELECT        0x0B
#define SCSIOP_SLEW_PRINT          0x0B
#define SCSIOP_SEEK_BLOCK          0x0C
#define SCSIOP_PARTITION           0x0D
#define SCSIOP_READ_REVERSE        0x0F
#define SCSIOP_WRITE_FILEMARKS     0x10
#define SCSIOP_FLUSH_BUFFER        0x10
#define SCSIOP_SPACE               0x11
#define SCSIOP_INQUIRY             0x12
#define SCSIOP_VERIFY6             0x13
#define SCSIOP_RECOVER_BUF_DATA    0x14
#define SCSIOP_MODE_SELECT         0x15
#define SCSIOP_RESERVE_UNIT        0x16
#define SCSIOP_RELEASE_UNIT        0x17
#define SCSIOP_COPY                0x18
#define SCSIOP_ERASE               0x19
#define SCSIOP_MODE_SENSE          0x1A
#define SCSIOP_START_STOP_UNIT     0x1B
#define SCSIOP_STOP_PRINT          0x1B
#define SCSIOP_LOAD_UNLOAD         0x1B
#define SCSIOP_RECEIVE_DIAGNOSTIC  0x1C
#define SCSIOP_SEND_DIAGNOSTIC     0x1D
#define SCSIOP_MEDIUM_REMOVAL      0x1E
#define SCSIOP_READ_CAPACITY       0x25
#define SCSIOP_READ                0x28
#define SCSIOP_WRITE               0x2A
#define SCSIOP_SEEK                0x2B
#define SCSIOP_LOCATE              0x2B
#define SCSIOP_WRITE_VERIFY        0x2E
#define SCSIOP_VERIFY              0x2F
#define SCSIOP_SEARCH_DATA_HIGH    0x30
#define SCSIOP_SEARCH_DATA_EQUAL   0x31
#define SCSIOP_SEARCH_DATA_LOW     0x32
#define SCSIOP_SET_LIMITS          0x33
#define SCSIOP_READ_POSITION       0x34
#define SCSIOP_SYNCHRONIZE_CACHE   0x35
#define SCSIOP_COMPARE             0x39
#define SCSIOP_COPY_COMPARE        0x3A
#define SCSIOP_WRITE_DATA_BUFF     0x3B
#define SCSIOP_READ_DATA_BUFF      0x3C
#define SCSIOP_CHANGE_DEFINITION   0x40
#define SCSIOP_READ_SUB_CHANNEL    0x42
#define SCSIOP_READ_TOC            0x43
#define SCSIOP_READ_HEADER         0x44
#define SCSIOP_PLAY_AUDIO          0x45
#define SCSIOP_PLAY_AUDIO_MSF      0x47
#define SCSIOP_PLAY_TRACK_INDEX    0x48
#define SCSIOP_PLAY_TRACK_RELATIVE 0x49
#define SCSIOP_PAUSE_RESUME        0x4B
#define SCSIOP_LOG_SELECT          0x4C
#define SCSIOP_LOG_SENSE           0x4D
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\common\wmdmutil\wmdmrevoked.cpp ===
// RevokedUtil.cpp : Implementation of WMDMUtil library

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <oleAuto.h>

#include <WMDMUtil.h>


// BUGBUG Update this to the revocation site after the issues are resolved.
#define REVOCATION_UPDATE_URL   L"http://www.microsoft.com/isapi/redir.dll?prd=wmdm&pver=7&os=win"

#define MAX_PARAMETERLEN    sizeof(L"&SubjectID0=4294967295")
#define MAX_LCIDLEN         sizeof(L"&LCID=4294967295")


#ifdef _M_IX86

// Get the subject id out of an APPCERT
DWORD GetSubjectIDFromAppCert( IN APPCERT appcert )
{
    DWORD   dwSubjectID;
    BYTE* pSubjectID = appcert.appcd.subject;
    
    dwSubjectID =   pSubjectID[3]  
                  + pSubjectID[2] * 0x100
                  + pSubjectID[1] * 0x10000
                  + pSubjectID[0] * 0x1000000;

    return dwSubjectID;
}
#endif

// Is this URL pointing to the Microsoft Revocatoin update server?
BOOL IsMicrosoftRevocationURL( LPWSTR pszRevocationURL )
{
    HRESULT hr = S_FALSE;
    BOOL    bMSUrl = FALSE;
    int     iBaseURLChars =  (sizeof( REVOCATION_UPDATE_URL ) / sizeof(WCHAR)) -1;

    // Does the URL start with the MS base URL?
    if( pszRevocationURL && wcsncmp( REVOCATION_UPDATE_URL, pszRevocationURL, iBaseURLChars ) == 0 )
    {
        bMSUrl = TRUE;
    }
        
    return bMSUrl;
}



// Max posible length of update URL
#define MAX_UPDATE_URL_LENGHT   sizeof(REVOCATION_UPDATE_URL) + 3*MAX_PARAMETERLEN + MAX_LCIDLEN


// Build the revocation update URL from base URL + SubjectID's as parameters
// Revoked subject id's are passed in in an NULL-terminated array
HRESULT BuildRevocationURL(IN DWORD* pdwSubjectIDs, 
                           IN OUT LPWSTR*  ppwszRevocationURL, 
                           IN OUT DWORD*   pdwBufferLen )    // Length in wchars of buffer (including 0 term)
{
    HRESULT hr = S_OK;
    WCHAR  pszOutURL[MAX_UPDATE_URL_LENGHT];
    int iStrPos = 0;             // Were are we at in the string
    int iSubjectIDIndex = 0;     // Looping throw all SubjectID's in the pdwSubjectIDs array
    
    if( ppwszRevocationURL == NULL || pdwBufferLen == NULL ) 
    {
        hr = E_POINTER;
        goto Error;
    }

    // Start creating the string by writing the base URL
    wcscpy( pszOutURL, REVOCATION_UPDATE_URL );
    iStrPos = (sizeof(REVOCATION_UPDATE_URL) /sizeof(WCHAR)) -1;

    // Add all subject id's as parameters to the URL
    for( iSubjectIDIndex = 0; pdwSubjectIDs[iSubjectIDIndex]; iSubjectIDIndex ++ )
    {
        int iCharsWritten;

        // Add subject id as parameter to URL
        iCharsWritten = swprintf( pszOutURL + iStrPos, L"&SubjectID%d=%d", 
                                  iSubjectIDIndex,
                                  pdwSubjectIDs[iSubjectIDIndex] );
        iStrPos += iCharsWritten;
    }

    // Add LCID parameter to specify UI/component default language.
    {
        int iCharsWritten;
        DWORD   dwLCID;

        dwLCID = (DWORD)GetSystemDefaultLCID();
        iCharsWritten = swprintf( pszOutURL + iStrPos, L"&LCID=%d", dwLCID );
        iStrPos += iCharsWritten;
    }


    // Do we need to reallocate the string buffer passed in?
    if( *pdwBufferLen < (DWORD)(iStrPos +1))
    {
        // Allocate bigger buffer
        *pdwBufferLen = (iStrPos +1);

        CoTaskMemFree( *ppwszRevocationURL );
        *ppwszRevocationURL = (LPWSTR)CoTaskMemAlloc( (iStrPos+1)*sizeof(WCHAR) );
        if( *ppwszRevocationURL == NULL )
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        }
    }        

    // Copy string into buffer
    wcscpy( *ppwszRevocationURL, pszOutURL );

Error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\dependencies\cesdk\include\rapi.h ===
// --------------------------------------------------------------------------
//
// Copyright (c) 1995-1997, Microsoft Corporation
//
// Module:
//
//     rapi.h
//
// Purpose:
//
//    Master include file for Windows CE Remote API
//
// --------------------------------------------------------------------------

#ifndef RAPI_H
#define RAPI_H

#include <windows.h>

//
// The Windows CE WIN32_FIND_DATA structure differs from the
// Windows WIN32_FIND_DATA stucture so we copy the Windows CE
// definition to here so that both sides match.
//
typedef struct _CE_FIND_DATA {
    DWORD    dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD    nFileSizeHigh;
    DWORD    nFileSizeLow;
    DWORD    dwOID;
    WCHAR    cFileName[MAX_PATH];
} CE_FIND_DATA, *LPCE_FIND_DATA;

typedef CE_FIND_DATA** LPLPCE_FIND_DATA;

//
// These are flags for CeFindAllFiles
//
#define FAF_ATTRIBUTES      ((DWORD) 0x01)
#define FAF_CREATION_TIME   ((DWORD) 0x02)
#define FAF_LASTACCESS_TIME ((DWORD) 0x04)
#define FAF_LASTWRITE_TIME  ((DWORD) 0x08)
#define FAF_SIZE_HIGH       ((DWORD) 0x10)
#define FAF_SIZE_LOW        ((DWORD) 0x20)
#define FAF_OID             ((DWORD) 0x40)
#define FAF_NAME            ((DWORD) 0x80)
#define FAF_FLAG_COUNT      ((UINT)  8)
#define FAF_ATTRIB_CHILDREN ((DWORD)			0x01000)
#define FAF_ATTRIB_NO_HIDDEN ((DWORD)			0x02000)
#define FAF_FOLDERS_ONLY    ((DWORD)			0x04000)
#define FAF_NO_HIDDEN_SYS_ROMMODULES ((DWORD)	0x08000)
#define FAF_GETTARGET	    ((DWORD)			0x10000)

#define FAD_OID             ((WORD) 0x01)
#define FAD_FLAGS           ((WORD) 0x02)
#define FAD_NAME            ((WORD) 0x04)
#define FAD_TYPE            ((WORD) 0x08)
#define FAD_NUM_RECORDS     ((WORD) 0x10)
#define FAD_NUM_SORT_ORDER  ((WORD) 0x20)
#define FAD_SIZE            ((WORD) 0x40)
#define FAD_LAST_MODIFIED   ((WORD) 0x80)
#define FAD_SORT_SPECS      ((WORD) 0x100)
#define FAD_FLAG_COUNT      ((UINT) 9)

#ifndef FILE_ATTRIBUTE_INROM
#define FILE_ATTRIBUTE_INROM        0x00000040
#endif
#ifndef FILE_ATTRIBUTE_ROMSTATICREF
#define FILE_ATTRIBUTE_ROMSTATICREF 0x00001000
#endif
#ifndef FILE_ATTRIBUTE_ROMMODULE
#define FILE_ATTRIBUTE_ROMMODULE    0x00002000
#endif

//
// The following is not a standard Windows CE File Attribute.
//
#ifndef FILE_ATTRIBUTE_HAS_CHILDREN
#define FILE_ATTRIBUTE_HAS_CHILDREN 0x00010000
#endif
#ifndef FILE_ATTRIBUTE_SHORTCUT
#define FILE_ATTRIBUTE_SHORTCUT		0x00020000
#endif

#undef  INTERFACE
#define INTERFACE   IRAPIStream

typedef enum tagRAPISTREAMFLAG
{
	STREAM_TIMEOUT_READ
} RAPISTREAMFLAG;

DECLARE_INTERFACE_ (IRAPIStream,  IStream)
{
		STDMETHOD(SetRapiStat)( THIS_ RAPISTREAMFLAG Flag, DWORD dwValue) PURE;
		STDMETHOD(GetRapiStat)( THIS_ RAPISTREAMFLAG Flag, DWORD *pdwValue) PURE;
};

// RAPI extension on Windows CE (e.g., MyFunctionFOO) called via CeRapiInvoke should be declared as:
// EXTERN_C RAPIEXT MyFunctionFOO;
typedef  HRESULT (STDAPICALLTYPE RAPIEXT)(
		 DWORD			cbInput,			// [IN]
		 BYTE			*pInput,			// [IN]
		 DWORD			*pcbOutput,	 		// [OUT]
		 BYTE			**ppOutput,			// [OUT]
		 IRAPIStream	*pIRAPIStream		// [IN]
		 );

//
// The following definitions are for the client side only,
// because they are already defined on Windows CE.
//
#ifndef UNDER_CE

#include <stddef.h>

typedef struct STORE_INFORMATION {
	DWORD dwStoreSize;
	DWORD dwFreeSize;
} STORE_INFORMATION, *LPSTORE_INFORMATION;

typedef DWORD CEPROPID;
typedef CEPROPID *PCEPROPID;
#define TypeFromPropID(propid) LOWORD(propid)

typedef DWORD CEOID;
typedef CEOID *PCEOID;

typedef struct  _CEGUID {
    DWORD Data1;
	DWORD Data2;
	DWORD Data3;
	DWORD Data4;
}	CEGUID;
typedef CEGUID *PCEGUID;

typedef struct _CENOTIFICATION {
	DWORD dwSize;
	DWORD dwParam;
	UINT  uType;
	CEGUID guid;
	CEOID  oid;
	CEOID  oidParent;
} CENOTIFICATION;

#define CEDB_EXNOTIFICATION	0x00000001
typedef struct _CENOTIFYREQUEST {
    DWORD dwSize;
    HWND  hwnd;
    DWORD dwFlags;
    HANDLE hHeap;
	DWORD  dwParam;
} CENOTIFYREQUEST;
typedef CENOTIFYREQUEST *PCENOTIFYREQUEST;

typedef struct _CEFILEINFO {
    DWORD   dwAttributes;
    CEOID   oidParent;
    WCHAR   szFileName[MAX_PATH];
    FILETIME ftLastChanged;
    DWORD   dwLength;
} CEFILEINFO;

typedef struct _CEDIRINFO {
    DWORD   dwAttributes;
    CEOID   oidParent;
    WCHAR   szDirName[MAX_PATH];
} CEDIRINFO;

typedef struct _CERECORDINFO {
    CEOID  oidParent;
} CERECORDINFO;

#define CEDB_SORT_DESCENDING        0x00000001
#define CEDB_SORT_CASEINSENSITIVE   0x00000002
#define CEDB_SORT_UNKNOWNFIRST      0x00000004
#define CEDB_SORT_GENERICORDER      0x00000008

typedef struct _SORTORDERSPEC {
    CEPROPID  propid;
    DWORD     dwFlags;
} SORTORDERSPEC;

#define CEDB_MAXDBASENAMELEN  32
#define CEDB_MAXSORTORDER     4

#define CEDB_VALIDNAME      0x0001
#define CEDB_VALIDTYPE      0x0002
#define CEDB_VALIDSORTSPEC  0x0004
#define CEDB_VALIDMODTIME   0x0008
#define CEDB_VALIDDBFLAGS   0x0010
#define CEDB_VALIDCREATE (CEDB_VALIDNAME|CEDB_VALIDTYPE|CEDB_VALIDSORTSPEC|CEDB_VALIDDBFLAGS)

#define CEDB_NOCOMPRESS     0x00010000

typedef struct _CEDBASEINFO {
    DWORD   dwFlags;
    WCHAR   szDbaseName[CEDB_MAXDBASENAMELEN];
    DWORD   dwDbaseType;
    WORD    wNumRecords;
    WORD    wNumSortOrder;
    DWORD   dwSize;
    FILETIME ftLastModified;
    SORTORDERSPEC rgSortSpecs[CEDB_MAXSORTORDER];
} CEDBASEINFO;

typedef struct _CEDB_FIND_DATA {
    CEOID       OidDb;
    CEDBASEINFO DbInfo;
} CEDB_FIND_DATA, *LPCEDB_FIND_DATA;

typedef CEDB_FIND_DATA ** LPLPCEDB_FIND_DATA;

#define OBJTYPE_INVALID     0
#define OBJTYPE_FILE        1
#define OBJTYPE_DIRECTORY   2
#define OBJTYPE_DATABASE    3
#define OBJTYPE_RECORD      4

typedef struct _CEOIDINFO {
    WORD  wObjType;
    WORD  wPad;
    union {
        CEFILEINFO   infFile;
        CEDIRINFO    infDirectory;
        CEDBASEINFO  infDatabase;
        CERECORDINFO infRecord;
    };
} CEOIDINFO;

#define CEDB_AUTOINCREMENT      0x00000001

#define CEDB_SEEK_CEOID         0x00000001
#define CEDB_SEEK_BEGINNING     0x00000002
#define CEDB_SEEK_END           0x00000004
#define CEDB_SEEK_CURRENT       0x00000008
#define CEDB_SEEK_VALUESMALLER     0x00000010
#define CEDB_SEEK_VALUEFIRSTEQUAL  0x00000020
#define CEDB_SEEK_VALUEGREATER     0x00000040
#define CEDB_SEEK_VALUENEXTEQUAL   0x00000080

typedef struct _CEBLOB {
    DWORD       dwCount;
    LPBYTE      lpb;
} CEBLOB;

#define CEVT_I2       2
#define CEVT_UI2      18
#define CEVT_I4       3
#define CEVT_UI4      19
#define CEVT_FILETIME 64
#define CEVT_LPWSTR   31
#define CEVT_BLOB     65
#define CEVT_BOOL     11
#define	CEVT_R8       5

typedef union _CEVALUNION {
    short           iVal;
    USHORT          uiVal;
    long            lVal;
    ULONG           ulVal;
    FILETIME        filetime;
    LPWSTR          lpwstr;
    CEBLOB          blob;
    BOOL            boolVal;
    double          dblVal;
} CEVALUNION;
 
#define CEDB_PROPNOTFOUND 0x0100
#define CEDB_PROPDELETE   0x0200
typedef struct _CEPROPVAL {
    CEPROPID    propid;
    WORD        wLenData;
    WORD        wFlags;
    CEVALUNION  val;
} CEPROPVAL, *PCEPROPVAL;

#define CEDB_MAXDATABLOCKSIZE  4092
#define CEDB_MAXPROPDATASIZE   (CEDB_MAXDATABLOCKSIZE*16)
#define CEDB_MAXRECORDSIZE     (128*1024)

#define CEDB_ALLOWREALLOC  0x00000001

#define CREATE_SYSTEMGUID(pguid) (memset((pguid), 0, sizeof(CEGUID)))
#define CREATE_INVALIDGUID(pguid) (memset((pguid), -1, sizeof(CEGUID)))

#define CHECK_SYSTEMGUID(pguid) !((pguid)->Data1|(pguid)->Data2|(pguid)->Data3|(pguid)->Data4)
#define CHECK_INVALIDGUID(pguid) !~((pguid)->Data1&(pguid)->Data2&(pguid)->Data3&(pguid)->Data4)

#define SYSMEM_CHANGED	0
#define SYSMEM_MUSTREBOOT 1
#define SYSMEM_REBOOTPENDING 2
#define SYSMEM_FAILED 3

typedef struct _CEOSVERSIONINFO{
    DWORD dwOSVersionInfoSize; 
    DWORD dwMajorVersion; 
    DWORD dwMinorVersion; 
    DWORD dwBuildNumber; 
    DWORD dwPlatformId; 
    WCHAR szCSDVersion[ 128 ]; 
} CEOSVERSIONINFO, *LPCEOSVERSIONINFO;

#define AC_LINE_OFFLINE                 0x00
#define AC_LINE_ONLINE                  0x01
#define AC_LINE_BACKUP_POWER            0x02
#define AC_LINE_UNKNOWN                 0xFF

#define BATTERY_FLAG_HIGH               0x01
#define BATTERY_FLAG_LOW                0x02
#define BATTERY_FLAG_CRITICAL           0x04
#define BATTERY_FLAG_CHARGING           0x08
#define BATTERY_FLAG_NO_BATTERY         0x80
#define BATTERY_FLAG_UNKNOWN            0xFF

#define BATTERY_PERCENTAGE_UNKNOWN      0xFF

#define BATTERY_LIFE_UNKNOWN        0xFFFFFFFF

typedef struct _SYSTEM_POWER_STATUS_EX {
    BYTE ACLineStatus;
    BYTE BatteryFlag;
    BYTE BatteryLifePercent;
    BYTE Reserved1;
    DWORD BatteryLifeTime;
    DWORD BatteryFullLifeTime;
    BYTE Reserved2;
    BYTE BackupBatteryFlag;
    BYTE BackupBatteryLifePercent;
    BYTE Reserved3;
    DWORD BackupBatteryLifeTime;
    DWORD BackupBatteryFullLifeTime;
}   SYSTEM_POWER_STATUS_EX, *PSYSTEM_POWER_STATUS_EX, *LPSYSTEM_POWER_STATUS_EX;

//
// MessageId: CERAPI_E_ALREADYINITIALIZED
//
//  CeRapiInit(Ex) has already been successfully called
//
#define CERAPI_E_ALREADYINITIALIZED     0x80041001

typedef struct _RAPIINIT
{
    DWORD cbSize;
    HANDLE heRapiInit;
    HRESULT hrRapiInit;
} RAPIINIT;

STDAPI CeRapiInitEx(RAPIINIT*);
STDAPI CeRapiInit();
STDAPI CeRapiUninit();
STDAPI CeRapiGetError(void);
STDAPI CeRapiFreeBuffer(LPVOID);
STDAPI_( HRESULT ) CeRapiInvoke(LPCWSTR, LPCWSTR,DWORD,BYTE *, DWORD *,BYTE **, IRAPIStream **,DWORD);

STDAPI_(CEOID)  CeCreateDatabase     (LPWSTR, DWORD, WORD, SORTORDERSPEC*);
STDAPI_(BOOL  ) CeDeleteDatabase     (CEOID);
STDAPI_(BOOL  ) CeDeleteRecord       (HANDLE, CEOID);
STDAPI_(HANDLE) CeFindFirstDatabase  (DWORD);
STDAPI_(CEOID)  CeFindNextDatabase    (HANDLE);
STDAPI_(BOOL  ) CeOidGetInfo         (CEOID, CEOIDINFO*);
STDAPI_(HANDLE) CeOpenDatabase       (PCEOID, LPWSTR, CEPROPID, DWORD, HWND);
STDAPI_(CEOID)  CeReadRecordProps    (HANDLE, DWORD, LPWORD, CEPROPID*, LPBYTE*, LPDWORD);
STDAPI_(CEOID)  CeSeekDatabase       (HANDLE, DWORD, DWORD, LPDWORD);
STDAPI_(BOOL  ) CeSetDatabaseInfo    (CEOID, CEDBASEINFO*);
STDAPI_(CEOID)  CeWriteRecordProps   (HANDLE, CEOID, WORD, CEPROPVAL*);
STDAPI_(HANDLE) CeFindFirstFile      (LPCWSTR, LPCE_FIND_DATA);
STDAPI_(BOOL  ) CeFindNextFile       (HANDLE, LPCE_FIND_DATA);
STDAPI_(BOOL  ) CeFindClose          (HANDLE);
STDAPI_(DWORD ) CeGetFileAttributes  (LPCWSTR);
STDAPI_(BOOL  ) CeSetFileAttributes  (LPCWSTR, DWORD);
STDAPI_(HANDLE) CeCreateFile         (LPCWSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES, DWORD, DWORD, HANDLE);
STDAPI_(BOOL  ) CeReadFile           (HANDLE, LPVOID, DWORD, LPDWORD, LPOVERLAPPED);
STDAPI_(BOOL  ) CeWriteFile          (HANDLE, LPCVOID, DWORD, LPDWORD, LPOVERLAPPED);
STDAPI_(BOOL  ) CeCloseHandle        (HANDLE);
STDAPI_(BOOL  ) CeFindAllFiles       (LPCWSTR, DWORD, LPDWORD, LPLPCE_FIND_DATA);
STDAPI_(BOOL  ) CeFindAllDatabases   (DWORD, WORD, LPWORD, LPLPCEDB_FIND_DATA);
STDAPI_(DWORD ) CeGetLastError       (void);
STDAPI_(DWORD ) CeSetFilePointer     (HANDLE, LONG, PLONG, DWORD);
STDAPI_(BOOL  ) CeSetEndOfFile       (HANDLE);
STDAPI_(BOOL  ) CeCreateDirectory    (LPCWSTR, LPSECURITY_ATTRIBUTES);
STDAPI_(BOOL  ) CeRemoveDirectory    (LPCWSTR);
STDAPI_(BOOL  ) CeCreateProcess      (LPCWSTR, LPCWSTR, LPSECURITY_ATTRIBUTES, LPSECURITY_ATTRIBUTES, BOOL, DWORD, LPVOID, LPWSTR, LPSTARTUPINFO, LPPROCESS_INFORMATION);
STDAPI_(BOOL  ) CeMoveFile           (LPCWSTR, LPCWSTR);
STDAPI_(BOOL  ) CeCopyFile           (LPCWSTR, LPCWSTR, BOOL);
STDAPI_(BOOL  ) CeDeleteFile         (LPCWSTR);
STDAPI_(DWORD ) CeGetFileSize        (HANDLE, LPDWORD);
STDAPI_(LONG  ) CeRegOpenKeyEx       (HKEY, LPCWSTR, DWORD, REGSAM, PHKEY);
STDAPI_(LONG  ) CeRegEnumKeyEx       (HKEY, DWORD, LPWSTR, LPDWORD, LPDWORD, LPWSTR, LPDWORD, PFILETIME);
STDAPI_(LONG  ) CeRegCreateKeyEx     (HKEY, LPCWSTR, DWORD, LPWSTR, DWORD, REGSAM, LPSECURITY_ATTRIBUTES, PHKEY, LPDWORD);
STDAPI_(LONG  ) CeRegCloseKey        (HKEY);
STDAPI_(LONG  ) CeRegDeleteKey       (HKEY, LPCWSTR);
STDAPI_(LONG  ) CeRegEnumValue       (HKEY, DWORD, LPWSTR, LPDWORD, LPDWORD, LPDWORD, LPBYTE, LPDWORD);
STDAPI_(LONG  ) CeRegDeleteValue     (HKEY, LPCWSTR);
STDAPI_(LONG  ) CeRegQueryInfoKey    (HKEY, LPWSTR, LPDWORD, LPDWORD, LPDWORD, LPDWORD, LPDWORD, LPDWORD, LPDWORD, LPDWORD, LPDWORD, PFILETIME);
STDAPI_(LONG  ) CeRegQueryValueEx    (HKEY, LPCWSTR, LPDWORD, LPDWORD, LPBYTE, LPDWORD);
STDAPI_(LONG  ) CeRegSetValueEx      (HKEY, LPCWSTR, DWORD, DWORD, LPBYTE, DWORD);
STDAPI_(BOOL  ) CeGetStoreInformation(LPSTORE_INFORMATION);
STDAPI_(INT   ) CeGetSystemMetrics   (INT);
STDAPI_(INT   ) CeGetDesktopDeviceCaps(INT);
STDAPI_(VOID  ) CeGetSystemInfo      (LPSYSTEM_INFO);
STDAPI_(DWORD ) CeSHCreateShortcut   (LPWSTR, LPWSTR);
STDAPI_(BOOL  ) CeSHGetShortcutTarget(LPWSTR, LPWSTR, INT);
STDAPI_(BOOL  ) CeCheckPassword      (LPWSTR);
STDAPI_(BOOL  ) CeGetFileTime        (HANDLE, LPFILETIME, LPFILETIME, LPFILETIME);
STDAPI_(BOOL  ) CeSetFileTime        (HANDLE, LPFILETIME, LPFILETIME, LPFILETIME);
STDAPI_(BOOL  ) CeGetVersionEx       (LPCEOSVERSIONINFO);
STDAPI_(HWND  ) CeGetWindow          (HWND, UINT);
STDAPI_(LONG  ) CeGetWindowLong      (HWND, int);
STDAPI_(int   ) CeGetWindowText      (HWND, LPWSTR, int);
STDAPI_(int   ) CeGetClassName       (HWND, LPWSTR, int);
STDAPI_(VOID  ) CeGlobalMemoryStatus (LPMEMORYSTATUS);
STDAPI_(BOOL  ) CeGetSystemPowerStatusEx(PSYSTEM_POWER_STATUS_EX, BOOL);
STDAPI_(DWORD ) CeGetTempPath        (DWORD, LPWSTR);
STDAPI_(DWORD ) CeGetSpecialFolderPath(int, DWORD, LPWSTR);
STDAPI_(HANDLE) CeFindFirstDatabaseEx (PCEGUID, DWORD);
STDAPI_(CEOID ) CeFindNextDatabaseEx (HANDLE, PCEGUID);
STDAPI_(CEOID ) CeCreateDatabaseEx   (PCEGUID, CEDBASEINFO*);
STDAPI_(BOOL  ) CeSetDatabaseInfoEx  (PCEGUID, CEOID, CEDBASEINFO*);
STDAPI_(HANDLE) CeOpenDatabaseEx     (PCEGUID, PCEOID, LPWSTR, CEPROPID, DWORD, CENOTIFYREQUEST *);
STDAPI_(BOOL  ) CeDeleteDatabaseEx   (PCEGUID, CEOID);
STDAPI_(CEOID ) CeReadRecordPropsEx  (HANDLE, DWORD, LPWORD, CEPROPID*, LPBYTE*, LPDWORD, HANDLE);
STDAPI_(CEOID ) CeWriteRecordProps   (HANDLE, CEOID, WORD, CEPROPVAL*);
STDAPI_(BOOL  ) CeMountDBVol         (PCEGUID, LPWSTR, DWORD);
STDAPI_(BOOL  ) CeUnmountDBVol       (PCEGUID);
STDAPI_(BOOL  ) CeFlushDBVol         (PCEGUID);
STDAPI_(BOOL  ) CeEnumDBVolumes      (PCEGUID, LPWSTR, DWORD);
STDAPI_(BOOL  ) CeOidGetInfoEx       (PCEGUID, CEOID, CEOIDINFO*);

#endif // #ifndef UNDER_CE

#include <ceapimap.h>

#ifdef CONN_INTERNAL
#include <prapi.h>  // internal defines
#endif

#endif // #ifndef RAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\dependencies\cesdk\include\dccole.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dccole.h

Abstract:

    This file defines the OLE interface to the DCCMAN module (Desktop Only)
    
Environment:

    User Mode - Win32

--*/

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

// {A7B88840-A812-11cf-8011-00A0C90A8F78}
DEFINE_GUID(IID_IDccManSink, 
0xa7b88840, 0xa812, 0x11cf, 0x80, 0x11, 0x0, 0xa0, 0xc9, 0xa, 0x8f, 0x78);
// {A7B88841-A812-11cf-8011-00A0C90A8F78}
DEFINE_GUID(IID_IDccMan, 
0xa7b88841, 0xa812, 0x11cf, 0x80, 0x11, 0x0, 0xa0, 0xc9, 0xa, 0x8f, 0x78);
// {499C0C20-A766-11cf-8011-00A0C90A8F78}
DEFINE_GUID(CLSID_DccMan, 
0x499c0c20, 0xa766, 0x11cf, 0x80, 0x11, 0x0, 0xa0, 0xc9, 0xa, 0x8f, 0x78);

#ifndef _DCCOLEH_
#define _DCCOLEH_

//============================== OLE INTERFACE ===================================

#undef  INTERFACE
#define INTERFACE   IDccManSink

DECLARE_INTERFACE_ (IDccManSink,  IUnknown)
{
 	// These methods corespond to GW_LOG messages generated by the Win95 DCC
    STDMETHOD(OnLogIpAddr) (THIS_ DWORD dwIpAddr) PURE;
    STDMETHOD(OnLogTerminated) (THIS) PURE;
    STDMETHOD(OnLogActive) (THIS) PURE;
	STDMETHOD(OnLogInactive) (THIS) PURE;
	STDMETHOD(OnLogAnswered) (THIS) PURE;
	STDMETHOD(OnLogListen) (THIS) PURE;
	STDMETHOD(OnLogDisconnection) (THIS) PURE;
	STDMETHOD(OnLogError) (THIS) PURE;
};
typedef IDccManSink *LPDCCMANSINK;

#undef  INTERFACE
#define INTERFACE   IDccMan

DECLARE_INTERFACE_ (IDccMan,  IUnknown)
{
    STDMETHOD(Advise) (THIS_
		IN	IDccManSink * pDccSink,	// The advise sink that is requesting notification
		OUT DWORD * pdwContext		// Identifies the context for future calls to the Unadvise method
	) PURE;
	
	STDMETHOD(Unadvise) (THIS_
		DWORD dwContext				// As returned by Advise()
	) PURE;
   
	STDMETHOD(ShowCommSettings) (THIS) PURE;	// Displays the Communication Property Sheet on the screen
												// If a connection is active, the sheet is in read-only mode
	STDMETHOD(AutoconnectEnable) (THIS) PURE;
	STDMETHOD(AutoconnectDisable) (THIS) PURE;

	STDMETHOD(ConnectNow) (THIS) PURE;			// Active only when Autoconnect is Disabled
	STDMETHOD(DisconnectNow) (THIS) PURE;		// Active only when Autoconnect is Disabled
	
	STDMETHOD(SetIconDataTransferring) (THIS) PURE;
	STDMETHOD(SetIconNoDataTransferring) (THIS) PURE;
	STDMETHOD(SetIconError) (THIS) PURE;
};
typedef IDccMan *LPDCCMAN;


#endif /* end, ifdef _DCCOLEH_  */

#ifdef __cplusplus
}
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\dependencies\cesdk\include\ceapimap.h ===
/*++

    Copyright (c) 1996 - 97 Microsoft Corporation
    
    File: ceapimap.h
    
    Abstract:
    
    Contents:  This file contains mappings for all the WinCE API names, 
               structures and constants to the new names.

               Eg. PEGOID -> CEOID
                   PegCreateDatabase -> CeCreateDatabase
    History:
    
        10/23/96   HareshV Created

--*/

#ifndef _CEAPIMAP_H
#define _CEAPIMAP_H

//
// Prop Ids for WinCE Properties:
//
typedef CEPROPID                    PEGPROPID;
typedef PEGPROPID                   *PPEGPROPID;

//
// Unique identifier for all WINCE objects
//
typedef CEOID                       PEGOID;
typedef PEGOID                      *PPEGOID;

//
// Structures:
//
#ifdef RAPI_H
typedef CE_FIND_DATA        PEG_FIND_DATA;
typedef LPCE_FIND_DATA      LPPEG_FIND_DATA;
typedef LPLPCE_FIND_DATA    LPLPPEG_FIND_DATA;

#ifndef UNDER_CE
typedef CEDB_FIND_DATA      PEGDB_FIND_DATA;
typedef LPCEDB_FIND_DATA    LPPEGDB_FIND_DATA;
typedef LPLPCEDB_FIND_DATA  LPLPPEGDB_FIND_DATA;
#endif
#endif

typedef CEFILEINFO                  PEGFILEINFO;
typedef PEGFILEINFO                 *PPEGFILEINFO;

typedef CEDIRINFO                   PEGDIRINFO;                  
typedef PEGDIRINFO                  *PPEGDIRINFO;                

typedef CERECORDINFO                PEGRECORDINFO;              
typedef PEGRECORDINFO               *PPEGRECORDINFO;             

#define PEGDB_SORT_DESCENDING       CEDB_SORT_DESCENDING
#define PEGDB_SORT_CASEINSENSITIVE  CEDB_SORT_CASEINSENSITIVE
#define PEGDB_SORT_UNKNOWNFIRST     CEDB_SORT_UNKNOWNFIRST
#define PEGDB_SORT_GENERICORDER     CEDB_SORT_GENERICORDER

#define PEGDB_MAXDBASENAMELEN       CEDB_MAXDBASENAMELEN
#define PEGDB_MAXSORTORDER          CEDB_MAXSORTORDER

//
// Values for flag:
//
#define PEGDB_VALIDNAME             CEDB_VALIDNAME
#define PEGDB_VALIDTYPE             CEDB_VALIDTYPE
#define PEGDB_VALIDSORTSPEC         CEDB_VALIDSORTSPEC
#define PEGDB_VALIDMODTIME          CEDB_VALIDMODTIME

typedef CEDBASEINFO                 PEGDBASEINFO; 
typedef PEGDBASEINFO                *PPEGDBASEINFO;               

typedef CEOIDINFO                   PEGOIDINFO;   
typedef PEGOIDINFO                  *PPEGOIDINFO;                

//
// Flags for open database - use low word:
//
#define PEGDB_AUTOINCREMENT         CEDB_AUTOINCREMENT
 
#define PEGDB_SEEK_PEGOID           CEDB_SEEK_CEOID   
#define PEGDB_SEEK_BEGINNING        CEDB_SEEK_BEGINNING
#define PEGDB_SEEK_END              CEDB_SEEK_END
#define PEGDB_SEEK_CURRENT          CEDB_SEEK_CURRENT
#define PEGDB_SEEK_VALUESMALLER     CEDB_SEEK_VALUESMALLER   
#define PEGDB_SEEK_VALUEFIRSTEQUAL  CEDB_SEEK_VALUEFIRSTEQUAL
#define PEGDB_SEEK_VALUEGREATER     CEDB_SEEK_VALUEGREATER   
#define PEGDB_SEEK_VALUENEXTEQUAL   CEDB_SEEK_VALUENEXTEQUAL 

typedef CEBLOB                      PEGBLOB;
typedef PEGBLOB                     *PPEGBLOB;

#define PEGVT_I2                    CEVT_I2
#define PEGVT_UI2                   CEVT_UI2                    
#define PEGVT_I4                    CEVT_I4                     
#define PEGVT_UI4                   CEVT_UI4                            
#define PEGVT_FILETIME              CEVT_FILETIME               
#define PEGVT_LPWSTR                CEVT_LPWSTR                 
#define PEGVT_BLOB                  CEVT_BLOB                   

typedef CEVALUNION                  PEGVALUNION;
typedef PEGVALUNION                 *PPEGVALUNION;

#define PEGDB_PROPNOTFOUND          CEDB_PROPNOTFOUND            
#define PEGDB_PROPDELETE            CEDB_PROPDELETE              

typedef CEPROPVAL                   PEGPROPVAL; 
typedef PEGPROPVAL                  *PPEGPROPVAL; 

#define PEGDB_MAXDATABLOCKSIZE      CEDB_MAXDATABLOCKSIZE 
#define PEGDB_MAXPROPDATASIZE       CEDB_MAXPROPDATASIZE  
#define PEGDB_MAXRECORDSIZE         CEDB_MAXRECORDSIZE

#define PEGDB_ALLOWREALLOC          CEDB_ALLOWREALLOC  

#ifndef UNDER_CE
typedef CEOSVERSIONINFO             PEGOSVERSIONINFO;
typedef LPCEOSVERSIONINFO           LPPEGOSVERSIONINFO;
#endif

#define PegCreateDatabase         CeCreateDatabase
#define PegDeleteDatabase         CeDeleteDatabase
#define PegDeleteRecord           CeDeleteRecord
#define PegFindFirstDatabase      CeFindFirstDatabase
#define PegFindNextDatabase       CeFindNextDatabase
#define PegOidGetInfo             CeOidGetInfo
#define PegOpenDatabase           CeOpenDatabase
#define PegReadRecordProps        CeReadRecordProps
#define PegSeekDatabase           CeSeekDatabase
#define PegSetDatabaseInfo        CeSetDatabaseInfo
#define PegWriteRecordProps       CeWriteRecordProps

#ifndef UNDER_CE
#define PegFindFirstFile          CeFindFirstFile
#define PegFindNextFile           CeFindNextFile
#define PegFindClose              CeFindClose
#define PegGetFileAttributes      CeGetFileAttributes
#define PegSetFileAttributes      CeSetFileAttributes
#define PegCreateFile             CeCreateFile
#define PegReadFile               CeReadFile
#define PegWriteFile              CeWriteFile
#define PegCloseHandle            CeCloseHandle
#define PegFindAllFiles           CeFindAllFiles
#define PegFindAllDatabases       CeFindAllDatabases
#define PegSetFilePointer         CeSetFilePointer
#define PegSetEndOfFile           CeSetEndOfFile
#define PegCreateDirectory        CeCreateDirectory
#define PegRemoveDirectory        CeRemoveDirectory
#define PegCreateProcess          CeCreateProcess
#define PegMoveFile               CeMoveFile
#define PegCopyFile               CeCopyFile
#define PegDeleteFile             CeDeleteFile
#define PegGetFileSize            CeGetFileSize
#define PegRegOpenKeyEx           CeRegOpenKeyEx
#define PegRegEnumKeyEx           CeRegEnumKeyEx
#define PegRegCreateKeyEx         CeRegCreateKeyEx
#define PegRegCloseKey            CeRegCloseKey
#define PegRegDeleteKey           CeRegDeleteKey
#define PegRegEnumValue           CeRegEnumValue
#define PegRegDeleteValue         CeRegDeleteValue
#define PegRegQueryInfoKey        CeRegQueryInfoKey
#define PegRegQueryValueEx        CeRegQueryValueEx
#define PegRegSetValueEx          CeRegSetValueEx
#define PegGetStoreInformation    CeGetStoreInformation
#define PegGetSystemMetrics       CeGetSystemMetrics
#define PegGetDesktopDeviceCaps   CeGetDesktopDeviceCaps
#define PegGetSystemInfo          CeGetSystemInfo
#define PegSHCreateShortcut       CeSHCreateShortcut
#define PegSHGetShortcutTarget    CeSHGetShortcutTarget
#define PegCheckPassword          CeCheckPassword
#define PegGetFileTime            CeGetFileTime
#define PegSetFileTime            CeSetFileTime
#define PegGetVersionEx           CeGetVersionEx
#define PegGetWindow              CeGetWindow
#define PegGetWindowLong          CeGetWindowLong
#define PegGetWindowText          CeGetWindowText
#define PegGetClassName           CeGetClassName
#define PegGlobalMemoryStatus     CeGlobalMemoryStatus
#define PegGetSystemPowerStatusEx CeGetSystemPowerStatusEx
#define PegGetTempPath            CeGetTempPath
#define PegGetSpecialFolderPath   CeGetSpecialFolderPath

#define PegRapiInitEx             CeRapiInitEx
#define PegRapiInit               CeRapiInit
#define PegRapiUninit             CeRapiUninit
#define PegGetLastError           CeGetLastError
#define RapiFreeBuffer            CeRapiFreeBuffer
#define GetRapiError              CeRapiGetError
#endif

#ifdef CONN_INTERNAL
#include <pceapimp.h>  // internal defines
#endif

#endif // _CEAPIMAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\dependencies\inc\license.h ===
//-----------------------------------------------------------------------------
//
// File:   license.h
//
// Microsoft Digital Rights Management
// Copyright (C) Microsoft Corporation, 1998 - 1999, All Rights Reserved
//
// Description:
//
//-----------------------------------------------------------------------------

#ifndef __LICENSE_H__
#define __LICENSE_H__

#include "widestr.h"		// XPLAT

#include "pkcrypto.h"


#define VERSION_LEN          4
#define DATE_LEN             4
#define SER_NUM_LEN          4
#define ISSUER_LEN           4
#define SUBJ_LEN             4
#define INT_LEN				 4
#define EXPORTKEYLEN         7

// Constant indicating the number of times SHA has to be used to get the hash of key.
// This hash is used to check whether the key is good or bad.
// CHECKSUM_LENGTH indicates the number of bytes in final hash value to use as CHECKSUM.
#define SHA_ITERATIONS      5
#define CHECKSUM_LENGTH 7

#define APPSEC_LEN           4

#define KIDLEN		25

#define VERSION_LEN          4
#define DATE_LEN             4
#define RIGHTS_LEN           4
#define APPSEC_LEN           4
#define INT_LEN				 4


// Version Format: a.b.c.d
//            a = not used.
//            b = major version
//            c = minor version
//            d = revision version
#define DRM_VERSION_STRING                          WIDESTR( "2.0.0.0" )
const BYTE DRM_VERSION[VERSION_LEN]                 = {2, 0, 0, 0}; // DRM Version. Keep this in sync with DRM_VERSION_STRING above.

const BYTE PK_VER[VERSION_LEN]                      = {2, 0, 0, 0}; // Indicates the version of the pubkey to be used for verification of PK CERT.
const BYTE KEYFILE_VER[VERSION_LEN]                 = {2, 0, 0, 0}; // Version of the key file.

#define LICREQUEST_VER_STRING						WIDESTR( "2.0.0.0" )
const BYTE LICREQUEST_VER[VERSION_LEN]              = {2, 0, 0, 0};

const BYTE CERT_VER[VERSION_LEN]                    = {0, 1, 0, 0}; // Indicates the public root key needed to verify the license server certificates.

#define LICENSE_VER_STRING                          WIDESTR( "2.0.0.0" ) 
const BYTE LICENSE_VER[VERSION_LEN]                 = {2, 0, 0, 0}; // Indicates the license version delivered.

const BYTE CLIENT_ID_VER[VERSION_LEN]               = {2, 0, 0, 0}; // The version for client id.

#define CONTENT_VERSION_STRING                      WIDESTR( "2.0.0.0" )
const BYTE CONTENT_VERSION[VERSION_LEN]             = {2, 0, 0, 0}; // Content Version. Keep this in sync with CONTENT_VERSION_STRING above.

#define PM_LICENSE_VER_STRING						WIDESTR( "0.1.0.0" )
const BYTE PM_LICENSE_VER[VERSION_LEN]              = {0, 1, 0, 0}; // Indicates the license version delivered to PMs

// For blackbox version, we have the following convention.
// a.b.c.d. a.b => release number. c => reserved. d => category. 
#define WIN32_INDIVBOX_CATEGORY 1

const BYTE APPCERT_VER[VERSION_LEN] = {0, 1, 0, 0};
const BYTE APPCERT_PK_VER[VERSION_LEN]   = {0, 1, 0, 0}; 
#define SDK_CERTS_COUNT 4
const BYTE APPCERT_SUBJECT_SDKSTUBS[SDK_CERTS_COUNT][SUBJ_LEN] = {{0, 0, 0, 200}, {0, 0, 0, 204}, {0, 0, 0, 208}, {0, 0, 0, 212}};

typedef struct {
	PUBKEY pk;
	BYTE version[VERSION_LEN];  
} PK;

typedef struct {
	PK pk;  // pk.version indicates the pubkey needed to verify.
	BYTE sign[PK_ENC_SIGNATURE_LEN];
} PKCERT;

typedef struct {
	BYTE version[VERSION_LEN];
    BYTE randNum[PK_ENC_CIPHERTEXT_LEN];
    PKCERT pk;
} CLIENTID;

//----------------cert section -----------------------

typedef struct CERTDATAtag{
    PUBKEY pk;
    BYTE expiryDate[DATE_LEN];
    BYTE serialNumber[SER_NUM_LEN];
    BYTE issuer[ISSUER_LEN];
    BYTE subject[SUBJ_LEN];
} CERTDATA, *PCERTDATA;


typedef struct CERTtag{
    BYTE certVersion[VERSION_LEN];
    BYTE datalen[INT_LEN];
    BYTE sign[PK_ENC_SIGNATURE_LEN];
    CERTDATA cd;
} CERT, *PCERT;


typedef struct {
	PK pk;
	BYTE appSec[APPSEC_LEN];
	BYTE subject[SUBJ_LEN];
} APPCERTDATA;

typedef struct {
	BYTE appcertVersion[VERSION_LEN];
	BYTE datalen[INT_LEN];
	BYTE sign[PK_ENC_SIGNATURE_LEN];
	APPCERTDATA appcd;
} APPCERT;

typedef struct {
	char KID[KIDLEN];
	BYTE key[PK_ENC_CIPHERTEXT_LEN];	// encrypted with DRM PK
	BYTE rights[RIGHTS_LEN];
	BYTE appSec[APPSEC_LEN];
	BYTE expiryDate[DATE_LEN];
} LICENSEDATA;

typedef struct {
	BYTE licVersion[VERSION_LEN];
	BYTE datalen[INT_LEN];
	BYTE sign[PK_ENC_SIGNATURE_LEN];	// signature over licensedata
	LICENSEDATA ld;
} LICENSE;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\cewmdm\cewmdmdbt.h ===
#include <dbt.h>

static const char g_szActiveSyncDeviceName[] = "ActiveSync";

typedef struct tagACTIVESYNC_DEV_BROADCAST_USERDEFINED
{
    struct _DEV_BROADCAST_HDR DBHeader; 
    char  szName[sizeof(g_szActiveSyncDeviceName) + 1];
	BOOL  fConnected;
} ACTIVESYNC_DEV_BROADCAST_USERDEFINED;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\cewmdm\cewmdm.cpp ===
// CEWMDM.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f CEWMDMps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"

#include "rapisp.h"
//#include "findleak.h"
#include "proppage.h"

//DECLARE_THIS_FILE;

CRapiModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(__uuidof(RapiDevice), CRapiDevice)
//MukundS
//OBJECT_ENTRY(__uuidof(FavoritesPropPage), CFavoritesPropertyPage)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer();
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\cewmdm\command.h ===
#pragma once

struct __declspec(uuid("{5a2eec11-754b-40a4-a5a1-349b35d6ba3a}")) RapierPlayCommand;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\dependencies\inc\pkcrypto.h ===
//-----------------------------------------------------------------------------
//
// File:   pkcrypto.h
//
// Microsoft Digital Rights Management
// Copyright (C) 1998-1999 Microsoft Corporation, All Rights Reserved
//
// Description:
//  public key crypto library
//
// Author:	marcuspe
//
//-----------------------------------------------------------------------------

#ifndef __DRMPKCRYPTO_H__
#define __DRMPKCRYPTO_H__

#include <wtypes.h>

#define LNGQDW 5

/*
typedef struct {
	DWORD y[2*LNGQDW];
} PUBKEY;

typedef struct {
	DWORD x[LNGQDW];
} PRIVKEY;
*/

#define PK_ENC_PUBLIC_KEY_LEN	(2 * LNGQDW * sizeof(DWORD))
#define PK_ENC_PRIVATE_KEY_LEN	(    LNGQDW * sizeof(DWORD))
#define PK_ENC_PLAINTEXT_LEN	((LNGQDW-1) * sizeof(DWORD))
#define PK_ENC_CIPHERTEXT_LEN	(4 * LNGQDW * sizeof(DWORD))
#define PK_ENC_SIGNATURE_LEN	(2 * LNGQDW * sizeof(DWORD))


//////////////////////////////////////////////////////////////////////
struct PUBKEY
{
	BYTE y[ PK_ENC_PUBLIC_KEY_LEN ];
};


//////////////////////////////////////////////////////////////////////
static inline int operator == ( const PUBKEY& a, const PUBKEY& b )
{
    return (memcmp( a.y, b.y, sizeof(a.y) ) == 0);
}


//////////////////////////////////////////////////////////////////////
struct PRIVKEY
{
	BYTE x[ PK_ENC_PRIVATE_KEY_LEN ];
};


#if 0
#include <iostream.h>
#include <iomanip.h>
static inline ostream& operator << ( ostream& out, const PUBKEY& oPublKey )
{
    for (int i = 0; i < sizeof(oPublKey.y); i++)
    {
        out << " " << setfill('0') << setw(2) << hex << oPublKey.y[i];
    }
    return out;
}
static inline ostream& operator << ( ostream& out, const PRIVKEY& oPrivKey )
{
    for (int i = 0; i < sizeof(oPrivKey.x); i++)
    {
        out << " " << setfill('0') << setw(2) << hex << oPrivKey.x[i];
    }
    return out;
}
#endif


//////////////////////////////////////////////////////////////////////
//
//
//
class CDRMPKCrypto {
private:
	char *pkd;
public:
	CDRMPKCrypto();
	~CDRMPKCrypto();
	HRESULT PKinit();
	HRESULT PKencrypt( PUBKEY *pk, BYTE *in, BYTE *out );
	HRESULT PKdecrypt( PRIVKEY *pk, BYTE *in, BYTE *out );
	HRESULT PKsign( PRIVKEY *privkey, BYTE  *buffer, DWORD lbuf, BYTE *sign );
	BOOL PKverify( PUBKEY *pubkey, BYTE *buffer, DWORD lbuf, BYTE *sign );
	HRESULT PKGenKeyPair( PUBKEY *pPub, PRIVKEY *pPriv );
    HRESULT PKEncryptLarge( PUBKEY *pk, BYTE *in, DWORD dwLenIn, BYTE *out, DWORD symm_key_len, DWORD symm_alg );
    HRESULT PKDecryptLarge( PRIVKEY *pk, BYTE *in, DWORD dwLenIn, BYTE *out );
};



//  #include "contcrpt.h"

#define PKSYMM_KEY_LEN_DRMV2	7
#define PKSYMM_ALG_TYPE_RC4		1


//  These are provided for backwards compatibility.
//  It can be more efficient to use the member functions in CDRMPKCrypto,
//  because construction of CDRMPKCrypto objects is relatively expensive.
//  in terms of computation.
inline HRESULT PKEncryptLarge( PUBKEY *pk, BYTE *in, DWORD dwLenIn, BYTE *out, DWORD symm_key_len, DWORD symm_alg )
{
    CDRMPKCrypto oPkc;
    return oPkc.PKEncryptLarge( pk, in, dwLenIn, out, symm_key_len, symm_alg );
}

inline HRESULT PKDecryptLarge( PRIVKEY *pk, BYTE *in, DWORD dwLenIn, BYTE *out )
{
    CDRMPKCrypto oPkc;
    return oPkc.PKDecryptLarge( pk, in, dwLenIn, out );
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\cewmdm\devenum.h ===
#pragma once

#include "device.h"

class CDeviceEnum:
public CComObjectRoot,
public IMDSPEnumDevice
{
public:
    CDeviceEnum();

public:
    BEGIN_COM_MAP(CDeviceEnum)
        COM_INTERFACE_ENTRY(IMDSPEnumDevice)
    END_COM_MAP()

public:
    void FinalRelease();
    HRESULT Init( CComDevice **rgDevice, UINT cItems, UINT iCur = 0 );

public:
    //
    // IMDSPEnumDevice interface
    //

    STDMETHOD( Next )( ULONG celt, IMDSPDevice ** ppDevice, ULONG *pceltFetched );
    STDMETHOD( Skip )( ULONG celt, ULONG *pceltFetched );        
    STDMETHOD( Reset )( void );        
    STDMETHOD( Clone )( IMDSPEnumDevice ** ppEnumDevice );

protected:
    UINT m_iCurItem;
    UINT m_cItems;
    CComDevice **m_rgDevices;
};

typedef CComObject<CDeviceEnum> CComEnumDevice;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\cewmdm\dccsink.h ===
#pragma once

class CDCCSink :
public CComObjectRoot,
public IDccManSink
{

public:
    CDCCSink();
    HRESULT Initialize();
    void FinalRelease();

    BEGIN_COM_MAP(CDCCSink)
        COM_INTERFACE_ENTRY_IID(IID_IDccManSink, IDccManSink)
    END_COM_MAP()

public:
    //
    // IDccManSink
    //

    STDMETHOD( OnLogActive ) ( void );
    STDMETHOD( OnLogAnswered ) ( void );
    STDMETHOD( OnLogDisconnection ) ( void );
    STDMETHOD( OnLogError ) ( void );
    STDMETHOD( OnLogInactive ) ( void );
    STDMETHOD( OnLogIpAddr ) ( DWORD dwIpAddr );
    STDMETHOD( OnLogListen ) ( void );
    STDMETHOD( OnLogTerminated ) ( void );

    //
    // Shutdown Method
    //
    void Shutdown();

protected:
    void DeviceDisconnected();
    HRESULT m_hrRapi;

    static DWORD WINAPI CreateDCCManProc(LPVOID lpParam );
    HANDLE m_hThread;
    HANDLE m_hThreadEvent;
    DWORD  m_dwThreadId;

    CComPtr<IDccMan> m_spDccMan;
    DWORD m_dwDccSink;
};

typedef CComObject<CDCCSink> CComDccSink;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\cewmdm\dccsink.cpp ===
#include "stdafx.h"
#include "dccsink.h"
//#include "findleak.h"

#ifdef ATTEMPT_DEVICE_CONNECTION_NOTIFICATION
#include "cewmdmdbt.h"
#endif

#define SAFE_CLOSEHANDLE(h)      CloseHandle((h))

//DECLARE_THIS_FILE;



//
// Construction/Destruction
//

CDCCSink::CDCCSink() :
    m_hThread(NULL),
    m_hThreadEvent(NULL),
    m_dwThreadId(0),
    m_dwDccSink(-1),
    m_hrRapi( 0 )
{
}

HRESULT CDCCSink::Initialize()
{
    HRESULT hr = S_OK;

    m_hThreadEvent = CreateEvent(NULL, FALSE, FALSE, NULL );
    if( NULL == m_hThreadEvent )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
    }

    if( SUCCEEDED( hr ) )
    {
        m_hThread = CreateThread( NULL, 0, CreateDCCManProc, this, 0, &m_dwThreadId );

        if( NULL == m_hThread )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
        }
    }

    if( SUCCEEDED( hr ) )
    {
        if( WAIT_OBJECT_0 != WaitForSingleObject( m_hThreadEvent, INFINITE ) )
        {
            hr = E_FAIL;
        }
        else
        {
            hr = m_hrRapi;
        }
    }

    return( hr );
}

void CDCCSink::FinalRelease()
{
    if( m_hThread )
    {
        SAFE_CLOSEHANDLE( m_hThread );
    }

    if( m_hThreadEvent )
    {
        SAFE_CLOSEHANDLE( m_hThreadEvent );
    }
}

//
// IDccManSink
//

STDMETHODIMP CDCCSink::OnLogActive ( void )
{
    m_hrRapi = CeRapiInit();

    return( S_OK );
}

STDMETHODIMP CDCCSink::OnLogAnswered ( void )
{
    return( S_OK );
}

STDMETHODIMP CDCCSink::OnLogDisconnection ( void )
{
    DeviceDisconnected();
    return( S_OK );
}

STDMETHODIMP CDCCSink::OnLogError ( void )
{
    DeviceDisconnected();
    return( S_OK );
}

STDMETHODIMP CDCCSink::OnLogInactive ( void )
{
    DeviceDisconnected();
    return( S_OK );
}

STDMETHODIMP CDCCSink::OnLogIpAddr ( DWORD dwIpAddr )
{
#ifdef ATTEMPT_DEVICE_CONNECTION_NOTIFICATION
    if( !_Module.g_fInitialAttempt )
    {
        ACTIVESYNC_DEV_BROADCAST_USERDEFINED  dbu;
        DWORD dwRecips = BSM_APPLICATIONS;

        memset( &dbu, 0, sizeof(dbu) );

        dbu.DBHeader.dbch_size = sizeof(dbu);
        dbu.fConnected = TRUE;
        strcpy( dbu.szName, g_szActiveSyncDeviceName );
  
        BroadcastSystemMessage( BSF_POSTMESSAGE | BSF_FORCEIFHUNG | BSF_NOHANG, &dwRecips, WM_DEVICECHANGE, DBT_USERDEFINED, (LPARAM)&dbu );
    }
#endif
    _Module.g_fDeviceConnected = TRUE;

    return( S_OK );
}

STDMETHODIMP CDCCSink::OnLogListen ( void )
{
    return( S_OK );
}

STDMETHODIMP CDCCSink::OnLogTerminated ( void )
{
    DeviceDisconnected();
    return( S_OK );
}

//
// Helper functions
//

void CDCCSink::DeviceDisconnected()
{
    if( SUCCEEDED( m_hrRapi ) )
    {
        _Module.g_fDeviceConnected = FALSE;
        CeRapiUninit();
        m_hrRapi = E_FAIL;

#ifdef ATTEMPT_DEVICE_CONNECTION_NOTIFICATION
        ACTIVESYNC_DEV_BROADCAST_USERDEFINED dbu;
        DWORD dwRecips = BSM_APPLICATIONS;

        memset( &dbu, 0, sizeof(dbu) );

        dbu.DBHeader.dbch_size = sizeof(dbu);
        dbu.fConnected = FALSE;
        strcpy( dbu.szName, g_szActiveSyncDeviceName );
  
        BroadcastSystemMessage( BSF_POSTMESSAGE | BSF_FORCEIFHUNG | BSF_NOHANG, &dwRecips, WM_DEVICECHANGE, DBT_USERDEFINED, (LPARAM)&dbu );
#endif
    }
}

void CDCCSink::Shutdown()
{
    if( m_hThread )
    {
        PostThreadMessage( m_dwThreadId, WM_QUIT, 0, 0 );
	WaitForSingleObject( m_hThread, INFINITE );
    }
}

DWORD WINAPI CDCCSink::CreateDCCManProc(LPVOID lpParam )
{
    HRESULT hr = S_OK;
    MSG msg;

    _ASSERTE( lpParam );

    CDCCSink *pThis = (CDCCSink *)lpParam;

    CoInitialize(NULL);
    
    if( SUCCEEDED( hr ) )
    {
        hr = CoCreateInstance(CLSID_DccMan, NULL, CLSCTX_ALL, IID_IDccMan, (LPVOID *)&(pThis->m_spDccMan) );
    }

    if( SUCCEEDED( hr ) )
    {
        hr = pThis->m_spDccMan->Advise(pThis, &(pThis->m_dwDccSink) );
    }

    pThis->m_hrRapi = hr;
    SetEvent( pThis->m_hThreadEvent );

    while( GetMessage( &msg, NULL, 0, 0 ) )
    {
        DispatchMessage( &msg );
    }

    if( NULL != pThis->m_spDccMan.p )
    {
        if( (DWORD)-1 != pThis->m_dwDccSink )
        {
            pThis->m_spDccMan->Unadvise( pThis->m_dwDccSink );
        }
    }

    CoUninitialize();

    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\cewmdm\device.cpp ===
#include "stdafx.h"
#include "device.h"
#include "enumStorage.h"
#include "resource.h"
#include <stdio.h>
#include <mmreg.h>
//#include "findleak.h"

//DECLARE_THIS_FILE;

#define WCS_MIME_TYPE_ALL L"*/*"
#define WMDM_WAVE_FORMAT_ALL (WORD)0xFFFF
#define WAVE_FORMAT_MSAUDIO     0x161

static const _WAVEFORMATEX g_krgWaveFormatsV1[] =
{
      // wFormatTag,             nChanneels, nSamplesPerSec, nAvgBytesPerSec, nBlockAlign, wBitsPerSample, cbSize
       { WAVE_FORMAT_MPEGLAYER3, 0,          0,              0,               0,           0,              0 },
       { WAVE_FORMAT_MSAUDIO,    2,          44000,          4000,            0,           0,              0 },
       { WAVE_FORMAT_MSAUDIO,    2,          44000,          16000,           0,           0,              0 }
};

       //
       // These are for CE version 2, in theory, since the player uses the Highest and Lowest
       // entries in the table, the CE version 2 table should "outweight" the CE version 1 table
       //

static const _WAVEFORMATEX g_krgWaveFormatsV2[] =
{
      // wFormatTag,             nChanneels, nSamplesPerSec, nAvgBytesPerSec, nBlockAlign, wBitsPerSample, cbSize
       { WAVE_FORMAT_MPEGLAYER3, 0,          0,              0,               0,           0,              0 },
       { WAVE_FORMAT_MSAUDIO,    2,          1000,           0,               0,           0,              0 },
       { WAVE_FORMAT_MSAUDIO,    2,          44000,          0,               0,           0,              0 }
};

static const LPCWSTR g_kszMimeTypes[] =
{
    L"audio/mpeg",
    L"audio/x-ms-wma",
    L"video/x-ms-wmv",
    L"video/x-ms-asf"
};

CDevice::CDevice() :
    m_pszInitPath(NULL), m_fAllowVideo(FALSE)
{
}

CDevice::~CDevice()
{
    delete [] m_pszInitPath;
}

HRESULT CDevice::Init( LPCWSTR pszInitPath )
{
    if( NULL == pszInitPath )
    {
        return( E_INVALIDARG );
    }

    m_pszInitPath = new WCHAR[ wcslen(pszInitPath) + 1 ];

    if( NULL == m_pszInitPath )
    {
        return( E_OUTOFMEMORY );
    }

    wcscpy( m_pszInitPath, pszInitPath );

    return( S_OK );
}

STDMETHODIMP CDevice::GetName( LPWSTR pwszName, UINT nMaxChars)
{
    HKEY hKey = NULL;
    HRESULT hr = S_OK;

    if( NULL == pwszName || 0 == nMaxChars )
    {
        return( E_INVALIDARG );
    }

    memset( pwszName, 0, sizeof(WCHAR)*nMaxChars );

    //
    // Indicates the base device
    //

    if( 0 == _wcsicmp(L"\\", m_pszInitPath ) )
    {
        if( ERROR_SUCCESS == CeRegOpenKeyEx( HKEY_LOCAL_MACHINE, L"Ident", 0, KEY_READ, &hKey ) )
        {
            DWORD cbData = nMaxChars * sizeof(WCHAR);
            if( ERROR_SUCCESS == CeRegQueryValueEx( hKey, L"Name", NULL, NULL, (LPBYTE)pwszName, &cbData) )
            {
                CeRegCloseKey( hKey );
            }
            else
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
        }
    }
    else
    {
        wcsncpy( pwszName, m_pszInitPath, nMaxChars - 1 );
    }

    return( hr );
}

STDMETHODIMP CDevice::GetManufacturer( LPWSTR pwszName, UINT nMaxChars)
{
    return( E_NOTIMPL );
}

STDMETHODIMP CDevice::GetVersion( DWORD *pdwVersion )
{
    CEOSVERSIONINFO osv;
    HRESULT hr = S_OK;
    
    if( NULL == pdwVersion )
    {
        return( E_INVALIDARG );
    }

    osv.dwOSVersionInfoSize = sizeof(osv);

    if( !CeGetVersionEx(&osv) )
    {
        hr = HRESULT_FROM_WIN32( CeGetLastError() );

        if( SUCCEEDED( hr ) )
        {
            hr = CeRapiGetError();
        }
    }
    else
    {
        *pdwVersion = osv.dwBuildNumber; // The Build Number of CE should suffice!
    }

    return( hr );
}

STDMETHODIMP CDevice::GetType( DWORD *pdwType )
{
    WCHAR szTestSerialPath[MAX_PATH];
    HRESULT hrSerial = S_OK;
    WMDMID SerialNumber;

    if( NULL == pdwType )
    {
        return( E_INVALIDARG );
    }

    *pdwType = 0;

    memset( &SerialNumber, 0, sizeof(SerialNumber) );
    SerialNumber.cbSize = sizeof(SerialNumber);

    //
    // TODO:Handle the case for WMDM_DEVICE_TYPE_SECURE!
    //

    if( 0 == _wcsicmp( L"\\", m_pszInitPath ) )
    {
        hrSerial = CeUtilGetSerialNumber( L"\\", &SerialNumber, NULL, 0 );
    }
    else
    {
        memset( szTestSerialPath, 0, sizeof(szTestSerialPath) );
        _snwprintf( szTestSerialPath, sizeof(szTestSerialPath)/sizeof(szTestSerialPath[0]) - 1, L"\\%s", m_pszInitPath );

        hrSerial = CeUtilGetSerialNumber( szTestSerialPath, &SerialNumber, NULL, 0 );
    }

    (*pdwType) = ( WMDM_DEVICE_TYPE_STORAGE | WMDM_DEVICE_TYPE_NONSDMI );

    if( S_OK == hrSerial )
    {
        (*pdwType) |= WMDM_DEVICE_TYPE_SDMI;
    }

    return( S_OK );
}

STDMETHODIMP CDevice::GetSerialNumber( PWMDMID pSerialNumber, BYTE abMac[WMDM_MAC_LENGTH] )
{
    HRESULT hr = S_OK;
    WCHAR szTestSerialPath[MAX_PATH];

    if( 0 == _wcsicmp( L"\\", m_pszInitPath ) )
    {
        hr = CeUtilGetSerialNumber( m_pszInitPath, pSerialNumber, NULL, 0 );
    }
    else
    {
        memset( szTestSerialPath, 0, sizeof(szTestSerialPath) );
        _snwprintf( szTestSerialPath, sizeof(szTestSerialPath)/sizeof(szTestSerialPath[0]) - 1, L"\\%s", m_pszInitPath );

        hr = CeUtilGetSerialNumber( szTestSerialPath, pSerialNumber, NULL, 0 );
    }

    if( hr == S_OK )
    {
	    // MAC the parameters
	    HMAC hMAC;
	    hr = g_pAppSCServer->MACInit(&hMAC);

        if( SUCCEEDED( hr ) )
        {
		    hr = g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(pSerialNumber), sizeof(WMDMID));
        }

        if( SUCCEEDED( hr ) )
        {
		    hr = g_pAppSCServer->MACFinal(hMAC, abMac);
        }
    }
    else
    {
        hr = WMDM_E_NOTSUPPORTED;
    }

    return( hr );
}

STDMETHODIMP CDevice::GetPowerSource( DWORD *pdwPowerSource, DWORD *pdwPercentRemaining)
{
    SYSTEM_POWER_STATUS_EX sps;
    HRESULT hr = S_OK;

    if( NULL == pdwPowerSource  )
    {
        return( E_POINTER );
    }

    *pdwPowerSource = 0;

    if( pdwPercentRemaining )
    {
        *pdwPercentRemaining = 0;
    }

    if( !CeGetSystemPowerStatusEx( &sps, TRUE) )
    {
        hr = HRESULT_FROM_WIN32( CeGetLastError() );

        if( SUCCEEDED( hr ) )
        {
            hr = CeRapiGetError();
        }
    }

    if( SUCCEEDED( hr ) )
    {
        if( 1 == sps.ACLineStatus )
        {
            *pdwPowerSource |= WMDM_POWER_IS_EXTERNAL;
        }
        else if( 0 == sps.ACLineStatus )
        {
            *pdwPowerSource |= WMDM_POWER_IS_BATTERY;
        }

        if( 255 != sps.ACLineStatus )
        {
            *pdwPowerSource |= WMDM_POWER_CAP_EXTERNAL;
        }

        if( 128 != sps.BatteryFlag && 255 != sps.BatteryFlag )
        {
            *pdwPowerSource |= WMDM_POWER_CAP_BATTERY;
        }

        if( pdwPercentRemaining )
        {
            if( 255 != sps.BatteryLifePercent )
            {
                *pdwPercentRemaining = sps.BatteryLifePercent;
            }
        }
    }

    return( hr );
}

STDMETHODIMP CDevice::GetStatus( DWORD *pdwStatus )
{
    if( NULL == pdwStatus )
    {
        return( E_INVALIDARG );
    }

    //
    // We may want to extend this in the future to handle
    // the player is playing, currently copying to device, etc!
    //

    if( !_Module.g_fDeviceConnected )
    {
        *pdwStatus = WMDM_STATUS_DEVICE_NOTPRESENT;
    }
    else
    {
        *pdwStatus = WMDM_STATUS_READY;
    }

    return( S_OK );
}

STDMETHODIMP CDevice::GetDeviceIcon( ULONG *hIcon )
{
    HRESULT hr = S_OK;

    if( NULL == hIcon )
    {
        return( E_POINTER );
    }

    *hIcon = HandleToULong(LoadIcon(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDI_CEWMDM_DEVICE) ));

    if( NULL == *hIcon )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
    }

    return( hr );
}

STDMETHODIMP CDevice::EnumStorage( IMDSPEnumStorage **ppEnumStorage )
{
    HRESULT hr = S_OK;
    CComEnumStorage *pEnumStorage = NULL;
    CComPtr<IMDSPEnumStorage> spEnum;

    if( NULL == ppEnumStorage )
    {
        return( E_INVALIDARG );
    }

    *ppEnumStorage = NULL;

    hr = CComEnumStorage::CreateInstance( &pEnumStorage );
    spEnum = pEnumStorage;

    if( SUCCEEDED( hr ) )
    {
        hr = pEnumStorage->Init( m_pszInitPath, TRUE, this );
    }

    if( SUCCEEDED( hr ) )
    {
        *ppEnumStorage = spEnum;
        spEnum.Detach();
    }

    return( hr );
}

STDMETHODIMP CDevice::GetFormatSupport( _WAVEFORMATEX **pFormatEx,
                                     UINT *pnFormatCount,
                                     LPWSTR **pppwszMimeType,
                                     UINT *pnMimeTypeCount)
{
    return InternalGetFormatSupport( pFormatEx, pnFormatCount, pppwszMimeType, pnMimeTypeCount );
}

STDMETHODIMP CDevice::SendOpaqueCommand( OPAQUECOMMAND *pCommand )
{
    return( E_NOTIMPL );
}

STDMETHODIMP CDevice::GetStorage( LPCWSTR pszStorageName, IMDSPStorage** ppStorage )
{
    return ( E_NOTIMPL );
}

STDMETHODIMP CDevice::GetPnPName( LPWSTR pwszPnPName, UINT nMaxChars )
{
    return E_NOTIMPL;
}

STDMETHODIMP CDevice::GetFormatSupport2( DWORD dwFlags,
                                         _WAVEFORMATEX **ppAudioFormatEx,
                                         UINT *pnAudioFormatCount,
                                         _VIDEOINFOHEADER **ppVideoFormatEx,
                                         UINT *pnVideoFormatCount,
                                         WMFILECAPABILITIES **ppFileType,
                                         UINT *pnFileTypeCount)
{
    HRESULT hr = S_OK;
    LPWSTR *ppwszMimeType = NULL;
    UINT nMimeTypeCount;
    BOOL fAllowVideo = FALSE;

    if( NULL != pnVideoFormatCount )
    {
        *pnVideoFormatCount = 0;
    }

    if( NULL != ppVideoFormatEx )
    {
        *ppVideoFormatEx = NULL;
    }

    if( NULL != pnFileTypeCount )
    {
        *pnFileTypeCount = 0;
    }

    if( NULL != ppFileType )
    {
        *ppFileType = NULL;
    }

    if( NULL == pnVideoFormatCount )
    {
        return( E_INVALIDARG );
    }

    if( NULL == ppVideoFormatEx )
    {
        return( E_INVALIDARG );
    }

    if( NULL == pnFileTypeCount )
    {
        return( E_INVALIDARG );
    }

    if( NULL == ppFileType )
    {
        return( E_INVALIDARG );
    }
  

    if ( SUCCEEDED(hr) )
    {
        // NOTE: This function calls GetCEPlayerVersion which sets m_fAllowVideo
        // if you need to put code above this call that depends on that member you must call GetCEPlayerVersion first
        hr = InternalGetFormatSupport( ppAudioFormatEx, pnAudioFormatCount, &ppwszMimeType, &nMimeTypeCount );

        if ( SUCCEEDED(hr) )
        {
            // Wrap all of the mime types in WMFILECAPABILITIES
            *ppFileType = (WMFILECAPABILITIES *)CoTaskMemAlloc( sizeof(WMFILECAPABILITIES) * nMimeTypeCount );
            if (*ppFileType)
            {
                memset( *ppFileType, 0, sizeof(WMFILECAPABILITIES) * nMimeTypeCount );
                for (UINT x=0; x < nMimeTypeCount; x++)
                {
                    (*ppFileType)[x].pwszMimeType = ppwszMimeType[x];
                }

                *pnFileTypeCount = nMimeTypeCount;
            }
            else
            {
                // If the memory alloc fail we need to clean up the return values from GetFormatSupport and the video format struct
                hr = E_OUTOFMEMORY;
            }
        }
    }

    // If it is the V2 regkey, tell the WMDM that we can support video
    if ( SUCCEEDED(hr) && m_fAllowVideo )
    {
        *ppVideoFormatEx = (_VIDEOINFOHEADER *)CoTaskMemAlloc( sizeof(_VIDEOINFOHEADER) );
        if (*ppVideoFormatEx)
        {
            memset( *ppVideoFormatEx, 0, sizeof(_VIDEOINFOHEADER) );

            // Setup the WMDMVIDEOINFOHEADER structure for video
            // These values are all being ignored by WMP8
            (*ppVideoFormatEx)->bmiHeader.biSize = sizeof(_BITMAPINFOHEADER);
            *pnVideoFormatCount = 1;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if ( FAILED(hr) )
    {
        if ( ppAudioFormatEx )
        {
            if ( *ppAudioFormatEx )
            {
                CoTaskMemFree(*ppAudioFormatEx);
            }
        }

        if ( ppwszMimeType )
        {
            if ( *ppwszMimeType )
            {
                while( nMimeTypeCount-- )
                {
                    CoTaskMemFree( ppwszMimeType[nMimeTypeCount] );
                }
            }
            CoTaskMemFree(ppwszMimeType);
        }
    }

    return ( hr );
}


STDMETHODIMP CDevice::GetSpecifyPropertyPages( ISpecifyPropertyPages** ppSpecifyPropPages, 
									           IUnknown*** pppUnknowns, 
									           ULONG *pcUnks )
{
    HRESULT hr = S_OK;
    HINSTANCE hInstance = NULL;
    DWORD dwVersion = 1;

    hInstance = LoadLibrary( _T("wmploc.dll") );

    if( NULL == hInstance )
    {
        return( E_NOTIMPL );
    }

    FreeLibrary( hInstance );

    GetCEPlayerVersion( &dwVersion );

    if( dwVersion < 3 )
    {
        return( E_NOTIMPL );
    }

    if( NULL == ppSpecifyPropPages )
    {
        hr = E_POINTER;
    }
    else
    {
        *ppSpecifyPropPages = NULL;
    }

    if( NULL != pppUnknowns )
    {
        *pppUnknowns = NULL;
    }

    if( NULL != pcUnks )
    {
        *pcUnks = 0;
    }

    if( SUCCEEDED( hr ) )
    {
        hr = QueryInterface( __uuidof(ISpecifyPropertyPages), (LPVOID *)ppSpecifyPropPages );
    }


    return ( hr );
}

STDMETHODIMP CDevice::GetCEPlayerVersion(DWORD *pdwVersion)
{
    HRESULT hr = S_OK;
    HKEY hkeyVer = NULL;

    if (NULL == pdwVersion)
    {
        return (E_INVALIDARG);
    }
    else
    {
        *pdwVersion = 1;
    }
    
    // Check the NOW continuously updated reg key on the device (this should NEVER MOVE on the CE player)
    if( ERROR_SUCCESS != CeRegOpenKeyEx( HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\wmdm\\CurrentInUseVersion", 0, KEY_READ, &hkeyVer ) )
    {
        //
        // On RAPIER Casio Devices, this call fails if the reg key isn't there, but RETURNS a handle, ugly....
        //

        hkeyVer = NULL;
    }


    // Check the regkey on the CE device
    WCHAR szTargetApp[MAX_PATH];

    if ( NULL == hkeyVer )
    {
        if( ERROR_SUCCESS != CeRegOpenKeyEx( HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Windows Media Player 2\\Version", 0, KEY_READ, &hkeyVer ) )
        {
            //
            // On RAPIER Casio Devices, this call fails if the reg key isn't there, but RETURNS a handle, ugly....
            //

            hkeyVer = NULL;
        }
    }

    if( NULL != hkeyVer )
    {
        DWORD cbData = sizeof(szTargetApp);
        if( ERROR_SUCCESS == CeRegQueryValueEx( hkeyVer, NULL, NULL, NULL, (LPBYTE)szTargetApp, &cbData ) )
        {
            LPWSTR pszSplit = wcsrchr( szTargetApp, L'.' );
            DWORD hi, lo;

            if( NULL != pszSplit )
            {
                *pszSplit = L'\0';
                pszSplit++;

                hi = _wtoi( szTargetApp );
                lo = _wtoi( pszSplit );

                if( hi >= 2 )
                {
                    m_fAllowVideo = TRUE;
                }  
                
                *pdwVersion = hi;
                hr = S_OK;
            }
        }

        CeRegCloseKey( hkeyVer );
    }

    return hr;
}

STDMETHODIMP CDevice::InternalGetFormatSupport( _WAVEFORMATEX **pFormatEx,
                                               UINT *pnFormatCount,
                                               LPWSTR **pppwszMimeType,
                                               UINT *pnMimeTypeCount)
{
    HRESULT hr = S_OK;
    UINT idxMimes = 0;
    UINT cMimes = 0;
    UINT cWaves = 0;
    const _WAVEFORMATEX *prgWaveFormats = NULL;

    if( NULL != pnFormatCount )
    {
        *pnFormatCount = 0;
    }

    if( NULL != pFormatEx )
    {
        *pFormatEx = NULL;
    }

    if( NULL != pppwszMimeType )
    {
        *pppwszMimeType = NULL;
    }

    if( NULL != pnMimeTypeCount )
    {
        *pnMimeTypeCount = 0;
    }

    if( NULL == pnFormatCount )
    {
        return( E_INVALIDARG );
    }

    if( NULL == pFormatEx )
    {
        return( E_INVALIDARG );
    }

    if( NULL == pppwszMimeType )
    {
        return( E_INVALIDARG );
    }

    if( NULL == pnMimeTypeCount )
    {
        return( E_INVALIDARG );
    }
   
    DWORD dwVersion;

    hr = GetCEPlayerVersion(&dwVersion);

    if(SUCCEEDED( hr ))
    {
        if( m_fAllowVideo )
        {
            cWaves = sizeof(g_krgWaveFormatsV2)/sizeof(g_krgWaveFormatsV2[0]);
            prgWaveFormats = g_krgWaveFormatsV2;
        }
        else
        {
            cWaves = sizeof(g_krgWaveFormatsV1)/sizeof(g_krgWaveFormatsV1[0]);
            prgWaveFormats = g_krgWaveFormatsV1;
        }
    }

    if (SUCCEEDED(hr))
    {
	    *pFormatEx = (_WAVEFORMATEX *)CoTaskMemAlloc(sizeof(_WAVEFORMATEX) * cWaves );
        if( NULL == *pFormatEx )
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if( SUCCEEDED( hr ) )
    {

        *pnFormatCount = cWaves;

        memcpy( *pFormatEx, prgWaveFormats, sizeof(_WAVEFORMATEX) * cWaves );
    }

    if( SUCCEEDED( hr ) )
    {
        cMimes = (sizeof(g_kszMimeTypes) / sizeof(g_kszMimeTypes[0]) - (m_fAllowVideo ? 0 : 2));
        *pppwszMimeType = (LPWSTR *)CoTaskMemAlloc( sizeof(LPWSTR) * cMimes );
        
        if( NULL == pppwszMimeType )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            for( idxMimes = 0; idxMimes < cMimes; idxMimes++ )
            {
                (*pppwszMimeType)[idxMimes] = NULL;
            }
        }
    }

    if( SUCCEEDED( hr ) )
    {
        for( idxMimes = 0; SUCCEEDED( hr ) && idxMimes < cMimes; idxMimes++ )
        {
            (*pppwszMimeType)[idxMimes] = (LPWSTR)CoTaskMemAlloc(sizeof(WCHAR)*(wcslen(g_kszMimeTypes[idxMimes])+1));

            if( NULL == (*pppwszMimeType)[idxMimes] )
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
        	    wcscpy( (*pppwszMimeType)[idxMimes], g_kszMimeTypes[idxMimes]);
            }
        }
    }

    if( SUCCEEDED( hr ) )
    {
        *pnMimeTypeCount = cMimes;
    }
    else
    {
        if( *pppwszMimeType )
        {
            for( idxMimes = 0; SUCCEEDED( hr ) && idxMimes < cMimes; idxMimes++ )
            {
                if( NULL != (*pppwszMimeType)[idxMimes] )
                {
                    CoTaskMemFree( (*pppwszMimeType)[idxMimes] );
                }
            }

            CoTaskMemFree( *pppwszMimeType );
            *pppwszMimeType = NULL;
        }

        if( *pFormatEx )
        {
            CoTaskMemFree( *pFormatEx );
            *pFormatEx = NULL;
        }

        *pnMimeTypeCount = 0;
        *pnFormatCount = 0;
    }

    return( hr );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\cewmdm\devenum.cpp ===
#include "stdafx.h"
#include "device.h"
#include "devenum.h"
//#include "findleak.h"

//DECLARE_THIS_FILE;

//
// Initialization
//
CDeviceEnum::CDeviceEnum()
{
    m_iCurItem = NULL;
    m_cItems = NULL;
    m_rgDevices = NULL;
}

HRESULT CDeviceEnum::Init( CComDevice **rgDevice, UINT cItems, UINT iCurItem )
{
    HRESULT hr = S_OK;

    if( NULL == rgDevice || 0 == cItems || iCurItem > cItems )
    {
        return( E_INVALIDARG );
    }

    m_rgDevices = new CComDevice*[cItems];
    if( NULL == m_rgDevices )
    {
        hr = E_OUTOFMEMORY;    
    }

    if( SUCCEEDED( hr ) )
    {
        m_iCurItem = iCurItem;
        m_cItems = cItems;

        while( cItems-- )
        {
            m_rgDevices[cItems] = rgDevice[cItems];
            if( m_rgDevices[cItems] )
            {
                m_rgDevices[cItems]->AddRef();
            }
        }
    }

    return( hr );
}

//
// Destruction
//

void CDeviceEnum::FinalRelease()
{
    UINT i = 0;

    if( m_rgDevices )
    {
        for( i = 0; i < m_cItems; i ++ )
        {
            if( m_rgDevices[i] )
            {
                m_rgDevices[i]->Release();
            }
        }

        delete [] m_rgDevices;
    }
}

//
// IMDSPEnumDevice interface
//

STDMETHODIMP CDeviceEnum::Next( ULONG celt, IMDSPDevice ** ppDevice, ULONG *pceltFetched )
{
    ULONG celtFetched = 0;
    HRESULT hr = S_OK;
    ULONG i;

    if( NULL == pceltFetched && celt != 1 )
    {
        return( E_INVALIDARG );
    }

    if( NULL == ppDevice )
    {
        return( E_POINTER );
    }

    for( i = 0; i < celt; i ++ )
    {
        ppDevice[i] = NULL;
    }
   
    while( celtFetched != celt )
    {
        if( m_iCurItem >= m_cItems )
        {
            hr = S_FALSE;
            break;
        }
        
        ppDevice[celtFetched] = m_rgDevices[m_iCurItem++];
        if( ppDevice[celtFetched] )
        {
            ppDevice[celtFetched++]->AddRef();
        }
    }

    if( NULL != pceltFetched )
    {
        *pceltFetched = celtFetched;
    }

    return( hr );
}

STDMETHODIMP CDeviceEnum::Skip( ULONG celt, ULONG *pceltFetched )
{
    ULONG celtSkipped = 0;
    HRESULT hr = S_OK;

    if( celt + m_iCurItem >= m_cItems )
    {
        celtSkipped = m_cItems - m_iCurItem;
        m_iCurItem = m_cItems;
        hr = S_FALSE;
    }
    else
    {
        celtSkipped = celt;
        m_iCurItem  += celt;
    }

    if( NULL != pceltFetched )
    {
        *pceltFetched = celtSkipped;
    }

    return( hr );
}

STDMETHODIMP CDeviceEnum::Reset( void )
{
    m_iCurItem = 0;
    return( S_OK );
}

STDMETHODIMP CDeviceEnum::Clone( IMDSPEnumDevice ** ppEnumDevice )
{
    CComEnumDevice *pNewEnum;
    CComPtr<IMDSPEnumDevice> spEnum;
    HRESULT hr = S_OK;

    if( SUCCEEDED(hr) )
    {
        hr = CComEnumDevice ::CreateInstance(&pNewEnum);
        spEnum = pNewEnum;
    }

    if( SUCCEEDED(hr) )
    {
        hr = pNewEnum->Init( m_rgDevices, m_cItems, m_iCurItem );
    }

    if( SUCCEEDED(hr) )
    {
        *ppEnumDevice = spEnum;
        spEnum.Detach();
    }

    return( S_OK );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\cewmdm\device.h ===
#pragma once

class CDevice:
public CComObjectRoot,
public IMDSPDevice2,
public ISpecifyPropertyPagesImpl<CDevice>
{

public:
    BEGIN_COM_MAP(CDevice)
        COM_INTERFACE_ENTRY2(IMDSPDevice, IMDSPDevice2)
        COM_INTERFACE_ENTRY(IMDSPDevice2)
        COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
    END_COM_MAP()

    //
    // Construction/Destruction
    //

    CDevice();
    virtual ~CDevice();
    HRESULT Init( LPCWSTR pszInitPath );

    BEGIN_PROP_MAP(CDevice)
        PROP_PAGE(__uuidof(FavoritesPropPage) )
    END_PROP_MAP()

public:

    //
    // IMDSPDevice
    //
    STDMETHOD( GetName )( LPWSTR pwszName, UINT nMaxChars);
    STDMETHOD( GetManufacturer )( LPWSTR pwszName, UINT nMaxChars);
    STDMETHOD( GetVersion ) ( DWORD *pdwVersion );
    STDMETHOD( GetType ) ( DWORD *pdwType );
    STDMETHOD( GetSerialNumber ) ( PWMDMID pSerialNumber, BYTE abMac[WMDM_MAC_LENGTH] ); 
    STDMETHOD( GetPowerSource ) ( DWORD *pdwPowerSource, DWORD *pdwPercentRemaining);
    STDMETHOD( GetStatus ) ( DWORD *pdwStatus );
    STDMETHOD( GetDeviceIcon )( ULONG *hIcon );
    STDMETHOD( EnumStorage )( IMDSPEnumStorage **ppEnumStorage );
    STDMETHOD( GetFormatSupport ) ( _WAVEFORMATEX **pFormatEx,
                                     UINT *pnFormatCount,
                                     LPWSTR **pppwszMimeType,
                                     UINT *pnMimeTypeCount);
    STDMETHOD( SendOpaqueCommand )( OPAQUECOMMAND *pCommand );

    //
    // IMDSPDevice2
    //
    STDMETHOD( GetStorage )( LPCWSTR pszStorageName, IMDSPStorage** ppStorage );
 
    STDMETHOD( GetFormatSupport2 )( DWORD dwFlags,
                                    _WAVEFORMATEX **ppAudioFormatEx,
                                    UINT *pnAudioFormatCount,
                                    _VIDEOINFOHEADER **ppVideoFormatEx,
                                    UINT *pnVideoFormatCount,
                                    WMFILECAPABILITIES **ppFileType,
                                    UINT *pnFileTypeCount);

    STDMETHOD ( GetSpecifyPropertyPages )( ISpecifyPropertyPages** ppSpecifyPropPages, 
                                           IUnknown*** pppUnknowns, 
                                           ULONG *pcUnks );


    STDMETHOD(GetPnPName)( LPWSTR pwszPnPName, UINT nMaxChars );

    //
    // Attributes
    //

private:
    STDMETHOD(GetCEPlayerVersion)(DWORD *pdwVersion);
    STDMETHOD(InternalGetFormatSupport)( _WAVEFORMATEX **pFormatEx,
                                         UINT *pnFormatCount,
                                         LPWSTR **pppwszMimeType,
                                         UINT *pnMimeTypeCount);

protected:
    LPWSTR m_pszInitPath;
    BOOL m_fAllowVideo;
};

typedef CComObject<CDevice> CComDevice;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\cewmdm\enumstorage.h ===
#pragma once
#include "storage.h"

class CEnumStorage:
public CComObjectRoot,
public IMDSPEnumStorage
{
//
// Construction/Destruction
//

public:
    CEnumStorage();
    HRESULT Init(LPCWSTR startPath, BOOL fIsDevice, IMDSPDevice *pDevice);
    HRESULT Init(CEnumStorage *pCopy, IMDSPDevice *pDevice);

    void FinalRelease();
public:
    BEGIN_COM_MAP(CEnumStorage)
        COM_INTERFACE_ENTRY(IMDSPEnumStorage)
    END_COM_MAP()

//
// IMDSPEnumStorage
//
    STDMETHOD( Next )( ULONG celt, IMDSPStorage ** ppDevice, ULONG *pceltFetched );
    STDMETHOD( Skip )( ULONG celt, ULONG *pceltFetched );        
    STDMETHOD( Reset )( void );        
    STDMETHOD( Clone )( IMDSPEnumStorage ** ppStorage );

protected:
    CE_FIND_DATA *m_rgFindData;
    UINT m_iCurItem;
    DWORD m_cItems;
    WCHAR m_szStartPath[MAX_PATH];
    CComPtr<IMDSPDevice> m_spDevice;
    BOOL m_fIsDevice;
};

typedef CComObject<CEnumStorage> CComEnumStorage;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\cewmdm\enumstorage.cpp ===
#include "stdafx.h"
#include "enumStorage.h"
#include <stdio.h>
//#include "findleak.h"

//DECLARE_THIS_FILE;

//
// Construction/Destruction
//

CEnumStorage::CEnumStorage()
{
    m_rgFindData = NULL;
    m_iCurItem = 0;
    m_cItems = 0;
    m_fIsDevice = FALSE;

    memset( m_szStartPath, 0, sizeof(m_szStartPath) );
}

HRESULT CEnumStorage::Init(LPCWSTR startPath, BOOL fIsDevice, IMDSPDevice *pDevice)
{
    HRESULT hr = S_OK;
    CE_FIND_DATA *rgFindData = NULL;
    WCHAR szSearchPath[MAX_PATH];
    DWORD cItems = 0;
    DWORD cStorageCardItems = 0;
    DWORD i = 0;
    BOOL fIsRootDevice = FALSE;

    if( NULL == pDevice ||
        NULL == startPath )
    {
        return( E_INVALIDARG );
    }

    m_spDevice = pDevice;
    m_fIsDevice = fIsDevice;

    if( startPath[0] != L'\\' )
    {
        wcscpy( m_szStartPath, L"\\" );
        hr = StringCbCatW(m_szStartPath, sizeof(m_szStartPath), startPath);
    }
    else
    {
        hr = StringCbCopyW(m_szStartPath, sizeof(m_szStartPath), startPath);
    }

    if (FAILED(hr))
    {
        return HRESULT_FROM_WIN32(HRESULT_CODE(hr)) ;
    }

    //
    // Check for root!
    //

    fIsRootDevice = ( 0 == _wcsicmp( L"\\", m_szStartPath ) );

    //
    // Make SURE there is a "My Documents" directory so that Cyprus's default storage lookup
    // stuff works properly
    //

    if( fIsDevice )
    {
        WCHAR szCreateDir[MAX_PATH];

        if( fIsRootDevice )
        {
            hr = StringCbPrintfW(szCreateDir, sizeof(szCreateDir), L"\\%s", L"My Documents");
        }
        else
        {
            hr = StringCbPrintfW(szCreateDir, sizeof(szCreateDir), L"%s\\%s", m_szStartPath, L"My Documents");
        }

        if (FAILED(hr))
        {
            return HRESULT_FROM_WIN32(HRESULT_CODE(hr)) ;
        }

        CeCreateDirectory( szCreateDir, NULL );
    }

    if( !m_fIsDevice ||                       // Are we a device at all?
        (m_fIsDevice && !fIsRootDevice) )     // Are we a storage card?
    {
        if( !m_fIsDevice )
        {
            if( fIsRootDevice )
            {
                hr = StringCbPrintfW(szSearchPath, sizeof(szSearchPath), L"%s*.*", m_szStartPath );
            }
            else
            {
                hr = StringCbPrintfW (szSearchPath, sizeof(szSearchPath), L"%s\\*.*", m_szStartPath );
            }
            
        }
        else
        {
            hr = StringCbCopyW(szSearchPath, sizeof(szSearchPath), m_szStartPath);
        }

        if (FAILED(hr))
        {
            return HRESULT_FROM_WIN32(HRESULT_CODE(hr)) ;
        }
            
        if( !CeFindAllFiles( szSearchPath,
                        FAF_ATTRIBUTES | 
                        FAF_CREATION_TIME | 
                        FAF_LASTACCESS_TIME | 
                        FAF_LASTWRITE_TIME  | 
                        FAF_SIZE_HIGH | 
                        FAF_SIZE_LOW | 
                        FAF_OID | 
                        FAF_NAME,
                        &cItems,
                        &rgFindData ) )
        {
            hr = HRESULT_FROM_WIN32( CeGetLastError() );

            if( SUCCEEDED( hr ) )
            {
                hr = CeRapiGetError();
            }
        }

        //
        // if this is the CE device, then skip storage cards
        //

        if( SUCCEEDED( hr ) && fIsRootDevice )
        {
            for( i = 0; i < cItems; i ++ )
            {
                if( rgFindData[i].dwFileAttributes & FILE_ATTRIBUTE_TEMPORARY )
                {
                    cStorageCardItems++;
                }
            }
        }

        if( SUCCEEDED( hr ) )
        {
            m_rgFindData = new CE_FIND_DATA[cItems - cStorageCardItems];
            if( NULL == m_rgFindData )
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                if( fIsRootDevice )
                {
                    m_cItems = 0;
                    for( i = 0; i < cItems; i++ )
                    {
                        if( !(rgFindData[i].dwFileAttributes & FILE_ATTRIBUTE_TEMPORARY) )
                        {
                            memcpy( &m_rgFindData[m_cItems], &rgFindData[i], sizeof(rgFindData[i]) );
                            m_cItems++;
                        }
                    }
                }
                else
                {
                    m_cItems = cItems;
                    memcpy( m_rgFindData, rgFindData, cItems * sizeof(rgFindData[0]) );
                }
            }

            if( rgFindData )
            {
                CeRapiFreeBuffer( rgFindData );
                rgFindData  = NULL;
            }

            //
            // Since CE doesn't set the FILE_ATTRIBUTE_HAS_CHILDREN, then I have to do it myself
            //

            DWORD idxItems = m_cItems;

            while( SUCCEEDED( hr ) && idxItems-- )
            {
                WCHAR szDirPath[MAX_PATH];
                DWORD dirItems = 0;
            
                if( !( m_rgFindData[idxItems].dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) )
                {
                    continue;
                }

                memset( szDirPath, 0, sizeof(szDirPath) );

                if( !m_fIsDevice )
                {
                    if( fIsRootDevice )
                    {
                        hr = StringCbPrintfW(szDirPath, sizeof(szDirPath), L"\\%s\\*.*", m_rgFindData[idxItems].cFileName );
                    }
                    else
                    {
                        hr = StringCbPrintfW(szDirPath, sizeof(szDirPath), L"%s\\%s\\*.*", m_szStartPath, m_rgFindData[idxItems].cFileName );
                    }
                }
                else
                {
                    hr = StringCbPrintf(szDirPath, sizeof(szDirPath), L"%s\\*.*", m_szStartPath ); // , m_rgFindData[idxItems].cFileName );
                }

                if (FAILED(hr))
                {
                    continue;
                }

                if( !CeFindAllFiles( szDirPath,
                                FAF_FOLDERS_ONLY,
                                &dirItems,
                                &rgFindData ) )
                {
                    hr = HRESULT_FROM_WIN32( CeGetLastError() );

                    if( SUCCEEDED( hr ) )
                    {
                        hr = CeRapiGetError();
                    }
                }

                if( SUCCEEDED( hr ) )
                {
                    if( 0 != dirItems &&
                        dirItems != cStorageCardItems )
                    {
                        m_rgFindData[idxItems].dwFileAttributes |= FILE_ATTRIBUTE_HAS_CHILDREN;
                    }

                    if( rgFindData )
                    {
                        CeRapiFreeBuffer( rgFindData );
                        rgFindData  = NULL;
                    }
                }
            }
        }
    }
    else
    {
        m_cItems = 1;
        m_rgFindData = new CE_FIND_DATA[m_cItems];

        if( NULL == m_rgFindData )
        {
            hr = E_OUTOFMEMORY;
        }

        if( SUCCEEDED( hr ) )
        {
            memset( &m_rgFindData[0], 0, sizeof(m_rgFindData[0]) );

            if( fIsRootDevice )
            {
                //
                // We must make up a date, and set attributes & name
                //

                if( SUCCEEDED( hr ) )
                {
                    m_rgFindData[0].dwFileAttributes = FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HAS_CHILDREN;
                    wcscpy(m_rgFindData[0].cFileName, L"\\");

                    GetSystemTimeAsFileTime( &m_rgFindData[0].ftCreationTime );
                    GetSystemTimeAsFileTime( &m_rgFindData[0].ftLastAccessTime );
                    GetSystemTimeAsFileTime( &m_rgFindData[0].ftLastWriteTime );
                }
            }
        }
    }

    return( hr );
}

HRESULT CEnumStorage::Init(CEnumStorage *pCopy, IMDSPDevice *pDevice)
{
    HRESULT hr = S_OK;

    if( NULL == pCopy || NULL == pDevice)
    {
        return( E_INVALIDARG );
    }

    m_spDevice = pDevice;
    m_cItems = pCopy->m_cItems;
    m_iCurItem = pCopy->m_iCurItem;
    wcsncpy(m_szStartPath, pCopy->m_szStartPath, sizeof(m_szStartPath)/sizeof(m_szStartPath[0]) - 1 );

    m_rgFindData = new CE_FIND_DATA[ m_cItems ];

    if( NULL == m_rgFindData )
    {
        hr = E_OUTOFMEMORY;
    }

    if( SUCCEEDED( hr ) )
    {
        memcpy(m_rgFindData, pCopy->m_rgFindData, m_cItems * sizeof(m_rgFindData[0]) );
    }

    return( hr );
}

void CEnumStorage::FinalRelease()
{
    if( m_rgFindData )
    {
        delete [] m_rgFindData;
    }
}

//
// IMDSPEnumStorage
//

STDMETHODIMP CEnumStorage::Next( ULONG celt, IMDSPStorage ** ppStorage, ULONG *pceltFetched )
{
    ULONG celtFetched = 0;
    HRESULT hr = S_OK;
    ULONG i;

    if( NULL == pceltFetched && celt != 1 )
    {
        return( E_INVALIDARG );
    }

    if( NULL == ppStorage )
    {
        return( E_POINTER );
    }

    for( i = 0; i < celt; i++ )
    {
        ppStorage[i] = NULL;
    }

    while( celtFetched != celt && SUCCEEDED( hr ) )
    {
        if( m_iCurItem >= m_cItems )
        {
            hr = S_FALSE;
            break;
        }
        
        CComStorage *pNewStorage = NULL;

        hr = CComStorage::CreateInstance( &pNewStorage );

        if( SUCCEEDED( hr ) )
        {
            hr = pNewStorage->Init(&m_rgFindData[m_iCurItem], m_szStartPath, m_fIsDevice, m_spDevice);
        }

        if( SUCCEEDED( hr ) )
        {
            ppStorage[celtFetched] = pNewStorage;
            ppStorage[celtFetched++]->AddRef();
            m_iCurItem++;
        }
    }

    if( FAILED(hr) )
    {
        while( celtFetched-- )
        {
            ppStorage[celtFetched]->Release();
            ppStorage[celtFetched] = NULL;
            m_iCurItem--;
        }

        celtFetched = 0;
    }

    if( NULL != pceltFetched )
    {
        *pceltFetched = celtFetched;
    }

    return( hr );
}


STDMETHODIMP CEnumStorage::Skip( ULONG celt, ULONG *pceltFetched )
{
    ULONG celtSkipped = 0;
    HRESULT hr = S_OK;

    if( celt + m_iCurItem >= m_cItems )
    {
        celtSkipped = m_cItems - m_iCurItem;
        m_iCurItem = m_cItems;
        hr = S_FALSE;
    }
    else
    {
        celtSkipped = celt;
        m_iCurItem  += celt;
    }

    if( NULL != pceltFetched )
    {
        *pceltFetched = celtSkipped;
    }

    return( hr );
}

STDMETHODIMP CEnumStorage::Reset( void )
{
    m_iCurItem = 0;
    return( S_OK );
}

STDMETHODIMP CEnumStorage::Clone( IMDSPEnumStorage ** ppStorage )
{
    CComEnumStorage *pNewEnum;
    CComPtr<IMDSPEnumStorage> spEnum;
    HRESULT hr = S_OK;

    if( SUCCEEDED(hr) )
    {
        hr = CComEnumStorage ::CreateInstance(&pNewEnum);
        spEnum = pNewEnum;
    }

    if( SUCCEEDED(hr) )
    {
        hr = pNewEnum->Init( this , m_spDevice );
    }

    if( SUCCEEDED(hr) )
    {
        *ppStorage = spEnum;
        spEnum.Detach();
    }

    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\cewmdm\key.h ===
extern "C" BYTE g_abPriv[4096];
extern "C" BYTE g_abAppCert[100];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\cewmdm\proppage.cpp ===
#include "stdafx.h"
#include "propPage.h"

#define DASSERT _ASSERTE
#include "errorBase.h"

#define CEDB_FAVORITES_NAME  L"WMPlayer.Favorites"
#define CEDB_PROP_ID_URL    MAKEWPARAM( CEVT_LPWSTR, 1 )
#define CEDB_PROP_ID_NAME   MAKEWPARAM( CEVT_LPWSTR, 2 )

CFavoritesPropertyPage::CFavoritesPropertyPage():
    m_hwndList( NULL ),
    m_hDb( INVALID_HANDLE_VALUE ),
    m_fLeaveDBOpen( FALSE ),
    m_hCursorWait( NULL )
{
    m_dwTitleID = IDS_CE_PROPPAGE_FAVORITES_TITLE;
    m_hCursorWait = LoadCursor( NULL, MAKEINTRESOURCE( IDC_WAIT ) );
}

CFavoritesPropertyPage::~CFavoritesPropertyPage()
{
    _ASSERTE( INVALID_HANDLE_VALUE == m_hDb );
}

//
// Message Handlers
//

LRESULT CFavoritesPropertyPage::OnItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    EnableControls();
    return( 0 );
}

LRESULT CFavoritesPropertyPage::OnEndLabelEdit(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    NMLVDISPINFO *pnmLV = (NMLVDISPINFO *)pnmh;

    if( NULL != pnmLV->item.pszText )
    {
        LVITEM lvi;
        memset( &lvi, 0, sizeof(lvi) );

        lvi.mask = LVIF_PARAM;
        lvi.iItem = pnmLV->item.iItem;
        lvi.lParam = (BOOL)TRUE;

        ListView_SetItem( m_hwndList, &lvi );
        ListView_SetColumnWidth( m_hwndList, 0, LVSCW_AUTOSIZE );
        ListView_SetColumnWidth( m_hwndList, 1, LVSCW_AUTOSIZE );
        SetDirty( TRUE );
        return( TRUE );
    }

    return( 0 );
}

LRESULT CFavoritesPropertyPage::OnKeyDown(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    LPNMLVKEYDOWN pnmKeyDown = (LPNMLVKEYDOWN)pnmh;

    if( NULL != pnmKeyDown )
    {
        if( VK_DELETE == pnmKeyDown->wVKey &&
            ::IsWindowEnabled( GetDlgItem( IDC_CE_PROPPAGE_FAVORITES_DELETE ) ) )
        {
            PostMessage( WM_COMMAND, MAKEWPARAM( IDC_CE_PROPPAGE_FAVORITES_DELETE, 0 ), 0 );
        }
        else if ( VK_INSERT == pnmKeyDown->wVKey &&
                  ::IsWindowEnabled( GetDlgItem( IDC_CE_PROPPAGE_FAVORITES_ADD ) ) )
        {
            PostMessage( WM_COMMAND, MAKEWPARAM( IDC_CE_PROPPAGE_FAVORITES_ADD, 0 ), 0 );
        }
    }

    return( 0 );
}

LRESULT CFavoritesPropertyPage::OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    CAddDialog dlg;
    HRESULT hr = S_OK;

    if( IDOK == dlg.DoModal( m_hWnd ) &&
        0 != wcslen( dlg.m_wszURL ) )
    {
        hr = AddFavorite( dlg.m_wszURL, dlg.m_wszName, TRUE );
    }

    EnableControls();

    ShowError( hr );

    return( 0 );
}

LRESULT CFavoritesPropertyPage::OnDelete(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HCURSOR hCurNormal = NULL;
    
    if( NULL != m_hCursorWait)
    {
        hCurNormal = SetCursor( m_hCursorWait );
    }

    int iItem = -1;
    HRESULT hr = S_OK;

    m_fLeaveDBOpen = TRUE;

    while( SUCCEEDED( hr ) && -1 != (iItem = ListView_GetNextItem( m_hwndList, -1, LVNI_SELECTED ) ) )
    {
        hr = ManageFavorites( iItem, TRUE );
        UpdateWindow();
    }

    m_fLeaveDBOpen = FALSE;
    if( INVALID_HANDLE_VALUE != m_hDb )
    {
        CeCloseHandle( m_hDb );
        m_hDb = INVALID_HANDLE_VALUE;
    }

    //
    // Since the user could have deleted their radio presets, allow them to do it again
    //

    EnableControls();

    if( NULL != hCurNormal )
    {
        SetCursor( hCurNormal );
    }

    ShowError( hr );

    return( 0 );
}

//
// IPropertyPage
//

STDMETHODIMP CFavoritesPropertyPage::Activate (HWND hWndParent, LPCRECT pRect, BOOL bModal)
{
    HRESULT hr = S_OK;

    hr = IPropertyPageImpl<CFavoritesPropertyPage>::Activate( hWndParent, pRect, bModal );

    if( SUCCEEDED( hr ) )
    {
        hr = InitList();
    }

    if( SUCCEEDED( hr ) )
    {
        hr = EnableControls();
    }

    ShowError( hr );

    return( hr );
}

STDMETHODIMP CFavoritesPropertyPage::Apply()
{
    HCURSOR hCurNormal = NULL;
    
    if( NULL != m_hCursorWait)
    {
        hCurNormal = SetCursor( m_hCursorWait );
    }

    int iItems = ListView_GetItemCount( m_hwndList );
    HRESULT hr = S_OK;

    if( !m_bDirty )
    {
        return( S_OK );
    }

    m_fLeaveDBOpen = TRUE;

    if( -1 != iItems )
    {
        while( SUCCEEDED( hr ) && iItems-- )
        {
            hr = ManageFavorites( iItems, FALSE );
        }
    }

    m_fLeaveDBOpen = FALSE;
    if( INVALID_HANDLE_VALUE != m_hDb )
    {
        CeCloseHandle( m_hDb );
        m_hDb = INVALID_HANDLE_VALUE;
    }

    SetDirty( FAILED( hr ) );

    if( NULL != hCurNormal )
    {
        SetCursor( hCurNormal );
    }

    ShowError( hr );

    return( hr );
}

HRESULT CFavoritesPropertyPage::InitList()
{
    HRESULT          hr = S_OK;
    CEOID             dbOID;
    HANDLE            hDb = INVALID_HANDLE_VALUE;
    HRESULT           hrFailCreate = S_OK;
    BOOL              fNoItems = TRUE;
    HCURSOR hCurNormal = NULL;
    
    if( NULL != m_hCursorWait)
    {
        hCurNormal = SetCursor( m_hCursorWait );
    }

    m_hwndList = GetDlgItem( IDC_CE_PROPPAGE_FAVORITES_FAVORITES );

    if( NULL == m_hwndList )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
    }

    if( SUCCEEDED( hr ) )
    {
        LVCOLUMN lvc;
        WCHAR wszColumn[MAX_PATH];
        
        ListView_SetExtendedListViewStyle( m_hwndList, LVS_EX_FULLROWSELECT );
        
        lvc.mask = LVCF_TEXT;
        lvc.pszText = wszColumn;

        LoadString( _Module.GetResourceInstance(), IDS_NAME, wszColumn, sizeof(wszColumn)/sizeof(wszColumn[0]) );
        ListView_InsertColumn( m_hwndList, 0, &lvc );

        LoadString( _Module.GetResourceInstance(), IDS_CE_PROPPAGE_FAVORITES_URL, wszColumn, sizeof(wszColumn)/sizeof(wszColumn[0]) );
        ListView_InsertColumn( m_hwndList, 1, &lvc );
    }

    //
    // 
    //
    //
    //

    if( SUCCEEDED( hr ) )
    {

        dbOID = CeCreateDatabase( CEDB_FAVORITES_NAME, 0, 0, NULL );
        if( 0 == dbOID )
        {
            hrFailCreate = HRESULT_FROM_WIN32( CeGetLastError() );
            if( SUCCEEDED( hrFailCreate ) )
            {
                hrFailCreate = HRESULT_FROM_WIN32( CeRapiGetError() );
            }
        }

        if( FAILED( hrFailCreate ) )
        {
            dbOID = 0;
        }

        hDb = CeOpenDatabase( &dbOID, CEDB_FAVORITES_NAME, 0, CEDB_AUTOINCREMENT, NULL );
        if( INVALID_HANDLE_VALUE == hDb )
        {           
            if( FAILED( hrFailCreate ) )
            {
                hr = hrFailCreate;
            }
            else
            {
                hr = HRESULT_FROM_WIN32( CeGetLastError() );
                if( SUCCEEDED( hr ) )
                {
                    hr = HRESULT_FROM_WIN32( CeRapiGetError() );
                }
            }
        }
    }

    if( SUCCEEDED( hr ) )
    {
        CEPROPVAL *pProps = NULL;
        WORD      cProps = 0;
        LPBYTE    lpBuffer = NULL;
        LPWSTR    pszURL = NULL;
        LPWSTR    pszName = NULL;
        DWORD     dwSize = 0;

        while( 0 != (dbOID = CeReadRecordProps( hDb, CEDB_ALLOWREALLOC, &cProps, NULL, &lpBuffer, &dwSize )  ) )
        {
            pszURL = NULL;
            pszName = NULL;

            _ASSERTE( NULL != lpBuffer );
            if( NULL == lpBuffer )
            {
                continue;
            }

            while( cProps-- )
            {
                pProps =  &(( CEPROPVAL *)lpBuffer)[cProps];
                if( pProps->propid == CEDB_PROP_ID_NAME )
                {
                    pszName = pProps->val.lpwstr;
                }
                if( pProps->propid == CEDB_PROP_ID_URL )
                {
                    pszURL = pProps->val.lpwstr;
                }
            }

            if( NULL != pszName && NULL != pszURL )
            {
                if( SUCCEEDED( AddFavorite( pszURL, pszName, FALSE ) ) )
                {
                    fNoItems = FALSE;
                }
            }

            LocalFree( lpBuffer );
            cProps = 0;
            lpBuffer = NULL;
            dwSize = 0;
        }
    }

    if( SUCCEEDED( hr ) )
    {
        if( fNoItems )
        {
            ListView_SetColumnWidth( m_hwndList, 0, LVSCW_AUTOSIZE_USEHEADER );
            ListView_SetColumnWidth( m_hwndList, 1, LVSCW_AUTOSIZE_USEHEADER );
        }
        else
        {
            ListView_SetColumnWidth( m_hwndList, 0, LVSCW_AUTOSIZE );
            ListView_SetColumnWidth( m_hwndList, 1, LVSCW_AUTOSIZE );
        }
    }

    if( INVALID_HANDLE_VALUE != hDb )
    {
        CeCloseHandle( hDb );
    }

    if( NULL != hCurNormal )
    {
        SetCursor( hCurNormal );
    }

    return( hr );
}

HRESULT CFavoritesPropertyPage::EnableControls()
{
    int iSelectedItem = 0;
    long cItems = 0;

    iSelectedItem = ListView_GetNextItem( m_hwndList, -1, LVNI_SELECTED );

    ::EnableWindow( GetDlgItem( IDC_CE_PROPPAGE_FAVORITES_DELETE ), -1 != iSelectedItem );

    ::ShowWindow( GetDlgItem( IDC_CE_PROPPAGE_FAVORITES_EXPORT ), SW_HIDE );

    return( S_OK );
}

void CFavoritesPropertyPage::ShowError(HRESULT hrError)
{
    if( FAILED( hrError ) )
    {
        LPTSTR pszBuffer = NULL;
        if( 0 != FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM |
                                FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                                FORMAT_MESSAGE_IGNORE_INSERTS, 
                                NULL,
                                hrError,
                                0,
                                (LPTSTR)&pszBuffer,
                                0,
                                NULL ) )
        {
            MessageBox( pszBuffer, NULL, MB_OK );
        }

        if( NULL != pszBuffer )
        {
            LocalFree( pszBuffer );
        }
    }
}

HRESULT CFavoritesPropertyPage::ManageFavorites( int iItem, BOOL fRemove)
{
    HRESULT           hr = S_OK;
    WCHAR             wszURL[INTERNET_MAX_URL_LENGTH];
    WCHAR             wszName[MAX_PATH];
    LVITEM            lvi;

    wszURL[0] = L'\0';
    wszName[0] = L'\0';

    memset( &lvi, 0, sizeof(lvi) );
    lvi.iItem = iItem;
    lvi.mask = LVIF_PARAM;
    ListView_GetItem( m_hwndList, &lvi);

    if( 0 != lvi.lParam || fRemove )
    {
        ListView_GetItemText( m_hwndList, iItem, 0, wszName, sizeof(wszName)/sizeof(wszName[0]) );
        ListView_GetItemText( m_hwndList, iItem, 1, wszURL, sizeof(wszURL)/sizeof(wszURL[0]) );

        if( 0 == wcslen( wszURL ) )
        {
            hr = E_INVALIDARG;
        }

        if( SUCCEEDED( hr ) )
        {
            hr = ManageFavorites( wszURL, wszName, fRemove );
        }

        if( SUCCEEDED( hr ) )
        {
            if( fRemove )
            {
                ListView_DeleteItem( m_hwndList, iItem );
            }
            else
            {
                lvi.lParam = 0;
                ListView_SetItem( m_hwndList, &lvi );
            }
        }
    }


    return( hr );
}

HRESULT CFavoritesPropertyPage::ManageFavorites( LPWSTR pszURL, LPWSTR pszName, BOOL fRemove )
{
    CEOID             dbOID;
    HANDLE            hDb = INVALID_HANDLE_VALUE;
    HRESULT           hrFailCreate = S_OK;
    BOOL              fFound = FALSE;
    BOOL              fRename = FALSE;
    HRESULT           hr = S_OK;

    if( INVALID_HANDLE_VALUE != m_hDb )
    {
        hDb = m_hDb;
    }
    else
    {
        if( SUCCEEDED( hr ) )
        {
            dbOID = CeCreateDatabase( CEDB_FAVORITES_NAME, 0, 0, NULL );
            if( 0 == dbOID )
            {
                hrFailCreate = HRESULT_FROM_WIN32( CeGetLastError() );
                if( SUCCEEDED( hrFailCreate ) )
                {
                    hrFailCreate = HRESULT_FROM_WIN32( CeRapiGetError() );
                }
            }

            if( FAILED( hrFailCreate ) )
            {
                dbOID = 0;
            }

            hDb = CeOpenDatabase( &dbOID, CEDB_FAVORITES_NAME, 0, CEDB_AUTOINCREMENT, NULL );
            if( INVALID_HANDLE_VALUE == hDb )
            {           
                if( FAILED( hrFailCreate ) )
                {
                    hr = hrFailCreate;
                }
                else
                {
                    hr = HRESULT_FROM_WIN32( CeGetLastError() );
                    if( SUCCEEDED( hr ) )
                    {
                        hr = HRESULT_FROM_WIN32( CeRapiGetError() );
                    }
                }
            }
        }
    }

    if( SUCCEEDED( hr ) )
    {
        CEPROPVAL *pProps = NULL;
        CEPROPVAL props[2];
        WORD      cProps = 0;
        LPBYTE    lpBuffer = NULL;
        DWORD     dwSize = 0;

        memset( &props, 0, sizeof(props) );

        props[0].propid = CEDB_PROP_ID_URL;
        props[0].val.lpwstr = pszURL;

        props[1].propid = CEDB_PROP_ID_NAME;
        props[1].val.lpwstr = pszName;

        while( 0 != (dbOID = CeReadRecordProps( hDb, CEDB_ALLOWREALLOC, &cProps, NULL, &lpBuffer, &dwSize)  ) )
        {
            _ASSERTE( NULL != lpBuffer );
            if( NULL == lpBuffer )
            {
                continue;
            }

            while( cProps-- )
            {
                pProps =  &(( CEPROPVAL *)lpBuffer)[cProps];

                if( pProps->propid == CEDB_PROP_ID_NAME &&
                    0 != wcsicmp( pProps->val.lpwstr, pszName ) )
                {
                    fRename = TRUE;
                }

                if( pProps->propid == CEDB_PROP_ID_URL &&
                    0 == wcsicmp( pProps->val.lpwstr, pszURL ) )
                {
                    fFound = TRUE;
                    break;
                }
            }

            LocalFree( lpBuffer );
            cProps = 0;
            lpBuffer = NULL;
            dwSize = 0;

            if( fFound )
            {
                break;
            }
            else
            {
                fRename = FALSE;
            }
        }

        if( fRemove )
        {
            if( fFound )
            {
                if( !CeDeleteRecord( hDb, dbOID ) )
                {
                    hr = HRESULT_FROM_WIN32( CeGetLastError() );
                    if( SUCCEEDED( hr ) )
                    {
                        hr = HRESULT_FROM_WIN32( CeRapiGetError() );
                    }
                }
            }
        }
        else
        {
            if( ( !fFound || fRename ) && 0 == CeWriteRecordProps( hDb, fRename ? dbOID : 0, sizeof(props)/sizeof(props[0]), props ) )
            {
                hr = HRESULT_FROM_WIN32( CeGetLastError() );
                if( SUCCEEDED( hr ) )
                {
                    hr = HRESULT_FROM_WIN32( CeRapiGetError() );
                }
            }
        }
    }

    if( INVALID_HANDLE_VALUE != hDb )
    {
        if( m_fLeaveDBOpen )
        {
            m_hDb = hDb;
        }
        else
        {
            CeCloseHandle( hDb );
        }
    }

    return( hr );
}

HRESULT CFavoritesPropertyPage::AddFavorite( LPWSTR pszURL, LPWSTR pszName, BOOL fDirty )
{
    HRESULT hr = S_OK;
    bool fAddedItem = false;
    LVITEM lvi;
    int iItem = -1;
    int cItems = ListView_GetItemCount( m_hwndList );
    WCHAR wszURL[INTERNET_MAX_URL_LENGTH];
    WCHAR wszName[MAX_PATH];
    bool  fFound = false;

    if( NULL == pszURL || NULL == pszName )
    {
        hr = E_INVALIDARG;
    }

    if( SUCCEEDED( hr ) )
    {
        //
        // Try to find the item first
        //

        while( cItems-- )
        {
            ListView_GetItemText( m_hwndList, cItems, 1, wszURL, sizeof(wszURL)/sizeof(wszURL[0]) );
            if( 0 == wcsicmp( pszURL, wszURL ) )
            {
                iItem = cItems;
                fFound = true;
                break;
            }
        }

        //
        // If we didn't find it, then insert one
        //

        memset( &lvi, 0, sizeof(lvi) );
        if( -1 == iItem )
        {
            lvi.iItem = ListView_GetItemCount( m_hwndList );
            iItem = ListView_InsertItem( m_hwndList, &lvi );
        }
        else
        {
            lvi.iItem = iItem;
        }

        if( -1 != iItem )
        {

            ListView_SetItemText( m_hwndList, iItem, 0, pszName );
            ListView_SetItemText( m_hwndList, iItem, 1, pszURL );

            lvi.mask = LVIF_PARAM;

            if( fFound )
            {
                ListView_GetItem( m_hwndList, &lvi );

                fDirty = lvi.lParam;

                if( !fDirty )
                {
                    ListView_GetItemText( m_hwndList, iItem, 0, wszName, sizeof(wszName)/sizeof(wszName[0]) );
                    fDirty = wcsicmp( pszName, wszName );
                }
            }

            lvi.lParam = (LPARAM)fDirty;
            ListView_SetItem( m_hwndList, &lvi );
            ListView_EnsureVisible( m_hwndList, iItem, FALSE );
            ListView_SetColumnWidth( m_hwndList, 0, LVSCW_AUTOSIZE );
            ListView_SetColumnWidth( m_hwndList, 1, LVSCW_AUTOSIZE );
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    if( SUCCEEDED( hr ) )
    {
        SetDirty( fDirty );
    }

    return( hr );
}

///////////////////////////////////////////////////////////////////////////////////////
//
//
//

CAddDialog::CAddDialog()
{
    m_wszURL[0] = L'\0';
    m_wszName[0] = L'\0';
}

LRESULT CAddDialog::OnURLChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    EnableControls();
    return( 0 );
}

LRESULT CAddDialog::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    SendDlgItemMessage( IDC_CE_PROPPAGE_FAVORITES_URL, WM_GETTEXT, sizeof(m_wszURL)/sizeof(m_wszURL[0]), (LPARAM)m_wszURL );
    SendDlgItemMessage( IDC_CE_PROPPAGE_FAVORITES_NAME, WM_GETTEXT, sizeof(m_wszName)/sizeof(m_wszName[0]), (LPARAM)m_wszName );

    EndDialog( IDOK );
    return( 0 );
}

LRESULT CAddDialog::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    EndDialog( IDCANCEL );
    return( 0 );
}

LRESULT CAddDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SendDlgItemMessage( IDC_CE_PROPPAGE_FAVORITES_URL, EM_LIMITTEXT, sizeof(m_wszURL)/sizeof(m_wszURL[0]), 0 );
    SendDlgItemMessage( IDC_CE_PROPPAGE_FAVORITES_NAME, EM_LIMITTEXT, sizeof(m_wszName)/sizeof(m_wszName[0]), 0 );

    EnableControls();
    return( 0 );
}

void CAddDialog::EnableControls()
{
    ::EnableWindow( GetDlgItem(IDOK), SendDlgItemMessage( IDC_CE_PROPPAGE_FAVORITES_URL, WM_GETTEXTLENGTH, 0, 0 ) != 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\cewmdm\keys.c ===
#include "wtypes.h"
BYTE g_abPriv[4096] = {
	0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 
	0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 
	0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 
	0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 
	0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 
	0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 
	0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 
	0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 
	0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 
	0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 
	0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 
	0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 
	0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 
	0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 
	0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 
	0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 
	0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 
	0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 
	0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 
	0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 
	0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 
	0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 
	0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 
	0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 
	0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 
	0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 
	0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 
	0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 
	0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 
	0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 
	0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 
	0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 
	0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 
	0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 
	0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 
	0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 
	0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 
	0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 
	0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 
	0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 
	0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 
	0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 
	0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 
	0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 
	0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 
	0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 
	0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 
	0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 
	0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 
	0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 
	0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 
	0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 
	0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 
	0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 
	0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 
	0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 
	0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 
	0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 
	0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 
	0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 
	0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 
	0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 
	0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 
	0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 
	0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 
	0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 
	0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 
	0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 
	0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 
	0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 
	0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 
	0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 
	0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 
	0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 
	0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 
	0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 
	0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 
	0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 
	0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 
	0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 
	0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 
	0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 
	0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 
	0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 
	0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 
	0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 
	0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 
	0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 
	0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 
	0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 
	0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 
	0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 
	0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 
	0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 
	0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 
	0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 
	0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 
	0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 
	0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 
	0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 
	0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 
	0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 
	0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 
	0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 
	0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 
	0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 
	0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 
	0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 
	0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 
	0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 
	0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 
	0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 
	0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 
	0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 
	0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 
	0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 
	0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 
	0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 
	0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 
	0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 
	0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 
	0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 
	0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 
	0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 
	0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 
	0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 
	0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 
	0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 
	0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 
	0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 
	0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 
	0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 
	0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 
	0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 
	0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 
	0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 
	0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 
	0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 
	0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 
	0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 
	0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 
	0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 
	0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 
	0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 
	0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 
	0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 
	0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 
	0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 
	0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 
	0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 
	0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 
	0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 
	0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 
	0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 
	0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 
	0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 
	0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 
	0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 
	0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 
	0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 
	0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 
	0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 
	0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 
	0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 
	0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 
	0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 
	0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 
	0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 
	0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 
	0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 
	0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 
	0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 
	0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 
	0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 
	0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 
	0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 
	0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 
	0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 
	0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 
	0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 
	0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 
	0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 
	0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 
	0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 
	0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 
	0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 
	0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 
	0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 
	0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 
	0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 
	0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 
	0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 
	0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 
	0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 
	0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 
	0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 
	0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 
	0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 
	0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 
	0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 
	0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 
	0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 
	0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 
	0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 
	0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 
	0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 
	0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 
	0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 
	0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 
	0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 
	0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 
	0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 
	0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 
	0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 
	0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 
	0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 
	0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 
	0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 
	0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 
	0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 
	0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 
	0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 
	0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 
	0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 
	0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 
	0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 
	0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 
	0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 
	0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 
	0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 
	0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 
	0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 
	0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 
	0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 
	0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 
	0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 
	0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 
	0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 
	0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0x2C, 
	0xE7, 0x8E, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 
	0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 
	0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 
	0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 
	0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 
	0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 
	0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 
	0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 
	0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 
	0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 
	0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 
	0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 
	0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 
	0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 
	0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 
	0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 
	0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 
	0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 
	0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0x51, 0xEA, 
	0xBB, 0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 
	0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 
	0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 
	0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 
	0xBC, 0x27, 0x6D, 0xA1, 0x75, 0x9E, 0xC4, 0xC5, 
	0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 
	0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 
	0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 
	0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 
	0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 
	0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 
	0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 
	0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 
	0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 
	0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 
	0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0x58, 
	0xE8, 0xA6, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 
	0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 
	0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 
	0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 
	0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 
	0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 
	0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 
	0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 
	0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 
	0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 
	0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 
	0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 
	0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 
	0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 
	0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 
	0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 
	0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 
	0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 
	0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 
	0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 
	0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 
	0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 
	0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 
	0xC3, 0xDC, 0x72, 0x22, 0x49, 0x0A, 0xE5, 0xCF, 
	0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 
	0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 
	0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 
	0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x51, 0x49, 
	0x47, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 
	0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 
	0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 
	0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 
	0xEA, 0x61, 0x14, 0x48, 0xBE, 0x3E, 0x45, 0xEB, 
	0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 
	0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 
	0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 
	0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 
	0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 
	0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 
	0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 
	0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 
	0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 
	0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 
	0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 
	0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 
	0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 
	0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 
	0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 
	0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 
	0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 
	0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 
	0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x26, 0x2D, 
	0x97, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 
	0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 
	0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 
	0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 
	0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 
	0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 
	0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 
	0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 
	0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 
	0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 
	0x0B, 0x91, 0x57, 0xC8, 0x56, 0x3E, 0xF5, 0x07, 
	0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 
	0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 
	0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 
	0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 
	0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 
	0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 
	0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 
	0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 
	0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 
	0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 
	0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 
	0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 
	0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 
	0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 
	0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 
	0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 
	0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 
	0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 
	0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 
	0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 
	0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 
	0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 
	0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 
	0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x4E, 0x26, 
	0xF0, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 
	0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 
	0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 
	0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 
	0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 
	0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 
	0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 
	0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 
	0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 
	0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 
	0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 
	0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 
	0x75, 0xE5, 0x64, 0xFA, 0x2E, 0xCF, 0x96, 0xD3, 
	0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 
	0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 
	0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 
	0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 
	0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 
	0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 
	0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 
	0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 
	0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 
	0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 
	0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 
	0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 
	0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 
	0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 
	0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 
	0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 
	0x71, 0x75, 0xF8, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 
	0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 
	0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 
	0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 
	0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 
	0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 
	0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 
	0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 
	0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 
	0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 
	0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 
	0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 
	0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 
	0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 
	0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 
	0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 
	0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 
	0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 
	0xEA, 0x42, 0x61, 0x24, 0x8F, 0x3E, 0x45, 0xEB, 
	0x7B, 0xC8, 0xE7, 0x5C, 0x19, 0xE8, 0xFA, 0x55, 
	0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 
	0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 
	0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 
	0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 
	0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 
	0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 
	0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 
	0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 
	0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 
	0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 
	0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 
	0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 
	0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 
	0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 
	0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 
	0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 
	0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 
	0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 
	0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 
	0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 
	0x29, 0x01, 0x27, 0x27, 0x9C, 0x02, 0xBE, 0xF4, 
	0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 
	0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 
	0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 
	0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 
	0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 
	0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 
	0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 
	0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 
	0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 
	0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 
	0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 
	0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 
	0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 
	0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 
	0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 
	0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 
	0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 
	0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 
	0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 
	0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 
	0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 
	0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x38, 0x85, 
	0x73, 0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 
	0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 
	0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 
	0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 
	0x5C, 0x8B, 0x49, 0x05, 0xCA, 0x0A, 0xEA, 0x86, 
	0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 
	0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 
	0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 
	0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 
	0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 
	0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 
	0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 
	0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0x1F, 0xC8, 0x5F, 
	0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 
	0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 
	0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 
	0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 
	0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 
	0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 
	0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 
	0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 
	0x31, 0x05, 0xA8, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 
	0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 
	0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 
	0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 
	0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 
	0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 
	0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 
	0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 
	0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x7F, 
	0x47, 0x41, 0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 
	0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 
	0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 
	0xE3, 0xC1, 0x7D, 0xB5, 0x95, 0x32, 0x86, 0x72, 
	0x41, 0x37, 0xC8, 0xCB, 0x9D, 0x31, 0xBE, 0x6C, 
	0xF7, 0xB1, 0xCA, 0x62, 0xD4, 0x69, 0x37, 0x70, 
	0x8A, 0x87, 0x2F, 0x1D, 0xDA, 0x7D, 0x58, 0x8A, 
	0x7D, 0x9F, 0xDC, 0xE2, 0x8E, 0xE3, 0x3A, 0x04, 
	0xF8, 0x54, 0xC1, 0x10, 0xBA, 0x97, 0xFE, 0xF0, 
	0x58, 0xEC, 0xB5, 0x8D, 0x06, 0x7C, 0xD0, 0x79, 
	0x58, 0x22, 0xB3, 0x3F, 0xED, 0xAA, 0x00, 0x29, 
	0x89, 0x9F, 0x7B, 0x0E, 0xD3, 0x49, 0x89, 0x79, 
	0x6D, 0x41, 0xCF, 0x30, 0x07, 0x23, 0x90, 0x96, 
	0xEF, 0xFF, 0x44, 0x9F, 0x61, 0xF5, 0x16, 0x31, 
	0x88, 0xD7, 0xDE, 0x5D, 0xE0, 0x8F, 0xE2, 0xA2, 
	0x9C, 0x8A, 0x97, 0xB8, 0x02, 0x93, 0x1E, 0xCD, 
	0xF0, 0x12, 0xFE, 0x87, 0x2A, 0x55, 0x6C, 0x9B, 
	0x0E, 0xAD, 0xA4, 0xEC, 0xA1, 0xD4, 0x84, 0xB6, 
	0x30, 0xFD, 0x93, 0x4F, 0x03, 0x34, 0x17, 0xE2, 
	0x71, 0x68, 0x44, 0xFD, 0xD0, 0x13, 0x25, 0x92, 
	0x61, 0x58, 0x7F, 0x55, 0xF6, 0x11, 0x67, 0xB7, 
	0x24, 0x6F, 0x50, 0x59, 0x77, 0x90, 0x1E, 0xFE, 
	0x26, 0x56, 0x9E, 0xCE, 0xEE, 0x16, 0xFA, 0x26, 
	0xEE, 0x6B, 0x3E, 0x05, 0xC4, 0x23, 0x76, 0x7D, 
	0x64, 0x7F, 0x5B, 0xBD, 0x7E, 0x4C, 0x65, 0xCF, 
	0xD7, 0x60, 0x0E, 0xCA, 0x01, 0xBA, 0x00, 0x14
};
BYTE g_abAppCert[100] = {
	0x00, 0x01, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
	0x64, 0x25, 0xC5, 0xF6, 0x1B, 0x18, 0x20, 0x7A, 
	0x1E, 0xE7, 0x04, 0xD4, 0x88, 0x7D, 0xE9, 0x89, 
	0x6B, 0x0F, 0xAE, 0x53, 0xBB, 0x9A, 0xB1, 0xBE, 
	0x18, 0x26, 0xA4, 0x67, 0x5D, 0x2A, 0xD1, 0x89, 
	0xA9, 0x5D, 0x68, 0x14, 0x3C, 0x54, 0xB0, 0x64, 
	0xD3, 0xE7, 0x53, 0x97, 0xAE, 0xDB, 0x7B, 0xC8, 
	0x75, 0x5D, 0xA4, 0x66, 0x51, 0xD0, 0x1C, 0x8D, 
	0x4B, 0x9C, 0x8A, 0x53, 0x74, 0x65, 0xFD, 0x54, 
	0x12, 0xB7, 0xAF, 0x7D, 0x0B, 0x10, 0xC3, 0x89, 
	0x9E, 0x45, 0xB3, 0xC6, 0x0B, 0x0A, 0x8D, 0x14, 
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x03, 0xE8, 
	0x00, 0x00, 0x00, 0x06
};
//=======================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\cewmdm\proppage.h ===
#pragma once
//#include "wmpresource.h"
#include "resource.h"
//#include "wmpcore.h"
#include <commctrl.h>
#include <wininet.h>

class ATL_NO_VTABLE CFavoritesPropertyPage:
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CFavoritesPropertyPage, &__uuidof(FavoritesPropPage)>,
    public CDialogImpl<CFavoritesPropertyPage>,
    public IPropertyPageImpl<CFavoritesPropertyPage>
{
    public:
        CFavoritesPropertyPage();
        virtual ~CFavoritesPropertyPage();

        enum { IDD = IDD_CE_PROPPAGE_FAVORITES_FAVORITES };
        DECLARE_REGISTRY_RESOURCEID(IDR_CEWMDM_REG)

    BEGIN_COM_MAP(CFavoritesPropertyPage)
        COM_INTERFACE_ENTRY(IPropertyPage)
    END_COM_MAP()

    BEGIN_MSG_MAP(CFavoritesPropertyPage)
        NOTIFY_CODE_HANDLER(LVN_ITEMCHANGED, OnItemChanged)
        NOTIFY_CODE_HANDLER(LVN_ENDLABELEDIT, OnEndLabelEdit)
        NOTIFY_CODE_HANDLER(LVN_KEYDOWN, OnKeyDown)
        COMMAND_ID_HANDLER(IDC_CE_PROPPAGE_FAVORITES_ADD, OnAdd)
        COMMAND_ID_HANDLER(IDC_CE_PROPPAGE_FAVORITES_DELETE, OnDelete)
        CHAIN_MSG_MAP(IPropertyPageImpl<CFavoritesPropertyPage>)
    END_MSG_MAP()

    //
    // Message Handlers
    //

    LRESULT OnItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnEndLabelEdit(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);       
    LRESULT OnKeyDown(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnDelete(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    //
    // IPropertyPage
    //

    STDMETHOD(Activate)(HWND hWndParent, LPCRECT pRect, BOOL bModal);
    STDMETHOD(Apply)();

    protected:
    HRESULT InitList();
    HRESULT EnableControls();
    HRESULT ManageFavorites( int iItem, BOOL fRemove );
    HRESULT ManageFavorites( LPWSTR pszURL, LPWSTR pszName, BOOL fRemove );
    HRESULT AddFavorite( LPWSTR pszURL, LPWSTR pszName, BOOL fDirty );

    void ShowError(HRESULT hrError);

    HWND    m_hwndList;
    HANDLE    m_hDb;
    BOOL      m_fLeaveDBOpen;
    HCURSOR   m_hCursorWait;
    };

class CAddDialog:
    public CDialogImpl<CAddDialog>
{
    public:
        CAddDialog();
        enum { IDD = IDD_CE_PROPPAGE_FAVORITES_ADD_FAVORITE};


    BEGIN_MSG_MAP(CAddDialog)
        COMMAND_ID_HANDLER(IDOK, OnOK)
        COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
        COMMAND_HANDLER(IDC_CE_PROPPAGE_FAVORITES_URL, EN_CHANGE, OnURLChange)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    END_MSG_MAP()

    //
    // Message Handlers
    //

    LRESULT OnURLChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    WCHAR m_wszURL[INTERNET_MAX_URL_LENGTH];
    WCHAR m_wszName[MAX_PATH];

    protected:
    void EnableControls();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\cewmdm\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\cewmdm\rapisp.cpp ===
#include "stdafx.h"
#include "rapisp.h"
#include "devenum.h"

#include <initguid.h>
#include "dccole.h"
#include "key.h"
//#include "findleak.h"

//DECLARE_THIS_FILE;

//
// Final Construction
//

CSecureChannelServer *g_pAppSCServer=NULL;

HRESULT CRapiDevice::FinalConstruct()
{
    HRESULT hr;
    m_pSink = NULL;

    hr = CComDccSink::CreateInstance( &m_pSink );
    m_spSink = m_pSink;

    if( SUCCEEDED( hr ) )
    {
        hr = m_pSink->Initialize();
    }

    if( SUCCEEDED( hr ) )
    {
        g_pAppSCServer = new CSecureChannelServer();

	    if (g_pAppSCServer)
	    {
            g_pAppSCServer->SetCertificate(SAC_CERT_V1, (BYTE*)g_abAppCert, sizeof(g_abAppCert), (BYTE*)g_abPriv, sizeof(g_abPriv));
	    }	
    }

    return( hr );
}

//
// Final Release
//
void CRapiDevice::FinalRelease()
{
    if( m_pSink )
    {
        m_pSink->Shutdown();
    }

    delete g_pAppSCServer;
    g_pAppSCServer = NULL;
}

//
// IMDServiceProvider
//

STDMETHODIMP CRapiDevice::GetDeviceCount ( DWORD *pdwCount )
{
    HRESULT hr = S_OK;
    CE_FIND_DATA *rgFindData = NULL;
    DWORD cItems = 0;

    if( NULL == pdwCount )
    {
        return( E_POINTER );
    }

    *pdwCount = 0;

    if( _Module.g_fDeviceConnected != FALSE )
    {
        if( !CeFindAllFiles( L"\\*.*",
                             FAF_ATTRIBUTES | FAF_FOLDERS_ONLY,
                             &cItems,
                             &rgFindData ) )
        {
            hr = HRESULT_FROM_WIN32( CeGetLastError() );
            if( SUCCEEDED( hr ) )
            {
                hr = CeRapiGetError();
            }
        }

        if( SUCCEEDED( hr ) )
        {
            while( cItems-- )
            {

                //
                // Temp directories are storage cards according to CE group
                //

                if( rgFindData[cItems].dwFileAttributes & FILE_ATTRIBUTE_TEMPORARY )
                {
                    (*pdwCount)++;
                }
            }
        }

        if( SUCCEEDED( hr ) )
        {
            //
            // Count one for the CE device itself
            //

            (*pdwCount)++;
        }
    }

    if( NULL != rgFindData )
    {
        CeRapiFreeBuffer( rgFindData );
    }

    return( hr );
}

STDMETHODIMP CRapiDevice::EnumDevices ( IMDSPEnumDevice ** ppEnumDevice )
{
    CComDevice **rgDevices = NULL;
    CE_FIND_DATA *rgFindData = NULL;
    DWORD dwDevCount = 0;
    DWORD cItems;
    HRESULT hr = S_OK;
    UINT i = 0;
    CComEnumDevice *pNewEnum;
    CComPtr<IMDSPEnumDevice> spEnum;

    if( NULL == ppEnumDevice )
    {
        return( E_POINTER );
    }

    *ppEnumDevice = NULL;

    if( !_Module.g_fDeviceConnected )
    {
        UINT iTryCount =0;

        for ( iTryCount = 0; iTryCount < 50; iTryCount++ )
        {

            Sleep( 100 );
            if( _Module.g_fDeviceConnected  )
            {
                break;
            }
        }

        if( !_Module.g_fDeviceConnected )         
        {
            // TODO: What to do here? Doc's don't specify
            return( E_FAIL );
        }
    }

#ifdef ATTEMPT_DEVICE_CONNECTION_NOTIFICATION
    _Module.g_fInitialAttempt = FALSE;
#endif

    if( !CeFindAllFiles( L"\\*.*",
                         FAF_ATTRIBUTES | FAF_FOLDERS_ONLY | FAF_NAME,
                         &cItems,
                         &rgFindData ) )
    {
        hr = HRESULT_FROM_WIN32( CeGetLastError() );
        if( SUCCEEDED( hr ) )
        {
            hr = CeRapiGetError();
        }
    }

    if( SUCCEEDED( hr ) )
    {
        for( i = 0; i < cItems; i++ )
        {
            if( rgFindData[i].dwFileAttributes & FILE_ATTRIBUTE_TEMPORARY )
            {
                dwDevCount++;
            }
        }
    }

    if( SUCCEEDED( hr ) )
    {
        dwDevCount++;
    }

    if( SUCCEEDED( hr ) )
    {
        rgDevices = new CComDevice*[dwDevCount]; // NOTE: Currently there can only be 1 CE Device connected

        if( NULL == rgDevices )
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if( SUCCEEDED( hr ) )
    {
        for( i = 0; i < dwDevCount; i++ )
        {
            rgDevices[0] = NULL;
        }
    }

    //
    // Initialize the CE Device Itself
    //

    if( SUCCEEDED(hr) )
    {
        hr = CComDevice::CreateInstance( &rgDevices[0] );
        if( SUCCEEDED( hr ) )
        {
            rgDevices[0]->AddRef();

            hr = rgDevices[0]->Init(L"\\");
        }
    }

    //
    // Initialize all the storage cards
    //

    if( SUCCEEDED(hr) )
    {
        dwDevCount = 0;

        for( i = 0; i < cItems && SUCCEEDED( hr ) ; i++ )
        {
            if( rgFindData[i].dwFileAttributes & FILE_ATTRIBUTE_TEMPORARY )
            {
                dwDevCount++;
                
                hr = CComDevice::CreateInstance( &rgDevices[dwDevCount] );

                if( SUCCEEDED( hr ) )
                {
                    rgDevices[dwDevCount]->AddRef();

                    hr = rgDevices[dwDevCount]->Init( rgFindData[i].cFileName );
                }
            }
        }
    }

    //
    // Initialize the enumeration class
    //

    if( SUCCEEDED(hr) )
    {
        dwDevCount++; // Add the CE Device itself
        hr = CComEnumDevice ::CreateInstance(&pNewEnum);
        spEnum = pNewEnum;
    }

    if( SUCCEEDED(hr) )
    {
        hr = pNewEnum->Init( rgDevices, dwDevCount );
    }

    if( SUCCEEDED(hr) )
    {
        *ppEnumDevice = spEnum;
        spEnum.Detach();
    }

    if( NULL != rgDevices )
    {
        for( i = 0; i < dwDevCount; i ++ )
        {
            if( rgDevices[i] )
            {
                rgDevices[i]->Release();
            }
        }

        delete [] rgDevices;
    }

    if( NULL != rgFindData )
    {
        CeRapiFreeBuffer( rgFindData );
    }

    return( hr );
}

//
// IComponentAuthenticate
//

STDMETHODIMP CRapiDevice::SACAuth( DWORD dwProtocolID,
                          DWORD dwPass,
                          BYTE *pbDataIn,
                          DWORD dwDataInLen,
                          BYTE **ppbDataOut,
                          DWORD *pdwDataOutLen)
{
    HRESULT hr;

    if (g_pAppSCServer)
        hr = g_pAppSCServer->SACAuth(dwProtocolID, dwPass, pbDataIn, dwDataInLen, ppbDataOut, pdwDataOutLen);
    else
        hr = E_FAIL;

    return( hr );
}

STDMETHODIMP CRapiDevice::SACGetProtocols (DWORD **ppdwProtocols,
                             DWORD *pdwProtocolCount)
{
    HRESULT hr;

    if (g_pAppSCServer)
        hr = g_pAppSCServer->SACGetProtocols(ppdwProtocols, pdwProtocolCount);
    else
        hr = E_FAIL;

    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\cewmdm\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CEWMDM.rc
//
#define IDS_PROJNAME                    100
#define IDR_CEWMDM_REG                  201
#define IDI_CEWMDM_DEVICE               202

// Property Page for CEWMDM.DLL
#define IDS_CE_PROPPAGE_FAVORITES_TITLE          32800
#define IDS_CE_PROPPAGE_FAVORITES_URL            32801
#define IDC_CE_PROPPAGE_FAVORITES_FAVORITES      32803
#define IDC_CE_PROPPAGE_FAVORITES_ADD            32805
#define IDD_CE_PROPPAGE_FAVORITES_FAVORITES      32806
#define IDC_CE_PROPPAGE_FAVORITES_DELETE         32807
#define IDC_CE_PROPPAGE_FAVORITES_EXPORT         32808
#define IDD_CE_PROPPAGE_FAVORITES_ADD_FAVORITE   32809
#define IDC_CE_PROPPAGE_FAVORITES_NAME           32810
#define IDC_CE_PROPPAGE_FAVORITES_URL            32811

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        203
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\cewmdm\rapi.cpp ===
#include "stdafx.h"
#include "drmerr.h"

#define E_NoActiveSync HRESULT_FROM_WIN32(ERROR_DLL_NOT_FOUND)
#define WIN_ERR_NO_ACTIVE_SYNC ERROR_DLL_NOT_FOUND

#define RAPILIBNAME L"rapi.dll"


HRESULT CeRapiInitEx(RAPIINIT* pRapiInit)
{
    HMODULE hMod = LoadLibrary (RAPILIBNAME);
    
    if (hMod != NULL)
    {
        typedef HRESULT (*PFN)(RAPIINIT *);

        PFN pfn = (PFN) GetProcAddress(hMod, "CeRapiInitEx");

        _Assert (pfn != NULL); //there is no good reason that this fn wd not be there, it probably means a bug in late binding

        if (pfn != NULL)
        {
            return (*pfn)(pRapiInit);
        }
    }

    return E_NoActiveSync;
}

HRESULT  CeRapiInvoke( LPCWSTR pDllPath, LPCWSTR pFunctionName, DWORD cbInput, BYTE *pInput, 
                            DWORD *pcbOutput, BYTE **ppOutput, IRAPIStream **ppIRAPIStream, DWORD dwReserved )
{
    HMODULE hMod = LoadLibrary (RAPILIBNAME);
    
    if (hMod != NULL)
    {
        typedef HRESULT (*PFN)(LPCWSTR, LPCWSTR, DWORD, BYTE*, DWORD*, BYTE**, IRAPIStream**, DWORD);

        PFN pfn = (PFN) GetProcAddress(hMod, "CeRapiInvoke");

        _Assert (pfn != NULL); //there is no good reason that this fn wd not be there, it probably means a bug in late binding

        if (pfn != NULL)
        {
            return (*pfn)(pDllPath, pFunctionName, cbInput, pInput, pcbOutput, ppOutput, ppIRAPIStream, dwReserved);
        }
    }

    return E_NoActiveSync;
}

 HRESULT  CeRapiInit(void)
{
    HMODULE hMod = LoadLibrary (RAPILIBNAME);
    
    if (hMod != NULL)
    {
        typedef HRESULT (*PFN)(void);

        PFN pfn = (PFN) GetProcAddress(hMod, "CeRapiInit");

        _Assert (pfn != NULL); //there is no good reason that this fn wd not be there, it probably means a bug in late binding

        if (pfn != NULL)
        {
            return (*pfn)();
        }
    }

    return E_NoActiveSync;
}

LONG  CeRegOpenKeyEx( HKEY hKey, LPCWSTR lpszSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult )
{
    HMODULE hMod = LoadLibrary (RAPILIBNAME);
    
    if (hMod != NULL)
    {
        typedef LONG (*PFN)(HKEY , LPCWSTR , DWORD , REGSAM , PHKEY  );

        PFN pfn = (PFN) GetProcAddress(hMod, "CeRegOpenKeyEx");

        _Assert (pfn != NULL); //there is no good reason that this fn wd not be there, it probably means a bug in late binding

        if (pfn != NULL)
        {
            return (*pfn)(hKey, lpszSubKey, ulOptions, samDesired, phkResult);
        }
    }

    return WIN_ERR_NO_ACTIVE_SYNC;
}

HRESULT  CeRapiGetError(void)
{
    HMODULE hMod = LoadLibrary (RAPILIBNAME);
    
    if (hMod != NULL)
    {
        typedef HRESULT (*PFN)();

        PFN pfn = (PFN) GetProcAddress(hMod, "CeRapiGetError");

        _Assert (pfn != NULL); //there is no good reason that this fn wd not be there, it probably means a bug in late binding

        if (pfn != NULL)
        {
            return (*pfn)();
        }
    }

    return E_NoActiveSync;
}

DWORD  CeGetLastError( void )
{
    HMODULE hMod = LoadLibrary (RAPILIBNAME);
    
    if (hMod != NULL)
    {
        typedef DWORD (*PFN)();

        PFN pfn = (PFN) GetProcAddress(hMod, "CeGetLastError");

        _Assert (pfn != NULL); //there is no good reason that this fn wd not be there, it probably means a bug in late binding

        if (pfn != NULL)
        {
            return (*pfn)();
        }
    }
    return WIN_ERR_NO_ACTIVE_SYNC;
}

BOOL  CeGetSystemPowerStatusEx(PSYSTEM_POWER_STATUS_EX pstatus, BOOL fUpdate)
{
    HMODULE hMod = LoadLibrary (RAPILIBNAME);
    
    if (hMod != NULL)
    {
        typedef BOOL (*PFN)(PSYSTEM_POWER_STATUS_EX, BOOL);

        PFN pfn = (PFN) GetProcAddress(hMod, "CeGetSystemPowerStatusEx");

        _Assert (pfn != NULL); //there is no good reason that this fn wd not be there, it probably means a bug in late binding

        if (pfn != NULL)
        {
            return (*pfn)(pstatus, fUpdate);
        }
    }

    return FALSE; //FALSE indicates error
}

HRESULT  CeRapiFreeBuffer( LPVOID Buffer )
{
    HMODULE hMod = LoadLibrary (RAPILIBNAME);
    
    if (hMod != NULL)
    {
        typedef HRESULT (*PFN)(LPVOID);

        PFN pfn = (PFN) GetProcAddress(hMod, "CeRapiFreeBuffer");

        _Assert (pfn != NULL); //there is no good reason that this fn wd not be there, it probably means a bug in late binding

        if (pfn != NULL)
        {
            return (*pfn)(Buffer);
        }
    }

    return E_NoActiveSync;
}

BOOL  CeFindAllFiles(LPCWSTR szPath, DWORD dwFlags, LPDWORD lpdwFoundCount, LPLPCE_FIND_DATA ppFindDataArray)
{
    HMODULE hMod = LoadLibrary (RAPILIBNAME);
    
    if (hMod != NULL)
    {
        typedef BOOL (*PFN)(LPCWSTR, DWORD, LPDWORD, LPLPCE_FIND_DATA);

        PFN pfn = (PFN) GetProcAddress(hMod, "CeFindAllFiles");

        _Assert (pfn != NULL); //there is no good reason that this fn wd not be there, it probably means a bug in late binding

        if (pfn != NULL)
        {
            return (*pfn)(szPath, dwFlags, lpdwFoundCount, ppFindDataArray);
        }
    }

    return FALSE; //FALSE indicates error
}

BOOL  CeCreateDirectory(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
    HMODULE hMod = LoadLibrary (RAPILIBNAME);
    
    if (hMod != NULL)
    {
        typedef BOOL (*PFN)(LPCWSTR, LPSECURITY_ATTRIBUTES);

        PFN pfn = (PFN) GetProcAddress(hMod, "CeCreateDirectory");

        _Assert (pfn != NULL); //there is no good reason that this fn wd not be there, it probably means a bug in late binding

        if (pfn != NULL)
        {
            return (*pfn)(lpPathName, lpSecurityAttributes);
        }
    }

    return FALSE; //FALSE indicates error
}

BOOL  CeCloseHandle( HANDLE hObject )
{
    HMODULE hMod = LoadLibrary (RAPILIBNAME);
    
    if (hMod != NULL)
    {
        typedef BOOL (*PFN)(HANDLE);

        PFN pfn = (PFN) GetProcAddress(hMod, "CeCloseHandle");

        _Assert (pfn != NULL); //there is no good reason that this fn wd not be there, it probably means a bug in late binding

        if (pfn != NULL)
        {
            return (*pfn)(hObject);
        }
    }

    return FALSE;
}

BOOL  CeSetFileAttributes(LPCWSTR lpFileName, DWORD dwFileAttributes)
{
    HMODULE hMod = LoadLibrary (RAPILIBNAME);
    
    if (hMod != NULL)
    {
        typedef BOOL (*PFN)(LPCWSTR, DWORD);

        PFN pfn = (PFN) GetProcAddress(hMod, "CeSetFileAttributes");

        _Assert (pfn != NULL); //there is no good reason that this fn wd not be there, it probably means a bug in late binding

        if (pfn != NULL)
        {
            return (*pfn)(lpFileName, dwFileAttributes);
        }
    }

    return FALSE;
}

LONG CeRegQueryValueEx( HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData )
{
    HMODULE hMod = LoadLibrary (RAPILIBNAME);
    
    if (hMod != NULL)
    {
        typedef LONG (*PFN)( HKEY, LPCWSTR, LPDWORD, LPDWORD, LPBYTE, LPDWORD  );

        PFN pfn = (PFN) GetProcAddress(hMod, "CeRegQueryValueEx");

        _Assert (pfn != NULL); //there is no good reason that this fn wd not be there, it probably means a bug in late binding

        if (pfn != NULL)
        {
            return (*pfn)(hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);
        }
    }

    return WIN_ERR_NO_ACTIVE_SYNC;
}

LONG CeRegCloseKey( HKEY hKey )
{
    HMODULE hMod = LoadLibrary (RAPILIBNAME);
    
    if (hMod != NULL)
    {
        typedef LONG (*PFN)( HKEY );

        PFN pfn = (PFN) GetProcAddress(hMod, "CeRegCloseKey");

        _Assert (pfn != NULL); //there is no reason that this fn wd not be there, it probably means a bug in late binding

        if (pfn != NULL)
        {
            return (*pfn)(hKey);
        }
    }

    return WIN_ERR_NO_ACTIVE_SYNC;
}

HRESULT CeRapiUninit(void)
{
    HMODULE hMod = LoadLibrary (RAPILIBNAME);
    
    if (hMod != NULL)
    {
        typedef HRESULT (*PFN)();

        PFN pfn = (PFN) GetProcAddress(hMod, "CeRapiUninit");

        _Assert (pfn != NULL); //there is no good reason that this fn wd not be there, it probably means a bug in late binding

        if (pfn != NULL)
        {
            return (*pfn)();
        }
    }

    return E_NoActiveSync;
}

BOOL CeRemoveDirectory(LPCWSTR lpPathName)
{
    HMODULE hMod = LoadLibrary (RAPILIBNAME);
    
    if (hMod != NULL)
    {
        typedef BOOL (*PFN)(LPCWSTR);

        PFN pfn = (PFN) GetProcAddress(hMod, "CeRemoveDirectory");

        _Assert (pfn != NULL); //there is no good reason that this fn wd not be there, it probably means a bug in late binding

        if (pfn != NULL)
        {
            return (*pfn)(lpPathName);
        }
    }

    return FALSE;
}

BOOL CeMoveFile(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName)
{
    HMODULE hMod = LoadLibrary (RAPILIBNAME);
    
    if (hMod != NULL)
    {
        typedef BOOL (*PFN)(LPCWSTR, LPCWSTR);

        PFN pfn = (PFN) GetProcAddress(hMod, "CeMoveFile");

        _Assert (pfn != NULL); //there is no good reason that this fn wd not be there, it probably means a bug in late binding

        if (pfn != NULL)
        {
            return (*pfn)(lpExistingFileName, lpNewFileName);
        }
    }

    return FALSE;
}

DWORD CeSetFilePointer( HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod )
{
    HMODULE hMod = LoadLibrary (RAPILIBNAME);
    
    if (hMod != NULL)
    {
        typedef DWORD (*PFN)( HANDLE, LONG, PLONG , DWORD  );

        PFN pfn = (PFN) GetProcAddress(hMod, "CeSetFilePointer");

        _Assert (pfn != NULL); //there is no good reason that this fn wd not be there, it probably means a bug in late binding

        if (pfn != NULL)
        {
            return (*pfn)(hFile, lDistanceToMove, lpDistanceToMoveHigh, dwMoveMethod);
        }
    }

    //dll not found, fail over
    if (NULL != lpDistanceToMoveHigh)
    {
        *lpDistanceToMoveHigh = NULL;
    }
    
    return -1;
}

BOOL CeDeleteFile(LPCWSTR lpFileName)
{
    HMODULE hMod = LoadLibrary (RAPILIBNAME);
    
    if (hMod != NULL)
    {
        typedef BOOL (*PFN)( LPCWSTR );

        PFN pfn = (PFN) GetProcAddress(hMod, "CeDeleteFile");

        _Assert (pfn != NULL); //there is no good reason that this fn wd not be there, it probably means a bug in late binding

        if (pfn != NULL)
        {
            return (*pfn)(lpFileName);
        }
    }

    return FALSE;
}

BOOL CeWriteFile( HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, 
                        LPOVERLAPPED lpOverlapped )
{
    HMODULE hMod = LoadLibrary (RAPILIBNAME);
    
    if (hMod != NULL)
    {
        typedef BOOL (*PFN)( HANDLE , LPCVOID , DWORD , LPDWORD , LPOVERLAPPED  );

        PFN pfn = (PFN) GetProcAddress(hMod, "CeWriteFile");

        _Assert (pfn != NULL); //there is no good reason that this fn wd not be there, it probably means a bug in late binding

        if (pfn != NULL)
        {
            return (*pfn)(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);
        }
    }

    return FALSE;
}

BOOL CeReadFile( HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, 
                        LPOVERLAPPED lpOverlapped )
{
    HMODULE hMod = LoadLibrary (RAPILIBNAME);
    
    if (hMod != NULL)
    {
        typedef BOOL (*PFN)( HANDLE , LPVOID , DWORD , LPDWORD , LPOVERLAPPED  );

        PFN pfn = (PFN) GetProcAddress(hMod, "CeReadFile");

        _Assert (pfn != NULL); //there is no good reason that this fn wd not be there, it probably means a bug in late binding

        if (pfn != NULL)
        {
            return (*pfn)(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);
        }
    }

    return FALSE;
}

DWORD CeGetFileAttributes(LPCWSTR lpFileName)
{
    HMODULE hMod = LoadLibrary (RAPILIBNAME);
    
    if (hMod != NULL)
    {
        typedef DWORD (*PFN)( LPCWSTR );

        PFN pfn = (PFN) GetProcAddress(hMod, "CeGetFileAttributes");

        _Assert (pfn != NULL); //there is no good reason that this fn wd not be there, it probably means a bug in late binding

        if (pfn != NULL)
        {
            return (*pfn)(lpFileName);
        }
    }
    return -1;
}

BOOL CeSHGetShortcutTarget(LPWSTR lpszShortcut, LPWSTR lpszTarget, int cbMax)
{
    HMODULE hMod = LoadLibrary (RAPILIBNAME);
    
    if (hMod != NULL)
    {
        typedef BOOL (*PFN)( LPWSTR , LPWSTR , int  );

        PFN pfn = (PFN) GetProcAddress(hMod, "CeSHGetShortcutTarget");

        _Assert (pfn != NULL); //there is no good reason that this fn wd not be there, it probably means a bug in late binding

        if (pfn != NULL)
        {
            return (*pfn)(lpszShortcut, lpszTarget, cbMax);
        }
    }

    return FALSE;
}

BOOL  CeCreateProcess(LPCWSTR lpApplicationName, LPCWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, 
                BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPWSTR lpCurrentDirectory, LPSTARTUPINFO lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
{
    HMODULE hMod = LoadLibrary (RAPILIBNAME);
    
    if (hMod != NULL)
    {
        typedef BOOL (*PFN)(LPCWSTR , LPCWSTR , LPSECURITY_ATTRIBUTES , LPSECURITY_ATTRIBUTES , 
                BOOL , DWORD , LPVOID , LPWSTR , LPSTARTUPINFO , LPPROCESS_INFORMATION );

        PFN pfn = (PFN) GetProcAddress(hMod, "CeCreateProcess");

        _Assert (pfn != NULL); //there is no good reason that this fn wd not be there, it probably means a bug in late binding

        if (pfn != NULL)
        {
            return (*pfn)(lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment,
                                lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
        }
    }

    return FALSE;
}

HANDLE  CeCreateFile(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
{
    HMODULE hMod = LoadLibrary (RAPILIBNAME);
    
    if (hMod != NULL)
    {
        typedef HANDLE (*PFN)(LPCWSTR , DWORD , DWORD , LPSECURITY_ATTRIBUTES , DWORD , DWORD , HANDLE );

        PFN pfn = (PFN) GetProcAddress(hMod, "CeCreateFile");

        _Assert (pfn != NULL); 