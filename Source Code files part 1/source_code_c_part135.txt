teResponse( rawWorkContext );

    //
    // If a response is to be sent, send it now.
    //

    if ( sendWriteComplete ) {

        SrvFsdBuildWriteCompleteResponse(
            WorkContext,
            status,
            immediateWriteDone ? immediateLength : 0
            );

        SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );

    } else {

        SrvDereferenceWorkItem( WorkContext );

    }

    IF_DEBUG(TRACE2) KdPrint(( "PrepareRawCopyWrite complete\n" ));
    return;

} // PrepareRawCopyWrite

BOOLEAN SRVFASTCALL
ReadRawPipe (
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes the Read Block Raw SMB for pipes.

    Note that Read Block Raw cannot return an error response.  When the
    server is unable to process the request, for whatever reason, it
    simply responds with a zero-length message.  The client uses a
    normal Read SMB to determine what happened.

Arguments:

    WorkContext - Pointer to the work context block.

Return Value:

    TRUE, if operation succeeds.
    FALSE, otherwise

--*/

{
    PREQ_READ_RAW request;

    USHORT fid;
    PRFCB rfcb;
    PLFCB lfcb;
    PCONNECTION connection;
    UCHAR minorFunction = 0;
    BOOLEAN byteModePipe;
    PVOID rawBuffer = NULL;
    CLONG readLength;
    PMDL mdl = NULL;
    ULONG key;
    LARGE_INTEGER offset;

    PFILE_PIPE_PEEK_BUFFER pipePeekBuffer;

    PAGED_CODE( );

    INCREMENT_DEBUG_STAT2( SrvDbgStatistics.RawReadsAttempted );

    request = (PREQ_READ_RAW)WorkContext->RequestParameters;

    fid = SmbGetUshort( &request->Fid );
    readLength = SmbGetUshort( &request->MaxCount );

    //
    // If raw mode has been disabled or if the connection is unreliable,
    // reject the raw read.  Ask the client to use standard read by
    // sending a zero-length response.  The client will react by issuing
    // a normal Read SMB, which we will be able to process.
    //

    connection = WorkContext->Connection;

    rfcb = WorkContext->Rfcb;
    lfcb = rfcb->Lfcb;
    byteModePipe = rfcb->ByteModePipe;

    //
    // Verify that the client has read access to the file via the
    // specified handle.
    //

    if ( !rfcb->ReadAccessGranted ) {
        SrvStatistics.GrantedAccessErrors++;
        IF_DEBUG(ERRORS) {
            KdPrint(( "ReadRawPipe: Read access not granted.\n"));
        }
        return(FALSE);
    }

    //
    // Verify the word counts
    //

    if ( (request->WordCount != 8) && (request->WordCount != 10) ) {

        //
        // Invalid word count.  Return 0 bytes.
        //

        return(FALSE);
    }

    //
    // If this operation may block, and we're running short of
    // resources, or if the target is a paused comm device, reject the
    // request.
    //

    if ( rfcb->BlockingModePipe ) {

         if ( SrvReceiveBufferShortage( ) ) {

            //
            // Reject the request.
            //
            // !!!  Consider routing the request to the FSP, instead.
            //

            IF_DEBUG(ERRORS) {
                KdPrint(( "ReadRawPipe: No resources for blocking "
                            "read\n" ));
            }

            SrvFailedBlockingIoCount++;
            SrvStatistics.BlockingSmbsRejected++;
            return(FALSE);

        }

        //
        // It is okay to start a blocking operation.
        // SrvReceiveBufferShortage() has already incremented
        // SrvBlockingOpsInProgress.
        //

        WorkContext->BlockingOperation = TRUE;
    }

    //
    // Form the lock key using the FID and the PID.
    //
    // *** The FID must be included in the key in order to account for
    //     the folding of multiple remote compatibility mode opens into
    //     a single local open.
    //

    key = rfcb->ShiftedFid |
            SmbGetAlignedUshort( &WorkContext->RequestHeader->Pid );

    //
    // If the SMB buffer is large enough, use it to do the local read.
    //

    if ( readLength <= WorkContext->ResponseBuffer->BufferLength ) {

        WorkContext->Parameters.ReadRaw.SavedResponseBuffer = NULL;
        WorkContext->Parameters.ReadRaw.MdlRead = FALSE;

        //
        // Try the fast I/O path first.
        //

        if ( byteModePipe && (lfcb->FastIoRead != NULL) ) {

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsAttempted );

            try {
                if ( lfcb->FastIoRead(
                        lfcb->FileObject,
                        &offset,
                        readLength,
                        TRUE,
                        key,
                        WorkContext->ResponseBuffer->Buffer,
                        &WorkContext->Irp->IoStatus,
                        lfcb->DeviceObject
                        ) ) {

                    //
                    // The fast I/O path worked.  Send the data.
                    //
                    WorkContext->bAlreadyTrace = TRUE;
                    SrvFsdRestartReadRaw( WorkContext );
                    return TRUE;

                }
            }
            except( EXCEPTION_EXECUTE_HANDLER ) {
                // Fall through to the slow path on an exception
                NTSTATUS status = GetExceptionCode();
                IF_DEBUG(ERRORS) {
                    KdPrint(("FastIoRead threw exception %x\n", status ));
                }
            }

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsFailed );
        }

        //
        // The fast I/O path failed, so we need to use a regular copy
        // I/O request.  Build an MDL describing the read buffer.
        //
        // *** Note the assumption that the response buffer already has
        //     a valid full MDL from which a partial MDL can be built.
        //

        IoBuildPartialMdl(
            WorkContext->ResponseBuffer->Mdl,
            WorkContext->ResponseBuffer->PartialMdl,
            WorkContext->ResponseBuffer->Buffer,
            readLength
            );

        mdl = WorkContext->ResponseBuffer->PartialMdl;
        rawBuffer = WorkContext->ResponseHeader;

        ASSERT( minorFunction == 0 );

    } else {

        //
        // We have to use a normal "copy" read.  We need to allocate
        // a separate raw buffer.
        //

        ASSERT( minorFunction == 0 );
        WorkContext->Parameters.ReadRaw.MdlRead = FALSE;

        rawBuffer = ALLOCATE_NONPAGED_POOL(
                        readLength,
                        BlockTypeDataBuffer
                        );
        IF_SMB_DEBUG(RAW2) KdPrint(( "rawBuffer: 0x%p\n", rawBuffer ));

        if ( rawBuffer == NULL ) {

            IF_DEBUG(ERRORS) {
                KdPrint(( "ReadRawPipe: Unable to allocate raw buffer\n" ));
            }

            return(FALSE);

        }

        //
        // We also need a buffer descriptor.
        //
        // *** Note: Currently, ResponseBuffer == RequestBuffer in a
        //     WorkContext block, so we don't really have to save
        //     the ResponseBuffer field.  But we do so just to be on
        //     the safe side.
        //

        WorkContext->Parameters.ReadRaw.SavedResponseBuffer =
                                         WorkContext->ResponseBuffer;

        WorkContext->ResponseBuffer = ALLOCATE_NONPAGED_POOL(
                                        sizeof(BUFFER),
                                        BlockTypeBuffer
                                        );

        if ( WorkContext->ResponseBuffer == NULL ) {

            INTERNAL_ERROR(
                ERROR_LEVEL_EXPECTED,
                "ReadRawPipe: Unable to allocate %d bytes from "
                "nonpaged pool.",
                sizeof(BUFFER),
                NULL
                );

            DEALLOCATE_NONPAGED_POOL( rawBuffer );

            WorkContext->ResponseBuffer =
                  WorkContext->Parameters.ReadRaw.SavedResponseBuffer;

            return(FALSE);
        }

        WorkContext->ResponseBuffer->Buffer = rawBuffer;
        WorkContext->ResponseBuffer->BufferLength = readLength;

        //
        // Finally, we need an MDL to describe the raw buffer.
        //
        // *** We used to try to use the PartialMdl for the SMB
        //     buffer here, if it was big enough.  But since we
        //     already decided that the buffer itself isn't big
        //     enough, it's extremely likely that the MDL isn't big
        //     enough either.
        //

        mdl = IoAllocateMdl( rawBuffer, readLength, FALSE, FALSE, NULL );

        if ( mdl == NULL ) {

            DEALLOCATE_NONPAGED_POOL( WorkContext->ResponseBuffer );
            WorkContext->ResponseBuffer =
               WorkContext->Parameters.ReadRaw.SavedResponseBuffer;

            DEALLOCATE_NONPAGED_POOL( rawBuffer );

            return(FALSE);

        }

        WorkContext->ResponseBuffer->Mdl = mdl;

        //
        // Build the mdl
        //

        MmBuildMdlForNonPagedPool( mdl );

        //
        // Try the fast I/O path first.
        //

        if ( byteModePipe && (lfcb->FastIoRead != NULL) ) {

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsAttempted );

            try {
                if ( lfcb->FastIoRead(
                        lfcb->FileObject,
                        &offset,
                        readLength,
                        TRUE,
                        key,
                        WorkContext->ResponseBuffer->Buffer,
                        &WorkContext->Irp->IoStatus,
                        lfcb->DeviceObject
                        ) ) {

                    //
                    // The fast I/O path worked.  Send the data.
                    //
                    WorkContext->bAlreadyTrace = TRUE;
                    SrvFsdRestartReadRaw( WorkContext );
                    return TRUE;

                }
            }
            except( EXCEPTION_EXECUTE_HANDLER ) {
                // Fall through to the slow path on an exception
                NTSTATUS status = GetExceptionCode();
                IF_DEBUG(ERRORS) {
                    KdPrint(("FastIoRead threw exception %x\n", status ));
                }
            }

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsFailed );

        }

        //
        // The fast I/O path failed, so we need to use a regular copy
        // I/O request.
        //

    } // read fits in SMB buffer?

    //
    // This is a read block raw on a named pipe.  If this is a
    // non-blocking read on a blocking mode pipe, we need to do a
    // peek first.  This is to ensure that we don't end up waiting
    // when we're not supposed to.
    //
    // *** We used to have to peek on message mode pipes, in case
    //     the message was too large or zero-length.  But now we
    //     have a special pipe FSCTL for this.  See below.
    //

    if ( (SmbGetUshort( &request->MinCount ) == 0) &&
          rfcb->BlockingModePipe ) {

        //
        // Allocate a buffer to peek the pipe.  This buffer is freed
        // in RestartPipeReadRawPeek().
        //

        pipePeekBuffer = ALLOCATE_NONPAGED_POOL(
                            FIELD_OFFSET( FILE_PIPE_PEEK_BUFFER, Data[0] ),
                            BlockTypeDataBuffer
                            );

        if ( pipePeekBuffer == NULL ) {

            //
            // Can't allocate a buffer to do a peek.  Nothing to do
            // but return zero bytes to the client.
            //

            INTERNAL_ERROR(
                ERROR_LEVEL_EXPECTED,
                "ReadRawPipe: Unable to allocate %d bytes from"
                    "nonpaged pool.",
                FIELD_OFFSET( FILE_PIPE_PEEK_BUFFER, Data[0] ),
                NULL
                );

            if ( WorkContext->Parameters.ReadRaw.SavedResponseBuffer !=
                                                            NULL ) {

                if ( mdl != WorkContext->Parameters.ReadRaw.
                                SavedResponseBuffer->PartialMdl ) {
                    IoFreeMdl( mdl );
                }

                DEALLOCATE_NONPAGED_POOL( WorkContext->ResponseBuffer );
                WorkContext->ResponseBuffer =
                   WorkContext->Parameters.ReadRaw.SavedResponseBuffer;

                DEALLOCATE_NONPAGED_POOL( rawBuffer );

            }

            return(FALSE);

        }

        //
        // Save the address of the pipe peek buffer for the restart
        // routine.
        //

        WorkContext->Parameters.ReadRaw.ReadRawOtherInfo.PipePeekBuffer =
            pipePeekBuffer;

        //
        // Build the pipe peek request.  We just want the header
        // information.  We do not need any data.
        //

        SrvBuildIoControlRequest(
            WorkContext->Irp,
            lfcb->FileObject,
            WorkContext,
            IRP_MJ_FILE_SYSTEM_CONTROL,
            FSCTL_PIPE_PEEK,
            pipePeekBuffer,
            0,
            NULL,
            FIELD_OFFSET( FILE_PIPE_PEEK_BUFFER, Data[0] ),
            NULL,
            NULL
            );

        WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
        WorkContext->FspRestartRoutine = RestartPipeReadRawPeek;

        //
        // Pass the request to NPFS.
        //

        (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

    } else {

        //
        // This is a blocking read, or a non-blocking read on a
        // non-blocking pipe.  Build and issue the read request.  If
        // this is a message-mode pipe, use the special ReadOverflow
        // FSCTL.  This FSCTL returns an error if the pipe is a
        // message mode pipe and the first message in the pipe is
        // either too big or has length 0.  We need this because we
        // can't return an error on a raw read -- the best we can do
        // is return a zero-length message.  So we need the
        // operation to act like a Peek if the message is the wrong
        // size.  That's what the special FSCTL gives us.
        //

        SrvBuildIoControlRequest(
            WorkContext->Irp,
            lfcb->FileObject,
            WorkContext,
            IRP_MJ_FILE_SYSTEM_CONTROL,
            byteModePipe ?
                FSCTL_PIPE_INTERNAL_READ : FSCTL_PIPE_INTERNAL_READ_OVFLOW,
            WorkContext->ResponseBuffer->Buffer,
            0,
            NULL,
            SmbGetUshort( &request->MaxCount ),
            NULL,
            NULL
            );
        WorkContext->bAlreadyTrace = TRUE;
        WorkContext->FsdRestartRoutine = SrvFsdRestartReadRaw;
        DEBUG WorkContext->FspRestartRoutine = NULL;

        IF_SMB_DEBUG(RAW2) {
            KdPrint((
                "ReadRawPipe: reading from file 0x%p, "
                    "length %ld, destination 0x%p\n",
                 lfcb->FileObject,
                 SmbGetUshort( &request->MaxCount ),
                 WorkContext->Parameters.ReadRaw.
                     SavedResponseBuffer->Buffer
            ));
        }

        (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

        //
        // The read has been started.  When it completes, processing
        // resumes at SrvFsdRestartReadRaw.
        //

    }

    IF_DEBUG(TRACE2) KdPrint(( "ReadRawPipe complete\n" ));
    return TRUE;

} // ReadRawPipe

VOID SRVFASTCALL
RestartMdlReadRawResponse (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes response send completion for an MDL read.  Releases the
    MDL back to the file system.

    This routine is called in the FSP.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    PAGED_CODE( );

    IF_DEBUG(FSD2) KdPrint(( " - RestartMdlReadRawResponse\n" ));

    //
    // Call the Cache Manager to release the MDL chain.  If the MDL read
    // failed to return an MDL (for example, if the read was entirely
    // beyond EOF), then we don't have to do this.
    //

    if ( WorkContext->Irp->MdlAddress ) {

        if( WorkContext->Rfcb->Lfcb->MdlReadComplete == NULL ||

            WorkContext->Rfcb->Lfcb->MdlReadComplete(
                WorkContext->Rfcb->Lfcb->FileObject,
                WorkContext->Irp->MdlAddress,
                WorkContext->Rfcb->Lfcb->DeviceObject ) == FALSE ) {

            status = SrvIssueMdlCompleteRequest( WorkContext, NULL,
                                            WorkContext->Irp->MdlAddress,
                                            IRP_MJ_READ,
                                            &WorkContext->Parameters.ReadRaw.ReadRawOtherInfo.Offset,
                                            WorkContext->Parameters.ReadRaw.ReadRawOtherInfo.Length
                     );

            if( !NT_SUCCESS( status ) ) {
                SrvLogServiceFailure( SRV_SVC_MDL_COMPLETE, status );
            }
        }

    }

    //
    // Start oplock break notifications, if any are outstanding.
    // SrvSendDelayedOplockBreak also sets read raw in progress to FALSE.
    //

    SrvSendDelayedOplockBreak( WorkContext->Connection );

    //
    // Finish postprocessing of the SMB.
    //

    SrvDereferenceWorkItem( WorkContext );

    IF_DEBUG(FSD2) KdPrint(( "RestartMdlReadRawResponse complete.\n" ));
    return;

} // RestartMdlReadRawResponse


VOID SRVFASTCALL
RestartPipeReadRawPeek (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function continues a read raw on a named pipe handle.

    This routine is called in the FSP.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PFILE_PIPE_PEEK_BUFFER pipePeekBuffer;
    PREQ_READ_RAW request;
    ULONG readLength;
    ULONG readDataAvailable;
    ULONG messageLength;
    ULONG numberOfMessages;
    PLFCB lfcb;
    PRFCB rfcb;

    PAGED_CODE( );

    pipePeekBuffer = WorkContext->Parameters.ReadRaw.ReadRawOtherInfo.
                                                            PipePeekBuffer;
    request = (PREQ_READ_RAW)WorkContext->RequestParameters;
    readLength = SmbGetUshort( &request->MaxCount );

    rfcb = WorkContext->Rfcb;
    lfcb = rfcb->Lfcb;

    //
    // The pipe peek has completed.  Extract the critical information,
    // then free the buffer.
    //

    readDataAvailable = pipePeekBuffer->ReadDataAvailable;
    messageLength = pipePeekBuffer->MessageLength;
    numberOfMessages = pipePeekBuffer->NumberOfMessages;

    DEALLOCATE_NONPAGED_POOL( pipePeekBuffer );

    //
    // The read request is a non-blocking read on a blocking mode pipe.
    // We react differently based on whether it is a byte mode pipe or
    // a message mode pipe.
    //
    // Byte mode: If there is _any_ data in the pipe, we go get it.  The
    //      read will complete immediately, copying either as much data
    //      as is available, or enough to fill the buffer, whichever is
    //      less, and there will be no error.  If there is no data in
    //      the pipe, we have to return immediately, because we can't
    //      wait for data to arrive.
    //
    // Message mode:  If there are no messages available, or if the
    //      first message is either zero-length or bigger than the
    //      client's buffer, we return immediately.  We can't indicate
    //      underflow or overflow, so we can't allow the message to be
    //      pulled out of the queue.  Otherwise, we can do the read.
    //

    if ( ( rfcb->ByteModePipe &&
           (readDataAvailable == 0)
         )
         ||
         ( !rfcb->ByteModePipe &&
           ( (numberOfMessages == 0)
             ||
             (messageLength == 0)
             ||
             (messageLength > readLength)
           )
         )
       ) {

        if ( WorkContext->Parameters.ReadRaw.SavedResponseBuffer != NULL ) {

            if ( WorkContext->ResponseBuffer->Mdl != WorkContext->Parameters.
                            ReadRaw.SavedResponseBuffer->PartialMdl ) {
                IoFreeMdl( WorkContext->ResponseBuffer->Mdl );
            }

            DEALLOCATE_NONPAGED_POOL( WorkContext->ResponseBuffer->Buffer );

            DEALLOCATE_NONPAGED_POOL( WorkContext->ResponseBuffer );
            WorkContext->ResponseBuffer =
               WorkContext->Parameters.ReadRaw.SavedResponseBuffer;

        }

        WorkContext->ResponseParameters = WorkContext->ResponseHeader;
        SrvFsdSendResponse( WorkContext );

        IF_DEBUG(TRACE2) KdPrint(( "RestartPipeReadRawPeek complete\n" ));
        return;

    }

    //
    // We have bypassed all of the pitfalls of doing a read block raw
    // on a named pipe.
    //
    // Build and issue the read request.
    //
    // *** Note that we do not use the special ReadOverflow FSCTL here
    //     because we know from the above tests that we don't need to.
    //

    SrvBuildIoControlRequest(
        WorkContext->Irp,
        lfcb->FileObject,
        WorkContext,
        IRP_MJ_FILE_SYSTEM_CONTROL,
        FSCTL_PIPE_INTERNAL_READ,
        WorkContext->ResponseBuffer->Buffer,
        0,
        NULL,
        readLength,
        NULL,
        NULL
        );

    WorkContext->bAlreadyTrace = TRUE;
    WorkContext->FsdRestartRoutine = SrvFsdRestartReadRaw;
    DEBUG WorkContext->FspRestartRoutine = NULL;

    IF_SMB_DEBUG(RAW2) {
        KdPrint(( "RestartPipeReadRawPeek: reading from file 0x%p, length %ld, destination 0x%p\n",
                    lfcb->FileObject, readLength,
                    WorkContext->ResponseBuffer->Buffer ));
    }

    (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

    //
    // The read has been started.  When it completes, processing resumes
    // at SrvFsdRestartReadRaw.
    //

    IF_DEBUG(TRACE2) KdPrint(( "RestartPipeReadRawPeek complete\n" ));
    return;

} // RestartPipeReadRawPeek


VOID SRVFASTCALL
SrvDecrementRawWriteCount (
    IN PRFCB Rfcb
    )

/*++

Routine Description:

    This routine decrements the count of active raw writes for an RFCB.
    If the count goes to zero, and there are work items queued pending
    completion of the raw write, they are restarted.  If the count goes
    to zero, and the RFCB is closing, then the RFCB's cleanup is resumed
    here.

    This routine is called in both the FSP and the FSD.

Arguments:

    Rfcb - Supplies a pointer to the RFCB.

Return Value:

    None.

--*/

{
    PLIST_ENTRY listEntry;
    PWORK_CONTEXT workContext;
    KIRQL oldIrql;
    PCONNECTION connection = Rfcb->Connection;

    //
    // Acquire the spin lock that guards the count.
    //

    ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );

    //
    // Decrement the active raw write count.
    //

    ASSERT( Rfcb->RawWriteCount > 0 );
    Rfcb->RawWriteCount--;

    if ( Rfcb->RawWriteCount == 0 ) {

        //
        // No raw writes are active.  Flush the list of work items
        // that were queued pending the completion of the raw write
        // by restarting each of them.
        //

        while ( !IsListEmpty(&Rfcb->RawWriteSerializationList) ) {

            listEntry = RemoveHeadList( &Rfcb->RawWriteSerializationList );
            workContext = CONTAINING_RECORD(
                            listEntry,
                            WORK_CONTEXT,
                            ListEntry
                            );
            QUEUE_WORK_TO_FSP( workContext );

        }

        if ( GET_BLOCK_STATE(Rfcb) == BlockStateClosing ) {

            //
            // The count is now zero and the RFCB is closing.  The
            // cleanup was deferred pending the completion of all raw
            // writes.  Do the cleanup now.
            //

            RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

            SrvCompleteRfcbClose( Rfcb );

        } else {

            RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

        }

    } else {

        RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );
    }

    return;

} // SrvDecrementRawWriteCount

VOID SRVFASTCALL
SrvRestartRawReceive (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This is the restart routine that is invoked when Write Block Raw
    write data is received.  It starts the local write operation.

    This routine is called in the FSP.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PCONNECTION connection;
    PIRP irp;
    PRFCB rfcb;
    PLFCB lfcb;
    PMDL mdl;
    PMDL partialMdl;
    PCHAR writeAddress;
    CLONG writeLength;
    LARGE_INTEGER offset;
    PVOID finalResponseBuffer;
    CLONG immediateLength;
    ULONG key;
    NTSTATUS status;

    PAGED_CODE( );

    IF_DEBUG(FSD1) KdPrint(( " - SrvRestartRawReceive\n" ));

    //
    // If the I/O request failed or was canceled, or if the connection
    // that received the message is no longer active, or if the server
    // FSP isn't active, abort the request.
    //
    // *** Note that we don't send a final response in any of these
    //     cases.  We assume that the failure is catastrophic, so
    //     there's no use sending a response.
    //

    connection = WorkContext->Connection;
    irp = WorkContext->Irp;

    WorkContext->CurrentWorkQueue->stats.BytesReceived += irp->IoStatus.Information;

    if ( irp->Cancel ||
         !NT_SUCCESS(irp->IoStatus.Status) ||
         (GET_BLOCK_STATE(connection) != BlockStateActive) ||
         SrvFspTransitioning ) {

        IF_DEBUG(TRACE2) {
            if ( irp->Cancel ) {
                KdPrint(( "  I/O canceled\n" ));
            } else if ( !NT_SUCCESS(irp->IoStatus.Status) ) {
                KdPrint(( "  I/O failed: %X\n", irp->IoStatus.Status ));
            } else if ( SrvFspTransitioning ) {
                KdPrint(( "  Server is shutting down.\n" ));
            } else {
                KdPrint(( "  Connection no longer active\n" ));
            }
        }

        //
        // Abort the raw write.
        //

        AbortRawWrite( WorkContext );

        IF_DEBUG(TRACE2) KdPrint(( "SrvRestartRawReceive complete\n" ));
        return;

    }

    //
    // Set up local variables.
    //

    rfcb = WorkContext->Rfcb;
    lfcb = rfcb->Lfcb;
    finalResponseBuffer = WorkContext->Parameters.WriteRaw.FinalResponseBuffer;
    immediateLength = WorkContext->Parameters.WriteRaw.ImmediateLength;

    //
    // Determine whether we're doing "copy write" or "MDL write".
    //

    if ( WorkContext->Parameters.WriteRaw.MdlWrite ) {

#if DBG
        IF_SMB_DEBUG(RAW2) {
            KdPrint(( "SrvRestartRawReceive: Receive MDL chain after receive\n" ));
            DumpMdlChain( irp->MdlAddress );
        }
#endif

        //
        // This was an MDL write.  If a partial MDL was built (because
        // of immediate data), unmap it.  Then complete the MDL write.
        //

        mdl = WorkContext->Parameters.WriteRaw.FirstMdl;
        partialMdl = WorkContext->Irp->MdlAddress;

        if ( partialMdl != mdl ) {
            ASSERT( (partialMdl->MdlFlags & MDL_PARTIAL) != 0 );
            MmPrepareMdlForReuse( partialMdl );
        }

        //
        // Build the "complete MDL write" request.  Note that
        // irp->IoStatus.Information, which is where we're supposed to
        // put the amount of data actually written, already contains the
        // length of the received data.
        //

        irp->MdlAddress = mdl;

        if ( !WorkContext->Parameters.WriteRaw.ImmediateWriteDone ) {
            irp->IoStatus.Information += immediateLength;
        }

#if DBG
        IF_SMB_DEBUG(RAW2) {
            KdPrint(( "SrvRestartRawReceive: Completing MDL write with length 0x%p\n",
                        (PVOID)irp->IoStatus.Information ));
            DumpMdlChain( mdl );
        }
#endif

        if( lfcb->MdlWriteComplete == NULL ||

            lfcb->MdlWriteComplete(
               lfcb->FileObject,
               &WorkContext->Parameters.WriteRaw.Offset,
               mdl,
               lfcb->DeviceObject ) == FALSE ) {

            status = SrvIssueMdlCompleteRequest( WorkContext, NULL,
                                                 mdl,
                                                 IRP_MJ_WRITE,
                                                 &WorkContext->Parameters.WriteRaw.Offset,
                                                 WorkContext->Parameters.WriteRaw.Length
                    );

            if( !NT_SUCCESS( status ) ) {
                SrvLogServiceFailure( SRV_SVC_MDL_COMPLETE, status );
            }
        }

        SrvFsdRestartWriteRaw( WorkContext );

        return;

    }

    //
    // We're doing a copy write.  Get parameters for the request.
    //

    offset = WorkContext->Parameters.WriteRaw.Offset;
    mdl = WorkContext->RequestBuffer->Mdl;

    //
    // Determine the amount of data to write.  This is the actual amount
    // of data sent by the client.  (Note that this cannot be more than
    // the client originally requested.)
    //

    writeAddress = (PCHAR)WorkContext->RequestBuffer->Buffer;
    writeLength = (ULONG)irp->IoStatus.Information;

    //
    // If the immediate data was not written earlier, it immedidately
    // precedes the data we just received.  Adjust writeAddress and
    // writeLength so that it too is written.
    //

    if ( !WorkContext->Parameters.WriteRaw.ImmediateWriteDone ) {
        writeAddress -= immediateLength;
        writeLength += immediateLength;

    }

    //
    // Form the lock key using the FID and the PID.
    //
    // *** The FID must be included in the key in order to account for
    //     the folding of multiple remote compatibility mode opens into
    //     a single local open.
    //

    key = rfcb->ShiftedFid | WorkContext->Parameters.WriteRaw.Pid;

    //
    // Try the fast I/O path first.
    //

    if ( lfcb->FastIoWrite != NULL ) {

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastWritesAttempted );

        try {
            if ( lfcb->FastIoWrite(
                    lfcb->FileObject,
                    &offset,
                    writeLength,
                    TRUE,
                    key,
                    writeAddress,
                    &WorkContext->Irp->IoStatus,
                    lfcb->DeviceObject
                    ) ) {

                //
                // The fast I/O path worked.  Call the restart routine directly.
                //

                SrvFsdRestartWriteRaw( WorkContext );
                return;
            }
        }
        except( EXCEPTION_EXECUTE_HANDLER ) {
            // Fall through to the slow path on an exception
            status = GetExceptionCode();
            IF_DEBUG(ERRORS) {
                KdPrint(("FastIoRead threw exception %x\n", status ));
            }
        }

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastWritesFailed );

    }

    //
    // The fast I/O path failed, so we need to issue a real I/O request.
    //
    // Remap the MDL to describe only the received data, which may be
    // less than was originally mapped.
    //
    // !!! Is this really necessary?  Can't we just pass in the entire
    //     MDL, and count on the file system to know when to stop?
    //

    if ( writeLength != WorkContext->RequestBuffer->BufferLength ) {
        MmInitializeMdl( mdl, writeAddress, writeLength );
        MmBuildMdlForNonPagedPool( mdl );
    }

    if ( rfcb->ShareType != ShareTypePipe ) {

        //
        // Start the write request, reusing the receive IRP.
        //

        SrvBuildReadOrWriteRequest(
                irp,                         // input IRP address
                lfcb->FileObject,            // target file object address
                WorkContext,                 // context
                IRP_MJ_WRITE,                // major function code
                0,                           // minor function code
                writeAddress,                // buffer address
                writeLength,                 // buffer length
                mdl,                         // MDL address
                offset,                      // byte offset
                key                          // lock key
                );

    } else {

        //
        // Build a write request for NPFS.
        //

        SrvBuildIoControlRequest(
            WorkContext->Irp,
            lfcb->FileObject,
            WorkContext,
            IRP_MJ_FILE_SYSTEM_CONTROL,
            FSCTL_PIPE_INTERNAL_WRITE,
            writeAddress,
            writeLength,
            NULL,
            0,
            NULL,
            NULL
            );

    }

    IF_SMB_DEBUG(RAW2) {
        KdPrint(( "SrvRestartRawReceive: writing to file 0x%p, offset %ld, length %ld\n",
                    lfcb->FileObject, offset.LowPart, writeLength ));
    }

    //
    // Pass the request to the file system.
    //

    WorkContext->FsdRestartRoutine = SrvFsdRestartWriteRaw;
    DEBUG WorkContext->FspRestartRoutine = NULL;

    (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

    //
    // The write has been started.  When it completes, processing
    // continues at SrvFsdRestartWriteRaw.
    //

    return;

} // SrvRestartRawReceive


VOID SRVFASTCALL
SrvRestartReadRawComplete (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This routine completes a read raw by starting any oplock breaks that
    may have been deferred due to the read raw.

    This routine is called in the FSP.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    //
    // Start oplock break notifications, if any are outstanding.
    // SrvSendDelayedOplockBreak also sets read raw in progress to FALSE.
    //

    SrvSendDelayedOplockBreak( WorkContext->Connection );

    //
    // Finish postprocessing of the SMB.
    //

    SrvDereferenceWorkItem( WorkContext );

    return;

} // SrvRestartReadRawComplete


VOID SRVFASTCALL
SrvRestartWriteCompleteResponse (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This is the restart routine that is invoked to clean up after a
    Write Block Raw/Mpx completes, and the necessary clean up could not
    be done in the FSD.  See RestartWriteCompleteResponse in fsd.c.

    This routine is called in the FSP.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    IF_DEBUG(WORKER1) KdPrint(( " - SrvRestartWriteCompleteResponse\n" ));

    //
    // Decrement the active raw write count for the RFCB, potentially
    // allowing the RFCB to be closed.  If WorkContext->Rfcb is NULL,
    // then the count has been decremented in the fsd.
    //

    if ( WorkContext->Rfcb != NULL ) {
        SrvDecrementRawWriteCount ( WorkContext->Rfcb );
    }

    //
    // Dereference control blocks and the connection.
    //

    SrvReleaseContext( WorkContext );

    SrvDereferenceConnection( WorkContext->Connection );
    WorkContext->Connection = NULL;
    WorkContext->Endpoint = NULL;       // not a referenced pointer

    //
    // Put the work item back on the raw mode work item list.
    //

    SrvRequeueRawModeWorkItem( WorkContext );

    IF_DEBUG(TRACE2) KdPrint(( "SrvRestartWriteCompleteResponse complete\n" ));
    return;

} // SrvRestartWriteCompleteResponse


VOID SRVFASTCALL
SrvBuildAndSendWriteCompleteResponse (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Sets up and sends a final response to a Write Block Raw/Mpx request.

    This routine is called in the FSP.  It is invoked as a restart routine
    from the FSD when the status to be returned is not STATUS_SUCCESS.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    SrvFsdBuildWriteCompleteResponse(
        WorkContext,
        WorkContext->Irp->IoStatus.Status,
        (ULONG)WorkContext->Irp->IoStatus.Information
        );

    WorkContext->ResponseBuffer->DataLength =
                    (CLONG)( (PCHAR)WorkContext->ResponseParameters -
                                    (PCHAR)WorkContext->ResponseHeader );
    WorkContext->ResponseHeader->Flags |= SMB_FLAGS_SERVER_TO_REDIR;

    SRV_START_SEND_2(
        WorkContext,
        SrvFsdSendCompletionRoutine,
        WorkContext->FsdRestartRoutine,
        NULL
        );

    return;

} // SrvBuildAndSendWriteCompleteResponse
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\smbprocs.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbprocs.h

Abstract:

    This module defines functions for processing SMBs.

Author:

    Chuck Lenzmeier (chuckl) 5-Oct-1989

Revision History:

--*/

#ifndef _SMBPROCS_
#define _SMBPROCS_

//#include <ntos.h>

//#include "srvblock.h"


//
// SMB processing routine definiton.  SMB_PROCESSOR_PARAMETERS is used
// to declare SMB processing routines.  It reduces the changes that
// have to be made if the definition changes.  SMB_PROCESSOR_ARGUMENTS
// is used by one SMB processor to call another.
//
//

#define SMB_PROCESSOR_PARAMETERS        \
    IN OUT PWORK_CONTEXT WorkContext

#define SMB_PROCESSOR_ARGUMENTS         \
    WorkContext

#define SMB_PROCESSOR_RETURN_TYPE SMB_STATUS SRVFASTCALL
#define SMB_PROCESSOR_RETURN_LOCAL SMB_STATUS

//
// SMB processor return status.
//

typedef enum _SMB_STATUS {
    SmbStatusMoreCommands,
    SmbStatusSendResponse,
    SmbStatusNoResponse,
    SmbStatusInProgress
} SMB_STATUS, *PSMB_STATUS;

//
// SMB transaction processor return status.
//

typedef enum _SMB_TRANS_STATUS {
    SmbTransStatusSuccess,
    SmbTransStatusErrorWithData,
    SmbTransStatusErrorWithoutData,
    SmbTransStatusInProgress
} SMB_TRANS_STATUS, *PSMB_TRANS_STATUS;


typedef
SMB_STATUS
(SRVFASTCALL *PSMB_PROCESSOR) (
    SMB_PROCESSOR_PARAMETERS
    );

/*++

Routine Description:

    The SMB_PROCESSOR is a routine that is called to process a specific
    SMB command.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  In particular, the following
        fields are valid:

        RequestHeader - Address of the request SMB header.

        RequestParameters - Address of the current command's request
            parameters.  The SMB processor should update this field to
            point to the next command in the SMB, if any.

        ResponseHeader - Address of the response SMB header.  Initially,
            this is a copy of the request header.  As return data, such
            as UID, TID, and FID, becomes available, it should be
            written into both the request header (for AndX command
            processors) and the response header (for the client).  Note
            that the response header address *may* be the same as the
            request header address.

        ResponseParameters - Address of the current command's response
            parameters.  The SMB processor should write the response
            data to this address, then update the pointer to point to
            the address of the next command's response area, if any.
            If there are no more commands in the SMB, this field should
            be set to point to the first byte after the response so that
            the length of the response can be computed.

        Endpoint, Connection - Addresses of the endpoint and the
            connection that received the SMB.  These fields should not
            be changed by the SMB processor.  Other block pointers in
            WorkContext (Share, Session, TreeConnect, and Rfcb) may be
            set by the SMB processor if such blocks are referenced
            during processing.  Any non-NULL pointers in these fields
            are dereferenced when SMB processing is complete, before the
            response (if any) is sent.  The Connection and Endpoint
            pointers are not cleared until the WorkContext is requeued
            to the receive queue.

        Parameters - This union is used by the various SMB processors to
            retain state during asynchronous operations.

Return Value:

    SMB_STATUS - Indicates the action to be taken by the calling routine.
        Possible values are the following:

        SmbStatusMoreCommands - There is at least one more AndX
            follow-on command in the request SMB.  The SMB processor has
            updated RequestParameters and ResponseParameters in
            WorkContext to point to the next command's request and
            response areas.  It has also copied the command code of
            the next command into RequestHeader->Command, so that
            SrvProcessSmb can dispatch the next request.

        SmbStatusSendResponse - Processing of the request is complete,
            and a response is to be sent.  ResponseParameters has been
            updated to point to the first location *after* the end of
            the response.  This is used to compute the length of the
            response.

        SmbStatusNoResponse - Processing of the request is complete, but
            either no response is needed or the SMB processor has
            already taken care of sending the response(s).

        SmbStatusInProgress - The SMB processor has started an
            asynchronous operation and will continue processing the SMB
            at an appropriate restart routine when the operation
            completes.  The restart routine, after updating WorkContext,
            calls SrvSmbProcessSmb to continue (or end) processing the
            SMB.

--*/


typedef
SMB_TRANS_STATUS
(*PSMB_TRANSACTION_PROCESSOR) (
    IN OUT PWORK_CONTEXT WorkContext
    );

/*++

Routine Description:

    The SMB_TRANSACTION_PROCESSOR is a routine that is called to process
    a specific Transaction or Transaction2 SMB subfunction.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  In particular, the following
        fields are valid and intended for use by the transaction
        processor:

        ResponseHeader - Address of the response SMB header.  Initially,
            this is a copy of the request header.  The transaction
            processor may update the error class and code fields if it
            encounters an error.

        Parameters.Transacton - Points to the transaction block
            describing the transaction.  All block pointer fields
            (Connection, Session, TreeConnect) in the block are valid.
            Pointers to the setup words and parameter and data bytes,
            and the lengths of these items, are valid.  The transaction
            block is on the connection's pending transaction list.

            The transaction processor must update the transaction block
            to indicate how much data to return.

Return Value:

    BOOLEAN - Indicates whether an error occurred.  FALSE indicates that
        the operation was successful, and that the data counts were
        updated to indicate how much data to return.  TRUE indicates
        that an error occurred, and that SrvSetSmbError was called to
        update the response header and place a null parameters field at
        the end of the response.

--*/


//
// SMB Processing routines.
//

SMB_PROCESSOR_RETURN_TYPE
SrvSmbNotImplemented (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbCreateDirectory (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbDeleteDirectory (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbOpen (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbCreate (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbClose (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbFlush (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbDelete (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbRename (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbQueryInformation (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbSetInformation (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbRead (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbWrite (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbLockByteRange (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbUnlockByteRange (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbCreateTemporary (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbCreateNew (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbCheckDirectory (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbProcessExit (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbSeek (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbLockAndRead (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbReadRaw (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbReadMpx (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbWriteRaw (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbWriteMpx (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbWriteMpxSecondary (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbSetInformation2 (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbQueryInformation2 (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbLockingAndX (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbTransaction (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbTransactionSecondary (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbNtTransaction (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbNtTransactionSecondary (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbNtCreateAndX (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbIoctl (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbIoctlSecondary (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbMove (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbEcho (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbWriteAndClose (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbOpenAndX (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbReadAndX (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbWriteAndX (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbCloseAndTreeDisc (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbFindClose2 (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbFindNotifyClose (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbTreeConnect (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbTreeDisconnect (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbNegotiate (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbSessionSetupAndX (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbLogoffAndX (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbTreeConnectAndX (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbQueryInformationDisk (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbSearch (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbOpenPrintFile (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbClosePrintFile (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbGetPrintQueue (
    SMB_PROCESSOR_PARAMETERS
    );

SMB_PROCESSOR_RETURN_TYPE
SrvSmbNtCancel (
    SMB_PROCESSOR_PARAMETERS
    );

//
// Transaction SMB processors
//

SMB_TRANS_STATUS
SrvSmbOpen2 (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSmbFindFirst2 (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSmbFindNext2 (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSmbQueryFsInformation (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSmbSetFsInformation (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSmbQueryPathInformation (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSmbSetPathInformation (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSmbQueryFileInformation (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSmbSetFileInformation (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSmbFsctl (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSmbIoctl2 (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSmbFindNotify (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSmbCreateDirectory2 (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSmbCreateWithSdOrEa (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSmbNtIoctl (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSmbNtNotifyChange (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSmbNtRename (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSmbQuerySecurityDescriptor (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSmbSetSecurityDescriptor (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSmbQueryQuota (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSmbSetQuota (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvTransactionNotImplemented (
    IN OUT PWORK_CONTEXT WorkContext
    );

//
// Dfs transactions and support routines
//
VOID
SrvInitializeDfs();

VOID
SrvTerminateDfs();

SMB_TRANS_STATUS
SrvSmbGetDfsReferral (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSmbReportDfsInconsistency (
    IN OUT PWORK_CONTEXT WorkContext
    );

NTSTATUS SRVFASTCALL
DfsNormalizeName(
    IN PSHARE Share,
    IN PUNICODE_STRING RelatedPath OPTIONAL,
    IN BOOLEAN StripLastComponent,
    IN OUT PUNICODE_STRING String
    );

NTSTATUS SRVFASTCALL
DfsFindShareName(
    IN PUNICODE_STRING ShareName
    );

VOID SRVFASTCALL
SrvIsShareInDfs(
    IN PSHARE Share,
    OUT BOOLEAN *IsDfs,
    OUT BOOLEAN *IsDfsRoot
);

#endif // def _SMBPROCS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\smbproc.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbproc.c

Abstract:

   This module contains the high-level routines for processing SMBs.
   Current contents:

        SrvEndSmbProcessing
        SrvProcessSmb

        SrvRestartFsdComplete
        SrvRestartSmbReceived

        SrvSmbIllegalCommand
        SrvSmbNotImplemented
        SrvTransactionNotImplemented

Author:

    David Treadwell (davidtr) 25-Sept-1989
    Chuck Lenzmeier

Revision History:

--*/

#include "precomp.h"
#include "smbproc.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_SMBPROC

#ifdef ALLOC_PRAGMA
//#pragma alloc_text( PAGE, SrvEndSmbProcessing )
//#pragma alloc_text( PAGE, SrvProcessSmb )
#pragma alloc_text( PAGE, SrvRestartFsdComplete )
//#pragma alloc_text( PAGE, SrvRestartReceive )
#pragma alloc_text( PAGE, SrvRestartSmbReceived )
#pragma alloc_text( PAGE, SrvSmbIllegalCommand )
#pragma alloc_text( PAGE, SrvSmbNotImplemented )
#pragma alloc_text( PAGE, SrvTransactionNotImplemented )
#endif

USHORT SessionInvalidateCommand = 0xFFFF;
USHORT SessionInvalidateIndex = 0;
USHORT SessionInvalidateMod = 100;


VOID
SrvEndSmbProcessing (
    IN OUT PWORK_CONTEXT WorkContext,
    IN SMB_STATUS SmbStatus
    )

/*++

Routine Description:

    This routine is called when all request processing on an SMB is
    complete.  If no response is to be sent, this routine simply cleans
    up and requeues the request buffer to the receive queue.  If a
    response is to be sent, this routine starts the sending of that
    response; in this case SrvFsdRestartSmbComplete will do the rest of
    the cleanup after the send completes.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        containing information about the SMB.

    SmbStatus - Either SmbStatusSendResponse or SmbStatusNoResponse.

Return Value:

    None.

--*/

{
    CLONG sendLength;

    PAGED_CODE( );

    IF_DEBUG(WORKER2) SrvPrint0( "SrvEndSmbProcessing entered\n" );

    if ( SmbStatus == SmbStatusSendResponse ) {

        //
        // A response is to be sent. The response starts at
        // WorkContext->ResponseHeader, and its length is calculated
        // using WorkContext->ResponseParameters, which the SMB
        // processor set to point to the next location *after* the end
        // of the response.
        //

        sendLength = (CLONG)( (PCHAR)WorkContext->ResponseParameters -
                                (PCHAR)WorkContext->ResponseHeader );

        WorkContext->ResponseBuffer->DataLength = sendLength;

        //
        // Set the bit in the SMB that indicates this is a response from
        // the server.
        //

        WorkContext->ResponseHeader->Flags |= SMB_FLAGS_SERVER_TO_REDIR;

        //
        // Send out the response.  When the send completes,
        // SrvFsdRestartSmbComplete is called.  We then put the original
        // buffer back on the receive queue.
        //

        SRV_START_SEND_2(
            WorkContext,
            SrvFsdRestartSmbAtSendCompletion,
            NULL,
            NULL
            );

        //
        // The send has been started.  Our work is done.
        //

        IF_DEBUG(WORKER2) SrvPrint0( "SrvEndSmbProcessing complete\n" );
        return;

    }

    //
    // There was no response to send.  Dereference the work item.
    //

    SrvDereferenceWorkItem( WorkContext );

    IF_DEBUG(WORKER2) SrvPrint0( "SrvEndSmbProcessing complete\n" );
    return;

} // SrvEndSmbProcessing


VOID SRVFASTCALL
SrvProcessSmb (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This routine dispatches the command(s) in an SMB to the appropriate
    processing routines.  Based on the current command code, it calls
    indirectly through the dispatch table (SrvFspSmbDispatchTable).  The
    SMB processor executes the command, updates pointers into the SMB,
    and returns with an indication of whether there is another command
    to be processed.  If yes, this routine dispatches the next command.
    If no, this routine sends a response, if any.  Alternatively, if the
    SMB processor starts an asynchronous operation, it can indicate so,
    and this routine will simply return to its caller.

    This routine is called initially from SrvRestartSmbReceived, which
    is the FSP routine that gains control after a TdiReceive completion
    work item is queued to the FSP.  It is also called from other
    restart routines when asynchronous operations, such as a file read,
    complete and there are chained (AndX) commands to process.

    SrvRestartSmbReceive loads SMB pointers and such into the work
    context block calling this routine.  Notably, it copies the first
    command code in the SMB into WorkContext->NextCommand.  When an AndX
    command is processed, the SMB processor must load the chained
    command code into NextCommand before calling this routine to process
    that command.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        containing information about the SMB to process.  This block
        is updated during the processing of the SMB.

Return Value:

    None.

--*/

{
    SMB_STATUS smbStatus;
    LONG commandIndex;

    PAGED_CODE( );

    IF_DEBUG(WORKER2) SrvPrint0( "SrvProcessSmb entered\n" );

    //
    // Loop dispatching SMB processors until a status other than
    // SmbStatusMoreCommands is returned.  When an SMB processor returns
    // this command code, it also sets the next command code in
    // WorkContext->NextCommand, so that we can dispatch the next
    // command.
    //

    if( WorkContext->ProcessingCount == 1 &&
        WorkContext->Connection->SmbSecuritySignatureActive &&
        SrvCheckSmbSecuritySignature( WorkContext ) == FALSE ) {

        //
        // We've received an SMB with an invalid security signature!
        //
        SrvSetSmbError( WorkContext, STATUS_ACCESS_DENIED );

        SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );
        return;
    }

    while ( TRUE ) {

        if( ( (WorkContext->NextCommand == SessionInvalidateCommand) ||
              (SessionInvalidateCommand == 0xFF00)
            ) &&
            !((SessionInvalidateIndex++)%SessionInvalidateMod)
          )
        {
            SrvVerifyUid( WorkContext, SmbGetAlignedUshort( &WorkContext->RequestHeader->Uid ) );
            if( WorkContext->Session )
            {
                WorkContext->Session->IsSessionExpired = TRUE;
                KdPrint(( "-=- Expiring Session %p -=-\n", WorkContext->Session ));
            }
        }

        //
        // The first SMB has been validated in the FSD.  It is safe to
        // execute it now.
        //

        commandIndex = SrvSmbIndexTable[WorkContext->NextCommand];

#if DBG
        IF_SMB_DEBUG( TRACE ) {
            KdPrint(( "%s @%p, Blocking %d, Count %d\n",
                    SrvSmbDispatchTable[ commandIndex ].Name,
                    WorkContext,
                    WorkContext->UsingBlockingThread,
                    WorkContext->ProcessingCount ));
        }
#endif

        smbStatus = SrvSmbDispatchTable[commandIndex].Func( WorkContext );

        //
        // If the SMB processor returned SmbStatusInProgress, it started
        // an asynchronous operation and will restart SMB processing
        // when that operation completes.
        //

        if ( smbStatus == SmbStatusInProgress ) {
            IF_DEBUG(WORKER2) SrvPrint0( "SrvProcessSmb complete\n" );
            return;
        }

        //
        // If the SMB processor didn't return SmbStatusMoreCommands,
        // processing of the SMB is done.  Call SrvEndSmbProcessing to
        // send the response, if any, and rundown the WorkContext.
        //
        // *** SrvEndSmbProcessing is a separate function so that
        //     asynchronous restart routines have something to call when
        //     they are done processing the SMB.
        //

        if ( smbStatus != SmbStatusMoreCommands ) {
            SrvEndSmbProcessing( WorkContext, smbStatus );
            IF_DEBUG(WORKER2) SrvPrint0( "SrvProcessSmb complete\n" );
            return;
        }

        //
        // There are more commands in the SMB.  Verify the SMB to make
        // sure that it has a valid header, and that the word count and
        // byte counts are within range.
        //

        if ( !SrvValidateSmb( WorkContext ) ) {
            IF_DEBUG(SMB_ERRORS) {
                SrvPrint0( "SrvProcessSmb: Invalid SMB.\n" );
                SrvPrint1( "  SMB received from %z\n",
                        (PCSTRING)&WorkContext->Connection->OemClientMachineNameString );
            }
            SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );
            IF_DEBUG(WORKER2) SrvPrint0( "SrvProcessSmb complete\n" );
            return;
        }

    }

    // can't get here.

} // SrvProcessSmb


VOID SRVFASTCALL
SrvRestartFsdComplete (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This is the restart routine invoked when SMB processing by the FSD
    is complete.  It's necessary to get back into the FSP in order to
    dereference objects that were used during the processing of the SMB.
    This is true because dereferencing an object may cause it to be
    deleted, which cannot happen in the FSD.

    This routine first dereferences control blocks.  Then, if a response
    SMB was sent, it checks for and processes send errors.  Finally, it
    requeues the work context block as a receive work item.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    IF_DEBUG(WORKER1) SrvPrint0( " - SrvRestartFsdComplete\n" );

    if ( WorkContext->OplockOpen ) {
        SrvCheckDeferredOpenOplockBreak( WorkContext );
    }

    //
    // Dereference the work item.
    //

    SrvDereferenceWorkItem( WorkContext );
    IF_DEBUG(TRACE2) SrvPrint0( "SrvRestartFsdComplete complete\n" );
    return;

} // SrvRestartFsdComplete


VOID SRVFASTCALL
SrvRestartReceive (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This is the restart routine for TDI Receive completion.  It validates
    the smb and setups header and parameter pointers in the work context
    block and before forwarding the request to SmbProcessSmb.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PCONNECTION connection;
    PIRP irp;
    PSMB_HEADER header;
    ULONG length;

    PAGED_CODE( );

    IF_DEBUG(WORKER1) SrvPrint0( " - SrvRestartReceive\n" );

    connection = WorkContext->Connection;
    irp = WorkContext->Irp;

    //
    // Save the length of the received message.  Store the length
    // in the work context block for statistics gathering.
    //

    length = (ULONG)irp->IoStatus.Information;
    WorkContext->RequestBuffer->DataLength = length;
    WorkContext->CurrentWorkQueue->stats.BytesReceived += length;

    //
    // Store in the work context block the time at which processing
    // of the request began.  Use the time that the work item was
    // queued to the FSP for this purpose.
    //

    WorkContext->StartTime = WorkContext->Timestamp;

    //
    // Update the server network error count.  If the TDI receive
    // failed or was canceled, don't try to process an SMB.
    //

    if ( !irp->Cancel &&
         NT_SUCCESS(irp->IoStatus.Status) ||
         irp->IoStatus.Status == STATUS_BUFFER_OVERFLOW ) {

        SrvUpdateErrorCount( &SrvNetworkErrorRecord, FALSE );

        if( irp->IoStatus.Status == STATUS_BUFFER_OVERFLOW ) {
            WorkContext->LargeIndication = TRUE;
        }

        //
        // Initialize the error class and code fields in the header to
        // indicate success.
        //

        header = WorkContext->ResponseHeader;

        SmbPutUlong( &header->ErrorClass, STATUS_SUCCESS );

        //
        // If the connection is closing or the server is shutting down,
        // ignore this SMB.
        //

        if ( (GET_BLOCK_STATE(connection) == BlockStateActive) &&
             !SrvFspTransitioning ) {

            //
            // Verify the SMB to make sure that it has a valid header,
            // and that the word count and byte counts are within range.
            //

            WorkContext->NextCommand = header->Command;

            if ( SrvValidateSmb( WorkContext ) ) {

                //
                // If this is NOT a raw read request, clear the flag
                // that indicates the we just sent an oplock break II to
                // none.  This allows subsequent raw reads to be
                // processed.
                //

                if ( header->Command != SMB_COM_READ_RAW ) {
                    connection->BreakIIToNoneJustSent = FALSE;
                }

                //
                // Process the received SMB.  The called routine is
                // responsible for sending any response(s) that are
                // needed and for getting the receive buffer back onto
                // the receive queue as soon as possible.
                //

                SrvProcessSmb( WorkContext );

                IF_DEBUG(TRACE2) SrvPrint0( "SrvRestartReceive complete\n" );
                return;

            } else {

                IF_DEBUG(SMB_ERRORS) {
                    SrvPrint0( "SrvProcessSmb: Invalid SMB.\n" );
                    SrvPrint1( "  SMB received from %z\n",
                               (PCSTRING)&WorkContext->Connection->OemClientMachineNameString );
                }

                //
                // The SMB is invalid.  We send back an INVALID_SMB
                // status, unless this looks like a Read Block Raw
                // request, in which case we send back a zero-byte
                // response, so as not to confuse the redirector.
                //

                if ( header->Command != SMB_COM_READ_RAW ) {
                    SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
                } else {
                    WorkContext->ResponseParameters = header;
                }

                if( WorkContext->LargeIndication ) {
                    //
                    // We need to consume the rest of the messaage!
                    //
                    SrvConsumeSmbData( WorkContext );
                    return;
                }
                SrvFsdSendResponse( WorkContext );
                return;

            }

        } else {

            SrvDereferenceWorkItem( WorkContext );
            return;

        }

    } else if( irp->Cancel || (irp->IoStatus.Status == STATUS_CANCELLED) ) {

        // The Cancel routine was called while we were receiving.  Let us consume
        // any data left on the transport and return cancelled as the user wishes.
        // We don't bother to return anything if the connection is going down.
        if( (GET_BLOCK_STATE(connection) == BlockStateActive) &&
             !SrvFspTransitioning  )
        {
            SrvSetSmbError( WorkContext, STATUS_CANCELLED );

            if( WorkContext->LargeIndication ) {
                //
                // We need to consume the rest of the messaage!
                //
                SrvConsumeSmbData( WorkContext );
                return;
            }

            SrvFsdSendResponse( WorkContext );
            return;
        }
        else
        {
            SrvDereferenceWorkItem( WorkContext );
            return;
        }

    } else {

        IF_DEBUG(NETWORK_ERRORS) {
            SrvPrint2( "SrvRestartReceive: status = %X for IRP %p\n",
                irp->IoStatus.Status, irp );
        }
        SrvUpdateErrorCount( &SrvNetworkErrorRecord, TRUE );
        SrvDereferenceWorkItem( WorkContext );
        return;

    }

} // SrvRestartReceive


VOID SRVFASTCALL
SrvRestartSmbReceived (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function is the worker thread restart routine for received
    SMBs.  It calls SrvProcessSmb to start processing of the first
    command in the SMB.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    IF_DEBUG(WORKER1) SrvPrint0( " - SrvRestartSmbReceived\n" );

    if ( (GET_BLOCK_STATE(WorkContext->Connection) != BlockStateActive) ||
         SrvFspTransitioning ) {

        //
        // The connection must be disconnecting.  Simply ignore this SMB.
        //

        SrvDereferenceWorkItem( WorkContext );

    } else {

        //
        // Process the received SMB.  The called routine is responsible
        // for sending any response(s) that are needed and for getting
        // the receive buffer back onto the receive queue as soon as
        // possible.
        //

        SrvProcessSmb( WorkContext );

    }

    IF_DEBUG(TRACE2) SrvPrint0( "SrvRestartSmbReceived complete\n" );
    return;

} // SrvRestartSmbReceived

SMB_PROCESSOR_RETURN_TYPE SRVFASTCALL
SrvSmbIllegalCommand (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    This routine is called to process SMBs that have an illegal
    (unassigned) command code.  It builds an error response.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{
    PAGED_CODE( );

    IF_DEBUG(SMB_ERRORS) {
        SrvPrint1( "SrvSmbIllegalCommand: command code 0x%lx\n",
            (ULONG)WorkContext->NextCommand );
    }

    SrvLogInvalidSmb( WorkContext );

    SrvSetSmbError( WorkContext, STATUS_SMB_BAD_COMMAND );
    return SmbStatusSendResponse;

} // SrvSmbIllegalCommand


SMB_PROCESSOR_RETURN_TYPE
SrvSmbNotImplemented (
    SMB_PROCESSOR_PARAMETERS
    )
{
    PAGED_CODE( );

    INTERNAL_ERROR(
        ERROR_LEVEL_UNEXPECTED,
        "SrvSmbNotImplemented: command code 0x%lx",
        (ULONG)WorkContext->NextCommand,
        NULL
        );

    SrvSetSmbError( WorkContext, STATUS_NOT_IMPLEMENTED );
    return SmbStatusSendResponse;

} // SrvSmbNotImplemented


SMB_TRANS_STATUS
SrvTransactionNotImplemented (
    IN OUT PWORK_CONTEXT WorkContext
    )
{
    PTRANSACTION transaction = WorkContext->Parameters.Transaction;

    PAGED_CODE( );

    DEBUG SrvPrint1( "SrvTransactionNotImplemented: function code %lx\n",
                        SmbGetUlong( (PULONG)&transaction->InSetup[0] ) );

    SrvSetSmbError( WorkContext, STATUS_NOT_IMPLEMENTED );

    return SmbTransStatusErrorWithoutData;

} // SrvTransactionNotImplemented
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\smbsrch.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbsrch.c

Abstract:

    This module contains routines for processing the Search SMB.

Author:

    David Treadwell (davidtr)    13-Feb-1990

Revision History:

--*/

#include "precomp.h"
#include "smbsrch.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_SMBSRCH

#define VOLUME_BUFFER_SIZE \
        FIELD_OFFSET(FILE_FS_VOLUME_INFORMATION,VolumeLabel) + \
        MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR)

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvSmbSearch )
#endif


SMB_PROCESSOR_RETURN_TYPE
SrvSmbSearch (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    This routine processes the various search SMBs, including the core
    Search and the LM 1.0 Find, Find Unique, and Find Close.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_SEARCH request;
    PRESP_SEARCH response;

    NTSTATUS status      = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    UNICODE_STRING fileName;
    PSRV_DIRECTORY_INFORMATION directoryInformation = NULL;
    CLONG availableSpace;
    CLONG totalBytesWritten;
    BOOLEAN calledQueryDirectory;
    BOOLEAN findFirst;
    BOOLEAN isUnicode;
    BOOLEAN filterLongNames;
    BOOLEAN isCoreSearch;
    PTABLE_ENTRY entry = NULL;
    SHORT sidIndex;
    SHORT sequence;
    PSMB_RESUME_KEY resumeKey = NULL;
    PCCHAR s;
    PSMB_DIRECTORY_INFORMATION smbDirInfo;
    USHORT smbFileAttributes;
    PSEARCH search = NULL;
    PDIRECTORY_CACHE dirCache, dc;
    USHORT count;
    USHORT maxCount;
    USHORT i;
    USHORT resumeKeyLength;
    UCHAR command;
    CCHAR j;
    CLONG nonPagedBufferSize;
    ULONG resumeFileIndex;
    WCHAR nameBuffer[8 + 1 + 3 + 1];
    OEM_STRING oemString;

    PTREE_CONNECT treeConnect;
    PSESSION session;
    PCONNECTION connection;
    PPAGED_CONNECTION pagedConnection;
    HANDLE RootDirectoryHandle;

    WCHAR unicodeResumeName[ sizeof( dirCache->UnicodeResumeName ) / sizeof( WCHAR ) ];
    USHORT unicodeResumeNameLength = 0;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_SEARCH;
    SrvWmiStartContext(WorkContext);

    connection = WorkContext->Connection;
    pagedConnection = connection->PagedConnection;

    //
    // HackHack: Check the flags2 field if dos client.  Some dos clients
    // set flags2 to 0xffff.
    //

    isUnicode = SMB_IS_UNICODE( WorkContext );

    if ( isUnicode && IS_DOS_DIALECT(connection->SmbDialect) ) {
        WorkContext->RequestHeader->Flags2 = 0;
        isUnicode = FALSE;
    }

    filterLongNames =
        ((SmbGetAlignedUshort( &WorkContext->RequestHeader->Flags2 ) &
          SMB_FLAGS2_KNOWS_LONG_NAMES) == 0) ||
        IS_DOS_DIALECT(connection->SmbDialect);

    IF_SMB_DEBUG(SEARCH1) {
        SrvPrint2( "Search request header at 0x%p, response header at 0x%p\n",
                      WorkContext->RequestHeader, WorkContext->ResponseHeader );
        SrvPrint2( "Search request params at 0x%p, response params%p\n",
                      WorkContext->RequestParameters,
                      WorkContext->ResponseParameters );
    }

    request = (PREQ_SEARCH)WorkContext->RequestParameters;
    response = (PRESP_SEARCH)WorkContext->ResponseParameters;
    command = WorkContext->RequestHeader->Command;

    //
    // Set up a pointer in the SMB buffer where we will write
    // information about files.  The +3 is to account for the
    // SMB_FORMAT_VARIABLE and the word that holds the data length.
    //

    smbDirInfo = (PSMB_DIRECTORY_INFORMATION)(response->Buffer + 3);

    fileName.Buffer = NULL;

    //
    // If a session block has not already been assigned to the current
    // work context , verify the UID.  If verified, the address of the
    // session block corresponding to this user is stored in the
    // WorkContext block and the session block is referenced.
    //
    // Find tree connect corresponding to given TID if a tree connect
    // pointer has not already been put in the WorkContext block by an
    // AndX command.
    //

    status = SrvVerifyUidAndTid(
                WorkContext,
                &session,
                &treeConnect,
                ShareTypeDisk
                );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(SMB_ERRORS) {
            SrvPrint0( "SrvSmbSearch: Invalid UID or TID\n" );
        }
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    isCoreSearch = (BOOLEAN)(command == SMB_COM_SEARCH);

    if( session->IsSessionExpired )
    {
        status = SESSION_EXPIRED_STATUS_CODE;
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Get necessary information from the request SMB before we start
    // overwriting it.
    //

    maxCount = SmbGetUshort( &request->MaxCount );

    //
    // If they aren't asking for any files, then they are confused!
    //
    if( maxCount == 0 ) {

        //
        // We would log this, but certain linux clients mistakenly do this
        //  over and over and over...
        //
        status = STATUS_INVALID_SMB;

        goto error_exit;
    }

    //
    // If this is a core search, we don't want to get too many files,
    // as we have to cache information about them between requests.
    //
    //
    // A buffer of nonpaged pool is required by SrvQueryDirectoryFile.
    // We need to use the SMB buffer for found file names and
    // information, so allocate a buffer from nonpaged pool.
    //
    // If we don't need to return many files, we don't need to allocate
    // a large buffer.  The buffer size is the configurable size or
    // enough to hold two more than the number of files we need to
    // return.  We get space to hold two extra files in case some files
    // do not meet the search criteria (eg directories).
    //

    if ( isCoreSearch ) {
        maxCount = MIN( maxCount, (USHORT)MAX_DIRECTORY_CACHE_SIZE );
        nonPagedBufferSize = MIN_SEARCH_BUFFER_SIZE;

    } else {

        if ( maxCount > MAX_FILES_FOR_MED_SEARCH ) {
            nonPagedBufferSize = MAX_SEARCH_BUFFER_SIZE;
        } else if ( maxCount > MAX_FILES_FOR_MIN_SEARCH ) {
            nonPagedBufferSize = MED_SEARCH_BUFFER_SIZE;
        } else {
            nonPagedBufferSize = MIN_SEARCH_BUFFER_SIZE;
        }
    }

    //
    // The response to a search is never unicode, though the request may be.
    //
    if( isUnicode ) {
        USHORT flags2 = SmbGetAlignedUshort( &WorkContext->RequestHeader->Flags2 );
        flags2 &= ~SMB_FLAGS2_UNICODE;
        SmbPutAlignedUshort( &WorkContext->ResponseHeader->Flags2, flags2 );
    }

    //
    // If there was a resume key, verify the SID.  If there was no
    // resume key, allocate a search block.  The first two bytes after
    // the format token are the length of the resume key.  If they are
    // both zero, then the request was a find first.
    //
    count = MIN( SmbGetUshort( &request->ByteCount ), (USHORT)(END_OF_REQUEST_SMB(WorkContext)-request->Buffer+1) );

    if( isUnicode ) {
        PWCHAR p;

        // We will be starting at a WCHAR offset, so we'll skip the first byte.  Remove it.
        // Also, set count to an even length so we don't have any "half-char" style buffer overruns
        count = count & ~1;

        for( p = (PWCHAR)((PCCHAR)request->Buffer+1), i = 0;
             i < count && SmbGetUshort(p) != UNICODE_NULL;
             p++, i += sizeof(*p) );

            s = (PCCHAR)(p + 1);        // skip past the null to the next char

    } else {

        for ( s = (PCCHAR)request->Buffer, i = 0;
              i < count && *s != (CCHAR)SMB_FORMAT_VARIABLE;
              s++, i += sizeof(*s) );
    }

    //
    // If there was no SMB_FORMAT_VARIABLE token in the buffer, fail.
    //

    if ( i == count || *s != (CCHAR)SMB_FORMAT_VARIABLE ) {

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint0( "SrvSmbSearch: no SMB_FORMAT_VARIABLE token.\n" );
        }

        SrvLogInvalidSmb( WorkContext );

        status = STATUS_INVALID_SMB;
        goto error_exit;
    }

    resumeKeyLength = SmbGetUshort( (PSMB_USHORT)(s+1) );

    if ( resumeKeyLength == 0 ) {

        //
        // There was no resume key, so either a Find First or a Find
        // Unique was intended.  If it was actually a Find Close, return
        // an error to the client.
        //

        if ( command == SMB_COM_FIND_CLOSE ) {

            IF_DEBUG(SMB_ERRORS) {
                SrvPrint0( "SrvSmbSearch: Find Close sent w/o resume key.\n" );
            }

            status = STATUS_INVALID_SMB;

            SrvLogInvalidSmb( WorkContext );
            goto error_exit;
        }

        IF_SMB_DEBUG(SEARCH2) SrvPrint0( "FIND FIRST\n" );

        findFirst = TRUE;
        calledQueryDirectory = FALSE;

        //
        // Initialize the string containing the path name.  The +1 is to
        // account for the ASCII token in the Buffer field of the
        // request SMB.
        //

        status = SrvCanonicalizePathName(
                WorkContext,
                treeConnect->Share,
                NULL,
                (PVOID)(request->Buffer + 1),
                END_OF_REQUEST_SMB( WorkContext ),
                FALSE,
                isUnicode,
                &fileName
                );

        if( !NT_SUCCESS( status ) ) {
            goto error_exit;
        }

        //
        // If the volume attribute bit is set, just return the volume name.
        //

        if ( SmbGetUshort( &request->SearchAttributes )
                 == SMB_FILE_ATTRIBUTE_VOLUME ) {

            //
            // Use NtQueryVolumeInformationFile to get the volume name.
            //

            IO_STATUS_BLOCK ioStatusBlock;
            PFILE_FS_VOLUME_INFORMATION volumeInformation;

            //
            // Allocate enough space to store the volume information structure
            // and MAXIMUM_FILENAME_LENGTH bytes for the volume label name.
            //

            volumeInformation = ALLOCATE_HEAP( VOLUME_BUFFER_SIZE, BlockTypeVolumeInformation );

            if ( volumeInformation == NULL ) {

                INTERNAL_ERROR(
                    ERROR_LEVEL_EXPECTED,
                    "SrvSmbSearch: Unable to allocate memory from server heap",
                    NULL,
                    NULL
                    );

                status = STATUS_INSUFF_SERVER_RESOURCES;
                goto error_exit;
            }

            RtlZeroMemory( volumeInformation, VOLUME_BUFFER_SIZE );

            //
            // Get the Share root handle.
            //

            status = SrvGetShareRootHandle( treeConnect->Share );

            if ( !NT_SUCCESS(status) ) {

                IF_DEBUG(ERRORS) {
                    SrvPrint1( "SrvSmbSearch: SrvGetShareRootHandle failed %x.\n",
                                status );
                }

                FREE_HEAP( volumeInformation );
                goto error_exit;
            }
                        //
            // Handle SnapShot case
            //
            status = SrvSnapGetRootHandle( WorkContext, &RootDirectoryHandle );
            if( !NT_SUCCESS(status) )
            {
                FREE_HEAP( volumeInformation );
                goto error_exit;
            }

            status = NtQueryVolumeInformationFile(
                         RootDirectoryHandle,
                         &ioStatusBlock,
                         volumeInformation,
                         VOLUME_BUFFER_SIZE,
                         FileFsVolumeInformation
                         );

            //
            // If the media was changed and we can come up with a new share root handle,
            //  then we should retry the operation
            //
            if( SrvRetryDueToDismount( treeConnect->Share, status ) ) {

                status = SrvSnapGetRootHandle( WorkContext, &RootDirectoryHandle );
                if( !NT_SUCCESS(status) )
                {
                    FREE_HEAP( volumeInformation );
                    goto error_exit;
                }

                status = NtQueryVolumeInformationFile(
                             RootDirectoryHandle,
                             &ioStatusBlock,
                             volumeInformation,
                             VOLUME_BUFFER_SIZE,
                             FileFsVolumeInformation
                             );
            }

            //
            // Release the share root handle
            //

            SrvReleaseShareRootHandle( WorkContext->TreeConnect->Share );

            if ( !NT_SUCCESS(status) ) {

                INTERNAL_ERROR(
                    ERROR_LEVEL_UNEXPECTED,
                    "SrvSmbSearch: NtQueryVolumeInformationFile returned %X",
                    status,
                    NULL
                    );

                SrvLogServiceFailure( SRV_SVC_NT_QUERY_VOL_INFO_FILE, status );

                FREE_HEAP( volumeInformation );
                goto error_exit;
            }

            IF_SMB_DEBUG(SEARCH2) {
                SrvPrint2( "NtQueryVolumeInformationFile succeeded, name = %ws, "
                          "length %ld\n", volumeInformation->VolumeLabel,
                              volumeInformation->VolumeLabelLength );
            }


            //
            // Check if we have a volume label
            //

            if ( volumeInformation->VolumeLabelLength > 0 ) {

                //
                // Build the response SMB.
                //

                response->WordCount = 1;
                SmbPutUshort( &response->Count, 1 );
                SmbPutUshort(
                    &response->ByteCount,
                    3 + sizeof(SMB_DIRECTORY_INFORMATION)
                    );
                response->Buffer[0] = SMB_FORMAT_VARIABLE;
                SmbPutUshort(
                    (PSMB_USHORT)(response->Buffer+1),
                    sizeof(SMB_DIRECTORY_INFORMATION)
                    );

                //
                // *** Is there anything that we must set in the resume key?
                //

                smbDirInfo->FileAttributes = SMB_FILE_ATTRIBUTE_VOLUME;
                SmbZeroTime( &smbDirInfo->LastWriteTime );
                SmbZeroDate( &smbDirInfo->LastWriteDate );
                SmbPutUlong( &smbDirInfo->FileSize, 0 );

                {
                    UNICODE_STRING unicodeString;
                    OEM_STRING innerOemString;

                    //
                    // Volume labels may be longer than 11 bytes, but we
                    // truncate then to this length in order to make sure that
                    // the label will fit into the 8.3+NULL -byte space in the
                    // SMB_DIRECTORY_INFORMATION structure.  Also, the LM 1.2
                    // ring 3 and Pinball servers do this.
                    //

                    unicodeString.Length =
                                    (USHORT) MIN(
                                        volumeInformation->VolumeLabelLength,
                                        11 * sizeof(WCHAR) );

                    unicodeString.MaximumLength = 13;
                    unicodeString.Buffer = volumeInformation->VolumeLabel;

                    innerOemString.MaximumLength = 13;
                    innerOemString.Buffer = (PCHAR)smbDirInfo->FileName;

                    RtlUnicodeStringToOemString(
                        &innerOemString,
                        &unicodeString,
                        FALSE
                        );

                    //
                    // If the volume label is greater than 8 characters, it
                    // needs to be turned into 8.3 format.
                    //
                    if( innerOemString.Length > 8 ) {
                        //
                        // Slide the last three characters one position to the
                        // right and insert a '.' to formulate an 8.3 name
                        //
                        smbDirInfo->FileName[11] = smbDirInfo->FileName[10];
                        smbDirInfo->FileName[10] = smbDirInfo->FileName[9];
                        smbDirInfo->FileName[9] = smbDirInfo->FileName[8];
                        smbDirInfo->FileName[8] = '.';
                        innerOemString.Length++;
                    }

                    smbDirInfo->FileName[innerOemString.Length] = '\0';

                    //
                    // Blank pad space after the volume label.
                    //

                    for ( i = (USHORT)(innerOemString.Length + 1);
                          i < 13;
                          i++ ) {
                        smbDirInfo->FileName[i] = ' ';
                    }

                }

                //
                // Store the resume key in the response packet. DOS redirs
                // actually use this!
                //

                {

                    UNICODE_STRING baseFileName;

                    SrvGetBaseFileName( &fileName, &baseFileName );

                    SrvUnicodeStringTo8dot3(
                        &baseFileName,
                        (PSZ)smbDirInfo->ResumeKey.FileName,
                        FALSE
                        );

                    //
                    // I set Sid = 1 because the next 5 bytes should
                    // be nonzero and we don't really have a sid.
                    //

                    smbDirInfo->ResumeKey.Sid = 0x01;
                    SmbPutUlong( &smbDirInfo->ResumeKey.FileIndex, 0);

                }

            } else {

                //
                // There is no volume label.
                //

                response->WordCount = 1;
                SmbPutUshort( &response->Count, 0 );
                SmbPutUshort( &response->ByteCount, 3 );
                response->Buffer[0] = SMB_FORMAT_VARIABLE;
                SmbPutUshort( (PSMB_USHORT)(response->Buffer+1), 0 );

            }

            WorkContext->ResponseParameters =
                NEXT_LOCATION(
                    response,
                    RESP_SEARCH,
                    SmbGetUshort( &response->ByteCount )
                    );

            FREE_HEAP( volumeInformation );

            if ( !isUnicode &&
                fileName.Buffer != NULL &&
                fileName.Buffer != nameBuffer ) {
                RtlFreeUnicodeString( &fileName );
            }

            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        //
        // If this is a core search without patterns, short circuit the
        //  whole thing right here.
        //
        if( isCoreSearch && fileName.Length <= sizeof( nameBuffer ) &&
            ( fileName.Length == 0 ||
              !FsRtlDoesNameContainWildCards( &fileName )) ) {

            IO_STATUS_BLOCK ioStatus;
            OBJECT_ATTRIBUTES objectAttributes;
            ULONG attributes;
            ULONG inclusiveSearchAttributes, exclusiveSearchAttributes;
            USHORT searchAttributes;
            UNICODE_STRING baseFileName;
            BOOLEAN returnDirectories, returnDirectoriesOnly;
            FILE_NETWORK_OPEN_INFORMATION fileInformation;
            PSZ dirInfoName;
            SMB_DATE dosDate;
            SMB_TIME dosTime;
            UNICODE_STRING foundFileName;

            UNICODE_STRING ObjectNameString;
            PUNICODE_STRING filePathName;
            BOOLEAN FreePathName = FALSE;

            ObjectNameString.Buffer = fileName.Buffer;
            ObjectNameString.Length = fileName.Length;
            ObjectNameString.MaximumLength = fileName.Length;

            if( fileName.Length == 0 ) {

                //
                // Since we are opening the root of the share, set the attribute to
                // case insensitive, as this is how we opened the share when it was added
                //
                status = SrvSnapGetNameString( WorkContext, &filePathName, &FreePathName );
                if( !NT_SUCCESS(status) )
                {
                    goto error_exit;
                }

                ObjectNameString = *filePathName;
                attributes = OBJ_CASE_INSENSITIVE;

            } else {

                attributes =
                    (WorkContext->RequestHeader->Flags & SMB_FLAGS_CASE_INSENSITIVE ||
                     WorkContext->Session->UsingUppercasePaths ) ?
                    OBJ_CASE_INSENSITIVE : 0;

            }

            SrvInitializeObjectAttributes_U(
                &objectAttributes,
                &ObjectNameString,
                attributes,
                NULL,
                NULL
                );

            status = IMPERSONATE( WorkContext );

            if( NT_SUCCESS( status ) ) {

                status = SrvGetShareRootHandle( treeConnect->Share );

                if( NT_SUCCESS( status ) ) {

                    //
                    // The file name is always relative to the share root
                    //
                    status = SrvSnapGetRootHandle( WorkContext, &objectAttributes.RootDirectory );
                    if( !NT_SUCCESS(status) )
                    {
                        goto SnapError;
                    }

                    //
                    // Get the attributes of the object
                    //
                    if( IoFastQueryNetworkAttributes(
                                            &objectAttributes,
                                            FILE_READ_ATTRIBUTES,
                                            0,
                                            &ioStatus,
                                            &fileInformation
                                            ) == FALSE ) {

                        SrvLogServiceFailure( SRV_SVC_IO_FAST_QUERY_NW_ATTRS, 0 );
                        ioStatus.Status = STATUS_OBJECT_PATH_NOT_FOUND;
                    }

                    status = ioStatus.Status;

                    //
                    // If the media was changed and we can come up with a new share root handle,
                    //  then we should retry the operation
                    //
                    if( SrvRetryDueToDismount( treeConnect->Share, status ) ) {

                        status = SrvSnapGetRootHandle( WorkContext, &objectAttributes.RootDirectory );
                        if( !NT_SUCCESS(status) )
                        {
                            goto SnapError;
                        }

                        //
                        // Get the attributes of the object
                        //
                        if( IoFastQueryNetworkAttributes(
                                                &objectAttributes,
                                                FILE_READ_ATTRIBUTES,
                                                0,
                                                &ioStatus,
                                                &fileInformation
                                                ) == FALSE ) {

                            SrvLogServiceFailure( SRV_SVC_IO_FAST_QUERY_NW_ATTRS, 0 );
                            ioStatus.Status = STATUS_OBJECT_PATH_NOT_FOUND;
                        }
                    }

                    SrvReleaseShareRootHandle( treeConnect->Share );
                }

SnapError:

                REVERT();
            }

            // Free up the string
            if( FreePathName )
            {
                FREE_HEAP( filePathName );
                filePathName = NULL;
            }

            if( !NT_SUCCESS( status ) ) {
                //
                // Do error mapping to keep the DOS clients happy
                //
                if ( status == STATUS_NO_SUCH_FILE ||
                     status == STATUS_OBJECT_NAME_NOT_FOUND ) {
                    status = STATUS_NO_MORE_FILES;
                }
                goto error_exit;
            }

            searchAttributes = SmbGetUshort( &request->SearchAttributes );
            searchAttributes &= SMB_FILE_ATTRIBUTE_READONLY |
                                SMB_FILE_ATTRIBUTE_HIDDEN |
                                SMB_FILE_ATTRIBUTE_SYSTEM |
                                SMB_FILE_ATTRIBUTE_VOLUME |
                                SMB_FILE_ATTRIBUTE_DIRECTORY |
                                SMB_FILE_ATTRIBUTE_ARCHIVE;

            //
            // The file or directory exists, now we need to see if it matches the
            // criteria given by the client
            //
            SRV_SMB_ATTRIBUTES_TO_NT(
                searchAttributes & 0xff,
                &returnDirectories,
                &inclusiveSearchAttributes
            );

            inclusiveSearchAttributes |= FILE_ATTRIBUTE_NORMAL |
                                         FILE_ATTRIBUTE_ARCHIVE |
                                         FILE_ATTRIBUTE_READONLY;

            SRV_SMB_ATTRIBUTES_TO_NT(
                searchAttributes >> 8,
                &returnDirectoriesOnly,
                &exclusiveSearchAttributes
            );

            exclusiveSearchAttributes &= ~FILE_ATTRIBUTE_NORMAL;

            //
            // See if the returned file meets our objectives
            //
            if(
                //
                // If we're only supposed to return directories, then we don't want it
                //
                returnDirectoriesOnly
                ||

                //
                // If there are bits set in FileAttributes that are
                //  not set in inclusiveSearchAttributes, then we don't want it
                //
                ((fileInformation.FileAttributes << 24 ) |
                ( inclusiveSearchAttributes << 24 )) !=
                ( inclusiveSearchAttributes << 24 )

                ||
                //
                // If the file doesn't have attribute bits specified as exclusive
                // bits, we don't want it
                //
                ( ((fileInformation.FileAttributes << 24 ) |
                  (exclusiveSearchAttributes << 24 )) !=
                   (fileInformation.FileAttributes << 24) )

            ) {
                //
                // Just as though the file was never there!
                //
                status = STATUS_OBJECT_PATH_NOT_FOUND;
                goto error_exit;
            }

            //
            // We want this entry!
            // Fill in the response
            //

            //
            // Switch over to a private name buffer, to avoid overwriting info
            //  in the SMB buffer.
            //
            RtlCopyMemory( nameBuffer, fileName.Buffer, fileName.Length );
            foundFileName.Buffer = nameBuffer;
            foundFileName.Length = fileName.Length;
            foundFileName.MaximumLength = fileName.MaximumLength;

            SrvGetBaseFileName( &foundFileName, &baseFileName );
            SrvUnicodeStringTo8dot3(
                &baseFileName,
                (PSZ)smbDirInfo->ResumeKey.FileName,
                TRUE
            );

            //
            // Resume Key doesn't matter, since the client will not come back.  But
            // just in case it does, make sure we have a bum resume key
            //
            SET_RESUME_KEY_INDEX( (PSMB_RESUME_KEY)smbDirInfo, 0xff );
            SET_RESUME_KEY_SEQUENCE(   (PSMB_RESUME_KEY)smbDirInfo, 0xff );
            SmbPutUlong( &((PSMB_RESUME_KEY)smbDirInfo)->FileIndex, 0 );
            SmbPutUlong( (PSMB_ULONG)&((PSMB_RESUME_KEY)smbDirInfo)->Consumer[0], 0 );

            //
            // Fill in the name (even though they knew what it was!)
            //
            oemString.Buffer = smbDirInfo->FileName;
            oemString.MaximumLength = sizeof( smbDirInfo->FileName );
            RtlUpcaseUnicodeStringToOemString( &oemString, &baseFileName, FALSE );

            //
            // Null terminate and blank-pad the name
            //
            oemString.Buffer[ oemString.Length ] = '\0';

            for( i=(USHORT)oemString.Length+1; i < sizeof( smbDirInfo->FileName); i++ ) {
                oemString.Buffer[i] = ' ';
            }

            SRV_NT_ATTRIBUTES_TO_SMB(
                fileInformation.FileAttributes,
                fileInformation.FileAttributes & FILE_ATTRIBUTE_DIRECTORY,
                &smbFileAttributes
                );
            smbDirInfo->FileAttributes = (UCHAR)smbFileAttributes;

            SrvTimeToDosTime(
                &fileInformation.LastWriteTime,
                &dosDate,
                &dosTime
                );

            SmbPutDate( &smbDirInfo->LastWriteDate, dosDate );
            SmbPutTime( &smbDirInfo->LastWriteTime, dosTime );

            SmbPutUlong( &smbDirInfo->FileSize, fileInformation.EndOfFile.LowPart );

            totalBytesWritten = sizeof(SMB_DIRECTORY_INFORMATION);
            count = 1;
            goto done_core;
        }

        directoryInformation = ALLOCATE_NONPAGED_POOL(
                                   nonPagedBufferSize,
                                   BlockTypeDirectoryInfo
                                   );

        if ( directoryInformation == NULL ) {

            INTERNAL_ERROR(
                ERROR_LEVEL_EXPECTED,
                "SrvSmbSearch: unable to allocate nonpaged pool",
                NULL,
                NULL
                );

            status = STATUS_INSUFF_SERVER_RESOURCES;
            goto error_exit;
        }

        directoryInformation->DirectoryHandle = NULL;
        directoryInformation->DownlevelTimewarp = FALSE;

        IF_SMB_DEBUG(SEARCH2) {
            SrvPrint2( "Allocated buffer space of %ld bytes at 0x%p\n",
                          nonPagedBufferSize, directoryInformation );
        }

        //
        // Allocate a search block.  The search block is used to retain
        // state information between search or find SMBs.  The search
        // blocks for core and regular searches are slightly different,
        // hence the BOOLEAN parameter to SrvAllocateSearch.
        //

        //
        // If we've reached our max, start closing searches.
        //

        if ( SrvStatistics.CurrentNumberOfOpenSearches >= SrvMaxOpenSearches ) {

            SrvForceTimeoutSearches( connection );
        }

        SrvAllocateSearch(
            &search,
            &fileName,
            isCoreSearch
            );

        if ( search == NULL ) {

            IF_DEBUG(ERRORS) {
                SrvPrint0( "SrvSmbSearch: unable to allocate search block.\n" );
            }

            status = STATUS_INSUFF_SERVER_RESOURCES;
            goto error_exit;
        }

        search->Pid = SmbGetAlignedUshort(
                               &WorkContext->RequestHeader->Pid
                               );

        //
        // Set up referenced session and tree connect pointers and
        // increment the count of open files on the session.  This
        // prevents an idle session with an open search from being
        // autodisconnected.
        //

        ACQUIRE_LOCK( &connection->Lock );

        if ( isCoreSearch ) {
            pagedConnection->CurrentNumberOfCoreSearches++;
        }

        search->Session = WorkContext->Session;
        SrvReferenceSession( WorkContext->Session );

        search->TreeConnect = WorkContext->TreeConnect;
        SrvReferenceTreeConnect( WorkContext->TreeConnect );

        //
        // If this is not a find unique, put the search block in the
        // search table.  Otherwise, just set the sidIndex and sequence
        // variables to 0 to distinguish between a valid resumable
        // search block.
        //

        if ( command == SMB_COM_FIND_UNIQUE ) {

            WorkContext->Session->CurrentSearchOpenCount++;
            RELEASE_LOCK( &connection->Lock );

            sequence = sidIndex = -1;

        } else {
            NTSTATUS TableStatus;
            PTABLE_HEADER searchTable = &pagedConnection->SearchTable;

            //
            // If there are no free entries in the table, attempt to
            // grow the table.  If we are unable to grow the table,
            // attempt to timeout a search block using the shorter
            // timeout period.  If this fails, reject the request.
            //

            if ( searchTable->FirstFreeEntry == -1
                 &&
                 SrvGrowTable(
                     searchTable,
                     SrvInitialSearchTableSize,
                     SrvMaxSearchTableSize,
                     &TableStatus ) == FALSE
                 &&
                 SrvTimeoutSearches(
                     NULL,
                     connection,
                     TRUE ) == 0
               ) {

                IF_DEBUG(ERRORS)
                    SrvPrint0( "SrvSmbSearch: Connection searchTable full.\n" );

                RELEASE_LOCK( &connection->Lock );

                if( TableStatus == STATUS_INSUFF_SERVER_RESOURCES )
                {
                    SrvLogTableFullError( SRV_TABLE_SEARCH );
                    status = STATUS_OS2_NO_MORE_SIDS;
                }
                else
                {
                    status = TableStatus;
                }

                goto error_exit;

            } else if ( GET_BLOCK_STATE( session ) != BlockStateActive ) {

                //
                //
                // If the session is closing do not insert this search
                // on the search list, because the list may already
                // have been cleaned up.
                //

                RELEASE_LOCK( &connection->Lock );

                status = STATUS_SMB_BAD_UID;
                goto error_exit;

            } else if ( GET_BLOCK_STATE( treeConnect ) != BlockStateActive ) {

                //
                // Tree connect is closing.  Don't insert the search block
                // so the tree connect can be cleaned up immediately.
                //

                RELEASE_LOCK( &connection->Lock );

                status = STATUS_SMB_BAD_TID;
                goto error_exit;

            }

            //
            // increment the count of open searches
            //

            WorkContext->Session->CurrentSearchOpenCount++;

            sidIndex = searchTable->FirstFreeEntry;

            //
            // A free SID was found.  Remove it from the free list and set
            // its owner and sequence number.
            //

            entry = &searchTable->Table[sidIndex];

            searchTable->FirstFreeEntry = entry->NextFreeEntry;
            DEBUG entry->NextFreeEntry = -2;
            if ( searchTable->LastFreeEntry == sidIndex ) {
                searchTable->LastFreeEntry = -1;
            }

            INCREMENT_SID_SEQUENCE( entry->SequenceNumber );

            //
            // SID = sequence | sidIndex == 0 is illegal.  If this is
            // the current value, increment the sequence.
            //

            if ( entry->SequenceNumber == 0 && sidIndex == 0 ) {
                INCREMENT_SID_SEQUENCE( entry->SequenceNumber );
            }

            sequence = entry->SequenceNumber;
            entry->Owner = search;

            RELEASE_LOCK( &connection->Lock );
        }

        //
        // Fill in other fields of the search block.
        //

        search->SearchAttributes =
            SmbGetUshort( &request->SearchAttributes );
        search->TableIndex = sidIndex;

        IF_SMB_DEBUG(SEARCH2) {
            SrvPrint3( "Allocated search block at 0x%p.  Index = 0x%lx, sequence = 0x%lx\n", search, sidIndex, sequence );
        }

    } else {

        //
        // The resume key length was nonzero, so this should be a find
        // next.  Check the resume key length to be safe.
        //

        USHORT resumeSequence;

        if ( resumeKeyLength != sizeof(SMB_RESUME_KEY) ) {

            IF_DEBUG(SMB_ERRORS) {
                SrvPrint2( "Resume key length was incorrect--was %ld instead "
                          "of %ld\n", resumeKeyLength, sizeof(SMB_RESUME_KEY) );
            }

            SrvLogInvalidSmb( WorkContext );

            status = STATUS_INVALID_SMB;
            goto error_exit;
        }

        findFirst = FALSE;

        resumeKey = (PSMB_RESUME_KEY)(s + 3);

        //
        // Set up the sequence number and index.  These are used for the
        // return resume keys.
        //

        sequence = SID_SEQUENCE( resumeKey );
        sidIndex = SID_INDEX( resumeKey );

        directoryInformation = ALLOCATE_NONPAGED_POOL(
                                   nonPagedBufferSize,
                                   BlockTypeDirectoryInfo
                                   );

        if ( directoryInformation == NULL ) {

            INTERNAL_ERROR(
                ERROR_LEVEL_EXPECTED,
                "SrvSmbSearch: unable to allocate nonpaged pool",
                NULL,
                NULL
                );

            status = STATUS_INSUFF_SERVER_RESOURCES;
            goto error_exit;
        }

        directoryInformation->DirectoryHandle = NULL;

        IF_SMB_DEBUG(SEARCH2) {
            SrvPrint2( "Allocated buffer space of %ld bytes at 0x%p\n",
                          nonPagedBufferSize, directoryInformation );
        }
        //
        // Verify the SID in the resume key.  SrvVerifySid also fills in
        // fields of directoryInformation so it is ready to be used by
        // SrvQueryDirectoryFile.
        //

        search = SrvVerifySid(
                     WorkContext,
                     sidIndex,
                     sequence,
                     directoryInformation,
                     nonPagedBufferSize
                     );

        if ( search == NULL ) {

            if (0) IF_DEBUG(SMB_ERRORS) {
                SrvPrint2( "SrvSmbSearch: Invalid resume key (SID): index = "
                          "%lx, seq. = %lx\n",
                          sidIndex, sequence );
            }

            status = STATUS_INVALID_PARAMETER;
            goto error_exit;
        }

        //
        // If this is a core search, take the search block off its last-use
        // list.  We will return it to the end of the list when we are
        // done processing this SMB.
        //

        if ( isCoreSearch ) {

            USHORT dirCacheIndex;

            ACQUIRE_LOCK( &connection->Lock );

            //
            // If the reference count on the search block is not 2,
            // somebody messed up and we could run into problems,
            // because the timeout code assumes that dereferencing a
            // search block will kill it.  The reference count is 2--one
            // for our pointer, one for the active status.
            //

            ASSERT( search->BlockHeader.ReferenceCount == 2 );

            //
            // If the search block has already been taken off the LRU
            // list, then the client has attempted two simultaneous core
            // searches with the same search block.  This is an error on
            // the part of the client.
            //

            if ( search->LastUseListEntry.Flink == NULL ) {

                RELEASE_LOCK( &connection->Lock );
                status = STATUS_INVALID_SMB;

                IF_DEBUG(SMB_ERRORS) {
                    SrvPrint0( "SrvSmbSearch: Attempt to do two simultaneuos core searches on same search block.\n" );
                }

                SrvLogInvalidSmb( WorkContext );
                goto error_exit;
            }

            SrvRemoveEntryList(
                &pagedConnection->CoreSearchList,
                &search->LastUseListEntry
                );

            DECREMENT_DEBUG_STAT2( SrvDbgStatistics.CoreSearches );

            //
            // Set the entry pointer fields to NULL so that if another
            // core search comes in for this search block we will know
            // there is an error.
            //

            search->LastUseListEntry.Flink = NULL;
            search->LastUseListEntry.Blink = NULL;

            //
            // Get the information from the directory cache
            // corresponding to this file and put it into the resume key
            // so that SrvQueryDirectoryFile has the proper information
            // in the resume key.  Core clients do not return the
            // correct file name in the resume key, and have special
            // requirements for the file index in the resume key.
            //

            resumeFileIndex = SmbGetUlong( &resumeKey->FileIndex );
            resumeSequence = (USHORT)((resumeFileIndex & 0xFFFF0000) >> 16);

            dirCacheIndex = (USHORT)(resumeFileIndex & (USHORT)0xFFFF);

            //
            // If the directory cache pointer in the search block
            // indicates that there is no directory cache, then we
            // returned no files last time, so return no files this
            // time.  This is due to DOS weirdness.
            //

            if ( search->DirectoryCache == NULL ||
                 dirCacheIndex >= search->NumberOfCachedFiles ) {

                IF_SMB_DEBUG(SEARCH2) {
                    SrvPrint0( "Core request for rewind when no dircache exists.\n" );
                }

                //
                // Put the search block back on the LRU list if the
                // session and tree connect is still active.
                //

                if ((GET_BLOCK_STATE( session ) == BlockStateActive) &&
                    (GET_BLOCK_STATE( treeConnect ) == BlockStateActive)) {

                    KeQuerySystemTime( &search->LastUseTime );
                    SrvInsertTailList(
                        &pagedConnection->CoreSearchList,
                        &search->LastUseListEntry
                        );
                    INCREMENT_DEBUG_STAT2( SrvDbgStatistics.CoreSearches );

                    RELEASE_LOCK( &connection->Lock );

                } else {

                    RELEASE_LOCK( &connection->Lock );

                    //
                    // Not needed any more since session is closing.
                    //

                    SrvCloseSearch( search );
                }

                //
                // Remove our pointer's reference.
                //

                SrvDereferenceSearch( search );

                //
                // Build the response SMB.
                //

                response->WordCount = 1;
                SmbPutUshort( &response->Count, 0 );
                SmbPutUshort( &response->ByteCount, 3 );
                response->Buffer[0] = SMB_FORMAT_VARIABLE;
                SmbPutUshort( (PSMB_USHORT)(response->Buffer+1), 0 );

                WorkContext->ResponseParameters = NEXT_LOCATION(
                                                     response,
                                                     RESP_SEARCH,
                                                     3
                                                     );

                DEALLOCATE_NONPAGED_POOL( directoryInformation );

                SmbStatus = SmbStatusSendResponse;
                goto Cleanup;
            }

            dirCache = &search->DirectoryCache[dirCacheIndex];

            IF_SMB_DEBUG(SEARCH2) {
                SrvPrint3( "Accessing dircache, real file = %ws, index = 0x%lx, "
                          "cache index = %ld\n",
                              dirCache->UnicodeResumeName, dirCache->FileIndex,
                              dirCacheIndex );
            }

            SmbPutUlong( &resumeKey->FileIndex, dirCache->FileIndex );
            unicodeResumeNameLength = dirCache->UnicodeResumeNameLength;

            ASSERT( unicodeResumeNameLength <= sizeof( unicodeResumeName ) );

            RtlCopyMemory( unicodeResumeName,
                           dirCache->UnicodeResumeName,
                           unicodeResumeNameLength );

            //
            // Free the directory cache--it is no longer needed.
            //

            FREE_HEAP( search->DirectoryCache );
            search->DirectoryCache = NULL;
            search->NumberOfCachedFiles = 0;

            RELEASE_LOCK( &connection->Lock );

        } else if ( command == SMB_COM_FIND_CLOSE ) {

            //
            // If this is a find close request, close the search block and
            // dereference it. Close out the directory query, and send the
            // response SMB.
            //

            IF_SMB_DEBUG(SEARCH2) {
                SrvPrint1( "FIND CLOSE: Closing search block at 0x%p\n",
                              search );
            }

            SrvCloseQueryDirectory( directoryInformation );
            search->DirectoryHandle = NULL;

            SrvCloseSearch( search );

            //
            // Dereference the search block.  SrvCloseSearch has already
            // dereferenced it once, so it will be deallocated when we
            // dereference it here.
            //

            SrvDereferenceSearch( search );

            DEALLOCATE_NONPAGED_POOL( directoryInformation );

            response->WordCount = 1;
            SmbPutUshort( &response->ByteCount, 3 );
            response->Buffer[0] = SMB_FORMAT_VARIABLE;
            SmbPutUshort( (PSMB_USHORT)(response->Buffer+1), 0 );

            WorkContext->ResponseParameters = NEXT_LOCATION(
                                                  response,
                                                  RESP_SEARCH,
                                                  0
                                                  );

            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        IF_SMB_DEBUG(SEARCH2) {
            SrvPrint1( "FIND NEXT: Resuming search with file %s\n",
                          resumeKey->FileName );
        }

        //
        // Set the filename string so that SrvQueryDirectoryFile knows
        // what search to resume on.
        //


        if( unicodeResumeNameLength != 0 ) {

            fileName.Buffer = unicodeResumeName;
            fileName.Length = fileName.MaximumLength = unicodeResumeNameLength;

        } else {

            fileName.Buffer = nameBuffer;

            Srv8dot3ToUnicodeString(
                (PSZ)resumeKey->FileName,
                &fileName
                );
        }


        //
        // Set calledQueryDirectory to TRUE will indicate to
        // SrvQueryDirectoryFile that it does not need to parse the
        // input name for the directory in which the search occurs, nor
        // does it need to open the directory.
        //

        calledQueryDirectory = TRUE;

        //
        // Get the resume file index in an aligned field for later use.
        //

        resumeFileIndex = SmbGetUlong( &resumeKey->FileIndex );

        IF_SMB_DEBUG(SEARCH2) {
            SrvPrint1( "Found search block at 0x%p\n", search );
        }
    }

    IF_SMB_DEBUG(SEARCH2) {
        SrvPrint2( "Sequence # = %ld, index = %ld\n", sequence, sidIndex );
    }

    //
    // Find the amount of space we have available for writing file
    // entries into.  The total buffer size available (includes space
    // for the SMB header and parameters) is the minimum of our buffer
    // size and the client's buffer size.  The available space is the
    // total buffer space less the amount we will need for the SMB
    // header and parameters.
    //

    IF_SMB_DEBUG(SEARCH2) {
        SrvPrint4( "BL = %ld, MBS = %ld, r->B = 0x%p, RB->Buffer = 0x%p\n",
                      WorkContext->ResponseBuffer->BufferLength,
                      session->MaxBufferSize, (PSZ)response->Buffer,
                      (PSZ)WorkContext->ResponseBuffer->Buffer );
    }

    availableSpace =
        MIN(
            WorkContext->ResponseBuffer->BufferLength,
            (CLONG)session->MaxBufferSize
            ) -
        PTR_DIFF(response->Buffer, WorkContext->ResponseBuffer->Buffer );

    IF_SMB_DEBUG(SEARCH2) {
        SrvPrint1( "Available buffer space: %ld\n", availableSpace );
    }

    //
    // Simplify the search patterns if possible.  This makes the filesystems more
    //  efficient, as they special case the '*' pattern
    //
    if ( (fileName.Length >= (12 * sizeof(WCHAR))) &&
         (RtlEqualMemory(
            &fileName.Buffer[fileName.Length/sizeof(WCHAR) - 12],
            StrQuestionMarks,
            12 * sizeof(WCHAR)))) {

            if( fileName.Length == (12 * sizeof( WCHAR )) ||
                fileName.Buffer[ fileName.Length/sizeof(WCHAR) - 13 ] == L'\\' ) {

                //
                // The search name ends in ????????.???, replace it with *
                //
                fileName.Buffer[fileName.Length/sizeof(WCHAR)-12] = L'*';
                fileName.Length -= 11 * sizeof(WCHAR);

            }

    } else if ((fileName.Length >= (3 * sizeof(WCHAR))) &&
         (RtlEqualMemory(
            &fileName.Buffer[fileName.Length/sizeof(WCHAR) - 3],
            StrStarDotStar,
            3 * sizeof(WCHAR)))) {

            if( fileName.Length == (3 * sizeof( WCHAR )) ||
                fileName.Buffer[ fileName.Length/sizeof(WCHAR) - 4 ] == L'\\' ) {

                //
                // The search name ends in *.*, replace it with *
                //

                fileName.Length -= 2 * sizeof(WCHAR);

            }
    }

    if( isCoreSearch ) {
        dirCache = (PDIRECTORY_CACHE)ALLOCATE_HEAP(
                                     maxCount * sizeof(DIRECTORY_CACHE),
                                     BlockTypeDirCache
                                     );

        if( dirCache == NULL ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_EXPECTED,
                "SrvSmbSearch: Unable to allocate %d bytes from heap",
                maxCount * sizeof(DIRECTORY_CACHE),
                NULL
                );

            status = STATUS_INSUFF_SERVER_RESOURCES;
            goto error_exit;
        }

        RtlZeroMemory( dirCache, maxCount * sizeof(DIRECTORY_CACHE) );
    }

    //
    // Now we can start getting files.  We do this until one of three
    // conditions is met:
    //
    //   1) There are no more files to return.
    //   2) We have obtained as many files as were requested.
    //   3) The SMB buffer is full.
    //

    count = 0;
    totalBytesWritten = 0;
    dc = dirCache;

    do {

        PSZ dirInfoName;
        UNICODE_STRING name;
        PFILE_BOTH_DIR_INFORMATION bothDirInfo;
        SMB_DATE dosDate;
        SMB_TIME dosTime;
        ULONG effectiveBufferSize;

        //
        // Since the file information returned by NtQueryDirectoryFile is
        // about twice the size of the information we must return in the SMB
        // (SMB_DIRECTORY_INFORMATION), use a buffer size equal to twice the
        // available space if the available space is getting small.  This
        // optimization means that NtQueryDirectoryFile will return unused
        // files less often.  For example, if there is only space left in
        // the SMB buffer for a single file entry, it does not make sense
        // for NtQueryDirectoryFile to completely fill up the buffer--all it
        // really needs to return is a single file.
        //

        effectiveBufferSize = MIN( nonPagedBufferSize, availableSpace * 2 );

        //
        // Make sure that there is at least enough room to hold a single
        // file.
        //

        effectiveBufferSize = MAX( effectiveBufferSize, MIN_SEARCH_BUFFER_SIZE );

        status = SrvQueryDirectoryFile(
                       WorkContext,
                       (BOOLEAN)!calledQueryDirectory,
                       TRUE,                        // filter long names
                       FALSE,                       // not for backup intent
                       FileBothDirectoryInformation,
                       0,
                       &fileName,
                       (PULONG)( (findFirst || count != 0) ?
                                  NULL : &resumeFileIndex ),
                       search->SearchAttributes,
                       directoryInformation,
                       effectiveBufferSize
                       );

        calledQueryDirectory = TRUE;

        if ( status == STATUS_NO_SUCH_FILE ) {
            status = STATUS_NO_MORE_FILES;
        } else if ( status == STATUS_OBJECT_NAME_NOT_FOUND ) {
            status = STATUS_OBJECT_PATH_NOT_FOUND;
        }

        if ( status == STATUS_NO_MORE_FILES ) {

            if ( findFirst && count == 0 ) {

                //
                // If no files matched on the find first, close out
                // the search.
                //

                IF_SMB_DEBUG(SEARCH1) {
                    SrvPrint1( "SrvSmbSearch: no matching files (%wZ).\n",
                                  &fileName );
                }

                if( isCoreSearch ) {
                    FREE_HEAP( dirCache );
                }
                goto error_exit;
            }

            break;

        } else if ( !NT_SUCCESS(status) ) {
            IF_DEBUG(ERRORS) {
                SrvPrint1(
                    "SrvSmbSearch: SrvQueryDirectoryFile returned %X\n",
                    status
                    );
            }

            if( isCoreSearch ) {
                FREE_HEAP( dirCache );
            }

            goto error_exit;
        }

        //
        // Set the resumeKey pointer to NULL.  If this is a find next, we
        // have already resumed/rewound the search, so calls to
        // NtQueryDirectoryFile during this search should continue where
        // the last search left off.
        //

        resumeKey = NULL;

        //
        // If this is a Find command, then put the 8dot3 (no ".")
        // representation of the file name into the resume key.  If
        // this is a search command, then put the 8dot3 representation of
        // the search specification in the resume key.
        //

        bothDirInfo = (PFILE_BOTH_DIR_INFORMATION)
                                directoryInformation->CurrentEntry;


        IF_SMB_DEBUG(SEARCH2) {
            SrvPrint3( "SrvQueryDirectoryFile--name %ws, length = %ld, "
                      "status = %X\n",
                          bothDirInfo->FileName,
                          bothDirInfo->FileNameLength,
                          status );
            SrvPrint1( "smbDirInfo = 0x%p\n", smbDirInfo );
        }

        //
        // Use the FileName, unless it is not legal 8.3
        //
        name.Buffer = bothDirInfo->FileName;
        name.Length = (SHORT)bothDirInfo->FileNameLength;

        if( bothDirInfo->ShortNameLength != 0 ) {

            if( !SrvIsLegalFatName( bothDirInfo->FileName,
                                    bothDirInfo->FileNameLength ) ) {

                //
                // FileName is not legal 8.3, so switch to the
                //  ShortName
                //
                name.Buffer = bothDirInfo->ShortName;
                name.Length = (SHORT)bothDirInfo->ShortNameLength;
            }
        }

        name.MaximumLength = name.Length;

        if ( isCoreSearch ) {

            UNICODE_STRING baseFileName;

            SrvGetBaseFileName( &search->SearchName, &baseFileName );

            SrvUnicodeStringTo8dot3(
                &baseFileName,
                (PSZ)smbDirInfo->ResumeKey.FileName,
                filterLongNames
                );

            //
            // Save the unicode version of the 8.3 name in the dirCache
            //
            dc->UnicodeResumeNameLength = MIN(name.Length, 12*sizeof(WCHAR));
            RtlCopyMemory( dc->UnicodeResumeName, name.Buffer, MIN(name.Length, 12*sizeof(WCHAR)) );
            dc->FileIndex = bothDirInfo->FileIndex;

            ++dc;

        } else {

            SrvUnicodeStringTo8dot3(
                &name,
                (PSZ)smbDirInfo->ResumeKey.FileName,
                filterLongNames
                );
        }

        //
        // Generate the resume key for this file.
        //
        // *** This must be done AFTER setting the file name in the resume
        //     key, as setting the resume key name would overwrite some
        //     of the sequence bytes which are stored in the high bits
        //     of the file name bytes.
        //

        SET_RESUME_KEY_INDEX( (PSMB_RESUME_KEY)smbDirInfo, sidIndex );
        SET_RESUME_KEY_SEQUENCE( (PSMB_RESUME_KEY)smbDirInfo, sequence );

        //
        // Put the file index in the resume key.
        //

        SmbPutUlong(
            &((PSMB_RESUME_KEY)smbDirInfo)->FileIndex,
            bothDirInfo->FileIndex
            );

        SmbPutUlong(
            (PSMB_ULONG)&((PSMB_RESUME_KEY)smbDirInfo)->Consumer[0],
            0
            );

        //
        // Load the file name into the SMB_DIRECTORY_INFORMATION structure.
        //

        dirInfoName = (PSZ)smbDirInfo->FileName;

        oemString.Buffer = dirInfoName;
        oemString.MaximumLength = (USHORT)RtlUnicodeStringToOemSize( &name );

        if ( filterLongNames ) {

            //
            // If the client doesn't understand long names, upcase the file
            // name.  This is necessary for compatibility reasons.  Note
            // that the FAT file system returns upcased names anyway.
            //

            RtlUpcaseUnicodeStringToOemString( &oemString, &name, FALSE );

        } else {

            RtlUnicodeStringToOemString( &oemString, &name, FALSE );

        }

        //
        // Blank-pad the end of the filename in order to be compatible with
        // prior redirectors.
        //
        // !!! It is not certain whether this is required.
        //

        for ( i = (USHORT)(oemString.MaximumLength); i < 13; i++ ) {
            dirInfoName[i] = ' ';
        }

        //
        // Fill in other fields in the file entry.
        //

        SRV_NT_ATTRIBUTES_TO_SMB(
            bothDirInfo->FileAttributes,
            bothDirInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY,
            &smbFileAttributes
            );

        smbDirInfo->FileAttributes = (UCHAR)smbFileAttributes;

        SrvTimeToDosTime(
            &bothDirInfo->LastWriteTime,
            &dosDate,
            &dosTime
            );

        SmbPutDate( &smbDirInfo->LastWriteDate, dosDate );
        SmbPutTime( &smbDirInfo->LastWriteTime, dosTime );

        //
        // *** NT file sizes are LARGE_INTEGERs (64 bits), SMB file sizes
        //     are longwords (32 bits).  We just return the low 32 bits
        //     of the NT file size, because that is all we can do.
        //

        SmbPutUlong( &smbDirInfo->FileSize, bothDirInfo->EndOfFile.LowPart );

        //
        // Find the space left in the SMB buffer.
        //

        availableSpace -= sizeof(SMB_DIRECTORY_INFORMATION);

        totalBytesWritten += sizeof(SMB_DIRECTORY_INFORMATION);

        //
        // Set up the smbDirInfo pointer for the next file.  There is
        // no padding for alignment between files, so just increment
        // the pointer.
        //

        smbDirInfo++;

        count++;

    } while ( ( availableSpace > sizeof(SMB_DIRECTORY_INFORMATION) ) &&
              ( count < maxCount ) );

    IF_SMB_DEBUG(SEARCH2) {

        SrvPrint0( "Stopped putting entries in buffer.  Reason:\n" );

        if ( status == STATUS_NO_MORE_FILES ) {
            SrvPrint0( "status = STATUS_NO_MORE_FILES\n" );
        } else if ( count >= maxCount ) {
            SrvPrint2( "count = %ld, maxCount = %ld\n", count, maxCount );
        } else {
            SrvPrint1( "Available space = %ld\n", availableSpace );
        }
    }

    //
    // Store information in the search block.
    //

    search->DirectoryHandle = directoryInformation->DirectoryHandle;
    search->Wildcards = directoryInformation->Wildcards;
    search->DownlevelTimewarp = directoryInformation->DownlevelTimewarp;

    //
    // If this was a core search, store information about the files that
    // were returned in a directory cache.  Also, modify the information
    // in the SMB buffer, as it is slightly different for core searches.
    //

    if ( isCoreSearch ) {

        if ( count == 0 ) {

            FREE_HEAP( dirCache );

            IF_SMB_DEBUG(SEARCH1) {
                SrvPrint3( "SrvSmbSearch: prematurely closing search %p, index %lx sequence %lx\n",
                               search, sidIndex, sequence );
            }

            SrvCloseSearch( search );
            goto done_core;
        }

        //
        // Modify the CoreSequence field of the search block.  This is
        // done because core searches demand that the FileIndex field of
        // the resume key always increase.
        //

        search->CoreSequence++;

        //
        // Set up the pointer to the file information now stored in the
        // SMB buffer and save the location of the directory cache.
        // Store the number of files in the directory cache.
        //

        smbDirInfo = (PSMB_DIRECTORY_INFORMATION)(response->Buffer + 3);
        search->DirectoryCache = dirCache;
        search->NumberOfCachedFiles = count;

        //
        // Loop through the files changing information about the files
        // in the SMB buffer to conform to what the core client expects.
        //

        for ( i = 0; i < count; i++ ) {

            SmbPutUlong(
                &smbDirInfo->ResumeKey.FileIndex,
                (search->CoreSequence << 16) + i
                );

            smbDirInfo++;
            dirCache++;
        }

        //
        // If this was a core search, put the search block back on the
        // appropriate search block list.  If no files were found for this
        // SMB, put the search block on the complete list.  Also, set the
        // last use time field of the search block.
        //
        // If this is a find first to which we responded with
        // one file AND either more than one file was requested or this
        // is a unique search (no wildcards) AND there was space in the
        // buffer for more, close out the search.  This saves the memory
        // associated with an open handle and frees up the search table
        // entry.  Also close the search if zero files are being returned.
        //
        // We can do this safely because we know that the client would
        // not be able to do a rewind or resume with these conditions
        // and get back anything other than NO_MORE_FILES, which is what
        // we'll return if the client attempts to resume or rewind to an
        // invalid SID.
        //

        if ( (count == 1
                 &&
              findFirst
                 &&
              ( maxCount > 1 || !search->Wildcards )
                 &&
              availableSpace > sizeof(SMB_DIRECTORY_INFORMATION) ) ) {

            IF_SMB_DEBUG(SEARCH1) {
                SrvPrint3( "SrvSmbSearch: prematurely closing search %p, index %lx sequence %lx\n",
                               search, sidIndex, sequence );
            }

            SrvCloseSearch( search );

        } else {

            PLIST_ENTRY hashEntry;

            //
            // Put the search on the core search list.
            //

            ACQUIRE_LOCK( &connection->Lock );

            if ( GET_BLOCK_STATE( session ) != BlockStateActive ) {

                //
                // The session is closing.  Do not insert this search
                // on the search list, because the list may already
                // have been cleaned up.
                //

                RELEASE_LOCK( &connection->Lock );
                status = STATUS_SMB_BAD_UID;
                goto error_exit;

            } else if ( GET_BLOCK_STATE( treeConnect ) != BlockStateActive ) {

                //
                // Tree connect is closing.  Don't insert the search block
                // so the tree connect can be cleaned up immediately.
                //

                RELEASE_LOCK( &connection->Lock );
                status = STATUS_SMB_BAD_TID;
                goto error_exit;
            }

            KeQuerySystemTime( &search->LastUseTime );

            SrvInsertTailList(
                &pagedConnection->CoreSearchList,
                &search->LastUseListEntry
                );

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.CoreSearches );

            //
            // Insert this into the hash table.
            //

            hashEntry = &search->HashTableEntry;

            if ( hashEntry->Flink == NULL ) {
                SrvAddToSearchHashTable(
                                pagedConnection,
                                search
                                );
            } else {

                PLIST_ENTRY listHead;

                listHead = &pagedConnection->SearchHashTable[
                                            search->HashTableIndex].ListHead;

                if ( listHead->Flink != hashEntry ) {

                    //
                    // remove it and put it back on the front of the queue.
                    //

                    SrvRemoveEntryList(
                        listHead,
                        hashEntry
                        );

                    SrvInsertHeadList(
                        listHead,
                        hashEntry
                        );
                }
            }

            RELEASE_LOCK( &connection->Lock );

            //
            // Make sure the reference count will be 2.  1 for out pointer,
            // and one for the active status.
            //

            ASSERT( search->BlockHeader.ReferenceCount == 2 );
        }

    } else if ( command == SMB_COM_FIND_UNIQUE ) {

        //
        // If this was a find unique, get rid of the search block by
        // closing the query directory and the search block.
        //

        search->DirectoryHandle = NULL;
        SrvCloseQueryDirectory( directoryInformation );
        SrvCloseSearch( search );
    }

done_core:

    //
    // Set up the response SMB.
    //

    response->WordCount = 1;
    SmbPutUshort( &response->Count, count );
    SmbPutUshort( &response->ByteCount, (USHORT)(totalBytesWritten+3) );
    response->Buffer[0] = SMB_FORMAT_VARIABLE;
    SmbPutUshort(
        (PSMB_USHORT)(response->Buffer+1),
        (USHORT)totalBytesWritten
        );

    WorkContext->ResponseParameters = NEXT_LOCATION(
                                          response,
                                          RESP_SEARCH,
                                          SmbGetUshort( &response->ByteCount )
                                          );

    //
    // Remove our pointer's reference.
    //

    if( search ) {
        search->InUse = FALSE;
        SrvDereferenceSearch( search );
    }

    if ( !isUnicode &&
        fileName.Buffer != NULL &&
        fileName.Buffer != nameBuffer &&
        fileName.Buffer != unicodeResumeName ) {

        RtlFreeUnicodeString( &fileName );
    }

    if( directoryInformation ) {
        DEALLOCATE_NONPAGED_POOL( directoryInformation );
    }

    SmbStatus = SmbStatusSendResponse;
    goto Cleanup;

error_exit:

    if ( search != NULL ) {

        //
        // If findFirst == TRUE, then we allocated a search block which
        //      we have to close.
        // If findFirst == TRUE and calledQueryDirectory == TRUE, then
        //      we also opened the directory handle and need to close it.
        // If findFirst == FALSE, then then we got an existing search
        //      block with an existing directory handle.
        //

        if ( findFirst) {
            if ( calledQueryDirectory ) {
                SrvCloseQueryDirectory( directoryInformation );
                search->DirectoryHandle = NULL;
            }
            SrvCloseSearch( search );
        }

        search->InUse = FALSE;

        //
        // Remove our pointer's reference.
        //

        SrvDereferenceSearch( search );
    }

    //
    // Deallocate the directory information block.  We do not need
    // to close the directoryhandle here since we should have already
    // closed it (if we need to) in the preceding code.
    //

    if ( directoryInformation != NULL ) {
        DEALLOCATE_NONPAGED_POOL( directoryInformation );
    }

    if ( !isUnicode &&
        fileName.Buffer != NULL &&
        fileName.Buffer != nameBuffer &&
        fileName.Buffer != unicodeResumeName ) {

        RtlFreeUnicodeString( &fileName );
    }

    if( status == STATUS_PATH_NOT_COVERED ) {
        SrvSetSmbError( WorkContext, status );

    } else {
        SrvSetSmbError(
            WorkContext,
            isCoreSearch && (status != STATUS_OBJECT_PATH_NOT_FOUND) ?
                STATUS_NO_MORE_FILES : status
        );
    }

    SmbStatus = SmbStatusSendResponse;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbSearch
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\smbrdwrt.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbrdwrt.c

Abstract:

    This module contains routines for processing the following SMBs:

        Lock and Read
        Read
        Read and X
        Seek
        Write
        Write and Close
        Write and Unlock
        Write and X

    Note that raw mode and multiplexed mode SMB processors are not
    contained in this module.  Check smbraw.c and smbmpx.c instead.
    SMB commands that pertain exclusively to locking (LockByteRange,
    UnlockByteRange, and LockingAndX) are processed in smblock.c.

--*/

#include "precomp.h"
#include "smbrdwrt.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_SMBRDWRT

//
// External routine from smblock.c
//

VOID
TimeoutLockRequest (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

//
// Forward declarations
//

STATIC
VOID SRVFASTCALL
RestartLockAndRead (
    IN OUT PWORK_CONTEXT WorkContext
    );

STATIC
VOID SRVFASTCALL
RestartPipeReadAndXPeek (
    IN OUT PWORK_CONTEXT WorkContext
    );

STATIC
BOOLEAN
SetNewPosition (
    IN PRFCB Rfcb,
    IN OUT PULONG Offset,
    IN BOOLEAN RelativeSeek
    );

STATIC
VOID SRVFASTCALL
SetNewSize (
    IN OUT PWORK_CONTEXT WorkContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvSmbLockAndRead )
#pragma alloc_text( PAGE, SrvSmbReadAndX )
#pragma alloc_text( PAGE, SrvSmbSeek )
#pragma alloc_text( PAGE, SrvSmbWrite )
#pragma alloc_text( PAGE, SrvSmbWriteAndX )
#pragma alloc_text( PAGE, SrvRestartChainedClose )
#pragma alloc_text( PAGE, RestartLockAndRead )
#pragma alloc_text( PAGE, RestartPipeReadAndXPeek )
#pragma alloc_text( PAGE, SrvRestartWriteAndUnlock )
#pragma alloc_text( PAGE, SrvRestartWriteAndXRaw )
#pragma alloc_text( PAGE, SetNewSize )
#pragma alloc_text( PAGE, SrvBuildAndSendErrorResponse )
#pragma alloc_text( PAGE8FIL, SetNewPosition )

#endif


SMB_PROCESSOR_RETURN_TYPE
SrvSmbLockAndRead (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes Lock And Read SMB.  The Lock part of this SMB is started
    here as an asynchronous request.  When the request completes, the
    routine RestartLockAndRead is called.  If the lock was obtained,
    that routine calls SrvSmbRead, the SMB processor for the core Read
    SMB, to process the Read part of the Lock And Read SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_READ request;

    USHORT fid;
    LARGE_INTEGER length;
    LARGE_INTEGER offset;
    ULONG key;
    BOOLEAN failImmediately;

    PRFCB rfcb;
    PLFCB lfcb;
    PSRV_TIMER timer;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;

    PAGED_CODE( );

    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_LOCK_AND_READ;
    SrvWmiStartContext(WorkContext);

    request = (PREQ_READ)WorkContext->RequestParameters;

    //
    // Verify the FID.  If verified, the RFCB is referenced and its
    // addresses is stored in the WorkContext block, and the RFCB
    // address is returned.
    //

    fid = SmbGetUshort( &request->Fid );

    rfcb = SrvVerifyFid(
                WorkContext,
                fid,
                TRUE,
                SrvRestartSmbReceived,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status )) {

            //
            // Invalid file ID or write behind error.  Reject the request.
            //

            IF_DEBUG(ERRORS) {
                KdPrint((
                    "SrvSmbLockAndRead: Status %X on FID: 0x%lx\n",
                    status,
                    fid
                    ));
            }

            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    if( rfcb->Lfcb->Session->IsSessionExpired )
    {
        status = SESSION_EXPIRED_STATUS_CODE;
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Verify that the client has lock access to the file via the
    // specified handle.
    //

    if ( rfcb->LockAccessGranted && rfcb->ExclusiveLockGranted ) {

        //
        // Get the offset and length of the range being locked.  Combine the
        // FID with the caller's PID to form the local lock key.
        //
        // *** The FID must be included in the key in order to account for
        //     the folding of multiple remote compatibility mode opens into
        //     a single local open.
        //

        offset.QuadPart = SmbGetUlong( &request->Offset );
        length.QuadPart = SmbGetUshort( &request->Count );

        key = rfcb->ShiftedFid |
                SmbGetAlignedUshort( &WorkContext->RequestHeader->Pid );

        IF_SMB_DEBUG(READ_WRITE1) {
            KdPrint(( "Lock and Read request; FID 0x%lx, count %ld, offset %ld\n",
                        fid, length.LowPart, offset.LowPart ));
        }

        lfcb = rfcb->Lfcb;
        IF_SMB_DEBUG(READ_WRITE2) {
            KdPrint(( "SrvSmbLockAndRead: Locking in file 0x%p: (%ld,%ld), key 0x%lx\n",
                        lfcb->FileObject, offset.LowPart, length.LowPart, key ));
        }

        //
        // If the session has expired, return that info
        //
        if( lfcb->Session->IsSessionExpired )
        {
            SrvSetSmbError( WorkContext, SESSION_EXPIRED_STATUS_CODE );
            status =  SESSION_EXPIRED_STATUS_CODE;
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        //
        // Try the turbo lock path first.  If the client is retrying the
        // lock that just failed, we want FailImmediately to be FALSE, so
        // that the fast path fails if there's a conflict.
        //

        failImmediately = (BOOLEAN)(
            (offset.QuadPart != rfcb->PagedRfcb->LastFailingLockOffset.QuadPart)
            &&
            (offset.QuadPart < SrvLockViolationOffset) );

        if ( lfcb->FastIoLock != NULL ) {

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastLocksAttempted );

            if ( lfcb->FastIoLock(
                    lfcb->FileObject,
                    &offset,
                    &length,
                    IoGetCurrentProcess(),
                    key,
                    failImmediately,
                    TRUE,
                    &WorkContext->Irp->IoStatus,
                    lfcb->DeviceObject
                    ) ) {

                //
                // If the turbo path got the lock, start the read.
                // Otherwise, return an error.
                //

                if ( NT_SUCCESS( WorkContext->Irp->IoStatus.Status ) ) {
                    InterlockedIncrement( &rfcb->NumberOfLocks );
                    SmbStatus = SrvSmbRead( WorkContext );
                    goto Cleanup;
                }
                WorkContext->Parameters.Lock.Timer = NULL;
                RestartLockAndRead( WorkContext );
                return SmbStatusInProgress;
            }

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastLocksFailed );
        }

        //
        // The turbo path failed (or didn't exist).  Start the lock request,
        // reusing the receive IRP.  If the client is retrying the lock that
        // just failed, start a timer for the request.
        //

        timer = NULL;
        if ( !failImmediately ) {
            timer = SrvAllocateTimer( );
            if ( timer == NULL ) {
                failImmediately = TRUE;
            }
        }

        SrvBuildLockRequest(
            WorkContext->Irp,                   // input IRP address
            lfcb->FileObject,                   // target file object address
            WorkContext,                        // context
            offset,                             // byte offset
            length,                             // range length
            key,                                // lock key
            failImmediately,
            TRUE                                // exclusive lock?
            );

        WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
        WorkContext->bAlreadyTrace = FALSE;
        WorkContext->FspRestartRoutine = RestartLockAndRead;

        //
        // Start the timer, if necessary.
        //

        WorkContext->Parameters.Lock.Timer = timer;

        if ( timer != NULL ) {
            SrvSetTimer(
                timer,
                &SrvLockViolationDelayRelative,
                TimeoutLockRequest,
                WorkContext
                );
        }

        //
        // Pass the request to the file system.
        //

        (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

        //
        // The lock request has been started.  Return the InProgress status
        // to the caller, indicating that the caller should do nothing
        // further with the SMB/WorkContext at the present time.
        //

        IF_DEBUG(TRACE2) KdPrint(( "SrvSmbLockAndRead complete\n" ));
        SmbStatus = SmbStatusInProgress;

    } else {

        SrvStatistics.GrantedAccessErrors++;

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbLockAndRead: Lock access not granted.\n"));
        }

        SrvSetSmbError( WorkContext, STATUS_ACCESS_DENIED );
        status    = STATUS_ACCESS_DENIED;
        SmbStatus = SmbStatusSendResponse;
    }

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;
} // SrvSmbLockAndRead


SMB_PROCESSOR_RETURN_TYPE
SrvSmbRead (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes the Read SMB.  This is the "core" read.  Also processes
    the Read part of the Lock and Read SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_READ request;
    PRESP_READ response;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    USHORT fid;
    PRFCB rfcb;
    PLFCB lfcb;
    PCHAR readAddress;
    CLONG readLength;
    LARGE_INTEGER offset;
    ULONG key;
    SHARE_TYPE shareType;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_READ;
    SrvWmiStartContext(WorkContext);

    request = (PREQ_READ)WorkContext->RequestParameters;
    response = (PRESP_READ)WorkContext->ResponseParameters;

    fid = SmbGetUshort( &request->Fid );

    IF_SMB_DEBUG(READ_WRITE1) {
        KdPrint(( "Read request; FID 0x%lx, count %ld, offset %ld\n",
            fid, SmbGetUshort( &request->Count ),
            SmbGetUlong( &request->Offset ) ));
    }

    //
    // First, verify the FID.  If verified, the RFCB is referenced and
    // its address is stored in the WorkContext block, and the RFCB
    // address is returned.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                fid,
                TRUE,
                SrvRestartSmbReceived,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS(status) ) {

            //
            // Invalid file ID or write behind error.  Reject the
            // request.
            //

            IF_DEBUG(ERRORS) {
                KdPrint((
                    "SrvSmbRead: Status %X on FID: 0x%lx\n",
                    status,
                    fid
                    ));
            }

            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }


    lfcb = rfcb->Lfcb;
    shareType = rfcb->ShareType;

    //
    // If the session has expired, return that info
    //
    if( lfcb->Session->IsSessionExpired )
    {
        SrvSetSmbError( WorkContext, SESSION_EXPIRED_STATUS_CODE );
        status =  SESSION_EXPIRED_STATUS_CODE;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Verify that the client has read access to the file via the
    // specified handle.
    //

    if ( !rfcb->ReadAccessGranted ) {

        CHECK_PAGING_IO_ACCESS(
                        WorkContext,
                        rfcb->GrantedAccess,
                        &status );
        if ( !NT_SUCCESS( status ) ) {
            SrvStatistics.GrantedAccessErrors++;
            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvSmbRead: Read access not granted.\n"));
            }
            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }
    }

    //
    // If this operation may block, and we are running short of free
    // work items, fail this SMB with an out of resources error.
    //

    if ( rfcb->BlockingModePipe ) {
        if ( SrvReceiveBufferShortage( ) ) {

            //
            // Fail the operation.
            //

            SrvStatistics.BlockingSmbsRejected++;

            SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
            status    = STATUS_INSUFF_SERVER_RESOURCES;
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        } else {

            //
            // It is okay to start a blocking operation.
            // SrvReceiveBufferShortage() has already incremented
            // SrvBlockingOpsInProgress.
            //

            WorkContext->BlockingOperation = TRUE;
        }
    }

    //
    // Form the lock key using the FID and the PID.  (This is also
    // irrelevant for pipes.)
    //
    // *** The FID must be included in the key in order to account for
    //     the folding of multiple remote compatibility mode opens into
    //     a single local open.
    //

    key = rfcb->ShiftedFid |
            SmbGetAlignedUshort( &WorkContext->RequestHeader->Pid );

    //
    // See if the direct host IPX smart card can handle this read.  If so,
    //  return immediately, and the card will call our restart routine at
    //  SrvIpxSmartCardReadComplete
    //
    if( rfcb->PagedRfcb->IpxSmartCardContext ) {
        IF_DEBUG( SIPX ) {
            KdPrint(( "SrvSmbRead: calling SmartCard Read for context %p\n",
                        WorkContext ));
        }

        //
        // Set the fields needed by SrvIpxSmartCardReadComplete in case the smart
        //  card is going to handle this request
        //
        WorkContext->Parameters.SmartCardRead.MdlReadComplete = lfcb->MdlReadComplete;
        WorkContext->Parameters.SmartCardRead.DeviceObject = lfcb->DeviceObject;

        if( SrvIpxSmartCard.Read( WorkContext->RequestBuffer->Buffer,
                                  rfcb->PagedRfcb->IpxSmartCardContext,
                                  key,
                                  WorkContext ) == TRUE ) {

            IF_DEBUG( SIPX ) {
                KdPrint(( "  SrvSmbRead:  SmartCard Read returns TRUE\n" ));
            }

            SmbStatus = SmbStatusInProgress;
            goto Cleanup;
        }

        IF_DEBUG( SIPX ) {
            KdPrint(( "  SrvSmbRead:  SmartCard Read returns FALSE\n" ));
        }
    }

    //
    // Determine the maximum amount of data we can read.  This is the
    // minimum of the amount requested by the client and the amount of
    // room left in the response buffer.  (Note that even though we may
    // use an MDL read, the read length is still limited to the size of
    // an SMB buffer.)
    //

    readAddress = (PCHAR)response->Buffer;

    readLength = MIN(
                    (CLONG)SmbGetUshort( &request->Count ),
                    WorkContext->ResponseBuffer->BufferLength -
                        PTR_DIFF(readAddress, WorkContext->ResponseHeader)
                    );

    //
    // Get the file offset.  (This is irrelevant for pipes.)
    //

    offset.QuadPart = SmbGetUlong( &request->Offset );

    //
    // Try the fast I/O path first.  If that fails, fall through to the
    // normal build-an-IRP path.
    //

    if ( lfcb->FastIoRead != NULL ) {

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsAttempted );

        try {
            if ( lfcb->FastIoRead(
                    lfcb->FileObject,
                    &offset,
                    readLength,
                    TRUE,
                    key,
                    readAddress,
                    &WorkContext->Irp->IoStatus,
                    lfcb->DeviceObject
                    ) ) {

                //
                // The fast I/O path worked.  Call the restart routine directly
                // to do postprocessing (including sending the response).
                //

                WorkContext->bAlreadyTrace = TRUE;
                SrvFsdRestartRead( WorkContext );
                IF_SMB_DEBUG(READ_WRITE2) KdPrint(( "SrvSmbRead complete.\n" ));
                SmbStatus = SmbStatusInProgress;
                goto Cleanup;
            }
        }
        except( EXCEPTION_EXECUTE_HANDLER ) {
            // Fall through to the slow path on an exception
            status = GetExceptionCode();
            IF_DEBUG(ERRORS) {
                KdPrint(("FastIoRead threw exception %x\n", status ));
            }
        }

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsFailed );

    }

    //
    // The turbo path failed.  Build the read request, reusing the
    // receive IRP.
    //

    if ( rfcb->ShareType != ShareTypePipe ) {

        //
        // Note that we never do MDL reads here.  The reasoning behind
        // this is that because the read is going into an SMB buffer, it
        // can't be all that large (by default, no more than 4K bytes),
        // so the difference in cost between copy and MDL is minimal; in
        // fact, copy read is probably faster than MDL read.
        //
        // Build an MDL describing the read buffer.  Note that if the
        // file system can complete the read immediately, the MDL isn't
        // really needed, but if the file system must send the request
        // to its FSP, the MDL _is_ needed.
        //
        // *** Note the assumption that the response buffer already has
        //     a valid full MDL from which a partial MDL can be built.
        //

        IoBuildPartialMdl(
            WorkContext->ResponseBuffer->Mdl,
            WorkContext->ResponseBuffer->PartialMdl,
            readAddress,
            readLength
            );

        //
        // Build the IRP.
        //

        SrvBuildReadOrWriteRequest(
                WorkContext->Irp,           // input IRP address
                lfcb->FileObject,           // target file object address
                WorkContext,                // context
                IRP_MJ_READ,                // major function code
                0,                          // minor function code
                readAddress,                // buffer address
                readLength,                 // buffer length
                WorkContext->ResponseBuffer->PartialMdl, // MDL address
                offset,                     // byte offset
                key                         // lock key
                );

        IF_SMB_DEBUG(READ_WRITE2) {
            KdPrint(( "SrvSmbRead: copy read from file 0x%p, offset %ld, length %ld, destination 0x%p\n",
                        lfcb->FileObject, offset.LowPart, readLength,
                        readAddress ));
        }

    } else {               // if ( rfcb->ShareType != ShareTypePipe )

        //
        // Build the PIPE_INTERNAL_READ IRP.
        //

        SrvBuildIoControlRequest(
            WorkContext->Irp,
            lfcb->FileObject,
            WorkContext,
            IRP_MJ_FILE_SYSTEM_CONTROL,
            FSCTL_PIPE_INTERNAL_READ,
            readAddress,
            0,
            NULL,
            readLength,
            NULL,
            NULL
            );

        IF_SMB_DEBUG(READ_WRITE2) {
            KdPrint(( "SrvSmbRead: reading from file 0x%p, length %ld, destination 0x%p\n",
                        lfcb->FileObject, readLength, readAddress ));
        }

    }

    //
    // Load the restart routine address and pass the request to the file
    // system.
    //

    WorkContext->bAlreadyTrace = TRUE;
    WorkContext->FsdRestartRoutine = SrvFsdRestartRead;
    DEBUG WorkContext->FspRestartRoutine = NULL;

#if SRVCATCH
    if( rfcb->SrvCatch > 0 ) {
        WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
        WorkContext->bAlreadyTrace = FALSE;
        WorkContext->FspRestartRoutine = SrvFsdRestartRead;
    }
#endif

    (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

    //
    // The read has been started.  Control will return to the restart
    // routine when the read completes.
    //
    SmbStatus = SmbStatusInProgress;
    IF_SMB_DEBUG(READ_WRITE2) KdPrint(( "SrvSmbRead complete.\n" ));

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbRead


SMB_PROCESSOR_RETURN_TYPE
SrvSmbReadAndX (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes the Read And X SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_READ_ANDX request;
    PREQ_NT_READ_ANDX ntRequest;
    PRESP_READ_ANDX response;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    USHORT fid;
    PRFCB rfcb;
    PLFCB lfcb;
    CLONG bufferOffset;
    PCHAR readAddress;
    CLONG readLength;
    LARGE_INTEGER offset;
    ULONG key;
    SHARE_TYPE shareType;
    BOOLEAN largeRead;
    PMDL mdl = NULL;
    UCHAR minorFunction;
    PBYTE readBuffer;
    USHORT flags2;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_READ_AND_X;
    SrvWmiStartContext(WorkContext);

    request = (PREQ_READ_ANDX)WorkContext->RequestParameters;
    ntRequest = (PREQ_NT_READ_ANDX)WorkContext->RequestParameters;
    response = (PRESP_READ_ANDX)WorkContext->ResponseParameters;

    fid = SmbGetUshort( &request->Fid );

    IF_SMB_DEBUG(READ_WRITE1) {
        KdPrint(( "ReadAndX request; FID 0x%lx, count %ld, offset %ld\n",
            fid, SmbGetUshort( &request->MaxCount ),
            SmbGetUlong( &request->Offset ) ));
    }

    //
    // First, verify the FID.  If verified, the RFCB is referenced and
    // its address is stored in the WorkContext block, and the RFCB
    // address is returned.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                fid,
                TRUE,
                SrvRestartSmbReceived,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS(status) ) {

            //
            // Invalid file ID or write behind error.  Reject the
            // request.
            //

            IF_DEBUG(ERRORS) {
                KdPrint((
                    "SrvSmbReadAndX Status %X on FID: 0x%lx\n",
                    status,
                    fid
                    ));
            }

            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    lfcb = rfcb->Lfcb;
    shareType = rfcb->ShareType;

    //
    // If the session has expired, return that info
    //
    if( lfcb->Session->IsSessionExpired )
    {
        SrvSetSmbError( WorkContext, SESSION_EXPIRED_STATUS_CODE );
        status =  SESSION_EXPIRED_STATUS_CODE;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Verify that the client has read access to the file via the
    // specified handle.
    //

    if ( !rfcb->ReadAccessGranted ) {

        CHECK_PAGING_IO_ACCESS(
                        WorkContext,
                        rfcb->GrantedAccess,
                        &status );
        if ( !NT_SUCCESS( status ) ) {
            SrvStatistics.GrantedAccessErrors++;
            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvSmbReadAndX: Read access not granted.\n"));
            }
            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }
    }

    readLength = (CLONG)SmbGetUshort( &request->MaxCount );

    //
    // NT requests allow the specification of up to 32 bits worth of read length.
    //   This field is overlaid with the Timeout field for pipe reads.  Some redirs
    //   set this field to 0xFFFFFFFF, even if a pipe isn't involved.  So, we need to
    //   filter out those fellows.
    //
    if( request->WordCount == 12 &&
        shareType != ShareTypePipe
        && SmbGetUshort( &ntRequest->MaxCountHigh ) != 0xFFFF ) {

        readLength |= ((CLONG)SmbGetUshort( &ntRequest->MaxCountHigh )) << 16;
    }

    //
    // The returned data must be longword aligned.  (Note the assumption
    // that the SMB itself is longword aligned.)
    //
    // NOTE: Don't change this for 64-bit, as it will Break Win2K interop

    bufferOffset = PTR_DIFF(response->Buffer, WorkContext->ResponseHeader);

    WorkContext->Parameters.ReadAndX.PadCount = (USHORT)(3 - (bufferOffset & 3));

    // This was changed to be Pointer-size aligned so this works in 64-bit
    bufferOffset = (bufferOffset + 3) & ~3;

    //
    // If we are not reading from a disk file, or we're connectionless,
    //   or there's an ANDX command,
    //   don't let the client exceed the negotiated buffer size.
    //
    if( shareType != ShareTypeDisk ||
        request->AndXCommand != SMB_COM_NO_ANDX_COMMAND ||
        WorkContext->Endpoint->IsConnectionless ) {

        readLength = MIN( readLength,
                    WorkContext->ResponseBuffer->BufferLength - bufferOffset
                    );
    } else {
        //
        // We're letting large reads through!  Make sure it isn't
        //  too large
        //
        readLength = MIN( readLength, SrvMaxReadSize );
    }

    largeRead = ( readLength > WorkContext->ResponseBuffer->BufferLength - bufferOffset );

    readAddress = (PCHAR)WorkContext->ResponseHeader + bufferOffset;

    WorkContext->Parameters.ReadAndX.ReadAddress = readAddress;
    WorkContext->Parameters.ReadAndX.ReadLength = readLength;

    //
    // Get the file offset.  (This is irrelevant for pipes.)
    //

    if ( shareType != ShareTypePipe ) {

        if ( request->WordCount == 10 ) {

            //
            // The client supplied a 32-bit offset.
            //

            offset.QuadPart = SmbGetUlong( &request->Offset );

        } else if ( request->WordCount == 12 ) {

            //
            // The client supplied a 64-bit offset.
            //

            offset.LowPart = SmbGetUlong( &ntRequest->Offset );
            offset.HighPart = SmbGetUlong( &ntRequest->OffsetHigh );

            //
            // Reject negative offsets
            //

            if ( offset.QuadPart < 0 ) {

                SrvLogInvalidSmb( WorkContext );
                IF_DEBUG(ERRORS) {
                    KdPrint(( "SrvSmbReadAndX: Negative offset rejected.\n"));
                }
                SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
                status    = STATUS_INVALID_SMB;
                SmbStatus = SmbStatusSendResponse;
                goto Cleanup;
            }

        } else {

            //
            // This is an invalid word count for Read and X.
            //

            SrvLogInvalidSmb( WorkContext );
            SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
            status = STATUS_INVALID_SMB;
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        WorkContext->Parameters.ReadAndX.ReadOffset = offset;

    } else {

        if ( (request->WordCount != 10) && (request->WordCount != 12) ) {

            //
            // This is an invalid word count for Read and X.
            //

            SrvLogInvalidSmb( WorkContext );
            SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
            status    = STATUS_INVALID_SMB;
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }
    }

    //
    // Form the lock key using the FID and the PID.  (This is also
    // irrelevant for pipes.)
    //
    // *** The FID must be included in the key in order to account for
    //     the folding of multiple remote compatibility mode opens into
    //     a single local open.
    //

    key = rfcb->ShiftedFid |
            SmbGetAlignedUshort( &WorkContext->RequestHeader->Pid );

    //
    // Save the AndX command code.  This is necessary because the read
    // data may overwrite the AndX command.  This command must be Close.
    // We don't need to save the offset because we're not going to look
    // at the AndX command request after starting the read.
    //

    WorkContext->NextCommand = request->AndXCommand;

    if ( request->AndXCommand == SMB_COM_CLOSE ) {

        //
        // Make sure the accompanying CLOSE fits within the received SMB buffer
        //
        if( (PCHAR)WorkContext->RequestHeader + request->AndXOffset + FIELD_OFFSET(REQ_CLOSE,Buffer) >
            END_OF_REQUEST_SMB( WorkContext ) ) {

            SrvLogInvalidSmb( WorkContext );
            SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
            status    = STATUS_INVALID_SMB;
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        WorkContext->Parameters.ReadAndX.LastWriteTimeInSeconds =
            ((PREQ_CLOSE)((PUCHAR)WorkContext->RequestHeader +
                            request->AndXOffset))->LastWriteTimeInSeconds;
    }

    //
    // Try the fast I/O path first.  If that fails, fall through to the
    // normal build-an-IRP path.
    //

    if( !largeRead ) {
small_read:

        if ( lfcb->FastIoRead != NULL ) {

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsAttempted );

            try {
                if ( lfcb->FastIoRead(
                        lfcb->FileObject,
                        &offset,
                        readLength,
                        TRUE,
                        key,
                        readAddress,
                        &WorkContext->Irp->IoStatus,
                        lfcb->DeviceObject
                        ) ) {

                    //
                    // The fast I/O path worked.  Call the restart routine directly
                    // to do postprocessing (including sending the response).
                    //
                    WorkContext->bAlreadyTrace = TRUE;
                    SrvFsdRestartReadAndX( WorkContext );

                    IF_SMB_DEBUG(READ_WRITE2) KdPrint(( "SrvSmbReadAndX complete.\n" ));
                    SmbStatus = SmbStatusInProgress;
                    goto Cleanup;
                }
            }
            except( EXCEPTION_EXECUTE_HANDLER ) {
                // Fall through to the slow path on an exception
                status = GetExceptionCode();
                IF_DEBUG(ERRORS) {
                    KdPrint(("FastIoRead threw exception %x\n", status ));
                }
            }

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsFailed );

        }

        //
        // The turbo path failed.  Build the read request, reusing the
        // receive IRP.
        //

        if ( shareType == ShareTypePipe ) {

            //
            // Pipe read.  If this is a non-blocking read, ensure we won't
            // block; otherwise, proceed with the request.
            //

            if ( rfcb->BlockingModePipe &&
                            (SmbGetUshort( &request->MinCount ) == 0) ) {

                PFILE_PIPE_PEEK_BUFFER pipePeekBuffer;

                //
                // This is a non-blocking read.  Allocate a buffer to peek
                // the pipe, so that we can tell if a read operation will
                // block.  This buffer is freed in
                // RestartPipeReadAndXPeek().
                //

                pipePeekBuffer = ALLOCATE_NONPAGED_POOL(
                    FIELD_OFFSET( FILE_PIPE_PEEK_BUFFER, Data[0] ),
                    BlockTypeDataBuffer
                    );

                if ( pipePeekBuffer == NULL ) {

                    //
                    //  Return to client with out of memory status.
                    //

                    SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
                    status    = STATUS_INSUFF_SERVER_RESOURCES;
                    SmbStatus = SmbStatusSendResponse;
                    goto Cleanup;
                }

                //
                // Save the address of the peek buffer so that the restart
                // routine can find it.
                //

                WorkContext->Parameters.ReadAndX.PipePeekBuffer = pipePeekBuffer;

                //
                // Build the pipe peek request.  We just want the header
                // information.  We do not need any data.
                //

                WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
                WorkContext->FspRestartRoutine = RestartPipeReadAndXPeek;

                SrvBuildIoControlRequest(
                    WorkContext->Irp,
                    lfcb->FileObject,
                    WorkContext,
                    IRP_MJ_FILE_SYSTEM_CONTROL,
                    FSCTL_PIPE_PEEK,
                    pipePeekBuffer,
                    0,
                    NULL,
                    FIELD_OFFSET( FILE_PIPE_PEEK_BUFFER, Data[0] ),
                    NULL,
                    NULL
                    );

                //
                // Pass the request to NPFS.
                //

                (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

            } else {

                //
                // This operation may block.  If we are short of receive
                // work items, reject the request.
                //

                if ( SrvReceiveBufferShortage( ) ) {

                    //
                    // Fail the operation.
                    //

                    SrvStatistics.BlockingSmbsRejected++;

                    SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
                    status    = STATUS_INSUFF_SERVER_RESOURCES;
                    SmbStatus = SmbStatusSendResponse;
                    goto Cleanup;
                } else {

                    //
                    // It is okay to start a blocking operation.
                    // SrvReceiveBufferShortage() has already incremented
                    // SrvBlockingOpsInProgress.
                    //

                    WorkContext->BlockingOperation = TRUE;

                    //
                    // Proceed with a potentially blocking read.
                    //

                    WorkContext->Parameters.ReadAndX.PipePeekBuffer = NULL;
                    RestartPipeReadAndXPeek( WorkContext );

                }

            }

        } else {

            //
            // This is not a pipe read.
            //
            // Note that we never do MDL reads here.  The reasoning behind
            // this is that because the read is going into an SMB buffer, it
            // can't be all that large (by default, no more than 4K bytes),
            // so the difference in cost between copy and MDL is minimal; in
            // fact, copy read is probably faster than MDL read.
            //
            // Build an MDL describing the read buffer.  Note that if the
            // file system can complete the read immediately, the MDL isn't
            // really needed, but if the file system must send the request
            // to its FSP, the MDL _is_ needed.
            //
            // *** Note the assumption that the response buffer already has
            //     a valid full MDL from which a partial MDL can be built.
            //

            IoBuildPartialMdl(
                WorkContext->ResponseBuffer->Mdl,
                WorkContext->ResponseBuffer->PartialMdl,
                readAddress,
                readLength
                );

            //
            // Build the IRP.
            //

            SrvBuildReadOrWriteRequest(
                    WorkContext->Irp,           // input IRP address
                    lfcb->FileObject,           // target file object address
                    WorkContext,                // context
                    IRP_MJ_READ,                // major function code
                    0,                          // minor function code
                    readAddress,                // buffer address
                    readLength,                 // buffer length
                    WorkContext->ResponseBuffer->PartialMdl, // MDL address
                    offset,                     // byte offset
                    key                         // lock key
                    );

            IF_SMB_DEBUG(READ_WRITE2) {
                KdPrint(( "SrvSmbReadAndX: copy read from file 0x%p, offset %ld, length %ld, destination 0x%p\n",
                            lfcb->FileObject, offset.LowPart, readLength,
                            readAddress ));
            }

            //
            // Pass the request to the file system.  If the chained command
            // is Close, we need to arrange to restart in the FSP after the
            // read completes.
            //

            if ( WorkContext->NextCommand != SMB_COM_CLOSE ) {
                WorkContext->bAlreadyTrace = TRUE;
                WorkContext->FsdRestartRoutine = SrvFsdRestartReadAndX;
                DEBUG WorkContext->FspRestartRoutine = NULL;
            } else {
                WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
                WorkContext->bAlreadyTrace = FALSE;
                WorkContext->FspRestartRoutine = SrvFsdRestartReadAndX;
            }

#if SRVCATCH
            if( rfcb->SrvCatch > 0 ) {
                //
                // Ensure passive level on restart
                //
                WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
                WorkContext->bAlreadyTrace = FALSE;
                WorkContext->FspRestartRoutine = SrvFsdRestartReadAndX;
            }
#endif

            (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

            //
            // The read has been started.  Control will return to the restart
            // routine when the read completes.
            //

        }

        IF_SMB_DEBUG(READ_WRITE2) KdPrint(( "SrvSmbReadAndX complete.\n" ));
        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    //
    // The client is doing a read from a disk file which exceeds our SMB buffer.
    // We do our best to satisfy it.
    //
    //  If we are unable to get buffers, we resort to doing a short read which fits
    //  in our smb buffer.
    //

    WorkContext->Parameters.ReadAndX.MdlRead = FALSE;

    //
    // Does the target file system support the cache manager routines?
    //
    if( lfcb->FileObject->Flags & FO_CACHE_SUPPORTED ) {

        //
        // We can use an MDL read.  Try the fast I/O path first.
        //

        WorkContext->Irp->MdlAddress = NULL;
        WorkContext->Irp->IoStatus.Information = 0;

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsAttempted );

        if( lfcb->MdlRead &&
            lfcb->MdlRead(
                lfcb->FileObject,
                &offset,
                readLength,
                key,
                &WorkContext->Irp->MdlAddress,
                &WorkContext->Irp->IoStatus,
                lfcb->DeviceObject
            ) && WorkContext->Irp->MdlAddress != NULL ) {

            //
            // The fast I/O path worked.  Send the data.
            //
            WorkContext->Parameters.ReadAndX.MdlRead = TRUE;
            WorkContext->Parameters.ReadAndX.CacheMdl = WorkContext->Irp->MdlAddress;
            WorkContext->bAlreadyTrace = TRUE;
            SrvFsdRestartLargeReadAndX( WorkContext );
            SmbStatus = SmbStatusInProgress;
            goto Cleanup;
        }

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsFailed );

        if( WorkContext->Irp->MdlAddress ) {
            //
            // The fast I/O path failed.  We need to issue a regular MDL read
            // request.
            //
            // The fast path may have partially succeeded, returning a partial MDL
            // chain.  We need to adjust our read request to account for that.
            //
            offset.QuadPart += WorkContext->Irp->IoStatus.Information;
            readLength -= (ULONG)WorkContext->Irp->IoStatus.Information;
            mdl = WorkContext->Irp->MdlAddress;
            WorkContext->Parameters.ReadAndX.CacheMdl = mdl;
            readBuffer = NULL;
            minorFunction = IRP_MN_MDL;
            WorkContext->Parameters.ReadAndX.MdlRead = TRUE;
        }
    }

    if( WorkContext->Parameters.ReadAndX.MdlRead == FALSE ) {

        minorFunction = 0;

        //
        // We have to use a normal "copy" read.  We need to allocate a
        //  separate buffer to hold the data, and we'll use the SMB buffer
        //  itself to hold the MDL
        //
        readBuffer = ALLOCATE_HEAP( readLength, BlockTypeLargeReadX );

        if( readBuffer == NULL ) {

            IF_DEBUG( ERRORS ) {
                KdPrint(( "SrvSmbReadX: Unable to allocate large buffer\n" ));
            }
            //
            // Trim back the read length so it will fit in the smb buffer and
            //  return as much data as we can.
            //
            readLength = MIN( readLength,
                WorkContext->ResponseBuffer->BufferLength - bufferOffset
                );

            largeRead = FALSE;
            goto small_read;
        }

        WorkContext->Parameters.ReadAndX.Buffer = readBuffer;

        //
        // Use the SMB buffer as the MDL to describe the just allocated read buffer.
        //  Lock the buffer into memory
        //
        mdl = (PMDL)(((ULONG_PTR)readAddress + sizeof(PVOID) - 1) & ~(sizeof(PVOID)-1));
        MmInitializeMdl( mdl, readBuffer, readLength );

        try {
            MmProbeAndLockPages( mdl, KernelMode, IoWriteAccess );
        } except( EXCEPTION_EXECUTE_HANDLER ) {

            IF_DEBUG( ERRORS ) {
                KdPrint(( "SrvSmbReadX: MmProbeAndLockPages status %X\n", GetExceptionCode() ));
            }

            FREE_HEAP( readBuffer );
            WorkContext->Parameters.ReadAndX.Buffer = NULL;

            //
            // Trim back the read length so it will fit in the smb buffer and
            //  return as much data as we can.
            //
            readLength = MIN( readLength,
                WorkContext->ResponseBuffer->BufferLength - bufferOffset
                );

            largeRead = FALSE;
            goto small_read;
        }

        if (MmGetSystemAddressForMdlSafe( mdl,NormalPoolPriority ) == NULL) {
            // The mapping call has failed. fail the read operation with the
            // appropriate error.

            FREE_HEAP( readBuffer );
            WorkContext->Parameters.ReadAndX.Buffer = NULL;
            SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
            status    = STATUS_INSUFF_SERVER_RESOURCES;
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        if( lfcb->FastIoRead != NULL ) {
            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsAttempted );

            try {
                if ( lfcb->FastIoRead(
                        lfcb->FileObject,
                        &offset,
                        readLength,
                        TRUE,
                        key,
                        readBuffer,
                        &WorkContext->Irp->IoStatus,
                        lfcb->DeviceObject
                        ) ) {

                    //
                    // The fast I/O path worked.  Send the data.
                    //

                    WorkContext->bAlreadyTrace = TRUE;
                    SrvFsdRestartLargeReadAndX( WorkContext );
                    SmbStatus = SmbStatusInProgress;
                    goto Cleanup;
                }
            }
            except( EXCEPTION_EXECUTE_HANDLER ) {
                // Fall through to the slow path on an exception
                status = GetExceptionCode();
                IF_DEBUG(ERRORS) {
                    KdPrint(("FastIoRead threw exception %x\n", status ));
                }
            }

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsFailed );
        }
    }

    //
    // We didn't satisfy the request with the fast I/O path
    //
    SrvBuildReadOrWriteRequest(
           WorkContext->Irp,               // input IRP address
           lfcb->FileObject,               // target file object address
           WorkContext,                    // context
           IRP_MJ_READ,                    // major function code
           minorFunction,                  // minor function code
           readBuffer,                     // buffer address
           readLength,                     // buffer length
           mdl,                            // MDL address
           offset,                         // byte offset
           key                             // lock key
           );

    //
    // Pass the request to the file system.  We want to queue the
    //  response to the head because we've tied up a fair amount
    //  resources with this SMB.
    //
    WorkContext->QueueToHead = 1;
    WorkContext->bAlreadyTrace = TRUE;
    WorkContext->FsdRestartRoutine = SrvFsdRestartLargeReadAndX;
    (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

    //
    // The read has been started.  When it completes, processing
    //  continues at SrvFsdRestartLargeReadAndX
    //
    SmbStatus = SmbStatusInProgress;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbReadAndX


SMB_PROCESSOR_RETURN_TYPE
SrvSmbSeek (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes the Seek SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_SEEK request;
    PRESP_SEEK response;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    PRFCB rfcb;
    PLFCB lfcb;
    LONG offset;
    ULONG newPosition;
    IO_STATUS_BLOCK iosb;
    FILE_STANDARD_INFORMATION fileInformation;
    BOOLEAN lockHeld = FALSE;
    SMB_DIALECT smbDialect;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_SEEK;
    SrvWmiStartContext(WorkContext);

    request = (PREQ_SEEK)WorkContext->RequestParameters;
    response = (PRESP_SEEK)WorkContext->ResponseParameters;

    offset = (LONG)SmbGetUlong( &request->Offset );

    IF_SMB_DEBUG(READ_WRITE1) {
        KdPrint(( "Seek request; FID 0x%lx, mode %ld, offset %ld\n",
                    SmbGetUshort( &request->Fid ),
                    SmbGetUshort( &request->Mode ),
                    offset ));
    }

    //
    // Verify the FID.  If verified, the RFCB block is referenced
    // and its addresses is stored in the WorkContext block, and the
    // RFCB address is returned.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                SmbGetUshort( &request->Fid ),
                TRUE,
                SrvRestartSmbReceived,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS(status) ) {

            //
            // Invalid file ID or write behind error.  Reject the request.
            //

            IF_DEBUG(ERRORS) {
                KdPrint((
                    "SrvSmbSeek: Status %X on FID: 0x%lx\n",
                    status,
                    SmbGetUshort( &request->Fid )
                    ));
            }

            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    if( rfcb->Lfcb->Session->IsSessionExpired )
    {
        status = SESSION_EXPIRED_STATUS_CODE;
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // We maintain our own file pointer, because the I/O and file system
    // don't do it for us (at least not the way we need them to).  This
    // isn't all that bad, since the target file position is passed in
    // all read/write SMBs.  So we don't actually issue a system call to
    // set the file position here, although we do have to return the
    // position we would have set it to.
    //
    // The seek request is in one of three modes:
    //
    //      0 = seek relative to beginning of file
    //      1 = seek relative to current file position
    //      2 = seek relative to end of file
    //
    // For modes 0 and 1, we can easily calculate the final position.
    // For mode 2, however, we have to issue a system call to obtain the
    // current end of file and calculate the final position relative to
    // that.  Note that we can't just maintain our own end of file marker,
    // because another local process could change it out from under us.
    //
    // !!! Need to check for wraparound (either positive or negative).
    //

    switch ( SmbGetUshort( &request->Mode ) ) {
    case 0:

        //
        // Seek relative to beginning of file.  The new file position
        // is simply that specified in the request.  Note that this
        // may be beyond the actual end of the file.  This is OK.
        // Negative seeks must be handled specially.
        //

        newPosition = offset;
        if ( !SetNewPosition( rfcb, &newPosition, FALSE ) ) {
            goto negative_seek;
        }

        break;

    case 1:

        //
        // Seek relative to current position.  The new file position is
        // the current position plus the specified offset (which may be
        // negative).  Note that this may be beyond the actual end of
        // the file.  This is OK.  Negative seeks must be handled
        // specially.
        //

        newPosition = offset;
        if ( !SetNewPosition( rfcb, &newPosition, TRUE ) ) {
            goto negative_seek;
        }

        break;

    case 2:

        //
        // Seek relative to end of file.  The new file position
        // is the current end of file plus the specified offset.
        //

        IF_SMB_DEBUG(READ_WRITE2) {
            KdPrint(( "SrvSmbSeek: Querying end-of-file\n" ));
        }

        lfcb = rfcb->Lfcb;
        fastIoDispatch = lfcb->DeviceObject->DriverObject->FastIoDispatch;

        if ( fastIoDispatch &&
             fastIoDispatch->FastIoQueryStandardInfo &&
             fastIoDispatch->FastIoQueryStandardInfo(
                                        lfcb->FileObject,
                                        TRUE,
                                        &fileInformation,
                                        &iosb,
                                        lfcb->DeviceObject
                                        ) ) {

            status = iosb.Status;

        } else {

            status = NtQueryInformationFile(
                        lfcb->FileHandle,
                        &iosb,
                        &fileInformation,
                        sizeof(fileInformation),
                        FileStandardInformation
                        );
        }

        if ( !NT_SUCCESS(status) ) {

            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvSmbSeek: QueryInformationFile (file information) "
                    "returned %X",
                status,
                NULL
                );

            SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );

            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        if ( fileInformation.EndOfFile.HighPart != 0 ) {

            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvSmbSeek: EndOfFile is beyond where client can read",
                NULL,
                NULL
                );

            SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, STATUS_END_OF_FILE);
            SrvSetSmbError( WorkContext, STATUS_END_OF_FILE);
            status    = STATUS_END_OF_FILE;
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        newPosition = fileInformation.EndOfFile.LowPart + offset;
        if ( !SetNewPosition( rfcb, &newPosition, FALSE ) ) {
            goto negative_seek;
        }

        break;

    default:

        //
        // Invalid seek mode.  Reject the request.
        //

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbSeek: Invalid mode: 0x%lx\n",
                        SmbGetUshort( &request->Mode ) ));
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_PARAMETER );
        status    = STATUS_INVALID_PARAMETER;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    } // switch ( request->Mode )

    //
    // Return the new file position in the response SMB.
    //
    // *** Note the assumption that the high part of the 64-bit EOF
    //     marker is zero.  If it's not (i.e., the file is bigger than
    //     4GB), then we're out of luck, because the SMB protocol can't
    //     express that.
    //

    IF_SMB_DEBUG(READ_WRITE2) {
        KdPrint(( "SrvSmbSeek: New file position %ld\n", newPosition ));
    }

    response->WordCount = 2;
    SmbPutUlong( &response->Offset, newPosition );
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = NEXT_LOCATION( response, RESP_SEEK, 0 );

    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbSeek complete\n" ));
    SmbStatus = SmbStatusSendResponse;
    goto Cleanup;

negative_seek:

    //
    // The client specified an absolute or relative seek that pointed
    // before the beginning of the file.  For some clients, this is not
    // an error, and results in positioning at the BOF.  Non-NT LAN Man
    // clients can request a negative seek on a named-pipe and expect
    // the operation to succeed.
    //

    smbDialect = rfcb->Connection->SmbDialect;

    if( smbDialect >= SmbDialectLanMan20 ||
        ( !IS_NT_DIALECT( smbDialect ) && rfcb->ShareType == ShareTypePipe )) {

            //
            // Negative seeks allowed for these fellows!
            //  Seek to the beginning of the file
            //

            newPosition = 0;
            SetNewPosition( rfcb, &newPosition, FALSE );

            IF_SMB_DEBUG(READ_WRITE2) {
                KdPrint(( "SrvSmbSeek: New file position: 0\n" ));
            }

            response->WordCount = 2;
            SmbPutUlong( &response->Offset, 0 );
            SmbPutUshort( &response->ByteCount, 0 );

            WorkContext->ResponseParameters = NEXT_LOCATION( response, RESP_SEEK, 0 );

    } else {

        //
        // Negative seeks are not allowed!
        //

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbSeek: Negative seek\n" ));
        }

        SrvSetSmbError( WorkContext, STATUS_OS2_NEGATIVE_SEEK );
        status = STATUS_OS2_NEGATIVE_SEEK;
    }
    SmbStatus = SmbStatusSendResponse;
    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbSeek complete\n" ));

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbSeek


SMB_PROCESSOR_RETURN_TYPE
SrvSmbWrite (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes the Write, Write and Close, and Write and Unlock, and
    Write Print File SMBs.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_WRITE request;
    PRESP_WRITE response;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    USHORT fid;
    PRFCB rfcb;
    PLFCB lfcb;
    PCHAR writeAddress;
    CLONG writeLength;
    LARGE_INTEGER offset;
    ULONG key;
    SHARE_TYPE shareType;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_WRITE;
    SrvWmiStartContext(WorkContext);

    request = (PREQ_WRITE)WorkContext->RequestParameters;
    response = (PRESP_WRITE)WorkContext->ResponseParameters;

    fid = SmbGetUshort( &request->Fid );

    IF_SMB_DEBUG(READ_WRITE1) {
        KdPrint(( "Write%s request; FID 0x%lx, count %ld, offset %ld\n",
            WorkContext->NextCommand == SMB_COM_WRITE_AND_UNLOCK ?
                " and Unlock" :
                WorkContext->NextCommand == SMB_COM_WRITE_AND_CLOSE ?
                    " and Close" : "",
            fid, SmbGetUshort( &request->Count ),
            SmbGetUlong( &request->Offset ) ));
    }

    //
    // First, verify the FID.  If verified, the RFCB is referenced and
    // its address is stored in the WorkContext block, and the RFCB
    // address is returned.
    //
    // Call SrvVerifyFid, but do not fail (return NULL) if there is
    // a saved write behind error for this rfcb.  We need the rfcb
    // in case this is a write and close SMB, in order to process
    // the close.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                fid,
                FALSE,
                SrvRestartSmbReceived,  // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID.  Reject the request.
            //

            IF_DEBUG(SMB_ERRORS) {
                KdPrint(("SrvSmbWrite: Invalid FID: 0x%lx\n", fid ));
            }

            SrvSetSmbError( WorkContext, STATUS_INVALID_HANDLE );
            status    = STATUS_INVALID_HANDLE;
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    } else if ( !NT_SUCCESS( rfcb->SavedError ) ) {

        NTSTATUS savedErrorStatus;

        //
        // Check the saved error.
        //

        savedErrorStatus = SrvCheckForSavedError( WorkContext, rfcb );

        //
        // See if the saved error was still there.
        //

        if ( !NT_SUCCESS( savedErrorStatus ) ) {

            //
            // There was a write behind error.
            //

            //
            // Do not update the file timestamp.
            //

            WorkContext->Parameters.LastWriteTime = 0;

            //
            // If this is not a Write and Close, we can send the
            // response now.  If it is a Write and Close, we need to
            // close the file first.
            //

            if ( WorkContext->NextCommand != SMB_COM_WRITE_AND_CLOSE ) {

                //
                // Not Write and Close.  Just send the response.
                //
                status    = savedErrorStatus;
                SmbStatus = SmbStatusSendResponse;
                goto Cleanup;
            }

            //
            // This is a Write and Close.
            //

            SrvRestartChainedClose( WorkContext );
            SmbStatus = SmbStatusInProgress;
            goto Cleanup;
        }
    }

    lfcb = rfcb->Lfcb;

    //
    // If the session has expired, return that info
    //
    if( lfcb->Session->IsSessionExpired )
    {
        SrvSetSmbError( WorkContext, SESSION_EXPIRED_STATUS_CODE );
        status =  SESSION_EXPIRED_STATUS_CODE;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Verify that the client has write access to the file via the
    // specified handle.
    //

    if ( !rfcb->WriteAccessGranted && !rfcb->AppendAccessGranted ) {
        SrvStatistics.GrantedAccessErrors++;
        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbWrite: Write access not granted.\n"));
        }
        SrvSetSmbError( WorkContext, STATUS_ACCESS_DENIED );
        status    = STATUS_ACCESS_DENIED;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // If the write length is zero, truncate the file at the specified
    // offset.
    //

    if ( (SmbGetUshort( &request->Count ) == 0) && (rfcb->GrantedAccess & FILE_WRITE_DATA) ) {
        SetNewSize( WorkContext );
        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    rfcb->WrittenTo = TRUE;

    //
    // Get the file share type.
    //

    shareType = rfcb->ShareType;

    //
    // If this operation may block, and we are running short of free
    // work items, fail this SMB with an out of resources error.
    //

    if ( rfcb->BlockingModePipe ) {
        if ( SrvReceiveBufferShortage( ) ) {

            //
            // Fail the operation.
            //

            SrvStatistics.BlockingSmbsRejected++;

            SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
            status    = STATUS_INSUFF_SERVER_RESOURCES;
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        } else {

            //
            // It is okay to start a blocking operation.
            // SrvReceiveBufferShortage() has already incremented
            // SrvBlockingOpsInProgress.
            //

            WorkContext->BlockingOperation = TRUE;

        }
    }

    //
    // *** If the Remaining field of the request is ever used, make sure
    //     that this is not a write and close SMB, which does not
    //     include a valid Remaining field.
    //

    //
    // Determine the amount of data to write.  This is the minimum of
    // the amount requested by the client and the amount of data
    // actually sent in the request buffer.
    //
    // !!! Should it be an error for the client to send less data than
    //     it actually wants us to write?  The OS/2 server seems not to
    //     reject such requests.
    //

    if ( WorkContext->NextCommand != SMB_COM_WRITE_PRINT_FILE ) {

        if ( WorkContext->NextCommand != SMB_COM_WRITE_AND_CLOSE ) {

            writeAddress = (PCHAR)request->Buffer;

        } else {

            //
            // Look at the WordCount field -- it should be 6 or 12.
            // From this we can calculate the writeAddress.
            //

            if ( request->WordCount == 6 ) {

                writeAddress =
                    (PCHAR)((PREQ_WRITE_AND_CLOSE)request)->Buffer;

            } else if ( request->WordCount == 12 ) {

                writeAddress =
                    (PCHAR)((PREQ_WRITE_AND_CLOSE_LONG)request)->Buffer;

            } else {

                //
                // An illegal WordCount value was passed.  Return an error
                // to the client.
                //

                IF_DEBUG(SMB_ERRORS) {
                    KdPrint(( "SrvSmbWrite: Bad WordCount for "
                                "WriteAndClose: %ld, should be 6 or 12\n",
                                request->WordCount ));
                }

                SrvLogInvalidSmb( WorkContext );

                SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
                status    = STATUS_INVALID_SMB;
                SmbStatus = SmbStatusSendResponse;
                goto Cleanup;
            }
        }

        writeLength = MIN(
                        (CLONG)SmbGetUshort( &request->Count ),
                        WorkContext->ResponseBuffer->DataLength -
                            PTR_DIFF(writeAddress, WorkContext->RequestHeader)
                        );

        offset.QuadPart = SmbGetUlong( &request->Offset );

    } else {

        writeAddress = (PCHAR)( ((PREQ_WRITE_PRINT_FILE)request)->Buffer ) + 3;

        writeLength =
            MIN(
              (CLONG)SmbGetUshort(
                         &((PREQ_WRITE_PRINT_FILE)request)->ByteCount ) - 3,
              WorkContext->ResponseBuffer->DataLength -
                  PTR_DIFF(writeAddress, WorkContext->RequestHeader)
              );

        offset.QuadPart = rfcb->CurrentPosition;
    }

    //
    // Ensure that the client is writing beyond the original file size
    //
    if( !rfcb->WriteAccessGranted &&
        offset.QuadPart < rfcb->Mfcb->NonpagedMfcb->OpenFileSize.QuadPart ) {

        //
        // The client is only allowed to append to this file!
        //

        SrvSetSmbError( WorkContext, STATUS_ACCESS_DENIED );
        status    = STATUS_ACCESS_DENIED;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Form the lock key using the FID and the PID.
    //
    // *** The FID must be included in the key in order to account for
    //     the folding of multiple remote compatibility mode opens into
    //     a single local open.
    //

    key = rfcb->ShiftedFid |
            SmbGetAlignedUshort( &WorkContext->RequestHeader->Pid );

    //
    // Try the fast I/O path first.  If that fails, fall through to the
    // normal build-an-IRP path.
    //

    if ( lfcb->FastIoWrite != NULL ) {

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastWritesAttempted );

        try {
            if ( lfcb->FastIoWrite(
                    lfcb->FileObject,
                    &offset,
                    writeLength,
                    TRUE,
                    key,
                    writeAddress,
                    &WorkContext->Irp->IoStatus,
                    lfcb->DeviceObject
                    ) ) {

                //
                // The fast I/O path worked.  Call the restart routine directly
                // to do postprocessing (including sending the response).
                //
                WorkContext->bAlreadyTrace = TRUE;
                SrvFsdRestartWrite( WorkContext );

                IF_SMB_DEBUG(READ_WRITE2) KdPrint(( "SrvSmbWrite complete.\n" ));
                SmbStatus = SmbStatusInProgress;
                goto Cleanup;
            }
        }
        except( EXCEPTION_EXECUTE_HANDLER ) {
            // Fall through to the slow path on an exception
            status = GetExceptionCode();
            IF_DEBUG(ERRORS) {
                KdPrint(("FastIoRead threw exception %x\n", status ));
            }
        }

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastWritesFailed );

    }

    //
    // The turbo path failed.  Build the write request, reusing the
    // receive IRP.
    //

    if (shareType != ShareTypePipe) {

        //
        // Build an MDL describing the write buffer.  Note that if the
        // file system can complete the write immediately, the MDL isn't
        // really needed, but if the file system must send the request
        // to its FSP, the MDL _is_ needed.
        //
        // *** Note the assumption that the request buffer already has a
        //     valid full MDL from which a partial MDL can be built.
        //

        IoBuildPartialMdl(
            WorkContext->RequestBuffer->Mdl,
            WorkContext->RequestBuffer->PartialMdl,
            writeAddress,
            writeLength
            );

        //
        // Build the IRP.
        //

        SrvBuildReadOrWriteRequest(
                WorkContext->Irp,               // input IRP address
                lfcb->FileObject,               // target file object address
                WorkContext,                    // context
                IRP_MJ_WRITE,                   // major function code
                0,                              // minor function code
                writeAddress,                   // buffer address
                writeLength,                    // buffer length
                WorkContext->RequestBuffer->PartialMdl,   // MDL address
                offset,                         // byte offset
                key                             // lock key
                );

        IF_SMB_DEBUG(READ_WRITE2) {
            KdPrint(( "SrvSmbWrite: writing to file 0x%p, offset %ld, length %ld, source 0x%p\n",
                        lfcb->FileObject, offset.LowPart, writeLength,
                        writeAddress ));
        }

    } else {

        //
        // Build the PIPE_INTERNAL_WRITE IRP.
        //

        SrvBuildIoControlRequest(
            WorkContext->Irp,
            lfcb->FileObject,
            WorkContext,
            IRP_MJ_FILE_SYSTEM_CONTROL,
            FSCTL_PIPE_INTERNAL_WRITE,
            writeAddress,
            writeLength,
            NULL,
            0,
            NULL,
            NULL
            );

        IF_SMB_DEBUG(READ_WRITE2) {
            KdPrint(( "SrvSmbWrite: writing to file 0x%p length %ld, destination 0x%p\n",
                        lfcb->FileObject, writeLength,
                        writeAddress ));
        }

    }

    //
    // Pass the request to the file system.  If this is a write and
    // close, we have to restart in the FSP because the restart routine
    // will free the MFCB stored in paged pool.  Similarly, if this is a
    // write and unlock, we have to restart in the FSP to do the unlock.
    //

    if ( (WorkContext->RequestHeader->Command == SMB_COM_WRITE_AND_CLOSE) ||
         (WorkContext->RequestHeader->Command == SMB_COM_WRITE_AND_UNLOCK) ) {
        WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
        WorkContext->bAlreadyTrace = FALSE;
        WorkContext->FspRestartRoutine = SrvFsdRestartWrite;
    } else {
        WorkContext->bAlreadyTrace = TRUE;
        WorkContext->FsdRestartRoutine = SrvFsdRestartWrite;
        DEBUG WorkContext->FspRestartRoutine = NULL;
    }

    (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

    //
    // The write has been started.  Control will return to
    // SrvFsdRestartWrite when the write completes.
    //
    SmbStatus = SmbStatusInProgress;
    IF_SMB_DEBUG(READ_WRITE2) KdPrint(( "SrvSmbWrite complete.\n" ));

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbWrite


SMB_PROCESSOR_RETURN_TYPE
SrvSmbWriteAndX (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes the Write And X SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PSMB_HEADER header;
    PREQ_WRITE_ANDX request;
    PREQ_NT_WRITE_ANDX ntRequest;
    PRESP_WRITE_ANDX response;

    PCONNECTION connection;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    USHORT fid;
    PRFCB rfcb;
    PLFCB lfcb;
    CLONG bufferOffset;
    PCHAR writeAddress;
    CLONG writeLength;
    LARGE_INTEGER offset;
    ULONG key;
    SHARE_TYPE shareType;
    BOOLEAN writeThrough;

    ULONG remainingBytes;
    ULONG totalLength;

    SMB_DIALECT smbDialect;

    PTRANSACTION transaction;
    PCHAR trailingBytes;
    USHORT flags2;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_WRITE_AND_X;
    //SrvReferenceWorkItem(WorkContext);
    SrvWmiStartContext(WorkContext);

    header = (PSMB_HEADER)WorkContext->RequestHeader;
    request = (PREQ_WRITE_ANDX)WorkContext->RequestParameters;
    ntRequest = (PREQ_NT_WRITE_ANDX)WorkContext->RequestParameters;
    response = (PRESP_WRITE_ANDX)WorkContext->ResponseParameters;

    //
    // Initialize the transaction pointer.
    //

    WorkContext->Parameters.Transaction = NULL;

    //
    // If this WriteAndX is actually a psuedo WriteBlockMultiplex, all
    // of the WriteAndX pieces must be assembled before submitting the
    // request to NPFS.  (This exists to support large message mode
    // writes to clients that can't do WriteBlockMultiplex.)
    //
    // This must be handled in the FSP.
    //

    fid = SmbGetUshort( &request->Fid );

    IF_SMB_DEBUG(READ_WRITE1) {
        KdPrint(( "WriteAndX request; FID 0x%lx, count %ld, offset %ld\n",
            fid, SmbGetUshort( &request->DataLength ),
            SmbGetUlong( &request->Offset ) ));
    }

    rfcb = SrvVerifyFid(
                WorkContext,
                fid,
                TRUE,
                SrvRestartSmbReceived,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID or write behind error.  Reject the request.
            //

            IF_DEBUG(ERRORS) {
                KdPrint((
                    "SrvSmbWriteAndX: status %X on FID: 0x%lx\n",
                    status,
                    fid
                    ));
            }

            SrvSetSmbError( WorkContext, status );
            SmbStatus = SrvConsumeSmbData( WorkContext );
            goto Cleanup;
        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    //
    // Get the LFCB and the file share type.
    //

    lfcb = rfcb->Lfcb;
    shareType = rfcb->ShareType;

    //
    // If the session has expired, return that info
    //
    if( lfcb->Session->IsSessionExpired )
    {
        SrvSetSmbError( WorkContext, SESSION_EXPIRED_STATUS_CODE );
        status =  SESSION_EXPIRED_STATUS_CODE;
        SmbStatus = SrvConsumeSmbData( WorkContext );
        goto Cleanup;
    }

    if( WorkContext->LargeIndication && shareType != ShareTypeDisk ) {

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status = STATUS_INVALID_SMB;

        //
        // We need to consume the rest of this SMB!
        //
        SmbStatus = SrvConsumeSmbData( WorkContext );
        goto Cleanup;
    }

    //
    // Verify that the client has write access to the file via the
    // specified handle.
    //
    if ( !rfcb->WriteAccessGranted && !rfcb->AppendAccessGranted ) {
        SrvStatistics.GrantedAccessErrors++;
        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbWriteAndX: Write access not granted.\n"));
        }
        SrvSetSmbError( WorkContext, STATUS_ACCESS_DENIED );
        status    = STATUS_ACCESS_DENIED;
        SmbStatus = SrvConsumeSmbData( WorkContext );
        goto Cleanup;
    }

    rfcb->WrittenTo = TRUE;
    flags2 = SmbGetAlignedUshort( &WorkContext->RequestHeader->Flags2 );

    //
    // Ensure the correct write through mode
    //

    if ( shareType == ShareTypeDisk ) {

        writeThrough = (BOOLEAN)((SmbGetUshort( &request->WriteMode ) &
                                            SMB_WMODE_WRITE_THROUGH) != 0);

        if ( writeThrough && (lfcb->FileMode & FILE_WRITE_THROUGH) == 0
            || !writeThrough && (lfcb->FileMode & FILE_WRITE_THROUGH) != 0 ) {

            SrvSetFileWritethroughMode( lfcb, writeThrough );

        }

        RtlZeroMemory( &WorkContext->Parameters.WriteAndX,
                        sizeof( WorkContext->Parameters.WriteAndX) );

    } else if ( rfcb->BlockingModePipe ) {
        //
        // If this operation may block, and we are running short of free
        // work items, fail this SMB with an out of resources error.
        //

        if ( SrvReceiveBufferShortage( ) ) {

            //
            // Fail the operation.
            //

            SrvStatistics.BlockingSmbsRejected++;

            SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
            status    = STATUS_INSUFF_SERVER_RESOURCES;
            SmbStatus = SrvConsumeSmbData( WorkContext );
            goto Cleanup;

        } else {

            //
            // SrvBlockingOpsInProgress has already been incremented.
            // Flag this work item as a blocking operation.
            //

            WorkContext->BlockingOperation = TRUE;
        }
    }

    //
    // Determine the amount of data to write.  This is the minimum of
    // the amount requested by the client and the amount of data
    // actually sent in the request buffer.
    //
    // !!! Should it be an error for the client to send less data than
    //     it actually wants us to write?  The OS/2 server seems not to
    //     reject such requests.
    //

    bufferOffset = SmbGetUshort( &request->DataOffset );

    writeAddress = (PCHAR)WorkContext->ResponseHeader + bufferOffset;

    writeLength = MIN(
                    (CLONG)SmbGetUshort( &request->DataLength ),
                    WorkContext->ResponseBuffer->DataLength - bufferOffset
                    );

    remainingBytes = SmbGetUshort( &request->Remaining );

    //
    // Form the lock key using the FID and the PID.
    //
    // *** The FID must be included in the key in order to account for
    //     the folding of multiple remote compatibility mode opens into
    //     a single local open.
    //

    key = rfcb->ShiftedFid |
            SmbGetAlignedUshort( &WorkContext->RequestHeader->Pid );

    flags2 = SmbGetAlignedUshort( &WorkContext->RequestHeader->Flags2 );

    //
    // Get the file offset.
    //

    if  ( shareType != ShareTypePipe ) {

        if ( request->WordCount == 12 ) {

            //
            // The client has supplied a 32 bit file offset.
            //

            offset.QuadPart = SmbGetUlong( &request->Offset );

        } else if ( request->WordCount == 14 ) {

            //
            // The client has supplied a 64 bit file offset.  This must be an
            //  uplevel NT-like client
            //

            offset.LowPart = SmbGetUlong( &ntRequest->Offset );
            offset.HighPart = SmbGetUlong( &ntRequest->OffsetHigh );

            //
            // Reject negative offsets
            //
            if ( offset.QuadPart < 0 && offset.QuadPart != 0xFFFFFFFFFFFFFFFF ) {

                IF_DEBUG(ERRORS) {
                    KdPrint(( "SrvSmbWriteAndX: Negative offset rejected.\n"));
                }

                SrvLogInvalidSmb( WorkContext );
                SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
                status    = STATUS_INVALID_SMB;
                SmbStatus = SrvConsumeSmbData( WorkContext );
                goto Cleanup;
            }

        } else {

            //
            // Invalid word count.
            //

            SrvLogInvalidSmb( WorkContext );

            SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
            status    = STATUS_INVALID_SMB;
            SmbStatus = SrvConsumeSmbData( WorkContext );
            goto Cleanup;
        }

        //
        // If the client can only append, ensure that the client is writing
        //   beyond the original EOF
        //
        if( !rfcb->WriteAccessGranted &&
            offset.QuadPart < rfcb->Mfcb->NonpagedMfcb->OpenFileSize.QuadPart ) {

            //
            // The client is only allowed to append to this file!
            //

            SrvSetSmbError( WorkContext, STATUS_ACCESS_DENIED );
            status    = STATUS_ACCESS_DENIED;
            SmbStatus = SrvConsumeSmbData( WorkContext );
            goto Cleanup;
        }

        //
        // Gather up parameters for large writes
        //
        if( WorkContext->LargeIndication ) {

            //
            // There can be no follow-on command, and we can not be using security signatures
            //
            if( request->WordCount != 14 ||
                WorkContext->Connection->SmbSecuritySignatureActive == TRUE ||
                request->AndXCommand != SMB_COM_NO_ANDX_COMMAND ) {

                SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
                status    = STATUS_INVALID_SMB;
                SmbStatus = SrvConsumeSmbData( WorkContext );
                goto Cleanup;
            }

            WorkContext->Parameters.WriteAndX.RemainingWriteLength =
                    (ULONG)SmbGetUshort( &ntRequest->DataLengthHigh ) << 16;
            WorkContext->Parameters.WriteAndX.RemainingWriteLength +=
                    (ULONG)SmbGetUshort( &ntRequest->DataLength );

            WorkContext->Parameters.WriteAndX.CurrentWriteLength = MIN(
                WorkContext->Parameters.WriteAndX.RemainingWriteLength,
                WorkContext->ResponseBuffer->DataLength - bufferOffset );

            writeLength = WorkContext->Parameters.WriteAndX.CurrentWriteLength;

            WorkContext->Parameters.WriteAndX.RemainingWriteLength -= writeLength;

            WorkContext->Parameters.WriteAndX.WriteAddress = writeAddress;
            WorkContext->Parameters.WriteAndX.BufferLength = writeLength;

            WorkContext->Parameters.WriteAndX.Key = key;
            WorkContext->Parameters.WriteAndX.Offset = offset;

            //
            // If the data should have fit within the original SMB buffer, then
            // this is an error
            //
            if( WorkContext->Parameters.WriteAndX.RemainingWriteLength == 0 ) {
                SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
                status    = STATUS_INVALID_SMB;
                SmbStatus = SrvConsumeSmbData( WorkContext );
                goto Cleanup;
            }
        }

    } else {

        if ( (request->WordCount != 12) && (request->WordCount != 14) ) {

            //
            // Invalid word count.
            //

            SrvLogInvalidSmb( WorkContext );

            SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
            status    = STATUS_INVALID_SMB;
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        //
        // Is this a multipiece named pipe write?
        //

        connection = WorkContext->Connection;

        if ( (SmbGetUshort( &request->WriteMode ) &
                                SMB_WMODE_WRITE_RAW_NAMED_PIPE) != 0 ) {

            //
            // This is a multipiece named pipe write, is this the first
            // piece?
            //

            if ( (SmbGetUshort( &request->WriteMode ) &
                                SMB_WMODE_START_OF_MESSAGE) != 0 ) {

                //
                // This is the first piece of a multipart WriteAndX SMB.
                // Allocate a buffer large enough to hold all of the data.
                //
                // The first two bytes of the data part of the SMB are the
                // named pipe message header, which we ignore.  Adjust for
                // that.
                //

                //
                // Ensure that enough bytes are available
                //
                if( writeLength < 2 ) {
                    SrvLogInvalidSmb( WorkContext );

                    SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
                    status    = STATUS_INVALID_SMB;
                    SmbStatus = SmbStatusSendResponse;
                    goto Cleanup;
                }

                writeAddress += 2;
                writeLength -= 2;

                // If this is an OS/2 client, add the current write to the
                // remainingBytes count. This is a bug in the OS/2 rdr.
                //

                smbDialect = connection->SmbDialect;

                if ( smbDialect == SmbDialectLanMan21 ||
                     smbDialect == SmbDialectLanMan20 ||
                     smbDialect == SmbDialectLanMan10 ) {

                    //
                    // Ignore the 1st 2 bytes of the message as they are the
                    // OS/2 message header.
                    //

                    totalLength = writeLength + remainingBytes;

                } else {
                    if( writeLength > remainingBytes ) {
                        // This is an invalid SMB, they are trying to overrun the buffer
                       SrvLogInvalidSmb( WorkContext );
                       SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
                       return SmbStatusSendResponse;
                    }

                    totalLength =  remainingBytes;
                }

                SrvAllocateTransaction(
                    &transaction,
                    (PVOID *)&trailingBytes,
                    connection,
                    totalLength,
#if DBG
                    StrWriteAndX,                  // Transaction name
#else
                    StrNull,
#endif
                    NULL,
                    TRUE,                          // Source name is Unicode
                    FALSE                          // Not a remote API
                    );

                if ( transaction == NULL ) {

                    //
                    // Could not allocate a large enough buffer.
                    //

                    IF_DEBUG(ERRORS) {
                        KdPrint(( "Unable to allocate transaction\n" ));
                    }

                    SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
                    status    = STATUS_INSUFF_SERVER_RESOURCES;
                    SmbStatus = SmbStatusSendResponse;
                    goto Cleanup;
                } else {

                    //
                    // Successfully allocated a transaction block.
                    //
                    // Save the TID, PID, UID, and MID from this request in
                    // the transaction block.  These values are used to
                    // relate secondary requests to the appropriate primary
                    // request.
                    //

                    transaction->Tid = SmbGetAlignedUshort( &header->Tid );
                    transaction->Pid = SmbGetAlignedUshort( &header->Pid );
                    transaction->Uid = SmbGetAlignedUshort( &header->Uid );
                    transaction->OtherInfo = fid;

                    //
                    // Remember the total size of the buffer and the number
                    // of bytes received so far.
                    //

                    transaction->DataCount = writeLength;
                    transaction->TotalDataCount = totalLength;
                    transaction->InData = trailingBytes + writeLength;
                    transaction->OutData = trailingBytes;

                    transaction->Connection = connection;
                    SrvReferenceConnection( connection );

                    transaction->Session = lfcb->Session;
                    SrvReferenceSession( transaction->Session );
                    transaction->TreeConnect = lfcb->TreeConnect;
                    SrvReferenceTreeConnect( transaction->TreeConnect );


                    //
                    // Copy the data out of the SMB buffer.
                    //

                    RtlCopyMemory(
                        trailingBytes,
                        writeAddress,
                        writeLength
                        );

                    //
                    // Increase the write length again, so as not to confuse
                    // the redirector.
                    //

                    writeLength += 2;

                    //
                    // Link the transaction block into the connection's
                    // pending transaction list.  This will fail if there is
                    // already a tranaction with the same xID values in the
                    // list.
                    //

                    if ( !SrvInsertTransaction( transaction ) ) {

                        //
                        // A transaction with the same xIDs is already in
                        // progress.  Return an error to the client.
                        //
                        // *** Note that SrvDereferenceTransaction can't be
                        //     used here because that routine assumes that
                        //     the transaction is queued to the transaction
                        //     list.
                        //

                        SrvDereferenceTreeConnect( transaction->TreeConnect );
                        SrvDereferenceSession( transaction->Session );

                        SrvFreeTransaction( transaction );

                        SrvDereferenceConnection( connection );

                        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
                        status    = STATUS_INVALID_SMB;
                        SmbStatus = SmbStatusSendResponse;
                        goto Cleanup;
                    }

                } // else ( transaction sucessfully allocated )

            } else {   // This is a secondary piece to a multi-part message

                transaction = SrvFindTransaction(
                                  connection,
                                  header,
                                  fid
                                  );

                if ( transaction == NULL ) {

                    //
                    // Unable to find a matching transaction.
                    //

                    IF_DEBUG(ERRORS) {
                        KdPrint(( "Cannot find initial write request for "
                            "WriteAndX SMB\n"));
                    }

                    SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
                    status    = STATUS_INVALID_SMB;
                    SmbStatus = SmbStatusSendResponse;
                    goto Cleanup;
                }

                //
                // Make sure there is enough space left in the transaction
                // buffer for the data that we have received.
                //

                if ( transaction->TotalDataCount - transaction->DataCount
                        < writeLength ) {

                    //
                    // Too much data.  Throw out the entire buffer and
                    // reject this write request.
                    //

                    SrvCloseTransaction( transaction );
                    SrvDereferenceTransaction( transaction );

                    SrvSetSmbError( WorkContext, STATUS_BUFFER_OVERFLOW );
                    status    = STATUS_BUFFER_OVERFLOW;
                    SmbStatus = SmbStatusSendResponse;
                    goto Cleanup;
                }

                RtlCopyMemory(transaction->InData, writeAddress, writeLength );

                //
                // Update the transaction data pointer to where the next
                // WriteAndX data buffer will go.
                //

                transaction->InData += writeLength;
                transaction->DataCount += writeLength;

            } // secondary piece of multipart write

            if ( transaction->DataCount < transaction->TotalDataCount ) {

                //
                // We don't have all of the data yet.
                //

                PRESP_WRITE_ANDX writeResponse;
                UCHAR nextCommand;

                //
                // SrvAllocateTransaction or SrvFindTransaction referenced
                // the transaction, so dereference it.
                //

                SrvDereferenceTransaction( transaction );

                //
                // Send an interim response.
                //

                ASSERT( request->AndXCommand == SMB_COM_NO_ANDX_COMMAND );

                writeResponse = (PRESP_WRITE_ANDX)WorkContext->ResponseParameters;

                nextCommand = request->AndXCommand;

                //
                // Build the response message.
                //

                writeResponse->AndXCommand = nextCommand;
                writeResponse->AndXReserved = 0;
                SmbPutUshort(
                    &writeResponse->AndXOffset,
                    GET_ANDX_OFFSET(
                        WorkContext->ResponseHeader,
                        WorkContext->ResponseParameters,
                        RESP_WRITE_ANDX,
                        0
                        )
                    );

                writeResponse->WordCount = 6;
                SmbPutUshort( &writeResponse->Count, (USHORT)writeLength );
                SmbPutUshort( &writeResponse->Remaining, (USHORT)-1 );
                SmbPutUlong( &writeResponse->Reserved, 0 );
                SmbPutUshort( &writeResponse->ByteCount, 0 );

                WorkContext->ResponseParameters =
                    (PCHAR)WorkContext->ResponseHeader +
                            SmbGetUshort( &writeResponse->AndXOffset );

                SmbStatus = SmbStatusSendResponse;
                goto Cleanup;
            }

            //
            // We have all of the data.  Set up to write it.
            //

            writeAddress = transaction->OutData;
            writeLength = PTR_DIFF(transaction->InData, transaction->OutData);

            //
            // Save a pointer to the transaction block so that it can be
            // freed when the write completes.
            //
            // *** Note that we retain the reference to the transaction that
            //     was set by SrvAllocateTransaction or added by
            //     SrvFindTransaction.
            //

            WorkContext->Parameters.Transaction = transaction;

            //
            // Fall through to issue the I/O request.
            //

        } // "raw mode" write?
    }

    //
    // Try the fast I/O path first.  If that fails, fall through to the
    // normal build-an-IRP path.
    //

    if ( lfcb->FastIoWrite != NULL ) {

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastWritesAttempted );

        try {

            if ( lfcb->FastIoWrite(
                    lfcb->FileObject,
                    &offset,
                    writeLength,
                    TRUE,
                    key,
                    writeAddress,
                    &WorkContext->Irp->IoStatus,
                    lfcb->DeviceObject
                    ) ) {


                IF_SYSCACHE_RFCB( rfcb ) {
                    KdPrint(( "FastIoWrite Rfcb %p Length %x Offset %x succeeded\n", rfcb, writeLength, offset.u.LowPart ));
                }

                //
                // The fast I/O path worked.  Call the restart routine directly
                // to do postprocessing (including sending the response).
                //
                WorkContext->bAlreadyTrace = TRUE;
                SrvFsdRestartWriteAndX( WorkContext );

                IF_SMB_DEBUG(READ_WRITE2) KdPrint(( "SrvSmbWriteAndX complete.\n" ));
                SmbStatus = SmbStatusInProgress;
                goto Cleanup;
            }
            else
            {
                IF_SYSCACHE_RFCB( rfcb ) {
                    KdPrint(( "FastIoWrite Rfcb %p Length %x Offset %x failed status %x\n", rfcb, writeLength, offset.u.LowPart, WorkContext->Irp->IoStatus.Status ));
                }
            }
        }
        except( EXCEPTION_EXECUTE_HANDLER ) {
            // Fall through to the slow path on an exception
            status = GetExceptionCode();
            IF_DEBUG(ERRORS) {
                KdPrint(("FastIoRead threw exception %x\n", status ));
            }

            IF_SYSCACHE_RFCB( rfcb ) {
                KdPrint(( "FastIoWrite Rfcb %p Length %x Offset %x threw exception\n", rfcb, writeLength, offset.u.LowPart ));
            }
        }

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastWritesFailed );

    }

    //
    // The turbo path failed.  Build the write request, reusing the
    // receive IRP.
    //

    if ( shareType != ShareTypePipe ) {

        //
        // Build an MDL describing the write buffer.  Note that if the
        // file system can complete the write immediately, the MDL isn't
        // really needed, but if the file system must send the request
        // to its FSP, the MDL _is_ needed.
        //
        // *** Note the assumption that the request buffer already has a
        //     valid full MDL from which a partial MDL can be built.
        //

        IoBuildPartialMdl(
            WorkContext->RequestBuffer->Mdl,
            WorkContext->RequestBuffer->PartialMdl,
            writeAddress,
            writeLength
            );

        //
        // Build the IRP.
        //

        SrvBuildReadOrWriteRequest(
                WorkContext->Irp,               // input IRP address
                lfcb->FileObject,               // target file object address
                WorkContext,                    // context
                IRP_MJ_WRITE,                   // major function code
                0,                              // minor function code
                writeAddress,                   // buffer address
                writeLength,                    // buffer length
                WorkContext->RequestBuffer->PartialMdl,   // MDL address
                offset,                         // byte offset
                key                             // lock key
                );

        IF_SMB_DEBUG(READ_WRITE2) {
            KdPrint(( "SrvSmbWriteAndX: writing to file 0x%p, offset %ld, length %ld, source 0x%p\n",
                        lfcb->FileObject, offset.LowPart, writeLength,
                        writeAddress ));
        }

    } else {

        //
        // Build the PIPE_INTERNAL_WRITE IRP.
        //

        SrvBuildIoControlRequest(
            WorkContext->Irp,
            lfcb->FileObject,
            WorkContext,
            IRP_MJ_FILE_SYSTEM_CONTROL,
            FSCTL_PIPE_INTERNAL_WRITE,
            writeAddress,
            writeLength,
            NULL,
            0,
            NULL,
            NULL
            );

        IF_SMB_DEBUG(READ_WRITE2) {
            KdPrint(( "SrvSmbWriteAndX: writing to file 0x%p length %ld, destination 0x%p\n",
                        lfcb->FileObject, writeLength,
                        writeAddress ));
        }

    }

    //
    // Pass the request to the file system.  If the chained command is
    // Close, we need to arrange to restart in the FSP after the write
    // completes.
    //
    // If we have a LargeIndication, we may want to do some cache
    //  operations in the restart routine.  For this, we must be at passive
    //  level.
    //

    if ( WorkContext->LargeIndication == FALSE
         && request->AndXCommand != SMB_COM_CLOSE ) {

        IF_SYSCACHE_RFCB( rfcb )
        {
            WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
            WorkContext->bAlreadyTrace = FALSE;
            WorkContext->FspRestartRoutine = SrvFsdRestartWriteAndX;
        }
        else
        {
            WorkContext->bAlreadyTrace = TRUE;
            WorkContext->FsdRestartRoutine = SrvFsdRestartWriteAndX;
            DEBUG WorkContext->FspRestartRoutine = NULL;
        }
    } else {
        WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
        WorkContext->bAlreadyTrace = FALSE;
        WorkContext->FspRestartRoutine = SrvFsdRestartWriteAndX;
    }

    (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

    //
    // The write has been started.  Control will return to
    // SrvFsdRestartWriteAndX when the write completes.
    //
    SmbStatus = SmbStatusInProgress;
    IF_SMB_DEBUG(READ_WRITE2) KdPrint(( "SrvSmbWriteAndX complete.\n" ));

Cleanup:
    SrvWmiEndContext(WorkContext);
    //SrvDereferenceWorkItem(WorkContext);
    return SmbStatus;

} // SrvSmbWriteAndX


VOID SRVFASTCALL
SrvRestartChainedClose (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This is the restart routine invoked after before the response to a
    WriteAndClose, or a ReadAndX or a WriteAndX when the chained command
    is Close.  This routine closes the file, then sends the response.

    This operation cannot be done in the FSD.  Closing a file
    dereferences a number of blocks that are in the FSP address space.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        representing the work item.  The response parameters must be
        fully set up.

Return Value:

    None.

--*/

{
    PRFCB rfcb = WorkContext->Rfcb;
    PRESP_CLOSE closeResponse = WorkContext->ResponseParameters;

    PAGED_CODE( );

    //
    // Set the file last write time.
    //

    if ( rfcb->WriteAccessGranted || rfcb->AppendAccessGranted ) {

        (VOID)SrvSetLastWriteTime(
                  rfcb,
                  WorkContext->Parameters.LastWriteTime,
                  rfcb->Lfcb->GrantedAccess
                  );

    }

    //
    // Close the file.
    //

    IF_SMB_DEBUG(READ_WRITE2) {
        KdPrint(( "SrvRestartChainedClose: closing RFCB 0x%p\n", WorkContext->Rfcb ));
    }

    SrvCloseRfcb( WorkContext->Rfcb );

    //
    // Dereference the RFCB immediately, rather than waiting for normal
    // work context cleanup after the response send completes.  This
    // gets the xFCB structures cleaned up in a more timely manner.
    //
    // *** The specific motivation for this change was to fix a problem
    //     where a compatibility mode open was closed, the response was
    //     sent, and a Delete SMB was received before the send
    //     completion was processed.  This resulted in the MFCB and LFCB
    //     still being present, which caused the delete processing to
    //     try to use the file handle in the LFCB, which we just closed
    //     here.
    //

    SrvDereferenceRfcb( WorkContext->Rfcb );
    WorkContext->Rfcb = NULL;

    //
    // Build the response parameters.
    //

    closeResponse->WordCount = 0;
    SmbPutUshort( &closeResponse->ByteCount, 0 );

    WorkContext->ResponseParameters = NEXT_LOCATION( closeResponse, RESP_CLOSE, 0 );

    //
    // Send the response.
    //

    SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );

    return;

} // SrvRestartChainedClose


VOID SRVFASTCALL
RestartLockAndRead (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes file lock completion for a Lock and Read SMB.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PREQ_READ request;

    LARGE_INTEGER offset;
    NTSTATUS status = STATUS_SUCCESS;
    SMB_STATUS smbStatus = SmbStatusInProgress;
    PSRV_TIMER timer;
    BOOLEAN bNeedTrace = (WorkContext->bAlreadyTrace == FALSE);

    PAGED_CODE( );
    if (bNeedTrace) {
        if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
            WorkContext->PreviousSMB = EVENT_TYPE_SMB_LOCK_AND_READ;
        SrvWmiStartContext(WorkContext);
    }
    else
        WorkContext->bAlreadyTrace = FALSE;

    IF_DEBUG(WORKER1) KdPrint(( " - RestartLockAndRead\n" ));

    //
    // If this request was being timed, cancel the timer.
    //

    timer = WorkContext->Parameters.Lock.Timer;
    if ( timer != NULL ) {
        SrvCancelTimer( timer );
        SrvFreeTimer( timer );
    }

    //
    // If the lock request failed, set an error status in the response
    // header.
    //

    status = WorkContext->Irp->IoStatus.Status;

    if ( !NT_SUCCESS(status) ) {

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.LockViolations );
        IF_DEBUG(ERRORS) KdPrint(( "Lock failed: %X\n", status ));

        //
        // Store the failing lock offset.
        //

        request = (PREQ_READ)WorkContext->RequestParameters;
        offset.QuadPart = SmbGetUlong( &request->Offset );

        WorkContext->Rfcb->PagedRfcb->LastFailingLockOffset = offset;

        //
        // Send back the bad news.
        //

        if ( status == STATUS_CANCELLED ) {
            status = STATUS_FILE_LOCK_CONFLICT;
        }
        SrvSetSmbError( WorkContext, status );
        SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );

        IF_DEBUG(TRACE2) KdPrint(( "RestartLockAndRead complete\n" ));
        goto Cleanup;
    }

    //
    // The lock request completed successfully.
    //

    InterlockedIncrement(
        &WorkContext->Rfcb->NumberOfLocks
        );

    //
    // Start the read to complete the LockAndRead.
    //

    smbStatus = SrvSmbRead( WorkContext );
    if ( smbStatus != SmbStatusInProgress ) {
        SrvEndSmbProcessing( WorkContext, smbStatus );
    }

Cleanup:
    if (bNeedTrace) {
        SrvWmiEndContext(WorkContext);
    }
    return;

} // RestartLockAndRead


VOID SRVFASTCALL
RestartPipeReadAndXPeek(
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function continues a read and X on a named pipe handle.  It can
    be called as a restart routine if a peek is preformed, but can also
    be called directly from SrvSmbReadAndX if it is not necessary to
    peek the pipe before reading from it.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        representing the work item.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    PLFCB lfcb;
    PIRP irp = WorkContext->Irp;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_OBJECT deviceObject;

    PAGED_CODE( );

    lfcb = WorkContext->Rfcb->Lfcb;
    if ( WorkContext->Parameters.ReadAndX.PipePeekBuffer != NULL ) {

        //
        // Non-blocking read.  We have issued a pipe peek; free the peek
        // buffer.
        //

        DEALLOCATE_NONPAGED_POOL(
            WorkContext->Parameters.ReadAndX.PipePeekBuffer
            );

        //
        // Now see if there is data to read.
        //

        status = irp->IoStatus.Status;

        if ( NT_SUCCESS(status) ) {

            //
            // There is no data in the pipe.  Fail the read.
            //

            SrvSetSmbError( WorkContext, STATUS_PIPE_EMPTY );
            SrvFsdSendResponse( WorkContext );
            IF_SMB_DEBUG(READ_WRITE2) KdPrint(( "RestartPipeReadAndXPeek complete.\n" ));
            return;

        } else if ( status != STATUS_BUFFER_OVERFLOW ) {

            //
            // An error occurred.  Return the status to the caller.
            //

            SrvSetSmbError( WorkContext, status );
            SrvFsdSendResponse( WorkContext );
            IF_SMB_DEBUG(READ_WRITE2) KdPrint(( "RestartPipeReadAndXPeek complete.\n" ));
            return;
        }

        //
        // There is data in pipe; proceed with read.
        //

    }

    //
    // in line internal read
    //

    deviceObject = lfcb->DeviceObject;

    irp->Tail.Overlay.OriginalFileObject = lfcb->FileObject;
    irp->Tail.Overlay.Thread = WorkContext->CurrentWorkQueue->IrpThread;
    DEBUG irp->RequestorMode = KernelMode;

    //
    // Get a pointer to the next stack location.  This one is used to
    // hold the parameters for the device I/O control request.
    //

    irpSp = IoGetNextIrpStackLocation( irp );

    //
    // Set up the completion routine.
    //

    IoSetCompletionRoutine(
        irp,
        SrvFsdIoCompletionRoutine,
        WorkContext,
        TRUE,
        TRUE,
        TRUE
        );

    irpSp->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL,
    irpSp->MinorFunction = 0;
    irpSp->FileObject = lfcb->FileObject;
    irpSp->DeviceObject = deviceObject;

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP for those parameters that are the same for all three methods.
    //

    irpSp->Parameters.FileSystemControl.OutputBufferLength =
                            WorkContext->Parameters.ReadAndX.ReadLength;
    irpSp->Parameters.FileSystemControl.InputBufferLength = 0;
    irpSp->Parameters.FileSystemControl.FsControlCode = FSCTL_PIPE_INTERNAL_READ;

    irp->MdlAddress = NULL;
    irp->AssociatedIrp.SystemBuffer =
                WorkContext->Parameters.ReadAndX.ReadAddress,
    irpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

    //
    // end in-line
    //

    //
    // Pass the request to the file system.  If the chained command is
    // Close, we need to arrange to restart in the FSP after the read
    // completes.
    //

    if ( WorkContext->NextCommand != SMB_COM_CLOSE ) {
        WorkContext->bAlreadyTrace = TRUE;
        WorkContext->FsdRestartRoutine = SrvFsdRestartReadAndX;
        DEBUG WorkContext->FspRestartRoutine = NULL;
    } else {
        WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
        WorkContext->bAlreadyTrace = FALSE;
        WorkContext->FspRestartRoutine = SrvFsdRestartReadAndX;
    }

    IF_SMB_DEBUG(READ_WRITE2) {
        KdPrint(( "RestartPipeReadAndXPeek: reading from file 0x%p, length %ld, destination 0x%p\n",
                     lfcb->FileObject,
                     WorkContext->Parameters.ReadAndX.ReadLength,
                     WorkContext->Parameters.ReadAndX.ReadAddress
                     ));
    }

    (VOID)IoCallDriver( deviceObject, WorkContext->Irp );

    //
    // The read has been started.  Control will return to the restart
    // routine when the read completes.
    //

    IF_SMB_DEBUG(READ_WRITE2) KdPrint(( "RestartPipeReadAndXPeek complete.\n" ));
    return;

} // RestartPipeReadAndXPeek


VOID SRVFASTCALL
SrvRestartWriteAndUnlock (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This restart routine is used when the Write part of a Write and
    Unlock SMB completes successfully.  (Note that the range remains
    locked if the write fails.) This routine handles the Unlock part of
    the request.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PREQ_WRITE request;
    PRESP_WRITE response;

    NTSTATUS status;
    PRFCB rfcb;
    PLFCB lfcb;
    LARGE_INTEGER length;
    LARGE_INTEGER offset;
    ULONG key;

    PAGED_CODE( );

    IF_DEBUG(WORKER1) KdPrint(( " - SrvRestartWriteAndUnlock\n" ));

    //
    // Get the request and response parameter pointers.
    //

    request = (PREQ_WRITE)WorkContext->RequestParameters;
    response = (PRESP_WRITE)WorkContext->ResponseParameters;

    //
    // Get the file pointer.
    //

    rfcb = WorkContext->Rfcb;
    IF_DEBUG(TRACE2) {
        KdPrint(( "  connection 0x%p, RFCB 0x%p\n",
                    WorkContext->Connection, rfcb ));
    }

    lfcb = rfcb->Lfcb;

    //
    // Get the offset and length of the range being unlocked.
    // Combine the FID with the caller's PID to form the local
    // lock key.
    //
    // *** The FID must be included in the key in order to
    //     account for the folding of multiple remote
    //     compatibility mode opens into a single local open.
    //

    offset.QuadPart = SmbGetUlong( &request->Offset );
    length.QuadPart = SmbGetUshort( &request->Count );

    key = rfcb->ShiftedFid |
            SmbGetAlignedUshort( &WorkContext->RequestHeader->Pid );

    //
    // Verify that the client has unlock access to the file via
    // the specified handle.
    //

    if ( rfcb->UnlockAccessGranted ) {

        //
        // Issue the Unlock request.
        //
        // *** Note that we do the Unlock synchronously.  Unlock is a
        //     quick operation, so there's no point in doing it
        //     asynchronously.  In order to do this, we have to let
        //     normal I/O completion happen (so the event is set), which
        //     means that we have to allocate a new IRP (I/O completion
        //     likes to deallocate an IRP).  This is a little wasteful,
        //     since we've got a perfectly good IRP hanging around.
        //

        IF_SMB_DEBUG(READ_WRITE2) {
            KdPrint(( "SrvRestartWriteAndUnlock: Unlocking in file 0x%p: (%ld,%ld), key 0x%lx\n", lfcb->FileObject,
                        offset.LowPart, length.LowPart, key ));
        }

        status = SrvIssueUnlockRequest(
                    lfcb->FileObject,               // target file object
                    &lfcb->DeviceObject,            // target device object
                    IRP_MN_UNLOCK_SINGLE,           // unlock operation
                    offset,                         // byte offset
                    length,                         // range length
                    key                             // lock key
                    );

        //
        // If the unlock request failed, set an error status in
        // the response header.  Otherwise, build a success response.
        //

        if ( !NT_SUCCESS(status) ) {

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvRestartWriteAndUnlock: Unlock failed: %X\n",
                            status ));
            }
            SrvSetSmbError( WorkContext, status );

        } else {

            response->WordCount = 1;
            SmbPutUshort( &response->Count, (USHORT)length.LowPart );
            SmbPutUshort( &response->ByteCount, 0 );

            WorkContext->ResponseParameters =
                                    NEXT_LOCATION( response, RESP_WRITE, 0 );

        }

    } else {

        SrvStatistics.GrantedAccessErrors++;

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvRestartWriteAndUnlock: Unlock access not granted.\n"));
        }

        SrvSetSmbError( WorkContext, STATUS_ACCESS_DENIED );
    }

    //
    // Processing of the SMB is complete.  Call SrvEndSmbProcessing
    // to send the response.
    //

    SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );

    IF_DEBUG(TRACE2) KdPrint(( "RestartWrite complete\n" ));
    return;

} // SrvRestartWriteAndUnlock


VOID SRVFASTCALL
SrvRestartWriteAndXRaw (
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function completes processing of a WriteAndX raw protocol.
    The work context block already points to the correct response.  All
    that is left to do is free the transaction block, and dispatch the
    And-X command, or send the response.

Arguments:

    WorkContext - A pointer to a set of

Return Value:

    None.

--*/

{
    PTRANSACTION transaction;

    PAGED_CODE( );

    transaction = WorkContext->Parameters.Transaction;

    ASSERT( transaction != NULL );
    ASSERT( GET_BLOCK_TYPE( transaction ) == BlockTypeTransaction );

    SrvCloseTransaction( transaction );
    SrvDereferenceTransaction( transaction );

    //
    // Test for a legal followon command, and dispatch as appropriate.
    // Close and CloseAndTreeDisconnect are handled specially.
    //

    switch ( WorkContext->NextCommand ) {

    case SMB_COM_NO_ANDX_COMMAND:

        //
        // No more commands.  Send the response.
        //

        SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );
        break;

    case SMB_COM_READ:
    case SMB_COM_READ_ANDX:
    case SMB_COM_LOCK_AND_READ:

        //
        // Redispatch the SMB for more processing.
        //

        SrvProcessSmb( WorkContext );
        break;

    case SMB_COM_CLOSE:
    //case SMB_COM_CLOSE_AND_TREE_DISC:   // Bogus SMB

        //
        // Call SrvRestartChainedClose to get the file time set and the
        // file closed.
        //

        WorkContext->Parameters.LastWriteTime =
            ((PREQ_CLOSE)WorkContext->RequestParameters)->LastWriteTimeInSeconds;

        SrvRestartChainedClose( WorkContext );

        break;

    default:                            // Illegal followon command

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvRestartWriteAndXRaw: Illegal followon "
                        "command: 0x%lx\n", WorkContext->NextCommand ));
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );

    }

    IF_DEBUG(TRACE2) KdPrint(( "SrvRestartWriteAndXRaw complete\n" ));
    return;

} // SrvRestartWriteAndXRaw


VOID SRVFASTCALL
SetNewSize (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes the Write SMB when Count == 0.  Sets the size of the
    target file to the specified Offset.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PREQ_WRITE request;
    PRESP_WRITE response;

    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    ACCESS_MASK grantedAccess;
    PLFCB lfcb;
    FILE_END_OF_FILE_INFORMATION newEndOfFile;
    FILE_ALLOCATION_INFORMATION newAllocation;

    PAGED_CODE( );

    IF_DEBUG(TRACE2) KdPrint(( "SetNewSize entered\n" ));

    request = (PREQ_WRITE)WorkContext->RequestParameters;
    response = (PRESP_WRITE)WorkContext->ResponseParameters;

    grantedAccess = WorkContext->Rfcb->GrantedAccess;
    lfcb = WorkContext->Rfcb->Lfcb;

    //
    // Verify that the client has the appropriate access to the file via
    // the specified handle.
    //

    CHECK_FILE_INFORMATION_ACCESS(
        grantedAccess,
        IRP_MJ_SET_INFORMATION,
        FileEndOfFileInformation,
        &status
        );

    if ( NT_SUCCESS(status) ) {
        CHECK_FILE_INFORMATION_ACCESS(
            grantedAccess,
            IRP_MJ_SET_INFORMATION,
            FileAllocationInformation,
            &status
            );
    }

    if ( !NT_SUCCESS(status) ) {

        SrvStatistics.GrantedAccessErrors++;

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SetNewSize: IoCheckFunctionAccess failed: "
                        "0x%X, GrantedAccess: %lx\n",
                        status, grantedAccess ));
        }

        SrvSetSmbError( WorkContext, status );
        SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );
        return;

    }

    //
    // NtSetInformationFile allows a 64-bit file size, but the SMB
    // protocol only allows 32-bit file sizes.  Only set the lower 32
    // bits, leaving the upper bits zero.
    //

    newEndOfFile.EndOfFile.QuadPart = SmbGetUlong( &request->Offset );

    //
    // Set the new EOF.
    //

    status = NtSetInformationFile(
                 lfcb->FileHandle,
                 &ioStatusBlock,
                 &newEndOfFile,
                 sizeof(newEndOfFile),
                 FileEndOfFileInformation
                 );

    if ( NT_SUCCESS(status) ) {

        //
        // Set the new allocation size for the file.
        //
        // !!! This should ONLY be done if this is a down-level client!
        //

        newAllocation.AllocationSize = newEndOfFile.EndOfFile;

        status = NtSetInformationFile(
                     lfcb->FileHandle,
                     &ioStatusBlock,
                     &newAllocation,
                     sizeof(newAllocation),
                     FileAllocationInformation
                     );
    }

    if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) {
            KdPrint(( "SetNewSize: NtSetInformationFile failed, "
                        "status = %X\n", status ));
        }

        SrvSetSmbError( WorkContext, status );
        SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );
        return;
    }

    //
    // Build and send the response SMB.
    //

    response->WordCount = 1;
    SmbPutUshort( &response->Count, 0 );
    SmbPutUshort( &response->ByteCount, 0 );
    WorkContext->ResponseParameters = NEXT_LOCATION( response, RESP_WRITE, 0 );

    IF_DEBUG(TRACE2) KdPrint(( "SetNewSize complete\n" ));
    SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );

    return;

} // SetNewSize


BOOLEAN
SetNewPosition (
    IN PRFCB Rfcb,
    IN OUT PULONG Offset,
    IN BOOLEAN RelativeSeek
    )

/*++

Routine Description:

    Sets the new file pointer.

Arguments:

    Rfcb - A pointer to the rfcb block which contains the position.
    Offset - A pointer to the offset sent by client.  If RelativeSeek is
        TRUE, then this pointer will be updated.
    RelativeSeek - Whether the seek is relative to the current position.

Return Value:

    TRUE, Not nagative seek. Position has been updated.
    FALSE, Negative seek. Position not updated.

--*/

{
    LARGE_INTEGER newPosition;

    UNLOCKABLE_CODE( 8FIL );

    if ( RelativeSeek ) {
        newPosition.QuadPart = Rfcb->CurrentPosition + *Offset;
    } else {
        newPosition.QuadPart = *Offset;
    }

    if ( newPosition.QuadPart < 0 ) {
        return FALSE;
    }

    Rfcb->CurrentPosition = newPosition.LowPart;
    *Offset = newPosition.LowPart;
    return TRUE;

} // SetNewPosition


VOID SRVFASTCALL
SrvBuildAndSendErrorResponse (
    IN OUT PWORK_CONTEXT WorkContext
    )
{
    PAGED_CODE( );

    SrvSetSmbError( WorkContext, WorkContext->Irp->IoStatus.Status );
    SrvFsdSendResponse( WorkContext );

    return;

} // SrvBuildAndSendErrorResponse
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\smbtree.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbtree.c

Abstract:

    This module contains routines for dealing with tree connects and
    disconnects:

        Tree Connect
        Tree Connect And X
        Tree Disconnect

Author:

    David Treadwell (davidtr)    15-Nov-1989

Revision History:


--*/

#include "precomp.h"
#include "smbtree.tmh"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvSmbTreeConnect )
#pragma alloc_text( PAGE, SrvSmbTreeConnectAndX )
#pragma alloc_text( PAGE, SrvSmbTreeDisconnect )
#endif


SMB_PROCESSOR_RETURN_TYPE
SrvSmbTreeConnect (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes a tree connect SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{

    PREQ_TREE_CONNECT request;
    PRESP_TREE_CONNECT response;

    PSESSION session;
    PSECURITY_CONTEXT SecurityContext;
    PCONNECTION connection;
    PPAGED_CONNECTION pagedConnection;
    PTABLE_HEADER tableHeader;
    PTABLE_ENTRY entry;
    SHORT tidIndex;
    PSHARE share;
    PTREE_CONNECT treeConnect;
    PSZ password, service;
    USHORT len;
    NTSTATUS   status    = STATUS_SUCCESS;
    NTSTATUS   TableStatus;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    BOOLEAN didLogon = FALSE;
    SHORT uidIndex;
    SMB_DIALECT smbDialect;
    PUNICODE_STRING clientMachineNameString;
    ACCESS_MASK desiredAccess;
    ACCESS_MASK grantedAccess;
    SECURITY_SUBJECT_CONTEXT subjectContext;
    UNICODE_STRING domain = { 0, 0, StrNull };

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_TREE_CONNECT;
    SrvWmiStartContext(WorkContext);

    IF_SMB_DEBUG(TREE1) {
        KdPrint(( "Tree connect request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader, WorkContext->ResponseHeader ));
        KdPrint(( "Tree connect request parameters at 0x%p, response parameters at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters ));
    }

    //
    // Set up parameters.
    //

    request = (PREQ_TREE_CONNECT)(WorkContext->RequestParameters);
    response = (PRESP_TREE_CONNECT)(WorkContext->ResponseParameters);

    connection = WorkContext->Connection;
    pagedConnection = connection->PagedConnection;
    smbDialect = connection->SmbDialect;

    // If we are requiring extended security signatures, than we can't let this through
    if( SrvRequireExtendedSignatures )
    {
        SrvSetSmbError( WorkContext, STATUS_LOGIN_WKSTA_RESTRICTION );
        status    = STATUS_LOGIN_WKSTA_RESTRICTION;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // If this client has not yet done a session setup and this his first
    // tree connection then we must first do a logon.  (i.e. SessionSetup)
    //

    len = SrvGetStringLength(
                             (PSZ)request->Buffer,
                             END_OF_REQUEST_SMB( WorkContext ),
                             FALSE,             // not unicode
                             FALSE              // do not include null terminator
                             );
    if( len == (USHORT)-1 ) {
        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    password = (PSZ)request->Buffer + 2 + len;

    len = SrvGetStringLength(
                             password,
                             END_OF_REQUEST_SMB( WorkContext ),
                             FALSE,             // not unicode
                             FALSE              // do not include null terminator
                             );

    if( len == (USHORT)-1 ) {
        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    service = password + (len + 1) + 1;

    //
    // Allocate a tree connect block.  We do this early on the
    // assumption that the request will usually succeed.  This also
    // reduces the amount of time that we hold the lock.
    //

    SrvAllocateTreeConnect( &treeConnect, NULL );

    if ( treeConnect == NULL ) {

        //
        // Unable to allocate tree connect.  Return an error to the
        // client.
        //

        SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
        status    = STATUS_INSUFF_SERVER_RESOURCES;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    ASSERT( SrvSessionList.Lock == &SrvOrderedListLock );

    ACQUIRE_LOCK( &connection->Lock );

    if ( connection->CurrentNumberOfSessions != 0 ) {

        RELEASE_LOCK( &connection->Lock );

        session = SrvVerifyUid (
                      WorkContext,
                      SmbGetAlignedUshort( &WorkContext->RequestHeader->Uid )
                      );

        if ( session == NULL ) {

            //
            // This should only happen if the client has already
            // established a session, as in tree connecting with a bad
            // UID.
            //

            SrvFreeTreeConnect( treeConnect );

            SrvSetSmbError( WorkContext, STATUS_SMB_BAD_UID );
            status    = STATUS_SMB_BAD_UID;
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }
        else if( session->IsSessionExpired )
        {
            SrvFreeTreeConnect( treeConnect );

            status = SESSION_EXPIRED_STATUS_CODE;
            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

    } else if ( (smbDialect <= SmbDialectLanMan10) ||
                (smbDialect == SmbDialectIllegal) ) {

        //
        // An LM 1.0 or newer client has tried to do a tree connect
        // without first doing session setup.  We call this a protocol
        // violation.
        //
        // Also catch clients that are trying to connect without
        // negotiating a valid protocol.
        //

        RELEASE_LOCK( &connection->Lock );

        IF_DEBUG(SMB_ERRORS) {

            if ( smbDialect == SmbDialectIllegal ) {

                KdPrint(("SrvSmbTreeConnect: Client %z is using an illegal "
                    "dialect.\n", (PCSTRING)&connection->OemClientMachineNameString ));;

            } else {

                KdPrint(( "Client speaking dialect %ld sent tree connect without session setup.\n", connection->SmbDialect ));
            }
        }

        SrvFreeTreeConnect( treeConnect );

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    } else {

        UNICODE_STRING machineName;
        PENDPOINT endpoint;
        BOOLEAN seqNumbers;

        RELEASE_LOCK( &connection->Lock );

        //
        // Convert the client name to unicode
        //

        clientMachineNameString = &connection->ClientMachineNameString;
        if ( clientMachineNameString->Length == 0 ) {

            UNICODE_STRING clientMachineName;
            clientMachineName.Buffer = connection->ClientMachineName;
            clientMachineName.MaximumLength =
                            (USHORT)(COMPUTER_NAME_LENGTH+1)*sizeof(WCHAR);

            (VOID)RtlOemStringToUnicodeString(
                            &clientMachineName,
                            &connection->OemClientMachineNameString,
                            FALSE
                            );

            //
            // Add the double backslashes to the length
            //

            clientMachineNameString->Length =
                            (USHORT)(clientMachineName.Length + 2*sizeof(WCHAR));

        }

        //
        // Form a string describing the computer name without the
        // leading backslashes.
        //

        machineName.Buffer = clientMachineNameString->Buffer + 2;
        machineName.Length = clientMachineNameString->Length - 2 * sizeof(WCHAR);
        machineName.MaximumLength =
            clientMachineNameString->MaximumLength - 2 * sizeof(WCHAR);

        SecurityContext = SrvAllocateSecurityContext();
        if( SecurityContext == NULL )
        {
            SrvFreeTreeConnect( treeConnect );

            SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
            status    = STATUS_INSUFF_SERVER_RESOURCES;
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        //
        // Allocate a session block.
        //

        SrvAllocateSession(
            &session,
            &machineName,
            &domain );

        if ( session == NULL ) {

            //
            // Unable to allocate a Session block.  Return an error
            // status.
            //

            SrvDereferenceSecurityContext( SecurityContext );
            SrvFreeTreeConnect( treeConnect );

            SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
            status    = STATUS_INSUFF_SERVER_RESOURCES;
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        //
        // Assume that down-level clients that are getting logged on
        // here will always use canonicalized (uppercase) paths.  This
        // will result in case insensitivity for all operations.
        //

        session->UsingUppercasePaths = TRUE;

        //
        // The only way for a client to tell us the buffer size or the
        // max count of pending requests he wants to use is the Session
        // Setup SMB.  If he didn't send one, then we get to
        // unilaterally determine the buffer size and multiplex count
        // used by both of us.
        //

        endpoint = connection->Endpoint;
        if ( endpoint->IsConnectionless ) {

            ULONG adapterNumber;

            //
            // Our session max buffer size is the smaller of the
            // server receive buffer size and the ipx transport
            // indicated max packet size.
            //

            adapterNumber =
                WorkContext->ClientAddress->DatagramOptions.LocalTarget.NicId;

            session->MaxBufferSize =
                        (USHORT) GetIpxMaxBufferSize(
                                                endpoint,
                                                adapterNumber,
                                                SrvReceiveBufferLength
                                                );

        } else {

            session->MaxBufferSize = (USHORT)SrvReceiveBufferLength;
        }

        session->MaxMpxCount = SrvMaxMpxCount;

        if ( session->MaxMpxCount < 2 ) {
            connection->OplocksAlwaysDisabled = TRUE;
        }


        if( SrvSmbSecuritySignaturesRequired == TRUE &&
            WorkContext->Connection->Endpoint->IsConnectionless == FALSE ) {

            seqNumbers = TRUE;

        } else {
            seqNumbers = FALSE;

        }

        //
        // Try to find legitimate name/password combination.
        //

        status = SrvValidateUser(
                    &SecurityContext->UserHandle,
                    session,
                    connection,
                    &machineName,
                    password,
                    strlen( password ) + 1,
                    NULL,                        // CaseSensitivePassword
                    0,                           // CaseSensitivePasswordLength
                    seqNumbers,
                    NULL                         // action
                    );

        //
        // If a bad name/password combination was sent, return an error.
        //

        if ( !NT_SUCCESS(status) ) {

            SrvFreeSession( session );
            SrvFreeTreeConnect ( treeConnect );

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvSmbTreeConnect: Bad user/password combination.\n" ));
            }

            SrvStatistics.LogonErrors++;

            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        IF_SMB_DEBUG(ADMIN1) {
            KdPrint(( "Validated user: %ws\n",
                connection->ClientMachineName ));
        }

        //
        // Making a new session visible is a multiple-step operation.  It
        // must be inserted in the global ordered tree connect list and the
        // containing connection's session table, and the connection must be
        // referenced.  We need to make these operations appear atomic, so
        // that the session cannot be accessed elsewhere before we're done
        // setting it up.  In order to do this, we hold all necessary locks
        // the entire time we're doing the operations.  The first operation
        // is protected by the global ordered list lock
        // (SrvOrderedListLock), while the other operations are protected by
        // the per-connection lock.  We take out the ordered list lock
        // first, then the connection lock.  This ordering is required by
        // lock levels (see lock.h).
        //
        //
        // Ready to try to find a UID for the session.  Check to see if
        // the connection is being closed, and if so, terminate this
        // operation.
        //

        ASSERT( SrvSessionList.Lock == &SrvOrderedListLock );

        ACQUIRE_LOCK( SrvSessionList.Lock );
        ACQUIRE_LOCK( &connection->Lock );

        // Set the Security Context now that we have the lock acquired
        SrvReplaceSessionSecurityContext( session, SecurityContext, WorkContext );

        if ( GET_BLOCK_STATE(connection) != BlockStateActive ) {

            RELEASE_LOCK( &connection->Lock );
            RELEASE_LOCK( SrvSessionList.Lock );

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvSmbTreeConnect: Connection closing\n" ));
            }

            SrvFreeSession( session );
            SrvFreeTreeConnect( treeConnect );

            SrvSetSmbError( WorkContext, STATUS_INVALID_PARAMETER );
            status    = STATUS_INVALID_PARAMETER;
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        //
        // Because the client is speaking the "core" dialect, it will
        // not send a valid UID in future SMBs, so it can only have one
        // session.  We define that session to live in UID slot 0.  We
        // know that the client has no sessions yet, so slot 0 must be
        // free.
        //

        tableHeader = &pagedConnection->SessionTable;
        ASSERT( tableHeader->Table[0].Owner == NULL );

        uidIndex = 0;

        //
        // Remove the UID slot from the free list and set its owner and
        // sequence number.  Create a UID for the session.  Increment
        // count of sessions.
        //

        entry = &tableHeader->Table[uidIndex];

        tableHeader->FirstFreeEntry = entry->NextFreeEntry;
        DEBUG entry->NextFreeEntry = -2;
        if ( tableHeader->LastFreeEntry == uidIndex ) {
            tableHeader->LastFreeEntry = -1;
        }

        entry->Owner = session;

        INCREMENT_UID_SEQUENCE( entry->SequenceNumber );
        if ( uidIndex == 0 && entry->SequenceNumber == 0 ) {
            INCREMENT_UID_SEQUENCE( entry->SequenceNumber );
        }
        session->Uid = MAKE_UID( uidIndex, entry->SequenceNumber );

        connection->CurrentNumberOfSessions++;

        IF_SMB_DEBUG(ADMIN1) {
            KdPrint(( "Found UID.  Index = 0x%lx, sequence = 0x%lx\n",
                        (ULONG)UID_INDEX( session->Uid ),
                        (ULONG)UID_SEQUENCE( session->Uid ) ));
        }

        //
        // Insert the session on the global session list.
        //

        SrvInsertEntryOrderedList( &SrvSessionList, session );

        //
        // Reference the connection block to account for the new
        // session.
        //

        SrvReferenceConnection( connection );
        session->Connection = connection;

        RELEASE_LOCK( &connection->Lock );
        RELEASE_LOCK( SrvSessionList.Lock );

        //
        // Session successfully created.  Remember its address in the
        // work context block.
        //
        // *** Note that the reference count on the session block is
        //     initially set to 2, to allow for the active status on the
        //     block and the pointer that we're maintaining.  In other
        //     words, this is a referenced pointer, and the pointer must
        //     be dereferenced when processing of this SMB is complete.
        //

        WorkContext->Session = session;

        didLogon = TRUE;

    }

    //
    // Try to match pathname against available shared resources.  Note
    // that if SrvVerifyShare finds a matching share, it references it
    // and stores its address in WorkContext->Share.
    //

    share = SrvVerifyShare(
                WorkContext,
                (PSZ)request->Buffer + 1,
                service,
                SMB_IS_UNICODE( WorkContext ),
                session->IsNullSession,
                &status,
                NULL
                );

    //
    // If no match was found, return an error.
    //

    if ( share == NULL ) {

        if ( didLogon ) {
            SrvCloseSession( session );
        }
        SrvFreeTreeConnect( treeConnect );

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbTreeConnect: SrvVerifyShare failed for %s. Status = %x\n", request->Buffer+1, status ));
        }

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Impersonate the user so that we can capture his security context.
    // This is necessary in order to determine whether the user can
    // connect to the share.
    //

    status = IMPERSONATE( WorkContext );

    if( !NT_SUCCESS( status ) ) {
        SrvSetSmbError( WorkContext, status );
        if ( didLogon ) {
            SrvCloseSession( session );
        }
        SrvFreeTreeConnect( treeConnect );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    SeCaptureSubjectContext( &subjectContext );

    //
    // Set up the desired access on the share, based on whether the
    // server is paused.  If the server is paused, admin privilege is
    // required to connect to any share; if the server is not paused,
    // admin privilege is required only for admin shares (C$, etc.).
    //

    if ( SrvPaused ) {
        desiredAccess = SRVSVC_PAUSED_SHARE_CONNECT;
    } else {
        desiredAccess = SRVSVC_SHARE_CONNECT;
    }

    //
    // Check whether the user has access to this share.
    //

    if ( !SeAccessCheck(
              share->SecurityDescriptor,
              &subjectContext,
              FALSE,
              desiredAccess,
              0L,
              NULL,
              &SrvShareConnectMapping,
              UserMode,
              &grantedAccess,
              &status
              ) ) {

        IF_SMB_DEBUG(TREE2) {
            KdPrint(( "SrvSmbTreeConnect: SeAccessCheck failed: %X\n",
                           status ));
        }

        //
        // Release the subject context and revert to the server's security
        // context.
        //

        SeReleaseSubjectContext( &subjectContext );

        REVERT( );

        if ( SrvPaused ) {
            SrvSetSmbError( WorkContext, STATUS_SHARING_PAUSED );
            status = STATUS_SHARING_PAUSED;
        } else {
            SrvSetSmbError( WorkContext, status );
        }

        if ( didLogon ) {
            SrvCloseSession( session );
        }
        SrvFreeTreeConnect( treeConnect );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    ASSERT( grantedAccess == desiredAccess );

    //
    // Release the subject context and revert to the server's security
    // context.
    //

    SeReleaseSubjectContext( &subjectContext );

    REVERT( );


    //
    // Let the license server know
    //
    if( share->ShareType != ShareTypePipe ) {

        status = SrvXsLSOperation( session, XACTSRV_MESSAGE_LSREQUEST );

        if( !NT_SUCCESS( status ) ) {
            if ( didLogon ) {
                SrvCloseSession( session );
            }
            SrvFreeTreeConnect( treeConnect );

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvSmbTreeConnect: License server returned %X\n",
                               status ));
            }

            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }
    }

    //
    // Making a new tree connect visible is a three-step operation.  It
    // must be inserted in the containing share's tree connect list, the
    // global ordered tree connect list, and the containing connection's
    // tree connect table.  We need to make these operations appear
    // atomic, so that the tree connect cannot be accessed elsewhere
    // before we're done setting it up.  In order to do this, we hold
    // all necessary locks the entire time we're doing the three
    // operations.  The first and second operations are protected by the
    // global share lock (SrvShareLock), while the third operation is
    // protected by the per-connection lock.  We take out the share lock
    // first, then the connection lock.  This ordering is required by
    // lock levels (see lock.h).
    //
    // Another problem here is that the checking of the share state, the
    // inserting of the tree connect on the share's list, and the
    // referencing of the share all need to be atomic.  (The same holds
    // for the connection actions.)  Normally this would not be a
    // problem, because we could just hold the share lock while doing
    // all three actions.  However, in this case we also need to hold
    // the connection lock, and we can't call SrvReferenceShare while
    // doing that.  To get around this problem, we reference the share
    // _before_ taking out the locks, and dereference after releasing
    // the locks if we decide not to insert the tree connect.
    //

    status = SrvReferenceShareForTreeConnect( share );

    //
    // SrvReferenceShareForTreeConnect will fail if it cannot open the
    // share root directory for some reason.  If this happens,
    // fail the tree connect attempt.
    //

    if ( !NT_SUCCESS(status) ) {

        if ( didLogon ) {
            SrvCloseSession( session );
        }
        SrvFreeTreeConnect( treeConnect );

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbTreeConnect: open of share root failed:%X\n",
                           status ));
        }

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    ACQUIRE_LOCK( &SrvShareLock );
    ASSERT( SrvTreeConnectList.Lock == &SrvShareLock );
    ACQUIRE_LOCK( &connection->Lock );

    //
    // We first check all conditions to make sure that we can actually
    // insert this tree connect block.
    //
    // Make sure that the share isn't closing, and that there aren't
    // already too many uses on this share.
    //

    if ( GET_BLOCK_STATE(share) != BlockStateActive ) {

        //
        // The share is closing.  Reject the request.
        //

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbTreeConnect: Share %wZ (0x%p) is closing\n",
                        &share->ShareName, share ));
        }

        status = STATUS_INVALID_PARAMETER;
        goto cant_insert;

    }

    if ( share->CurrentUses > share->MaxUses ) {

        //
        // The share is full.  Reject the request.
        //

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbTreeConnect: No more uses available for share %wZ (0x%p), max = %ld\n",
                        &share->ShareName, share, share->MaxUses ));
        }

        status = STATUS_REQUEST_NOT_ACCEPTED;
        goto cant_insert;

    }

    //
    // Make sure that the connection isn't closing.
    //

    if ( GET_BLOCK_STATE(connection) != BlockStateActive ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbTreeConnect: Connection closing\n" ));
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_PARAMETER );
        status = STATUS_INVALID_PARAMETER;
        goto cant_insert;

    }

    //
    // Find a TID that can be used for this tree connect.
    //

    tableHeader = &pagedConnection->TreeConnectTable;
    if ( tableHeader->FirstFreeEntry == -1
         &&
         SrvGrowTable(
             tableHeader,
             SrvInitialTreeTableSize,
             SrvMaxTreeTableSize,
             &TableStatus ) == FALSE
       ) {

        //
        // No free entries in the tree table.  Reject the request.
        //

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbTreeConnect: No more TIDs available.\n" ));
        }

        status = TableStatus;

        if( TableStatus == STATUS_INSUFF_SERVER_RESOURCES )
        {
            SrvLogTableFullError( SRV_TABLE_TREE_CONNECT );
        }
        goto cant_insert;

    }

    tidIndex = tableHeader->FirstFreeEntry;

    //
    // All conditions have been satisfied.  We can now do the things
    // necessary to make the tree connect visible.
    //
    // Increment the count of uses for the share.  Link the tree connect
    // into the list of active tree connects for the share.  Save the
    // share address in the tree connect.  Note that we referenced the
    // share earlier, before taking out the connection lock.
    //

    SrvInsertTailList(
        &share->TreeConnectList,
        &treeConnect->ShareListEntry
        );

    treeConnect->Share = share;

    //
    // Remove the TID slot from the free list and set its owner and
    // sequence number.  Create a TID for the tree connect.
    //

    entry = &tableHeader->Table[tidIndex];

    tableHeader->FirstFreeEntry = entry->NextFreeEntry;
    DEBUG entry->NextFreeEntry = -2;
    if ( tableHeader->LastFreeEntry == tidIndex ) {
        tableHeader->LastFreeEntry = -1;
    }

    entry->Owner = treeConnect;

    INCREMENT_TID_SEQUENCE( entry->SequenceNumber );
    if ( tidIndex == 0 && entry->SequenceNumber == 0 ) {
        INCREMENT_TID_SEQUENCE( entry->SequenceNumber );
    }
    treeConnect->Tid = MAKE_TID( tidIndex, entry->SequenceNumber );

    IF_SMB_DEBUG(TREE1) {
        KdPrint(( "Found TID.  Index = 0x%lx, sequence = 0x%lx\n",
                    TID_INDEX( treeConnect->Tid ),
                    TID_SEQUENCE( treeConnect->Tid ) ));
    }

    //
    // Reference the connection to account for the active tree connect.
    //

    SrvReferenceConnection( connection );
    treeConnect->Connection = connection;

    if( session )
    {
        SrvReferenceSession( session );
        treeConnect->Session = session;
    }

    //
    // Link the tree connect into the global list of tree connects.
    //

    SrvInsertEntryOrderedList( &SrvTreeConnectList, treeConnect );

    //
    // If this session is the one controlling the extended security signatures,
    // see if we need to hash the session key
    //
    if( session->SessionKeyState == SrvSessionKeyAuthenticating )
    {
        // Downlevel machines that use a simple TREE_CONNECT (instead of TREE_CONNECT_ANDX)
        // don't understand extended signatures, so we can make the session key availible.
        // Note that if the REQUIRE_EXTENDED_SIGNATURES policy is active, that check occurred
        // above.
        session->SessionKeyState = SrvSessionKeyAvailible;
    }

    //
    // Release the locks used to make this operation appear atomic.
    //

    RELEASE_LOCK( &connection->Lock );
    RELEASE_LOCK( &SrvShareLock );

    //
    // Get the qos information for this connection
    //

    SrvUpdateVcQualityOfService ( connection, NULL );

    //
    // Tree connect successfully created.  Because the tree connect was
    // created with an initial reference count of 2, dereference it now.
    //
    // *** Don't bother to save the tree connect address in the work
    //     context block, because we're going to forget our pointers
    //     soon anyway (we're done with the request).  TreeConnectAndX
    //     has to remember these things, though.
    //

    SrvDereferenceTreeConnect( treeConnect );

    //
    // Set up response SMB.
    //

    SmbPutAlignedUshort( &WorkContext->ResponseHeader->Tid, treeConnect->Tid );

    response->WordCount = 2;
    SmbPutUshort( &response->MaxBufferSize, (USHORT)session->MaxBufferSize );
    SmbPutUshort( &response->Tid, treeConnect->Tid  );
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = NEXT_LOCATION(
                                        response,
                                        RESP_TREE_CONNECT,
                                        0
                                        );

    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbTreeConnect complete.\n" ));
    SmbStatus = SmbStatusSendResponse;
    goto Cleanup;

cant_insert:

    //
    // We get here if for some reason we decide that we can't insert
    // the tree connect.  On entry, status contains the reason code.
    // The connection lock and the share lock are held.
    //

    RELEASE_LOCK( &connection->Lock );
    RELEASE_LOCK( &SrvShareLock );

    if ( didLogon ) {
        SrvCloseSession( session );
    }

    SrvDereferenceShareForTreeConnect( share );

    SrvFreeTreeConnect( treeConnect );

    SrvSetSmbError( WorkContext, status );
    SmbStatus = SmbStatusSendResponse;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;
} // SrvSmbTreeConnect


SMB_PROCESSOR_RETURN_TYPE
SrvSmbTreeConnectAndX (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes a tree connect and X SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{

    PREQ_TREE_CONNECT_ANDX request;
    PRESP_TREE_CONNECT_ANDX response;
    PRESP_EXTENDED_TREE_CONNECT_ANDX responseExtended;
    PRESP_21_TREE_CONNECT_ANDX response21;

    NTSTATUS   status    = STATUS_SUCCESS;
    NTSTATUS   TableStatus;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    PCONNECTION connection;
    PPAGED_CONNECTION pagedConnection;
    PTABLE_HEADER tableHeader;
    PTABLE_ENTRY entry;
    SHORT tidIndex;
    PSHARE share;
    PTREE_CONNECT treeConnect;
    PVOID shareName;
    PUCHAR shareType;
    USHORT shareNameLength;
    USHORT reqAndXOffset;
    UCHAR nextCommand;
    PSZ shareString;
    USHORT shareStringLength;
    USHORT RequestFlags;
    USHORT byteCount;
    USHORT maxByteCount;
    PUCHAR smbBuffer;
    PSESSION session;
    SECURITY_SUBJECT_CONTEXT subjectContext;
    ACCESS_MASK desiredAccess;
    ACCESS_MASK grantedAccess;
    BOOLEAN isUnicode;
    UNICODE_STRING serverName;
    BOOLEAN remapPipeNames = FALSE;
    BOOLEAN KeyHashed = FALSE;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_TREE_CONNECT_AND_X;
    SrvWmiStartContext(WorkContext);

    IF_SMB_DEBUG(TREE1) {
        KdPrint(( "Tree connect and X request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader, WorkContext->ResponseHeader ));
        KdPrint(( "Tree connect and X request parameters at 0x%p, response parameters at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters ));
    }

    //
    // Set up parameters.
    //

    request = (PREQ_TREE_CONNECT_ANDX)(WorkContext->RequestParameters);
    response = (PRESP_TREE_CONNECT_ANDX)(WorkContext->ResponseParameters);
    responseExtended = (PRESP_EXTENDED_TREE_CONNECT_ANDX)(WorkContext->ResponseParameters);
    response21 = (PRESP_21_TREE_CONNECT_ANDX)(WorkContext->ResponseParameters);

    //
    // If bit 0 of Flags is set, disconnect tree in header TID.  We must
    // get the appropriate tree connect pointer.  SrvVerifyTid does this
    // for us, referencing the tree connect and storing the pointer in
    // the work context block.  We have to dereference the block and
    // erase the pointer after calling SrvCloseTreeConnect.
    //

    if ( (SmbGetUshort( &request->Flags ) & 1) != 0 ) {

        if ( SrvVerifyTid(
                WorkContext,
                SmbGetAlignedUshort( &WorkContext->RequestHeader->Tid )
                ) == NULL ) {

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvSmbTreeConnectAndX: Invalid TID to disconnect: 0x%lx\n",
                    SmbGetAlignedUshort( &WorkContext->RequestHeader->Tid ) ));
            }

            //
            // Just ignore an invalid TID--this is what the LM 2.0
            // server does.
            //

        } else {

            SrvCloseTreeConnect( WorkContext->TreeConnect );

            SrvDereferenceTreeConnect( WorkContext->TreeConnect );
            WorkContext->TreeConnect = NULL;

        }

    }

    //
    // Validate the UID in the header and get a session pointer.  We need
    // the user's token to check whether they can access this share.
    //

    session = SrvVerifyUid(
                  WorkContext,
                  SmbGetAlignedUshort( &WorkContext->RequestHeader->Uid )
                  );

    //
    // If we couldn't find a valid session fail the tree connect.
    //

    if ( session == NULL ) {

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbTreeConnectAndX: rejecting tree connect for "
                       "session %p due to server paused.\n", session ));
        }

        SrvSetSmbError( WorkContext, STATUS_SMB_BAD_UID );
        status    = STATUS_SMB_BAD_UID;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }
    else if( session->IsSessionExpired )
    {
        status = SESSION_EXPIRED_STATUS_CODE;
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Try to match pathname against available shared resources.  Note
    // that if SrvVerifyShare finds a matching share, it references it
    // and stores its address in WorkContext->Share.
    //

    shareName = (PSZ)request->Buffer +
                    SmbGetUshort( &request->PasswordLength );

    connection = WorkContext->Connection;
    pagedConnection = connection->PagedConnection;

    isUnicode = SMB_IS_UNICODE( WorkContext );

    if ( isUnicode ) {
        shareName = ALIGN_SMB_WSTR( shareName );
    }

    shareNameLength = SrvGetStringLength(
                                    shareName,
                                    END_OF_REQUEST_SMB( WorkContext ),
                                    SMB_IS_UNICODE( WorkContext ),
                                    TRUE        // include null terminator
                                    );

    //
    // if share name is bogus, return an error.
    //

    if ( shareNameLength == (USHORT)-1 ) {

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbTreeConnectAndX: pathname is bogus.\n"));
        }

        SrvSetSmbError( WorkContext, STATUS_BAD_NETWORK_NAME );
        status    = STATUS_BAD_NETWORK_NAME;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    shareType = (PCHAR)shareName + shareNameLength;

    share = SrvVerifyShare(
                WorkContext,
                shareName,
                shareType,
                isUnicode,
                session->IsNullSession,
                &status,
                &serverName
                );

    //
    // If no match was found, return an error.
    //

    if ( share == NULL ) {

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbTreeConnectAndX: pathname does not match "
                        "any shares: %s\n", shareName ));
        }

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // If the the client is connecting with a netbiosless transport and the name of the
    //  server which the client was requesting doesn't match any of our servernames, then
    //  the client has accidentally connected to the wrong server.  Let the client know.
    //
    if( !SrvDisableStrictNameChecking &&
        serverName.Buffer != NULL &&
        connection->Endpoint->IsNoNetBios &&
        SrvIsDottedQuadAddress( &serverName ) == FALSE &&
        SrvFindNamedEndpoint( &serverName, NULL ) == FALSE &&
        SrvIsLocalHost( &serverName ) == FALSE ) {

        BOOL bBadName = TRUE;

        // Last check, make sure its not the domain DNS name (which may differ from the NETBIOS DNS name)
        ACQUIRE_LOCK_SHARED( &SrvEndpointLock );

        // We only check up to the first ., so ntdev.microsoft.com would match SrvDnsDomainName "NTDEV"
        // Strip off the excess info for the check, then put it back
        if( SrvDnsDomainName ) {
            if( SrvDnsDomainName->Length <= serverName.Length )
            {
                USHORT oldLength = serverName.Length;
                serverName.Length = SrvDnsDomainName->Length;

                if( RtlEqualUnicodeString( &serverName, SrvDnsDomainName, TRUE ) )
                {
                    bBadName = FALSE;
                }

                serverName.Length = oldLength;
            }
        }

        RELEASE_LOCK( &SrvEndpointLock );

        //
        // The client has connected to this server in error--turn the client back!
        //
        if( bBadName )
        {
            SrvSetSmbError( WorkContext,  STATUS_DUPLICATE_NAME );
            status    = STATUS_DUPLICATE_NAME;
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }
    }

    //
    // Impersonate the user so that we can capture his security context.
    // This is necessary in order to determine whether the user can
    // connect to the share.
    //

    status = IMPERSONATE( WorkContext );
    if( !NT_SUCCESS( status ) ) {
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    SeCaptureSubjectContext( &subjectContext );

    //
    // Set up the desired access on the share, based on whether the
    // server is paused.  If the server is paused, admin privilege is
    // required to connect to any share; if the server is not paused,
    // admin privilege is required only for admin shares (C$, etc.).
    //

    if ( SrvPaused ) {
        desiredAccess = SRVSVC_PAUSED_SHARE_CONNECT;
    } else {
        desiredAccess = SRVSVC_SHARE_CONNECT;
    }

    //
    // Check whether the user has access to this share.
    //

    if ( !SeAccessCheck(
              share->SecurityDescriptor,
              &subjectContext,
              FALSE,
              desiredAccess,
              0L,
              NULL,
              &SrvShareConnectMapping,
              UserMode,
              &grantedAccess,
              &status
              ) ) {

        IF_SMB_DEBUG(TREE2) {
            KdPrint(( "SrvSmbTreeConnectAndX: SeAccessCheck failed: %X\n",
                           status ));
        }

        //
        // Release the subject context and revert to the server's security
        // context.
        //

        SeReleaseSubjectContext( &subjectContext );

        REVERT( );

        if ( SrvPaused ) {
            SrvSetSmbError( WorkContext, STATUS_SHARING_PAUSED );
            status = STATUS_SHARING_PAUSED;
        } else {
            SrvSetSmbError( WorkContext, status );
        }

        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    ASSERT( grantedAccess == desiredAccess );

    //
    // Release the subject context and revert to the server's security
    // context.
    //

    SeReleaseSubjectContext( &subjectContext );

    REVERT( );

    //
    // See if the license server wants to let this person in on the NTAS
    //
    if( share->ShareType != ShareTypePipe ) {

        status = SrvXsLSOperation( session, XACTSRV_MESSAGE_LSREQUEST );

        if( !NT_SUCCESS( status ) ) {

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvSmbTreeConnectAndX: License server returned %X\n",
                               status ));
            }

            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

    } else if( serverName.Buffer != NULL ) {

        //
        // This is the IPC$ share.  See if we're supposed to remap pipe names
        //
        SrvFindNamedEndpoint( &serverName, &remapPipeNames );

    }

    //
    // Allocate a tree connect block.
    //

    SrvAllocateTreeConnect( &treeConnect, serverName.Buffer ? &serverName : NULL );

    if ( treeConnect == NULL ) {

        //
        // Unable to allocate tree connect.  Return an error to the
        // client.
        //

        SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
        status    = STATUS_INSUFF_SERVER_RESOURCES;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    treeConnect->RemapPipeNames = remapPipeNames;

    //
    // Making a new tree connect visible is a three-step operation.  It
    // must be inserted in the containing share's tree connect list, the
    // global ordered tree connect list, and the containing connection's
    // tree connect table.  We need to make these operations appear
    // atomic, so that the tree connect cannot be accessed elsewhere
    // before we're done setting it up.  In order to do this, we hold
    // all necessary locks the entire time we're doing the three
    // operations.  The first and second operations are protected by the
    // global share lock (SrvShareLock), while the third operation is
    // protected by the per-connection lock.  We take out the share lock
    // first, then the connection lock.  This ordering is required by
    // lock levels (see lock.h).
    //
    // Another problem here is that the checking of the share state, the
    // inserting of the tree connect on the share's list, and the
    // referencing of the share all need to be atomic.  (The same holds
    // for the connection actions.)  Normally this would not be a
    // problem, because we could just hold the share lock while doing
    // all three actions.  However, in this case we also need to hold
    // the connection lock, and we can't call SrvReferenceShare while
    // doing that.  To get around this problem, we reference the share
    // _before_ taking out the locks, and dereference after releasing
    // the locks if we decide not to insert the tree connect.
    //

    status = SrvReferenceShareForTreeConnect( share );

    //
    // SrvReferenceShareForTreeConnect will fail if it cannot open the
    // share root directory for some reason.  If this happens,
    // fail the tree connect attempt.
    //

    if ( !NT_SUCCESS(status) ) {

        SrvFreeTreeConnect( treeConnect );

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbTreeConnectAndX: open of share root failed:%X\n",
                           status ));
        }

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    ACQUIRE_LOCK( &SrvShareLock );
    ASSERT( SrvTreeConnectList.Lock == &SrvShareLock );
    ACQUIRE_LOCK( &connection->Lock );

    if( SrvRequireExtendedSignatures )
    {
        // If we are requiring extended signatures, and the client has not
        // asked for them on this request or any previous request, deny
        // this request.
        if( session->SessionKeyState == SrvSessionKeyAuthenticating )
        {
            if ( !(request->Flags & TREE_CONNECT_ANDX_EXTENDED_SIGNATURES) ) {
                status    = STATUS_LOGIN_WKSTA_RESTRICTION;
                goto cant_insert;
            }
        }
    }

    // If they sent this uplevel flag on a downlevel request, than someone must
    // of been tricking us during negotiate.  Fail.
    if( (request->Flags & TREE_CONNECT_ANDX_EXTENDED_SIGNATURES) &&
        (connection->SmbDialect > SmbDialectDosLanMan21) )
    {
        status    = STATUS_DOWNGRADE_DETECTED;
        goto cant_insert;
    }


    //
    // We first check all conditions to make sure that we can actually
    // insert this tree connect block.
    //
    // Make sure that the share isn't closing, and that there aren't
    // already too many uses on this share.
    //

    if ( GET_BLOCK_STATE(share) != BlockStateActive ) {

        //
        // The share is closing.  Reject the request.
        //

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbTreeConnectAndX: Share %wZ (0x%p) is closing\n",
                        &share->ShareName, share ));
        }

        status = STATUS_INVALID_PARAMETER;
        goto cant_insert;

    }

    if ( share->CurrentUses > share->MaxUses ) {

        //
        // The share is full.  Reject the request.
        //

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbTreeConnectAndX: No more uses available for share %wZ (0x%p), max = %ld\n",
                        &share->ShareName, share, share->MaxUses ));
        }

        status = STATUS_REQUEST_NOT_ACCEPTED;
        goto cant_insert;

    }

    //
    // Make sure that the connection isn't closing, and that there's
    // room in its tree connect table.
    //

    if ( GET_BLOCK_STATE(connection) != BlockStateActive ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbTreeConnectAndX: Connection closing\n" ));
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_PARAMETER );
        status = STATUS_INVALID_PARAMETER;
        goto cant_insert;

    }

    //
    // Find a TID that can be used for this tree connect.
    //

    tableHeader = &pagedConnection->TreeConnectTable;
    if ( tableHeader->FirstFreeEntry == -1
         &&
         SrvGrowTable(
             tableHeader,
             SrvInitialTreeTableSize,
             SrvMaxTreeTableSize,
             &TableStatus ) == FALSE
       ) {

        //
        // No free entries in the tree table.  Reject the request.
        //

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbTreeConnect: No more TIDs available.\n" ));
        }

        if( TableStatus == STATUS_INSUFF_SERVER_RESOURCES )
        {
            SrvLogTableFullError( SRV_TABLE_TREE_CONNECT );
        }

        status = TableStatus;
        goto cant_insert;

    }

    tidIndex = tableHeader->FirstFreeEntry;

    //
    // All conditions have been satisfied.  We can now do the things
    // necessary to make the tree connect visible.
    //
    // Link the tree connect into the list of active tree connects for
    // the share.  Save the share address in the tree connect.  Note
    // that we referenced the share earlier, before taking out the
    // connection lock.
    //

    SrvInsertTailList(
        &share->TreeConnectList,
        &treeConnect->ShareListEntry
        );

    treeConnect->Share = share;

    //
    // Remove the TID slot from the free list and set its owner and
    // sequence number.  Create a TID for the tree connect.
    //

    entry = &tableHeader->Table[tidIndex];

    tableHeader->FirstFreeEntry = entry->NextFreeEntry;
    DEBUG entry->NextFreeEntry = -2;
    if ( tableHeader->LastFreeEntry == tidIndex ) {
        tableHeader->LastFreeEntry = -1;
    }

    entry->Owner = treeConnect;

    INCREMENT_TID_SEQUENCE( entry->SequenceNumber );
    if ( tidIndex == 0 && entry->SequenceNumber == 0 ) {
        INCREMENT_TID_SEQUENCE( entry->SequenceNumber );
    }
    treeConnect->Tid = MAKE_TID( tidIndex, entry->SequenceNumber );

    IF_SMB_DEBUG(TREE1) {
        KdPrint(( "Found TID.  Index = 0x%lx, sequence = 0x%lx\n",
                    TID_INDEX( treeConnect->Tid ),
                    TID_SEQUENCE( treeConnect->Tid ) ));
    }

    //
    // Reference the connection to account for the active tree connect.
    //

    SrvReferenceConnection( connection );
    treeConnect->Connection = connection;
    if( session )
    {
        SrvReferenceSession( session );
        treeConnect->Session = session;
    }

    //
    // Link the tree connect into the global list of tree connects.
    //

    SrvInsertEntryOrderedList( &SrvTreeConnectList, treeConnect );

    //
    // If this session is the one controlling the extended security signatures,
    // see if we need to hash the session key
    //
    if( session->SessionKeyState == SrvSessionKeyAuthenticating )
    {
        if (request->Flags & TREE_CONNECT_ANDX_EXTENDED_SIGNATURES) {
            // Hash the session key
            SrvHashUserSessionKey( session->NtUserSessionKey );
            KeyHashed = TRUE;
        }

        // This machine has either upgraded to hashed session key, or does not want to
        // Move to availible
        session->SessionKeyState = SrvSessionKeyAvailible;
    }

    //
    // Release the locks used to make this operation appear atomic.
    //

    RELEASE_LOCK( &connection->Lock );
    RELEASE_LOCK( &SrvShareLock );

    //
    // Get the qos information for this connection
    //

    SrvUpdateVcQualityOfService ( connection, NULL );

    //
    // Tree connect successfully created.  Save the tree connect block
    // address in the work context block.  Note that the reference count
    // on the new block was incremented on creation to account for our
    // reference to the block.
    //

    WorkContext->TreeConnect = treeConnect;

    //
    // Set up response SMB, making sure to save request fields first in
    // case the response overwrites the request.
    //

    reqAndXOffset = SmbGetUshort( &request->AndXOffset );
    nextCommand = request->AndXCommand;

    RequestFlags = SmbGetUshort(&request->Flags);

    SmbPutAlignedUshort( &WorkContext->RequestHeader->Tid, treeConnect->Tid );
    SmbPutAlignedUshort( &WorkContext->ResponseHeader->Tid, treeConnect->Tid );

    response->AndXCommand = nextCommand;
    response->AndXReserved = 0;

    if ( connection->SmbDialect > SmbDialectDosLanMan21) {
        response->WordCount = 2;
        smbBuffer = (PUCHAR)response->Buffer;
    } else {
        if (RequestFlags & TREE_CONNECT_ANDX_EXTENDED_RESPONSE) {
            responseExtended->WordCount = 7;
            smbBuffer = (PUCHAR)responseExtended->Buffer;
        } else {
            response21->WordCount = 3;
            smbBuffer = (PUCHAR)response21->Buffer;
        }

        // Fields common to 21 and extended response.
        response21->OptionalSupport = SMB_SUPPORT_SEARCH_BITS;

        if (share->IsDfs) {
            response21->OptionalSupport |= SMB_SHARE_IS_IN_DFS;
        }

        if (KeyHashed)
        {
            response21->OptionalSupport |= SMB_EXTENDED_SIGNATURES;
        }

        switch( share->CSCState ) {
        case CSC_CACHE_MANUAL_REINT:
            response21->OptionalSupport |= SMB_CSC_CACHE_MANUAL_REINT;
            break;
        case CSC_CACHE_AUTO_REINT:
            response21->OptionalSupport |= SMB_CSC_CACHE_AUTO_REINT;
            break;
        case CSC_CACHE_VDO:
            response21->OptionalSupport |= SMB_CSC_CACHE_VDO;
            break;
        case CSC_CACHE_NONE:
            response21->OptionalSupport |= SMB_CSC_NO_CACHING;
            break;
        }

        if( SrvNoAliasingOnFilesystem || (share->ShareProperties & SHI1005_FLAGS_ALLOW_NAMESPACE_CACHING) )
        {
            response21->OptionalSupport |= SMB_UNIQUE_FILE_NAME;
        }
    }

    // Calculate the size of the response buffer
    maxByteCount = (USHORT)(END_OF_RESPONSE_BUFFER(WorkContext) - smbBuffer + 1);

    //
    // Append the service name string to the SMB.  The service name
    // is always sent in ANSI.
    //

    shareString = StrShareTypeNames[share->ShareType];
    shareStringLength = (USHORT)( strlen( shareString ) + 1 );

    if( shareStringLength > maxByteCount )
    {
        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    RtlCopyMemory ( smbBuffer, shareString, shareStringLength );

    byteCount = shareStringLength;
    smbBuffer += shareStringLength;

    if ( connection->SmbDialect <= SmbDialectDosLanMan21 ) {

        //
        // Append the file system name to the response.
        // If the file system name is unavailable, supply the nul string
        // as the name.
        //

        if ( isUnicode ) {

            if ( ((ULONG_PTR)smbBuffer & 1) != 0 ) {
                smbBuffer++;
                byteCount++;
            }

            if ( share->Type.FileSystem.Name.Buffer != NULL ) {

                if( byteCount + share->Type.FileSystem.Name.Length > maxByteCount )
                {
                    SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
                    status    = STATUS_INVALID_SMB;
                    SmbStatus = SmbStatusSendResponse;
                    goto Cleanup;
                }

                RtlCopyMemory(
                    smbBuffer,
                    share->Type.FileSystem.Name.Buffer,
                    share->Type.FileSystem.Name.Length
                    );

                byteCount += share->Type.FileSystem.Name.Length;

            } else {

                *(PWCH)smbBuffer = UNICODE_NULL;
                byteCount += sizeof( UNICODE_NULL );

            }

        } else {

            if ( share->Type.FileSystem.Name.Buffer != NULL ) {

                if( byteCount + share->Type.FileSystem.OemName.Length > maxByteCount )
                {
                    SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
                    status    = STATUS_INVALID_SMB;
                    SmbStatus = SmbStatusSendResponse;
                    goto Cleanup;
                }

                RtlCopyMemory(
                    smbBuffer,
                    share->Type.FileSystem.OemName.Buffer,
                    share->Type.FileSystem.OemName.Length
                    );

                byteCount += share->Type.FileSystem.OemName.Length;

            } else {

                *(PUCHAR)smbBuffer = '\0';
                byteCount += 1;

            }

        }


        if (RequestFlags & TREE_CONNECT_ANDX_EXTENDED_RESPONSE) {
            PRESP_EXTENDED_TREE_CONNECT_ANDX ExtendedResponse;

            ExtendedResponse = (PRESP_EXTENDED_TREE_CONNECT_ANDX)response;

            SmbPutUshort( &ExtendedResponse->ByteCount, byteCount );

            SrvUpdateMaximalShareAccessRightsInResponse(
                WorkContext,
                &ExtendedResponse->MaximalShareAccessRights,
                &ExtendedResponse->GuestMaximalShareAccessRights);

            SmbPutUshort(
                &ExtendedResponse->AndXOffset,
                GET_ANDX_OFFSET(
                    WorkContext->ResponseHeader,
                    WorkContext->ResponseParameters,
                    RESP_EXTENDED_TREE_CONNECT_ANDX,
                    byteCount
                    )
                );
        } else {
            SmbPutUshort( &response21->ByteCount, byteCount );

            SmbPutUshort(
                &response->AndXOffset,
                GET_ANDX_OFFSET(
                    WorkContext->ResponseHeader,
                    WorkContext->ResponseParameters,
                    RESP_21_TREE_CONNECT_ANDX,
                    byteCount
                    )
                );
        }
    } else {  // if Smb dialect == LAN Man 2.1
        SmbPutUshort( &response->ByteCount, byteCount );

        SmbPutUshort(
            &response->AndXOffset,
            GET_ANDX_OFFSET(
                WorkContext->ResponseHeader,
                WorkContext->ResponseParameters,
                RESP_TREE_CONNECT_ANDX,
                byteCount
                )
            );
    }


    WorkContext->ResponseParameters = (PUCHAR)WorkContext->ResponseHeader +
                                        SmbGetUshort( &response->AndXOffset );

    //
    // Test for legal followon command.
    //

    switch ( nextCommand ) {
    case SMB_COM_NO_ANDX_COMMAND:
        break;

    case SMB_COM_OPEN:
    case SMB_COM_OPEN_ANDX:
    case SMB_COM_CREATE:
    case SMB_COM_CREATE_NEW:
    case SMB_COM_CREATE_DIRECTORY:
    case SMB_COM_DELETE:
    case SMB_COM_DELETE_DIRECTORY:
    case SMB_COM_SEARCH:
    case SMB_COM_FIND:
    case SMB_COM_FIND_UNIQUE:
    case SMB_COM_COPY:
    case SMB_COM_RENAME:
    case SMB_COM_NT_RENAME:
    case SMB_COM_CHECK_DIRECTORY:
    case SMB_COM_QUERY_INFORMATION:
    case SMB_COM_SET_INFORMATION:
    case SMB_COM_QUERY_INFORMATION_SRV:
    case SMB_COM_OPEN_PRINT_FILE:
    case SMB_COM_GET_PRINT_QUEUE:
    case SMB_COM_TRANSACTION:
        //
        // Make sure the AndX command is still within the received SMB
        //
        if( (PCHAR)WorkContext->RequestHeader + reqAndXOffset <=
            END_OF_REQUEST_SMB( WorkContext ) ) {
            break;
        }

        /* Falls Through */

    default:                            // Illegal followon command

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbTreeConnectAndX: Illegal followon command: 0x%c\n", nextCommand ));
        }

        SrvLogInvalidSmb( WorkContext );

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // If there is an AndX command, set up to process it.  Otherwise,
    // indicate completion to the caller.
    //

    if ( nextCommand != SMB_COM_NO_ANDX_COMMAND ) {

        // *** Watch out for overwriting request with response.

        WorkContext->NextCommand = nextCommand;

        WorkContext->RequestParameters = (PUCHAR)WorkContext->RequestHeader +
                                            reqAndXOffset;

        SmbStatus = SmbStatusMoreCommands;
        goto Cleanup;
    }

    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbTreeConnectAndX complete.\n" ));
    SmbStatus = SmbStatusSendResponse;
    goto Cleanup;

cant_insert:

    //
    // We get here if for some reason we decide that we can't insert
    // the tree connect.  On entry, status contains the reason code.
    // The connection lock and the share lock are held.
    //

    RELEASE_LOCK( &connection->Lock );
    RELEASE_LOCK( &SrvShareLock );

    SrvDereferenceShareForTreeConnect( share );

    SrvFreeTreeConnect( treeConnect );

    SrvSetSmbError( WorkContext, status );
    SmbStatus = SmbStatusSendResponse;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;
} // SrvSmbTreeConnectAndX


SMB_PROCESSOR_RETURN_TYPE
SrvSmbTreeDisconnect (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes a tree disconnect SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{
    PREQ_TREE_DISCONNECT request;
    PRESP_TREE_DISCONNECT response;
    PTREE_CONNECT treeConnect;
    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_TREE_DISCONNECT;
    SrvWmiStartContext(WorkContext);

    IF_SMB_DEBUG(TREE1) {
        KdPrint(( "Tree disconnect request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader, WorkContext->ResponseHeader ));
        KdPrint(( "Tree disconnect request parameters at 0x%p, response parameters at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters ));
    }

    //
    // Set up parameters.
    //

    request = (PREQ_TREE_DISCONNECT)(WorkContext->RequestParameters);
    response = (PRESP_TREE_DISCONNECT)(WorkContext->ResponseParameters);

    //
    // Find tree connect corresponding to given TID if a tree connect
    // pointer has not already been put in the WorkContext block by an
    // AndX command.
    //

    treeConnect = SrvVerifyTid(
                    WorkContext,
                    SmbGetAlignedUshort( &WorkContext->RequestHeader->Tid )
                    );

    if ( treeConnect == NULL ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbTreeDisconnect: Invalid TID: 0x%lx\n",
                SmbGetAlignedUshort( &WorkContext->RequestHeader->Tid ) ));
        }

        SrvSetSmbError( WorkContext, STATUS_SMB_BAD_TID );
        status    = STATUS_SMB_BAD_UID;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Do the actual tree disconnect.
    //

    SrvCloseTreeConnect( WorkContext->TreeConnect );

    //
    // Build the response SMB.
    //

    response->WordCount = 0;
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = NEXT_LOCATION(
                                        response,
                                        RESP_TREE_DISCONNECT,
                                        0
                                        );
    SmbStatus = SmbStatusSendResponse;
    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbTreeDisconnect complete.\n" ));

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbTreeDisconnect
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\smbtrans.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    smbtrans.c

Abstract:

    This module contains routines for processing the following SMBs:

        Transaction
        Transaction2

Author:

    Chuck Lenzmeier (chuckl) 19-Feb-1990

Revision History:

--*/

#include "precomp.h"
#include "smbtrans.tmh"
#include <align.h> // ROUND_UP_POINTER
#pragma hdrstop

#define BugCheckFileId SRV_FILE_SMBTRANS

#define MAX_SETUP_COUNT 128

//
// Forward declarations
//

SMB_STATUS SRVFASTCALL
ExecuteTransaction (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
RestartTransactionResponse (
    IN PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
RestartIpxMultipieceSend (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
RestartIpxTransactionResponse (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
MailslotTransaction (
    PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
RestartMailslotWrite (
    IN OUT PWORK_CONTEXT WorkContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, ExecuteTransaction )
#pragma alloc_text( PAGE, SrvCompleteExecuteTransaction )
#pragma alloc_text( PAGE, SrvFindTransaction )
#pragma alloc_text( PAGE, SrvInsertTransaction )
#pragma alloc_text( PAGE, RestartTransactionResponse )
#pragma alloc_text( PAGE, SrvSmbTransaction )
#pragma alloc_text( PAGE, SrvSmbTransactionSecondary )
#pragma alloc_text( PAGE, SrvSmbNtTransaction )
#pragma alloc_text( PAGE, SrvSmbNtTransactionSecondary )
#pragma alloc_text( PAGE, MailslotTransaction )
#pragma alloc_text( PAGE, RestartMailslotWrite )
#pragma alloc_text( PAGE, SrvRestartExecuteTransaction )
#pragma alloc_text( PAGE, RestartIpxMultipieceSend )
#pragma alloc_text( PAGE, RestartIpxTransactionResponse )
#endif


SMB_STATUS SRVFASTCALL
ExecuteTransaction (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Executes a transaction and starts the process of sending the
    zero or more responses.

Arguments:

    WorkContext - Supplies a pointer to a work context block.  The block
        contains information about the last SMB received for the
       transaction.

        WorkContext->Parameters.Transaction supplies a referenced
        pointer to a transaction block.  All block pointer fields in the
        block are valid.  Pointers to the setup words and parameter and
        data bytes, and the lengths of these items, are valid.  The
        transaction block is on the connection's pending transaction
        list.

Return Value:

    SMB_STATUS - Indicates the status of SMB processing.

--*/

{
    PTRANSACTION transaction;
    PSMB_HEADER header;
    PRESP_TRANSACTION response;
    PRESP_NT_TRANSACTION ntResponse;
    SMB_TRANS_STATUS resultStatus;
    CLONG offset;
    USHORT command;
    NTSTATUS status;

    PAGED_CODE( );

    resultStatus = SmbTransStatusErrorWithoutData;

    transaction = WorkContext->Parameters.Transaction;

    if ( (WorkContext->NextCommand == SMB_COM_TRANSACTION ||
          WorkContext->NextCommand == SMB_COM_TRANSACTION_SECONDARY ) &&
         transaction->RemoteApiRequest &&
         WorkContext->UsingLpcThread == 0 ) {

        //
        // This is a downlevel API request, we must make sure we are on
        // a blocking thread before handling it, since it will LPC to the
        // srvsvc which might take some time to complete.
        //
        WorkContext->FspRestartRoutine = ExecuteTransaction;
        status = SrvQueueWorkToLpcThread( WorkContext, TRUE );
        if( !NT_SUCCESS(status) )
        {
            SrvSetSmbError(
                WorkContext,
                status
                );

            return SmbTransStatusErrorWithoutData;
        }

        return SmbStatusInProgress;
    }

    header = WorkContext->ResponseHeader;
    response = (PRESP_TRANSACTION)WorkContext->ResponseParameters;
    ntResponse = (PRESP_NT_TRANSACTION)WorkContext->ResponseParameters;

    //
    // Setup output pointers
    //

    if ( WorkContext->NextCommand == SMB_COM_NT_TRANSACT ||
         WorkContext->NextCommand == SMB_COM_NT_TRANSACT_SECONDARY ) {
        transaction->OutSetup = (PSMB_USHORT)ntResponse->Buffer;
    } else {
        transaction->OutSetup = (PSMB_USHORT)response->Buffer;
    }

    if ( transaction->OutParameters == NULL ) {

        //
        // Parameters will go into the SMB buffer.  Calculate the pointer
        // then round it up to the next DWORD address.
        //

        transaction->OutParameters = (PCHAR)(transaction->OutSetup +
            transaction->MaxSetupCount);
        offset = (PTR_DIFF(transaction->OutParameters, header) + 3) & ~3;
        transaction->OutParameters = (PCHAR)header + offset;
    }

    if ( transaction->OutData == NULL ) {

        //
        // Data will go into the SMB buffer.  Calculate the pointer
        // then round it up to the next DWORD address.
        //

        transaction->OutData = transaction->OutParameters +
            transaction->MaxParameterCount;
        offset = (PTR_DIFF(transaction->OutData, header) + 3) & ~3;
        transaction->OutData = (PCHAR)header + offset;
    }

    //
    // If this is a Transaction2 request, then we can simply index into
    // a table to find the right transaction processor.  If it's a
    // Transaction request, we have to do more complicated things to
    // determine what to do.
    //

    if ( (WorkContext->NextCommand == SMB_COM_TRANSACTION) ||
         (WorkContext->NextCommand == SMB_COM_TRANSACTION_SECONDARY) ) {

        //
        // Dispatching for Transaction SMBs
        //

        if ( transaction->RemoteApiRequest ) {

           //
           // This is a down-level remote API request.  Send it to
           // XACTSRV for processing.
           //

           ASSERT( transaction->PipeRequest );

           resultStatus = SrvXsRequest( WorkContext );

        } else if ( transaction->PipeRequest ) {

            //
            // Normal pipe function.  Handle it.
            //

            command = SmbGetUshort(&transaction->InSetup[0]);

            //
            // If this operation may block, and we are running short of
            // free work items, fail this SMB with an out of resources error.
            //

            if ( !WorkContext->BlockingOperation &&
                 (command == TRANS_CALL_NMPIPE ||
                  command == TRANS_TRANSACT_NMPIPE ||
                  command == TRANS_WAIT_NMPIPE ||
                  command == TRANS_RAW_WRITE_NMPIPE) ) {

                if ( SrvReceiveBufferShortage( ) ) {

                    SrvStatistics.BlockingSmbsRejected++;

                    SrvSetSmbError(
                        WorkContext,
                        STATUS_INSUFF_SERVER_RESOURCES
                        );

                    resultStatus = SmbTransStatusErrorWithoutData;
                    goto exit;

                } else {

                    //
                    // SrvBlockingOpsInProgress has already been incremented.
                    // Flag this work item as a blocking operation.
                    //

                    WorkContext->BlockingOperation = TRUE;

                }

            }


            switch( command ) {

            case TRANS_TRANSACT_NMPIPE:
                resultStatus = SrvTransactNamedPipe( WorkContext );
                break;

            case TRANS_PEEK_NMPIPE:
                resultStatus = SrvPeekNamedPipe( WorkContext );
                break;

            case TRANS_CALL_NMPIPE:
                resultStatus = SrvCallNamedPipe( WorkContext );
                break;

            case TRANS_WAIT_NMPIPE:
                resultStatus = SrvWaitNamedPipe( WorkContext );
                break;

            case TRANS_QUERY_NMPIPE_STATE:
                resultStatus = SrvQueryStateNamedPipe( WorkContext );
                break;

            case TRANS_SET_NMPIPE_STATE:
                resultStatus = SrvSetStateNamedPipe( WorkContext );
                break;

            case TRANS_QUERY_NMPIPE_INFO:
                resultStatus = SrvQueryInformationNamedPipe( WorkContext );
                break;

            case TRANS_RAW_WRITE_NMPIPE:
                resultStatus = SrvRawWriteNamedPipe( WorkContext );
                break;

            case TRANS_RAW_READ_NMPIPE:  // Legal command, unsupported by server
                SrvSetSmbError( WorkContext, STATUS_INVALID_PARAMETER );
                resultStatus = SmbTransStatusErrorWithoutData;
                break;

            case TRANS_WRITE_NMPIPE:
                resultStatus = SrvWriteNamedPipe( WorkContext );
                break;

            case TRANS_READ_NMPIPE:
                resultStatus = SrvReadNamedPipe( WorkContext );
                break;

            default:
                SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
                resultStatus = SmbTransStatusErrorWithoutData;

                SrvLogInvalidSmb( WorkContext );
            }

        } else if ( _wcsnicmp(
                        transaction->TransactionName.Buffer,
                        StrSlashMailslot,
                        UNICODE_SMB_MAILSLOT_PREFIX_LENGTH / sizeof(WCHAR)
                        ) == 0 ) {

            //
            // This is a mailslot transaction
            //

            resultStatus = MailslotTransaction( WorkContext );

        } else {

            //
            // This is not a named pipe transaction or a mailslot
            // transaction.  The server should never see these.
            //

            SrvSetSmbError( WorkContext, STATUS_NOT_IMPLEMENTED );
            resultStatus = SmbTransStatusErrorWithoutData;

        }

    } else if ( (WorkContext->NextCommand == SMB_COM_NT_TRANSACT) ||
         (WorkContext->NextCommand == SMB_COM_NT_TRANSACT_SECONDARY) ) {

        command = transaction->Function;

        if ( command >= NT_TRANSACT_MIN_FUNCTION &&
                command <= NT_TRANSACT_MAX_FUNCTION ) {

            //
            // Legal function code.  Call the processing routine.  The
            // transaction processor returns TRUE if it encountered an
            // error and updated the response header appropriately (by
            // calling SrvSetSmbError).  In this case, no transaction-
            // specific response data will be sent.
            //

            resultStatus =
                SrvNtTransactionDispatchTable[ command ]( WorkContext );

            IF_SMB_DEBUG(TRANSACTION1) {
                if ( resultStatus != SmbTransStatusSuccess ) {
                    SrvPrint0( "NT Transaction processor returned error\n" );
                }
            }

        } else {

            //
            // Either no setup words were sent, or the function code is
            // out-of-range.  Return an error.
            //

            IF_DEBUG(SMB_ERRORS) {
                SrvPrint1( "Invalid NT Transaction function code 0x%lx\n",
                           transaction->Function );
            }

            SrvLogInvalidSmb( WorkContext );

            SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
            resultStatus = SmbTransStatusErrorWithoutData;

        }

    } else if ( (WorkContext->NextCommand == SMB_COM_TRANSACTION2) ||
         (WorkContext->NextCommand == SMB_COM_TRANSACTION2_SECONDARY) ) {

        command = SmbGetUshort( &transaction->InSetup[0] );

        if ( (transaction->SetupCount >= 1) &&
             (command <= TRANS2_MAX_FUNCTION) ) {

            //
            // Legal function code.  Call the processing routine.  The
            // transaction processor returns TRUE if it encountered an
            // error and updated the response header appropriately (by
            // calling SrvSetSmbError).  In this case, no transaction-
            // specific response data will be sent.
            //

            resultStatus =
                SrvTransaction2DispatchTable[ command ]( WorkContext );

            IF_SMB_DEBUG(TRANSACTION1) {
                if ( resultStatus != SmbTransStatusSuccess ) {
                    SrvPrint0( "Transaction processor returned error\n" );
                }
            }

        } else {

            //
            // Either no setup words were sent, or the function code is
            // out-of-range.  Return an error.
            //

            IF_DEBUG(SMB_ERRORS) {
                if ( transaction->SetupCount <= 0 ) {
                    SrvPrint0( "No Transaction2 setup words\n" );
                } else {
                    SrvPrint1( "Invalid Transaction2 function code 0x%lx\n",
                                (ULONG)SmbGetUshort(
                                           &transaction->InSetup[0] ) );
                }
            }

            SrvLogInvalidSmb( WorkContext );

            SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
            resultStatus = SmbTransStatusErrorWithoutData;

        }

    } else {

        ASSERT( FALSE );

    }

exit:

    //
    // If the transaction call completed synchronously, generate the
    // response and send it.
    //
    // If the call will be completed asynchronously, then the handler
    // for that call will call SrvCompleteExectuteTransaction().
    //

    if ( resultStatus != SmbTransStatusInProgress ) {
        SrvCompleteExecuteTransaction(WorkContext, resultStatus);
    }

    return SmbStatusInProgress;

} // ExecuteTransaction


VOID
SrvCompleteExecuteTransaction (
    IN OUT PWORK_CONTEXT WorkContext,
    IN SMB_TRANS_STATUS ResultStatus
    )

/*++

Routine Description:

    This function completes the execution of a transaction and sends
    the response

Arguments:

    WorkContext - A pointer to the associated work context block.
    ResultStatus - The return code from the

--*/

{
    PTRANSACTION transaction;
    UCHAR transactionCommand;
    PSMB_HEADER header;
    PRESP_TRANSACTION response;
    PRESP_NT_TRANSACTION ntResponse;

    CLONG maxSize;

    PSMB_USHORT byteCountPtr;
    PCHAR paramPtr;
    CLONG paramLength;
    CLONG paramOffset;
    PCHAR dataPtr;
    CLONG dataLength;
    CLONG dataOffset;
    CLONG sendLength;

    BOOLEAN ntTransaction = FALSE;

    PAGED_CODE( );

    transaction = WorkContext->Parameters.Transaction;

    header = WorkContext->ResponseHeader;
    transactionCommand = (UCHAR)SmbGetUshort( &transaction->InSetup[0] );

    if ( ResultStatus == SmbTransStatusErrorWithoutData ) {

        USHORT flags = transaction->Flags;

        //
        // An error occurred, so no transaction-specific response data
        // will be returned.  Close the transaction and arrange for a
        // response message indicating the error to be returned.
        //

        IF_SMB_DEBUG(TRANSACTION1) {
            SrvPrint1( "Error response. Closing transaction 0x%p\n",
                        transaction );
        }

        SrvCloseTransaction( transaction );
        SrvDereferenceTransaction( transaction );

        //
        // If the NO_RESPONSE bit was set in the request, don't send a
        // response; instead, just close the transaction.  (If the
        // transaction arrived as part of an AndX chain, we need to send a
        // response anyway, to respond to the preceeding commands.)
        //

        if ( (flags & SMB_TRANSACTION_NO_RESPONSE) &&
             (header->Command == WorkContext->NextCommand) ) {

            if ( WorkContext->OplockOpen ) {
                SrvCheckDeferredOpenOplockBreak( WorkContext );
            }

            //
            // The Transaction request came by itself.  No response.
            //

            SrvDereferenceWorkItem( WorkContext );

            return;

        }

        //
        // Calculate the length of the response message.
        //

        sendLength = (CLONG)( (PCHAR)WorkContext->ResponseParameters -
                                (PCHAR)WorkContext->ResponseHeader );

        WorkContext->ResponseBuffer->DataLength = sendLength;
        WorkContext->ResponseHeader->Flags |= SMB_FLAGS_SERVER_TO_REDIR;

        //
        // Send the response.
        //

        SRV_START_SEND_2(
            WorkContext,
            SrvFsdRestartSmbAtSendCompletion,
            NULL,
            NULL
            );

        return;
    }

    //
    // The transaction has been executed, and transaction-specific
    // response data is to be returned.  The processing routine updated
    // the output pointers and counts appropriately.
    //

    ASSERT( transaction->SetupCount <= transaction->MaxSetupCount);
    ASSERT( transaction->ParameterCount <= transaction->MaxParameterCount);
    ASSERT( transaction->DataCount <= transaction->MaxDataCount);

    //
    // If the NO_RESPONSE bit was set in the request, don't send a
    // response; instead, just close the transaction.  (If the
    // transaction arrived as part of an AndX chain, we need to send a
    // response anyway, to respond to the preceeding commands.)
    //

    if ( (transaction->Flags & SMB_TRANSACTION_NO_RESPONSE) &&
        ResultStatus != SmbTransStatusErrorWithData ) {

        IF_SMB_DEBUG(TRANSACTION1) {
            SrvPrint1( "No response.  Closing transaction 0x%p\n",
                        transaction );
        }

        SrvCloseTransaction( transaction );
        SrvDereferenceTransaction( transaction );

        if ( header->Command == WorkContext->NextCommand ) {

            if ( WorkContext->OplockOpen ) {
                SrvCheckDeferredOpenOplockBreak( WorkContext );
            }

            SrvDereferenceWorkItem( WorkContext );

            //
            // The Transaction request came by itself.  No response.
            //

            return;

        } else {

            //
            // The Transaction request was part of an AndX chain.  Find
            // the preceding command in the chain and update it to
            // indicate that it is now the end of the chain.
            //

            PGENERIC_ANDX genericResponse;

            IF_SMB_DEBUG(TRANSACTION1) {
                SrvPrint0( "AndX chain.  Sending response anyway\n" );
            }

            genericResponse = (PGENERIC_ANDX)(header + 1);
            while( genericResponse->AndXCommand != WorkContext->NextCommand ) {
                genericResponse = (PGENERIC_ANDX)((PCHAR)header +
                              SmbGetUshort( &genericResponse->AndXOffset ) );
            }

            genericResponse->AndXCommand = SMB_COM_NO_ANDX_COMMAND;
            SmbPutUshort( &genericResponse->AndXOffset, 0 );

            //
            // Calculate the length of the response message.
            //

            sendLength = (CLONG)( (PCHAR)WorkContext->ResponseParameters -
                                    (PCHAR)WorkContext->ResponseHeader );

            WorkContext->ResponseBuffer->DataLength = sendLength;

            //
            // Send the response.
            //

            SRV_START_SEND_2(
                WorkContext,
                SrvFsdRestartSmbAtSendCompletion,
                NULL,
                NULL
                );

            return;
        }
    }

    //
    // The client wants a response.  Build the first (and possibly only)
    // response.  The last received SMB of the transaction request was
    // retained for this purpose.
    //

    response = (PRESP_TRANSACTION)WorkContext->ResponseParameters;
    ntResponse = (PRESP_NT_TRANSACTION)WorkContext->ResponseParameters;

    //
    // If the transaction arrived in multiple pieces, then we have to
    // put the correct command code in the response header.  (Note that
    // a multi-part transaction request cannot be sent as part of an
    // AndX chain, so we know it's safe to write into the header.)
    //

    if ( (WorkContext->NextCommand == SMB_COM_TRANSACTION) ||
         (WorkContext->NextCommand == SMB_COM_TRANSACTION2) ) {
       ;
    } else if ( WorkContext->NextCommand == SMB_COM_NT_TRANSACT ) {
       ntTransaction = TRUE;
    } else if ( WorkContext->NextCommand == SMB_COM_TRANSACTION_SECONDARY ) {
       header->Command = SMB_COM_TRANSACTION;
    } else if ( WorkContext->NextCommand == SMB_COM_TRANSACTION2_SECONDARY ) {
       header->Command = SMB_COM_TRANSACTION2;
    } else if ( WorkContext->NextCommand == SMB_COM_NT_TRANSACT_SECONDARY ) {
       header->Command = SMB_COM_NT_TRANSACT;
       ntTransaction = TRUE;
    }

    //
    // Is this an NT transaction?  If so format an nt transaction
    // response.  The response formats for transact and transact2
    // are essentially identical.
    //
    // Build the parameters portion of the response.
    //

    if ( ntTransaction ) {
        ntResponse->WordCount = (UCHAR)(18 + transaction->SetupCount);
        ntResponse->Reserved1 = 0;
        SmbPutUshort( &ntResponse->Reserved2, 0 );
        SmbPutUlong( &ntResponse->TotalParameterCount,
                     transaction->ParameterCount
                     );
        SmbPutUlong( &ntResponse->TotalDataCount,
                     transaction->DataCount
                     );
        ntResponse->SetupCount = (UCHAR)transaction->SetupCount;
    } else {
        response->WordCount = (UCHAR)(10 + transaction->SetupCount);
        SmbPutUshort( &response->TotalParameterCount,
                      (USHORT)transaction->ParameterCount
                      );
        SmbPutUshort( &response->TotalDataCount,
                      (USHORT)transaction->DataCount
                      );
        SmbPutUshort( &response->Reserved, 0 );
        response->SetupCount = (UCHAR)transaction->SetupCount;
        response->Reserved2 = 0;
    }

    //
    // Save a pointer to the byte count field.
    //
    // If the output data and parameters are not already in the SMB
    // buffer we must calculate how much of the parameters and data can
    // be sent in this response.  The maximum amount we can send is
    // minimum of the size of our buffer and the size of the client's
    // buffer.
    //
    // The parameter and data byte blocks are aligned on longword
    // boundaries in the message.
    //

    byteCountPtr = transaction->OutSetup + transaction->SetupCount;

    //
    // Either we have a session, in which case the client's buffer sizes
    // are contained therein, or someone put the size in the transaction.
    // There is one known instance of the latter: Kerberos authentication
    // that requires an extra negotiation leg.
    //

    maxSize = MIN(
                WorkContext->ResponseBuffer->BufferLength,
                transaction->Session ?
                  (CLONG)transaction->Session->MaxBufferSize :
                    transaction->cMaxBufferSize
                );

    if ( transaction->OutputBufferCopied ) {

        //
        // The response data was not written directly in the SMB
        // response buffer.  It must now be copied out of the transaction
        // block into the SMB.
        //

        paramPtr = (PCHAR)(byteCountPtr + 1);    // first legal location
        paramOffset = PTR_DIFF(paramPtr, header);// offset from start of header
        paramOffset = (paramOffset + 3) & ~3;    // round to next longword
        paramPtr = (PCHAR)header + paramOffset;  // actual location

        paramLength = transaction->ParameterCount;  // assume all parameters fit

        if ( (paramOffset + paramLength) > maxSize ) {

            //
            // Not all of the parameter bytes will fit.  Send the maximum
            // number of longwords that will fit.  Don't send any data bytes
            // in the first message.
            //

            paramLength = maxSize - paramOffset;    // max that will fit
            paramLength = paramLength & ~3;         // round down to longword

            dataLength = 0;                         // don't send data bytes
            dataOffset = 0;
            dataPtr = paramPtr + paramLength;       // make calculations work

        } else {

            //
            // All of the parameter bytes fit.  Calculate how many of the
            // data bytes fit.
            //

            dataPtr = paramPtr + paramLength;       // first legal location
            dataOffset = PTR_DIFF(dataPtr, header); // offset from start of header
            dataOffset = (dataOffset + 3) & ~3;     // round to next longword
            dataPtr = (PCHAR)header + dataOffset;   // actual location

            dataLength = transaction->DataCount;    // assume all data bytes fit

            if ( (dataOffset + dataLength) > maxSize ) {

                //
                // Not all of the data bytes will fit.  Send the maximum
                // number of longwords that will fit.
                //

                dataLength = maxSize - dataOffset;  // max that will fit
                dataLength = dataLength & ~3;       // round down to longword

            }

        }

        //
        // Copy the appropriate parameter and data bytes into the message.
        //
        // !!! Note that it would be possible to use the chain send
        //     capabilities of TDI to send the parameter and data bytes from
        //     their own buffers.  There is extra overhead involved in doing
        //     this, however, because the buffers must be locked down and
        //     mapped into system space so that the network drivers can look
        //     at them.
        //

        if ( paramLength != 0 ) {
            RtlMoveMemory( paramPtr, transaction->OutParameters, paramLength );
        }

        if ( dataLength != 0 ) {
            RtlMoveMemory( dataPtr, transaction->OutData, dataLength );
        }


    } else {

        //
        // The data and paramter are already in the SMB buffer.  The entire
        // response will fit in one response buffer and there is no copying
        // to do.
        //

        paramPtr = transaction->OutParameters;
        paramOffset = PTR_DIFF(paramPtr, header);
        paramLength = transaction->ParameterCount;

        dataPtr = transaction->OutData;
        dataOffset = PTR_DIFF(dataPtr, header);
        dataLength = transaction->DataCount;

    }

    //
    // Finish filling in the response parameters.
    //

    if ( ntTransaction ) {
        SmbPutUlong( &ntResponse->ParameterCount, paramLength );
        SmbPutUlong( &ntResponse->ParameterOffset, paramOffset );
        SmbPutUlong( &ntResponse->ParameterDisplacement, 0 );

        SmbPutUlong( &ntResponse->DataCount, dataLength );
        SmbPutUlong( &ntResponse->DataOffset, dataOffset );
        SmbPutUlong( &ntResponse->DataDisplacement, 0 );
    } else {
        SmbPutUshort( &response->ParameterCount, (USHORT)paramLength );
        SmbPutUshort( &response->ParameterOffset, (USHORT)paramOffset );
        SmbPutUshort( &response->ParameterDisplacement, 0 );

        SmbPutUshort( &response->DataCount, (USHORT)dataLength );
        SmbPutUshort( &response->DataOffset, (USHORT)dataOffset );
        SmbPutUshort( &response->DataDisplacement, 0 );
    }

    transaction->ParameterDisplacement = paramLength;
    transaction->DataDisplacement = dataLength;

    SmbPutUshort(
        byteCountPtr,
        (USHORT)(dataPtr - (PCHAR)(byteCountPtr + 1) + dataLength)
        );

    //
    // Calculate the length of the response message.
    //

    sendLength = (CLONG)( dataPtr + dataLength -
                                (PCHAR)WorkContext->ResponseHeader );

    WorkContext->ResponseBuffer->DataLength = sendLength;

    //
    // Set the bit in the SMB that indicates this is a response from the
    // server.
    //

    WorkContext->ResponseHeader->Flags |= SMB_FLAGS_SERVER_TO_REDIR;

    //
    // If this isn't the last part of the response, inhibit statistics
    // gathering.  If it is the last part of the response, restore the
    // start time to the work context block.
    //
    // If this isn't the last part of the response, tell TDI that we
    // do not expect back traffic, so that the client will immediately
    // ACK this packet, rather than waiting.
    //

    if ( (paramLength != transaction->ParameterCount) ||
         (dataLength != transaction->DataCount) ) {

        ASSERT( transaction->Inserted );
        WorkContext->StartTime = 0;

        //
        // Save the address of the transaction block in the work context
        // block.  Send out the response.  When the send completes,
        // RestartTransactionResponse is called to either send the next
        // message or close the transaction.
        //
        //
        // Note that the transaction block remains referenced while the
        // response is being sent.
        //

        WorkContext->Parameters.Transaction = transaction;
        WorkContext->ResponseBuffer->Mdl->ByteCount = sendLength;

        if ( WorkContext->Endpoint->IsConnectionless ) {

            WorkContext->FspRestartRoutine = RestartIpxMultipieceSend;
            WorkContext->FsdRestartRoutine = NULL;
            transaction->MultipieceIpxSend = TRUE;

            SrvIpxStartSend( WorkContext, SrvQueueWorkToFspAtSendCompletion );

        } else {

            SRV_START_SEND(
                WorkContext,
                WorkContext->ResponseBuffer->Mdl,
                TDI_SEND_NO_RESPONSE_EXPECTED,
                SrvQueueWorkToFspAtSendCompletion,
                NULL,
                RestartTransactionResponse
                );
        }

    } else {

        //
        // This is the final piece. Close the transaction.
        //

        WorkContext->StartTime = transaction->StartTime;

        SrvCloseTransaction( transaction );
        SrvDereferenceTransaction( transaction );

        //
        // Send the response.
        //

        SRV_START_SEND_2(
            WorkContext,
            SrvFsdRestartSmbAtSendCompletion,
            NULL,
            NULL
            );
    }

    //
    // The response send is in progress.  The caller will assume
    // the we will handle send completion.
    //

    return;

} // SrvCompleteExecuteTransaction


PTRANSACTION
SrvFindTransaction (
    IN PCONNECTION Connection,
    IN PSMB_HEADER Header,
    IN USHORT Fid OPTIONAL
    )

/*++

Routine Description:

    Searches the list of pending transactions for a connection, looking
    for one whose identity matches that of a received secondary
    Transaction(2) request.  If one is found, it is referenced.

Arguments:

    Connection - Supplies a pointer to the connection block for the
        connection on which the secondary request was received.

    Header - Supplies a pointer to the header of the received
        Transaction(2) Secondary SMB.

    Fid - The file handle for this operation.  The parameter is required
       if operation is progress is a WriteAndX SMB.

Return Value:

    PTRANSACTION - Returns a pointer to the matching transaction block,
        if one is found, else NULL.

--*/

{
    PLIST_ENTRY listEntry;
    PTRANSACTION thisTransaction;

    USHORT targetOtherInfo;

    PAGED_CODE( );

    //
    // If this is a multipiece transaction SMB, the MIDs of all the pieces
    // must match.  If it is a multipiece WriteAndX protocol the pieces
    // using the FID.
    //

    if (Header->Command == SMB_COM_WRITE_ANDX) {
        targetOtherInfo = Fid;
    } else {
        targetOtherInfo = SmbGetAlignedUshort( &Header->Mid );
    }

    //
    // Acquire the transaction lock.  This prevents the connection's
    // transaction list from changing while we walk it.
    //

    ACQUIRE_LOCK( &Connection->Lock );

    //
    // Walk the transaction list, looking for one with the same
    // identity as the new transaction.
    //

    for ( listEntry = Connection->PagedConnection->TransactionList.Flink;
          listEntry != &Connection->PagedConnection->TransactionList;
          listEntry = listEntry->Flink ) {

        thisTransaction = CONTAINING_RECORD(
                            listEntry,
                            TRANSACTION,
                            ConnectionListEntry
                            );

        if ( ( thisTransaction->Tid == SmbGetAlignedUshort( &Header->Tid ) ) &&
             ( thisTransaction->Pid == SmbGetAlignedUshort( &Header->Pid ) ) &&
             ( thisTransaction->Uid == SmbGetAlignedUshort( &Header->Uid ) ) &&
             ( thisTransaction->OtherInfo == targetOtherInfo ) ) {

            //
            // A transaction with the same identity has been found.  If
            // it's still active, reference it and return its address.
            // Otherwise, return a NULL pointer to indicate that a valid
            // matching transaction was not found.
            //

            if ( GET_BLOCK_STATE(thisTransaction) == BlockStateActive ) {

                SrvReferenceTransaction( thisTransaction );

                RELEASE_LOCK( &Connection->Lock );

                return thisTransaction;

            } else {

                RELEASE_LOCK( &Connection->Lock );
                return NULL;

            }

        }

    } // for

    //
    // We made it all the way through the list without finding a
    // matching transaction.  Return a NULL pointer.
    //

    RELEASE_LOCK( &Connection->Lock );

    return NULL;

} // SrvFindTransaction


BOOLEAN
SrvInsertTransaction (
    IN PTRANSACTION Transaction
    )

/*++

Routine Description:

    Inserts a transaction block into the list of pending transactions
    for a connection.  Prior to doing so, it ensures a transaction
    with the same identity (combination of TID, PID, UID, and MID)
    is not already in the list.

Arguments:

    Transaction - Supplies a pointer to a transaction block.  The
        Connection, Tid, Pid, Uid, and Mid fields must be valid.

Return Value:

    BOOLEAN - Returns TRUE if the transaction block was inserted.
        Returns FALSE if the block was not inserted because a
        transaction with the same identity already exists in the list.

--*/

{
    PCONNECTION connection;
    PPAGED_CONNECTION pagedConnection;
    PLIST_ENTRY listEntry;
    PTRANSACTION thisTransaction;

    PAGED_CODE( );

    ASSERT( !Transaction->Inserted );

    //
    // Acquire the transaction lock.  This prevents the connection's
    // transaction list from changing while we walk it.
    //

    connection = Transaction->Connection;
    pagedConnection = connection->PagedConnection;

    ACQUIRE_LOCK( &connection->Lock );

    //
    // Make sure the connection, session, and tree connect aren't
    // closing, so that we don't put the transaction on the list
    // after the list has been run down.
    //

    if ( (GET_BLOCK_STATE(connection) != BlockStateActive) ||
         ((Transaction->Session != NULL) &&
            (GET_BLOCK_STATE(Transaction->Session) != BlockStateActive)) ||
         ((Transaction->TreeConnect != NULL) &&
            (GET_BLOCK_STATE(Transaction->TreeConnect) != BlockStateActive)) ) {

        RELEASE_LOCK( &connection->Lock );
        return FALSE;
    }

    //
    // Walk the transaction list, looking for one with the same
    // identity as the new transaction.
    //

    for ( listEntry = pagedConnection->TransactionList.Flink;
          listEntry != &pagedConnection->TransactionList;
          listEntry = listEntry->Flink ) {

        thisTransaction = CONTAINING_RECORD(
                            listEntry,
                            TRANSACTION,
                            ConnectionListEntry
                            );

        if ( (thisTransaction->Tid == Transaction->Tid) &&
             (thisTransaction->Pid == Transaction->Pid) &&
             (thisTransaction->Uid == Transaction->Uid) &&
             (thisTransaction->OtherInfo == Transaction->OtherInfo) ) {

            //
            // A transaction with the same identity has been found.
            // Don't insert the new one in the list.
            //

            RELEASE_LOCK( &connection->Lock );

            return FALSE;

        }

    } // for

    //
    // We made it all the way through the list without finding a
    // matching transaction.  Insert the new one at the tail of the
    // list.
    //

    SrvInsertTailList(
        &pagedConnection->TransactionList,
        &Transaction->ConnectionListEntry
        );

    Transaction->Inserted = TRUE;

    RELEASE_LOCK( &connection->Lock );

    return TRUE;

} // SrvInsertTransaction


VOID SRVFASTCALL
RestartTransactionResponse (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes send completion for a Transaction response.  If more
    responses are required, it builds and sends the next one.  If all
    responses have been sent, it closes the transaction.

Arguments:

    WorkContext - Supplies a pointer to a work context block.  The
        block contains information about the last SMB received for
        the transaction.

        WorkContext->Parameters.Transaction supplies a referenced
        pointer to a transaction block.  All block pointer fields in the
        block are valid.  Pointers to the setup words and parameter and
        data bytes, and the lengths of these items, are valid.  The
        transaction block is on the connection's pending transaction
        list.

Return Value:

    None.

--*/

{
    PTRANSACTION transaction;
    PSMB_HEADER header;
    PRESP_TRANSACTION response;
    PRESP_NT_TRANSACTION ntResponse;
    PCONNECTION connection;

    CLONG maxSize;

    PSMB_USHORT byteCountPtr;
    PCHAR paramPtr;
    CLONG paramLength;
    CLONG paramOffset;
    CLONG paramDisp;
    PCHAR dataPtr;
    CLONG dataLength;
    CLONG dataOffset;
    CLONG dataDisp;
    CLONG sendLength;

    BOOLEAN ntTransaction;

    PAGED_CODE( );

    transaction = WorkContext->Parameters.Transaction;
    paramDisp = transaction->ParameterDisplacement;
    dataDisp = transaction->DataDisplacement;

    IF_DEBUG(WORKER1) SrvPrint0( " - RestartTransactionResponse\n" );

    //
    // Get the connection pointer.  The connection pointer is a
    // referenced pointer.
    //

    connection = WorkContext->Connection;
    IF_DEBUG(TRACE2) {
        SrvPrint2( "  connection 0x%p, endpoint 0x%p\n",
                    connection, WorkContext->Endpoint );
    }

    //
    // If the I/O request failed or was canceled, or if the connection
    // is no longer active, clean up.  (The connection is marked as
    // closing when it is disconnected or when the endpoint is closed.)
    //
    // !!! If I/O failure, should we drop the connection?
    //

    if ( WorkContext->Irp->Cancel ||
          !NT_SUCCESS(WorkContext->Irp->IoStatus.Status) ||
          (GET_BLOCK_STATE(connection) != BlockStateActive) ) {

        IF_DEBUG(TRACE2) {
            if ( WorkContext->Irp->Cancel ) {
                SrvPrint0( "  I/O canceled\n" );
            } else if ( !NT_SUCCESS(WorkContext->Irp->IoStatus.Status) ) {
                SrvPrint1( "  I/O failed: %X\n",
                            WorkContext->Irp->IoStatus.Status );
            } else {
                SrvPrint0( "  Connection no longer active\n" );
            }
        }

        //
        // Close the transaction.  Indicate that SMB processing is
        // complete.
        //

        IF_DEBUG(ERRORS) {
            SrvPrint1( "I/O error. Closing transaction 0x%p\n", transaction );
        }
        SrvCloseTransaction( transaction );
        SrvDereferenceTransaction( transaction );

        if ( WorkContext->OplockOpen ) {
            SrvCheckDeferredOpenOplockBreak( WorkContext );
        }
        SrvEndSmbProcessing( WorkContext, SmbStatusNoResponse );

        IF_DEBUG(TRACE2) {
            SrvPrint0( "RestartTransactionResponse complete\n" );
        }
        return;

    }

    IF_SMB_DEBUG(TRANSACTION1) {
        SrvPrint2( "Continuing transaction response; block 0x%p, name %wZ\n",
                    transaction, &transaction->TransactionName );
        SrvPrint3( "Connection 0x%p, session 0x%p, tree connect 0x%p\n",
                    transaction->Connection, transaction->Session,
                    transaction->TreeConnect );
        SrvPrint2( "Remaining: parameters %ld bytes, data %ld bytes\n",
                    transaction->ParameterCount - paramDisp,
                    transaction->DataCount - dataDisp );
    }

    //
    // Update the parameters portion of the response, reusing the last
    // SMB.
    //

    ASSERT( transaction->Inserted );

    header = WorkContext->ResponseHeader;
    response = (PRESP_TRANSACTION)WorkContext->ResponseParameters;
    ntResponse = (PRESP_NT_TRANSACTION)WorkContext->ResponseParameters;

    if ( WorkContext->NextCommand == SMB_COM_NT_TRANSACT ||
         WorkContext->NextCommand == SMB_COM_NT_TRANSACT_SECONDARY ) {

        ntTransaction = TRUE;
        ntResponse->WordCount = (UCHAR)18;
        ntResponse->SetupCount = 0;

        //
        // Save a pointer to the byte count field.  Calculate how much of
        // the parameters and data can be sent in this response.  The
        // maximum amount we can send is minimum of the size of our buffer
        // and the size of the client's buffer.
        //
        // The parameter and data byte blocks are aligned on longword
        // boundaries in the message.
        //

        byteCountPtr = (PSMB_USHORT)ntResponse->Buffer;

    } else {

        ntTransaction = FALSE;
        response->WordCount = (UCHAR)10;
        response->SetupCount = 0;

        //
        // Save a pointer to the byte count field.  Calculate how much of
        // the parameters and data can be sent in this response.  The
        // maximum amount we can send is minimum of the size of our buffer
        // and the size of the client's buffer.
        //
        // The parameter and data byte blocks are aligned on longword
        // boundaries in the message.
        //

        byteCountPtr = (PSMB_USHORT)response->Buffer;
    }

    //
    // Either we have a session, in which case the client's buffer sizes
    // are contained therein, or someone put the size in the transaction.
    // There is one known instance of the latter: Kerberos authentication
    // that requires an extra negotiation leg.
    //

    maxSize = MIN(
                WorkContext->ResponseBuffer->BufferLength,
                transaction->Session ?
                  (CLONG)transaction->Session->MaxBufferSize :
                    transaction->cMaxBufferSize
                );

    paramPtr = (PCHAR)(byteCountPtr + 1);       // first legal location
    paramOffset = PTR_DIFF(paramPtr, header);   // offset from start of header
    paramOffset = (paramOffset + 3) & ~3;       // round to next longword
    paramPtr = (PCHAR)header + paramOffset;     // actual location

    paramLength = transaction->ParameterCount - paramDisp;
                                                // assume all parameters fit

    if ( (paramOffset + paramLength) > maxSize ) {

        //
        // Not all of the parameter bytes will fit.  Send the maximum
        // number of longwords that will fit.  Don't send any data bytes
        // in this message.
        //

        paramLength = maxSize - paramOffset;    // max that will fit
        paramLength = paramLength & ~3;         // round down to longword

        dataLength = 0;                         // don't send data bytes
        dataOffset = 0;
        dataPtr = paramPtr + paramLength;       // make calculations work

    } else {

        //
        // All of the parameter bytes fit.  Calculate how many of data
        // bytes fit.
        //

        dataPtr = paramPtr + paramLength;       // first legal location
        dataOffset = PTR_DIFF(dataPtr, header); // offset from start of header
        dataOffset = (dataOffset + 3) & ~3;     // round to next longword
        dataPtr = (PCHAR)header + dataOffset;   // actual location

        dataLength = transaction->DataCount - dataDisp;
                                                // assume all data bytes fit

        if ( (dataOffset + dataLength) > maxSize ) {

            //
            // Not all of the data bytes will fit.  Send the maximum
            // number of longwords that will fit.
            //

            dataLength = maxSize - dataOffset;  // max that will fit
            dataLength = dataLength & ~3;       // round down to longword

        }

    }

    //
    // Finish filling in the response parameters.
    //

    if ( ntTransaction) {
        SmbPutUlong( &ntResponse->ParameterCount, paramLength );
        SmbPutUlong( &ntResponse->ParameterOffset, paramOffset );
        SmbPutUlong( &ntResponse->ParameterDisplacement, paramDisp );

        SmbPutUlong( &ntResponse->DataCount, dataLength );
        SmbPutUlong( &ntResponse->DataOffset, dataOffset );
        SmbPutUlong( &ntResponse->DataDisplacement, dataDisp );
    } else {
        SmbPutUshort( &response->ParameterCount, (USHORT)paramLength );
        SmbPutUshort( &response->ParameterOffset, (USHORT)paramOffset );
        SmbPutUshort( &response->ParameterDisplacement, (USHORT)paramDisp );

        SmbPutUshort( &response->DataCount, (USHORT)dataLength );
        SmbPutUshort( &response->DataOffset, (USHORT)dataOffset );
        SmbPutUshort( &response->DataDisplacement, (USHORT)dataDisp );
    }

    transaction->ParameterDisplacement = paramDisp + paramLength;
    transaction->DataDisplacement = dataDisp + dataLength;

    SmbPutUshort(
        byteCountPtr,
        (USHORT)(dataPtr - (PCHAR)(byteCountPtr + 1) + dataLength)
        );

    //
    // Copy the appropriate parameter and data bytes into the message.
    //
    // !!! Note that it would be possible to use the chain send
    //     capabilities of TDI to send the parameter and data bytes from
    //     their own buffers.  There is extra overhead involved in doing
    //     this, however, because the buffers must be locked down and
    //     mapped into system space so that the network drivers can look
    //     at them.
    //

    if ( paramLength != 0 ) {
        RtlMoveMemory(
            paramPtr,
            transaction->OutParameters + paramDisp,
            paramLength
            );
    }

    if ( dataLength != 0 ) {
        RtlMoveMemory(
            dataPtr,
            transaction->OutData + dataDisp,
            dataLength
            );
    }

    //
    // Calculate the length of the response message.
    //

    sendLength = (CLONG)( dataPtr + dataLength -
                                (PCHAR)WorkContext->ResponseHeader );

    WorkContext->ResponseBuffer->DataLength = sendLength;

    //
    // If this is the last part of the response, reenable statistics
    // gathering and restore the start time to the work context block.
    //

    if ( ((paramLength + paramDisp) == transaction->ParameterCount) &&
         ((dataLength + dataDisp) == transaction->DataCount) ) {

        //
        // This is the final piece. Close the transaction.
        //

        WorkContext->StartTime = transaction->StartTime;

        SrvCloseTransaction( transaction );
        SrvDereferenceTransaction( transaction );

        //
        // Send the response.
        //

        SRV_START_SEND_2(
            WorkContext,
            SrvFsdRestartSmbAtSendCompletion,
            NULL,
            NULL
            );


    } else {

        // If this isn't the last part of the response, tell TDI that we
        // do not expect back traffic, so that the client will immediately
        // ACK this packet, rather than waiting.

        WorkContext->ResponseBuffer->Mdl->ByteCount = sendLength;

        //
        // Send out the response.  When the send completes,
        // RestartTransactionResponse is called to either send the next
        // message or close the transaction.
        //
        // Note that the response bit in the SMB header is already set.
        //

        SRV_START_SEND(
            WorkContext,
            WorkContext->ResponseBuffer->Mdl,
            TDI_SEND_NO_RESPONSE_EXPECTED,
            SrvQueueWorkToFspAtSendCompletion,
            NULL,
            RestartTransactionResponse
            );
    }

    //
    // The response send is in progress.
    //

    IF_DEBUG(TRACE2) SrvPrint0( "RestartTransactionResponse complete\n" );
    return;

} // RestartTransactionResponse


SMB_PROCESSOR_RETURN_TYPE
SrvSmbTransaction (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes a primary Transaction or Transaction2 SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;

    PREQ_TRANSACTION request;
    PSMB_HEADER header;

    PCONNECTION connection;
    PSESSION session;
    PTREE_CONNECT treeConnect;
    PTRANSACTION transaction;
    PCHAR trailingBytes;
    PCHAR startOfTrailingBytes;
    PVOID name;
    PVOID endOfSmb;

    CLONG setupOffset;
    CLONG setupCount;
    CLONG maxSetupCount;
    CLONG totalSetupCount;
    CLONG parameterOffset;
    CLONG parameterCount;       // For input on this buffer
    CLONG maxParameterCount;    // For output
    CLONG totalParameterCount;  // For input
    CLONG dataOffset;
    CLONG dataCount;            // For input on this buffer
    CLONG maxDataCount;         // For output
    CLONG totalDataCount;       // For input
    CLONG smbLength;

    CLONG outputBufferSize = (CLONG)-1;
    CLONG inputBufferSize = (CLONG)-1;
    CLONG requiredBufferSize;

    USHORT command;

    BOOLEAN pipeRequest;
    BOOLEAN remoteApiRequest;
    BOOLEAN buffersOverlap = FALSE;
    BOOLEAN noResponse;
    BOOLEAN singleBufferTransaction;
    BOOLEAN isUnicode;


    PAGED_CODE( );

    request = (PREQ_TRANSACTION)WorkContext->RequestParameters;
    header = WorkContext->RequestHeader;
    IF_SMB_DEBUG(TRANSACTION1) {
        SrvPrint1( "Transaction%s (primary) request\n",
                    (WorkContext->NextCommand == SMB_COM_TRANSACTION)
                    ? "" : "2" );
    }

    //
    // Make sure that the WordCount is correct to avoid any problems
    // with overrunning the SMB buffer.  SrvProcessSmb was unable to
    // verify WordCount because it is variable, but it did verify that
    // the supplied WordCount/ByteCount combination was valid.
    // Verifying WordCount here ensure that what SrvProcessSmb thought
    // was ByteCount really was, and that it's valid.  The test here
    // also implicit verifies SetupCount and that all of the setup words
    // are "in range".
    //

    if ( (ULONG)request->WordCount != (ULONG)(14 + request->SetupCount) ) {

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint3( "SrvSmbTransaction: Invalid WordCount: %ld, should be "
                      "SetupCount+14 = %ld+14 = %ld\n",
                      request->WordCount, request->SetupCount,
                      14 + request->SetupCount );
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Even though we know that WordCount and ByteCount are valid, it's
    // still possible that the offsets and lengths of the Parameter and
    // Data bytes are invalid.  So we check them now.
    //

    setupOffset = PTR_DIFF(request->Buffer, header);
    setupCount = request->SetupCount * sizeof(USHORT);
    maxSetupCount = request->MaxSetupCount * sizeof(USHORT);
    totalSetupCount = setupCount;

    parameterOffset = SmbGetUshort( &request->ParameterOffset );
    parameterCount = SmbGetUshort( &request->ParameterCount );
    maxParameterCount = SmbGetUshort( &request->MaxParameterCount );
    totalParameterCount = SmbGetUshort( &request->TotalParameterCount );

    dataOffset = SmbGetUshort( &request->DataOffset );
    dataCount = SmbGetUshort( &request->DataCount );
    maxDataCount = SmbGetUshort( &request->MaxDataCount );
    totalDataCount = SmbGetUshort( &request->TotalDataCount );

    smbLength = WorkContext->RequestBuffer->DataLength;

    if ( ( (setupOffset + setupCount) > smbLength ) ||
         ( (parameterOffset + parameterCount) > smbLength ) ||
         ( (dataOffset + dataCount) > smbLength ) ||
         ( dataCount > totalDataCount ) ||
         ( parameterCount > totalParameterCount ) ||
         ( setupCount > MAX_SETUP_COUNT) ) {

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint4( "SrvSmbTransaction: Invalid setup, parameter or data "
                      "offset+count: sOff=%ld,sCnt=%ld;pOff=%ld,pCnt=%ld;",
                      setupOffset, setupCount,
                      parameterOffset, parameterCount );
            SrvPrint2( "dOff=%ld,dCnt=%ld;", dataOffset, dataCount );
            SrvPrint1( "smbLen=%ld", smbLength );
        }

        SrvLogInvalidSmb( WorkContext );

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    singleBufferTransaction = (dataCount == totalDataCount) &&
                              (parameterCount == totalParameterCount);

    //
    // Should we return a final response?  If this is not a single buffer
    // transaction, we need to return an interim response regardless of the
    // no response flag.
    //

    noResponse = singleBufferTransaction &&
                    ((SmbGetUshort( &request->Flags ) &
                     SMB_TRANSACTION_NO_RESPONSE) != 0);

    //
    // Calculate buffer sizes.
    //
    // First determine whether this is a named pipe, LanMan RPC, or
    // mailslot transaction.  We avoid checking the transaction name
    // ("\PIPE\" or "\MAILSLOT\") by recognizing that Transaction SMB
    // must be one of the three, and that a mailslot write must have a
    // setup count of 3 (words) and command code of
    // TRANS_MAILSLOT_WRITE, and that a LanMan RPC must have a setup
    // count of 0.
    //

    command = SmbGetUshort( (PSMB_USHORT)&request->Buffer[0] );

    name = StrNull;
    endOfSmb = NULL;
    isUnicode = TRUE;

    ASSERT( TRANS_SET_NMPIPE_STATE == TRANS_MAILSLOT_WRITE );

    pipeRequest = (BOOLEAN)( (WorkContext->NextCommand == SMB_COM_TRANSACTION)
                             &&
                             ( (setupCount != 6) ||
                               ( (setupCount == 6) &&
                                 (command != TRANS_MAILSLOT_WRITE) ) ) );

    remoteApiRequest = (BOOLEAN)(pipeRequest && (setupCount == 0) );

    if ( pipeRequest && !remoteApiRequest ) {

        //
        // Step 1.  Have we received all of the input data and parameters?
        //
        // If so, we can generate the input buffers directly from the SMB
        // buffer.
        //
        // If not, then we must copy all of the pieces to a single buffer
        // which will are about to allocate.  Both parameters and data
        // must be dword aligned.
        //

        if ( singleBufferTransaction ) {

            /*

            This is a downlevel path that was optimized for speed in a special case, but taking it
            avoids a fair amount of the validation we normally do.  Since this is a rare path, we simply
            remove the optimization and allow the operation to flow as it normally would so all the validation takes
            place

            SMB_STATUS smbStatus;

            //
            // If this is a single buffer transact named pipe request, try
            // the server fast path.
            //

            if ( (command == TRANS_TRANSACT_NMPIPE) &&
                 SrvFastTransactNamedPipe( WorkContext, &smbStatus ) ) {
                SmbStatus =smbStatus;
                goto Cleanup;
            }
            */

            inputBufferSize = 0;
        } else {
            inputBufferSize = ((totalSetupCount * sizeof(UCHAR) + 3) & ~3) +
                              ((totalDataCount * sizeof(UCHAR) + 3) & ~3) +
                              ((totalParameterCount * sizeof(UCHAR) + 3) & ~3);
        }

        //
        // If a session block has not already been assigned to the current
        // work context, verify the UID.  If verified, the address of the
        // session block corresponding to this user is stored in the
        // WorkContext block and the session block is referenced.
        //
        // If a tree connect block has not already been assigned to the
        // current work context, find the tree connect corresponding to the
        // given TID.
        //

        status = SrvVerifyUidAndTid(
                    WorkContext,
                    &session,
                    &treeConnect,
                    ShareTypeWild
                    );

        if ( !NT_SUCCESS(status) ) {
            IF_DEBUG(SMB_ERRORS) {
                SrvPrint0( "SrvSmbTransaction: Invalid UID or TID\n" );
            }
            SrvSetSmbError( WorkContext, status );
            SmbStatus = noResponse ? SmbStatusNoResponse
                                   : SmbStatusSendResponse;
            goto Cleanup;
        }

        if( session->IsSessionExpired )
        {
            status = SESSION_EXPIRED_STATUS_CODE;
            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        //
        // Step 2. Can all the output data and paramter fit in the SMB
        // buffer?  If so then we do not need to allocate extra space.
        //

        //
        // Special case.  If this is a PEEK_NMPIPE call, then allocate
        // at least enough parameter bytes for the NT call.
        //
        // Since the SMB request normally asks for 6 parameter bytes,
        // and NT NPFS will return 16 parameter bytes, this allows us
        // to read the data and parameters directly from the NT call
        // into the transaction buffer.
        //
        // At completion time, we will reformat the paramters, but if
        // the data is read directly into the SMB buffer, there will
        // be no need to recopy it.
        //

        if ( command == TRANS_PEEK_NMPIPE) {
            maxParameterCount = MAX(
                                    maxParameterCount,
                                    4 * sizeof(ULONG)
                                    );
        }

        outputBufferSize = ((maxParameterCount * sizeof(CHAR) + 3) & ~3) +
                           ((maxDataCount * sizeof(CHAR) + 3) & ~3);

        if ( sizeof(SMB_HEADER) +
                sizeof (RESP_TRANSACTION) +
                sizeof(USHORT) * request->SetupCount +
                sizeof(USHORT) +
                outputBufferSize
                        <= (ULONG)session->MaxBufferSize) {
            outputBufferSize = 0;
        }

        //
        // Since input and output data and parameters can overlap, just
        // allocate a buffer big enough for the biggest possible buffer.
        //

        requiredBufferSize = MAX( inputBufferSize, outputBufferSize );

        //
        // If this is a call or wait named pipe operation, we need to
        // keep the pipe name in the transaction block.
        //

        if ( (command == TRANS_CALL_NMPIPE) ||
             (command == TRANS_WAIT_NMPIPE) ) {
            isUnicode = SMB_IS_UNICODE( WorkContext );
            name = ((PUSHORT)(&request->WordCount + 1) +
                                                    request->WordCount + 1);
            if ( isUnicode ) {
                name = ALIGN_SMB_WSTR( name );
            }
            endOfSmb = END_OF_REQUEST_SMB( WorkContext );
        }

        //
        // This is a named pipe transaction.  Input and output buffers
        // can safely overlap.
        //

        buffersOverlap = TRUE;

    } else {

        //
        // If a session block has not already been assigned to the current
        // work context, verify the UID.  If verified, the address of the
        // session block corresponding to this user is stored in the
        // WorkContext block and the session block is referenced.
        //
        // If a tree connect block has not already been assigned to the
        // current work context, find the tree connect corresponding to the
        // given TID.
        //

        status = SrvVerifyUidAndTid(
                    WorkContext,
                    &session,
                    &treeConnect,
                    ShareTypeWild
                    );

        if ( !NT_SUCCESS(status) ) {

            IF_DEBUG(SMB_ERRORS) {
                SrvPrint0( "SrvSmbTransaction: Invalid UID or TID\n" );
            }
            SrvSetSmbError( WorkContext, status );
            SmbStatus = noResponse ? SmbStatusNoResponse
                                   : SmbStatusSendResponse;
            goto Cleanup;
        }

        if( session->IsSessionExpired )
        {
            status = SESSION_EXPIRED_STATUS_CODE;
            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        //
        // This is a Transaction2 call or a mailslot or LanMan RPC
        // Transaction call.  Don't assume anything about the buffers.
        //
        // !!! It should be possible to be smarter about buffer space
        //     on Trans2 SMBs.  We should be able to overlap input
        //     and output as well as avoiding copies to and from
        //     the SMB buffer.
        //

        requiredBufferSize =
            ((totalSetupCount + 3) & ~3) + ((maxSetupCount + 3) & ~3) +
            ((totalParameterCount + 3) & ~3) + ((maxParameterCount + 3) & ~3) +
            ((totalDataCount + 3) & ~3) + ((maxDataCount + 3) & ~3);

        //
        // If this is a remote API request, check whether we have
        // initialized the connection with XACTSRV.
        //

        if ( remoteApiRequest ) {

            if ( SrvXsPortMemoryHeap == NULL ) {

                //
                // XACTSRV is not started.  Reject the request.
                //

                IF_DEBUG(ERRORS) {
                    SrvPrint0( "SrvSmbTransaction: The XACTSRV service is not started.\n" );
                }

                SrvSetSmbError( WorkContext, STATUS_NOT_SUPPORTED );
                status    = STATUS_NOT_SUPPORTED;
                SmbStatus = noResponse ? SmbStatusNoResponse
                                       : SmbStatusSendResponse;
                goto Cleanup;
            }

        } else if ( WorkContext->NextCommand == SMB_COM_TRANSACTION ) {

            //
            // We need to save the transaction name for mailslot writes.
            //

            isUnicode = SMB_IS_UNICODE( WorkContext );
            name = ((PUSHORT)(&request->WordCount + 1) +
                                                    request->WordCount + 1);
            if ( isUnicode ) {
                name = ALIGN_SMB_WSTR( name );
            }
            endOfSmb = END_OF_REQUEST_SMB( WorkContext );

        }

    }

    //
    // If there is a transaction secondary buffer on the way, ensure
    // that we have a free work item to receive it.  Otherwise fail
    // this SMB with an out of resources error.
    //

    if  ( !singleBufferTransaction ) {

        if ( SrvReceiveBufferShortage( ) ) {

            SrvStatistics.BlockingSmbsRejected++;

            SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
            status    = STATUS_INSUFF_SERVER_RESOURCES;
            SmbStatus = noResponse ? SmbStatusNoResponse
                                   : SmbStatusSendResponse;
            goto Cleanup;
        } else {

            //
            // SrvBlockingOpsInProgress has already been incremented.
            // Flag this work item as a blocking operation.
            //

            WorkContext->BlockingOperation = TRUE;

        }

    }

    //
    // Allocate a transaction block.  This block is used to retain
    // information about the state of the transaction.  This is
    // necessary because multiple SMBs are potentially sent and
    // received.
    //

    connection = WorkContext->Connection;

    SrvAllocateTransaction(
        &transaction,
        (PVOID *)&trailingBytes,
        connection,
        requiredBufferSize,
        name,
        endOfSmb,
        isUnicode,
        remoteApiRequest
        );

    if ( transaction == NULL ) {

        //
        // Unable to allocate transaction.  Return an error to the
        // client.  (The session and tree connect blocks are
        // dereferenced automatically.)
        //

        IF_DEBUG(ERRORS) {
            SrvPrint0( "Unable to allocate transaction\n" );
        }

        SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
        status    = STATUS_INSUFF_SERVER_RESOURCES;
        SmbStatus = noResponse ? SmbStatusNoResponse : SmbStatusSendResponse;
        goto Cleanup;
    }

    IF_SMB_DEBUG(TRANSACTION1) {
        SrvPrint1( "Allocated transaction 0x%p\n", transaction );
    }

    transaction->PipeRequest = pipeRequest;

    //
    // Save the connection, session, and tree connect pointers in the
    // transaction block.  If this transaction will NOT require multiple
    // SMB exchanges, the session and tree connect pointers are not
    // referenced pointers, because the work context block's pointers
    // will remain valid for the duration of the transaction.
    //

    transaction->Connection = connection;
    SrvReferenceConnection( connection );

    if ( session != NULL ) {

        transaction->Session = session;
        transaction->TreeConnect = treeConnect;

        if ( requiredBufferSize != 0 ) {
            SrvReferenceSession( session );
            SrvReferenceTreeConnect( treeConnect );
        }

    } else {
        IF_SMB_DEBUG(TRANSACTION1) {
            SrvPrint0( "SrvSmbTransaction - Session Setup: skipping session and tree connect reference.\n" );
        }
    }

    //
    // Save the TID, PID, UID, and MID from this request in the
    // transaction block.  These values are used to relate secondary
    // requests to the appropriate primary request.
    //

    transaction->Tid = SmbGetAlignedUshort( &header->Tid );
    transaction->Pid = SmbGetAlignedUshort( &header->Pid );
    transaction->Uid = SmbGetAlignedUshort( &header->Uid );
    transaction->OtherInfo = SmbGetAlignedUshort( &header->Mid );

    //
    // Save the time that the initial request SMB arrived, for use in
    // calculating the elapsed time for the entire transaction.
    //

    transaction->StartTime = WorkContext->StartTime;

    //
    // Save other sundry information, but don't load the ParameterCount
    // and DataCount fields until after copying the data.  This is to
    // prevent the reception of a secondary request prior to our
    // completion here from causing the transaction to be executed
    // twice.  (These fields are initialized to 0 during allocation.)
    //

    transaction->Timeout = SmbGetUlong( &request->Timeout );
    transaction->Flags = SmbGetUshort( &request->Flags );

    transaction->SetupCount = totalSetupCount;
    transaction->MaxSetupCount = maxSetupCount;

    transaction->TotalParameterCount = totalParameterCount;
    transaction->MaxParameterCount = maxParameterCount;

    transaction->TotalDataCount = totalDataCount;
    transaction->MaxDataCount = maxDataCount;

    startOfTrailingBytes = trailingBytes;

    //
    // Calculate the addresses of the various buffers.
    //

    if ( inputBufferSize != 0 ) {

        //
        // Input setup, parameters and data will be copied to a separate
        // buffer.
        //

        transaction->InSetup = (PSMB_USHORT)trailingBytes;
        trailingBytes += (totalSetupCount + 3) & ~3;

        transaction->InParameters = (PCHAR)trailingBytes;
        trailingBytes += (totalParameterCount + 3) & ~3;

        transaction->InData = (PCHAR)trailingBytes;
        trailingBytes += (totalDataCount + 3) & ~3;

        transaction->InputBufferCopied = TRUE;

    } else {

        //
        // Input parameters and data will be sent directly out of the
        // request buffer.
        //

        transaction->InSetup = (PSMB_USHORT)( (PCHAR)header + setupOffset );
        transaction->InParameters = (PCHAR)header + parameterOffset;
        transaction->InData = (PCHAR)header + dataOffset;
        transaction->InputBufferCopied = FALSE;
    }

    //
    // Setup the output data pointers.
    //

    transaction->OutSetup = (PSMB_USHORT)NULL;

    if ( buffersOverlap ) {

        //
        // The output buffer overlaps the input buffer.
        //

        trailingBytes = startOfTrailingBytes;
    }

    if ( outputBufferSize != 0 ) {

        //
        // The output is going into a separate buffer, to be copied
        // later into the response SMB buffer.
        //

        transaction->OutParameters = (PCHAR)trailingBytes;
        trailingBytes += (maxParameterCount + 3) & ~3;

        transaction->OutData = (PCHAR)trailingBytes;

        transaction->OutputBufferCopied = TRUE;

    } else {

        //
        // The data (and parameters) will be going into the response
        // SMB buffer, which may not be the one we are currently
        // processing.  So temporarily set these pointers to NULL.  The
        // correct pointers will be calculated at ExecuteTransaction time.
        //

        transaction->OutParameters = NULL;
        transaction->OutData = NULL;
        transaction->OutputBufferCopied = FALSE;
    }

    //
    // If this transaction will require multiple SMB exchanges, link the
    // transaction block into the connection's pending transaction list.
    // This will fail if there is already a transaction with the same
    // xID values in the list.
    //
    // !!! Need a way to prevent the transaction list from becoming
    //     clogged with pending transactions.
    //

    if ( (requiredBufferSize != 0) && !SrvInsertTransaction( transaction ) ) {

        //
        // A transaction with the same xIDs is already in progress.
        // Return an error to the client.
        //
        // *** Note that SrvDereferenceTransaction can't be used here
        //     because that routine assumes that the transaction is
        //     queued to the transaction list.
        //

        IF_SMB_DEBUG(TRANSACTION1) {
            SrvPrint0( "Duplicate transaction exists\n" );
        }

        SrvLogInvalidSmb( WorkContext );

        SrvDereferenceSession( session );
        DEBUG transaction->Session = NULL;

        SrvDereferenceTreeConnect( treeConnect );
        DEBUG transaction->TreeConnect = NULL;

        SrvFreeTransaction( transaction );

        SrvDereferenceConnection( connection );

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = noResponse ? SmbStatusNoResponse : SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Copy the setup, parameter and data bytes that arrived in the
    // primary SMB.
    //
    // !!! We could allow secondary requests to start by allocating a
    //     separate buffer for the interim response, sending the
    //     response, then copying the data.
    //

    if ( inputBufferSize != 0 ) {

        if ( setupCount != 0 ) {
            RtlMoveMemory(
                (PVOID)transaction->InSetup,
                (PCHAR)header + setupOffset,
                setupCount
                );
        }

        //
        // We can now check to see if we are doing a session setup trans2
        //

        if ( session == NULL ) {

            IF_SMB_DEBUG(TRANSACTION1) {
                SrvPrint0( "SrvSmbTransaction - Receiving a Session setup SMB\n");
            }
        }

        if ( parameterCount != 0 ) {
            RtlMoveMemory(
                transaction->InParameters,
                (PCHAR)header + parameterOffset,
                parameterCount
                );
        }

        if ( dataCount != 0 ) {
            RtlMoveMemory(
                transaction->InData,
                (PCHAR)header + dataOffset,
                dataCount
                );
        }

    }

    //
    // Update the received parameter and data counts.  If all of the
    // transaction bytes have arrived, execute it.  Otherwise, send
    // an interim response.
    //

    transaction->ParameterCount = parameterCount;
    transaction->DataCount = dataCount;

    if ( singleBufferTransaction ) {

        //
        // All of the data has arrived.  Execute the transaction.  When
        // ExecuteTransaction returns, the first (possibly only)
        // response, if any, has been sent.  Our work is done.
        //

        WorkContext->Parameters.Transaction = transaction;

        SmbStatus = ExecuteTransaction( WorkContext );
        goto Cleanup;
    } else {

        //
        // Not all of the data has arrived.  We have already queued the
        // transaction to the connection's transaction list.  We need to
        // send an interim response telling the client to send the
        // remaining data.  We also need to dereference the transaction
        // block, since we'll no longer have a pointer to it.
        //

        PRESP_TRANSACTION_INTERIM response;

        IF_SMB_DEBUG(TRANSACTION1) {
            SrvPrint0( "More transaction data expected.\n" );
        }

        ASSERT( transaction->Inserted );
        SrvDereferenceTransaction( transaction );

        response = (PRESP_TRANSACTION_INTERIM)WorkContext->ResponseParameters;
        response->WordCount = 0;
        SmbPutUshort( &response->ByteCount, 0 );
        WorkContext->ResponseParameters = NEXT_LOCATION(
                                            response,
                                            RESP_TRANSACTION_INTERIM,
                                            0
                                            );
        //
        // Inhibit statistics gathering -- this isn't the end of the
        // transaction.
        //

        WorkContext->StartTime = 0;

        SmbStatus = SmbStatusSendResponse;
    }

Cleanup:
    return SmbStatus;

} // SrvSmbTransaction


SMB_PROCESSOR_RETURN_TYPE
SrvSmbTransactionSecondary (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes a secondary Transaction or Transaction2 SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_TRANSACTION_SECONDARY request;
    PSMB_HEADER header;

    PTRANSACTION transaction;
    PCONNECTION connection;

    CLONG parameterOffset;
    CLONG parameterCount;
    CLONG parameterDisplacement;
    CLONG dataOffset;
    CLONG dataCount;
    CLONG dataDisplacement;
    CLONG smbLength;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;

    PAGED_CODE( );

    request = (PREQ_TRANSACTION_SECONDARY)WorkContext->RequestParameters;
    header = WorkContext->RequestHeader;

    IF_SMB_DEBUG(TRANSACTION1) {
        SrvPrint1( "Transaction%s (secondary) request\n",
                    (WorkContext->NextCommand == SMB_COM_TRANSACTION_SECONDARY)
                    ? "" : "2" );
    }

    //
    // Find the transaction block that matches this secondary request.
    // The TID, PID, UID, and MID in the headers of all messages in
    // a transaction are the same.  If a match is found, it is
    // referenced to prevent its deletion and its address is returned.
    //

    connection = WorkContext->Connection;

    transaction = SrvFindTransaction( connection, header, 0 );

    if ( transaction == NULL ) {

        //
        // Unable to find a matching transaction.  Ignore this SMB.
        //
        // !!! Is this the right thing to do?  It's what PIA does.
        //

        IF_DEBUG(ERRORS) {
            SrvPrint0( "No matching transaction.  Ignoring request.\n" );
        }
        SmbStatus = SmbStatusNoResponse;
        goto Cleanup;
    }

    ASSERT( transaction->Connection == connection );

    if( transaction->Session->IsSessionExpired )
    {
        status = SESSION_EXPIRED_STATUS_CODE;
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Ensure that the transaction isn't already complete.
    //     That is, that this is not a message accidentally added to a
    //     transaction that's already being executed.
    //


#if 0
    // !!! Apparently we don't get any secondary request on remote
    //     APIs, because this little piece of code causes an infinite
    //     loop because it doesn't check to see if it's already in a
    //     blocking thread.  And it's been here for 2-1/2 years!
    //     Besides, we don't do primary remote APIs in blocking threads,
    //     so why do secondaries?
    //
    // If this is a remote API request, send it off to a blocking thread
    // since it is possible for the operation to take a long time.
    //

    if ( transaction->RemoteApiRequest ) {

        DEBUG WorkContext->FsdRestartRoutine = NULL;
        WorkContext->FspRestartRoutine = SrvRestartSmbReceived;

        SrvQueueWorkToBlockingThread( WorkContext );
        SrvDereferenceTransaction( transaction );

        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }
#endif

    //
    // Unlike the Transaction[2] SMB, the Transaction[2] Secondary SMB
    // has a fixed WordCount, so SrvProcessSmb has already verified it.
    // But it's still possible that the offsets and lengths of the
    // Parameter and Data bytes are invalid.  So we check them now.
    //

    parameterOffset = SmbGetUshort( &request->ParameterOffset );
    parameterCount = SmbGetUshort( &request->ParameterCount );
    parameterDisplacement = SmbGetUshort( &request->ParameterDisplacement );
    dataOffset = SmbGetUshort( &request->DataOffset );
    dataCount = SmbGetUshort( &request->DataCount );
    dataDisplacement = SmbGetUshort( &request->DataDisplacement );

    //
    // See if this is a special ack by the client to tell us to send
    // the next piece of a multipiece response.
    //

    if ( transaction->MultipieceIpxSend ) {

        ASSERT( WorkContext->Endpoint->IsConnectionless );

        if ( (parameterCount == 0) && (parameterOffset == 0) &&
             (dataCount == 0) && (dataOffset == 0)) {

            //
            // got the ACK. Make sure the displacement numbers are reasonable.
            //

            if ( (dataDisplacement > transaction->DataCount) ||
                 (parameterDisplacement > transaction->ParameterCount) ) {

                IF_DEBUG(SMB_ERRORS) {
                    SrvPrint2( "SrvSmbTransactionSecondary: Invalid parameter or data "
                              "displacement: pDisp=%ld ;dDisp=%ld",
                              parameterDisplacement, dataDisplacement );
                }

                goto invalid_smb;
            }

            transaction->DataDisplacement = dataDisplacement;
            transaction->ParameterDisplacement = parameterDisplacement;

            WorkContext->Parameters.Transaction = transaction;

            //
            // Change the secondary command code to the primary code.
            //

            WorkContext->NextCommand--;
            header->Command = WorkContext->NextCommand;

            RestartIpxTransactionResponse( WorkContext );
            SmbStatus = SmbStatusInProgress;
            goto Cleanup;
        } else {

            IF_DEBUG(SMB_ERRORS) {
                SrvPrint4( "SrvSmbTransactionSecondary: Invalid parameter or data "
                          "offset+count: pOff=%ld,pCnt=%ld;dOff=%ld,dCnt=%ld;",
                          parameterOffset, parameterCount,
                          dataOffset, dataCount );
                SrvPrint0("Should be all zeros.\n");
            }

            goto invalid_smb;
        }
    }

    smbLength = WorkContext->RequestBuffer->DataLength;

    if ( ( (parameterOffset + parameterCount) > smbLength ) ||
         ( (dataOffset + dataCount) > smbLength )  ||
         ( (parameterCount + parameterDisplacement ) >
             transaction->TotalParameterCount ) ||
         ( (dataCount + dataDisplacement ) > transaction->TotalDataCount ) ) {

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint4( "SrvSmbTransactionSecondary: Invalid parameter or data "
                      "offset+count: pOff=%ld,pCnt=%ld;dOff=%ld,dCnt=%ld;",
                      parameterOffset, parameterCount,
                      dataOffset, dataCount );
            SrvPrint1( "smbLen=%ld", smbLength );
        }

        goto invalid_smb;
    }

    ACQUIRE_LOCK( &connection->Lock );

    if( transaction->Executing == TRUE ) {
        RELEASE_LOCK( &connection->Lock );
        IF_DEBUG(ERRORS) {
            SrvPrint0( "Transaction already executing.  Ignoring request.\n" );
        }
        goto invalid_smb;
    }

    //
    // Copy the parameter and data bytes that arrived in this SMB.  We do
    //  this while we hold the resource to ensure that we don't copy memory
    //  into the buffer if somebody sends us an extra secondary transaction.
    //
    if ( parameterCount != 0 ) {
        RtlMoveMemory(
            transaction->InParameters + parameterDisplacement,
            (PCHAR)header + parameterOffset,
            parameterCount
            );
    }

    if ( dataCount != 0 ) {
        RtlMoveMemory(
            transaction->InData + dataDisplacement,
            (PCHAR)header + dataOffset,
            dataCount
            );
    }

    //
    // Update the received parameter and data counts.  If all of the
    // transaction bytes have arrived, execute the transaction.  We
    // check for the unlikely case of the transaction having been
    // aborted in the short amount of time since we verified that it was
    // on the transaction list.
    //
    // *** This is all done under a lock in order to prevent the arrival
    //     of another secondary request (which could very easily happen)
    //     from interfering with our processing.  Only one arrival can
    //     be allowed to actually update the counters such that they
    //     match the expected data size.
    //


    if ( GET_BLOCK_STATE(transaction) != BlockStateActive ) {

        RELEASE_LOCK( &connection->Lock );

        IF_SMB_DEBUG(TRANSACTION1) {
            SrvPrint0( "Transaction closing.  Ignoring request.\n" );
        }
        SrvDereferenceTransaction( transaction );

        SmbStatus = SmbStatusNoResponse;
        goto Cleanup;
    }

    transaction->ParameterCount += parameterCount;
    transaction->DataCount += dataCount;

    if ( (transaction->DataCount == transaction->TotalDataCount) &&
         (transaction->ParameterCount == transaction->TotalParameterCount) ) {

        //
        // All of the data has arrived.  Prepare to execute the
        // transaction.  Reference the tree connect and session blocks,
        // saving pointers in the work context block.  Note that even
        // though the transaction block already references these blocks,
        // we store pointers to them in the work context block so that
        // common support routines only have to look there to find their
        // pointers.
        //

        WorkContext->Session = transaction->Session;
        SrvReferenceSession( transaction->Session );

        if( WorkContext->Session->SecurityContext != NULL )
        {
            WorkContext->SecurityContext = WorkContext->Session->SecurityContext;
            SrvReferenceSecurityContext( WorkContext->SecurityContext );
        }

        WorkContext->TreeConnect = transaction->TreeConnect;
        SrvReferenceTreeConnect( transaction->TreeConnect );

        transaction->Executing = TRUE;

        RELEASE_LOCK( &connection->Lock );

        //
        // Execute the transaction.  When ExecuteTransaction returns,
        // the first (possibly only) response, if any, has been sent.
        // Our work is done.
        //

        WorkContext->Parameters.Transaction = transaction;

        SmbStatus = ExecuteTransaction( WorkContext );
        goto Cleanup;
    } else {

        RELEASE_LOCK( &connection->Lock );

        //
        // Not all of the data has arrived.  Leave the transaction on
        // the list, and don't send a response.  Dereference the
        // transaction block, since we'll no longer have a pointer to
        // it.
        //

        IF_SMB_DEBUG(TRANSACTION1) {
            SrvPrint0( "More transaction data expected.\n" );
        }

        SrvDereferenceTransaction( transaction );

        //
        // We do things differently when we are directly using ipx.
        //

        if ( WorkContext->Endpoint->IsConnectionless ) {

            //
            // Send a go-ahead response.
            //

            PRESP_TRANSACTION_INTERIM response;

            response = (PRESP_TRANSACTION_INTERIM)WorkContext->ResponseParameters;
            response->WordCount = 0;
            SmbPutUshort( &response->ByteCount, 0 );
            WorkContext->ResponseParameters = NEXT_LOCATION(
                                                response,
                                                RESP_TRANSACTION_INTERIM,
                                                0
                                                );
            //
            // Inhibit statistics gathering -- this isn't the end of the
            // transaction.
            //

            WorkContext->StartTime = 0;

            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        } else {
            SmbStatus = SmbStatusNoResponse;
            goto Cleanup;
        }
    }

invalid_smb:
    SrvDereferenceTransaction( transaction );
    SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
    status    = STATUS_INVALID_SMB;
    SmbStatus = SmbStatusSendResponse;

Cleanup:
    return SmbStatus;
} // SrvSmbTransactionSecondary


SMB_PROCESSOR_RETURN_TYPE
SrvSmbNtTransaction (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes a primary NT Transaction SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;

    PREQ_NT_TRANSACTION request;
    PSMB_HEADER header;

    PCONNECTION connection;
    PSESSION session;
    PTREE_CONNECT treeConnect;
    PTRANSACTION transaction;
    PCHAR trailingBytes;

    CLONG parameterOffset;
    CLONG parameterCount;       // For input on this buffer
    CLONG maxParameterCount;    // For output
    CLONG totalParameterCount;  // For input
    CLONG dataOffset;
    CLONG dataCount;            // For input on this buffer
    CLONG maxDataCount;         // For output
    CLONG totalDataCount;       // For input
    CLONG smbLength;

    CLONG requiredBufferSize;

    CLONG parameterLength;      // MAX of input and output param length

    BOOLEAN singleBufferTransaction;

    PAGED_CODE( );

    request = (PREQ_NT_TRANSACTION)WorkContext->RequestParameters;
    header = WorkContext->RequestHeader;

    IF_SMB_DEBUG(TRANSACTION1) {
        SrvPrint0( "NT Transaction (primary) request\n" );
    }

    //
    // Make sure that the WordCount is correct to avoid any problems
    // with overrunning the SMB buffer.  SrvProcessSmb was unable to
    // verify WordCount because it is variable, but it did verify that
    // the supplied WordCount/ByteCount combination was valid.
    // Verifying WordCount here ensure that what SrvProcessSmb thought
    // was ByteCount really was, and that it's valid.  The test here
    // also implicit verifies SetupCount and that all of the setup words
    // are "in range".
    //

    if ( (ULONG)request->WordCount != (ULONG)(19 + request->SetupCount) ) {

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint3( "SrvSmbTransaction: Invalid WordCount: %ld, should be "
                      "SetupCount+19 = %ld+14 = %ld\n",
                      request->WordCount, request->SetupCount,
                      19 + request->SetupCount );
        }

        SrvLogInvalidSmb( WorkContext );

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Even though we know that WordCount and ByteCount are valid, it's
    // still possible that the offsets and lengths of the Parameter and
    // Data bytes are invalid.  So we check them now.
    //

    parameterOffset = request->ParameterOffset;
    parameterCount = request->ParameterCount;
    maxParameterCount = request->MaxParameterCount;
    totalParameterCount = request->TotalParameterCount;

    dataOffset = request->DataOffset;
    dataCount = request->DataCount;
    maxDataCount = request->MaxDataCount;
    totalDataCount = request->TotalDataCount;

    smbLength = WorkContext->RequestBuffer->DataLength;

    if ( ( parameterOffset > smbLength ) ||
         ( parameterCount > smbLength ) ||
         ( (parameterOffset + parameterCount) > smbLength ) ||
         ( dataOffset > smbLength ) ||
         ( dataCount > smbLength ) ||
         ( (dataOffset + dataCount) > smbLength ) ||
         ( dataCount > totalDataCount ) ||
         ( parameterCount > totalParameterCount ) ) {

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint4( "SrvSmbTransaction: Invalid parameter or data "
                      "offset+count: pOff=%ld,pCnt=%ld;dOff=%ld,dCnt=%ld;",
                      parameterOffset, parameterCount,
                      dataOffset, dataCount );
            SrvPrint1( "smbLen=%ld", smbLength );
        }

        SrvLogInvalidSmb( WorkContext );

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Ensure the client isn't asking for more data than we are willing
    //  to deal with
    //
    if( ( totalParameterCount > SrvMaxNtTransactionSize) ||
        ( totalDataCount > SrvMaxNtTransactionSize ) ||
        ( (totalParameterCount + totalDataCount) > SrvMaxNtTransactionSize) ||
        ( maxParameterCount > SrvMaxNtTransactionSize ) ||
        ( maxDataCount > SrvMaxNtTransactionSize ) ||
        ( (maxParameterCount + maxDataCount) > SrvMaxNtTransactionSize ) ||
        ( request->SetupCount > MAX_SETUP_COUNT ) ) {

        SrvSetSmbError( WorkContext, STATUS_INVALID_BUFFER_SIZE );
        status    = STATUS_INVALID_BUFFER_SIZE;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    singleBufferTransaction = (dataCount == totalDataCount) &&
                              (parameterCount == totalParameterCount);

    //
    // If a session block has not already been assigned to the current
    // work context, verify the UID.  If verified, the address of the
    // session block corresponding to this user is stored in the
    // WorkContext block and the session block is referenced.
    //
    // If a tree connect block has not already been assigned to the
    // current work context, find the tree connect corresponding to the
    // given TID.
    //

    status = SrvVerifyUidAndTid(
                WorkContext,
                &session,
                &treeConnect,
                ShareTypeWild
                );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(SMB_ERRORS) {
            SrvPrint0( "SrvSmbNtTransaction: Invalid UID or TID\n" );
        }
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    if( session->IsSessionExpired )
    {
        status = SESSION_EXPIRED_STATUS_CODE;
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // If there is a transaction secondary buffer on the way, ensure
    // that we have a free work item to receive it.  Otherwise fail
    // this SMB with an out of resources error.
    //

    if  ( !singleBufferTransaction ) {

        if ( SrvReceiveBufferShortage( ) ) {

            SrvStatistics.BlockingSmbsRejected++;

            SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
            status    = STATUS_INSUFF_SERVER_RESOURCES;
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        } else {

            //
            // SrvBlockingOpsInProgress has already been incremented.
            // Flag this work item as a blocking operation.
            //

            WorkContext->BlockingOperation = TRUE;

        }

    }

    //
    // Calculate buffer sizes.
    //
    // Input and output parameter buffers overlap.
    // Input and output data buffers overlap.
    //

    //
    // !!! It should be possible to be smarter about buffer space
    //     on NT Transaction SMBs.  We should be able to avoid
    //     copies to and from the SMB buffer.
    //

    parameterLength =
        MAX( ( (request->TotalParameterCount + 7) & ~7),
             ( (request->MaxParameterCount + 7) & ~7));

    requiredBufferSize = parameterLength +
        MAX( ( (request->TotalDataCount + 7) & ~7),
             ( (request->MaxDataCount + 7) & ~7) );

    if( !singleBufferTransaction ) {
        requiredBufferSize += (((request->SetupCount * sizeof(USHORT)) + 7 ) & ~7);
    }

    //
    // We will later quad-word align input buffer for OFS query
    // FSCTL since they are using MIDL to generate there marshalling
    // (pickling). For this reason, we have to bump up our requiredBufferSize
    // by 8 bytes (because the subsequent quad align might go up by as many
    // as 7 bytes. 8 looks like a better number to use.
    //
    // While OFS is long gone, we now always quad-align the buffer for the 64-bit case,
    // and for 32-bit transactions that require LARGE_INTEGER alignment.
    requiredBufferSize += 8;

    //
    // Allocate a transaction block.  This block is used to retain
    // information about the state of the transaction.  This is
    // necessary because multiple SMBs are potentially sent and
    // received.
    //

    connection = WorkContext->Connection;

    SrvAllocateTransaction(
        &transaction,
        (PVOID *)&trailingBytes,
        connection,
        requiredBufferSize,
        StrNull,
        NULL,
        TRUE,
        FALSE   // This is not a remote API
        );

    if ( transaction == NULL ) {

        //
        // Unable to allocate transaction.  Return an error to the
        // client.  (The session and tree connect blocks are
        // dereferenced automatically.)
        //

        IF_DEBUG(ERRORS) {
            SrvPrint0( "Unable to allocate transaction\n" );
        }

        if( requiredBufferSize > MAX_TRANSACTION_TAIL_SIZE )
        {
            SrvSetSmbError( WorkContext, STATUS_INVALID_BUFFER_SIZE );
            status    = STATUS_INVALID_BUFFER_SIZE;
        }
        else
        {
            SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
            status    = STATUS_INSUFF_SERVER_RESOURCES;
        }
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    IF_SMB_DEBUG(TRANSACTION1) {
        SrvPrint1( "Allocated transaction 0x%p\n", transaction );
    }

    //
    // Save the connection, session, and tree connect pointers in the
    // transaction block.  These are referenced pointers to prevent the
    // blocks from being deleted while the transaction is pending.
    //

    SrvReferenceConnection( connection );
    transaction->Connection = connection;

    SrvReferenceSession( session );
    transaction->Session = session;

    SrvReferenceTreeConnect( treeConnect );
    transaction->TreeConnect = treeConnect;

    //
    // Save the TID, PID, UID, and MID from this request in the
    // transaction block.  These values are used to relate secondary
    // requests to the appropriate primary request.
    //

    transaction->Tid = SmbGetAlignedUshort( &header->Tid );
    transaction->Pid = SmbGetAlignedUshort( &header->Pid );
    transaction->Uid = SmbGetAlignedUshort( &header->Uid );
    transaction->OtherInfo = SmbGetAlignedUshort( &header->Mid );

    //
    // Save the time that the initial request SMB arrived, for use in
    // calculating the elapsed time for the entire transaction.
    //

    transaction->StartTime = WorkContext->StartTime;

    //
    // Save other sundry information, but don't load the ParameterCount
    // and DataCount fields until after copying the data.  This is to
    // prevent the reception of a secondary request prior to our
    // completion here from causing the transaction to be executed
    // twice.  (These fields are initialized to 0 during allocation.)
    //

    transaction->Flags = SmbGetUshort( &request->Flags );
    transaction->Function = SmbGetUshort( &request->Function );

    transaction->SetupCount = request->SetupCount;
    transaction->MaxSetupCount = request->MaxSetupCount;

    transaction->TotalParameterCount = totalParameterCount;
    transaction->MaxParameterCount = maxParameterCount;

    transaction->TotalDataCount = totalDataCount;
    transaction->MaxDataCount = maxDataCount;

    //
    // Calculate the addresses of the various buffers.
    //

    if( singleBufferTransaction ) {
        transaction->InSetup = (PSMB_USHORT)request->Buffer;

    } else {

        if( request->SetupCount ) {
            transaction->InSetup = (PSMB_USHORT)trailingBytes;
            RtlCopyMemory( transaction->InSetup, request->Buffer, request->SetupCount * sizeof(USHORT) );
            trailingBytes += (((request->SetupCount * sizeof(USHORT)) + 7 ) & ~7);
        } else {
            transaction->InSetup = NULL;
        }

    }

    //
    // Input parameters and data will be copied to a separate buffer.
    //

    transaction->InParameters = (PCHAR)trailingBytes;
    trailingBytes += parameterLength;

    // We can always Quad-Align this because we padded the buffer for the OFS queries.
    // This will allow all our 64-bit calls to go through fine, along with our 32-bit ones
    transaction->InData = (PCHAR)ROUND_UP_POINTER(trailingBytes, 8);

    transaction->InputBufferCopied = TRUE;

    //
    // Setup the output data pointers.
    //

    transaction->OutSetup = (PSMB_USHORT)NULL;

    //
    // The output is going into a separate buffer, to be copied
    // later into the response SMB buffer.
    //

    transaction->OutParameters = transaction->InParameters;
    transaction->OutData = transaction->InData;

    transaction->OutputBufferCopied = TRUE;

    //
    // Link the transaction block into the connection's pending
    // transaction list.  This will fail if there is already a
    // tranaction with the same xID values in the list.
    //
    // !!! Need a way to prevent the transaction list from becoming
    //     clogged with pending transactions.
    //
    // *** We can link the block into the list even though we haven't
    //     yet copied the data from the current message into the list
    //     because even if a secondary request arrives before we've done
    //     the copy, only one of us will be the one to find out that all
    //     of the data has arrived.  This is because we update the
    //     counters while we hold a lock.
    //

    if ( !SrvInsertTransaction( transaction ) ) {

        //
        // A transaction with the same xIDs is already in progress.
        // Return an error to the client.
        //
        // *** Note that SrvDereferenceTransaction can't be used here
        //     because that routine assumes that the transaction is
        //     queued to the transaction list.
        //

        IF_SMB_DEBUG(TRANSACTION1) {
            SrvPrint0( "Duplicate transaction exists\n" );
        }

        SrvLogInvalidSmb( WorkContext );

        SrvDereferenceSession( session );
        DEBUG transaction->Session = NULL;

        SrvDereferenceTreeConnect( treeConnect );
        DEBUG transaction->TreeConnect = NULL;

        SrvFreeTransaction( transaction );

        SrvDereferenceConnection( connection );

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Copy the parameter and data bytes that arrived in the primary SMB.
    // There is no need to copy the setup words as they always arrive
    // completely in the primary buffer (unless we have a multipiece transaction)
    //
    // !!! We could allow secondary requests to start by allocating a
    //     separate buffer for the interim response, sending the
    //     response, then copying the data.
    //

    if ( parameterCount != 0 ) {
        RtlMoveMemory(
            transaction->InParameters,
            (PCHAR)header + parameterOffset,
            parameterCount
            );
    }

    if ( dataCount != 0 ) {
        RtlMoveMemory(
            transaction->InData,
            (PCHAR)header + dataOffset,
            dataCount
            );
    }

    //
    // Update the received parameter and data counts.  If all of the
    // transaction bytes have arrived, execute it.  Otherwise, send
    // an interim response.
    //

    transaction->ParameterCount = parameterCount;
    transaction->DataCount = dataCount;

    if ( singleBufferTransaction ) {

        //
        // All of the data has arrived.  Execute the transaction.  When
        // ExecuteTransaction returns, the first (possibly only)
        // response, if any, has been sent.  Our work is done.
        //

        WorkContext->Parameters.Transaction = transaction;

        SmbStatus = ExecuteTransaction( WorkContext );
        goto Cleanup;
    } else {

        //
        // Not all of the data has arrived.  We have already queued the
        // transaction to the connection's transaction list.  We need to
        // send an interim response telling the client to send the
        // remaining data.  We also need to dereference the transaction
        // block, since we'll no longer have a pointer to it.
        //

        PRESP_NT_TRANSACTION_INTERIM response;

        IF_SMB_DEBUG(TRANSACTION1) {
            SrvPrint0( "More transaction data expected.\n" );
        }
        ASSERT( transaction->Inserted );
        SrvDereferenceTransaction( transaction );

        response = (PRESP_NT_TRANSACTION_INTERIM)WorkContext->ResponseParameters;
        response->WordCount = 0;
        SmbPutUshort( &response->ByteCount, 0 );
        WorkContext->ResponseParameters = NEXT_LOCATION(
                                            response,
                                            RESP_NT_TRANSACTION_INTERIM,
                                            0
                                            );

        //
        // Inhibit statistics gathering -- this isn't the end of the
        // transaction.
        //

        WorkContext->StartTime = 0;

        SmbStatus = SmbStatusSendResponse;
    }

Cleanup:
    return SmbStatus;
} // SrvSmbNtTransaction


SMB_PROCESSOR_RETURN_TYPE
SrvSmbNtTransactionSecondary (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes a secondary Nt Transaction SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_NT_TRANSACTION_SECONDARY request;
    PSMB_HEADER header;

    PTRANSACTION transaction;
    PCONNECTION connection;

    CLONG parameterOffset;
    CLONG parameterCount;
    CLONG parameterDisplacement;
    CLONG dataOffset;
    CLONG dataCount;
    CLONG dataDisplacement;
    CLONG smbLength;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;

    PAGED_CODE( );

    request = (PREQ_NT_TRANSACTION_SECONDARY)WorkContext->RequestParameters;
    header = WorkContext->RequestHeader;

    IF_SMB_DEBUG(TRANSACTION1) {
        SrvPrint0( "Nt Transaction (secondary) request\n" );
    }

    //
    // Find the transaction block that matches this secondary request.
    // The TID, PID, UID, and MID in the headers of all messages in
    // a transaction are the same.  If a match is found, it is
    // referenced to prevent its deletion and its address is returned.
    //

    connection = WorkContext->Connection;

    transaction = SrvFindTransaction( connection, header, 0 );

    if ( transaction == NULL ) {

        //
        // Unable to find a matching transaction.  Ignore this SMB.
        //
        // !!! Is this the right thing to do?  It's what PIA does.
        //

        IF_DEBUG(ERRORS) {
            SrvPrint0( "No matching transaction.  Ignoring request.\n" );
        }

        SrvLogInvalidSmb( WorkContext );
        SmbStatus = SmbStatusNoResponse;
        goto Cleanup;
    }

    ASSERT( transaction->Connection == connection );

    if( transaction->Session->IsSessionExpired )
    {
        status = SESSION_EXPIRED_STATUS_CODE;
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // !!! Should ensure that the transaction isn't already complete.
    //     That is, that this is not a message accidentally added to a
    //     transaction that's already being executed.  (This is pretty
    //     much impossible to completely prevent, but we should do
    //     something to stop it.)
    //

    //
    // Unlike the NtTransaction SMB, the NtTransaction Secondary SMB
    // has a fixed WordCount, so SrvProcessSmb has already verified it.
    // But it's still possible that the offsets and lengths of the
    // Parameter and Data bytes are invalid.  So we check them now.
    //

    parameterOffset = request->ParameterOffset;
    parameterCount = request->ParameterCount;
    parameterDisplacement = request->ParameterDisplacement;
    dataOffset = request->DataOffset;
    dataCount = request->DataCount;
    dataDisplacement = request->DataDisplacement;

    //
    // See if this is a special ack by the client to tell us to send
    // the next piece of a multipiece response.
    //

    if ( transaction->MultipieceIpxSend ) {

        ASSERT( WorkContext->Endpoint->IsConnectionless );

        if ( (parameterCount == 0) && (parameterOffset == 0) &&
             (dataCount == 0) && (dataOffset == 0)) {

            //
            // got the ACK. Make sure the displacement numbers are reasonable.
            //

            if ( (dataDisplacement > transaction->DataCount) ||
                 (parameterDisplacement > transaction->ParameterCount) ) {

                IF_DEBUG(SMB_ERRORS) {
                    SrvPrint2( "SrvSmbNtTransactionSecondary: Invalid parameter or data "
                              "displacement: pDisp=%ld ;dDisp=%ld",
                              parameterDisplacement, dataDisplacement );
                }

                goto invalid_smb;
            }

            transaction->DataDisplacement = dataDisplacement;
            transaction->ParameterDisplacement = parameterDisplacement;

            WorkContext->Parameters.Transaction = transaction;

            //
            // Change the secondary command code to the primary code.
            //

            WorkContext->NextCommand = SMB_COM_NT_TRANSACT;
            header->Command = WorkContext->NextCommand;

            RestartIpxTransactionResponse( WorkContext );
            SmbStatus = SmbStatusInProgress;
            goto Cleanup;
        } else {

            IF_DEBUG(SMB_ERRORS) {
                SrvPrint4( "SrvSmbNtTransactionSecondary: Invalid parameter or data "
                          "offset+count: pOff=%ld,pCnt=%ld;dOff=%ld,dCnt=%ld;",
                          parameterOffset, parameterCount,
                          dataOffset, dataCount );
                SrvPrint0("Should be all zeros.\n");
            }

            goto invalid_smb;
        }
    }

    smbLength = WorkContext->RequestBuffer->DataLength;

    if ( ( parameterOffset > smbLength ) ||
         ( parameterCount > smbLength ) ||
         ( (parameterOffset + parameterCount) > smbLength ) ||
         ( dataOffset > smbLength ) ||
         ( dataCount > smbLength ) ||
         ( (dataOffset + dataCount) > smbLength ) ||
         ( parameterCount > transaction->TotalParameterCount ) ||
         ( parameterDisplacement > transaction->TotalParameterCount ) ||
         ( (parameterCount + parameterDisplacement ) > transaction->TotalParameterCount ) ||
         ( dataCount > transaction->TotalDataCount ) ||
         ( dataDisplacement > transaction->TotalDataCount ) ||
         ( (dataCount + dataDisplacement ) > transaction->TotalDataCount ) ) {

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint4( "SrvSmbTransactionSecondary: Invalid parameter or data "
                      "offset+count: pOff=%ld,pCnt=%ld;dOff=%ld,dCnt=%ld;",
                      parameterOffset, parameterCount,
                      dataOffset, dataCount );
            SrvPrint1( "smbLen=%ld", smbLength );
        }

        goto invalid_smb;
    }

    ACQUIRE_LOCK( &connection->Lock );

    if( transaction->Executing == TRUE ) {
        RELEASE_LOCK( &connection->Lock );
        IF_DEBUG(ERRORS) {
            SrvPrint0( "Transaction already executing.  Ignoring request.\n" );
        }
        goto invalid_smb;
    }

    //
    // Copy the parameter and data bytes that arrived in this SMB.
    //

    if ( parameterCount != 0 ) {
        RtlMoveMemory(
            transaction->InParameters + parameterDisplacement,
            (PCHAR)header + parameterOffset,
            parameterCount
            );
    }

    if ( dataCount != 0 ) {
        RtlMoveMemory(
            transaction->InData + dataDisplacement,
            (PCHAR)header + dataOffset,
            dataCount
            );
    }

    //
    // Update the received parameter and data counts.  If all of the
    // transaction bytes have arrived, execute the transaction.  We
    // check for the unlikely case of the transaction having been
    // aborted in the short amount of time since we verified that it was
    // on the transaction list.
    //
    // *** This is all done under a lock in order to prevent the arrival
    //     of another secondary request (which could very easily happen)
    //     from interfering with our processing.  Only one arrival can
    //     be allowed to actually update the counters such that they
    //     match the expected data size.
    //


    if ( GET_BLOCK_STATE(transaction) != BlockStateActive ) {

        RELEASE_LOCK( &connection->Lock );

        IF_SMB_DEBUG(TRANSACTION1) {
            SrvPrint0( "Transaction closing.  Ignoring request.\n" );
        }
        SrvDereferenceTransaction( transaction );

        SmbStatus = SmbStatusNoResponse;
        goto Cleanup;
    }

    transaction->ParameterCount += parameterCount;
    transaction->DataCount += dataCount;

    if ( (transaction->DataCount == transaction->TotalDataCount) &&
         (transaction->ParameterCount == transaction->TotalParameterCount) ) {

        //
        // All of the data has arrived.  Prepare to execute the
        // transaction.  Reference the tree connect and session blocks,
        // saving pointers in the work context block.  Note that even
        // though the transaction block already references these blocks,
        // we store pointers to them in the work context block so that
        // common support routines only have to look there to find their
        // pointers.
        //

        WorkContext->Session = transaction->Session;
        SrvReferenceSession( transaction->Session );

        if( WorkContext->Session->SecurityContext != NULL )
        {
            WorkContext->SecurityContext = WorkContext->Session->SecurityContext;
            SrvReferenceSecurityContext( WorkContext->SecurityContext );
        }

        WorkContext->TreeConnect = transaction->TreeConnect;
        SrvReferenceTreeConnect( transaction->TreeConnect );

        transaction->Executing = TRUE;

        RELEASE_LOCK( &connection->Lock );

        //
        // Execute the transaction.  When ExecuteTransaction returns,
        // the first (possibly only) response, if any, has been sent.
        // Our work is done.
        //

        WorkContext->Parameters.Transaction = transaction;

        SmbStatus = ExecuteTransaction( WorkContext );
        goto Cleanup;
    } else {

        //
        // Not all of the data has arrived.  Leave the transaction on
        // the list, and don't send a response.  Dereference the
        // transaction block, since we'll no longer have a pointer to
        // it.
        //

        RELEASE_LOCK( &connection->Lock );

        SrvDereferenceTransaction( transaction );
        IF_SMB_DEBUG(TRANSACTION1) SrvPrint0( "More data expected.\n" );

        //
        // We do things differently when we are directly using ipx.
        //

        if ( WorkContext->Endpoint->IsConnectionless ) {

            //
            // Send the go-ahead response.
            //

            PRESP_NT_TRANSACTION_INTERIM response;

            response = (PRESP_NT_TRANSACTION_INTERIM)WorkContext->ResponseParameters;
            response->WordCount = 0;
            SmbPutUshort( &response->ByteCount, 0 );
            WorkContext->ResponseParameters = NEXT_LOCATION(
                                                response,
                                                RESP_NT_TRANSACTION_INTERIM,
                                                0
                                                );
            //
            // Inhibit statistics gathering -- this isn't the end of the
            // transaction.
            //

            WorkContext->StartTime = 0;

            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        } else {
            SmbStatus = SmbStatusNoResponse;
            goto Cleanup;
        }
    }

invalid_smb:
    SrvDereferenceTransaction( transaction );
    SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
    status    = STATUS_INVALID_SMB;
    SmbStatus = SmbStatusSendResponse;

Cleanup:
    return SmbStatus;
} // SrvSmbNtTransactionSecondary


SMB_TRANS_STATUS
MailslotTransaction (
    PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function processes a mailslot transaction.

Arguments:

    WorkContext - Supplies a pointer to a work context block.

Return Value:

    SMB_TRANS_STATUS

--*/

{
    PTRANSACTION transaction;
    PSMB_HEADER header;
    PRESP_TRANSACTION response;
    PREQ_TRANSACTION request;
    USHORT command;
    PCHAR name;
    NTSTATUS status;

    HANDLE fileHandle;
    PFILE_OBJECT fileObject;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    OBJECT_HANDLE_INFORMATION handleInformation;
    UNICODE_STRING mailslotPath;
    UNICODE_STRING fullName;

    PAGED_CODE( );

    header = WorkContext->ResponseHeader;
    request = (PREQ_TRANSACTION)WorkContext->RequestParameters;
    response = (PRESP_TRANSACTION)WorkContext->ResponseParameters;
    transaction = WorkContext->Parameters.Transaction;

    command = SmbGetUshort( &transaction->InSetup[0] );
    name = (PCHAR)((PUSHORT)(&request->WordCount + 1) +
            request->WordCount + 1);

    //
    // The only legal mailslot transaction is a mailslot write.
    //

    if ( command != TRANS_MAILSLOT_WRITE ) {

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        return SmbTransStatusErrorWithoutData;

    }

    //
    // Strip "\MAILSLOT\" prefix from the path string.  Ensure that the
    // name contains more than just "\MAILSLOT\".
    //

    fullName.Buffer = NULL;

    mailslotPath = WorkContext->Parameters.Transaction->TransactionName;

    if ( mailslotPath.Length <=
            (UNICODE_SMB_MAILSLOT_PREFIX_LENGTH + sizeof(WCHAR)) ) {

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        return SmbTransStatusErrorWithoutData;

    }

    mailslotPath.Length -=
            (UNICODE_SMB_MAILSLOT_PREFIX_LENGTH + sizeof(WCHAR));
    mailslotPath.Buffer +=
            (UNICODE_SMB_MAILSLOT_PREFIX_LENGTH + sizeof(WCHAR))/sizeof(WCHAR);

    SrvAllocateAndBuildPathName(
        &SrvMailslotRootDirectory,
        &mailslotPath,
        NULL,
        &fullName
        );

    if ( fullName.Buffer == NULL ) {

        //
        // Unable to allocate heap for the full name.
        //

        IF_DEBUG(ERRORS) {
            SrvPrint0( "MailslotTransaction: Unable to allocate heap for full path name\n" );
        }

        SrvSetSmbError (WorkContext, STATUS_INSUFF_SERVER_RESOURCES);
        IF_DEBUG(TRACE2) SrvPrint0( "MailslotTransaction complete\n" );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // Attempt to open the mailslot.
    //

    SrvInitializeObjectAttributes_U(
        &objectAttributes,
        &fullName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );
    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpensForPathOperations );

    status = SrvIoCreateFile(
                WorkContext,
                &fileHandle,
                GENERIC_READ | GENERIC_WRITE,
                &objectAttributes,
                &ioStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_OPEN,
                0,                      // Create Options
                NULL,                   // EA Buffer
                0,                      // EA Length
                CreateFileTypeMailslot,
                (PVOID)NULL,            // Create parameters
                IO_FORCE_ACCESS_CHECK,
                NULL
                );

    FREE_HEAP( fullName.Buffer );


    if (!NT_SUCCESS(status)) {

        //
        // If the user didn't have this permission, update the
        // statistics database.
        //

        if ( status == STATUS_ACCESS_DENIED ) {
            SrvStatistics.AccessPermissionErrors++;
        }

        //
        // The server could not open the requested mailslot
        // return the error.
        //

        IF_SMB_DEBUG(TRANSACTION1) {
            SrvPrint2( "MailslotTransaction: Failed to open %ws, err=%d\n",
                WorkContext->Parameters.Transaction->TransactionName.Buffer,
                status );
        }

        SrvSetSmbError (WorkContext, status);
        IF_DEBUG(TRACE2) SrvPrint0( "MailslotTransaction complete\n" );
        return SmbTransStatusErrorWithoutData;
    }

    SRVDBG_CLAIM_HANDLE( fileHandle, "FIL", 31, transaction );
    SrvStatistics.TotalFilesOpened++;

    //
    // Get a pointer to the file object, so that we can directly
    // build IRPs for asynchronous operations (read and write).
    // Also, get the granted access mask, so that we can prevent the
    // client from doing things that it isn't allowed to do.
    //

    status = ObReferenceObjectByHandle(
                fileHandle,
                0,
                NULL,
                KernelMode,
                (PVOID *)&fileObject,
                &handleInformation
                );

    if ( !NT_SUCCESS(status) ) {

        SrvLogServiceFailure( SRV_SVC_OB_REF_BY_HANDLE, status );

        //
        // This internal error bugchecks the system.
        //

        INTERNAL_ERROR(
            ERROR_LEVEL_IMPOSSIBLE,
            "MailslotTransaction: unable to reference file handle 0x%lx",
            fileHandle,
            NULL
            );

        SrvSetSmbError( WorkContext, status );
        IF_DEBUG(TRACE2) SrvPrint0( "Mailslot transaction complete\n" );
        return SmbTransStatusErrorWithoutData;

    }

    //
    // Save file handle for the completion routine.
    //

    transaction = WorkContext->Parameters.Transaction;
    transaction->FileHandle = fileHandle;
    transaction->FileObject = fileObject;

    //
    // Set the Restart Routine addresses in the work context block.
    //

    WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
    WorkContext->FspRestartRoutine = RestartMailslotWrite;

    transaction = WorkContext->Parameters.Transaction;

    //
    // Build the IRP to start a mailslot write.
    // Pass this request to MSFS.
    //

    SrvBuildMailslotWriteRequest(
        WorkContext->Irp,                    // input IRP address
        fileObject,                          // target file object address
        WorkContext,                         // context
        transaction->InData,                 // buffer address
        transaction->TotalDataCount          // buffer length
        );

    (VOID)IoCallDriver(
                IoGetRelatedDeviceObject( fileObject ),
                WorkContext->Irp
                );

    //
    // The write was successfully started.  Return the InProgress
    // status to the caller, indicating that the caller should do
    // nothing further with the SMB/WorkContext at the present time.
    //

    IF_DEBUG(TRACE2) SrvPrint0( "MailslotTransaction complete\n" );
    return SmbTransStatusInProgress;

} // MailslotTransaction


VOID SRVFASTCALL
RestartMailslotWrite (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This is the completion routine for MailslotTransaction

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    PTRANSACTION transaction;

    PAGED_CODE( );

    //
    // If the write request failed, set an error status in the response
    // header.
    //

    status = WorkContext->Irp->IoStatus.Status;
    transaction = WorkContext->Parameters.Transaction;

    //
    // Close the open pipe handle.
    //

    SRVDBG_RELEASE_HANDLE( transaction->FileHandle, "FIL", 52, transaction );
    SrvNtClose( transaction->FileHandle, TRUE );
    ObDereferenceObject( transaction->FileObject );

    if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) {
            SrvPrint1( "RestartMailslotWrite:  Mailslot write failed: %X\n",
                        status );
        }
        SrvSetSmbError( WorkContext, status );

        SrvCompleteExecuteTransaction(
                        WorkContext,
                        SmbTransStatusErrorWithoutData
                        );
    } else {

        //
        // Success.  Prepare to generate and send the response.
        //

        transaction->SetupCount = 0;
        transaction->ParameterCount = 2;   // return 2 parameter bytes
        transaction->DataCount = 0;

        //
        // Return an OS/2 error code in the return parameter bytes.  Just copy
        // the error from the header.  If it is a network error the client
        // will figure it out.
        //
        // *** If the client understands NT errors, make it look in the
        //     SMB header.
        //

        if ( !CLIENT_CAPABLE_OF(NT_STATUS,WorkContext->Connection) ) {
            SmbPutUshort(
                (PSMB_USHORT)transaction->OutParameters,
                SmbGetUshort( &WorkContext->ResponseHeader->Error )
                );
        } else {
            SmbPutUshort(
                (PSMB_USHORT)transaction->OutParameters,
                (USHORT)-1
                );
        }

        SrvCompleteExecuteTransaction(WorkContext, SmbTransStatusSuccess);
    }

    IF_DEBUG(TRACE2) SrvPrint0( "RestartCallNamedPipe complete\n" );
    return;

} // RestartMailslotWrite


VOID SRVFASTCALL
SrvRestartExecuteTransaction (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This is the restart routine for Transaction SMBs that need to be
    queued pending the completion of a raw write.

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    None.

--*/

{
    SMB_STATUS status;

    PAGED_CODE( );

    status = ExecuteTransaction( WorkContext );
    ASSERT( status == SmbStatusInProgress );

    return;

} // SrvRestartExecuteTransaction

VOID SRVFASTCALL
RestartIpxMultipieceSend (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes send completion for a multipiece Transaction response over IPX.

Arguments:

    WorkContext - Supplies a pointer to a work context block.  The
        block contains information about the last SMB received for
        the transaction.

        WorkContext->Parameters.Transaction supplies a referenced
        pointer to a transaction block.  All block pointer fields in the
        block are valid.  Pointers to the setup words and parameter and
        data bytes, and the lengths of these items, are valid.  The
        transaction block is on the connection's pending transaction
        list.

Return Value:

    None.

--*/
{
    PTRANSACTION transaction = WorkContext->Parameters.Transaction;

    PAGED_CODE( );

    //
    // If the I/O request failed or was canceled, or if the connection
    // is no longer active, clean up.  (The connection is marked as
    // closing when it is disconnected or when the endpoint is closed.)
    //
    // !!! If I/O failure, should we drop the connection?
    //

    if ( WorkContext->Irp->Cancel ||
         !NT_SUCCESS(WorkContext->Irp->IoStatus.Status) ||
         (GET_BLOCK_STATE(WorkContext->Connection) != BlockStateActive) ) {

        IF_DEBUG(TRACE2) {
            if ( WorkContext->Irp->Cancel ) {
                SrvPrint0( "  I/O canceled\n" );
            } else if ( !NT_SUCCESS(WorkContext->Irp->IoStatus.Status) ) {
                SrvPrint1( "  I/O failed: %X\n",
                            WorkContext->Irp->IoStatus.Status );
            } else {
                SrvPrint0( "  Connection no longer active\n" );
            }
        }

        //
        // Close the transaction.  Indicate that SMB processing is
        // complete.
        //

        IF_DEBUG(ERRORS) {
            SrvPrint1( "I/O error. Closing transaction 0x%p\n", transaction );
        }
        SrvCloseTransaction( transaction );
    }

    //
    // We had a reference to this transaction during the send.  Remove it.
    //

    DEBUG WorkContext->Parameters.Transaction = NULL;
    SrvDereferenceTransaction( transaction );
    SrvRestartFsdComplete( WorkContext );
    return;

} // RestartIpxMultipieceSend


VOID SRVFASTCALL
RestartIpxTransactionResponse (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes send completion for a Transaction response.  If more
    responses are required, it builds and sends the next one.  If all
    responses have been sent, it closes the transaction.

Arguments:

    WorkContext - Supplies a pointer to a work context block.  The
        block contains information about the last SMB received for
        the transaction.

        WorkContext->Parameters.Transaction supplies a referenced
        pointer to a transaction block.  All block pointer fields in the
        block are valid.  Pointers to the setup words and parameter and
        data bytes, and the lengths of these items, are valid.  The
        transaction block is on the connection's pending transaction
        list.

Return Value:

    None.

--*/

{
    PTRANSACTION transaction;
    PSMB_HEADER header;
    PRESP_TRANSACTION response;
    PRESP_NT_TRANSACTION ntResponse;
    PCONNECTION connection;

    CLONG maxSize;

    PSMB_USHORT byteCountPtr;
    PCHAR paramPtr;
    CLONG paramLength;
    CLONG paramOffset;
    CLONG paramDisp;
    PCHAR dataPtr;
    CLONG dataLength;
    CLONG dataOffset;
    CLONG dataDisp;
    CLONG sendLength;

    BOOLEAN ntTransaction;

    PAGED_CODE( );

    transaction = WorkContext->Parameters.Transaction;
    paramDisp = transaction->ParameterDisplacement;
    dataDisp = transaction->DataDisplacement;

    IF_DEBUG(WORKER1) SrvPrint0( " - RestartIpxTransactionResponse\n" );

    //
    // Get the connection pointer.  The connection pointer is a
    // referenced pointer.
    //

    connection = WorkContext->Connection;
    IF_DEBUG(TRACE2) {
        SrvPrint2( "  connection 0x%p, endpoint 0x%p\n",
                    connection, WorkContext->Endpoint );
    }

    IF_SMB_DEBUG(TRANSACTION1) {
        SrvPrint2( "Continuing transaction response; block 0x%p, name %wZ\n",
                    transaction, &transaction->TransactionName );
        SrvPrint3( "Connection 0x%p, session 0x%p, tree connect 0x%p\n",
                    transaction->Connection, transaction->Session,
                    transaction->TreeConnect );
        SrvPrint2( "Remaining: parameters %ld bytes, data %ld bytes\n",
                    transaction->ParameterCount - paramDisp,
                    transaction->DataCount - dataDisp );
    }

    //
    // Update the parameters portion of the response, reusing the last
    // SMB.
    //

    ASSERT( transaction->Inserted );

    header = WorkContext->ResponseHeader;
    response = (PRESP_TRANSACTION)WorkContext->ResponseParameters;
    ntResponse = (PRESP_NT_TRANSACTION)WorkContext->ResponseParameters;

    if ( WorkContext->NextCommand == SMB_COM_NT_TRANSACT ) {

        ntTransaction = TRUE;
        ntResponse->WordCount = (UCHAR)18;
        ntResponse->SetupCount = 0;

        ntResponse->Reserved1 = 0;
        SmbPutUshort( &ntResponse->Reserved2, 0 );
        SmbPutUlong( &ntResponse->TotalParameterCount,
                     transaction->ParameterCount
                     );
        SmbPutUlong( &ntResponse->TotalDataCount,
                     transaction->DataCount
                     );

        //
        // Save a pointer to the byte count field.  Calculate how much of
        // the parameters and data can be sent in this response.  The
        // maximum amount we can send is minimum of the size of our buffer
        // and the size of the client's buffer.
        //
        // The parameter and data byte blocks are aligned on longword
        // boundaries in the message.
        //

        byteCountPtr = (PSMB_USHORT)ntResponse->Buffer;

    } else {

        ntTransaction = FALSE;
        response->WordCount = (UCHAR)10;
        response->SetupCount = 0;

        SmbPutUshort( &response->Reserved, 0 );
        SmbPutUshort( &response->TotalParameterCount,
                      (USHORT)transaction->ParameterCount
                      );
        SmbPutUshort( &response->TotalDataCount,
                      (USHORT)transaction->DataCount
                      );

        //
        // Save a pointer to the byte count field.  Calculate how much of
        // the parameters and data can be sent in this response.  The
        // maximum amount we can send is minimum of the size of our buffer
        // and the size of the client's buffer.
        //
        // The parameter and data byte blocks are aligned on longword
        // boundaries in the message.
        //

        byteCountPtr = (PSMB_USHORT)response->Buffer;
    }

    maxSize = MIN(
                WorkContext->ResponseBuffer->BufferLength,
                (CLONG)transaction->Session->MaxBufferSize
                );

    paramPtr = (PCHAR)(byteCountPtr + 1);       // first legal location
    paramOffset = PTR_DIFF(paramPtr, header);   // offset from start of header
    paramOffset = (paramOffset + 3) & ~3;       // round to next longword
    paramPtr = (PCHAR)header + paramOffset;     // actual location

    paramLength = transaction->ParameterCount - paramDisp;
                                                // assume all parameters fit

    if ( (paramOffset + paramLength) > maxSize ) {

        //
        // Not all of the parameter bytes will fit.  Send the maximum
        // number of longwords that will fit.  Don't send any data bytes
        // in this message.
        //

        paramLength = maxSize - paramOffset;    // max that will fit
        paramLength = paramLength & ~3;         // round down to longword

        dataLength = 0;                         // don't send data bytes
        dataOffset = 0;
        dataPtr = paramPtr + paramLength;       // make calculations work

    } else {

        //
        // All of the parameter bytes fit.  Calculate how many of data
        // bytes fit.
        //

        dataPtr = paramPtr + paramLength;       // first legal location
        dataOffset = PTR_DIFF(dataPtr, header); // offset from start of header
        dataOffset = (dataOffset + 3) & ~3;     // round to next longword
        dataPtr = (PCHAR)header + dataOffset;   // actual location

        dataLength = transaction->DataCount - dataDisp;
                                                // assume all data bytes fit

        if ( (dataOffset + dataLength) > maxSize ) {

            //
            // Not all of the data bytes will fit.  Send the maximum
            // number of longwords that will fit.
            //

            dataLength = maxSize - dataOffset;  // max that will fit
            dataLength = dataLength & ~3;       // round down to longword

        }

    }

    //
    // Finish filling in the response parameters.
    //

    if ( ntTransaction) {
        SmbPutUlong( &ntResponse->ParameterCount, paramLength );
        SmbPutUlong( &ntResponse->ParameterOffset, paramOffset );
        SmbPutUlong( &ntResponse->ParameterDisplacement, paramDisp );

        SmbPutUlong( &ntResponse->DataCount, dataLength );
        SmbPutUlong( &ntResponse->DataOffset, dataOffset );
        SmbPutUlong( &ntResponse->DataDisplacement, dataDisp );
    } else {
        SmbPutUshort( &response->ParameterCount, (USHORT)paramLength );
        SmbPutUshort( &response->ParameterOffset, (USHORT)paramOffset );
        SmbPutUshort( &response->ParameterDisplacement, (USHORT)paramDisp );

        SmbPutUshort( &response->DataCount, (USHORT)dataLength );
        SmbPutUshort( &response->DataOffset, (USHORT)dataOffset );
        SmbPutUshort( &response->DataDisplacement, (USHORT)dataDisp );
    }

    transaction->ParameterDisplacement = paramDisp + paramLength;
    transaction->DataDisplacement = dataDisp + dataLength;

    SmbPutUshort(
        byteCountPtr,
        (USHORT)(dataPtr - (PCHAR)(byteCountPtr + 1) + dataLength)
        );

    //
    // Copy the appropriate parameter and data bytes into the message.
    //
    // !!! Note that it would be possible to use the chain send
    //     capabilities of TDI to send the parameter and data bytes from
    //     their own buffers.  There is extra overhead involved in doing
    //     this, however, because the buffers must be locked down and
    //     mapped into system space so that the network drivers can look
    //     at them.
    //

    if ( paramLength != 0 ) {
        RtlMoveMemory(
            paramPtr,
            transaction->OutParameters + paramDisp,
            paramLength
            );
    }

    if ( dataLength != 0 ) {
        RtlMoveMemory(
            dataPtr,
            transaction->OutData + dataDisp,
            dataLength
            );
    }

    //
    // Calculate the length of the response message.
    //

    sendLength = (CLONG)( dataPtr + dataLength -
                                (PCHAR)WorkContext->ResponseHeader );

    WorkContext->ResponseBuffer->DataLength = sendLength;

    //
    // If this is the last part of the response, reenable statistics
    // gathering and restore the start time to the work context block.
    //

    header->Flags |= SMB_FLAGS_SERVER_TO_REDIR;
    if ( ((paramLength + paramDisp) == transaction->ParameterCount) &&
         ((dataLength + dataDisp) == transaction->DataCount) ) {

        //
        // This is the final piece.  Close the transaction.
        //

        WorkContext->StartTime = transaction->StartTime;

        SrvCloseTransaction( transaction );
        SrvDereferenceTransaction( transaction );

        //
        // Send the response.
        //

        SRV_START_SEND_2(
            WorkContext,
            SrvFsdRestartSmbAtSendCompletion,
            NULL,
            NULL
            );


    } else {

        WorkContext->ResponseBuffer->Mdl->ByteCount = sendLength;

        //
        // Send out the response.  When the send completes,
        // RestartTransactionResponse is called to either send the next
        // message or close the transaction.
        //
        // Note that the response bit in the SMB header is already set.
        //

        WorkContext->FspRestartRoutine = RestartIpxMultipieceSend;
        WorkContext->FsdRestartRoutine = NULL;
        transaction->MultipieceIpxSend = TRUE;

        SrvIpxStartSend( WorkContext, SrvQueueWorkToFspAtSendCompletion );
    }

    //
    // The response send is in progress.
    //

    IF_DEBUG(TRACE2) SrvPrint0( "RestartIpxTransactionResponse complete\n" );
    return;

} // RestartIpxTransactionResponse
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\smbsupp.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbsupp.c

Abstract:

    This module contains various support routines for processing SMBs.

Author:

    Chuck Lenzmeier (chuckl) 9-Nov-1989
    David Treadwell (davidtr)

Revision History:

--*/

#include "precomp.h"
#include "smbsupp.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_SMBSUPP

#define CHAR_SP ' '

//
// Mapping is defined in inc\srvfsctl.h
//

STATIC GENERIC_MAPPING SrvFileAccessMapping = GENERIC_SHARE_FILE_ACCESS_MAPPING;

//
// Forward references
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, Srv8dot3ToUnicodeString )
#pragma alloc_text( PAGE, SrvAllocateAndBuildPathName )
#pragma alloc_text( PAGE, SrvCanonicalizePathName )
#pragma alloc_text( PAGE, SrvCanonicalizePathNameWithReparse )
#pragma alloc_text( PAGE, SrvCheckSearchAttributesForHandle )
#pragma alloc_text( PAGE, SrvCheckSearchAttributes )
#pragma alloc_text( PAGE, SrvGetAlertServiceName )
#pragma alloc_text( PAGE, SrvGetBaseFileName )
#pragma alloc_text( PAGE, SrvGetMultiSZList )
#pragma alloc_text( PAGE, SrvGetOsVersionString )
#pragma alloc_text( PAGE, SrvGetString )
#pragma alloc_text( PAGE, SrvGetStringLength )
#pragma alloc_text( PAGE, SrvGetSubdirectoryLength )
#pragma alloc_text( PAGE, SrvIsLegalFatName )
#pragma alloc_text( PAGE, SrvMakeUnicodeString )
//#pragma alloc_text( PAGE, SrvReleaseContext )
#pragma alloc_text( PAGE, SrvSetFileWritethroughMode )
#pragma alloc_text( PAGE, SrvOemStringTo8dot3 )
#pragma alloc_text( PAGE, SrvUnicodeStringTo8dot3 )
#pragma alloc_text( PAGE, SrvVerifySid )
#pragma alloc_text( PAGE, SrvVerifyTid )
#pragma alloc_text( PAGE, SrvVerifyUid )
#pragma alloc_text( PAGE, SrvVerifyUidAndTid )
#pragma alloc_text( PAGE, SrvIoCreateFile )
#pragma alloc_text( PAGE, SrvNtClose )
#pragma alloc_text( PAGE, SrvVerifyDeviceStackSize )
#pragma alloc_text( PAGE, SrvImpersonate )
#pragma alloc_text( PAGE, SrvRevert )
#pragma alloc_text( PAGE, SrvSetLastWriteTime )
#pragma alloc_text( PAGE, SrvCheckShareFileAccess )
#pragma alloc_text( PAGE, SrvReleaseShareRootHandle )
#pragma alloc_text( PAGE, SrvUpdateVcQualityOfService )
#pragma alloc_text( PAGE, SrvIsAllowedOnAdminShare )
#pragma alloc_text( PAGE, SrvRetrieveMaximalAccessRightsForUser )
#pragma alloc_text( PAGE, SrvRetrieveMaximalAccessRights )
#pragma alloc_text( PAGE, SrvRetrieveMaximalShareAccessRights )
#pragma alloc_text( PAGE, SrvUpdateMaximalAccessRightsInResponse )
#pragma alloc_text( PAGE, SrvUpdateMaximalShareAccessRightsInResponse )
//#pragma alloc_text( PAGE, SrvValidateSmb )
#pragma alloc_text( PAGE, SrvWildcardRename )
#pragma alloc_text( PAGE8FIL, SrvCheckForSavedError )
#pragma alloc_text( PAGE, SrvIsDottedQuadAddress )
#endif
#if 0
NOT PAGEABLE -- SrvUpdateStatistics2
NOT PAGEABLE -- SrvVerifyFid2
NOT PAGEABLE -- SrvVerifyFidForRawWrite
NOT PAGEABLE -- SrvReceiveBufferShortage
#endif


VOID
Srv8dot3ToUnicodeString (
    IN PSZ Input8dot3,
    OUT PUNICODE_STRING OutputString
    )

/*++

Routine Description:

    Convert FAT 8.3 format into a string.

Arguments:

    Input8dot3 - Supplies the input 8.3 name to convert

    OutputString - Receives the converted name.  The memory must be
        supplied by the caller.

Return Value:

    None

--*/

{
    LONG i;
    CLONG lastOutputChar;
    UCHAR tempBuffer[8+1+3];
    OEM_STRING tempString;

    PAGED_CODE( );

    //
    // If we get "." or "..", just return them.  They do not follow
    // the usual rules for FAT names.
    //

    lastOutputChar = 0;

    if ( Input8dot3[0] == '.' && Input8dot3[1] == '\0' ) {

        tempBuffer[0] = '.';
        lastOutputChar = 0;

    } else if ( Input8dot3[0] == '.' && Input8dot3[1] == '.' &&
                    Input8dot3[2] == '\0' ) {

        tempBuffer[0] = '.';
        tempBuffer[1] = '.';
        lastOutputChar = 1;

    } else {

        //
        // Copy over the 8 part of the 8.3 name into the output buffer,
        // then back up the index to the first non-space character,
        // searching backwards.
        //

        RtlCopyMemory( tempBuffer, Input8dot3, 8 );

        for ( i = 7;
              (i >= 0) && (tempBuffer[i] == CHAR_SP);
              i -- ) {
            ;
        }

        //
        // Add a dot.
        //

        i++;
        tempBuffer[i] = '.';

        //
        // Copy over the 3 part of the 8.3 name into the output buffer,
        // then back up the index to the first non-space character,
        // searching backwards.
        //

        lastOutputChar = i;

        for ( i = 8; i < 11; i++ ) {

            //
            // Copy the byte.
            //
            // *** This code used to mask off the top bit.  This was a
            //     legacy of very ancient times when the bit may have
            //     been used as a resume key sequence bit.
            //

            tempBuffer[++lastOutputChar] = (UCHAR)Input8dot3[i];

        }

        while ( tempBuffer[lastOutputChar] == CHAR_SP ) {
            lastOutputChar--;
        }

        //
        // If the last character is a '.', then we don't have an
        // extension, so back up before the dot.
        //

        if ( tempBuffer[lastOutputChar] == '.') {
            lastOutputChar--;
        }

    }

    //
    // Convert to Unicode.
    //

    tempString.Length = (SHORT)(lastOutputChar + 1);
    tempString.Buffer = tempBuffer;

    OutputString->MaximumLength =
                            (SHORT)((lastOutputChar + 2) * sizeof(WCHAR));

    RtlOemStringToUnicodeString( OutputString, &tempString, FALSE );

    return;

} // Srv8dot3ToUnicodeString


VOID
SrvAllocateAndBuildPathName(
    IN PUNICODE_STRING Path1,
    IN PUNICODE_STRING Path2 OPTIONAL,
    IN PUNICODE_STRING Path3 OPTIONAL,
    OUT PUNICODE_STRING BuiltPath
    )

/*++

Routine Description:

    Allocates space and concatenates the paths in the parameter strings.
    ALLOCATE_HEAP is used to allocate the memory for the full
    pathname.  Directory separator characters ('\') are added as
    necessary so that a legitimate path is built.  If the third
    parameter is NULL, then only the first two strings are concatenated,
    and if both the second and third parameters are NULL then the first
    string is simply copied over to a new location.

Arguments:

    Input8dot3 - Supplies the input 8.3 name to convert

    OutputString - Receives the converted name, the memory must be supplied
        by the caller.

Return Value:

    None

--*/

{
    UNICODE_STRING path2;
    UNICODE_STRING path3;
    PWCH nextLocation;
    PWSTR pathBuffer;
    ULONG allocationLength;
    WCHAR nullString = 0;

    PAGED_CODE( );

    //
    // Set up the strings for optional parameters Path2 and Path3.  Doing
    // this allows later code to be ignorant of whether the strings were
    // actually passed.
    //

    if ( ARGUMENT_PRESENT(Path2) ) {

        path2.Buffer = Path2->Buffer;
        path2.Length = Path2->Length;

    } else {

        path2.Buffer = &nullString;
        path2.Length = 0;
    }

    if ( ARGUMENT_PRESENT(Path3) ) {

        path3.Buffer = Path3->Buffer;
        path3.Length = Path3->Length;

    } else {

        path3.Buffer = &nullString;
        path3.Length = 0;
    }

    //
    // Allocate space in which to put the path name we are building.
    // The +3 if to account for as many as two directory separator
    // characters being added and the zero terminator at the end.  This
    // has a small cost in terms of memory usage, but it simplifies this
    // code.
    //
    // The calling routine must be careful to deallocate this space
    // when it is done with the path name.
    //

    allocationLength = Path1->Length + path2.Length + path3.Length +
                        3 * sizeof(WCHAR);

    pathBuffer = ALLOCATE_HEAP_COLD(
                        allocationLength,
                        BlockTypeDataBuffer
                        );
    if ( pathBuffer == NULL ) {

        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvAllocateAndBuildPathName: Unable to allocate %d bytes "
                "from heap.",
            allocationLength,
            NULL
            );

        BuiltPath->Buffer = NULL;
        return;
    }

    BuiltPath->Buffer = pathBuffer;
    BuiltPath->MaximumLength = (USHORT)allocationLength;

    ASSERT ( ( allocationLength & 0xffff0000 ) == 0 );

    RtlZeroMemory( pathBuffer, allocationLength );

    //
    // Copy the first path name to the space we have allocated.
    //

    RtlCopyMemory( pathBuffer, Path1->Buffer, Path1->Length );
    nextLocation = (PWCH)((PCHAR)pathBuffer + Path1->Length);

    //
    // If there was no separator character at the end of the first path
    // or at the beginning of the next path, put one in.  We don't
    // want to put in leading slashes, however, so don't put one in
    // if it would be the first character.  Also, we don't want to insert
    // a slash if a relative stream is being opened (i.e. name begins with ':')
    //

    if ( nextLocation > pathBuffer &&
             *(nextLocation - 1) != DIRECTORY_SEPARATOR_CHAR &&
             *path2.Buffer != DIRECTORY_SEPARATOR_CHAR &&
             *path2.Buffer != RELATIVE_STREAM_INITIAL_CHAR ) {

        *nextLocation++ = DIRECTORY_SEPARATOR_CHAR;
    }

    //
    // Concatenate the second path name with the first.
    //

    RtlCopyMemory( nextLocation, path2.Buffer, path2.Length );
    nextLocation = (PWCH)((PCHAR)nextLocation + path2.Length);

    //
    // If there was no separator character at the end of the first path
    // or at the beginning of the next path, put one in.  Again, don't
    // put in leading slashes, and watch out for relative stream opens.
    //

    if ( nextLocation > pathBuffer &&
             *(nextLocation - 1) != DIRECTORY_SEPARATOR_CHAR &&
             *path3.Buffer != DIRECTORY_SEPARATOR_CHAR &&
             *path3.Buffer != RELATIVE_STREAM_INITIAL_CHAR ) {

        *nextLocation++ = DIRECTORY_SEPARATOR_CHAR;
    }

    //
    // Concatenate the third path name.
    //

    RtlCopyMemory( nextLocation, path3.Buffer, path3.Length );
    nextLocation = (PWCH)((PCHAR)nextLocation + path3.Length);

    //
    // The path cannot end in a '\', so if there was one at the end get
    // rid of it.
    //

    if ( nextLocation > pathBuffer &&
             *(nextLocation - 1) == DIRECTORY_SEPARATOR_CHAR ) {
        *(--nextLocation) = '\0';
    }

    //
    // Find the length of the path we built.
    //

    BuiltPath->Length = (SHORT)((PCHAR)nextLocation - (PCHAR)pathBuffer);

    return;

} // SrvAllocateAndBuildPathName

NTSTATUS
SrvCanonicalizePathName(
    IN PWORK_CONTEXT WorkContext,
    IN PSHARE Share OPTIONAL,
    IN PUNICODE_STRING RelatedPath OPTIONAL,
    IN OUT PVOID Name,
    IN PCHAR LastValidLocation,
    IN BOOLEAN RemoveTrailingDots,
    IN BOOLEAN SourceIsUnicode,
    OUT PUNICODE_STRING String
    )

/*++

Routine Description:

    This routine canonicalizes a filename.  All ".\" are removed, and
    "..\" are evaluated to go up a directory level.  A check is also
    made to ensure that the pathname does not go to a directory above
    the share root directory (i.e., no leading "..\").  Trailing blanks
    are always removed, as are trailing dots if RemoveTrailingDots is
    TRUE.

    If the input string is not Unicode, a Unicode representation of the
    input is obtained.  This requires that additional space be
    allocated, and it is the caller's responsibility to free this space.

    If the input string IS Unicode, this routine will align the input
    pointer (Name) to the next two-byte boundary before performing the
    canonicalization.  All Unicode strings in SMBs must be aligned
    properly.

    This routine operates "in place," meaning that it puts the
    canonicalized pathname in the same storage as the uncanonicalized
    pathname.  This is useful for operating on the Buffer fields of the
    request SMBs--simply call this routine and it will fix the pathname.
    However, the calling routine must be careful if there are two
    pathnames stored in the buffer field--the second won't necessarily
    start in the space just after the first '\0'.

    The LastValidLocation parameter is used to determine the maximum
    possible length of the name.  This prevents an access violation if
    the client fails to include a zero terminator, or for strings (such
    as the file name in NT Create And X) that are not required to be
    zero terminated.

    If the SMB described by WorkContext is marked as containing Dfs names,
    this routine will additionally call the Dfs driver to translate the
    Dfs name to a path relative to the Share. Since this call to the Dfs
    driver is NOT idempotent, the SMB flag indicating that it contains a
    Dfs name is CLEARED after a call to this routine. This posses a problem
    for the few SMBs that contain multiple names. The handlers for those
    SMBs must make sure that they conditionally call the SMB_MARK_AS_DFS_NAME
    macro before calling this routine.

Arguments:

    WorkContext - contains information about the negotiated dialect. This
        is used for deciding whether to strip trailing spaces and dots.

    Share - a pointer to the share entry

    Name - a pointer to the filename to canonicalize.

    LastValidLocation - a pointer to the last valid location in the
        buffer pointed to by Name.

    RemoveTrailingDots - if TRUE, trailing dots are removed.  Otherwise,
        they are left in (this supports special behavior needed by
        directory search logic).

    SourceIsUnicode - if TRUE, the input is canonicalized in place.
        If FALSE, the input is first converted to Unicode, then
        canonicalized.

    String - a pointer to string descriptor.

Return Value:

    BOOLEAN - FALSE if the name was invalid or if storage for the
        Unicode string could not be obtained.

--*/

{
    PWCH source, destination, lastComponent, name;
    BOOLEAN notNtClient;
    NTSTATUS status = STATUS_SUCCESS;
    DWORD numberOfPathElements = 0;

    PAGED_CODE( );

#if DBG
    return SrvCanonicalizePathNameWithReparse( WorkContext, Share, RelatedPath, Name, LastValidLocation, RemoveTrailingDots, SourceIsUnicode, String );
#else
    if( SMB_IS_UNICODE( WorkContext ) &&
        (
         FlagOn( WorkContext->RequestHeader->Flags2, SMB_FLAGS2_REPARSE_PATH ) ||
         (Share && (Share->SnapShotEpic != -1) && !SrvDisableDownlevelTimewarp)
        )
      )
    {
        return SrvCanonicalizePathNameWithReparse( WorkContext, Share, RelatedPath, Name, LastValidLocation, RemoveTrailingDots, SourceIsUnicode, String );
    }
#endif


    notNtClient = !IS_NT_DIALECT( WorkContext->Connection->SmbDialect );

    if ( SourceIsUnicode ) {

        //
        // The source string is already Unicode.  Align the pointer.
        // Save the character at the last location in the buffer, then
        // set that location to zero.  This prevents any loops from
        // going past the end of the buffer.
        //

        name = ALIGN_SMB_WSTR(Name);
        String->Buffer = name;

    } else {

        OEM_STRING oemString;
        PCHAR p;
        ULONG length;

        //
        // The source string is not Unicode.  Determine the length of
        // the string by finding the zero terminator or the end of the
        // input buffer.  We need the length in order to convert the
        // string to Unicode, and we can't just call RtlInitString, in
        // case the string isn't terminated.
        //

        for ( p = Name, length = 0;
              p <= LastValidLocation && *p != 0;
              p++, length++ ) {
            ;
        }

        //
        // Convert the source string to Unicode.
        //

        oemString.Buffer = Name;
        oemString.Length = (USHORT)length;
        oemString.MaximumLength = (USHORT)length;

        status = RtlOemStringToUnicodeString(
                            String,
                            &oemString,
                            TRUE
                            );

        if( !NT_SUCCESS( status ) ) {
            return status;
        }

        name = (PWCH)String->Buffer;
        LastValidLocation = (PCHAR)String->Buffer + String->Length;

    }

    //
    // Though everything is done in place, separate source and
    // destination pointers are maintained.  It is necessary that source
    // >= destination at all times to avoid writing into space we
    // haven't looked at yet.  The three main operations performed by
    // this routine ( ".\", "..\", and getting rid of trailing "." and "
    // ") do not interfere with this goal.
    //

    destination = name;
    source = name;

    //
    // The lastComponent variable is used as a placeholder when
    // backtracking over trailing blanks and dots.  It points to the
    // first character after the last directory separator or the
    // beginning of the pathname.
    //

    lastComponent = destination;

    //
    // Get rid of leading directory separators.
    //

    while ( source <= (PWCH)LastValidLocation &&
            (*source == UNICODE_DIR_SEPARATOR_CHAR) && (*source != L'\0') ) {
        source++;
    }

    //
    // Walk through the pathname until we reach the zero terminator.  At
    // the start of this loop, source points to the first charaecter
    // after a directory separator or the first character of the
    // pathname.
    //

    while ( (source <= (PWCH)LastValidLocation) && (*source != L'\0') ) {

        if ( *source == L'.' ) {

            //
            // If we see a dot, look at the next character.
            //

            if ( notNtClient &&
                 ((source+1) <= (PWCH)LastValidLocation) &&
                 (*(source+1) == UNICODE_DIR_SEPARATOR_CHAR) ) {

                //
                // If the next character is a directory separator,
                // advance the source pointer to the directory
                // separator.
                //

                source += 1;

            } else if ( ((source+1) <= (PWCH)LastValidLocation) &&
                        (*(source+1) == L'.') &&
                        ((source+1) == (PWCH)LastValidLocation ||
                        IS_UNICODE_PATH_SEPARATOR( *(source+2) ))) {

                //
                // If the following characters are ".\", we have a "..\".
                // Advance the source pointer to the "\".
                //

                source += 2;

                //
                // Move the destination pointer to the charecter before the
                // last directory separator in order to prepare for backing
                // up.  This may move the pointer before the beginning of
                // the name pointer.
                //

                destination -= 2;

                //
                // If destination points before the beginning of the name
                // pointer, fail because the user is attempting to go
                // to a higher directory than the share root.  This is
                // the equivalent of a leading "..\", but may result from
                // a case like "dir\..\..\file".
                //

                if ( destination <= name ) {
                    if ( !SourceIsUnicode ) {
                        RtlFreeUnicodeString( String );
                        String->Buffer = NULL;
                    }
                    return STATUS_OBJECT_PATH_SYNTAX_BAD;
                }

                //
                // Back up the destination pointer to after the last
                // directory separator or to the beginning of the pathname.
                // Backup to the beginning of the pathname will occur
                // in a case like "dir\..\file".
                //

                while ( destination >= name &&
                        *destination != UNICODE_DIR_SEPARATOR_CHAR ) {
                    destination--;
                }

                //
                // destination points to \ or character before name; we
                // want it to point to character after last \.
                //

                destination++;

            } else {

                //
                // The characters after the dot are not "\" or ".\", so
                // so just copy source to destination until we reach a
                // directory separator character.  This will occur in
                // a case like ".file" (filename starts with a dot).
                //

                do {
                    *destination++ = *source++;
                } while ( (source <= (PWCH)LastValidLocation) &&
                          !IS_UNICODE_PATH_SEPARATOR( *source ) );

                numberOfPathElements++;

            }

        } else {             // if ( *source == L'.' )

            //
            // source does not point to a dot, so copy source to
            // destination until we get to a directory separator.
            //

            while ( (source <= (PWCH)LastValidLocation) &&
                    !IS_UNICODE_PATH_SEPARATOR( *source ) ) {
                    *destination++ = *source++;
            }

            numberOfPathElements++;

        }

        //
        // Truncate trailing dots and blanks.  destination should point
        // to the last character before the directory separator, so back
        // up over blanks and dots.
        //

        if ( notNtClient ) {

            while ( ( destination > lastComponent ) &&
                    ( (RemoveTrailingDots && *(destination-1) == '.')
                        || *(destination-1) == ' ' ) ) {
                destination--;
            }
        }

        //
        // At this point, source points to a directory separator or to
        // a zero terminator.  If it is a directory separator, put one
        // in the destination.
        //

        if ( (source <= (PWCH)LastValidLocation) &&
             (*source == UNICODE_DIR_SEPARATOR_CHAR) ) {

            //
            // If we haven't put the directory separator in the path name,
            // put it in.
            //

            if ( destination != name &&
                 *(destination-1) != UNICODE_DIR_SEPARATOR_CHAR ) {

                *destination++ = UNICODE_DIR_SEPARATOR_CHAR;

            }

            //
            // It is legal to have multiple directory separators, so get
            // rid of them here.  Example: "dir\\\\\\\\file".
            //

            do {
                source++;
            } while ( (source <= (PWCH)LastValidLocation) &&
                      (*source == UNICODE_DIR_SEPARATOR_CHAR) );

            //
            // Make lastComponent point to the character after the directory
            // separator.
            //

            lastComponent = destination;

        }

    }

    //
    // We're just about done.  If there was a trailing ..  (example:
    // "file\.."), trailing .  ("file\."), or multiple trailing
    // separators ("file\\\\"), then back up one since separators are
    // illegal at the end of a pathname.
    //

    if ( destination > name &&
        *(destination-1) == UNICODE_DIR_SEPARATOR_CHAR ) {

        destination--;
    }

    *destination = L'\0';

    //
    // The length of the destination string is the difference between the
    // destination pointer (points to zero terminator at this point)
    // and the name pointer (points to the beginning of the destination
    // string).
    //

    String->Length = (SHORT)((PCHAR)destination - (PCHAR)name);
    String->MaximumLength = String->Length;

    //
    // One final thing:  Is this SMB referring to a DFS name?  If so, ask
    //  the DFS driver to turn it into a local name.
    //
    if( ARGUMENT_PRESENT( Share ) &&
        Share->IsDfs &&
        SMB_CONTAINS_DFS_NAME( WorkContext )) {

        BOOLEAN stripLastComponent = FALSE;

        //
        // We have to special case some SMBs (like TRANS2_FIND_FIRST2)
        // because they contain path Dfs path names that could refer to a
        // junction point. The SMB handlers for these SMBs are not interested
        // in a STATUS_PATH_NOT_COVERED error; instead they want the name
        // to be resolved to the the junction point.
        //

        if (WorkContext->NextCommand == SMB_COM_TRANSACTION2 ) {

            PTRANSACTION transaction;
            USHORT command;

            transaction = WorkContext->Parameters.Transaction;
            command = SmbGetUshort( &transaction->InSetup[0] );

            if (command == TRANS2_FIND_FIRST2 && numberOfPathElements > 2 )
                stripLastComponent = TRUE;

        }

        status =
            DfsNormalizeName(Share, RelatedPath, stripLastComponent, String);

        SMB_MARK_AS_DFS_TRANSLATED( WorkContext );

        if( !NT_SUCCESS( status ) ) {
            if ( !SourceIsUnicode ) {
                RtlFreeUnicodeString( String );
                String->Buffer = NULL;
            }
        }
    }

    return status;

} // SrvCanonicalizePathName

NTSTATUS
SrvCanonicalizePathNameWithReparse(
    IN PWORK_CONTEXT WorkContext,
    IN PSHARE Share OPTIONAL,
    IN PUNICODE_STRING RelatedPath OPTIONAL,
    IN OUT PVOID Name,
    IN PCHAR LastValidLocation,
    IN BOOLEAN RemoveTrailingDots,
    IN BOOLEAN SourceIsUnicode,
    OUT PUNICODE_STRING String
    )

/*++

Routine Description:

    This routine is identical to the one above with the exception that it
    checks the path for reparse-able names (such as snapshot references) and
    handles them accordingly.  This allows us to present new features within
    the Win32 namespace so old applications can use them.

Arguments:

    WorkContext - contains information about the negotiated dialect. This
        is used for deciding whether to strip trailing spaces and dots.

    Share - a pointer to the share entry

    Name - a pointer to the filename to canonicalize.

    LastValidLocation - a pointer to the last valid location in the
        buffer pointed to by Name.

    RemoveTrailingDots - if TRUE, trailing dots are removed.  Otherwise,
        they are left in (this supports special behavior needed by
        directory search logic).

    SourceIsUnicode - if TRUE, the input is canonicalized in place.
        If FALSE, the input is first converted to Unicode, then
        canonicalized.

    String - a pointer to string descriptor.

Return Value:

    BOOLEAN - FALSE if the name was invalid or if storage for the
        Unicode string could not be obtained.

--*/

{
    PWCH source, destination, lastComponent, name;
    BOOLEAN notNtClient;
    NTSTATUS status = STATUS_SUCCESS;
    DWORD numberOfPathElements = 0;

    PAGED_CODE( );

    notNtClient = !IS_NT_DIALECT( WorkContext->Connection->SmbDialect );

    if ( SourceIsUnicode ) {

        //
        // The source string is already Unicode.  Align the pointer.
        // Save the character at the last location in the buffer, then
        // set that location to zero.  This prevents any loops from
        // going past the end of the buffer.
        //

        name = ALIGN_SMB_WSTR(Name);
        String->Buffer = name;

    } else {

        OEM_STRING oemString;
        PCHAR p;
        ULONG length;

        //
        // The source string is not Unicode.  Determine the length of
        // the string by finding the zero terminator or the end of the
        // input buffer.  We need the length in order to convert the
        // string to Unicode, and we can't just call RtlInitString, in
        // case the string isn't terminated.
        //

        for ( p = Name, length = 0;
              p <= LastValidLocation && *p != 0;
              p++, length++ ) {
            ;
        }

        //
        // Convert the source string to Unicode.
        //

        oemString.Buffer = Name;
        oemString.Length = (USHORT)length;
        oemString.MaximumLength = (USHORT)length;

        status = RtlOemStringToUnicodeString(
                            String,
                            &oemString,
                            TRUE
                            );

        if( !NT_SUCCESS( status ) ) {
            return status;
        }

        name = (PWCH)String->Buffer;
        LastValidLocation = (PCHAR)String->Buffer + String->Length;

    }

    //
    // Though everything is done in place, separate source and
    // destination pointers are maintained.  It is necessary that source
    // >= destination at all times to avoid writing into space we
    // haven't looked at yet.  The three main operations performed by
    // this routine ( ".\", "..\", and getting rid of trailing "." and "
    // ") do not interfere with this goal.
    //

    destination = name;
    source = name;

    //
    // The lastComponent variable is used as a placeholder when
    // backtracking over trailing blanks and dots.  It points to the
    // first character after the last directory separator or the
    // beginning of the pathname.
    //

    lastComponent = destination;

    //
    // Get rid of leading directory separators.
    //

    while ( source <= (PWCH)LastValidLocation &&
            (*source == UNICODE_DIR_SEPARATOR_CHAR) && (*source != L'\0') ) {
        source++;
    }

    //
    // Walk through the pathname until we reach the zero terminator.  At
    // the start of this loop, source points to the first charaecter
    // after a directory separator or the first character of the
    // pathname.
    //

    while ( (source <= (PWCH)LastValidLocation) && (*source != L'\0') ) {

        if ( *source == L'.' ) {

            //
            // If we see a dot, look at the next character.
            //

            if ( notNtClient &&
                 ((source+1) <= (PWCH)LastValidLocation) &&
                 (*(source+1) == UNICODE_DIR_SEPARATOR_CHAR) ) {

                //
                // If the next character is a directory separator,
                // advance the source pointer to the directory
                // separator.
                //

                source += 1;

            } else if ( ((source+1) <= (PWCH)LastValidLocation) &&
                        (*(source+1) == L'.') &&
                        ((source+1) == (PWCH)LastValidLocation ||
                        IS_UNICODE_PATH_SEPARATOR( *(source+2) ))) {

                //
                // If the following characters are ".\", we have a "..\".
                // Advance the source pointer to the "\".
                //

                source += 2;

                //
                // Move the destination pointer to the charecter before the
                // last directory separator in order to prepare for backing
                // up.  This may move the pointer before the beginning of
                // the name pointer.
                //

                destination -= 2;

                //
                // If destination points before the beginning of the name
                // pointer, fail because the user is attempting to go
                // to a higher directory than the share root.  This is
                // the equivalent of a leading "..\", but may result from
                // a case like "dir\..\..\file".
                //

                if ( destination <= name ) {
                    if ( !SourceIsUnicode ) {
                        RtlFreeUnicodeString( String );
                        String->Buffer = NULL;
                    }
                    return STATUS_OBJECT_PATH_SYNTAX_BAD;
                }

                //
                // Back up the destination pointer to after the last
                // directory separator or to the beginning of the pathname.
                // Backup to the beginning of the pathname will occur
                // in a case like "dir\..\file".
                //

                while ( destination >= name &&
                        *destination != UNICODE_DIR_SEPARATOR_CHAR ) {
                    destination--;
                }

                //
                // destination points to \ or character before name; we
                // want it to point to character after last \.
                //

                destination++;

            } else {

                //
                // The characters after the dot are not "\" or ".\", so
                // so just copy source to destination until we reach a
                // directory separator character.  This will occur in
                // a case like ".file" (filename starts with a dot).
                //

                do {
                    *destination++ = *source++;
                } while ( (source <= (PWCH)LastValidLocation) &&
                          !IS_UNICODE_PATH_SEPARATOR( *source ) );

                numberOfPathElements++;

            }

        } else {             // if ( *source == L'.' )
            LARGE_INTEGER SnapShotTime;

            // Try to parse out a snap token
            // Length = LastValidLocation - Source + sizeof(WCHAR) (since LastValidLocation is potentially a valid character)
            if( SrvSnapParseToken( source, ((ULONG)((PCHAR)LastValidLocation - (PCHAR)source + sizeof(WCHAR))), &SnapShotTime ) )
            {
                if( (WorkContext->SnapShotTime.QuadPart != 0) || (SnapShotTime.QuadPart == 0) )
                {
                    // Don't allow 2 timestamps in the same path, or 0-time timestamps.  These
                    // can cause a variety of confusing or Denail-of-Service situations.
                    return STATUS_INVALID_PARAMETER;
                }

                WorkContext->SnapShotTime = SnapShotTime;

                while ( (source <= (PWCH)LastValidLocation) &&
                        !IS_UNICODE_PATH_SEPARATOR( *source ) ) {
                        source++;
                }

#if 0 //DBG
                if( !(WorkContext->RequestHeader->Flags2 & SMB_FLAGS2_REPARSE_PATH) )
                {
                    DbgPrint( "Found token but REPARSE not set!\n" );
                    DbgBreakPoint();
                }
#endif
            }
            else
            {
                while ( (source <= (PWCH)LastValidLocation) &&
                        !IS_UNICODE_PATH_SEPARATOR( *source ) ) {
                        *destination++ = *source++;
                }
            }

            numberOfPathElements++;

        }

        //
        // Truncate trailing dots and blanks.  destination should point
        // to the last character before the directory separator, so back
        // up over blanks and dots.
        //

        if ( notNtClient ) {

            while ( ( destination > lastComponent ) &&
                    ( (RemoveTrailingDots && *(destination-1) == '.')
                        || *(destination-1) == ' ' ) ) {
                destination--;
            }
        }

        //
        // At this point, source points to a directory separator or to
        // a zero terminator.  If it is a directory separator, put one
        // in the destination.
        //

        if ( (source <= (PWCH)LastValidLocation) &&
             (*source == UNICODE_DIR_SEPARATOR_CHAR) ) {

            //
            // If we haven't put the directory separator in the path name,
            // put it in.
            //

            if ( destination != name &&
                 *(destination-1) != UNICODE_DIR_SEPARATOR_CHAR ) {

                *destination++ = UNICODE_DIR_SEPARATOR_CHAR;

            }

            //
            // It is legal to have multiple directory separators, so get
            // rid of them here.  Example: "dir\\\\\\\\file".
            //

            do {
                source++;
            } while ( (source <= (PWCH)LastValidLocation) &&
                      (*source == UNICODE_DIR_SEPARATOR_CHAR) );

            //
            // Make lastComponent point to the character after the directory
            // separator.
            //

            lastComponent = destination;

        }

    }

    //
    // We're just about done.  If there was a trailing ..  (example:
    // "file\.."), trailing .  ("file\."), or multiple trailing
    // separators ("file\\\\"), then back up one since separators are
    // illegal at the end of a pathname.
    //

    if ( destination > name &&
        *(destination-1) == UNICODE_DIR_SEPARATOR_CHAR ) {

        destination--;
    }

    *destination = L'\0';

    //
    // The length of the destination string is the difference between the
    // destination pointer (points to zero terminator at this point)
    // and the name pointer (points to the beginning of the destination
    // string).
    //

    String->Length = (SHORT)((PCHAR)destination - (PCHAR)name);
    String->MaximumLength = String->Length;

    //
    // One final thing:  Is this SMB referring to a DFS name?  If so, ask
    //  the DFS driver to turn it into a local name.
    //
    if( ARGUMENT_PRESENT( Share ) &&
        Share->IsDfs &&
        SMB_CONTAINS_DFS_NAME( WorkContext )) {

        BOOLEAN stripLastComponent = FALSE;

        //
        // We have to special case some SMBs (like TRANS2_FIND_FIRST2)
        // because they contain path Dfs path names that could refer to a
        // junction point. The SMB handlers for these SMBs are not interested
        // in a STATUS_PATH_NOT_COVERED error; instead they want the name
        // to be resolved to the the junction point.
        //

        if (WorkContext->NextCommand == SMB_COM_TRANSACTION2 ) {

            PTRANSACTION transaction;
            USHORT command;

            transaction = WorkContext->Parameters.Transaction;
            command = SmbGetUshort( &transaction->InSetup[0] );

            if (command == TRANS2_FIND_FIRST2 && numberOfPathElements > 2 )
                stripLastComponent = TRUE;

        }

        status =
            DfsNormalizeName(Share, RelatedPath, stripLastComponent, String);

        SMB_MARK_AS_DFS_TRANSLATED( WorkContext );

        if( !NT_SUCCESS( status ) ) {
            if ( !SourceIsUnicode ) {
                RtlFreeUnicodeString( String );
                String->Buffer = NULL;
            }
        }
    }

#if 0 //DBG
    if( (WorkContext->RequestHeader->Flags2 & SMB_FLAGS2_REPARSE_PATH) &&
        (WorkContext->SnapShotTime.QuadPart == 0) )
    {
        DbgPrint( "Token not found but REPARSE set!\n" );
        DbgBreakPoint();
    }
#endif

    return status;

} // SrvCanonicalizePathNameWithReparse



NTSTATUS
SrvCheckForSavedError(
    IN PWORK_CONTEXT WorkContext,
    IN PRFCB Rfcb
    )

/*++

Routine Description:

    This routine checks to see if there was a saved error.

Arguments:

    WorkContext - Pointer to the workcontext block which will be
        marked with the error.

    Rfcb - Pointer to the rfcb which contains the saved error status.

Return Value:

    status of SavedErrorCode.

--*/

{

    NTSTATUS savedErrorStatus;
    KIRQL oldIrql;

    UNLOCKABLE_CODE( 8FIL );

    //
    // Acquire the spin lock and see if the saved error
    // is still there.
    //

    ACQUIRE_SPIN_LOCK( &Rfcb->Connection->SpinLock, &oldIrql );
    savedErrorStatus = Rfcb->SavedError;
    if ( !NT_SUCCESS( savedErrorStatus ) ) {

        //
        // There was a write behind error.  Fail this operation
        // with the write error.
        //

        Rfcb->SavedError = STATUS_SUCCESS;
        RELEASE_SPIN_LOCK( &Rfcb->Connection->SpinLock, oldIrql );

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvCheckForSavedError: Returning write"
                "behind error %X\n", savedErrorStatus ));
        }
        SrvSetSmbError( WorkContext, savedErrorStatus );

    } else {

        RELEASE_SPIN_LOCK( &Rfcb->Connection->SpinLock, oldIrql );
    }

    return savedErrorStatus;

} // SrvCheckForSavedError


NTSTATUS SRVFASTCALL
SrvCheckSearchAttributes(
    IN USHORT FileAttributes,
    IN USHORT SmbSearchAttributes
    )
/*++

Routine Description:

    Determines whether the FileAttributes has
    attributes not specified in SmbSearchAttributes.  Only the system
    and hidden bits are examined.

Arguments:

    FileAttributes - The attributes in question

    SmbSearchAttributes - the search attributes passed in an SMB.

Return Value:

    STATUS_NO_SUCH_FILE if the attributes do not jive, or STATUS_SUCCESS if
        the search attributes encompass the attributes on the file.

--*/
{
    PAGED_CODE( );

    //
    // If the search attributes has both the system and hidden bits set,
    // then the file must be OK.
    //

    if ( (SmbSearchAttributes & FILE_ATTRIBUTE_SYSTEM) != 0 &&
         (SmbSearchAttributes & FILE_ATTRIBUTE_HIDDEN) != 0 ) {
        return STATUS_SUCCESS;
    }

    //
    // Mask out everything but the system and hidden bits--they're all
    // we care about.
    //

    FileAttributes &= (FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN);

    //
    // If a bit is set in fileAttributes that was not set in the search
    // attributes, then their bitwise OR will have a bit set that is
    // not set in search attributes.
    //

    if ( (SmbSearchAttributes | FileAttributes) != SmbSearchAttributes ) {
        return STATUS_NO_SUCH_FILE;
    }

    return STATUS_SUCCESS;

} // SrvCheckSearchAttributes


NTSTATUS
SrvCheckSearchAttributesForHandle(
    IN HANDLE FileHandle,
    IN USHORT SmbSearchAttributes
    )

/*++

Routine Description:

    Determines whether the file corresponding to FileHandle has
    attributes not specified in SmbSearchAttributes.  Only the system
    and hidden bits are examined.

Arguments:

    FileHandle - handle to the file; must have FILE_READ_ATTRIBUTES access.

    SmbSearchAttributes - the search attributes passed in an SMB.

Return Value:

    STATUS_NO_SUCH_FILE if the attributes do not jive, some other status
        code if the NtQueryInformationFile fails, or STATUS_SUCCESS if
        the search attributes encompass the attributes on the file.

--*/

{
    NTSTATUS status;
    FILE_BASIC_INFORMATION fileBasicInformation;

    PAGED_CODE( );

    //
    // If the search attributes has both the system and hidden bits set,
    // then the file must be OK.
    //

    if ( (SmbSearchAttributes & FILE_ATTRIBUTE_SYSTEM) != 0 &&
         (SmbSearchAttributes & FILE_ATTRIBUTE_HIDDEN) != 0 ) {
        return STATUS_SUCCESS;
    }

    //
    // Get the attributes on the file.
    //

    status = SrvQueryBasicAndStandardInformation(
                                            FileHandle,
                                            NULL,
                                            &fileBasicInformation,
                                            NULL
                                            );

    if ( !NT_SUCCESS(status) ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "SrvCheckSearchAttributesForHandle: NtQueryInformationFile (basic "
                "information) returned %X",
            status,
            NULL
            );

        SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );
        return status;
    }

    return SrvCheckSearchAttributes( (USHORT)fileBasicInformation.FileAttributes,
                                     SmbSearchAttributes );

} // SrvCheckSearchAttributesForHandle

VOID
SrvGetAlertServiceName(
    VOID
    )

/*++

Routine Description:

    This routine gets the server display string from the registry.

Arguments:

    None.

Return Value:

    none.

--*/
{
    UNICODE_STRING unicodeKeyName;
    UNICODE_STRING unicodeRegPath;
    OBJECT_ATTRIBUTES objAttributes;
    HANDLE keyHandle;

    ULONG lengthNeeded;
    NTSTATUS status;

    PWCHAR displayString;
    PWCHAR newString;

    PKEY_VALUE_FULL_INFORMATION infoBuffer = NULL;

    PAGED_CODE( );

    RtlInitUnicodeString( &unicodeRegPath, StrRegServerPath );
    RtlInitUnicodeString( &unicodeKeyName, StrRegSrvDisplayName );

    InitializeObjectAttributes(
                        &objAttributes,
                        &unicodeRegPath,
                        OBJ_CASE_INSENSITIVE,
                        NULL,
                        NULL
                        );

    status = ZwOpenKey(
                    &keyHandle,
                    KEY_QUERY_VALUE,
                    &objAttributes
                    );

    if ( !NT_SUCCESS(status) ) {
        goto use_default;
    }

    status = ZwQueryValueKey(
                        keyHandle,
                        &unicodeKeyName,
                        KeyValueFullInformation,
                        NULL,
                        0,
                        &lengthNeeded
                        );

    if ( status != STATUS_BUFFER_TOO_SMALL ) {
        NtClose( keyHandle );
        goto use_default;
    }

    infoBuffer = ALLOCATE_HEAP_COLD( lengthNeeded, BlockTypeDataBuffer );

    if ( infoBuffer == NULL ) {
        NtClose( keyHandle );
        goto use_default;
    }

    status = ZwQueryValueKey(
                        keyHandle,
                        &unicodeKeyName,
                        KeyValueFullInformation,
                        infoBuffer,
                        lengthNeeded,
                        &lengthNeeded
                        );

    NtClose( keyHandle );

    if ( !NT_SUCCESS(status) ) {
        goto use_default;
    }

    //
    // If it's empty, use the default.
    //

    lengthNeeded = infoBuffer->DataLength;
    if ( lengthNeeded <= sizeof(WCHAR) ) {
        goto use_default;
    }

    //
    // Get the display string.  If this is the same as the default,
    // exit.
    //

    displayString = (PWCHAR)((PCHAR)infoBuffer + infoBuffer->DataOffset);

    if ( wcscmp( displayString, StrDefaultSrvDisplayName ) == 0 ) {
        goto use_default;
    }

    //
    // allocate memory for the new display string
    //

    newString = (PWCHAR)ALLOCATE_HEAP_COLD( lengthNeeded, BlockTypeDataBuffer );

    if ( newString == NULL ) {
        goto use_default;
    }

    RtlCopyMemory(
            newString,
            displayString,
            lengthNeeded
            );

    SrvAlertServiceName = newString;
    FREE_HEAP( infoBuffer );
    return;

use_default:

    if ( infoBuffer != NULL ) {
        FREE_HEAP( infoBuffer );
    }

    SrvAlertServiceName = StrDefaultSrvDisplayName;
    return;

} // SrvGetAlertServiceName

VOID
SrvGetBaseFileName (
    IN PUNICODE_STRING InputName,
    OUT PUNICODE_STRING OutputName
    )

/*++

Routine Description:

    This routine finds the part of a path name that is only a file
    name.  For example, with a\b\c\filename, it sets the buffer
    field of OutputName to point to "filename" and the length to 8.

    *** This routine should be used AFTER SrvCanonicalizePathName has
        been used on the path name to ensure that the name is good and
        '..' have been removed.

Arguments:

    InputName - Supplies a pointer to the pathname string.

    OutputName - a pointer to where the base name information should
        be written.

Return Value:

    None.

--*/

{
    PWCH ep = &InputName->Buffer[ InputName->Length / sizeof(WCHAR) ];
    PWCH baseFileName = ep - 1;

    PAGED_CODE( );

    for( ; baseFileName > InputName->Buffer; --baseFileName ) {
        if( *baseFileName == DIRECTORY_SEPARATOR_CHAR ) {
            OutputName->Buffer = baseFileName + 1;
            OutputName->Length = PTR_DIFF_SHORT(ep, OutputName->Buffer);
            OutputName->MaximumLength = OutputName->Length;
            return;
        }
    }

    *OutputName = *InputName;

    return;

} // SrvGetBaseFileName

VOID
SrvGetMultiSZList(
    PWSTR **ListPointer,
    PWSTR BaseKeyName,
    PWSTR ParameterKeyName,
    PWSTR *DefaultList
    )

/*++

Routine Description:

    This routine queries a registry value key for its MULTI_SZ values.

Arguments:

    ListPointer - Pointer to receive the pointer to the null session pipes.
    ParameterKeyValue - Name of the value parameter to query.
    DefaultList - Value to assign to the list pointer in case
        something goes wrong.

Return Value:

    none.

--*/
{
    UNICODE_STRING unicodeKeyName;
    UNICODE_STRING unicodeParamPath;
    OBJECT_ATTRIBUTES objAttributes;
    HANDLE keyHandle;

    ULONG lengthNeeded;
    ULONG i;
    ULONG numberOfEntries;
    ULONG numberOfDefaultEntries = 0;
    NTSTATUS status;

    PWCHAR regEntry;
    PWCHAR dataEntry;
    PWSTR *ptrEntry;
    PCHAR newBuffer;
    PKEY_VALUE_FULL_INFORMATION infoBuffer = NULL;

    PAGED_CODE( );

    RtlInitUnicodeString( &unicodeParamPath, BaseKeyName );
    RtlInitUnicodeString( &unicodeKeyName, ParameterKeyName );

    InitializeObjectAttributes(
                        &objAttributes,
                        &unicodeParamPath,
                        OBJ_CASE_INSENSITIVE,
                        NULL,
                        NULL
                        );

    status = ZwOpenKey(
                    &keyHandle,
                    KEY_QUERY_VALUE,
                    &objAttributes
                    );

    if ( !NT_SUCCESS(status) ) {
        goto use_default;
    }

    status = ZwQueryValueKey(
                        keyHandle,
                        &unicodeKeyName,
                        KeyValueFullInformation,
                        NULL,
                        0,
                        &lengthNeeded
                        );

    if ( status != STATUS_BUFFER_TOO_SMALL ) {
        NtClose( keyHandle );
        goto use_default;
    }

    infoBuffer = ALLOCATE_HEAP_COLD( lengthNeeded, BlockTypeDataBuffer );

    if ( infoBuffer == NULL ) {
        NtClose( keyHandle );
        goto use_default;
    }

    status = ZwQueryValueKey(
                        keyHandle,
                        &unicodeKeyName,
                        KeyValueFullInformation,
                        infoBuffer,
                        lengthNeeded,
                        &lengthNeeded
                        );

    NtClose( keyHandle );

    if ( !NT_SUCCESS(status) ) {
        goto use_default;
    }

    //
    // Figure out how many entries there are.
    //
    // numberOfEntries should be total number of entries + 1.  The extra
    // one is for the NULL sentinel entry.
    //

    lengthNeeded = infoBuffer->DataLength;
    if ( lengthNeeded <= sizeof(WCHAR) ) {

        //
        // No entries on the list.  Use default.
        //

        goto use_default;
    }

    dataEntry = (PWCHAR)((PCHAR)infoBuffer + infoBuffer->DataOffset);
    for ( i = 0, regEntry = dataEntry, numberOfEntries = 0;
        i < lengthNeeded;
        i += sizeof(WCHAR) ) {

        if ( *regEntry++ == L'\0' ) {
            numberOfEntries++;
        }
    }

    //
    // Add the number of entries in the default list.
    //

    if ( DefaultList != NULL ) {
        for ( i = 0; DefaultList[i] != NULL ; i++ ) {
            numberOfDefaultEntries++;
        }
    }

    //
    // Allocate space needed for the array of pointers.  This is in addition
    // to the ones in the default list.
    //

    newBuffer = ALLOCATE_HEAP_COLD(
                        lengthNeeded +
                            (numberOfDefaultEntries + numberOfEntries + 1) *
                            sizeof( PWSTR ),
                        BlockTypeDataBuffer
                        );

    if ( newBuffer == NULL ) {
        goto use_default;
    }

    //
    // Copy the names
    //

    regEntry = (PWCHAR)(newBuffer +
        (numberOfDefaultEntries + numberOfEntries + 1) * sizeof(PWSTR));

    RtlCopyMemory(
            regEntry,
            dataEntry,
            lengthNeeded
            );

    //
    // Free the info buffer
    //

    FREE_HEAP( infoBuffer );

    //
    // Copy the pointers in the default list.
    //

    ptrEntry = (PWSTR *) newBuffer;

    for ( i = 0; i < numberOfDefaultEntries ; i++ ) {

        *ptrEntry++ = DefaultList[i];

    }

    //
    // Build the array of pointers.  If numberOfEntries is 1, then
    // it means that the list is empty.
    //


    if ( numberOfEntries > 1 ) {

        *ptrEntry++ = regEntry++;

        //
        // Skip the first WCHAR and the last 2 NULL terminators.
        //

        for ( i = 3*sizeof(WCHAR) ; i < lengthNeeded ; i += sizeof(WCHAR) ) {
            if ( *regEntry++ == L'\0' ) {
                *ptrEntry++ = regEntry;
            }
        }
    }

    *ptrEntry = NULL;
    *ListPointer = (PWSTR *)newBuffer;
    return;

use_default:

    if ( infoBuffer != NULL ) {
        FREE_HEAP( infoBuffer );
    }
    *ListPointer = DefaultList;
    return;

} // SrvGetMultiSZList

NTSTATUS
SrvGetDWord(
    PWSTR BaseKeyName,
    PWSTR ParameterKeyName,
    LPDWORD Value
    )

/*++

Routine Description:

    This routine queries a dword registry value key

Arguments:

    BaseKeyName - value of the base key
    ParameterKeyValue - Name of the value parameter to query.
    Value - pointer to where to fill in the value if successful

Return Value:

    none.

--*/
{
    UNICODE_STRING unicodeKeyName;
    UNICODE_STRING unicodeParamPath;
    OBJECT_ATTRIBUTES objAttributes;
    HANDLE keyHandle;

    ULONG lengthNeeded;
    NTSTATUS status;
    BYTE bData[sizeof(KEY_VALUE_PARTIAL_INFORMATION)+2*(sizeof(DWORD))];

    PKEY_VALUE_PARTIAL_INFORMATION infoBuffer = (PKEY_VALUE_PARTIAL_INFORMATION)bData;

    PAGED_CODE( );

    *Value = 0;

    RtlInitUnicodeString( &unicodeParamPath, BaseKeyName );
    RtlInitUnicodeString( &unicodeKeyName, ParameterKeyName );

    InitializeObjectAttributes(
                        &objAttributes,
                        &unicodeParamPath,
                        OBJ_CASE_INSENSITIVE,
                        NULL,
                        NULL
                        );

    status = ZwOpenKey(
                    &keyHandle,
                    KEY_QUERY_VALUE,
                    &objAttributes
                    );

    if ( !NT_SUCCESS(status) ) {
        return status;
    }

    status = ZwQueryValueKey(
                        keyHandle,
                        &unicodeKeyName,
                        KeyValuePartialInformation,
                        infoBuffer,
                        sizeof(KEY_VALUE_PARTIAL_INFORMATION)+2*(sizeof(DWORD)),
                        &lengthNeeded
                        );

    NtClose( keyHandle );

    if ( !NT_SUCCESS(status) ) {
        return status;
    }

    if( infoBuffer->Type != REG_DWORD ||
        infoBuffer->DataLength < sizeof(DWORD) )
    {
        return STATUS_INVALID_PARAMETER;
    }

    *Value = *( (LPDWORD)(infoBuffer->Data) );

    return STATUS_SUCCESS;

} // SrvGetDWord


//
// NOTE: Any changes made here should also be made to the accompanying routines in the MRXSMB
//  RDR such that NativeLanMan and NativeOS match between the two.
//
VOID
SrvGetOsVersionString(
   VOID
   )
{
   ULONG            Storage[256], Storage2[256], Storage3[256];
   UNICODE_STRING   UnicodeString;
   HANDLE           hRegistryKey;
   NTSTATUS         Status, Status2;
   ULONG            BytesRead;

   OBJECT_ATTRIBUTES ObjectAttributes;
   PKEY_VALUE_FULL_INFORMATION Value = (PKEY_VALUE_FULL_INFORMATION)Storage;
   PKEY_VALUE_FULL_INFORMATION Value2 = (PKEY_VALUE_FULL_INFORMATION)Storage2;
   PKEY_VALUE_FULL_INFORMATION Value3 = (PKEY_VALUE_FULL_INFORMATION)Storage3;
   KEY_VALUE_PARTIAL_INFORMATION InitialPartialInformationValue;
   ULONG AllocationLength;

   PAGED_CODE();

   RtlInitUnicodeString(&UnicodeString, StrRegOsVersionPath);

   InitializeObjectAttributes(
       &ObjectAttributes,
       &UnicodeString,             // name
       OBJ_CASE_INSENSITIVE,       // attributes
       NULL,                       // root
       NULL);                      // security descriptor

   Status = ZwOpenKey (&hRegistryKey, KEY_READ, &ObjectAttributes);

   if( NT_SUCCESS(Status) )
   {
       RtlInitUnicodeString(&UnicodeString, StrRegVersionBuildNumberKeyName);
       Status = ZwQueryValueKey(
                   hRegistryKey,
                   &UnicodeString,
                   KeyValueFullInformation,
                   Value,
                   sizeof(Storage),
                   &BytesRead);

       if (NT_SUCCESS(Status)) {

           RtlInitUnicodeString(&UnicodeString, StrRegVersionProductKeyName );
           Status = ZwQueryValueKey(
                           hRegistryKey,
                           &UnicodeString,
                           KeyValueFullInformation,
                           Value3,
                           sizeof(Storage3),
                           &BytesRead);

           if( NT_SUCCESS(Status) )
           {
               // Change the data pointers
               PWSTR pProduct = (PWSTR)((PCHAR)Value3 + Value3->DataOffset);
               if( (Value3->DataLength > 20) &&
                   (_wcsnicmp( pProduct, L"Microsoft ", 10 ) == 0) )
               {
                   Value3->DataLength -= 20;
                   Value3->DataOffset += 20;
               }

               // check for existance of Service Pack String
               RtlInitUnicodeString(&UnicodeString, StrRegVersionSPKeyName);
               Status2 = ZwQueryValueKey(
                               hRegistryKey,
                               &UnicodeString,
                               KeyValueFullInformation,
                               Value2,
                               sizeof(Storage2),
                               &BytesRead);

               SrvNativeOS.MaximumLength = (USHORT)Value->DataLength + (USHORT)Value3->DataLength + sizeof(WCHAR);

               if(NT_SUCCESS(Status2)) {
                    SrvNativeOS.MaximumLength += (USHORT)Value2->DataLength;
               }

               SrvNativeOS.Length = 0;

               SrvNativeOS.Buffer = ALLOCATE_HEAP_COLD(SrvNativeOS.MaximumLength, BlockTypeDataBuffer);

               if (SrvNativeOS.Buffer != NULL) {

                   RtlZeroMemory( SrvNativeOS.Buffer, SrvNativeOS.MaximumLength );

                   // Copy string
                   RtlCopyMemory(SrvNativeOS.Buffer,
                         (PCHAR)Value3+Value3->DataOffset,
                         Value3->DataLength);
                   // Replace NULL with SPACE
                   RtlCopyMemory((SrvNativeOS.Buffer +
                          (Value3->DataLength/sizeof(WCHAR)) - 1),
                         L" ",
                         sizeof(WCHAR));
                   SrvNativeOS.Length += (USHORT)Value3->DataLength;

                   // Copy next string
                   RtlCopyMemory((SrvNativeOS.Buffer +
                          (Value3->DataLength/sizeof(WCHAR))),
                         (PCHAR)Value+Value->DataOffset,
                         Value->DataLength);
                   SrvNativeOS.Length += (USHORT)Value->DataLength;

                   if(NT_SUCCESS(Status2)) {

                       // replace NULL with SPACE
                       RtlCopyMemory(SrvNativeOS.Buffer +
                             (Value3->DataLength + Value->DataLength)/sizeof(WCHAR) - 1,
                             L" ",
                             sizeof(WCHAR));

                       // Copy last string (including NULL)
                       RtlCopyMemory(SrvNativeOS.Buffer +
                             (Value3->DataLength + Value->DataLength)/sizeof(WCHAR),
                             (PCHAR)Value2+Value2->DataOffset,
                             Value2->DataLength);
                       SrvNativeOS.Length += (USHORT)Value2->DataLength;
                   }

                   Status = RtlUnicodeStringToOemString(
                                           &SrvOemNativeOS,
                                           &SrvNativeOS,
                                           TRUE
                                           );

                   if ( !NT_SUCCESS(Status) ) {

                       FREE_HEAP( SrvNativeOS.Buffer );
                       SrvNativeOS.Buffer = NULL;
                   }

               } else {
                   Status = STATUS_INSUFFICIENT_RESOURCES;
               }
           }
       }

       if (NT_SUCCESS(Status)) {
          RtlInitUnicodeString(&UnicodeString, StrRegVersionKeyName);
          Status = ZwQueryValueKey(
                         hRegistryKey,
                         &UnicodeString,
                         KeyValueFullInformation,
                         Value,
                         sizeof(Storage),
                         &BytesRead);

          if (NT_SUCCESS(Status)) {
             SrvNativeLanMan.MaximumLength =
                 SrvNativeLanMan.Length = (USHORT)Value->DataLength +
                                        (USHORT)Value3->DataLength + sizeof(WCHAR);

             SrvNativeLanMan.Buffer = ALLOCATE_HEAP_COLD(SrvNativeLanMan.Length, BlockTypeDataBuffer );
             if (SrvNativeLanMan.Buffer != NULL) {

                RtlZeroMemory( SrvNativeLanMan.Buffer, SrvNativeLanMan.MaximumLength );
                SrvNativeLanMan.Length = 0;

                RtlCopyMemory(
                      SrvNativeLanMan.Buffer,
                      (PCHAR)Value3 + Value3->DataOffset,
                      Value3->DataLength);
                RtlCopyMemory(
                      (SrvNativeLanMan.Buffer +
                       (Value3->DataLength/sizeof(WCHAR)) - 1),
                      L" ",
                      sizeof(WCHAR));
                SrvNativeLanMan.Length += (USHORT)Value3->DataLength;

                RtlCopyMemory(
                      (SrvNativeLanMan.Buffer +
                       (Value3->DataLength/sizeof(WCHAR))),
                      (PCHAR)Value+Value->DataOffset,
                      Value->DataLength);
                SrvNativeLanMan.Length += (USHORT)Value->DataLength;

                Status = RtlUnicodeStringToOemString(
                                        &SrvOemNativeLanMan,
                                        &SrvNativeLanMan,
                                        TRUE
                                        );

                if ( !NT_SUCCESS(Status) ) {

                    FREE_HEAP( SrvNativeOS.Buffer );
                    SrvNativeOS.Buffer = NULL;

                    RtlFreeOemString( &SrvOemNativeOS );
                    SrvOemNativeOS.Buffer = NULL;

                    FREE_HEAP( SrvNativeLanMan.Buffer );
                    SrvNativeLanMan.Buffer = NULL;
                }


             } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
             }
          }
       }

       ZwClose(hRegistryKey);
   }

   if( !NT_SUCCESS(Status) )
   {
       RtlInitUnicodeString( &SrvNativeOS, StrDefaultNativeOs );
       RtlInitAnsiString( (PANSI_STRING)&SrvOemNativeOS, StrDefaultNativeOsOem );
       RtlInitUnicodeString( &SrvNativeLanMan, StrNativeLanman );
       RtlInitAnsiString( (PANSI_STRING)&SrvOemNativeLanMan, StrNativeLanmanOem );
   }

   return;
}


USHORT
SrvGetString (
    IN OUT PUNICODE_STRING Destination,
    IN PVOID Source,
    IN PVOID EndOfSourceBuffer,
    IN BOOLEAN SourceIsUnicode
    )

/*++

Routine Description:

    Reads a string out of an SMB buffer, and converts it to Unicode,
    if necessary.  This function is similar to SrvMakeUnicodeString,
    except

    (1) It always copies data from source to destination
    (2) It assumes storage for destination has been preallocated.  Its length
        is Destination->MaximumLength

Arguments:

    Destination - the resultant Unicode string.

    Source - a zero-terminated input.

    EndOfSourceBuffer - A pointer to the end of the SMB buffer.  Used to
        protect the server from accessing beyond the end of the SMB buffer,
        if the format is invalid.

    SourceIsUnicode - TRUE if the source is already Unicode.

Return Value:

    Length - Length of input buffer (included the NUL terminator).
             -1 if EndOfSourceBuffer is reached before the NUL terminator.

--*/

{
    USHORT length;

    PAGED_CODE( );

    if ( SourceIsUnicode ) {

        PWCH currentChar = Source;

        ASSERT( ((ULONG_PTR)Source & 1) == 0 );

        length = 0;
        while ( currentChar < (PWCH)EndOfSourceBuffer &&
                *currentChar != UNICODE_NULL ) {
            currentChar++;
            length += sizeof( WCHAR );
        }

        //
        // If we hit the end of the SMB buffer without finding a NUL, this
        // is a bad string.  Return an error.
        //

        if ( currentChar >= (PWCH)EndOfSourceBuffer ) {
            return (USHORT)-1;
        }

        //
        // If we overran our storage buffer, this is a bad string.  Return an error
        //
        if( length + sizeof( UNICODE_NULL ) > Destination->MaximumLength ) {
            return (USHORT)-1;
        }

        //
        // Copy the unicode data to the destination, including the NULL.  Set length
        //  of Destination to the non-null string length.
        //
        Destination->Length = length;

        //
        // We didn't change this to RtlCopyMemory because it is possible that
        // the source and destination can overlap.  Copy the NULL as well
        //

        RtlMoveMemory( Destination->Buffer, Source, length );

    } else {

        PCHAR currentChar = Source;
        OEM_STRING sourceString;

        length = 0;
        while ( currentChar <= (PCHAR)EndOfSourceBuffer &&
                *currentChar != '\0' ) {
            currentChar++;
            length++;
        }

        //
        // If we hit the end of the SMB buffer without finding a NUL, this
        // is a bad string.  Return an error.
        //

        if ( currentChar > (PCHAR)EndOfSourceBuffer ) {
            return (USHORT)-1;
        }

        //
        // If we overran our storage buffer, this is a bad string.  Return an error
        //
        if( (USHORT)(length + 1)*sizeof(WCHAR) > Destination->MaximumLength ) {
            return (USHORT)-1;
        }

        sourceString.Buffer = Source;
        sourceString.Length = length;

        //
        // Convert the data to unicode.
        //

        Destination->Length = 0;
        RtlOemStringToUnicodeString( Destination, &sourceString, FALSE );

        //
        // Increment 'length', to indicate that the NUL has been copied.
        //

        length++;

    }

    //
    // Return the number of bytes copied from the source buffer.
    //

    return length;

} // SrvGetString

USHORT
SrvGetStringLength (
    IN PVOID Source,
    IN PVOID EndOfSourceBuffer,
    IN BOOLEAN SourceIsUnicode,
    IN BOOLEAN IncludeNullTerminator
    )

/*++

Routine Description:

    This routine returns the length of a string in an SMB buffer in bytes.
    If the end of the buffer is encountered before the NUL terminator,
    the function returns -1 as the length.

Arguments:

    Source - a NUL-terminated input.

    EndOfSourceBuffer - A pointer to the end of the SMB buffer.  Used to
        protect the server from accessing beyond the end of the SMB buffer,
        if the format is invalid.

    SourceIsUnicode - TRUE if the source is already Unicode.

    IncludeNullTerminator - TRUE if the Length to be returned includes the
        null terminator.

Return Value:

    Length - Length of input buffer.  -1 if EndOfSourceBuffer is reached
    before the NUL terminator.

--*/

{
    USHORT length;

    PAGED_CODE( );

    if ( IncludeNullTerminator) {
        length = 1;
    } else {
        length = 0;
    }

    if ( SourceIsUnicode ) {

        PWCH currentChar = (PWCH)Source;

        ASSERT( ((ULONG_PTR)currentChar & 1) == 0 );

        while ( currentChar < (PWCH)EndOfSourceBuffer &&
                *currentChar != UNICODE_NULL ) {
            currentChar++;
            length++;
        }

        //
        // If we hit the end of the SMB buffer without finding a NUL, this
        // is a bad string.  Return an error.
        //

        if ( currentChar >= (PWCH)EndOfSourceBuffer ) {
            length = (USHORT)-1;
        } else {
            length = (USHORT)(length * sizeof(WCHAR));
        }

    } else {

        PCHAR currentChar = Source;

        while ( currentChar <= (PCHAR)EndOfSourceBuffer &&
                *currentChar != '\0' ) {
            currentChar++;
            length++;
        }

        //
        // If we hit the end of the SMB buffer without finding a NUL, this
        // is a bad string.  Return an error.
        //

        if ( currentChar > (PCHAR)EndOfSourceBuffer ) {
            length = (USHORT)-1;
        }

    }

    //
    // Return the length of the string.
    //

    return length;

} // SrvGetStringLength


USHORT
SrvGetSubdirectoryLength (
    IN PUNICODE_STRING InputName
    )

/*++

Routine Description:

    This routine finds the length of "subdirectory" information in a
    path name, that is, the parts of the path name that are not the
    actual name of the file.  For example, for a\b\c\filename, it
    returns 5.  This allows the calling routine to open the directory
    containing the file or get a full pathname to a file after a search.

    *** This routine should be used AFTER SrvCanonicalizePathName has
        been used on the path name to ensure that the name is good and
        '..' have been removed.

Arguments:

    InputName - Supplies a pointer to the pathname string.

Return Value:

    The number of bytes that contain directory information.  If the
    input is just a filename, then 0 is returned.

--*/

{
    ULONG i;
    PWCH baseFileName = InputName->Buffer;

    PAGED_CODE( );

    for ( i = 0; i < InputName->Length / sizeof(WCHAR); i++ ) {

        //
        // If s points to a directory separator, set fileBaseName to
        // the character after the separator.
        //

        if ( InputName->Buffer[i] == DIRECTORY_SEPARATOR_CHAR ) {
            baseFileName = &InputName->Buffer[i];
        }

    }

    return (USHORT)((baseFileName - InputName->Buffer) * sizeof(WCHAR));

} // SrvGetSubdirectoryLength


BOOLEAN SRVFASTCALL
SrvIsLegalFatName (
    IN PWSTR InputName,
    IN CLONG InputNameLength
    )

/*++

Routine Description:

    Determines whether a file name would be legal for FAT.  This
    is needed for SrvQueryDirectoryFile because it must filter names
    for clients that do not know about long or non-FAT filenames.

Arguments:

    InputName - Supplies the string to test
    InputNameLength - Length of the string (excluding the NULL termination)
                to test.

Return Value:

    TRUE if the name is a legal FAT name, FALSE if the name would be
    rejected by FAT.

--*/

{
    UNICODE_STRING original_name;

    UNICODE_STRING upcase_name;
    WCHAR          upcase_buffer[ 13 ];

    STRING         oem_string;
    CHAR           oem_buffer[ 13 ];

    UNICODE_STRING converted_name;
    WCHAR          converted_name_buffer[ 13 ];

    BOOLEAN spacesInName, nameValid8Dot3;

    PAGED_CODE();

    //
    // Special case . and .. -- they are legal FAT names
    //
    if( InputName[0] == L'.' ) {

        if( InputNameLength == sizeof(WCHAR) ||
            ((InputNameLength == 2*sizeof(WCHAR)) && InputName[1] == L'.')) {
            return TRUE;
        }

        return FALSE;
    }

    original_name.Buffer = InputName;
    original_name.Length = original_name.MaximumLength = (USHORT)InputNameLength;

    nameValid8Dot3 = RtlIsNameLegalDOS8Dot3( &original_name, NULL, &spacesInName );

    if( !nameValid8Dot3 || spacesInName ) {
        return FALSE;
    }

    if( SrvFilterExtendedCharsInPath == FALSE ) {
        //
        // One final test -- we must be able to convert this name to OEM and back again
        //  without any loss of information.
        //

        oem_string.Buffer = oem_buffer;
        upcase_name.Buffer = upcase_buffer;
        converted_name.Buffer = converted_name_buffer;

        oem_string.MaximumLength = sizeof( oem_buffer );
        upcase_name.MaximumLength = sizeof( upcase_buffer );
        converted_name.MaximumLength = sizeof( converted_name_buffer );

        oem_string.Length = 0;
        upcase_name.Length = 0;
        converted_name.Length = 0;

        nameValid8Dot3 = NT_SUCCESS( RtlUpcaseUnicodeString( &upcase_name, &original_name, FALSE )) &&
            NT_SUCCESS( RtlUnicodeStringToOemString( &oem_string, &upcase_name, FALSE )) &&
            FsRtlIsFatDbcsLegal( oem_string, FALSE, FALSE, FALSE ) &&
            NT_SUCCESS( RtlOemStringToUnicodeString( &converted_name, &oem_string, FALSE )) &&
            RtlEqualUnicodeString( &upcase_name, &converted_name, FALSE );
    }

    return nameValid8Dot3;

} // SrvIsLegalFatName

NTSTATUS
SrvMakeUnicodeString (
    IN BOOLEAN SourceIsUnicode,
    OUT PUNICODE_STRING Destination,
    IN PVOID Source,
    IN PUSHORT SourceLength OPTIONAL
    )

/*++

Routine Description:

    Makes a unicode string from a zero-terminated input that is either
    ANSI or Unicode.

Arguments:

    SourceIsUnicode - TRUE if the source is already Unicode.  If FALSE,
        RtlOemStringToUnicodeString will allocate space to hold the
        Unicode string; it is the responsibility of the caller to
        free this space.

    Destination - the resultant Unicode string.

    Source - a zero-terminated input.

Return Value:

    NTSTATUS - result of operation.

--*/

{
    OEM_STRING oemString;

    PAGED_CODE( );

    if ( SourceIsUnicode ) {

        ASSERT( ((ULONG_PTR)Source & 1) == 0 );

        if ( ARGUMENT_PRESENT( SourceLength ) ) {
            ASSERT( (*SourceLength) != (USHORT) -1 );
            Destination->Buffer = Source;
            Destination->Length = *SourceLength;
            Destination->MaximumLength = *SourceLength;
        } else {
            RtlInitUnicodeString( Destination, Source );
        }

        return STATUS_SUCCESS;
    }

    if ( ARGUMENT_PRESENT( SourceLength ) ) {
        oemString.Buffer = Source;
        oemString.Length = *SourceLength;
        oemString.MaximumLength = *SourceLength;
    } else {
        RtlInitString( &oemString, Source );
    }

    return RtlOemStringToUnicodeString(
               Destination,
               &oemString,
               TRUE
               );

} // SrvMakeUnicodeString


VOID
SrvReleaseContext (
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function releases (dereferences) control blocks referenced by a
    Work Context block.  It is called when processing of an incoming SMB
    is complete, just before the response SMB (if any) is set.

    The following control blocks are dereferenced: Share, Session,
    TreeConnect, and File.  If any of these fields is nonzero in
    WorkContext, the block is dereferenced and the fields is zeroed.

    Note that the Connection block and the Endpoint block are NOT
    dereferenced.  This is based on the assumption that a response is
    about to be sent, so the connection must stay referenced.  The
    Connection block is dereferenced after the send of the response (if
    any) when SrvRequeueReceiveIrp is called.  That function also
    releases the response buffer, if it is different from the request
    buffer.

Arguments:

    WorkContext - Supplies a pointer to a work context block.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    //
    // !!! If you change the way this routine works (e.g., you add
    //     another block that needs to be dereferenced), make sure you
    //     check fsd.c\SrvFsdRestartSmbComplete to see if it needs to be
    //     changed too.
    //

    //
    // Dereference the Share block, if any.
    //

    if ( WorkContext->Share != NULL ) {
        SrvDereferenceShare( WorkContext->Share );
        WorkContext->Share = NULL;
    }

    //
    // Dereference the Security Context, if any.
    //

    if ( WorkContext->SecurityContext != NULL ) {
        SrvDereferenceSecurityContext( WorkContext->SecurityContext );
        WorkContext->SecurityContext = NULL;
    }

    //
    // Dereference the Session block, if any.
    //

    if ( WorkContext->Session != NULL ) {
        SrvDereferenceSession( WorkContext->Session );
        WorkContext->Session= NULL;
    }

    //
    // Dereference the Tree Connect block, if any.
    //

    if ( WorkContext->TreeConnect != NULL ) {
        SrvDereferenceTreeConnect( WorkContext->TreeConnect );
        WorkContext->TreeConnect = NULL;
    }

    //
    // Dereference the RFCB, if any.
    //

    if ( WorkContext->Rfcb != NULL ) {
        SrvDereferenceRfcb( WorkContext->Rfcb );
        WorkContext->OplockOpen = FALSE;
        WorkContext->Rfcb = NULL;
    }

    //
    // Dereference the wait for oplock break, if any
    //

    if ( WorkContext->WaitForOplockBreak != NULL ) {
        SrvDereferenceWaitForOplockBreak( WorkContext->WaitForOplockBreak );
        WorkContext->WaitForOplockBreak = NULL;
    }

    //
    // If this was a blocking operation, update the blocking i/o count.
    //

    if ( WorkContext->BlockingOperation ) {
        InterlockedDecrement( &SrvBlockingOpsInProgress );
        WorkContext->BlockingOperation = FALSE;
    }

    return;

} // SrvReleaseContext


BOOLEAN
SrvSetFileWritethroughMode (
    IN PLFCB Lfcb,
    IN BOOLEAN Writethrough
    )

/*++

Routine Description:

    Sets the writethrough mode of a file as specified.  Returns the
    original mode of the file.

Arguments:

    Lfcb - A pointer to the LFCB representing the open file.

    Writethrough - A boolean indicating whether the file is to be placed
        into writethrough mode (TRUE) or writebehind mode (FALSE).

Return Value:

    BOOLEAN - Returns the original mode of the file.

--*/

{
    FILE_MODE_INFORMATION modeInformation;
    IO_STATUS_BLOCK iosb;

    PAGED_CODE( );

    //
    // If the file is already in the correct mode, simply return.
    // Otherwise, set the file to the correct mode.
    //

    if ( Writethrough ) {

        if ( (Lfcb->FileMode & FILE_WRITE_THROUGH) != 0 ) {
            return TRUE;
        } else {
            Lfcb->FileMode |= FILE_WRITE_THROUGH;
        }

    } else {

        if ( (Lfcb->FileMode & FILE_WRITE_THROUGH) == 0 ) {
            return FALSE;
        } else {
            Lfcb->FileMode &= ~FILE_WRITE_THROUGH;
        }

    }

    //
    // Change the file mode.
    //
    // !!! Don't do this by file handle -- build and issue an IRP using
    //     the file object pointer directly.
    //

    modeInformation.Mode = Lfcb->FileMode;

    (VOID)NtSetInformationFile(
            Lfcb->FileHandle,
            &iosb,
            &modeInformation,
            sizeof( modeInformation ),
            FileModeInformation
            );

    //
    // Return the original mode of the file, which was the opposite of
    // what was requested.
    //

    return (BOOLEAN)!Writethrough;

} // SrvSetFileWritethroughMode

VOID
SrvOemStringTo8dot3 (
    IN POEM_STRING InputString,
    OUT PSZ Output8dot3
    )

/*++

Routine Description:

    Convert a string into FAT 8.3 format.  This derived from GaryKi's
    routine FatStringTo8dot3 in fastfat\namesup.c.

Arguments:

    InputString - Supplies the input string to convert

    Output8dot3 - Receives the converted string.  The memory must be
        supplied by the caller.

Return Value:

    None.

--*/
{
    CLONG i, j;
    PCHAR inBuffer = InputString->Buffer;
    ULONG inLength = InputString->Length;

    PAGED_CODE( );

    ASSERT( inLength <= 12 );

    //
    // First make the output name all blanks.
    //

    RtlFillMemory( Output8dot3, 11, CHAR_SP );

    //
    // If we get "." or "..", just return them.  They do not follow
    // the usual rules for FAT names.
    //

    if( inBuffer[0] == '.' ) {
        if( inLength == 1 ) {
            Output8dot3[0] = '.';
            return;
        }

        if( inLength == 2 && inBuffer[1] == '.' ) {
            Output8dot3[0] = '.';
            Output8dot3[1] = '.';
            return;
        }
    }

    //
    // Copy over the first part of the file name.  Stop when we get to
    // the end of the input string or a dot.
    //

    if (NLS_MB_CODE_PAGE_TAG) {

        for ( i = 0;
              (i < inLength) && (inBuffer[i] != '.') && (inBuffer[i] != '\\');
              i++ ) {

            if (FsRtlIsLeadDbcsCharacter(inBuffer[i])) {

                if (i+1 < inLength) {
                    Output8dot3[i] = inBuffer[i];
                    i++;
                    Output8dot3[i] = inBuffer[i];
                } else {
                    break;
                }

            } else {

                Output8dot3[i] = inBuffer[i];
            }
        }

    } else {

        for ( i = 0;
              (i < inLength) && (inBuffer[i] != '.') && (inBuffer[i] != '\\');
              i++ ) {

            Output8dot3[i] = inBuffer[i];
        }

    }

    //
    // See if we need to add an extension.
    //

    if ( i < inLength ) {

        //
        // Skip over the dot.
        //

        ASSERT( (inLength - i) <= 4 );
        ASSERT( inBuffer[i] == '.' );

        i++;

        //
        // Add the extension to the output name
        //

        if (NLS_MB_CODE_PAGE_TAG) {

            for ( j = 8;
                  (i < inLength) && (inBuffer[i] != '\\');
                  i++, j++ ) {

                if (FsRtlIsLeadDbcsCharacter(inBuffer[i])) {

                    if (i+1 < inLength) {
                        Output8dot3[j] = inBuffer[i];
                        i++; j++;
                        Output8dot3[j] = inBuffer[i];
                    } else {
                        break;
                    }

                } else {

                    Output8dot3[j] = inBuffer[i];

                }
            }

        } else {

            for ( j = 8;
                  (i < inLength) && (inBuffer[i] != '\\');
                  i++, j++ ) {

                Output8dot3[j] = inBuffer[i];
            }
        }
    }

    //
    // We're all done with the conversion.
    //

    return;

} // SrvOemStringTo8dot3


VOID
SrvUnicodeStringTo8dot3 (
    IN PUNICODE_STRING InputString,
    OUT PSZ Output8dot3,
    IN BOOLEAN Upcase
    )

/*++

Routine Description:

    Convert a string into fat 8.3 format.  This derived from GaryKi's
    routine FatStringTo8dot3 in fat\fatname.c.

Arguments:

    InputString - Supplies the input string to convert

    Output8dot3 - Receives the converted string, the memory must be supplied
        by the caller.

    Upcase - Whether the string is to be uppercased.

Return Value:

    None.

--*/

{
    ULONG oemSize;
    OEM_STRING oemString;
    ULONG index = 0;
    UCHAR aSmallBuffer[ 50 ];
    NTSTATUS status;

    PAGED_CODE( );

    oemSize = RtlUnicodeStringToOemSize( InputString );

    ASSERT( oemSize < MAXUSHORT );

    if( oemSize <= sizeof( aSmallBuffer ) ) {
        oemString.Buffer = aSmallBuffer;
    } else {
        oemString.Buffer = ALLOCATE_HEAP( oemSize, BlockTypeBuffer );
        if( oemString.Buffer == NULL ) {
           *Output8dot3 = '\0';
            return;
        }
    }

    oemString.MaximumLength = (USHORT)oemSize;
    oemString.Length = (USHORT)oemSize - 1;

    if ( Upcase ) {

        status = RtlUpcaseUnicodeToOemN(
                    oemString.Buffer,
                    oemString.Length,
                    &index,
                    InputString->Buffer,
                    InputString->Length
                    );

        ASSERT( NT_SUCCESS( status ) );


    } else {

        status = RtlUnicodeToOemN(
                    oemString.Buffer,
                    oemString.Length,
                    &index,
                    InputString->Buffer,
                    InputString->Length
                    );

        ASSERT( NT_SUCCESS( status ) );
    }

    if( NT_SUCCESS( status ) ) {

        oemString.Buffer[ index ] = '\0';

        SrvOemStringTo8dot3(
                    &oemString,
                    Output8dot3
                    );
    } else {

        *Output8dot3 = '\0';
    }

    if( oemSize > sizeof( aSmallBuffer ) ) {
        FREE_HEAP( oemString.Buffer );
    }

} // SrvUnicodeStringTo8dot3

#if SRVDBG_STATS
VOID SRVFASTCALL
SrvUpdateStatistics2 (
    PWORK_CONTEXT WorkContext,
    UCHAR SmbCommand
    )

/*++

Routine Description:

    Update the server statistics database to reflect the work item
    that is being completed.

Arguments:

    WorkContext - pointer to the work item containing the statistics
        for this request.

    SmbCommand - The SMB command code of the current operation.

Return Value:

    None.

--*/

{
    if ( WorkContext->StartTime != 0 ) {

        LARGE_INTEGER td;

        td.QuadPart = WorkContext->CurrentWorkQueue->stats.SystemTime - WorkContext->StartTime;

        //
        // Update the SMB-specific statistics fields.
        //
        // !!! doesn't work for original transact smb--SmbCommand is too
        //     large.

        //ASSERT( SmbCommand <= MAX_STATISTICS_SMB );

        if ( SmbCommand <= MAX_STATISTICS_SMB ) {
            SrvDbgStatistics.Smb[SmbCommand].SmbCount++;
            SrvDbgStatistics.Smb[SmbCommand].TotalTurnaroundTime.QuadPart +=
                td.QuadPart;
        }

#if 0 // this code is no longer valid!
        //
        // Update the size-dependent IO fields if necessary.  The arrays
        // in SrvStatistics correspond to powers of two sizes for the IO.
        // The correspondence between array location and IO size is:
        //
        //     Location        IO Size (min)
        //        0                  0
        //        1                  1
        //        2                  2
        //        3                  4
        //        4                  8
        //        5                 16
        //        6                 32
        //        7                 64
        //        8                128
        //        9                256
        //       10                512
        //       11               1024
        //       12               2048
        //       13               4096
        //       14               8192
        //       15              16384
        //       16              32768
        //

        if ( WorkContext->BytesRead != 0 ) {

            CLONG i;

            for ( i = 0;
                  i < 17 && WorkContext->BytesRead != 0;
                  i++, WorkContext->BytesRead >>= 1 );

            SrvDbgStatistics.ReadSize[i].SmbCount++;
            SrvDbgStatistics.ReadSize[i].TotalTurnaroundTime.QuadPart +=
                td.QuadPart;
        }

        if ( WorkContext->BytesWritten != 0 ) {

            CLONG i;

            for ( i = 0;
                  i < 17 && WorkContext->BytesWritten != 0;
                  i++, WorkContext->BytesWritten >>= 1 );

            SrvDbgStatistics.WriteSize[i].SmbCount++;
            SrvDbgStatistics.WriteSize[i].TotalTurnaroundTime.QuadPart +=
                td.QuadPart;
        }
#endif

    }

    return;

} // SrvUpdateStatistics2
#endif // SRVDBG_STATS


PRFCB
SrvVerifyFid2 (
    IN PWORK_CONTEXT WorkContext,
    IN USHORT Fid,
    IN BOOLEAN FailOnSavedError,
    IN PRESTART_ROUTINE SerializeWithRawRestartRoutine OPTIONAL,
    OUT PNTSTATUS NtStatus
    )

/*++

Routine Description:

    Verifies the FID, TID, and UID in an incoming SMB.  If they are
    valid, the address of the RFCB corresponding to the FID is returned,
    and the block is referenced.

Arguments:

    WorkContext - Supplies a pointer to the work context block for the
        current SMB.  In particular, the Connection block pointer is
        used to find the appropriate file table.  If the FID is valid,
        the RFCB address is stored in WorkContext->Rfcb.

    Fid - Supplies the FID sent in the request SMB

    FailOnSavedError - If TRUE, return NULL to the caller if there is
        an outstanding write behind error.  If FALSE, always attempt
        to return a pointer to the RFCB.

    SerializeWithRawRestartRoutine - If not NULL, is the address of an
        FSP restart routine, and specifies that this operation should be
        queued if a raw write is currently in progress on the file.  If
        this is the case, this routine queues the work context block to
        a queue in the RFCB.  When the raw write completes, all work
        items on the queue are restarted.

    NtStatus - This field is filled in only when this function returns
        NULL.  If there was a write behind error, NtStatus returns the
        write behind error status, otherwise it returns
        STATUS_INVALID_HANDLE.

Return Value:

    PRFCB - Address of the RFCB, or SRV_INVALID_RFCB_POINTER if the Fid
        was invalid, or if there is a raw write in progress and
        serialization was requested (in which case *NtStatus is set
        to STATUS_SUCCESS).

--*/

{
    PCONNECTION connection;
    PTABLE_HEADER tableHeader;
    PRFCB rfcb;
    USHORT index;
    USHORT sequence;
    KIRQL oldIrql;

#if 0
    // THIS IS NOW DONE IN THE SrvVerifyFid MACRO.
    //
    // If the FID has already been verified, return the RFCB pointer.
    //
    // *** Note that we don't do the saved error checking or the raw
    //     write serialization in this case, on the assumption that
    //     since we already passed the checks once (in order to get the
    //     RFCB pointer in the first place), we don't need to do them
    //     again.
    //

    if ( WorkContext->Rfcb != NULL ) {
        return WorkContext->Rfcb;
    }
#endif

    //
    // Initialize local variables:  obtain the connection block address
    // and crack the FID into its components.
    //

    connection = WorkContext->Connection;

    //
    // Acquire the spin lock that guards the connection's file table.
    //

    ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );

    //
    // See if this is the cached rfcb
    //

    if ( connection->CachedFid == (ULONG)Fid ) {

        rfcb = connection->CachedRfcb;

    } else {

        //
        // Verify that the FID is in range, is in use, and has the correct
        // sequence number.

        index = FID_INDEX( Fid );
        sequence = FID_SEQUENCE( Fid );
        tableHeader = &connection->FileTable;

        if ( (index >= tableHeader->TableSize) ||
             (tableHeader->Table[index].Owner == NULL) ||
             (tableHeader->Table[index].SequenceNumber != sequence) ) {

            *NtStatus = STATUS_INVALID_HANDLE;
            goto error_exit;
        }

        rfcb = tableHeader->Table[index].Owner;

        if ( GET_BLOCK_STATE(rfcb) != BlockStateActive ) {

            *NtStatus = STATUS_INVALID_HANDLE;
            goto error_exit;
        }

        //
        // If the caller wants to fail when there is a write behind
        // error and the error exists, fill in NtStatus and do not
        // return the RFCB pointer.
        //

        if ( !NT_SUCCESS(rfcb->SavedError) && FailOnSavedError ) {

            if ( !NT_SUCCESS(rfcb->SavedError) ) {
                *NtStatus = rfcb->SavedError;
                rfcb->SavedError = STATUS_SUCCESS;
                goto error_exit;
            }
        }

        //
        // Cache the fid.
        //

        connection->CachedRfcb = rfcb;
        connection->CachedFid = (ULONG)Fid;
    }

    //
    // The FID is valid within the context of this connection.  Verify
    // that the owning tree connect's TID is correct.
    //
    // Do not verify the UID for clients that do not understand it.
    //

    if ( (rfcb->Tid !=
                SmbGetAlignedUshort( &WorkContext->RequestHeader->Tid )) ||
         ((rfcb->Uid !=
                SmbGetAlignedUshort( &WorkContext->RequestHeader->Uid )) &&
           DIALECT_HONORS_UID(connection->SmbDialect)) ) {

        *NtStatus = STATUS_INVALID_HANDLE;
        goto error_exit;
    }

    //
    // If raw write serialization was requested, and a raw write
    // is active, queue this work item in the RFCB pending
    // completion of the raw write.
    //

    if ( (rfcb->RawWriteCount != 0) &&
         ARGUMENT_PRESENT(SerializeWithRawRestartRoutine) ) {

        InsertTailList(
            &rfcb->RawWriteSerializationList,
            &WorkContext->ListEntry
            );

        WorkContext->FspRestartRoutine = SerializeWithRawRestartRoutine;
        *NtStatus = STATUS_SUCCESS;
        goto error_exit;
    }

    //
    // The file is active and the TID is valid.  Reference the
    // RFCB.  Release the spin lock (we don't need it anymore).
    //

    rfcb->BlockHeader.ReferenceCount++;
    UPDATE_REFERENCE_HISTORY( rfcb, FALSE );

    RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

    //
    // Save the RFCB address in the work context block and
    // return the file address.
    //

    WorkContext->Rfcb = rfcb;

    //
    // Mark the rfcb as active
    //

    rfcb->IsActive = TRUE;

    ASSERT( GET_BLOCK_TYPE( rfcb->Mfcb ) == BlockTypeMfcb );

    return rfcb;

error_exit:

    //
    // Either the FID is invalid for this connection, the file is
    // closing, or the TID doesn't match.  Release the lock, clear the
    // file address in the work context block, and return a file address
    // of NULL.
    //

    WorkContext->Rfcb = NULL;   // connection spinlock must be held
    RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

    return SRV_INVALID_RFCB_POINTER;

} // SrvVerifyFid2


PRFCB
SrvVerifyFidForRawWrite (
    IN PWORK_CONTEXT WorkContext,
    IN USHORT Fid,
    OUT PNTSTATUS NtStatus
    )

/*++

Routine Description:

    Verifies the FID, TID, and UID in an incoming SMB.  If they are
    valid, the address of the RFCB corresponding to the FID is returned,
    and the block is referenced.  In addition, the RawWriteCount in the
    RFCB is incremented.

Arguments:

    WorkContext - Supplies a pointer to the work context block for the
        current SMB.  In particular, the Connection block pointer is
        used to find the appropriate file table.  If the FID is valid,
        the RFCB address is stored in WorkContext->Rfcb.

    Fid - Supplies the FID sent in the request SMB

    NtStatus - This field is filled in only when this function returns
        NULL.  If there was a write behind error, NtStatus returns the
        write behind error status, otherwise it returns
        STATUS_INVALID_HANDLE.

Return Value:

    PRFCB - Address of the RFCB, or SRV_INVALID_RFCB_POINTER if the Fid
        was invalid, or if there is a raw write in progress and
        serialization was requested (in which case *NtStatus is set
        to STATUS_SUCCESS).

--*/

{
    PCONNECTION connection;
    PTABLE_HEADER tableHeader;
    PRFCB rfcb;
    USHORT index;
    USHORT sequence;
    KIRQL oldIrql;

    ASSERT( WorkContext->Rfcb == NULL );

    //
    // Initialize local variables:  obtain the connection block address
    // and crack the FID into its components.
    //

    connection = WorkContext->Connection;

    //
    // Acquire the spin lock that guards the connection's file table.
    //

    ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );

    //
    // See if this is the cached rfcb
    //

    if ( connection->CachedFid == Fid ) {

        rfcb = connection->CachedRfcb;

    } else {

        //
        // Verify that the FID is in range, is in use, and has the correct
        // sequence number.

        index = FID_INDEX( Fid );
        sequence = FID_SEQUENCE( Fid );
        tableHeader = &connection->FileTable;

        if ( (index >= tableHeader->TableSize) ||
             (tableHeader->Table[index].Owner == NULL) ||
             (tableHeader->Table[index].SequenceNumber != sequence) ) {

            *NtStatus = STATUS_INVALID_HANDLE;
            goto error_exit;
        }

        rfcb = tableHeader->Table[index].Owner;

        if ( GET_BLOCK_STATE(rfcb) != BlockStateActive ) {

            *NtStatus = STATUS_INVALID_HANDLE;
            goto error_exit;
        }

        //
        // If there is a write behind error, fill in NtStatus and do
        // not return the RFCB pointer.
        //

        if ( !NT_SUCCESS( rfcb->SavedError ) ) {
            if ( !NT_SUCCESS( rfcb->SavedError ) ) {
                *NtStatus = rfcb->SavedError;
                rfcb->SavedError = STATUS_SUCCESS;
                goto error_exit;
            }
        }

        connection->CachedRfcb = rfcb;
        connection->CachedFid = (ULONG)Fid;

        //
        // The FID is valid within the context of this connection.  Verify
        // that the owning tree connect's TID is correct.
        //
        // Do not verify the UID for clients that do not understand it.
        //

        if ( (rfcb->Tid !=
                 SmbGetAlignedUshort(&WorkContext->RequestHeader->Tid)) ||
             ( (rfcb->Uid !=
                 SmbGetAlignedUshort(&WorkContext->RequestHeader->Uid)) &&
               DIALECT_HONORS_UID(connection->SmbDialect) ) ) {
            *NtStatus = STATUS_INVALID_HANDLE;
            goto error_exit;
        }
    }

    //
    // If a raw write is already active, queue this work item in
    // the RFCB pending completion of the raw write.
    //

    if ( rfcb->RawWriteCount != 0 ) {

        InsertTailList(
            &rfcb->RawWriteSerializationList,
            &WorkContext->ListEntry
            );

        WorkContext->FspRestartRoutine = SrvRestartSmbReceived;
        *NtStatus = STATUS_SUCCESS;
        goto error_exit;
    }

    //
    // The file is active and the TID is valid.  Reference the
    // RFCB and increment the raw write count.  Release the spin
    // lock (we don't need it anymore).
    //

    rfcb->BlockHeader.ReferenceCount++;
    UPDATE_REFERENCE_HISTORY( rfcb, FALSE );

    rfcb->RawWriteCount++;

    RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

    //
    // Save the RFCB address in the work context block and
    // return the file address.
    //

    WorkContext->Rfcb = rfcb;
    ASSERT( GET_BLOCK_TYPE( rfcb->Mfcb ) == BlockTypeMfcb );

    //
    // Mark the rfcb as active
    //

    rfcb->IsActive = TRUE;

    return rfcb;

error_exit:

    //
    // Either the FID is invalid for this connection, the file is
    // closing, or the TID and UID don't match.  Clear the file address
    // in the work context block, and return a file address of NULL.
    //

    WorkContext->Rfcb = NULL;   // connection spinlock must be held
    RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

    return SRV_INVALID_RFCB_POINTER;

} // SrvVerifyFidForRawWrite


PSEARCH
SrvVerifySid (
    IN PWORK_CONTEXT WorkContext,
    IN USHORT Index,
    IN USHORT Sequence,
    IN PSRV_DIRECTORY_INFORMATION DirectoryInformation,
    IN CLONG BufferSize
    )

/*++

Routine Description:

    Verifies the SID in the resume key of a Search or Find SMB.  If the
    SID is valid, the address of the search block corresponding to the
    SID is returned.  The appropiate fields in the DirectoryInformation
    structure are filled in so that SrvQueryDirectoryFile may be called.

Arguments:

    WorkContext - Supplies a pointer to the work context block for the
        current SMB.  In particular, the Connection block pointer is
        used to find the appropriate search table.

    ResumeKey - a pointer the the resume key to evaluate.

Return Value:

    PSEARCH - address of the Search block, or NULL.

--*/

{
    PCONNECTION connection;
    PTABLE_HEADER tableHeader;
    PSEARCH search;

    PAGED_CODE( );

    connection = WorkContext->Connection;

    //
    // Acquire the connection's lock.
    //

    ACQUIRE_LOCK( &connection->Lock );

    //
    // Verify that the index is in range, that the search block is in use,
    // and that the resume key has the correct sequence number.
    //

    tableHeader = &connection->PagedConnection->SearchTable;
    if ( (Index < tableHeader->TableSize) &&
         (tableHeader->Table[Index].Owner != NULL) &&
         (tableHeader->Table[Index].SequenceNumber == Sequence) ) {

        search = tableHeader->Table[Index].Owner;

        //
        // The SID is valid.  Verify that the search block is still
        // active.
        //
        // !!! Does this really apply for search blocks?
        //

        if ( GET_BLOCK_STATE(search) != BlockStateActive || search->InUse ) {

            //
            // The search block is no longer active or somebody is
            // already using the search block.
            //

            search = NULL;

        } else {

            //
            // We found a legitimate search block, so reference it.
            //

            SrvReferenceSearch( search );

            //
            // Fill in fields of DirectoryInformation.
            //

            DirectoryInformation->DirectoryHandle = search->DirectoryHandle;
            DirectoryInformation->CurrentEntry = NULL;
            DirectoryInformation->BufferLength = BufferSize -
                sizeof(SRV_DIRECTORY_INFORMATION);
            DirectoryInformation->Wildcards = search->Wildcards;
            DirectoryInformation->ErrorOnFileOpen = FALSE;
            DirectoryInformation->DownlevelTimewarp = search->DownlevelTimewarp;

            //
            // Indicate that the search is being used.
            //

            search->InUse = TRUE;
        }

    } else {

        //
        // The SID is invalid.
        //

        search = NULL;

    }

    //
    // Release the lock and return the search block address (or NULL).
    //

    RELEASE_LOCK( &connection->Lock );

    return search;

} // SrvVerifySid


PTREE_CONNECT
SrvVerifyTid (
    IN PWORK_CONTEXT WorkContext,
    IN USHORT Tid
    )

/*++

Routine Description:

    Verifies the TID in an incoming SMB.  If the TID is valid, the
    address of the tree connect block corresponding to the TID is
    returned, and the block is referenced.

Arguments:

    WorkContext - Supplies a pointer to the work context block for the
        current SMB.  In particular, the Connection block pointer is
        used to find the appropriate tree table.  Also, the tree connect
        block address, if the TID is valid, is stored in
        WorkContext->TreeConnect.

    Tid - Supplies the TID sent in the request SMB

Return Value:

    PTREE_CONNECT - Address of the tree connect block, or NULL

--*/

{
    PCONNECTION connection;
    PTREE_CONNECT treeConnect;
    PTABLE_HEADER tableHeader;
    USHORT index;
    USHORT sequence;

    PAGED_CODE( );

    //
    // If the TID has already been verified, return the tree connect
    // pointer.
    //

    if ( WorkContext->TreeConnect != NULL ) {
        return WorkContext->TreeConnect;
    }

    //
    // Initialize local variables:  obtain the connection block address
    // and crack the TID into its components.
    //

    connection = WorkContext->Connection;
    index = TID_INDEX( Tid );
    sequence = TID_SEQUENCE( Tid );

    //
    // Acquire the connection's tree connect lock.
    //

    ACQUIRE_LOCK( &connection->Lock );

    //
    // Verify that the TID is in range, is in use, and has the correct
    // sequence number.

    tableHeader = &connection->PagedConnection->TreeConnectTable;
    if ( (index < tableHeader->TableSize) &&
         (tableHeader->Table[index].Owner != NULL) &&
         (tableHeader->Table[index].SequenceNumber == sequence) ) {

        treeConnect = tableHeader->Table[index].Owner;

        //
        // The TID is valid within the context of this connection.
        // Verify that the tree connect is still active.
        //

        if ( GET_BLOCK_STATE(treeConnect) == BlockStateActive ) {

            //
            // The tree connect is active.  Reference it.
            //

            SrvReferenceTreeConnect( treeConnect );

        } else {

            //
            // The tree connect is closing.
            //

            treeConnect = NULL;

        }

    } else {

        //
        // The TID is invalid for this connection.
        //

        treeConnect = NULL;

    }

    //
    // Release the lock, save the tree connect address in the work context
    // block, and return the tree connect address (or NULL).
    //

    RELEASE_LOCK( &connection->Lock );

    WorkContext->TreeConnect = treeConnect;

    return treeConnect;

} // SrvVerifyTid


PSESSION
SrvVerifyUid (
    IN PWORK_CONTEXT WorkContext,
    IN USHORT Uid
    )

/*++

Routine Description:

    Verifies the UID in an incoming SMB.  If the UID is valid, the
    address of the session block corresponding to the UID is returned,
    and the block is referenced.

Arguments:

    WorkContext - Supplies a pointer to the work context block for the
        current SMB.  In particular, the Connection block pointer is
        used to find the appropriate user table.  Also, the session block
        address, if the UID is valid, is stored in WorkContext->Session.

    Uid - Supplies the UID sent in the request SMB

Return Value:

    PSESSION - Address of the session block, or NULL

--*/

{
    PCONNECTION connection;
    PTABLE_HEADER tableHeader;
    PSESSION session;
    PSECURITY_CONTEXT securityContext;
    USHORT index;
    USHORT sequence;

    PAGED_CODE( );

    //
    // If the UID has already been verified, return the session pointer.
    //

    if ( WorkContext->Session != NULL ) {
        return WorkContext->Session;
    }

    //
    // Initialize local variables:  obtain the connection block address
    // and crack the UID into its components.
    //

    connection = WorkContext->Connection;
    index = UID_INDEX( Uid );
    sequence = UID_SEQUENCE( Uid );

    //
    // Acquire the connection's session lock.
    //

    ACQUIRE_LOCK( &connection->Lock );

    //
    // If this is a down-level (LAN Man 1.0 or earlier) client, than
    // we will not receive a UID, and there will only be one session
    // per connection.  Reference that session.
    //

    tableHeader = &connection->PagedConnection->SessionTable;
    if (!DIALECT_HONORS_UID(connection->SmbDialect) ) {

        session = tableHeader->Table[0].Owner;

    } else if ( (index < tableHeader->TableSize) &&
         (tableHeader->Table[index].Owner != NULL) &&
         (tableHeader->Table[index].SequenceNumber == sequence) ) {

        //
        // The UID is in range, is in use, and has the correct sequence
        // number.
        //

        session = tableHeader->Table[index].Owner;

    } else {

        //
        // The UID is invalid for this connection.
        //

        IF_DEBUG( ERRORS ) {
            KdPrint(( "SrvVerifyUid: index %d, size %d\n", index, tableHeader->TableSize ));
            if( index < tableHeader->TableSize ) {
                KdPrint(("    Owner %p, Table.SequenceNumber %d, seq %d\n",
                    tableHeader->Table[index].Owner,
                    tableHeader->Table[index].SequenceNumber,
                    sequence
                ));
            }
        }

        session = NULL;
    }

    if ( session != NULL ) {

        //
        // The UID is valid within the context of this connection.
        // Verify that the session is still active.
        //

        if ( GET_BLOCK_STATE(session) == BlockStateActive ) {

            LARGE_INTEGER liNow;

            KeQuerySystemTime( &liNow);

            if( session->LogonSequenceInProgress == FALSE &&
                liNow.QuadPart >= session->LogOffTime.QuadPart )
            {
                IF_DEBUG( ERRORS ) {
                    KdPrint(( "SrvVerifyUid: LogOffTime has passed %x %x\n",
                        session->LogOffTime.HighPart,
                        session->LogOffTime.LowPart
                    ));
                }

                // Mark the session as expired
                session->IsSessionExpired = TRUE;
                KdPrint(( "Marking session as expired.\n" ));
            }

            //
            // The session is active.  Reference it.
            //

            SrvReferenceSession( session );

            securityContext = session->SecurityContext;
            if( securityContext != NULL ) SrvReferenceSecurityContext( securityContext );

            //
            // Update the last use time for autologoff.
            //

            session->LastUseTime = liNow;

        } else {

            //
            // The session is closing.
            //

            IF_DEBUG( ERRORS ) {
                KdPrint(( "SrvVerifyUid: Session state %x\n",  GET_BLOCK_STATE( session ) ));
            }

            session = NULL;
            securityContext = NULL;
        }
    }
    else
    {
        securityContext = NULL;
    }

    //
    // Release the lock, save the session address in the work context
    // block, and return the session address (or NULL).
    //

    RELEASE_LOCK( &connection->Lock );

    WorkContext->Session = session;
    WorkContext->SecurityContext = securityContext;

    return session;

} // SrvVerifyUid


NTSTATUS
SrvVerifyUidAndTid (
    IN  PWORK_CONTEXT WorkContext,
    OUT PSESSION *Session,
    OUT PTREE_CONNECT *TreeConnect,
    IN  SHARE_TYPE ShareType
    )

/*++

Routine Description:

    Verifies the UID and TID in an incoming SMB.  If both the UID and
    the TDI are valid, the addresses of the session/tree connect blocks
    corresponding to the UID/TID are returned, and the blocks are
    referenced.

Arguments:

    WorkContext - Supplies a pointer to the work context block for the
        current SMB.  In particular, the Connection block pointer is
        used to find the appropriate user table.  If the UID and TID are
        valid, the session/tree connect block addresses are stored in
        WorkContext->Session and WorkContext->TreeConnect.

    Uid - Supplies the UID sent in the request SMB

    Tid - Supplies the TID sent in the request SMB

    Session - Returns a pointer to the session block

    TreeConnect - Returns a pointer to the tree connect block

    ShareType - the type of share it should be

Return Value:

    NTSTATUS - STATUS_SUCCESS, STATUS_SMB_BAD_UID, or STATUS_SMB_BAD_TID

--*/

{
    PCONNECTION connection;
    PSESSION session;
    PTREE_CONNECT treeConnect;
    PPAGED_CONNECTION pagedConnection;
    PTABLE_HEADER tableHeader;
    USHORT index;
    USHORT Uid;
    USHORT Tid;
    USHORT sequence;
    LARGE_INTEGER liNow;

    PAGED_CODE( );

    KeQuerySystemTime(&liNow);

    //
    // If the UID and TID have already been verified, don't do all this
    // work again.
    //

    if ( (WorkContext->Session != NULL) &&
         (WorkContext->TreeConnect != NULL) ) {

        if( ShareType != ShareTypeWild &&
            WorkContext->TreeConnect->Share->ShareType != ShareType ) {
            return STATUS_ACCESS_DENIED;
        }

        *Session = WorkContext->Session;
        *TreeConnect = WorkContext->TreeConnect;

        return STATUS_SUCCESS;
    }

    //
    // Obtain the connection block address and lock the connection.
    //

    connection = WorkContext->Connection;
    pagedConnection = connection->PagedConnection;

    ACQUIRE_LOCK( &connection->Lock );

    //
    // If we haven't negotiated successfully with this client, then we have
    //  a failure
    //
    if( connection->SmbDialect == SmbDialectIllegal) {
        RELEASE_LOCK( &connection->Lock );
        return STATUS_INVALID_SMB;
    }

    //
    // If the UID has already been verified, don't verify it again.
    //

    if ( WorkContext->Session != NULL ) {

        session = WorkContext->Session;

    } else {

        //
        // Crack the UID into its components.
        //

        Uid = SmbGetAlignedUshort( &WorkContext->RequestHeader->Uid ),
        index = UID_INDEX( Uid );
        sequence = UID_SEQUENCE( Uid );

        //
        // If this is a down-level (LAN Man 1.0 or earlier) client, than
        // we will not receive a UID, and there will only be one session
        // per connection.  Reference that session.
        //
        // For clients that do send UIDs, verify that the UID is in
        // range, is in use, and has the correct sequence number, and
        // that the session is not closing.
        //

        tableHeader = &pagedConnection->SessionTable;


        if (!DIALECT_HONORS_UID(connection->SmbDialect))
        {
            session = tableHeader->Table[0].Owner;
        }
        else if( (index >= tableHeader->TableSize) ||
                 ((session = tableHeader->Table[index].Owner) == NULL) ||
                 (tableHeader->Table[index].SequenceNumber != sequence) ||
                 (GET_BLOCK_STATE(session) != BlockStateActive) )
        {

            //
            // The UID is invalid for this connection, or the session is
            // closing.
            //

            RELEASE_LOCK( &connection->Lock );

            return STATUS_SMB_BAD_UID;

        }

        //
        // it's valid
        //

        if( session == NULL )
        {
            RELEASE_LOCK( &connection->Lock );

            return STATUS_SMB_BAD_UID;
        }

        if( session->LogonSequenceInProgress == FALSE &&
            liNow.QuadPart >= session->LogOffTime.QuadPart )
        {
            // Mark the session as expired
            session->IsSessionExpired = TRUE;
        }

    }

    //
    // The UID is valid.  Check the TID.  If the TID has already been
    // verified, don't verify it again.
    //

    if ( WorkContext->TreeConnect != NULL ) {

        treeConnect = WorkContext->TreeConnect;

    } else {

        //
        // Crack the TID into its components.
        //

        Tid = SmbGetAlignedUshort( &WorkContext->RequestHeader->Tid ),
        index = TID_INDEX( Tid );
        sequence = TID_SEQUENCE( Tid );

        //
        // Verify that the TID is in range, is in use, and has the
        // correct sequence number, and that the tree connect is not
        // closing.
        //

        tableHeader = &pagedConnection->TreeConnectTable;
        if ( (index >= tableHeader->TableSize) ||
             ((treeConnect = tableHeader->Table[index].Owner) == NULL) ||
             (tableHeader->Table[index].SequenceNumber != sequence) ||
             (GET_BLOCK_STATE(treeConnect) != BlockStateActive) ) {

            //
            // The TID is invalid for this connection, or the tree
            // connect is closing.
            //

            RELEASE_LOCK( &connection->Lock );

            return STATUS_SMB_BAD_TID;

        }

        //
        // Make sure this is not a Null session trying to sneak in
        // through an established tree connect.
        //

        if ( session->IsNullSession &&
             SrvRestrictNullSessionAccess &&
             ( treeConnect->Share->ShareType != ShareTypePipe ) ) {


            BOOLEAN matchFound = FALSE;
            ULONG i;

            ACQUIRE_LOCK_SHARED( &SrvConfigurationLock );

            for ( i = 0; SrvNullSessionShares[i] != NULL ; i++ ) {

                if ( _wcsicmp(
                        SrvNullSessionShares[i],
                        treeConnect->Share->ShareName.Buffer
                        ) == 0 ) {

                    matchFound = TRUE;
                    break;
                }
            }

            RELEASE_LOCK( &SrvConfigurationLock );

            //
            // The null session is not allowed to access this share - reject.
            //

            if ( !matchFound ) {

                RELEASE_LOCK( &connection->Lock );
                return(STATUS_ACCESS_DENIED);
            }
        }
    }

    //
    // Both the UID and the TID are valid.  Reference the session and
    // tree connect blocks.
    //

    if ( WorkContext->Session == NULL ) {

        SrvReferenceSession( session );
        WorkContext->Session = session;

        if( session->SecurityContext != NULL )
        {
            SrvReferenceSecurityContext( session->SecurityContext );
            WorkContext->SecurityContext = session->SecurityContext;
        }

        //
        // Update the last use time for autologoff.
        //

        session->LastUseTime = liNow;

    }

    if ( WorkContext->TreeConnect == NULL ) {

        SrvReferenceTreeConnect( treeConnect );
        WorkContext->TreeConnect = treeConnect;

    }

    //
    // Release the connection lock and return success.
    //

    RELEASE_LOCK( &connection->Lock );

    *Session = session;
    *TreeConnect = treeConnect;

    //
    // Make sure this is the correct type of share
    //
    if( ShareType != ShareTypeWild && (*TreeConnect)->Share->ShareType != ShareType ) {
        return STATUS_ACCESS_DENIED;
    }

    return STATUS_SUCCESS;

} // SrvVerifyUidAndTid


BOOLEAN
SrvReceiveBufferShortage (
    VOID
    )

/*++

Routine Description:

    This function calculates if the server is running low on receive
    work items that are not involved in blocking operations.

Arguments:

    None.

Return Value:

    TRUE - The server is running short on receive work items.
    FALSE - The server is *not* running short on receive work items.

--*/

{
    KIRQL oldIrql;
    BOOLEAN bufferShortage;
    PWORK_QUEUE queue = PROCESSOR_TO_QUEUE();

    //
    // Even if we have reached our limit, we will allow this blocking
    // operation if we have enough free work items to allocate.  This
    // will allow the resource thread to allocate more work items to
    // service blocking requests.
    //

    if ( (queue->FreeWorkItems < queue->MaximumWorkItems) ||
         ((queue->FreeWorkItems - SrvBlockingOpsInProgress)
                                 > SrvMinFreeWorkItemsBlockingIo) ) {

        //
        // The caller will start a blocking operation.  Increment the
        // blocking operation count.
        //

        InterlockedIncrement( &SrvBlockingOpsInProgress );
        bufferShortage = FALSE;

    } else {

        //
        // The server is running short on uncommitted receive work items.
        //

        bufferShortage = TRUE;
    }

    return bufferShortage;

} // SrvReceiveBufferShortage

#if SMBDBG

//
// The following functions are defined in smbgtpt.h.  When debug mode is
// disabled (!SMBDBG), these functions are instead defined as macros.
//

USHORT
SmbGetUshort (
    IN PSMB_USHORT SrcAddress
    )

{
    return (USHORT)(
            ( ( (PUCHAR)(SrcAddress) )[0]       ) |
            ( ( (PUCHAR)(SrcAddress) )[1] <<  8 )
            );
}

USHORT
SmbGetAlignedUshort (
    IN PUSHORT SrcAddress
    )

{
    return *(SrcAddress);
}

VOID
SmbPutUshort (
    OUT PSMB_USHORT DestAddress,
    IN USHORT Value
    )

{
    ( (PUCHAR)(DestAddress) )[0] = BYTE_0(Value);
    ( (PUCHAR)(DestAddress) )[1] = BYTE_1(Value);
    return;
}

VOID
SmbPutAlignedUshort (
    OUT PUSHORT DestAddress,
    IN USHORT Value
    )

{
    *(DestAddress) = (Value);
    return;
}

ULONG
SmbGetUlong (
    IN PSMB_ULONG SrcAddress
    )

{
    return (ULONG)(
            ( ( (PUCHAR)(SrcAddress) )[0]       ) |
            ( ( (PUCHAR)(SrcAddress) )[1] <<  8 ) |
            ( ( (PUCHAR)(SrcAddress) )[2] << 16 ) |
            ( ( (PUCHAR)(SrcAddress) )[3] << 24 )
            );
}

ULONG
SmbGetAlignedUlong (
    IN PULONG SrcAddress
    )

{
    return *(SrcAddress);
}

VOID
SmbPutUlong (
    OUT PSMB_ULONG DestAddress,
    IN ULONG Value
    )

{
    ( (PUCHAR)(DestAddress) )[0] = BYTE_0(Value);
    ( (PUCHAR)(DestAddress) )[1] = BYTE_1(Value);
    ( (PUCHAR)(DestAddress) )[2] = BYTE_2(Value);
    ( (PUCHAR)(DestAddress) )[3] = BYTE_3(Value);
    return;
}

VOID
SmbPutAlignedUlong (
    OUT PULONG DestAddress,
    IN ULONG Value
    )

{
    *(DestAddress) = Value;
    return;
}

VOID
SmbPutDate (
    OUT PSMB_DATE DestAddress,
    IN SMB_DATE Value
    )

{
    ( (PUCHAR)&(DestAddress)->Ushort )[0] = BYTE_0(Value.Ushort);
    ( (PUCHAR)&(DestAddress)->Ushort )[1] = BYTE_1(Value.Ushort);
    return;
}

VOID
SmbMoveDate (
    OUT PSMB_DATE DestAddress,
    IN PSMB_DATE SrcAddress
    )

{
    (DestAddress)->Ushort = (USHORT)(
        ( ( (PUCHAR)&(SrcAddress)->Ushort )[0]       ) |
        ( ( (PUCHAR)&(SrcAddress)->Ushort )[1] <<  8 ) );
    return;
}

VOID
SmbZeroDate (
    IN PSMB_DATE Date
    )

{
    (Date)->Ushort = 0;
}

BOOLEAN
SmbIsDateZero (
    IN PSMB_DATE Date
    )

{
    return (BOOLEAN)( (Date)->Ushort == 0 );
}

VOID
SmbPutTime (
    OUT PSMB_TIME DestAddress,
    IN SMB_TIME Value
    )

{
    ( (PUCHAR)&(DestAddress)->Ushort )[0] = BYTE_0(Value.Ushort);
    ( (PUCHAR)&(DestAddress)->Ushort )[1] = BYTE_1(Value.Ushort);
    return;
}

VOID
SmbMoveTime (
    OUT PSMB_TIME DestAddress,
    IN PSMB_TIME SrcAddress
    )

{
    (DestAddress)->Ushort = (USHORT)(
        ( ( (PUCHAR)&(SrcAddress)->Ushort )[0]       ) |
        ( ( (PUCHAR)&(SrcAddress)->Ushort )[1] <<  8 ) );
    return;
}

VOID
SmbZeroTime (
    IN PSMB_TIME Time
    )

{
    (Time)->Ushort = 0;
}

BOOLEAN
SmbIsTimeZero (
    IN PSMB_TIME Time
    )

{
    return (BOOLEAN)( (Time)->Ushort == 0 );
}

#endif // SMBDBG


NTSTATUS
SrvIoCreateFile (
    IN PWORK_CONTEXT WorkContext,
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG Disposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength,
    IN CREATE_FILE_TYPE CreateFileType,
    IN PVOID ExtraCreateParameters OPTIONAL,
    IN ULONG Options,
    IN PSHARE Share OPTIONAL
    )
{
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    NTSTATUS status;
    NTSTATUS tempStatus;
    BOOLEAN dispositionModified = FALSE;
    ULONG eventToLog = 0;
    ULONG newUsage;
    ULONG requiredSize;
    SHARE_TYPE shareType = ShareTypeWild;
    UNICODE_STRING fileName, *pName;

#if SRVDBG_STATS
    LARGE_INTEGER timeStamp, currentTime;
    LARGE_INTEGER timeDifference;
#endif

    PAGED_CODE( );

    IF_DEBUG( CREATE ) {
        KdPrint(("\nSrvIoCreateFile:\n" ));
        KdPrint(("  Obja->ObjectName <%wZ>\n", ObjectAttributes->ObjectName ));
        KdPrint(("  Obja->Attributes %X,", ObjectAttributes->Attributes ));
        KdPrint((" RootDirectory %p,", ObjectAttributes->RootDirectory ));
        KdPrint((" SecurityDescriptor %p,", ObjectAttributes->SecurityDescriptor ));
        KdPrint((" SecurityQOS %p\n", ObjectAttributes->SecurityQualityOfService ));
        KdPrint(("    DesiredAccess %X, FileAttributes %X, ShareAccess %X\n",
                    DesiredAccess, FileAttributes, ShareAccess ));
        KdPrint(("    Disposition %X, CreateOptions %X, EaLength %X\n",
                    Disposition, CreateOptions, EaLength ));
        KdPrint(("    CreateFileType %X, ExtraCreateParameters %p, Options %X\n",
                    CreateFileType, ExtraCreateParameters, Options ));
    }

    //
    // See if this operation is allowed on this share
    //
    if( ARGUMENT_PRESENT( Share ) ) {
        status = SrvIsAllowedOnAdminShare( WorkContext, Share );

        if( !NT_SUCCESS( status ) ) {
            IF_DEBUG( CREATE ) {
                KdPrint(("Create disallowed on Admin Share: %X\n", status ));
            }
            return status;
        }
    }

    //
    // We do not allow the remote opening of structured storage files
    //
    if( (CreateOptions & FILE_STRUCTURED_STORAGE) == FILE_STRUCTURED_STORAGE ) {
        IF_DEBUG( CREATE ) {
            KdPrint(("Create FILE_STRUCTURED_STORAGE unsupported\n" ));
        }
        return STATUS_NOT_SUPPORTED;
    }

    //
    // We do not allow opening files by ID.  It is too easy to escape the share
    //
    if( CreateOptions & FILE_OPEN_BY_FILE_ID ) {
        IF_DEBUG( CREATE ) {
            KdPrint(("Create FILE_OPEN_BY_FILE_ID unsupported\n" ));
        }
        return STATUS_NOT_SUPPORTED;
    }

    //
    // Make sure the client isn't trying to create a file having the name
    //   of a DOS device
    //
    SrvGetBaseFileName( ObjectAttributes->ObjectName, &fileName );
    for( pName = SrvDosDevices; pName->Length; pName++ ) {
        if( pName->Length == fileName.Length &&
            RtlCompareUnicodeString( pName, &fileName, TRUE ) == 0 ) {
            //
            // Whoa!  We don't want clients trying to create files having a
            //   DOS device name
            //
            IF_DEBUG( CREATE ) {
                KdPrint(("Create open %wZ unsupported\n", &fileName ));
            }
            return STATUS_ACCESS_DENIED;
        }
    }

    //
    // If this is from the NULL session, allow it to open only certain
    // pipes.
    //

    if ( CreateFileType != CreateFileTypeMailslot ) {

        shareType = WorkContext->TreeConnect->Share->ShareType;

        if( shareType == ShareTypePipe ) {
            if ( WorkContext->Session->IsNullSession ) {

                if( SrvRestrictNullSessionAccess ) {
                    BOOLEAN matchFound = FALSE;
                    ULONG i;

                    ACQUIRE_LOCK( &SrvConfigurationLock );

                    for ( i = 0; SrvNullSessionPipes[i] != NULL ; i++ ) {

                        if ( _wcsicmp(
                                SrvNullSessionPipes[i],
                                ObjectAttributes->ObjectName->Buffer
                                ) == 0 ) {

                            matchFound = TRUE;
                            break;
                        }
                    }

                    RELEASE_LOCK( &SrvConfigurationLock );

                    if ( !matchFound ) {
                        IF_DEBUG( CREATE ) {
                            KdPrint(( "Create via NULL session denied\n" ));
                        }
                        return(STATUS_ACCESS_DENIED);
                    }
                }

            } else if( WorkContext->Session->IsLSNotified == FALSE ) {
                //
                // We have a pipe open request, not a NULL session, and
                //  we haven't gotten clearance from the license server yet.
                //  If this pipe requires clearance, get a license.
                //
                ULONG i;
                BOOLEAN matchFound = FALSE;

                ACQUIRE_LOCK( &SrvConfigurationLock );

                for ( i = 0; SrvPipesNeedLicense[i] != NULL ; i++ ) {

                    if ( _wcsicmp(
                            SrvPipesNeedLicense[i],
                            ObjectAttributes->ObjectName->Buffer
                            ) == 0 ) {
                        matchFound = TRUE;
                        break;
                    }
                }

                RELEASE_LOCK( &SrvConfigurationLock );

                if( matchFound == TRUE ) {
                    status = SrvXsLSOperation( WorkContext->Session,
                                               XACTSRV_MESSAGE_LSREQUEST );

                    if( !NT_SUCCESS( status ) ) {
                        IF_DEBUG( CREATE ) {
                            KdPrint(( "Create failed due to license server: %X\n", status ));
                        }
                        return status;
                    }
                }
            }
        }

        //
        // !!! a hack to handle a bug in the Object system and path-based
        //     operations on print shares.  to test a fix, try from OS/2:
        //
        //         copy config.sys \\server\printshare
        //

        if ( Share == NULL &&
                 ObjectAttributes->ObjectName->Length == 0 &&
                 ObjectAttributes->RootDirectory == NULL ) {

            IF_DEBUG( CREATE ) {
                KdPrint(("Create failed: ObjectName Len == 0, an ! Root directory\n" ));
            }
            return STATUS_OBJECT_PATH_SYNTAX_BAD;
        }

        //
        // Check desired access against share ACL.
        //
        // This gets a little hairy.  Basically, we simply want to check the
        // desired access against the ACL.  But this doesn't correctly
        // handle the case where the client only has read access to the
        // share, and wants to (perhaps optionally) create (or overwrite) a
        // file or directory, but only asks for read access to the file.  We
        // deal with this problem by, in effect, adding write access to the
        // access requested by the client if the client specifies a
        // dispostion mode that will or may create or overwrite the file.
        //
        // If the client specifies a dispostion that WILL create or
        // overwrite (CREATE, SUPERSEDE, OVERWRITE, or OVERWRITE_IF), we
        // turn on the FILE_WRITE_DATA (aka FILE_ADD_FILE) and
        // FILE_APPEND_DATA (aka FILE_ADD_SUBDIRECTORY) accesses.  If the
        // access check fails, we return STATUS_ACCESS_DENIED.
        //
        // If the client specifies optional creation, then we have to be
        // even more tricky.  We don't know if the file actually exists, so
        // we can't just reject the request out-of-hand, because if the file
        // does exist, and the client really does have read access to the
        // file, it will look weird if we deny the open.  So in this case we
        // turn the OPEN_IF request into an OPEN (fail if doesn't exist)
        // request.  If the open fails because the file doesn't exist, we
        // return STATUS_ACCESS_DENIED.
        //
        // Note that this method effectively means that the share ACL cannot
        // distinguish between a user who can write to existing files but
        // who cannot create new files.  This is because of the overloading
        // of FILE_WRITE_DATA/FILE_ADD_FILE and
        // FILE_APPEND_DATA/FILE_ADD_SUBDIRECTORY.
        //
        //
        // OK.  First, check the access exactly as requested.
        //

        status = SrvCheckShareFileAccess( WorkContext, DesiredAccess, &ShareAccess );
        if ( !NT_SUCCESS( status )) {
            //
            // Some clients want ACCESS_DENIED to be in the server class
            // instead of the DOS class when it's due to share ACL
            // restrictions.  So we need to keep track of why we're
            // returning ACCESS_DENIED.
            //
            IF_DEBUG( CREATE ) {
                KdPrint(("Create failed, SrvCheckShareFileAccess returns %X\n", status ));
            }

            WorkContext->ShareAclFailure = TRUE;
            return STATUS_ACCESS_DENIED;
        }

    } else {

        //
        // Set it to CreateFileTypeNone so no extra checking is done.
        //

        CreateFileType = CreateFileTypeNone;
    }

    //
    // That worked.  Now, if the Disposition may or will create or
    // overwrite, do more checking.
    //

    if ( Disposition != FILE_OPEN ) {

        status = SrvCheckShareFileAccess(
                    WorkContext,
                    DesiredAccess | FILE_WRITE_DATA | FILE_APPEND_DATA,
                    &ShareAccess
                    );

        if ( !NT_SUCCESS( status )) {

            //
            // The client cannot create or overwrite files.  Unless
            // they asked for FILE_OPEN_IF, jump out now.
            //

            if ( Disposition != FILE_OPEN_IF ) {
                //
                // Some clients want ACCESS_DENIED to be in the server class
                // instead of the DOS class when it's due to share ACL
                // restrictions.  So we need to keep track of why we're
                // returning ACCESS_DENIED.
                //
                IF_DEBUG( CREATE ) {
                    KdPrint(("Create failed, SrvCheckShareFileAccess returns ACCESS_DENIED\n"));
                }
                WorkContext->ShareAclFailure = TRUE;
                return STATUS_ACCESS_DENIED;
            }

            //
            // Change OPEN_IF to OPEN, and remember that we did it.
            //

            Disposition = FILE_OPEN;
            dispositionModified = TRUE;

        }

    }

    //
    // If this client is reading from the file, turn off FILE_SEQUENTIAL_ONLY in case
    //  caching this file would be beneficial to other clients.
    //
    if( shareType == ShareTypeDisk &&
        !(DesiredAccess & (FILE_WRITE_DATA|FILE_APPEND_DATA)) ) {

        CreateOptions &= ~FILE_SEQUENTIAL_ONLY;
    }

    if( SrvMaxNonPagedPoolUsage != 0xFFFFFFFF ) {
        //
        // Make sure that this open will not push the server over its
        // nonpaged and paged quotas.
        //

        newUsage = InterlockedExchangeAdd(
                        (PLONG)&SrvStatistics.CurrentNonPagedPoolUsage,
                        IO_FILE_OBJECT_NON_PAGED_POOL_CHARGE
                        ) + IO_FILE_OBJECT_NON_PAGED_POOL_CHARGE;

        if ( newUsage > SrvMaxNonPagedPoolUsage ) {
            status = STATUS_INSUFF_SERVER_RESOURCES;
            eventToLog = EVENT_SRV_NONPAGED_POOL_LIMIT;
            goto error_exit1;
        }

        if ( SrvStatistics.CurrentNonPagedPoolUsage > SrvStatistics.PeakNonPagedPoolUsage) {
            SrvStatistics.PeakNonPagedPoolUsage = SrvStatistics.CurrentNonPagedPoolUsage;
        }
    }

    if( SrvMaxPagedPoolUsage != 0xFFFFFFFF ) {

        ASSERT( (LONG)SrvStatistics.CurrentPagedPoolUsage >= 0 );
        newUsage = InterlockedExchangeAdd(
                        (PLONG)&SrvStatistics.CurrentPagedPoolUsage,
                        IO_FILE_OBJECT_PAGED_POOL_CHARGE
                        ) + IO_FILE_OBJECT_PAGED_POOL_CHARGE;
        ASSERT( (LONG)SrvStatistics.CurrentPagedPoolUsage >= 0 );

        if ( newUsage > SrvMaxPagedPoolUsage ) {
            status = STATUS_INSUFF_SERVER_RESOURCES;
            eventToLog = EVENT_SRV_PAGED_POOL_LIMIT;
            goto error_exit;
        }

        if ( SrvStatistics.CurrentPagedPoolUsage > SrvStatistics.PeakPagedPoolUsage) {
            SrvStatistics.PeakPagedPoolUsage = SrvStatistics.CurrentPagedPoolUsage;
        }
    }


    //
    // If Share is specified, we may need to fill up the root share
    // handle of the object attribute.
    //

    if ( ARGUMENT_PRESENT( Share ) && (shareType != ShareTypePrint) ) {

        //
        // Get the Share root handle.
        //

        status = SrvGetShareRootHandle( Share );

        if ( !NT_SUCCESS(status) ) {

            IF_DEBUG(CREATE) {
                KdPrint(( "SrvIoCreateFile: SrvGetShareRootHandle failed: %X\n",
                              status ));
            }
            goto error_exit;

        }

        //
        // Fill in the root handle.
        //

        status = SrvSnapGetRootHandle( WorkContext, &ObjectAttributes->RootDirectory );
        if( !NT_SUCCESS( status ) )
        {
            goto error_exit;
        }

        //
        // Make sure no data is being written
        //
        if( (WorkContext->SnapShotTime.QuadPart != 0) &&
            (DesiredAccess & (FILE_WRITE_DATA|FILE_APPEND_DATA)) )
        {
            status = STATUS_ACCESS_DENIED;
            goto error_exit;
        }
    }

    //
    // Impersonate the client.  This makes us look like the client for
    // the purpose of checking security.  Don't do impersonation if
    // this is a spool file since spool files have admin all access,
    // everybody read access by definition.
    //

    status = STATUS_SUCCESS;

    if ( shareType != ShareTypePrint ) {
        status = IMPERSONATE( WorkContext );
    }

#if SRVDBG_STATS
    //
    // Get the system time for statistics tracking.
    //

    KeQuerySystemTime( &timeStamp );
#endif

    //
    // Perform the actual open.
    //
    // *** Do not lose the status returned by IoCreateFile!  Even if
    //     it's a success code.  The caller needs to know if it's
    //     STATUS_OPLOCK_BREAK_IN_PROGRESS.
    //

    if( NT_SUCCESS( status ) ) {

        status = IoCreateFile(
                     FileHandle,
                     DesiredAccess,
                     ObjectAttributes,
                     IoStatusBlock,
                     AllocationSize,
                     FileAttributes,
                     ShareAccess,
                     Disposition,
                     CreateOptions,
                     EaBuffer,
                     EaLength,
                     CreateFileType,
                     ExtraCreateParameters,
                     Options
                     );

        //
        // If the volume was dismounted, and we can refresh the share root handle,
        //   we should try the operation again.
        //

        if( ARGUMENT_PRESENT( Share ) && SrvRetryDueToDismount( Share, status ) ) {

            status = SrvSnapGetRootHandle( WorkContext, &ObjectAttributes->RootDirectory );
            if( !NT_SUCCESS( status ) )
            {
                goto error_exit;
            }

            status = IoCreateFile(
                         FileHandle,
                         DesiredAccess,
                         ObjectAttributes,
                         IoStatusBlock,
                         AllocationSize,
                         FileAttributes,
                         ShareAccess,
                         Disposition,
                         CreateOptions,
                         EaBuffer,
                         EaLength,
                         CreateFileType,
                         ExtraCreateParameters,
                         Options
                         );
        }

    }

#if SRVDBG_STATS
    //
    // Grab the time again.
    //

    KeQuerySystemTime( &currentTime );
#endif

    //
    // Go back to the server's security context.
    //

    if ( shareType != ShareTypePrint ) {
        //
        // Calling REVERT() even if the impersonate failed is harmless
        //
        REVERT( );
    }

#if SRVDBG_STATS
    //
    // Determine how long the IoCreateFile took.
    //
    timeDifference.QuadPart = currentTime.QuadPart - timeStamp.QuadPart;

    //
    // Update statistics, including server pool quota statistics if the
    // open didn't succeed.
    //

    ExInterlockedAddLargeInteger(
        &SrvDbgStatistics.TotalIoCreateFileTime,
        timeDifference,
        &GLOBAL_SPIN_LOCK(Statistics)
        );
#endif
    //
    // Release the share root handle
    //

    if ( ARGUMENT_PRESENT( Share ) ) {
        SrvReleaseShareRootHandle( Share );
    }

    if ( NT_SUCCESS(status) ) {

        IF_DEBUG( CREATE ) {
            KdPrint(( "    ** %wZ, handle %p\n",
                    ObjectAttributes->ObjectName, *FileHandle ));
        }

        tempStatus = SrvVerifyDeviceStackSize(
                        *FileHandle,
                        TRUE,
                        &fileObject,
                        &deviceObject,
                        NULL
                        );

        if ( !NT_SUCCESS( tempStatus )) {

            INTERNAL_ERROR(
                ERROR_LEVEL_EXPECTED,
                "SrvIoCreateFile: Verify Device Stack Size failed: %X\n",
                tempStatus,
                NULL
                );

            SRVDBG_RELEASE_HANDLE( *FileHandle, "FIL", 50, 0 );
            SrvNtClose( *FileHandle, FALSE );
            status = tempStatus;
        } else {

             //
             //  Mark the orgin of this file as remote.  This should
             //  never fail.  If it does, it means it is already set.
             //  Check for this in a debug build, but ignore errors
             //  in the retail build.
             //

#if DBG
             tempStatus =
#endif
             IoSetFileOrigin( fileObject,
                              TRUE );

             ASSERT( tempStatus == STATUS_SUCCESS );

             //
             //  Remove the reference we added in SrvVerifyDeviceStackSize().
             //

             ObDereferenceObject( fileObject );
        }

    }

    if ( !NT_SUCCESS(status) ) {
        goto error_exit;
    }

    IF_DEBUG(HANDLES) {
        if ( NT_SUCCESS(status) ) {
            PVOID caller, callersCaller;
            RtlGetCallersAddress( &caller, &callersCaller );
            KdPrint(( "opened handle %p for %wZ (%p %p)\n",
                           *FileHandle, ObjectAttributes->ObjectName,
                           caller, callersCaller ));
        }
    }

    IF_DEBUG( CREATE ) {
        KdPrint(("    Status %X\n", status ));
    }

    return status;

error_exit:

    if( SrvMaxPagedPoolUsage != 0xFFFFFFFF ) {
        ASSERT( (LONG)SrvStatistics.CurrentPagedPoolUsage >= IO_FILE_OBJECT_PAGED_POOL_CHARGE );

        InterlockedExchangeAdd(
            (PLONG)&SrvStatistics.CurrentPagedPoolUsage,
            -IO_FILE_OBJECT_PAGED_POOL_CHARGE
            );

        ASSERT( (LONG)SrvStatistics.CurrentPagedPoolUsage >= 0 );
    }

error_exit1:

    if( SrvMaxNonPagedPoolUsage != 0xFFFFFFFF ) {
        ASSERT( (LONG)SrvStatistics.CurrentNonPagedPoolUsage >= IO_FILE_OBJECT_NON_PAGED_POOL_CHARGE );

        InterlockedExchangeAdd(
            (PLONG)&SrvStatistics.CurrentNonPagedPoolUsage,
            -IO_FILE_OBJECT_NON_PAGED_POOL_CHARGE
            );

        ASSERT( (LONG)SrvStatistics.CurrentNonPagedPoolUsage >= 0 );
    }

    if ( status == STATUS_INSUFF_SERVER_RESOURCES ) {

        requiredSize = ((eventToLog == EVENT_SRV_NONPAGED_POOL_LIMIT) ?
                            IO_FILE_OBJECT_NON_PAGED_POOL_CHARGE :
                            IO_FILE_OBJECT_PAGED_POOL_CHARGE);

        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvIoCreateFile: nonpaged pool limit reached, current = %ld, max = %ld\n",
            newUsage - requiredSize,
            SrvMaxNonPagedPoolUsage
            );

        SrvLogError(
            SrvDeviceObject,
            eventToLog,
            STATUS_INSUFFICIENT_RESOURCES,
            &requiredSize,
            sizeof(ULONG),
            NULL,
            0
            );

    } else {

        //
        // Finish up the access checking started above.  If the open failed
        // because the file didn't exist, and we turned off the create-if
        // mode because the client doesn't have write access, change the
        // status to STATUS_ACCESS_DENIED.
        //

        if ( dispositionModified && (status == STATUS_OBJECT_NAME_NOT_FOUND) ) {
            status = STATUS_ACCESS_DENIED;
        }

    }

    IF_DEBUG( CREATE ) {
        KdPrint(("    Status %X\n", status ));
    }

    return status;

} // SrvIoCreateFile


NTSTATUS
SrvNtClose (
    IN HANDLE Handle,
    IN BOOLEAN QuotaCharged
    )

/*++

Routine Description:

    Closes a handle, records statistics for number of handles closed,
    total time spent closing handles.

Arguments:

    Handle - the handle to close.

    QuotaCharged - indicates whether the server's internal quota for
        paged and nonpaged pool was charged for this open.

Return Value:

    NTSTATUS - result of operation.

--*/

{
    NTSTATUS status;
#if SRVDBG_STATS
    LARGE_INTEGER timeStamp, currentTime;
    LARGE_INTEGER timeDifference;
#endif
    PEPROCESS process;

    PAGED_CODE( );

#if SRVDBG_STATS
    //
    // SnapShot the system time.
    //

    KeQuerySystemTime( &timeStamp );
#endif

    //
    // Make sure we're in the server FSP.
    //

    process = IoGetCurrentProcess();
    if ( process != SrvServerProcess ) {
        //KdPrint(( "SRV: Closing handle %x in process %x\n", Handle, process ));
        KeAttachProcess( SrvServerProcess );
    }

    IF_DEBUG( CREATE ) {
        KdPrint(( "SrvNtClose handle %p\n", Handle ));
    }

    //
    // Close the handle.
    //

    status = NtClose( Handle );

    //
    // Return to the original process.
    //

    if ( process != SrvServerProcess ) {
        KeDetachProcess();
    }

    IF_DEBUG( ERRORS ) {
        if ( !NT_SUCCESS( status ) ) {
            KdPrint(( "SRV: NtClose failed: %x\n", status ));
#if DBG
            DbgBreakPoint( );
#endif
        }
    }

    ASSERT( NT_SUCCESS( status ) );

#if SRVDBG_STATS
    //
    // Get the time again.
    //

    KeQuerySystemTime( &currentTime );

    //
    // Determine how long the close took.
    //

    timeDifference.QuadPart = currentTime.QuadPart - timeStamp.QuadPart;
#endif

    //
    // Update the relevant statistics, including server quota statistics.
    //

#if SRVDBG_STATS
    SrvDbgStatistics.TotalNtCloseTime.QuadPart += timeDifference.QuadPart;
#endif

    if ( QuotaCharged ) {
        if( SrvMaxPagedPoolUsage != 0xFFFFFFFF ) {
            ASSERT( (LONG)SrvStatistics.CurrentPagedPoolUsage >= 0 );
            InterlockedExchangeAdd(
                (PLONG)&SrvStatistics.CurrentPagedPoolUsage,
                -(LONG)IO_FILE_OBJECT_PAGED_POOL_CHARGE
                );
            ASSERT( (LONG)SrvStatistics.CurrentPagedPoolUsage >= 0 );
        }

        if( SrvMaxNonPagedPoolUsage != 0xFFFFFFFF ) {
            ASSERT( (LONG)SrvStatistics.CurrentNonPagedPoolUsage >= 0 );
            InterlockedExchangeAdd(
                (PLONG)&SrvStatistics.CurrentNonPagedPoolUsage,
                -(LONG)IO_FILE_OBJECT_NON_PAGED_POOL_CHARGE
                );
            ASSERT( (LONG)SrvStatistics.CurrentNonPagedPoolUsage >= 0 );
        }
    }

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalHandlesClosed );

    IF_DEBUG(HANDLES) {
        PVOID caller, callersCaller;
        RtlGetCallersAddress( &caller, &callersCaller );
        if ( NT_SUCCESS(status) ) {
            KdPrint(( "closed handle %p (%p %p)\n",
                           Handle, caller, callersCaller ));
        } else {
            KdPrint(( "closed handle %p (%p %p) FAILED: %X\n",
                           Handle, caller, callersCaller, status ));
        }
    }

    return STATUS_SUCCESS;

} // SrvNtClose


NTSTATUS
SrvVerifyDeviceStackSize (
    IN HANDLE FileHandle,
    IN BOOLEAN ReferenceFileObject,
    OUT PFILE_OBJECT *FileObject,
    OUT PDEVICE_OBJECT *DeviceObject,
    OUT POBJECT_HANDLE_INFORMATION HandleInformation OPTIONAL
    )
/*++

Routine Description:

    Ths routine references the file object associated with the
    file handle and checks whether our work item has sufficient
    irp stack size to handle requests to this device or the device
    associated with this file.

Arguments:

    FileHandle - The handle to an open device or file
    ReferenceFileObject - if TRUE, the file object is left referenced.
    FileObject - The file object associated with the filehandle.
    DeviceObject - the device object associated with the filehandle.
    HandleInformation - if not NULL, returns information about the file handle.

Return Value:

    Status of request.

--*/
{

    NTSTATUS status;

    PAGED_CODE( );

    //
    // Get a pointer to the file object, so that we can directly
    // get the related device object that should contain a count
    // of the irp stack size needed by that device.
    //

    status = ObReferenceObjectByHandle(
                FileHandle,
                0,
                NULL,
                KernelMode,
                (PVOID *)FileObject,
                HandleInformation
                );

    if ( !NT_SUCCESS(status) ) {

        SrvLogServiceFailure( SRV_SVC_OB_REF_BY_HANDLE, status );

        //
        // This internal error bugchecks the system.
        //

        INTERNAL_ERROR(
            ERROR_LEVEL_IMPOSSIBLE,
            "SrvVerifyDeviceStackSize: unable to reference file handle 0x%lx",
            FileHandle,
            NULL
            );

    } else {

        *DeviceObject = IoGetRelatedDeviceObject( *FileObject );

        if ( (*DeviceObject)->StackSize > SrvReceiveIrpStackSize ) {

            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvVerifyStackSize: WorkItem Irp StackSize too small. Need %d Allocated %d\n",
                (*DeviceObject)->StackSize+1,
                SrvReceiveIrpStackSize
                );

            SrvLogSimpleEvent( EVENT_SRV_IRP_STACK_SIZE, STATUS_SUCCESS );

            ObDereferenceObject( *FileObject );
            *FileObject = NULL;
            status = STATUS_INSUFF_SERVER_RESOURCES;

        } else if ( !ReferenceFileObject ) {

            ObDereferenceObject( *FileObject );
            *FileObject = NULL;

        }
    }

    return status;

} // SrvVerifyDeviceStackSize


NTSTATUS
SrvImpersonate (
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Impersonates the remote client specified in the Session pointer
    of the work context block.

Arguments:

    WorkContext - a work context block containing a valid pointer to
        a session block.

Return Value:

    status code of the attempt

--*/

{
    NTSTATUS status;

    PAGED_CODE( );

    ASSERT( WorkContext->Session != NULL );

    if( WorkContext->SecurityContext == NULL ||
        !IS_VALID_SECURITY_HANDLE (WorkContext->SecurityContext->UserHandle) ) {
        return STATUS_ACCESS_DENIED;
    }

    status = ImpersonateSecurityContext(
                    &WorkContext->SecurityContext->UserHandle
                    );

    if ( !NT_SUCCESS(status) ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "IMPERSONATE: NtSetInformationThread failed: %X",
                status,
                NULL
                );

            SrvLogServiceFailure( SRV_SVC_NT_SET_INFO_THREAD, status );
    }

    return status;

} // SrvImpersonate


NTSTATUS
SrvImpersonateSession (
    IN PSESSION Session
    )

/*++

Routine Description:

    Impersonates the remote client specified in the Session pointer
    of the work context block.

Arguments:

    WorkContext - a work context block containing a valid pointer to
        a session block.

Return Value:

    status code of the attempt

--*/

{
    NTSTATUS status;

    PAGED_CODE( );

    ASSERT( Session != NULL );

    ACQUIRE_LOCK( &Session->Connection->Lock );

    if( Session->SecurityContext == NULL ||
        !IS_VALID_SECURITY_HANDLE (Session->SecurityContext->UserHandle) ) {
        status = STATUS_ACCESS_DENIED;
    }
    else
    {
        status = ImpersonateSecurityContext(
                        &Session->SecurityContext->UserHandle
                        );
    }

    RELEASE_LOCK( &Session->Connection->Lock );

    return status;

} // SrvImpersonate



VOID
SrvRevert (
    VOID
    )

/*++

Routine Description:

    Reverts to the server FSP's default thread context.

Arguments:

    None.

Return Value:

    None.

--*/

{
    NTSTATUS status;

    PAGED_CODE( );

    status = PsAssignImpersonationToken(PsGetCurrentThread(),NULL);

    if ( !NT_SUCCESS(status) ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "REVERT: NtSetInformationThread failed: %X",
            status,
            NULL
            );

        SrvLogServiceFailure( SRV_SVC_NT_SET_INFO_THREAD, status );
    }

    return;

} // SrvRevert


NTSTATUS
SrvSetLastWriteTime (
    IN PRFCB Rfcb,
    IN ULONG LastWriteTimeInSeconds,
    IN ACCESS_MASK GrantedAccess
    )
/*++

Routine Description:

    Sets the last write time on a file if the specified handle has
    sufficient access.  This is used by the Close and Create SMBs to
    ensure that file times on server files are consistent with
    times on clients.

Arguments:

    Rfcb - pointer to the rfcb block that is associated with the file
        which we need to set the lastwrite time on.

    LastWriteTimeInSeconds - the time, in seconds since 1970, to put
        on the file.  If it is 0 or -1, the last write time is not
        changed.

    GrantedAccess - an access mask specifying the access the specified
        handle has.  If it has insufficient access, the file time is
        not changed.

    ForceChanges - flag set to true if we want to send down the
        SetFileInfo anyway even if the client specified a zero lastWriteTime.
        Useful to force the filesystem to update the file control block now
        rather than at the close.

Return Value:

    NTSTATUS - result of operation.

--*/

{
    NTSTATUS status;
    FILE_BASIC_INFORMATION fileBasicInfo;
    IO_STATUS_BLOCK ioStatusBlock;

    PAGED_CODE( );

    //
    // If the client doesn't want to set the time, don't set it.
    //

    if ( Rfcb->ShareType != ShareTypeDisk ||
         LastWriteTimeInSeconds == 0     ||
         LastWriteTimeInSeconds == 0xFFFFFFFF ) {

        //
        // If the file was written to, we won't cache the file.  This is to
        // ensure the file directory entry gets updated by the file system.
        //

        if ( Rfcb->WrittenTo ) {
            Rfcb->IsCacheable = FALSE;
        }
        return STATUS_SUCCESS;
    }

    //
    // Make sure that we have the correct access on the specified handle.
    //

    CHECK_FILE_INFORMATION_ACCESS(
        GrantedAccess,
        IRP_MJ_SET_INFORMATION,
        FileBasicInformation,
        &status
        );

    if ( !NT_SUCCESS(status) ) {
        return status;
    }

    //
    // Set to 0 the fields we don't want to change.
    //

    fileBasicInfo.CreationTime.QuadPart = 0;
    fileBasicInfo.LastAccessTime.QuadPart = 0;
    fileBasicInfo.ChangeTime.QuadPart = 0;
    fileBasicInfo.FileAttributes = 0;

    //
    // Set up the last write time.
    //

    RtlSecondsSince1970ToTime(
        LastWriteTimeInSeconds,
        &fileBasicInfo.LastWriteTime
        );

    ExLocalTimeToSystemTime(
        &fileBasicInfo.LastWriteTime,
        &fileBasicInfo.LastWriteTime
        );

    //
    // Set the time using the passed-in file handle.
    //

    status = NtSetInformationFile(
                 Rfcb->Lfcb->FileHandle,
                 &ioStatusBlock,
                 &fileBasicInfo,
                 sizeof(FILE_BASIC_INFORMATION),
                 FileBasicInformation
                 );

    if ( !NT_SUCCESS(status) ) {

        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "SrvSetLastWriteTime: NtSetInformationFile returned %X",
            status,
            NULL
            );

        SrvLogServiceFailure( SRV_SVC_NT_SET_INFO_FILE, status );
        return status;
    }

    return STATUS_SUCCESS;

} // SrvSetLastWriteTime

NTSTATUS
SrvCheckShareFileAccess(
    IN PWORK_CONTEXT WorkContext,
    IN ACCESS_MASK FileDesiredAccess,
    IN OUT PULONG ShareMode
    )

/*++

Routine Description:

    This routine checks the desired access against the permissions
    set for this client.

Arguments:

    WorkContext - pointer to the work context block that contains information
        about the request.
    FileDesiredAccess - the desired access.
    ShareMode - The sharing mode desired.  This can be manipulated to prevent Read-Deny Read on
                shares marked as such, to prevent a variety of DoS attacks

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    SECURITY_SUBJECT_CONTEXT subjectContext;
    PSECURITY_DESCRIPTOR securityDescriptor;
    ACCESS_MASK grantedAccess;
    ACCESS_MASK mappedAccess = FileDesiredAccess;
    PPRIVILEGE_SET privileges = NULL;

    PAGED_CODE( );

    //
    // For Restrict Opens behavior, we no longer allow someone to lock the file exclusively if they are opening
    // simple for read.  This prevents cases where clients with read-only access can lock a file and prevent anyone
    // else from reading it.  It presents interesting DoS situations in policy.
    //
    if( WorkContext->TreeConnect->Share->ShareProperties & SHI1005_FLAGS_RESTRICT_EXCLUSIVE_OPENS )
    {
        if( (!((*ShareMode) & FILE_SHARE_READ) &&
             !(FileDesiredAccess & (FILE_WRITE_DATA|FILE_WRITE_ATTRIBUTES|FILE_WRITE_EA|FILE_APPEND_DATA)) ) )
        {
            *ShareMode |= FILE_SHARE_READ;
        }
    }

    if( WorkContext->TreeConnect->Share->ShareProperties & SHI1005_FLAGS_FORCE_SHARED_DELETE )
    {
        *ShareMode |= FILE_SHARE_DELETE;
    }

    ACQUIRE_LOCK_SHARED( WorkContext->TreeConnect->Share->SecurityDescriptorLock );

    securityDescriptor = WorkContext->TreeConnect->Share->FileSecurityDescriptor;

    if (securityDescriptor != NULL) {

        status = IMPERSONATE( WorkContext );

        if( NT_SUCCESS( status ) ) {

            SeCaptureSubjectContext( &subjectContext );

            RtlMapGenericMask( &mappedAccess, &SrvFileAccessMapping );

            //
            // SYNCHRONIZE and ACCESS_SYSTEM_SECURITY do not make any sense for a share ACL
            //
            mappedAccess &= ~(SYNCHRONIZE|ACCESS_SYSTEM_SECURITY);

            if ( !SeAccessCheck(
                        securityDescriptor,
                        &subjectContext,
                        FALSE,                  // Locked ?
                        mappedAccess,
                        0,                      // PreviousGrantedAccess
                        &privileges,
                        &SrvFileAccessMapping,
                        UserMode,
                        &grantedAccess,
                        &status
                        ) ) {


                IF_DEBUG(ERRORS) {
                    KdPrint((
                        "SrvCheckShareFileAccess: Status %x, Desired access %x, mappedAccess %x\n",
                        status,
                        FileDesiredAccess,
                        mappedAccess
                        ));
                }
            }


            if ( privileges != NULL ) {
                SeFreePrivileges( privileges );
            }

            SeReleaseSubjectContext( &subjectContext );

            REVERT( );
        }
    }

    RELEASE_LOCK( WorkContext->TreeConnect->Share->SecurityDescriptorLock );

    return status;

} // SrvCheckShareFileAccess

VOID
SrvReleaseShareRootHandle (
    IN PSHARE Share
    )

/*++

Routine Description:

    This routine releases the root handle for a given share if the
    shared device is removable (floopy, or cdrom).

Arguments:

    Share - The share for which the root directory handle is to be released.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    if ( Share->Removable ) {

        ASSERT( Share->CurrentRootHandleReferences > 0 );
        ACQUIRE_LOCK( &SrvShareLock );

        if ( --Share->CurrentRootHandleReferences == 0 ) {

            ASSERT( Share->RootDirectoryHandle != NULL );
            SRVDBG_RELEASE_HANDLE( Share->RootDirectoryHandle, "RTD", 51, Share );
            SrvNtClose( Share->RootDirectoryHandle, FALSE );
            Share->RootDirectoryHandle = NULL;
            SrvDereferenceShare( Share );

        }

        RELEASE_LOCK( &SrvShareLock );

    }

    return;

} // SrvReleaseShareRootHandle

VOID
SrvUpdateVcQualityOfService (
    IN PCONNECTION Connection,
    IN PLARGE_INTEGER CurrentTime OPTIONAL
    )

/*++

Routine Description:

    Updates the connection quality of service information by
    querying the underlying transport.

Arguments:

    Connection - pointer to the connection whose qos we want to update.

    CurrentTime - an optional pointer to a large interger containing the
                current time.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    PTDI_CONNECTION_INFO connectionInfo;
    LARGE_INTEGER currentTime;
    LARGE_INTEGER throughput;
    LARGE_INTEGER linkDelay;
    PPAGED_CONNECTION pagedConnection = Connection->PagedConnection;

    PAGED_CODE( );

    //
    // This routine is a no-op on connectionless transports.
    //

    if ( Connection->Endpoint->IsConnectionless ) {

        Connection->EnableOplocks = FALSE;
        Connection->EnableRawIo = FALSE;
        return;
    }

    //
    // Update the connection information
    //

    if ( ARGUMENT_PRESENT( CurrentTime ) ) {

        currentTime = *CurrentTime;

    } else {

        KeQuerySystemTime( &currentTime );

    }

    //
    // Check if connection info is still valid.
    //

    if ( pagedConnection->LinkInfoValidTime.QuadPart > currentTime.QuadPart ) {
        return;
    }

    //
    // We need to update the connection information.
    //

    connectionInfo = ALLOCATE_NONPAGED_POOL(
                            sizeof(TDI_CONNECTION_INFO),
                            BlockTypeDataBuffer
                            );

    if ( connectionInfo == NULL ) {
        goto exitquery;
    }

    //
    // Issue a TdiQueryInformation to get the current connection info
    // from the transport provider for this connection.  This is a
    // synchronous operation.
    //

    status = SrvIssueTdiQuery(
                Connection->FileObject,
                &Connection->DeviceObject,
                (PUCHAR)connectionInfo,
                sizeof(TDI_CONNECTION_INFO),
                TDI_QUERY_CONNECTION_INFO
                );

    //
    // If the request failed, log an event.
    //
    // *** We special-case STATUS_INVALID_CONNECTION because NBF completes
    //     our Accept IRP before it's actually ready to accept requests.
    //

    if ( !NT_SUCCESS(status) ) {
        if ( status != STATUS_INVALID_CONNECTION &&
             status != STATUS_CONNECTION_INVALID ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvUpdateVcQualityOfService: SrvIssueTdiQuery failed: %X\n",
                status,
                NULL
                );
            SrvLogServiceFailure( SRV_SVC_NT_IOCTL_FILE, status );
        }

        DEALLOCATE_NONPAGED_POOL( connectionInfo );
        goto exitquery;
    }

    //
    // Set the time when this information becomes invalid.
    //

    currentTime.QuadPart += SrvLinkInfoValidTime.QuadPart;

    //
    // Get a positive delay.  The TP returns a relative time which
    // is negative.
    //

    linkDelay.QuadPart = -connectionInfo->Delay.QuadPart;
    if ( linkDelay.QuadPart < 0 ) {
        linkDelay.QuadPart = 0;
    }

    //
    // Get the throughput
    //

    throughput = connectionInfo->Throughput;

    //
    // If connection is reliable, check and see if the delay and throughput
    // are within our limits. If not, the vc is unreliable.
    //

    Connection->EnableOplocks =
            (BOOLEAN) ( !connectionInfo->Unreliable &&
                        throughput.QuadPart >= SrvMinLinkThroughput.QuadPart );

    DEALLOCATE_NONPAGED_POOL( connectionInfo );

    //
    // We need to check the delay for Raw I/O.
    //

    Connection->EnableRawIo =
            (BOOLEAN) ( Connection->EnableOplocks &&
                        linkDelay.QuadPart <= SrvMaxLinkDelay.QuadPart );

    //
    // See if oplocks are always disabled for this connection.  We do it
    // here so that Connection->EnableRawIo can be computed correctly.
    //

    if ( Connection->OplocksAlwaysDisabled ) {
        Connection->EnableOplocks = FALSE;
    }

    //
    // Access "large" connection QOS fields using a lock, to
    // ensure consistent values.
    //

    ACQUIRE_LOCK( &Connection->Lock );
    pagedConnection->LinkInfoValidTime = currentTime;
    pagedConnection->Delay = linkDelay;
    pagedConnection->Throughput = throughput;
    RELEASE_LOCK( &Connection->Lock );

    return;

exitquery:

    Connection->EnableOplocks = TRUE;
    Connection->EnableRawIo = TRUE;
    return;

} // SrvUpdateVcQualityOfService


BOOLEAN SRVFASTCALL
SrvValidateSmb (
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function validates an SMB header.

Arguments:

    WorkContext - Pointer to a work context block.  The RequestHeader
        and RequestParameter fields must be valid.

Return Value:

    TRUE - The SMB is valid
    FALSE - The SMB is invalid

--*/

{
    PSMB_HEADER smbHeader;
    UCHAR wordCount = 0;
    PSMB_USHORT byteCount = NULL;
    ULONG availableSpaceForSmb = 0;

    PAGED_CODE( );

    smbHeader = WorkContext->RequestHeader;

    //
    // Did we get an entire SMB?  We check here for an SMB that at least goes
    // to the WordCount field.
    //
    if( WorkContext->RequestBuffer->DataLength < sizeof( SMB_HEADER ) + sizeof( UCHAR ) ) {
        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SMB of %d bytes too short!\n", availableSpaceForSmb ));
        }
        IF_DEBUG( ERRORS ) {
            KdPrint(("Closing connection %p -- msg too small\n", WorkContext->Connection ));
        }
        //
        // This client has really misbehaved.  Nuke it!
        //
        WorkContext->Connection->DisconnectReason = DisconnectBadSMBPacket;
        SrvCloseConnection( WorkContext->Connection, FALSE );
        return FALSE;
    }

    //
    // Does it start with 0xFF S M B ?
    //
    if ( SmbGetAlignedUlong( (PULONG)smbHeader->Protocol ) !=
                                                SMB_HEADER_PROTOCOL ) {
        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SMB does not start with SMB_HEADER_PROTOCOL\n" ));
        }
        IF_DEBUG( ERRORS ) {
            KdPrint(("Closing connection %p -- no ffSMB\n", WorkContext->Connection ));
        }
        //
        // This client has really misbehaved.  Nuke it!
        //
        WorkContext->Connection->DisconnectReason = DisconnectBadSMBPacket;
        SrvCloseConnection( WorkContext->Connection, FALSE );
        return FALSE;
    }

#if 0

    if ( smbHeader->Reserved != 0 ) {
        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SMB Header->Reserved %x != 0!\n", smbHeader->Reserved ));
        }
        SrvLogInvalidSmb( WorkContext );
        return FALSE;
    }

    //
    // DOS LM2.1 sets SMB_FLAGS_SERVER_TO_REDIR on an oplock break
    // response, so ignore that bit.
    //

    if ( (smbHeader->Flags &
            ~(INCOMING_SMB_FLAGS | SMB_FLAGS_SERVER_TO_REDIR)) != 0 ) {
        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SMB Header->Flags (%x) invalid\n", smbHeader->Flags ));
        }
        SrvLogInvalidSmb( WorkContext );
        return FALSE;
    }

    if ( (SmbGetAlignedUshort( &smbHeader->Flags2 ) &
                                            ~INCOMING_SMB_FLAGS2) != 0 ) {
        KdPrint(( "ValidatesmbHeader: Flags2 = %lx, valid bits = %lx, "
                  "invalid bit(s) = %lx\n",
                      SmbGetAlignedUshort( &smbHeader->Flags2 ),
                      INCOMING_SMB_FLAGS2,
                      SmbGetAlignedUshort( &smbHeader->Flags2 ) &
                          ~INCOMING_SMB_FLAGS2 ));

        SrvLogInvalidSmb( WorkContext );
        return FALSE;
    }

#endif

#if 0
    if( (smbHeader->Command != SMB_COM_LOCKING_ANDX) &&
        (smbHeader->Flags & SMB_FLAGS_SERVER_TO_REDIR) ) {

        //
        // A client has set the bit indicating that this is a server response
        //   packet. This could be an attempt by a client to sneak through a
        //   firewall -- because the firewall may be configured to allow incoming
        //   responses, but no incomming requests (thereby allowing internal clients
        //   to access Internet servers, but not allowing external clients to access
        //   internal servers).  Reject this SMB.
        //
        //

        SrvLogInvalidSmb( WorkContext );
        return FALSE;
    }
#endif

    if( WorkContext->Connection->SmbDialect == SmbDialectIllegal &&
        smbHeader->Command != SMB_COM_NEGOTIATE ) {

        //
        // Whoa -- the client sent us an SMB, but we haven't negotiated a dialect
        //  yet!
        //
        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SMB command %x w/o negotiate!\n", smbHeader->Command ));
        }
        IF_DEBUG( ERRORS ) {
            KdPrint(("Closing connection %p -- no Negotiate\n", WorkContext->Connection ));
        }

        //
        // This client has really misbehaved.  Nuke it!
        //
        WorkContext->Connection->DisconnectReason = DisconnectBadSMBPacket;
        SrvCloseConnection( WorkContext->Connection, FALSE );

        return FALSE;
    }

    //
    // Get the WordCount and ByteCount values to make sure that there
    // was enough information sent to satisfy the specifications.
    //

    wordCount = *((PUCHAR)WorkContext->RequestParameters);
    byteCount = (PSMB_USHORT)( (PCHAR)WorkContext->RequestParameters +
                sizeof(UCHAR) + (wordCount * sizeof(USHORT)) );
    availableSpaceForSmb = WorkContext->RequestBuffer->DataLength -
                           PTR_DIFF( WorkContext->ResponseParameters,
                                     WorkContext->RequestBuffer->Buffer );

    //
    // Verify all of the fixed valued SMB header fields.  Variable
    // valued fields (such as Tid) are verified as needed by the
    // individual SMB handlers.
    //

    //
    // Make sure that the valid word count was sent across.  If the
    // value in the table is -1, then the processing routine will
    // verify the word count, and if the word count is -2 then this
    // is an illegal command which will be caught later.
    //
    // We check whether the word count is negative first since
    // critical smbs like read/write (andX/raw) have -1.
    //

    //
    // Make sure that the ByteCount lies within the boundaries of
    // the received SMB.  Without this test, it would be possible,
    // when at the end of a long AndX chain and WordCount is large,
    // for the server to take an access violation when looking at
    // ByteCount.  The location for ByteCount must be at least two
    // bytes short of the end of the buffer, as ByteCount is a
    // USHORT (two bytes).
    //

    //
    // The WordCount parameter is a byte that indicates the number of
    // word parameters, and ByteCount is a word that indicated the
    // number of following bytes.  They do not account for their own
    // sizes, so add sizeof(UCHAR) + sizeof(USHORT) to account for them.
    //

    if ( ((SrvSmbWordCount[WorkContext->NextCommand] < 0)
                        ||
          ((CHAR)wordCount == SrvSmbWordCount[WorkContext->NextCommand]))

            &&

         ((PCHAR)byteCount <= (PCHAR)WorkContext->RequestBuffer->Buffer +
                             WorkContext->RequestBuffer->DataLength -
                             sizeof(USHORT))

            &&

         ((wordCount*sizeof(USHORT) + sizeof(UCHAR) + sizeof(USHORT) +
            SmbGetUshort( byteCount )) <= availableSpaceForSmb) ) {

        return(TRUE);

    }

    //
    // If we have an NT style WriteAndX, we let the client exceed the negotiated
    //  buffer size.  We do not need to check the WordCount, because we know that
    //  the SMB processor itself checks it.
    //
    if( WorkContext->LargeIndication ) {

        if( WorkContext->NextCommand == SMB_COM_WRITE_ANDX ) {
            return(TRUE);
        } else {
            IF_DEBUG(SMB_ERRORS) {
                KdPrint(( "LargeIndication but not WRITE_AND_X (%x) received!\n",
                        WorkContext->NextCommand ));
            }
            IF_DEBUG( ERRORS ) {
                KdPrint(("Closing connection %p -- msg too large\n", WorkContext->Connection ));
            }
            //
            // This client has really misbehaved.  Nuke it!
            //
            WorkContext->Connection->DisconnectReason = DisconnectBadSMBPacket;
            SrvCloseConnection( WorkContext->Connection, FALSE );

            return( FALSE );
        }

    }

    //
    // Make sure that the valid word count was sent across.  If the
    // value in the table is -1, then the processing routine will
    // verify the word count, and if the word count is -2 then this
    // is an illegal command which will be caught later.
    //
    // We check whether the word count is negative first since
    // critical smbs like read/write (andX/raw) have -1.
    //

    if ( (CHAR)wordCount != SrvSmbWordCount[WorkContext->NextCommand] ) {

        //
        // Living with sin.  The DOS redir sends a word count of 9
        // (instead of 8) on a Transaction secondary SMB.  Pretend it
        // sent the correct number.
        //

        if ( WorkContext->RequestHeader->Command ==
                       SMB_COM_TRANSACTION_SECONDARY &&
             IS_DOS_DIALECT( WorkContext->Connection->SmbDialect) &&
             wordCount == 9 ) {

             wordCount = 8;
             *((PUCHAR)WorkContext->RequestParameters) = 8;

             byteCount = (PSMB_USHORT)( (PCHAR)WorkContext->RequestParameters +
                         sizeof(UCHAR) + (8 * sizeof(USHORT)) );

        } else {

            //
            // Any other request with an incorrect word count is
            // toast.  Reject the request.
            //

            IF_DEBUG(SMB_ERRORS) {
                KdPrint(( "SMB WordCount incorrect.  WordCount=%ld, "
                    "should be %ld (command = 0x%lx)\n", wordCount,
                    SrvSmbWordCount[WorkContext->NextCommand],
                    WorkContext->NextCommand ));
                KdPrint(( "  SMB received from %z\n",
                    (PCSTRING)&WorkContext->Connection->OemClientMachineNameString ));

            }
            SrvLogInvalidSmb( WorkContext );
            return FALSE;
        }
    }

    //
    // Make sure that the ByteCount lies within the boundaries of
    // the received SMB.  Without this test, it would be possible,
    // when at the end of a long AndX chain and WordCount is large,
    // for the server to take an access violation when looking at
    // ByteCount.  The location for ByteCount must be at least two
    // bytes short of the end of the buffer, as ByteCount is a
    // USHORT (two bytes).
    //

    if ( (PCHAR)byteCount > (PCHAR)WorkContext->RequestBuffer->Buffer +
                             WorkContext->RequestBuffer->DataLength -
                             sizeof(USHORT) ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "ByteCount address past end of sent SMB. "
                        "ByteCount address=0x%p, "
                        "End of buffer=0x%lx\n",
                        byteCount,
                        WorkContext->RequestBuffer->DataLength ));
            KdPrint(( "  SMB received from %z\n",
                    (PCSTRING)&WorkContext->Connection->OemClientMachineNameString ));

        }

        SrvLogInvalidSmb( WorkContext );

        IF_DEBUG( ERRORS ) {
            KdPrint(("Closing connection %p -- ByteCount too big\n", WorkContext->Connection ));
        }

        //
        // This client has really misbehaved.  Nuke it!
        //
        WorkContext->Connection->DisconnectReason = DisconnectBadSMBPacket;
        SrvCloseConnection( WorkContext->Connection, FALSE );

    } else {

        //
        // if this is an IOCTL smb with category 0x53, set byte count to zero.
        // This is due to a DOS Lm2.0 and Lm2.1 bug which does not zero out
        // the bcc causing the preceding check to fail.
        //

        if ( (WorkContext->RequestHeader->Command == SMB_COM_IOCTL) &&
             (((PREQ_IOCTL) WorkContext->RequestParameters)->Category == 0x53)
           ) {

            SmbPutUshort( byteCount , 0 );
            return(TRUE);
        }

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SMB WordCount and/or ByteCount incorrect.  "
                        "WordCount=%ld, ByteCount=%ld, Space=%ld\n",
                        wordCount, SmbGetUshort( byteCount ),
                        availableSpaceForSmb ));
            KdPrint(( "  SMB received from %z\n",
                        (PCSTRING)&WorkContext->Connection->OemClientMachineNameString ));

        }

        SrvLogInvalidSmb( WorkContext );
    }

    return FALSE;

} // SrvValidateSmb


NTSTATUS
SrvWildcardRename(
            IN PUNICODE_STRING FileSpec,
            IN PUNICODE_STRING SourceString,
            OUT PUNICODE_STRING TargetString
            )

/*++

Routine Description:

    This routine converts a filespec and a source filename into a
    destination file name.  This routine is used to support DOS-based
    wildcard renames.

Arguments:

    FileSpec - The wildcard specification describing the destination file.
    SourceString - Pointer to a string that contains the source file name.
    TargetString - Pointer to a string that will contain the destination name.

Return Value:

    Status of operation.

--*/
{
    PWCHAR currentFileSpec;
    WCHAR delimit;
    PWCHAR buffer;
    PWCHAR source;
    ULONG bufferSize;
    ULONG sourceLeft;
    ULONG i;

    //
    // This will store the number of bytes we have written to the
    // target buffer so far.
    //

    ULONG resultLength = 0;

    PAGED_CODE( );

    //
    // This points to the current character in the filespec.
    //

    currentFileSpec = FileSpec->Buffer;

    //
    //  Initialize the pointer and the length of the source buffer.
    //

    source = SourceString->Buffer;
    sourceLeft = SourceString->Length;

    //
    //  Initialize the pointer and the length of the target buffer.
    //

    buffer = TargetString->Buffer;
    bufferSize = TargetString->MaximumLength;

    //
    // Go throught each character in the filespec.
    //

    for ( i = 0; i < (ULONG)FileSpec->Length ; i += sizeof(WCHAR) ) {

        if (resultLength < bufferSize) {

            switch ( *currentFileSpec ) {
                case L':':
                case L'\\':
                    return STATUS_OBJECT_NAME_INVALID;

                case L'*':

                    //
                    // Store the next character.
                    //

                    delimit = *(currentFileSpec+1);

                    //
                    //  While we have not exceeded the buffer and
                    //  we have not reached the end of the source string
                    //  and the current source character is not equal to
                    //  the delimeter, copy the source character to the
                    //  target string.
                    //

                    while ( ( resultLength < bufferSize ) &&
                            ( sourceLeft > 0 ) &&
                            ( *source != delimit )  ) {

                        *(buffer++) = *(source++);
                        sourceLeft -= sizeof(WCHAR);
                        resultLength += sizeof(WCHAR);
                    }
                    break;

                case L'?':  //
                case L'>':  // should we even consider >, <, and "
                case L'<':  // I'll just put this here to be safe

                    //
                    // For each ? in the filespec, we copy one character
                    // from the source string.
                    //

                    if ( ( *source != L'.' ) && ( sourceLeft > 0 )) {

                        if (resultLength < bufferSize) {

                            *(buffer++) = *(source++);
                            sourceLeft -= sizeof(WCHAR);
                            resultLength += sizeof(WCHAR);

                        } else {

                            return(STATUS_BUFFER_OVERFLOW);

                        }

                    }
                    break;

                case L'.':
                case L'"':

                    //
                    // Discard all the characters from the source string up
                    // to . or the end of the string.
                    //

                    while ( (*source != L'.') && (sourceLeft > 0) ) {
                        source++;
                        sourceLeft -= sizeof(WCHAR);
                    }

                    *(buffer++) = L'.';
                    resultLength += sizeof(WCHAR);

                    if ( sourceLeft > 0 ) {
                        source++;
                        sourceLeft -= sizeof(WCHAR);
                    }
                    break;

                default:

                    //
                    // Just copy one to one
                    //

                    if ( (*source != L'.') && (sourceLeft > 0)) {
                        source++;
                        sourceLeft -= sizeof(WCHAR);
                    }

                    if (resultLength < bufferSize) {
                        *(buffer++) = *currentFileSpec;
                        resultLength += sizeof(WCHAR);

                    } else {

                        return(STATUS_BUFFER_OVERFLOW);

                   }
                   break;
            }

            currentFileSpec++;

        } else {
            return(STATUS_BUFFER_OVERFLOW);
        }
    }

    TargetString->Length = (USHORT)resultLength;

    return( STATUS_SUCCESS );

}  // SrvWildcardRename

VOID
DispatchToOrphanage(
    IN PQUEUEABLE_BLOCK_HEADER Block
    )
{
    KIRQL oldIrql;

    ASSERT( Block->BlockHeader.ReferenceCount == 1 );

    ExInterlockedPushEntrySList(
        &SrvBlockOrphanage,
        &Block->SingleListEntry,
        &GLOBAL_SPIN_LOCK(Fsd)
        );

    ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );

    InterlockedIncrement( &SrvResourceOrphanedBlocks );

    SrvFsdQueueExWorkItem(
        &SrvResourceThreadWorkItem,
        &SrvResourceThreadRunning,
        CriticalWorkQueue
        );

    RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );

    return;
} // DispatchToOrphanage

NTSTATUS
SrvIsAllowedOnAdminShare(
    IN PWORK_CONTEXT WorkContext,
    IN PSHARE Share
)
/*++

Routine Description:

    This routine returns STATUS_SUCCESS if the client represented by
    the WorkContext should be allowed to access the Share, if the share
    is an Administrative Disk share.

Arguments:

    WorkContext - the unit of work
    Share - pointer to a share, possibly an administrative share

Return Value:

    STATUS_SUCCESS if allowed.  Error otherwise.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    if( Share->SpecialShare && Share->ShareType == ShareTypeDisk ) {

        SECURITY_SUBJECT_CONTEXT subjectContext;
        ACCESS_MASK desiredAccess, grantedAccess;

        status = IMPERSONATE( WorkContext );

        if( NT_SUCCESS( status ) ) {
            SeCaptureSubjectContext( &subjectContext );

            if( !SeAccessCheck(
                    Share->SecurityDescriptor,
                    &subjectContext,
                    FALSE,
                    SRVSVC_SHARE_CONNECT,
                    0L,
                    NULL,
                    &SrvShareConnectMapping,
                    UserMode,
                    &grantedAccess,
                    &status
                    ) ) {

                //
                // We have a non-administrative user trying to access a file
                // through an administrative share.  Can't allow that!
                //
                // Some clients want ACCESS_DENIED to be in the server class
                // instead of the DOS class when it's due to share ACL
                // restrictions.  So we need to keep track of why we're
                // returning ACCESS_DENIED.
                //

                WorkContext->ShareAclFailure = TRUE;
            }

            SeReleaseSubjectContext( &subjectContext );

            REVERT();
        }
    }

    return status;
}

NTSTATUS
SrvRetrieveMaximalAccessRightsForUser(
    CtxtHandle              *pUserHandle,
    PSECURITY_DESCRIPTOR    pSecurityDescriptor,
    PGENERIC_MAPPING        pMapping,
    PACCESS_MASK            pMaximalAccessRights)
/*++

Routine Description:

    This routine retrieves the maximal access rights for this client

Arguments:

    pUserHandle     - the users security handle

    pSecurityDescriptor  - the security descriptor

    pMapping        - the mapping of access rights

    pMaximalAccessRights - the computed rights

Return Value:

    Status of operation.

Notes:

    The srv macros IMPERSONATE is defined in terms of a WORK_CONTEXT. Since
    we desire this routine should be used in all situations even when a
    WORK_CONTEXT is not available the code in SrvImpersonate is duplicated
    over here

--*/
{
    NTSTATUS status;
    PPRIVILEGE_SET privileges = NULL;
    SECURITY_SUBJECT_CONTEXT subjectContext;

    if( !IS_VALID_SECURITY_HANDLE (*pUserHandle) ) {
        return STATUS_ACCESS_DENIED;
    }

    status = ImpersonateSecurityContext(
                pUserHandle);

    if( NT_SUCCESS( status ) ) {

        SeCaptureSubjectContext( &subjectContext );

        if (!SeAccessCheck(
                pSecurityDescriptor,
                &subjectContext,
                FALSE,                  // Locked ?
                MAXIMUM_ALLOWED,
                0,                      // PreviousGrantedAccess
                &privileges,
                pMapping,
                UserMode,
                pMaximalAccessRights,
                &status
                ) ) {
            IF_DEBUG(ERRORS) {
                KdPrint((
                    "SrvCheckShareFileAccess: Status %x, Desired access %x\n",
                    status,
                    MAXIMUM_ALLOWED
                    ));
            }
        }

        if ( privileges != NULL ) {
            SeFreePrivileges( privileges );
        }

        SeReleaseSubjectContext( &subjectContext );

        REVERT();

        if (status == STATUS_ACCESS_DENIED) {
            *pMaximalAccessRights = 0;
            status = STATUS_SUCCESS;
        }
    }

    return status;
}

NTSTATUS
SrvRetrieveMaximalAccessRights(
    IN  OUT PWORK_CONTEXT WorkContext,
    OUT     PACCESS_MASK  pMaximalAccessRights,
    OUT     PACCESS_MASK  pGuestMaximalAccessRights)
/*++

Routine Description:

    This routine retrieves the maximal access rights for this client as well
    as a guest based upon the ACLs specified for the file

Arguments:

    WorkContext - pointer to the work context block that contains information
        about the request.

    pMaximalAccessRights  - the maximal access rights for this client.

    pGuestMaximalAccessRights - the maximal access rights for a guest

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;

    BOOLEAN  SecurityBufferAllocated = FALSE;

    PRFCB rfcb;

    ULONG lengthNeeded;

    LONG SecurityDescriptorBufferLength;

    PSECURITY_DESCRIPTOR SecurityDescriptorBuffer;

    GENERIC_MAPPING Mapping = {
                                FILE_GENERIC_READ,
                                FILE_GENERIC_WRITE,
                                FILE_GENERIC_EXECUTE,
                                FILE_ALL_ACCESS
                              };

    rfcb = WorkContext->Rfcb;

    SecurityDescriptorBufferLength = (WorkContext->RequestBuffer->DataLength -
                                      sizeof(SMB_HEADER) -
                                      - 4);

    if (SecurityDescriptorBufferLength > 0) {
        SecurityDescriptorBufferLength &= ~3;
    } else {
        SecurityDescriptorBufferLength = 0;
    }

    SecurityDescriptorBuffer = ((PCHAR)WorkContext->RequestBuffer->Buffer +
                                WorkContext->RequestBuffer->BufferLength -
                                SecurityDescriptorBufferLength);

    status = NtQuerySecurityObject(
                 rfcb->Lfcb->FileHandle,
                 (DACL_SECURITY_INFORMATION |
                  SACL_SECURITY_INFORMATION |
                  GROUP_SECURITY_INFORMATION |
                  OWNER_SECURITY_INFORMATION),
                 SecurityDescriptorBuffer,
                 SecurityDescriptorBufferLength,
                 &lengthNeeded
                 );

    if (status == STATUS_BUFFER_TOO_SMALL) {
        SecurityDescriptorBuffer = ALLOCATE_HEAP(lengthNeeded,PagedPool);

        if (SecurityDescriptorBuffer != NULL) {
            SecurityBufferAllocated = TRUE;

            SecurityDescriptorBufferLength = lengthNeeded;

            status = NtQuerySecurityObject(
                         rfcb->Lfcb->FileHandle,
                         (DACL_SECURITY_INFORMATION |
                          SACL_SECURITY_INFORMATION |
                          GROUP_SECURITY_INFORMATION |
                          OWNER_SECURITY_INFORMATION),
                         SecurityDescriptorBuffer,
                         SecurityDescriptorBufferLength,
                         &lengthNeeded
                         );
        } else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (status == STATUS_SUCCESS) {
        status = SrvRetrieveMaximalAccessRightsForUser(
                     &WorkContext->SecurityContext->UserHandle,
                     SecurityDescriptorBuffer,
                     &Mapping,
                     pMaximalAccessRights);
    }

    // Extract the GUEST access rights
    if (status == STATUS_SUCCESS) {
        status = SrvRetrieveMaximalAccessRightsForUser(
                     &SrvNullSessionToken,
                     SecurityDescriptorBuffer,
                     &Mapping,
                     pGuestMaximalAccessRights);

    }

    if (SecurityBufferAllocated) {
        FREE_HEAP(SecurityDescriptorBuffer);
    }

    return status;
}

NTSTATUS
SrvRetrieveMaximalShareAccessRights(
    IN PWORK_CONTEXT WorkContext,
    OUT PACCESS_MASK pMaximalAccessRights,
    OUT PACCESS_MASK pGuestMaximalAccessRights)
/*++

Routine Description:

    This routine retrieves the maximal access rights for this client as well
    as a guest based upon the ACLs specified for the share

Arguments:

    WorkContext - pointer to the work context block that contains information
        about the request.

    pMaximalAccessRights  - the maximal access rights for this client.

    pGuestMaximalAccessRights - the maximal access rights for a guest

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PSECURITY_DESCRIPTOR securityDescriptor;
    ACCESS_MASK grantedAccess;
    ACCESS_MASK mappedAccess = MAXIMUM_ALLOWED;

    PAGED_CODE( );

    ACQUIRE_LOCK_SHARED( WorkContext->TreeConnect->Share->SecurityDescriptorLock );

    securityDescriptor = WorkContext->TreeConnect->Share->FileSecurityDescriptor;

    if (securityDescriptor != NULL) {
        status = SrvRetrieveMaximalAccessRightsForUser(
                     &WorkContext->SecurityContext->UserHandle,
                     securityDescriptor,
                     &SrvFileAccessMapping,
                     pMaximalAccessRights);

        if (NT_SUCCESS(status)) {
            // Get the guest rights
            status = SrvRetrieveMaximalAccessRightsForUser(
                         &SrvNullSessionToken,
                         securityDescriptor,
                         &SrvFileAccessMapping,
                         pGuestMaximalAccessRights);
        }
    } else {
        // No Share Level ACL, Grant maximum access to both the current client
        // as well as guest

        *pMaximalAccessRights = 0x1ff;
        *pGuestMaximalAccessRights = 0x1ff;
    }

    RELEASE_LOCK( WorkContext->TreeConnect->Share->SecurityDescriptorLock );

    return status;
}

NTSTATUS
SrvUpdateMaximalAccessRightsInResponse(
    IN OUT PWORK_CONTEXT WorkContext,
    OUT PSMB_ULONG pMaximalAccessRightsInResponse,
    OUT PSMB_ULONG pGuestMaximalAccessRightsInResponse
    )
/*++

Routine Description:

    This routine updates the maximal access rights fields in an extended
    response. This is used to update these fields in various kinds of
    OPEN requests

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

    pMaximalAccessRightsInResponse - the maximal access rights field in
    the response

    pGuestMaximalAccessRightsInResponse - the guest maximal access rights field
    in the response

Return Value:

    STATUS_SUCCESS if successful, otherwise appropriate error code

--*/
{
    NTSTATUS status;

    ACCESS_MASK  OwnerMaximalAccessRights = 0;
    ACCESS_MASK  GuestMaximalAccessRights = 0;

    status = SrvRetrieveMaximalAccessRights(
                 WorkContext,
                 &OwnerMaximalAccessRights,
                 &GuestMaximalAccessRights);

    if (status == STATUS_SUCCESS) {
        SmbPutUlong(
            pMaximalAccessRightsInResponse,
            OwnerMaximalAccessRights
            );

        SmbPutUlong(
            pGuestMaximalAccessRightsInResponse,
            GuestMaximalAccessRights
            );
    }

    return status;
}


NTSTATUS
SrvUpdateMaximalShareAccessRightsInResponse(
    IN OUT PWORK_CONTEXT WorkContext,
    OUT PSMB_ULONG pMaximalAccessRightsInResponse,
    OUT PSMB_ULONG pGuestMaximalAccessRightsInResponse
    )
/*++

Routine Description:

    This routine updates the maximal access rights fields in an extended
    response. This is used to update these fields in various kinds of
    TREE_CONNECT requests

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

    pMaximalAccessRightsInResponse - the maximal access rights field in
    the response

    pGuestMaximalAccessRightsInResponse - the guest maximal access rights field
    in the response

Return Value:

    STATUS_SUCCESS if successful, otherwise appropriate error code

--*/
{
    NTSTATUS status;

    ACCESS_MASK  OwnerMaximalAccessRights = 0;
    ACCESS_MASK  GuestMaximalAccessRights = 0;

    status = SrvRetrieveMaximalShareAccessRights(
                 WorkContext,
                 &OwnerMaximalAccessRights,
                 &GuestMaximalAccessRights);

    if (status == STATUS_SUCCESS) {
        SmbPutUlong(
            pMaximalAccessRightsInResponse,
            OwnerMaximalAccessRights
            );

        SmbPutUlong(
            pGuestMaximalAccessRightsInResponse,
            GuestMaximalAccessRights
            );
    }

    return status;
}

VOID SRVFASTCALL
RestartConsumeSmbData(
    IN OUT PWORK_CONTEXT WorkContext
)
/*++

Routine Description:

    This is the restart routine for 'SrvConsumeSmbData'.  We need to see if we
    drained the current message from the transport.  If we have, then we send
    the response SMB to the client.  If we have not, we keep going.

--*/
{
    PIRP irp = WorkContext->Irp;
    PIO_STACK_LOCATION irpSp;
    PTDI_REQUEST_KERNEL_RECEIVE parameters;

    ASSERT( WorkContext->LargeIndication );

    //
    // Check to see if we are done.  If so, send the response to the client
    //
    if( irp->Cancel ||
        NT_SUCCESS( irp->IoStatus.Status ) ||
        irp->IoStatus.Status != STATUS_BUFFER_OVERFLOW ) {

        RtlZeroMemory( WorkContext->ResponseHeader + 1, sizeof( SMB_PARAMS ) );
        WorkContext->ResponseBuffer->DataLength = sizeof( SMB_HEADER ) + sizeof( SMB_PARAMS );
        WorkContext->ResponseHeader->Flags |= SMB_FLAGS_SERVER_TO_REDIR;

        //
        // Send the data!
        //
        SRV_START_SEND_2(
            WorkContext,
            SrvFsdRestartSmbAtSendCompletion,
            NULL,
            NULL
            );

        return;
    }

    //
    // Not done yet.  Consume more data!
    //

    WorkContext->Connection->ReceivePending = FALSE;

    irp->Tail.Overlay.OriginalFileObject = NULL;
    irp->Tail.Overlay.Thread = WorkContext->CurrentWorkQueue->IrpThread;
    DEBUG irp->RequestorMode = KernelMode;

    //
    // Get a pointer to the next stack location.  This one is used to
    // hold the parameters for the device I/O control request.
    //
    irpSp = IoGetNextIrpStackLocation( irp );

    //
    // Set up the completion routine
    //
    IoSetCompletionRoutine(
        irp,
        SrvFsdIoCompletionRoutine,
        WorkContext,
        TRUE,
        TRUE,
        TRUE
        );

    WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
    WorkContext->FspRestartRoutine = RestartConsumeSmbData;

    irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    irpSp->MinorFunction = (UCHAR)TDI_RECEIVE;
    irpSp->FileObject = WorkContext->Connection->FileObject;
    irpSp->DeviceObject = WorkContext->Connection->DeviceObject;
    irpSp->Flags = 0;

    parameters = (PTDI_REQUEST_KERNEL_RECEIVE)&irpSp->Parameters;
    parameters->ReceiveLength = WorkContext->ResponseBuffer->BufferLength - sizeof( SMB_HEADER );
    parameters->ReceiveFlags = 0;

    //
    // Set the buffer's partial mdl to point just after the header for this
    // WriteAndX SMB.  We need to preserve the header to make it easier to send
    // back the response.
    //

    IoBuildPartialMdl(
        WorkContext->RequestBuffer->Mdl,
        WorkContext->RequestBuffer->PartialMdl,
        WorkContext->ResponseHeader + 1,
        parameters->ReceiveLength
    );

    irp->MdlAddress = WorkContext->RequestBuffer->PartialMdl;
    irp->AssociatedIrp.SystemBuffer = NULL;
    irp->Flags = (ULONG)IRP_BUFFERED_IO;        // ???

    (VOID)IoCallDriver( irpSp->DeviceObject, irp );

}

SMB_PROCESSOR_RETURN_TYPE
SrvConsumeSmbData(
    IN OUT PWORK_CONTEXT WorkContext
)
/*++

Routine Description:

    This routine handles the case where we have received a LargeIndication
    from a client (i.e. received SMB exceeds the negotiated buffer size).  Some
    error has occurred prior to consuming the entire message.  The SMB header is
    already formatted for the response, but we need to consume the rest of the
    incoming data and then send the response.

--*/
{
    if( WorkContext->LargeIndication == FALSE ) {
        return SmbStatusSendResponse;
    }

    IF_DEBUG( ERRORS ) {
        KdPrint(("SRV: SrvConsumeSmbData, BytesAvailable = %u\n",
                WorkContext->BytesAvailable ));
    }

    WorkContext->Irp->Cancel = FALSE;
    WorkContext->Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;
    RestartConsumeSmbData( WorkContext );

    return SmbStatusInProgress;
}

BOOLEAN
SrvIsDottedQuadAddress(
    IN PUNICODE_STRING ServerName
)
/*++

Routine Description:
    Return true if the ServerName appears to be a dotted quad address along the lines
    of xxx.yyy.zzz.qqq

    False otherwise
--*/
{
    PWCHAR p, ep;
    DWORD numberOfDots = 0;
    DWORD numberOfDigits = 0;

    PAGED_CODE();

    //
    // If the address is all digits and contains 3 dots, then we'll figure that it's
    //  a dotted quad address.
    //

    ep = &ServerName->Buffer[ ServerName->Length / sizeof( WCHAR ) ];

    for( p = ServerName->Buffer; p < ep; p++ ) {

        if( *p == L'.' ) {
            if( ++numberOfDots > 3 || numberOfDigits == 0 ) {
                return FALSE;
            }
            numberOfDigits = 0;

        } else if( (*p < L'0' || *p > L'9') || ++numberOfDigits > 3 ) {
            return FALSE;
        }
    }

    return (numberOfDots == 3) && (numberOfDigits <= 3);
}


BOOLEAN
SrvIsLocalHost(
    IN PUNICODE_STRING ServerName
)
/*++

Routine Description:
    Return true if the ServerName represents the loopback connection

    False otherwise
--*/
{
    UNICODE_STRING LocalHost = { 18, 18, L"localhost" };

    return !RtlCompareUnicodeString( ServerName, &LocalHost, TRUE );
}

PSESSION
SrvFindSession(
    IN PCONNECTION connection,
    IN USHORT Uid
    )
{
    PTABLE_HEADER tableHeader;
    PSESSION session;
    USHORT index;
    USHORT sequence;

    PAGED_CODE( );

    //
    // Initialize local variables:  obtain the connection block address
    // and crack the UID into its components.
    //

    index = UID_INDEX( Uid );
    sequence = UID_SEQUENCE( Uid );

    //
    // Acquire the connection's session lock.
    //

    ACQUIRE_LOCK( &connection->Lock );

    //
    // If this is a down-level (LAN Man 1.0 or earlier) client, than
    // we will not receive a UID, and there will only be one session
    // per connection.  Reference that session.
    //

    tableHeader = &connection->PagedConnection->SessionTable;
    if (!DIALECT_HONORS_UID(connection->SmbDialect) ) {

        session = tableHeader->Table[0].Owner;

    } else if ( (index < tableHeader->TableSize) &&
         (tableHeader->Table[index].Owner != NULL) &&
         (tableHeader->Table[index].SequenceNumber == sequence) ) {

        //
        // The UID is in range, is in use, and has the correct sequence
        // number.
        //

        session = tableHeader->Table[index].Owner;

    } else {

        //
        // The UID is invalid for this connection.
        //

        session = NULL;
    }

    if( session && GET_BLOCK_STATE(session) == BlockStateActive )
    {
        SrvReferenceSession( session );
    }
    else
    {
        session = NULL;
    }

    RELEASE_LOCK( &connection->Lock );

    return session;
}

NTSTATUS
DuplicateSystemHandle(PKPROCESS InitialSystemProcess,
              HANDLE FileHandle,
              HANDLE *NewFileHandle)
{
    HANDLE  SystemProcess;
    NTSTATUS    Status;

    if (NewFileHandle == NULL) {
    return STATUS_INVALID_PARAMETER;
    }

    Status = ObOpenObjectByPointer(
                InitialSystemProcess,
                0,
                NULL,
                0,
                NULL, //PsProcessType,
                KernelMode,
                &SystemProcess
                );

    if ( !NT_SUCCESS(Status)) {
        return Status;
    }

    Status = ZwDuplicateObject(
                SystemProcess,
                FileHandle,
                NtCurrentProcess(),
                NewFileHandle,
                0,
                0,
                DUPLICATE_SAME_ATTRIBUTES | DUPLICATE_SAME_ACCESS
                );

    // close system process
    ZwClose (SystemProcess);

    return Status;
}

NTSTATUS
SrvCreateHandleWithOptions(PUNICODE_STRING FileName,
               HANDLE FileHandle,
               ULONG Options,
               ACCESS_MASK Access,
               ULONG    Share,
               BOOLEAN  KernelHandle,
               HANDLE *Handle)
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS    err;
    UNICODE_STRING cwspath;
    WCHAR *name;
    WCHAR *prefix = L"\\??\\";
    ULONG length;

    length = (wcslen(prefix) * sizeof(WCHAR)) + FileName->MaximumLength + sizeof(WCHAR);
    name = ALLOCATE_HEAP( length, BlockTypeMisc );
    if (name == NULL) {
        return STATUS_NO_MEMORY;
    }

    cwspath.Buffer = name;
    cwspath.MaximumLength = (USHORT)length;
    cwspath.Length = 0;
    RtlAppendUnicodeToString(&cwspath, prefix);
    RtlAppendUnicodeStringToString(&cwspath, FileName);

    InitializeObjectAttributes(&ObjectAttributes,
           &cwspath,
                   OBJ_CASE_INSENSITIVE |
               ((KernelHandle == TRUE) ? OBJ_KERNEL_HANDLE : 0),
                   NULL,
                   0);

    err = IoCreateFileSpecifyDeviceObjectHint (Handle,
                           Access,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           NULL,
                           0L,
                           Share,
                           FILE_OPEN,
                           Options,
                           NULL,
                           0,
                           CreateFileTypeNone,
                           NULL,
                           IO_IGNORE_SHARE_ACCESS_CHECK |
                           IO_NO_PARAMETER_CHECKING,
                           NULL);

    FREE_HEAP(name);

    return err;
}

NTSTATUS
SrvProcessHandleDuplicateRequest(
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PSRV_REQUEST_HANDLE_DUP pDupRequest,
    IN OUT PSRV_RESPONSE_HANDLE_DUP pOutHandleDup
    )
{
    PRFCB rfcb;
    PSESSION session;
    NTSTATUS status;

    PAGED_CODE( );

    //
    // Try to find a file that matches the file ID.  Only an exact
    // match will work.
    //

    rfcb = SrvFindEntryInOrderedList(
               &SrvRfcbList,
               NULL,
               NULL,
               (ULONG)(pDupRequest->Key.ResumeKey),
               TRUE,
               NULL
               );

    if ( (rfcb == NULL) ||
         ( (UINT64)(rfcb->PagedRfcb->OpenTime.QuadPart) != pDupRequest->Key.Timestamp) ) {
        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    //
    // Don't do LWIO on TIMEWARP files
    //
    if ( rfcb->Mfcb->SnapShotTime.QuadPart != 0 )
    {
        SrvDereferenceRfcb( rfcb );
        return STATUS_NOT_SUPPORTED;
    }

    //
    // Validate that the SID matches that used to open the file
    //
    session = SrvFindSession( rfcb->Connection, rfcb->Uid );
    if( !session )
    {
        status = STATUS_OBJECT_NAME_NOT_FOUND;
    }
    else
    {
        pOutHandleDup->LockKey = rfcb->ShiftedFid | SmbGetUshort(&pDupRequest->Key.Pid);

        status = SrvImpersonateSession( session );

        if( NT_SUCCESS(status) )
        {
            if (IoGetCurrentProcess() != SrvServerProcess) {
                status = DuplicateSystemHandle(SrvServerProcess,
                               rfcb->Lfcb->FileHandle,
                               &pOutHandleDup->hFile);

                if (pDupRequest->Options != 0 && status == STATUS_SUCCESS) {
                    HANDLE tmp;

                    if (SrvCreateHandleWithOptions(&rfcb->Lfcb->Mfcb->FileName,
                           pOutHandleDup->hFile,
                           pDupRequest->Options,
                           rfcb->GrantedAccess,
                           rfcb->ShareAccess,
                           FALSE,
                           &tmp) == STATUS_SUCCESS) {
                        ZwClose(pOutHandleDup->hFile);
                        pOutHandleDup->hFile = tmp;
                    }
                }
            } else {
                status = SrvCreateHandleWithOptions(
                                    &rfcb->Lfcb->Mfcb->FileName,
                                    rfcb->Lfcb->FileHandle,
                                    pDupRequest->Options,
                                    rfcb->GrantedAccess,
                                    rfcb->ShareAccess,
                                    TRUE,
                                    &pOutHandleDup->hFile);
            }

            SrvRevert();
        }

        SrvDereferenceSession( session );
    }

    SrvDereferenceRfcb( rfcb );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

    Add SRVNTVERCHK to the C_DEFINES line below if you want to enable
    server side checking of NT build numbers.  Having compiled with this,
    you can set REG_DWORD MinNt5Client in the registry to the minimum NT5
    build number that a client must be running in order to connect to a disk
    share on this server.  If you have clients which you want to exclude from
    this check, you can add their static IP address to REG_MULTI_SZ ValidNT5IPAddr
    as dotted quad values. You do not need to restart the server if you make
    changes to these registry values.  If you want to restrict clients from connecting
    to all shares (not just disk), use the MinNT5ClientIPC keyword instead of
    MinNt5Client.



!ENDIF

MAJORCOMP=ntos
MINORCOMP=srv

TARGETNAME=srv
TARGETTYPE=DRIVER
TARGETPATH=obj

TARGETLIBS=$(DDK_LIB_PATH)\tdi.lib \
           $(DDK_LIB_PATH)\ksecdd.lib \
           $(DS_LIB_PATH)\rsa32k.lib

# merge RSA32K.LIB paged code & data into non-paged sections.
LINKER_FLAGS = $(LINKER_FLAGS) -merge:PAGER32C=.text -merge:PAGER32D=.data -merge:PAGER32R=.rdata


NT_UP=0

INCLUDES=\
    ..;\
    $(O);\
    $(NET_INC_PATH);\
    $(DS_INC_PATH);\
    $(DS_INC_PATH)\crypto;\
    $(DRIVERS_INC_PATH);\
    $(IFSKIT_INC_PATH)


C_DEFINES=$(C_DEFINES) -D_NTDRIVER_ -D_PNP_POWER_ -DSRVNTVERCHK -DSRVCATCH -DSYSCACHE_DEBUGGING

MSC_WARNING_LEVEL=/W3 /WX

!IFNDEF DISABLE_NET_UNICODE
UNICODE=1
NET_C_DEFINES=-DUNICODE
!ENDIF

!IFDEF BUILD_FOR_3_51
C_DEFINES=$(C_DEFINES) -D_NTIFS_
!ENDIF

NTPROFILEINPUT=yes

SOURCES=               \
        ..\access.c    \
        ..\blkconn.c   \
        ..\blkdebug.c  \
        ..\blkdir.c    \
        ..\blkendp.c   \
        ..\blkfile.c   \
        ..\blksec.c    \
        ..\blksess.c   \
        ..\blkshare.c  \
        ..\blksrch.c   \
        ..\blktable.c  \
        ..\blktimer.c  \
        ..\blktrans.c  \
        ..\blktree.c   \
        ..\blkwork.c   \
        ..\copy.c      \
        ..\dfs.c       \
        ..\ea.c        \
        ..\errorlog.c  \
        ..\fsd.c       \
        ..\fsddisp.c   \
        ..\fsdraw.c    \
        ..\fsdsmb.c    \
        ..\fspinit.c   \
        ..\heapmgr.c   \
        ..\info.c      \
        ..\ipx.c       \
        ..\io.c        \
        ..\lock.c      \
        ..\lockcode.c  \
        ..\move.c      \
        ..\network.c   \
        ..\open.c      \
        ..\oplock.c    \
        ..\pipe.c      \
        ..\prnsupp.c   \
        ..\scavengr.c  \
        ..\share.c     \
        ..\smbadmin.c  \
        ..\smbattr.c   \
        ..\smbclose.c  \
        ..\smbdir.c    \
        ..\smbfile.c   \
        ..\smbfind.c   \
        ..\smbioctl.c  \
        ..\smblock.c   \
        ..\smbmisc.c   \
        ..\smbmpx.c    \
        ..\smbnotfy.c  \
        ..\smbopen.c   \
        ..\smbprint.c  \
        ..\smbproc.c   \
        ..\smbraw.c    \
        ..\smbrdwrt.c  \
        ..\smbsrch.c   \
        ..\smbsupp.c   \
        ..\smbtrans.c  \
        ..\smbtree.c   \
        ..\srv.rc      \
        ..\srvconfg.c  \
        ..\srvdata.c   \
        ..\srvsnap.c   \
        ..\srvstamp.c  \
        ..\srvstat.c   \
        ..\srvstrng.c  \
        ..\svcconn.c   \
        ..\svcfile.c   \
        ..\svcsess.c   \
        ..\svcshare.c  \
        ..\svcsrv.c    \
        ..\svcstats.c  \
        ..\svcsupp.c   \
        ..\svcxport.c  \
        ..\worker.c    \
        ..\xssupp.c

RUN_WPP=$(SOURCES) -km -gen{simple.tpl}*.tmh -func:KdPrint((MSG,...)) -ini:localwpp.ini -func:SrvPrint0(MSG) -func:SrvPrint1(MSG,...) -func:SrvPrint2(MSG,...) -func:SrvPrint3(MSG,...) -func:SrvPrint4(MSG,...)

NTTARGETFILE0=srv.bmf

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

SOURCES_USED=..\SOURCES.INC
MISCFILES=smbsrv.sld
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\srvblock.h ===
/*++ BUILD Version: 0003    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    srvblock.h

Abstract:

    This module defines the standard header for data blocks maintained
    by the LAN Manager server.

Author:

    Chuck Lenzmeier (chuckl) 1-Dec-1989
    David Treadwell (davidtr)

Revision History:

--*/

#ifndef _SRVBLOCK_
#define _SRVBLOCK_

//#include "srvtypes.h"


//
// The following define the various types of data blocks used by the
// server.
//
// *** The pool tag array in heapmgr.c must be maintained in concert
//     with these definitions.
//

#define BlockTypeGarbage            0x00
#define BlockTypeBuffer             0x01
#define BlockTypeConnection         0x02
#define BlockTypeEndpoint           0x03
#define BlockTypeLfcb               0x04
#define BlockTypeMfcb               0x05
#define BlockTypeRfcb               0x06
#define BlockTypeSearch             0x07
#define BlockTypeSearchCore         0x08
#define BlockTypeSession            0x0A
#define BlockTypeShare              0x0B
#define BlockTypeTransaction        0x0C
#define BlockTypeTreeConnect        0x0D
#define BlockTypeWaitForOplockBreak 0x0E
#define BlockTypeCommDevice         0x0F
#define BlockTypeWorkContextInitial 0x10
#define BlockTypeWorkContextNormal  0x11
#define BlockTypeWorkContextRaw     0x12
#define BlockTypeWorkContextSpecial 0x13
#define BlockTypeCachedDirectory    0x14

// The following "blocks" do NOT have block headers.

#define BlockTypeDataBuffer         0x15
#define BlockTypeTable              0x16
#define BlockTypeNonpagedHeader     0x17
#define BlockTypePagedConnection    0x18
#define BlockTypePagedRfcb          0x19
#define BlockTypeNonpagedMfcb       0x1A
#define BlockTypeTimer              0x1B
#define BlockTypeAdminCheck         0x1C
#define BlockTypeWorkQueue          0x1D
#define BlockTypeDfs                0x1E
#define BlockTypeLargeReadX         0x1F
#define BlockTypeAdapterStatus      0x20
#define BlockTypeShareRemark        0x21
#define BlockTypeShareSecurityDescriptor    0x22
#define BlockTypeVolumeInformation  0x23
#define BlockTypeFSName             0x24
#define BlockTypeNameInfo           0x25
#define BlockTypeDirectoryInfo      0x26
#define BlockTypeDirCache           0x27
#define BlockTypeMisc               0x28
#define BlockTypeSnapShot           0x29
#define BlockTypeSecurityContext    0x2A

// The following is defined just to know how many types there are.
#define BlockTypeMax                0x2B

//
// The following define the various states that blocks can be in.
// Initializing is used (relatively rarely) to indicate that
// creation/initialization of a block is in progress.  Active is the
// state blocks are usually in.  Closing is used to indicate that a
// block is being prepared for deletion; when the reference count on the
// block reaches 0, the block will be deleted.  Dead is used when
// debugging code is enabled to indicate that the block has been
// deleted.
//

#define BlockStateDead          0x00
#define BlockStateInitializing  0x01
#define BlockStateActive        0x02
#define BlockStateClosing       0x03

// The following is defined just to know how many states there are.

#define BlockStateMax           0x04


//
// ALLOCATE_NONPAGED_POOL is a macro that translates to a call to
// SrvAllocateNonPagedPool if debugging is not enabled or to
// SrvAllocateNonPagedPoolDebug if it is enabled.
// DEALLOCATE_NONPAGED_POOL translates to SrvFreeNonPagedPool or
// SrvFreeNonPagedPoolDebug.  The Srv routines are used to track pool
// usage by the server.
//

//
// When POOL_TAGGING is on, we pass the block type through to
// SrvAllocateNonPagedPool so that it can pass a tag to the pool
// allocator.
//

#ifdef POOL_TAGGING
#define ALLOCATE_NONPAGED_POOL(size,type) \
            SrvAllocateNonPagedPool( (size), (type) )
#else
#define ALLOCATE_NONPAGED_POOL(size,type) \
            SrvAllocateNonPagedPool( (size) )
#endif

#define DEALLOCATE_NONPAGED_POOL(addr) SrvFreeNonPagedPool( (addr) )

//
// Routines that track server nonpaged pool usage in order to support the
// "maxnonpagedmemoryusage" configuration parameter.
//

PVOID SRVFASTCALL
SrvAllocateNonPagedPool (
    IN CLONG NumberOfBytes
#ifdef POOL_TAGGING
    ,IN CLONG BlockType
#endif
    );

VOID SRVFASTCALL
SrvFreeNonPagedPool (
    IN PVOID Address
    );

VOID SRVFASTCALL
SrvClearLookAsideList(
    PLOOK_ASIDE_LIST l,
    VOID (SRVFASTCALL *FreeRoutine )( PVOID )
    );

//
// The _HEAP macros are like the _NONPAGED_POOL macros, except they
// operate on paged pool.  The "HEAP" name is historical, from the
// days when the server used process heap instead of paged pool.
//
// *** When SRVDBG2 is enabled, all server control blocks and all
//     reference history blocks must be allocated from nonpaged pool,
//     because SrvUpdateReferenceHistory touches these thing while
//     holding a spin lock (i.e., at raised IRQL).  To make this easy,
//     the ALLOCATE_HEAP and FREE_HEAP macros are modified to use
//     nonpaged pool.  This means that ALL memory allocated by the
//     server comes out of nonpaged pool when SRVDBG2 is on.
//

#if SRVDBG2

#define ALLOCATE_HEAP(size,type) ALLOCATE_NONPAGED_POOL( (size), (type) )
#define ALLOCATE_HEAP_COLD(size,type) ALLOCATE_NONPAGED_POOL( (size), (type) )
#define FREE_HEAP(addr) DEALLOCATE_NONPAGED_POOL( (addr) )

#else // SRVDBG2

//
// When POOL_TAGGING is on, we pass the block type through to
// SrvAllocateNonPagedPool so that it can pass a tag to the pool
// allocator.
//

#ifdef POOL_TAGGING
#define ALLOCATE_HEAP(size,type) SrvAllocatePagedPool( PagedPool, (size), (type) )
#define ALLOCATE_HEAP_COLD(size,type) SrvAllocatePagedPool( (PagedPool | POOL_COLD_ALLOCATION), (size), (type) )
#else
#define ALLOCATE_HEAP(size,type) SrvAllocatePagedPool( PagedPool, (size) )
#define ALLOCATE_HEAP_COLD(size,type) SrvAllocatePagedPool( (PagedPool | POOL_COLD_ALLOCATION), (size) )
#endif

#define FREE_HEAP(addr) SrvFreePagedPool( (addr) )

#endif // else SRVDBG2

//
// Routines that track server paged pool usage in order to support the
// "maxpagedmemoryusage" configuration parameter.
//

PVOID SRVFASTCALL
SrvAllocatePagedPool (
    IN POOL_TYPE PoolType,
    IN CLONG NumberOfBytes
#ifdef POOL_TAGGING
    ,IN CLONG BlockType
#endif
    );

VOID SRVFASTCALL
SrvFreePagedPool (
    IN PVOID Address
    );


//
// SHARE_TYPE is an enumerated type used to indicate what type of
// resource is being shared.  This type corresponds to the server
// table StrShareTypeNames.  Keep the two in sync.
//

typedef enum _SHARE_TYPE {
    ShareTypeDisk,
    ShareTypePrint,
    ShareTypePipe,
    ShareTypeWild   // not a real share type, but can be specified in tcon
} SHARE_TYPE, *PSHARE_TYPE;

//
// SHARE_SNAPSHOT represents a snapshot availible for this share.
//
typedef struct _SHARE_SNAPSHOT
{
    LIST_ENTRY SnapShotList;
    ULONG Flags;
    HANDLE SnapShotRootDirectoryHandle;
    LARGE_INTEGER Timestamp;
    UNICODE_STRING SnapShotName;    // "SS@GMT-YYYY.MM.DD-HH.MM.SS"
    UNICODE_STRING SnapShotPath;
} SHARE_SNAPSHOT, *PSHARE_SNAPSHOT;

#define SNAPSHOT_NAME_LENGTH (strlen("@GMT-YYYY.MM.DD-HH.MM.SS")+1)*sizeof(WCHAR)
#define SNAPSHOT_NAME_FORMAT L"@GMT-%04d.%02d.%02d-%02d.%02d.%02d"
#define SRV_SNAP_SHARE_NOT_FOUND 1

//
// For each resource that the server shares, a Share Block is
// maintained.  The global share list is anchored at SrvShareHashTable.  A
// list of active tree connections using a resource is anchored in the
// Share Block.
//

typedef struct _SHARE {
    BLOCK_HEADER BlockHeader;   // must be first element

    LIST_ENTRY TreeConnectList;
    LIST_ENTRY GlobalShareList;

    HANDLE RootDirectoryHandle;

    UNICODE_STRING ShareName;
    UNICODE_STRING NtPathName;
    UNICODE_STRING DosPathName;
    UNICODE_STRING Remark;
    UNICODE_STRING RelativePath;


    ULONG ShareNameHashValue;

    union {
        struct {
            UNICODE_STRING Name;
            OEM_STRING OemName;
        } FileSystem;
        HANDLE hPrinter;
    } Type;

    ULONG MaxUses;
    ULONG CurrentUses;
    ULONG CurrentRootHandleReferences;              // used for removable devices
    LONG QueryNamePrefixLength;

    PSECURITY_DESCRIPTOR SecurityDescriptor;        // for tree connects
    PSECURITY_DESCRIPTOR FileSecurityDescriptor;    // file acls on shares

    SHARE_TYPE ShareType;
    BOOLEAN Removable;                              // Is the share storage removable?
    BOOLEAN SpecialShare;
    BOOLEAN IsDfs;                                  // Is this share in the Dfs?
    BOOLEAN IsDfsRoot;                              // Is this share the root of a Dfs?
    BOOLEAN PotentialSystemFile;                    // Are files in this share potentially
                                                    //   system files?
    BOOLEAN IsCatchShare;                           // Should the SRVCATCH code be active

    ULONG   ShareProperties;

    //
    // These flags are returned to the client on a tree connect to instruct the client
    //  how it can cache the files on this share.  The server does not interpret these
    //  flags -- it is the client's responsibility to do the right thing.
    //
    ULONG CSCState;

    PSRV_LOCK SecurityDescriptorLock;

    HANDLE ShareVolumeHandle;
    LIST_ENTRY SnapShots;
    PSRV_LOCK  SnapShotLock;
    LONG       SnapShotEpic;

    // WCHAR ShareNameData[ShareName.MaximumLength];
    // WCHAR NtPathNameData[PathName.MaximumLength];
    // WCHAR DosPathNameData[PathName.MaximumLength];
    // SECURITY_DESCRIPTOR SecurityDescriptor;

} SHARE, *PSHARE;

//
// For each network that the server uses, an Endpoint Block is
// maintained.  An ENDPOINT contains the network name (for
// administrative purposes), the endpoint name (server address), the
// endpoint (file) handle, a pointer to the endpoint object, a pointer
// to the transport provider's device object, and state information.
// The global endpoint list is anchored at SrvEndpointList.  A list of
// active connections created using an endpoint is anchored in the
// Endpoint Block.
//

#if SRVDBG29
#define HISTORY_LENGTH 256
typedef struct {
    ULONG Operation;
    PVOID Connection;
    BLOCK_HEADER ConnectionHeader;
} HISTORY, *PHISTORY;
#define UpdateConnectionHistory(_op,_endp,_conn) {                          \
    PHISTORY history = &(_endp)->History[(_endp)->NextHistoryLocation++];   \
    if ((_endp)->NextHistoryLocation >= HISTORY_LENGTH) {                   \
        (_endp)->NextHistoryLocation = 0;                                   \
    }                                                                       \
    history->Operation = *(PULONG)(_op);                                    \
    history->Connection = (_conn);                                          \
    if (_conn) {                                                            \
        history->ConnectionHeader = *(PBLOCK_HEADER)(_conn);                \
    }                                                                       \
}
#endif

struct _CONNECTION;

typedef struct _ENDPOINT {
    BLOCK_HEADER BlockHeader;   // must be first element

    //
    // List of free connections.
    //

    LIST_ENTRY FreeConnectionList;

    //
    // Table of connections.  We use a table instead of a list in order
    // to speed up lookup of IPX connections based on the SID stored in
    // the SMB header.
    //

    TABLE_HEADER ConnectionTable;

    ORDERED_LIST_ENTRY GlobalEndpointListEntry;

    //
    // Handle and file/device objects for connection-oriented endpoint
    // or for connectionless server data socket.
    //

    HANDLE EndpointHandle;
    PFILE_OBJECT FileObject;
    PDEVICE_OBJECT DeviceObject;
    PULONG IpxMaxPacketSizeArray;
    ULONG MaxAdapters;

    //
    // Handle and file/device objects for connectionless NetBIOS name
    // socket.
    //

    HANDLE NameSocketHandle;
    PFILE_OBJECT NameSocketFileObject;
    PDEVICE_OBJECT NameSocketDeviceObject;

    PDRIVER_DISPATCH FastTdiSend;
    PDRIVER_DISPATCH FastTdiSendDatagram;

    TDI_ADDRESS_IPX LocalAddress;

    ULONG FreeConnectionCount;
    ULONG TotalConnectionCount;

    //
    // Various flags
    //
    struct {
        ULONG IsConnectionless  : 1;    // connectionless transport?
        ULONG NameInConflict    : 1;    // unable to claim name?
        ULONG IsPrimaryName     : 1;    // set if not an alternate name
        ULONG IsNoNetBios       : 1;    // set if we are direct hosting on a VC
        ULONG RemapPipeNames    : 1;    // set if we are remapping pipe names for clusters
    };

    WCHAR NetworkAddressData[12 + 1];

    UNICODE_STRING NetworkName;         // administrative name
    UNICODE_STRING TransportName;       // e.g., "\Device\Nbf_Elnkii01"
    UNICODE_STRING ServerName;          // e.g., L"NTSERVER"
    ANSI_STRING TransportAddress;       // e.g., "NTSERVER        "
    UNICODE_STRING NetworkAddress;
    UNICODE_STRING DomainName;          // domain being served by this endpoint
    OEM_STRING     OemDomainName;       // oem version of domain name

    // WCHAR NetworkNameData[NetworkName.MaximumLength/2];
    // WCHAR TransportNameData[TransportName.MaximumLength/2];
    // WCHAR ServerName[ ServerName.MaximumLength/2 ];
    // CHAR TransportAddressData[TransportAddress.MaximumLength];
    // WCHAR DomainNameData[ DNLEN + 1];
    // CHAR  OemDomainNameData[ DNLEN+1 ]

    BOOLEAN AlternateAddressFormat;     // should this endpoint be included when
                                        // enumerating?
#if SRVDBG29
    ULONG NextHistoryLocation;
    HISTORY History[HISTORY_LENGTH];
#endif

} ENDPOINT, *PENDPOINT;


//
// Size of search hash table (must be a power of 2)
//

#define SEARCH_HASH_TABLE_SIZE      4

typedef struct _HASH_TABLE_ENTRY {

    LIST_ENTRY ListHead;
    BOOLEAN Dirty;

} HASH_TABLE_ENTRY, *PHASH_TABLE_ENTRY;

//
// When we discover something which is a directory, we place the name
//  in this per-connection cache for quick re-use for CheckPath.
//
typedef struct {
    BLOCK_HEADER;
    LIST_ENTRY      ListEntry;                  // list is linked through this element
    UNICODE_STRING  DirectoryName;              // canonicalized name of this directory
    USHORT          Tid;                        // DirectoryName is relative to this tid
    ULONG           TimeStamp;                  // Tick count when this element was cached

} CACHED_DIRECTORY, *PCACHED_DIRECTORY;

//
// For each connection (virtual circuit) that is created, a Connection
// Block is maintained.  All connections made over a single endpoint are
// linked through that endpoint.  Tables of sessions, tree connects, and
// files created using a connection are anchored in the connection
// block.
//
// The Lock field in the connection protects the data in the connection
// and the data structures associated with the connection, such as
// the tree connects and sessions.  However, the list of connections
// linked off the endpoint is protected by the endpoint lock, and
// LFCBs and RFCBs associated with a connection are protected by
// the MFCB's lock.
//

typedef struct _PAGED_CONNECTION {

    PAGED_HEADER PagedHeader;

    //
    // List of active transactions
    //

    LIST_ENTRY TransactionList;

    //
    // This list is maintained in order of access, so the entry at the top
    // of the list is the oldest, the entry at the bottom is the youngest.
    //

    LIST_ENTRY CoreSearchList;

    //
    // This information is used to determine whether oplocks and Raw
    // I/O's are allowed.  This is determined by information obtained by
    // querying the transport provider using TDI_QUERY_CONNECTION_INFO.
    //

    LARGE_INTEGER LinkInfoValidTime;
    LARGE_INTEGER Throughput;
    LARGE_INTEGER Delay;

    //
    // Table headers for session, tree connect, and search tables.
    //

    TABLE_HEADER SessionTable;
    TABLE_HEADER TreeConnectTable;
    TABLE_HEADER SearchTable;

    HANDLE ConnectionHandle;

    //
    // The number of searches active on the connection.
    //

    USHORT CurrentNumberOfCoreSearches;

    //
    // Hash table for picking out duplicate core searches
    //

    HASH_TABLE_ENTRY SearchHashTable[SEARCH_HASH_TABLE_SIZE];

    //
    // The encryption key obtained from LsaCallAuthenticationPackage.
    // This is a per-VC value--any logon on a given VC uses this
    // encryption key.
    //

    UCHAR EncryptionKey[MSV1_0_CHALLENGE_LENGTH];

    //
    // If we have an NT5 client, this is its build number (if non-zero)
    //
    ULONG ClientBuildNumber;

    //
    // Have we logged an invalid SMB for this client yet?  We use this
    //  flag to keep a single client from flooding the event log
    //
    BOOLEAN LoggedInvalidSmb;

#if SRVNTVERCHK
    //
    // Have we determined that the client's NT build number is too old to
    //  allow it to connect to this server?
    //
    BOOLEAN ClientTooOld;
#endif

} PAGED_CONNECTION, *PPAGED_CONNECTION;

#define MAX_SAVED_RESPONSE_LENGTH 100
#define SRV_CONNECTION_SOCKADDR_SIZE 32

typedef struct _CONNECTION {

    QUEUEABLE_BLOCK_HEADER ;    // must be first element

/* start of spin lock cache line */

    //
    // Per-connection spin lock.
    //

    KSPIN_LOCK SpinLock;

    //
    // Points to the endpoint spinlock that guards this connection's
    // entry in the endpoint connection table.
    //

    PKSPIN_LOCK EndpointSpinLock;

    //
    // This is the WORK_QUEUE we are queueing on, which may not be the
    //  same as PreferredWorkQueue due to load balancing
    //
    PWORK_QUEUE CurrentWorkQueue;

    //
    // A countdown for the number of operations we'll do before we try
    //  to pick a better processor for this connection
    //
    ULONG BalanceCount;

    //
    // Cached Rfcb
    //

    struct _RFCB *CachedRfcb;
    ULONG CachedFid;

    //
    // BreakIIToNoneJustSent is set when a oplock break II to none is
    // sent, and reset whenever an SMB is received.  If a raw read
    // arrives while this is set, the raw read is rejected.
    //

    BOOLEAN BreakIIToNoneJustSent;

    //
    // Raw io enabled
    //

    BOOLEAN EnableRawIo;

    //
    // Sid represents the connection's location in the endpoint's
    // connection table.
    //

    USHORT Sid;

    // The SidIndex allows us to use all the 16 bits for the index. For
    // regular connections this prevents the aliasing problem that can occur
    // in using the IXPSID index since the IPX sequence number takes up 4 bits

    USHORT  SidIndex;

    // additional USHORT to satisfy alignment on dword boundaries
    USHORT  Pad;

    //
    // Pointer to the endpoint, fileobject, and deviceobject
    //

    PENDPOINT Endpoint;
    PFILE_OBJECT FileObject;

    PDEVICE_OBJECT DeviceObject;

    //
    // The maximum message size we can send over this connection.
    //

    ULONG   MaximumSendSize;

    //
    // This is the WORK_QUEUE we would prefer to be on, because this
    //  queue assigns work to the same procesor that is handling the
    //  adaptor's DPCs
    //

    PWORK_QUEUE PreferredWorkQueue;

    //
    // Table header for file table.
    //

    TABLE_HEADER FileTable;

    //
    // The SMB dialect chosen for this connection.  Used in fsd.
    //

    SMB_DIALECT SmbDialect;

    //
    // List of active work items associated with the connection.
    //

    LIST_ENTRY InProgressWorkItemList;

    //
    // Stores the time of the last oplock break resp processed.  This is
    // used to synchronize readraw processing with the oplock break
    // processing.
    //

    ULONG LatestOplockBreakResponse;

    //
    // The following two fields descibe operations in progress on this
    // connection.  It is possible that there are multiple oplock breaks
    // in progress.  Also, there is a brief window when multiple raw
    // reads can be active -- after we've sent the response to one raw
    // read, but before we've done postprocessing (so it looks like the
    // first one is still in progress), we could receive another raw
    // read request.
    //
    // Interaction between the two fields are controlled using
    // SrvFsdSpinLock (see the block comment in oplock.c for details).
    //

    LONG OplockBreaksInProgress;
    ULONG RawReadsInProgress;

    //
    // Are oplocks allowed?
    //

    BOOLEAN OplocksAlwaysDisabled;
    BOOLEAN EnableOplocks;

    //
    // Is the client coming in over IPX?
    //
    BOOLEAN DirectHostIpx;

    //
    // Are security signatures currently active for this connection?
    //  Security signatures are not supported for Direct Host IPX connections
    //  and some W9x clients
    //
    BOOLEAN SmbSecuritySignatureActive;

    union {
        //
        //  The following struct of this union holds relevant state
        //   when the client is connecting over direct host IPX.
        //   IpxAddress holds the client's IPX address, when the client
        //   'connects' over IPX.
        //
        struct {
            USHORT SequenceNumber;
            USHORT LastResponseLength;
            USHORT LastResponseBufferLength;
            USHORT LastUid;
            USHORT LastTid;
            NTSTATUS LastResponseStatus;
            ULONG IpxDuplicateCount;
            ULONG IpxDropDuplicateCount;
            ULONG StartupTime;
            TDI_ADDRESS_IPX IpxAddress;
            PVOID LastResponse;
        };

        //
        // This struct holds relevant state when the client is using
        //  a virtual circuit.
        //
        struct {

            //
            // The following fields are used for security signatures.
            //
            MD5_CTX Md5Context;

            ULONG SmbSecuritySignatureIndex;

            // If we are unable to allocate a WORK_CONTEXT
            // at receive indicate time, the receive is done
            // in SrvFsdServiceNeedResourceQueue.  Depending
            // on the received SMB, we sometimes do not send
            // a response SMB.  Since the Tdi lookahead data
            // is not available when SrvFsdServiceNeedResourceQueue
            // is run, we have to remember not to advance the signature
            // index for the response.

            BOOLEAN NoResponseSignatureIndex;

            //
            // The following field, if non-zero is the IP address of the client
            //
            ULONG ClientIPAddress;

            USHORT SockAddr[SRV_CONNECTION_SOCKADDR_SIZE/sizeof(USHORT)];

        };
    };

    //
    // Pointer to paged part of connection block.
    //

    PPAGED_CONNECTION PagedConnection;

    //
    // Per-connection interlock.
    //

    KSPIN_LOCK Interlock;

    //
    // Quadword align list entries and large ints
    //

    LIST_ENTRY EndpointFreeListEntry;

    //
    // A list of deferred oplock work break items.  Oplock breaks are
    // deferred if a read raw is in progress, or if the server runs
    // out of work context blocks, and cannot send the oplock break
    // request.
    //

    LIST_ENTRY OplockWorkList;

    //
    // List of RFCBs with batch oplocks that have been cached after
    // being closed by the client.  Count of such RFCBs.
    //

    LIST_ENTRY CachedOpenList;
    ULONG CachedOpenCount;

    //
    // List of directories which have been recently identified.  This is a list of
    //  CACHED_DIRECTORY entries.
    //
    LIST_ENTRY CachedDirectoryList;
    ULONG      CachedDirectoryCount;

    //
    // Security context handle for the extensible security negotiate buffer.
    //

    CtxtHandle NegotiateHandle;

    //
    // The following represent consumer capabilities.
    //

    ULONG ClientCapabilities;

    //
    // Per-connection resource.
    //

    SRV_LOCK Lock;

    //
    // Lock for dealing with the license server
    //

    SRV_LOCK LicenseLock;

    //
    // Oem version of the client machine name string.
    //

    OEM_STRING OemClientMachineNameString;

    //
    // A string for the client's name.  The Buffer field points to the
    // leading slashes (below), the MaximumLength is
    // (COMPUTER_NAME_LENGTH + 3) * sizeof(WCHAR), and Length is the
    // number of characters in the name that are not blanks *
    // sizeof(WHCAR).
    //

    UNICODE_STRING ClientMachineNameString;

    //
    // The following two fields make up the client's name in the form
    // "\\client              ", including a trailing NULL.
    //

    WCHAR LeadingSlashes[2];
    WCHAR ClientMachineName[COMPUTER_NAME_LENGTH+1];

    //
    // Head of singly linked list of cached transactions.
    //

    SLIST_HEADER CachedTransactionList;
    LONG CachedTransactionCount;

    //
    // The time when the last message was received for this connection
    //
    ULONG LastRequestTime;

    //
    // If we are on the OnNeedResourceQueue for a pending recieve, this
    //  is the amount of data that was indicated to us.
    //
    ULONG BytesAvailable;

    //
    // OnNeedResource is true if this connection is on the global need
    // recource queue.  This happens if it is waiting for a work context
    // block to complete a pending receive or an oplock break request.
    //

    BOOLEAN OnNeedResourceQueue;

    //
    // NotReusable is set when an operation fails in such a way that the
    // server's idea of the connection state may be different than the
    // transport's.  For example, a server-initiated disconnect failed.
    // If we tried to reuse the connection (by returning it from a
    // connect indication), the transport would get confused.  When
    // NotReusable is set, SrvDereferenceConnection frees the connection
    // instead of putting it on the endpoint's free list.
    //

    BOOLEAN NotReusable;

    //
    // DisconnectPending indicates that a disconect indication has been
    // received from the transport.  ReceivePending indicates that the
    // server could not assign a work item to handle a receive indication.
    //

    BOOLEAN DisconnectPending;
    BOOLEAN ReceivePending;

    //
    // Oem version of the client name.  We need this because we could
    // not do unicode operations in the fsd, where we initially get our
    // computer name.
    //

    CHAR OemClientMachineName[COMPUTER_NAME_LENGTH+1];

    //
    // Information about the client context.
    //

    UNICODE_STRING ClientOSType;
    UNICODE_STRING ClientLanManType;

    UCHAR BuiltinSavedResponse[MAX_SAVED_RESPONSE_LENGTH];

    //
    // The number of sessions active on the connection.
    //

    USHORT CurrentNumberOfSessions;

    // Used to monitor how many work contexts a client is using up
    LONG InProgressWorkContextCount;
    LONG OperationsPendingOnTransport;
    BOOLEAN IsConnectionSuspect;
    DISCONNECT_REASON DisconnectReason;

} CONNECTION, *PCONNECTION;

//
// For each session that is created, a Session Block is maintained.  All
// sessions created over a single connection are linked through a table
// owned by that connection.  A list of files opened using a session can
// be obtained by searching the file table owned by the connection
// block.
//

// This is copied from ntmsv1_0.h

typedef struct _SECURITY_CONTEXT {
    BLOCK_HEADER BlockHeader;
    CtxtHandle UserHandle;
} SECURITY_CONTEXT, *PSECURITY_CONTEXT;

typedef enum _SRV_SESSION_KEY_STATE {
    SrvSessionKeyUnavailible = 0,
    SrvSessionKeyAuthenticating,
    SrvSessionKeyAvailible
} SRV_SESSION_KEY_STATE;

#define MSV1_0_USER_SESSION_KEY_LENGTH 16

typedef struct _SESSION {
    //
    // *** NOTE:  The reference count field in the session block
    //            header is not used!  Instead, the reference count is
    //            in the NonpagedHeader structure.
    //

    BLOCK_HEADER BlockHeader;

    PNONPAGED_HEADER NonpagedHeader;

    ULONG CurrentFileOpenCount;          // count of files open on the session
    ULONG CurrentSearchOpenCount;        // count of searches open on the session

    ORDERED_LIST_ENTRY GlobalSessionListEntry;

    PCONNECTION Connection;

    //
    // If clients are using the GSS-style authentication, we query the
    //  UserHandle for the user and domain names.  If they are using
    //  old-style authentication, we store the names here.  In any case,
    //  code that needs access to the user and/or domain names should
    //  call SrvGetUserAndDomainName() and SrvReleaseUserAndDomainName()
    //
    UNICODE_STRING NtUserName;
    UNICODE_STRING NtUserDomain;

    LARGE_INTEGER StartTime;
    LARGE_INTEGER LastUseTime;           // for autologoff
    LARGE_INTEGER LogOffTime;            // for forced logoff
    LARGE_INTEGER KickOffTime;           // for forced logoff
    LARGE_INTEGER LastExpirationMessage; // for forced logoff

    LUID LogonId;
    CHAR NtUserSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];
    CHAR LanManSessionKey[MSV1_0_LANMAN_SESSION_KEY_LENGTH];

    PSECURITY_CONTEXT SecurityContext;   // Security handle to this user

    USHORT MaxBufferSize;                // Consumer's maximum buffer size
    USHORT MaxMpxCount;                  // Actual max multiplexed pending requests
    USHORT Uid;

    SRV_SESSION_KEY_STATE SessionKeyState;           // Used to determine if the session key can be given to the user.

    BOOLEAN UsingUppercasePaths;         // Must paths be uppercased?
    BOOLEAN GuestLogon;                  // Is the client logged on as a guest?
    BOOLEAN EncryptedLogon;              // Was an encrypted password sent?
    BOOLEAN LogoffAlertSent;
    BOOLEAN TwoMinuteWarningSent;
    BOOLEAN FiveMinuteWarningSent;
    BOOLEAN IsNullSession;               // Is client using a null session?
    BOOLEAN IsAdmin;                     // Is this an administrative user?
    BOOLEAN IsLSNotified;                // Does license server know about this user?
    BOOLEAN LogonSequenceInProgress;     // Are we in the middle of an extended logon sequence?
    BOOLEAN IsSessionExpired;            // Do we need to reauthenticate?
    HANDLE  hLicense;                    // if( IsLSNotified ) this is License handle

#if SRVNTVERCHK
    //
    // Have we determined that we don't like this client's domain?
    //
    BOOLEAN ClientBadDomain;
#endif

    //CHAR UserNameBuffer[UserName.MaximumLength];

} SESSION, *PSESSION;

//
// For each tree connect that is made, a Tree Connect Block is
// maintained.  All tree connects made over a single connection are
// linked through a table owned by that connection.  All tree connects
// made to a single shared resource are linked through that share block.
// A list of files opened using a tree connect can be obtained by
// searching the file table owned by the connection block.
//

typedef struct _TREE_CONNECT {
    //
    // *** NOTE:  The reference count field in the tree connect block
    //            header is not used!  Instead, the reference count is
    //            in the NonpagedHeader structure.
    //

    BLOCK_HEADER BlockHeader;

    PNONPAGED_HEADER NonpagedHeader;

    PCONNECTION Connection;
    PSESSION Session;
    PSHARE Share;

    ORDERED_LIST_ENTRY GlobalTreeConnectListEntry;

    ULONG CurrentFileOpenCount;

    LIST_ENTRY ShareListEntry;
    LIST_ENTRY PrintFileList;                // only if print share

    LARGE_INTEGER StartTime;

    UNICODE_STRING ServerName;

    BOOLEAN RemapPipeNames;

    USHORT Tid;

} TREE_CONNECT, *PTREE_CONNECT;


//
// Master File Control Block (MFCB) -- one per named file that is open
//      at least once.  Used to support compatibility mode and oplocks.
//
// Local File Control Block (LFCB) -- one for each local open instance.
//      Represents local file object/handle.  There may be multiple
//      LFCBs linked to a single MFCB.
//
// Remote File Control Block (RFCB) -- one for each remote open instance.
//      Represents remote FID.  There is usually one RFCB per LFCB, but
//      multiple compatibility mode RFCBs may be linked to a single LFCB.
//      Multiple remote FCB opens for a single file from a single session
//      are folded into one RFCB, because old DOS redirectors only send
//      one close.
//

//
// For each disk file that is open, a Master File Control Block (MFCB)
// is maintained.  If a given file is open multiple times, there is one
// MFCB for the file and multiple LFCBs, one for each local open
// instance.  All MFCBs are linked into the global Master File Table.
// The MFCB has a list of the LFCBs representing open instances for the
// file.
//

typedef struct _NONPAGED_MFCB {

    union {

        //
        // When NONPAGED_MFCB structures are freed, they may be placed
        // on the WORK_QUEUE's MfcbFreeList to avoid unnecessary Nonpaged
        // pool activity.  SingleListEntry is used for the linkage.
        //

        SLIST_ENTRY SingleListEntry;

        struct {
            ULONG Type;
            PVOID PagedBlock;

            //
            // We must serialize opens to the same file, since 2 concurrent opens
            // may be compatibility mode opens.  This lock also protects all data
            // in this MFCB and the LFCBs and RFCBs associated with this MFCB.
            //

            SRV_LOCK Lock;
        };
    };

    LARGE_INTEGER OpenFileSize;
    ULONG OpenFileAttributes;

} NONPAGED_MFCB, *PNONPAGED_MFCB;

typedef struct _MFCB {

    //
    // *** NOTE:  The reference count field in the mfcb block
    //            header is not used!  Instead, the reference count is
    //            in the NonpagedHeader structure.
    //

    BLOCK_HEADER BlockHeader;   // must be first element

    PNONPAGED_MFCB NonpagedMfcb;

    //
    // All LFCBs for a given named file are linked to the parent MFCB.
    //

    LIST_ENTRY LfcbList;

    //
    // The count of active RFCB for this MFCB.  This is used to coordinate
    // compatibility opens with non-compatibility mode opens.
    //

    ULONG ActiveRfcbCount;

    //
    // The fully qualified name of the file is appended to the MFCB.
    // The FileName field is a descriptor for the name.
    //
    UNICODE_STRING FileName;

    //
    // Mfcbs are linked into the MfcbHashTable by MfcbHashTableEntry
    //
    LIST_ENTRY MfcbHashTableEntry;

    //
    // FileNameHashValue is a hash value derived from the upper case
    //  version of FileName.  It is used to speed up name comparisons, and to
    //  locate the hash entry
    //
    ULONG FileNameHashValue;

    //
    // CompatibilityOpen indicates whether the file is open in
    // compatibility mode.
    //
    BOOLEAN CompatibilityOpen;

    //
    // Timestamp for SnapShot opens
    //
    LARGE_INTEGER SnapShotTime;

#if SRVCATCH
    CHAR SrvCatch;
#endif

    // WCHAR FileNameData[FileName.MaximumLength/2];

} MFCB, *PMFCB;

//
// The MFCBs are all linked into the master MFCB hash table.
//
typedef struct {
    LIST_ENTRY  List;           // the list of MFCBs in this bucket
    PSRV_LOCK   Lock;           // protects this bucket's list
} MFCBHASH, *PMFCBHASH;


//
// For each instance of a local file open, a Local File Control Block
// (LFCB) is maintained.  All LFCBs for a particular named file are
// linked through the MFCB for that file.
//
// LFCBs contain information that is specific to the local open, such
// as the file handle and a pointer to the file object.  The LFCB also
// contains other information that is common to all child RFCBs, such
// as pointers to the owning connection and tree connect.
//
//

typedef struct _LFCB {

    union {
        BLOCK_HEADER BlockHeader;           // must be first element
        SINGLE_LIST_ENTRY SingleListEntry;  // used when LFCB is freed
    };

    //
    // Multiple remote opens of a file are folded into a single local
    // open by linking the RFCBs to the parent LFCB.
    //

    LIST_ENTRY RfcbList;

    //
    // The number of associated active RFCBs.
    //

    ULONG HandleCount;

    //
    // LFCBs are linked into their MFCB's open file list.
    //

    PMFCB Mfcb;
    LIST_ENTRY MfcbListEntry;

    //
    // Connection, Session, and TreeConnect are referenced pointers to
    // the respective "owning" blocks.
    //

    PCONNECTION Connection;
    PSESSION Session;
    PTREE_CONNECT TreeConnect;

    //
    // GrantedAccess is the access obtained when the file was opened.
    // For a compatibility mode open, this is the maximum access
    // available to the client; individual opens may have less access.
    //

    ACCESS_MASK GrantedAccess;

    //
    // FileHandle is a handle to the open file.  FileObject is a
    // referenced pointer.  DeviceObject is NOT a referenced pointer;
    // the reference to the file object prevents the device object from
    // going away.
    //

    HANDLE FileHandle;
    PFILE_OBJECT FileObject;
    PDEVICE_OBJECT DeviceObject;

    //
    // FileMode tracks whether writethrough is enabled for this file
    // object.

    ULONG FileMode;

    //
    // The job ID of a print job corresponding to the opened file.
    // This is only used for print file opens.
    //

    ULONG JobId;

    //
    // Cache these hot-path entry points.
    //

    PFAST_IO_READ FastIoRead;
    PFAST_IO_WRITE FastIoWrite;
    PFAST_IO_LOCK FastIoLock;
    PFAST_IO_UNLOCK_SINGLE FastIoUnlockSingle;
    PFAST_IO_MDL_READ MdlRead;
    PFAST_IO_MDL_READ_COMPLETE MdlReadComplete;
    PFAST_IO_PREPARE_MDL_WRITE PrepareMdlWrite;
    PFAST_IO_MDL_WRITE_COMPLETE MdlWriteComplete;

    //
    // CompatibilityOpen indicates whether the file is open in
    // compatibility mode.
    //

    BOOLEAN CompatibilityOpen;

} LFCB, *PLFCB;


//
// For each instance of a remote file open, a Remote File Control Block
// (RFCB) is maintained.  The RFCB points to the LFCB that contains the
// local file handle.  Normally RFCBs and LFCBs exist in one-to-one
// correspondence, but multiple compatibility mode opens are folded into
// a single local open, so that the server can enforce the appropriate
// sharing rules.
//
// RFCBs contain information that is specific to the remote open, such
// as the assigned FID, the PID of the creator, the granted access mask,
// and the current file position.
//
// All RFCBs for a single connection are linked through a table owned by
// that connection; the FID assigned to the RFCB represents an index
// into the file table.  Pointers to the owning connection and tree
// connect can be found in the LFCB, which is pointed to by the RFCB.  A
// list of files opened through a given tree connect can be obtained by
// searching the owning connection's file table for RFCBs whose parent
// LFCBs point to the tree connect.
//

//
// WRITE_MPX_CONTEXT holds context associated with an active Write Block
// Multiplexed sequence.
//
// !!! This structure is probably big enough to be worth putting
//     outside the RFCB.
//

#define MAX_GLOM_RUN_COUNT 8

typedef struct _WRITE_MPX_RUN {
    USHORT Offset;
    USHORT Length;
} WRITE_MPX_RUN, *PWRITE_MPX_RUN;

typedef struct _WRITE_MPX_CONTEXT {

    //
    // ReferenceCount counts the number of Write Mpx SMBs that are
    // currently being processed.  When this count goes to zero, and
    // we have received the sequenced command that ends the current
    // mux, we send the response.  This method is needed to ensure
    // that we don't process the mux SMBs out-of-order, which leads
    // to performance problems, and even worse, data corruption,
    // thanks to the mask-shifting method used by the Snowball redir.
    //

    ULONG ReferenceCount;

    //
    // Mask holds the logical OR of the masks received in multiplexed
    // write requests.  When an IPX client sends the last block of write
    // mpx data, we send back MpxMask to indicate whether we lost any
    // frames.
    //

    ULONG Mask;

    //
    // FileObject is a copy of the file object pointer from the LFCB.
    //

    PFILE_OBJECT FileObject;

    //
    // Mid holds the MID of the current multiplexed write.  PreviousMid
    // hold the MID of the previous one.  This needs to be retained in
    // order to deal with duplicated write mux SMBs -- if a duplicate
    // SMB arrives AFTER the first SMB of the next write mux (with a new
    // MID), we need to know to toss it, not kill the new write mux.
    //

    USHORT Mid;
    USHORT PreviousMid;

    //
    // SequenceNumber holds the sequence number given in the last
    // request of the mux.  This needs to be retained because we
    // may be simultaneously processing previous parts of the mux
    // when we detect that we've received the sequenced comand.
    //

    USHORT SequenceNumber;

    //
    // Glomming is set if the current write mux series is being glommed
    // into one large write.
    //
    // GlomPending is set when the indication for the first packet of
    // a new write mux occurs.  It is cleared when the FSP is done
    // preparing the glomming operation.  While GlomPending is set,
    // subsequent packets of the write mux are queued to GlomDelayList.
    //

    BOOLEAN Glomming;
    BOOLEAN GlomPending;
    LIST_ENTRY GlomDelayList;

    ULONG StartOffset;
    USHORT Length;
    BOOLEAN GlomComplete;

    //
    // MpxGlommingAllowed is set when the underlying file system
    // supports MDL write.
    //

    BOOLEAN MpxGlommingAllowed;

    PMDL MdlChain;

    ULONG NumberOfRuns;
    WRITE_MPX_RUN RunList[MAX_GLOM_RUN_COUNT];

} WRITE_MPX_CONTEXT, *PWRITE_MPX_CONTEXT;

#define NO_OPLOCK_BREAK_IN_PROGRESS     ((UCHAR)-1)

typedef struct _PAGED_RFCB {

    PAGED_HEADER PagedHeader;

    //
    // RFCBs are linked into their parent LFCB's compatibility open
    // list.
    //

    LIST_ENTRY LfcbListEntry;

    //
    // Information about the last lock attempt by the client that failed.
    //

    LARGE_INTEGER LastFailingLockOffset;

    //
    // Current oplock break timeout.
    //

    LARGE_INTEGER OplockBreakTimeoutTime;

    //
    // FcbOpenCount indicates how many remote FCB opens this RFCB
    // represents.  (Whether an RFCB represents a compatibility mode
    // open can be determined by looking at the LFCB.)
    //
    // *** Note that FCB opens are treated similarly to compatibility
    //     mode opens.  However, soft compatibility maps compatibility
    //     opens into regular opens, but it does not change an FCB open
    //     into a non-FCB open.  So it is possible to have an FCB open
    //     that is not a compatibility mode open.
    //

    CLONG FcbOpenCount;

    //
    // Per-file context for a direct host IPX smart card, if we have one.
    //  The smart card is willing to handle the read operations for this file if
    //  IpxSmartCardContext is not NULL.
    //
    PVOID   IpxSmartCardContext;

    //
    // The time the RFCB was opened.  This combined with the ResumeKey uniquely identify
    // an RFCB
    //
    LARGE_INTEGER OpenTime;

} PAGED_RFCB, *PPAGED_RFCB;

typedef struct _RFCB {

    //
    // The list entry in the RFCB's block header is used to queue the
    // RFCB for oplock processing to the nonblocking worker thread work
    // queue, which also contains work context blocks.
    //
    // *** Note that this is an unnamed field, so that its elements can
    //     can be referenced directly.  The field names defined in
    //     QUEUEABLE_BLOCK_HEADER cannot be used elsewhere in this
    //     block.
    //

    QUEUEABLE_BLOCK_HEADER ;   // must be first element

/* start of spin lock cache line */

    //
    // These booleans indicate whether we've already been granted
    // read/write/lock access, thus saving a few instructions on every
    // read/write/lock.  These are checked during the file open.
    //

    BOOLEAN ReadAccessGranted;   // TRUE, if read access in granted
    BOOLEAN WriteAccessGranted;  // TRUE, if write access is granted
    BOOLEAN LockAccessGranted;   // TRUE, if lock access is granted
    BOOLEAN UnlockAccessGranted; // TRUE, if unlock access is granted
    BOOLEAN AppendAccessGranted; // TRUE, if append access is granted
    BOOLEAN ExclusiveLockGranted; // TRUE, if exclusive lock access is granted

    //
    // CurrentPosition maintains the file position after the last Read,
    // Write, or Seek by the client.  This field is needed only to
    // support relative Seeks.  Since clients that use relative seeks only
    // need 32-bits of file position, this field is maintained as a ULONG.
    //

    ULONG CurrentPosition;

    //
    // Type of this share.  Accessed in the fsd.
    //

    SHARE_TYPE ShareType;

    //
    // The connection pointer is copied from the LFCB so that we can
    // find the connection at DPC level (the LFCB is paged, as is the
    // pointer to the LFCB in PagedRfcb).
    //

    PCONNECTION Connection;

    //
    // The LFCB is used to find the file handle, file object, etc.
    //

    PLFCB Lfcb;

    //
    // MpxGlommingAllowed is set when the underlying file system
    // supports MDL write.
    //

    BOOLEAN MpxGlommingAllowed;

    //
    // The following two booleans describe the read mode, and blocking
    // mode of a named pipe.
    //

    BOOLEAN BlockingModePipe;  // TRUE = Blocking, FALSE = Nonblocking
    BOOLEAN ByteModePipe;      // TRUE = Byte mode, FALSE = Message mode

    //
    // Indicates whether this file has been written to.
    //

    BOOLEAN WrittenTo;

/* end of spin lock cache line */

    //
    // RawWriteSerializationList holds works items that have been queued
    // pending completion of a raw write.  When the raw write count is
    // decremented to 0, this list is flushed by restarting all queued
    // work items.
    //

    LIST_ENTRY RawWriteSerializationList;

    //
    // fid << 16.  Used for key computations.
    //

    ULONG ShiftedFid;

    //
    // RawWriteCount counts the number of active raw writes.  This is
    // used to prevent the file handle from being closed while raw
    // writes are in progress.  If Raw writes are in progress when the
    // close happens, we defer the cleanup until the rawwritecount goes
    // to zero.
    //

    ULONG RawWriteCount;

    //
    // SavedError retains the error code when a raw read or a raw write
    // in writebehind mode gets an error.  The next access to the file
    // will receive an error indication.
    //

    NTSTATUS SavedError;

    //
    // NumberOfLocks is the count of locks currently on the file.
    // It is here to support the File APis and RFCB cacheing -- you can't
    //   cache an RFCB if it has locks in it.
    //

    LONG NumberOfLocks;

    //
    // Fid is the file ID assigned to the file and returned to the
    // client.  Pid is the process ID given by the client when the file
    // was opened.  Tid is a copy of the parent tree connect's Tid
    // field.  Uid is used to ensure that the client using a file handle
    // is the same one that opened the file.
    //

    USHORT Fid;
    USHORT Pid;
    USHORT Tid;
    USHORT Uid;

    //
    // WriteMpx is a WRITE_MPX_CONTEXT structure.  It retains context
    // about multiplexed write operations.  This structure is not used
    // on connectionless sessions.
    //

    WRITE_MPX_CONTEXT WriteMpx;

    //
    // FileMode tracks whether writethrough is enabled for this file
    // object.

    ULONG FileMode;

    //
    // MFCB points to the Master File Control Block for this file.
    //

    PMFCB Mfcb;

    //
    // Oplock information.  The oplock IRP currently in progress, etc.
    // The list entry for queueing the RFCB for oplock break processing
    // is located in the block header.
    //

    PIRP Irp;
    BOOLEAN OnOplockBreaksInProgressList;

    //
    // The oplock level to change to, if there is an oplock break
    // in progress.  Otherwise it is always NO_OPLOCK_BREAK_IN_PROGRESS.
    //

    UCHAR NewOplockLevel;

    //
    // This boolean indicates whether or an oplock granted open response
    // need to be sent for this RFCB.  If it is FALSE, and an oplock break
    // request needs to be sent, the request must be deferred until after
    // sending the open response.
    //
    // Access to these fields is synchronized using the MFCB lock.
    //

    BOOLEAN OpenResponseSent;
    BOOLEAN DeferredOplockBreak;

    //
    // Pointer to the paged portion of the rfcb
    //

    PPAGED_RFCB PagedRfcb;

    //
    // CachedOpen is set if the RFCB has been cached after being
    // closed by the client.
    //

    LIST_ENTRY CachedOpenListEntry;
    BOOLEAN CachedOpen;

    //
    // See if this rfcb can be cached.
    //

    BOOLEAN IsCacheable;

    //
    // See if the file was accessed in the last scavenger update period.
    // (This is used to update the session last access time).
    //

    BOOLEAN IsActive;

    //
    // Is it ok for us to do MPX writes to this RFCB?
    //
    BOOLEAN MpxWritesOk;

    //
    //  This event is used when the server needs to request an oplock II
    //  when the initial oplock request fails.
    //

    PKEVENT RetryOplockRequest;

    //
    // All RFCBs in the server are stored in a global list to support
    // NetFileEnum.  This field contains the LIST_ENTRY for the RFCB in
    // the global list and a resume handle to support resuming
    // enumerations.
    //

    ORDERED_LIST_ENTRY GlobalRfcbListEntry;

    //
    // GrantedAccess is the access allowed through this open.  This
    // GrantedAccess may allow less access than that given in the parent
    // LFCB for compatibility mode opens.
    //

    ACCESS_MASK GrantedAccess;

    //
    // ShareAccess is the file sharing access specified when the file
    // was opened.
    //

    ULONG ShareAccess;

    //
    // Current oplock state.
    //

    OPLOCK_STATE OplockState;

    //
    // Is it ok for us to do MPX reads to this RFCB?
    //
    BOOLEAN MpxReadsOk;
#ifdef SRVCATCH
    CHAR SrvCatch;
#endif

#ifdef SRVDBG_RFCBHIST
    UCHAR HistoryIndex;
    ULONG History[256];
#endif

} RFCB, *PRFCB;

#ifdef SRVDBG_RFCBHIST
VOID UpdateRfcbHistory( PRFCB Rfcb, ULONG Event );
#else
#define UpdateRfcbHistory(_rfcb,_event)
#endif

//
// Each incoming (request) and outgoing (response) buffer is represented
// by a BUFFER structure.  This descriptor describes the size of the
// buffer, its address, and a full and partial MDL that may be used
// to describe the buffer.
//
// *** The descriptor contains a pointer to the real buffer, which is
//     normally allocated out of nonpaged pool.  The descriptor itself
//     may be allocated out of the FSP heap, although receive buffer
//     descriptors are allocated from nonpaged pool, so the FSD
//     read/write code can access them.
//

typedef struct _BUFFER {
    PVOID Buffer;
    CLONG BufferLength;             // Length allocated to buffer
    PMDL Mdl;                       // MDL describing entire buffer
    PMDL PartialMdl;                // Partial MDL for read/write/etc.
    CLONG DataLength;               // Length of data currently in buffer
    ULONG Reserved;                 // Pad to quadword
} BUFFER, *PBUFFER;

#define MIN_SEND_SIZE               512
#define MAX_PARTIAL_BUFFER_SIZE     65535

//
// For each search request that is started (Find First or core Search),
// a search block is allocated.  This is used to hold enough information
// that the search may be quickly restarted or rewound.
//
// Ths InUse field is protected by Connection->Lock--this lock must be
// held when accessing this field of the search block.
//

typedef struct _SEARCH {
    BLOCK_HEADER BlockHeader;

    HANDLE DirectoryHandle;

    ULONG LastFileIndexReturned;
    UNICODE_STRING SearchName;
    UNICODE_STRING LastFileNameReturned;

    LARGE_INTEGER LastUseTime;
    LIST_ENTRY LastUseListEntry;
    LIST_ENTRY HashTableEntry;

    PSESSION Session;
    PTREE_CONNECT TreeConnect;
    ULONG SearchStorageType;

    struct _DIRECTORY_CACHE *DirectoryCache;
    USHORT NumberOfCachedFiles;

    USHORT SearchAttributes;
    SHORT CoreSequence;
    SHORT TableIndex;
    USHORT HashTableIndex;

    USHORT Pid;
    USHORT Flags2;

    BOOLEAN Wildcards;
    BOOLEAN InUse;
    BOOLEAN DownlevelTimewarp;

    // WCHAR SearchNameData[SearchName.MaximumLength/2];

} SEARCH, *PSEARCH;

//
// Each pending transaction request (Transaction, Transaction2, and
// Ioctl) has a transaction block.  It records information that is
// needed to stage input and output data across multiple SMBs.
//
// *******************************************************************
// *                                                                 *
// * DO NOT CHANGE THIS STRUCTURE WITHOUT CHANGING THE CORRESPONDING *
// * STRUCTURE IN net\inc\xstypes.h!                                 *
// *                                                                 *
// *******************************************************************
//

typedef struct _TRANSACTION {

    //
    // *** NOTE:  The reference count field in the transaction block
    //            header is not used!  Instead, the reference count is
    //            in the NonpagedHeader structure.
    //

    BLOCK_HEADER BlockHeader;

    PNONPAGED_HEADER NonpagedHeader;

    //
    // The connection, session, and tree connect pointers are referenced
    // pointers if and only if Inserted is TRUE.  Otherwise, they are
    // simply copies of the work context block's pointers.
    //

    PCONNECTION Connection;
    PSESSION Session;
    PTREE_CONNECT TreeConnect;

    LIST_ENTRY ConnectionListEntry;

    UNICODE_STRING TransactionName; // not used if Transaction2

    ULONG StartTime;
    ULONG Timeout;
    CLONG cMaxBufferSize;        // if needed we stash this here

    //
    // The following pointers point into either the trailing portion
    // of the transaction block or the last received SMB.
    //
    // *** ALL information in buffers pointed to by these parameters
    //     should ALWAYS be in little-endian format.  Always use the
    //     macros defined in srvmacro.h (SmbGetAlignedUshort, etc.) to
    //     read from or write into these buffers.
    //

    PSMB_USHORT InSetup;
    PSMB_USHORT OutSetup;
    PCHAR InParameters;
    PCHAR OutParameters;
    PCHAR InData;
    PCHAR OutData;

    //
    // *** Data in all the remaining fields of the transaction block are
    //     in native format, so no special macros should be used, except
    //     when copying data to/from the actual SMB.
    //

    CLONG SetupCount;               // amount received (all in first buffer)
    CLONG MaxSetupCount;            // max that can be sent back
    CLONG ParameterCount;           // amount received or sent
    CLONG TotalParameterCount;      // amount expected
    CLONG MaxParameterCount;        // max that can be sent back
    CLONG DataCount;                // amount received or sent
    CLONG TotalDataCount;           // amount expected
    CLONG MaxDataCount;             // max that can be sent back

    USHORT Category;                // Ioctl function category
    USHORT Function;                // Nt Transaction or ioctl function code

    //
    // The SMB data and paramters may or may not be copied to the
    // transaction buffer.  If they are not copied, they are read
    // and/or written directly into an SMB buffer.
    //
    // Setup words are never copied.
    //

    BOOLEAN InputBufferCopied;       // if FALSE input buffer is in SMB
    BOOLEAN OutputBufferCopied;      // if FALSE output buffer is in SMB
    BOOLEAN OutDataAllocated;        // if TRUE OutData buffer has been separately allocated

    USHORT Flags;

    USHORT Tid;
    USHORT Pid;
    USHORT Uid;
    USHORT OtherInfo;

    HANDLE FileHandle;              // Used only for CallNamedPipe processing
    PFILE_OBJECT FileObject;        // Used only for CallNamedPipe processing

    //
    // The following fields are used while the response is being sent.
    //

    CLONG ParameterDisplacement;
    CLONG DataDisplacement;

    //
    // PipeRequest is set for named pipe transactions.  RemoteApiRequest
    // is set for remote API requests.
    //

    BOOLEAN PipeRequest;
    BOOLEAN RemoteApiRequest;

    //
    // The following boolean is TRUE if the transaction has been inserted
    // on the connection's transaction list.  It will be FALSE when the
    // transaction can be handled using a single SMB exchange.
    //

    BOOLEAN Inserted;

    //
    // This boolean is TRUE if the transaction is in the state where
    // it is waiting for a transaction secondary request to come in
    // to acknowledge the receipt of the previous piece of a multipiece
    // transaction response.
    //

    BOOLEAN MultipieceIpxSend;

    //
    // This boolean is TRUE if all of the transaction data has been received
    //  and the transaction has been scheduled for execution.
    //
    BOOLEAN Executing;

    //
    // The main part of the transaction block is trailed by transaction
    // name data and possibly setup words and parameter and data bytes.
    //

} TRANSACTION, *PTRANSACTION;

//
// Each pending blocking open request has a BLOCKING_OPEN block.  This
// block contains all the info needed to make the call into the file
// system.

typedef struct _BLOCKING_OPEN {
    BLOCK_HEADER BlockHeader;

    PMFCB Mfcb;

    PIO_STATUS_BLOCK IoStatusBlock;

    OBJECT_ATTRIBUTES ObjectAttributes;

    UNICODE_STRING RelativeName;

    PVOID EaBuffer;
    CLONG EaLength;

    LARGE_INTEGER AllocationSize;
    ULONG DesiredAccess;
    ULONG FileAttributes;
    ULONG ShareAccess;
    ULONG CreateDisposition;
    ULONG CreateOptions;

    BOOLEAN CaseInsensitive;

} BLOCKING_OPEN, *PBLOCKING_OPEN;

//
// SRV_TIMER is used for timed operations.  The server maintains a pool
// of these structures.
//

typedef struct _SRV_TIMER {
    SLIST_ENTRY Next;
    KEVENT Event;
    KTIMER Timer;
    KDPC Dpc;
} SRV_TIMER, *PSRV_TIMER;

typedef struct _IPX_CLIENT_ADDRESS {
    TA_IPX_ADDRESS IpxAddress;
    TDI_CONNECTION_INFORMATION Descriptor;
    IPX_DATAGRAM_OPTIONS DatagramOptions;
} IPX_CLIENT_ADDRESS, *PIPX_CLIENT_ADDRESS;

//
// The state for an I/O request is maintained in a Work Context Block.
// Various fields in the block are filled in or not depending upon the
// request.  When a worker thread removes a work item from the FSP work
// queue, it uses the context block, and items pointed to by the
// context block, to determine what to do.
//
// *** Not all of the back pointers have to be here, because a tree
//     connect points to a session, which points to a connection, which
//     points to an endpoint, etc.  However, depending on the operation
//     and the state of the operation, we may have a connection pointer
//     but no session pointer, etc.  So we maintain all of the
//     pointers.
//
// *** Any changes to the first 2 elements of this structure must be
//     made in concert with the SPECIAL_WORK_ITEM structure in srvtypes.h
//

typedef struct _WORK_CONTEXT {

    //
    // The list entry in the block header is used to queue the WC for to
    // the nonblocking or blocking worker thread work queue.  The
    // nonblocking work queue also contains RFCBs.
    //
    // *** Note that this is an unnamed field, so that its elements can
    //     can be referenced directly.  The field names defined in
    //     QUEUEABLE_BLOCK_HEADER cannot be used elsewhere in this
    //     block.
    //
    // Timestamp (in the block header) is used to calculate the total
    // time this work context block was on the work queue.
    //
    // When the work context block is not in use, Timestamp is used to
    // record the time at which the block was inserted on the free list.
    // This is used to determine when dynamically-allocated work context
    // blocks have been idle long enough justify their deletion.
    //
    // FspRestartRoutine (in the block header) is the routine that is to
    // be called by worker thread when the work item is dequeued from
    // the work queue.
    //

    QUEUEABLE_BLOCK_HEADER ;   // must be first element

    //
    // This is the WORK_QUEUE to queue on if we're doing nonblocking work
    //   It will always point to a valid WORK_QUEUE, even if we're doing
    //   blocking work.
    //
    PWORK_QUEUE CurrentWorkQueue;

    //
    // The free list this should be returned to when work is done
    //
    PSLIST_HEADER FreeList;

    //
    // FsdRestartRoutine is the routine that is to be called by the
    // FSD's I/O completion routine.  This routine can do more
    // processing or queue the work item to the FSP.  In this case, when
    // a worker thread removes the item from the work queue, it calls
    // FspRestartRoutine.
    //

    PRESTART_ROUTINE FsdRestartRoutine;

    //
    // Linkage field for the in-progress work item list.
    //

    LIST_ENTRY InProgressListEntry;

    //
    // Pointers to various structures that might be used.
    // These pointers are all referenced pointers.  It is
    // the responsibility of the SMB processing routines to
    // dereference and clear these pointers when they are no
    // longer needed.
    //
    PRFCB Rfcb;
    PSHARE Share;
    PSESSION Session;
    PTREE_CONNECT TreeConnect;
    PSECURITY_CONTEXT SecurityContext;

    //
    // These are gathered in one place to facilitate quick zeroing
    // of their values when the work context is finished
    //
    struct _WorkContextZeroBeforeReuse {
        //
        // unreferenced pointer to the endpoint structure for
        //  this work context.  Filled in by SrvRestartReceive and
        //  available to all SMB processing routines.
        //
        //  Endpoint must be the first element in this structure.  See
        //   INITIALIZE_WORK_CONTEXT in srvmacro.h if changed.
        //
        PENDPOINT Endpoint;         // not a referenced pointer

        //
        // referenced pointer to the connection structure for this
        //  this work context.  Filled in by SrvRestartReceive and
        //  available to all SMB processing routines.
        //
        PCONNECTION Connection;     // a reference pointer

        //
        // The number of times this SMB has been queued to a worker thread
        // for processing.
        //
        ULONG ProcessingCount;

        //
        // This is a random collection of flags that are needed to steer
        // the WorkItem
        //
        struct {

            //
            // Can the processing of the current SMB block?
            //

            ULONG BlockingOperation : 1;

            //
            // UsingExtraSmbBuffer is TRUE if this work context uses the an extra SMB
            // buffer.
            //

            ULONG UsingExtraSmbBuffer : 1;

            //
            // Did this Work Item cause a successful oplock open to occur?
            //

            ULONG OplockOpen : 1;

            //
            // If we got an ACCESS_DENIED error when opening a file, was it because
            // of share ACL checking?

            ULONG ShareAclFailure : 1;

            //
            // Should the WorkContext be queued to the head of the list?
            //
            ULONG QueueToHead : 1;

            //
            //  Even if security signatures are enabled, do not generate a signature for
            //   this response.
            //
            ULONG NoResponseSmbSecuritySignature : 1;

            //
            // The indicated message exceeds the SMB buffer size.  This is allowed
            //  only for specific SMB(s)
            //
            ULONG LargeIndication: 1;

#if DBG_STUCK
            //
            // Do not include this operation in the StuckOperation catching logic
            //  which is in the scavenger
            //
            ULONG IsNotStuck : 1;
#endif

        };

        // For SnapShot usage
        LARGE_INTEGER SnapShotTime;

    };

    //
    // Pointers to allocated buffers.  RequestBuffer is the buffer into
    // which the SMB is read.  ResponseBuffer is the buffer into which
    // the response is written.
    //
    // *** Currently, ResponseBuffer is always the same as
    //     RequestBuffer.  We have separate pointers in order to reduce
    //     dependence on this being the case.
    //

    PBUFFER RequestBuffer;
    PBUFFER ResponseBuffer;

    //
    // SMB processing pointers.  These are pointers into the request
    // buffer.  They are maintained in the work context block in support
    // of SMB processors that do asynchronous I/O.
    //
    // Separate request and response parameter pointers are maintained
    // to make AndX processing simpler and more efficient.  RequestHeader
    // is normally the same as ResponseHeader -- both are normally the
    // same as RequestBuffer.Buffer.  SMB processing code must not depend
    // on this -- it must not assume the the request and response buffers
    // are the same, nor can it assume that they are different.  Special
    // rules around AndX SMBs do allow them to assume that the response
    // to one command will not overwrite the next request.
    //

    PSMB_HEADER RequestHeader;
    PVOID RequestParameters;
    PSMB_HEADER ResponseHeader;
    PVOID ResponseParameters;

    //
    // Pointer to the IRP associated with this work item.
    //

    PIRP Irp;

    //
    // StartTime stores the time at which processing of the current
    // request began so that the turnaround time may be calculated.
    //

    ULONG StartTime;

    //
    // The PartOfInitialAllocation boolean indicates whether this work
    // item is part of the block of work items allocated at server
    // startup (see blkwork.c\SrvAllocateInitialWorkItems).  Such work
    // items cannot be deleted during server operation.  A work item
    // that is dynamically allocated in response to server load does not
    // have this bit set, and is a candidate for deletion when the
    // server's load decreases.
    //

    ULONG PartOfInitialAllocation;

    //
    // The following field contadins the command code of the next
    // command to be processed in an SMB.  The SMB processing
    // initializer and chained (AndX) SMB command processors load this
    // field prior to calling or returning to SrvProcessSmb.
    //

    UCHAR NextCommand;

    //
    // ClientAddress is used when receiving or sending over IPX.
    //

    PIPX_CLIENT_ADDRESS ClientAddress;

    //
    // Spin lock protecting reference count.
    //

    KSPIN_LOCK SpinLock;

    //
    // The security signature index for the request
    //
    ULONG SmbSecuritySignatureIndex;

    //
    // The security signature index for the response
    //
    ULONG ResponseSmbSecuritySignatureIndex;


    //
    // The following union is used to hold request-specific state while
    // a response is being sent or while waiting for more data.
    //

    union {

        //
        // RemainingEchoCount is used when processing the Echo SMB.
        //

        USHORT RemainingEchoCount;

        //
        // Structure used for lock processing.  This structure is
        // currently used when processing the Lock, LockingAndX, and the
        // LockAndRead SMBs.
        //

        struct {

            //
            // LockRange is used when processing the LockingAndX SMB.  It is
            // really either a PLOCKING_ANDX_RANGE, or a PNTLOCKING_ANDX_RANGE
            // not just a PVOID.
            //

            PVOID LockRange;

            //
            // Timer is a timer and DPC used to timeout lock requests.
            //

            PSRV_TIMER Timer;

        } Lock;

        //
        // Transaction is used when processing the Transaction[2] SMBs.
        // Or when processing a write and X SMB.
        //

        PTRANSACTION Transaction;

        //
        // MdlIo is used when processing the ReadRaw or WriteRaw
        // SMBs when "MDL read" or "MDL write" is used.  It
        // retains the status of the response send while the MDL is
        // returned to the file system.
        //

        struct {
            IO_STATUS_BLOCK IoStatus;
            ULONG IrpFlags;
        } MdlIo;

        //
        // LastWriteTime is used when processing any Read or Write SMB
        // that uses RestartChainedClose as a restart routine.  This
        // field contains the new last write time to set for the file.
        //

        ULONG LastWriteTime;

        //
        // CurrentTableIndex is used when processing the Flush SMB.  It
        // retains the current index into the connection's file table
        // when an asynchronous flush is in progress.
        //

        LONG CurrentTableIndex;

        //
        // ReadRaw is used when processing the Read Block Raw SMB.
        // Offset is the file offset of the read.  SavedResponseBuffer
        // points to the original SMB response buffer descriptor, which
        // is temporarily replaced by a descriptor for the raw read
        // buffer.  MdlRead indicates whether an MDL read was used,
        // rather than a Copy read.
        //

        struct {

            union {

                //
                // Used for non named pipe reads
                //

                LARGE_INTEGER Offset;
                ULONG Length;

                //
                // Used only for named pipe reads
                //

                PFILE_PIPE_PEEK_BUFFER PipePeekBuffer;

            } ReadRawOtherInfo;

            PBUFFER SavedResponseBuffer;

            BOOLEAN MdlRead;

        } ReadRaw;

        //
        // WriteRaw is used when processing the Write Block Raw SMB.
        // FinalResponseBuffer points to the buffer allocated to contain
        // the final response SMB, if writethrough mode was specified.
        // Offset is the file offset of the write.  ImmediateLength is
        // the amount of write data that was sent with the request SMB.
        // Pid is the PID of the writer, used to form the lock key on
        // the write.  FileObject is a pointer to the file object copied
        // from the LFCB.  (Pid is not used when MDL write is used;
        // FileObject is not used when copy write is used.)
        //

        struct {
            struct _WORK_CONTEXT *RawWorkContext;
        } WriteRawPhase1;

        struct {
            LARGE_INTEGER Offset;
            ULONG Length;
            PVOID FinalResponseBuffer;
            CLONG ImmediateLength;
            PMDL FirstMdl;
            //PFILE_OBJECT FileObject;
            USHORT Pid;
            BOOLEAN MdlWrite;
            BOOLEAN ImmediateWriteDone;
        } WriteRaw;

        //
        // ReadAndX is the structure used when handling the ReadAndX
        // SMB.
        //

        struct {
            LARGE_INTEGER ReadOffset;
            ULONG ReadLength;
            PCHAR ReadAddress;
            union {
                struct {
                    PFILE_PIPE_PEEK_BUFFER PipePeekBuffer;
                    ULONG LastWriteTimeInSeconds;   // used if Close is chained
                };
                struct {                        // used for ReadLength > negotiated size
                    PBYTE   Buffer;             // allocated paged pool, if copy read
                    PMDL    SavedMdl;
                    PMDL    CacheMdl;
                    USHORT  PadCount;
                    BOOLEAN MdlRead;
                };
            };
        } ReadAndX;

#define READX_BUFFER_OFFSET (sizeof(SMB_HEADER) + FIELD_OFFSET(RESP_READ_ANDX, Buffer) )

        //
        // WriteAndX is the structure used when handling the flavor of WriteAndX that
        //  exceeds the negotiated buffer size
        //
        struct {
            ULONG CurrentWriteLength;       // amount of data that was written this time
            LARGE_INTEGER Offset;           // file offset for this piece of the write
            ULONG RemainingWriteLength;     // amount of data remaining to be read from xport
            ULONG Key;                      // lock key for the operation
            PCHAR WriteAddress;             // address in buffer for the data
            ULONG BufferLength;             // Maximum buffer length in this WorkContext
            NTSTATUS FinalStatus;           // Final status of the operation
            PMDL MdlAddress;                // File MDL if MdlWrite == TRUE
            BOOLEAN InitialComplete;        // TRUE if we have written first part to the file
        } WriteAndX;

        //
        // ReadMpx is the structure used when handling the ReadMpx SMB, unless
        //  we have a SmartCard accelerating our reads.  In this case,
        //  SmartCardRead is used.
        //

        struct {
            ULONG Offset;
            USHORT FragmentSize;
            USHORT RemainingLength;
            ULONG ReadLength;
            BOOLEAN MdlRead;
            UCHAR Unused;
            USHORT CurrentMdlOffset; // logically part of MDL read struct below
            union {
                struct {
                    PVOID MpxBuffer;
                    PMDL MpxBufferMdl;
                    PCHAR NextFragmentAddress;
                } ;
                struct {
                    PMDL FirstMdl;
                    PMDL CurrentMdl;
                } ;
            } ;
        } ReadMpx;

        //
        // SmartCardRead is used to handle direct host read requests if we have
        //   a Smart Card accelerating the particular request.
        //
        struct {
            PDEVICE_OBJECT DeviceObject;
            PFAST_IO_MDL_READ_COMPLETE MdlReadComplete;
        } SmartCardRead;

        //
        // WriteMpx is the structure used when handling the WriteMpx SMB.
        //

        struct {
            ULONG Offset;
            USHORT WriteLength;
            USHORT Mid;
            BOOLEAN FirstPacketOfGlom;
            PVOID Buffer;
            ULONG ReceiveDatagramFlags;
            PVOID TransportContext;
            PMDL DataMdl;
        } WriteMpx;

        struct {
            LARGE_INTEGER   CacheOffset;
            ULONG           WriteLength;
            PMDL            CacheMdl;
        } WriteMpxMdlWriteComplete;


        //
        // FastTransactNamedPipe is used when handling a small named pipe
        // transaction.
        //

        struct {
            PSMB_USHORT OutSetup;
            PCHAR OutParam;
            PCHAR OutData;
        } FastTransactNamedPipe;

    } Parameters;

    // !!! check whether the compiler leaves a dword gap here!

    //
    // The following union holds state information about SMBs in progress
    // waiting for an oplock break.  It is kept separate from the Parameters
    // union, since information from both is needed to process some SMBs.
    //

    union {

        //
        // Open is the structure used when handling the Open,
        // OpenAndX, Open2, Create, or CreateTemporary SMB.
        //

        struct {
            PRFCB Rfcb;
            PFILE_FULL_EA_INFORMATION NtFullEa;
            ULONG EaErrorOffset;

            //
            // The Irp used to open the file is the same Irp used to handle
            //  the oplock processing.  This can cause us to lose the original
            //  iosb->Information.  Save it here.
            //
            ULONG_PTR IosbInformation;

            //
            // If TRUE, the file was opened only in order to get a handle
            // so that we can wait for an oplock to break.  This handle will
            // be immediately closed, and the open will be retried with the
            // user requested access.
            //

            BOOLEAN TemporaryOpen;
        } Open;

        //
        // FileInformation is the structure used when handling the
        // QueryInformation, SetInformation, QueryPathInformation,
        // or SetPathInformation SMB.
        //

        struct {
            HANDLE FileHandle;
        } FileInformation;

        //
        // LockLength is used to contain the length of a byte range
        // lock since the IRP stack location has no room to hold it.

        LARGE_INTEGER LockLength;

    } Parameters2;

    //
    // This field is used when the current operation is blocked waiting
    // for an oplock break to occur.
    //

    struct _WAIT_FOR_OPLOCK_BREAK *WaitForOplockBreak;


    union {
        //
        // where we keep the actual client address data.
        //
        IPX_CLIENT_ADDRESS ClientAddressData;


        //
        // For a VC-based client, this is the amount of available data if
        //  LargeIndication is set (above)
        //
        ULONG BytesAvailable;
    };

    struct {
        LARGE_INTEGER G_StartTime;
        ULONG         ElapseKCPU;
        ULONG         ElapseUCPU;
        ULONG         ClientAddr;
        PFILE_OBJECT  FileObject;
    };

    ULONG         KCPUStart;
    ULONG         UCPUStart;
    UCHAR         PreviousSMB;
    UCHAR         bAlreadyTrace;
    USHORT        FileNameSize;
    WCHAR         strFileName[1024];

#if DBG_STUCK
    //
    // Time at which this work context was allocated for this current
    //  unit of work.  This time is examined by debugging code in the
    //  scavenger to help find operations which are taking too long
    //  to complete.
    //
    LARGE_INTEGER OpStartTime;
#endif
} WORK_CONTEXT, *PWORK_CONTEXT;

//
// Structure used to maintain information about a thread waiting for
// an oplock break.
//

typedef struct _WAIT_FOR_OPLOCK_BREAK {
    BLOCK_HEADER BlockHeader;
    LIST_ENTRY ListEntry;
    LARGE_INTEGER TimeoutTime;
    PIRP Irp;
    WAIT_STATE WaitState;
} WAIT_FOR_OPLOCK_BREAK, *PWAIT_FOR_OPLOCK_BREAK;


//
// Block manager routines
//

//
// Buffer routines
//

VOID
SrvAllocateBuffer (
    OUT PBUFFER *Buffer,
    IN CLONG BufferLength
    );

VOID
SrvFreeBuffer (
    IN PBUFFER Buffer
    );

//
// Connection routines
//

VOID
SrvAllocateConnection (
    OUT PCONNECTION *Connection
    );

VOID
SrvCloseConnection (
    IN PCONNECTION Connection,
    IN BOOLEAN RemoteDisconnect
    );

VOID
SrvCloseConnectionsFromClient(
    IN PCONNECTION Connection,
    IN BOOLEAN OnlyIfNoSessions
    );

VOID
SrvCloseFreeConnection (
    IN PCONNECTION Connection
    );

VOID
SrvDereferenceConnection (
    IN PCONNECTION Connection
    );

VOID
SrvFreeConnection (
    IN PCONNECTION Connection
    );

#if DBG
NTSTATUS
SrvQueryConnections (
    OUT PVOID Buffer,
    IN ULONG BufferLength,
    OUT PULONG BytesWritten
    );
#endif

//
// Endpoint routines
//

VOID
SrvAllocateEndpoint (
    OUT PENDPOINT *Endpoint,
    IN PUNICODE_STRING NetworkName,
    IN PUNICODE_STRING TransportName,
    IN PANSI_STRING TransportAddress,
    IN PUNICODE_STRING DomainName
    );

BOOLEAN SRVFASTCALL
SrvCheckAndReferenceEndpoint (
    IN PENDPOINT Endpoint
    );

VOID
SrvCloseEndpoint (
    IN PENDPOINT Endpoint
    );

VOID SRVFASTCALL
SrvDereferenceEndpoint (
    IN PENDPOINT Endpoint
    );

VOID
SrvFreeEndpoint (
    IN PENDPOINT Endpoint
    );

VOID
SrvReferenceEndpoint (
    IN PENDPOINT Endpoint
    );

BOOLEAN
SrvFindNamedEndpoint (
    IN PUNICODE_STRING ServerName,
    IN PBOOLEAN RemapPipeNames OPTIONAL
    );

VOID
EmptyFreeConnectionList (
    IN PENDPOINT Endpoint
    );

PCONNECTION
WalkConnectionTable (
    IN PENDPOINT Endpoint,
    IN PUSHORT Index
    );

//
// Local File Control Block routines
//

VOID
SrvAllocateLfcb (
    OUT PLFCB *Lfcb,
    IN PWORK_CONTEXT WorkContext
    );

VOID
SrvCloseLfcb (
    IN PLFCB Lfcb
    );

VOID
SrvDereferenceLfcb (
    IN PLFCB Lfcb
    );

VOID
SrvFreeLfcb (
    IN PLFCB Lfcb,
    IN PWORK_QUEUE queue
    );

VOID
SrvReferenceLfcb (
    IN PLFCB Lfcb
    );

//
// Master File Control Block routines
//


PMFCB
SrvCreateMfcb(
    IN PUNICODE_STRING FileName,
    IN PWORK_CONTEXT WorkContext,
    IN ULONG HashValue
    );

PMFCB
SrvFindMfcb(
    IN PUNICODE_STRING FileName,
    IN BOOLEAN CaseInsensitive,
    OUT PSRV_LOCK *Lock,
    OUT PULONG HashValue,
    IN PWORK_CONTEXT WorkContext
    );

VOID
SrvDereferenceMfcb (
    IN PMFCB Mfcb
    );

VOID
SrvFreeMfcb (
    IN PMFCB Mfcb
    );

VOID
SrvUnlinkLfcbFromMfcb (
    IN PLFCB Lfcb
    );

//
// Remote File Control Block routines
//

VOID SRVFASTCALL
SrvAllocateRfcb (
    OUT PRFCB *Rfcb,
    IN PWORK_CONTEXT WorkContext
    );

BOOLEAN SRVFASTCALL
SrvCheckAndReferenceRfcb (
    IN PRFCB Rfcb
    );

VOID SRVFASTCALL
SrvCloseRfcb (
    IN PRFCB Rfcb
    );

VOID
SrvCloseRfcbsOnLfcb (
    PLFCB Lfcb
    );

VOID
SrvCloseRfcbsOnSessionOrPid (
    IN PSESSION Session,
    IN PUSHORT Pid OPTIONAL
    );

VOID
SrvCloseRfcbsOnTree (
    PTREE_CONNECT TreeConnect
    );

VOID
SrvCompleteRfcbClose (
    IN PRFCB Rfcb
    );

VOID SRVFASTCALL
SrvDereferenceRfcb (
    IN PRFCB Rfcb
    );

VOID SRVFASTCALL
SrvFreeRfcb (
    IN PRFCB Rfcb,
    IN PWORK_QUEUE queue
    );

VOID SRVFASTCALL
SrvReferenceRfcb (
    IN PRFCB Rfcb
    );

BOOLEAN
SrvFindCachedRfcb (
    IN PWORK_CONTEXT WorkContext,
    IN PMFCB Mfcb,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN OPLOCK_TYPE RequestedOplockType,
    OUT PNTSTATUS Status
    );

VOID
SrvCloseCachedRfcb (
    IN PRFCB Rfcb,
    IN KIRQL OldIrql
    );

VOID
SrvCloseCachedRfcbsOnConnection (
    IN PCONNECTION Connection
    );

VOID
SrvCloseCachedRfcbsOnLfcb (
    IN PLFCB Lfcb
    );

ULONG
SrvCountCachedRfcbsForTid(
    PCONNECTION connection,
    USHORT Tid
);

ULONG
SrvCountCachedRfcbsForUid(
    PCONNECTION connection,
    USHORT Uid
);


//
// Search Block routines
//

typedef
BOOLEAN
(*PSEARCH_FILTER_ROUTINE) (
    IN PSEARCH Search,
    IN PVOID FunctionParameter1,
    IN PVOID FunctionParameter2
    );

VOID
SrvAllocateSearch (
    OUT PSEARCH *Search,
    IN PUNICODE_STRING SearchName,
    IN BOOLEAN IsCoreSearch
    );

VOID
SrvCloseSearch (
    IN PSEARCH Search
    );

VOID
SrvCloseSearches (
    IN PCONNECTION Connection,
    IN PSEARCH_FILTER_ROUTINE SearchFilterRoutine,
    IN PVOID FunctionParameter1,
    IN PVOID FunctionParameter2
    );

VOID
SrvDereferenceSearch (
    IN PSEARCH Search
    );

VOID
SrvFreeSearch (
    IN PSEARCH Search
    );

VOID
SrvReferenceSearch (
    IN PSEARCH Search
    );

BOOLEAN
SrvSearchOnDelete(
    IN PSEARCH Search,
    IN PUNICODE_STRING DirectoryName,
    IN PTREE_CONNECT TreeConnect
    );

BOOLEAN
SrvSearchOnPid(
    IN PSEARCH Search,
    IN USHORT Pid,
    IN PVOID Dummy
    );

BOOLEAN
SrvSearchOnSession(
    IN PSEARCH Search,
    IN PSESSION Session,
    IN PVOID Dummy
    );

BOOLEAN
SrvSearchOnTreeConnect(
    IN PSEARCH Search,
    IN PTREE_CONNECT TreeConnect,
    IN PVOID Dummy
    );

VOID
SrvForceTimeoutSearches(
    IN PCONNECTION Connection
    );

ULONG
SrvTimeoutSearches(
    IN PLARGE_INTEGER SearchCutoffTime OPTIONAL,
    IN PCONNECTION Connection,
    IN BOOLEAN OnlyTimeoutOneBlock
    );

VOID
RemoveDuplicateCoreSearches(
    IN PPAGED_CONNECTION PagedConnection
    );

VOID
SrvAddToSearchHashTable(
    IN PPAGED_CONNECTION PagedConnection,
    IN PSEARCH Search
    );

//
// Cached directory routines
//
BOOLEAN
SrvIsDirectoryCached (
    IN PWORK_CONTEXT    WorkContext,
    IN PUNICODE_STRING  DirectoryName
    );

VOID
SrvCacheDirectoryName (
    IN PWORK_CONTEXT    WorkContext,
    IN PUNICODE_STRING  DirectoryName
    );

VOID
SrvRemoveCachedDirectoryName (
    IN PWORK_CONTEXT    WorkContext,
    IN PUNICODE_STRING  DirectoryName
    );

VOID
SrvCloseCachedDirectoryEntries (
    IN PCONNECTION      Connection
    );

//
// Security Context routines
//

PSECURITY_CONTEXT
SrvAllocateSecurityContext();

VOID
SrvSetSecurityContext(
    PSECURITY_CONTEXT Context,
    PCtxtHandle handle
    );

VOID
SrvReferenceSecurityContext(
    PSECURITY_CONTEXT Context
    );

VOID
SrvDereferenceSecurityContext(
    PSECURITY_CONTEXT Context
    );

VOID
SrvReplaceSessionSecurityContext(
    PSESSION Session,
    PSECURITY_CONTEXT Context,
    PWORK_CONTEXT WorkContext
    );


//
// Session routines
//

VOID
SrvAllocateSession (
    OUT PSESSION *Session,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING Domain
    );

BOOLEAN SRVFASTCALL
SrvCheckAndReferenceSession (
    IN PSESSION Session
    );

VOID
SrvCloseSession (
    IN PSESSION Session
    );

VOID
SrvCloseSessionsOnConnection (
    IN PCONNECTION Connection,
    IN PUNICODE_STRING UserName OPTIONAL
    );

VOID SRVFASTCALL
SrvDereferenceSession (
    IN PSESSION Session
    );

VOID
SrvFreeSession (
    IN PSESSION Session
    );

//
// Smb Security Signature Routines
//
BOOLEAN SRVFASTCALL
SrvCheckSmbSecuritySignature(
    IN PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
SrvAddSmbSecuritySignature(
    IN OUT PWORK_CONTEXT WorkContext,
    IN PMDL Mdl,
    IN ULONG SendLength
    );

VOID SRVFASTCALL
SrvInitializeSmbSecuritySignature(
    IN OUT PCONNECTION Connection,
    IN PUCHAR SessionKey,
    IN PUCHAR ChallengeResponse,
    IN ULONG ChallengeResponseLength
    );

VOID
SrvHashUserSessionKey(
    PCHAR SessionKey
    );

//
// Share routines
//

VOID
SrvAllocateShare (
    OUT PSHARE *Share,
    IN PUNICODE_STRING ShareName,
    IN PUNICODE_STRING NtPathName,
    IN PUNICODE_STRING DosPathName,
    IN PUNICODE_STRING Remark,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSECURITY_DESCRIPTOR FileSecurityDescriptor OPTIONAL,
    IN SHARE_TYPE ShareType
    );

VOID
SrvCloseShare (
    IN PSHARE Share
    );

VOID
SrvDereferenceShare (
    IN PSHARE Share
    );

VOID
SrvDereferenceShareForTreeConnect (
    PSHARE Share
    );

VOID
SrvFreeShare (
    IN PSHARE Share
    );

VOID
SrvReferenceShare (
    IN PSHARE Share
    );

NTSTATUS
SrvReferenceShareForTreeConnect (
    PSHARE Share
    );

//
// Table routines
//

VOID
SrvAllocateTable (
    IN PTABLE_HEADER TableHeader,
    IN ULONG NumberOfEntries,
    IN BOOLEAN Nonpaged
    );

#define SrvFreeTable( _table ) {                                    \
        if ( (_table)->Nonpaged ) {                                 \
            DEALLOCATE_NONPAGED_POOL( (_table)->Table );            \
        } else {                                                    \
            FREE_HEAP( (_table)->Table );                           \
        }                                                           \
        DEBUG (_table)->Table = NULL;                               \
        DEBUG (_table)->TableSize = -1;                             \
        DEBUG (_table)->FirstFreeEntry = -1;                        \
        DEBUG (_table)->LastFreeEntry = -1;                         \
    }

BOOLEAN
SrvGrowTable (
    IN PTABLE_HEADER TableHeader,
    IN ULONG NumberOfNewEntries,
    IN ULONG MaxNumberOfEntries,
    OUT NTSTATUS* pStatus
    );

VOID
SrvRemoveEntryTable (
    IN PTABLE_HEADER TableHeader,
    IN USHORT Index
    );

//
// Transaction routines
//

VOID
SrvAllocateTransaction (
    OUT PTRANSACTION *Transaction,
    OUT PVOID *TrailingBytes,
    IN PCONNECTION Connection,
    IN CLONG TrailingByteCount,
    IN PVOID TransactionName,
    IN PVOID EndOfSourceBuffer OPTIONAL,
    IN BOOLEAN SourceIsUnicode,
    IN BOOLEAN RemoteApiRequest
    );

VOID
SrvCloseTransaction (
    IN PTRANSACTION Transaction
    );

VOID
SrvCloseTransactionsOnSession (
    PSESSION Session
    );

VOID
SrvCloseTransactionsOnTree (
    PTREE_CONNECT TreeConnect
    );

VOID
SrvDereferenceTransaction (
    IN PTRANSACTION Transaction
    );

VOID
SrvFreeTransaction (
    IN PTRANSACTION Transaction
    );

PTRANSACTION
SrvFindTransaction (
    IN PCONNECTION Connection,
    IN PSMB_HEADER Header,
    IN USHORT Fid OPTIONAL
    );

BOOLEAN
SrvInsertTransaction (
    IN PTRANSACTION Transaction
    );

//
// Tree connect routines
//

VOID
SrvAllocateTreeConnect (
    OUT PTREE_CONNECT *TreeConnect,
    IN PUNICODE_STRING ServerName OPTIONAL
    );

BOOLEAN SRVFASTCALL
SrvCheckAndReferenceTreeConnect (
    IN PTREE_CONNECT TreeConnect
    );

VOID
SrvCloseTreeConnect (
    IN PTREE_CONNECT TreeConnect
    );

VOID SRVFASTCALL
SrvDereferenceTreeConnect (
    IN PTREE_CONNECT TreeConnect
    );

VOID
SrvFreeTreeConnect (
    IN PTREE_CONNECT TreeConnect
    );

VOID
SrvDisconnectTreeConnectsFromSession (
    PCONNECTION connection,
    PSESSION Session
    );

VOID
SrvCloseTreeConnectsOnShare (
    IN PSHARE Share
    );

//
// Work item routines (includes work contexts, buffers, MDLs, IRPs, etc)
//

NTSTATUS
SrvAllocateInitialWorkItems (
    VOID
    );

NTSTATUS
SrvAllocateNormalWorkItem (
    OUT PWORK_CONTEXT *WorkContext,
    IN  PWORK_QUEUE queue
    );

VOID
SrvAllocateRawModeWorkItem (
    OUT PWORK_CONTEXT *WorkContext,
    IN PWORK_QUEUE queue
);

PWORK_CONTEXT
SrvGetRawModeWorkItem (
    VOID
    );

VOID
SrvRequeueRawModeWorkItem (
    IN PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
SrvDereferenceWorkItem (
    IN PWORK_CONTEXT WorkContext
    );

VOID
SrvFsdDereferenceWorkItem (
    IN PWORK_CONTEXT WorkContext
    );

NTSTATUS
SrvAllocateExtraSmbBuffer (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID
SrvAllocateWaitForOplockBreak (
    OUT PWAIT_FOR_OPLOCK_BREAK *WaitForOplockBreak
    );

VOID
SrvDereferenceWaitForOplockBreak (
    IN PWAIT_FOR_OPLOCK_BREAK WaitForOplockBreak
    );

VOID
SrvFreeWaitForOplockBreak (
    IN PWAIT_FOR_OPLOCK_BREAK WaitForOplockBreak
    );

VOID
SrvOplockWaitTimeout(
    IN PWAIT_FOR_OPLOCK_BREAK WaitForOplockBreak
    );

NTSTATUS
SrvCheckOplockWaitState(
    IN PWAIT_FOR_OPLOCK_BREAK WaitForOplockBreak
    );

NTSTATUS
SrvWaitForOplockBreak (
    IN PWORK_CONTEXT WorkContext,
    IN HANDLE FileHandle
    );

NTSTATUS
SrvStartWaitForOplockBreak (
    IN PWORK_CONTEXT WorkContext,
    IN PRESTART_ROUTINE RestartRoutine,
    IN HANDLE Handle OPTIONAL,
    IN PFILE_OBJECT FileObject OPTIONAL
    );

VOID
SrvSendDelayedOplockBreak (
    IN PCONNECTION Connection
    );

VOID
SrvFreeInitialWorkItems (
    VOID
    );

VOID
SrvFreeNormalWorkItem (
    IN PWORK_CONTEXT WorkContext
    );

VOID
SrvFreeRawModeWorkItem (
    IN PWORK_CONTEXT WorkContext
    );

//
// Timer routines
//

PSRV_TIMER
SrvAllocateTimer (
    VOID
    );

VOID
SrvCancelTimer (
    IN PSRV_TIMER Timer
    );

#define SrvDeleteTimer(_timer) DEALLOCATE_NONPAGED_POOL(_timer)

#define SrvFreeTimer(_timer) \
        ExInterlockedPushEntrySList(&SrvTimerList, &(_timer)->Next, &GLOBAL_SPIN_LOCK(Timer))

VOID
SrvSetTimer (
    IN PSRV_TIMER Timer,
    IN PLARGE_INTEGER Timeout,
    IN PKDEFERRED_ROUTINE TimeoutHandler,
    IN PVOID Context
    );

#if SRVDBG2

VOID
SrvInitializeReferenceHistory (
    IN PBLOCK_HEADER Block,
    IN LONG InitialReferenceCount
    );

VOID
SrvUpdateReferenceHistory (
    IN PBLOCK_HEADER Block,
    IN PVOID Caller,
    IN PVOID CallersCaller,
    IN BOOLEAN IsDereference
    );

VOID
SrvTerminateReferenceHistory (
    IN PBLOCK_HEADER Block
    );


#define INITIALIZE_REFERENCE_HISTORY(block)                        \
            SrvInitializeReferenceHistory(                         \
                &(block)->BlockHeader,                             \
                ((PBLOCK_HEADER)(block))->ReferenceCount           \
                )

#define UPDATE_REFERENCE_HISTORY(block,isdereference)              \
        {                                                          \
            PVOID caller, callerscaller;                           \
            RtlGetCallersAddress( &caller, &callerscaller );       \
            SrvUpdateReferenceHistory(                             \
                &(block)->BlockHeader,                             \
                caller,                                            \
                callerscaller,                                     \
                isdereference                                      \
                );                                                 \
        }

#define TERMINATE_REFERENCE_HISTORY(block) \
            SrvTerminateReferenceHistory( &(block)->BlockHeader )

#else

#define INITIALIZE_REFERENCE_HISTORY(block)
#define UPDATE_REFERENCE_HISTORY(block,isdereference)
#define TERMINATE_REFERENCE_HISTORY(block)

#endif // if SRVDBG2

#endif // ndef _SRVBLOCK
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\srvconfg.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    srvconfg.c

Abstract:

    This module defines global configuration data for the LAN Manager
    server.  The variables referenced herein, because they are part of
    the driver image, are not pageable.

    All variables defined here are initialized, but not with real values.
    The initializers are present to get the variables into the Data
    section and out of the BSS section.  The real initialization occurs
    when the server is started.

Author:

    Chuck Lenzmeier (chuckl) 31-Dec-1989

Revision History:

--*/

#include "precomp.h"
#include "srvconfg.tmh"
#pragma hdrstop


//
// Product type and server size.
//

BOOLEAN SrvProductTypeServer = FALSE;
ULONG SrvServerSize = 2;

//
// Server "heuristics", enabling various capabilities.
//

BOOLEAN SrvEnableOplocks = 0;
BOOLEAN SrvEnableFcbOpens = 0;
BOOLEAN SrvEnableSoftCompatibility = 0;
BOOLEAN SrvEnableRawMode = 0;

//
// Receive buffer size, receive work item count, and receive IRP stack
// size.
//

CLONG SrvReceiveBufferLength = 0;
CLONG SrvReceiveBufferSize = 0;

CLONG SrvInitialReceiveWorkItemCount = 0;
CLONG SrvMaxReceiveWorkItemCount = 0;

CLONG SrvInitialRawModeWorkItemCount = 0;
CLONG SrvMaxRawModeWorkItemCount = 0;

CCHAR SrvReceiveIrpStackSize = 0;
CLONG SrvReceiveIrpSize = 0;
CLONG SrvReceiveMdlSize = 0;
CLONG SrvMaxMdlSize = 0;

//
// Minimum negotiated buffer size we'll allow from a client
//
CLONG SrvMinClientBufferSize;

//
// Minimum and maximum number of free connections for an endpoint.
//

ULONG SrvFreeConnectionMinimum = 0;
ULONG SrvFreeConnectionMaximum = 0;

//
// Maximum raw mode buffer size.
//

CLONG SrvMaxRawModeBufferLength = 0;

//
// Cache-related parameters.
//

CLONG SrvMaxCopyReadLength = 0;

CLONG SrvMaxCopyWriteLength = 0;

//
// Initial table sizes.
//

USHORT SrvInitialSessionTableSize = 0;
USHORT SrvMaxSessionTableSize = 0;

USHORT SrvInitialTreeTableSize = 0;
USHORT SrvMaxTreeTableSize = 0;

USHORT SrvInitialFileTableSize = 0;
USHORT SrvMaxFileTableSize = 0;

USHORT SrvInitialSearchTableSize = 0;
USHORT SrvMaxSearchTableSize = 0;

USHORT SrvInitialCommDeviceTableSize = 0;
USHORT SrvMaxCommDeviceTableSize = 0;


//
// Core search timeouts.  There are four timeout values: two for core
// searches that have completed, two for core searches that have had
// STATUS_NO_MORE_FILES returned to the client.  For each of these cases,
// there is a maximum timeout, which is used by the scavanger thread
// and is the longest possible time the search block can be around, and
// a minimum timeout, which is the minimum amount of time the search
// block will be kept around.  The minimum timeout is used when the search
// table is full and cannot be expanded.
//

LARGE_INTEGER SrvSearchMaxTimeout = {0};

//
// Should we remove duplicate searches?
//

BOOLEAN SrvRemoveDuplicateSearches = TRUE;

//
// restrict null session access ?
//

BOOLEAN SrvRestrictNullSessionAccess = TRUE;

//
// This flag is needed to enable old (snowball) clients to connect to the
// server over direct hosted ipx.  It is enabled by default even though
// Snowball ipx clients don't do pipes correctly, because disabling it
// breaks browsing.
//
// *** We actually don't expect anybody to use this parameter now that
//     it defaults to enabled, but due to the nearness of the Daytona
//     release, we are just changing the default instead of removing
//     the parameter.
//

BOOLEAN SrvEnableWfW311DirectIpx = TRUE;

//
// The maximum number of threads allowed on each work queue.  The
//  server tries to minimize the number of threads -- this value is
//  just to keep the threads from getting out of control.
//
// Since the blocking work queue is not per-processor, the max thread
//  count for the blocking work queue is the following value times the
//  number of processors in the system.
//
ULONG SrvMaxThreadsPerQueue = 0;

//
// Load balancing variables
//
ULONG SrvPreferredAffinity = 0;
ULONG SrvOtherQueueAffinity = 0;
ULONG SrvBalanceCount = 0;
LARGE_INTEGER SrvQueueCalc = {0};

//
// Scavenger thread idle wait time.
//

LARGE_INTEGER SrvScavengerTimeout = {0};
ULONG SrvScavengerTimeoutInSeconds = 0;

//
// Various information variables for the server.
//

USHORT SrvMaxMpxCount = 0;
CLONG SrvMaxNumberVcs = 0;

//
// Enforced minimum number of receive work items for the free queue
// at all times.
//

CLONG SrvMinReceiveQueueLength = 0;

//
// Enforced minimum number of receive work items on the free queue
// before the server may initiate a blocking operation.
//

CLONG SrvMinFreeWorkItemsBlockingIo = 0;

//
// Enforced maximum number of RFCBs held on the internal free lists, per processor
//

CLONG SrvMaxFreeRfcbs = 0;

//
// Enforced maximum number of RFCBs held on the internal free lists, per processor
//

CLONG SrvMaxFreeMfcbs = 0;

//
// Enforced maximum size of a saved pool chunk per processor
//
CLONG SrvMaxPagedPoolChunkSize = 0;

//
// Enforced maximum size of a saved non paged pool chunk per processor
//
CLONG SrvMaxNonPagedPoolChunkSize = 0;

//
// The number of elements in the directory name cache per connection
//
CLONG SrvMaxCachedDirectory;

//
// Size of the shared memory section used for communication between the
// server and XACTSRV.
//

LARGE_INTEGER SrvXsSectionSize = {0};

//
// The time sessions may be idle before they are automatically
// disconnected.  The scavenger thread does the disconnecting.
//

LARGE_INTEGER SrvAutodisconnectTimeout = {0};
ULONG SrvIpxAutodisconnectTimeout = {0};

//
// The time a connection structure can hang around without any sessions
//
ULONG SrvConnectionNoSessionsTimeout = {0};

//
// The maximum number of users the server will permit.
//

ULONG SrvMaxUsers = 0;

//
// Priority of server worker and blocking threads.
//

KPRIORITY SrvThreadPriority = 0;

//
// The time to wait before timing out a wait for oplock break.
//

LARGE_INTEGER SrvWaitForOplockBreakTime = {0};

//
// The time to wait before timing out a an oplock break request.
//

LARGE_INTEGER SrvWaitForOplockBreakRequestTime = {0};

//
// This BOOLEAN determines whether files with oplocks that have had
// an oplock break outstanding for longer than SrvWaitForOplockBreakTime
// should be closed or if the subsequest opens should fail.
//
// !!! it is currently ignored, defaulting to FALSE.

BOOLEAN SrvEnableOplockForceClose = 0;

//
// Overall limits on server memory usage.
//

ULONG SrvMaxPagedPoolUsage = 0;
ULONG SrvMaxNonPagedPoolUsage = 0;

//
// This BOOLEAN indicates whether the forced logoff code in the scavenger
// thread should actually disconnect a user that remains on beyond
// his logon hours, or just send messages coaxing them to log off.
//

BOOLEAN SrvEnableForcedLogoff = 0;

//
// The delay and throughput thresholds used to determine if a link
// is unreliable.  The delay is in 100ns.  The Throughput is in bytes/s
// SrvLinkInfoValidTime is the time within which the link info is still
// considered valid.
//

LARGE_INTEGER SrvMaxLinkDelay = {0};
LARGE_INTEGER SrvMinLinkThroughput = {0};
LARGE_INTEGER SrvLinkInfoValidTime = {0};
LONG SrvScavengerUpdateQosCount = 0;

//
// Used to determine how long a work context block can stay idle
// before being freed.
//

ULONG SrvWorkItemMaxIdleTime = 0;

LARGE_INTEGER SrvAlertSchedule = {0}; // Interval at which we do alert checks
ULONG SrvAlertMinutes = 0;            // As above, in minutes
ULONG SrvFreeDiskSpaceThreshold = 0;  // The disk free space threshold to raise an alert
ULONG SrvFreeDiskSpaceCeiling   = 250;// The minimum disk free space to log an event
ULONG SrvDiskConfiguration = 0;       // A bit mask of available disks

//
// List of pipes and shares that can be opened by the NULL session.
//

PWSTR *SrvNullSessionPipes = NULL;
PWSTR *SrvNullSessionShares = NULL;

#if SRVNTVERCHK
//
// List of domain names that we disallow
//
PWSTR *SrvInvalidDomainNames = NULL;
#endif

//
// List of pipes that shouldn't be remapped, even in the clusters case
//
PWSTR *SrvNoRemapPipeNames = NULL;

//
// List of error codes that we do not log to the error log
//
NTSTATUS SrvErrorLogIgnore[ SRVMAXERRLOGIGNORE+1 ];

//
// List of pipes that require a license
//
PWSTR *SrvPipesNeedLicense = NULL;

//
// Delay and number of retries for opens returning sharing violation
//

ULONG SrvSharingViolationRetryCount = 0;
LARGE_INTEGER SrvSharingViolationDelay = {0};

//
// Delay for lock requests returning lock violation
//

ULONG SrvLockViolationDelay = 0;
LARGE_INTEGER SrvLockViolationDelayRelative = {0};
ULONG SrvLockViolationOffset = 0;

//
// Upper limit for searches.
//

ULONG SrvMaxOpenSearches = 0;

//
// length to switchover to mdl read
//

ULONG SrvMdlReadSwitchover = 0;
ULONG SrvMpxMdlReadSwitchover = 0;

//
// maximum length of buffers to copy before taking the whole receive buffer.
// currently this is enabled only for WRITE_MPX on direct host IPX.
//

ULONG SrvMaxCopyLength;

//
// Number of open files that can be cached after close.
//

ULONG SrvCachedOpenLimit = 0;

//
// Globally unique id identifying server
//

GUID ServerGuid;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\srvconfg.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    srvconfg.h

Abstract:

    This module defines global configuration data for the LAN Manager
    server.

Author:

    Chuck Lenzmeier (chuckl) 31-Dec-1989

Revision History:

--*/

#ifndef _SRVCONFG_
#define _SRVCONFG_

//#include <ntos.h>

//#include "srvconst.h"

//
// All global variables referenced in this module are defined in
// srvconfg.c.  See that module for complete descriptions.
//
// The variables referenced herein, because they are part of the driver
// image, are not pageable.
//


//
// Product type and server size.
//

extern BOOLEAN SrvProductTypeServer; // FALSE for Workstation, TRUE for Server
extern ULONG SrvServerSize;

//
// Server "heuristics", enabling various capabilities.
//

extern BOOLEAN SrvEnableOplocks;
extern BOOLEAN SrvEnableFcbOpens;
extern BOOLEAN SrvEnableSoftCompatibility;
extern BOOLEAN SrvEnableRawMode;

//
// Receive buffer size, receive work item count, and receive IRP stack
// size.
//

extern CLONG SrvReceiveBufferLength;
extern CLONG SrvReceiveBufferSize;

extern CLONG SrvInitialReceiveWorkItemCount;
extern CLONG SrvMaxReceiveWorkItemCount;

extern CLONG SrvInitialRawModeWorkItemCount;
extern CLONG SrvMaxRawModeWorkItemCount;

extern CCHAR SrvReceiveIrpStackSize;
extern CLONG SrvReceiveIrpSize;
extern CLONG SrvReceiveMdlSize;
extern CLONG SrvMaxMdlSize;

//
// Minimum negotiated buffer size we'll allow from a client
//
extern CLONG SrvMinClientBufferSize;

//
// Minimum and maximum number of free connections for an endpoint.  When
// the minimum is reached, the resource thread creates more.  When the
// maximum is reached, connections are closed as they are disconnected.
//

extern ULONG SrvFreeConnectionMinimum;
extern ULONG SrvFreeConnectionMaximum;

//
// Initial and maximum table sizes.
//

extern USHORT SrvInitialSessionTableSize;
extern USHORT SrvMaxSessionTableSize;

extern USHORT SrvInitialTreeTableSize;
extern USHORT SrvMaxTreeTableSize;

extern USHORT SrvInitialFileTableSize;
extern USHORT SrvMaxFileTableSize;

extern USHORT SrvInitialSearchTableSize;
extern USHORT SrvMaxSearchTableSize;

//
// Core search timeouts.  The first is for active core searches, the second
// is for core searches where we have returned STATUS_NO_MORE_FILES.  The
// second should be shorter, as these are presumably complete.
//

extern LARGE_INTEGER SrvSearchMaxTimeout;

//
// Should we remove duplicate searches?
//

extern BOOLEAN SrvRemoveDuplicateSearches;

//
// restrict null session access ?
//

extern BOOLEAN SrvRestrictNullSessionAccess;

//
// This flag is needed to enable old (snowball) clients to connect to the
// server over direct hosted ipx.  It is disabled by default because
// snowball  ipx clients don't do pipes correctly.
//

extern BOOLEAN SrvEnableWfW311DirectIpx;

//
// The maximum number of threads allowed on each work queue.  The
//  server tries to minimize the number of threads -- this value is
//  just to keep the threads from getting out of control.
//
// Since the blocking work queue is not per-processor, the max thread
//  count for the blocking work queue is the following value times the
//  number of processors in the system.
//
extern ULONG SrvMaxThreadsPerQueue;

//
// Load balancing variables
//
extern ULONG SrvPreferredAffinity;
extern ULONG SrvOtherQueueAffinity;
extern ULONG SrvBalanceCount;
extern LARGE_INTEGER SrvQueueCalc;

//
// Scavenger thread idle wait time.
//

extern LARGE_INTEGER SrvScavengerTimeout;
extern ULONG SrvScavengerTimeoutInSeconds;

//
// Various information variables for the server.
//

extern USHORT SrvMaxMpxCount;

//
// This is supposed to indicate how many virtual connections are allowed
// between this server and client machines.  It should always be set to
// one, though more VCs can be established.  This duplicates the LM 2.0
// server's behavior.
//

extern CLONG SrvMaxNumberVcs;

//
// Receive work item thresholds
//

//
// The minimum desirable number of free receive work items.
//

extern CLONG SrvMinReceiveQueueLength;

//
// The number of freed RFCBs that we keep internally, per processor
//
extern CLONG SrvMaxFreeRfcbs;

//
// The number of freed MFCBs that we keep internally, per processor
//
extern CLONG SrvMaxFreeMfcbs;

//
// Enforced maximum size of a saved pool chunk per processor
//
extern CLONG SrvMaxPagedPoolChunkSize;

//
// Enforced maximum size of a saved non paged pool chunk per processor
//
extern CLONG SrvMaxNonPagedPoolChunkSize;

//
// The minimum number of free receive work items available before
// the server will start processing a potentially blocking SMB.
//

extern CLONG SrvMinFreeWorkItemsBlockingIo;

//
// The number of cached directory names per connection
//
extern CLONG SrvMaxCachedDirectory;

//
// Size of the shared memory section used for communication between the
// server and XACTSRV.
//

extern LARGE_INTEGER SrvXsSectionSize;

//
// The time sessions may be idle before they are automatically
// disconnected.  The scavenger thread does the disconnecting.
//

extern LARGE_INTEGER SrvAutodisconnectTimeout;
extern ULONG SrvIpxAutodisconnectTimeout;

//
// The time a connection structure can hang around without any sessions
//
extern ULONG SrvConnectionNoSessionsTimeout;

//
// The maximum number of users the server will permit.
//

extern ULONG SrvMaxUsers;

//
// Priority of server worker and blocking threads.
//

extern KPRIORITY SrvThreadPriority;

//
// The time to wait before timing out a wait for oplock break.
//

extern LARGE_INTEGER SrvWaitForOplockBreakTime;

//
// The time to wait before timing out a an oplock break request.
//

extern LARGE_INTEGER SrvWaitForOplockBreakRequestTime;

//
// This BOOLEAN determines whether files with oplocks that have had
// an oplock break outstanding for longer than SrvWaitForOplockBreakTime
// should be closed or if the subsequest opens should fail.
//

extern BOOLEAN SrvEnableOplockForceClose;

//
// Overall limits on server memory usage.
//

extern ULONG SrvMaxPagedPoolUsage;
extern ULONG SrvMaxNonPagedPoolUsage;

//
// This BOOLEAN indicates whether the forced logoff code in the scavenger
// thread should actually disconnect a user that remains on beyond
// his logon hours, or just send messages coaxing them to log off.
//

extern BOOLEAN SrvEnableForcedLogoff;

//
// The delay and throughput thresholds used to determine if a link
// is unreliable.  The delay is in 100ns.  The Throughput is in bytes/s
// SrvLinkInfoValidTime is the time within which the link info is still
// considered valid.
//

extern LARGE_INTEGER SrvMaxLinkDelay;
extern LARGE_INTEGER SrvMinLinkThroughput;
extern LARGE_INTEGER SrvLinkInfoValidTime;
extern LONG SrvScavengerUpdateQosCount;

//
// Used to determine how long a work context block can stay idle
// before being freed.
//

extern ULONG SrvWorkItemMaxIdleTime;

//
// Alert information
//

extern LARGE_INTEGER SrvAlertSchedule;
extern ULONG SrvAlertMinutes;
extern ULONG SrvFreeDiskSpaceThreshold;
extern ULONG SrvFreeDiskSpaceCeiling;
extern ULONG SrvDiskConfiguration;

//
// List of pipes and shares that can be opened by the NULL session.
//

extern PWSTR *SrvNullSessionPipes;
extern PWSTR *SrvNullSessionShares;

#if SRVNTVERCHK
//
// List of domain names that we disallow
//
extern PWSTR *SrvInvalidDomainNames;
#endif

//
// List of pipes that are not remapped, even when we are in a cluster environment
//
extern PWSTR *SrvNoRemapPipeNames;

//
// List of error codes that we do not log to the error log
//
extern NTSTATUS SrvErrorLogIgnore[ SRVMAXERRLOGIGNORE + 1 ];

//
// List of pipes that require a license from the license server
//
extern PWSTR *SrvPipesNeedLicense;

//
// Interval at which SMB statistics are calculated.
//

#define STATISTICS_SMB_INTERVAL 16

//
// Interval at which each thread determines the current system time
//
#define TIME_SMB_INTERVAL   16

//
// Delay and number of retries for opens returning sharing violation
//

extern ULONG SrvSharingViolationRetryCount;
extern LARGE_INTEGER SrvSharingViolationDelay;

//
// Delay for lock requests returning lock violation
//

extern ULONG SrvLockViolationDelay;
extern LARGE_INTEGER SrvLockViolationDelayRelative;
extern ULONG SrvLockViolationOffset;

//
// Upper limit for searches.
//

extern ULONG SrvMaxOpenSearches;

//
// length to switchover to mdl read
//

extern ULONG SrvMdlReadSwitchover;
extern ULONG SrvMpxMdlReadSwitchover;


//
// maximum length of buffers to copy, rather than take the whole buffer.
// currently this is only enabled for WRITE_MPX on direct host IPX.
//

extern ULONG SrvMaxCopyLength;

//
// Globally unique id identifying this server
//

extern
GUID ServerGuid;

//
// Number of open files that can be cached after close.
//

extern ULONG SrvCachedOpenLimit;

//
// *** Change the following defines to limit WinNT (vs. NTAS) parameters.
//
// *** If you make a change here, you need to make the same change in
//     srvsvc\server\srvconfg.h!

#define MAX_USERS_WKSTA                 10
#define MAX_MAXWORKITEMS_WKSTA          64
#define MAX_THREADS_WKSTA                5

#define MAX_USERS_PERSONAL               5
#define MAX_USERS_WEB_BLADE             10


#endif // def _SRVCONFG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\srvconst.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    srvconst.h

Abstract:

    This module defines manifest constants for the LAN Manager server.

Author:

    Chuck Lenzmeier (chuckl)    22-Sep-1989

Revision History:

--*/

#ifndef _SRVCONST_
#define _SRVCONST_

// !!! #include <lmcons.h>


// !!! The following constant should be gotten from netcons.h
#define COMPUTER_NAME_LENGTH 15

//
// This is the size of the data for doing oplock breaks.  Used to compute
// round trip propagation delays.
//

#define SRV_PROPAGATION_DELAY_SIZE  (ULONG) \
            (sizeof(SMB_HEADER) + sizeof(REQ_LOCKING_ANDX) + \
            sizeof(SMB_HEADER) + sizeof(RESP_LOCKING_ANDX) + 100)

//
// The number of slots in the error log record array, must be a power
// of 2.
//

#define NUMBER_OF_SLOTS 8

//
// The number of entries in the SrvMfcbHashTable.  Arbitrary.
//
#define NMFCB_HASH_TABLE    131

//
// The number of resources which guard entries in SrvMfcbHashTable. Only makes
//   sense for this number to be <= NMFCB_HASH_TABLE.
//
#define NMFCB_HASH_TABLE_LOCKS  10      // arbitrary

//
// The number of entries in the SrvShareHashTable.  Arbitrary
//
#define NSHARE_HASH_TABLE   17

//
// The number of pieces of pool we'll hang onto in a LOOK_ASIDE_LIST
// after deallocation for quick re-allocation.  Per processor.
// Involves a linear search...
//
#define LOOK_ASIDE_MAX_ELEMENTS 4

//
// Two look aside lists for quick pool allocation and deallocation are
//  kept, and a POOL_HEADER goes on one list or the other depending on
//  the size of the allocated block.  This is to reduce memory wastage.
//  LOOK_ASIDE_SWITCHOVER is the maximum block size for a memory chunk
//  to end up on the SmallFreeList in the LOOK_ASIDE_LIST
//
#define LOOK_ASIDE_SWITCHOVER   32

//
// We have to multiply the ea size we get back from the system to get
// the buffer size we need to query the ea.  This is because the returned
// ea size is the os/2 ea size.
//
#define EA_SIZE_FUDGE_FACTOR    2

#define ENDPOINT_LOCK_COUNT 4
#define ENDPOINT_LOCK_MASK  (ENDPOINT_LOCK_COUNT-1)

//
// The server keeps a table of NTSTATUS codes that it will avoid putting in
// the error log.  This is the number of codes we can hold
//
#define SRVMAXERRLOGIGNORE  50

//
// The following constants are copied from net\inc\apinums.h
// This is a list of apis and apinumbers that are callable
// on the null session.
//
#define API_WUserGetGroups                          59
#define API_WUserPasswordSet2                       115
#define API_NetServerEnum2                          104
#define API_WNetServerReqChallenge                  126
#define API_WNetServerAuthenticate                  127
#define API_WNetServerPasswordSet                   128
#define API_WNetAccountDeltas                       129
#define API_WNetAccountSync                         130
#define API_WWkstaUserLogoff                        133
#define API_WNetWriteUpdateLog                      208
#define API_WNetAccountUpdate                       209
#define API_WNetAccountConfirmUpdate                210
#define API_SamOEMChgPasswordUser2_P                214
#define API_NetServerEnum3                          215

//
// This is the presumed cache line size for the processor
//
#define CACHE_LINE_SIZE 32

//
// This is the number of ULONGS in a cache line
//
#define ULONGS_IN_CACHE (CACHE_LINE_SIZE / sizeof( ULONG ))

//
// This is the number of samples used to compute the average WORK_QUEUE depth.
// Must be a power of 2
//
#define QUEUE_SAMPLES   8

//
// This is Log2( QUEUE_SAMPLES )
//
#define LOG2_QUEUE_SAMPLES  3

//
// If we have an IPX client, we want to drop every few retries of the same SMB
//  by the client to decrease the server load.  WIN95 backs off its requests
//  when it gets ERR_WORKING, but wfw does not.  So, there's no value (from the
//  server's perspective) in responding very often to the wfw client.  The WfW
//  client retries approx every 300mS, and must receive a response in approx 9
//  seconds.  Therefore, we choose 9 drops as approx 3 seconds.  This will allow two
//  of our responses to be dropped and will allow enough time for the client to
//  try a third time.
//
#define MIN_IPXDROPDUP  2
#define MAX_IPXDROPDUP  9

//
// The number of configuration work items.  This roughly governs the number of kernel
//   worker threads which will be occupied processing configuration irps
//
#define MAX_CONFIG_WORK_ITEMS 2

//
// The maximum size of the buffer associated with a TRANSACTION
//
#define MAX_TRANSACTION_TAIL_SIZE 65*1024

//
// The number of times we will continue doing paged writes with WriteThrough
// set before we try and go back to cached writes.  This is used in situations
// where the cache manager has hit the cache throttle to prevent deadlocks
//
#define MAX_FORCED_WRITE_THROUGH 64

#endif // ndef _SRVCONST_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\srvdata.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    srvdata.c

Abstract:

    This module defines global data for the LAN Manager server FSP.  The
    globals defined herein are part of the server driver image, and are
    therefore loaded into the system address space and are nonpageable.
    Some of the fields point to, or contain pointers to, data that is
    also in the system address space and nonpageable.  Such data can be
    accessed by both the FSP and the FSD.  Other fields point to data
    that is in the FSP address and may or may not be pageable.  Only the
    FSP is allowed to address this data.  Pageable data can only be
    accessed at low IRQL (so that page faults are allowed).

    This module also has a routine to initialize those fields defined
    here that cannot be statically initialized.

Author:

    Chuck Lenzmeier (chuckl)    3-Oct-1989
    David Treadwell (davidtr)

Revision History:

--*/

#include "precomp.h"
#include "srvdata.tmh"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, SrvInitializeData )
#pragma alloc_text( PAGE, SrvTerminateData )
#endif


#if SRVDBG

ULARGE_INTEGER SrvDebug = {DEBUG_STOP_ON_ERRORS};
ULARGE_INTEGER SmbDebug = {0};

CLONG SrvDumpMaximumRecursion = 0;

#endif // SRVDBG

#ifdef PAGED_DBG
ULONG ThisCodeCantBePaged = 0;
#endif

//
// SrvDeviceObject is a pointer to the server's device object, which
// is created by the server FSD during initialization.  This global
// location is accessed primarily by the FSP.  The FSD usually knows
// the device object address by other means -- because it was called
// with the address as a parameter, or via a file object, etc.  But
// the transport receive event handler in the FSD doesn't have such
// other means, so it needs to access the global storage.
//
// *** The event handler has the address of a server connection block
//     (in its ConnectionContext parameter).  The device object address
//     could be found through the connection block.
//

PDEVICE_OBJECT SrvDeviceObject = NULL;

//
// Fields describing the state of the FSP.
//

BOOLEAN SrvFspActive = FALSE;             // Indicates whether the FSP is
                                          // running
BOOLEAN SrvFspTransitioning = FALSE;      // Indicates that the server is
                                          // in the process of starting up
                                          // or shutting down

BOOLEAN SrvMultiProcessorDriver = FALSE;  // Is this a multiprocessor driver?

BOOLEAN SrvCompletedPNPRegistration = FALSE;    // Indicates whether the FSP has completed
                                                //  registering for PNP notifications

PEPROCESS SrvServerProcess = NULL;        // Pointer to the initial system process

PEPROCESS SrvSvcProcess = NULL;           // Pointer to the service controller process

CLONG SrvEndpointCount = 0;               // Number of transport endpoints
KEVENT SrvEndpointEvent = {0};            // Signaled when no active endpoints

//
// DMA alignment size
//

ULONG SrvCacheLineSize = 0;

//
// Global spin locks.
//

SRV_GLOBAL_SPIN_LOCKS SrvGlobalSpinLocks = {0};

#if SRVDBG || SRVDBG_HANDLES
//
// Lock used to protect debugging structures.
//

SRV_LOCK SrvDebugLock = {0};
#endif

//
// SrvConfigurationLock is used to synchronize configuration requests.
//

SRV_LOCK SrvConfigurationLock = {0};

//
// SrvStartupShutdownLock is used to synchronize server startup and shutdown
//

SRV_LOCK SrvStartupShutdownLock = {0};

//
// SrvEndpointLock serializes access to the global endpoint list and
// all endpoints.  Note that the list of connections in each endpoint
// is also protected by this lock.
//

SRV_LOCK SrvEndpointLock = {0};

//
// SrvShareLock protects all shares.
//

SRV_LOCK SrvShareLock = {0};

//
// The number of processors in the system
//
ULONG SrvNumberOfProcessors = {0};

//
// A vector of nonblocking work queues, one for each processor
//
#if MULTIPROCESSOR

PBYTE SrvWorkQueuesBase = 0;      // base of allocated memory for the queues
PWORK_QUEUE SrvWorkQueues = 0;    // first queue in the allocated memory

#else

WORK_QUEUE SrvWorkQueues[1];

#endif

PWORK_QUEUE eSrvWorkQueues = 0;   // used for terminating 'for' loops

//
// Blocking Work Queue
//
#if MULTIPROCESSOR

PBYTE SrvBlockingWorkQueuesBase = 0;    // base of allocated memory for blocking queues
PWORK_QUEUE SrvBlockingWorkQueues = 0;  // first queue in the allocated memory

#else

WORK_QUEUE SrvBlockingWorkQueues[1];

#endif

WORK_QUEUE SrvLpcWorkQueue;

PWORK_QUEUE eSrvBlockingWorkQueues = 0;  // used for terminating 'for' loops


ULONG SrvReBalanced = 0;
ULONG SrvNextBalanceProcessor = 0;

CLONG SrvBlockingOpsInProgress = 0; // Number of blocking ops currently
                                    //   being processed


//
// The queue of connections that need an SMB buffer to process a pending
// receive completion.
//

LIST_ENTRY SrvNeedResourceQueue = {0};  // The queue

//
// The queue of connections that are disconnecting and need resource
// thread processing.
//

LIST_ENTRY SrvDisconnectQueue = {0};    // The queue

//
// Queue of connections that needs to be dereferenced.
//

SLIST_HEADER SrvBlockOrphanage = {0};    // The queue

//
// FSP configuration queue.  The FSD puts configuration request IRPs
// (from NtDeviceIoControlFile) on this queue, and it is serviced by an
// EX worker thread.
//

LIST_ENTRY SrvConfigurationWorkQueue = {0};     // The queue itself

//
// This is the number of configuration IRPs which have been queued but not
//  yet completed.
//
ULONG SrvConfigurationIrpsInProgress = 0;

//
// Base address of the large block allocated to hold initial normal
// work items (see blkwork.c\SrvAllocateInitialWorkItems).
//

PVOID SrvInitialWorkItemBlock = NULL;

//
// Work item used to run the resource thread.  Notification event used
// to inform the resource thread to continue running.
//

WORK_QUEUE_ITEM SrvResourceThreadWorkItem = {0};
BOOLEAN SrvResourceThreadRunning = FALSE;
BOOLEAN SrvResourceDisconnectPending = FALSE;

WORK_QUEUE_ITEM SrvResourceAllocThreadWorkItem = {0};
BOOLEAN SrvResourceAllocThreadRunning = FALSE;
BOOLEAN SrvResourceAllocConnection = FALSE;

LONG SrvResourceOrphanedBlocks = 0;

//
// Denial of Service monitoring variables for the Resource Thread
//
LONG SrvDoSTearDownInProgress = 0;
LONG SrvDoSWorkItemTearDown = 0;
BOOLEAN SrvDoSDetected = FALSE;
BOOLEAN SrvDoSRundownDetector = FALSE;
BOOLEAN SrvDoSRundownIncreased = FALSE;
BOOLEAN SrvDisableDoSChecking = FALSE;
SPECIAL_WORK_ITEM SrvDoSWorkItem;
KSPIN_LOCK SrvDosSpinLock;
LARGE_INTEGER SrvDoSLastRan = {0};

//
// Should we enforce strict name checking?
//
BOOLEAN SrvDisableStrictNameChecking = FALSE;

//
// Should we disable large read/write ops?
//
BOOLEAN SrvDisableLargeRead = FALSE;
BOOLEAN SrvDisableLargeWrite = FALSE;

//
// Should we allow downlevel timewarp
//
BOOLEAN SrvDisableDownlevelTimewarp = FALSE;

//
// Can the client do namespace caching (global setting)
//
BOOLEAN SrvNoAliasingOnFilesystem = FALSE;

//
// Should we map no-intermediate-buffering into write-through
//
BOOLEAN SrvMapNoIntermediateBuffering = FALSE;

//
// Generic security mapping for connecting to shares
//
GENERIC_MAPPING SrvShareConnectMapping = GENERIC_SHARE_CONNECT_MAPPING;

//
// What's the minumum # of free work items each processor should have?
//
ULONG SrvMinPerProcessorFreeWorkItems = 0;

//
// The server has callouts to enable a smart card to accelerate its direct
//  host IPX performance.  This is the vector of entry points.
//
SRV_IPX_SMART_CARD SrvIpxSmartCard = {0};

//
// This is the name of the server computer.  Returned in the negprot response
//
UNICODE_STRING SrvComputerName = {0};

//
// The master file table contains one entry for each named file that has
// at least one open instance.
//
MFCBHASH SrvMfcbHashTable[ NMFCB_HASH_TABLE ] = {0};

//
// This is the list of resources which protect the SrvMfcbHashTable buckets
//
SRV_LOCK SrvMfcbHashTableLocks[ NMFCB_HASH_TABLE_LOCKS ];

//
// The share table contains one entry for each share the server is supporting
//
LIST_ENTRY SrvShareHashTable[ NSHARE_HASH_TABLE ] = {0};

//
// Array of the hex digits for use by the dump routines and
// SrvSmbCreateTemporary.
//

CHAR SrvHexChars[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
                       'A', 'B', 'C', 'D', 'E', 'F' };


#if SRVCATCH
//
// Are we looking for the special file?
//
UNICODE_STRING SrvCatch;
PWSTR *SrvCatchBuf = NULL;
UNICODE_STRING SrvCatchExt;
PWSTR *SrvCatchExtBuf = NULL;
ULONG SrvCatchShares = 0;
PWSTR *SrvCatchShareNames = NULL;
#endif

//
// SrvSmbIndexTable is the first-layer index table for processing SMBs.
// The contents of this table are used to index into SrvSmbDispatchTable.
//

UCHAR SrvSmbIndexTable[] = {
    ISrvSmbCreateDirectory,         // SMB_COM_CREATE_DIRECTORY
    ISrvSmbDeleteDirectory,         // SMB_COM_DELETE_DIRECTORY
    ISrvSmbOpen,                    // SMB_COM_OPEN
    ISrvSmbCreate,                  // SMB_COM_CREATE
    ISrvSmbClose,                   // SMB_COM_CLOSE
    ISrvSmbFlush,                   // SMB_COM_FLUSH
    ISrvSmbDelete,                  // SMB_COM_DELETE
    ISrvSmbRename,                  // SMB_COM_RENAME
    ISrvSmbQueryInformation,        // SMB_COM_QUERY_INFORMATION
    ISrvSmbSetInformation,          // SMB_COM_SET_INFORMATION
    ISrvSmbRead,                    // SMB_COM_READ
    ISrvSmbWrite,                   // SMB_COM_WRITE
    ISrvSmbLockByteRange,           // SMB_COM_LOCK_BYTE_RANGE
    ISrvSmbUnlockByteRange,         // SMB_COM_UNLOCK_BYTE_RANGE
    ISrvSmbCreateTemporary,         // SMB_COM_CREATE_TEMPORARY
    ISrvSmbCreate,                  // SMB_COM_CREATE
    ISrvSmbCheckDirectory,          // SMB_COM_CHECK_DIRECTORY
    ISrvSmbProcessExit,             // SMB_COM_PROCESS_EXIT
    ISrvSmbSeek,                    // SMB_COM_SEEK
    ISrvSmbLockAndRead,             // SMB_COM_LOCK_AND_READ
    ISrvSmbWrite,                   // SMB_COM_WRITE_AND_UNLOCK
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbReadRaw,                 // SMB_COM_READ_RAW
    ISrvSmbReadMpx,                 // SMB_COM_READ_MPX
    ISrvSmbIllegalCommand,          // SMB_COM_READ_MPX_SECONDARY (server only)
    ISrvSmbWriteRaw,                // SMB_COM_WRITE_RAW
    ISrvSmbWriteMpx,                // SMB_COM_WRITE_MPX
    ISrvSmbWriteMpxSecondary,       // SMB_COM_WRITE_MPX_SECONDARY
    ISrvSmbIllegalCommand,          // SMB_COM_WRITE_COMPLETE (server only)
    ISrvSmbIllegalCommand,          // SMB_COM_QUERY_INFORMATION_SRV
    ISrvSmbSetInformation2,         // SMB_COM_SET_INFORMATION2
    ISrvSmbQueryInformation2,       // SMB_COM_QUERY_INFORMATION2
    ISrvSmbLockingAndX,             // SMB_COM_LOCKING_ANDX
    ISrvSmbTransaction,             // SMB_COM_TRANSACTION
    ISrvSmbTransactionSecondary,    // SMB_COM_TRANSACTION_SECONDARY
    ISrvSmbIoctl,                   // SMB_COM_IOCTL
    ISrvSmbIoctlSecondary,          // SMB_COM_IOCTL_SECONDARY
    ISrvSmbMove,                    // SMB_COM_COPY
    ISrvSmbMove,                    // SMB_COM_MOVE
    ISrvSmbEcho,                    // SMB_COM_ECHO
    ISrvSmbWrite,                   // SMB_COM_WRITE_AND_CLOSE
    ISrvSmbOpenAndX,                // SMB_COM_OPEN_ANDX
    ISrvSmbReadAndX,                // SMB_COM_READ_ANDX
    ISrvSmbWriteAndX,               // SMB_COM_WRITE_ANDX
    ISrvSmbIllegalCommand,          // SMB_COM_SET_NEW_SIZE
    ISrvSmbClose,                   // SMB_COM_CLOSE_AND_TREE_DISC
    ISrvSmbTransaction,             // SMB_COM_TRANSACTION2
    ISrvSmbTransactionSecondary,    // SMB_COM_TRANSACTION2_SECONDARY
    ISrvSmbFindClose2,              // SMB_COM_FIND_CLOSE2
    ISrvSmbFindNotifyClose,         // SMB_COM_FIND_NOTIFY_CLOSE
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbTreeConnect,             // SMB_COM_TREE_CONNECT
    ISrvSmbTreeDisconnect,          // SMB_COM_TREE_DISCONNECT
    ISrvSmbNegotiate,               // SMB_COM_NEGOTIATE
    ISrvSmbSessionSetupAndX,        // SMB_COM_SESSION_SETUP_ANDX
    ISrvSmbLogoffAndX,              // SMB_COM_LOGOFF_ANDX
    ISrvSmbTreeConnectAndX,         // SMB_COM_TREE_CONNECT_ANDX
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbQueryInformationDisk,    // SMB_COM_QUERY_INFORMATION_DISK
    ISrvSmbSearch,                  // SMB_COM_SEARCH
    ISrvSmbSearch,                  // SMB_COM_SEARCH
    ISrvSmbSearch,                  // SMB_COM_SEARCH
    ISrvSmbSearch,                  // SMB_COM_SEARCH
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbNtTransaction,           // SMB_COM_NT_TRANSACT
    ISrvSmbNtTransactionSecondary,  // SMB_COM_NT_TRANSACT_SECONDARY
    ISrvSmbNtCreateAndX,            // SMB_COM_NT_CREATE_ANDX
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbNtCancel,                // SMB_COM_NT_CANCEL
    ISrvSmbRename,                  // SMB_COM_NT_RENAME
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbOpenPrintFile,           // SMB_COM_OPEN_PRINT_FILE
    ISrvSmbWrite,                   // SMB_COM_WRITE_PRINT_FILE
    ISrvSmbClosePrintFile,          // SMB_COM_CLOSE_PRINT_FILE
    ISrvSmbGetPrintQueue,           // SMB_COM_GET_PRINT_QUEUE
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_SEND_MESSAGE
    ISrvSmbIllegalCommand,          // SMB_COM_SEND_BROADCAST_MESSAGE
    ISrvSmbIllegalCommand,          // SMB_COM_FORWARD_USER_NAME
    ISrvSmbIllegalCommand,          // SMB_COM_CANCEL_FORWARD
    ISrvSmbIllegalCommand,          // SMB_COM_GET_MACHINE_NAME
    ISrvSmbIllegalCommand,          // SMB_COM_SEND_START_MB_MESSAGE
    ISrvSmbIllegalCommand,          // SMB_COM_SEND_END_MB_MESSAGE
    ISrvSmbIllegalCommand,          // SMB_COM_SEND_TEXT_MB_MESSAGE
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand,          // SMB_COM_ILLEGAL_COMMAND
    ISrvSmbIllegalCommand           // SMB_COM_ILLEGAL_COMMAND
};

//
// SrvSmbDispatchTable is the jump table for processing SMBs.
//

#if DBG
#define SMB_DISPATCH_ENTRY( x )  { x, #x }
#else
#define SMB_DISPATCH_ENTRY( x ) { x }
#endif

SRV_SMB_DISPATCH_TABLE SrvSmbDispatchTable[] = {

    SMB_DISPATCH_ENTRY( SrvSmbIllegalCommand ),
    SMB_DISPATCH_ENTRY( SrvSmbCreateDirectory ),
    SMB_DISPATCH_ENTRY( SrvSmbDeleteDirectory ),
    SMB_DISPATCH_ENTRY( SrvSmbOpen ),
    SMB_DISPATCH_ENTRY( SrvSmbCreate ),
    SMB_DISPATCH_ENTRY( SrvSmbClose ),
    SMB_DISPATCH_ENTRY( SrvSmbFlush ),
    SMB_DISPATCH_ENTRY( SrvSmbDelete ),
    SMB_DISPATCH_ENTRY( SrvSmbRename ),
    SMB_DISPATCH_ENTRY( SrvSmbQueryInformation ),
    SMB_DISPATCH_ENTRY( SrvSmbSetInformation ),
    SMB_DISPATCH_ENTRY( SrvSmbRead ),
    SMB_DISPATCH_ENTRY( SrvSmbWrite ),
    SMB_DISPATCH_ENTRY( SrvSmbLockByteRange ),
    SMB_DISPATCH_ENTRY( SrvSmbUnlockByteRange ),
    SMB_DISPATCH_ENTRY( SrvSmbCreateTemporary ),
    SMB_DISPATCH_ENTRY( SrvSmbCheckDirectory ),
    SMB_DISPATCH_ENTRY( SrvSmbProcessExit ),
    SMB_DISPATCH_ENTRY( SrvSmbSeek ),
    SMB_DISPATCH_ENTRY( SrvSmbLockAndRead ),
    SMB_DISPATCH_ENTRY( SrvSmbSetInformation2 ),
    SMB_DISPATCH_ENTRY( SrvSmbQueryInformation2 ),
    SMB_DISPATCH_ENTRY( SrvSmbLockingAndX ),
    SMB_DISPATCH_ENTRY( SrvSmbTransaction ),
    SMB_DISPATCH_ENTRY( SrvSmbTransactionSecondary ),
    SMB_DISPATCH_ENTRY( SrvSmbIoctl ),
    SMB_DISPATCH_ENTRY( SrvSmbIoctlSecondary ),
    SMB_DISPATCH_ENTRY( SrvSmbMove ),
    SMB_DISPATCH_ENTRY( SrvSmbEcho ),
    SMB_DISPATCH_ENTRY( SrvSmbOpenAndX ),
    SMB_DISPATCH_ENTRY( SrvSmbReadAndX ),
    SMB_DISPATCH_ENTRY( SrvSmbWriteAndX ),
    SMB_DISPATCH_ENTRY( SrvSmbFindClose2 ),
    SMB_DISPATCH_ENTRY( SrvSmbFindNotifyClose ),
    SMB_DISPATCH_ENTRY( SrvSmbTreeConnect ),
    SMB_DISPATCH_ENTRY( SrvSmbTreeDisconnect ),
    SMB_DISPATCH_ENTRY( SrvSmbNegotiate ),
    SMB_DISPATCH_ENTRY( SrvSmbSessionSetupAndX ),
    SMB_DISPATCH_ENTRY( SrvSmbLogoffAndX ),
    SMB_DISPATCH_ENTRY( SrvSmbTreeConnectAndX ),
    SMB_DISPATCH_ENTRY( SrvSmbQueryInformationDisk ),
    SMB_DISPATCH_ENTRY( SrvSmbSearch ),
    SMB_DISPATCH_ENTRY( SrvSmbNtTransaction ),
    SMB_DISPATCH_ENTRY( SrvSmbNtTransactionSecondary ),
    SMB_DISPATCH_ENTRY( SrvSmbNtCreateAndX ),
    SMB_DISPATCH_ENTRY( SrvSmbNtCancel ),
    SMB_DISPATCH_ENTRY( SrvSmbOpenPrintFile ),
    SMB_DISPATCH_ENTRY( SrvSmbClosePrintFile ),
    SMB_DISPATCH_ENTRY( SrvSmbGetPrintQueue ),
    SMB_DISPATCH_ENTRY( SrvSmbReadRaw ),
    SMB_DISPATCH_ENTRY( SrvSmbWriteRaw ),
    SMB_DISPATCH_ENTRY( SrvSmbReadMpx ),
    SMB_DISPATCH_ENTRY( SrvSmbWriteMpx ),
    SMB_DISPATCH_ENTRY( SrvSmbWriteMpxSecondary )
};

//
// Table of WordCount values for all SMBs.
//

SCHAR SrvSmbWordCount[] = {
    0,            // SMB_COM_CREATE_DIRECTORY
    0,            // SMB_COM_DELETE_DIRECTORY
    2,            // SMB_COM_OPEN
    3,            // SMB_COM_CREATE
    3,            // SMB_COM_CLOSE
    1,            // SMB_COM_FLUSH
    1,            // SMB_COM_DELETE
    1,            // SMB_COM_RENAME
    0,            // SMB_COM_QUERY_INFORMATION
    8,            // SMB_COM_SET_INFORMATION
    5,            // SMB_COM_READ
    5,            // SMB_COM_WRITE
    5,            // SMB_COM_LOCK_BYTE_RANGE
    5,            // SMB_COM_UNLOCK_BYTE_RANGE
    3,            // SMB_COM_CREATE_TEMPORARY
    3,            // SMB_COM_CREATE
    0,            // SMB_COM_CHECK_DIRECTORY
    0,            // SMB_COM_PROCESS_EXIT
    4,            // SMB_COM_SEEK
    5,            // SMB_COM_LOCK_AND_READ
    5,            // SMB_COM_WRITE_AND_UNLOCK
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -1,           // SMB_COM_READ_RAW
    8,            // SMB_COM_READ_MPX
    8,            // SMB_COM_READ_MPX_SECONDARY
    -1,           // SMB_COM_WRITE_RAW
    12,           // SMB_COM_WRITE_MPX
    12,           // SMB_COM_WRITE_MPX_SECONDARY
    -2,           // SMB_COM_ILLEGAL_COMMAND
    1,            // SMB_COM_QUERY_INFORMATION_SRV
    7,            // SMB_COM_SET_INFORMATION2
    1,            // SMB_COM_QUERY_INFORMATION2
    8,            // SMB_COM_LOCKING_ANDX
    -1,           // SMB_COM_TRANSACTION
    8,            // SMB_COM_TRANSACTION_SECONDARY
    14,           // SMB_COM_IOCTL
    8,            // SMB_COM_IOCTL_SECONDARY
    3,            // SMB_COM_COPY
    3,            // SMB_COM_MOVE
    1,            // SMB_COM_ECHO
    -1,           // SMB_COM_WRITE_AND_CLOSE
    15,           // SMB_COM_OPEN_ANDX
    -1,           // SMB_COM_READ_ANDX
    -1,           // SMB_COM_WRITE_ANDX
    3,            // SMB_COM_SET_NEW_SIZE
    3,            // SMB_COM_CLOSE_AND_TREE_DISC
    -1,           // SMB_COM_TRANSACTION2
    9,            // SMB_COM_TRANSACTION2_SECONDARY
    1,            // SMB_COM_FIND_CLOSE2
    1,            // SMB_COM_FIND_NOTIFY_CLOSE
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    0,            // SMB_COM_TREE_CONNECT
    0,            // SMB_COM_TREE_DISCONNECT
    0,            // SMB_COM_NEGOTIATE
    -1,           // SMB_COM_SESSION_SETUP_ANDX
    2,            // SMB_COM_LOGOFF_ANDX
    4,            // SMB_COM_TREE_CONNECT_ANDX
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    0,            // SMB_COM_QUERY_INFORMATION_DISK
    2,            // SMB_COM_SEARCH
    2,            // SMB_COM_SEARCH
    2,            // SMB_COM_SEARCH
    2,            // SMB_COM_SEARCH
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -1,           // SMB_COM_NT_TRANSACT
    18,           // SMB_COM_NT_TRANSACT_SECONDARY
    24,           // SMB_COM_NT_CREATE_ANDX
    -2,           // SMB_COM_ILLEGAL_COMMAND
    0,            // SMB_COM_NT_CANCEL
    4,            // SMB_COM_NT_RENAME
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    2,            // SMB_COM_OPEN_PRINT_FILE
    1,            // SMB_COM_WRITE_PRINT_FILE
    1,            // SMB_COM_CLOSE_PRINT_FILE
    2,            // SMB_COM_GET_PRINT_QUEUE
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_SEND_MESSAGE
    -2,           // SMB_COM_SEND_BROADCAST_MESSAGE
    -2,           // SMB_COM_FORWARD_USER_NAME
    -2,           // SMB_COM_CANCEL_FORWARD
    -2,           // SMB_COM_GET_MACHINE_NAME
    -2,           // SMB_COM_SEND_START_MB_MESSAGE
    -2,           // SMB_COM_SEND_END_MB_MESSAGE
    -2,           // SMB_COM_SEND_TEXT_MB_MESSAGE
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
    -2,           // SMB_COM_ILLEGAL_COMMAND
};

//
// SrvCanonicalNamedPipePrefix is "PIPE\".
//

UNICODE_STRING SrvCanonicalNamedPipePrefix = {0};

//
// The following is used to generate NT style pipe paths.
//

UNICODE_STRING SrvNamedPipeRootDirectory = {0};

//
// The following is used to generate NT style mailslot paths.
//

UNICODE_STRING SrvMailslotRootDirectory = {0};

//
// SrvTransaction2DispatchTable is the jump table for processing
// Transaction2 SMBs.
//

PSMB_TRANSACTION_PROCESSOR SrvTransaction2DispatchTable[] = {
    SrvSmbOpen2,
    SrvSmbFindFirst2,
    SrvSmbFindNext2,
    SrvSmbQueryFsInformation,
    SrvSmbSetFsInformation,
    SrvSmbQueryPathInformation,
    SrvSmbSetPathInformation,
    SrvSmbQueryFileInformation,
    SrvSmbSetFileInformation,
    SrvSmbFsctl,
    SrvSmbIoctl2,
    SrvSmbFindNotify,
    SrvSmbFindNotify,
    SrvSmbCreateDirectory2,
    SrvTransactionNotImplemented,                // Can be reused...
    SrvTransactionNotImplemented,
    SrvSmbGetDfsReferral,
    SrvSmbReportDfsInconsistency
};

//
// SrvNtTransactionDispatchTable is the jump table for processing
// NtTransaction SMBs.
//

PSMB_TRANSACTION_PROCESSOR SrvNtTransactionDispatchTable[ NT_TRANSACT_MAX_FUNCTION+1 ] = {
    NULL,
    SrvSmbCreateWithSdOrEa,
    SrvSmbNtIoctl,
    SrvSmbSetSecurityDescriptor,
    SrvSmbNtNotifyChange,
    SrvSmbNtRename,
    SrvSmbQuerySecurityDescriptor,
    SrvSmbQueryQuota,
    SrvSmbSetQuota
};

//
// Global variables for server statistics.
//

SRV_STATISTICS SrvStatistics = {0};

#if SRVDBG_STATS || SRVDBG_STATS2
SRV_STATISTICS_DEBUG SrvDbgStatistics = {0};
#endif

//
// The number of abortive disconnects that the server has gotten
//
ULONG SrvAbortiveDisconnects = 0;

//
// The number of memory retries, and how often they were successful
//
LONG SrvMemoryAllocationRetries = 0;
LONG SrvMemoryAllocationRetriesSuccessful = 0;

//
// Server environment information strings.
//

UNICODE_STRING SrvNativeOS = {0};
OEM_STRING SrvOemNativeOS = {0};
UNICODE_STRING SrvNativeLanMan = {0};
OEM_STRING SrvOemNativeLanMan = {0};
UNICODE_STRING SrvSystemRoot = {0};

//
// The following will be a permanent handle and device object pointer
// to NPFS.
//

HANDLE SrvNamedPipeHandle = NULL;
PDEVICE_OBJECT SrvNamedPipeDeviceObject = NULL;
PFILE_OBJECT SrvNamedPipeFileObject = NULL;

//
// The following are used to converse with the Dfs driver
//
PFAST_IO_DEVICE_CONTROL SrvDfsFastIoDeviceControl = NULL;
PDEVICE_OBJECT SrvDfsDeviceObject = NULL;
PFILE_OBJECT SrvDfsFileObject = NULL;

//
// The following will be a permanent handle and device object pointer
// to MSFS.
//

HANDLE SrvMailslotHandle = NULL;
PDEVICE_OBJECT SrvMailslotDeviceObject = NULL;
PFILE_OBJECT SrvMailslotFileObject = NULL;

//
// Flag indicating XACTSRV whether is active, and resource synchronizing
// access to XACTSRV-related variabled.
//

BOOLEAN SrvXsActive = FALSE;

ERESOURCE SrvXsResource = {0};

//
// Handle to the unnamed shared memory and communication port used for
// communication between the server and XACTSRV.
//

HANDLE SrvXsSectionHandle = NULL;
HANDLE SrvXsPortHandle = NULL;

//
// Pointers to control the unnamed shared memory for the XACTSRV LPC port.
// The port memory heap handle is initialized to NULL to indicate that
// there is no connection with XACTSRV yet.
//

PVOID SrvXsPortMemoryBase = NULL;
ULONG_PTR SrvXsPortMemoryDelta = 0;
PVOID SrvXsPortMemoryHeap = NULL;

//
// Pointer to heap header for the special XACTSRV shared-memory heap.
//

PVOID SrvXsHeap = NULL;

//
// Dispatch table for server APIs.  APIs are dispatched based on the
// control code passed to NtFsControlFile.
//
// *** The order here must match the order of API codes defined in
//     net\inc\srvfsctl.h!

PAPI_PROCESSOR SrvApiDispatchTable[] = {
    SrvNetConnectionEnum,
    SrvNetFileClose,
    SrvNetFileEnum,
    SrvNetServerDiskEnum,
    SrvNetServerSetInfo,
    SrvNetServerTransportAdd,
    SrvNetServerTransportDel,
    SrvNetServerTransportEnum,
    SrvNetSessionDel,
    SrvNetSessionEnum,
    SrvNetShareAdd,
    SrvNetShareDel,
    SrvNetShareEnum,
    SrvNetShareSetInfo,
    SrvNetStatisticsGet
};

//
// Names for the various types of clients.  This array corresponds to
// the SMB_DIALECT enumerated type.
//

UNICODE_STRING SrvClientTypes[LAST_DIALECT] = {0};

//
// All the resumable Enum APIs use ordered lists for context-free
// resume.  All data blocks in the server that correspond to return
// information for Enum APIs are maintained in ordered lists.
//

SRV_LOCK SrvOrderedListLock = {0};

ORDERED_LIST_HEAD SrvEndpointList = {0};
ORDERED_LIST_HEAD SrvRfcbList = {0};
ORDERED_LIST_HEAD SrvSessionList = {0};
ORDERED_LIST_HEAD SrvTreeConnectList = {0};

//
// The DNS name for the domain
//
PUNICODE_STRING SrvDnsDomainName = NULL;

//
// To synchronize server shutdown with API requests handled in the
// server FSD, we track the number of outstanding API requests.  The
// shutdown code waits until all APIs have been completed to start
// termination.
//
// SrvApiRequestCount tracks the active APIs in the FSD.
// SrvApiCompletionEvent is set by the last API to complete, and the
// shutdown code waits on it if there are outstanding APIs.
//

ULONG SrvApiRequestCount = 0;
KEVENT SrvApiCompletionEvent = {0};

//
// Security data for logging on remote users.  SrvLsaHandle is the logon
// process handle that we use in calls to LsaLogonUser.
// SrvSystemSecurityMode contains the secutity mode the system is
// running in.  SrvAuthenticationPackage is a token that describes the
// authentication package being used.  SrvNullSessionToken is a cached
// token handle representing the null session.
//

CtxtHandle SrvNullSessionToken = {0, 0};
CtxtHandle SrvLmLsaHandle = {0, 0};

CtxtHandle SrvExtensibleSecurityHandle = {0, 0};

//
// Security descriptor granting Administrator READ access.
//  Used to see if a client has administrative privileges
//
SECURITY_DESCRIPTOR SrvAdminSecurityDescriptor;

//
// Security descriptor granting Anonymous READ access.
//  Used to see if a client was an anonymous (null session) logon
//
SECURITY_DESCRIPTOR SrvNullSessionSecurityDescriptor;

//
// A list of SMBs waiting for an oplock break to occur, before they can
// proceed, and a lock to protect the list.
//

LIST_ENTRY SrvWaitForOplockBreakList = {0};
SRV_LOCK SrvOplockBreakListLock = {0};

//
// A list of outstanding oplock break requests.  The list is protected by
// SrvOplockBreakListLock.
//

LIST_ENTRY SrvOplockBreaksInProgressList = {0};

//
// Global security context.  Use static tracking.
//

SECURITY_QUALITY_OF_SERVICE SrvSecurityQOS = {0};

//
// A BOOLEAN to indicate whether the server is paused.  If paused, the
// server will not accept new tree connections from non-admin users.
//

BOOLEAN SrvPaused = FALSE;

//
// Alerting information.
//

SRV_ERROR_RECORD SrvErrorRecord = {0};
SRV_ERROR_RECORD SrvNetworkErrorRecord = {0};

BOOLEAN SrvDiskAlertRaised[26] = {0};

//
// Counts of the number of times pool allocations have failed because
// the server was at its configured pool limit.
//

ULONG SrvNonPagedPoolLimitHitCount = 0;
ULONG SrvPagedPoolLimitHitCount = 0;

//
// SrvOpenCount counts the number of active opens of the server device.
// This is used at server shutdown time to determine whether the server
// service should unload the driver.
//

ULONG SrvOpenCount = 0;

//
// Counters for logging resource shortage events during a scavenger pass.
//

ULONG SrvOutOfFreeConnectionCount = 0;
ULONG SrvOutOfRawWorkItemCount = 0;
ULONG SrvFailedBlockingIoCount = 0;

//
// Current core search timeout time in seconds
//

ULONG SrvCoreSearchTimeout = 0;

SRV_LOCK SrvUnlockableCodeLock = {0};
SECTION_DESCRIPTOR SrvSectionInfo[SRV_CODE_SECTION_MAX] = {
    { SrvSmbRead, NULL, 0 },                // pageable code -- locked
                                            //   only and always on NTAS
    { SrvCheckAndReferenceRfcb, NULL, 0 }   // 8FIL section -- locked
                                            //   when files are open
    };

//
// SrvTimerList is a pool of timer/DPC structures available for use by
// code that needs to start a timer.
//

SLIST_HEADER SrvTimerList = {0};

//
// Name that should be displayed when doing a server alert.
//

PWSTR SrvAlertServiceName = NULL;

//
// Variable to store the number of tick counts for 5 seconds
//

ULONG SrvFiveSecondTickCount = 0;

//
// Flag indicating whether or not we need to filter extended characters
//  out of 8.3 names ourselves.
//
BOOLEAN SrvFilterExtendedCharsInPath = FALSE;

//
// Flag indicating if we enforce all logoff times
//
BOOLEAN SrvEnforceLogoffTimes = FALSE;

//
// Should we try extended signatures
//
BOOLEAN SrvEnableExtendedSignatures = TRUE;
BOOLEAN SrvRequireExtendedSignatures = FALSE;

//
// Holds the TDI PNP notification handle
//
HANDLE SrvTdiNotificationHandle = 0;

//
// Should we log invalid SMB commands
//
#if DBG
BOOLEAN SrvEnableInvalidSmbLogging = TRUE;
#else
BOOLEAN SrvEnableInvalidSmbLogging = FALSE;
#endif

//
// Flag indicating whether or not SMB security signatures are enabled.
//
BOOLEAN SrvSmbSecuritySignaturesEnabled = FALSE;

//
// Flag indicating whether or not SMB security signatures are required.  The signature
//   must match between the client and the server for the smb to be accepted.
//
BOOLEAN SrvSmbSecuritySignaturesRequired = FALSE;

//
// Flag indicating whether or not SMB security signatures should be applied to W9x
// clients.
//
BOOLEAN SrvEnableW9xSecuritySignatures = FALSE;

//
// Maximum amount of data that we'll allocate to support a METHOD_NEITHER Fsctl call
//
ULONG SrvMaxFsctlBufferSize = 70*1024;

//
// Maximum NT transaction size which we'll accept.
//
ULONG SrvMaxNtTransactionSize = 70*1024;

//
// Maximum size of large Read&X that we'll allow.  We need to lock down a cache region
//  to service this request, so we don't want it to get too big
//
ULONG SrvMaxReadSize = 64*1024;

//
// When we receive an large write from a client, we receive it in chunks,
//  locking & unlocking the file cache as we receive the data.  SrvMaxWriteChunk is the
//  size of this 'chunk'.  There's no magic to this chosen value.
//
ULONG SrvMaxWriteChunk =  64 * 1024;

//
// Handle used for PoRegisterSystemState calls
//
PVOID SrvPoRegistrationState = NULL;
//
// Counter used to suppress extraneous PoRegisterSystemStateCalls
//
ULONG SrvIdleCount = 0;

//
// If a server worker threads remains idle for this many ticks, then it terminate
//
LONGLONG SrvIdleThreadTimeOut = 0;

//
// Denial-of-Service monitoring and logging controls
//
LARGE_INTEGER SrvLastDosAttackTime = {0};
ULONG SrvDOSAttacks = 0;
BOOLEAN SrvLogEventOnDOS = TRUE;


#if SRVNTVERCHK
//
// This is the minimum NT5 client build number that we will allow to connect to the server
//
ULONG SrvMinNT5Client = 0;
BOOLEAN SrvMinNT5ClientIPCToo = FALSE;

//
// To force upgrades of our internal development community, we can set a
//  value in the registry that governs the minimum NT release that we allow
//  people to run to connect to this server.  However, some folks have special
//  needs that preclude a forced upgrade.  Presuming they have a static IP address,
//  you can add their address to the registry to exclude them from the build number
//  checking logic
//
DWORD SrvAllowIPAddress[25];
#endif


VOID
SrvInitializeData (
    VOID
    )

/*++

Routine Description:

    This is the initialization routine for data defined in this module.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG i,j;
    ANSI_STRING string;

    PAGED_CODE( );

#if MULTIPROCESSOR
    SrvMultiProcessorDriver = TRUE;
#endif

    //
    // Initialize the statistics database.
    //

    RtlZeroMemory( &SrvStatistics, sizeof(SrvStatistics) );
#if SRVDBG_STATS || SRVDBG_STATS2
    RtlZeroMemory( &SrvDbgStatistics, sizeof(SrvDbgStatistics) );
#endif

    //
    // Store the address of the initial system process for later use.
    //

    SrvServerProcess = IoGetCurrentProcess();

    //
    // Store the number of processors
    //
    SrvNumberOfProcessors = KeNumberProcessors;

    //
    // Initialize the event used to determine when all endpoints have
    // closed.
    //

    KeInitializeEvent( &SrvEndpointEvent, SynchronizationEvent, FALSE );

    //
    // Initialize the event used to deterine when all API requests have
    // completed.
    //

    KeInitializeEvent( &SrvApiCompletionEvent, SynchronizationEvent, FALSE );

    //
    // Allocate the spin lock used to synchronize between the FSD and
    // the FSP.
    //

    INITIALIZE_GLOBAL_SPIN_LOCK( Fsd );

#if SRVDBG || SRVDBG_HANDLES
    INITIALIZE_GLOBAL_SPIN_LOCK( Debug );
#endif

    INITIALIZE_GLOBAL_SPIN_LOCK( Statistics );

    //
    // Initialize various (non-spin) locks.
    //

    INITIALIZE_LOCK(
        &SrvConfigurationLock,
        CONFIGURATION_LOCK_LEVEL,
        "SrvConfigurationLock"
        );
    INITIALIZE_LOCK(
        &SrvStartupShutdownLock,
        STARTUPSHUTDOWN_LOCK_LEVEL,
        "SrvStartupShutdownLock"
        );
    INITIALIZE_LOCK(
        &SrvEndpointLock,
        ENDPOINT_LOCK_LEVEL,
        "SrvEndpointLock"
        );

    for( i=0; i < NMFCB_HASH_TABLE_LOCKS; i++ ) {
        INITIALIZE_LOCK(
            &SrvMfcbHashTableLocks[i],
            MFCB_LIST_LOCK_LEVEL,
            "SrvMfcbListLock"
            );
    }

    INITIALIZE_LOCK(
        &SrvShareLock,
        SHARE_LOCK_LEVEL,
        "SrvShareLock"
        );

    INITIALIZE_LOCK(
        &SrvOplockBreakListLock,
        OPLOCK_LIST_LOCK_LEVEL,
        "SrvOplockBreakListLock"
        );

#if SRVDBG || SRVDBG_HANDLES
    INITIALIZE_LOCK(
        &SrvDebugLock,
        DEBUG_LOCK_LEVEL,
        "SrvDebugLock"
        );
#endif

    //
    // Create the resource serializing access to the XACTSRV port.  This
    // resource protects access to the shared memory reference count and
    // the shared memory heap.
    //

    ExInitializeResourceLite( &SrvXsResource );

    //
    // Initialize the need resource queue
    //

    InitializeListHead( &SrvNeedResourceQueue );

    //
    // Initialize the connection disconnect queue
    //

    InitializeListHead( &SrvDisconnectQueue );

    //
    // Initialize the configuration queue.
    //

    InitializeListHead( &SrvConfigurationWorkQueue );

    //
    // Initialize the orphan queue
    //

    ExInitializeSListHead( &SrvBlockOrphanage );

    //
    // Initialize the Timer List
    //

    ExInitializeSListHead( &SrvTimerList );

    //
    // Initialize the resource thread work item and continuation event.
    // (Note that this is a notification [non-autoclearing] event.)
    //

    ExInitializeWorkItem(
        &SrvResourceThreadWorkItem,
        SrvResourceThread,
        NULL
        );

    ExInitializeWorkItem(
        &SrvResourceAllocThreadWorkItem,
        SrvResourceAllocThread,
        NULL
        );

    //
    // Initialize global lists.
    //
    for( i=j=0; i < NMFCB_HASH_TABLE; i++ ) {
        InitializeListHead( &SrvMfcbHashTable[i].List );
        SrvMfcbHashTable[i].Lock = &SrvMfcbHashTableLocks[ j ];
        if( ++j == NMFCB_HASH_TABLE_LOCKS ) {
            j = 0;
        }
    }

    for( i=0; i < NSHARE_HASH_TABLE; i++ ) {
        InitializeListHead( &SrvShareHashTable[i] );
    }

    //
    // Initialize the ordered list lock.  Indicate that the ordered
    // lists have not yet been initialized, so that TerminateServer can
    // determine whether to delete them.
    //

    INITIALIZE_LOCK(
        &SrvOrderedListLock,
        ORDERED_LIST_LOCK_LEVEL,
        "SrvOrderedListLock"
        );

    SrvEndpointList.Initialized = FALSE;
    SrvRfcbList.Initialized = FALSE;
    SrvSessionList.Initialized = FALSE;
    SrvTreeConnectList.Initialized = FALSE;

    //
    // Initialize the unlockable code package lock.
    //

    INITIALIZE_LOCK(
        &SrvUnlockableCodeLock,
        UNLOCKABLE_CODE_LOCK_LEVEL,
        "SrvUnlockableCodeLock"
        );

    //
    // Initialize the waiting for oplock break to occur list, and the
    // oplock breaks in progress list.
    //

    InitializeListHead( &SrvWaitForOplockBreakList );
    InitializeListHead( &SrvOplockBreaksInProgressList );

    //
    // The default security quality of service for non NT clients.
    //

    SrvSecurityQOS.ImpersonationLevel = SecurityImpersonation;
    SrvSecurityQOS.ContextTrackingMode = SECURITY_STATIC_TRACKING;
    SrvSecurityQOS.EffectiveOnly = FALSE;

    //
    // Initialize Unicode strings.
    //

    RtlInitString( &string, StrPipeSlash );
    RtlAnsiStringToUnicodeString(
        &SrvCanonicalNamedPipePrefix,
        &string,
        TRUE
        );

    RtlInitUnicodeString( &SrvNamedPipeRootDirectory, StrNamedPipeDevice );
    RtlInitUnicodeString( &SrvMailslotRootDirectory, StrMailslotDevice );

    //
    // The server's name
    //

    RtlInitUnicodeString( &SrvNativeLanMan, StrNativeLanman );
    RtlInitAnsiString( (PANSI_STRING)&SrvOemNativeLanMan, StrNativeLanmanOem );

    //
    // The system root
    //
#if defined(i386)
    RtlInitUnicodeString( &SrvSystemRoot, SharedUserData->NtSystemRoot );
#endif

    //
    // Debug logic to verify the contents of SrvApiDispatchTable (see
    // inititialization earlier in this module).
    //

    ASSERT( SRV_API_INDEX(FSCTL_SRV_MAX_API_CODE) + 1 ==
                sizeof(SrvApiDispatchTable) / sizeof(PAPI_PROCESSOR) );

    ASSERT( SrvApiDispatchTable[SRV_API_INDEX(
            FSCTL_SRV_NET_CONNECTION_ENUM)] == SrvNetConnectionEnum );
    ASSERT( SrvApiDispatchTable[SRV_API_INDEX(
            FSCTL_SRV_NET_FILE_CLOSE)] == SrvNetFileClose );
    ASSERT( SrvApiDispatchTable[SRV_API_INDEX(
            FSCTL_SRV_NET_FILE_ENUM)] == SrvNetFileEnum );
    ASSERT( SrvApiDispatchTable[SRV_API_INDEX(
            FSCTL_SRV_NET_SERVER_DISK_ENUM)] == SrvNetServerDiskEnum );
    ASSERT( SrvApiDispatchTable[SRV_API_INDEX(
            FSCTL_SRV_NET_SERVER_SET_INFO)] == SrvNetServerSetInfo );
    ASSERT( SrvApiDispatchTable[SRV_API_INDEX(
            FSCTL_SRV_NET_SERVER_XPORT_ADD)] == SrvNetServerTransportAdd );
    ASSERT( SrvApiDispatchTable[SRV_API_INDEX(
            FSCTL_SRV_NET_SERVER_XPORT_DEL)] == SrvNetServerTransportDel );
    ASSERT( SrvApiDispatchTable[SRV_API_INDEX(
            FSCTL_SRV_NET_SERVER_XPORT_ENUM)] == SrvNetServerTransportEnum );
    ASSERT( SrvApiDispatchTable[SRV_API_INDEX(
            FSCTL_SRV_NET_SESSION_DEL)] == SrvNetSessionDel );
    ASSERT( SrvApiDispatchTable[SRV_API_INDEX(
            FSCTL_SRV_NET_SESSION_ENUM)] == SrvNetSessionEnum );
    ASSERT( SrvApiDispatchTable[SRV_API_INDEX(
            FSCTL_SRV_NET_SHARE_ADD)] == SrvNetShareAdd );
    ASSERT( SrvApiDispatchTable[SRV_API_INDEX(
            FSCTL_SRV_NET_SHARE_DEL)] == SrvNetShareDel );
    ASSERT( SrvApiDispatchTable[SRV_API_INDEX(
            FSCTL_SRV_NET_SHARE_ENUM)] == SrvNetShareEnum );
    ASSERT( SrvApiDispatchTable[SRV_API_INDEX(
            FSCTL_SRV_NET_SHARE_SET_INFO)] == SrvNetShareSetInfo );
    ASSERT( SrvApiDispatchTable[SRV_API_INDEX(
            FSCTL_SRV_NET_STATISTICS_GET)] == SrvNetStatisticsGet );

    //
    // Setup error log records
    //

    SrvErrorRecord.AlertNumber = ALERT_ErrorLog;
    SrvNetworkErrorRecord.AlertNumber = ALERT_NetIO;

    //
    // Names for the various types of clients.  This array corresponds
    // to the SMB_DIALECT enumerated type.
    //

    for ( i = 0; i <= SmbDialectMsNet30; i++ ) {
        RtlInitUnicodeString( &SrvClientTypes[i], StrClientTypes[i] );
    }
    for ( ; i < LAST_DIALECT; i++ ) {
        SrvClientTypes[i] = SrvClientTypes[i-1]; // "DOWN LEVEL"
    }

    //
    // Initialize the timer pool.
    //

    INITIALIZE_GLOBAL_SPIN_LOCK( Timer );

    //
    // Initialize the 4 endpoint spinlocks
    //

    for ( i = 0 ; i < ENDPOINT_LOCK_COUNT ; i++ ) {
        INITIALIZE_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(i) );
    }
    //KeSetSpecialSpinLock( &ENDPOINT_SPIN_LOCK(0), "endpoint 0    " );
    //KeSetSpecialSpinLock( &ENDPOINT_SPIN_LOCK(1), "endpoint 1    " );
    //KeSetSpecialSpinLock( &ENDPOINT_SPIN_LOCK(2), "endpoint 2    " );
    //KeSetSpecialSpinLock( &ENDPOINT_SPIN_LOCK(3), "endpoint 3    " );

    //
    // Initialize the DMA alignment size
    //

    SrvCacheLineSize = KeGetRecommendedSharedDataAlignment(); // For PERF improvement, get the recommended cacheline
                                                              // alignment, instead of the HAL default

#if SRVDBG
    {
        ULONG cls = SrvCacheLineSize;
        while ( cls > 2 ) {
            ASSERTMSG(
                "SRV: cache line size not a power of two",
                (cls & 1) == 0 );
            cls = cls >> 1;
        }
    }
#endif

    if ( SrvCacheLineSize < 8 ) SrvCacheLineSize = 8;

    SrvCacheLineSize--;

    //
    // Compute the number of tick counts for 5 seconds
    //

    SrvFiveSecondTickCount = 5*10*1000*1000 / KeQueryTimeIncrement();

    return;

} // SrvInitializeData


VOID
SrvTerminateData (
    VOID
    )

/*++

Routine Description:

    This is the rundown routine for data defined in this module.  It is
    called when the server driver is unloaded.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG i;

    PAGED_CODE( );

    //
    // Terminate various (non-spin) locks.
    //

    DELETE_LOCK( &SrvConfigurationLock );
    DELETE_LOCK( &SrvStartupShutdownLock );
    DELETE_LOCK( &SrvEndpointLock );

    for( i=0; i < NMFCB_HASH_TABLE_LOCKS; i++ ) {
        DELETE_LOCK( &SrvMfcbHashTableLocks[i] );
    }

    DELETE_LOCK( &SrvShareLock );
    DELETE_LOCK( &SrvOplockBreakListLock );

#if SRVDBG || SRVDBG_HANDLES
    DELETE_LOCK( &SrvDebugLock );
#endif

    DELETE_LOCK( &SrvOrderedListLock );
    DELETE_LOCK( &SrvUnlockableCodeLock );

    ExDeleteResourceLite( &SrvXsResource );

    RtlFreeUnicodeString( &SrvCanonicalNamedPipePrefix );

    RtlFreeUnicodeString( &SrvComputerName );

} // SrvTerminateData
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\srvdebug.h ===
#ifndef _SRVDEBUG_
#define _SRVDEBUG_

#ifdef MEMPRINT
#include <memprint.h>
#endif

//
// Debugging macros
//

#ifndef DBG
#define DBG 0
#endif

#if !DBG

#undef SRVDBG
#define SRVDBG 0
#undef SRVDBG2
#define SRVDBG2 0

#define SRVFASTCALL FASTCALL

#else

#ifndef SRVDBG
#define SRVDBG 0
#endif
#ifndef SRVDBG2
#define SRVDBG2 0
#endif

#define SRVFASTCALL

#endif

#ifndef SRVDBG_LIST
#define SRVDBG_LIST 0
#endif
#ifndef SRVDBG_LOCK
#define SRVDBG_LOCK 0
#endif
#ifndef SRVDBG_STATS
#define SRVDBG_STATS 0
#endif
#ifndef SRVDBG_STATS2
#define SRVDBG_STATS2 0
#endif
#ifndef SRVDBG_HANDLES
#define SRVDBG_HANDLES 0
#endif

#undef IF_DEBUG
#undef IF_SMB_DEBUG

#if 0
#define STATIC static
#else
#define STATIC
#endif

#define DEBUG_TRACE1              (ULONGLONG)0x0000000000000001
#define DEBUG_TRACE2              (ULONGLONG)0x0000000000000002
#define DEBUG_REFCNT              (ULONGLONG)0x0000000000000004
#define DEBUG_HEAP                (ULONGLONG)0x0000000000000008

#define DEBUG_WORKER1             (ULONGLONG)0x0000000000000010
#define DEBUG_WORKER2             (ULONGLONG)0x0000000000000020
#define DEBUG_NET1                (ULONGLONG)0x0000000000000040
#define DEBUG_NET2                (ULONGLONG)0x0000000000000080

#define DEBUG_FSP1                (ULONGLONG)0x0000000000000100
#define DEBUG_FSP2                (ULONGLONG)0x0000000000000200
#define DEBUG_FSD1                (ULONGLONG)0x0000000000000400
#define DEBUG_FSD2                (ULONGLONG)0x0000000000000800

#define DEBUG_SCAV1               (ULONGLONG)0x0000000000001000
#define DEBUG_SCAV2               (ULONGLONG)0x0000000000002000
#define DEBUG_BLOCK1              (ULONGLONG)0x0000000000004000
#define DEBUG_IPX_PIPES           (ULONGLONG)0x0000000000008000

#define DEBUG_HANDLES             (ULONGLONG)0x0000000000010000
#define DEBUG_IPX                 (ULONGLONG)0x0000000000020000
#define DEBUG_TDI                 (ULONGLONG)0x0000000000040000
#define DEBUG_OPLOCK              (ULONGLONG)0x0000000000080000

#define DEBUG_NETWORK_ERRORS      (ULONGLONG)0x0000000000100000
#define DEBUG_FILE_CACHE          (ULONGLONG)0x0000000000200000
#define DEBUG_IPX2                (ULONGLONG)0x0000000000400000
#define DEBUG_LOCKS               (ULONGLONG)0x0000000000800000

#define DEBUG_SEARCH              (ULONGLONG)0x0000000001000000
#define DEBUG_BRUTE_FORCE_REWIND  (ULONGLONG)0x0000000002000000
#define DEBUG_COMM                (ULONGLONG)0x0000000004000000
#define DEBUG_XACTSRV             (ULONGLONG)0x0000000008000000

#define DEBUG_API_ERRORS          (ULONGLONG)0x0000000010000000
#define DEBUG_STOP_ON_ERRORS      (ULONGLONG)0x0000000020000000 // If set, stop on internal errs
#define DEBUG_SMB_ERRORS          (ULONGLONG)0x0000000040000000
#define DEBUG_ERRORS              (ULONGLONG)0x0000000080000000

#define DEBUG_LICENSE             (ULONGLONG)0x0000000100000000
#define DEBUG_WORKITEMS           (ULONGLONG)0x0000000200000000
#define DEBUG_IPXNAMECLAIM        (ULONGLONG)0x0000000400000000

#define DEBUG_SENDS2OTHERCPU      (ULONGLONG)0x0000001000000000
#define DEBUG_REBALANCE           (ULONGLONG)0x0000002000000000
#define DEBUG_PNP                 (ULONGLONG)0x0000004000000000
#define DEBUG_SNAPSHOT            (ULONGLONG)0x0000008000000000

#define DEBUG_DFS                 (ULONGLONG)0x0000010000000000
#define DEBUG_SIPX                (ULONGLONG)0x0000020000000000
#define DEBUG_CREATE              (ULONGLONG)0x0000080000000000

#define DEBUG_SECSIG              (ULONGLONG)0x0000100000000000
#define DEBUG_STUCK_OPLOCK        (ULONGLONG)0x0000200000000000

//
// SMB debug flags.
//

#define DEBUG_SMB_ADMIN1          (ULONGLONG)0x0000000000000001
#define DEBUG_SMB_ADMIN2          (ULONGLONG)0x0000000000000002

#define DEBUG_SMB_TREE1           (ULONGLONG)0x0000000000000004
#define DEBUG_SMB_TREE2           (ULONGLONG)0x0000000000000008

#define DEBUG_SMB_DIRECTORY1      (ULONGLONG)0x0000000000000010
#define DEBUG_SMB_DIRECTORY2      (ULONGLONG)0x0000000000000020

#define DEBUG_SMB_OPEN_CLOSE1     (ULONGLONG)0x0000000000000040
#define DEBUG_SMB_OPEN_CLOSE2     (ULONGLONG)0x0000000000000080

#define DEBUG_SMB_FILE_CONTROL1   (ULONGLONG)0x0000000000000100
#define DEBUG_SMB_FILE_CONTROL2   (ULONGLONG)0x0000000000000200

#define DEBUG_SMB_READ_WRITE1     (ULONGLONG)0x0000000000000400
#define DEBUG_SMB_READ_WRITE2     (ULONGLONG)0x0000000000000800

#define DEBUG_SMB_LOCK1           (ULONGLONG)0x0000000000001000
#define DEBUG_SMB_LOCK2           (ULONGLONG)0x0000000000002000

#define DEBUG_SMB_RAW1            (ULONGLONG)0x0000000000004000
#define DEBUG_SMB_RAW2            (ULONGLONG)0x0000000000008000

#define DEBUG_SMB_MPX1            (ULONGLONG)0x0000000000010000
#define DEBUG_SMB_MPX2            (ULONGLONG)0x0000000000020000

#define DEBUG_SMB_SEARCH1         (ULONGLONG)0x0000000000040000
#define DEBUG_SMB_SEARCH2         (ULONGLONG)0x0000000000080000

#define DEBUG_SMB_TRANSACTION1    (ULONGLONG)0x0000000000100000
#define DEBUG_SMB_TRANSACTION2    (ULONGLONG)0x0000000000200000

#define DEBUG_SMB_PRINT1          (ULONGLONG)0x0000000000400000
#define DEBUG_SMB_PRINT2          (ULONGLONG)0x0000000000800000

#define DEBUG_SMB_MESSAGE1        (ULONGLONG)0x0000000001000000
#define DEBUG_SMB_MESSAGE2        (ULONGLONG)0x0000000002000000

#define DEBUG_SMB_MISC1           (ULONGLONG)0x0000000004000000
#define DEBUG_SMB_MISC2           (ULONGLONG)0x0000000008000000

#define DEBUG_SMB_QUERY_SET1      (ULONGLONG)0x0000000010000000
#define DEBUG_SMB_QUERY_SET2      (ULONGLONG)0x0000000020000000

#define DEBUG_SMB_TRACE           (ULONGLONG)0x0000000100000000

// Which WMI events should be built into the server?
#define BUILD_FLAGS (DEBUG_SMB_ERRORS | DEBUG_ERRORS | DEBUG_NETWORK_ERRORS | DEBUG_SNAPSHOT)
#define BUILD_FLAGS_SMB (0)

#define IF_DEBUG(flag) if (BUILD_FLAGS & DEBUG_ ## flag) \
                            if ( SRV_WMI_LEVEL( VERBOSE ) && SRV_WMI_FLAGON( ERRORS ) && (KeGetCurrentIrql() < DISPATCH_LEVEL) )
#define IF_SMB_DEBUG(flag) if (BUILD_FLAGS_SMB & DEBUG_SMB_ ## flag) \
                            if ( SRV_WMI_LEVEL( VERBOSE ) && SRV_WMI_FLAGON( ERRORS ) && (KeGetCurrentIrql() < DISPATCH_LEVEL) )

#define IF_STRESS() if( SRV_WMI_LEVEL( VERBOSE ) && SRV_WMI_FLAGON( STRESS ) && (KeGetCurrentIrql() < DISPATCH_LEVEL) )

#ifdef SYSCACHE_DEBUGGING
#define IF_SYSCACHE() if( SRV_WMI_LEVEL( VERBOSE ) && SRV_WMI_FLAGON( SYSCACHE ) && (KeGetCurrentIrql() < DISPATCH_LEVEL) )
#define IF_SYSCACHE_RFCB( INRFCB ) if( (INRFCB->SrvCatch < 0) && SRV_WMI_LEVEL( VERBOSE ) && SRV_WMI_FLAGON( SYSCACHE ) && (KeGetCurrentIrql() < DISPATCH_LEVEL) )
#else
#define IF_SYSCACHE() if( FALSE )
#define IF_SYSCACHE_RFCB( INRFCB ) if( FALSE )
#endif

#if !SRVDBG

#define DEBUG if (FALSE)

#define SrvPrint0(fmt)  KdPrint((fmt))
#define SrvPrint1(fmt,v0) KdPrint((fmt,v0))
#define SrvPrint2(fmt,v0,v1) KdPrint((fmt,v0,v1))
#define SrvPrint3(fmt,v0,v1,v2) KdPrint((fmt,v0,v1,v2))
#define SrvPrint4(fmt,v0,v1,v2,v3) KdPrint((fmt,v0,v1,v2,v3))

#define SrvHPrint0(fmt)
#define SrvHPrint1(fmt,v0)
#define SrvHPrint2(fmt,v0,v1)
#define SrvHPrint3(fmt,v0,v1,v2)
#define SrvHPrint4(fmt,v0,v1,v2,v3)

#else

#define SrvHPrint0(fmt) DbgPrint( fmt )
#define SrvHPrint1(fmt,v0) DbgPrint( fmt, v0 )
#define SrvHPrint2(fmt,v0,v1) DbgPrint( fmt, v0, v1 )
#define SrvHPrint3(fmt,v0,v1,v2) DbgPrint( fmt, v0, v1, v2 )
#define SrvHPrint4(fmt,v0,v1,v2,v3) DbgPrint( fmt, v0, v1, v2, v3 )

#define DEBUG if (TRUE)

#define SrvPrint0(fmt) DbgPrint((fmt))
#define SrvPrint1(fmt,v0) DbgPrint((fmt),(v0))
#define SrvPrint2(fmt,v0,v1) DbgPrint((fmt),(v0),(v1))
#define SrvPrint3(fmt,v0,v1,v2) DbgPrint((fmt),(v0),(v1),(v2))
#define SrvPrint4(fmt,v0,v1,v2,v3) DbgPrint((fmt),(v0),(v1),(v2),(v3))

#define PRINT_LITERAL(literal) DbgPrint( #literal" = %lx\n", (literal) )


#endif // else !SRVDBG

//
// Macros for list debugging.  These verify that lists are good whenever
// a list operation is made.
//

#if SRVDBG_LIST || SRVDBG_LOCK
ULONG
SrvCheckListIntegrity (
    IN PLIST_ENTRY ListHead,
    IN ULONG MaxEntries
    );
#endif

#if !SRVDBG_LIST

#define SrvInsertHeadList(head,entry) InsertHeadList(head,entry)
#define SrvInsertTailList(head,entry) InsertTailList(head,entry)
#define SrvRemoveEntryList(head,entry) RemoveEntryList(entry)

#else // !SRVDBG_LIST

VOID
SrvIsEntryInList (
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY ListEntry
    );

VOID
SrvIsEntryNotInList (
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY ListEntry
    );

#define SrvInsertHeadList(head,entry)                        \
            (VOID)SrvCheckListIntegrity( head, 0xFFFFFFFF ); \
            SrvIsEntryNotInList(head,entry);                 \
            InsertHeadList(head,entry)

#define SrvInsertTailList(head,entry)                        \
            (VOID)SrvCheckListIntegrity( head, 0xFFFFFFFF ); \
            SrvIsEntryNotInList(head,entry);                 \
            InsertTailList(head,entry)

#define SrvRemoveEntryList(head,entry)                       \
            (VOID)SrvCheckListIntegrity( head, 0xFFFFFFFF ); \
            SrvIsEntryInList( head, entry );                 \
            RemoveEntryList(entry)

#endif // else !SRVDBG_LIST

//
// Macros for statistics arithmetics.
//

#if !SRVDBG_STATS
#define INCREMENT_DEBUG_STAT( _stat_ )
#define DECREMENT_DEBUG_STAT( _stat_ )
#else // !SRVDBG_STATS
#define INCREMENT_DEBUG_STAT( _stat_ ) (_stat_)++
#define DECREMENT_DEBUG_STAT( _stat_ ) (_stat_)--
#endif // else !SRVDBG_STATS
#if !SRVDBG_STATS2
#define INCREMENT_DEBUG_STAT2( _stat_ )
#define DECREMENT_DEBUG_STAT2( _stat_ )
#else // !SRVDBG_STATS2
#define INCREMENT_DEBUG_STAT2( _stat_ ) (_stat_)++
#define DECREMENT_DEBUG_STAT2( _stat_ ) (_stat_)--
#endif // else !SRVDBG_STATS2

//
// Macros for handle tracing.
//

#if !SRVDBG_HANDLES

#define SRVDBG_CLAIM_HANDLE(_a_,_b_,_c_,_d_)
#define SRVDBG_RELEASE_HANDLE(_a_,_b_,_c_,_d_)

#else

VOID
SrvdbgClaimOrReleaseHandle (
    IN HANDLE Handle,
    IN PSZ HandleType,
    IN ULONG Location,
    IN BOOLEAN Release,
    IN PVOID Data
    );
#define SRVDBG_CLAIM_HANDLE(_a_,_b_,_c_,_d_) SrvdbgClaimOrReleaseHandle((_a_),(_b_),(_c_),FALSE,(_d_))
#define SRVDBG_RELEASE_HANDLE(_a_,_b_,_c_,_d_) SrvdbgClaimOrReleaseHandle((_a_),(_b_),(_c_),TRUE,(_d_))

#endif

#endif // ndef _SRVDEBUG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\srvdata.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    srvdata.h

Abstract:

    This module defines global data for the LAN Manager server.

Author:

    Chuck Lenzmeier (chuckl)    22-Sep-1989

Revision History:

--*/

#ifndef _SRVDATA_
#define _SRVDATA_

//#include <ntos.h>

//#include "lock.h"
//#include "srvconst.h"
//#include "smbtypes.h"

//
// All global variables referenced in this module are defined in
// srvdata.c.  See that module for complete descriptions.
//
// The variables referenced herein, because they are part of the driver
// image, are not pageable.  However, some of the things pointed to by
// these variables are in the FSP's address space and are pageable.
// These variables are only accessed by the FSP, and only at low IRQL.
// Any data referenced by the FSP at elevated IRQL or by the FSD must
// be nonpageable.
//

//
// Routine to initialize data structures contained herein that cannot
// be statically initialized.
//

VOID
SrvInitializeData (
    VOID
    );

//
// Routine to clean up global server data when the driver is unloaded.
//

VOID
SrvTerminateData (
    VOID
    );


//
// Address of the server device object.
//

extern PDEVICE_OBJECT SrvDeviceObject;

//
// Fields describing the state of the FSP.
//

extern BOOLEAN SrvFspActive;             // Indicates whether the FSP is running
extern BOOLEAN SrvFspTransitioning;      // Indicates that the server is in the
                                         // process of starting up or
                                         // shutting down

extern PEPROCESS SrvServerProcess;       // Pointer to the initial system process

extern PEPROCESS SrvSvcProcess;          // Pointer to the service controller process

extern BOOLEAN SrvCompletedPNPRegistration; // Indicates whether the FSP has completed
                                            //  registering for PNP notifications

//
// Endpoint variables.  SrvEndpointCount is used to count the number of
// active endpoints.  When the last endpoint is closed, SrvEndpointEvent
// is set so that the thread processing the shutdown request continues
// server termination.
//

extern CLONG SrvEndpointCount;          // Number of transport endpoints
extern KEVENT SrvEndpointEvent;         // Signaled when no active endpoints

//
// DMA alignment size
//
extern ULONG SrvCacheLineSize;

//
// Global spin locks.
//

extern SRV_GLOBAL_SPIN_LOCKS SrvGlobalSpinLocks;

#if SRVDBG || SRVDBG_HANDLES
//
// Lock used to protect debugging structures.
//

extern SRV_LOCK SrvDebugLock;
#endif

//
// SrvConfigurationLock is used to synchronize configuration requests.
//

extern SRV_LOCK SrvConfigurationLock;

//
// SrvStartupShutdownLock is used to synchronize driver starting and stopping
//

extern SRV_LOCK SrvStartupShutdownLock;

//
// SrvEndpointLock serializes access to the global endpoint list and
// all endpoints.  Note that the list of connections in each endpoint
// is also protected by this lock.
//

extern SRV_LOCK SrvEndpointLock;

//
// SrvShareLock protects all shares.
//

extern SRV_LOCK SrvShareLock;

//
// The number of processors in the system
//
extern ULONG SrvNumberOfProcessors;

//
// Work queues -- nonblocking, blocking, and critical.
//

#if MULTIPROCESSOR
extern PBYTE SrvWorkQueuesBase;
extern PWORK_QUEUE SrvWorkQueues;
extern PBYTE SrvBlockingWorkQueuesBase;
extern PWORK_QUEUE SrvBlockingWorkQueues;
#else
extern WORK_QUEUE SrvWorkQueues[1];
#endif

extern WORK_QUEUE SrvLpcWorkQueue;

extern PWORK_QUEUE eSrvWorkQueues;          // used to terminate 'for' loops
extern PWORK_QUEUE eSrvBlockingWorkQueues;

extern ULONG SrvReBalanced;                 // how often we've picked another CPU
extern ULONG SrvNextBalanceProcessor;       // Which processor we'll look for next

extern CLONG SrvBlockingOpsInProgress;

//
// Various list heads.
//

extern LIST_ENTRY SrvNeedResourceQueue;    // The need resource queue
extern LIST_ENTRY SrvDisconnectQueue;      // The disconnect queue

//
// Queue of connections that needs to be dereferenced.
//

extern SLIST_HEADER SrvBlockOrphanage;

//
// FSP configuration queue.  The FSD puts configuration request IRPs
// (from NtDeviceIoControlFile) on this queue, and it is serviced by an
// EX worker thread.
//

extern LIST_ENTRY SrvConfigurationWorkQueue;

//
// This is the number of configuration IRPs which have been queued but not
//  yet completed.
//
extern ULONG SrvConfigurationIrpsInProgress;

//
// Work item for running the configuration thread in the context of an
// EX worker thread.

extern WORK_QUEUE_ITEM SrvConfigurationThreadWorkItem[ MAX_CONFIG_WORK_ITEMS ];

//
// Base address of the large block allocated to hold initial normal
// work items (see blkwork.c\SrvAllocateInitialWorkItems).
//

extern PVOID SrvInitialWorkItemBlock;

//
// Work item used to run the resource thread.  Booleans used to inform
// the resource thread to continue running.
//

extern WORK_QUEUE_ITEM SrvResourceThreadWorkItem;
extern BOOLEAN SrvResourceThreadRunning;
extern BOOLEAN SrvResourceDisconnectPending;


extern WORK_QUEUE_ITEM SrvResourceAllocThreadWorkItem;
extern BOOLEAN SrvResourceAllocThreadRunning;
extern BOOLEAN SrvResourceAllocConnection;
extern LONG SrvResourceOrphanedBlocks;

//
// Denial of Service monitoring variables for the Resource Thread
//
#define SRV_DOS_MINIMUM_DOS_WAIT_PERIOD (50*1000*10)
#define SRV_DOS_TEARDOWN_MIN (LONG)MAX((SrvMaxReceiveWorkItemCount>>4),32)
#define SRV_DOS_TEARDOWN_MAX (LONG)(SrvMaxReceiveWorkItemCount>>1)
#define SRV_DOS_INCREASE_TEARDOWN() {                                               \
    LONG lTearDown = InterlockedCompareExchange( &SrvDoSWorkItemTearDown, 0, 0 );    \
    LONG lNewTearDown = MIN(lTearDown+(lTearDown>>2), SRV_DOS_TEARDOWN_MAX);        \
    SrvDoSRundownIncreased = TRUE;                                                  \
    InterlockedCompareExchange( &SrvDoSWorkItemTearDown, lNewTearDown, lTearDown );  \
}
#define SRV_DOS_DECREASE_TEARDOWN() {                                               \
    LONG lTearDown = InterlockedCompareExchange( &SrvDoSWorkItemTearDown, 0, 0 );    \
    LONG lNewTearDown = MAX(lTearDown-(SRV_DOS_TEARDOWN_MIN), SRV_DOS_TEARDOWN_MIN);        \
    if( lNewTearDown == SRV_DOS_TEARDOWN_MIN ) SrvDoSRundownIncreased = FALSE;      \
    InterlockedCompareExchange( &SrvDoSWorkItemTearDown, lNewTearDown, lTearDown );  \
}
#define SRV_DOS_GET_TEARDOWN()  InterlockedCompareExchange( &SrvDoSWorkItemTearDown, 0, 0 )
#define SRV_DOS_IS_TEARDOWN_IN_PROGRESS() InterlockedCompareExchange( &SrvDoSTearDownInProgress, 0, 0 )
#define SRV_DOS_CAN_START_TEARDOWN() !InterlockedCompareExchange( &SrvDoSTearDownInProgress, 1, 0 )
#define SRV_DOS_COMPLETE_TEARDOWN() InterlockedCompareExchange( &SrvDoSTearDownInProgress, 0, 1 )
extern LONG SrvDoSWorkItemTearDown;
extern LONG SrvDoSTearDownInProgress;      // Is a teardown in progress?
extern BOOLEAN SrvDoSDetected;
extern BOOLEAN SrvDoSRundownDetector;      // Used to rundown the teardown amounts
extern BOOLEAN SrvDoSRundownIncreased;     // Have we increased the Rundown past the minimum
extern BOOLEAN SrvDisableDoSChecking;
extern SPECIAL_WORK_ITEM SrvDoSWorkItem;
extern KSPIN_LOCK SrvDosSpinLock;
extern LARGE_INTEGER SrvDoSLastRan;

//
// Should we disable strict name checking
//
extern BOOLEAN SrvDisableStrictNameChecking;

//
// Should we disable large read/write ops?
//
extern BOOLEAN SrvDisableLargeRead;
extern BOOLEAN SrvDisableLargeWrite;

//
// Should we disable downlevel timewarp
//
extern BOOLEAN SrvDisableDownlevelTimewarp;

//
// Can the client do name-space caching (Global setting)
//
extern BOOLEAN SrvNoAliasingOnFilesystem;

//
// Should we map no-intermediate-buffering into write-through
//
extern BOOLEAN SrvMapNoIntermediateBuffering;

//
// Generic security mapping for connecting to shares
//
extern GENERIC_MAPPING SrvShareConnectMapping;

//
// What's the minumum # of free work items each processor should have?
//
extern ULONG SrvMinPerProcessorFreeWorkItems;

//
// The server has callouts to enable a smart card to accelerate its direct
//  host IPX performance.  This is the vector of entry points.
//
extern SRV_IPX_SMART_CARD SrvIpxSmartCard;

//
// This is the name of the server computer.  Returned in the negprot response
//
extern UNICODE_STRING SrvComputerName;

//
// The master file table contains one entry for each named file that has
// at least one open instance.
//
extern MFCBHASH SrvMfcbHashTable[ NMFCB_HASH_TABLE ];

//
// The share table contains one entry for each share
//
extern LIST_ENTRY SrvShareHashTable[ NSHARE_HASH_TABLE ];

//
// Hex digits array used by the dump routines and SrvSmbCreateTemporary.
//

extern CHAR SrvHexChars[];

#if SRVCATCH
//
// Are we looking for the special file?
//
extern UNICODE_STRING SrvCatch;
extern PWSTR *SrvCatchBuf;
extern UNICODE_STRING SrvCatchExt;
extern PWSTR *SrvCatchExtBuf;
extern ULONG SrvCatchShares;
extern PWSTR *SrvCatchShareNames;
#endif

//
// SMB dispatch table
//

extern UCHAR SrvSmbIndexTable[];

//
// This is an enum structure that enumerates all the routines in the
// SrvSmbDispatchTable.  This is done for convenience only.  Note that
// this will only work if this list corresponds exactly to
// SrvSmbDispatchTable.
//

typedef enum _SRV_SMB_INDEX {
    ISrvSmbIllegalCommand,
    ISrvSmbCreateDirectory,
    ISrvSmbDeleteDirectory,
    ISrvSmbOpen,
    ISrvSmbCreate,
    ISrvSmbClose,
    ISrvSmbFlush,
    ISrvSmbDelete,
    ISrvSmbRename,
    ISrvSmbQueryInformation,
    ISrvSmbSetInformation,
    ISrvSmbRead,
    ISrvSmbWrite,
    ISrvSmbLockByteRange,
    ISrvSmbUnlockByteRange,
    ISrvSmbCreateTemporary,
    ISrvSmbCheckDirectory,
    ISrvSmbProcessExit,
    ISrvSmbSeek,
    ISrvSmbLockAndRead,
    ISrvSmbSetInformation2,
    ISrvSmbQueryInformation2,
    ISrvSmbLockingAndX,
    ISrvSmbTransaction,
    ISrvSmbTransactionSecondary,
    ISrvSmbIoctl,
    ISrvSmbIoctlSecondary,
    ISrvSmbMove,
    ISrvSmbEcho,
    ISrvSmbOpenAndX,
    ISrvSmbReadAndX,
    ISrvSmbWriteAndX,
    ISrvSmbFindClose2,
    ISrvSmbFindNotifyClose,
    ISrvSmbTreeConnect,
    ISrvSmbTreeDisconnect,
    ISrvSmbNegotiate,
    ISrvSmbSessionSetupAndX,
    ISrvSmbLogoffAndX,
    ISrvSmbTreeConnectAndX,
    ISrvSmbQueryInformationDisk,
    ISrvSmbSearch,
    ISrvSmbNtTransaction,
    ISrvSmbNtTransactionSecondary,
    ISrvSmbNtCreateAndX,
    ISrvSmbNtCancel,
    ISrvSmbOpenPrintFile,
    ISrvSmbClosePrintFile,
    ISrvSmbGetPrintQueue,
    ISrvSmbReadRaw,
    ISrvSmbWriteRaw,
    ISrvSmbReadMpx,
    ISrvSmbWriteMpx,
    ISrvSmbWriteMpxSecondary
} SRV_SMB_INDEX;

typedef struct {
    PSMB_PROCESSOR  Func;
#if DBG
    LPSTR           Name;
#endif
} SRV_SMB_DISPATCH_TABLE;

extern SRV_SMB_DISPATCH_TABLE SrvSmbDispatchTable[];

//
// SMB word count table.
//

extern SCHAR SrvSmbWordCount[];

//
// Device prefix strings.
//

extern UNICODE_STRING SrvCanonicalNamedPipePrefix;
extern UNICODE_STRING SrvNamedPipeRootDirectory;
extern UNICODE_STRING SrvMailslotRootDirectory;

//
// Transaction2 dispatch table
//

extern PSMB_TRANSACTION_PROCESSOR SrvTransaction2DispatchTable[];
extern PSMB_TRANSACTION_PROCESSOR SrvNtTransactionDispatchTable[];

extern SRV_STATISTICS SrvStatistics;
#if SRVDBG_STATS || SRVDBG_STATS2
extern SRV_STATISTICS_DEBUG SrvDbgStatistics;
#endif

//
// The number of abortive disconnects that the server has gotten
//
extern ULONG SrvAbortiveDisconnects;

//
// Server environment information strings.
//

extern UNICODE_STRING SrvNativeOS;
extern OEM_STRING SrvOemNativeOS;
extern UNICODE_STRING SrvNativeLanMan;
extern OEM_STRING SrvOemNativeLanMan;
extern UNICODE_STRING SrvSystemRoot;

//
// The following will be a permanent handle and device object pointer
// to NPFS.
//

extern HANDLE SrvNamedPipeHandle;
extern PDEVICE_OBJECT SrvNamedPipeDeviceObject;
extern PFILE_OBJECT SrvNamedPipeFileObject;

//
// The following are used to converse with the Dfs driver
//
extern PFAST_IO_DEVICE_CONTROL SrvDfsFastIoDeviceControl;
extern PDEVICE_OBJECT SrvDfsDeviceObject;
extern PFILE_OBJECT SrvDfsFileObject;

//
// The following will be a permanent handle and device object pointer
// to MSFS.
//

extern HANDLE SrvMailslotHandle;
extern PDEVICE_OBJECT SrvMailslotDeviceObject;
extern PFILE_OBJECT SrvMailslotFileObject;

//
// Flag indicating XACTSRV whether is active, and resource synchronizing
// access to XACTSRV-related variabled.
//

extern BOOLEAN SrvXsActive;

extern ERESOURCE SrvXsResource;

//
// Handle to the unnamed shared memory and communication port used for
// communication between the server and XACTSRV.
//

extern HANDLE SrvXsSectionHandle;
extern HANDLE SrvXsPortHandle;

//
// Pointers to control the unnamed shared memory for the XACTSRV LPC port.
//

extern PVOID SrvXsPortMemoryBase;
extern ULONG_PTR SrvXsPortMemoryDelta;
extern PVOID SrvXsPortMemoryHeap;

//
// Pointer to heap header for the special XACTSRV shared-memory heap.
//

extern PVOID SrvXsHeap;

//
// Dispatch table for handling server API requests.
//

extern PAPI_PROCESSOR SrvApiDispatchTable[];

//
// Names for the various types of clients.
//

extern UNICODE_STRING SrvClientTypes[];

//
// All the resumable Enum APIs use ordered lists for context-free
// resume.  All data blocks in the server that correspond to return
// information for Enum APIs are maintained in ordered lists.
//

extern SRV_LOCK SrvOrderedListLock;

extern ORDERED_LIST_HEAD SrvEndpointList;
extern ORDERED_LIST_HEAD SrvRfcbList;
extern ORDERED_LIST_HEAD SrvSessionList;
extern ORDERED_LIST_HEAD SrvShareList;
extern ORDERED_LIST_HEAD SrvTreeConnectList;

// The DNS domain name for the domain
extern PUNICODE_STRING SrvDnsDomainName;

//
// To synchronize server shutdown with API requests handled in the
// server FSD, we track the number of outstanding API requests.  The
// shutdown code waits until all APIs have been completed to start
// termination.
//
// SrvApiRequestCount tracks the active APIs in the FSD.
// SrvApiCompletionEvent is set by the last API to complete, and the
// shutdown code waits on it if there are outstanding APIs.
//

extern ULONG SrvApiRequestCount;
extern KEVENT SrvApiCompletionEvent;


//
// Security contexts required for mutual authentication.
// SrvKerberosLsaHandle and SrvLmLsaHandle are credentials of the server
// principal. They are used to validate incoming kerberos tickets.
// SrvNullSessionToken is a cached token handle representing the null session.
//
extern CtxtHandle SrvLmLsaHandle;
extern CtxtHandle SrvNullSessionToken;


extern CtxtHandle SrvExtensibleSecurityHandle;

//
// Oplock break information.
//

extern LIST_ENTRY SrvWaitForOplockBreakList;
extern SRV_LOCK SrvOplockBreakListLock;
extern LIST_ENTRY SrvOplockBreaksInProgressList;

//
// The default server security quality of service.
//

extern SECURITY_QUALITY_OF_SERVICE SrvSecurityQOS;

//
// A BOOLEAN to indicate whether the server is paused.  If paused, the
// server will not accept new tree connections from non-admin users.
//

extern BOOLEAN SrvPaused;

//
// Alerting information.
//

extern SRV_ERROR_RECORD SrvErrorRecord;
extern SRV_ERROR_RECORD SrvNetworkErrorRecord;
extern BOOLEAN SrvDiskAlertRaised[26];

//
// Counts of the number of times pool allocations have failed because
// the server was at its configured pool limit.
//

extern ULONG SrvNonPagedPoolLimitHitCount;
extern ULONG SrvPagedPoolLimitHitCount;

//
// SrvOpenCount counts the number of active opens of the server device.
// This is used at server shutdown time to determine whether the server
// service should unload the driver.
//

extern ULONG SrvOpenCount;

//
// Counters for logging resource shortage events during a scavenger pass.
//

extern ULONG SrvOutOfFreeConnectionCount;
extern ULONG SrvOutOfRawWorkItemCount;
extern ULONG SrvFailedBlockingIoCount;

//
// Current core search timeout time in seconds
//

extern ULONG SrvCoreSearchTimeout;

//
// SrvTimerList is a pool of timer/DPC structures available for use by
// code that needs to start a timer.
//

extern SLIST_HEADER SrvTimerList;

//
// Name that should be displayed when doing a server alert.
//

extern PWSTR SrvAlertServiceName;

//
// Variable to store the number of tick counts for 5 seconds
//

extern ULONG SrvFiveSecondTickCount;

//
// Holds the PNP notification handle for TDI
//
extern HANDLE SrvTdiNotificationHandle;

//
// Should we log invalid SMB commands
//
extern BOOLEAN SrvEnableInvalidSmbLogging;

//
// Flag indicating whether or not SMB security signatures are enabled.
//
extern BOOLEAN SrvSmbSecuritySignaturesEnabled;

//
// Flag indicating whether or not SMB security signatures are required.  The signature
//   must match between the client and the server for the smb to be accepted.
//
extern BOOLEAN SrvSmbSecuritySignaturesRequired;

//
// Flag indicating whether or not SMB security signatures should be applied to W9x
// clients.
//
extern BOOLEAN SrvEnableW9xSecuritySignatures;

//
// Security descriptor granting Administrator READ access.
//  Used to see if a client has administrative privileges
//
extern SECURITY_DESCRIPTOR SrvAdminSecurityDescriptor;

//
// Security descriptor granting Anonymous READ access.
//  Used to see if a client was an anonymous (null session) logon
//
extern SECURITY_DESCRIPTOR SrvNullSessionSecurityDescriptor;

//
// Flag indicating whether or not we need to filter extended characters
//  out of 8.3 names ourselves.
//
extern BOOLEAN SrvFilterExtendedCharsInPath;

//
// Flag indicating whether we enforce logoff times
//
extern BOOLEAN SrvEnforceLogoffTimes;

//
// Maximum amount of data that we'll allocate to support a METHOD_NEITHER Fsctl call
//
extern ULONG SrvMaxFsctlBufferSize;

//
// Should we try to do extended security signatures
//
extern BOOLEAN SrvEnableExtendedSignatures;
extern BOOLEAN SrvRequireExtendedSignatures;

//
// Maximum NT transaction size which we'll accept.
//
extern ULONG SrvMaxNtTransactionSize;

//
// Maximum size of large Read&X that we'll allow.  We need to lock down a cache region
//  to service this request, so we don't want it to get too big
//
extern ULONG SrvMaxReadSize;

//
// When we receive an large write from a client, we receive it in chunks,
//  locking & unlocking the file cache as we receive the data.  SrvMaxWriteChunk is the
//  size of this 'chunk'.  There's no magic to this chosen value.
//
extern ULONG SrvMaxWriteChunk;

//
// Handle used for PoRegisterSystemState calls
//
extern PVOID SrvPoRegistrationState;

//
// Counter used to suppress extraneous PoRegisterSystemStateCalls
//
extern ULONG SrvIdleCount;

#if SRVNTVERCHK
//
// This is the minimum NT5 client build number that we will allow to connect to the server
//
extern ULONG SrvMinNT5Client;
extern BOOLEAN SrvMinNT5ClientIPCToo;

//
// To force upgrades of our internal development community, we can set a
//  value in the registry that governs the minimum NT release that we allow
//  people to run to connect to this server.  However, some folks have special
//  needs that preclude a forced upgrade.  Presuming they have a static IP address,
//  you can add their address to the registry to exclude them from the build number
//  checking logic
//
extern DWORD SrvAllowIPAddress[25];

//
// If a server worker threads remains idle for this many ticks, then it terminate
//
extern LONGLONG SrvIdleThreadTimeOut;

extern LARGE_INTEGER SrvLastDosAttackTime;
extern ULONG SrvDOSAttacks;
extern BOOLEAN SrvLogEventOnDOS;

#endif

//
//  These are used for internal testing of the reauthentication code
//
extern USHORT SessionInvalidateCommand;
extern USHORT SessionInvalidateMod;

typedef struct _SRV_REAUTH_TEST_
{
    USHORT InvalidateCommand;
    USHORT InvalidateModulo;
} SRV_REAUTH_TEST, *PSRV_REAUTH_TEST;

//
// These are used for LWIO server extensions
//
extern PBYTE SrvLWIOContext;
extern ULONG SrvLWIOContextLength;
extern PSRV_RESUME_CONTEXT_CALLBACK SrvLWIOCallback;

#endif // ndef _SRVDATA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\srvfsd.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    srvfsd.h

Abstract:

    This module defines routines in the File System Driver for the LAN
    Manager server.

Author:

    Chuck Lenzmeier (chuckl) 1-Dec-1989

Revision History:

--*/

#ifndef _SRVFSD_
#define _SRVFSD_

//#include "srvblock.h"

#include "wmilib.h"

typedef struct _DEVICE_EXTENSION {
    PDEVICE_OBJECT pDeviceObject;
    ULONG          TestCounter;
    WMILIB_CONTEXT WmiLibContext;
} DEVICE_EXTENSION, * PDEVICE_EXTENSION;

typedef enum _tagSrvWmiEvents {
    EVENT_TYPE_SMB_CREATE_DIRECTORY,
    EVENT_TYPE_SMB_DELETE_DIRECTORY,
    EVENT_TYPE_SMB_OPEN,
    EVENT_TYPE_SMB_CREATE,
    EVENT_TYPE_SMB_CLOSE,
    EVENT_TYPE_SMB_FLUSH,
    EVENT_TYPE_SMB_DELETE,
    EVENT_TYPE_SMB_RENAME,
    EVENT_TYPE_SMB_QUERY_INFORMATION,
    EVENT_TYPE_SMB_SET_INFORMATION,
    EVENT_TYPE_SMB_READ,
    EVENT_TYPE_SMB_WRITE,
    EVENT_TYPE_SMB_LOCK_BYTE_RANGE,
    EVENT_TYPE_SMB_UNLOCK_BYTE_RANGE,
    EVENT_TYPE_SMB_CREATE_TEMPORARY,
    EVENT_TYPE_SMB_CHECK_DIRECTORY,
    EVENT_TYPE_SMB_PROCESS_EXIT,
    EVENT_TYPE_SMB_SEEK,
    EVENT_TYPE_SMB_LOCK_AND_READ,
    EVENT_TYPE_SMB_SET_INFORMATION2,
    EVENT_TYPE_SMB_QUERY_INFORMATION2,
    EVENT_TYPE_SMB_LOCKING_AND_X,
    EVENT_TYPE_SMB_TRANSACTION,
    EVENT_TYPE_SMB_TRANSACTION_SECONDARY,
    EVENT_TYPE_SMB_IOCTL,
    EVENT_TYPE_SMB_IOCTL_SECONDARY,
    EVENT_TYPE_SMB_MOVE,
    EVENT_TYPE_SMB_ECHO,
    EVENT_TYPE_SMB_OPEN_AND_X,
    EVENT_TYPE_SMB_READ_AND_X,
    EVENT_TYPE_SMB_WRITE_AND_X,
    EVENT_TYPE_SMB_FIND_CLOSE2,
    EVENT_TYPE_SMB_FIND_NOTIFY_CLOSE,
    EVENT_TYPE_SMB_TREE_CONNECT,
    EVENT_TYPE_SMB_TREE_DISCONNECT,
    EVENT_TYPE_SMB_NEGOTIATE,
    EVENT_TYPE_SMB_SESSION_SETUP_AND_X,
    EVENT_TYPE_SMB_LOGOFF_AND_X,
    EVENT_TYPE_SMB_TREE_CONNECT_AND_X,
    EVENT_TYPE_SMB_QUERY_INFORMATION_DISK,
    EVENT_TYPE_SMB_SEARCH,
    EVENT_TYPE_SMB_NT_TRANSACTION,
    EVENT_TYPE_SMB_NT_TRANSACTION_SECONDARY,
    EVENT_TYPE_SMB_NT_CREATE_AND_X,
    EVENT_TYPE_SMB_NT_CANCEL,
    EVENT_TYPE_SMB_OPEN_PRINT_FILE,
    EVENT_TYPE_SMB_CLOSE_PRINT_FILE,
    EVENT_TYPE_SMB_GET_PRINT_QUEUE,
    EVENT_TYPE_SMB_READ_RAW,
    EVENT_TYPE_SMB_WRITE_RAW,
    EVENT_TYPE_SMB_READ_MPX,
    EVENT_TYPE_SMB_WRITE_MPX,
    EVENT_TYPE_SMB_WRITE_MPX_SECONDARY,

    EVENT_TYPE_SMB_OPEN2,
    EVENT_TYPE_SMB_FIND_FIRST2,
    EVENT_TYPE_SMB_FIND_NEXT2,
    EVENT_TYPE_SMB_QUERY_FS_INFORMATION,
    EVENT_TYPE_SMB_SET_FS_INFORMATION,
    EVENT_TYPE_SMB_QUERY_PATH_INFORMATION,
    EVENT_TYPE_SMB_SET_PATH_INFORMATION,
    EVENT_TYPE_SMB_QUERY_FILE_INFORMATION,
    EVENT_TYPE_SMB_SET_FILE_INFORMATION,
    EVENT_TYPE_SMB_FSCTL,
    EVENT_TYPE_SMB_IOCTL2,
    EVENT_TYPE_SMB_FIND_NOTIFY,
    EVENT_TYPE_SMB_CREATE_DIRECTORY2,
    EVENT_TYPE_SMB_GET_DFS_REFERRALS,
    EVENT_TYPE_SMB_REPORT_DFS_INCONSISTENCY,

    EVENT_TYPE_SMB_CREATE_WITH_SD_OR_EA,
    EVENT_TYPE_SMB_NT_IOCTL,
    EVENT_TYPE_SMB_SET_SECURITY_DESCRIPTOR,
    EVENT_TYPE_SMB_NT_NOTIFY_CHANGE,
    EVENT_TYPE_SMB_NT_RENAME,
    EVENT_TYPE_SMB_QUERY_SECURITY_DESCRIPTOR,
    EVENT_TYPE_SMB_QUERY_QUOTA,
    EVENT_TYPE_SMB_SET_QUOTA,

    EVENT_TYPE_SMB_LAST_EVENT
} SrvWmiEvents;

// WMI Dispatch routine
//
void
SrvWmiInitContext(
    PWORK_CONTEXT WorkContext
    );

void
SrvWmiStartContext(
    PWORK_CONTEXT   WorkContext
    );

void
SrvWmiEndContext(
    PWORK_CONTEXT   WorkContext
    );

void
SrvWmiTraceEvent(
    PWORK_CONTEXT WorkContext
    );

NTSTATUS
SrvWmiDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

//
// FSD dispatch routine.
//

NTSTATUS
SrvFsdDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//
// FSD I/O completion routine
//

NTSTATUS
SrvFsdIoCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

//
// FSD TDI send completion routine
//

NTSTATUS
SrvFsdSendCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

//
// FSD Oplock request completion routine
//

NTSTATUS
SrvFsdOplockCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

//
// FSD transport Connect indication handler
//

NTSTATUS
SrvFsdTdiConnectHandler (
    IN PVOID TdiEventContext,
    IN int RemoteAddressLength,
    IN PVOID RemoteAddress,
    IN int UserDataLength,
    IN PVOID UserData,
    IN int OptionsLength,
    IN PVOID Options,
    OUT CONNECTION_CONTEXT *ConnectionContext,
    OUT PIRP *AcceptIrp
    );

//
// FSD transport Disconnect indication handler
//

NTSTATUS
SrvFsdTdiDisconnectHandler (
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN int DisconnectDataLength,
    IN PVOID DisconnectData,
    IN int DisconnectInformationLength,
    IN PVOID DisconnectInformation,
    IN ULONG DisconnectFlags
    );

//
// FSD transport Receive indication handler
//

NTSTATUS
SrvFsdTdiReceiveHandler (
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    );

VOID
SrvPnpBindingHandler (
    IN TDI_PNP_OPCODE   PnpOpcode,
    IN PUNICODE_STRING  DeviceName,
    IN PWSTR            MultiSZBindList
);

NTSTATUS
SrvPnpPowerHandler (
    IN PUNICODE_STRING  DeviceName,
    IN PNET_PNP_EVENT   PnPEvent,
    IN PTDI_PNP_CONTEXT Context1,
    IN PTDI_PNP_CONTEXT Context2
);

//
// Routine to get a work item from the free list.  Wakes the resource
// thread if the list is getting empty.
//

PWORK_CONTEXT SRVFASTCALL
SrvFsdGetReceiveWorkItem (
    PWORK_QUEUE queue
    );

//
// If a workitem could not be allocated, SrvServiceWorkItemShortage() is called
// when the next workitem is freed
//
VOID SRVFASTCALL
SrvServiceWorkItemShortage (
    IN PWORK_CONTEXT WorkContext
    );

//
// If we have detected a DoS attack, the workitem will trigger a teardown
//
VOID SRVFASTCALL
SrvServiceDoSTearDown (
    IN PWORK_CONTEXT WorkContext
    );

//
// Routine to queue an EX work item to an EX worker thread.
//

#define SrvFsdQueueExWorkItem(_item,_running,_type) {   \
        if ( !*(_running) ) {                           \
            *(_running) = TRUE;                         \
            ObReferenceObject( SrvDeviceObject );      \
            ExQueueWorkItem( (_item), (_type) );        \
        }                                               \
    }

//
// SMB processing support routines.
//

VOID SRVFASTCALL
SrvFsdRequeueReceiveWorkItem (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
SrvFsdRestartSmbComplete (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID
SrvFsdServiceNeedResourceQueue (
    IN PWORK_CONTEXT *WorkContext,
    IN PKIRQL OldIrql
    );

//
// SMB processing restart routines referenced by the FSP.
//

VOID SRVFASTCALL
SrvFsdRestartRead (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
SrvFsdRestartReadAndX (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
SrvFsdRestartWrite (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
SrvFsdRestartWriteAndX (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
IpxRestartStartSendOnCorrectProcessor (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
SrvFsdRestartLargeReadAndX (
    IN OUT PWORK_CONTEXT WorkContext
    );

//
// Resource shortage routines.
//

BOOLEAN
SrvAddToNeedResourceQueue (
    IN PCONNECTION Connection,
    IN RESOURCE_TYPE ResourceType,
    IN PRFCB Rfcb OPTIONAL
    );

VOID
SrvCheckForAndQueueDoS(
    PWORK_QUEUE queue
    );

//
// Send Completion Routines
//

NTSTATUS
SrvFsdRestartSmbAtSendCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PWORK_CONTEXT WorkContext
    );

NTSTATUS
SrvQueueWorkToFspAtSendCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PWORK_CONTEXT WorkContext
    );

NTSTATUS
SrvFsdRestartSendOplockIItoNone(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN OUT PWORK_CONTEXT WorkContext
    );

NTSTATUS
RequeueIpxWorkItemAtSendCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN OUT PWORK_CONTEXT WorkContext
    );

NTSTATUS
RestartCopyReadMpxComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN OUT PWORK_CONTEXT WorkContext
    );

NTSTATUS
RestartCopyReadRawResponse (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID
SrvpNotifyChangesToNetBt(
    IN TDI_PNP_OPCODE   PnPOpcode,
    IN PUNICODE_STRING  DeviceName,
    IN PWSTR            MultiSZBindList);

#endif // ndef _SRVFSD_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\srvmacro.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    srvmacro.h

Abstract:

    This module defines miscellaneous macros for the LAN Manager server.

Author:

    Chuck Lenzmeier (chuckl) 2-Mar-90

Revision History:

    19-Nov-1990 mannyw


--*/

#ifndef _SRVMACRO_
#define _SRVMACRO_

#include <limits.h>

//
// For WMI logging
//
extern TRACEHANDLE LoggerHandle;
extern ULONG SrvWmiEnableLevel;
extern ULONG SrvWmiEnableFlags;
#define WPP_GET_LOGGER LoggerHandle

#define SRV_WMI_LEVEL( LVL )  (SrvWmiEnableLevel >= SRV_WMI_LEVEL_ ## LVL )
#define SRV_WMI_FLAGON( FLG ) (SrvWmiEnableFlags & SRV_WMI_FLAG_ ## FLG )

#define SRV_WMI_LEVEL_ALWAYS 0
#define SRV_WMI_LEVEL_SPARSE 1
#define SRV_WMI_LEVEL_VERBOSE 2
#define SRV_WMI_LEVEL_COMPLETE 3


#define SRV_WMI_FLAG_CAPACITY 0x00000000  // Capacity Planning Instrumentation is on if no flag is specified
#define SRV_WMI_FLAG_ERRORS   0x00000001  // Error Tracking Instrumentation
#define SRV_WMI_FLAG_STRESS   0x00000002  // Tracking for IOStress Servers
#define SRV_WMI_FLAG_SYSCACHE 0x00000004  // Tracking for Syscache


//
// Simple MIN and MAX macros.  Watch out for side effects!
//

#define MIN(a,b) ( ((a) < (b)) ? (a) : (b) )
#define MAX(a,b) ( ((a) < (b)) ? (b) : (a) )

#define RNDM_CONSTANT   314159269    /* default scrambling constant */
#define RNDM_PRIME     1000000007    /* prime number for scrambling  */

//
// Used for time conversions
//

#define AlmostTwoSeconds ((2*1000*1000*10)-1)

//
// Used for eventlog throttling
//
#define SRV_ONE_DAY ((LONGLONG)(10*1000*1000)*60*60*24)

//
// Width-agnostic inline to take the difference (in bytes) of two pointer
// values.
//

ULONG_PTR
__inline
PTR_DIFF_FULLPTR(
    IN PVOID Ptr1,
    IN PVOID Ptr2
    )
{
    ULONG_PTR difference;

    difference = (ULONG_PTR)Ptr1 - (ULONG_PTR)Ptr2;

    return difference;
}

ULONG
__inline
PTR_DIFF(
    IN PVOID Ptr1,
    IN PVOID Ptr2
    )
{
    ULONG_PTR difference;

    difference = (ULONG_PTR)Ptr1 - (ULONG_PTR)Ptr2;
    ASSERT( difference < ULONG_MAX );

    return (ULONG)difference;
}

USHORT
__inline
PTR_DIFF_SHORT(
    IN PVOID Ptr1,
    IN PVOID Ptr2
    )
{
    ULONG difference;

    difference = PTR_DIFF(Ptr1, Ptr2);
    ASSERT( difference < USHRT_MAX );

    return (USHORT)difference;
}

//
// Compute a string hash value that is invariant to case
//
#define COMPUTE_STRING_HASH( _pus, _phash ) {                \
    PWCHAR _p = (_pus)->Buffer;                              \
    PWCHAR _ep = _p + ((_pus)->Length/sizeof(WCHAR));        \
    ULONG _chHolder =0;                                      \
    DWORD _ch;                                               \
                                                             \
    while( _p < _ep ) {                                      \
        _ch = RtlUpcaseUnicodeChar( *_p++ );                 \
        _chHolder = 37 * _chHolder + (unsigned int) _ch ;    \
    }                                                        \
                                                             \
    *(_phash) = abs(RNDM_CONSTANT * _chHolder) % RNDM_PRIME; \
}

//
// Convert the output of one of the above hash functions to an index into
//  a hash table
//
#define HASH_TO_MFCB_INDEX( _hash )    ((_hash) % NMFCB_HASH_TABLE)

#define HASH_TO_SHARE_INDEX( _hash )   ((_hash) % NSHARE_HASH_TABLE)

//
// GET_SERVER_TIME retrieves the server's concept of the current system time.
//

#define GET_SERVER_TIME(_queue, a) (*(a) = (_queue)->stats.SystemTime)

//
// SET_SERVER_TIME updates the server's concept of the current system time.
//

#define SET_SERVER_TIME( _queue ) {         \
    LARGE_INTEGER currentTime;              \
    KeQueryTickCount( &currentTime );       \
    (_queue)->stats.SystemTime = currentTime.LowPart; \
}

//++
//
// NTSTATUS
// IMPERSONATE (
//     IN PWORK_CONTEXT WorkContext
//     )
//
// Routine Description:
//
//     This macro calls NtSetInformationThread to impersonate a client.
//     This should be called before attempting any open on behalf of
//     a remote client.
//
// Arguments:
//
//     WorkContext - a pointer to a work context block.  It must have
//         a valid, referenced session pointer, from which the token
//         handle is obtained.
//
// Return Value:
//
//     None.
//
//--

#define IMPERSONATE( WorkContext ) SrvImpersonate( WorkContext )

//++
//
// VOID
// REVERT (
//     IN PWORK_CONTEXT WorkContext
//     )
//
// Routine Description:
//
//     This macro calls NtSetInformationThread with a NULL token in order
//     to revert to a thread's original context.  This should be called
//     after the IMPERSONATE macro and an open attempt.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//--

#define REVERT( ) SrvRevert( )

//
// Determine if the security handle has been initialized
//
#define IS_VALID_SECURITY_HANDLE( handle )  ((handle).dwLower || (handle).dwUpper )

//
// Mark this security handle invalid
//
#define INVALIDATE_SECURITY_HANDLE( handle ) (handle).dwLower = (handle).dwUpper = 0

//++
//
// VOID
// CHECK_FUNCTION_ACCESS (
//     IN ACCESS_MASK GrantedAccess,
//     IN UCHAR MajorFunction,
//     IN UCHAR MinorFunction,
//     IN ULONG IoControlCode,
//     OUT PNTSTATUS Status
//     )
//
// Routine Description:
//
//     This macro calls IoCheckFunctionAccess the check the client's
//     access to an I/O function identified by major and minor function
//     codes.
//
//     *** This macro is here only because CHECK_FILE_INFORMATION_ACCESS
//         and CHECK_FS_INFORMATION_ACCESS are here.
//
// Arguments:
//
//     GrantedAccess - The access granted to the client for the target
//         target file object.
//
//     MajorFunction - The major function code of the requested
//         operation.
//
//     MinorFunction - The minor function code of the requested
//         operation.
//
//     IoControlCode - The control code for device or file system control.
//
//     Status - Indicates whether the client has the requested access.
//
// Return Value:
//
//     None.
//
//--

#define CHECK_FUNCTION_ACCESS( GrantedAccess, MajorFunction, MinorFunction, \
                               IoControlCode, Status ) {                    \
            *(Status) = IoCheckFunctionAccess(                              \
                            (GrantedAccess),                                \
                            (MajorFunction),                                \
                            (MinorFunction),                                \
                            IoControlCode,                                  \
                            NULL,                                           \
                            NULL                                            \
                            );                                              \
        }

//++
//
// VOID
// CHECK_PAGING_IO_ACCESS (
//     IN PWORK_CONTEXT WorkContext
//     IN ACCESS_MASK GrantedAccess,
//     OUT PNTSTATUS Status
//     )
//
// Routine Description:
//
//     This macro checks to see if the client opened the file for execute.
//     If so, then we allow the redirector to read the file.  If this is
//     an NT redirector, it must set the FLAGS2_PAGING_IO bit for access
//     to be allowed.
//
// Arguments:
//
//     GrantedAccess - The access granted to the client for the target
//         target file object.
//
//     WorkContext - A pointer to a work context block.
//
//     Status - Indicates whether the client has the requested access.
//
// Return Value:
//
//     None.
//
//--

#define CHECK_PAGING_IO_ACCESS( WorkContext, GrantedAccess, Status ) {           \
                                                                            \
            if ( ((GrantedAccess) & FILE_EXECUTE) &&                        \
                 ( !IS_NT_DIALECT( WorkContext->Connection->SmbDialect ) || \
                   WorkContext->RequestHeader->Flags2 &                     \
                       SMB_FLAGS2_PAGING_IO ) ) {                           \
                *Status = STATUS_SUCCESS;                                   \
            } else {                                                        \
                *Status = STATUS_ACCESS_DENIED;                             \
            }                                                               \
        }

//++
//
// VOID
// CHECK_FILE_INFORMATION_ACCESS (
//     IN ACCESS_MASK GrantedAccess,
//     IN UCHAR MajorFunction,
//     IN FILE_INFORMATION_CLASS FileInformationClass
//     OUT PNTSTATUS Status
//     )
//
// Routine Description:
//
//     This macro calls IoCheckFunctionAccess the check the client's
//     access to a query or set file information function identified by
//     major function code and information class.
//
//     *** This macro is here because IoCheckFunctionAccess takes an
//         OPTIONAL FileInformationClass argument; this is argument is
//         therefore passed by reference.  Rather than force the caller
//         to allocate local storage so that it can pass a constant by
//         reference, we do it in the macro.
//
// Arguments:
//
//     GrantedAccess - The access granted to the client for the target
//         target file object.
//
//     MajorFunction - The major function code of the requested
//         operation.
//
//     FileInformationClass - The type of file information being queried
//         or set.
//
//     Status - Indicates whether the client has the requested access.
//
// Return Value:
//
//     None.
//
//--

#define CHECK_FILE_INFORMATION_ACCESS( GrantedAccess, MajorFunction,        \
                                        FileInformationClass, Status ) {    \
            FILE_INFORMATION_CLASS fileInfoClass = FileInformationClass;    \
            *(Status) = IoCheckFunctionAccess(                              \
                            (GrantedAccess),                                \
                            (MajorFunction),                                \
                            0,                                              \
                            0,                                              \
                            &fileInfoClass,                                 \
                            NULL                                            \
                            );                                              \
        }

//++
//
// PCHAR
// END_OF_REQUEST_SMB (
//     IN PWORK_CONTEXT WorkContext
//     )
//
// Routine Description:
//
//     This routine returns the address of the last valid location in
//     the request SMB associated with the specified work context
//     block.
//
// Arguments:
//
//     WorkContext - Pointer to the work context block that owns the
//         request SMB.
//
// Return Value:
//
//     PCHAR - Address of the last valid location in the request SMB.
//
//--

#define END_OF_REQUEST_SMB( WorkContext )                       \
            ( (PCHAR)( (WorkContext)->RequestBuffer->Buffer ) + \
                (WorkContext)->RequestBuffer->DataLength - 1 )

//++
//
// PCHAR
// END_OF_RESPONSE_BUFFER (
//     IN PWORK_CONTEXT WorkContext
//     )
//
// Routine Description:
//
//     This routine returns the address of the last valid location in
//     the response buffer associated with the specified work context
//     block.
//
// Arguments:
//
//     WorkContext - Pointer to the work context block that owns the
//         request SMB.
//
// Return Value:
//
//     PCHAR - Address of the last valid location in the request SMB.
//
//--

#define END_OF_RESPONSE_BUFFER( WorkContext )                       \
            ( (PCHAR)( (WorkContext)->ResponseBuffer->Buffer ) + \
                (WorkContext)->RequestBuffer->BufferLength - 1 )


//++
//
// PCHAR
// END_OF_TRANSACTION_PARAMETERS (
//     IN PTRANSACTION Transaction
//     )
//
// Routine Description:
//
//     This routine returns the address of the last valid location in
//     the InParameters buffer of the transaction block.
//
// Arguments:
//
//     Transaction - a pointer to the transaction block to check.
//
// Return Value:
//
//     PCHAR - Address of the last valid location in the InParameters
//         buffer of the transaction.
//
//--

#define END_OF_TRANSACTION_PARAMETERS( Transaction )   \
            ( (PCHAR)( (Transaction)->InParameters ) + \
                (Transaction)->ParameterCount - 1 )

//++
//
// VOID
// INTERNAL_ERROR (
//     IN ULONG ErrorLevel,
//     IN PSZ Message,
//     IN PVOID Arg1 OPTIONAL,
//     IN PVOID Arg2 OPTIONAL
//     )
//
// Routine Description:
//
//     This routine handles logging of a server internal error.
//
//     *** This macro must be usable in the FSD, at DPC level.
//
// Arguments:
//
//     ErrorLevel - The severity of the error
//
//     Message    - An error message string in DbgPrint() format
//
//     Arg1       - Argument 1 for the error message
//
//     Arg2       - Argument 2 for the error message
//
//--

#define INTERNAL_ERROR( _level, _msg, _arg1, _arg2 ) {          \
    IF_DEBUG(ERRORS) {                                          \
        DbgPrint( (_msg), (_arg1), (_arg2) );                  \
        DbgPrint( "\n" );                                      \
        if ( (_level) >= ERROR_LEVEL_UNEXPECTED ) {             \
            IF_DEBUG(STOP_ON_ERRORS) {                          \
                DbgBreakPoint();                                \
            }                                                   \
        }                                                       \
    }                                                           \
    if ( (_level) == ERROR_LEVEL_EXPECTED ) {                   \
        ;                                                       \
    } else if ( (_level) == ERROR_LEVEL_UNEXPECTED ) {          \
        SrvStatistics.SystemErrors++;                           \
    } else {                                                    \
        ASSERT( (_level) > ERROR_LEVEL_UNEXPECTED );            \
        KeBugCheckEx(                                           \
            LM_SERVER_INTERNAL_ERROR,                           \
            BugCheckFileId | __LINE__,                          \
            (ULONG_PTR)(_arg1),                                 \
            (ULONG_PTR)(_arg2),                                 \
            0                                                   \
            );                                                  \
    }                                                           \
}

#define SRV_FILE_ACCESS     0x00010000
#define SRV_FILE_BLKCOMM    0x00020000
#define SRV_FILE_BLKCONN    0x00030000
#define SRV_FILE_BLKDEBUG   0x00040000
#define SRV_FILE_BLKENDP    0x00050000
#define SRV_FILE_BLKFILE    0x00060000
#define SRV_FILE_BLKSESS    0x00070000
#define SRV_FILE_BLKSHARE   0x00080000
#define SRV_FILE_BLKSRCH    0x00090000
#define SRV_FILE_BLKTABLE   0x000A0000
#define SRV_FILE_BLKTRANS   0x000B0000
#define SRV_FILE_BLKTREE    0x000C0000
#define SRV_FILE_BLKWORK    0x000D0000
#define SRV_FILE_COPY       0x000E0000
#define SRV_FILE_EA         0x000F0000
#define SRV_FILE_ERRORLOG   0x00100000
#define SRV_FILE_FSD        0x00110000
#define SRV_FILE_FSDDISP    0x00120000
#define SRV_FILE_FSDRAW     0x00130000
#define SRV_FILE_FSDSMB     0x00140000
#define SRV_FILE_FSPINIT    0x00150000
#define SRV_FILE_HEAPMGR    0x00160000
#define SRV_FILE_INFO       0x00170000
#define SRV_FILE_IPX        0x00180000
#define SRV_FILE_IO         0x00190000
#define SRV_FILE_LOCK       0x001A0000
#define SRV_FILE_LOCKCODE   0x001B0000
#define SRV_FILE_MOVE       0x001C0000
#define SRV_FILE_NETWORK    0x001D0000
#define SRV_FILE_OPEN       0x001E0000
#define SRV_FILE_OPLOCK     0x001F0000
#define SRV_FILE_PIPE       0x00200000
#define SRV_FILE_PRNSUPP    0x00210000
#define SRV_FILE_SCAVENGR   0x00220000
#define SRV_FILE_SHARE      0x00230000
#define SRV_FILE_SLMCHECK   0x00240000
#define SRV_FILE_SMBADMIN   0x00250000
#define SRV_FILE_SMBATTR    0x00260000
#define SRV_FILE_SMBCLOSE   0x00270000
#define SRV_FILE_SMBDIR     0x00280000
#define SRV_FILE_SMBFILE    0x00290000
#define SRV_FILE_SMBFIND    0x002A0000
#define SRV_FILE_SMBIOCTL   0x002B0000
#define SRV_FILE_SMBLOCK    0x002C0000
#define SRV_FILE_SMBMISC    0x002D0000
#define SRV_FILE_SMBMPX     0x002E0000
#define SRV_FILE_SMBNOTFY   0x002F0000
#define SRV_FILE_SMBOPEN    0x00300000
#define SRV_FILE_SMBPRINT   0x00310000
#define SRV_FILE_SMBPROC    0x00320000
#define SRV_FILE_SMBRAW     0x00330000
#define SRV_FILE_SMBRDWRT   0x00340000
#define SRV_FILE_SMBSRCH    0x00350000
#define SRV_FILE_SMBSUPP    0x00360000
#define SRV_FILE_SMBTRANS   0x00370000
#define SRV_FILE_SMBTREE    0x00380000
#define SRV_FILE_SRVCONFG   0x00390000
#define SRV_FILE_SRVDATA    0x003A0000
#define SRV_FILE_SRVSTAT    0x003B0000
#define SRV_FILE_SRVSTRNG   0x003C0000
#define SRV_FILE_SVCCDEV    0x003D0000
#define SRV_FILE_SVCCDEVQ   0x003E0000
#define SRV_FILE_SVCCONN    0x003F0000
#define SRV_FILE_SVCFILE    0x00400000
#define SRV_FILE_SVCSESS    0x00410000
#define SRV_FILE_SVCSHARE   0x00420000
#define SRV_FILE_SVCSRV     0x00430000
#define SRV_FILE_SVCSTATS   0x00440000
#define SRV_FILE_SVCSUPP    0x00450000
#define SRV_FILE_SVCXPORT   0x00460000
#define SRV_FILE_WORKER     0x00470000
#define SRV_FILE_XSSUPP     0x00480000
#define SRV_FILE_BLKDIR     0x00490000
#define SRV_FILE_DFS        0x004A0000

//
// Error levels used with INTERNAL_ERROR
//

#define ERROR_LEVEL_EXPECTED    0
#define ERROR_LEVEL_UNEXPECTED  1
#define ERROR_LEVEL_IMPOSSIBLE  2
#define ERROR_LEVEL_FATAL       3


//
// Helper macros for dealing with unqiue identifiers (UID, PID, TID,
// FID, SID).  In these macros, id, index, and sequence should all be
// USHORTs.
//

#define TID_INDEX(id) (USHORT)( (id) & 0x07FF )
#define TID_SEQUENCE(id) (USHORT)( (id) >> 11 )
#define MAKE_TID(index, sequence) (USHORT)( ((sequence) << 11) | (index) )
#define INCREMENT_TID_SEQUENCE(id) (id) = (USHORT)(( (id) + 1 ) & 0x1F);

#define UID_INDEX(id) (USHORT)( (id) & 0x07FF )
#define UID_SEQUENCE(id) (USHORT)( (id) >> 11 )
#define MAKE_UID(index, sequence) (USHORT)(( (sequence) << 11) | (index) )
#define INCREMENT_UID_SEQUENCE(id) (id) = (USHORT)(( (id) + 1 ) & 0x1F);

#define FID_INDEX(id) (USHORT)( (id) & 0x03FFF )
#define FID_SEQUENCE(id) (USHORT)( (id) >> 14 )
#define MAKE_FID(index, sequence) (USHORT)( ((sequence) << 14) | (index) )
#define INCREMENT_FID_SEQUENCE(id) (id) = (USHORT)(( (id) + 1 ) & 0x3);

//
// *** Note that the macros relating to search IDs are somewhat
//     different from those for other kinds of IDs.  The SID is stored
//     in a Resume Key (see smb.h for its definition), in discontiguous
//     fields.  The macros for getting the SID therefore take a pointer
//     to a resume key.
//

#define SID_INDEX(ResumeKey)                                                 \
            (USHORT)( ( ((ResumeKey)->Reserved & 0x7) << 8 ) |               \
                      (ResumeKey)->Sid )
#define SID_SEQUENCE(ResumeKey)                                              \
            (USHORT)( ((ResumeKey)->Reserved & 0x18) >> 3 )
#define SID(ResumeKey)                                                       \
            (USHORT)( ( ((ResumeKey)->Reserved & 0x1F) << 8 ) |              \
                      (ResumeKey)->Sid )
#define INCREMENT_SID_SEQUENCE(id) (id) = (USHORT)(( (id) + 1 ) & 0x3);
#define SET_RESUME_KEY_SEQUENCE(ResumeKey,Sequence) {                       \
            (ResumeKey)->Reserved &= ~0x18;                                 \
            (ResumeKey)->Reserved |= (Sequence) << 3;                       \
        }
#define SET_RESUME_KEY_INDEX(ResumeKey,Index) {                             \
            (ResumeKey)->Reserved = (UCHAR)( (ULONG)(Index) >> 8 );         \
            (ResumeKey)->Reserved &= (UCHAR)0x7;                            \
            (ResumeKey)->Sid = (UCHAR)( (Index) & (USHORT)0xFF );           \
        }

//
// The following SID macros are used in the same way as the macros for
// other IDs (see above, TID, FID, UID).  The Find2 protocols (Transaction2)
// use a USHORT as a SID, rather than various fields in a resume key.
//

#define SID_INDEX2(Sid)                                                      \
            (USHORT)( (Sid) & 0x7FF )
#define SID_SEQUENCE2(Sid)                                                   \
            (USHORT)( ((Sid) & 0x1800) >> 11 )
#define MAKE_SID(Index,Sequence)                                             \
            (USHORT)( ((Sequence) << 11) | (Index) )

//
// InitializeObjectAttributes, with security.
//

#define SrvInitializeObjectAttributes(ObjectAttributes,p1,p2,p3,p4)   \
            InitializeObjectAttributes(ObjectAttributes,p1,p2,p3,p4); \
            (ObjectAttributes)->SecurityQualityOfService = (PVOID)&SrvSecurityQOS;

#define SrvInitializeObjectAttributes_U(ObjectAttributes,p1,p2,p3,p4)   \
            InitializeObjectAttributes(ObjectAttributes,p1,p2,p3,p4); \
            (ObjectAttributes)->SecurityQualityOfService = (PVOID)&SrvSecurityQOS;


//
// Macro used to map from NT attributes to SMB attributes.  The output is placed
//   in *_SmbAttributes
//
#define SRV_NT_ATTRIBUTES_TO_SMB( _NtAttributes, _Directory, _SmbAttributes ) {\
    *(_SmbAttributes) = (USHORT)( (_NtAttributes) &             \
                            ( FILE_ATTRIBUTE_READONLY |         \
                              FILE_ATTRIBUTE_HIDDEN   |         \
                              FILE_ATTRIBUTE_SYSTEM   |         \
                              FILE_ATTRIBUTE_ARCHIVE  |         \
                              FILE_ATTRIBUTE_DIRECTORY )) ;     \
    if ( _Directory ) {                                         \
        *(_SmbAttributes) |= SMB_FILE_ATTRIBUTE_DIRECTORY;      \
    }                                                           \
}


//    This macro converts attributes from SMB format to NT format.
//
//   The attribute bits in the SMB protocol (same as OS/2) have the
//    following meanings:
//
//      bit 0 - read only file
//      bit 1 - hidden file
//      bit 2 - system file
//      bit 3 - reserved
//      bit 4 - directory
//      bit 5 - archive file
//
//    NT file attributes are similar, but have a bit set for a "normal"
//    file (no other bits set) and do not have a bit set for directories.
//    Instead, directory information is passed to and from APIs as a
//    BOOLEAN parameter.

#define SRV_SMB_ATTRIBUTES_TO_NT( _SmbAttributes, _Directory, _NtAttributes ) {\
    ULONG _attr = (_SmbAttributes);                                     \
    *(_NtAttributes) = _attr &                                          \
                            ( SMB_FILE_ATTRIBUTE_READONLY |             \
                              SMB_FILE_ATTRIBUTE_HIDDEN   |             \
                              SMB_FILE_ATTRIBUTE_SYSTEM   |             \
                              SMB_FILE_ATTRIBUTE_ARCHIVE  |             \
                              SMB_FILE_ATTRIBUTE_DIRECTORY );           \
    if ( _attr == 0 ) {                                                 \
        *(_NtAttributes) = FILE_ATTRIBUTE_NORMAL;                       \
    }                                                                   \
    if( _Directory ) {                                                  \
        if ( (_attr & SMB_FILE_ATTRIBUTE_DIRECTORY) != 0 ) {            \
            *(PBOOLEAN)(_Directory) = TRUE;                             \
        } else {                                                        \
            *(PBOOLEAN)(_Directory) = FALSE;                            \
        }                                                               \
    }                                                                   \
}

//
// ULONG
// MAP_SMB_INFO_TYPE_TO_NT (
//     IN PULONG Map,
//     IN ULONG SmbInformationLevel
//     )
//
// Routine description:
//
//     This macro maps SMB_INFO level to Nt info level.
//
// Arguments:
//
//     Map - An array of ULONGS.  The first ulong is the base SMB info level
//          the seconds through Nth are NT mappings of the corresponding
//          SMB info levels.
//
//     Level - The SMB info level to map.
//
// Return Value:
//
//     NtInfoLevel - The NT info level.
//

#define MAP_SMB_INFO_TYPE_TO_NT( Map, Level )   Map[Level - Map[0] + 1]

//
// ULONG
// MAP_SMB_INFO_TO_MIN_NT_SIZE (
//     IN PULONG Map,
//     IN ULONG SmbINformationLevel
//     )
//
// Routine Description:
//
//  This macro maps SMB_INFO level to the minimum buffer size needed to make the
//    NtQueryInformationFile call
//
// Arguments:
//     Map - An array of ULONGS.  The first ulong is the base SMB info level,
//          the second is the NT info level, and the third through Nth are the
//          NT mapings for the sizes of the NT info levels.
//
//     Level - The SMB info level to find the buffer size
//
// Return Value:
//
//    NtMinumumBufferSIze - the minumum buffer size for the request

#define MAP_SMB_INFO_TO_MIN_NT_SIZE( Map, Level )  Map[ Level - Map[0] + 2]

//
// BOOLEAN
// SMB_IS_UNICODE(
//     IN PWORK_CONTEXT WorkContext
//     )
//
// Routine description:
//
//     This macro discovers whether or not an SMB contains Unicode
//     ANSI strings.
//
// Arguments:
//
//     WorkContext - A pointer to the active work context
//
// Return Value:
//
//     TRUE - The SMB strings are unicode.
//     FALSE - The SMB strings are ANSI.
//

#define SMB_IS_UNICODE( WorkContext )  \
            (BOOLEAN)( ((WorkContext)->RequestHeader->Flags2 & SMB_FLAGS2_UNICODE ) != 0 )

//
// BOOLEAN
// SMB_CONTAINS_DFS_NAME(
//      IN PWORK_CONTEXT WorkContext
//      )
//
// Routine description:
//
//      This macro discovers whether or not an SMB contains a pathname
//      referring to the DFS namespace.
//
// Arguments:
//
//      WorkContext - A pointer to the active work context
//
// Return Value:
//
//      TRUE  - The SMB has a DFS name in it
//      FALSE - The SMB does not have a DFS name in it
//

#define SMB_CONTAINS_DFS_NAME( WorkContext ) \
            (BOOLEAN)( ((WorkContext)->RequestHeader->Flags2 & SMB_FLAGS2_DFS ) != 0 )

//
// BOOLEAN
// SMB_MARK_AS_DFS_NAME(
//      IN PWORK_CONTEXT WorkContext
//      )
//
// Routine description:
//
//      This macro marks the WorkContext as containing a Dfs name. This is
//      used when processing SMBs that contain two path names; after the first
//      path name has been canonicalized, the SMB is marked as being
//      Dfs-Translated by SrvCanonicalizePathName, so the attempt to
//      canonicalize the second path in the SMB will fail to do the
//      Dfs translation. Calling this macro will ensure that the next call
//      to SrvCanonicalizePathName will go through Dfs translation
//
// Arguments:
//
//      WorkContext - A pointer to the active work context
//
// Return Value:
//
//      None
//

#define SMB_MARK_AS_DFS_NAME( WorkContext ) \
        (WorkContext)->RequestHeader->Flags2 |= SMB_FLAGS2_DFS

//
// BOOLEAN
// SMB_MARK_AS_DFS_TRANSLATED(
//      IN PWORK_CONTEXT WorkContext
//      )
//
// Routine description:
//
//      This macro marks the WorkContext as having been through a Dfs
//      translation for the express purpose of preventing a second attempt
//      at Dfs translation on the translated name.
//
// Arguments:
//
//      WorkContext - A pointer to the active work context
//
// Return Value:
//
//      None
//

#define SMB_MARK_AS_DFS_TRANSLATED( WorkContext ) \
        (WorkContext)->RequestHeader->Flags2 &= (~SMB_FLAGS2_DFS)

//
// BOOLEAN
// CLIENT_CAPABLE_OF(
//     IN ULONG Capability,
//     IN PCONNECTION Connection
//     )
//
// Routine description:
//
//     This macro discovers whether or not a client is supports a
//     certain capability.
//
//     *Warning* This macro assumes that only one capability is being tested.
//
// Arguments:
//
//     Connection - A pointer to the active connection
//
// Return Value:
//
//     TRUE - Capability supported.
//     FALSE - otherwise.
//

#define CLIENT_CAPABLE_OF( Capability, Connection ) \
            (BOOLEAN) ( ((Connection)->ClientCapabilities & (CAP_ ## Capability)) != 0 )

//
// BOOLEAN
// SMB_IS_PIPE_PREFIX(
//     IN PWORK_CONTEXT WorkContext
//     IN PVOID Name
//     )
//
// Routine description:
//
//     This macro discovers whether or not a path prefix is named pipe prefix
//     for a transaction SMB.
//
// Arguments:
//
//     WorkContext - A pointer to the active work context
//     Name - A pointer to a name string.  This may be ANSI or Unicode
//
// Return Value:
//
//     TRUE - The name is a pipe prefix.
//     FALSE - The name is not a pipe prefix.
//

#define SMB_NAME_IS_PIPE_PREFIX( WorkContext, Name )                    \
                                                                        \
       ( ( !SMB_IS_UNICODE( WorkContext ) &&                            \
           strnicmp(                                                    \
                (PCHAR)Name,                                            \
                SMB_PIPE_PREFIX,                                        \
                SMB_PIPE_PREFIX_LENGTH                                  \
                ) == 0                                                  \
         )                                                              \
        ||                                                              \
         ( SMB_IS_UNICODE( WorkContext ) &&                             \
           wcsnicmp(                                                    \
                (PWCH)Name,                                             \
                UNICODE_SMB_PIPE_PREFIX,                                \
                UNICODE_SMB_PIPE_PREFIX_LENGTH / sizeof(WCHAR)          \
                ) == 0                                                  \
         )                                                              \
       )

//
// BOOLEAN
// SMB_IS_PIPE_API(
//     IN PWORK_CONTEXT WorkContext
//     IN PVOID Name
//     )
//
// Routine description:
//
//     This macro discovers whether or not a transaction name indicates
//     that the transaction is for a LM remote API request.
//
// Arguments:
//
//     WorkContext - A pointer to the active work context
//     Name - A pointer to a name string.  This may be ANSI or Unicode
//
// Return Value:
//
//     TRUE - The name is a remote API request.
//     FALSE - The name is not a remote API request.
//

#define SMB_NAME_IS_PIPE_API( WorkContext, Name )                       \
                                                                        \
       ( ( !SMB_IS_UNICODE( WorkContext ) &&                            \
           stricmp(                                                     \
                (PCHAR)Name,                                            \
                StrPipeApiOem                                           \
                ) == 0                                                  \
         )                                                              \
                        ||                                              \
         ( SMB_IS_UNICODE( WorkContext ) &&                             \
           wcsicmp(                                                     \
                (PWCH)Name,                                             \
                StrPipeApi                                              \
                ) == 0                                                  \
         )                                                              \
       )

//
// VOID
// SrvReferenceConnection (
//     PCONNECTION Connection
//     )
//
// Routine Description:
//
//     This macro increments the reference count on a connection block.
//
//     !!! Users of this macro must be nonpageable.
//
// Arguments:
//
//     Connection - Address of connection
//
// Return Value:
//
//     None.
//

#define SrvReferenceConnection( _conn_ )    {                           \
            ASSERT( GET_BLOCK_TYPE(_conn_) ==                           \
                                    BlockTypeConnection );              \
            UPDATE_REFERENCE_HISTORY( (_conn_), FALSE );                \
            (VOID) ExInterlockedAddUlong(                               \
                        &(_conn_)->BlockHeader.ReferenceCount,          \
                        1,                                              \
                        (_conn_)->EndpointSpinLock                      \
                        );                                              \
            IF_DEBUG(REFCNT) {                                          \
                SrvHPrint2(                                              \
                "Referencing connection %lx; new refcnt %lx\n",         \
                (_conn_), (_conn_)->BlockHeader.ReferenceCount);        \
            }                                                           \
        }

//
// VOID
// SrvReferenceConnectionLocked (
//     PCONNECTION Connection
//     )
//
// Routine Description:
//
//     This macro increments the reference count on a connection block.
//     Invokers of this macro must hold the SrvFsdSpinLock.
//
// Arguments:
//
//     Connection - Address of connection
//
// Return Value:
//
//     None.
//

#define SrvReferenceConnectionLocked( _conn_ )    {                     \
            ASSERT( GET_BLOCK_TYPE(_conn_) ==                           \
                                    BlockTypeConnection );              \
            UPDATE_REFERENCE_HISTORY( (_conn_), FALSE );                \
            (_conn_)->BlockHeader.ReferenceCount++;                     \
            IF_DEBUG(REFCNT) {                                          \
                SrvHPrint2(                                              \
                    "Referencing connection %lx; new refcnt %lx\n",     \
                    (_conn_), (_conn_)->BlockHeader.ReferenceCount );   \
            }                                                           \
        }

//
// VOID
// SrvReferenceSession (
//     PSESSION Session
//     )
//
// Routine Description:
//
//     This macro increments the reference count on a session block.
//
// Arguments:
//
//     Session - Address of session
//
// Return Value:
//
//     None.
//

#define SrvReferenceSession( _sess_ )    {                              \
            ASSERT( (_sess_)->NonpagedHeader->ReferenceCount > 0 );     \
            ASSERT( GET_BLOCK_TYPE(_sess_) == BlockTypeSession );       \
            UPDATE_REFERENCE_HISTORY( (_sess_), FALSE );                \
            InterlockedIncrement(                                       \
                &(_sess_)->NonpagedHeader->ReferenceCount               \
                );                                                      \
            IF_DEBUG(REFCNT) {                                          \
                SrvHPrint2(                                              \
                    "Referencing session %lx; new refcnt %lx\n",        \
                  (_sess_), (_sess_)->NonpagedHeader->ReferenceCount ); \
            }                                                           \
        }

//
// VOID
// SrvReferenceTransaction (
//     PTRANSACTION Transaction
//     )
//
// Routine Description:
//
//     This macro increments the reference count on a transaction block.
//
// Arguments:
//
//     Transaction - Address of transaction
//
// Return Value:
//
//     None.
//

#define SrvReferenceTransaction( _trans_ )    {                         \
            ASSERT( (_trans_)->NonpagedHeader->ReferenceCount > 0 );    \
            ASSERT( GET_BLOCK_TYPE(_trans_) == BlockTypeTransaction );  \
            UPDATE_REFERENCE_HISTORY( (_trans_), FALSE );               \
            InterlockedIncrement(                                       \
                &(_trans_)->NonpagedHeader->ReferenceCount              \
                );                                                      \
            IF_DEBUG(REFCNT) {                                          \
                SrvHPrint2(                                              \
                    "Referencing transaction %lx; new refcnt %lx\n",    \
                (_trans_), (_trans_)->NonpagedHeader->ReferenceCount ); \
            }                                                           \
        }

//
// VOID
// SrvReferenceTreeConnect (
//     PTREE_CONNECT TreeConnect
//     )
//
// Routine Description:
//
//     This macro increments the reference count on a tree connect block.
//     Invokers of this macro must hold TreeConnect->Connection->Lock.
//
// Arguments:
//
//     TreeConnect - Address of tree connect
//
// Return Value:
//
//     None.
//

#define SrvReferenceTreeConnect( _tree_ )    {                          \
            ASSERT( (_tree_)->NonpagedHeader->ReferenceCount > 0 );     \
            ASSERT( GET_BLOCK_TYPE(_tree_) == BlockTypeTreeConnect );   \
            UPDATE_REFERENCE_HISTORY( (_tree_), FALSE );                \
            InterlockedIncrement(                                       \
                &(_tree_)->NonpagedHeader->ReferenceCount               \
                );                                                      \
            IF_DEBUG(REFCNT) {                                          \
                SrvHPrint2(                                              \
                    "Referencing tree connect %lx; new refcnt %lx\n",   \
                  (_tree_), (_tree_)->NonpagedHeader->ReferenceCount ); \
            }                                                           \
        }

//
// VOID
// SrvReferenceWorkItem (
//     IN PWORK_CONTEXT WorkContext
//     )
//
// Routine Description:
//
//     This function increments the reference count of a work context block.
//     Invokers of this macro must hold WorkContext->SpinLock.
//
// Arguments:
//
//     WORK_CONTEXT - Pointer to the work context block to reference.
//
// Return Value:
//
//     None.
//

#define SrvReferenceWorkItem( _wc_ ) {                                      \
        ASSERT( (LONG)(_wc_)->BlockHeader.ReferenceCount >= 0 );            \
        ASSERT( (GET_BLOCK_TYPE(_wc_) == BlockTypeWorkContextInitial) ||    \
                (GET_BLOCK_TYPE(_wc_) == BlockTypeWorkContextNormal) ||     \
                (GET_BLOCK_TYPE(_wc_) == BlockTypeWorkContextRaw) );        \
        UPDATE_REFERENCE_HISTORY( (_wc_), FALSE );                          \
        (_wc_)->BlockHeader.ReferenceCount++;                               \
        IF_DEBUG(REFCNT) {                                                  \
            SrvHPrint2(                                                      \
              "Referencing WorkContext 0x%lx; new refcnt 0x%lx\n",          \
              (_wc_), (_wc_)->BlockHeader.ReferenceCount );                 \
        }                                                                   \
    }

//
// VOID
// SRV_START_SEND (
//     IN OUT PWORK_CONTEXT WorkContext,
//     IN PMDL Mdl OPTIONAL,
//     IN ULONG SendOptions,
//     IN PRESTART_ROUTINE FsdRestartRoutine,
//     IN PRESTART_ROUTINE FspRestartRoutine
//     )
//
// Routine Description:
//
//     This macro calls the SrvStartSend routine.  It sets the fsd and
//     fsp restart routines before calling it.
//
// Arguments:
//
//     WorkContext - Supplies a pointer to a Work Context block.
//
//     Mdl - Supplies a pointer to the first (or only) MDL describing the
//         data that is to be sent.
//
//     SendOptions - Supplied TDI send options.
//
//     FsdRestartRoutine - Supplies the address of the FSD routine that is
//         to be called when the I/O completes.  (Often, this is
//         SrvQueueWorkToFspAtDpcLevel.)
//
//     FspRestartRoutine - Supplies the address of the FSP routine that is
//         to be called when the FSD queues the work item to the FSP.
//

#define SRV_START_SEND( _wc, _mdl, _opt, _compl, _fsdRestart, _fspRestart ) { \
        ASSERT( !(_wc)->Endpoint->IsConnectionless );                 \
        if ( (_fspRestart) != NULL ) {                                \
            (_wc)->FspRestartRoutine = (_fspRestart);                 \
        }                                                             \
        if ( (_fsdRestart) != NULL ) {                                \
            (_wc)->FsdRestartRoutine = (_fsdRestart);                 \
        }                                                             \
        SrvStartSend( (_wc), (_compl), (_mdl), (_opt) );              \
    }

#define SRV_START_SEND_2( _wc, _compl, _fsdRestart, _fspRestart ) {   \
        (_wc)->ResponseBuffer->Mdl->ByteCount =                       \
                            (_wc)->ResponseBuffer->DataLength;        \
        if ( (_fspRestart) != NULL ) {                                \
            (_wc)->FspRestartRoutine = (_fspRestart);                 \
        }                                                             \
        if ( (_fsdRestart) != NULL ) {                                \
            (_wc)->FsdRestartRoutine = (_fsdRestart);                 \
        }                                                             \
        if ( !(_wc)->Endpoint->IsConnectionless ) {                   \
            SrvStartSend2( (_wc), (_compl) );                         \
        } else {                                                      \
            SrvIpxStartSend( (_wc), (_compl) );                       \
        }                                                             \
    }

//
// VOID
// SrvUpdateErrorCount(
//     PSRV_ERROR_RECORD ErrorRecord,
//     BOOLEAN IsError
//     )
// /*++
//
// Routine Description:
//
//     This routine updates the server's record of successful / unsuccesful
//     operations.
//
// Arguments:
//
//     IsError - TRUE - A server error occured
//               FALSE - A server operation was attempted
//
// Return Value:
//
//    None.
//

#if 0
#define SrvUpdateErrorCount( ErrorRecord, IsError )                     \
        if ( IsError ) {                                                \
            (ErrorRecord)->FailedOperations++;                          \
        } else {                                                        \
            (ErrorRecord)->SuccessfulOperations++;                      \
        }
#else
#define SrvUpdateErrorCount( ErrorRecord, IsError )
#endif

//
// VOID
// SrvUpdateStatistics (
//     PWORK_CONTEXT WorkContext,
//     ULONG BytesSent,
//     UCHAR SmbCommand
//     )
//
// Routine Description:
//
//     Macro to update the server statistics database to reflect the
//     work item that is being completed.
//
// Arguments:
//
//     WorkContext - Pointer to the workcontext block containing
//         the statistics for this request.
//
//     BytesSent - Supplies a count of the number of bytes of response data
//         sent as a result of the current SMB.
//
//     SmbCommand - The SMB command code of the current operation.
//
//
// Return Value:
//
//    None.
//

#if SRVDBG_STATS
VOID SRVFASTCALL
SrvUpdateStatistics2 (
    PWORK_CONTEXT WorkContext,
    UCHAR SmbCommand
    );
#define UPDATE_STATISTICS2(_work,_cmd) SrvUpdateStatistics2((_work),(_cmd))
#else
#define UPDATE_STATISTICS2(_work,_cmd)
#endif

#define UPDATE_STATISTICS(_work,_sent,_cmd ) {                 \
    _work->CurrentWorkQueue->stats.BytesSent += (_sent);       \
    UPDATE_STATISTICS2((_work),(_cmd));                        \
}

#define UPDATE_READ_STATS( _work, _count) {                    \
    _work->CurrentWorkQueue->stats.ReadOperations++;           \
    _work->CurrentWorkQueue->stats.BytesRead += (_count);      \
}

#define UPDATE_WRITE_STATS(_work, _count) {                    \
    _work->CurrentWorkQueue->stats.WriteOperations++;          \
    _work->CurrentWorkQueue->stats.BytesWritten += (_count);   \
}

//
// VOID
// SrvFsdSendResponse (
//     IN OUT PWORK_CONTEXT WorkContext
//     )
//
// Routine Description:
//
//     This routine is called when all request processing on an SMB is
//     complete and a response is to be sent.  It starts the sending of
//     that response.  The work item will be queued for final cleanup when
//     the send completes.
//
// Arguments:
//
//     WorkContext - Supplies a pointer to the work context block
//         containing information about the SMB.
//
// Return Value:
//
//    None.
//

#define SrvFsdSendResponse( _wc ) {                               \
                                                                  \
    (_wc)->ResponseBuffer->DataLength =                           \
                    (CLONG)( (PCHAR)(_wc)->ResponseParameters -   \
                                (PCHAR)(_wc)->ResponseHeader );   \
    (_wc)->ResponseHeader->Flags |= SMB_FLAGS_SERVER_TO_REDIR;    \
    SRV_START_SEND_2( (_wc), SrvFsdRestartSmbAtSendCompletion, NULL, NULL );    \
    }

//
// VOID
// SrvFsdSendResponse2 (
//     IN OUT PWORK_CONTEXT WorkContext,
//     IN PRESTART_ROUTINE FspRestartRoutine
//     )
//
// Routine Description:
//
//     This routine is identical to SrvFsdSendResponse, except that
//     processing restarts after the send in the FSP, not the FSD.
//
//     *** If you change either SrvFsdSendResponse or SrvFsdSendResponse2,
//         CHANGE BOTH OF THEM!
//
// Arguments:
//
//     WorkContext - Supplies a pointer to the work context block
//         containing information about the SMB.
//
//     FspRestartRoutine - Supplies the address of the restart routine in
//         the FSP that is to be called when the TdiSend completes.
//
// Return Value:
//
//     None.
//

#define SrvFsdSendResponse2( _wc, _fspRestart ) {                       \
                                                                        \
    (_wc)->ResponseBuffer->DataLength =                                 \
                    (CLONG)( (PCHAR)(_wc)->ResponseParameters -         \
                                (PCHAR)(_wc)->ResponseHeader );         \
    (_wc)->ResponseHeader->Flags |= SMB_FLAGS_SERVER_TO_REDIR;          \
    SRV_START_SEND_2((_wc), SrvQueueWorkToFspAtSendCompletion, NULL, (_fspRestart));\
    }

//
// VOID
// ParseLockData (
//     IN BOOLEAN LargeFileLock,
//     IN PLOCKING_ANDX_RANGE SmallRange,
//     IN PNTLOCKING_ANDX_RANGE LargeRange,
//     OUT PUSHORT Pid,
//     OUT PLARGE_INTEGER Offset,
//     OUT PLARGE_INTEGER Length
//     )
// {
//

#define ParseLockData( _largeLock, _sr, _lr, _pid, _offset, _len ) {    \
                                                                        \
        if ( _largeLock ) {                                             \
            *(_pid) = SmbGetUshort( &(_lr)->Pid );                      \
            (_offset)->LowPart = SmbGetUlong( &(_lr)->OffsetLow );      \
            (_offset)->HighPart = SmbGetUlong( &(_lr)->OffsetHigh );    \
            (_len)->LowPart = SmbGetUlong( &(_lr)->LengthLow );         \
            (_len)->HighPart = SmbGetUlong( &(_lr)->LengthHigh );       \
        } else {                                                        \
            *(_pid) = SmbGetUshort( &(_sr)->Pid );                      \
            (_offset)->QuadPart = SmbGetUlong( &(_sr)->Offset );        \
            (_len)->QuadPart = SmbGetUlong( &(_sr)->Length );           \
        }                                                               \
    }

//
// CHECK_SEND_COMPLETION_STATUS( _status ) will log errors
// that occurs during send completion.
//

#define CHECK_SEND_COMPLETION_STATUS( _status ) {                       \
    InterlockedDecrement( &WorkContext->Connection->OperationsPendingOnTransport ); \
    if ( !NT_SUCCESS( _status ) ) {                                     \
        SrvCheckSendCompletionStatus( _status, __LINE__ );              \
    } else {                                                            \
        SrvUpdateErrorCount( &SrvNetworkErrorRecord, FALSE );           \
    }                                                                   \
}
#define CHECK_SEND_COMPLETION_STATUS_CONNECTIONLESS( _status ) {                       \
    if ( !NT_SUCCESS( _status ) ) {                                     \
        SrvCheckSendCompletionStatus( _status, __LINE__ );              \
    } else {                                                            \
        SrvUpdateErrorCount( &SrvNetworkErrorRecord, FALSE );           \
    }                                                                   \
}

//
// Definitions for unlockable code sections.
//

#define SRV_CODE_SECTION_1AS  0
#define SRV_CODE_SECTION_8FIL 1
#define SRV_CODE_SECTION_MAX  2

extern SRV_LOCK SrvUnlockableCodeLock;

typedef struct _SECTION_DESCRIPTOR {
    PVOID Base;
    PVOID Handle;
    ULONG ReferenceCount;
} SECTION_DESCRIPTOR, *PSECTION_DESCRIPTOR;

extern SECTION_DESCRIPTOR SrvSectionInfo[SRV_CODE_SECTION_MAX];

#define UNLOCKABLE_CODE( _section )                                     \
    ASSERTMSG( "Unlockable code called while section not locked",       \
        SrvSectionInfo[SRV_CODE_SECTION_##_section##].Handle != NULL )

VOID
SrvReferenceUnlockableCodeSection (
    IN ULONG CodeSection
    );

VOID
SrvDereferenceUnlockableCodeSection (
    IN ULONG CodeSection
    );

//
// We only need to lock these sections on the workstation product,
//  since we lock them down in InitializeServer() if we're NTAS
//
#define REFERENCE_UNLOCKABLE_CODE( _section ) \
    if( !SrvProductTypeServer ) SrvReferenceUnlockableCodeSection( SRV_CODE_SECTION_##_section## )

#define DEREFERENCE_UNLOCKABLE_CODE( _section ) \
    if( !SrvProductTypeServer) SrvDereferenceUnlockableCodeSection( SRV_CODE_SECTION_##_section## )


#define GET_BLOCKING_WORK_QUEUE() ( (SrvNumberOfProcessors < 4) ? SrvBlockingWorkQueues : (SrvBlockingWorkQueues + KeGetCurrentProcessorNumber()) )


//
// VOID
// SrvInsertWorkQueueTail (
//     IN OUT PWORK_QUEUE WorkQueue,
//     IN PQUEUEABLE_BLOCK_HEADER WorkItem
//     )

#if SRVDBG_STATS2
#define SrvInsertWorkQueueTail( _workQ, _workItem ) {                   \
    ULONG depth;                                                        \
    GET_SERVER_TIME( _workQ, &(_workItem)->Timestamp );                 \
    depth = KeInsertQueue( &(_workQ)->Queue, &(_workItem)->ListEntry ); \
    (_workQ)->ItemsQueued++;                                            \
    if ( (LONG)depth > (_workQ)->MaximumDepth ) {                       \
        (_workQ)->MaximumDepth = (LONG)depth;                           \
    }                                                                   \
}
#else
#define SrvInsertWorkQueueTail( _workQ, _workItem ) {                   \
    GET_SERVER_TIME( _workQ, &(_workItem)->Timestamp );                 \
    (VOID)KeInsertQueue( &(_workQ)->Queue, &(_workItem)->ListEntry );   \
}
#endif // SRVDBG_STATS2

//
// VOID
// SrvInsertWorkQueueHead (
//     IN OUT PWORK_QUEUE WorkQueue,
//     IN PQUEUEABLE_BLOCK_HEADER WorkItem
//     )
#define SrvInsertWorkQueueHead( _workQ, _workItem ) {                    \
    GET_SERVER_TIME( _workQ, &(_workItem)->Timestamp );                  \
    (VOID)KeInsertHeadQueue( &(_workQ)->Queue, &(_workItem)->ListEntry );\
}

//
// BOOLEAN
// SrvRetryDueToDismount(
//      IN PSHARE Share,
//      IN NTSTATUS Status
//  )
#define SrvRetryDueToDismount( _share, _status ) \
        ((_status) == STATUS_VOLUME_DISMOUNTED && \
        SrvRefreshShareRootHandle( _share, &(_status) ) )



#if DBG_STUCK
#define SET_OPERATION_START_TIME( _context ) \
    if( *(_context) != NULL ) KeQuerySystemTime( &((*(_context))->OpStartTime) );
#else
#define SET_OPERATION_START_TIME( _context )
#endif

#if DBG
#define CHECKIRP( irp ) {                                                       \
    if( (irp) && (irp)->CurrentLocation != (irp)->StackCount + 1 ) {            \
        DbgPrint( "SRV: IRP %p already in use at %u!\n", irp, __LINE__ );       \
        DbgBreakPoint();                                                        \
    }                                                                           \
}
#else
#define CHECKIRP( irp )
#endif

//
// Allocate a WORK_CONTEXT structure.
//
#define INITIALIZE_WORK_CONTEXT( _queue, _context ) {\
    (_context)->BlockHeader.ReferenceCount = 1; \
    GET_SERVER_TIME( _queue, &(_context)->Timestamp ); \
    RtlZeroMemory( &(_context)->Endpoint, sizeof( struct _WorkContextZeroBeforeReuse ) ); \
    SrvWmiInitContext((_context)); \
}

#define ALLOCATE_WORK_CONTEXT( _queue, _context ) {             \
    *(_context) = NULL;                                         \
    *(_context) = (PWORK_CONTEXT)InterlockedExchangePointer( &(_queue)->FreeContext, (*_context) ); \
    if( *(_context) != NULL ) {                                 \
        INITIALIZE_WORK_CONTEXT( _queue, *(_context) );         \
    } else {                                                    \
        *(_context) = SrvFsdGetReceiveWorkItem( _queue );       \
    }                                                           \
    CHECKIRP( *(_context) ? (*(_context))->Irp : NULL );        \
    SET_OPERATION_START_TIME( _context )                        \
}

//
// Returns the work item to the free list.
//

#define RETURN_FREE_WORKITEM( _wc ) \
    do {                                                                \
        PWORK_QUEUE _queue  = _wc->CurrentWorkQueue;                    \
        ASSERT( _queue >= SrvWorkQueues && _queue < eSrvWorkQueues );   \
        ASSERT( _wc->BlockHeader.ReferenceCount == 0 );                 \
        ASSERT( _wc->FreeList != NULL );                                \
        CHECKIRP( (_wc)->Irp );                                         \
        if( (_wc)->Irp->AssociatedIrp.SystemBuffer &&                   \
            (_wc)->Irp->Flags & IRP_DEALLOCATE_BUFFER ) {               \
                ExFreePool( (_wc)->Irp->AssociatedIrp.SystemBuffer );   \
                (_wc)->Irp->AssociatedIrp.SystemBuffer = NULL;          \
                (_wc)->Irp->Flags &= ~IRP_DEALLOCATE_BUFFER;            \
        }                                                               \
        if( _queue->NeedWorkItem ) {                                    \
            if( InterlockedDecrement( &(_queue->NeedWorkItem) ) >= 0 ){ \
                _wc->FspRestartRoutine = SrvServiceWorkItemShortage;    \
                SrvInsertWorkQueueHead( _queue, _wc );                  \
                break;                                                  \
            } else {                                                    \
                InterlockedIncrement( &(_queue->NeedWorkItem) );        \
            }                                                           \
        }                                                               \
        _wc = (PWORK_CONTEXT)InterlockedExchangePointer( &_queue->FreeContext, _wc ); \
        if( _wc ) {                                                     \
            CHECKIRP( (_wc)->Irp );                                     \
            ExInterlockedPushEntrySList( _wc->FreeList, &_wc->SingleListEntry, &_queue->SpinLock );\
            InterlockedIncrement( &_queue->FreeWorkItems );             \
        }                                                               \
    } while (0);

//
// Our current work queue, based on our current processor
//

#if MULTIPROCESSOR

#define PROCESSOR_TO_QUEUE()  (&SrvWorkQueues[ KeGetCurrentProcessorNumber() ])

#else

#define PROCESSOR_TO_QUEUE() (&SrvWorkQueues[0])

#endif

#define SET_INVALID_CONTEXT_HANDLE(h)   ((h).dwLower = (h).dwUpper = (ULONG)(-1))

#define IS_VALID_CONTEXT_HANDLE(h)      (((h).dwLower != (ULONG) -1) && ((h).dwUpper != (ULONG) -1))

#ifdef POOL_TAGGING

//
// Macro to map from block type to pool tag.
//

extern ULONG SrvPoolTags[BlockTypeMax-1];
#define TAG_FROM_TYPE(_type) SrvPoolTags[(_type)-1]

#else

#define TAG_FROM_TYPE(_type) ignoreme

#endif // def POOL_TAGGING

#endif // def _SRVMACRO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\srvnls.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    srvnls.h

Abstract:

    This module defines string constants used by the LAN Manager server.
    The purpose of this module is to isolate NLS concerns.

Author:

    Chuck Lenzmeier (chuckl) 12-Jun-1990

Revision History:

--*/

#ifndef _SRVNLS_
#define _SRVNLS_


#endif // ndef _SRVNLS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\srvfsp.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    srvfsp.h

Abstract:

    This module defines main FSP routines for the LAN Manager server.

Author:

    Chuck Lenzmeier (chuckl) 1-Dec-1989

Revision History:

--*/

#ifndef _SRVFSP_
#define _SRVFSP_

//#include <ntos.h>

//
// Configuration thread routine.  Processes requests from the server
// service.  Runs in an EX worker thread.
//

VOID
SrvConfigurationThread (
    IN PDEVICE_OBJECT pDevice,
    IN PIO_WORKITEM pWorkItem
    );

//
// Thread manager routines
//

NTSTATUS
SrvInitializeScavenger (
    VOID
    );

VOID
SrvResourceThread (
    IN PVOID Parameter
    );

VOID
SrvResourceAllocThread (
    IN PVOID Parameter
    );

VOID
SrvTerminateScavenger (
    VOID
    );

NTSTATUS
SrvCreateWorkerThreads (
    VOID
    );

VOID SRVFASTCALL
SrvTerminateWorkerThread (
    IN OUT PWORK_CONTEXT SpecialWorkItem
    );

VOID
SrvBalanceLoad (
    IN OUT PCONNECTION connection
    );

//
// Work queue functions.
//

VOID SRVFASTCALL
SrvQueueWorkToBlockingThread (
    IN OUT PWORK_CONTEXT WorkContext
    );

NTSTATUS SRVFASTCALL
SrvQueueWorkToLpcThread (
    IN OUT PWORK_CONTEXT WorkContext,
    IN BOOLEAN ThrottleRequest
    );

VOID SRVFASTCALL
SrvQueueWorkToFsp (
    IN OUT PWORK_CONTEXT WorkContext
    );

//
// SrvQueueWorkToFspAtDpcLevel was once a different routine than
// SrvQueueWorkToFsp -- the latter routine called KeRaise/LowerIrql.
// With the advent of the kernel queue object, there is no longer a
// difference between the routines.  The calling code has not been
// changed in order to retain the knowledge about which callers can use
// the optimized call if there is ever again a difference between them.
//

#define SrvQueueWorkToFspAtDpcLevel SrvQueueWorkToFsp

#define QUEUE_WORK_TO_FSP(_work) {                  \
    (_work)->ProcessingCount++;                     \
    SrvInsertWorkQueueTail(                         \
        _work->CurrentWorkQueue,                    \
        (PQUEUEABLE_BLOCK_HEADER)(_work)            \
        );                                          \
}

//
// Routine in scavengr.c to store scavenger/alerter timeouts.
//

VOID
SrvCaptureScavengerTimeout (
    IN PLARGE_INTEGER ScavengerTimeout,
    IN PLARGE_INTEGER AlerterTimeout
    );

VOID
SrvUpdateStatisticsFromQueues (
    OUT PSRV_STATISTICS CapturedSrvStatistics OPTIONAL
    );

#endif // ndef _SRVFSP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\srvio.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    srvio.h

Abstract:

    This module defines functions for building I/O request packets for
    the LAN Manager server.

Author:

    Chuck Lenzmeier (chuckl) 1-Dec-1989

Revision History:

--*/

#ifndef _SRVIO_
#define _SRVIO_

//#include <ntos.h>

//
// I/O request packet builders
//

PIRP
SrvBuildIoControlRequest (
    IN OUT PIRP Irp OPTIONAL,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PVOID Context,
    IN UCHAR MajorFunction,
    IN ULONG IoControlCode,
    IN PVOID MainBuffer,
    IN ULONG InputBufferLength,
    IN PVOID AuxiliaryBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN OUT PMDL Mdl OPTIONAL,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine OPTIONAL
    );

VOID
SrvBuildFlushRequest (
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN PVOID Context OPTIONAL
    );

VOID
SrvBuildLockRequest (
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN PVOID Context OPTIONAL,
    IN LARGE_INTEGER ByteOffset,
    IN LARGE_INTEGER Length,
    IN ULONG Key,
    IN BOOLEAN FailImmediately,
    IN BOOLEAN ExclusiveLock
    );

VOID
SrvBuildReadOrWriteRequest (
    IN OUT PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN PVOID Context OPTIONAL,
    IN UCHAR MajorFunction,
    IN UCHAR MinorFunction,
    IN PVOID Buffer OPTIONAL,
    IN ULONG Length,
    IN OUT PMDL Mdl OPTIONAL,
    IN LARGE_INTEGER ByteOffset,
    IN ULONG Key OPTIONAL
    );

PIRP
SrvBuildNotifyChangeRequest (
    IN OUT PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN PVOID Context OPTIONAL,
    IN ULONG CompletionFilter,
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN BOOLEAN WatchTree
    );

VOID
SrvBuildMailslotWriteRequest (
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN PVOID Context OPTIONAL,
    IN PVOID Buffer OPTIONAL,
    IN ULONG Length
    );

NTSTATUS
SrvIssueMdlCompleteRequest (
    IN PWORK_CONTEXT WorkContext OPTIONAL,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PMDL Mdl,
    IN UCHAR Function,
    IN PLARGE_INTEGER ByteOffset,
    IN ULONG Length
    );

NTSTATUS
SrvIssueAssociateRequest (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT *DeviceObject,
    IN HANDLE AddressFileHandle
    );

NTSTATUS
SrvIssueDisconnectRequest (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT *DeviceObject,
    IN ULONG Flags
    );

NTSTATUS
SrvIssueTdiAction (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT *DeviceObject,
    IN PCHAR Buffer,
    IN ULONG BufferLength
    );

NTSTATUS
SrvIssueTdiQuery (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT *DeviceObject,
    IN PCHAR Buffer,
    IN ULONG BufferLength,
    IN ULONG QueryType
    );

NTSTATUS
SrvIssueQueryDirectoryRequest (
    IN HANDLE FileHandle,
    IN PCHAR Buffer,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN PUNICODE_STRING FileName OPTIONAL,
    IN PULONG FileIndex OPTIONAL,
    IN BOOLEAN RestartScan,
    IN BOOLEAN SingleEntriesOnly
    );

NTSTATUS
SrvIssueQueryEaRequest (
    IN HANDLE FileHandle,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PVOID EaList OPTIONAL,
    IN ULONG EaListLength,
    IN BOOLEAN RestartScan,
    OUT PULONG EaErrorOffset OPTIONAL
    );

NTSTATUS
SrvIssueSendDatagramRequest (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT *DeviceObject,
    IN PTDI_CONNECTION_INFORMATION SendDatagramInformation,
    IN PVOID Buffer,
    IN ULONG Length
    );

NTSTATUS
SrvIssueSetClientProcessRequest (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT *DeviceObject,
    IN PCONNECTION Connection,
    IN PVOID ClientSession,
    IN PVOID ClientProcess
    );

NTSTATUS
SrvIssueSetEaRequest (
    IN HANDLE FileHandle,
    IN PVOID Buffer,
    IN ULONG Length,
    OUT PULONG EaErrorOffset OPTIONAL
    );

NTSTATUS
SrvIssueSetEventHandlerRequest (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT *DeviceObject,
    IN ULONG EventType,
    IN PVOID EventHandler,
    IN PVOID EventContext
    );

NTSTATUS
SrvIssueUnlockRequest (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT *DeviceObject,
    IN UCHAR UnlockOperation,
    IN LARGE_INTEGER ByteOffset,
    IN LARGE_INTEGER Length,
    IN ULONG Key
    );

NTSTATUS
SrvIssueUnlockSingleRequest (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT *DeviceObject,
    IN LARGE_INTEGER ByteOffset,
    IN LARGE_INTEGER Length,
    IN ULONG Key
    );

NTSTATUS
SrvIssueWaitForOplockBreak (
    IN HANDLE FileHandle,
    PWAIT_FOR_OPLOCK_BREAK WaitForOplockBreak
    );

VOID
SrvQuerySendEntryPoint(
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT *DeviceObject,
    IN ULONG IoControlCode,
    IN PVOID *EntryPoint
    );

#endif // ndef _SRVIO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\srvnet.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    srvnet.h

Abstract:

    This module defines types and functions for accessing the network
    for the LAN Manager server.

Author:

    Chuck Lenzmeier (chuckl) 1-Dec-1989

Revision History:

--*/

#ifndef _SRVNET_
#define _SRVNET_

//#include <ntos.h>

//#include "srvblock.h"


//
// Network manager routines
//

NTSTATUS
SrvAddServedNet (
    IN PUNICODE_STRING NetworkName,
    IN PUNICODE_STRING TransportName,
    IN PANSI_STRING TransportAddress,
    IN PUNICODE_STRING DomainName,
    IN ULONG           Flags,
    IN DWORD           PasswordLength,
    IN PBYTE           Password
    );

NTSTATUS
SrvDoDisconnect (
    IN OUT PCONNECTION Connection
    );

NTSTATUS
SrvDeleteServedNet (
    IN PUNICODE_STRING TransportName,
    IN PANSI_STRING TransportAddress
    );

NTSTATUS
SrvOpenConnection (
    IN PENDPOINT Endpoint
    );

VOID
SrvPrepareReceiveWorkItem (
    IN OUT PWORK_CONTEXT WorkContext,
    IN BOOLEAN QueueToFreeList
    );

VOID SRVFASTCALL
SrvRestartAccept (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID
SrvStartSend (
    IN OUT PWORK_CONTEXT WorkContext,
    IN PIO_COMPLETION_ROUTINE SendCompletionRoutine,
    IN PMDL Mdl OPTIONAL,
    IN ULONG SendOptions
    );

VOID
SrvStartSend2 (
    IN OUT PWORK_CONTEXT WorkContext,
    IN PIO_COMPLETION_ROUTINE SendCompletionRoutine
    );

ULONG
GetIpxMaxBufferSize(
    PENDPOINT Endpoint,
    ULONG AdapterNumber,
    ULONG DefaultMaxBufferSize
    );

#endif // ndef _SRVNET_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\srvstamp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    srvstamp.h

Abstract:

    This module defines the file stamp support routines for the server
Author:

    David Kruse (dkruse) 10-23-2000
    
Revision History:

--*/

#ifndef _SRVSTAMP_
#define _SRVSTAMP_

#ifdef SRVCATCH
void SrvIsMonitoredShare( PSHARE Share );
ULONG SrvFindCatchOffset( OUT PVOID pBuffer, ULONG BufferSize );
void SrvCorrectCatchBuffer( PVOID pBuffer, ULONG CatchOffset );
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\srvsnap.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    srvsnap.c

Abstract:

    This module contains routines for supporting the SnapShot feature
    that interfaces CIFS with SnapShots

Author:

    David Kruse (dkruse) 22-March-2001

Revision History:

--*/

#include "precomp.h"
#include <initguid.h>
#include <mountmgr.h>
#include <strsafe.h>
#include "srvsupp.h"
#include "ntddsnap.h"
#include "stdarg.h"
#include "stdio.h"
#include "srvsnap.tmh"
#pragma hdrstop

#define MAX_SNAPSHOTS_PER_SHARE 500

// Function Declaractions
NTSTATUS
StartIoAndWait (
    IN PIRP Irp,
    IN PDEVICE_OBJECT DeviceObject,
    IN PKEVENT Event,
    IN PIO_STATUS_BLOCK IoStatusBlock
    );

PIRP
BuildCoreOfSyncIoRequest (
    IN HANDLE FileHandle,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PKEVENT Event,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN OUT PDEVICE_OBJECT *DeviceObject
    );

NTSTATUS
SrvSnapIssueIoctl(
    IN HANDLE hFile,
    IN DWORD IOCtl,
    IN OUT PVOID pBuffer,
    IN OUT LPDWORD lpdwBufSize
    );

NTSTATUS
SrvSnapGetNamesForVolume(
    IN HANDLE hFile,
    OUT PVOLSNAP_NAMES* Names
    );

NTSTATUS
SrvSnapGetEpicForVolume(
    IN HANDLE hFile,
    OUT PLONG Epic
    );

NTSTATUS
SrvSnapFillConfigInfo(
    IN PSHARE_SNAPSHOT SnapShare,
    IN PUNICODE_STRING SnapShotPath
    );

BOOLEAN
SrvParseMultiSZ(
    IN OUT PUNICODE_STRING mszString
    );

NTSTATUS
SrvSnapInsertSnapIntoShare(
    IN PSHARE Share,
    IN PSHARE_SNAPSHOT SnapShot
    );

NTSTATUS
SrvSnapAddShare(
    IN PSHARE Share,
    IN PUNICODE_STRING SnapPath
    );

NTSTATUS
SrvSnapRemoveShare(
    IN PSHARE_SNAPSHOT SnapShare
    );

NTSTATUS
SrvSnapCheckForAndCreateSnapShare(
    IN PSHARE Share,
    IN PUNICODE_STRING SnapShotName
    );

NTSTATUS
SrvSnapRefreshSnapShotsForShare(
    IN PSHARE Share
    );

NTSTATUS
SrvSnapEnumerateSnapShots(
    IN PWORK_CONTEXT WorkContext
    );

NTSTATUS
SrvSnapGetRootHandle(
    IN PWORK_CONTEXT WorkContext,
    OUT HANDLE* RootHandle
    );

NTSTATUS
SrvSnapGetNameString(
    IN PWORK_CONTEXT WorkContext,
    OUT PUNICODE_STRING* ShareName,
    OUT PBOOLEAN AllocatedShareName
    );

BOOLEAN
ExtractNumber(
    IN PWSTR psz,
    IN ULONG Count,
    OUT PLONG value
    );

BOOLEAN
SrvSnapParseToken(
    IN PWSTR Source,
    IN ULONG SourceSizeInBytes,
    OUT PLARGE_INTEGER TimeStamp
    );

NTSTATUS
SrvSnapCheckAppInfoForTimeWarp(
    IN PUNICODE_STRING SnapShotHandle
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvSnapIssueIoctl )
#pragma alloc_text( PAGE, SrvSnapGetNamesForVolume )
#pragma alloc_text( PAGE, SrvSnapGetEpicForVolume )
#pragma alloc_text( PAGE, SrvSnapFillConfigInfo )
#pragma alloc_text( PAGE, SrvParseMultiSZ )
#pragma alloc_text( PAGE, SrvSnapInsertSnapIntoShare )
#pragma alloc_text( PAGE, SrvSnapAddShare )
#pragma alloc_text( PAGE, SrvSnapRemoveShare )
#pragma alloc_text( PAGE, SrvSnapCheckForAndCreateSnapShare )
#pragma alloc_text( PAGE, SrvSnapRefreshSnapShotsForShare )
#pragma alloc_text( PAGE, SrvSnapEnumerateSnapShots )
#pragma alloc_text( PAGE, SrvSnapGetRootHandle )
#pragma alloc_text( PAGE, SrvSnapGetNameString )
#pragma alloc_text( PAGE, ExtractNumber )
#pragma alloc_text( PAGE, SrvSnapParseToken )
#pragma alloc_text( PAGE, SrvSnapCheckAppInfoForTimeWarp )
#pragma alloc_text( PAGE, SrvSnapEnumerateSnapShotsAsDirInfo )
#endif

//
// Helper Functions
//

NTSTATUS
SrvSnapIssueIoctl(
    IN HANDLE hFile,
    IN DWORD IOCtl,
    IN OUT PVOID pBuffer,
    IN OUT LPDWORD lpdwBufSize
    )
/*++

Routine Description:

    This function takes a volume handle and attempts to enumerate all the
    SnapShots on that volume into the given buffer

Arguments:

    hFile - The handle to the volume

    IOCtl - the IoControl to issue

    pBuffer - A pointer to the output buffer

    lpdwBufSize - Pointer to the size of passed in buffer.  Set to the
    required size if STATUS_BUFFER_OVERFLOW is returned

Return Value:

    NTSTATUS - Expected return codes are STATUS_SUCCESS or STATUS_BUFFER_OVERFLOW.
      Any other response is an unexpected error code and the request should be
      failed

--*/

{
    PIRP Irp = NULL;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatus;
    KEVENT CompletionEvent;
    PDEVICE_OBJECT DeviceObject = NULL;
    PIO_STACK_LOCATION IrpSp;

    PAGED_CODE();

    // Initialize the variables
    KeInitializeEvent( &CompletionEvent, SynchronizationEvent, FALSE );

    // Create the IRP
    Irp = BuildCoreOfSyncIoRequest(
                        hFile,
                        NULL,
                        &CompletionEvent,
                        &IoStatus,
                        &DeviceObject );
    if( !Irp )
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Initialize the other IRP fields
    Irp->Flags |= (LONG)IRP_BUFFERED_IO;
    Irp->AssociatedIrp.SystemBuffer = pBuffer;
    IrpSp = IoGetNextIrpStackLocation( Irp );
    IrpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    IrpSp->MinorFunction = 0;
    IrpSp->Parameters.DeviceIoControl.OutputBufferLength = *lpdwBufSize;
    IrpSp->Parameters.DeviceIoControl.InputBufferLength = 0;
    IrpSp->Parameters.DeviceIoControl.IoControlCode = IOCtl;
    IrpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

    // Issue the IO
    Status = StartIoAndWait( Irp, DeviceObject, &CompletionEvent, &IoStatus );

    // If this was a buffer overflow, update the value
    if( Status == STATUS_BUFFER_OVERFLOW )
    {
        *lpdwBufSize = (DWORD)(IoStatus.Information);
    }

    return Status;
}


NTSTATUS
SrvSnapGetNamesForVolume(
    IN HANDLE hFile,
    OUT PVOLSNAP_NAMES* Names
    )
/*++

Routine Description:

    This function takes a volume handle and returns the list of SnapShots for that
    volume.  If an error occurs, or no SnapShots exist, the returned pointer is
    NULL.   NOTE: The caller is responsible for freeing the returned pointer via
    DEALLOCATE_NONPAGED_POOL

Arguments:

    hFile - The handle to the volume

    Names - A pointer to the pointer where we will store the volume name list

Return Value:

    NTSTATUS - Expected return code is STATUS_SUCCESS . Any other response is an
    unexpected error code and the request should be failed

--*/
{
    NTSTATUS Status;
    VOLSNAP_NAMES VolNamesBase;
    PVOLSNAP_NAMES pNames = NULL;
    DWORD dwSize = sizeof(VOLSNAP_NAMES);

    PAGED_CODE();

    // Initialize the values
    *Names = NULL;

    // Find out how big it should be
    Status = SrvSnapIssueIoctl( hFile, IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS, &VolNamesBase, &dwSize );

    if( Status != STATUS_BUFFER_OVERFLOW )
    {
        return Status;
    }

    // Allocate the correct size block
    dwSize = VolNamesBase.MultiSzLength + sizeof(VOLSNAP_NAMES);
    pNames = (PVOLSNAP_NAMES)ALLOCATE_NONPAGED_POOL( dwSize, BlockTypeSnapShot );
    if( !pNames )
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Build up the IRP to be used for the query
    Status = SrvSnapIssueIoctl( hFile, IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS, pNames, &dwSize );

    // Save the output if we're successful, or else deallocate
    if( !NT_SUCCESS(Status) )
    {
        if( pNames )
        {
            DEALLOCATE_NONPAGED_POOL( pNames );
            pNames = NULL;
            *Names = NULL;
        }
    }
    else
    {
        ASSERT(pNames);
        *Names = pNames;
    }

    return Status;
}

NTSTATUS
SrvSnapGetEpicForVolume(
    IN HANDLE hFile,
    OUT PLONG Epic
    )
/*++

Routine Description:

    This function takes a volume handle and returns the epic number for the volume that
    hosts the share

Arguments:

    hFile - The handle to the volume

    Epic  - Pointer to LONG that will receive the data

Return Value:

    NTSTATUS - Expected return code is STATUS_SUCCESS . Any other response is an
    unexpected error code and the request should be failed

--*/
{
    NTSTATUS Status;
    VOLSNAP_EPIC VolEpic;
    DWORD dwSize = sizeof(VOLSNAP_EPIC);

    PAGED_CODE();

    // Build up the IRP to be used for the query
    Status = SrvSnapIssueIoctl( hFile, IOCTL_VOLSNAP_QUERY_EPIC, &VolEpic, &dwSize );

    if( NT_SUCCESS(Status) )
    {
        *Epic = VolEpic.EpicNumber;
    }
    else
    {
        *Epic = -1;
    }

    return Status;
}

NTSTATUS
SrvSnapFillConfigInfo(
    IN PSHARE_SNAPSHOT SnapShare,
    IN PUNICODE_STRING SnapShotPath
    )
/*++

Routine Description:

    This function takes a SnapShare with existing names filled in and
    queries the extra config info (the timestamp, the epic) for that SnapShot

Arguments:

    SnapShare - Pointer to the SnapShot share to be filled in

Return Value:

    NTSTATUS - Expected return code is STATUS_SUCCESS . Any other response is an
    unexpected error code and the request should be failed

--*/
{
    HANDLE hVolume;
    DWORD dwSize = sizeof(VOLSNAP_CONFIG_INFO);
    NTSTATUS Status;
    OBJECT_ATTRIBUTES objectAttributes;
    VOLSNAP_CONFIG_INFO ConfigInfo;
    IO_STATUS_BLOCK IoStatus;

    PAGED_CODE();

    // Now open the SnapShot handle
    InitializeObjectAttributes(
        &objectAttributes,
        SnapShotPath,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );
    Status = NtOpenFile(
                &hVolume,
                0,
                &objectAttributes,
                &IoStatus,
                FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                0
                );
    if( !NT_SUCCESS(Status) )
    {
        return Status;
    }

    // Get the timestamp
    Status = SrvSnapIssueIoctl( hVolume, IOCTL_VOLSNAP_QUERY_CONFIG_INFO, &ConfigInfo, &dwSize );
    if( NT_SUCCESS( Status ) )
    {
        // Fill in the info
        SnapShare->Timestamp = ConfigInfo.SnapshotCreationTime;
    }

    NtClose( hVolume );
    return Status;
}

BOOLEAN
SrvParseMultiSZ(
    IN OUT PUNICODE_STRING mszString
    )
/*++

Routine Description:

    This function takes a UNICODE_STRING that points to a MultiSZ value, and
    parses it with each iteration (similar to strtok( psz, "\0" )).  For every
    iteration this returns TRUE, the string will point to the next SZ in the
    MultiSZ

Arguments:

    mszString - Pointer to the MultiSZ string.  For the first iteration, set the
    MaximumLength to the length of the MultiSZ, and the Length to 0.  For all
    other iterations, simply pass in the string from the previous iteration

Return Value:

    BOOLEAN - If TRUE, this is a valid SZ.  If FALSE, all have been parsed

--*/
{
    USHORT Count;

    PAGED_CODE();

    ASSERT( mszString->Length <= mszString->MaximumLength );

    if( mszString->Length > 0 )
    {
        // Move the pointer past the string and the NULL
        mszString->Buffer += (mszString->Length/2)+1;
        mszString->MaximumLength -= (mszString->Length+2);
    }

    for( Count=0; Count<mszString->MaximumLength; Count++ )
    {
        if( mszString->Buffer[Count] == (WCHAR)'\0' )
        {
            mszString->Length = Count*2;
            if( Count > 0 )
                return TRUE;
            else
                return FALSE;
        }
    }

    // The starting data was bad!
    ASSERT(FALSE);

    return FALSE;
}

NTSTATUS
SrvSnapInsertSnapIntoShare(
    IN PSHARE Share,
    IN PSHARE_SNAPSHOT SnapShot
    )
{
    PLIST_ENTRY ListEntry = Share->SnapShots.Flink;

    PAGED_CODE();

    // Walk the SnapShot share list and see if this is a duplicate
    while( ListEntry != &Share->SnapShots )
    {
        PSHARE_SNAPSHOT snapShare = CONTAINING_RECORD( ListEntry, SHARE_SNAPSHOT, SnapShotList );
        if( RtlEqualUnicodeString( &SnapShot->SnapShotName, &snapShare->SnapShotName, TRUE ) )
        {
            return STATUS_DUPLICATE_NAME;
        }
        ListEntry = ListEntry->Flink;
    }


    InsertTailList( &Share->SnapShots, &SnapShot->SnapShotList );
    return STATUS_SUCCESS;
}


NTSTATUS
SrvSnapAddShare(
    IN PSHARE Share,
    IN PUNICODE_STRING SnapPath
    )
/*++

Routine Description:

    This function allocates a SnapShot Share that is being added to the system and
    initializes it

Arguments:

    Share - Pointer to the parent share

    SnapPath - UNICODE_STRING name of the SnapShot (\\Device\\HardDiskSnap1)

    NOTE: Caller must have the SnapShotLock acquired

Return Value:

    NTSTATUS - Returns STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES

--*/
{
#define SHARE_DEVICE_HEADER 6
    NTSTATUS Status;
    PSHARE_SNAPSHOT snapShare = NULL;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK IoStatus;
    ULONG AllocSize;
    TIME_FIELDS rtlTime;
    WCHAR FieldSeperator = L'\\';

    PAGED_CODE();

    IF_DEBUG( SNAPSHOT) KdPrint(( "SrvSnapAddShare %p %wZ\n", Share, SnapPath ));

    // Calculate the size to allocate
    // sizeof(SNAP_STRUCT) + (Length of SnapShotName) + (Max Length of SnapShot Path)
    AllocSize = sizeof(SHARE_SNAPSHOT) + SNAPSHOT_NAME_LENGTH + (SnapPath->Length + Share->RelativePath.Length + 2);

    snapShare = ALLOCATE_HEAP( AllocSize, BlockTypeSnapShot );
    if( !snapShare )
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Initialize the SnapShot-share structure
    RtlZeroMemory( snapShare, sizeof(SHARE_SNAPSHOT) );
    snapShare->SnapShotName.MaximumLength = SNAPSHOT_NAME_LENGTH;
    snapShare->SnapShotName.Length = 0;
    snapShare->SnapShotName.Buffer = (PWCHAR)(snapShare+1);

    // This is only valid on shares who's NT Path is \??\X:\ where X is a logical drive
    // Don't allow any others
    if( Share->NtPathName.Length < (SHARE_DEVICE_HEADER+1)*sizeof(WCHAR) )
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Build the new SnapShot-relative path
    snapShare->SnapShotPath.MaximumLength = SnapPath->Length + Share->RelativePath.Length + 2;
    snapShare->SnapShotPath.Length = 0;
    snapShare->SnapShotPath.Buffer = snapShare->SnapShotName.Buffer + (snapShare->SnapShotName.MaximumLength/sizeof(WCHAR));

    // Build the path by starting with the device name
    RtlCopyUnicodeString( &snapShare->SnapShotPath, SnapPath );

    // Append the middle whack
    RtlCopyMemory( snapShare->SnapShotPath.Buffer + (snapShare->SnapShotPath.Length/sizeof(WCHAR)), &FieldSeperator, sizeof(WCHAR) );
    snapShare->SnapShotPath.Length += sizeof(WCHAR);

    // Now append the Relative Path name
    RtlCopyMemory( snapShare->SnapShotPath.Buffer + (snapShare->SnapShotPath.Length/sizeof(WCHAR)), Share->RelativePath.Buffer, Share->RelativePath.Length );
    snapShare->SnapShotPath.Length += Share->RelativePath.Length;

    //DbgPrint( "%wZ => %wZ\n", &Share->NtPathName, &snapShare->SnapShotPath );

    //IF_DEBUG( SNAPSHOT ) KdPrint(( "%wZ -> %wZ\n", &Share->NtPathName, &snapShare->SnapShotPath ));

    // Now open the relative handle
    InitializeObjectAttributes(
        &objectAttributes,
        &snapShare->SnapShotPath,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );
    Status = NtOpenFile(
                &snapShare->SnapShotRootDirectoryHandle,
                FILE_TRAVERSE,
                &objectAttributes,
                &IoStatus,
                FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                0
                );
    if( !NT_SUCCESS(Status) )
    {
        goto Cleanup;
    }

    // Make sure its a timewarp snapshot
    Status = SrvSnapCheckAppInfoForTimeWarp( SnapPath );
    if( !NT_SUCCESS(Status) )
    {
        NtClose( snapShare->SnapShotRootDirectoryHandle );
        goto Cleanup;
    }

    // Fill in the configuration information
    Status = SrvSnapFillConfigInfo( snapShare, SnapPath );
    if( !NT_SUCCESS(Status) )
    {
        NtClose( snapShare->SnapShotRootDirectoryHandle );
        goto Cleanup;
    }

    // Generate the SnapShot name
    snapShare->SnapShotName.Length = SNAPSHOT_NAME_LENGTH-sizeof(WCHAR);
    RtlTimeToTimeFields( &snapShare->Timestamp, &rtlTime );
    rtlTime.Milliseconds = 0;
    rtlTime.Weekday = 0;
    if( !SUCCEEDED( StringCbPrintf( snapShare->SnapShotName.Buffer, SNAPSHOT_NAME_LENGTH, SNAPSHOT_NAME_FORMAT, rtlTime.Year, rtlTime.Month, rtlTime.Day, rtlTime.Hour, rtlTime.Minute, rtlTime.Second ) ) )
    {
        Status = STATUS_INTERNAL_ERROR;
        NtClose( snapShare->SnapShotRootDirectoryHandle );
        goto Cleanup;
    }

    RtlTimeFieldsToTime( &rtlTime, &snapShare->Timestamp );
    ASSERT( wcslen( snapShare->SnapShotName.Buffer )*sizeof(WCHAR) == snapShare->SnapShotName.Length );


    // Insert it into the list, and return Success
    Status = SrvSnapInsertSnapIntoShare( Share, snapShare );

    if( !NT_SUCCESS(Status) ) {
        NtClose( snapShare->SnapShotRootDirectoryHandle );
        goto Cleanup;
    }

    //IF_DEBUG( SNAPSHOT ) KdPrint(( "%wZ Handle=%p\n", &snapShare->SnapShotPath, snapShare->SnapShotRootDirectoryHandle ));

Cleanup:
    // Cleanup
    if( !NT_SUCCESS(Status) )
    {
        if( snapShare ) FREE_HEAP( snapShare );
    }

    return Status;
}

NTSTATUS
SrvSnapRemoveShare(
    IN PSHARE_SNAPSHOT SnapShare
    )
/*++

Routine Description:

    This function deallocates a SnapShot Share after it has been removed from
    the underlying disk

    NOTE: Caller must have the SnapShotLock acquired

Arguments:

    SnapShare - Pointer to the SnapShot Share to remove.  It will be removed and
      deallocated.

Return Value:

    NTSTATUS - Returns STATUS_SUCCESS

--*/
{
    PAGED_CODE();

    IF_DEBUG( SNAPSHOT ) KdPrint(( "SrvSnapRemoveShare %p %wZ\n", SnapShare, &SnapShare->SnapShotName ));

    if( SnapShare->SnapShotRootDirectoryHandle )
    {
        NtClose( SnapShare->SnapShotRootDirectoryHandle );
        SnapShare->SnapShotRootDirectoryHandle = NULL;
    }

    RemoveEntryList( &SnapShare->SnapShotList );
    FREE_HEAP( SnapShare );

    return STATUS_SUCCESS;
}

NTSTATUS
SrvSnapCheckForAndCreateSnapShare(
    IN PSHARE Share,
    IN PUNICODE_STRING SnapShotName
    )
/*++

Routine Description:

    This function checks to see if a given SnapShot share exists on the given
    share, and if it does not it creates one.  If it does, it removes the NOT_FOUND
    flag to signify this share still exists

    NOTE: Caller must have the SnapShotLock acquired

Arguments:

    Share - The parent share of the SnapShot
    SnapShotName - The UNICODE_STRING name of the SnapShot (\\Device\\HardDiskSnap1)

Return Value:

    NTSTATUS - Returns STATUS_SUCCESS or an unexpected error

--*/
{
    PLIST_ENTRY snapList;
    UNICODE_STRING SnapPartialName;

    PAGED_CODE();

    //IF_DEBUG( SNAPSHOT ) KdPrint(( "Share %x, Name %wZ\n", Share, SnapShotName ));

    snapList = Share->SnapShots.Flink;
    SnapPartialName.Length = SnapShotName->Length;

    while( snapList != &Share->SnapShots )
    {
        PSHARE_SNAPSHOT snapShare = CONTAINING_RECORD( snapList, SHARE_SNAPSHOT, SnapShotList );
        snapList = snapList->Flink;

        // Strip the trailing \ off the name
        SnapPartialName.Buffer = snapShare->SnapShotPath.Buffer;

        if( (snapShare->SnapShotPath.Length >= SnapPartialName.Length) &&
            RtlEqualUnicodeString( SnapShotName, &SnapPartialName, TRUE ) &&
            ( (snapShare->SnapShotPath.Length == SnapShotName->Length) ||
              (snapShare->SnapShotPath.Buffer[ SnapShotName->Length/sizeof(WCHAR) ] == L'\\') ) )
        {
            if( NT_SUCCESS( SrvSnapCheckAppInfoForTimeWarp( &SnapPartialName ) ) )
            {
                ClearFlag( snapShare->Flags, SRV_SNAP_SHARE_NOT_FOUND );
            }

            return STATUS_SUCCESS;
        }
    }

    return SrvSnapAddShare( Share, SnapShotName );
}

NTSTATUS
SrvSnapSetVolumeHandle(
    IN PSHARE Share
    )
{
    PFILE_OBJECT ShareFileObject;
    NTSTATUS status;
    KEVENT                      event;
    PMOUNTDEV_NAME              name;
    UCHAR                       buffer[512];
    PIRP                        irp;
    IO_STATUS_BLOCK             ioStatus;
    UNICODE_STRING              VolumeName;
    OBJECT_ATTRIBUTES           objectAttributes;

    if( Share->ShareVolumeHandle != NULL )
    {
        return STATUS_SUCCESS;
    }

    // We have a handle to the volume, get the FILE_OBJECT
    status = ObReferenceObjectByHandle( Share->RootDirectoryHandle, SYNCHRONIZE|FILE_TRAVERSE, NULL, KernelMode, &ShareFileObject, NULL );
    if( !NT_SUCCESS(status) )
    {
        return status;
    }

    try {
        KeInitializeEvent(&event, NotificationEvent, FALSE);

        name = (PMOUNTDEV_NAME) buffer;
        irp = IoBuildDeviceIoControlRequest(IOCTL_MOUNTDEV_QUERY_DEVICE_NAME,
                                            ShareFileObject->DeviceObject, NULL, 0, name,
                                            512, FALSE, &event, &ioStatus);
        if (!irp) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }

        status = IoCallDriver(ShareFileObject->DeviceObject, irp);
        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            status = ioStatus.Status;
        }

        if (!NT_SUCCESS(status)) {
            leave;
        }

        VolumeName.Length = VolumeName.MaximumLength = name->NameLength;
        VolumeName.Buffer = name->Name;

        /*
        DbgPrint( "Share %p\n", Share );
        DbgPrint( "Share Nt Path %wZ\n", &Share->NtPathName );
        DbgPrint( "Share Dos Path %wZ\n", &Share->DosPathName );
        DbgPrint( "Share File Path %wZ\n", &ShareFileObject->FileName );
        DbgPrint( "Share Volume Path %wZ\n", &VolumeName );
        */

        // Determine the volume relative path
        // The relative path is equal to the path relative to the volume that the share location resides on.
        // We can determine it by looking at the file name for the Root Directory FILE_OBJECT and removing 1 character
        // representing the trailing \, and then compining this with the NtPathName (Which has no trailing \)
        Share->RelativePath.Length = (ShareFileObject->FileName.Length-2);
        ASSERT( Share->RelativePath.Length < Share->NtPathName.Length );
        Share->RelativePath.Buffer = Share->NtPathName.Buffer + ((Share->NtPathName.Length - Share->RelativePath.Length)/sizeof(WCHAR));

        //DbgPrint( "Share Relative Path %wZ\n", &Share->RelativePath );


        SrvInitializeObjectAttributes_U(
            &objectAttributes,
            &VolumeName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

        status = NtOpenFile(
                    &Share->ShareVolumeHandle,
                    0,
                    &objectAttributes,
                    &ioStatus,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    0
                    );
        if( !NT_SUCCESS(status) )
        {
            Share->ShareVolumeHandle = NULL;
        }
        else
        {
            //DbgPrint( "Share Volume Handle %p\n", Share->ShareVolumeHandle );
        }
    }
    finally {
        ObDereferenceObject( ShareFileObject );
    }

    return status;
}

NTSTATUS
SrvSnapRefreshSnapShotsForShare(
    IN PSHARE Share
    )
/*++

Routine Description:

    This function takes a share and refreshes the SnapShot views on the share
    so that only currently existing SnapShots are listed

Arguments:

    Share - The share we are examining

Return Value:

    NTSTATUS - STATUS_SUCCESS if all went well, otherwise the appropriate error
      code (and the request should be failed)

--*/

{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    OBJECT_HANDLE_INFORMATION HandleInfo;
    PVOLSNAP_NAMES pNames = NULL;
    UNICODE_STRING VolumeName;
    UNICODE_STRING RootVolume;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK iosb;
    PLIST_ENTRY shareList;
    ULONG NumberOfSnapshots = 0;
    LONG Epic;

    PAGED_CODE();

    // Validate we can do SnapShots
    if( Share->Removable )
    {
        Status = STATUS_NOT_SUPPORTED;
        goto Cleanup;
    }

    SrvSnapSetVolumeHandle( Share );

    if( Share->ShareVolumeHandle == NULL )
    {
        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    // Check the EPIC number, so we can exit quickly if possible
    ACQUIRE_LOCK_SHARED( Share->SnapShotLock );

    Status = SrvSnapGetEpicForVolume( Share->ShareVolumeHandle, &Epic );
    if( NT_SUCCESS(Status) &&
        Epic == Share->SnapShotEpic )
    {
        RELEASE_LOCK( Share->SnapShotLock );
        //DbgPrint( "Fast refresh with Epic\n" );
        return STATUS_SUCCESS;
    }

    RELEASE_LOCK( Share->SnapShotLock );

    //DbgPrint( "Slow refresh (Epic mismatch)\n" );

    ACQUIRE_LOCK( Share->SnapShotLock );

    // Check the EPIC number again.  There is a chance that another thread
    // grabbed the resource exclusively before us and has already done the update.
    // If so, we can exit.  If not, we use this to set the new Epic number
    Status = SrvSnapGetEpicForVolume( Share->ShareVolumeHandle, &Epic );

    if( !NT_SUCCESS(Status) )
    {
        // Set Epic to -1, so we will always update
        Epic = -1;
    }
    else if( Epic == Share->SnapShotEpic )
    {
        RELEASE_LOCK( Share->SnapShotLock );
        //DbgPrint( "Fast refresh (exclusive) with Epic\n" );
        return STATUS_SUCCESS;
    }

    // Get the NamesArray for the volume
    Status = SrvSnapGetNamesForVolume( Share->ShareVolumeHandle, &pNames );

    if( !NT_SUCCESS(Status) )
    {
        RELEASE_LOCK( Share->SnapShotLock );
        goto Cleanup;
    }
    else if( !pNames )
    {
        // No SnapShots were found, so delete any that exist
        shareList = Share->SnapShots.Flink;
        while( shareList != &Share->SnapShots )
        {
            PSHARE_SNAPSHOT snapShare = CONTAINING_RECORD( shareList, SHARE_SNAPSHOT, SnapShotList );
            shareList = shareList->Flink;
            SrvSnapRemoveShare( snapShare );
        }

        // Try and update the Epic.  Ignore failure, as it simply makes us query again
        Share->SnapShotEpic = Epic;

        RELEASE_LOCK( Share->SnapShotLock );

        return STATUS_SUCCESS;
    }

    // We only allow MAX_SNAPSHOTS_PER_SHARE snapshots on a volume, or enough
    // to fill a buffer of length MAX_USHORT.  (MAX_SNAPSHOTS_PER_SHARE is always the
    // limiting factor, the MAX_USHORT is for safety of parsing to make sure we don't
    // crash if this ever changes)
    VolumeName.MaximumLength = (USHORT)(MIN(pNames->MultiSzLength,0xFFFF));
    VolumeName.Length = 0;
    VolumeName.Buffer = pNames->Names;

    // Mark all the snap-shares as "not-found"
    shareList = Share->SnapShots.Flink;
    while( shareList != &Share->SnapShots )
    {
        PSHARE_SNAPSHOT snapShare = CONTAINING_RECORD( shareList, SHARE_SNAPSHOT, SnapShotList );
        snapShare->Flags |= SRV_SNAP_SHARE_NOT_FOUND;
        shareList = shareList->Flink;
    }

    // Walk the name list and create a SnapShot for any volumes we don't currently have
    while( (NumberOfSnapshots < MAX_SNAPSHOTS_PER_SHARE) && SrvParseMultiSZ( &VolumeName ) )
    {
        Status = SrvSnapCheckForAndCreateSnapShare( Share, &VolumeName );
        if( !NT_SUCCESS(Status) )
        {
            IF_DEBUG( SNAPSHOT ) KdPrint(( "Failed to Add share %wZ (%x).  Continuing..\n", &VolumeName, Status ));
            Status = STATUS_SUCCESS;
        }

        NumberOfSnapshots++;
    }

    // Any shares that are still marked as "not-found" are no longer availibe,
    // so we need to remove them
    shareList = Share->SnapShots.Flink;
    while( shareList != &Share->SnapShots )
    {
        PSHARE_SNAPSHOT snapShare = CONTAINING_RECORD( shareList, SHARE_SNAPSHOT, SnapShotList );
        shareList = shareList->Flink;

        if( snapShare->Flags & SRV_SNAP_SHARE_NOT_FOUND )
        {
            SrvSnapRemoveShare( snapShare );
        }
    }

    // Update the Epic.
    Share->SnapShotEpic = Epic;

    RELEASE_LOCK( Share->SnapShotLock );

    //DbgPrint( "Refresh complete\n" );

Cleanup:

    // Release the memory associated with the enumeration
    if( pNames )
    {
        DEALLOCATE_NONPAGED_POOL( pNames );
        pNames = NULL;
    }

    return Status;
}

NTSTATUS
SrvSnapEnumerateSnapShots(
    IN PWORK_CONTEXT WorkContext
    )
/*++

Routine Description:

    This function handles a transaction that wants to enumerate the availible
    SnapShots for a given share

Arguments:

    WorkContext - The context for the transaction

Return Value:

    NTSTATUS - STATUS_SUCCESS and STATUS_BUFFER_OVERFLOW are expected, and should
       be returned with data.  Any other status code should be returned without data

--*/
{
    NTSTATUS Status;
    ULONG SnapShotCount;
    PLIST_ENTRY listEntry;
    PSHARE Share = WorkContext->TreeConnect->Share;
    PTRANSACTION transaction = WorkContext->Parameters.Transaction;
    PSRV_SNAPSHOT_ARRAY SnapShotArray = (PSRV_SNAPSHOT_ARRAY)transaction->OutData;

    PAGED_CODE();

    ASSERT(WorkContext->TreeConnect);

    // Check the buffer
    if( transaction->MaxDataCount < sizeof(SRV_SNAPSHOT_ARRAY) )
    {
        return STATUS_INVALID_PARAMETER;
    }

    // Refresh the SnapShot share list
    if( transaction->MaxDataCount == sizeof(SRV_SNAPSHOT_ARRAY) )
    {
        Status = SrvSnapRefreshSnapShotsForShare( Share );
        if( !NT_SUCCESS(Status) )
        {
            return Status;
        }
    }

    // Lock the share
    ACQUIRE_LOCK_SHARED( Share->SnapShotLock );

    // Check the buffer size
    SnapShotCount = 0;
    listEntry = Share->SnapShots.Blink;
    while( listEntry != &(Share->SnapShots) )
    {
        SnapShotCount++;
        listEntry = listEntry->Blink;
    }

    // Set the value and check if we will overflow
    SnapShotArray->NumberOfSnapShots = SnapShotCount;
    SnapShotArray->SnapShotArraySize = SNAPSHOT_NAME_LENGTH*SnapShotArray->NumberOfSnapShots+sizeof(WCHAR);
    if( (SnapShotCount == 0) || (transaction->MaxDataCount < SnapShotArray->SnapShotArraySize) )
    {
        // The buffer is not big enough.  Return the required size
        SnapShotArray->NumberOfSnapShotsReturned = 0;
        transaction->DataCount = sizeof(SRV_SNAPSHOT_ARRAY);
        Status = STATUS_SUCCESS;
    }
    else
    {
        // The buffer is big enough.  Fill it in and return it
        PBYTE nameLocation = (PBYTE)SnapShotArray->SnapShotMultiSZ;

        SnapShotCount = 0;
        listEntry = Share->SnapShots.Blink;
        RtlZeroMemory( SnapShotArray->SnapShotMultiSZ, SnapShotArray->SnapShotArraySize );
        while( listEntry != &(Share->SnapShots) )
        {
            PSHARE_SNAPSHOT SnapShot = CONTAINING_RECORD( listEntry, SHARE_SNAPSHOT, SnapShotList );
            RtlCopyMemory( nameLocation, SnapShot->SnapShotName.Buffer, SNAPSHOT_NAME_LENGTH );
            nameLocation += SNAPSHOT_NAME_LENGTH;
            SnapShotCount++;
            listEntry = listEntry->Blink;
        }

        SnapShotArray->NumberOfSnapShotsReturned = SnapShotArray->NumberOfSnapShots;
        transaction->DataCount = sizeof(SRV_SNAPSHOT_ARRAY)+SnapShotArray->SnapShotArraySize;
        Status = STATUS_SUCCESS;
    }


    // Release the lock
    RELEASE_LOCK( Share->SnapShotLock );

    return Status;
}

NTSTATUS
SrvSnapGetRootHandle(
    IN PWORK_CONTEXT WorkContext,
    OUT HANDLE* RootHandle
    )
/*++

Routine Description:

    This function retrieves the correct Root Handle for an operation given the
    parsed SnapShot timestamp on the WORK_CONTEXT

Arguments:

    WorkContext - The context for the transaction
    RootHandle  - Where to store the resulting handle

Return Value:

    NTSTATUS - STATUS_SUCCESS or STATUS_NOT_FOUND if the SnapShot is not found

--*/
{
    NTSTATUS Status = STATUS_OBJECT_NAME_NOT_FOUND;
    PSHARE Share;
    PLIST_ENTRY listEntry;
    PSHARE_SNAPSHOT SnapShare;

    PAGED_CODE();

    ASSERT( WorkContext );
    ASSERT( WorkContext->TreeConnect );
    ASSERT( WorkContext->TreeConnect->Share );
    Share = WorkContext->TreeConnect->Share;

    if( WorkContext->SnapShotTime.QuadPart != 0 )
    {
        //IF_DEBUG( SNAPSHOT ) KdPrint(( "Looking for %x%x\n", WorkContext->SnapShotTime.HighPart, WorkContext->SnapShotTime.LowPart ));

        // Acquire the shared lock
        ACQUIRE_LOCK_SHARED( Share->SnapShotLock );

        // Walk the list and look for the entry
        listEntry = Share->SnapShots.Flink;
        while( listEntry != &Share->SnapShots )
        {
            SnapShare = CONTAINING_RECORD( listEntry, SHARE_SNAPSHOT, SnapShotList );
            if( SnapShare->Timestamp.QuadPart == WorkContext->SnapShotTime.QuadPart )
            {
                //IF_DEBUG( SNAPSHOT ) KdPrint((" Found %wZ\n", &SnapShare->SnapShotName ));
                *RootHandle = SnapShare->SnapShotRootDirectoryHandle;
                Status = STATUS_SUCCESS;
                break;
            }

            listEntry = listEntry->Flink;
        }

        RELEASE_LOCK( Share->SnapShotLock );
    }
    else
    {
        *RootHandle = Share->RootDirectoryHandle;
        Status = STATUS_SUCCESS;
    }

    return Status;
}

NTSTATUS
SrvSnapGetNameString(
    IN PWORK_CONTEXT WorkContext,
    OUT PUNICODE_STRING* ShareName,
    OUT PBOOLEAN AllocatedShareName
    )
/*++

Routine Description:

    This function retrieves the correct Root Handle for an operation given the
    parsed SnapShot timestamp on the WORK_CONTEXT

Arguments:

    WorkContext - The context for the transaction
    ShareName   - The Name of the share
    AllocatedShareName - Whether the ShareName should be freed after use (via FREE_HEAP)

Return Value:

    PUNICODE_STRING - pointer to existing string or NULL
    BUGBUG = Have to take a reference or copy at this point!

--*/
{
    NTSTATUS Status = STATUS_OBJECT_NAME_NOT_FOUND;
    PSHARE Share;
    PLIST_ENTRY listEntry;
    PSHARE_SNAPSHOT SnapShare;
    PUNICODE_STRING SnapShareName;

    PAGED_CODE();

    ASSERT( WorkContext );
    ASSERT( WorkContext->TreeConnect );
    ASSERT( WorkContext->TreeConnect->Share );
    Share = WorkContext->TreeConnect->Share;

    if( WorkContext->SnapShotTime.QuadPart != 0 )
    {
        //IF_DEBUG( SNAPSHOT ) KdPrint(( "Looking for %x%x\n", WorkContext->SnapShotTime.HighPart, WorkContext->SnapShotTime.LowPart ));

        // Acquire the shared lock
        ACQUIRE_LOCK_SHARED( Share->SnapShotLock );

        // Walk the list and look for the entry
        listEntry = Share->SnapShots.Flink;
        while( listEntry != &Share->SnapShots )
        {
            SnapShare = CONTAINING_RECORD( listEntry, SHARE_SNAPSHOT, SnapShotList );
            if( SnapShare->Timestamp.QuadPart == WorkContext->SnapShotTime.QuadPart )
            {
                SnapShareName = ALLOCATE_HEAP( sizeof(UNICODE_STRING)+SnapShare->SnapShotPath.Length, BlockTypeSnapShot );
                if( !SnapShareName )
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    *AllocatedShareName = FALSE;
                }
                else
                {
                    SnapShareName->Length = 0;
                    SnapShareName->MaximumLength = SnapShare->SnapShotPath.Length;
                    SnapShareName->Buffer = (PWCHAR)(SnapShareName+1);
                    RtlCopyUnicodeString( SnapShareName, &SnapShare->SnapShotPath );
                    *AllocatedShareName = TRUE;
                    *ShareName = SnapShareName;
                    Status = STATUS_SUCCESS;
                }

                RELEASE_LOCK( Share->SnapShotLock );

                return Status;
            }

            listEntry = listEntry->Flink;
        }

        RELEASE_LOCK( Share->SnapShotLock );

        return Status;
    }
    else
    {
        *ShareName = &WorkContext->TreeConnect->Share->NtPathName;
        *AllocatedShareName = FALSE;
        return STATUS_SUCCESS;
    }
}

BOOLEAN
ExtractNumber(
    IN PWSTR psz,
    IN ULONG Count,
    OUT PLONG value
    )
/*++

Routine Description:

    This function takes a string of characters and parses out a <Count> length decimal
    number.  If it returns TRUE, value has been set and the string was parsed correctly.
    FALSE indicates an error in parsing.

Arguments:

    psz - String pointer
    Count - Number of characters to pull off
    value - pointer to output parameter where value is stored

Return Value:

    BOOLEAN - See description

--*/
{
    PAGED_CODE();

    *value = 0;

    while( Count )
    {
        if( (*psz == L'\0') ||
            IS_UNICODE_PATH_SEPARATOR( *psz ) )
        {
            //IF_DEBUG( SNAPSHOT ) KdPrint(( "Path Seperator found %d\n", Count ));
            return FALSE;
        }

        if( (*psz < L'0') || (*psz > L'9') )
        {
            //IF_DEBUG( SNAPSHOT ) KdPrint(( "Non-digit found %x\n", *psz ));
            return FALSE;
        }

        *value = (*value)*10+(*psz-L'0');
        Count--;
        psz++;
    }

    return TRUE;
}


BOOLEAN
SrvSnapParseToken(
    IN PWSTR Source,
    IN ULONG SourceSizeInBytes,
    OUT PLARGE_INTEGER TimeStamp
    )
/*++

Routine Description:

    This function parses a null-terminated UNICODE file path name string to see if the
    current token is a Snap-designator

Arguments:

    Source - Pointer to the string
    SourceSizeInBytes - size of the source string in bytes
    TimeStamp - If this is a SnapShot, this is set to the time value designated by the string

Return Value:

    BOOLEAN - indicates whether this is a SnapShot token

--*/
{
    PWSTR psz = Source;
    UNICODE_STRING NameString;
    ULONG Count = 0;
#define SNAPSHOT_HEADER L"@GMT-"
    PWSTR header = SNAPSHOT_HEADER;
    TIME_FIELDS rtlTime;
    LONG value;

    PAGED_CODE();

    if( SourceSizeInBytes < (SNAPSHOT_NAME_LENGTH-sizeof(WCHAR)) )
    {
        return FALSE;
    }

    // Check the SNAP. header
    for( Count=0; Count<wcslen(SNAPSHOT_HEADER); Count++,psz++ )
    {
        if( (toupper(*psz) != header[Count]) ||
            (*psz == L'\0') ||
            IS_UNICODE_PATH_SEPARATOR( *psz ) )
        {
            //IF_DEBUG( SNAPSHOT ) KdPrint(("Count %d (%x != %x)\n", Count, *psz, header[Count] ));
            goto NoMatch;
        }
    }

    // Prepare to parse
    RtlZeroMemory( &rtlTime, sizeof(TIME_FIELDS) );

    // Extract the Year
    if( !ExtractNumber( psz, 4, &value ) )
        goto NoMatch;
    if( psz[4] != L'.' )
        goto NoMatch;
    rtlTime.Year = (CSHORT)value;
    psz += 5;

    // Extract the Month
    if( !ExtractNumber( psz, 2, &value ) )
        goto NoMatch;
    if( psz[2] != L'.' )
        goto NoMatch;
    rtlTime.Month = (CSHORT)value;
    psz += 3;

    // Extract the Day
    if( !ExtractNumber( psz, 2, &value ) )
        goto NoMatch;
    if( psz[2] != L'-' )
        goto NoMatch;
    rtlTime.Day = (CSHORT)value;
    psz += 3;

    // Extract the Hour
    if( !ExtractNumber( psz, 2, &value ) )
        goto NoMatch;
    if( psz[2] != L'.' )
        goto NoMatch;
    rtlTime.Hour = (CSHORT)value;
    psz += 3;

    // Extract the Minutes
    if( !ExtractNumber( psz, 2, &value ) )
        goto NoMatch;
    if( psz[2] != L'.' )
        goto NoMatch;
    rtlTime.Minute = (CSHORT)value;
    psz += 3;

    // Extract the Seconds
    if( !ExtractNumber( psz, 2, &value ) )
        goto NoMatch;
    if( !IS_UNICODE_PATH_SEPARATOR( psz[2] ) &&
        (psz[2] != L'\0') )
        goto NoMatch;
    rtlTime.Second = (CSHORT)value;
    psz += 3;

    RtlTimeFieldsToTime( &rtlTime, TimeStamp );

    return TRUE;

NoMatch:
    return FALSE;
}

NTSTATUS
SrvSnapCheckAppInfoForTimeWarp(
    IN PUNICODE_STRING SnapShotPath
    )
/*++

Routine Description:

    This function determines whether the specified snapshot should be allowed as a snapshot share

Arguments:

    SnapShotHandle - Handle to the snapshot volume

Return Value:

    NTSTATUS (either STATUS_SUCCESS, or STATUS_INVALID_DEVICE_REQUEST)

--*/
{
    HANDLE hVolume;
    DWORD dwSize = sizeof(VOLSNAP_APPLICATION_INFO);
    NTSTATUS Status;
    OBJECT_ATTRIBUTES objectAttributes;
    VOLSNAP_APPLICATION_INFO AppInfo;
    PVOLSNAP_APPLICATION_INFO pAppInfo;
    IO_STATUS_BLOCK IoStatus;

    PAGED_CODE();

    // Now open the SnapShot handle
    dwSize = sizeof(VOLSNAP_APPLICATION_INFO);
    InitializeObjectAttributes(
        &objectAttributes,
        SnapShotPath,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );
    Status = NtOpenFile(
                &hVolume,
                0,
                &objectAttributes,
                &IoStatus,
                FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                0
                );
    if( !NT_SUCCESS(Status) )
    {
        return Status;
    }

    try {

        // Find out how big it should be
        Status = SrvSnapIssueIoctl( hVolume, IOCTL_VOLSNAP_QUERY_APPLICATION_INFO, &AppInfo, &dwSize );
        if( Status != STATUS_BUFFER_OVERFLOW )
        {
            Status = STATUS_INVALID_DEVICE_REQUEST;
            leave;
        }

        // Allocate the correct size block
        dwSize = sizeof(VOLSNAP_APPLICATION_INFO)+AppInfo.InformationLength;
        pAppInfo = (PVOLSNAP_APPLICATION_INFO)ALLOCATE_NONPAGED_POOL( dwSize, BlockTypeSnapShot );
        if( !pAppInfo )
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }

        // Build up the IRP to be used for the query
        Status = SrvSnapIssueIoctl( hVolume, IOCTL_VOLSNAP_QUERY_APPLICATION_INFO, pAppInfo, &dwSize );

        // Check whether the AppInfo contains the GUID we are interested in
        if( !NT_SUCCESS(Status) )
        {
            Status = STATUS_INVALID_DEVICE_REQUEST;
        }
        else
        {
            if( pAppInfo->InformationLength > sizeof(GUID) )
            {
                if( RtlEqualMemory( pAppInfo->Information, &VOLSNAP_APPINFO_GUID_CLIENT_ACCESSIBLE, sizeof(GUID) ) )
                {
                    Status = STATUS_SUCCESS;
                }
                else
                {
                    Status = STATUS_INVALID_DEVICE_REQUEST;
                }
            }
        }

        // Return the result
        DEALLOCATE_NONPAGED_POOL(pAppInfo);
        pAppInfo = NULL;
    }
    finally {
        // Close the handle to the volume
        NtClose( hVolume );
    }

    return Status;
}


NTSTATUS
SrvSnapEnumerateSnapShotsAsDirInfo(
    IN PWORK_CONTEXT WorkContext,
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN PUNICODE_STRING FileResumeName,
    IN BOOLEAN SingleEntries,
    IN OUT PSRV_DIRECTORY_INFORMATION DirectoryInformation
    )
{
    NTSTATUS Status;
    ULONG SnapShotCount;
    ULONG Current = 0;
    ULONG Count = 0;
    PLIST_ENTRY listEntry;
    PSHARE Share = WorkContext->TreeConnect->Share;
    ULONG Remaining = BufferLength - FIELD_OFFSET( SRV_DIRECTORY_INFORMATION, Buffer );
    PBYTE pCurrent = Buffer;
    PFILE_BOTH_DIR_INFORMATION fileBoth = (PFILE_BOTH_DIR_INFORMATION)pCurrent;
    PFILE_BOTH_DIR_INFORMATION currentEntry = (PFILE_BOTH_DIR_INFORMATION)DirectoryInformation->DirectoryHandle;
    UNICODE_STRING lastName;

    PAGED_CODE();

    if( currentEntry && !FileResumeName )
    {
        lastName.MaximumLength = lastName.Length = (USHORT)currentEntry->FileNameLength;
        lastName.Buffer = currentEntry->FileName;
        FileResumeName = &lastName;
    }

    // Lock the share
    ACQUIRE_LOCK_SHARED( Share->SnapShotLock );

    // Check the buffer size
    SnapShotCount = 0;
    listEntry = Share->SnapShots.Blink;
    while( listEntry != &(Share->SnapShots) )
    {
        SnapShotCount++;
        listEntry = listEntry->Blink;
    }

    // Start filling the buffer.  First, let's find the starting entry
    listEntry = Share->SnapShots.Blink;

    if( FileResumeName != NULL  )
    {
        while( listEntry != &(Share->SnapShots) )
        {
            PSHARE_SNAPSHOT SnapShot = CONTAINING_RECORD( listEntry, SHARE_SNAPSHOT, SnapShotList );
            listEntry = listEntry->Blink;

            if( RtlEqualUnicodeString( &SnapShot->SnapShotName, FileResumeName, TRUE ) )
            {
                break;
            }

            Current++;
        }

        if( listEntry == &Share->SnapShots )
        {
            Status = STATUS_NO_MORE_FILES;
            goto return_with_lock;
        }
    }

    fileBoth->NextEntryOffset = 0;

    // Now lets start filling the buffer
    while( listEntry != &(Share->SnapShots) )
    {
        PSHARE_SNAPSHOT SnapShot = CONTAINING_RECORD( listEntry, SHARE_SNAPSHOT, SnapShotList );
        ULONG requiredSize = ALIGN_UP(sizeof(FILE_BOTH_DIR_INFORMATION)+SnapShot->SnapShotName.Length, LARGE_INTEGER);
        WCHAR ShortName[12];
        HRESULT result;

        // Check if we can fit this entry
        if( requiredSize > Remaining )
        {
            break;
        }
        else
        {
            listEntry = listEntry->Blink;
            pCurrent += fileBoth->NextEntryOffset;
            fileBoth = (PFILE_BOTH_DIR_INFORMATION)pCurrent;
        }

        RtlZeroMemory( fileBoth, sizeof(FILE_BOTH_DIR_INFORMATION) );
        fileBoth->AllocationSize.QuadPart = 0;
        fileBoth->ChangeTime = fileBoth->CreationTime = fileBoth->LastAccessTime = fileBoth->LastWriteTime = SnapShot->Timestamp;
        fileBoth->EaSize = 0;
        fileBoth->EndOfFile.QuadPart = 0;
        fileBoth->FileAttributes = FILE_ATTRIBUTE_DIRECTORY;// | FILE_ATTRIBUTE_HIDDEN;
        fileBoth->FileIndex = 0;
        fileBoth->FileNameLength = SnapShot->SnapShotName.Length;
        RtlZeroMemory( ShortName, 12*sizeof(WCHAR) );
        result = StringCbPrintf( ShortName, 12*sizeof(WCHAR), L"@GMT~%03d", Current );
        ASSERT( SUCCEEDED(result) );   // Since # of snapshots is limited, current will never exceed 3 digits
        RtlCopyMemory( fileBoth->ShortName, ShortName, 12*sizeof(WCHAR) );
        fileBoth->ShortNameLength = wcslen(ShortName)*sizeof(WCHAR);

        RtlCopyMemory( fileBoth->FileName, SnapShot->SnapShotName.Buffer, fileBoth->FileNameLength );
        fileBoth->NextEntryOffset = ALIGN_UP( requiredSize, LARGE_INTEGER );
        DirectoryInformation->DirectoryHandle = (HANDLE)fileBoth;

        Remaining -= fileBoth->NextEntryOffset;
        Current++;
        Count++;
    }

    if( fileBoth->NextEntryOffset != 0 )
    {
        fileBoth->NextEntryOffset = 0;
    }

    if( listEntry == &(Share->SnapShots) &&
        (Count == 0) )
    {
        Status = STATUS_NO_MORE_FILES;
    }
    else if( Count == 0 )
    {
        Status = STATUS_BUFFER_TOO_SMALL;
    }
    else
    {
        Status = STATUS_SUCCESS;
    }

    // Release the lock
return_with_lock:
    RELEASE_LOCK( Share->SnapShotLock );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\srvstamp.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    srvstamp.c

Abstract:

    This module contains routines for supporting the SrvStamp functionality
    
Author:

    David Kruse (dkruse) 23-Oct-2000

Revision History:

--*/

#include "precomp.h"
#include "srvstamp.tmh"
#pragma hdrstop
                    
#ifdef SRVCATCH

//
//  Stupid compiler won't convert memcmp( data, constdata, 8 ) into
//  a single 64-bit compare, so we use 64-bit numeric constants here.
//

#define PVD_SIGNATURE 0x0001313030444301    // 0x01 "CD001" 0x01 0x00
#define TVD_SIGNATURE 0x00013130304443FF    // 0xFF "CD001" 0x01 0x00

#ifdef STATIC_CRC_TABLE
 
const unsigned long CrcTable32[ 256 ] = {
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,
    0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,
    0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
    0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
    0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,
    0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106,
    0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D,
    0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
    0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7,
    0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA,
    0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
    0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84,
    0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
    0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,
    0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55,
    0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28,
    0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,
    0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
    0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69,
    0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,
    0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693,
    0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D};

#else

unsigned long *CrcTable32 = NULL;

#endif

BOOLEAN GenerateCrcTable()
{
#ifndef STATIC_CRC_TABLE

    ULONG i, j, Value;

    if( !CrcTable32 )
    {
        CrcTable32 = ALLOCATE_NONPAGED_POOL( sizeof(ULONG)*256, BlockTypeMisc );
        if( !CrcTable32 )
            return FALSE;
    }

    for ( i = 0; i < 256; i++ ) 
    {
        for ( Value = i, j = 8; j > 0; j-- ) 
        {
            if ( Value & 1 ) 
            {
                Value = ( Value >> 1 ) ^ 0xEDB88320;
            }
            else 
            {
                Value >>= 1;
            }
        }

        CrcTable32[ i ] = Value;
    }

#endif

    return TRUE;
}

BOOLEAN CleanupCrcTable()
{
#ifndef STATIC_CRC_TABLE
    if( CrcTable32 )
    {
        DEALLOCATE_NONPAGED_POOL( CrcTable32 );
        CrcTable32 = NULL;
    }
#endif

    return TRUE;
}

#pragma optimize( "t", on ) // following code should be fast versus small
// (crc loop 40000 times per corrected image)


ULONG
__forceinline               // called from only one location
Crc32(
     ULONG InitialCrc,
     const VOID *Buffer,
     ULONG Bytes
     )
{

    ULONG Crc = InitialCrc;
    const UCHAR *p = Buffer;
    ULONG Count = Bytes;

    while ( Count-- )
    {
        Crc = ( Crc >> 8 ) ^ CrcTable32[ (UCHAR)Crc ^ *p++ ];
    }

    return Crc;
}


ULONG
__fastcall
LocateTvdSectorInIsoFileHeader(
                              PVOID FileHeader,       // should be at least 20 * 2048 (40,960) bytes, but
                              ULONG SizeOfHeader      //  won't search past 24 * 2048 (49,152) bytes
                              )
{
    PBYTE p;
    PBYTE z;

    if ( SizeOfHeader >= ( 20 * 2048 ))
    {   // big enough for ISO-9660 headers

        if ( SizeOfHeader > ( 24 * 2048 ))
        {    // don't bother searching
            SizeOfHeader = ( 24 * 2048 );      // beyond sector 23
        }

        p = (PBYTE)FileHeader + ( 16 * 2048 );  // point at PVD sector
        z = (PBYTE)FileHeader + SizeOfHeader;   // search until p >= z

        //
        //  If FileHeader buffer is guaranteed to be 8-byte aligned, can remove
        //  the UNALIGNED keywords below.
        //

        if ( *(UNALIGNED UINT64 *)p == PVD_SIGNATURE )
        {    // ISO-9660 image

            p += 2048;                          // skip PVD and scan for TVD

            do
            {

                if ( *(UNALIGNED UINT64 *)p == TVD_SIGNATURE )
                {

                    return(ULONG)( p - (PBYTE)FileHeader );   // return offset to TVD
                }

                p += 2048;
            }

            while ( p < z );

        }
    }

    return 0;                               // no TVD, not valid ISO-9660 image
}


VOID
__fastcall
EmbedDataInIsoTvdAndCorrectCrc(
                              PVOID IsoFileHeader,
                              ULONG TvdSectorOffset,
                              PVOID DataToEmbed,
                              ULONG SizeOfData
                              )
{
    //
    //  If IsoFileHeader is 4-byte aligned, can remove UNALIGNED keyword.
    //

    UNALIGNED ULONG *pCrcCorrection;

    ASSERT( SizeOfData <= 1020 );

    memcpy( (PBYTE)IsoFileHeader + TvdSectorOffset + 1024, DataToEmbed, SizeOfData );

    //
    //  We only perform CRC correction if the TVD has been predisposed to
    //  CRC correction (cdimage -xx).  In other words, if the last four
    //  bytes of the TVD already contain a non-zero CRC correction.
    //

    pCrcCorrection = (PULONG)( (PBYTE)IsoFileHeader + TvdSectorOffset + 2048 - 4 );

    if ( *pCrcCorrection )
    {
        *pCrcCorrection = Crc32( 0xFFFFFFFF, IsoFileHeader, TvdSectorOffset + 2048 - 4 );
    }
}

ULONG 
SrvFindCatchOffset( 
    IN OUT PVOID pBuffer, 
    IN ULONG BufferSize
    )
{
    ULONG offset;
    offset = LocateTvdSectorInIsoFileHeader( pBuffer, BufferSize );
    if( offset )
    {
        offset += 1024;
    }
    
    return offset;
}

void
SrvCorrectCatchBuffer(
    IN PVOID pBuffer,
    IN ULONG CatchOffset
    )
{
    UNALIGNED ULONG *pCrcCorrection;

    CatchOffset -= 1024;

    //
    //  We only perform CRC correction if the TVD has been predisposed to
    //  CRC correction (cdimage -xx).  In other words, if the last four
    //  bytes of the TVD already contain a non-zero CRC correction.
    //

    pCrcCorrection = (PULONG)( (PBYTE)pBuffer + CatchOffset + 2048 - 4 );

    if ( *pCrcCorrection )
    {
        *pCrcCorrection = Crc32( 0xFFFFFFFF, pBuffer, CatchOffset + 2048 - 4 );
    }
}

void 
SrvIsMonitoredShare( 
    IN OUT PSHARE Share
    )
{
    int i;
    UNICODE_STRING watchShare;

    if( SrvCatchShares > 0 )
    {
        for( i=0; SrvCatchShareNames[i]; i++ )
        {
            watchShare.Buffer = SrvCatchShareNames[i];
            watchShare.Length = (USHORT)STRLEN( SrvCatchShareNames[i] )*sizeof(WCHAR);
            if( RtlCompareUnicodeString( &watchShare, &Share->ShareName, TRUE ) == 0 )
            {
                Share->IsCatchShare = TRUE;
                break;
            }
        }
    }
}

#endif // SRVCATCH
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\srvsnap.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    srvsnap.h

Abstract:

    This module implements making SnapShots availible over the network

Author:

    David Kruse (dkruse) 22-March-2001

Revision History:

--*/

#ifndef _SRVSNAP_
#define _SRVSNAP_

typedef struct _SRV_SNAPSHOT_ARRAY
{
    ULONG NumberOfSnapShots;            // The number of SnapShots for the volume
    ULONG NumberOfSnapShotsReturned;    // The number of SnapShots being returned
    ULONG SnapShotArraySize;            // The size (in bytes) needed for the array
    WCHAR SnapShotMultiSZ[1];           // The multiSZ array of SnapShot names
} SRV_SNAPSHOT_ARRAY, *PSRV_SNAPSHOT_ARRAY;


NTSTATUS
SrvSnapRefreshSnapShotsForShare(
    IN PSHARE Share
    );

NTSTATUS
SrvSnapRemoveShare(
    IN PSHARE_SNAPSHOT SnapShare
    );

NTSTATUS
SrvSnapEnumerateSnapShots(
    IN PWORK_CONTEXT WorkContext
    );

NTSTATUS
SrvSnapGetRootHandle(
    IN PWORK_CONTEXT WorkContext,
    OUT HANDLE* RootHandle
    );

NTSTATUS
SrvSnapGetNameString(
    IN PWORK_CONTEXT WorkContext,
    OUT PUNICODE_STRING* pathName,
    OUT BOOLEAN* FreePath
    );

BOOLEAN
SrvSnapParseToken(
    IN PWSTR Source,
    IN ULONG SourceSizeInBytes,
    OUT PLARGE_INTEGER TimeStamp
    );

NTSTATUS
SrvSnapEnumerateSnapShotsAsDirInfo(
    IN PWORK_CONTEXT WorkContext,
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN PUNICODE_STRING FileResumeName,
    IN BOOLEAN SingleEntries,
    IN OUT PSRV_DIRECTORY_INFORMATION DirectoryInformation
    );

#endif // _SRVSNAP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\srvstat.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    srvstat.c

Abstract:

    Contains data and modules for error handling.

Author:

    David Treadwell (davidtr)    10-May-1990

Revision History:

--*/

#include "precomp.h"
#include "srvstat.tmh"
#pragma hdrstop

#define DISK_HARD_ERROR 0x38

NTSTATUS DbgBreakError = STATUS_SUCCESS;

VOID
MapErrorForDosClient (
    IN PWORK_CONTEXT WorkContext,
    IN ULONG Error,
    OUT PUSHORT DosError,
    OUT PUCHAR DosErrorClass
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, _SrvSetSmbError2 )
#pragma alloc_text( PAGE, MapErrorForDosClient )
#pragma alloc_text( PAGE8FIL, SrvSetBufferOverflowError )
#endif


VOID
_SrvSetSmbError2 (
    IN PWORK_CONTEXT WorkContext,
    IN NTSTATUS Status,
    IN BOOLEAN HeaderOnly,
    IN ULONG Line,
    IN PCHAR File
    )

/*++

Routine Description:

    Loads error information into a response SMB.  If the client is
    NT, the status is placed directly into the outgoing SMB.  If
    the client is DOS or OS/2 and this is a special status code that
    has the DOS/OS|2/SMB error code embedded, put the code and class
    from the status code into the outgoing SMB.  If that doesn't work,
    use RtlNtStatusToDosError to try to map the status to an OS/2
    error code, then map to DOS if necessary.  If we still haven't
    mapped it, use our own array to try to find a mapping.  And,
    finally, if that doesn't work, return the generic error code.

Arguments:

    WorkContext - Supplies a pointer to the work context block for the
        current SMB.  In particular, the Connection block pointer is
        used to find the negotiated dialect for the connection, and
        the ResponseHeader and ResponseParameter pointers are used
        to determine where to write the error information.

    Status - Supplies an NT status code.

Return Value:

    None.

--*/

{
    PSMB_HEADER header = WorkContext->ResponseHeader;
    PSMB_PARAMS params = WorkContext->ResponseParameters;
    SMB_DIALECT smbDialect;

    ULONG error;
    CCHAR errorClass;
    USHORT errorCode;
    USHORT flags;

    PAGED_CODE( );

    if( (DbgBreakError != STATUS_SUCCESS) &&
        (Status == DbgBreakError) )
    {
        DbgPrint( "Caught error %x\n", DbgBreakError );
        DbgPrint( "WorkContext = %p, Line = %d, File = %x\n", WorkContext, Line, File );
        DbgBreakPoint();
    }

    IF_DEBUG( ERRORS ) {                                                \
        KdPrint(( "SrvSetSmbError %X (%s,%d)\n",Status,File,Line )); \
    }

    smbDialect = WorkContext->Connection->SmbDialect;

    //
    // Update the SMB body, if necessary.
    //

    if ( !HeaderOnly ) {
        params->WordCount = 0;
        SmbPutUshort( &params->ByteCount, 0 );
        WorkContext->ResponseParameters = (PVOID)(params + 1);
    }

    //
    // If the status code is a real NT status, then either return it
    // directly to the client or map it to a Win32 error code.
    //

    if ( !SrvIsSrvStatus( Status ) ) {

        //
        // Map STATUS_INSUFFICIENT_RESOURCES to the server form.  If we
        // get an insufficient resources error from the system, we
        // report it as a server shortage.  This helps keep things
        // clearer for the client.
        //

        if ( Status == STATUS_WORKING_SET_QUOTA ) {
            Status = STATUS_INSUFF_SERVER_RESOURCES;
            if( WorkContext->Rfcb )
            {
                PNT_SMB_HEADER pHeader = (PNT_SMB_HEADER)WorkContext->RequestHeader;
                BOOL PagingIo = (pHeader->Flags2 & SMB_FLAGS2_PAGING_IO) ? TRUE : FALSE;
                IF_SYSCACHE_RFCB( WorkContext->Rfcb ) {
                    KdPrint(("Op on %p failed with C00000A1, Paging=%d, Ofst=%x, Ln=%x\n", WorkContext->Rfcb, PagingIo,
                             WorkContext->Parameters.WriteAndX.Offset.u.LowPart, WorkContext->Parameters.WriteAndX.CurrentWriteLength ));
                }
            }
        }

        if ( Status == STATUS_INSUFFICIENT_RESOURCES ) {
            Status = STATUS_INSUFF_SERVER_RESOURCES;
        }

        if ( CLIENT_CAPABLE_OF(NT_STATUS, WorkContext->Connection) ) {

            //
            // The client understands NT status codes.  Load the status
            // directly into the SMB header.
            //

            SmbPutUlong( (PULONG)&header->ErrorClass, Status );

            flags = SmbGetAlignedUshort( &header->Flags2 ) | SMB_FLAGS2_NT_STATUS;
            SmbPutAlignedUshort( &header->Flags2, flags );

            return;

        }

        //
        // This is an NT status, but the client doesn't understand them.
        // Indicate that we're not returning an NT status code.  Then
        // map the NT status to a Win32 status.  Some NT status codes
        // require special mapping.
        //

        flags = SmbGetAlignedUshort( &header->Flags2 ) & ~SMB_FLAGS2_NT_STATUS;
        SmbPutAlignedUshort( &header->Flags2, flags );

        switch ( Status ) {

        case STATUS_TIMEOUT:
            header->ErrorClass = SMB_ERR_CLASS_SERVER;
            SmbPutUshort( &header->Error, SMB_ERR_TIMEOUT );
            return;

        case STATUS_INVALID_SYSTEM_SERVICE:

            //
            // This status code is returned by XACTSRV when an invalid API
            // number is specified.
            //

            header->ErrorClass = SMB_ERR_CLASS_DOS;
            SmbPutUshort( &header->Error, NERR_InvalidAPI );
            return;

        case STATUS_PATH_NOT_COVERED:
            //
            // This code indicates that the server does not cover this part
            // of the DFS namespace.
            //
            header->ErrorClass = SMB_ERR_CLASS_SERVER;
            SmbPutUshort( &header->Error, SMB_ERR_BAD_PATH );
            return;

        default:

            //
            // This is not a special status code.  Map the NT status
            // code to a Win32 error code.  If there is no mapping,
            // return the generic SMB error.
            //

            error = RtlNtStatusToDosErrorNoTeb( Status );

            if ( error == ERROR_MR_MID_NOT_FOUND || error == (ULONG)Status ) {
                header->ErrorClass = SMB_ERR_CLASS_HARDWARE;
                SmbPutUshort( &header->Error, SMB_ERR_GENERAL );
                return;
            }

            //
            // We now have a Win32 error.  Drop through to the code
            // that maps Win32 errors for downlevel clients.
            //

            break;

        }

    } else {

        //
        // The status code is not an NT status.  Deal with it based on
        // the error class.
        //

        errorClass = SrvErrorClass( Status );

        //
        // Clear the FLAGS2_NT_STATUS bit to indicate that this is *not* an
        // NT_STATUS
        //

        flags = SmbGetAlignedUshort( &header->Flags2 ) & ~SMB_FLAGS2_NT_STATUS;
        SmbPutAlignedUshort( &header->Flags2, flags );

        switch ( errorClass ) {

        case SMB_ERR_CLASS_DOS:
        case SMB_ERR_CLASS_SERVER:
        case SMB_ERR_CLASS_HARDWARE:

            //
            // The status code has the SMB error class and code
            // embedded.
            //

            header->ErrorClass = errorClass;

            //
            // Because SMB_ERR_NO_SUPPORT in the SERVER class is 0xFFFF
            // (16 bits), we must special-case for it.  The code
            // SMB_ERR_NO_SUPPORT_INTERNAL in the error code field of
            // the status, along with class = 2 (SERVER), indicates that
            // we should use SMB_ERR_NO_SUPPORT.
            //

            if ( errorClass == SMB_ERR_CLASS_SERVER &&
                 SrvErrorCode( Status ) == SMB_ERR_NO_SUPPORT_INTERNAL ) {
                SmbPutUshort( &header->Error, SMB_ERR_NO_SUPPORT );
            } else {
                SmbPutUshort( &header->Error, SrvErrorCode( Status ) );
            }

            return;

        case 0xF:

            //
            // The error code is defined in OS/2 but not in the SMB
            // protocol.  If the client is speaking a dialect after
            // LanMan 1.0 and is not a DOS client, send the OS/2 error
            // code.  Otherwise, send the generic SMB error code.
            //

            if ( smbDialect <= SmbDialectLanMan10 &&
                 !IS_DOS_DIALECT(smbDialect) ) {
                header->ErrorClass = SMB_ERR_CLASS_DOS;
                SmbPutUshort( &header->Error, SrvErrorCode( Status ) );
            } else {
                header->ErrorClass = SMB_ERR_CLASS_HARDWARE;
                SmbPutUshort( &header->Error, SMB_ERR_GENERAL );
            }

            return;

        case 0xE:

            //
            // This is a Win32 error.  Drop through to the code that
            // maps Win32 errors for downlevel clients.
            //

            error = SrvErrorCode( Status );

            break;

        case 0x0:
        default:

            //
            // This is an internal server error (class 0) or some other
            // undefined class.  We should never get here.  But since we
            // did, return the generic error.
            //

            KdPrint(( "SRV: Unmapped error: %lx\n", Status ));
            header->ErrorClass = SMB_ERR_CLASS_HARDWARE;
            SmbPutUshort( &header->Error, SMB_ERR_GENERAL );

            return;

        }

    }

    //
    // At this point we have a Win32 error code and need to map it for
    // the downlevel client.  Some errors need to be specially mapped.
    //

    errorClass = SMB_ERR_CLASS_DOS;

    switch ( error ) {

    case ERROR_NOT_ENOUGH_SERVER_MEMORY:
        error = ERROR_NOT_ENOUGH_MEMORY;
        break;

    case ERROR_INSUFFICIENT_BUFFER:
        error = ERROR_BUFFER_OVERFLOW;
        break;

    case ERROR_ACCOUNT_LOCKED_OUT:
    case ERROR_PRIVILEGE_NOT_HELD:
    case ERROR_NO_SUCH_USER:
    case ERROR_LOGON_FAILURE:
    case ERROR_LOGON_TYPE_NOT_GRANTED:
    case ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT:
    case ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT:
    case ERROR_NOLOGON_SERVER_TRUST_ACCOUNT:
    case ERROR_TRUSTED_RELATIONSHIP_FAILURE:
    case ERROR_TRUSTED_DOMAIN_FAILURE:
    case ERROR_TRUST_FAILURE:
    case ERROR_NO_TRUST_SAM_ACCOUNT:
    case ERROR_NO_TRUST_LSA_SECRET:
        error = ERROR_ACCESS_DENIED;
        break;

    //
    // For the following four errors, we return an ERROR_ACCESS_DENIED
    // for clients older than doslm20.  The error class for these
    // must be SMB_ERR_CLASS_SERVER.
    //

    case ERROR_INVALID_LOGON_HOURS:
        if ( IS_DOS_DIALECT(smbDialect) && (smbDialect > SmbDialectDosLanMan20) ) {
            error = ERROR_ACCESS_DENIED;
        } else {
            errorClass = SMB_ERR_CLASS_SERVER;
            error = NERR_InvalidLogonHours;
        }
        break;

    case ERROR_INVALID_WORKSTATION:
        if ( IS_DOS_DIALECT(smbDialect) && (smbDialect > SmbDialectDosLanMan20) ) {
            error = ERROR_ACCESS_DENIED;
        } else {
            errorClass = SMB_ERR_CLASS_SERVER;
            error = NERR_InvalidWorkstation;
        }
        break;

    case ERROR_ACCOUNT_DISABLED:
    case ERROR_ACCOUNT_EXPIRED:
        if ( IS_DOS_DIALECT(smbDialect) && (smbDialect > SmbDialectDosLanMan20) ) {
            error = ERROR_ACCESS_DENIED;
        } else {
            errorClass = SMB_ERR_CLASS_SERVER;
            error = NERR_AccountExpired;
        }
        break;

    case ERROR_PASSWORD_MUST_CHANGE:
    case ERROR_PASSWORD_EXPIRED:
        if ( IS_DOS_DIALECT(smbDialect) && (smbDialect > SmbDialectDosLanMan20) ) {
            error = ERROR_ACCESS_DENIED;
        } else {
            errorClass = SMB_ERR_CLASS_SERVER;
            error = NERR_PasswordExpired;
        }
        break;

    //
    // The only NERR codes that DOSLM20 understands are the 4 above.
    // According to larryo, the rest of the NERR codes have to be
    // mapped to ERROR_ACCESS_DENIED.
    //

    case ERROR_NETLOGON_NOT_STARTED:
        if ( IS_DOS_DIALECT(smbDialect) && (smbDialect > SmbDialectDosLanMan21) ) {
            error = ERROR_ACCESS_DENIED;
        } else {
            error = NERR_NetlogonNotStarted;
        }
        break;

    case ERROR_NO_LOGON_SERVERS:
        if ( IS_DOS_DIALECT(smbDialect) ) {
            error = ERROR_ACCESS_DENIED;
        } else {
            error = NERR_LogonServerNotFound;
        }
        break;

    case ERROR_DIR_NOT_EMPTY:
        if ( IS_DOS_DIALECT(smbDialect) ) {
            error = ERROR_ACCESS_DENIED;
        }
        break;

    default:
        break;

    }

    //
    // Now map the error to a DOS or OS/2 error code.
    //

    if ( error == ERROR_ACCESS_DENIED &&
         smbDialect == SmbDialectDosLanMan21 &&
         WorkContext->ShareAclFailure ) {

        //
        // WfW & DOS LM2.1 want SMB_ERR_ACCESS to be in the server
        // error class when it's due to ACL restrictions, but in the
        // DOS class otherwise.
        //
        errorClass = SMB_ERR_CLASS_SERVER;
        errorCode = SMB_ERR_ACCESS;

    } else if ( smbDialect > SmbDialectLanMan10 ) {

        MapErrorForDosClient(
            WorkContext,
            error,
            &errorCode,
            &errorClass
            );

    } else if ( (error > ERROR_ARITHMETIC_OVERFLOW) &&
                ((error < NERR_BASE) || (error > MAX_NERR)) ) {

        //
        // Win32 errors above ERROR_ARITHMETIC_OVERFLOW (but not in the
        // NERR_xxx range) do not map to DOS or OS/2 errors, so we
        // return the generic error for those.
        //

        errorClass = SMB_ERR_CLASS_HARDWARE;
        errorCode = SMB_ERR_GENERAL;

    } else {

        errorCode = (USHORT)error;

    }

    header->ErrorClass = errorClass;
    SmbPutUshort( &header->Error, errorCode );

    return;

} // _SrvSetSmbError2


VOID
MapErrorForDosClient (
    IN PWORK_CONTEXT WorkContext,
    IN ULONG Error,
    OUT PUSHORT DosError,
    OUT PUCHAR DosErrorClass
    )

/*++

Routine Description:

    Maps an Win32 error to a DOS error.

Arguments:

    WorkContext - Supplies a pointer to the work context block for the
        current SMB.

    Error - the Win32 error code to map.

    DosError - the corresponding DOS error.

    DosErrorClass - the error class to put in the outgoing SMB.

Return Value:

    None.

--*/

{
    PSMB_HEADER header = WorkContext->ResponseHeader;

    PAGED_CODE( );

    //
    // Default to using the initial error code and the win32 error.
    //

    *DosError = (USHORT)Error;
    *DosErrorClass = SMB_ERR_CLASS_DOS;

    //
    // If the error is more recent and not part of the set of DOS errors
    // (value greater than ERROR_NET_WRITE_FAULT) and the SMB command is
    // not a newer SMB (errors for these get mapped by the newer DOS
    // redir that sent them), then map the OS/2 error to the DOS range.
    // This code was lifted from the ring 3 OS/2 server.
    //

    if ( Error > ERROR_NET_WRITE_FAULT &&
         !( header->Command == SMB_COM_COPY ||
            header->Command == SMB_COM_MOVE ||
            header->Command == SMB_COM_TRANSACTION ||
            header->Command == SMB_COM_TRANSACTION_SECONDARY ) ) {

        switch( Error ) {

        case ERROR_OPEN_FAILED:

            *DosError = ERROR_FILE_NOT_FOUND;
            break;

        case ERROR_BUFFER_OVERFLOW:
        case ERROR_INSUFFICIENT_BUFFER:
        case ERROR_INVALID_NAME:
        case ERROR_INVALID_LEVEL:
        case ERROR_SEEK_ON_DEVICE:

            //
            // These don't get mapped to anything.  No explanation was
            // given in the ring 3 code.
            //

            break;

        case ERROR_BAD_EXE_FORMAT:
        case ERROR_INVALID_STARTING_CODESEG:
        case ERROR_INVALID_STACKSEG:
        case ERROR_INVALID_MODULETYPE:
        case ERROR_INVALID_EXE_SIGNATURE:
        case ERROR_EXE_MARKED_INVALID:
        case ERROR_ITERATED_DATA_EXCEEDS_64k:
        case ERROR_INVALID_MINALLOCSIZE:
        case ERROR_DYNLINK_FROM_INVALID_RING:
        case ERROR_IOPL_NOT_ENABLED:
        case ERROR_INVALID_SEGDPL:
        case ERROR_AUTODATASEG_EXCEEDS_64k:
        case ERROR_RING2SEG_MUST_BE_MOVABLE:
        case ERROR_RELOC_CHAIN_XEEDS_SEGLIM:
        case ERROR_INFLOOP_IN_RELOC_CHAIN:
        //case ERROR_BAD_DYNALINK:
        case ERROR_TOO_MANY_MODULES:

            //
            // About these, the ring 3 server code says "map to bad
            // format errors." Whatever that means.  It doesn't do
            // anything with them, so we don't either.
            //

            break;

        case ERROR_DISK_CHANGE:

            *DosErrorClass = SMB_ERR_CLASS_HARDWARE;
            *DosError = ERROR_WRONG_DISK;
            break;

        case ERROR_DRIVE_LOCKED:

            *DosErrorClass = SMB_ERR_CLASS_HARDWARE;
            *DosError = ERROR_NOT_READY;
            break;

        case ERROR_ALREADY_EXISTS:

            *DosError = ERROR_FILE_EXISTS;
            break;

        case ERROR_DISK_FULL:

            //
            // Per LarryO, map to the "old" disk full error code.
            //

            *DosErrorClass = SMB_ERR_CLASS_HARDWARE;
            *DosError = ERROR_HANDLE_DISK_FULL;
            break;

        case ERROR_NO_MORE_SEARCH_HANDLES:

            *DosError = ERROR_OUT_OF_STRUCTURES;
            break;

        case ERROR_INVALID_TARGET_HANDLE:

            *DosError = ERROR_INVALID_HANDLE;
            break;

        case ERROR_BROKEN_PIPE:
        case ERROR_BAD_PIPE:
        case ERROR_PIPE_BUSY:
        case ERROR_NO_DATA:
        case ERROR_PIPE_NOT_CONNECTED:
        case ERROR_MORE_DATA:

            //
            // If this is a pipe share, return these unmolested.  If
            // it's not a pipe share, so map to the generic error.
            //

            if ( (WorkContext->Rfcb != NULL &&
                  WorkContext->Rfcb->ShareType == ShareTypePipe)
                               ||
                 (WorkContext->TreeConnect != NULL &&
                  WorkContext->TreeConnect->Share->ShareType == ShareTypePipe) ) {

                break;

            } else {

                *DosErrorClass = SMB_ERR_CLASS_HARDWARE;
                *DosError = SMB_ERR_GENERAL;
            }

            break;

        case ERROR_BAD_PATHNAME:
            break;

        //
        // The following error mappings (not including default) were not
        // copied from the OS/2 server mapping.
        //

        case ERROR_LOCK_FAILED:
        case ERROR_NOT_LOCKED:
            *DosError = ERROR_LOCK_VIOLATION;
            break;

        case NERR_InvalidLogonHours:
        case NERR_InvalidWorkstation:
        case NERR_PasswordExpired:
        case NERR_AccountUndefined:
        case ERROR_ACCESS_DENIED:
            *DosError = ERROR_ACCESS_DENIED;
            break;

        default:

            *DosErrorClass = SMB_ERR_CLASS_HARDWARE;
            *DosError = SMB_ERR_GENERAL;
        }
    }

    //
    // The DOS redirector uses the reserved field for the hard error action.
    // Set it now.
    //

    if ( *DosErrorClass == SMB_ERR_CLASS_HARDWARE ) {
        WorkContext->ResponseHeader->Reserved = DISK_HARD_ERROR;
    }

} // MapErrorForDosClient


VOID
SrvSetBufferOverflowError (
    IN PWORK_CONTEXT WorkContext
    )
{
    PSMB_HEADER header = WorkContext->ResponseHeader;
    USHORT flags = SmbGetAlignedUshort( &header->Flags2 );

    UNLOCKABLE_CODE( 8FIL );

    if ( CLIENT_CAPABLE_OF(NT_STATUS, WorkContext->Connection) ) {
        SmbPutUlong(
            (PULONG)&header->ErrorClass,
            (ULONG)STATUS_BUFFER_OVERFLOW
            );
        flags |= SMB_FLAGS2_NT_STATUS;
    } else {
        header->ErrorClass = SMB_ERR_CLASS_DOS;
        SmbPutUshort( &header->Error, ERROR_MORE_DATA );
        flags &= ~SMB_FLAGS2_NT_STATUS;
    }
    SmbPutAlignedUshort( &header->Flags2, flags );

    return;

} // SrvSetBufferOverflowError
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\srvstrng.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    srvstrng.c

Abstract:

    This module defines global string data for the LAN Manager server.
    The globals defined herein are part of the server driver image, and
    are therefore loaded into the system address space and are
    nonpageable.

Author:

    Chuck Lenzmeier (chuckl)    6-Oct-1993

Revision History:

--*/

#include "precomp.h"
#include "srvstrng.tmh"
#pragma hdrstop

//
// Device prefix strings.
//

PWSTR StrNamedPipeDevice = L"\\Device\\NamedPipe\\";
PWSTR StrMailslotDevice = L"\\Device\\Mailslot\\";

PWSTR StrSlashPipe = UNICODE_SMB_PIPE_PREFIX;
PSTR StrSlashPipeAnsi = SMB_PIPE_PREFIX;
PWSTR StrSlashPipeSlash = L"\\PIPE\\";
PSTR StrPipeSlash = CANONICAL_PIPE_PREFIX;
PWSTR StrSlashMailslot = UNICODE_SMB_MAILSLOT_PREFIX;

//
// Pipe name for remote down-level API requests.
//

PWSTR StrPipeApi = L"\\PIPE\\LANMAN";
PSTR StrPipeApiOem = "\\PIPE\\LANMAN";

PWSTR StrNull = L"";
PSTR StrNullAnsi = "";

PWSTR StrUnknownClient = L"(?)";

PWSTR StrServerDevice = SERVER_DEVICE_NAME;

PSTR StrLogonProcessName = "LAN Manager Server";
PSTR StrLogonPackageName = MSV1_0_PACKAGE_NAME;

WCHAR StrStarDotStar[] = L"*.*";

PSTR StrTransportAddress = TdiTransportAddress;
PSTR StrConnectionContext = TdiConnectionContext;

PWSTR StrUserAlertEventName = ALERT_USER_EVENT;
PWSTR StrAdminAlertEventName = ALERT_ADMIN_EVENT;
PWSTR StrDefaultSrvDisplayName = SERVER_DISPLAY_NAME;
PWSTR StrNoNameTransport = L"<No Name>";

PWSTR StrAlerterMailslot = L"\\Device\\Mailslot\\Alerter";

//
// Registry paths.
//

PWSTR StrRegServerPath = L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\LanmanServer";
PWSTR StrRegSrvDisplayName = L"DisplayName";

PWSTR StrRegOsVersionPath = L"\\Registry\\Machine\\Software\\Microsoft\\Windows Nt\\CurrentVersion";
PWSTR StrRegVersionKeyName = L"CurrentVersion";
PWSTR StrRegVersionBuildNumberKeyName = L"CurrentBuildNumber";
PWSTR StrRegVersionProductKeyName = L"ProductName";
PWSTR StrRegVersionSPKeyName = L"CSDVersion";

PWSTR StrRegSrvParameterPath = L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\LanmanServer\\Parameters";
PWSTR StrRegExtendedCharsInPath = L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\FileSystem";
PWSTR StrRegExtendedCharsInPathValue = L"NtfsAllowExtendedCharacterIn8dot3Name";
PWSTR StrRegNullSessionPipes = L"NullSessionPipes";
PWSTR StrRegNullSessionShares = L"NullSessionShares";
PWSTR StrRegPipesNeedLicense = L"PipesNeedLicense";
PWSTR StrRegNoRemapPipes = L"NoRemapPipes";
PWSTR StrRegEnforceLogoffTimes = L"EnforceLogoffTimes";
PWSTR StrRegDisableDosChecking = L"DisableDoS";
PWSTR StrRegEnableSecuritySignatures = L"enablesecuritysignature";
PWSTR StrRegRequireSecuritySignatures = L"requiresecuritysignature";
PWSTR StrRegEnableExtendedSignatures = L"enableextendedsignature";
PWSTR StrRegRequireExtendedSignatures = L"requireextendedsignature";
PWSTR StrRegEnableInvalidSmbLogging = L"enableinvalidsmblogging";

PWSTR StrRegDisableLargeRead = L"disablelargeread";
PWSTR StrRegDisableLargeWrite = L"disablelargewrite";
PWSTR StrRegNoAliasingOnFilesystem = L"noaliasingonfilesystem";
PWSTR StrRegDisableDownlevelTimewarp = L"disabledownleveltimewarp";

PWSTR StrRegMapNoIntermediateBuffering = L"mapnointermediatebuffering";

UNICODE_STRING StrRegSrvPnpClientName = { 24, 24, L"LanManServer" };

PWSTR StrRegErrorLogIgnore = L"ErrorLogIgnore";

#if SRVNTVERCHK
PWSTR StrRegInvalidDomainNames = L"InvalidDomainsForNt5Clients";
PWSTR StrRegAllowedIPAddresses = L"ValidNT5IPAddr";
#endif

//
// Pipes that are never remapped, even when running on clusters (see open.c::RemapPipeName())
//
STATIC
PWSTR StrDefaultNoRemapPipeNames[] = {
    L"netlogon",
    L"lsarpc",
    L"samr",
    L"browser",
    L"srvsvc",
    L"wkssvc",
    NULL
};

//
// Pipes that are accessible by the NULL session.
//

STATIC
PWSTR StrDefaultNullSessionPipes[] = {
    L"netlogon",
    L"lsarpc",
    L"samr",
    L"browser",
    L"srvsvc",
    L"wkssvc",
    NULL
};

//
// Shares that are accessible by the NULL session.
//

STATIC
PWSTR StrDefaultNullSessionShares[] = {
    NULL
};

//
// DOS device names that can not be accessed by clients
//
UNICODE_STRING SrvDosDevices[] = {
    { 8, 8, L"LPT1"},
    { 8, 8, L"LPT2"},
    { 8, 8, L"LPT3"},
    { 8, 8, L"LPT4"},
    { 8, 8, L"LPT5"},
    { 8, 8, L"LPT6"},
    { 8, 8, L"LPT7"},
    { 8, 8, L"LPT8"},
    { 8, 8, L"LPT9"},
    { 8, 8, L"COM1"},
    { 8, 8, L"COM2"},
    { 8, 8, L"COM3"},
    { 8, 8, L"COM4"},
    { 8, 8, L"COM5"},
    { 8, 8, L"COM6"},
    { 8, 8, L"COM7"},
    { 8, 8, L"COM8"},
    { 8, 8, L"COM9"},
    { 6, 6, L"PRN" },
    { 6, 6, L"AUX" },
    { 6, 6, L"NUL" },
    { 6, 6, L"CON" },
    { 12, 12, L"CLOCK$" },
    {0}
};

//
// Name of EA data file on FAT
//
UNICODE_STRING SrvEaFileName = { 22, 22, L"EA DATA. SF" };

//
// Pipes that require a license from the license server.
//
STATIC
PWSTR StrDefaultPipesNeedLicense[] = {
    L"spoolss",
    NULL
};

//
// Error codes that should not be logged
//
STATIC
PWSTR StrDefaultErrorLogIgnore[] = {
    L"C0000001",    //STATUS_UNSUCCESSFUL
    L"C000013B",    //STATUS_LOCAL_DISCONNECT
    L"C000013C",    //STATUS_REMOTE_DISCONNECT
    L"C000013E",    //STATUS_LINK_FAILED
    L"C000013F",    //STATUS_LINK_TIMEOUT
    L"C00000B0",    //STATUS_PIPE_DISCONNECTED
    L"C00000B1",    //STATUS_PIPE_CLOSING
    L"C0000121",    //STATUS_CANNOT_DELETE
    L"C00000B5",    //STATUS_IO_TIMEOUT
    L"C0000120",    //STATUS_CANCELLED
    L"C0000034",    //STATUS_OBJECT_NAME_NOT_FOUND
    L"C000003A",    //STATUS_OBJECT_PATH_NOT_FOUND
    L"C0000022",    //STATUS_ACCESS_DENIED
    L"C000013B",    //STATUS_LOCAL_DISCONNECT
    L"C000013C",    //STATUS_REMOTE_DISCONNECT
    L"C000013E",    //STATUS_LINK_FAILED
    L"C000020C",    //STATUS_CONNECTION_DISCONNECTED
    L"C0000241",    //STATUS_CONNECTION_ABORTED
    L"C0000140",    //STATUS_INVALID_CONNECTION
    L"C000023A",    //STATUS_CONNECTION_INVALID
    L"C000020D",    //STATUS_CONNECTION_RESET
    L"C00000B5",    //STATUS_IO_TIMEOUT
    L"C000023C",    //STATUS_NETWORK_UNREACHABLE
    L"C0000120",    //STATUS_CANCELLED
    L"C000013F",    //STATUS_LINK_TIMEOUT
    L"C0000008",    //STATUS_INVALID_HANDLE
    L"C000009A",    //STATUS_INSUFFICIENT_RESOURCES
    0
};

//
// StrDialects[] holds ASCII strings corresponding to the dialects
// that the NT LanMan server can speak.  They are listed in descending
// order of preference, so the first listed is the one we'd most like to
// use.  This array should match the SMB_DIALECT enum in inc\smbtypes.h
//

STATIC
PSTR StrDialects[] = {
    CAIROX,                         // Cairo
    NTLANMAN,                       // NT LanMan
    LANMAN21,                       // OS/2 LanMan 2.1
    DOSLANMAN21,                    // DOS LanMan 2.1
    LANMAN12,                       // OS/2 1.2 LanMan 2.0
    DOSLANMAN12,                    // DOS LanMan 2.0
    LANMAN10,                       // 1st version of full LanMan extensions
    MSNET30,                        // Larger subset of LanMan extensions
    MSNET103,                       // Limited subset of LanMan extensions
    PCLAN1,                         // Alternate original protocol
    PCNET1,                         // Original protocol
    "ILLEGAL",
};

//
// StrClientTypes[] holds strings mapping dialects to client versions.
//

STATIC
PWSTR StrClientTypes[] = {
    L"Cairo",
    L"NT",
    L"OS/2 LM 2.1",
    L"DOS LM 2.1",
    L"OS/2 LM 2.0",
    L"DOS LM 2.0",
    L"OS/2 LM 1.0",
    L"DOS LM",
    L"DOWN LEVEL"
};

#if DBG
PWSTR StrWriteAndX = L"WriteAndX";
#endif

WCHAR StrQuestionMarks[] = L"????????.???";

PWSTR StrFsCdfs = FS_CDFS;
PWSTR StrFsFat = FS_FAT;

PWSTR StrNativeOsPrefix =         L"Windows ";

PWSTR StrDefaultNativeOs =        L"Windows 2000";
PSTR  StrDefaultNativeOsOem =      "Windows 2000";

PWSTR StrNativeLanman =         L"Windows 2000 LAN Manager";
PSTR  StrNativeLanmanOem =       "Windows 2000 LAN Manager";

//
// Table of service name strings.  This table corresponds to the
// enumerated type SHARE_TYPE.  Keep the two in sync.
//

PSTR StrShareTypeNames[] = {
    SHARE_TYPE_NAME_DISK,
    SHARE_TYPE_NAME_PRINT,
    SHARE_TYPE_NAME_PIPE,
    SHARE_TYPE_NAME_WILD,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\srvsvc.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    srvsvc.h

Abstract:

    This module defines prototypes for the API processors.  These
    routines are called in response to an FSCTL from the server
    service.

Author:

    David Treadwell (davidtr) 20-Jan-1991

Revision History:

--*/

#ifndef _SRVSVC_
#define _SRVSVC_

//
// Standard prototype for all API processors.
//

typedef
NTSTATUS
(*PAPI_PROCESSOR) (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    );

//
// Prototypes for filter, size, and buffer filling routines used by Enum
// APIs.  SrvEnumApiHandler calls these routines when it has found a
// block to determine whether the block should actually be put in the
// output buffer.
//

typedef
BOOLEAN
(*PENUM_FILTER_ROUTINE) (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    );

typedef
ULONG
(*PENUM_SIZE_ROUTINE) (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    );

typedef
VOID
(*PENUM_FILL_ROUTINE) (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block,
    IN OUT PVOID *FixedStructurePointer,
    IN OUT LPWSTR *EndOfVariableData
    );

//
// Prototype for filter routine for SrvMatchEntryInOrderedList.
//

typedef
BOOLEAN
(*PFILTER_ROUTINE) (
    IN PVOID Context,
    IN PVOID Block
    );

//
// Connection APIs.
//

NTSTATUS
SrvNetConnectionEnum (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    );

//
// File APIs.
//

NTSTATUS
SrvNetFileClose (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    );

NTSTATUS
SrvNetFileEnum (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    );

//
// Server APIs.
//

NTSTATUS
SrvNetServerDiskEnum (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    );

NTSTATUS
SrvNetServerSetInfo (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    );

//
// Transport routines.
//

NTSTATUS
SrvNetServerTransportAdd (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    );

NTSTATUS
SrvNetServerTransportDel (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    );

NTSTATUS
SrvNetServerTransportEnum (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    );

//
// Session APIs.
//

NTSTATUS
SrvNetSessionDel (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    );

NTSTATUS
SrvNetSessionEnum (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    );

//
// Share APIs.
//

NTSTATUS
SrvNetShareAdd (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    );

NTSTATUS
SrvNetShareDel (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    );

NTSTATUS
SrvNetShareEnum (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    );

NTSTATUS
SrvNetShareSetInfo (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    );

//
// Statistics routine.
//

NTSTATUS
SrvNetStatisticsGet (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    );

//
// API support routines.
//

VOID
SrvCopyUnicodeStringToBuffer (
    IN PUNICODE_STRING String,
    IN PCHAR FixedStructure,
    IN OUT LPWSTR *EndOfVariableData,
    OUT LPWSTR *VariableDataPointer
    );

VOID
SrvDeleteOrderedList (
    IN PORDERED_LIST_HEAD ListHead
    );

NTSTATUS
SrvEnumApiHandler (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID OutputBuffer,
    IN ULONG BufferLength,
    IN PORDERED_LIST_HEAD ListHead,
    IN PENUM_FILTER_ROUTINE FilterRoutine,
    IN PENUM_SIZE_ROUTINE SizeRoutine,
    IN PENUM_FILL_ROUTINE FillRoutine
    );

PVOID
SrvFindEntryInOrderedList (
    IN PORDERED_LIST_HEAD ListHead,
    IN PFILTER_ROUTINE FilterRoutine OPTIONAL,
    IN PVOID Context OPTIONAL,
    IN ULONG ResumeHandle,
    IN BOOLEAN ExactHandleMatch,
    IN PLIST_ENTRY StartLocation OPTIONAL
    );

PVOID
SrvFindNextEntryInOrderedList (
    IN PORDERED_LIST_HEAD ListHead,
    IN PVOID Block
    );

PSESSION
SrvFindUserOnConnection (
    IN PCONNECTION Connection
    );

ULONG
SrvGetResumeHandle (
    IN PORDERED_LIST_HEAD ListHead,
    IN PVOID Block
    );

VOID
SrvInitializeOrderedList (
    IN PORDERED_LIST_HEAD ListHead,
    IN ULONG ListEntryOffset,
    IN PREFERENCE_ROUTINE ReferenceRoutine,
    IN PDEREFERENCE_ROUTINE DereferenceRoutine,
    IN PSRV_LOCK Lock
    );

VOID
SrvInsertEntryOrderedList (
    IN PORDERED_LIST_HEAD ListHead,
    IN PVOID Block
    );

VOID
SrvRemoveEntryOrderedList (
    IN PORDERED_LIST_HEAD ListHead,
    IN PVOID Block
    );

NTSTATUS
SrvSendDatagram (
    IN PANSI_STRING Domain,
    IN PUNICODE_STRING Transport OPTIONAL,
    IN PVOID Buffer,
    IN ULONG BufferLength
    );

//
// Macro to convert an offset in an API data structure to a pointer
// meaningful to the server.
//

#define OFFSET_TO_POINTER(val,start)                                 \
    {                                                                \
        if ( (val) != NULL ) {                                       \
            (val) = (PVOID)( (PCHAR)(start) + (ULONG_PTR)(val) );    \
        }                                                            \
    }
//
// Macro to determine whether a pointer is within a certain range.
//

#define POINTER_IS_VALID(val,start,len)                      \
    ( (val) == NULL ||                                       \
      ( (ULONG_PTR)(val) > (ULONG_PTR)(start) &&             \
          (ULONG_PTR)(val) < ((ULONG_PTR)(start) + (len)) ) )
#endif // _SRVSVC_

//
// Ensure that the system will not go into a power-down idle standby mode
//
VOID SrvInhibitIdlePowerDown();

//
// Allow the system to go into a power-down idle standby mode
//
VOID SrvAllowIdlePowerDown();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\srvstrng.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    srvstrng.h

Abstract:

    This module defines global string data for the LAN Manager server.

Author:

    Chuck Lenzmeier (chuckl)    6-Oct-1993

Revision History:

--*/

#ifndef _SRVSTRNG_
#define _SRVSTRNG_

//
// Device prefix strings.
//

extern PWSTR StrNamedPipeDevice;
extern PWSTR StrMailslotDevice;

extern PWSTR StrSlashPipe;
extern PSTR StrSlashPipeAnsi;
extern PWSTR StrSlashPipeSlash;
extern PSTR StrPipeSlash;
extern PWSTR StrSlashMailslot;

//
// Pipe name for remote down-level API requests.
//

extern PWSTR StrPipeApi;
extern PSTR StrPipeApiOem;

extern PWSTR StrNull;
extern PSTR StrNullAnsi;

extern PWSTR StrUnknownClient;

extern PWSTR StrServerDevice;

extern PSTR StrLogonProcessName;
extern PSTR StrLogonPackageName;

extern WCHAR StrStarDotStar[];

extern PSTR StrTransportAddress;
extern PSTR StrConnectionContext;

extern PWSTR StrUserAlertEventName;
extern PWSTR StrAdminAlertEventName;
extern PWSTR StrDefaultSrvDisplayName;
extern PWSTR StrNoNameTransport;

extern PWSTR StrAlerterMailslot;

//
// Registry paths.
//

extern PWSTR StrRegServerPath;
extern PWSTR StrRegSrvDisplayName;
extern PWSTR StrRegOsVersionPath;
extern PWSTR StrRegVersionKeyName;
extern PWSTR StrRegVersionBuildNumberKeyName;
extern PWSTR StrRegVersionProductKeyName;
extern PWSTR StrRegVersionSPKeyName;

extern UNICODE_STRING StrRegSrvPnpClientName;

extern PWSTR StrRegSrvParameterPath;
extern PWSTR StrRegExtendedCharsInPath;
extern PWSTR StrRegExtendedCharsInPathValue;
extern PWSTR StrRegNullSessionPipes;
extern PWSTR StrRegNullSessionShares;
extern PWSTR StrRegPipesNeedLicense;
extern PWSTR StrRegNoRemapPipes;
extern PWSTR StrRegEnforceLogoffTimes;
extern PWSTR StrRegDisableDosChecking;
extern PWSTR StrRegEnableSecuritySignatures;
extern PWSTR StrRegRequireSecuritySignatures;
extern PWSTR StrRegEnableExtendedSignatures;
extern PWSTR StrRegRequireExtendedSignatures;
extern PWSTR StrRegEnableInvalidSmbLogging;

extern PWSTR StrRegDisableLargeRead;
extern PWSTR StrRegDisableLargeWrite;
extern PWSTR StrRegMapNoIntermediateBuffering;
extern PWSTR StrRegNoAliasingOnFilesystem;
extern PWSTR StrRegDisableDownlevelTimewarp;

extern PWSTR StrRegErrorLogIgnore;

#if SRVNTVERCHK
extern PWSTR StrRegInvalidDomainNames;
extern PWSTR StrRegAllowedIPAddresses;
#endif

//
// Pipes and shares that are accessible by the NULL session.
//

extern PWSTR StrDefaultNullSessionPipes[];
extern PWSTR StrDefaultNullSessionShares[];

//
// Pipes that are not remapped, even in cluster environments
//
extern PWSTR StrDefaultNoRemapPipeNames[];

//
// DOS device names that can not be accessed by clients
//
extern UNICODE_STRING SrvDosDevices[];

//
// Name of the EA file on FAT
//
extern UNICODE_STRING SrvEaFileName;

//
// Pipes that require a license for access
//
extern PWSTR StrDefaultPipesNeedLicense[];

//
// Error codes that should not be logged
//
extern PWSTR StrDefaultErrorLogIgnore[];

extern PSTR StrDialects[];
extern PWSTR StrClientTypes[];

#if DBG
extern PWSTR StrWriteAndX;
#endif

extern WCHAR StrQuestionMarks[];

#define FS_CDFS L"CDFS"
#define FS_FAT L"FAT"

extern PWSTR StrFsCdfs;
extern PWSTR StrFsFat;

extern PWSTR StrNativeOsPrefix;

extern PWSTR StrDefaultNativeOs;
extern PSTR  StrDefaultNativeOsOem;

extern PWSTR StrNativeLanman;
extern PSTR StrNativeLanmanOem;

//
// Table of service name strings.  This table corresponds to the
// enumerated type SHARE_TYPE.  Keep the two in sync.
//

extern PSTR StrShareTypeNames[];

#endif // ndef _SRVSTRNG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\srvtyp32.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    srvtyp32.h

Abstract:

    This module defines data structures for thunking to 32-bit on Win64
    
Author:

    David Kruse (dkruse)    29-Nov 2000

Revision History:

--*/

#ifndef _SRVTYP32_
#define _SRVTYP32_

// Thunking structure for rename info
typedef struct _FILE_RENAME_INFORMATION32
{
    BOOLEAN ReplaceIfExists;
    ULONG RootDirectory; // Is HANDLE in real structure
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_RENAME_INFORMATION32, *PFILE_RENAME_INFORMATION32;

// For remote link tracking code

typedef struct _REMOTE_LINK_TRACKING_INFORMATION32_ {
    ULONG       TargetFileObject;
    ULONG   TargetLinkTrackingInformationLength;
    UCHAR   TargetLinkTrackingInformationBuffer[1];
} REMOTE_LINK_TRACKING_INFORMATION32,
 *PREMOTE_LINK_TRACKING_INFORMATION32;

typedef struct _FILE_TRACKING_INFORMATION32 {
    ULONG DestinationFile;
    ULONG ObjectInformationLength;
    CHAR ObjectInformation[1];
} FILE_TRACKING_INFORMATION32, *PFILE_TRACKING_INFORMATION32;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\srvtypes.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    srvtypes.h

Abstract:

    This module defines data structures and other types for the LAN
    Manager server.

Author:

    Chuck Lenzmeier (chuckl)    22-Sep-1989

Revision History:

--*/

#ifndef _SRVTYPES_
#define _SRVTYPES_

#include "srvtyp32.h"

//#include <nt.h>

//#include <smbtypes.h>

//
// REFERENCE_HISTORY is used to trace references and dereferences to
// a block when SRVDBG2 is defined.
//
// WARNING:  When using a srv.sys with SRVDBG2 enabled, you must also
//           use a srvsvc.dll and xactsrv.dll with SRVDBG2 enabled.
//           This is because they share the TRANSACTION structure.
//
// *******************************************************************
// *                                                                 *
// * DO NOT CHANGE THIS STRUCTURE WITHOUT CHANGING THE CORRESPONDING *
// * STRUCTURE IN net\inc\xstypes.h!                                 *
// *                                                                 *
// *******************************************************************
//

#if SRVDBG2

typedef struct _REFERENCE_HISTORY_ENTRY {
    ULONG NewReferenceCount;
    ULONG IsDereference;
    PVOID Caller;
    PVOID CallersCaller;
} REFERENCE_HISTORY_ENTRY, *PREFERENCE_HISTORY_ENTRY;

typedef struct _REFERENCE_HISTORY {
    ULONG TotalReferences;
    ULONG TotalDereferences;
    ULONG NextEntry;
    PREFERENCE_HISTORY_ENTRY HistoryTable;
} REFERENCE_HISTORY, *PREFERENCE_HISTORY;

#define REFERENCE_HISTORY_LENGTH 256

#endif


//
// BLOCK_HEADER is the standard block header that appears at the
// beginning of most server-private data structures.  This header is
// used primarily for debugging and tracing.  The Type and State fields
// are described above.  The Size field indicates how much space was
// allocated for the block.  ReferenceCount indicates the number of
// reasons why the block should not be deallocated.  The count is set to
// 2 by the allocation routine, to account for 1) the fact that the
// block is "open" and 2) the pointer returned to the caller.  When the
// block is closed, State is set to Closing, and the ReferenceCount is
// decremented.  When all references (pointers) to the block are
// deleted, and the reference count reaches 0, the block is deleted.
//
// WARNING:  When using a srv.sys with SRVDBG2 enabled, you must also
//           use a srvsvc.dll and xactsrv.dll with SRVDBG2 enabled.
//           This is because they share the TRANSACTION structure.
//
// *******************************************************************
// *                                                                 *
// * DO NOT CHANGE THIS STRUCTURE WITHOUT CHANGING THE CORRESPONDING *
// * STRUCTURE IN net\inc\xstypes.h!                                 *
// *                                                                 *
// *******************************************************************
//

typedef struct _BLOCK_HEADER {
    union {
        struct {
            UCHAR Type;
            UCHAR State;
            USHORT Size;
        };
        ULONG TypeStateSize;
    };
    ULONG ReferenceCount;
#if SRVDBG2
    REFERENCE_HISTORY History;
#endif
} BLOCK_HEADER, *PBLOCK_HEADER;

//
// CLONG_PTR is used to aid the 64-bit porting effort.
//

typedef ULONG_PTR CLONG_PTR;

//
// Work restart routine.  This routine is invoked when a previously
// started operation completes.  In the FSD, the restart routine is
// invoked by the I/O completion routine.  In the FSP, the restart
// routine is invoked by the worker thread when it retrieves a work item
// from the work queue.
//

typedef
VOID
( SRVFASTCALL *PRESTART_ROUTINE) (
    IN OUT struct _WORK_CONTEXT *WorkContext
    );

//
// QUEUEABLE_BLOCK_HEADER is a BLOCK_HEADER followed by a LIST_ENTRY.
// This header is used when more than one type of block needs to be
// queue to the same list -- it ensures that the linkage fields are at
// the same offset in each type of block.  The timestamp can be used to
// measure how long a block has been in the queue.
//
// FspRestartRoutine is the address of the routine that the worker thread
// is to call when the work item is dequeued from the work queue.
//

typedef struct _QUEUEABLE_BLOCK_HEADER {
    BLOCK_HEADER BlockHeader;
    union {
        LIST_ENTRY ListEntry;
        DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT) SLIST_ENTRY SingleListEntry;
    };
    ULONG Timestamp;
    BOOLEAN UsingBlockingThread;                      // Is the current thread a blocking thread?
    BOOLEAN UsingLpcThread;
    PRESTART_ROUTINE FspRestartRoutine;
} QUEUEABLE_BLOCK_HEADER, *PQUEUEABLE_BLOCK_HEADER;

//
// The nonpaged header is used for blocks that are allocated from paged
// pool so that the reference count can be kept in nonpaged pool, thus
// allowing the use of interlocked operations.
//

typedef struct _NONPAGED_HEADER {
    ULONG Type;
    LONG ReferenceCount;
    PVOID PagedBlock;

    //
    // Note that ListEntry is cast to SLIST_ENTRY before use, however
    // that type is not used here as it would add unnecessary padding
    // to this oft-used structure on Win64.
    //

    SINGLE_LIST_ENTRY ListEntry;
} NONPAGED_HEADER, *PNONPAGED_HEADER;

#if defined(_WIN64)

C_ASSERT(0 ==
    FIELD_OFFSET(NONPAGED_HEADER,ListEntry) % MEMORY_ALLOCATION_ALIGNMENT);

#endif

//
// The paged header is used for the paged portions of a block.
//

typedef struct _PAGED_HEADER {
    ULONG Type;
    PVOID NonPagedBlock;
} PAGED_HEADER, *PPAGED_HEADER;

//
// Macros for accessing the block header structure.
//
// *** Note that the existing usage of these macros assumes that the block
//     header is the first element in the block!
//

#define GET_BLOCK_STATE(block) ( ((PBLOCK_HEADER)(block))->State )
#define SET_BLOCK_STATE(block,state) \
            ( ((PBLOCK_HEADER)(block))->State = (UCHAR)(state) )

#define GET_BLOCK_TYPE(block) ( ((PBLOCK_HEADER)(block))->Type )
#define SET_BLOCK_TYPE(block,type) \
            ( ((PBLOCK_HEADER)(block))->Type = (UCHAR)(type) )

#define GET_BLOCK_SIZE(block) ( ((PBLOCK_HEADER)(block))->Size )
#define SET_BLOCK_SIZE(block, size )\
            ( ((PBLOCK_HEADER)(block))->Size = (USHORT)(size) )

//
// Most efficient way to set the block header up.  Compiler will generally turn this
// into a single write of a single constant
//
#define SET_BLOCK_TYPE_STATE_SIZE( block, type,state,size ) \
            ( ((PBLOCK_HEADER)(block))->TypeStateSize = (ULONG)(((USHORT)size<<16) | \
                                                         ((UCHAR)state<<8) | \
                                                          (UCHAR)type ))

//
// A POOL_HEADER is placed on the front of all pool allocations by the
// server
//
typedef struct _POOL_HEADER {

    //
    // This is the number of bytes in the original allocation for this block
    //
    ULONG RequestedSize;

    //
    // This is the base of a vector of LOOK_ASIDE_MAX_ELEMENTS length where
    // this block of memory might be freed to.  If NULL, this block should
    // be returned directly to the appropriate system heap.
    //
    struct _POOL_HEADER **FreeList;

} POOL_HEADER, *PPOOL_HEADER;


//
// SRV_FILE_INFORMATION holds file information in SMB-compatible format,
// as opposed to native NT format.  Creation, last access, and last
// write times are stored in OS/2 format.  Creation time is also stored
// in seconds-since-1970 format, as in the core protocol.  File
// allocation and data sizes are stored as longwords, as opposed to
// LARGE_INTEGERS.
//
// *** Note that files whose size is too large to fit in a longword
//     cannot properly be respresented in the SMB protocol.
//
// *** The fields in this structure are stored in native-endian format,
//     and must be converted to/from little-ending in an actual SMB.
//

typedef struct _SRV_FILE_INFORMATION_ABBREVIATED {
    LARGE_INTEGER DataSize;
    USHORT Attributes;
    ULONG LastWriteTimeInSeconds;
    USHORT Type;
    USHORT HandleState;
} SRV_FILE_INFORMATION_ABBREVIATED, *PSRV_FILE_INFORMATION_ABBREVIATED;

typedef struct _SRV_FILE_INFORMATION {
    SRV_FILE_INFORMATION_ABBREVIATED;
    SMB_DATE CreationDate;
    SMB_TIME CreationTime;
    SMB_DATE LastAccessDate;
    SMB_TIME LastAccessTime;
    SMB_DATE LastWriteDate;
    SMB_TIME LastWriteTime;
    ULONG EaSize;
    LARGE_INTEGER AllocationSize;
} SRV_FILE_INFORMATION, *PSRV_FILE_INFORMATION;




typedef struct {
    FILE_NETWORK_OPEN_INFORMATION;
    ULONG EaSize;
} SRV_NETWORK_OPEN_INFORMATION, *PSRV_NETWORK_OPEN_INFORMATION;

//
// SRV_FILE_INFORMATION holds file information in NT SMB-compatible format,
// It is used to support NT protocol SMB such as NtCreateAndX and
// NtTransactCreate.
//
typedef struct {
    SRV_NETWORK_OPEN_INFORMATION   NwOpenInfo;
    USHORT Type;
    USHORT HandleState;
} SRV_NT_FILE_INFORMATION, *PSRV_NT_FILE_INFORMATION;


//
// Various blocks get a unique identifier (UID, PID, TID, FID, SID).
// This is a typically 16-bit value, the higher bits being the sequence
// number (used to check validity of an ID) and the lower bits being an
// index into an array that contains elements of type TABLE_ENTRY.
// These elements contain the sequence number of the ID and a pointer to
// the block that 'owns' the ID.  Free table elements are joined in a
// singly-linked list.
//
// *** For now, the table entry struct is flat -- the in-use and free
//     fields are not defined in a union.  This is because the flat size
//     of the struct is eight bytes, which is how big the compiler will
//     make it anyway to ensure alignment.  If this changes, consider
//     using a union.
//

typedef struct _TABLE_ENTRY {
    PVOID Owner;
    USHORT SequenceNumber;
    SHORT NextFreeEntry;            // index of next free entry, or -1
} TABLE_ENTRY, *PTABLE_ENTRY;

//
// Information about tables is stored in TABLE_HEADER.  This structure
// has a pointer to the first entry in the table, the size of the table,
// and indices of the first and last free entries.
//

typedef struct _TABLE_HEADER {
    PTABLE_ENTRY Table;
    USHORT TableSize;
    SHORT FirstFreeEntry;
    SHORT LastFreeEntry;
    BOOLEAN Nonpaged;
    UCHAR Reserved;
} TABLE_HEADER, *PTABLE_HEADER;

//
// Typedefs for check-state-and-reference and dereference routines.  All
// server check-state-and-reference and dereference routines follow this
// general format, though the actual pointer they take is not a PVOID
// but rather a pointer to the block type they deal with, so a typecast
// is necessary when assigning these routines.
//
// The check-state-and-reference routine checks the state of the block
// and if the state is "active", references the block.  This must be
// done as an atomic operation.
//

typedef
BOOLEAN
(SRVFASTCALL * PREFERENCE_ROUTINE) (
    IN PVOID Block
    );

typedef
VOID
(SRVFASTCALL * PDEREFERENCE_ROUTINE) (
    IN PVOID Block
    );

//
// Structures used for ordered lists in the server.  Ordered lists
// allow an easy mechanism for walking instances of data blocks and
// include a sort of handle for easily finding the block again, or
// determining if the block has been deleted.
//
// The way they work is to have a global doubly linked list of all the
// relevant data blocks.  The list is stored in order of time of
// allocation, and each block has a ULONG associated with it.  This
// ULONG, called the ResumeHandle, is monotonically increasing starting
// at 1.  (It starts at 1 rather than 0 so that it is simple to write
// code to start a search at the beginning of the list.)  The ResumeHandle
// is all that is necessary to find the next entry in the list.
//

typedef struct _ORDERED_LIST_HEAD {
    LIST_ENTRY ListHead;
    PSRV_LOCK Lock;
    ULONG CurrentResumeHandle;
    ULONG ListEntryOffset;
    PREFERENCE_ROUTINE ReferenceRoutine;
    PDEREFERENCE_ROUTINE DereferenceRoutine;
    BOOLEAN Initialized;
} ORDERED_LIST_HEAD, *PORDERED_LIST_HEAD;

typedef struct _ORDERED_LIST_ENTRY {
    LIST_ENTRY ListEntry;
    ULONG ResumeHandle;
} ORDERED_LIST_ENTRY, *PORDERED_LIST_ENTRY;

//
// Type of resource shortages
//

typedef enum _RESOURCE_TYPE {
    ReceivePending,
    OplockSendPending
} RESOURCE_TYPE, *PRESOURCE_TYPE;

//
// Oplocks types.  Currently one the first 2 will ever be requested
// by a client.
//

typedef enum _OPLOCK_TYPE {
    OplockTypeNone,
    OplockTypeBatch,
    OplockTypeExclusive,
    OplockTypeShareRead,
    OplockTypeServerBatch
} OPLOCK_TYPE, *POPLOCK_TYPE;

//
// The oplock states of an RFCB.
//

typedef enum _OPLOCK_STATE {
    OplockStateNone = 0,
    OplockStateOwnExclusive,
    OplockStateOwnBatch,
    OplockStateOwnLevelII,
    OplockStateOwnServerBatch
} OPLOCK_STATE, *POPLOCK_STATE;

//
// The state of a wait for oplock break.  This is used to mark the state
// of a client that is waiting for another client to break its oplock.
//

typedef enum _WAIT_STATE {
    WaitStateNotWaiting,
    WaitStateWaitForOplockBreak,
    WaitStateOplockWaitTimedOut,
    WaitStateOplockWaitSucceeded
} WAIT_STATE, *PWAIT_STATE;

//
// The reason a connection is being disconnected
typedef enum _DISCONNECT_REASON {
    DisconnectIdleConnection=0,
    DisconnectEndpointClosing,
    DisconnectNewSessionSetupOnConnection,
    DisconnectTransportIssuedDisconnect,
    DisconnectSessionDeleted,
    DisconnectBadSMBPacket,
    DisconnectSuspectedDOSConnection,
    DisconnectAcceptFailedOrCancelled,
    DisconnectStaleIPXConnection,
    DisconnectReasons
} DISCONNECT_REASON, *PDISCONNECT_REASON;

//
// Per-queue variables for server statistics.
//

typedef struct _SRV_STATISTICS_QUEUE {

    ULONGLONG BytesReceived;
    ULONGLONG BytesSent;
    ULONGLONG ReadOperations;
    ULONGLONG BytesRead;
    ULONGLONG WriteOperations;
    ULONGLONG BytesWritten;
    SRV_TIMED_COUNTER WorkItemsQueued;

    //
    // System time, as maintained by the server.  This
    // is the low part of the system tick count.  The
    // server samples it periodically, so the time is
    // not exactly accurate.  It is monotontically increasing,
    // except that it wraps every 74 days or so.
    //

    ULONG     SystemTime;

} SRV_STATISTICS_QUEUE, *PSRV_STATISTICS_QUEUE;

//
// Structure used to keep internal statistics in the server. Mainly used
// for servicing the NetStatisticsGet API.
//

typedef struct _SRV_ERROR_RECORD {

    ULONG SuccessfulOperations;
    ULONG FailedOperations;

    ULONG AlertNumber;

    ULONG ErrorThreshold;

} SRV_ERROR_RECORD, *PSRV_ERROR_RECORD;

//
// This looks enough like a WORK_CONTEXT structure to allow queueing to
// a work queue, and dispatching to the FspRestartRoutine.  Its blocktype
// is BlockTypeWorkContextSpecial.  It must not be freed to the free lists.
//
typedef struct _SPECIAL_WORK_ITEM {
    QUEUEABLE_BLOCK_HEADER ;
    struct _WORK_QUEUE *CurrentWorkQueue;
} SPECIAL_WORK_ITEM, *PSPECIAL_WORK_ITEM;

//
// This structure holds a vector of PPOOL_HEADERs in lists which are set and
//  retrieved with ExInterlockedExchange() for fast allocation and deallocation.
//
typedef struct {

    //
    // SmallFreeList is a look aside vector of recently freed PPOOL_HEADERs
    //  which are <= LOOK_ASIDE_SWITCHOVER bytes.
    //
    PPOOL_HEADER SmallFreeList[ LOOK_ASIDE_MAX_ELEMENTS ];

    //
    // LargeFreeList is a look aside vector of recently freed PPOOL_HEADERs
    //  which are greater than LOOK_ASIDE_SWITCHOVER bytes,
    //  but less than MaxSize bytes.
    //
    PPOOL_HEADER LargeFreeList[ LOOK_ASIDE_MAX_ELEMENTS ];

    //
    // This is the maximum size that we'll save in the LargeFreeList
    //
    CLONG MaxSize;

    //
    // This is the number of times we allocated from either list
    //
    CLONG AllocHit;

    //
    // This is the number of times we failed to allocate from either list
    //
    CLONG AllocMiss;

} LOOK_ASIDE_LIST, *PLOOK_ASIDE_LIST;

//
// WORK_QUEUE describes a work queue.
//

typedef struct _WORK_QUEUE {

    union {

        //
        // Since this is an unnamed structure inside of an unnamed union, we
        // can just directly name the members elsewhere in the code.
        //
        struct _QUEUE {
            //
            // The mode we use to wait
            //
            KPROCESSOR_MODE WaitMode;

            //
            // The kernel queue that is holding the requests for this processor
            //
            KQUEUE Queue;

            //
            // This is how long a kernel worker threads hangs around looking for work.
            //  If it doesn't find work, it will voluntarily terminate
            //
            LARGE_INTEGER IdleTimeOut;

            //
            // Number of threads currently NOT running on this queue
            //
            ULONG AvailableThreads;

            //
            // Spin lock that protects list manipulation and various items in
            // this structure
            //
            KSPIN_LOCK SpinLock;

            //
            //  Possibly one free WORK_CONTEXT structure.  Use InterlockedExchange
            //   to see if you can get it.
            //
            struct _WORK_CONTEXT *FreeContext;

            //
            // InitialWorkItemList is the free list of work items that
            //  were preallocated at startup
            //
            SLIST_HEADER InitialWorkItemList;

            //
            // NormalWorkItemList is the free list of work items that are
            //  allocated as needed as we go
            //
            SLIST_HEADER NormalWorkItemList;

            //
            // RawModeWorkItemList is the free list of raw mode work items
            //   and are allocated as needed as we go
            //
            SLIST_HEADER RawModeWorkItemList;

            //
            // How many clients have this as their CurrentWorkQueue
            //
            ULONG CurrentClients;

            //
            // The number of work items on either of the above lists
            //
            LONG FreeWorkItems;

            //
            // The maximum number of WorkItems we're allowed to have
            //
            LONG MaximumWorkItems;

            //
            // The minimum number of free work items we'd like to have on the lists
            //
            LONG MinFreeWorkItems;

            //
            // The number of work items that we need to recycle due to shortage
            //
            LONG NeedWorkItem;

            //
            // The number of work items stolen from us by other processors
            //
            LONG StolenWorkItems;

            //
            // The number of free RawModeWorkItems
            //
            LONG FreeRawModeWorkItems;

            //
            // RfcbFreeList is a free list of RFCB structures, used to cut
            //  down on the number of pool allocations
            //
            struct _RFCB      *CachedFreeRfcb;
            SLIST_HEADER      RfcbFreeList;

            //
            // The number of entries in the RfcbFreeList
            //
            LONG FreeRfcbs;

            //
            // The maximum number we'll allow in the RfcbFreeList
            //
            LONG MaxFreeRfcbs;

            //
            // MfcbFreeList is a free list of NONPAGED_MFCB structures, used
            //  to reduce the number of pool allocations
            //
            struct _NONPAGED_MFCB    *CachedFreeMfcb;
            SLIST_HEADER             MfcbFreeList;

            //
            // The number of entries in the MfcbFreeList
            //
            LONG FreeMfcbs;

            //
            // The maximum number we'll allow in the MfcbFreeList
            //
            LONG MaxFreeMfcbs;

            //
            // These two lists hold recently freed blocks of memory.
            //
            LOOK_ASIDE_LIST   PagedPoolLookAsideList;

            LOOK_ASIDE_LIST   NonPagedPoolLookAsideList;

            //
            // The number of allocated RawModeWorkItems
            //
            LONG AllocatedRawModeWorkItems;

            //
            // The number of threads servicing this queue
            //
            ULONG Threads;

            //
            // The maximum number of threads we'll allow on this queue
            //
            ULONG MaxThreads;

            //
            // The number of WorkItems that we have allocated for this workqueue
            //
            LONG AllocatedWorkItems;

            //
            // A pointer to one of our threads, needed for irps
            //
            PETHREAD IrpThread;

            //
            // Data used to compute average queue depth...
            //
            // A vector of depth samples
            //
            ULONG DepthSamples[ QUEUE_SAMPLES ];

            //
            // Position of next sample update.  This is set to NULL when we're
            //  trying to terminate the computation dpc
            //
            PULONG NextSample;

            //
            // Time of next sample update
            //
            LARGE_INTEGER NextAvgUpdateTime;

            //
            // The sum of the samples in the DepthSamples vector
            //
            ULONG AvgQueueDepthSum;

            //
            // Event used to synchronize termination of the avg queue
            //  depth computation dpc
            //
            KEVENT AvgQueueDepthTerminationEvent;

            //
            // DPC object used to schedule the depth computation
            //
            KDPC QueueAvgDpc;

            //
            // Timer object for running QueueAvgDpc
            //
            KTIMER QueueAvgTimer;

            //
            // Per-queue statistics
            //
            SRV_STATISTICS_QUEUE stats;

            //
            // When we update the Io counters for operations, we need to know
            //  the number of operations that have been processed since the last update.
            //  'saved' stores the values which were given last time -- the difference between
            //  the statistics in 'stats' and the corresponding member in 'saved' is the
            //  number which should be given to the Io counters.  (see scavengr.c)
            //
            struct {
                ULONGLONG ReadOperations;
                ULONGLONG BytesRead;
                ULONGLONG WriteOperations;
                ULONGLONG BytesWritten;
            } saved;

            //
            // This work item is queued on the Queue above to cause
            //  more work items to be allocated
            //
            SPECIAL_WORK_ITEM   CreateMoreWorkItems;

        };

        //
        // Since we are allocating an array of these (one per processor), it
        // would cause interprocessor cache sloshing if a WORK_QUEUE structure
        // was not a multiple of the CACHE_LINE_SIZE.  The following pad is
        // set to round up the size of the above struct to the next cache line size.
        //
        ULONG _pad[ (sizeof(struct _QUEUE)+CACHE_LINE_SIZE-1) / CACHE_LINE_SIZE * ULONGS_IN_CACHE ];

    };
} WORK_QUEUE, *PWORK_QUEUE;

#endif // ndef _SRVTYPES_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\srvsupp.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    srvsupp.h

Abstract:

    This module defines support routines for SMB processors for the LAN
    Manager server.

Author:

    Chuck Lenzmeier (chuckl) 1-Dec-1989
    David Treadwell (davidtr)

Revision History:

--*/

#ifndef _SRVSUPP_
#define _SRVSUPP_

//#include <ntos.h>

//#include <smb.h>
//#include "smbtypes.h"
//#include "srvblock.h"

//
// Use the same directory separator as the object system uses.
//

// Status code used to signal the need for reauthentication
#define SESSION_EXPIRED_STATUS_CODE STATUS_NETWORK_SESSION_EXPIRED

#define DIRECTORY_SEPARATOR_CHAR ((UCHAR)(OBJ_NAME_PATH_SEPARATOR))
#define UNICODE_DIR_SEPARATOR_CHAR ((WCHAR)(OBJ_NAME_PATH_SEPARATOR))
#define RELATIVE_STREAM_INITIAL_CHAR ((UCHAR)':')

#define IS_ANSI_PATH_SEPARATOR(character) \
            ( character == DIRECTORY_SEPARATOR_CHAR || character == '\0' )
#define IS_UNICODE_PATH_SEPARATOR(character) \
            ( character == UNICODE_DIR_SEPARATOR_CHAR || character == L'\0' )

//
// Access necessary for copying a file.  DO NOT use generic bits here;
// these are used in calls to IoCheckDesiredAccess, which cannot accept
// generic bits for the DesiredAccess.
//

#define SRV_COPY_SOURCE_ACCESS READ_CONTROL | \
                               FILE_READ_DATA | \
                               FILE_READ_ATTRIBUTES | \
                               FILE_READ_EA

#define SRV_COPY_TARGET_ACCESS WRITE_DAC | \
                               WRITE_OWNER | \
                               FILE_WRITE_DATA | \
                               FILE_APPEND_DATA | \
                               FILE_WRITE_ATTRIBUTES | \
                               FILE_WRITE_EA

//
// This type is used to determine the size of the largest directory query
// information structure.
//

typedef union _SRV_QUERY_DIRECTORY_INFORMATION {
    FILE_DIRECTORY_INFORMATION Directory;
    FILE_FULL_DIR_INFORMATION FullDir;
    FILE_BOTH_DIR_INFORMATION BothDir;
    FILE_NAMES_INFORMATION Names;
} SRV_QUERY_DIRECTORY_INFORMATION, *PSRV_QUERY_DIRECTORY_INFORMATION;

//
// Type definition for the structure used by SrvQueryDirectoryFile
// to do its work.  Calling routines must set up a buffer in nonpaged
// pool with enough room for this structure plus other things.  (See
// MIN_SEARCH_BUFFER_SIZE.)
//

typedef struct _SRV_DIRECTORY_INFORMATION {
    HANDLE DirectoryHandle;
    PFILE_DIRECTORY_INFORMATION CurrentEntry;
    ULONG BufferLength;
    struct {
        BOOLEAN Wildcards : 1;
        BOOLEAN ErrorOnFileOpen : 1;
        BOOLEAN OnlySingleEntries : 1;
        BOOLEAN DownlevelTimewarp : 1;
    };
    LONG Buffer[1];
} SRV_DIRECTORY_INFORMATION, *PSRV_DIRECTORY_INFORMATION;

//
// Type definition for the structure used by SrvQueryEaFile to do its
// work.  Calling routines must set up a buffer in nonpaged pool with
// enough room for this structure and at least a single EA.  An EA may
// be as large as sizeof(FILE_FULL_EA_INFORMATION) +
// (2 ^ (sizeof(UCHAR)*8)) + (2 ^ (sizeof(USHORT)*8)) ~= 65k, so
// calling routines should first query the size of the EAs, then allocate
// a buffer big enough for either all the EAs or a single maximum-sized
// EA.
//

typedef struct _SRV_EA_INFORMATION {
    PFILE_FULL_EA_INFORMATION CurrentEntry;
    ULONG BufferLength;
    ULONG GetEaListOffset;
    LONG Buffer[1];
} SRV_EA_INFORMATION, *PSRV_EA_INFORMATION;

#define MAX_SIZE_OF_SINGLE_EA ( sizeof(FILE_FULL_EA_INFORMATION) + 257 + 65536 )

//
// The directory cache structure used to maintain information about
// core searches between requests.  One of these structures is maintained
// for each file returned.
//

typedef struct _DIRECTORY_CACHE {
    ULONG FileIndex;
    WCHAR UnicodeResumeName[ 12 ];
    USHORT UnicodeResumeNameLength;
} DIRECTORY_CACHE, *PDIRECTORY_CACHE;

//
// Limit the number of files that may be returned on a core search.
//

#define MAX_DIRECTORY_CACHE_SIZE 10

//
// Macros used to determine the search buffer size.  The first three are
// possible buffer sizes, the second two are numbers of files to be returned
// that represent cutoff points for using the different search buffer
// sizes.
//
// An approximate formula for determining the size of the search buffer is:
//
// (maxCount+2) * (sizeof(SRV_QUERY_DIRECTORY_INFORMATION)+13) +
// sizeof(SRV_DIRECTORY_INFORMATION)
//
// where maxCount is the maximum number of files to return.  The +2 is
// a slop factor to account for the possibility of files that to not
// match the search attributes, and the +13 accounts for the size of
// FAT filenames.
//
// Note that the minimum buffer size must include the following factors in
// order to avoid the possibility of not even being able to hold one entry
// with the longest legal filename:
//
//    sizeof(SRV_DIRECTORY_INFORMATION)
//    sizeof(SRV_QUERY_DIRECTORY_INFORMATION) + (MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR))
//    sizeof(UNICODE_STRING) + (MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR)) + 3
//
// The last factor is needed because SrvIssueQueryDirectoryRequest puts
// the search filename at the end of the buffer.  (The +3 is necessary to
// allow for aligning the UNICODE_STRING on a ULONG boundary.)
//

#define MAX_SEARCH_BUFFER_SIZE 4096
#define MED_SEARCH_BUFFER_SIZE 2048
#define MIN_SEARCH_BUFFER_SIZE                                                                  \
        (sizeof(SRV_DIRECTORY_INFORMATION) +                                                    \
        (sizeof(SRV_QUERY_DIRECTORY_INFORMATION) + (MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR))) + \
        (sizeof(UNICODE_STRING) + (MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR)) + 3))

#define MAX_FILES_FOR_MED_SEARCH 20
#define MAX_FILES_FOR_MIN_SEARCH 10

//
// The macros for FIND2 have the same meaning as the SEARCH macros except
// that they are used in the FIND2 protocols.
//

#define MAX_FILES_FOR_MED_FIND2 16
#define MAX_FILES_FOR_MIN_FIND2 8

//
// Macros to check context handles for equality and for NULLness
//

#define CONTEXT_EQUAL(x,y)  (((x).dwLower == (y).dwLower) && ((x).dwUpper == (y).dwUpper))
#define CONTEXT_NULL(x)     (((x).dwLower == 0) && ((x).dwUpper == 0))


//
// SMB processing support routines.
//

VOID
SrvAllocateAndBuildPathName(
    IN PUNICODE_STRING Path1,
    IN PUNICODE_STRING Path2,
    IN PUNICODE_STRING Path3 OPTIONAL,
    OUT PUNICODE_STRING BuiltPath
    );

NTSTATUS
SrvCanonicalizePathName(
    IN PWORK_CONTEXT WorkContext,
    IN PSHARE Share OPTIONAL,
    IN PUNICODE_STRING RelatedPath OPTIONAL,
    IN OUT PVOID Name,
    IN PCHAR LastValidLocation,
    IN BOOLEAN RemoveTrailingDots,
    IN BOOLEAN SourceIsUnicode,
    OUT PUNICODE_STRING String
    );

NTSTATUS
SrvCanonicalizePathNameWithReparse(
    IN PWORK_CONTEXT WorkContext,
    IN PSHARE Share OPTIONAL,
    IN PUNICODE_STRING RelatedPath OPTIONAL,
    IN OUT PVOID Name,
    IN PCHAR LastValidLocation,
    IN BOOLEAN RemoveTrailingDots,
    IN BOOLEAN SourceIsUnicode,
    OUT PUNICODE_STRING String
    );

VOID
SrvCloseQueryDirectory(
    PSRV_DIRECTORY_INFORMATION DirectoryInformation
    );

NTSTATUS
SrvCheckSearchAttributesForHandle(
    IN HANDLE FileHandle,
    IN USHORT SmbSearchAttributes
    );

NTSTATUS SRVFASTCALL
SrvCheckSearchAttributes(
    IN USHORT FileAttributes,
    IN USHORT SmbSearchAttributes
    );

NTSTATUS
SrvCopyFile(
    IN HANDLE SourceHandle,
    IN HANDLE TargetHandle,
    IN USHORT SmbOpenFunction,
    IN USHORT SmbFlags,
    IN ULONG ActionTaken
    );

NTSTATUS
SrvCreateFile(
    IN PWORK_CONTEXT WorkContext,
    IN USHORT SmbDesiredAccess,
    IN USHORT SmbFileAttributes,
    IN USHORT SmbOpenFunction,
    IN ULONG SmbAllocationSize,
    IN PCHAR SmbFileName,
    IN PCHAR EndOfSmbFileName,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength,
    IN PULONG EaErrorOffset OPTIONAL,
    IN OPLOCK_TYPE RequestedOplockType,
    IN PRESTART_ROUTINE RestartRoutine
    );

NTSTATUS
SrvNtCreateFile(
    IN OUT PWORK_CONTEXT WorkContext,
    IN ULONG RootDirectoryFid,
    IN ACCESS_MASK DesiredAccess,
    IN LARGE_INTEGER AllocationSize,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN PVOID SecurityDescriptorBuffer OPTIONAL,
    IN PUNICODE_STRING FileName,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength,
    OUT PULONG EaErrorOffset OPTIONAL,
    ULONG OptionFlags,
    PSECURITY_QUALITY_OF_SERVICE QualityOfService,
    IN OPLOCK_TYPE RequestedOplockType,
    IN PRESTART_ROUTINE RestartRoutine
    );

VOID
SrvDosTimeToTime(
    OUT PLARGE_INTEGER Time,
    IN SMB_DATE DosDate,
    IN SMB_TIME DosTime
    );

PSHARE
SrvFindShare(
    IN PUNICODE_STRING ShareName
    );

VOID
SrvGetBaseFileName (
    IN PUNICODE_STRING InputName,
    OUT PUNICODE_STRING OutputName
    );

CLONG
SrvGetNumberOfEasInList (
    IN PVOID List
    );

USHORT
SrvGetSubdirectoryLength (
    IN PUNICODE_STRING InputName
    );

NTSTATUS
SrvMakeUnicodeString (
    IN BOOLEAN SourceIsUnicode,
    OUT PUNICODE_STRING Destination,
    IN PVOID Source,
    IN PUSHORT SourceLength OPTIONAL
    );

USHORT
SrvGetString (
    OUT PUNICODE_STRING Destination,
    IN PVOID Source,
    IN PVOID EndOfSourceBuffer,
    IN BOOLEAN SourceIsUnicode
    );

USHORT
SrvGetStringLength (
    IN PVOID Source,
    IN PVOID EndOfSourceBuffer,
    IN BOOLEAN SourceIsUnicode,
    IN BOOLEAN IncludeNullTerminator
    );

NTSTATUS
SrvMoveFile(
    IN PWORK_CONTEXT WorkContext,
    IN PSHARE TargetShare,
    IN USHORT SmbOpenFunction,
    IN PUSHORT SmbFlags,
    IN USHORT SmbSearchAttributes,
    IN BOOLEAN FailIfTargetIsDirectory,
    IN USHORT InformationLevel,
    IN ULONG ClusterCount,
    IN PUNICODE_STRING Source,
    IN OUT PUNICODE_STRING Target
    );

VOID
SrvNtAttributesToSmb(
    IN ULONG NtAttributes,
    IN BOOLEAN Directory OPTIONAL,
    OUT PUSHORT SmbAttributes
    );

NTSTATUS
SrvQueryDirectoryFile (
    IN PWORK_CONTEXT WorkContext,
    IN BOOLEAN IsFirstCall,
    IN BOOLEAN FilterLongNames,
    IN BOOLEAN FindWithBackupIntent,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN ULONG SearchStorageType,
    IN PUNICODE_STRING FilePathName,
    IN PULONG ResumeFileIndex OPTIONAL,
    IN USHORT SmbSearchAttributes,
    IN PSRV_DIRECTORY_INFORMATION DirectoryInformation,
    IN CLONG BufferLength
    );

NTSTATUS
SrvDownlevelTWarpQueryDirectoryFile (
    IN PWORK_CONTEXT WorkContext,
    IN BOOLEAN IsFirstCall,
    IN BOOLEAN FilterLongNames,
    IN BOOLEAN FindWithBackupIntent,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN ULONG SearchStorageType,
    IN PUNICODE_STRING FilePathName,
    IN PULONG ResumeFileIndex OPTIONAL,
    IN USHORT SmbSearchAttributes,
    IN PSRV_DIRECTORY_INFORMATION DirectoryInformation,
    IN CLONG BufferLength
    );

NTSTATUS
SrvQueryEaFile (
    IN BOOLEAN IsFirstCall,
    IN HANDLE FileHandle,
    IN PFILE_GET_EA_INFORMATION EaList OPTIONAL,
    IN ULONG EaListLength,
    IN PSRV_EA_INFORMATION EaInformation,
    IN CLONG BufferLength,
    OUT PULONG EaErrorOffset
    );

NTSTATUS
SrvQueryInformationFile (
    IN HANDLE FileHandle,
    PFILE_OBJECT FileObject,
    OUT PSRV_FILE_INFORMATION SrvFileInformation,
    IN SHARE_TYPE ShareType,
    IN BOOLEAN QueryEaSize
    );

NTSTATUS
SrvQueryInformationFileAbbreviated (
    IN HANDLE FileHandle,
    PFILE_OBJECT FileObject,
    OUT PSRV_FILE_INFORMATION_ABBREVIATED SrvFileInformation,
    IN BOOLEAN AdditionalInformation,
    IN SHARE_TYPE ShareType
    );

NTSTATUS
SrvQueryNtInformationFile (
    IN HANDLE FileHandle,
    PFILE_OBJECT FileObject,
    IN SHARE_TYPE ShareType,
    IN BOOLEAN AdditionalInformation,
    OUT PSRV_NT_FILE_INFORMATION SrvFileInformation
    );

NTSTATUS
SrvQueryBasicAndStandardInformation(
    HANDLE FileHandle,
    PFILE_OBJECT FileObject,
    PFILE_BASIC_INFORMATION FileBasicInfo,
    PFILE_STANDARD_INFORMATION FileStandardInfo OPTIONAL
    );

NTSTATUS
SrvQueryNetworkOpenInformation(
    IN HANDLE FileHandle,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN OUT PSRV_NETWORK_OPEN_INFORMATION SrvNetworkOpenInformation,
    IN BOOLEAN QueryEaSize
    );

VOID
SrvReleaseContext (
    IN PWORK_CONTEXT WorkContext
    );

BOOLEAN
SrvSetFileWritethroughMode (
    IN PLFCB Lfcb,
    IN BOOLEAN Writethrough
    );

#define SrvSetSmbError( _wc, _status )  { \
    _SrvSetSmbError2( (_wc), (_status), FALSE, __LINE__, __FILE__ );                        \
    }

#define SrvSetSmbError2( _wc, _status, HeaderOnly )  {                  \
    _SrvSetSmbError2( (_wc), (_status), HeaderOnly, __LINE__, __FILE__ );                   \
    }

VOID
_SrvSetSmbError2 (
    IN PWORK_CONTEXT WorkContext,
    IN NTSTATUS Status,
    IN BOOLEAN HeaderOnly,
    IN ULONG LineNumber,
    IN PCHAR FileName
    );

VOID
SrvSetBufferOverflowError (
    IN PWORK_CONTEXT WorkContext
    );

VOID
SrvSmbAttributesToNt (
    IN USHORT SmbAttributes,
    OUT PBOOLEAN Directory,
    OUT PULONG NtAttributes
    );

VOID
SrvTimeToDosTime (
    IN PLARGE_INTEGER Time,
    OUT PSMB_DATE DosDate,
    OUT PSMB_TIME DosTime
    );

USHORT
SrvGetOs2TimeZone(
    IN PLARGE_INTEGER SystemTime
    );

#define SrvVerifyFid(_wc,_fid,_fail,_ser,_status)                 \
    ((_wc)->Rfcb != NULL ?                                                  \
        (_wc)->Rfcb : SrvVerifyFid2(_wc,_fid,_fail,_ser,_status))

PRFCB
SrvVerifyFid2 (
    IN PWORK_CONTEXT WorkContext,
    IN USHORT Fid,
    IN BOOLEAN FailOnSavedError,
    IN PRESTART_ROUTINE SerializeWithRawRestartRoutine OPTIONAL,
    OUT PNTSTATUS NtStatus
    );

#define SRV_INVALID_RFCB_POINTER    ((PRFCB)-1)

PRFCB
SrvVerifyFidForRawWrite (
    IN PWORK_CONTEXT WorkContext,
    IN USHORT Fid,
    OUT PNTSTATUS NtStatus
    );

PSEARCH
SrvVerifySid (
    IN PWORK_CONTEXT WorkContext,
    IN USHORT Index,
    IN USHORT Sequence,
    IN PSRV_DIRECTORY_INFORMATION DirectoryInformation,
    IN CLONG BufferSize
    );

PTREE_CONNECT
SrvVerifyTid (
    IN PWORK_CONTEXT WorkContext,
    IN USHORT Tid
    );

PSESSION
SrvVerifyUid (
    IN PWORK_CONTEXT WorkContext,
    IN USHORT Uid
    );

NTSTATUS
SrvVerifyUidAndTid (
    IN PWORK_CONTEXT WorkContext,
    OUT PSESSION *Session,
    OUT PTREE_CONNECT *TreeConnect,
    IN SHARE_TYPE ShareType
    );

NTSTATUS
SrvWildcardRename(
    IN PUNICODE_STRING FileSpec,
    IN PUNICODE_STRING SourceString,
    OUT PUNICODE_STRING TargetString
    );


//
// Security routines.
//

NTSTATUS
SrvValidateUser (
    OUT CtxtHandle *Token,
    IN PSESSION Session OPTIONAL,
    IN PCONNECTION Connection OPTIONAL,
    IN PUNICODE_STRING UserName OPTIONAL,
    IN PCHAR CaseInsensitivePassword,
    IN CLONG CaseInsensitivePasswordLength,
    IN PCHAR CaseSensitivePassword OPTIONAL,
    IN CLONG CaseSensitivePasswordLength,
    IN BOOLEAN SmbSecuritySignatureRequired,
    OUT PUSHORT Action OPTIONAL
    );

NTSTATUS
SrvValidateSecurityBuffer(
    IN PCONNECTION Connection,
    IN OUT PCtxtHandle Handle,
    IN PSESSION Session,
    IN PCHAR Buffer,
    IN ULONG BufferLength,
    IN BOOLEAN SecuritySignaturesRequired,
    OUT PCHAR ReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PLARGE_INTEGER Expiry,
    OUT PCHAR NtUserSessionKey,
    OUT PLUID LogonId,
    OUT PBOOLEAN IsGuest
    );

NTSTATUS
SrvGetExtensibleSecurityNegotiateBuffer(
    OUT PCtxtHandle Token,
    OUT PCHAR Buffer,
    IN OUT ULONG *BufferLength
    );

NTSTATUS
SrvFreeSecurityContexts (
    IN PSESSION Session
    );

NTSTATUS
AcquireLMCredentials (
    VOID
    );

NTSTATUS
SrvGetUserAndDomainName (
    IN PSESSION Session,
    OUT PUNICODE_STRING UserName OPTIONAL,
    OUT PUNICODE_STRING DomainName OPTIONAL
    );

VOID
SrvReleaseUserAndDomainName (
    IN PSESSION Session,
    IN OUT PUNICODE_STRING UserName OPTIONAL,
    IN OUT PUNICODE_STRING DomainName OPTIONAL
    );

VOID
SrvAddSecurityCredentials(
    IN PANSI_STRING ComputerName,
    IN PUNICODE_STRING DomainName,
    IN DWORD PasswordLength,
    IN PBYTE Password
);

BOOLEAN
SrvIsAdmin(
    CtxtHandle  Handle
    );

BOOLEAN
SrvIsNullSession(
    CtxtHandle  Handle
    );

NTSTATUS
SrvIsAllowedOnAdminShare(
    IN PWORK_CONTEXT WorkContext,
    IN PSHARE Share
    );

NTSTATUS
SrvCheckShareFileAccess(
    IN PWORK_CONTEXT WorkContext,
    IN ACCESS_MASK FileDesiredAccess,
    IN OUT PULONG ShareMode
    );

NTSTATUS
SrvRetrieveMaximalAccessRightsForUser(
    CtxtHandle              *pUserHandle,
    PSECURITY_DESCRIPTOR    pSecurityDescriptor,
    PGENERIC_MAPPING        pMapping,
    PACCESS_MASK            pMaximalAccessRights);

NTSTATUS
SrvRetrieveMaximalAccessRights(
    IN  OUT PWORK_CONTEXT WorkContext,
    OUT     PACCESS_MASK  pMaximalAccessRights,
    OUT     PACCESS_MASK  pGuestMaximalAccessRights);

NTSTATUS
SrvRetrieveMaximalShareAccessRights(
    IN PWORK_CONTEXT WorkContext,
    OUT PACCESS_MASK pMaximalAccessRights,
    OUT PACCESS_MASK pGuestMaximalAccessRights);

NTSTATUS
SrvUpdateMaximalAccessRightsInResponse(
    IN OUT PWORK_CONTEXT WorkContext,
    OUT PSMB_ULONG pMaximalAccessRightsInResponse,
    OUT PSMB_ULONG pGuestMaximalAccessRightsInResponse
    );

NTSTATUS
SrvUpdateMaximalShareAccessRightsInResponse(
    IN OUT PWORK_CONTEXT WorkContext,
    OUT PSMB_ULONG pMaximalAccessRightsInResponse,
    OUT PSMB_ULONG pGuestMaximalAccessRightsInResponse
    );

//
// Share handling routines.
//

PSHARE
SrvVerifyShare (
    IN PWORK_CONTEXT WorkContext,
    IN PSZ ShareName,
    IN PSZ ShareTypeString,
    IN BOOLEAN ShareNameIsUnicode,
    IN BOOLEAN IsNullSession,
    OUT PNTSTATUS Status,
    OUT PUNICODE_STRING ServerName
    );

VOID
SrvRemoveShare(
    PSHARE Share
);

VOID
SrvAddShare(
    PSHARE Share
);

NTSTATUS
SrvShareEnumApiHandler (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID OutputBuffer,
    IN ULONG BufferLength,
    IN PENUM_FILTER_ROUTINE FilterRoutine,
    IN PENUM_SIZE_ROUTINE SizeRoutine,
    IN PENUM_FILL_ROUTINE FillRoutine
    );

NTSTATUS
SrvClearDfsOnShares();

SMB_PROCESSOR_RETURN_TYPE
SrvConsumeSmbData(
    IN OUT PWORK_CONTEXT WorkContext
);

BOOLEAN
SrvIsDottedQuadAddress(
    IN PUNICODE_STRING ServerName
);

BOOLEAN
SrvIsLocalHost(
    IN PUNICODE_STRING ServerName
);

//
// Fat name routines.
//

VOID
Srv8dot3ToUnicodeString (
    IN PSZ Input8dot3,
    OUT PUNICODE_STRING OutputString
    );

BOOLEAN SRVFASTCALL
SrvIsLegalFatName (
    IN PWSTR InputName,
    IN CLONG InputNameLength
    );

VOID
SrvOemStringTo8dot3 (
    IN POEM_STRING InputString,
    OUT PSZ Output8dot3
    );

VOID
SrvUnicodeStringTo8dot3 (
    IN PUNICODE_STRING InputString,
    OUT PSZ Output8dot3,
    IN BOOLEAN Upcase
    );

//
// EA conversion support routines.
//

BOOLEAN
SrvAreEasNeeded (
    IN PFILE_FULL_EA_INFORMATION NtFullEa
    );

USHORT
SrvGetOs2FeaOffsetOfError (
    IN ULONG NtErrorOffset,
    IN PFILE_FULL_EA_INFORMATION NtFullEa,
    IN PFEALIST FeaList
    );

USHORT
SrvGetOs2GeaOffsetOfError (
    IN ULONG NtErrorOffset,
    IN PFILE_GET_EA_INFORMATION NtGetEa,
    IN PGEALIST GeaList
    );

NTSTATUS
SrvOs2FeaListToNt (
    IN PFEALIST FeaList,
    OUT PFILE_FULL_EA_INFORMATION *NtFullEa,
    OUT PULONG BufferLength,
    OUT PUSHORT EaErrorOffset
    );

ULONG
SrvOs2FeaListSizeToNt (
    IN PFEALIST FeaList
    );

PVOID
SrvOs2FeaToNt (
    OUT PFILE_FULL_EA_INFORMATION NtFullEa,
    IN PFEA Fea
    );

NTSTATUS
SrvOs2GeaListToNt (
    IN PGEALIST GeaList,
    OUT PFILE_GET_EA_INFORMATION *NtGetEa,
    OUT PULONG BufferLength,
    OUT PUSHORT EaErrorOffset
    );

ULONG
SrvOs2GeaListSizeToNt (
    IN PGEALIST GeaList
    );

PVOID
SrvOs2GeaToNt (
    OUT PFILE_GET_EA_INFORMATION NtGetEa,
    IN PGEA Gea
    );

PVOID
SrvNtFullEaToOs2 (
    OUT PFEA Fea,
    IN PFILE_FULL_EA_INFORMATION NtFullEa
    );

PVOID
SrvNtGetEaToOs2 (
    OUT PGEA Gea,
    IN PFILE_GET_EA_INFORMATION NtGetEa
    );

CLONG
SrvNumberOfEasInList (
    IN PVOID List
    );

NTSTATUS
SrvQueryOs2FeaList (
    IN HANDLE FileHandle,
    IN PGEALIST GeaList OPTIONAL,
    IN PFILE_GET_EA_INFORMATION NtGetEaList OPTIONAL,
    IN ULONG GeaListLength OPTIONAL,
    IN PFEALIST FeaList,
    IN ULONG BufferLength,
    OUT PUSHORT EaErrorOffset
    );

NTSTATUS
SrvSetOs2FeaList (
    IN HANDLE FileHandle,
    IN PFEALIST FeaList,
    IN ULONG BufferLength,
    OUT PUSHORT EaErrorOffset
    );

NTSTATUS
SrvConstructNullOs2FeaList (
    IN PFILE_GET_EA_INFORMATION NtGeaList,
    OUT PFEALIST FeaList,
    IN ULONG BufferLength
    );

//
// Named pipe worker functions.
//

SMB_TRANS_STATUS
SrvCallNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvWaitNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvQueryStateNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvQueryInformationNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvSetStateNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvPeekNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvTransactNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    );

BOOLEAN
SrvFastTransactNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext,
    OUT SMB_STATUS *SmbStatus
    );

SMB_TRANS_STATUS
SrvRawWriteNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvWriteNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    );

SMB_TRANS_STATUS
SrvReadNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    );

//
// Transaction worker functions.
//

VOID
SrvCompleteExecuteTransaction (
    IN OUT PWORK_CONTEXT WorkContext,
    IN SMB_TRANS_STATUS ResultStatus
    );

VOID SRVFASTCALL
SrvRestartExecuteTransaction (
    IN OUT PWORK_CONTEXT WorkContext
    );

//
// XACTSRV support routines.
//

PVOID
SrvXsAllocateHeap(
    IN ULONG SizeOfAllocation OPTIONAL,
    OUT PNTSTATUS Status
    );

NTSTATUS
SrvXsConnect (
    IN PUNICODE_STRING PortName
    );

VOID
SrvXsFreeHeap(
    IN PVOID MemoryToFree OPTIONAL
    );

SMB_TRANS_STATUS
SrvXsRequest (
    IN OUT PWORK_CONTEXT WorkContext
    );

NTSTATUS
SrvXsLSOperation (
    IN PSESSION Session,
    IN ULONG Type
    );

VOID
SrvXsPnpOperation(
    IN PUNICODE_STRING DeviceName,
    IN BOOLEAN Bind
    );

VOID
SrvXsDisconnect();

//
// Oplock support routines.
//

VOID SRVFASTCALL
SrvOplockBreakNotification (
    IN PWORK_CONTEXT WorkContext            // actually, a PRFCB
    );

VOID
SrvFillOplockBreakRequest (
    IN PWORK_CONTEXT WorkContext,
    IN PRFCB Rfcb
    );

VOID SRVFASTCALL
SrvRestartOplockBreakSend(
    IN PWORK_CONTEXT WorkContext
    );

VOID
SrvAcknowledgeOplockBreak (
    IN PRFCB Rfcb,
    IN UCHAR NewOplockLevel
    );

BOOLEAN
SrvRequestOplock (
    IN PWORK_CONTEXT WorkContext,
    IN POPLOCK_TYPE OplockType,
    IN BOOLEAN RequestIIOnFailure
    );

LARGE_INTEGER
SrvGetOplockBreakTimeout (
    IN PWORK_CONTEXT WorkContext
    );

VOID
SrvSendOplockRequest(
    IN PCONNECTION Connection,
    IN PRFCB Rfcb,
    IN KIRQL OldIrql
    );

VOID SRVFASTCALL
SrvCheckDeferredOpenOplockBreak(
    IN PWORK_CONTEXT WorkContext
    );

//
// Buffer management support
//

BOOLEAN
SrvReceiveBufferShortage(
    VOID
    );

NTSTATUS
SrvIoCreateFile (
    IN PWORK_CONTEXT WorkContext,
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG Disposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength,
    IN CREATE_FILE_TYPE CreateFileType,
    IN PVOID ExtraCreateParameters OPTIONAL,
    IN ULONG Options,
    IN PSHARE Share OPTIONAL
    );

NTSTATUS
SrvNtClose (
    IN HANDLE Handle,
    IN BOOLEAN QuotaCharged
    );

NTSTATUS
SrvVerifyDeviceStackSize(
    IN HANDLE FileHandle,
    IN BOOLEAN ReferenceFileObject,
    OUT PFILE_OBJECT *FileObject,
    OUT PDEVICE_OBJECT *DeviceObject,
    OUT POBJECT_HANDLE_INFORMATION HandleInformation OPTIONAL
    );

VOID
SrvCheckForBadSlm (
    IN PRFCB Rfcb,
    IN ULONG StartOffset,
    IN PCONNECTION Connection,
    IN PVOID Buffer,
    IN ULONG BufferLength
    );

//
// Routines used to go to XACTSRV through LPC to issue user-mode APIs.
//

NTSTATUS
SrvOpenPrinter (
    IN PWCH PrinterName,
    OUT PHANDLE phPrinter,
    OUT PULONG Error
    );

NTSTATUS
SrvAddPrintJob (
    IN PWORK_CONTEXT WorkContext,
    IN HANDLE Handle,
    OUT PUNICODE_STRING FileName,
    OUT PULONG JobId,
    OUT PULONG Error
    );

NTSTATUS
SrvSchedulePrintJob (
    IN HANDLE PrinterHandle,
    IN ULONG JobId
    );

NTSTATUS
SrvClosePrinter (
    OUT HANDLE Handle
    );

//
// Routines for handling impersonation of remote clients.
//

NTSTATUS
SrvImpersonate (
    IN PWORK_CONTEXT WorkContext
    );

VOID
SrvRevert (
    VOID
    );

//
// Routine for setting the last write time on a file given the last
// write time in seconds since 1970.
//
NTSTATUS
SrvSetLastWriteTime (
    IN PRFCB Rfcb,
    IN ULONG LastWriteTimeInSeconds,
    IN ACCESS_MASK GrantedAccess
    );

ULONG
SrvLengthOfStringInApiBuffer (
    IN PUNICODE_STRING UnicodeString
    );

//
// Routine for updating quality of service information for a vc
//

VOID
SrvUpdateVcQualityOfService(
    IN PCONNECTION Connection,
    IN PLARGE_INTEGER CurrentTime OPTIONAL
    );

//
// Routines for obtaining and releasing share root directory handles
// for removable devices
//


VOID
SrvFillInFileSystemName(
            IN PSHARE Share,
            IN PWSTR FileSystemName,
            IN ULONG FileSystemNameLength
            );

NTSTATUS
SrvGetShareRootHandle(
    IN PSHARE Share
    );

BOOLEAN
SrvRefreshShareRootHandle (
    IN PSHARE Share,
    OUT PNTSTATUS Status
    );

VOID
SrvReleaseShareRootHandle(
    IN PSHARE Share
    );

//
// SMB validation routine.
//

BOOLEAN SRVFASTCALL
SrvValidateSmb (
    IN PWORK_CONTEXT WorkContext
    );

//
// Check on saved error.
//

NTSTATUS
SrvCheckForSavedError(
    IN PWORK_CONTEXT WorkContext,
    IN PRFCB Rfcb
    );

//
// Read registry parameters.
//

VOID
SrvGetMultiSZList(
    PWSTR **ListPointer,
    PWSTR BaseKeyName,
    PWSTR ParameterKeyName,
    PWSTR *DefaultPointerValue
    );

NTSTATUS
SrvGetDWord(
    PWSTR BaseKeyName,
    PWSTR ParameterKeyName,
    LPDWORD Value
    );

//
// Read server display name from the registry.
//

VOID
SrvGetAlertServiceName(
    VOID
    );

//
// Read OS version string from registry.
//

VOID
SrvGetOsVersionString(
    VOID
    );

//
// Queues up blocks for later cleanup
//

VOID
DispatchToOrphanage(
    IN PQUEUEABLE_BLOCK_HEADER Block
    );

//
// Process handle duplication for Sqooter
//
NTSTATUS
SrvProcessHandleDuplicateRequest(
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PSRV_REQUEST_HANDLE_DUP pDupRequest,
    IN OUT PSRV_RESPONSE_HANDLE_DUP pOutHandleDup
    );

#endif // def _SRVSUPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\svcconn.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    svcconn.c

Abstract:

    This module contains routines for supporting the connection APIs in
    the server service, SrvNetConnectionEnum.

Author:

    David Treadwell (davidtr) 23-Feb-1991

Revision History:

--*/

#include "precomp.h"
#include "svcconn.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_SVCCONN

//
// Forward declarations.
//

VOID
FillConnectionInfoBuffer (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block,
    IN OUT PVOID *FixedStructurePointer,
    IN OUT LPWSTR *EndOfVariableData
    );

BOOLEAN
FilterConnections (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    );

ULONG
SizeConnections (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvNetConnectionEnum )
#pragma alloc_text( PAGE, FillConnectionInfoBuffer )
#pragma alloc_text( PAGE, FilterConnections )
#pragma alloc_text( PAGE, SizeConnections )
#endif

//
// Macros to determine the size a share would take up at one of the
// levels of share information.
//

#define TOTAL_SIZE_OF_CONNECTION(treeConnect,level,user,netname)         \
    ( (level) == 0 ? sizeof(CONNECTION_INFO_0) :                         \
                     sizeof(CONNECTION_INFO_1) +                         \
                         SrvLengthOfStringInApiBuffer((user)) +         \
                         SrvLengthOfStringInApiBuffer((netname)) )

#define FIXED_SIZE_OF_CONNECTION(level)                  \
    ( (level) == 0 ? sizeof(CONNECTION_INFO_0) :         \
                     sizeof(CONNECTION_INFO_1) )


NTSTATUS
SrvNetConnectionEnum (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine processes the NetConnectionEnum API in the server FSD.

Arguments:

    Srp - a pointer to the server request packet that contains all
        the information necessary to satisfy the request.  This includes:

      INPUT:

        Name1 - qualifier for determining the basis for the search.  It
            is either a computer name, in which case information about
            tree connects from the specified client is returned, or
            a share name, in which case information about tree connects
            to the specified share is returned.

        Level - level of information to return, 0 or 1.

      OUTPUT:

        Parameters.Get.EntriesRead - the number of entries that fit in
            the output buffer.

        Parameters.Get.TotalEntries - the total number of entries that
            would be returned with a large enough buffer.

        Parameters.Get.TotalBytesNeeded - the buffer size that would be
            required to hold all the entries.

    Buffer - a pointer to the buffer for results.

    BufferLength - the length of this buffer.

Return Value:

    NTSTATUS - result of operation to return to the server service.

--*/

{
    PAGED_CODE( );

    return SrvEnumApiHandler(
               Srp,
               Buffer,
               BufferLength,
               &SrvTreeConnectList,
               FilterConnections,
               SizeConnections,
               FillConnectionInfoBuffer
               );

} // SrvNetConnectionEnum


STATIC
VOID
FillConnectionInfoBuffer (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block,
    IN OUT PVOID *FixedStructure,
    IN LPWSTR *EndOfVariableData
    )

/*++

Routine Description:

    This routine puts a single fixed session structure and, if it fits,
    associated variable data, into a buffer.  Fixed data goes at the
    beginning of the buffer, variable data at the end.

    *** This routine must be called with Connection->Lock held!

Arguments:

    Level - the level of information to copy from the connection.

    Connection - the tree connect from which to get information.

    FixedStructure - where the ine buffer to place the fixed structure.
        This pointer is updated to point to the next available
        position for a fixed structure.

    EndOfVariableData - the last position on the buffer that variable
        data for this structure can occupy.  The actual variable data
        is written before this position as long as it won't overwrite
        fixed structures.  It is would overwrite fixed structures, it
        is not written.

Return Value:

    None.

--*/

{
    PTREE_CONNECT treeConnect = Block;
    PSESSION session;
    PCONNECTION_INFO_1 coni1;

    LARGE_INTEGER currentTime;
    ULONG currentSecondsSince1980;
    ULONG startTimeInSecondsSince1980;
    ULONG secondsAlive;

    PAGED_CODE();

    //
    // Get the current time and use this to determine how long the
    // tree connection has been alive.
    //

    KeQuerySystemTime( &currentTime );

    RtlTimeToSecondsSince1980(
        &currentTime,
        &currentSecondsSince1980
        );

    RtlTimeToSecondsSince1980(
        &treeConnect->StartTime,
        &startTimeInSecondsSince1980
        );

    secondsAlive = currentSecondsSince1980 - startTimeInSecondsSince1980;

    //
    // Set up the fixed structure pointer and find out where the fixed
    // structure ends.
    //

    coni1 = *FixedStructure;

    *FixedStructure = (PCHAR)*FixedStructure +
                          FIXED_SIZE_OF_CONNECTION( Srp->Level );
    ASSERT( (ULONG_PTR)*EndOfVariableData >= (ULONG_PTR)*FixedStructure );

    //
    // Case on the level to fill in the fixed structure appropriately.
    // We fill in actual pointers in the output structure.  This is
    // possible because we are in the server FSD, hence the server
    // service's process and address space.
    //
    // *** This routine assumes that the fixed structure will fit in the
    //     buffer!
    //
    // *** Using the switch statement in this fashion relies on the fact
    //     that the first fields on the different session structures are
    //     identical.
    //

    switch( Srp->Level ) {

    case 1:

        //
        // Convert the server's internal representation of share types
        // to the expected format.
        //

        switch ( treeConnect->Share->ShareType ) {

        case ShareTypeDisk:

            coni1->coni1_type = STYPE_DISKTREE;
            break;

        case ShareTypePrint:

            coni1->coni1_type = STYPE_PRINTQ;
            break;

#if SRV_COMM_DEVICES
        case ShareTypeComm:

            coni1->coni1_type = STYPE_DEVICE;
            break;
#endif
        case ShareTypePipe:

            coni1->coni1_type = STYPE_IPC;
            break;

        default:

            //
            // This should never happen.  It means that somebody
            // stomped on the share block.
            //

            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "FillConnectionInfoBuffer: invalid share type in share: %ld",
                treeConnect->Share->ShareType,
                NULL
                );

            SrvLogInvalidSmb( NULL );
            return;
        }

        //
        // Set up the count of opens done on this tree connect.  Do not include
        //  cached opens, as they are transparent to users and administrators
        //

        coni1->coni1_num_opens = treeConnect->CurrentFileOpenCount;

        if( coni1->coni1_num_opens > 0 ) {

            ULONG count = SrvCountCachedRfcbsForTid(
                                     treeConnect->Connection,
                                     treeConnect->Tid );

            if( coni1->coni1_num_opens > count ) {
                coni1->coni1_num_opens -= count;
            } else {
                coni1->coni1_num_opens = 0;
            }

        }

        //
        // There is always exactly one user on a tree connect.
        //
        // !!! Is this correct???

        coni1->coni1_num_users = 1;

        //
        // Set up the alive time.
        //

        coni1->coni1_time = secondsAlive;

        //
        // Attempt to find a reasonable user name.  Since the SMB
        // protocol does not link tree connects with users, only with
        // sessions, it may not be possible to return a user name.
        //

        ACQUIRE_LOCK( &treeConnect->Connection->Lock );

        session = treeConnect->Session;

        if ( session != NULL ) {
            UNICODE_STRING userName;

            SrvGetUserAndDomainName( session, &userName, NULL );

            SrvCopyUnicodeStringToBuffer(
                &userName,
                *FixedStructure,
                EndOfVariableData,
                &coni1->coni1_username
                );

            if( userName.Buffer ) {
                SrvReleaseUserAndDomainName( session, &userName, NULL );
            }

        } else {

            coni1->coni1_username = NULL;
        }

        RELEASE_LOCK( &treeConnect->Connection->Lock );

        //
        // Set up the net name.  If the qualifier passed in the
        // SRP is a computer name, then the net name is the share
        // name.  If the qualifier is a share name, the net name
        // is a computer name.
        //

        if ( Srp->Name1.Length > 2 && *Srp->Name1.Buffer == '\\' &&
                 *(Srp->Name1.Buffer+1) == '\\' ) {

            SrvCopyUnicodeStringToBuffer(
                &treeConnect->Share->ShareName,
                *FixedStructure,
                EndOfVariableData,
                &coni1->coni1_netname
                );

        } else {

            UNICODE_STRING clientName;
            PUNICODE_STRING clientMachineName;

            clientMachineName =
                &treeConnect->Connection->ClientMachineNameString;

            //
            // Make a string that does not contain the leading
            // backslashes.
            //

            clientName.Buffer = clientMachineName->Buffer + 2;
            clientName.Length =
                (USHORT) (clientMachineName->Length - 2 * sizeof(WCHAR));
            clientName.MaximumLength = clientName.Length;

            SrvCopyUnicodeStringToBuffer(
                &clientName,
                *FixedStructure,
                EndOfVariableData,
                &coni1->coni1_netname
                );
        }

        // *** Lack of break is intentional!

    case 0:

        //
        // Set up the tree connect ID.
        //

        coni1->coni1_id = SrvGetResumeHandle( &SrvTreeConnectList, treeConnect );

        break;

    default:

        //
        // This should never happen.  The server service should have
        // checked for an invalid level.
        //

        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "FillConnectionInfoBuffer: invalid level number: %ld",
            Srp->Level,
            NULL
            );

        SrvLogInvalidSmb( NULL );
    }

    return;

} // FillConnectionInfoBuffer


BOOLEAN
FilterConnections (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    )

/*++

Routine Description:

    This routine is intended to be called by SrvEnumApiHandler to check
    whether a particular tree connect should be returned.

Arguments:

    Srp - a pointer to the SRP for the operation.  Name1 ("qualifier"
        on NetConnectionEnum) is used to do the filtering.

    Block - a pointer to the tree connect to check.

Return Value:

    TRUE if the block should be placed in the output buffer, FALSE
        if it should be passed over.

--*/

{
    PTREE_CONNECT treeConnect = Block;
    PUNICODE_STRING compareName;

    PAGED_CODE( );

    //
    // We're going to compare the Name1 field against the share name
    // if a computer name is the qualifier or against the computer
    // name if the share name was the qualifier.
    //

    if ( Srp->Name1.Length > 2*sizeof(WCHAR) && *Srp->Name1.Buffer == '\\' &&
             *(Srp->Name1.Buffer+1) == '\\' ) {
        compareName =
            &treeConnect->Connection->ClientMachineNameString;
    } else {
        compareName = &treeConnect->Share->ShareName;
    }

    return RtlEqualUnicodeString(
               &Srp->Name1,
               compareName,
               TRUE
               );

} // FilterConnections


ULONG
SizeConnections (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    )

/*++

Routine Description:

    This routine returns the size the passed-in tree connect would take
    up in an API output buffer.

Arguments:

    Srp - a pointer to the SRP for the operation.  The level and Name1
        ("qualifier" on NetConnectionEnum) are used.

    Block - a pointer to the tree connect to size.

Return Value:

    ULONG - The number of bytes the tree connect would take up in the
        output buffer.

--*/

{
    PTREE_CONNECT treeConnect = Block;
    PUNICODE_STRING netName;
    UNICODE_STRING userName;
    PSESSION session;
    ULONG size;

    PAGED_CODE( );

    if ( Srp->Name1.Length > 2 && *Srp->Name1.Buffer == '\\' &&
             *(Srp->Name1.Buffer+1) == '\\' ) {
        netName = &treeConnect->Share->ShareName;
    } else {
        netName =
            &treeConnect->Connection->ClientMachineNameString;
    }

    //
    // Attempt to find a reasonable user name.  Since the SMB protocol
    // does not link tree connects with users, only with sessions, it
    // may not be possible to return a user name.
    //

    ACQUIRE_LOCK( &treeConnect->Connection->Lock );

    session = treeConnect->Session;

    if ( (session != NULL) && (GET_BLOCK_STATE(session) == BlockStateActive) ) {
        SrvGetUserAndDomainName( session, &userName, NULL );
    } else {
        userName.Buffer = NULL;
    }

    size = TOTAL_SIZE_OF_CONNECTION( treeConnect,
                                     Srp->Level,
                                     userName.Buffer ? &userName : NULL,
                                     netName
                                   );

    if( userName.Buffer ) {
        SrvReleaseUserAndDomainName( session, &userName, NULL );
    }

    RELEASE_LOCK( &treeConnect->Connection->Lock );

    return size;

} // SizeConnections
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\svcsrv.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    svcsrv.c

Abstract:

    This module contains routines for supporting the server APIs in the
    server service, SrvNetServerDiskEnum, and SrvNetServerSetInfo.

Author:

    David Treadwell (davidtr) 31-Jan-1991

Revision History:

--*/

#include "precomp.h"
#include "svcsrv.tmh"
#pragma hdrstop

//
// Forward declarations.
//

LARGE_INTEGER
SecondsToTime (
    IN ULONG Seconds,
    IN BOOLEAN MakeNegative
    );

LARGE_INTEGER
MinutesToTime (
    IN ULONG Seconds,
    IN BOOLEAN MakeNegative
    );

ULONG
MultipleOfProcessors (
    IN ULONG value
    );

BOOL
IsSuiteVersion(
    IN USHORT Version
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvNetServerDiskEnum )
#pragma alloc_text( PAGE, SrvNetServerSetInfo )
#pragma alloc_text( PAGE, SecondsToTime )
#pragma alloc_text( PAGE, MinutesToTime )
#pragma alloc_text( PAGE, MultipleOfProcessors )
#pragma alloc_text( PAGE, IsSuiteVersion )
#endif

#define IsWebBlade() IsSuiteVersion(VER_SUITE_BLADE)
#define IsPersonal() IsSuiteVersion(VER_SUITE_PERSONAL)
#define IsEmbedded() IsSuiteVersion(VER_SUITE_EMBEDDEDNT)

BOOL
IsSuiteVersion(USHORT Version)
{
    OSVERSIONINFOEX Osvi;
    DWORD TypeMask;
    DWORDLONG ConditionMask;

    memset(&Osvi, 0, sizeof(OSVERSIONINFOEX));
    Osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    Osvi.wSuiteMask = Version;
    TypeMask = VER_SUITENAME;
    ConditionMask = 0;
    VER_SET_CONDITION(ConditionMask, VER_SUITENAME, VER_OR);
    return(NT_SUCCESS(RtlVerifyVersionInfo(&Osvi, TypeMask, ConditionMask)));
}




NTSTATUS
SrvNetServerDiskEnum (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    )
{
    PAGED_CODE( );

    Srp, Buffer, BufferLength;
    return STATUS_NOT_IMPLEMENTED;

} // SrvNetServerDiskEnum


NTSTATUS
SrvNetServerSetInfo (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine processes the NetServerSetInfo API in the server FSD.

Arguments:

    Srp - a pointer to the server request packet that contains all
        the information necessary to satisfy the request.  This includes:

      INPUT:

        None.

      OUTPUT:

        None.

    Buffer - a pointer to a SERVER_INFO_102, followed immediately by a
        SERVER_INFO_599 structure, followed by a SERVER_INFO_559a
        structure.  All information is always reset in this routine; the
        server service also tracks this data, so when it gets a
        NetServerSetInfo it overwrites the appropriate fields and sends
        all the data.

    BufferLength - total length of this buffer.

Return Value:

    NTSTATUS - result of operation to return to the server service.

--*/

{
    NTSTATUS status = STATUS_INVALID_PARAMETER;
    PSERVER_INFO_102 sv102;
    PSERVER_INFO_599 sv599;
    PSERVER_INFO_598 sv598;

    LARGE_INTEGER scavengerTimeout;
    LARGE_INTEGER alerterTimeout;

    ULONG ipxdisc;
    LARGE_INTEGER li;
    ULONG bufferOffset;
    ULONG keTimeIncrement;

    PAGED_CODE( );

    //
    // Make sure that the input buffer length is correct.
    //
    if ( BufferLength < sizeof(SERVER_INFO_102) +
                        sizeof(SERVER_INFO_599) + sizeof(SERVER_INFO_598) ) {
        return status;
    }

    //
    // Set up buffer pointers as appropriate.  The SERVER_INFO_599
    // structure must immediately follow the SERVER_INFO_102 structure
    // in the buffer.
    //

    sv102 = Buffer;
    sv599 = (PSERVER_INFO_599)(sv102 + 1);
    sv598 = (PSERVER_INFO_598)(sv599 + 1);

    if( sv599->sv599_scavtimeout == 0 )
    {
        // This will cause a divide by zero later on
        return STATUS_INVALID_PARAMETER;
    }

    //
    // store the time increment count
    //

    keTimeIncrement = KeQueryTimeIncrement();

    //
    // Grab the lock that protects configuration changes.
    //

    ACQUIRE_LOCK( &SrvConfigurationLock );

    //
    // Set all configuration information in the server.
    //

    try {

        SrvMaxUsers = sv102->sv102_users;

        //
        // The autodisconnect timeout must be converted from minutes to NT
        // time, which has a base of 100s of nanoseconds.  If the specified
        // value is negative (top bit set), set the timeout to 0, indicating
        // that no autodisconnect should be done.  If the specified value is
        // 0, meaning to autodisconnect immediately, set the timeout to a
        // small value, but not 0.
        //

        if ( (sv102->sv102_disc & 0x80000000) == 0 ) {
            if ( sv102->sv102_disc != 0 ) {
                SrvAutodisconnectTimeout.QuadPart =
                    Int32x32To64( sv102->sv102_disc, 10*1000*1000*60 );
            } else {
                SrvAutodisconnectTimeout.QuadPart = 1;
            }
        } else {
            SrvAutodisconnectTimeout.QuadPart = 0;
        }

        SrvInitialSessionTableSize = (USHORT)sv599->sv599_initsesstable;
        SrvInitialTreeTableSize = (USHORT)sv599->sv599_initconntable;
        SrvInitialFileTableSize = (USHORT)sv599->sv599_initfiletable;
        SrvInitialSearchTableSize = (USHORT)sv599->sv599_initsearchtable;
        SrvMaxFileTableSize = (USHORT)sv599->sv599_sessopens;
        SrvMaxNumberVcs = sv599->sv599_sessvcs;
        SrvMaxSearchTableSize = (USHORT)sv599->sv599_opensearch;
        SrvReceiveBufferLength = sv599->sv599_sizreqbuf;
        SrvReceiveBufferSize = (SrvReceiveBufferLength + SrvCacheLineSize) & ~SrvCacheLineSize;
        SrvReceiveMdlSize = (ULONG)(MmSizeOfMdl( (PVOID)(PAGE_SIZE-1), SrvReceiveBufferSize ) + 7) & ~7;
        SrvMaxMdlSize = (ULONG)(MmSizeOfMdl( (PVOID)(PAGE_SIZE-1), MAX_PARTIAL_BUFFER_SIZE ) + 7) & ~7;
        SrvInitialReceiveWorkItemCount = sv599->sv599_initworkitems;
        SrvMaxReceiveWorkItemCount = sv599->sv599_maxworkitems;
        SrvInitialRawModeWorkItemCount = sv599->sv599_rawworkitems;
        SrvReceiveIrpStackSize = (CCHAR)sv599->sv599_irpstacksize;
        SrvReceiveIrpSize = (IoSizeOfIrp( SrvReceiveIrpStackSize ) + 7) & ~7;
        SrvMaxSessionTableSize = (USHORT)sv599->sv599_sessusers;
        SrvMaxTreeTableSize = (USHORT)sv599->sv599_sessconns;
        SrvMaxPagedPoolUsage = sv599->sv599_maxpagedmemoryusage;
        SrvMaxNonPagedPoolUsage = sv599->sv599_maxnonpagedmemoryusage;
        SrvEnableSoftCompatibility = (BOOLEAN)sv599->sv599_enablesoftcompat;
        SrvEnableForcedLogoff = (BOOLEAN)sv599->sv599_enableforcedlogoff;
        SrvCoreSearchTimeout = sv599->sv599_maxkeepsearch;
        SrvSearchMaxTimeout = SecondsToTime( SrvCoreSearchTimeout, FALSE );
        SrvScavengerTimeoutInSeconds = sv599->sv599_scavtimeout;
        scavengerTimeout = SecondsToTime( SrvScavengerTimeoutInSeconds, FALSE );
        SrvMaxMpxCount = (USHORT)sv599->sv599_maxmpxct;
        SrvWaitForOplockBreakTime = SecondsToTime( sv599->sv599_oplockbreakwait, FALSE );
        SrvWaitForOplockBreakRequestTime = SecondsToTime( sv599->sv599_oplockbreakresponsewait, FALSE );
        SrvMinReceiveQueueLength = sv599->sv599_minrcvqueue;
        SrvMinFreeWorkItemsBlockingIo = sv599->sv599_minfreeworkitems;
        SrvXsSectionSize.QuadPart = sv599->sv599_xactmemsize;
        SrvThreadPriority = (KPRIORITY)sv599->sv599_threadpriority;
        SrvEnableOplockForceClose = (BOOLEAN)sv599->sv599_enableoplockforceclose;
        SrvEnableFcbOpens = (BOOLEAN)sv599->sv599_enablefcbopens;
        SrvEnableRawMode = (BOOLEAN)sv599->sv599_enableraw;
        SrvFreeConnectionMinimum = sv599->sv599_minfreeconnections;
        SrvFreeConnectionMaximum = sv599->sv599_maxfreeconnections;

        //
        // Max work item idle time is in ticks
        //

        li =  SecondsToTime( sv599->sv599_maxworkitemidletime, FALSE );
        li.QuadPart /= keTimeIncrement;
        if ( li.HighPart != 0 ) {
            li.LowPart = 0xffffffff;
        }
        SrvWorkItemMaxIdleTime = li.LowPart;

        //
        // Oplocks should not be enabled if SrvMaxMpxCount == 1
        //

        if ( SrvMaxMpxCount > 1 ) {
            SrvEnableOplocks = (BOOLEAN)sv599->sv599_enableoplocks;
        } else {
            SrvEnableOplocks = FALSE;
        }

        SrvProductTypeServer = MmIsThisAnNtAsSystem( );

        SrvServerSize = sv598->sv598_serversize;

        SrvMaxRawModeWorkItemCount = sv598->sv598_maxrawworkitems;
        SrvMaxThreadsPerQueue = sv598->sv598_maxthreadsperqueue;
        ipxdisc = sv598->sv598_connectionlessautodisc;
        SrvConnectionNoSessionsTimeout = sv598->sv598_ConnectionNoSessionsTimeout;

        SrvRemoveDuplicateSearches =
                (BOOLEAN)sv598->sv598_removeduplicatesearches;
        SrvMaxOpenSearches = sv598->sv598_maxglobalopensearch;
        SrvSharingViolationRetryCount = sv598->sv598_sharingviolationretries;
        SrvSharingViolationDelay.QuadPart =
            Int32x32To64( sv598->sv598_sharingviolationdelay, -1*10*1000 );

        SrvLockViolationDelay = sv598->sv598_lockviolationdelay;

        SrvLockViolationOffset = sv598->sv598_lockviolationoffset;

        SrvCachedOpenLimit = sv598->sv598_cachedopenlimit;
        SrvMdlReadSwitchover = sv598->sv598_mdlreadswitchover;
        SrvEnableWfW311DirectIpx =
                    (BOOLEAN)sv598->sv598_enablewfw311directipx;
        SrvRestrictNullSessionAccess =
                    (BOOLEAN)sv598->sv598_restrictnullsessaccess;

        SrvQueueCalc = SecondsToTime( sv598->sv598_queuesamplesecs, FALSE );
        SrvPreferredAffinity = sv598->sv598_preferredaffinity;
        SrvOtherQueueAffinity = sv598->sv598_otherqueueaffinity;
        SrvBalanceCount = sv598->sv598_balancecount;

        SrvMaxFreeRfcbs = sv598->sv598_maxfreerfcbs;
        SrvMaxFreeMfcbs = sv598->sv598_maxfreemfcbs;
        SrvMaxPagedPoolChunkSize = sv598->sv598_maxpagedpoolchunksize;

        SrvMaxCachedDirectory = sv598->sv598_cacheddirectorylimit;

        SrvMaxCopyLength = sv598->sv598_maxcopylength;

        SrvMinClientBufferSize = sv598->sv598_minclientbuffersize;
        SrvMinClientBufferSize &= ~03;

        SrvSmbSecuritySignaturesEnabled  = (sv598->sv598_enablesecuritysignature != FALSE);
        SrvSmbSecuritySignaturesRequired = (sv598->sv598_requiresecuritysignature != FALSE);
        SrvEnableW9xSecuritySignatures   = (sv598->sv598_enableW9xsecuritysignature != FALSE);

        ServerGuid = sv598->sv598_serverguid;

        SrvEnforceLogoffTimes = (sv598->sv598_enforcekerberosreauthentication != FALSE);
        SrvDisableDoSChecking = (sv598->sv598_disabledos != FALSE);
        SrvDisableStrictNameChecking = (sv598->sv598_disablestrictnamechecking != FALSE);
        SrvFreeDiskSpaceCeiling = sv598->sv598_lowdiskspaceminimum;

        //
        // Make sure the settings are consistent!
        //
        if( SrvSmbSecuritySignaturesEnabled == FALSE ) {
            SrvSmbSecuritySignaturesRequired = FALSE;
        }

        SrvMaxNonPagedPoolChunkSize = SrvMaxPagedPoolChunkSize;

        SrvLockViolationDelayRelative.QuadPart =
            Int32x32To64( sv598->sv598_lockviolationdelay, -1*10*1000 );

        //
        // Convert the idle thread timeout from seconds to ticks
        //
        SrvIdleThreadTimeOut =
            Int32x32To64( sv598->sv598_IdleThreadTimeOut, -1*10*1000*1000 );

        //
        // Calculate switchover number for mpx
        //

        bufferOffset = (sizeof(SMB_HEADER) + sizeof(RESP_READ_MPX) - 1 + 3) & ~3;

        if ( SrvMdlReadSwitchover > (SrvReceiveBufferLength - bufferOffset) ) {

            SrvMpxMdlReadSwitchover = SrvReceiveBufferLength - bufferOffset;

        } else {

            SrvMpxMdlReadSwitchover = SrvMdlReadSwitchover;
        }

        //
        // The IPX autodisconnect timeout must be converted from minutes to
        // ticks.  If 0 is specified, use 15 minutes.
        //

        if ( ipxdisc == 0 ) {
            ipxdisc = 15;
        }
        li.QuadPart = Int32x32To64( ipxdisc, 10*1000*1000*60 );
        li.QuadPart /= keTimeIncrement;
        if ( li.HighPart != 0 ) {
            li.LowPart = 0xffffffff;
        }
        SrvIpxAutodisconnectTimeout = li.LowPart;

        //
        // The "idle connection without sessions" timeout must be converted from
        //  minutes to ticks.
        //
        li.QuadPart = Int32x32To64( SrvConnectionNoSessionsTimeout, 10*1000*1000*60 );
        li.QuadPart /= keTimeIncrement;
        if( li.HighPart != 0 ) {
            li.LowPart = 0xffffffff;
        }
        SrvConnectionNoSessionsTimeout = li.LowPart;

        //
        // Event logging and alerting information.
        //

        alerterTimeout = MinutesToTime( sv599->sv599_alertschedule, FALSE );
        SrvAlertMinutes = sv599->sv599_alertschedule;
        SrvErrorRecord.ErrorThreshold = sv599->sv599_errorthreshold;
        SrvNetworkErrorRecord.ErrorThreshold =
                            sv599->sv599_networkerrorthreshold;
        SrvFreeDiskSpaceThreshold = sv599->sv599_diskspacethreshold;

        SrvCaptureScavengerTimeout( &scavengerTimeout, &alerterTimeout );

        //
        // Link Speed Parameters
        //

        SrvMaxLinkDelay = SecondsToTime( sv599->sv599_maxlinkdelay, FALSE );

        SrvMinLinkThroughput.QuadPart = sv599->sv599_minlinkthroughput;

        SrvLinkInfoValidTime =
                SecondsToTime ( sv599->sv599_linkinfovalidtime, FALSE );

        SrvScavengerUpdateQosCount =
            sv599->sv599_scavqosinfoupdatetime / sv599->sv599_scavtimeout;

        //
        // Override parameters that cannot be set on WinNT (vs. NTAS).
        //
        // We override the parameters passed by the service in case somebody
        // figures out the FSCTL that changes parameters.  We also override
        // in the service in order to keep the service's view consistent
        // with the server's.  If you make any changes here, also make them
        // in srvsvc\server\registry.c.
        //

        //
        // For Embedded systems, just take the registry value.  They do their own
        // validation of settings.
        //
        if( !IsEmbedded() )
        {
            if ( !SrvProductTypeServer ) {

                //
                // On WinNT, the maximum value of certain parameters is fixed at
                // build time.  These include: concurrent users, SMB buffers,
                //

    #define MINIMIZE(_param,_max) _param = MIN( _param, _max );

                MINIMIZE( SrvMaxUsers, MAX_USERS_WKSTA );
                MINIMIZE( SrvMaxReceiveWorkItemCount, MAX_MAXWORKITEMS_WKSTA );
                MINIMIZE( SrvMaxThreadsPerQueue, MAX_THREADS_WKSTA );

                if( IsPersonal() )
                {
                    MINIMIZE( SrvMaxUsers, MAX_USERS_PERSONAL );
                }

                //
                // On WinNT, we do not cache the following:
                //

                SrvCachedOpenLimit = 0;         // don't cache close'd files
                SrvMaxCachedDirectory = 0;      // don't cache directory names
                SrvMaxFreeRfcbs = 0;            // don't cache free'd RFCB structs
                SrvMaxFreeMfcbs = 0;            // don't cache free'd NONPAGED_MFCB structs
            }

            if( IsWebBlade() )
            {
                MINIMIZE( SrvMaxUsers, MAX_USERS_WEB_BLADE );
                MINIMIZE( SrvMaxReceiveWorkItemCount, MAX_MAXWORKITEMS_WKSTA );
                MINIMIZE( SrvMaxThreadsPerQueue, MAX_THREADS_WKSTA );
            }
        }

        if( (SrvMaxUsers < UINT_MAX) && (SrvMaxUsers > 0) )
        {
            // Increment by 1 to allow the "emergency admin" user.  Essentially, the final user
            // to connect must be an administrator in case something is going wrong, such as DoS
            SrvMaxUsers += 1;
        }

        //
        // The following items are generally per-processor.  Ensure they
        // are a multiple of the number of processors in the system.
        //
        SrvMaxReceiveWorkItemCount =
            MultipleOfProcessors( SrvMaxReceiveWorkItemCount );

        SrvInitialReceiveWorkItemCount =
            MultipleOfProcessors( SrvInitialReceiveWorkItemCount );

        SrvMinReceiveQueueLength =
            MultipleOfProcessors( SrvMinReceiveQueueLength );

        SrvMaxRawModeWorkItemCount =
            MultipleOfProcessors( SrvMaxRawModeWorkItemCount );

        SrvInitialRawModeWorkItemCount =
            MultipleOfProcessors( SrvInitialRawModeWorkItemCount );


        status = STATUS_SUCCESS;

    } except( EXCEPTION_EXECUTE_HANDLER ) {

        status = GetExceptionCode();
    }

    RELEASE_LOCK( &SrvConfigurationLock );

    return status;

} // SrvNetServerSetInfo


LARGE_INTEGER
SecondsToTime (
    IN ULONG Seconds,
    IN BOOLEAN MakeNegative
    )

/*++

Routine Description:

    This routine converts a time interval specified in seconds to
    the NT time base in 100s on nanoseconds.

Arguments:

    Seconds - the interval in seconds.

    MakeNegative - if TRUE, the time returned is a negative, i.e. relative
        time.

Return Value:

    LARGE_INTEGER - the interval in NT time.

--*/

{
    LARGE_INTEGER ntTime;

    PAGED_CODE( );

    if ( MakeNegative ) {
        ntTime.QuadPart = Int32x32To64( Seconds, -1*10*1000*1000 );
    } else {
        ntTime.QuadPart = Int32x32To64( Seconds, 1*10*1000*1000 );
    }

    return ntTime;

} // SecondsToTime


LARGE_INTEGER
MinutesToTime (
    IN ULONG Minutes,
    IN BOOLEAN MakeNegative
    )

/*++

Routine Description:

    This routine converts a time interval specified in minutes to
    the NT time base in 100s on nanoseconds.

Arguments:

    Minutes - the interval in minutes.

    MakeNegative - if TRUE, the time returned is a negative, i.e. relative
        time.

Return Value:

    LARGE_INTEGER - the interval in NT time.

--*/

{
    PAGED_CODE( );

    return SecondsToTime( 60*Minutes, MakeNegative );

} // MinutesToTime

ULONG
MultipleOfProcessors(
    IN ULONG value
    )
/*++

Routine Description:

    This routine ensures the passed in value is a multiple of the number
    of processors in the system.  The value will be adjusted upward if
    necessary.

Arguments:

    value - the value to be adjusted

Return Value:

    the adjusted value

--*/
{
    value += SrvNumberOfProcessors - 1;
    value /= SrvNumberOfProcessors;
    value *= SrvNumberOfProcessors;

    return value;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\svcfile.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    svcfile.c

Abstract:

    This module contains routines for supporting the file APIs in the
    server service, SrvNetFileClose, SrvNetFileEnum, and
    SrvNetFileGetInfo,

Author:

    David Treadwell (davidtr) 31-Jan-1991

Revision History:

--*/

#include "precomp.h"
#include "svcfile.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_SVCFILE

//
// Forward declarations.
//

VOID
FillFileInfoBuffer (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block,
    IN OUT PVOID *FixedStructure,
    IN LPWSTR *EndOfVariableData
    );

BOOLEAN
FilterFiles (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    );

ULONG
SizeFiles (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvNetFileClose )
#pragma alloc_text( PAGE, SrvNetFileEnum )
#pragma alloc_text( PAGE, FillFileInfoBuffer )
#pragma alloc_text( PAGE, FilterFiles )
#pragma alloc_text( PAGE, SizeFiles )
#endif

//
// Macros to determine the size an RFCB would take up at one of the
// levels of file information.
//
// *** Note that the zero terminator on the path name is accounted for by
//     the leading backslash, which is not returned.
//

#define TOTAL_SIZE_OF_FILE(lfcb,level, user)                                   \
    ( (level) == 2 ? sizeof(FILE_INFO_2) :                                     \
                     sizeof(FILE_INFO_3) +                                     \
                         SrvLengthOfStringInApiBuffer(                         \
                             &(lfcb)->Mfcb->FileName) +                        \
                         SrvLengthOfStringInApiBuffer( user ) )

#define FIXED_SIZE_OF_FILE(level)                  \
    ( (level) == 2 ? sizeof(FILE_INFO_2) :         \
                     sizeof(FILE_INFO_3) )

NTSTATUS
SrvNetFileClose (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine processes the NetFileClose API in the server.

Arguments:

    Srp - a pointer to the server request packet that contains all
        the information necessary to satisfy the request.  This includes:

      INPUT:

        Parameters.Get.ResumeHandle - the file ID to close.

      OUTPUT:

        None.

    Buffer - unused.

    BufferLength - unused.

Return Value:

    NTSTATUS - result of operation to return to the server service.

--*/

{
    PRFCB rfcb;

    PAGED_CODE( );

    Buffer, BufferLength;

    //
    // Try to find a file that matches the file ID.  Only an exact
    // match will work.
    //

    rfcb = SrvFindEntryInOrderedList(
               &SrvRfcbList,
               NULL,
               NULL,
               Srp->Parameters.Get.ResumeHandle,
               TRUE,
               NULL
               );

    if ( rfcb == NULL ) {
        Srp->ErrorCode = NERR_FileIdNotFound;
        return STATUS_SUCCESS;
    }

    //
    // Close this RFCB.
    //

    SrvCloseRfcb( rfcb );

    //
    // SrvFindEntryInOrderedList referenced the RFCB; dereference it
    // now.
    //

    SrvDereferenceRfcb( rfcb );

    return STATUS_SUCCESS;

} // SrvNetFileClose


NTSTATUS
SrvNetFileEnum (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine processes the NetFileEnum API in the server.

Arguments:

    Srp - a pointer to the server request packet that contains all
        the information necessary to satisfy the request.  This includes:

      INPUT:

        Name1 - basename for limiting search--only files whose path name
            begin with this string are returned.

        Level - level of information to return, 2 or 3.

        Flags - if SRP_RETURN_SINGLE_ENTRY is set, then this is a
            NetFileGetInfo, so behave accordingly.

        Parameters.Get.ResumeHandle - a handle to the last file that was
            returned, or 0 if this is the first call.

      OUTPUT:

        Parameters.Get.EntriesRead - the number of entries that fit in
            the output buffer.

        Parameters.Get.TotalEntries - the total number of entries that
            would be returned with a large enough buffer.

        Parameters.Get.TotalBytesNeeded - the buffer size that would be
            required to hold all the entries.

        Parameters.Get.ResumeHandle - a handle to the last file
            returned.

    Buffer - a pointer to the buffer for results.

    BufferLength - the length of this buffer.

Return Value:

    NTSTATUS - result of operation to return to the server service.

--*/

{
    PAGED_CODE( );

    //
    // If this is a GetInfo API, we really want to start with the file
    // corresponding to the resume handle, not the one after it.
    // Decrement the resume handle.
    //

    if ( (Srp->Flags & SRP_RETURN_SINGLE_ENTRY) != 0 ) {
        Srp->Parameters.Get.ResumeHandle--;
    }

    return SrvEnumApiHandler(
               Srp,
               Buffer,
               BufferLength,
               &SrvRfcbList,
               FilterFiles,
               SizeFiles,
               FillFileInfoBuffer
               );

} // SrvNetFileEnum


VOID
FillFileInfoBuffer (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block,
    IN OUT PVOID *FixedStructure,
    IN LPWSTR *EndOfVariableData
    )

/*++

Routine Description:

    This routine puts a single fixed file structure and associated
    variable data, into a buffer.  Fixed data goes at the beginning of
    the buffer, variable data at the end.

    *** This routine assumes that ALL the data, both fixed and variable,
        will fit.

Arguments:

    Srp - a pointer to the SRP for the operation.  Only the Level
        field is used.

    Block - the RFCB from which to get information.

    FixedStructure - where the ine buffer to place the fixed structure.
        This pointer is updated to point to the next available
        position for a fixed structure.

    EndOfVariableData - the last position on the buffer that variable
        data for this structure can occupy.  The actual variable data
        is written before this position as long as it won't overwrite
        fixed structures.  It is would overwrite fixed structures, it
        is not written.

Return Value:

    None.

--*/

{
    PFILE_INFO_3 fi3 = *FixedStructure;
    PRFCB rfcb;
    PLFCB lfcb;
    UNICODE_STRING userName;

    PAGED_CODE( );

    //
    // Update FixedStructure to point to the next structure location.
    //

    *FixedStructure = (PCHAR)*FixedStructure + FIXED_SIZE_OF_FILE( Srp->Level );
    ASSERT( (ULONG_PTR)*EndOfVariableData >= (ULONG_PTR)*FixedStructure );

    rfcb = Block;
    lfcb = rfcb->Lfcb;

    //
    // Case on the level to fill in the fixed structure appropriately.
    // We fill in actual pointers in the output structure.  This is
    // possible because we are in the server FSD, hence the server
    // service's process and address space.
    //
    // *** Using the switch statement in this fashion relies on the fact
    //     that the first fields on the different file structures are
    //     identical.
    //

    switch( Srp->Level ) {

    case 3:

        //
        // Set level 3 specific fields in the buffer.  Convert the
        // permissions (granted access) stored in the LFCB to the format
        // expected by the API.
        //

        fi3->fi3_permissions = 0;

        if ( (lfcb->GrantedAccess & FILE_READ_DATA) != 0 ) {
            fi3->fi3_permissions |= ACCESS_READ;
        }

        if ( (lfcb->GrantedAccess & FILE_WRITE_DATA) != 0 ) {
            fi3->fi3_permissions |= ACCESS_WRITE;
        }

        if ( (lfcb->GrantedAccess & FILE_EXECUTE) != 0 ) {
            fi3->fi3_permissions |= ACCESS_EXEC;
        }

        if ( (lfcb->GrantedAccess & DELETE) != 0 ) {
            fi3->fi3_permissions |= ACCESS_DELETE;
        }

        if ( (lfcb->GrantedAccess & FILE_WRITE_ATTRIBUTES) != 0 ) {
            fi3->fi3_permissions |= ACCESS_ATRIB;
        }

        if ( (lfcb->GrantedAccess & WRITE_DAC) != 0 ) {
            fi3->fi3_permissions |= ACCESS_PERM;
        }

        //
        // Set count of locks on the RFCB.
        //

        fi3->fi3_num_locks = rfcb->NumberOfLocks;

        //
        // Set up the pathname and username of the RFCB.  Note that we
        // don't return the leading backslash on file names.
        //

        SrvCopyUnicodeStringToBuffer(
            &lfcb->Mfcb->FileName,
            *FixedStructure,
            EndOfVariableData,
            &fi3->fi3_pathname
            );

        ASSERT( fi3->fi3_pathname != NULL );

        SrvGetUserAndDomainName( lfcb->Session, &userName, NULL );

        SrvCopyUnicodeStringToBuffer(
            &userName,
            *FixedStructure,
            EndOfVariableData,
            &fi3->fi3_username
            );

        if( userName.Buffer ) {
            SrvReleaseUserAndDomainName( lfcb->Session, &userName, NULL );
        }

        //ASSERT( fi3->fi3_username != NULL );

        // *** Lack of break is intentional!

    case 2:

        //
        // Set up the file ID.  Note that it is the same value as is
        // used for the resume handle, so it is possible to use this
        // value for rewindability.
        //

        fi3->fi3_id = rfcb->GlobalRfcbListEntry.ResumeHandle;

        break;

    default:

        //
        // This should never happen.  The server service should have
        // checked for an invalid level.
        //

        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "FillFileInfoBuffer: invalid level number: %ld",
            Srp->Level,
            NULL
            );

        return;
    }

    return;

} // FillFileInfoBuffer


BOOLEAN
FilterFiles (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    )

/*++

Routine Description:

    This routine is intended to be called by SrvEnumApiHandler to check
    whether a particular RFCB should be returned.

Arguments:

    Srp - a pointer to the SRP for the operation.  ResumeHandle is
        used if this is a NetFileGetInfo; Name1 is used as the path
        name and Name2 is used as the user name if this is a
        NetFileEnum.

    Block - a pointer to the RFCB to check.

Return Value:

    TRUE if the block should be placed in the output buffer, FALSE
        if it should be passed over.

--*/

{
    PRFCB rfcb = Block;
    PLFCB lfcb = rfcb->Lfcb;
    PMFCB mfcb = lfcb->Mfcb;
    UNICODE_STRING pathName;
    UNICODE_STRING userName;

    PAGED_CODE( );

    //
    // Check if this is an Enum or GetInfo command.  The SRP_RETURN_SINGLE_ENTRY
    // flag is set if this is a get info.
    //

    if ( (Srp->Flags & SRP_RETURN_SINGLE_ENTRY) == 0 ) {

        //
        // If a user name was specified, the user name on the session
        // must match the user name in the SRP exactly.
        //

        if ( Srp->Name2.Length != 0 ) {

            //
            // Get the user name for the owning session
            //
            SrvGetUserAndDomainName( lfcb->Session, &userName, NULL );

            if( userName.Buffer == NULL ) {
                //
                // Since we don't know who owns the session, we can't match
                //   the username
                //
                return FALSE;
            }

            if ( !RtlEqualUnicodeString(
                      &Srp->Name2,
                      &userName,
                      TRUE ) ) {

                //
                // The names don't match.  Don't put this RFCB in the
                // output buffer.
                //

                SrvReleaseUserAndDomainName( lfcb->Session, &userName, NULL );
                return FALSE;
            }

            SrvReleaseUserAndDomainName( lfcb->Session, &userName, NULL );
        }

        //
        // See if the names match to as many digits of precision as are in
        // the specified base name.  Note that if no base name was
        // specified, then the length = 0 and the file path will always
        // match.  Also note that the path name stored in the MFCB has a
        // leading backslash, while the passed-in path name will never have
        // this leading slash, hence the increment of the MFCB file name
        // buffer.
        //

        pathName.Buffer = mfcb->FileName.Buffer;
        pathName.Length =
            MIN( Srp->Name1.Length, mfcb->FileName.Length );
        pathName.MaximumLength = mfcb->FileName.MaximumLength;

        return RtlEqualUnicodeString(
                   &Srp->Name1,
                   &pathName,
                   TRUE
                   );
    }

    //
    // It's a GetInfo, so just see if the ResumeHandle in the SRP
    // matches the ResumeHandle on the RFCB.  We increment the value in
    // the SRP because it was decremented before calling
    // SrvEnumApiHandler.
    //

    return (BOOLEAN)( Srp->Parameters.Get.ResumeHandle + 1==
                          SrvGetResumeHandle( &SrvRfcbList, rfcb ) );

} // FilterFiles


ULONG
SizeFiles (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    )

/*++

Routine Description:

    This routine returns the size the passed-in RFCB would take up
    in an API output buffer.

Arguments:

    Srp - a pointer to the SRP for the operation.  Only the level
        parameter is used.

    Block - a pointer to the RFCB to size.

Return Value:

    ULONG - The number of bytes the file would take up in the output
        buffer.

--*/

{
    PRFCB rfcb = Block;
    UNICODE_STRING userName;
    ULONG size;

    PAGED_CODE( );

    SrvGetUserAndDomainName( rfcb->Lfcb->Session, &userName, NULL );

    size = TOTAL_SIZE_OF_FILE( rfcb->Lfcb, Srp->Level, &userName );

    SrvReleaseUserAndDomainName( rfcb->Lfcb->Session, &userName, NULL );

    return size;

} // SizeFiles
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\svcsupp.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    svcshare.c

Abstract:

    This module contains support routines for the server service.

Author:

    David Treadwell (davidtr) 13-Feb-1991

Revision History:

--*/

#include "precomp.h"
#include "svcsupp.tmh"
#pragma hdrstop


BOOLEAN
FilterTransportName (
    IN PVOID Context,
    IN PVOID Block
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvCopyUnicodeStringToBuffer )
#pragma alloc_text( PAGE, SrvDeleteOrderedList )
#pragma alloc_text( PAGE, SrvEnumApiHandler )
#pragma alloc_text( PAGE, SrvFindEntryInOrderedList )
#pragma alloc_text( PAGE, SrvFindNextEntryInOrderedList )
#pragma alloc_text( PAGE, SrvFindUserOnConnection )
#pragma alloc_text( PAGE, SrvGetResumeHandle )
#pragma alloc_text( PAGE, SrvInitializeOrderedList )
#pragma alloc_text( PAGE, SrvInsertEntryOrderedList )
#pragma alloc_text( PAGE, SrvRemoveEntryOrderedList )
#pragma alloc_text( PAGE, SrvSendDatagram )
#pragma alloc_text( PAGE, FilterTransportName )
#pragma alloc_text( PAGE, SrvLengthOfStringInApiBuffer )
#pragma alloc_text( PAGE, SrvInhibitIdlePowerDown )
#pragma alloc_text( PAGE, SrvAllowIdlePowerDown )
#endif


VOID
SrvCopyUnicodeStringToBuffer (
    IN PUNICODE_STRING String,
    IN PCHAR FixedStructure,
    IN OUT LPWSTR *EndOfVariableData,
    OUT LPWSTR *VariableDataPointer
    )

/*++

Routine Description:

    This routine puts a single variable-length Unicode string into a
    buffer.  The string data is converted to ANSI as it is copied.  The
    string is not written if it would overwrite the last fixed structure
    in the buffer.

Arguments:

    String - a pointer to the string to copy into the buffer.  If String
        is null (Length == 0 || Buffer == NULL) then a pointer to a
        zero terminator is inserted.

    FixedStructure - a pointer to the end of the last fixed
        structure in the buffer.

    EndOfVariableData - the last position on the buffer that variable
        data for this structure can occupy.

    VariableDataPointer - a pointer to the place in the buffer where
        a pointer to the variable data should be written.

Return Value:

    None.

--*/

{
    ULONG length;
    ULONG i;
    PWCH src;
    LPWSTR dest;

    PAGED_CODE( );

    //
    // Determine where in the buffer the string will go, allowing for a
    // zero-terminator.
    //

    if ( String->Buffer != NULL ) {
        length = String->Length >> 1;
        *EndOfVariableData -= (length + 1);
    } else {
        length = 0;
        *EndOfVariableData -= 1;
    }

    //
    // Will the string fit?  If no, just set the pointer to NULL.
    //

    if ( (ULONG_PTR)*EndOfVariableData >= (ULONG_PTR)FixedStructure ) {

        //
        // It fits.  Set up the pointer to the place in the buffer where
        // the string will go.
        //

        *VariableDataPointer = *EndOfVariableData;

        //
        // Copy the string to the buffer if it is not null.
        //

        dest = *EndOfVariableData;

        for ( i = 0, src = String->Buffer; i < length; i++ ) {
            *dest++ = (TCHAR)*src++;
        }

        //
        // Set the zero terminator.
        //

        *dest = (TCHAR)(L'\0');

    } else {

        //
        // It doesn't fit.  Set the offset to NULL.
        //

        *VariableDataPointer = NULL;

    }

    return;

} // SrvCopyUnicodeStringToBuffer


VOID
SrvDeleteOrderedList (
    IN PORDERED_LIST_HEAD ListHead
    )

/*++

Routine Description:

    "Deinitializes" or deletes an ordered list head.

Arguments:

    ListHead - a pointer to the list head to delete.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    if ( ListHead->Initialized ) {

        ASSERT( IsListEmpty( &ListHead->ListHead ) );

        //
        // Indicate that the ordered list has been "deleted".
        //

        ListHead->Initialized = FALSE;

    }

    return;

} // SrvDeleteOrderedList


NTSTATUS
SrvEnumApiHandler (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID OutputBuffer,
    IN ULONG BufferLength,
    IN PORDERED_LIST_HEAD ListHead,
    IN PENUM_FILTER_ROUTINE FilterRoutine,
    IN PENUM_SIZE_ROUTINE SizeRoutine,
    IN PENUM_FILL_ROUTINE FillRoutine
    )

/*++

Routine Description:

    All Enum and GetInfo APIs are handled by this routine in the server
    FSD.  It takes the ResumeHandle in the SRP to find the first
    appropriate block, then calls the passed-in filter routine to check
    if the block should be filled in.  If it should, we call the filter
    routine, then try to get another block.  This continues until tyhe
    entire list has been walked.

Arguments:

    Srp - a pointer to the SRP for the operation.

    OutputBuffer - the buffer in which to fill output information.

    BufferLength - the length of the buffer.

    ListHead - the head of the ordered list to walk.

    FilterRoutine - a pointer to a function that will check a block
        against information in the SRP to determine whether the
        information in the block should be placed in the output
        buffer.

    SizeRoutine - a pointer to a function that will find the total size
        a single block will take up in the output buffer.  This routine
        is used to check whether we should bother to call the fill
        routine.

    FillRoutine - a pointer to a function that will fill in the output
        buffer with information from a block.

Return Value:

    NTSTATUS - results of operation.

--*/

{
    PVOID block;
    PVOID lastBlockRead;
    ULONG totalEntries;
    ULONG entriesRead;
    ULONG bytesRequired;
    ULONG newResumeHandle;

    PCHAR fixedStructurePointer;
    PCHAR variableData;
    ULONG level;
    ULONG maxResumeHandle;

    BOOLEAN bufferOverflow = FALSE;

    PAGED_CODE( );

    //
    // Set up local variables.
    //

    fixedStructurePointer = OutputBuffer;
    variableData = fixedStructurePointer + BufferLength;
    variableData = (PCHAR)((ULONG_PTR)variableData & ~1);
    level = Srp->Level;

    lastBlockRead = NULL;
    entriesRead = 0;
    totalEntries = 0;
    bytesRequired = 0;
    newResumeHandle = 0;

    //
    // Grab the current resume handle in the list we're
    // enumerating.  This allows us to return only blocks that existed
    // when the enumeration started, thereby avoiding problems with
    // blocks created after the enumeration distorting the data.
    //

    maxResumeHandle = ListHead->CurrentResumeHandle;

    //
    // Get blocks from the global list by using the ordered list
    // routines.  We pass resume handle +1 to get the next block after
    // the last one returned.  If the passed-in resume handle is 0, this
    // will return the first valid block in the list.
    //

    block = SrvFindEntryInOrderedList(
                ListHead,
                NULL,
                NULL,
                Srp->Parameters.Get.ResumeHandle + 1,
                FALSE,
                NULL
                );

    while ( block != NULL &&
                SrvGetResumeHandle( ListHead, block ) < maxResumeHandle ) {

        ULONG blockSize;

        //
        // Call the filter routine to determine whether we should
        // return this block.
        //

        if ( FilterRoutine( Srp, block ) ) {

            blockSize = SizeRoutine( Srp, block );

            totalEntries++;
            bytesRequired += blockSize;

            //
            // If all the information in the block will fit in the
            // output buffer, write it.  Otherwise, indicate that there
            // was an overflow.  As soon as an entry doesn't fit, stop
            // putting them in the buffer.  This ensures that the resume
            // mechanism will work--retuning partial entries would make
            // it nearly impossible to use the resumability of the APIs,
            // since the caller would have to resume from an imcomplete
            // entry.
            //

            if ( (ULONG_PTR)fixedStructurePointer + blockSize <=
                     (ULONG_PTR)variableData && !bufferOverflow ) {

                FillRoutine(
                    Srp,
                    block,
                    (PVOID *)&fixedStructurePointer,
                    (LPWSTR *)&variableData
                    );

                entriesRead++;
                lastBlockRead = block;
                newResumeHandle = SrvGetResumeHandle( ListHead, lastBlockRead );
            } else {

                bufferOverflow = TRUE;
            }
        }

        //
        // Get the next block in the list.  This routine will dereference
        // the block we have been looking at and get a new block if a valid
        // one exists.
        //

        block = SrvFindNextEntryInOrderedList( ListHead, block );
    }

    //
    // Dereference this last one.
    //

    if ( block != NULL ) {

        ListHead->DereferenceRoutine( block );

    }

    //
    // Set the information to pass back to the server service.
    //

    Srp->Parameters.Get.EntriesRead = entriesRead;
    Srp->Parameters.Get.TotalEntries = totalEntries;
    Srp->Parameters.Get.TotalBytesNeeded = bytesRequired;

    //
    // If we found at least one block, return the resume handle for it.
    // If we didn't find any blocks, don't modify the resume handle.
    //

    if ( lastBlockRead != NULL ) {
        Srp->Parameters.Get.ResumeHandle = newResumeHandle;
    }

    //
    // Return appropriate status.
    //

    if ( entriesRead == 0 && totalEntries > 0 ) {

        //
        // Not even a single entry fit.
        //

        Srp->ErrorCode = NERR_BufTooSmall;
        return STATUS_SUCCESS;

    } else if ( bufferOverflow ) {

        //
        // At least one entry fit, but not all of them.
        //

        Srp->ErrorCode = ERROR_MORE_DATA;
        return STATUS_SUCCESS;

    } else {

        //
        // All entries fit.
        //

        Srp->ErrorCode = NO_ERROR;
        return STATUS_SUCCESS;
    }

} // SrvEnumApiHandler


PVOID
SrvFindEntryInOrderedList (
    IN PORDERED_LIST_HEAD ListHead,
    IN PFILTER_ROUTINE FilterRoutine OPTIONAL,
    IN PVOID Context OPTIONAL,
    IN ULONG ResumeHandle,
    IN BOOLEAN ExactHandleMatch,
    IN PLIST_ENTRY StartLocation OPTIONAL
    )

/*++

Routine Description:

    This routine uses a filter routine or resume handle to find an entry
    in an ordered list.  It walks the list, looking for a block with a
    resume handle less than or equal to the specified resume handle, or
    a block that passes the filter routine's tests.  If a matching
    handle or passing block is found, the block is referenced and a
    pointer to it is returned.  If ExactHandleMatch is FALSE and there
    is no exact match of the handle, then the first block with a resume
    handle greater than the one specified is referenced and returned.

Arguments:

    ListHead - a pointer to the list head to search.

    FilterRoutine - a routine that will check whether a block is valid
        for the purposes of the calling routine.

    Context - a pointer to pass to the filter routine.

    ResumeHandle - the resume handle to look for.  If a filter routine
        is specified, this parameter should be -1.

    ExactHandleMatch - if TRUE, only an exact match is returned.  If there
        is no exact match, return NULL.  If a filter routine is specified
        this should be FALSE.

    StartLocation - if specified, start looking at this location in
        the list.  This is used by SrvFindNextEntryInOrderedList to
        speed up finding a valid block.

Return Value:

    PVOID - NULL if no block matched or if the handle is beyond the end of
       the list.  A pointer to a block if a valid block is found.  The
       block is referenced.

--*/

{
    PLIST_ENTRY listEntry;
    PVOID block;

    PAGED_CODE( );

    //
    // Acquire the lock that protects the ordered list.
    //

    ACQUIRE_LOCK( ListHead->Lock );

    //
    // Find the starting location for the search.  If a start was
    // specified, start there; otherwise, start at the beginning of the
    // list.
    //

    if ( ARGUMENT_PRESENT( StartLocation ) ) {
        listEntry = StartLocation;
    } else {
        listEntry = ListHead->ListHead.Flink;
    }

    //
    // Walk the list of blocks until we find one with a resume handle
    // greater than or equal to the specified resume handle.
    //

    for ( ; listEntry != &ListHead->ListHead; listEntry = listEntry->Flink ) {

        ULONG currentResumeHandle;

        currentResumeHandle = ((PORDERED_LIST_ENTRY)listEntry)->ResumeHandle;

        //
        // Get a pointer to the actual block.
        //

        block = (PCHAR)listEntry - ListHead->ListEntryOffset;

        //
        // Determine whether we've reached the specified handle, or
        // whether the block passes the filter routine's tests.
        //

        if ( currentResumeHandle >= ResumeHandle ||
             ( ARGUMENT_PRESENT( FilterRoutine ) &&
               FilterRoutine( Context, block ) ) ) {

            if ( ExactHandleMatch && currentResumeHandle != ResumeHandle ) {

                //
                // We have passed the specified resume handle without
                // finding an exact match.  Return NULL, indicating that
                // no exact match exists.
                //

                RELEASE_LOCK( ListHead->Lock );

                return NULL;
            }

            //
            // Check the state of the block and if it is active,
            // reference it.  This must be done as an atomic operation
            // order to prevent the block from being deleted.
            //

            if ( ListHead->ReferenceRoutine( block ) ) {

                //
                // Release the list lock and return a pointer to the
                // block to the caller.
                //

                RELEASE_LOCK( ListHead->Lock );

                return block;

            }

        }

    } // walk list

    //
    // If we are here, it means that we walked the entire list without
    // finding a valid match.  Release the list lock and return NULL.
    //

    RELEASE_LOCK( ListHead->Lock );

    return NULL;

} // SrvFindEntryInOrderedList


PVOID
SrvFindNextEntryInOrderedList (
    IN PORDERED_LIST_HEAD ListHead,
    IN PVOID Block
    )

/*++

Routine Description:

    This routine finds the next valid block after the one passed in.
    It calls SrvFindEntryInOrderedList to do most of the work.  It
    also handles dereferencing the passed-in block and referencing the
    returned block.  The passed-in block is dereferenced regardless
    of whether a block is returned, so calling routines must be careful
    to obtain all the information they need from the block before
    calling this routine.

Arguments:

    ListHead - a pointer to the list head to search.

    Block - a pointer to the block after which we should look for
        the next block.

Return Value:

    PVOID - NULL if no block matched or if the handle is beyond the end of
       the list.  A pointer to a block if a valid block is found.

--*/

{
    PVOID returnBlock;
    PORDERED_LIST_ENTRY listEntry;

    PAGED_CODE( );

    //
    // Find the ordered list entry in the block.  We need this to pass
    // the start location and resume handle to
    // SrvFindEntryInOrderedList.
    //

    listEntry =
        (PORDERED_LIST_ENTRY)( (PCHAR)Block + ListHead->ListEntryOffset );

    //
    // Call SrvFindEntryInOrderedList with a start location.  This will
    // find the block to return, if any.
    //

    // This adds one to the resume handle because we want the *next*
    // block, not this one, to be returned.
    //

    returnBlock = SrvFindEntryInOrderedList(
                      ListHead,
                      NULL,
                      NULL,
                      listEntry->ResumeHandle + 1,
                      FALSE,
                      &listEntry->ListEntry
                      );

    //
    // Dereference the passed-in block.
    //

    ListHead->DereferenceRoutine( Block );

    //
    // Return what we got from SrvFindEntryInOrderedList.
    //

    return returnBlock;

} // SrvFindNextEntryInOrderedList


PSESSION
SrvFindUserOnConnection (
    IN PCONNECTION Connection
    )

/*++

Routine Description:

    Finds a "legitimate" user on a virtual circuit.  This routine is
    an attempt to find a good username to return even though there
    may be multiple users on a VC.  Some of the APIs assume that there
    will be one user per VC, and this is an attempt to support that
    bahavior.

    The following rules are used:

    0 users--return NULL.

    1 user--return a pointer to that session block.

    2 users--if one matches the computer name, return the other.  This
        is because RIPL sessions have a session name matching the
        client name, and this is probably not a useful user.  If both
        usernames differ from the computer name, return NULL.

    3 or more users--return NULL.

    *** THIS ROUTINE MUST BE CALLED WITH THE CONNECTION LOCK HELD.  It
        remains held on exit.

Arguments:

    Connection - a pointer to the connection block to search for a user.

Return Value:

    NULL or a pointer to a session.

--*/

{
    PSESSION matchingSession = NULL;
    PSESSION nonMatchingSession = NULL;
    USHORT i;
    PPAGED_CONNECTION pagedConnection = Connection->PagedConnection;

    PAGED_CODE( );

    //
    // Walk the connection's session table looking for valid sessions.
    //

    for ( i = 0; i < pagedConnection->SessionTable.TableSize; i++ ) {

        PSESSION session;

        session = pagedConnection->SessionTable.Table[i].Owner;

        //
        // Determine whether this is a valid session.
        //

        if ( session != NULL && GET_BLOCK_STATE(session) == BlockStateActive ) {

            //
            // It is a valid session.  Determine whether the name matches
            // the connection's client name.
            //

            UNICODE_STRING computerName, userName;

            computerName.Buffer = Connection->ClientMachineName;
            computerName.Length =
                (USHORT)( Connection->ClientMachineNameString.Length -
                            sizeof(WCHAR) * 2 );

            SrvGetUserAndDomainName( session, &userName, NULL );

            if( userName.Buffer && userName.Length != 0 ) {

                if ( RtlCompareUnicodeString(
                         &computerName,
                         &userName,
                         TRUE ) == 0 ) {

                    //
                    // The user name and machine name are the same.
                    //

                    matchingSession = session;

                } else {

                    //
                    // If we already found another user name that doesn't match
                    // the client computer name, we're hosed.  Return NULL.
                    //

                    if ( nonMatchingSession != NULL ) {
                        SrvReleaseUserAndDomainName( session, &userName, NULL );
                        return NULL;
                    }

                    nonMatchingSession = session;

                }  // does session user name match computer name?

                SrvReleaseUserAndDomainName( session, &userName, NULL );
            }

        } // valid session?

    } // walk session table

    //
    // If only one non-matching name was found, we got here, so return
    // that session.
    //

    if ( nonMatchingSession != NULL ) {
        return nonMatchingSession;
    }

    //
    // If a matching session was found return it, or return NULL if
    // no sessions matched.
    //

    return matchingSession;

} // SrvFindUserOnConnection


ULONG
SrvGetResumeHandle (
    IN PORDERED_LIST_HEAD ListHead,
    IN PVOID Block
    )
{
    PORDERED_LIST_ENTRY listEntry;

    PAGED_CODE( );

    // !!! make this a macro?

    listEntry =
        (PORDERED_LIST_ENTRY)( (PCHAR)Block + ListHead->ListEntryOffset );

    return listEntry->ResumeHandle;

} // SrvGetResumeHandle


VOID
SrvInitializeOrderedList (
    IN PORDERED_LIST_HEAD ListHead,
    IN ULONG ListEntryOffset,
    IN PREFERENCE_ROUTINE ReferenceRoutine,
    IN PDEREFERENCE_ROUTINE DereferenceRoutine,
    IN PSRV_LOCK Lock
    )

/*++

Routine Description:

    This routine initializes an ordered list.  It initializes the list
    head and lock and sets up other header fields from the information
    passed in.

Arguments:

    ListHead - a pointer to the list head to initialize.

    ListEntryOffset - the offset into a data block in the list to the
        ORDERED_LIST_ENTRY field.  This is used to find the start of
        the block from the list entry field.

    ReferenceRoutine - a pointer to the routine to call to reference
        a data block stored in the list.  This is done to prevent the
        data block from going away between when we find it and when
        higher-level routines start using it.

    DereferenceRoutine - a pointer to the routine to call to dereference
       a data block stored in the list.

    Lock - a pointer to a lock to use for synchronization.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    ASSERT( !ListHead->Initialized );

    //
    // Initialize the head of the doubly linked list.
    //

    InitializeListHead( &ListHead->ListHead );

    //
    // Save the address of the list lock.
    //

    ASSERT( ARGUMENT_PRESENT(Lock) );
    ListHead->Lock = Lock;

    //
    // Initialize other fields in the header.
    //

    ListHead->CurrentResumeHandle = 1;
    ListHead->ListEntryOffset = ListEntryOffset;
    ListHead->ReferenceRoutine = ReferenceRoutine,
    ListHead->DereferenceRoutine = DereferenceRoutine;

    ListHead->Initialized = TRUE;

    return;

} // SrvInitializeOrderedList


VOID
SrvInsertEntryOrderedList (
    IN PORDERED_LIST_HEAD ListHead,
    IN PVOID Block
    )

/*++

Routine Description:

    This routine inserts an entry in an ordered list.  The entry is
    placed on the doubly linked list and the resume handle is set.

    *** It is the responsibility of that calling routine to ensure that
        the block does not go away while this routine executes.

Arguments:

    ListHead - a pointer to the list head on which to put the block.

    Block - a pointer to the data block to place on the list.

Return Value:

    None.

--*/

{
    PORDERED_LIST_ENTRY listEntry;

    PAGED_CODE( );

    //
    // Determine where the list entry field is.
    //

    listEntry = (PORDERED_LIST_ENTRY)
                    ( (PCHAR)Block + ListHead->ListEntryOffset );

    //
    // Acquire the lock that protects the ordered list.
    //

    ACQUIRE_LOCK( ListHead->Lock );

    //
    // Insert the entry in the doubly linked list.
    //

    SrvInsertTailList( &ListHead->ListHead, &listEntry->ListEntry );

    //
    // Set up the resume handle in the block and update the current
    // handle in the header.
    //

    listEntry->ResumeHandle = ListHead->CurrentResumeHandle;
    ListHead->CurrentResumeHandle++;

    //
    // Release the lock and return.
    //

    RELEASE_LOCK( ListHead->Lock );

    return;

} // SrvInsertEntryOrderedList


VOID
SrvRemoveEntryOrderedList (
    IN PORDERED_LIST_HEAD ListHead,
    IN PVOID Block
    )

/*++

Routine Description:

    This routine removes an entry from an ordered list.

    *** It is the responsibility of that calling routine to ensure that
        the block does not go away while this routine executes.

Arguments:

    ListHead - a pointer to the list head on which to put the block.

    Block - a pointer to the data block to place on the list.

Return Value:

    None.

--*/

{
    PORDERED_LIST_ENTRY listEntry;

    PAGED_CODE( );

    //
    // Determine where the list entry field is.
    //

    listEntry = (PORDERED_LIST_ENTRY)
                    ( (PCHAR)Block + ListHead->ListEntryOffset );

    //
    // Acquire the lock that protects the ordered list.
    //

    ACQUIRE_LOCK( ListHead->Lock );

    //
    // Remove the entry from the doubly linked list.
    //

    SrvRemoveEntryList( &ListHead->ListHead, &listEntry->ListEntry );

    //
    // Release the lock and return.
    //

    RELEASE_LOCK( ListHead->Lock );

    return;

} // SrvRemoveEntryOrderedList


NTSTATUS
SrvSendDatagram (
    IN PANSI_STRING Domain,
    IN PUNICODE_STRING Transport OPTIONAL,
    IN PVOID Buffer,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine sends a datagram to the specified domain.

    !!! Temporary--should go away when we have real 2nd-class mailslot
        support.

Arguments:

    Domain - the name of the domain to send to.  Note that the domain
        name must be padded with spaces and terminated with the
        appropriate signature byte (00 or 07) by the caller.

    Transport - the name of the transport to send to.  If not present, then
        the datagram is sent on all transports.

    Buffer - the message to send.

    BufferLength - the length of the buffer,

Return Value:

    NTSTATUS - results of operation.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG connectionInformationSize;
    PTDI_CONNECTION_INFORMATION connectionInformation;
    PTA_NETBIOS_ADDRESS taNetbiosAddress;
    PENDPOINT endpoint;

    PAGED_CODE( );

    connectionInformationSize = sizeof(TDI_CONNECTION_INFORMATION) +
                                                sizeof(TA_NETBIOS_ADDRESS);
    connectionInformation = ALLOCATE_NONPAGED_POOL(
                                connectionInformationSize,
                                BlockTypeDataBuffer
                                );

    if ( connectionInformation == NULL ) {
        return STATUS_INSUFF_SERVER_RESOURCES;
    }

    connectionInformation->UserDataLength = 0;
    connectionInformation->UserData = NULL;
    connectionInformation->OptionsLength = 0;
    connectionInformation->Options = NULL;
    connectionInformation->RemoteAddressLength = sizeof(TA_NETBIOS_ADDRESS);

    taNetbiosAddress = (PTA_NETBIOS_ADDRESS)(connectionInformation + 1);
    connectionInformation->RemoteAddress = taNetbiosAddress;
    taNetbiosAddress->TAAddressCount = 1;
    taNetbiosAddress->Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
    taNetbiosAddress->Address[0].AddressLength = sizeof(TDI_ADDRESS_NETBIOS);
    taNetbiosAddress->Address[0].Address[0].NetbiosNameType = 0;

    RtlCopyMemory(
        taNetbiosAddress->Address[0].Address[0].NetbiosName,
        Domain->Buffer,
        MIN( Domain->Length, COMPUTER_NAME_LENGTH + 1 )
        );

    endpoint = SrvFindEntryInOrderedList(
                  &SrvEndpointList,
                  FilterTransportName,
                  Transport,
                  (ULONG)-1,
                  FALSE,
                  NULL
                  );

    while ( endpoint != NULL ) {

        if ( !endpoint->IsConnectionless ) {

            if( endpoint->IsNoNetBios ) {
                //
                // Make mailslot sends over this transport "always work"
                //
                status = STATUS_SUCCESS;

            } else {
                status = SrvIssueSendDatagramRequest(
                         endpoint->FileObject,
                         &endpoint->DeviceObject,
                         connectionInformation,
                         Buffer,
                         BufferLength
                         );
            }

        } else {
            //
            //  Dereference the endpoint if this was targetted to a specific
            //  transport, and return an error.
            //

            if (Transport != NULL) {

                DEALLOCATE_NONPAGED_POOL( connectionInformation );
                SrvDereferenceEndpoint( endpoint );

                return STATUS_REQUEST_NOT_ACCEPTED;
            }
        }


        if (Transport == NULL) {

            //
            // Find the next endpoint.  This will dereference the current
            // endpoint.
            //

            endpoint = SrvFindNextEntryInOrderedList( &SrvEndpointList, endpoint );

        } else {

            //
            // This datagram was destined to a specific endpoint.  Do not
            // look for the next endpoint.
            //

            SrvDereferenceEndpoint( endpoint );
            endpoint = NULL;
        }

    }

    DEALLOCATE_NONPAGED_POOL( connectionInformation );

    return status;

} // SrvSendDatagram


BOOLEAN
FilterTransportName (
    IN PVOID Context,
    IN PVOID Block
    )
{
    PENDPOINT endpoint = Block;

    PAGED_CODE( );

    if ( Context == NULL ) {
        return( TRUE );
    }

    return ( RtlEqualUnicodeString ( &endpoint->TransportName, (PUNICODE_STRING)Context, TRUE ) );
}


ULONG
SrvLengthOfStringInApiBuffer (
    IN PUNICODE_STRING UnicodeString
    )
{
    PAGED_CODE( );

    if ( UnicodeString == NULL ) {
        return 0;
    }

    return UnicodeString->Length + sizeof(UNICODE_NULL);

} // SrvLengthOfStringInApiBuffer

//
// Ensure that the system will not go into a power-down idle standby mode
//
VOID
SrvInhibitIdlePowerDown()
{
    PAGED_CODE();

    if( SrvPoRegistrationState != NULL &&
        InterlockedIncrement( &SrvIdleCount ) == 1 ) {

        IF_DEBUG( PNP ) {
            KdPrint(( "SRV: Calling PoRegisterSystemState to inhibit idle standby\n" ));
        }

        PoRegisterSystemState( SrvPoRegistrationState, ES_SYSTEM_REQUIRED | ES_CONTINUOUS );

    }
}

//
// Allow the system to go into a power-down idle standby mode
//
VOID
SrvAllowIdlePowerDown()
{
    PAGED_CODE();

    if( SrvPoRegistrationState != NULL &&
        InterlockedDecrement( &SrvIdleCount ) == 0 ) {

        IF_DEBUG( PNP ) {
            KdPrint(( "SRV: Calling PoRegisterSystemState to allow idle standby\n" ));
        }

        PoRegisterSystemState( SrvPoRegistrationState, ES_CONTINUOUS );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\svcshare.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    svcshare.c

Abstract:

    This module contains routines for supporting the share APIs in the
    server service, NetShareAdd, NetShareCheck, NetShareDel,
    NetShareEnum, NetShareGetInfo, and NetShareSetInfo.

Author:

    David Treadwell (davidtr) 15-Jan-1991

Revision History:

--*/

#include "precomp.h"
#include "svcshare.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_SVCSHARE

#define DISK_ROOT_NAME_TEMPLATE L"\\DosDevices\\X:\\"

//
// Forward declarations.
//

STATIC
VOID
FillShareInfoBuffer (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block,
    IN OUT PVOID *FixedStructure,
    IN LPWSTR *EndOfVariableData
    );

STATIC
BOOLEAN
FilterShares (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    );

STATIC
ULONG
SizeShares (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvNetShareAdd )
#pragma alloc_text( PAGE, SrvNetShareDel )
#pragma alloc_text( PAGE, SrvNetShareEnum )
#pragma alloc_text( PAGE, SrvNetShareSetInfo )
#pragma alloc_text( PAGE, FillShareInfoBuffer )
#pragma alloc_text( PAGE, FilterShares )
#pragma alloc_text( PAGE, SizeShares )
#endif


#define FIXED_SIZE_OF_SHARE(level)                      \
    ( (level) == 0    ? sizeof(SHARE_INFO_0) :          \
      (level) == 1    ? sizeof(SHARE_INFO_1) :          \
      (level) == 2    ? sizeof(SHARE_INFO_2) :          \
      (level) == 501  ? sizeof(SHARE_INFO_501) :        \
      (level) == 502  ? sizeof(SHARE_INFO_502) :        \
                        sizeof(SHARE_INFO_1005) )


NTSTATUS
SrvNetShareAdd (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine processes the NetShareAdd API in the server.

Arguments:

    Srp - a pointer to the server request packet that contains all
        the information necessary to satisfy the request.  This includes:

      INPUT:

        Name1 - the NT path name of the share.

      OUTPUT:

        Parameters.Set.ErrorParameter - if STATUS_INVALID_PARAMETER is
            returned, this contains the index of the parameter in error.

    Buffer - a pointer to a SHARE_INFO2 structure for the new share.

    BufferLength - total length of this buffer.

Return Value:

    NTSTATUS - result of operation to return to the server service.

--*/

{
    NTSTATUS status;
    PSHARE share;
    SHARE_TYPE shareType;
    BOOLEAN isSpecial;
    BOOLEAN isRemovable;
    BOOLEAN isCdrom;
    UNICODE_STRING shareName;
    UNICODE_STRING ntPath;
    UNICODE_STRING dosPath;
    UNICODE_STRING remark;
    PSHARE_INFO_502 shi502;
    PSECURITY_DESCRIPTOR securityDescriptor = NULL;
    PSECURITY_DESCRIPTOR fileSecurityDescriptor = NULL;

    PAGED_CODE( );

    //
    // We usually don't return any information about the parameter in
    // error.
    //

    Srp->Parameters.Set.ErrorParameter = 0;

    //
    // Convert the offsets in the share data structure to pointers.  Also
    // make sure that all the pointers are within the specified buffer.
    //

    shi502 = Buffer;

    OFFSET_TO_POINTER( shi502->shi502_netname, shi502 );
    OFFSET_TO_POINTER( shi502->shi502_remark, shi502 );
    OFFSET_TO_POINTER( shi502->shi502_path, shi502 );
    OFFSET_TO_POINTER( shi502->shi502_security_descriptor, shi502 );

    //
    // Construct the security descriptor pointer by hand, because
    // shi502_permissions is only 32 bits in width.
    //

    if( shi502->shi502_permissions ) {
        securityDescriptor =
            (PSECURITY_DESCRIPTOR)((PCHAR)shi502 + shi502->shi502_permissions);
    }
    else
    {
        // Connect securityDescriptor is REQUIRED!
        return STATUS_INVALID_PARAMETER;
    }

    if ( !POINTER_IS_VALID( shi502->shi502_netname, shi502, BufferLength ) ||
         !POINTER_IS_VALID( shi502->shi502_remark, shi502, BufferLength ) ||
         !POINTER_IS_VALID( shi502->shi502_path, shi502, BufferLength ) ||
         !POINTER_IS_VALID( securityDescriptor, shi502, BufferLength ) ||
         !POINTER_IS_VALID( shi502->shi502_security_descriptor, shi502, BufferLength ) ) {

        return STATUS_ACCESS_VIOLATION;
    }


    //
    // Check the share type
    //

    isSpecial = (BOOLEAN)((shi502->shi502_type & STYPE_SPECIAL) != 0);

    isRemovable = FALSE;
    isCdrom = FALSE;

    switch ( shi502->shi502_type & ~(STYPE_TEMPORARY|STYPE_SPECIAL) ) {
    case STYPE_CDROM:

        isCdrom = TRUE;         // lack of break is intentional

    case STYPE_REMOVABLE:

        isRemovable = TRUE;     // lack of break is intentional

    case STYPE_DISKTREE:

        shareType = ShareTypeDisk;
        break;

    case STYPE_PRINTQ:

        shareType = ShareTypePrint;
        break;

    case STYPE_IPC:

        shareType = ShareTypePipe;
        break;

    default:

        //
        // An illegal share type was passed in.
        //

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvNetShareAdd: illegal share type: %ld\n",
                          shi502->shi502_type ));
        }

        Srp->Parameters.Set.ErrorParameter = SHARE_TYPE_PARMNUM;

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Get pointers to the share name, path, remark, and security
    // descriptor.
    //

    RtlInitUnicodeString( &shareName, (PWCH)shi502->shi502_netname );
    ntPath = Srp->Name1;
    RtlInitUnicodeString( &dosPath, (PWCH)shi502->shi502_path );
    RtlInitUnicodeString( &remark, (PWCH)shi502->shi502_remark );

    //
    // If this is level 502, get the file security descriptor
    //

    if ( Srp->Level == 502 ) {

        fileSecurityDescriptor = shi502->shi502_security_descriptor;

        //
        // if the sd is invalid, quit.
        //

        if ( fileSecurityDescriptor != NULL &&
             !RtlValidSecurityDescriptor( fileSecurityDescriptor) ) {

            Srp->Parameters.Set.ErrorParameter = SHARE_FILE_SD_PARMNUM;
            return STATUS_INVALID_PARAMETER;
        }

    }

    //
    // Allocate a share block.
    //

    SrvAllocateShare(
        &share,
        &shareName,
        &ntPath,
        &dosPath,
        &remark,
        securityDescriptor,
        fileSecurityDescriptor,
        shareType
        );

    if ( share == NULL ) {
        DEBUG KdPrint(( "SrvNetShareAdd: unable to allocate share block\n" ));
        return STATUS_INSUFF_SERVER_RESOURCES;
    }

    share->SpecialShare = isSpecial;
    share->Removable = isRemovable;

    //
    // Set the MaxUses field in the share.  The CurrentUses field was
    // zeroed by SrvAllocateShare.
    //

    share->MaxUses = shi502->shi502_max_uses;

    if ( shareType == ShareTypePrint ) {

        status = SrvOpenPrinter((PWCH)shi502->shi502_path,
                     &share->Type.hPrinter,
                     &Srp->ErrorCode
                     );

        if ( !NT_SUCCESS(status) ) {
            SrvFreeShare( share );
            return status;
        }

        if ( Srp->ErrorCode != NO_ERROR ) {
            SrvFreeShare( share );
            return STATUS_SUCCESS;
        }
    }

    //
    // Mark the share if it is in the DFS
    //
    SrvIsShareInDfs( share, &share->IsDfs, &share->IsDfsRoot );

    //
    // Ensure that another share with the same name doesn't already
    // exist.  Insert the share block in the global share list.
    //

    ACQUIRE_LOCK( &SrvShareLock );

    if ( SrvFindShare( &share->ShareName ) != NULL ) {

        //
        // A share with the same name exists.  Clean up and return an
        // error.
        //
        // *** Note that SrvFindShare ignores existing shares that are
        //     closing.  This allows a new share to be created even if
        //     and old share with the same name is in the "twilight
        //     zone" between existence and nonexistence because of a
        //     stray reference.
        //

        RELEASE_LOCK( &SrvShareLock );

        SrvFreeShare( share );

        Srp->ErrorCode = NERR_DuplicateShare;
        return STATUS_SUCCESS;
    }

    //
    // Insert the share on the global ordered list.
    //

    SrvAddShare( share );

    RELEASE_LOCK( &SrvShareLock );

    //
    // Is this is a removable type e.g. Floppy or CDROM, fill up the
    // file system name.
    //

    if ( isRemovable ) {

        PWSTR fileSystemName;
        ULONG fileSystemNameLength;

        if ( isCdrom ) {

            //
            // uses cdfs
            //

            fileSystemName = StrFsCdfs;
            fileSystemNameLength = sizeof( FS_CDFS ) - sizeof(WCHAR);

        } else {

            //
            // assume it's fat
            //

            fileSystemName = StrFsFat;
            fileSystemNameLength = sizeof( FS_FAT ) - sizeof(WCHAR);
        }


        SrvFillInFileSystemName(
                            share,
                            fileSystemName,
                            fileSystemNameLength
                            );

    }

    //
    // If this is an administrative disk share, update SrvDiskConfiguration
    // to cause the scavenger thread to check the disk free space.  The server
    // service has already verified that the format of the pathname is valid
    // before it allowed the ShareAdd to get this far.
    //
    // We want to skip this if its a \\?\ name
    //
    if( share->SpecialShare && share->ShareType == ShareTypeDisk &&
        share->ShareName.Buffer[1] == L'$' &&
        share->DosPathName.Buffer[0] != L'\\' ) {

        ACQUIRE_LOCK( &SrvConfigurationLock );
        SrvDiskConfiguration |= (0x80000000 >> (share->DosPathName.Buffer[0] - L'A'));
        RELEASE_LOCK( &SrvConfigurationLock );
    }

    //
    // Dereference the share block, because we're going to forget
    // its address.  (The initial reference count is 2.)
    //

    SrvDereferenceShare( share );

    return STATUS_SUCCESS;

} // SrvNetShareAdd


NTSTATUS
SrvNetShareDel (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine processes the NetShareDel API in the server.

Arguments:

    Srp - a pointer to the server request packet that contains all
        the information necessary to satisfy the request.  This includes:

      INPUT:

        Name1 - name of the share to delete.

      OUTPUT:

        None.

    Buffer - unused.

    BufferLength - unused.

Return Value:

    NTSTATUS - result of operation to return to the server service.

--*/

{
    PSHARE share;
    DWORD AdministrativeDiskBit = 0;
    BOOLEAN isPrintShare = FALSE;

    PAGED_CODE( );

    Buffer, BufferLength;

    //
    // Find the share with the specified name.  Note that if a share
    // with the specified name exists but is closing, it will not be
    // found.
    //

    ACQUIRE_LOCK( &SrvShareLock );

    share = SrvFindShare( &Srp->Name1 );

    if ( share == NULL ) {

        //
        // No share with the specified name exists.  Return an error.
        //

        RELEASE_LOCK( &SrvShareLock );

        Srp->ErrorCode = NERR_NetNameNotFound;
        return STATUS_SUCCESS;

    }

    //
    // Make sure the DFS state for this share is accurate
    //
    SrvIsShareInDfs( share, &share->IsDfs, &share->IsDfsRoot );

    //
    // If the share really is in the DFS, then do not allow it to be deleted
    //
    if( share->IsDfs == TRUE ) {

        RELEASE_LOCK( &SrvShareLock );

        IF_DEBUG( DFS ) {
            KdPrint(("NetShareDel attempted on share in DFS!\n" ));
        }

        Srp->ErrorCode = NERR_IsDfsShare;

        return STATUS_SUCCESS;
    }

    // Don't allow the deletion of IPC$, as behavior is very bad with it gone
    // (Named-pipe traffic doesn't work, so NetAPI's and RPC don't work..)
    if( share->SpecialShare )
    {
        UNICODE_STRING Ipc = { 8, 8, L"IPC$" };

        if( RtlCompareUnicodeString( &Ipc, &share->ShareName, TRUE ) == 0 )
        {
            RELEASE_LOCK( &SrvShareLock );

            Srp->ErrorCode = ERROR_ACCESS_DENIED;

            return STATUS_SUCCESS;
        }
    }


    switch( share->ShareType ) {
    case ShareTypePrint:
        //
        // This is a print share
        // Don't close the printer here because we have the ShareLock acquired,
        // and it can cause some strange deadlocks because it involves calling up
        // to usermode, and then calling over to Spooler, etc.  This can take a long time
        //
        isPrintShare = TRUE;

        // Reference the share so it doesn't go away at SrvCloseShare time
        SrvReferenceShare( share );
        break;

    case ShareTypeDisk:
        //
        // See if this was an administrative disk share
        //
        if( share->SpecialShare && share->DosPathName.Buffer[1] == L'$' ) {
            AdministrativeDiskBit = (0x80000000 >> (share->DosPathName.Buffer[0] - L'A'));
        }

        break;
    }

    SrvCloseShare( share );

    RELEASE_LOCK( &SrvShareLock );

    // If it was a print share, we need to close the printer now that we've released the lock
    if( isPrintShare )
    {
        SrvClosePrinter( share->Type.hPrinter );
        SrvDereferenceShare( share );
    }

    //
    // If this was an administrative disk share, update SrvDiskConfiguration
    // to cause the scavenger thread to ignore this disk.
    //
    if( AdministrativeDiskBit ) {
        ACQUIRE_LOCK( &SrvConfigurationLock );
        SrvDiskConfiguration &= ~AdministrativeDiskBit;
        RELEASE_LOCK( &SrvConfigurationLock );
    }

    return STATUS_SUCCESS;

} // SrvNetShareDel


NTSTATUS
SrvNetShareEnum (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine processes the NetShareEnum API in the server.

Arguments:

    Srp - a pointer to the server request packet that contains all
        the information necessary to satisfy the request.  This includes:

      INPUT:

        Level - level of information to return, 0, 1, or 2.

        Parameters.Get.ResumeHandle - share ID to determine where to
            start returning info.  We start with the first share with an
            ID greater than this value.

      OUTPUT:

        Parameters.Get.EntriesRead - the number of entries that fit in
            the output buffer.

        Parameters.Get.TotalEntries - the total number of entries that
            would be returned with a large enough buffer.

        Parameters.Get.TotalBytesNeeded - the buffer size that would be
            required to hold all the entries.

        Parameters.Get.ResumeHandle - share ID of last share returned.

    Buffer - a pointer to the buffer for results.

    BufferLength - the length of this buffer.

Return Value:

    NTSTATUS - result of operation to return to the server service.

--*/

{
    PAGED_CODE( );

    return SrvShareEnumApiHandler(
               Srp,
               Buffer,
               BufferLength,
               FilterShares,
               SizeShares,
               FillShareInfoBuffer
               );

} // SrvNetShareEnum


NTSTATUS
SrvNetShareSetInfo (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine processes the NetShareSetInfo API in the server.

Arguments:

    Srp - a pointer to the server request packet that contains all
        the information necessary to satisfy the request.  This includes:

      INPUT:

        Name1 - name of the share to set information on.

        Parameters.Set.Api.ShareInfo.MaxUses - if not 0, a new maximum
            user count.  If the current count of users on the share
            exceeds the new value, no check is made, but no new
            tree connects are allowed.

      OUTPUT:

        Parameters.Set.ErrorParameter - if ERROR_INVALID_PARAMETER is
            returned, this contains the index of the parameter in error.

    Buffer - a pointer to a SHARE_INFO_502 structure.

    BufferLength - length of this buffer.

Return Value:

    NTSTATUS - result of operation to return to the user.

--*/

{
    PSHARE share;
    UNICODE_STRING remark;
    PWCH newRemarkBuffer = NULL;
    ULONG maxUses;
    ULONG level;
    PSHARE_INFO_502 shi502;
    PSECURITY_DESCRIPTOR fileSD;
    PSECURITY_DESCRIPTOR securityDescriptor = NULL;

    PAGED_CODE( );

    //
    // Convert the offsets in the share data structure to pointers.  Also
    // make sure that all the pointers are within the specified buffer.
    //

    level = Srp->Level;

    switch( level ) {
    default:

        shi502 = Buffer;

        if( shi502->shi502_permissions ) {
            securityDescriptor =
                (PSECURITY_DESCRIPTOR)((PCHAR)shi502 + shi502->shi502_permissions);
        }

        OFFSET_TO_POINTER( shi502->shi502_netname, shi502 );
        OFFSET_TO_POINTER( shi502->shi502_remark, shi502 );
        OFFSET_TO_POINTER( shi502->shi502_path, shi502 );
        OFFSET_TO_POINTER( shi502->shi502_security_descriptor, shi502 );

        if ( !POINTER_IS_VALID( shi502->shi502_netname, shi502, BufferLength ) ||
             !POINTER_IS_VALID( shi502->shi502_remark, shi502, BufferLength ) ||
             !POINTER_IS_VALID( shi502->shi502_path, shi502, BufferLength ) ||
             !POINTER_IS_VALID( securityDescriptor, shi502, BufferLength ) ||
             !POINTER_IS_VALID( shi502->shi502_security_descriptor, shi502, BufferLength ) ) {

            return STATUS_ACCESS_VIOLATION;
        }

        break;

    case 1005:
        break;
    }

    //
    // Acquire the lock that protects the share list and attempt to find
    // the correct share.
    //

    ACQUIRE_LOCK( &SrvShareLock );

    share = SrvFindShare( &Srp->Name1 );

    if ( share == NULL ) {
        IF_DEBUG(API_ERRORS) {
            KdPrint(( "SrvNetShareSetInfo: share %wZ not found.\n",
                          &Srp->Name1 ));
        }
        RELEASE_LOCK( &SrvShareLock );
        Srp->ErrorCode = NERR_NetNameNotFound;
        return STATUS_SUCCESS;
    }

    if( level == 1005 ) {

        if( share->ShareType != ShareTypeDisk ) {
            Srp->Parameters.Set.ErrorParameter = 0;
            Srp->ErrorCode = ERROR_BAD_DEV_TYPE;
        } else {
            PSHARE_INFO_1005 shi1005 = Buffer;

            share->CSCState = shi1005->shi1005_flags & CSC_MASK;
            share->ShareProperties = (shi1005->shi1005_flags & ~CSC_MASK);

            Srp->ErrorCode = 0;
        }

        RELEASE_LOCK( &SrvShareLock );
        return STATUS_SUCCESS;
    }

    //
    // Set up local variables.
    //

    maxUses = Srp->Parameters.Set.Api.ShareInfo.MaxUses;

    //
    // If a remark was specified, allocate space for a new remark and
    // copy over the remark.
    //

    if ( ARGUMENT_PRESENT( shi502->shi502_remark ) ) {

        RtlInitUnicodeString( &remark, shi502->shi502_remark );

        newRemarkBuffer = ALLOCATE_HEAP_COLD(
                            remark.MaximumLength,
                            BlockTypeDataBuffer
                            );

        if ( newRemarkBuffer == NULL ) {

            RELEASE_LOCK( &SrvShareLock );

            INTERNAL_ERROR(
                ERROR_LEVEL_EXPECTED,
                "SrvNetShareSetInfo: unable to allocate %ld bytes of heap.\n",
                remark.MaximumLength,
                NULL
                );

            Srp->Parameters.Set.ErrorParameter = SHARE_REMARK_PARMNUM;
            return STATUS_INSUFF_SERVER_RESOURCES;
        }
    }

    //
    // If a file security descriptor was specified, allocate space for a
    // new SD and copy over the new SD.  We do this before setting the
    // MaxUses in case the allocation fails and we have to back out.
    //
    // Don't let a file ACL be specified for admin shares.
    //

    fileSD = shi502->shi502_security_descriptor;

    if ( ((level == 502) || (level == SHARE_FILE_SD_INFOLEVEL)) &&
            ARGUMENT_PRESENT( fileSD ) ) {

        PSECURITY_DESCRIPTOR newFileSD;
        ULONG newFileSDLength;

        if ( share->SpecialShare || !RtlValidSecurityDescriptor( fileSD ) ) {
            RELEASE_LOCK( &SrvShareLock );
            if ( newRemarkBuffer != NULL) {
                FREE_HEAP( newRemarkBuffer );
            }
            Srp->Parameters.Set.ErrorParameter = SHARE_FILE_SD_PARMNUM;
            return STATUS_INVALID_PARAMETER;
        }

        newFileSDLength = RtlLengthSecurityDescriptor( fileSD );

        newFileSD = ALLOCATE_HEAP_COLD(
                            newFileSDLength,
                            BlockTypeDataBuffer
                            );

        if ( newFileSD == NULL ) {

            RELEASE_LOCK( &SrvShareLock );

            INTERNAL_ERROR(
                ERROR_LEVEL_EXPECTED,
                "SrvNetShareSetInfo: unable to allocate %ld bytes of heap.\n",
                newFileSDLength,
                NULL
                );

            Srp->Parameters.Set.ErrorParameter = SHARE_FILE_SD_PARMNUM;

            //
            // Free the remarks buffer allocated
            //

            if ( newRemarkBuffer != NULL) {
                FREE_HEAP( newRemarkBuffer );
            }

            return STATUS_INSUFF_SERVER_RESOURCES;
        }

        ACQUIRE_LOCK( share->SecurityDescriptorLock );

        //
        // Free the old security descriptor
        //

        if ( share->FileSecurityDescriptor != NULL ) {
            FREE_HEAP( share->FileSecurityDescriptor );
        }

        //
        // And set up the new one.
        //

        share->FileSecurityDescriptor = newFileSD;
        RtlCopyMemory(
                share->FileSecurityDescriptor,
                fileSD,
                newFileSDLength
                );

        RELEASE_LOCK( share->SecurityDescriptorLock );
    }

    //
    // Replace the old remark if a new one was specified.
    //

    if ( newRemarkBuffer != NULL ) {

        //
        // Free the old remark buffer.
        //

        if ( share->Remark.Buffer != NULL ) {
            FREE_HEAP( share->Remark.Buffer );
        }

        //
        // And set up the new one.
        //

        share->Remark.Buffer = newRemarkBuffer;
        share->Remark.MaximumLength = remark.MaximumLength;
        RtlCopyUnicodeString( &share->Remark, &remark );

    }

    //
    // If MaxUses was specified, set the new value.
    //

    if ( maxUses != 0 ) {
        share->MaxUses = maxUses;
    }

    //
    // Release the share lock.
    //

    RELEASE_LOCK( &SrvShareLock );

    //
    // Set up the error parameter to 0 (no error) and return.
    //

    Srp->Parameters.Set.ErrorParameter = 0;

    return STATUS_SUCCESS;

} // SrvNetShareSetInfo


VOID
FillShareInfoBuffer (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block,
    IN OUT PVOID *FixedStructure,
    IN LPWSTR *EndOfVariableData
    )

/*++

Routine Description:

    This routine puts a single fixed share structure and, if it fits,
    associated variable data, into a buffer.  Fixed data goes at the
    beginning of the buffer, variable data at the end.

Arguments:

    Level - the level of information to copy from the share.

    Block - the share from which to get information.

    FixedStructure - where the ine buffer to place the fixed structure.
        This pointer is updated to point to the next available
        position for a fixed structure.

    EndOfVariableData - the last position on the buffer that variable
        data for this structure can occupy.  The actual variable data
        is written before this position as long as it won't overwrite
        fixed structures.  It is would overwrite fixed structures, it
        is not written.

Return Value:

    None.

--*/

{

    PSHARE share = Block;
    PSHARE_INFO_501 shi501 = *FixedStructure;
    PSHARE_INFO_502 shi502 = *FixedStructure;
    PSHARE_INFO_1005 shi1005 = *FixedStructure;

    PAGED_CODE( );

    //
    // Update FixedStructure to point to the next structure
    // location.
    //

    *FixedStructure = (PCHAR)*FixedStructure + FIXED_SIZE_OF_SHARE( Srp->Level );
    ASSERT( (ULONG_PTR)*EndOfVariableData >= (ULONG_PTR)*FixedStructure );

    //
    // Case on the level to fill in the fixed structure appropriately.
    // We fill in actual pointers in the output structure.  This is
    // possible because we are in the server FSD, hence the server
    // service's process and address space.
    //
    // *** This routine assumes that the fixed structure will fit in the
    //     buffer!
    //
    // *** Using the switch statement in this fashion relies on the fact
    //     that the first fields on the different share structures are
    //     identical.
    //

    switch( Srp->Level ) {
    case 1005:
        shi1005->shi1005_flags = 0;

        if( share->IsDfs ) {
            shi1005->shi1005_flags |= SHI1005_FLAGS_DFS;
        }
        if( share->IsDfsRoot ) {
            shi1005->shi1005_flags |= SHI1005_FLAGS_DFS_ROOT;
        }

        shi1005->shi1005_flags |= share->ShareProperties;
        shi1005->shi1005_flags |= share->CSCState;
        break;

    case 502:

        ACQUIRE_LOCK_SHARED( share->SecurityDescriptorLock );

        if ( share->FileSecurityDescriptor != NULL ) {

            ULONG fileSDLength;
            fileSDLength =
                RtlLengthSecurityDescriptor( share->FileSecurityDescriptor );


            //
            // DWord Align
            //

            *EndOfVariableData = (LPWSTR) ( (ULONG_PTR) ((PCHAR) *EndOfVariableData -
                            fileSDLength ) & ~3 );

            shi502->shi502_security_descriptor = *EndOfVariableData;
            shi502->shi502_reserved  = fileSDLength;

            RtlCopyMemory(
                    shi502->shi502_security_descriptor,
                    share->FileSecurityDescriptor,
                    fileSDLength
                    );

        } else {
            shi502->shi502_security_descriptor = NULL;
            shi502->shi502_reserved = 0;
        }

        RELEASE_LOCK( share->SecurityDescriptorLock );

    case 2:

        //
        // Set level 2 specific fields in the buffer.  Since this server
        // can only have user-level security, share permissions are
        // meaningless.
        //

        shi502->shi502_permissions = 0;
        shi502->shi502_max_uses = share->MaxUses;
        shi502->shi502_current_uses = share->CurrentUses;

        //
        // Copy the DOS path name to the buffer.
        //

        SrvCopyUnicodeStringToBuffer(
            &share->DosPathName,
            *FixedStructure,
            EndOfVariableData,
            &shi502->shi502_path
            );

        //
        // We don't have per-share passwords (share-level security)
        // so set the password pointer to NULL.
        //

        shi502->shi502_passwd = NULL;

        // *** Lack of break is intentional!

    case 501:

        if( Srp->Level == 501 ) {
            shi501->shi501_flags = share->CSCState;
        }

        // *** Lack of break is intentional!

    case 1:

        //
        // Convert the server's internal representation of share types
        // to the expected format.
        //

        switch ( share->ShareType ) {

        case ShareTypeDisk:

            shi502->shi502_type = STYPE_DISKTREE;
            break;

        case ShareTypePrint:

            shi502->shi502_type = STYPE_PRINTQ;
            break;

        case ShareTypePipe:

            shi502->shi502_type = STYPE_IPC;
            break;

        default:

            //
            // This should never happen.  It means that somebody
            // stomped on the share block.
            //

            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "FillShareInfoBuffer: invalid share type in share: %ld",
                share->ShareType,
                NULL
                );

            shi502->shi502_type = 0;

        }

        if ( share->SpecialShare ) {
            shi502->shi502_type |= STYPE_SPECIAL;
        }
        //
        // Copy the remark to the buffer.  The routine will handle the
        // case where there is no remark on the share and put a pointer
        // to a zero terminator in the buffer.
        //
        // *** We hold the share lock to keep SrvNetShareSetInfo from
        //     changing the remark during the copy.  (Changing the
        //     remark can result in different storage being allocated.)
        //

        SrvCopyUnicodeStringToBuffer(
            &share->Remark,
            *FixedStructure,
            EndOfVariableData,
            &shi502->shi502_remark
            );

        // *** Lack of break is intentional!

    case 0:

        //
        // Copy the share name to the buffer.
        //

        SrvCopyUnicodeStringToBuffer(
            &share->ShareName,
            *FixedStructure,
            EndOfVariableData,
            &shi502->shi502_netname
            );

        break;

    default:

        //
        // This should never happen.  The server service should have
        // checked for an invalid level.
        //

        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "FillShareInfoBuffer: invalid level number: %ld",
            Srp->Level,
            NULL
            );

    }

    return;

} // FillShareInfoBuffer


BOOLEAN
FilterShares (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    )

/*++

Routine Description:

    This routine is intended to be called by SrvEnumApiHandler to check
    whether a particular share should be returned.

Arguments:

    Srp - a pointer to the SRP for the operation.  Name1 ("netname"
        on NetShareGetInfo) is used to do the filtering.

    Block - a pointer to the share to check.

Return Value:

    TRUE if the block should be placed in the output buffer, FALSE
        if it should be passed over.

--*/

{
    PSHARE share = Block;

    PAGED_CODE( );

    //
    // If this share is being deleted, than we should not let it be enumerated
    //
    if( GET_BLOCK_STATE(share) == BlockStateClosing )
    {
        return FALSE;
    }

    //
    // If this is an Enum, then we definitely want the share.  An Enum
    // leaves the net name blank; a get info sets the name to the share
    // name on which to return info.
    //

    if ( Srp->Name1.Length == 0 ) {
        return TRUE;
    }

    //
    // This is a get info; use the share only if the share name matches
    // the Name1 field of the SRP.
    //

    return RtlEqualUnicodeString(
               &Srp->Name1,
               &share->ShareName,
               TRUE
               );

} // FilterShares


ULONG
SizeShares (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    )

/*++

Routine Description:

    This routine returns the size the passed-in share would take up in
    an API output buffer.

Arguments:

    Srp - a pointer to the SRP for the operation.  Only the Level
        parameter is used.

    Block - a pointer to the share to size.

Return Value:

    ULONG - The number of bytes the share would take up in the
        output buffer.

--*/

{
    PSHARE share = Block;
    ULONG shareSize = 0;

    PAGED_CODE( );

    switch ( Srp->Level ) {
    case 502:
        ACQUIRE_LOCK_SHARED( share->SecurityDescriptorLock );

        if ( share->FileSecurityDescriptor != NULL ) {

            //
            // add 4 bytes for possible padding
            //

            shareSize = sizeof( ULONG ) +
                RtlLengthSecurityDescriptor( share->FileSecurityDescriptor );
        }

        RELEASE_LOCK( share->SecurityDescriptorLock );

    case 2:
        shareSize += SrvLengthOfStringInApiBuffer(&share->DosPathName);

    case 501:
    case 1:
        shareSize += SrvLengthOfStringInApiBuffer(&share->Remark);

    case 0:
        shareSize += SrvLengthOfStringInApiBuffer(&share->ShareName);

    }

    return ( shareSize + FIXED_SIZE_OF_SHARE( Srp->Level ) );

} // SizeShares
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\svcsess.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    svcsess.c

Abstract:

    This module contains routines for supporting the session APIs in the
    server service, SrvNetSessionDel, SrvNetSessionEnum and
    SrvNetSessionGetInfo.

Author:

    David Treadwell (davidtr) 31-Jan-1991

Revision History:

--*/

#include "precomp.h"
#include "svcsess.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_SVCSESS

//
// defined in scavengr.c
//

VOID
UpdateSessionLastUseTime(
    IN PLARGE_INTEGER CurrentTime
    );

//
// Forward declarations.
//

VOID
FillSessionInfoBuffer (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block,
    IN OUT PVOID *FixedStructure,
    IN LPWSTR *EndOfVariableData
    );

BOOLEAN
FilterSessions (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    );

ULONG
SizeSessions (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvNetSessionDel )
#pragma alloc_text( PAGE, SrvNetSessionEnum )
#pragma alloc_text( PAGE, FillSessionInfoBuffer )
#pragma alloc_text( PAGE, FilterSessions )
#pragma alloc_text( PAGE, SizeSessions )
#endif

//
// Macros to determine the size a session would take up at one of the
// levels of session information.
//

#define FIXED_SIZE_OF_SESSION(level)                  \
    ( (level) == 0  ? sizeof(SESSION_INFO_0)  :       \
      (level) == 1  ? sizeof(SESSION_INFO_1)  :       \
      (level) == 2  ? sizeof(SESSION_INFO_2)  :       \
      (level) == 10 ? sizeof(SESSION_INFO_10) :       \
                      sizeof(SESSION_INFO_502) )

NTSTATUS
SrvNetSessionDel (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    )
/*++

Routine Description:

    This routine processes the NetSessionEnum API in the server FSP.
    It must run in the FSP because in order to close the session it must
    use the endpoint handle to force the TDI connection closed.

    Either the client name or user name must be specified, and it is
    legal to specify both.  If only the computer name is specified, then
    the VC gets closed.  If only the user name is specified, then all
    that users sessions are closed.  If both are specified, then the
    particular user session is closed.

Arguments:

    Srp - a pointer to the server request packet that contains all
        the information necessary to satisfy the request.  This includes:

      INPUT:

        Name1 - name of the client computer whose session we should
            delete.

        Name2 - name of the user whose session we should delete.

      OUTPUT:

        None.

    Buffer - unused.

    BufferLength - unused.

Return Value:

    NTSTATUS - result of operation to return to the server service.

--*/

{
    BOOLEAN foundSession = FALSE;
    PSESSION session;

    PAGED_CODE( );

    Buffer, BufferLength;

    //
    // Walk the ordered list, finding matching entries.
    //

    session = SrvFindEntryInOrderedList(
                &SrvSessionList,
                (PFILTER_ROUTINE)FilterSessions,
                Srp,
                (ULONG)-1,
                FALSE,
                NULL );

    while ( session != NULL ) {

        foundSession = TRUE;

        //
        // If a computer name was specified but not a user name, then
        // we're supposed to blow away the VC.  Close the connection.
        //

        if ( Srp->Name1.Buffer != NULL && Srp->Name2.Buffer == NULL ) {

#if SRVDBG29
            UpdateConnectionHistory( "SDL1", session->Connection->Endpoint, session->Connection );
#endif
            session->Connection->DisconnectReason = DisconnectSessionDeleted;
            SrvCloseConnection( session->Connection, FALSE );

        } else {

            //
            // We want to close a user on the connection.  Close that
            // session, then if there are no longer any sessions on the
            // connection, close the connection.
            //
            // Increment the count of sessions that have been logged off
            // normally.
            //

            SrvStatistics.SessionsLoggedOff++;
            SrvCloseSession( session );
            if ( session->Connection->CurrentNumberOfSessions == 0 ) {
#if SRVDBG29
                UpdateConnectionHistory( "SDL2", session->Connection->Endpoint, session->Connection );
#endif
                session->Connection->DisconnectReason = DisconnectSessionDeleted;
                SrvCloseConnection( session->Connection, FALSE );
            }

        }

        //
        // Find the next session that matches.  This will dereference the
        // current session.
        //

        do {

            session =
                SrvFindNextEntryInOrderedList( &SrvSessionList, session );

        } while ( (session != NULL) && !FilterSessions( Srp, session ) );

    }

    if ( foundSession ) {
        return STATUS_SUCCESS;
    }

    Srp->ErrorCode = NERR_ClientNameNotFound;
    return STATUS_SUCCESS;

} // SrvNetSessionDel


NTSTATUS
SrvNetSessionEnum (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine processes the NetSessionEnum API in the server.

Arguments:

    Srp - a pointer to the server request packet that contains all
        the information necessary to satisfy the request.  This includes:

      INPUT:

        Level - level of information to return, 0, 1, or 2.

        Name1 - a client machine name to filter on, if any.

        Name2 - a user name to filter on, if any.


      OUTPUT:

        Parameters.Get.EntriesRead - the number of entries that fit in
            the output buffer.

        Parameters.Get.TotalEntries - the total number of entries that
            would be returned with a large enough buffer.

        Parameters.Get.TotalBytesNeeded - the buffer size that would be
            required to hold all the entries.

    Buffer - a pointer to the buffer for results.

    BufferLength - the length of this buffer.

Return Value:

    NTSTATUS - result of operation to return to the server service.

--*/

{
    LARGE_INTEGER currentTime;

    PAGED_CODE( );

    //
    // See if we need to update the session last use time
    //

    KeQuerySystemTime( &currentTime );
    UpdateSessionLastUseTime( &currentTime );

    return SrvEnumApiHandler(
               Srp,
               Buffer,
               BufferLength,
               &SrvSessionList,
               FilterSessions,
               SizeSessions,
               FillSessionInfoBuffer
               );

} // SrvNetSessionEnum


VOID
FillSessionInfoBuffer (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block,
    IN OUT PVOID *FixedStructure,
    IN LPWSTR *EndOfVariableData
    )

/*++

Routine Description:

    This routine puts a single fixed file structure and associated
    variable data, into a buffer.  Fixed data goes at the beginning of
    the buffer, variable data at the end.

    *** This routine assumes that ALL the data, both fixed and variable,
        will fit.

Arguments:

    Srp - a pointer to the SRP for the operation.  Only the Level
        field is used.

    Block - the Session from which to get information.

    FixedStructure - where the in the buffer to place the fixed structure.
        This pointer is updated to point to the next available
        position for a fixed structure.

    EndOfVariableData - the last position on the buffer that variable
        data for this structure can occupy.  The actual variable data
        is written before this position as long as it won't overwrite
        fixed structures.  It is would overwrite fixed structures, it
        is not written.

Return Value:

    None.

--*/

{
    PSESSION_INFO_502 sesi502 = *FixedStructure;
    PSESSION_INFO_2 sesi2 = *FixedStructure;
    PSESSION_INFO_10 sesi10 = *FixedStructure;
    PSESSION session = Block;
    UNICODE_STRING machineNameString;
    UNICODE_STRING userName;
    PPAGED_CONNECTION pagedConnection;

    LARGE_INTEGER currentTime;
    ULONG currentSecondsSince1980;
    ULONG startTimeInSecondsSince1980;
    ULONG secondsAlive;
    ULONG lastUseTimeInSecondsSince1980;
    ULONG secondsIdle;

    PAGED_CODE();

    //
    // Get the current time and use this to determine how long the
    // connection has been alive and how long it has been idle.
    //

    KeQuerySystemTime( &currentTime );

    RtlTimeToSecondsSince1980(
        &currentTime,
        &currentSecondsSince1980
        );

    RtlTimeToSecondsSince1980(
        &session->StartTime,
        &startTimeInSecondsSince1980
        );

    RtlTimeToSecondsSince1980(
        &session->LastUseTime,
        &lastUseTimeInSecondsSince1980
        );

    secondsAlive = currentSecondsSince1980 - startTimeInSecondsSince1980;
    secondsIdle = currentSecondsSince1980 - lastUseTimeInSecondsSince1980;

    //
    // Update FixedStructure to point to the next structure location.
    //

    *FixedStructure = (PCHAR)*FixedStructure +
                          FIXED_SIZE_OF_SESSION( Srp->Level );
    ASSERT( (ULONG_PTR)*EndOfVariableData >= (ULONG_PTR)*FixedStructure );

    //
    // We'll return a machine name that does not contain the leading
    // backslashes.
    //
    pagedConnection = session->Connection->PagedConnection;

    machineNameString.Buffer = session->Connection->ClientMachineName;
    machineNameString.Length =
        (USHORT)( session->Connection->ClientMachineNameString.Length -
                    (sizeof(WCHAR) * 2) );

    //
    // Case on the level to fill in the fixed structure appropriately.
    // We fill in actual pointers in the output structure.  This is
    // possible because we are in the server FSD, hence the server
    // service's process and address space.
    //
    // *** Using the switch statement in this fashion relies on the fact
    //     that the first fields on the different session structures are
    //     identical (with the exception of level 10, which is handled
    //     separately).
    //

    switch( Srp->Level ) {

    case 502:

        //
        // Copy the transport string to the output buffer.
        //

        SrvCopyUnicodeStringToBuffer(
            &session->Connection->Endpoint->TransportName,
            *FixedStructure,
            EndOfVariableData,
            &sesi502->sesi502_transport
            );

        // *** lack of break is intentional!

    case 2:

        //
        // Copy the client type string to the output buffer.
        //

        SrvCopyUnicodeStringToBuffer(
            session->Connection->ClientOSType.Buffer != NULL ?
                &session->Connection->ClientOSType :
                &SrvClientTypes[session->Connection->SmbDialect],
            *FixedStructure,
            EndOfVariableData,
            &sesi2->sesi2_cltype_name
            );

        // *** lack of break is intentional!

    case 1:

        //
        // Copy the user name to the output buffer.
        //

        SrvGetUserAndDomainName( session, &userName, NULL );

        SrvCopyUnicodeStringToBuffer(
            &userName,
            *FixedStructure,
            EndOfVariableData,
            &sesi2->sesi2_username
            );

        if( userName.Buffer ) {
            SrvReleaseUserAndDomainName( session, &userName, NULL );
        }

        //
        // Set up other fields.
        //

        //
        // Return the number of files open over this session, taking care
        //  not to count those in the RFCB cache (since the RFCB cache should
        //  be transparent to users and administrators.
        //

        sesi2->sesi2_num_opens = session->CurrentFileOpenCount;

        if( sesi2->sesi2_num_opens > 0 ) {

            ULONG count = SrvCountCachedRfcbsForUid( session->Connection, session->Uid );

            if( sesi2->sesi2_num_opens > count ) {
                sesi2->sesi2_num_opens -= count;
            } else {
                sesi2->sesi2_num_opens = 0;
            }
        }

        sesi2->sesi2_time = secondsAlive;
        sesi2->sesi2_idle_time = secondsIdle;

        //
        // Set up the user flags.
        //

        sesi2->sesi2_user_flags = 0;

        if ( session->GuestLogon ) {
            sesi2->sesi2_user_flags |= SESS_GUEST;
        }

        if ( !session->EncryptedLogon ) {
            sesi2->sesi2_user_flags |= SESS_NOENCRYPTION;
        }

        // *** lack of break is intentional!

    case 0:

        //
        // Set up the client machine name in the output buffer.
        //

        SrvCopyUnicodeStringToBuffer(
            &machineNameString,
            *FixedStructure,
            EndOfVariableData,
            &sesi2->sesi2_cname
            );

        break;

    case 10:

        //
        // Set up the client machine name and user name in the output
        // buffer.
        //

        SrvCopyUnicodeStringToBuffer(
            &machineNameString,
            *FixedStructure,
            EndOfVariableData,
            &sesi10->sesi10_cname
            );

        SrvGetUserAndDomainName( session, &userName, NULL );

        SrvCopyUnicodeStringToBuffer(
            &userName,
            *FixedStructure,
            EndOfVariableData,
            &sesi10->sesi10_username
            );

        if( userName.Buffer ) {
            SrvReleaseUserAndDomainName( session, &userName, NULL );
        }

        //
        // Set up other fields.
        //

        sesi10->sesi10_time = secondsAlive;
        sesi10->sesi10_idle_time = secondsIdle;

        break;

    default:

        //
        // This should never happen.  The server service should have
        // checked for an invalid level.
        //

        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "FillSessionInfoBuffer: invalid level number: %ld",
            Srp->Level,
            NULL
            );

        SrvLogInvalidSmb( NULL );
    }

    return;

} // FillSessionInfoBuffer


BOOLEAN
FilterSessions (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    )

/*++

Routine Description:

    This routine is intended to be called by SrvEnumApiHandler to check
    whether a particular session should be returned.

Arguments:

    Srp - a pointer to the SRP for the operation.  Name1 is the client
        name, Name2 is the user name.

    Block - a pointer to the session to check.

Return Value:

    TRUE if the block should be placed in the output buffer, FALSE
        if it should be passed over.

--*/

{
    PSESSION session = Block;
    UNICODE_STRING userName;

    PAGED_CODE( );

    //
    // If there was a client name passed in the NetSessionEnum API,
    // check whether it matches the client name on the connection
    // corresponding to the session.
    //

    if ( Srp->Name1.Length > 0 ) {

        if ( !RtlEqualUnicodeString(
                  &Srp->Name1,
                  &session->Connection->ClientMachineNameString,
                  TRUE ) ) {

            return FALSE;
        }
    }

    //
    // If there was a user name passed in the NetSessionEnum API,
    // check whether it matches the user name on the session.
    //

    if ( Srp->Name2.Length > 0 ) {

        SrvGetUserAndDomainName( session, &userName, NULL );
        if( userName.Buffer == NULL ) {
            return FALSE;
        }

        if ( !RtlEqualUnicodeString(
                  &Srp->Name2,
                  &userName,
                  TRUE ) ) {

            SrvReleaseUserAndDomainName( session, &userName, NULL );
            return FALSE;
        }

        SrvReleaseUserAndDomainName( session, &userName, NULL );
    }

    //
    // The session passed both tests.  Put it in the output buffer.
    //

    return TRUE;

} // FilterSessions


ULONG
SizeSessions (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    )

/*++

Routine Description:

    This routine returns the size the passed-in session would take up
    in an API output buffer.

Arguments:

    Srp - a pointer to the SRP for the operation.  Only the level
        parameter is used.

    Block - a pointer to the session to size.

Return Value:

    ULONG - The number of bytes the session would take up in the output
        buffer.

--*/

{
    PSESSION session = Block;
    PCONNECTION connection = session->Connection;
    ULONG size;
    UNICODE_STRING userName;

    PAGED_CODE( );

    size = SrvLengthOfStringInApiBuffer(
                    &connection->ClientMachineNameString
                    );

    if ( Srp->Level > 0 ) {
        SrvGetUserAndDomainName( session, &userName, NULL );
        if( userName.Buffer != NULL ) {
            size += SrvLengthOfStringInApiBuffer(&userName);
            SrvReleaseUserAndDomainName( session, &userName, NULL );
        }
    }

    switch ( Srp->Level ) {
    case 0:
        size += sizeof(SESSION_INFO_0);
        break;

    case 1:
        size += sizeof(SESSION_INFO_1);
        break;

    case 2:
        size += sizeof( SESSION_INFO_2 );

        if( connection->ClientOSType.Buffer != NULL ) {
            size += SrvLengthOfStringInApiBuffer( &connection->ClientOSType );
        } else {
            size += SrvLengthOfStringInApiBuffer( &SrvClientTypes[ connection->SmbDialect ] );
        }

        break;

    case 10:
        size += sizeof(SESSION_INFO_10);
        break;

    case 502:
        size += sizeof(SESSION_INFO_502) +
                SrvLengthOfStringInApiBuffer(
                    &connection->Endpoint->TransportName
                    );

        if( connection->ClientOSType.Buffer != NULL ) {
            size += SrvLengthOfStringInApiBuffer( &connection->ClientOSType );
        } else {
            size += SrvLengthOfStringInApiBuffer( &SrvClientTypes[ connection->SmbDialect ] );
        }

        break;

    }

    return size;

} // SizeSessions
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\svcstats.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    svcstats.c

Abstract:

    This module contains routines for supporting the NetStatisticsGet.

Author:

    David Treadwell (davidtr) 12-Apr-1991

Revision History:

--*/

#include "precomp.h"
#include "svcstats.tmh"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvNetStatisticsGet )
#endif


NTSTATUS
SrvNetStatisticsGet (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine processes the server half of NetStatisticsGet in
    the server FSD.

Arguments:

    Srp - a pointer to the server request packet that contains all
        the information necessary to satisfy the request.  This includes:

      INPUT:

        Flags - MBZ

      OUTPUT:

        Not used.

    Buffer - a pointer to a STAT_SERVER_0 structure for the new share.

    BufferLength - total length of this buffer.

Return Value:

    NTSTATUS - result of operation to return to the server service.

--*/

{
    SRV_STATISTICS capturedStats;
    PSTAT_SERVER_0 sts0 = Buffer;
    NTSTATUS status;

    PAGED_CODE( );

    //
    // Make sure that the user's buffer is large enough.
    //

    if ( BufferLength < sizeof(STAT_SERVER_0) ) {
        Srp->ErrorCode = NERR_BufTooSmall;
        return STATUS_SUCCESS;
    }

    //
    // Indicate in the SRP that we read one stucture.  We always read
    // exactly one structure for this API.
    //

    Srp->Parameters.Get.EntriesRead = 1;

    //
    // Get a copy of the latest server statistics.
    //

    SrvUpdateStatisticsFromQueues( &capturedStats );

    //
    // Fill in the fields in the statistics structure.
    //

    try {

        RtlTimeToSecondsSince1970(
            &capturedStats.StatisticsStartTime,
            &sts0->sts0_start
            );

        sts0->sts0_fopens = capturedStats.TotalFilesOpened;
        sts0->sts0_devopens = 0;
        sts0->sts0_jobsqueued = 0;
        sts0->sts0_sopens = capturedStats.CurrentNumberOfSessions;
        sts0->sts0_stimedout = capturedStats.SessionsTimedOut;
        sts0->sts0_serrorout = capturedStats.SessionsErroredOut;
        sts0->sts0_pwerrors = capturedStats.LogonErrors;
        sts0->sts0_permerrors = capturedStats.AccessPermissionErrors;
        sts0->sts0_syserrors = capturedStats.SystemErrors;
        sts0->sts0_bytessent_low = capturedStats.TotalBytesSent.LowPart;
        sts0->sts0_bytessent_high = capturedStats.TotalBytesSent.HighPart;
        sts0->sts0_bytesrcvd_low = capturedStats.TotalBytesReceived.LowPart;
        sts0->sts0_bytesrcvd_high = capturedStats.TotalBytesReceived.HighPart;

        //
        // Calculate the average response time by finding the total number
        // of SMBs we have received, the total time we have spent processing
        // them, and dividing to get the average.
        //

        sts0->sts0_avresponse = 0;

        //
        // Since we autotune the buffer counts, we never say that we had to
        // add more of them.  These are supposed to flag an admin that
        // parameters need adjustment, but we do it ourselves.
        //
        // !!! We probably won't really autotune them!

        sts0->sts0_reqbufneed = 0;
        sts0->sts0_bigbufneed = 0;

        status = STATUS_SUCCESS;

    } except( EXCEPTION_EXECUTE_HANDLER ) {

        status = GetExceptionCode();
    }

    return status;

} // SrvNetStatisticsGet
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\worker.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    worker.c

Abstract:

    This module implements the LAN Manager server FSP worker thread
    function.  It also implements routines for managing (i.e., starting
    and stopping) worker threads, and balancing load.

Author:

    Chuck Lenzmeier (chuckl)    01-Oct-1989
    David Treadwell (davidtr)

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#include "worker.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_WORKER

// This is the maximum number of workitems that can be in the queue to be
// LPC'd up to user mode.  This prevents us from consuming all the resources if
// spooler or some other user-mode process gets wedged or overly stressed
#define SRV_MAX_LPC_CALLS 250

//
// Local declarations
//

NTSTATUS
CreateQueueThread (
    IN PWORK_QUEUE Queue
    );

VOID
InitializeWorkerThread (
    IN PWORK_QUEUE WorkQueue,
    IN KPRIORITY ThreadPriority
    );

VOID
WorkerThread (
    IN PWORK_QUEUE WorkQueue
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvCreateWorkerThreads )
#pragma alloc_text( PAGE, CreateQueueThread )
#pragma alloc_text( PAGE, InitializeWorkerThread )
#pragma alloc_text( PAGE, WorkerThread )
#endif
#if 0
NOT PAGEABLE -- SrvQueueWorkToBlockingThread
NOT PAGEABLE -- SrvQueueWorkToFsp
NOT PAGEABLE -- SrvQueueWorkToFspAtSendCompletion
NOT PAGEABLE -- SrvBalanceLoad
#endif


NTSTATUS
SrvCreateWorkerThreads (
    VOID
    )

/*++

Routine Description:

    This function creates the worker threads for the LAN Manager server
    FSP.

Arguments:

    None.

Return Value:

    NTSTATUS - Status of thread creation

--*/

{
    NTSTATUS status;
    PWORK_QUEUE queue;

    PAGED_CODE( );

    //
    // Create the nonblocking worker threads.
    //
    for( queue = SrvWorkQueues; queue < eSrvWorkQueues; queue++ ) {
        status = CreateQueueThread( queue );
        if( !NT_SUCCESS( status ) ) {
            return status;
        }
    }

    //
    // Create the blocking worker threads.
    //
    for( queue = SrvBlockingWorkQueues; queue < eSrvBlockingWorkQueues; queue++ ) {
        status = CreateQueueThread( queue );
        if( !NT_SUCCESS( status ) ) {
            return status;
        }
    }

    status = CreateQueueThread( &SrvLpcWorkQueue );
    if( !NT_SUCCESS( status ) )
    {
        return status;
    }

    return STATUS_SUCCESS;

} // SrvCreateWorkerThreads


NTSTATUS
CreateQueueThread (
    IN PWORK_QUEUE Queue
    )
/*++

Routine Description:

    This function creates a worker thread to service a queue.

    NOTE:  The scavenger occasionally kills off threads on a queue.  If logic
        here is modified, you may need to look there too.

Arguments:

    Queue - the queue to service

Return Value:

    NTSTATUS - Status of thread creation

--*/
{
    HANDLE threadHandle;
    LARGE_INTEGER interval;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Another thread is coming into being.  Keep the counts up to date
    //
    InterlockedIncrement( &Queue->Threads );
    InterlockedIncrement( &Queue->AvailableThreads );

    status = PsCreateSystemThread(
                &threadHandle,
                PROCESS_ALL_ACCESS,
                NULL,
                NtCurrentProcess(),
                NULL,
                WorkerThread,
                Queue
                );

    if ( !NT_SUCCESS(status) ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "CreateQueueThread: PsCreateSystemThread for "
                "queue %X returned %X",
            Queue,
            status
            );

        InterlockedDecrement( &Queue->Threads );
        InterlockedDecrement( &Queue->AvailableThreads );

        SrvLogServiceFailure( SRV_SVC_PS_CREATE_SYSTEM_THREAD, status );
        return status;
    }

    //
    // Close the handle so the thread can die when needed
    //

    SrvNtClose( threadHandle, FALSE );

    //
    // If we just created the first queue thread, wait for it
    // to store its thread pointer in IrpThread.  This pointer is
    // stored in all IRPs issued for this queue by the server.
    //
    while ( Queue->IrpThread == NULL ) {
        interval.QuadPart = -1*10*1000*10; // .01 second
        KeDelayExecutionThread( KernelMode, FALSE, &interval );
    }

    return STATUS_SUCCESS;

} // CreateQueueThread


VOID
InitializeWorkerThread (
    IN PWORK_QUEUE WorkQueue,
    IN KPRIORITY ThreadPriority
    )
{
    NTSTATUS status;
    KPRIORITY basePriority;

    PAGED_CODE( );


#if SRVDBG_LOCK
{
    //
    // Create a special system thread TEB.  The size of this TEB is just
    // large enough to accommodate the first three user-reserved
    // longwords.  These three locations are used for lock debugging.  If
    // the allocation fails, then no lock debugging will be performed
    // for this thread.
    //
    //

    PETHREAD Thread = PsGetCurrentThread( );
    ULONG TebSize = FIELD_OFFSET( TEB, UserReserved[0] ) + SRV_TEB_USER_SIZE;

    Thread->Tcb.Teb = ExAllocatePoolWithTag( NonPagedPool, TebSize, TAG_FROM_TYPE(BlockTypeMisc) );

    if ( Thread->Tcb.Teb != NULL ) {
        RtlZeroMemory( Thread->Tcb.Teb, TebSize );
    }
}
#endif // SRVDBG_LOCK

    //
    // Set this thread's priority.
    //

    basePriority = ThreadPriority;

    status = NtSetInformationThread (
                 NtCurrentThread( ),
                 ThreadBasePriority,
                 &basePriority,
                 sizeof(basePriority)
                 );

    if ( !NT_SUCCESS(status) ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "InitializeWorkerThread: NtSetInformationThread failed: %X\n",
            status,
            NULL
            );
        SrvLogServiceFailure( SRV_SVC_NT_SET_INFO_THREAD, status );
    }

#if MULTIPROCESSOR
    //
    // If this is a nonblocking worker thread, set its ideal processor affinity.  Setting
    //  ideal affinity informs ntos that the thread would rather run on its ideal
    //  processor if reasonable, but if ntos can't schedule it on that processor then it is
    //  ok to schedule it on a different processor.
    //
    if( SrvNumberOfProcessors > 1 && WorkQueue >= SrvWorkQueues && WorkQueue < eSrvWorkQueues ) {
        KeSetIdealProcessorThread( KeGetCurrentThread(), (CCHAR)(WorkQueue - SrvWorkQueues) );
    }

    //
    // Blocking threads are now also affinitized
    //
    if( SrvNumberOfProcessors >= 4 && WorkQueue >= SrvBlockingWorkQueues && WorkQueue < eSrvBlockingWorkQueues ) {
        KeSetIdealProcessorThread( KeGetCurrentThread(), (CCHAR)(WorkQueue - SrvBlockingWorkQueues) );
    }

#endif

    //
    // Disable hard error popups for this thread.
    //

    IoSetThreadHardErrorMode( FALSE );

    return;

} // InitializeWorkerThread


VOID
WorkerThread (
    IN PWORK_QUEUE WorkQueue
    )
{
    PLIST_ENTRY listEntry;
    PWORK_CONTEXT workContext;
    ULONG timeDifference;
    ULONG updateSmbCount = 0;
    ULONG updateTime = 0;
    BOOLEAN iAmBlockingThread = ((WorkQueue >= SrvBlockingWorkQueues) && (WorkQueue < eSrvBlockingWorkQueues)) ? TRUE : FALSE;
    PLARGE_INTEGER Timeout = NULL;
    BOOLEAN iAmLpcThread = (WorkQueue == &SrvLpcWorkQueue) ? TRUE : FALSE;

    PAGED_CODE();

    //
    // If this is the first worker thread, save the thread pointer.
    //
    if( WorkQueue->IrpThread == NULL ) {
        WorkQueue->IrpThread = PsGetCurrentThread( );
    }

    InitializeWorkerThread( WorkQueue, SrvThreadPriority );

    //
    // If we are the IrpThread, we don't want to die
    //
    if( WorkQueue->IrpThread != PsGetCurrentThread( ) ) {
        Timeout = &WorkQueue->IdleTimeOut;
    }

    //
    // Loop infinitely dequeueing and processing work items.
    //

    while ( TRUE ) {

        listEntry = KeRemoveQueue(
                        &WorkQueue->Queue,
                        WorkQueue->WaitMode,
                        Timeout
                        );

        if( (ULONG_PTR)listEntry == STATUS_TIMEOUT ) {
            //
            // We have a non critical thread that hasn't gotten any work for
            //  awhile.  Time to die.
            //
            InterlockedDecrement( &WorkQueue->AvailableThreads );
            InterlockedDecrement( &WorkQueue->Threads );
            SrvTerminateWorkerThread( NULL );
        }

        if( InterlockedDecrement( &WorkQueue->AvailableThreads ) == 0 &&
            !SrvFspTransitioning &&
            WorkQueue->Threads < WorkQueue->MaxThreads ) {

            //
            // We are running low on threads for this queue.  Spin up
            // another one before handling this request
            //
            CreateQueueThread( WorkQueue );
        }

        //
        // Get the address of the work item.
        //

        workContext = CONTAINING_RECORD(
                        listEntry,
                        WORK_CONTEXT,
                        ListEntry
                        );

        ASSERT( KeGetCurrentIrql() == 0 );

        //
        // There is work available.  It may be a work contect block or
        // an RFCB.  (Blocking threads won't get RFCBs.)
        //

        ASSERT( (GET_BLOCK_TYPE(workContext) == BlockTypeWorkContextInitial) ||
                (GET_BLOCK_TYPE(workContext) == BlockTypeWorkContextNormal) ||
                (GET_BLOCK_TYPE(workContext) == BlockTypeWorkContextRaw) ||
                (GET_BLOCK_TYPE(workContext) == BlockTypeWorkContextSpecial) ||
                (GET_BLOCK_TYPE(workContext) == BlockTypeRfcb) );

#if DBG
        if ( GET_BLOCK_TYPE( workContext ) == BlockTypeRfcb ) {
            ((PRFCB)workContext)->ListEntry.Flink =
                                ((PRFCB)workContext)->ListEntry.Blink = NULL;
        }
#endif

        IF_DEBUG(WORKER1) {
            KdPrint(( "WorkerThread working on work context %p", workContext ));
        }

        //
        // Make sure we have a resaonable idea of the system time
        //
        if( ++updateTime == TIME_SMB_INTERVAL ) {
            updateTime = 0;
            SET_SERVER_TIME( WorkQueue );
        }

        //
        // Update statistics.
        //
        if ( ++updateSmbCount == STATISTICS_SMB_INTERVAL ) {

            updateSmbCount = 0;

            GET_SERVER_TIME( WorkQueue, &timeDifference );
            timeDifference = timeDifference - workContext->Timestamp;

            ++(WorkQueue->stats.WorkItemsQueued.Count);
            WorkQueue->stats.WorkItemsQueued.Time.QuadPart += timeDifference;
        }

        {
        //
        // Put the workContext out relative to bp so we can find it later if we need
        //  to debug.  The block of memory we're writing to is likely already in cache,
        //  so this should be relatively cheap.
        //
        PWORK_CONTEXT volatile savedWorkContext;
        savedWorkContext = workContext;

        }

        //
        // Make sure the WorkContext knows if it is on the blocking work queue
        //
        workContext->UsingBlockingThread = iAmBlockingThread;
        workContext->UsingLpcThread = iAmLpcThread;

        //
        // Call the restart routine for the work item.
        //

        IF_SMB_DEBUG( TRACE ) {
            KdPrint(( "Blocking %d, Count %d -> %p( %p )\n",
                        iAmBlockingThread,
                        workContext->ProcessingCount,
                        workContext->FspRestartRoutine,
                        workContext
            ));
        }

        workContext->FspRestartRoutine( workContext );

        //
        // Make sure we are still at normal level.
        //

        ASSERT( KeGetCurrentIrql() == 0 );

        //
        // We're getting ready to be available (i.e. waiting on the queue)
        //
        InterlockedIncrement( &WorkQueue->AvailableThreads );

    }

} // WorkerThread

VOID SRVFASTCALL
SrvQueueWorkToBlockingThread (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This routine queues a work item to a blocking thread.  These threads
    are used to service requests that may block for a long time, so we
    don't want to tie up our normal worker threads.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        representing the work item

Return Value:

    None.

--*/

{
    //
    // Increment the processing count.
    //

    WorkContext->ProcessingCount++;

    //
    // Insert the work item at the tail of the blocking work queue.
    //

    SrvInsertWorkQueueTail(
        GET_BLOCKING_WORK_QUEUE(),
        (PQUEUEABLE_BLOCK_HEADER)WorkContext
    );

    return;

} // SrvQueueWorkToBlockingThread

NTSTATUS SRVFASTCALL
SrvQueueWorkToLpcThread (
    IN OUT PWORK_CONTEXT WorkContext,
    IN BOOLEAN ThrottleRequest
    )

/*++

Routine Description:

    This routine queues a work item to a blocking thread.  These threads
    are used to service requests that may block for a long time, so we
    don't want to tie up our normal worker threads.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        representing the work item

Return Value:

    None.

--*/

{
    // The most LPC calls we allow is the number of work items / 4 with a maximum of 250.
    // The minimum is 4.  If the SrvSvc is not processing it at this fast of a rate, we need
    // to turn them away.
    if ( ThrottleRequest &&
         (KeReadStateQueue( &SrvLpcWorkQueue.Queue ) > (LONG)MAX( 4, MIN(SrvMaxReceiveWorkItemCount>>2, 250) )) ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // Increment the processing count.
    //

    WorkContext->ProcessingCount++;

    //
    // Insert the work item at the tail of the blocking work queue.
    //

    SrvInsertWorkQueueTail(
        &SrvLpcWorkQueue,
        (PQUEUEABLE_BLOCK_HEADER)WorkContext
    );

    return STATUS_SUCCESS;

} // SrvQueueWorkToBlockingThread



VOID SRVFASTCALL
SrvQueueWorkToFsp (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This is the restart routine for work items that are to be queued to
    a nonblocking worker thread in the FSP.  This function is also
    called from elsewhere in the server to transfer work to the FSP.
    This function should not be called at dispatch level -- use
    SrvQueueWorkToFspAtDpcLevel instead.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        representing the work item

Return Value:

    None.

--*/

{
    //
    // Increment the processing count.
    //

    WorkContext->ProcessingCount++;

    //
    // Insert the work item at the tail of the nonblocking work queue.
    //

    if( WorkContext->QueueToHead ) {

        SrvInsertWorkQueueHead(
            WorkContext->CurrentWorkQueue,
            (PQUEUEABLE_BLOCK_HEADER)WorkContext
        );

    } else {

        SrvInsertWorkQueueTail(
            WorkContext->CurrentWorkQueue,
            (PQUEUEABLE_BLOCK_HEADER)WorkContext
        );

    }

} // SrvQueueWorkToFsp


NTSTATUS
SrvQueueWorkToFspAtSendCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Send completion handler for  work items that are to be queued to
    a nonblocking worker thread in the FSP.  This function is also
    called from elsewhere in the server to transfer work to the FSP.
    This function should not be called at dispatch level -- use
    SrvQueueWorkToFspAtDpcLevel instead.

Arguments:

    DeviceObject - Pointer to target device object for the request.

    Irp - Pointer to I/O request packet

    WorkContext - Caller-specified context parameter associated with IRP.
        This is actually a pointer to a Work Context block.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED.

--*/

{
    //
    // Check the status of the send completion.
    //

    CHECK_SEND_COMPLETION_STATUS( Irp->IoStatus.Status );

    //
    // Reset the IRP cancelled bit.
    //

    Irp->Cancel = FALSE;

    //
    // Increment the processing count.
    //

    WorkContext->ProcessingCount++;

    //
    // Insert the work item on the nonblocking work queue.
    //

    if( WorkContext->QueueToHead ) {

        SrvInsertWorkQueueHead(
            WorkContext->CurrentWorkQueue,
            (PQUEUEABLE_BLOCK_HEADER)WorkContext
        );

    } else {

        SrvInsertWorkQueueTail(
            WorkContext->CurrentWorkQueue,
            (PQUEUEABLE_BLOCK_HEADER)WorkContext
        );

    }

    return STATUS_MORE_PROCESSING_REQUIRED;

} // SrvQueueWorkToFspAtSendCompletion


VOID SRVFASTCALL
SrvTerminateWorkerThread (
    IN OUT PWORK_CONTEXT WorkItem OPTIONAL
    )
/*++

Routine Description:

    This routine is called when a thread is being requested to terminate.  There
        are two cases when this happens.  One is at server shutdown -- in this
        case we need to keep requeueing the termination request until all the
        threads on the queue have terminated.  The other time is if a thread has
        not received work for some amount of time.
--*/
{
    LONG priority = 16;


    //
    // Raise our priority to ensure that this thread has a chance to get completely
    //  done before the main thread causes the driver to unload or something
    //
    NtSetInformationThread (
                    NtCurrentThread( ),
                    ThreadBasePriority,
                    &priority,
                    sizeof(priority)
                    );

    if( ARGUMENT_PRESENT( WorkItem ) &&
        InterlockedDecrement( &WorkItem->CurrentWorkQueue->Threads ) != 0 ) {

        //
        // We are being asked to terminate all of the worker threads on this queue.
        //  So, if we're not the last thread, we should requeue the workitem so
        //  the other threads will terminate
        //

        //
        // There are still other threads servicing this queue, so requeue
        //  the workitem
        //
        SrvInsertWorkQueueTail( WorkItem->CurrentWorkQueue,
                                (PQUEUEABLE_BLOCK_HEADER)WorkItem );
    }

    PsTerminateSystemThread( STATUS_SUCCESS ); // no return;
}


#if MULTIPROCESSOR

VOID
SrvBalanceLoad(
    IN PCONNECTION connection
    )
/*++

Routine Description:

    Ensure that the processor handling 'connection' is the best one
     for the job.  This routine is called periodically per connection from
     DPC level.  It can not be paged.

Arguments:

    connection - the connection to inspect

Return Value:

    none.

--*/
{
    ULONG MyQueueLength, OtherQueueLength;
    ULONG i;
    PWORK_QUEUE tmpqueue;
    PWORK_QUEUE queue = connection->CurrentWorkQueue;

    ASSERT( queue >= SrvWorkQueues );
    ASSERT( queue < eSrvWorkQueues );

    //
    // Reset the countdown.  After the client performs BalanceCount
    //   more operations, we'll call this routine again.
    //
    connection->BalanceCount = SrvBalanceCount;

    //
    // Figure out the load on the current work queue.  The load is
    //  the sum of the average work queue depth and the current work
    //  queue depth.  This gives us some history mixed in with the
    //  load *right now*
    //
    MyQueueLength = queue->AvgQueueDepthSum >> LOG2_QUEUE_SAMPLES;
    MyQueueLength += KeReadStateQueue( &queue->Queue );

    //
    // If we are not on our preferred queue, look to see if we want to
    //  go back to it.  The preferred queue is the queue for the processor
    //  handling this client's network card DPCs.  We prefer to run on that
    //  processor to avoid sloshing data between CPUs in an MP system.
    //
    tmpqueue = connection->PreferredWorkQueue;

    ASSERT( tmpqueue >= SrvWorkQueues );
    ASSERT( tmpqueue < eSrvWorkQueues );

    if( tmpqueue != queue ) {

        //
        // We are not queueing to our preferred queue.  See if we
        // should go back to our preferred queue
        //

        ULONG PreferredQueueLength;

        PreferredQueueLength = tmpqueue->AvgQueueDepthSum >> LOG2_QUEUE_SAMPLES;
        PreferredQueueLength += KeReadStateQueue( &tmpqueue->Queue );

        if( PreferredQueueLength <= MyQueueLength + SrvPreferredAffinity ) {

            //
            // We want to switch back to our preferred processor!
            //

            IF_DEBUG( REBALANCE ) {
                KdPrint(( "%p C%d(%p) > P%p(%d)\n",
                    connection,
                    MyQueueLength,
                    (PVOID)(connection->CurrentWorkQueue - SrvWorkQueues),
                    (PVOID)(tmpqueue - SrvWorkQueues),
                    PreferredQueueLength ));
            }

            InterlockedDecrement( &queue->CurrentClients );
            InterlockedExchangePointer( &connection->CurrentWorkQueue, tmpqueue );
            InterlockedIncrement( &tmpqueue->CurrentClients );
            SrvReBalanced++;
            return;
        }
    }

    //
    // We didn't hop to the preferred processor, so let's see if
    // another processor looks more lightly loaded than we are.
    //

    //
    // SrvNextBalanceProcessor is the next processor we should consider
    //  moving to.  It is a global to ensure everybody doesn't pick the
    //  the same processor as the next candidate.
    //
    tmpqueue = &SrvWorkQueues[ SrvNextBalanceProcessor ];

    //
    // Advance SrvNextBalanceProcessor to the next processor in the system
    //
    i = SrvNextBalanceProcessor + 1;

    if( i >= SrvNumberOfProcessors )
        i = 0;

    SrvNextBalanceProcessor = i;

    //
    // Look at the other processors, and pick the next one which is doing
    // enough less work than we are to make the jump worthwhile
    //

    for( i = SrvNumberOfProcessors; i > 1; --i ) {

        ASSERT( tmpqueue >= SrvWorkQueues );
        ASSERT( tmpqueue < eSrvWorkQueues );

        OtherQueueLength = tmpqueue->AvgQueueDepthSum >> LOG2_QUEUE_SAMPLES;
        OtherQueueLength += KeReadStateQueue( &tmpqueue->Queue );

        if( OtherQueueLength + SrvOtherQueueAffinity < MyQueueLength ) {

            //
            // This processor looks promising.  Switch to it
            //

            IF_DEBUG( REBALANCE ) {
                KdPrint(( "%p %c%p(%d) > %c%p(%d)\n",
                    connection,
                    queue == connection->PreferredWorkQueue ? 'P' : 'C',
                    (PVOID)(queue - SrvWorkQueues),
                    MyQueueLength,
                    tmpqueue == connection->PreferredWorkQueue ? 'P' : 'C',
                    (PVOID)(tmpqueue - SrvWorkQueues),
                    OtherQueueLength ));
            }

            InterlockedDecrement( &queue->CurrentClients );
            InterlockedExchangePointer( &connection->CurrentWorkQueue, tmpqueue );
            InterlockedIncrement( &tmpqueue->CurrentClients );
            SrvReBalanced++;
            return;
        }

        if( ++tmpqueue == eSrvWorkQueues )
            tmpqueue = SrvWorkQueues;
    }

    //
    // No rebalancing necessary
    //
    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\svcxport.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    svcxport.c

Abstract:

    This module contains routines for supporting the transport APIs in the
    server service, NetServerTransportAdd, NetServerTransportDel,
    and NetServerTransportEnum.

Author:

    David Treadwell (davidtr) 6-Mar-1991

Revision History:

--*/

#include "precomp.h"
#include "svcxport.tmh"
#pragma hdrstop

//
// Forward declarations.
//

VOID
FillTransportInfoBuffer (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block,
    IN OUT PVOID *FixedStructure,
    IN LPWSTR *EndOfVariableData
    );

BOOLEAN
FilterTransports (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    );

ULONG
SizeTransports (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvNetServerTransportAdd )
#pragma alloc_text( PAGE, SrvNetServerTransportDel )
#pragma alloc_text( PAGE, SrvNetServerTransportEnum )
#pragma alloc_text( PAGE, FillTransportInfoBuffer )
#pragma alloc_text( PAGE, FilterTransports )
#pragma alloc_text( PAGE, SizeTransports )
#endif


NTSTATUS
SrvNetServerTransportAdd (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine processes the NetServerTransportAdd API in the server
    FSP.  Because it opens an object (the transport device object) it
    must be done in the server FSP, not the FSD.

Arguments:

    Srp - a pointer to the server request packet that contains all
        the information necessary to satisfy the request.  This includes:

      INPUT:

        None.

      OUTPUT:

        None.

    Buffer - a pointer to a TRANSPORT_INFO_0 structure for the new
        transport.  All pointers should have been changed to offsets
        within the buffer.

    BufferLength - total length of this buffer.

Return Value:

    NTSTATUS - result of operation to return to the server service.

--*/

{
    NTSTATUS status;
    PSERVER_TRANSPORT_INFO_3 svti3;
    UNICODE_STRING transportName;
    UNICODE_STRING domainName;
    ANSI_STRING transportAddress;
    UNICODE_STRING netName;

    PAGED_CODE( );

    //
    // Convert the offsets in the transport data structure to pointers.
    // Also make sure that all the pointers are within the specified
    // buffer.
    //

    svti3 = Buffer;

    OFFSET_TO_POINTER( svti3->svti3_transportname, svti3 );
    OFFSET_TO_POINTER( svti3->svti3_transportaddress, svti3 );
    OFFSET_TO_POINTER( svti3->svti3_domain, svti3 );

    if ( !POINTER_IS_VALID( svti3->svti3_transportname, svti3, BufferLength ) ||
         !POINTER_IS_VALID( svti3->svti3_transportaddress, svti3, BufferLength ) ||
         !POINTER_IS_VALID( svti3->svti3_domain, svti3, BufferLength ) ) {

        IF_DEBUG( ERRORS ) {
            KdPrint(( "SrvNetServerTransportAdd: Bad pointers\n" ));
        }

        return STATUS_ACCESS_VIOLATION;
    }

    if( svti3->svti3_passwordlength > sizeof( svti3->svti3_password ) ) {

        IF_DEBUG( ERRORS ) {
            KdPrint(( "SrvNetServerTransportAdd: svti3_passwordlength %d\n", svti3->svti3_passwordlength ));
        }

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Set up the transport name, server name, domain name, and net name.
    //

    RtlInitUnicodeString( &transportName, (PWCH)svti3->svti3_transportname );

    netName.Buffer = NULL;
    netName.Length = 0;
    netName.MaximumLength = 0;

    RtlInitUnicodeString( &domainName, (PWCH)svti3->svti3_domain );

    transportAddress.Buffer = svti3->svti3_transportaddress;
    transportAddress.Length = (USHORT)svti3->svti3_transportaddresslength;
    transportAddress.MaximumLength = (USHORT)svti3->svti3_transportaddresslength;

    //
    // Attempt to add the new transport to the server.
    //

    IF_DEBUG( PNP ) {
        KdPrint(( "SRV: SrvNetServerTransportAdd: %wZ\n", &transportName ));
    }

    status = SrvAddServedNet( &netName,
                              &transportName,
                              &transportAddress,
                              &domainName,
                              Srp->Flags & SRP_XADD_FLAGS,
                              svti3->svti3_passwordlength,
                              svti3->svti3_password
                             );

    IF_DEBUG( PNP ) {
        KdPrint(( "SRV: SrvNetServerTransportAdd: %wZ, status %X\n", &transportName, status ));
    }

    return status;

} // SrvNetServerTransportAdd


NTSTATUS
SrvNetServerTransportDel (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine processes the NetServerTransportEnum API in the server
    FSD.

Arguments:

    Srp - a pointer to the server request packet that contains all
        the information necessary to satisfy the request.  This includes:

    Buffer - a pointer to a TRANSPORT_INFO_0 structure for the
        transport.  All pointers should have been changed to offsets
        within the buffer.

    BufferLength - total length of this buffer.

Return Value:

    NTSTATUS - result of operation to return to the server service.

--*/

{
    NTSTATUS status;
    PSERVER_TRANSPORT_INFO_3 svti3;
    UNICODE_STRING transportName;
    ANSI_STRING transportAddress;

    PAGED_CODE( );

    Srp;

    //
    // Convert the offsets in the transport data structure to pointers.
    // Also make sure that all the pointers are within the specified
    // buffer.
    //

    svti3 = Buffer;

    OFFSET_TO_POINTER( svti3->svti3_transportname, svti3 );

    if ( !POINTER_IS_VALID( svti3->svti3_transportname, svti3, BufferLength ) ) {
        IF_DEBUG( ERRORS ) {
            KdPrint(("SrvNetServerTransportDel: STATUS_ACCESS_VIOLATION at %u\n", __LINE__ ));
        }
        return STATUS_ACCESS_VIOLATION;
    }


    RtlInitUnicodeString( &transportName, (PWCH)svti3->svti3_transportname );

    transportAddress.Length = (USHORT)svti3->svti3_transportaddresslength;
    transportAddress.MaximumLength = (USHORT)svti3->svti3_transportaddresslength;

    if( transportAddress.Length != 0 ) {

        OFFSET_TO_POINTER( svti3->svti3_transportaddress, svti3 );

        if( !POINTER_IS_VALID( svti3->svti3_transportaddress, svti3, BufferLength ) ) {
            IF_DEBUG( ERRORS ) {
                KdPrint(("SrvNetServerTransportDel: STATUS_ACCESS_VIOLATION at %u\n", __LINE__ ));
            }
            return STATUS_ACCESS_VIOLATION;
        }

        transportAddress.Buffer = svti3->svti3_transportaddress;
    }

    //
    // Attempt to delete the transport endpoint from the server.
    //
    status = SrvDeleteServedNet( &transportName, &transportAddress );

    IF_DEBUG( ERRORS ) {
        if( !NT_SUCCESS( status ) ) {
            KdPrint(( "SrvNetServerTransportDel: SrvDeleteServedNet status %X\n", status ));
        }
    }

    return status;

} // SrvNetServerTransportDel


NTSTATUS
SrvNetServerTransportEnum (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Buffer,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine processes the NetServerTransportEnum API in the server
    FSD.

Arguments:

    Srp - a pointer to the server request packet that contains all
        the information necessary to satisfy the request.  This includes:

      INPUT:

        None.

      OUTPUT:

        Parameters.Get.EntriesRead - the number of entries that fit in
            the output buffer.

        Parameters.Get.TotalEntries - the total number of entries that
            would be returned with a large enough buffer.

        Parameters.Get.TotalBytesNeeded - the buffer size that would be
            required to hold all the entries.

    Buffer - a pointer to a TRANSPORT_INFO_0 structure for the new
        transport.  All pointers should have been changed to offsets
        within the buffer.

    BufferLength - total length of this buffer.

Return Value:

    NTSTATUS - result of operation to return to the server service.

--*/

{
    PAGED_CODE( );

    return SrvEnumApiHandler(
               Srp,
               Buffer,
               BufferLength,
               &SrvEndpointList,
               FilterTransports,
               SizeTransports,
               FillTransportInfoBuffer
               );

} // SrvNetServerTransportEnum


VOID
FillTransportInfoBuffer (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block,
    IN OUT PVOID *FixedStructure,
    IN LPWSTR *EndOfVariableData
    )

/*++

Routine Description:

    This routine puts a single fixed transport structure and, if it fits,
    associated variable data, into a buffer.  Fixed data goes at the
    beginning of the buffer, variable data at the end.

Arguments:

    Endpoint - the endpoint from which to get information.

    FixedStructure - where the in the buffer to place the fixed structure.
        This pointer is updated to point to the next available
        position for a fixed structure.

    EndOfVariableData - the last position on the buffer that variable
        data for this structure can occupy.  The actual variable data
        is written before this position as long as it won't overwrite
        fixed structures.  It is would overwrite fixed structures, it
        is not written.

Return Value:

    None.

--*/

{
    PENDPOINT endpoint = Block;
    PSERVER_TRANSPORT_INFO_1 svti1 = *FixedStructure;
    ULONG TransportAddressLength;

    PAGED_CODE( );

    //
    // Update FixedStructure to point to the next structure location.
    //

    *FixedStructure = (PCHAR)*FixedStructure +
        (Srp->Level ? sizeof( SERVER_TRANSPORT_INFO_1 ) : sizeof( SERVER_TRANSPORT_INFO_0 ));

    ASSERT( (ULONG_PTR)*EndOfVariableData >= (ULONG_PTR)*FixedStructure );

    //
    // The number of VCs on the endpoint is equal to the total number
    // of connections on the endpoint less the free connections.
    //

    ACQUIRE_LOCK_SHARED( &SrvEndpointLock );

    svti1->svti1_numberofvcs =
        endpoint->TotalConnectionCount - endpoint->FreeConnectionCount;

    RELEASE_LOCK( &SrvEndpointLock );

    //
    // Copy over the transport name.
    //

    SrvCopyUnicodeStringToBuffer(
        &endpoint->TransportName,
        *FixedStructure,
        EndOfVariableData,
        &svti1->svti1_transportname
        );

    //
    // Copy over the network name.
    //

    SrvCopyUnicodeStringToBuffer(
        &endpoint->NetworkAddress,
        *FixedStructure,
        EndOfVariableData,
        &svti1->svti1_networkaddress
        );

    //
    // Copy over the domain name
    //
    if( Srp->Level > 0 ) {

        SrvCopyUnicodeStringToBuffer(
            &endpoint->DomainName,
            *FixedStructure,
            EndOfVariableData,
            &svti1->svti1_domain
            );

    }

    //
    // Copy over the transport address.  We have to manually check here
    // whether it will fit in the output buffer.
    //
    //
    // Don't copy the trailing blanks of the transport address.
    //

    for ( TransportAddressLength = endpoint->TransportAddress.Length;
          TransportAddressLength > 0 && endpoint->TransportAddress.Buffer[TransportAddressLength-1] == ' ' ;
          TransportAddressLength-- ) ;

    *EndOfVariableData = (LPWSTR)( (PCHAR)*EndOfVariableData - TransportAddressLength );

    //
    // Ensure we remain byte aligned, so knock off the low bit if necessary.  Remember, we
    //  are filling backwards from the end of the buffer so we want to round the address down
    //
    *EndOfVariableData = (LPWSTR)( (ULONG_PTR)*EndOfVariableData & ~1 );

    if ( (ULONG_PTR)*EndOfVariableData > (ULONG_PTR)*FixedStructure ) {

        //
        // The address will fit.  Copy it over to the output buffer.
        //

        RtlCopyMemory(
            *EndOfVariableData,
            endpoint->TransportAddress.Buffer,
            TransportAddressLength
            );

        svti1->svti1_transportaddress = (LPBYTE)*EndOfVariableData;
        svti1->svti1_transportaddresslength = TransportAddressLength;

    } else {

        svti1->svti1_transportaddress = NULL;
        svti1->svti1_transportaddresslength = 0;
    }

    return;

} // FillTransportInfoBuffer


BOOLEAN
FilterTransports (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    )

/*++

Routine Description:

    This routine just returns TRUE since we always want to place
    information about all transports in the output buffer for a
    NetServerTransportEnum.

Arguments:

    Srp - not used.

    Block - not used.

Return Value:

    TRUE.

--*/

{
    PENDPOINT endpoint = Block;

    PAGED_CODE( );

    Srp, Block;

    //
    //  We filter out AlternateEndpoint since they are endpoints we've
    //  created ourselves.
    //

    if (endpoint->AlternateAddressFormat) {

        return FALSE;
    }

    //
    // We always return information about all transports.
    //

    return TRUE;

} // FilterFiles


ULONG
SizeTransports (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID Block
    )

/*++

Routine Description:

    This routine returns the size the passed-in endpoint would take up
    in an API output buffer.

Arguments:

    Srp - not used.

    Block - a pointer to the endpoint to size.

Return Value:

    ULONG - The number of bytes the endpoint would take up in the
        output buffer.

--*/

{
    PENDPOINT endpoint = Block;
    ULONG size;

    PAGED_CODE( );

    size = Srp->Level ? sizeof( SERVER_TRANSPORT_INFO_1 ) : sizeof( SERVER_TRANSPORT_INFO_0 );

    size += SrvLengthOfStringInApiBuffer(&(endpoint)->TransportName);
    size += (endpoint)->TransportAddress.Length + sizeof(TCHAR);
    size += SrvLengthOfStringInApiBuffer(&(endpoint)->NetworkAddress);

    if( Srp->Level ) {
        size += SrvLengthOfStringInApiBuffer( &(endpoint)->DomainName );
    }

    return size;

} // SizeTransports
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\daytonam\makefile.inc ===
MOF: srv.bmf

srv.bmf: ..\srv.mof
    mofcomp -B:srv.bmf ..\srv.mof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\xssupp.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    xssupp.c

Abstract:

    This module contains the code necessary to support XACTSRV for down-level
    remote APIs.

Author:

    David Treadwell (davidtr)   05-Jan-1991

Revision History:

--*/

#include "precomp.h"
#include "xssupp.tmh"
#pragma hdrstop

//
// Xs forward declarations
//

VOID
SrvXsFreeSharedMemory (
    VOID
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvXsConnect )
#pragma alloc_text( PAGE, SrvXsRequest )
#pragma alloc_text( PAGE, SrvXsLSOperation )
#pragma alloc_text( PAGE, SrvXsDisconnect )
#pragma alloc_text( PAGE, SrvXsFreeSharedMemory )
#pragma alloc_text( PAGE, SrvXsAllocateHeap )
#pragma alloc_text( PAGE, SrvXsFreeHeap )
#pragma alloc_text( PAGE, SrvXsPnpOperation )
#endif

//
// Xs internal Globals
//

//
// This count indicates how many outstanding transactions are using
// the XS shared memory.  This prevents us from deleting the shared
// memory while it is still being accessed.
//

ULONG SrvXsSharedMemoryReference = 0;


NTSTATUS
SrvXsConnect (
    IN PUNICODE_STRING PortName
    )

/*++

Routine Description:

    This routine performs all the work necessary to connect the server
    to XACTSRV.  It creates a section of shared memory to use, then
    calls NtConnectPort to connect to the port that XACTSRV has already
    created.

Arguments:

    PortName - Name of the port XACTSRV has opened.

Return Value:

    NTSTATUS - result of operation.

--*/

{
    NTSTATUS status;
    PORT_VIEW clientView;
    SECURITY_QUALITY_OF_SERVICE dynamicQos;

    PAGED_CODE( );

    //
    // Initialize variables so that we know what to close on exit.
    //

    SrvXsSectionHandle = NULL;
    SrvXsPortHandle = NULL;
    SrvXsPortMemoryHeap = NULL;

    //
    // Create the section to be used as unnamed shared memory for
    // communication between the server and XACTSRV.
    //

    status = NtCreateSection(
                 &SrvXsSectionHandle,
                 SECTION_ALL_ACCESS,
                 NULL,                           // ObjectAttributes
                 &SrvXsSectionSize,
                 PAGE_READWRITE,
                 SEC_RESERVE,
                 NULL                            // FileHandle
                 );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvXsConnect: NtCreateSection failed: %X\n", status ));
        }
        goto exit;
    }

    IF_DEBUG(XACTSRV) {
        KdPrint(( "SrvXsConnect: created section of %ld bytes, handle %p\n",
                      SrvXsSectionSize.LowPart, SrvXsSectionHandle ));
    }

    //
    // Set up for a call to NtConnectPort and connect to XACTSRV.  This
    // includes a description of the port memory section so that the
    // LPC connection logic can make the section visible to both the
    // client and server processes.
    //

    clientView.Length = sizeof(clientView);
    clientView.SectionHandle = SrvXsSectionHandle;
    clientView.SectionOffset = 0;
    clientView.ViewSize = SrvXsSectionSize.LowPart;
    clientView.ViewBase = 0;
    clientView.ViewRemoteBase = 0;

    //
    // Set up the security quality of service parameters to use over the
    // port.  Use dynamic tracking so that XACTSRV will impersonate the
    // user that we are impersonating when we call NtRequestWaitReplyPort.
    // If we used static tracking, XACTSRV would impersonate the context
    // when the connection is made.
    //

    dynamicQos.ImpersonationLevel = SecurityImpersonation;
    dynamicQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    dynamicQos.EffectiveOnly = TRUE;

    // !!! We might want to use a timeout value.

    status = NtConnectPort(
                 &SrvXsPortHandle,
                 PortName,
                 &dynamicQos,
                 &clientView,
                 NULL,                           // ServerView
                 NULL,                           // MaxMessageLength
                 NULL,                           // ConnectionInformation
                 NULL                            // ConnectionInformationLength
                 );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvXsConnect: NtConnectPort for port %wZ failed: %X\n",
                          PortName, status ));
        }
        goto exit;
    }

    IF_DEBUG(XACTSRV) {
        KdPrint(( "SrvXsConnect: conected to port %wZ, handle %p\n",
                      PortName, SrvXsPortHandle ));
    }

    //
    // Store information about the section so that we can create pointers
    // meaningful to XACTSRV.
    //

    SrvXsPortMemoryBase = clientView.ViewBase;
    SrvXsPortMemoryDelta = PTR_DIFF_FULLPTR( clientView.ViewRemoteBase,
                                             clientView.ViewBase );

    IF_DEBUG(XACTSRV) {
        KdPrint(( "SrvXsConnect: port mem base %p, port mem delta %p\n",
                      SrvXsPortMemoryBase, (PVOID)SrvXsPortMemoryDelta ));
    }

    //
    // Set up the port memory as heap.
    //
    // *** Note that we do our own heap serialization using
    //     SrvXsResource.
    //
    SrvXsPortMemoryHeap = RtlCreateHeap(
                              HEAP_NO_SERIALIZE,        // Flags
                              SrvXsPortMemoryBase,      // HeapBase
                              SrvXsSectionSize.LowPart, // ReserveSize
                              PAGE_SIZE,                // CommitSize
                              NULL,                     // Lock
                              0                         // Reserved
                              );

    SrvXsActive = TRUE;

    //
    // Test it out to ensure everything is working right
    //
    SrvXsFreeHeap( SrvXsAllocateHeap( 100, &status ) );

    return status;

exit:

    if ( SrvXsSectionHandle != NULL ) {
       SrvNtClose( SrvXsSectionHandle, FALSE );
    }

    if ( SrvXsPortHandle != NULL ) {
       SrvNtClose( SrvXsPortHandle, FALSE );
    }

    return status;

} // SrvXsConnect


SMB_TRANS_STATUS
SrvXsRequest (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This routine sends a remote API request to XACTSRV.  It first
    updates all the pointers in the transaction block so that they
    are meaningful to XACTSRV, then sends a message over the port
    indicating that there is a request in the shared memory ready to
    be serviced.  It then fixes all the pointers in the transaction
    block.

Arguments:

    WorkContext - a pointer to a work context block that has a pointer to
        transaction block to use.

Return Value:

    NTSTATUS - result of operation.

--*/

{
    NTSTATUS status;
    PCONNECTION connection = WorkContext->Connection;
    PSESSION session = WorkContext->Session;
    SMB_TRANS_STATUS returnStatus;
    PTRANSACTION transaction;
    XACTSRV_REQUEST_MESSAGE requestMessage;
    XACTSRV_REPLY_MESSAGE replyMessage;
    PWCH destPtr, sourcePtr, sourceEndPtr;

    PAGED_CODE( );

    //
    // If this call is made on the NULL session, make sure it's one of
    // the authorized apis.
    //

    transaction = WorkContext->Parameters.Transaction;
    if ( session->IsNullSession && SrvRestrictNullSessionAccess ) {

        USHORT apiNumber;

        apiNumber = SmbGetUshort( (PSMB_USHORT)transaction->InParameters );

        if ( apiNumber != API_WUserPasswordSet2         &&
             apiNumber != API_WUserGetGroups            &&
             apiNumber != API_NetServerEnum2            &&
             apiNumber != API_WNetServerReqChallenge    &&
             apiNumber != API_WNetServerAuthenticate    &&
             apiNumber != API_WNetServerPasswordSet     &&
             apiNumber != API_WNetAccountDeltas         &&
             apiNumber != API_WNetAccountSync           &&
             apiNumber != API_WWkstaUserLogoff          &&
             apiNumber != API_WNetWriteUpdateLog        &&
             apiNumber != API_WNetAccountUpdate         &&
             apiNumber != API_SamOEMChgPasswordUser2_P  &&
             apiNumber != API_NetServerEnum3            &&
             apiNumber != API_WNetAccountConfirmUpdate  ) {

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvXsRequest: Null session tried to call api.%d\n",
                              apiNumber ));
            }

            SrvSetSmbError( WorkContext, STATUS_ACCESS_DENIED );
            return SmbTransStatusErrorWithoutData;
        }
    }

    //
    // Initialize the transport name pointer to make sure we can know if
    // it has been allocated.
    //

    requestMessage.Message.DownLevelApi.TransportName = NULL;

    //
    // Convert the relevant pointers in the transaction block to the base
    // in XACTSRV.
    //

    transaction->TransactionName.Buffer += SrvXsPortMemoryDelta;
    transaction->InSetup += SrvXsPortMemoryDelta;
    transaction->OutSetup += SrvXsPortMemoryDelta;
    transaction->InParameters += SrvXsPortMemoryDelta;
    transaction->OutParameters += SrvXsPortMemoryDelta;
    transaction->InData += SrvXsPortMemoryDelta;
    transaction->OutData += SrvXsPortMemoryDelta;

    //
    // Build the transport name in the message.
    //

    requestMessage.Message.DownLevelApi.TransportName =
        SrvXsAllocateHeap(
            WorkContext->Endpoint->TransportName.Length + sizeof(WCHAR),
            &status
            );

    if ( requestMessage.Message.DownLevelApi.TransportName == NULL ) {
        SrvSetSmbError( WorkContext, status );
        returnStatus = SmbTransStatusErrorWithoutData;
        goto exit;
    }


    requestMessage.Message.DownLevelApi.TransportNameLength =
                        WorkContext->Endpoint->TransportName.Length;

    RtlCopyMemory(
        requestMessage.Message.DownLevelApi.TransportName,
        WorkContext->Endpoint->TransportName.Buffer,
        WorkContext->Endpoint->TransportName.Length
        );

    //
    // Null terminate the transport name.
    //

    requestMessage.Message.DownLevelApi.TransportName[ WorkContext->Endpoint->TransportName.Length / sizeof(WCHAR) ] = UNICODE_NULL;

    //
    // Adjust the transport name to be self relative within the buffer.
    //

    requestMessage.Message.DownLevelApi.TransportName =
        (PWSTR)((PUCHAR)requestMessage.Message.DownLevelApi.TransportName +
                                                SrvXsPortMemoryDelta);

    //
    // Build the server name in the message
    //
    RtlCopyMemory(
        requestMessage.Message.DownLevelApi.ServerName,
        WorkContext->Endpoint->TransportAddress.Buffer,
        MIN( sizeof(requestMessage.Message.DownLevelApi.ServerName),
             WorkContext->Endpoint->TransportAddress.Length )
        );

    requestMessage.Message.DownLevelApi.Transaction =
        (PTRANSACTION)( (PCHAR)transaction + SrvXsPortMemoryDelta );

    //
    // Set up the message to send over the port.
    //

    requestMessage.PortMessage.u1.s1.DataLength =
            (USHORT)( sizeof(requestMessage) - sizeof(PORT_MESSAGE) );
    requestMessage.PortMessage.u1.s1.TotalLength = sizeof(requestMessage);
    requestMessage.PortMessage.u2.ZeroInit = 0;
    requestMessage.PortMessage.u2.s2.Type = LPC_KERNELMODE_MESSAGE;
    requestMessage.MessageType = XACTSRV_MESSAGE_DOWN_LEVEL_API;

    //
    // Copy the client machine name for XACTSRV, skipping over the
    // initial "\\", and deleting trailing spaces.
    //

    destPtr = requestMessage.Message.DownLevelApi.ClientMachineName;
    sourcePtr =
        connection->ClientMachineNameString.Buffer + 2;
    sourceEndPtr = sourcePtr
        + min( connection->ClientMachineNameString.Length,
               sizeof(requestMessage.Message.DownLevelApi.ClientMachineName) /
               sizeof(WCHAR) - 1 );

    while ( sourcePtr < sourceEndPtr && *sourcePtr != UNICODE_NULL ) {
        *destPtr++ = *sourcePtr++;
    }

    *destPtr-- = UNICODE_NULL;

    while ( destPtr >= requestMessage.Message.DownLevelApi.ClientMachineName
            &&
            *destPtr == L' ' ) {
        *destPtr-- = UNICODE_NULL;
    }

    //
    // Copy the lanman session key.  This will be used to decrypt doubly
    // encrypted passwords.
    //

    RtlCopyMemory(
            requestMessage.Message.DownLevelApi.LanmanSessionKey,
            session->LanManSessionKey,
            MSV1_0_LANMAN_SESSION_KEY_LENGTH
            );

    //
    // Set the flags
    //

    requestMessage.Message.DownLevelApi.Flags = 0;

    if ( IS_NT_DIALECT( connection->SmbDialect ) ) {

        requestMessage.Message.DownLevelApi.Flags |= XS_FLAGS_NT_CLIENT;
    }

    //
    // Send the message to XACTSRV and wait for a response message.
    //
    // !!! We may want to put a timeout on this.
    //

    IF_DEBUG(XACTSRV) {
        KdPrint(( "SrvXsRequest: Sending message at %p, port mem %p.\n",
                      &requestMessage,  transaction ));
    }

    status = IMPERSONATE( WorkContext );

    if( NT_SUCCESS( status ) ) {

        status = NtRequestWaitReplyPort(
                     SrvXsPortHandle,
                     (PPORT_MESSAGE)&requestMessage,
                     (PPORT_MESSAGE)&replyMessage
                     );

        REVERT( );
    }

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvXsRequest: NtRequestWaitReplyPort failed: %X\n",
                          status ));
        }
        SrvSetSmbError( WorkContext, status );
        returnStatus = SmbTransStatusErrorWithoutData;
        goto exit;
    }

    IF_DEBUG(XACTSRV) {
        KdPrint(( "SrvXsRequest: Received response at %p\n", &replyMessage ));
    }

    //
    // Check the status returned in the reply.
    //

    status = replyMessage.Message.DownLevelApi.Status;

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvXsRequest: XACTSRV reply had status %X\n", status ));
        }
        SrvSetSmbError( WorkContext, status );
        returnStatus = SmbTransStatusErrorWithoutData;
        goto exit;
    }

    returnStatus = SmbTransStatusSuccess;

exit:

    //
    // We're done with the API.  Free up the buffer containing the
    // transport name.
    //

    if ( requestMessage.Message.DownLevelApi.TransportName != NULL ) {

        requestMessage.Message.DownLevelApi.TransportName =
            (PWSTR)((PUCHAR)requestMessage.Message.DownLevelApi.TransportName -
                            SrvXsPortMemoryDelta);

        SrvXsFreeHeap( requestMessage.Message.DownLevelApi.TransportName );

    }

    //
    // Convert the relevant pointers in the transaction block back to
    // the server base.
    //

    transaction->TransactionName.Buffer -= SrvXsPortMemoryDelta;
    transaction->InSetup -= SrvXsPortMemoryDelta;
    transaction->OutSetup -= SrvXsPortMemoryDelta;
    transaction->InParameters -= SrvXsPortMemoryDelta;
    transaction->OutParameters -= SrvXsPortMemoryDelta;
    transaction->InData -= SrvXsPortMemoryDelta;
    transaction->OutData -= SrvXsPortMemoryDelta;

    return returnStatus;

} // SrvXsRequest


NTSTATUS
SrvXsLSOperation (
IN PSESSION Session,
IN ULONG Type
)

/*++

Routine Description:

    This routine causes the Xact service to do an NtLSRequest call

Arguments:

    Session - a pointer to the session structure involved in the request

    Type - either XACTSRV_MESSAGE_LSREQUEST or XACTSRV_MESSAGE_LSRELEASE
            depending on whether a license is being requested or being
            released.

Return Value:

    STATUS_SUCCESS if the license was granted

Notes:
    Once a license is granted for a particular session, it is never released
      until the session is deallocated.  Therefore, it is only necessary to
      hold the Session->Connection->LicenseLock when we are checking for
      acquisition of the license.

    We don't need licenses if we are running on a workstation.
    We don't try for licenses over NULL sessions

--*/

{
    XACTSRV_REQUEST_MESSAGE requestMessage;
    XACTSRV_REPLY_MESSAGE replyMessage;
    NTSTATUS status;
    ULONG requestLength;
    UNICODE_STRING userName, userDomain;

    PAGED_CODE( );

    if( SrvProductTypeServer == FALSE || !SrvXsActive ) {
        return STATUS_SUCCESS;
    }

    switch( Type ) {
    case XACTSRV_MESSAGE_LSREQUEST:

        if( Session->IsNullSession ||
            Session->IsLSNotified ) {

                return STATUS_SUCCESS;
        }

        ACQUIRE_LOCK( &Session->Connection->LicenseLock );

        if( Session->IsLSNotified == TRUE ) {
            RELEASE_LOCK( &Session->Connection->LicenseLock );
            return STATUS_SUCCESS;
        }

        //
        // Put domainname\username in the message
        //
        status = SrvGetUserAndDomainName( Session, &userName, &userDomain );
        if( !NT_SUCCESS( status ) ) {
            RELEASE_LOCK( &Session->Connection->LicenseLock );
            return status;
        }

        requestMessage.Message.LSRequest.UserName =
            SrvXsAllocateHeap( userDomain.Length + sizeof(WCHAR)
                               + userName.Length + sizeof(WCHAR), &status
                             );

        if ( requestMessage.Message.LSRequest.UserName == NULL ) {
            RELEASE_LOCK( &Session->Connection->LicenseLock );
            SrvReleaseUserAndDomainName( Session, &userName, &userDomain );
            return status;
        }

        if( userDomain.Length ) {
            RtlCopyMemory(
                requestMessage.Message.LSRequest.UserName,
                userDomain.Buffer,
                userDomain.Length
                );
        }

        requestMessage.Message.LSRequest.UserName[ userDomain.Length / sizeof(WCHAR) ] = L'\\';

        RtlCopyMemory(
            requestMessage.Message.LSRequest.UserName + (userDomain.Length / sizeof( WCHAR )) + 1,
            userName.Buffer,
            userName.Length
            );

        requestMessage.Message.LSRequest.UserName[ (userDomain.Length
                                                   + userName.Length) / sizeof( WCHAR )
                                                   + 1 ]
            = UNICODE_NULL;

        requestMessage.Message.LSRequest.IsAdmin = Session->IsAdmin;

        IF_DEBUG(LICENSE) {
            KdPrint(("XACTSRV_MESSAGE_LSREQUEST: %ws, IsAdmin: %d\n",
            requestMessage.Message.LSRequest.UserName,
            requestMessage.Message.LSRequest.IsAdmin ));
        }

        // Adjust the buffer pointers to be self relative within the buffer.

        requestMessage.Message.LSRequest.UserName =
            (PWSTR)((PUCHAR)requestMessage.Message.LSRequest.UserName + SrvXsPortMemoryDelta);

        SrvReleaseUserAndDomainName( Session, &userName, &userDomain );

        break;

    case XACTSRV_MESSAGE_LSRELEASE:

        if( Session->IsLSNotified == FALSE )
            return STATUS_SUCCESS;

        IF_DEBUG(LICENSE) {
            KdPrint(("XACTSRV_MESSAGE_LSRELEASE: Handle %p\n", Session->hLicense ));
        }


        requestMessage.Message.LSRelease.hLicense = Session->hLicense;

        break;

    default:

        ASSERT( !"Bad Type" );
        return STATUS_INVALID_PARAMETER;
    }

    requestMessage.PortMessage.u1.s1.DataLength =
            (USHORT)( sizeof(requestMessage) - sizeof(PORT_MESSAGE) );
    requestMessage.PortMessage.u1.s1.TotalLength = sizeof(requestMessage);
    requestMessage.PortMessage.u2.ZeroInit = 0;
    requestMessage.PortMessage.u2.s2.Type = LPC_KERNELMODE_MESSAGE;
    requestMessage.MessageType = Type;

    //
    // Send the message to XACTSRV and wait for a response message.
    //
    // !!! We may want to put a timeout on this.
    //

    status = NtRequestWaitReplyPort(
                 SrvXsPortHandle,
                 (PPORT_MESSAGE)&requestMessage,
                 (PPORT_MESSAGE)&replyMessage
                 );

    IF_DEBUG( ERRORS ) {
        if( !NT_SUCCESS( status ) ) {
            KdPrint(( "SrvXsLSOperation: NtRequestWaitReplyPort failed: %X\n", status ));
        }
    }

    if( NT_SUCCESS( status ) )
        status = replyMessage.Message.LSRequest.Status;

    switch( Type ) {

    case XACTSRV_MESSAGE_LSREQUEST:

        requestMessage.Message.LSRequest.UserName =
            (PWSTR)((PUCHAR)requestMessage.Message.LSRequest.UserName - SrvXsPortMemoryDelta);
        SrvXsFreeHeap( requestMessage.Message.LSRequest.UserName );

        if( NT_SUCCESS( status ) ) {
            Session->IsLSNotified = TRUE;
            Session->hLicense = replyMessage.Message.LSRequest.hLicense;
            IF_DEBUG( LICENSE ) {
                KdPrint(("  hLicense = %p\n", Session->hLicense ));
            }
        }
        RELEASE_LOCK( &Session->Connection->LicenseLock );
        break;

    case XACTSRV_MESSAGE_LSRELEASE:

        Session->IsLSNotified = FALSE;
        break;
    }

    IF_DEBUG( LICENSE ) {
        if( !NT_SUCCESS( status ) ) {
            KdPrint(( "    SrvXsLSOperation returning status %X\n", status ));
        }
    }

    return status;

} // SrvXsLSOperation


VOID
SrvXsPnpOperation(
    PUNICODE_STRING DeviceName,
    BOOLEAN Bind
)

/*++

Routine Description:

    This routine sends the Xact service a PNP notification

--*/

{
    PXACTSRV_REQUEST_MESSAGE requestMessage;
    PXACTSRV_REQUEST_MESSAGE responseMessage;
    ULONG len;
    NTSTATUS status;

    PAGED_CODE( );

    if( SrvXsPortHandle == NULL ) {
        IF_DEBUG( PNP ) {
            KdPrint(( "SRV: SrvXsPnpOperation no SRVSVC handle!\n" ));
        }
        return;
    }

    len = (sizeof( XACTSRV_REQUEST_MESSAGE ) * 2) + DeviceName->Length + sizeof( WCHAR );

    requestMessage = SrvXsAllocateHeap( len, &status );

    if( requestMessage == NULL ) {
        IF_DEBUG( PNP ) {
            KdPrint(( "SRV: SrvXsPnpOperation unable to allocate memory: %X\n", status ));
        }
        return;
    }

    RtlZeroMemory( requestMessage, len );

    responseMessage = requestMessage + 1;
    requestMessage->Message.Pnp.TransportName.Buffer = (PWCHAR)(responseMessage + 1);

    requestMessage->Message.Pnp.Bind = Bind;

    //
    // Send the name of the transport of interest to Xactsrv
    //
    requestMessage->Message.Pnp.TransportName.Length = DeviceName->Length;
    requestMessage->Message.Pnp.TransportName.MaximumLength = DeviceName->Length + sizeof( WCHAR );

    RtlCopyMemory( requestMessage->Message.Pnp.TransportName.Buffer,
                   DeviceName->Buffer,
                   DeviceName->Length
                 );

    //
    // Normalize the buffer pointer so xactsrv can rebase it
    //
    requestMessage->Message.Pnp.TransportName.Buffer =
            (PWSTR)((PUCHAR)requestMessage->Message.Pnp.TransportName.Buffer + SrvXsPortMemoryDelta);

    requestMessage->PortMessage.u1.s1.DataLength =
            (USHORT)( sizeof(*requestMessage) - sizeof(PORT_MESSAGE) );
    requestMessage->PortMessage.u1.s1.TotalLength = sizeof(*requestMessage);
    requestMessage->PortMessage.u2.ZeroInit = 0;
    requestMessage->PortMessage.u2.s2.Type = LPC_KERNELMODE_MESSAGE;
    requestMessage->MessageType = XACTSRV_MESSAGE_PNP;

    //
    // Send the message to XACTSRV
    //

    IF_DEBUG( PNP ) {
        KdPrint(( "SRV: Sending PNP %sbind request for %wZ to SRVSVC\n",
                    requestMessage->Message.Pnp.Bind ? "" : "un", DeviceName
               ));
    }

    status = NtRequestWaitReplyPort(
                 SrvXsPortHandle,
                 (PPORT_MESSAGE)requestMessage,
                 (PPORT_MESSAGE)responseMessage
                 );


    IF_DEBUG( PNP ) {
        if( !NT_SUCCESS( status ) ) {
            KdPrint(( "SRV: PNP response from xactsrv status %X\n", status ));
        }
    }

    SrvXsFreeHeap( requestMessage );
}


VOID
SrvXsDisconnect ( )
{
    NTSTATUS status;

    PAGED_CODE( );

    //
    // Acquire exclusive access to the port resource, to prevent new
    // requests from being started.
    //

    IF_DEBUG(XACTSRV) {
        KdPrint(( "SrvXsDisconnect: Xactsrv disconnect called.\n"));
    }

    ExAcquireResourceExclusiveLite( &SrvXsResource, TRUE );

    SrvXsActive = FALSE;

    SrvXsFreeSharedMemory();

    ExReleaseResourceLite( &SrvXsResource );

    IF_DEBUG(XACTSRV) {
        KdPrint(( "SrvXsDisconnect: SrvXsResource released.\n"));
    }

    return;

} // SrvXsDisconnect


VOID
SrvXsFreeSharedMemory (
    VOID
    )

/*++

Routine Description:

    This routine frees the xactsrv shared memory.  SrvXsResource assumed
    held exclusive.

Arguments:

    none.

Return Value:

    TRUE if xactsrv memory was freed, FALSE otherwise.

--*/

{
    PAGED_CODE( );

    //
    // Free up memory only if we don't have any transactions using the
    // shared memory.
    //

    if ( SrvXsSharedMemoryReference == 0 ) {
        if ( SrvXsPortMemoryHeap != NULL ) {
            RtlDestroyHeap( SrvXsPortMemoryHeap );
            SrvXsPortMemoryHeap = NULL;
        }

        if ( SrvXsSectionHandle != NULL ) {
            SrvNtClose( SrvXsSectionHandle, FALSE );
            SrvXsSectionHandle = NULL;
        }

        if ( SrvXsPortHandle != NULL ) {
            SrvNtClose( SrvXsPortHandle, FALSE );
            SrvXsPortHandle = NULL;
        }

        IF_DEBUG(XACTSRV) {
            KdPrint(( "SrvXsFreeSharedMemory: Xactsrv memory freed.\n" ));
        }
    } else {
        IF_DEBUG(XACTSRV) {
            KdPrint(( "SrvXsFreeSharedMemory: Active transactions %d.\n",
                        SrvXsSharedMemoryReference ));
        }
    }

    return;

} // SrvXsFreeSharedMemory


PVOID
SrvXsAllocateHeap (
    IN ULONG SizeOfAllocation OPTIONAL,
    OUT PNTSTATUS Status
    )

/*++

Routine Description:

    This routine allocates heap from the Xs shared memory.

Arguments:

    SizeOfAllocation - if specified, the number of bytes to allocate.
                       if zero, no memory will be allocated.

    Status - the status of the request.

Return Value:

    Address of the allocated memory.  NULL, if no memory is allocated.

--*/

{
    PVOID heapAllocated = NULL;

    PAGED_CODE( );

    *Status = STATUS_SUCCESS;

    //
    // Check that XACTSRV is active.  This must be done while holding
    // the resource.
    //

    ExAcquireResourceExclusiveLite( &SrvXsResource, TRUE );
    IF_DEBUG(XACTSRV) {
        KdPrint(( "SrvXsAllocateHeap: SrvXsResource acquired.\n"));
    }

    if ( !SrvXsActive ) {
        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvXsAllocateHeap: XACTSRV is not active.\n" ));
        }
        ExReleaseResourceLite( &SrvXsResource );
        IF_DEBUG(XACTSRV) {
            KdPrint(( "SrvXsAllocateHeap: SrvXsResource released.\n"));
        }
        *Status = STATUS_NOT_SUPPORTED;
        return NULL;
    }

    //
    // Increment reference to our shared memory.
    //

    SrvXsSharedMemoryReference++;

    IF_DEBUG(XACTSRV) {
        KdPrint(( "SrvXsAllocateHeap: Incremented transaction count = %d.\n",
            SrvXsSharedMemoryReference
            ));
    }

    //
    // If SizeOfAllocation == 0, then the caller does not want any heap
    // allocated and only wants to have the lock held.
    //

    IF_DEBUG(XACTSRV) {
        KdPrint(( "SrvXsAllocateHeap: Heap to allocate %d bytes.\n",
            SizeOfAllocation
            ));
    }

    if ( SizeOfAllocation > 0 ) {

        heapAllocated = RtlAllocateHeap(
                            SrvXsPortMemoryHeap,
                            HEAP_NO_SERIALIZE,
                            SizeOfAllocation
                            );

        if ( heapAllocated == NULL ) {

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvXsAllocateHeap: RtlAllocateHeap failed "
                    "to allocate %d bytes.\n",
                    SizeOfAllocation
                    ));
            }

            *Status = STATUS_INSUFF_SERVER_RESOURCES;
        }
    }

    //
    // Release the resource.
    //

    ExReleaseResourceLite( &SrvXsResource );
    IF_DEBUG(XACTSRV) {
        KdPrint(( "SrvXsAllocateHeap: SrvXsResource released.\n"));
    }

    return heapAllocated;

} // SrvXsAllocateHeap


VOID
SrvXsFreeHeap (
    IN PVOID MemoryToFree OPTIONAL
    )

/*++

Routine Description:

    This routine frees heap allocated through SrvXsAllocateHeap.

Arguments:

    MemoryToFree - pointer to the memory to be freed. If NULL, no memory
                    is freed.

Return Value:

    none.

--*/

{
    PAGED_CODE( );

    //
    // We need exclusive access to the resource in order to free
    // heap and decrement the reference count.
    //

    ExAcquireResourceExclusiveLite( &SrvXsResource, TRUE );
    IF_DEBUG(XACTSRV) {
        KdPrint(( "SrvXsFreeHeap: SrvXsResource acquired.\n"));
    }

    //
    // Free the allocated heap (if any).
    //

    if ( MemoryToFree != NULL ) {
        RtlFreeHeap( SrvXsPortMemoryHeap, 0, MemoryToFree );
        IF_DEBUG(XACTSRV) {
            KdPrint(( "SrvXsFreeHeap: Heap %p freed.\n", MemoryToFree ));
        }
    }

    //
    // Decrement the shared memory reference count, and check whether XS
    // shutdown is in progress.  If so, complete XS cleanup if the
    // reference count reaches 0.
    //

    ASSERT( SrvXsSharedMemoryReference > 0 );
    SrvXsSharedMemoryReference--;

    IF_DEBUG(XACTSRV) {
        KdPrint(( "SrvXsFreeHeap: Decrement transaction count = %d.\n",
            SrvXsSharedMemoryReference
            ));
    }

    //
    // If SrvXsActive is FALSE, XACTSRV cleanup is in progress.
    //

    if ( !SrvXsActive ) {
        SrvXsFreeSharedMemory( );
    }

    //
    // Release the resource.
    //

    ExReleaseResourceLite( &SrvXsResource );
    IF_DEBUG(XACTSRV) {
        KdPrint(( "SrvXsFreeHeap: SrvXsResource released.\n"));
    }

    return;

} // SrvXsFreeHeap
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\udfs\allocsup.c ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    AllocSup.c

Abstract:

    This module implements mappings to physical blocks on UDF media.  The basic
    structure used here is the Pcb, which contains lookup information for each
    partition reference in the volume.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]   	5-Sep-1996
    
Revision History:

    Tom Jolly       [TomJolly]  21-Jan-2000     CcPurge and append at vmcb end
    Tom Jolly       [TomJolly]   1-March-2000   UDF 2.01 support

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_ALLOCSUP)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_ALLOCSUP)

//
//  Local support routines.
//

PPCB
UdfCreatePcb (
    IN ULONG NumberOfPartitions
    );

NTSTATUS
UdfLoadSparingTables(
    PIRP_CONTEXT IrpContext,
    PVCB Vcb,
    PPCB Pcb,
    ULONG Reference
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfAddToPcb)
#pragma alloc_text(PAGE, UdfCompletePcb)
#pragma alloc_text(PAGE, UdfCreatePcb)
#pragma alloc_text(PAGE, UdfDeletePcb)
#pragma alloc_text(PAGE, UdfEquivalentPcb)
#pragma alloc_text(PAGE, UdfInitializePcb)
#pragma alloc_text(PAGE, UdfLookupAllocation)
#pragma alloc_text(PAGE, UdfLookupMetaVsnOfExtent)
#pragma alloc_text(PAGE, UdfLookupPsnOfExtent)
#endif


BOOLEAN
UdfLookupAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN LONGLONG FileOffset,
    OUT PLONGLONG DiskOffset,
    OUT PULONG ByteCount
    )

/*++

Routine Description:

    This routine looks through the mapping information for the file
    to find the logical diskoffset and number of bytes at that offset.

    This routine assumes we are looking up a valid range in the file.  If
    a mapping does not exist,

Arguments:

    Fcb - Fcb representing this stream.

    FileOffset - Lookup the allocation beginning at this point.

    DiskOffset - Address to store the logical disk offset.

    ByteCount - Address to store the number of contiguous bytes beginning
        at DiskOffset above.

Return Value:

    BOOLEAN - whether the extent is unrecorded data

--*/

{
    PVCB Vcb;

    BOOLEAN Recorded = TRUE;

    BOOLEAN Result;

    LARGE_INTEGER LocalPsn;
    LARGE_INTEGER LocalSectorCount;

    PAGED_CODE();

    //
    //  Check inputs
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    //
    //  We will never be looking up the allocations of embedded objects.
    //

    ASSERT( !FlagOn( Fcb->FcbState, FCB_STATE_EMBEDDED_DATA ));

    Vcb = Fcb->Vcb;

    LocalPsn.QuadPart = LocalSectorCount.QuadPart = 0;

    //
    //  Lookup the entry containing this file offset.
    //

    if (FlagOn( Fcb->FcbState, FCB_STATE_VMCB_MAPPING )) {

        //
        //  Map this offset into the metadata stream.
        //

        ASSERT( SectorOffset( Vcb, FileOffset ) == 0 );

        Result = UdfVmcbVbnToLbn( &Vcb->Vmcb,
                                  SectorsFromLlBytes( Vcb, FileOffset ),
                                  &LocalPsn.LowPart,
                                  &LocalSectorCount.LowPart );
    } else {

        //
        //  Map this offset in a regular stream.
        //

        ASSERT( FlagOn( Fcb->FcbState, FCB_STATE_MCB_INITIALIZED ));

        Result = FsRtlLookupLargeMcbEntry( &Fcb->Mcb,
                                           LlSectorsFromBytes( Vcb, FileOffset ),
                                           &LocalPsn.QuadPart,
                                           &LocalSectorCount.QuadPart,
                                           NULL,
                                           NULL,
                                           NULL );
    }

    //
    //  If within the Mcb then we use the data out of this entry and are nearly done.
    //

    if (Result) {

        if ( LocalPsn.QuadPart == -1 ) {

            //
            //  Regular files can have holey allocations which represent unrecorded extents.  For
            //  such extents which are sandwiched in between recorded extents of the file, the Mcb
            //  package tells us that it found a valid mapping but that it doesn't correspond to
            //  any extents on the media yet.  In this case, simply fake the disk offset.  The
            //  returned sector count is accurate.
            //

            *DiskOffset = 0;

            Recorded = FALSE;

        } else {

            //
            //  Now mimic the effects of physical sector sparing.  This may shrink the size of the
            //  returned run if sparing interrupted the extent on disc.
            //

            ASSERT( LocalPsn.HighPart == 0 );

            if (Vcb->Pcb->SparingMcb) {

                LONGLONG SparingPsn;
                LONGLONG SparingSectorCount;

                if (FsRtlLookupLargeMcbEntry( Vcb->Pcb->SparingMcb,
                                              LocalPsn.LowPart,
                                              &SparingPsn,
                                              &SparingSectorCount,
                                              NULL,
                                              NULL,
                                              NULL )) {

                    //
                    //  Only emit noise if we will really change anything as a result
                    //  of the sparing table.
                    //

                    if (SparingPsn != -1 ||
                        SparingSectorCount < LocalSectorCount.QuadPart) {

                        DebugTrace(( 0, Dbg, "UdfLookupAllocation, spared [%x, +%x) onto [%x, +%x)\n",
                                             LocalPsn.LowPart,
                                             LocalSectorCount.LowPart,
                                             (ULONG) SparingPsn,
                                             (ULONG) SparingSectorCount ));
                    }

                    //
                    //  If we did not land in a hole, map the sector.
                    //

                    if (SparingPsn != -1) {

                        LocalPsn.QuadPart = SparingPsn;
                    }

                    //
                    //  The returned sector count now reduces the previous sector count.
                    //  If we landed in a hole, this indicates that the trailing edge of
                    //  the extent is spared, if not this indicates that the leading
                    //  edge is spared.
                    //

                    if (SparingSectorCount < LocalSectorCount.QuadPart) {

                        LocalSectorCount.QuadPart = SparingSectorCount;
                    }
                }
            }

            *DiskOffset = LlBytesFromSectors( Vcb, LocalPsn.QuadPart ) + SectorOffset( Vcb, FileOffset );

            //
            //  Now we can apply method 2 fixups, which will again interrupt the size of the extent.
            //

            if (FlagOn( Vcb->VcbState, VCB_STATE_METHOD_2_FIXUP )) {

                LARGE_INTEGER SectorsToRunout;

                SectorsToRunout.QuadPart= UdfMethod2NextRunoutInSectors( Vcb, *DiskOffset );

                if (SectorsToRunout.QuadPart < LocalSectorCount.QuadPart) {

                    LocalSectorCount.QuadPart = SectorsToRunout.QuadPart;
                }

                *DiskOffset = UdfMethod2TransformByteOffset( Vcb, *DiskOffset );
            }
        }

    } else {

        //
        //  We know that prior to this call the system has restricted IO to points within the
        //  the file data.  Since we failed to find a mapping this is an unrecorded extent at
        //  the end of the file, so just conjure up a proper representation.
        //

        if ((Ccb != NULL) && FlagOn( Ccb->Flags, CCB_FLAG_ALLOW_EXTENDED_DASD_IO )) {
            
            LocalSectorCount.QuadPart = LlSectorsFromBytes( Vcb, ByteCount );
            *DiskOffset = FileOffset;
            
            Recorded = TRUE;
            
        } else {
        
            ASSERT( FileOffset < Fcb->FileSize.QuadPart );
            
            LocalSectorCount.QuadPart = LlSectorsFromBytes( Vcb, Fcb->FileSize.QuadPart ) -
                                        LlSectorsFromBytes( Vcb, FileOffset ) +
                                        1;
            *DiskOffset = 0;
            
            Recorded = FALSE;

        }
        
    }

    //
    //  Restrict to MAXULONG bytes of allocation
    //

    if (LocalSectorCount.QuadPart > SectorsFromBytes( Vcb, MAXULONG )) {

        *ByteCount = MAXULONG;

    } else {

        *ByteCount = BytesFromSectors( Vcb, LocalSectorCount.LowPart );
    }

    *ByteCount -= SectorOffset( Vcb, FileOffset );

    return Recorded;
}


VOID
UdfDeletePcb (
    IN PPCB Pcb
    )

/*++

Routine Description:

    This routine deallocates a Pcb and all ancilliary structures.

Arguments:

    Pcb - Pcb being deleted

Return Value:

    None

--*/

{
    PUDF_PARTITION Partition;

    if (Pcb->SparingMcb) {

        FsRtlUninitializeLargeMcb( Pcb->SparingMcb );
        UdfFreePool( &Pcb->SparingMcb );
    }

    for (Partition = Pcb->Partition;
         Partition < &Pcb->Partition[Pcb->Partitions];
         Partition++) {

        switch (Partition->Type) {

            case Physical:

                UdfFreePool( &Partition->Physical.PartitionDescriptor );
                UdfFreePool( &Partition->Physical.SparingMap );                

                break;

            case Virtual:
            case Uninitialized:
                break;

            default:

                ASSERT( FALSE );
                break;
        }
    }

    ExFreePool( Pcb );
}


NTSTATUS
UdfInitializePcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN OUT PPCB *Pcb,
    IN PNSR_LVOL LVD
    )

/*++

Routine Description:

    This routine walks through the partition map of a Logical Volume Descriptor
    and builds an intializing Pcb from it.  The Pcb will be ready to be used
    in searching for the partition descriptors of a volume.

Arguments:

    Vcb - The volume this Pcb will pertain to

    Pcb - Caller's pointer to the Pcb

    LVD - The Logical Volume Descriptor being used

Return Value:

    STATUS_SUCCESS if the partition map is good and the Pcb is built

    STATUS_DISK_CORRUPT_ERROR if corrupt maps are found

    STATUS_UNRECOGNIZED_VOLUME if noncompliant maps are found

--*/

{
    PPARTMAP_UDF_GENERIC Map;
    PUDF_PARTITION Partition;

    BOOLEAN Found;

    PAGED_CODE();

    //
    //  Check the input parameters
    //

    ASSERT_OPTIONAL_PCB( *Pcb );

    DebugTrace(( +1, Dbg,
                 "UdfInitializePcb, Lvd %08x\n",
                 LVD ));

    //
    //  Delete a pre-existing (partially initialized from a failed
    //  crawl of a VDS) Pcb.
    //

    if (*Pcb != NULL) {

        UdfDeletePcb( *Pcb );
        *Pcb = NULL;
    }

    *Pcb = UdfCreatePcb( LVD->MapTableCount );

    //
    //  Walk the table of partition maps intializing the Pcb for the descriptor
    //  initialization pass.
    //

    for (Map = (PPARTMAP_UDF_GENERIC) LVD->MapTable,
         Partition = (*Pcb)->Partition;

         Partition < &(*Pcb)->Partition[(*Pcb)->Partitions];

         Map = Add2Ptr( Map, Map->Length, PPARTMAP_UDF_GENERIC ),
         Partition++) {

        //
        //  Now check that this LVD can actually contain this map entry.  First check that
        //  the descriptor can contain the first few fields, then check that it can hold
        //  all of the bytes claimed by the descriptor.
        //

        if (Add2Ptr( Map, sizeof( PARTMAP_GENERIC ), PCHAR ) > Add2Ptr( LVD, ISONsrLvolSize( LVD ), PCHAR ) ||
            Add2Ptr( Map, Map->Length,               PCHAR ) > Add2Ptr( LVD, ISONsrLvolSize( LVD ), PCHAR )) {

            DebugTrace(( 0, Dbg,
                         "UdfInitializePcb, map at +%04x beyond Lvd size %04x\n",
                         (PCHAR) Map - (PCHAR) LVD,
                         ISONsrLvolSize( LVD )));

            DebugTrace(( -1, Dbg,
                         "UdfInitializePcb -> STATUS_DISK_CORRUPT_ERROR\n" ));

            return STATUS_DISK_CORRUPT_ERROR;
        }

        //
        //  Now load up this map entry.
        //

        switch (Map->Type) {

            case PARTMAP_TYPE_PHYSICAL:

                {
                    PPARTMAP_PHYSICAL MapPhysical = (PPARTMAP_PHYSICAL) Map;

                    //
                    //  Type 1 - Physical Partition
                    //

                    DebugTrace(( 0, Dbg,
                                 "UdfInitializePcb, map reference %02x is Physical (Partition # %08x)\n",
                                 (Partition - (*Pcb)->Partition)/sizeof(UDF_PARTITION),
                                 MapPhysical->Partition ));

                    //
                    //  It must be the case that the volume the partition is on is the first
                    //  one since we only do single disc UDF.  This will have already been
                    //  checked by the caller.
                    //

                    if (MapPhysical->VolSetSeq > 1) {

                        DebugTrace(( 0, Dbg,
                                     "UdfInitializePcb, ... but physical partition resides on volume set volume # %08x (> 1)!\n",
                                     MapPhysical->VolSetSeq ));

                        DebugTrace(( -1, Dbg,
                                     "UdfInitializePcb -> STATUS_DISK_CORRUPT_ERROR\n" ));

                        return STATUS_DISK_CORRUPT_ERROR;
                    }

                    SetFlag( (*Pcb)->Flags, PCB_FLAG_PHYSICAL_PARTITION );
                    Partition->Type = Physical;
                    Partition->Physical.PartitionNumber = MapPhysical->Partition;
                }

                break;

            case PARTMAP_TYPE_PROXY:

                //
                //  Type 2 - a Proxy Partition, something not explicitly physical.
                //

                DebugTrace(( 0, Dbg,
                             "UdfInitializePcb, map reference %02x is a proxy\n",
                             (Partition - (*Pcb)->Partition)/sizeof(UDF_PARTITION)));

                //
                //  Handle the various types of proxy partitions we recognize
                //

                if (UdfDomainIdentifierContained( &Map->PartID,
                                                  &UdfVirtualPartitionDomainIdentifier,
                                                  UDF_VERSION_150,
                                                  UDF_VERSION_RECOGNIZED )) {

                    {
                        PPARTMAP_VIRTUAL MapVirtual = (PPARTMAP_VIRTUAL) Map;

                        //
                        //  Only one of these guys can exist, since there can be only one VAT per media surface.
                        //

                        if (FlagOn( (*Pcb)->Flags, PCB_FLAG_VIRTUAL_PARTITION )) {

                            DebugTrace(( 0, Dbg,
                                         "UdfInitializePcb, ... but this is a second virtual partition!?!!\n" ));

                            DebugTrace(( -1, Dbg,
                                         "UdfInitializePcb -> STATUS_UNCRECOGNIZED_VOLUME\n" ));

                            return STATUS_UNRECOGNIZED_VOLUME;
                        }

                        DebugTrace(( 0, Dbg,
                                     "UdfInitializePcb, ... Virtual (Partition # %08x)\n",
                                     MapVirtual->Partition ));

                        SetFlag( (*Pcb)->Flags, PCB_FLAG_VIRTUAL_PARTITION );
                        Partition->Type = Virtual;

                        //
                        //  We will convert the partition number to a partition reference
                        //  before returning.
                        //

                        Partition->Virtual.RelatedReference = MapVirtual->Partition;
                    }

                } else if (UdfDomainIdentifierContained( &Map->PartID,
                                                         &UdfSparablePartitionDomainIdentifier,
                                                         UDF_VERSION_150,
                                                         UDF_VERSION_RECOGNIZED )) {

                    {
                        NTSTATUS Status;
                        PPARTMAP_SPARABLE MapSparable = (PPARTMAP_SPARABLE) Map;

                        //
                        //  It must be the case that the volume the partition is on is the first
                        //  one since we only do single disc UDF.  This will have already been
                        //  checked by the caller.
                        //

                        if (MapSparable->VolSetSeq > 1) {

                            DebugTrace(( 0, Dbg,
                                         "UdfInitializePcb, ... but sparable partition resides on volume set volume # %08x (> 1)!\n",
                                         MapSparable->VolSetSeq ));

                            DebugTrace(( -1, Dbg,
                                         "UdfInitializePcb -> STATUS_DISK_CORRUPT_ERROR\n" ));

                            return STATUS_DISK_CORRUPT_ERROR;
                        }

                        DebugTrace(( 0, Dbg,
                                     "UdfInitializePcb, ... Sparable (Partition # %08x)\n",
                                     MapSparable->Partition ));

                        //
                        //  We pretend that sparable partitions are basically the same as
                        //  physical partitions.  Since we are not r/w (and will never be
                        //  on media that requires host-based sparing in any case), this
                        //  is a good simplification.
                        //

                        SetFlag( (*Pcb)->Flags, PCB_FLAG_SPARABLE_PARTITION );
                        Partition->Type = Physical;
                        Partition->Physical.PartitionNumber = MapSparable->Partition;

                        //
                        //  Save this map for use when the partition descriptor is found.
                        //  We can't load the sparing table at this time because we have
                        //  to turn the Lbn->Psn mapping into a Psn->Psn mapping.  UDF
                        //  believes that the way sparing will be used in concert with
                        //  the Lbn->Psn mapping engine (like UdfLookupPsnOfExtent).
                        //
                        //  Unfortunately, this would be a bit painful at this time.
                        //  The users of UdfLookupPsnOfExtent would need to iterate
                        //  over a new interface (not so bad) but the Vmcb package
                        //  would need to be turned inside out so that it didn't do
                        //  the page-filling alignment of blocks in the metadata
                        //  stream - instead, UdfLookupMetaVsnOfExtent would need to
                        //  do this itself.  I choose to lay the sparing engine into
                        //  the read path and raw sector read engine instead.
                        //

                        Partition->Physical.SparingMap = FsRtlAllocatePoolWithTag( PagedPool,
                                                                                   sizeof(PARTMAP_SPARABLE),
                                                                                   TAG_NSR_FSD);
                        RtlCopyMemory( Partition->Physical.SparingMap,
                                       MapSparable,
                                       sizeof(PARTMAP_SPARABLE));
                    }

                } else {

                    DebugTrace(( 0, Dbg,
                                 "UdfInitializePcb, ... but we don't recognize this proxy!\n" ));

                    DebugTrace(( -1, Dbg,
                                 "UdfInitializePcb -> STATUS_UNRECOGNIZED_VOLUME\n" ));

                    return STATUS_UNRECOGNIZED_VOLUME;
                }

                break;

            default:

                DebugTrace(( 0, Dbg,
                             "UdfInitializePcb, map reference %02x is of unknown type %02x\n",
                             Map->Type ));

                DebugTrace(( -1, Dbg,
                             "UdfInitializePcb -> STATUS_UNRECOGNIZED_VOLUME\n" ));

                return STATUS_UNRECOGNIZED_VOLUME;
                break;
        }
    }

    if (!FlagOn( (*Pcb)->Flags, PCB_FLAG_PHYSICAL_PARTITION | PCB_FLAG_SPARABLE_PARTITION )) {

        DebugTrace(( 0, Dbg,
                     "UdfInitializePcb, no physical partition seen on this logical volume!\n" ));

        DebugTrace(( -1, Dbg,
                     "UdfInitializePcb -> STATUS_UNRECOGNIZED_VOLUME\n" ));

        return STATUS_UNRECOGNIZED_VOLUME;
    }

    if (FlagOn( (*Pcb)->Flags, PCB_FLAG_VIRTUAL_PARTITION )) {

        PUDF_PARTITION Host;

        //
        //  Confirm the validity of any type 2 virtual maps on this volume
        //  and convert partition numbers to partition references that will
        //  immediately index an element of the Pcb.
        //

        for (Partition = (*Pcb)->Partition;
             Partition < &(*Pcb)->Partition[(*Pcb)->Partitions];
             Partition++) {

            if (Partition->Type == Virtual) {

                //
                //  Go find the partition this thing is talking about
                //

                Found = FALSE;

                for (Host = (*Pcb)->Partition;
                     Host < &(*Pcb)->Partition[(*Pcb)->Partitions];
                     Host++) {

                    if (Host->Type == Physical &&
                        Host->Physical.PartitionNumber ==
                        Partition->Virtual.RelatedReference) {

                        Partition->Virtual.RelatedReference =
                            (USHORT)(Host - (*Pcb)->Partition)/sizeof(UDF_PARTITION);
                        Found = TRUE;
                        break;
                    }
                }

                //
                //  Failure to find a physical partition for this virtual guy
                //  is not a good sign.
                //

                if (!Found) {

                    return STATUS_DISK_CORRUPT_ERROR;
                }
            }
        }
    }

    DebugTrace(( -1, Dbg,
             "UdfInitializePcb -> STATUS_SUCCESS\n" ));

    return STATUS_SUCCESS;
}


VOID
UdfAddToPcb (
    IN PPCB Pcb,
    IN PNSR_PART PartitionDescriptor
)

/*++

Routine Description:

    This routine possibly adds a partition descriptor into a Pcb if it
    turns out to be of higher precendence than a descriptor already
    present.  Used in building a Pcb already initialized in preperation
    for UdfCompletePcb.

Arguments:

    Vcb - Vcb of the volume the Pcb describes

    Pcb - Pcb being filled in

Return Value:

    None. An old partition descriptor may be returned in the input field.

--*/

{
    USHORT Reference;

    PAGED_CODE();

    //
    //  Check inputs
    //

    ASSERT_PCB( Pcb );
    ASSERT( PartitionDescriptor );

    for (Reference = 0;
         Reference < Pcb->Partitions;
         Reference++) {

        DebugTrace(( 0, Dbg, "UdfAddToPcb,  considering partition reference %d (type %d)\n", (ULONG)Reference, Pcb->Partition[Reference].Type));
        
        switch (Pcb->Partition[Reference].Type) {

            case Physical:

                //
                //  Now possibly store this descriptor in the Pcb if it is
                //  the partition number for this partition reference.
                //

                if (Pcb->Partition[Reference].Physical.PartitionNumber == PartitionDescriptor->Number) {

                    //
                    //  It seems to be legal (if questionable) for multiple partition maps to reference 
                    //  the same partition descriptor.  So we make a copy of the descriptor for each 
                    //  referencing partitionmap to make life easier when it comes to freeing it.
                    //

                    UdfStoreVolumeDescriptorIfPrevailing( (PNSR_VD_GENERIC *) &Pcb->Partition[Reference].Physical.PartitionDescriptor,
                                                          (PNSR_VD_GENERIC) PartitionDescriptor );
                }
                
                break;

            case Virtual:
                break;

            default:

                ASSERT(FALSE);
                break;
        }
    }
}


NTSTATUS
UdfCompletePcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PPCB Pcb
    )

/*++

Routine Description:

    This routine completes initialization of a Pcb which has been filled
    in with partition descriptors.  Initialization-time data such as the
    physical partition descriptors will be returned to the system.

Arguments:

    Vcb - Vcb of the volume the Pcb describes

    Pcb - Pcb being completed

Return Value:

    NTSTATUS according to whether intialization completion was succesful

--*/

{
    ULONG Reference;

    NTSTATUS Status;

    PAGED_CODE();

    //
    //  Check inputs
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );
    ASSERT_PCB( Pcb );

    DebugTrace(( +1, Dbg, "UdfCompletePcb, Vcb %08x Pcb %08x\n", Vcb, Pcb ));

    //
    //  Complete intialization all physical partitions
    //

    for (Reference = 0;
         Reference < Pcb->Partitions;
         Reference++) {

        DebugTrace(( 0, Dbg, "UdfCompletePcb, Examining Ref %u (type %u)!\n", Reference, Pcb->Partition[Reference].Type));

        switch (Pcb->Partition[Reference].Type) {

            case Physical:

                if (Pcb->Partition[Reference].Physical.PartitionDescriptor == NULL) {

                    DebugTrace(( 0, Dbg,
                                 "UdfCompletePcb, ... but didn't find Partition# %u!\n",
                                 Pcb->Partition[Reference].Physical.PartitionNumber ));

                    DebugTrace(( -1, Dbg, "UdfCompletePcb -> STATUS_DISK_CORRUPT_ERROR\n" ));

                    return STATUS_DISK_CORRUPT_ERROR;
                }

                Pcb->Partition[Reference].Physical.Start =
                    Pcb->Partition[Reference].Physical.PartitionDescriptor->Start;
                Pcb->Partition[Reference].Physical.Length =
                    Pcb->Partition[Reference].Physical.PartitionDescriptor->Length;


                //
                //  Retrieve the sparing information at this point if appropriate.
                //  We have to do this when we can map logical -> physical blocks.
                //

                if (Pcb->Partition[Reference].Physical.SparingMap) {

                    Status = UdfLoadSparingTables( IrpContext,
                                                   Vcb,
                                                   Pcb,
                                                   Reference );

                    if (!NT_SUCCESS( Status )) {

                        DebugTrace(( -1, Dbg,
                                     "UdfCompletePcb -> %08x\n", Status ));
                        return Status;
                    }
                }

                DebugTrace(( 0, Dbg, "Start Psn: 0x%X,  sectors: 0x%x\n", 
                             Pcb->Partition[Reference].Physical.Start,
                             Pcb->Partition[Reference].Physical.Length));

                //
                //  We will not need the descriptor or sparing map anymore, so drop them.  
                //

                UdfFreePool( &Pcb->Partition[Reference].Physical.PartitionDescriptor );
                UdfFreePool( &Pcb->Partition[Reference].Physical.SparingMap );
                break;

            case Virtual:
                break;

            default:

                ASSERT(FALSE);
                break;
        }
    }

    DebugTrace(( -1, Dbg, "UdfCompletePcb -> STATUS_SUCCESS\n" ));

    return STATUS_SUCCESS;
}


BOOLEAN
UdfEquivalentPcb (
    IN PIRP_CONTEXT IrpContext,
    IN PPCB Pcb1,
    IN PPCB Pcb2
    )

/*++

Routine Description:

    This routine compares two completed Pcbs to see if they appear equivalent.

Arguments:

    Pcb1 - Pcb being compared

    Pcb2 - Pcb being compared

Return Value:

    BOOLEAN according to whether they are equivalent (TRUE, else FALSE)

--*/

{
    ULONG Index;

    PAGED_CODE();

    //
    //  Check input.
    //

    ASSERT_IRP_CONTEXT( IrpContext );

    if (Pcb1->Partitions != Pcb2->Partitions) {

        return FALSE;
    }

    for (Index = 0;
         Index < Pcb1->Partitions;
         Index++) {

        //
        //  First check that the partitions are of the same type.
        //

        if (Pcb1->Partition[Index].Type != Pcb2->Partition[Index].Type) {

            return FALSE;
        }

        //
        //  Now the map content must be the same ...
        //

        switch (Pcb1->Partition[Index].Type) {

            case Physical:

                if (Pcb1->Partition[Index].Physical.PartitionNumber != Pcb2->Partition[Index].Physical.PartitionNumber ||
                    Pcb1->Partition[Index].Physical.Length != Pcb2->Partition[Index].Physical.Length ||
                    Pcb1->Partition[Index].Physical.Start != Pcb2->Partition[Index].Physical.Start) {

                    return FALSE;
                }
                break;

            case Virtual:

                if (Pcb1->Partition[Index].Virtual.RelatedReference != Pcb2->Partition[Index].Virtual.RelatedReference) {

                    return FALSE;
                }
                break;

            default:

                ASSERT( FALSE);
                return FALSE;
                break;
        }
    }

    //
    //  All map elements were equivalent.
    //

    return TRUE;
}


ULONG
UdfLookupPsnOfExtent (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN USHORT Reference,
    IN ULONG Lbn,
    IN ULONG Len
    )

/*++

Routine Description:

    This routine maps the input logical block extent on a given partition to
    a starting physical sector.  It doubles as a bounds checker - if the routine
    does not raise, the caller is guaranteed that the extent lies within the
    partition.

Arguments:

    Vcb - Vcb of logical volume

    Reference - Partition reference to use in the mapping

    Lbn - Logical block number

    Len - Length of extent in bytes

Return Value:

    ULONG physical sector number

--*/

{
    PPCB Pcb = Vcb->Pcb;
    ULONG Psn;

    PBCB Bcb;
    LARGE_INTEGER Offset;
    PULONG MappedLbn;

    PAGED_CODE();

    //
    //  Check inputs
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );
    ASSERT_PCB( Pcb );

    DebugTrace(( +1, Dbg, "UdfLookupPsnOfExtent, [%04x/%08x, +%08x)\n", Reference, Lbn, Len ));

    if (Reference < Pcb->Partitions) {

        while (TRUE) {

            switch (Pcb->Partition[Reference].Type) {

                case Physical:

                    //
                    //  Check that the input extent lies inside the partition.  Calculate the
                    //  Lbn of the last block and see that it is interior.
                    //

                    if (SectorsFromBlocks( Vcb, Lbn ) + SectorsFromBytes( Vcb, Len ) >
                        Pcb->Partition[Reference].Physical.Length) {

                        goto NoGood;
                    }

                    Psn = Pcb->Partition[Reference].Physical.Start + SectorsFromBlocks( Vcb, Lbn );

                    DebugTrace(( -1, Dbg, "UdfLookupPsnOfExtent -> %08x\n", Psn ));
                    return Psn;

                case Virtual:

                    //
                    //  Bounds check.  Per UDF 2.00 2.3.10 and implied in UDF 1.50, virtual
                    //  extent lengths cannot be greater than one block in size.  Lbn must also
                    //  fall within the VAT!
                    //

                    if ((Lbn >= Vcb->VATEntryCount) || (Len > BlockSize( Vcb )))  {

                        DebugTrace(( 0, Dbg, "UdfLookupPsnOfExtent() - Either Lbn (0x%x) > VatLbns (0x%X), or len (0x%x) > blocksize (0x%x)\n", Lbn, Vcb->VATEntryCount, Len, BlockSize(Vcb)));
                        goto NoGood;
                    }

                    try {

                        Bcb = NULL;
                        
                        //
                        //  Calculate the location of the mapping element in the VAT
                        //  and retrieve.  Bias by the size of the VAT header,  if any.
                        //

                        Offset.QuadPart = Vcb->OffsetToFirstVATEntry + Lbn * sizeof(ULONG);

                        CcMapData( Vcb->VatFcb->FileObject,
                                   &Offset,
                                   sizeof(ULONG),
                                   TRUE,
                                   &Bcb,
                                   &MappedLbn );

                        //
                        //  Now rewrite the inputs in terms of the virtual mapping.  We
                        //  will reloop to perform the logical -> physical mapping.
                        //

                        DebugTrace(( 0, Dbg,
                                     "UdfLookupPsnOfExtent, Mapping V %04x/%08x -> L %04x/%08x\n",
                                     Reference,
                                     Lbn,
                                     Pcb->Partition[Reference].Virtual.RelatedReference,
                                     *MappedLbn ));

                        Lbn = *MappedLbn;
                        Reference = Pcb->Partition[Reference].Virtual.RelatedReference;

                    } finally {

                        DebugUnwind( UdfLookupPsnOfExtent );

                        UdfUnpinData( IrpContext, &Bcb );
                    }

                    //
                    //  An Lbn of ~0 in the VAT is defined to indicate that the sector is unused,
                    //  so we should never see such a thing.
                    //

                    if (Lbn == ~0) {

                        goto NoGood;
                    }

                    break;

                default:

                    ASSERT(FALSE);
                    break;
            }
        }
    }

    NoGood:

    //
    //  Some people have misinterpreted a partition number to equal a
    //  partition reference, or perhaps this is just corrupt media.
    //

    UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
}


ULONG
UdfLookupMetaVsnOfExtent (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN USHORT Reference,
    IN ULONG Lbn,
    IN ULONG Len,
    IN BOOLEAN ExactEnd
    )

/*++

Routine Description:

    This routine maps the input logical block extent on a given partition to
    a starting virtual block in the metadata stream.  If a mapping does not
    exist, one will be created and the metadata stream extended.

    Callers must hold NO mappings into the VMCB stream when calling this
    function.
    
Arguments:

    Vcb - Vcb of logical volume

    Reference - Partition reference to use in the mapping

    Lbn - Logical block number

    Len - Length of extent in bytes
    
    ExactEnd - Indicates the extension policy if these blocks are not mapped.

Return Value:

    ULONG virtual sector number

    Raised status if the Lbn extent is split across multiple Vbn extents.

--*/

{
    ULONG Vsn;
    ULONG Psn;
    ULONG SectorCount;

    BOOLEAN Result;

    BOOLEAN UnwindExtension = FALSE;
    BOOLEAN UnwindVmcb = FALSE;
    LONGLONG UnwindAllocationSize;

    PFCB Fcb = NULL;

    //
    //  Check inputs
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    //
    //  The extent must be a multiple of blocksize
    //

    if ((0 == Len) || BlockOffset( Vcb, Len)) {

        UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
    }

    //
    //  Get the physical mapping of the extent.  The Mcb package operates on ULONG/ULONG
    //  keys and values so we must render our 48bit address into 32.  We can do this since
    //  this is a single surface implementation, and it is guaranteed that a surface cannot
    //  contain more than MAXULONG physical sectors.
    //

    Psn = UdfLookupPsnOfExtent( IrpContext,
                                Vcb,
                                Reference,
                                Lbn,
                                Len );

    //
    //  Use try-finally for cleanup
    //

    try {

        //
        //  We must safely establish a mapping and extend the metadata stream so that cached
        //  reads can occur on this new extent.  This lock was moved out here (rather than just
        //  protecting the actual Fcb changes) to protect against mappings being made
        //  by other threads between this thread extending the vmcb and calling CcSetFileSizes.
        //  this would result in zeroed pages being mapped...
        //
        
        Fcb = Vcb->MetadataFcb;
        UdfLockFcb( IrpContext, Fcb );

        //
        //  Add / lookup the mapping.  We know that it is being added to the end of the stream.
        //
        
        UnwindVmcb = UdfAddVmcbMapping(IrpContext,
                                       &Vcb->Vmcb,
                                       Psn,
                                       SectorsFromBytes( Vcb, Len ),
                                       ExactEnd,
                                       &Vsn,
                                       &SectorCount );

        ASSERT( SectorCount >= SectorsFromBytes( Vcb, Len));

        //
        //  If this was a new mapping,  then we need to extend the Vmcb file size
        //
        
        if (UnwindVmcb)  {

            UnwindAllocationSize = Fcb->AllocationSize.QuadPart;
            UnwindExtension = TRUE;

            Fcb->AllocationSize.QuadPart =
            Fcb->FileSize.QuadPart =
            Fcb->ValidDataLength.QuadPart = LlBytesFromSectors( Vcb, Vsn + SectorCount);

            CcSetFileSizes( Fcb->FileObject, (PCC_FILE_SIZES) &Fcb->AllocationSize );
            UnwindExtension = FALSE;
        }

    } 
    finally {

        if (UnwindExtension) {

            ULONG FirstZappedVsn;

            //
            //  Strip off the additional mappings we made.
            //

            Fcb->AllocationSize.QuadPart =
            Fcb->FileSize.QuadPart =
            Fcb->ValidDataLength.QuadPart = UnwindAllocationSize;

            FirstZappedVsn = SectorsFromLlBytes( Vcb, UnwindAllocationSize );

            if (UnwindVmcb)  {
                
                UdfRemoveVmcbMapping( &Vcb->Vmcb,
                                      FirstZappedVsn,
                                      Vsn + SectorCount - FirstZappedVsn );
            }

            CcSetFileSizes( Fcb->FileObject, (PCC_FILE_SIZES) &Fcb->AllocationSize );
        }

        if (Fcb) { UdfUnlockFcb( IrpContext, Fcb ); }
    }

    return Vsn;
}


//
//  Local support routine.
//

PPCB
UdfCreatePcb (
    IN ULONG NumberOfPartitions
    )

/*++

Routine Description:

    This routine creates a new Pcb of the indicated size.

Arguments:

    NumberOfPartitions - Number of partitions this Pcb will describe

Return Value:

    PPCB - the Pcb created

--*/

{
    PPCB Pcb;
    ULONG Size = sizeof(PCB) + sizeof(UDF_PARTITION)*NumberOfPartitions;

    PAGED_CODE();

    ASSERT( NumberOfPartitions );
    ASSERT( NumberOfPartitions < MAXUSHORT );

    Pcb = (PPCB) FsRtlAllocatePoolWithTag( UdfPagedPool,
                                           Size,
                                           TAG_PCB );

    RtlZeroMemory( Pcb, Size );

    Pcb->NodeTypeCode = UDFS_NTC_PCB;
    Pcb->NodeByteSize = (USHORT) Size;

    Pcb->Partitions = (USHORT)NumberOfPartitions;

    return Pcb;
}


//
//  Internal support routine
//

NTSTATUS
UdfLoadSparingTables(
    PIRP_CONTEXT IrpContext,
    PVCB Vcb,
    PPCB Pcb,
    ULONG Reference
    )

/*++

Routine Description:

    This routine reads the sparing tables for a partition and fills
    in the sparing Mcb.

Arguments:

    Vcb - the volume hosting the spared partition

    Pcb - the partion block corresponding to the volume

    Reference - the partition reference being pulled in

Return Value:

    NTSTATUS according to whether the sparing tables were loaded

--*/

{
    NTSTATUS Status;

    ULONG SparingTable;
    PULONG SectorBuffer;
    ULONG Psn;

    ULONG RemainingBytes;
    ULONG ByteOffset;
    ULONG TotalBytes;

    BOOLEAN Complete;

    PSPARING_TABLE_HEADER Header;
    PSPARING_TABLE_ENTRY Entry;

    PUDF_PARTITION Partition = &Pcb->Partition[Reference];
    PPARTMAP_SPARABLE Map = Partition->Physical.SparingMap;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    ASSERT( Map != NULL );

    DebugTrace(( +1, Dbg, "UdfLoadSparingTables, Vcb %08x, PcbPartition %08x, Map @ %08x\n", Vcb, Partition, Map ));

    DebugTrace(( 0, Dbg, "UdfLoadSparingTables, Map sez: PacketLen %u, NTables %u, TableSize %u\n",
                         Map->PacketLength,
                         Map->NumSparingTables,
                         Map->TableSize));


    //
    //  Check that the sparable map appears sane.  If there are no sparing tables that
    //  is pretty OK, and it'll wind up looking like a regular physical partition.
    //

    if (Map->NumSparingTables == 0) {

        DebugTrace((  0, Dbg, "UdfLoadSparingTables, no sparing tables claimed!\n" ));
        DebugTrace(( -1, Dbg, "UdfLoadSparingTables -> STATUS_SUCCESS\n" ));
        return STATUS_SUCCESS;
    }

    if (Map->NumSparingTables > sizeof(Map->TableLocation)/sizeof(ULONG)) {

        DebugTrace((  0, Dbg, "UdfLoadSparingTables, too many claimed tables to fit! (max %u)\n",
                              sizeof(Map->TableLocation)/sizeof(ULONG)));
        DebugTrace(( -1, Dbg, "UdfLoadSparingTables -> STATUS_DISK_CORRUPT_ERROR\n" ));
        return  STATUS_DISK_CORRUPT_ERROR;
    }

    if ((Map->PacketLength != UDF_SPARING_PACKET_LENGTH_CDRW) &&
        (Map->PacketLength != UDF_SPARING_PACKET_LENGTH_DVDRW)) {

        DebugTrace((  0, Dbg, "UdfLoadSparingTables, packet size is %u!\n",
                              Map->PacketLength));
        DebugTrace(( -1, Dbg, "UdfLoadSparingTables -> STATUS_DISK_CORRUPT_ERROR\n" ));
        return  STATUS_DISK_CORRUPT_ERROR;
    }

    if (Map->TableSize < sizeof(SPARING_TABLE_HEADER) ||
        (Map->TableSize - sizeof(SPARING_TABLE_HEADER)) % sizeof(SPARING_TABLE_ENTRY) != 0) {

        DebugTrace((  0, Dbg, "UdfLoadSparingTables, sparing table size is too small or unaligned!\n" ));
        DebugTrace(( -1, Dbg, "UdfLoadSparingTables -> STATUS_DISK_CORRUPT_ERROR\n" ));
        return  STATUS_DISK_CORRUPT_ERROR;
    }

#ifdef UDF_SANITY
    DebugTrace(( 0, Dbg, "UdfLoadSparingTables" ));
    for (SparingTable = 0; SparingTable < Map->NumSparingTables; SparingTable++) {

        DebugTrace(( 0, Dbg, ", Table %u @ %x", SparingTable, Map->TableLocation[SparingTable] ));
    }
    DebugTrace(( 0, Dbg, "\n" ));
#endif

    //
    //  If a sparing mcb doesn't exist, manufacture one.
    //

    if (Pcb->SparingMcb == NULL) {

        Pcb->SparingMcb = FsRtlAllocatePoolWithTag( PagedPool, sizeof(LARGE_MCB), TAG_SPARING_MCB );
        FsRtlInitializeLargeMcb( Pcb->SparingMcb, PagedPool );
    }

    SectorBuffer = FsRtlAllocatePoolWithTag( PagedPool, PAGE_SIZE, TAG_NSR_FSD );

    //
    //  Now loop across the sparing tables and pull the data in.
    //

    try {

        for (Complete = FALSE, SparingTable = 0;

             SparingTable < Map->NumSparingTables;

             SparingTable++) {

            DebugTrace((  0, Dbg, "UdfLoadSparingTables, loading sparing table %u!\n",
                                  SparingTable ));

            ByteOffset = 0;
            TotalBytes = 0;
            RemainingBytes = 0;

            do {

                if (RemainingBytes == 0) {

                    (VOID) UdfReadSectors( IrpContext,
                                           BytesFromSectors( Vcb, Map->TableLocation[SparingTable] ) + ByteOffset,
                                           SectorSize( Vcb ),
                                           FALSE,
                                           SectorBuffer,
                                           Vcb->TargetDeviceObject );

                    //
                    //  Verify the descriptor at the head of the sparing table.  If it is not
                    //  valid, we just break out for a chance at the next table, if any.
                    //

                    if (ByteOffset == 0) {

                        Header = (PSPARING_TABLE_HEADER) SectorBuffer;

                        if (!UdfVerifyDescriptor( IrpContext,
                                                  &Header->Destag,
                                                  0,
                                                  SectorSize( Vcb ),
                                                  Header->Destag.Lbn,
                                                  TRUE )) {

                            DebugTrace((  0, Dbg, "UdfLoadSparingTables, sparing table %u didn't verify destag!\n",
                                                  SparingTable ));
                            break;
                        }

                        if (!UdfUdfIdentifierContained( &Header->RegID,
                                                        &UdfSparingTableIdentifier,
                                                        UDF_VERSION_150,
                                                        UDF_VERSION_RECOGNIZED,
                                                        OSCLASS_INVALID,
                                                        OSIDENTIFIER_INVALID)) {

                            DebugTrace((  0, Dbg, "UdfLoadSparingTables, sparing table %u didn't verify regid!\n",
                                                  SparingTable ));
                            break;
                        }

                        //
                        //  Calculate the total number bytes this map spans and check it against what
                        //  we were told the sparing table sizes are.
                        //

                        DebugTrace(( 0, Dbg, "UdfLoadSparingTables, Sparing table %u has %u entries\n",
                                             SparingTable,
                                             Header->TableEntries ));

                        TotalBytes = sizeof(SPARING_TABLE_HEADER) + Header->TableEntries * sizeof(SPARING_TABLE_ENTRY);

                        if (Map->TableSize < TotalBytes) {

                            DebugTrace((  0, Dbg, "UdfLoadSparingTables, sparing table #ents %u overflows allocation!\n",
                                                  Header->TableEntries ));
                            break;
                        }

                        //
                        //  So far so good, advance past the header.
                        //

                        ByteOffset = sizeof(SPARING_TABLE_HEADER);
                        Entry = Add2Ptr( SectorBuffer, sizeof(SPARING_TABLE_HEADER), PSPARING_TABLE_ENTRY );

                    } else {

                        //
                        //  Pick up in the new sector.
                        //

                        Entry = (PSPARING_TABLE_ENTRY) SectorBuffer;
                    }

                    RemainingBytes = Min( SectorSize( Vcb ), TotalBytes - ByteOffset );
                }

                //
                //  Add the mapping.  Since sparing tables are an Lbn->Psn mapping,
                //  very odd, and I want to simplify things by putting the sparing
                //  in right at IO dispatch, translate this to a Psn->Psn mapping.
                //

                if (Entry->Original != UDF_SPARING_AVALIABLE &&
                    Entry->Original != UDF_SPARING_DEFECTIVE) {

                    Psn = Partition->Physical.Start + SectorsFromBlocks( Vcb, Entry->Original );

                    DebugTrace((  0, Dbg, "UdfLoadSparingTables, mapping from Psn %x (Lbn %x) -> Psn %x\n",
                                          Psn,
                                          Entry->Original,
                                          Entry->Mapped ));

                    FsRtlAddLargeMcbEntry( Pcb->SparingMcb,
                                           Psn,
                                           Entry->Mapped,
                                           Map->PacketLength);
                }

                //
                //  Advance to the next, and drop out if we've hit the end.
                //

                ByteOffset += sizeof(SPARING_TABLE_ENTRY);
                RemainingBytes -= sizeof(SPARING_TABLE_ENTRY);
                Entry++;

            } while ( ByteOffset < TotalBytes );
        }

    } finally {

        DebugUnwind( UdfLoadSparingTables );

        UdfFreePool( &SectorBuffer );
    }

    DebugTrace(( -1, Dbg, "UdfLoadSparingTables -> STATUS_SUCCESS\n" ));

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\udfs\cachesup.c ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    CacheSup.c

Abstract:

    This module implements the cache management routines for the Udfs
    FSD and FSP, by calling the Common Cache Manager.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]     12-Sep-1996
    
Revision History:

    Tom Jolly       [tomjolly]  21-Jan-2000     CcPurge and append at end of vmcb stream

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_CACHESUP)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_CACHESUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfCompleteMdl)
#pragma alloc_text(PAGE, UdfCreateInternalStream)
#pragma alloc_text(PAGE, UdfDeleteInternalStream)
#pragma alloc_text(PAGE, UdfMapMetadataView)
#pragma alloc_text(PAGE, UdfPurgeVolume)
#endif


VOID
UdfCreateInternalStream (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This function creates an internal stream file for interaction
    with the cache manager.  The Fcb here will be for a directory
    stream.

Arguments:

    Vcb - Vcb for this volume.

    Fcb - Points to the Fcb for this file.  It is an Index Fcb.

Return Value:

    None.

--*/

{
    PFILE_OBJECT StreamFile = NULL;
    BOOLEAN DecrementReference = FALSE;

    PAGED_CODE();

    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB_INDEX( Fcb );

    //
    //  We may only have the Fcb shared.  Lock the Fcb and do a
    //  safe test to see if we need to really create the file object.
    //

    UdfLockFcb( IrpContext, Fcb );

    if (Fcb->FileObject != NULL) {

        UdfUnlockFcb( IrpContext, Fcb );
        return;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Create the internal stream.  The Vpb should be pointing at our volume
        //  device object at this point.
        //

        StreamFile = IoCreateStreamFileObject( NULL, Vcb->Vpb->RealDevice );

        if (StreamFile == NULL) {

            UdfRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
        }

        //
        //  Initialize the fields of the file object.
        //

        StreamFile->ReadAccess = TRUE;
        StreamFile->WriteAccess = FALSE;
        StreamFile->DeleteAccess = FALSE;

        StreamFile->SectionObjectPointer = &Fcb->FcbNonpaged->SegmentObject;

        //
        //  Set the file object type and increment the Vcb counts.
        //

        UdfSetFileObject( IrpContext,
                         StreamFile,
                         StreamFileOpen,
                         Fcb,
                         NULL );

        //
        //  We will reference the current Fcb twice to keep it from going
        //  away in the error path.  Otherwise if we dereference it
        //  below in the finally clause a close could cause the Fcb to
        //  be deallocated.
        //

        UdfLockVcb( IrpContext, Vcb );
        
        DebugTrace(( +1, Dbg, 
                     "UdfCreateInternalStream, Fcb %08x Vcb %d/%d Fcb %d/%d\n",
                     Fcb,
                     Vcb->VcbReference,
                     Vcb->VcbUserReference,
                     Fcb->FcbReference,
                     Fcb->FcbUserReference ));

        UdfIncrementReferenceCounts( IrpContext, Fcb, 2, 0 );
        UdfUnlockVcb( IrpContext, Vcb );
        DecrementReference = TRUE;

        //
        //  Initialize the cache map for the file.
        //

        CcInitializeCacheMap( StreamFile,
                              (PCC_FILE_SIZES)&Fcb->AllocationSize,
                              TRUE,
                              &UdfData.CacheManagerCallbacks,
                              Fcb );

        //
        //  Go ahead and store the stream file into the Fcb.
        //

        Fcb->FileObject = StreamFile;
        StreamFile = NULL;

    } finally {

        DebugUnwind( "UdfCreateInternalStream" );

        //
        //  If we raised then we need to dereference the file object.
        //

        if (StreamFile != NULL) {

            ObDereferenceObject( StreamFile );
            Fcb->FileObject = NULL;
        }

        //
        //  Dereference and unlock the Fcb.
        //

        if (DecrementReference) {

            UdfLockVcb( IrpContext, Vcb );
            UdfDecrementReferenceCounts( IrpContext, Fcb, 1, 0 );
            
            DebugTrace(( -1, Dbg, 
                         "UdfCreateInternalStream, Vcb %d/%d Fcb %d/%d\n",
                         Vcb->VcbReference,
                         Vcb->VcbUserReference,
                         Fcb->FcbReference,
                         Fcb->FcbUserReference ));

            UdfUnlockVcb( IrpContext, Vcb );
        }

        UdfUnlockFcb( IrpContext, Fcb );
    }

    return;
}


VOID
UdfDeleteInternalStream (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This function creates an internal stream file for interaction
    with the cache manager.  The Fcb here can be for either a
    directory stream or for a metadata stream.

Arguments:

    Fcb - Points to the Fcb for this file.  It is either an Index or
        Metadata Fcb.

Return Value:

    None.

--*/

{
    PFILE_OBJECT FileObject;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    //
    //  Lock the Fcb.
    //

    UdfLockFcb( IrpContext, Fcb );

    //
    //  Capture the file object.
    //

    FileObject = Fcb->FileObject;
    Fcb->FileObject = NULL;

    //
    //  It is now safe to unlock the Fcb.
    //

    UdfUnlockFcb( IrpContext, Fcb );

    //
    //  Dereference the file object if present.
    //

    if (FileObject != NULL) {

        if (FileObject->PrivateCacheMap != NULL) {

            CcUninitializeCacheMap( FileObject, NULL, NULL );
        }

        ObDereferenceObject( FileObject );
    }

    return;
}


NTSTATUS
UdfCompleteMdl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the function of completing Mdl reads.
    It should be called only from UdfCommonRead.

Arguments:

    Irp - Supplies the originating Irp.

Return Value:

    NTSTATUS - Will always be STATUS_SUCCESS.

--*/

{
    PFILE_OBJECT FileObject;

    PAGED_CODE();

    //
    // Do completion processing.
    //

    FileObject = IoGetCurrentIrpStackLocation( Irp )->FileObject;

    CcMdlReadComplete( FileObject, Irp->MdlAddress );

    //
    // Mdl is now deallocated.
    //

    Irp->MdlAddress = NULL;

    //
    // Complete the request and exit right away.
    //

    UdfCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );

    return STATUS_SUCCESS;
}


VOID
UdfMapMetadataView (
    IN PIRP_CONTEXT IrpContext,
    IN PMAPPED_PVIEW View,
    IN PVCB Vcb,
    IN USHORT Partition,
    IN ULONG Lbn,
    IN ULONG Length,
    IN MAPMETAOP Operation
    )

/*++

Routine Description:

    Perform the common work of mapping an extent of metadata into a mapped view.
    Any existing view in the supplied MAPPED_VIEW is unmapped.

    Any single thread must only ever have ONE mapping ESTABLISHED through the
    Vmcb stream at any one time.  Failure to observe this may result in deadlocks
    when the Vmcb package tries to extend an existing mapping and hence do a 
    purge.  I.e. no more than one MAPPED_VIEW should be in use (actually mapped)
    by any given thread at any moment.

    Acquires Vcb->VmcbMappingResource shared (will be held on return, except for
    INIT_ONLY operation).  May acquire exclusive before shared if the mapping
    is not present in the vmcb, so calling threads must have no other active
    mappings through the vmcb stream.

Arguments:

    View - View structure to map the bytes into
    
    Vcb - Vcb of the volume the extent is on
    
    Partition - Partition of the extent
    
    Lbn - Lbn of the extent
    
    Length - Length of the extent

    Operation - METAMAPOP_INIT_VIEW_ONLY -  Just store the part/lbn/len. Doesn't
                                            access the vmcb,  or do a CcMap.
                                            
                METAMAPOP_REMAP_VIEW -      Do the CcMap through the vmcb using 
                                            the partition/lbn/len already in
                                            the supplied view record
                                            
                METAMAPOP_INIT_AND_MAP -    Does both of the above in sequence.
Return Value:

    None.

--*/

{
    LARGE_INTEGER Offset;

    ASSERT_IRP_CONTEXT( IrpContext );

    //
    //  Remove any existing mapping & release Vmcb mapping resource
    //
    
    UdfUnpinView( IrpContext, View );

    if ( METAMAPOP_REMAP_VIEW != Operation)  {
    
        //
        //  Update the view information if we're not remapping using the
        //  existing values in the view record.
        //

        View->Partition = Partition;
        View->Lbn = Lbn;
        View->Length = Length;
        View->Vsn = UDF_INVALID_VSN;
        View->Bcb = View->View = NULL;
    }

    if ( METAMAPOP_INIT_VIEW_ONLY != Operation)  {
    
        ASSERT_NOT_HELD_VMCB( Vcb);

        //
        //  Find (or add) the mapping for this extent in the vmcb stream.  We now
        //  store the Vsn in the MAPPED_VIEW,  so we don't have to do the lookup
        //  again later (simplifies locking,  amongst other things).
        //

        View->Vsn = UdfLookupMetaVsnOfExtent( IrpContext,
                                             Vcb,
                                             View->Partition,
                                             View->Lbn,
                                             View->Length,
                                             FALSE );

        Offset.QuadPart = LlBytesFromSectors( Vcb, View->Vsn );

        //
        //  Map the extent.  Acquire the vmcb map resource to synchronise against
        //  purges of the vmcb stream.  See comments in Vmcb code for more detail.
        //

        UdfAcquireVmcbForCcMap( IrpContext,  Vcb);
        
        try {
        
            CcMapData( Vcb->MetadataFcb->FileObject,
                       &Offset,
                       View->Length,
                       TRUE,
                       &View->Bcb,
                       &View->View );
        } 
        finally {

            //
            //  If this raised,  we should release the mapping lock.  Callers will
            //  only cleanup and release if a non-NULL BCB is present in the pview.
            //
            
            if (AbnormalTermination())  {

                UdfReleaseVmcb( IrpContext, Vcb);

                View->View = View->Bcb = NULL;
            }
            else {
            
                ASSERT( View->View && View->Bcb);
            }
        }
    }
}


NTSTATUS
UdfPurgeVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN DismountUnderway
    )

/*++

Routine Description:

    This routine is called to purge the volume.  The purpose is to make all the stale file
    objects in the system go away, minimizing the reference counts, so that the volume may
    be locked or deleted.

    The Vcb is already acquired exclusively.  We will lock out all file operations by
    acquiring the global file resource.  Then we will walk through all of the Fcb's and
    perform the purge.

Arguments:

    Vcb - Vcb for the volume to purge.

    DismountUnderway - Indicates that we are trying to delete all of the objects.
        We will purge the Metadata and VolumeDasd and dereference all internal streams.

Return Value:

    NTSTATUS - The first failure of the purge operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PVOID RestartKey = NULL;
    PFCB ThisFcb = NULL;
    PFCB NextFcb;

    BOOLEAN RemovedFcb;

    PAGED_CODE();

    ASSERT_EXCLUSIVE_VCB( Vcb);

    //
    //  Force any remaining Fcb's in the delayed close queue to be closed.
    //

    UdfFspClose( Vcb );

    //
    //  Acquire the global file resource.
    //

    UdfAcquireAllFiles( IrpContext, Vcb );

    //
    //  Loop through each Fcb in the Fcb Table and perform the flush.
    //

    while (TRUE) {

        //
        //  Lock the Vcb to lookup the next Fcb.
        //

        UdfLockVcb( IrpContext, Vcb );
        NextFcb = UdfGetNextFcb( IrpContext, Vcb, &RestartKey );

        //
        //  Reference the NextFcb if present.
        //

        if (NextFcb != NULL) {

            NextFcb->FcbReference += 1;
        }

        //
        //  If the last Fcb is present then decrement reference count and call teardown
        //  to see if it should be removed.
        //

        if (ThisFcb != NULL) {

            ThisFcb->FcbReference -= 1;

            UdfUnlockVcb( IrpContext, Vcb );

            UdfTeardownStructures( IrpContext, ThisFcb, FALSE, &RemovedFcb );

        } else {

            UdfUnlockVcb( IrpContext, Vcb );
        }

        //
        //  Break out of the loop if no more Fcb's.
        //

        if (NextFcb == NULL) {

            break;
        }

        //
        //  Move to the next Fcb.
        //

        ThisFcb = NextFcb;

        //
        //  If there is a image section then see if that can be closed.
        //

        if (ThisFcb->FcbNonpaged->SegmentObject.ImageSectionObject != NULL) {

            MmFlushImageSection( &ThisFcb->FcbNonpaged->SegmentObject, MmFlushForWrite );
        }

        //
        //  If there is a data section then purge this.  If there is an image
        //  section then we won't be able to.  Remember this if it is our first
        //  error.
        //

        if ((ThisFcb->FcbNonpaged->SegmentObject.DataSectionObject != NULL) &&
            !CcPurgeCacheSection( &ThisFcb->FcbNonpaged->SegmentObject,
                                   NULL,
                                   0,
                                   FALSE ) &&
            (Status == STATUS_SUCCESS)) {

            Status = STATUS_UNABLE_TO_DELETE_SECTION;
        }

        //
        //  Dereference the internal stream if dismounting.
        //

        if (DismountUnderway &&
            (SafeNodeType( ThisFcb ) != UDFS_NTC_FCB_DATA) &&
            (ThisFcb->FileObject != NULL)) {

            UdfDeleteInternalStream( IrpContext, ThisFcb );
        }
    }

    //
    //  Now look at the Root Index, Metadata, Volume Dasd and VAT Fcbs.
    //  Note that we usually hit the Root Index in the loop above, but
    //  it is possible miss it if it didn't get into the Fcb table in the
    //  first place!
    //

    if (DismountUnderway) {

        if (Vcb->RootIndexFcb != NULL) {

            ThisFcb = Vcb->RootIndexFcb;
            InterlockedIncrement( &ThisFcb->FcbReference );

            if ((ThisFcb->FcbNonpaged->SegmentObject.DataSectionObject != NULL) &&
                !CcPurgeCacheSection( &ThisFcb->FcbNonpaged->SegmentObject,
                                       NULL,
                                       0,
                                       FALSE ) &&
                (Status == STATUS_SUCCESS)) {

                Status = STATUS_UNABLE_TO_DELETE_SECTION;
            }

            UdfDeleteInternalStream( IrpContext, ThisFcb );
            InterlockedDecrement( &ThisFcb->FcbReference );
            UdfTeardownStructures( IrpContext, ThisFcb, FALSE, &RemovedFcb );
        }
        
        if (Vcb->MetadataFcb != NULL) {

            ThisFcb = Vcb->MetadataFcb;
            InterlockedIncrement( &ThisFcb->FcbReference );

            if ((ThisFcb->FcbNonpaged->SegmentObject.DataSectionObject != NULL) &&
                !CcPurgeCacheSection( &ThisFcb->FcbNonpaged->SegmentObject,
                                       NULL,
                                       0,
                                       FALSE ) &&
                (Status == STATUS_SUCCESS)) {

                Status = STATUS_UNABLE_TO_DELETE_SECTION;
            }

            UdfDeleteInternalStream( IrpContext, ThisFcb );
            InterlockedDecrement( &ThisFcb->FcbReference );
            UdfTeardownStructures( IrpContext, ThisFcb, FALSE, &RemovedFcb );
        }

        if (Vcb->VatFcb != NULL) {

            ThisFcb = Vcb->VatFcb;
            InterlockedIncrement( &ThisFcb->FcbReference );

            if ((ThisFcb->FcbNonpaged->SegmentObject.DataSectionObject != NULL) &&
                !CcPurgeCacheSection( &ThisFcb->FcbNonpaged->SegmentObject,
                                       NULL,
                                       0,
                                       FALSE ) &&
                (Status == STATUS_SUCCESS)) {

                Status = STATUS_UNABLE_TO_DELETE_SECTION;
            }

            UdfDeleteInternalStream( IrpContext, ThisFcb );
            InterlockedDecrement( &ThisFcb->FcbReference );
            UdfTeardownStructures( IrpContext, ThisFcb, FALSE, &RemovedFcb );
        }

        if (Vcb->VolumeDasdFcb != NULL) {

            ThisFcb = Vcb->VolumeDasdFcb;
            InterlockedIncrement( &ThisFcb->FcbReference );

            if ((ThisFcb->FcbNonpaged->SegmentObject.DataSectionObject != NULL) &&
                !CcPurgeCacheSection( &ThisFcb->FcbNonpaged->SegmentObject,
                                       NULL,
                                       0,
                                       FALSE ) &&
                (Status == STATUS_SUCCESS)) {

                Status = STATUS_UNABLE_TO_DELETE_SECTION;
            }

            InterlockedDecrement( &ThisFcb->FcbReference );
            UdfTeardownStructures( IrpContext, ThisFcb, FALSE, &RemovedFcb );
        }
    }

    //
    //  Release all of the files.
    //

    UdfReleaseAllFiles( IrpContext, Vcb );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\srv\srvkd\srvkd.c ===
#ifndef DBG
#define DBG 1
#endif
#define SRVDBG 1

#define SRVKD 1
#include "precomp.h"

#include <ntverp.h>

#include <windows.h>
#include <wdbgexts.h>
#include <stdlib.h>
#include <string.h>

WINDBG_EXTENSION_APIS ExtensionApis;
EXT_API_VERSION ApiVersion = { 5, 0, EXT_API_VERSION_NUMBER, 0 };

#define    ERRPRT     dprintf

#ifndef MIN
#define MIN(a,b) ( ((a) < (b)) ? (a) : (b) )
#endif

#define    NL      1
#define    NONL    0

USHORT SavedMajorVersion;
USHORT SavedMinorVersion;
BOOL   ChkTarget;            // is debuggee a CHK build?

/*
 * The help strings printed out
 */
static LPSTR Extensions[] = {
    "Lan Manager Server Debugger Extensions:\n",
    "buffer address                                  Dump the BUFFER structure",
    "client                                          Dump the clients + CONNECTION structs",
    "connection address                              Dump the CONNECTION structure",
    "context address                                 Dump the WORK_CONTEXT structure",
    "df address                                      Follow an entire LIST_ENTRY to end",
    "endpoint [ address ]                            Dump the ENDPOINT structure(s)",
    "errcodes                                        Dump the error log code filter",
    "globals                                         Print out srv's global variables",
    "help",
    "lfcb address                                    Dump the LFCB structure",
    "lock [ address ]                                Dump the ERESOURCE structure(s)",
    "mfcb address                                    Dump the LFCB structure",
    "pagedconnection address                         Dump the PAGED_CONNECTION structure",
    "queue [ address ]                               Dump the WORK_QUEUE structure",
    "rfcb [ address ]                                Dump the RFCB structure(s)",
    "scavenger                                       Dump scavenger info",
    "search address                                  Dump the SEARCH structure",
    "session address                                 Dump the SESSION structure",
    "share [ address | disk | print | comm | pipe ]  Dump the SHARE structure(s)",
    "share =name                                     Dump the SHARE structure for 'name'",
    "smb address                                     Dump the SMB_HEADER",
#if SRVDBG == 1
    "smbdebug [ t | f | #'s ]                        Get or set SMB debug flags",
#endif
    "srv                                             Turn target into a Server",
#if SRVDBG == 1
    "srvdebug [ t | f | #'s ]                        Get or set server debug flags",
#endif
    "statistics                                      Dump the SrvStatistics structure",
    "tcon address                                    Dump the TREE_CONNECT structure",
    "transaction address                             Dump the TRANSACTION structure",
    "version",
    "wksta                                           Turn target into a Workstation",
    0
};

static LPSTR BlockState[] = {
    "BlockStateDead",
    "BlockStateInitializing",
    "BlockStateActive",
    "BlockStateClosing"
};

static LPSTR BlockType[] = {
    "BlockTypeGarbage",
    "BlockTypeBuffer",
    "BlockTypeConnection",
    "BlockTypeEndpoint",
    "BlockTypeLfcb",
    "BlockTypeMfcb",
    "BlockTypeRfcb",
    "BlockTypeSearch",
    "BlockTypeSearchCore",
    "BlockTypeByteRangeLock",
    "BlockTypeSession",
    "BlockTypeShare",
    "BlockTypeTransaction",
    "BlockTypeTreeConnect",
    "BlockTypeWaitForOplockBreak",
    "BlockTypeCommDevice",
    "BlockTypeWorkContextInitial",
    "BlockTypeWorkContextNormal",
    "BlockTypeWorkContextRaw",
    "BlockTypeDataBuffer",
    "BlockTypeTable",
    "BlockTypeNonpagedHeader",
    "BlockTypePagedConnection",
    "BlockTypePagedRfcb",
    "BlockTypeNonpagedMfcb",
    "BlockTypeTimer",
    "BlockTypeAdminCheck",
    "BlockTypeWorkQueue",
#ifdef INCLUDE_SMB_PERSISTENT
    "BlockTypeDfs",
    "BlockTypePersistentState",
    "BlockTypePersistentBitMap",
    "BlockTypePersistentShareState",
#else
    "BlockTypeDfs"
#endif
};

/*
 * The locks that we'd like to dump
 */
static LPSTR SrvLocks[] = {
    "SrvConfigurationLock",
    "SrvEndpointLock",
    "SrvShareLock",
    "SrvOrderedListLock",
    "SrvOplockBreakListLock",
    "SrvUnlockableCodeLock",
    0
};

/*
 * The globals that we'd like to dump
 */
static LPSTR GlobalBool[] = {
    "SrvProductTypeServer",
    "SrvMultiProcessorDriver",
    "SrvEnableOplocks",
    "SrvEnableFcbOpens",
    "SrvEnableSoftCompatibility",
    "SrvEnableRawMode",
    "SrvSmbSecuritySignaturesRequired",
    "SrvSmbSecuritySignaturesEnabled",
    "SrvEnableW9xSecuritySignatures",
    "SrvRemoveDuplicateSearches",
    "SrvRestrictNullSessionAccess",
    "SrvEnableWfW311DirectIpx",
    "SrvEnableOplockForceClose",
    "SrvEnableForcedLogoff",
    "SrvFspActive",
    "SrvXsActive",
    "SrvPaused",
    "SrvCompletedPNPRegistration",
    "SrvFspTransitioning",
    "SrvResourceThreadRunning",
    "SrvResourceDisconnectPending",
    "SrvResourceFreeConnection",
    "SrvResourceOrphanedBlocks",
    0
};

static LPSTR GlobalShort[] = {
    "SrvInitialSessionTableSize",
    "SrvMaxSessionTableSize",
    "SrvInitialTreeTableSize",
    "SrvInitialTreeTableSize",
    "SrvMaxTreeTableSize",
    "SrvInitialFileTableSize",
    "SrvMaxFileTableSize",
    "SrvInitialSearchTableSize",
    "SrvMaxSearchTableSize",
    "SrvMaxMpxCount",
    0
};

static LPSTR GlobalLong[] = {
    "SrvServerSize",
    "SrvNumberOfProcessors",
    "SrvMinNT5Client",
    "SrvAbortiveDisconnects",
    "SrvBalanceCount",
    "SrvReBalanced",
    "SrvOtherQueueAffinity",
    "SrvPreferredAffinity",
    "SrvMaxFreeRfcbs",
    "SrvMaxFreeMfcbs",
    "SrvReceiveBufferLength",
    "SrvInitialReceiveWorkItemCount",
    "SrvMaxReceiveWorkItemCount",
    "SrvInitialRawModeWorkItemCount",
    "SrvMaxRawModeWorkItemCount",
    "SrvFreeConnectionMinimum",
    "SrvFreeConnectionMaximum",
    "SrvScavengerTimeoutInSeconds",
    "SrvMaxNumberVcs",
    "SrvMinReceiveQueueLength",
    "SrvMinFreeWorkItemsBlockingIo",
    "SrvIpxAutodisconnectTimeout",
    "SrvConnectionNoSessionsTimeout",
    "SrvMaxUsers",
    "SrvMaxPagedPoolUsage",
    "SrvMaxNonPagedPoolUsage",
    "SrvScavengerUpdateQosCount",
    "SrvWorkItemMaxIdleTime",
    "SrvAlertMinutes",
    "SrvFreeDiskSpaceThreshold",
    "SrvSharingViolationRetryCount",
    "SrvLockViolationDelay",
    "SrvLockViolationOffset",
    "SrvMaxOpenSearches",
    "SrvMaxFsctlBufferSize",
    "SrvMdlReadSwitchover",
    "SrvMpxMdlReadSwitchover",
    "SrvCachedOpenLimit",
    "SrvXsSharedMemoryReference",
    "SrvEndpointCount",
    "SrvBlockingOpsInProgress",
    "SrvFastWorkAllocation",
    "SrvSlowWorkAllocation",
    "SrvMinClientBufferSize",
    "SrvMaxFsctlBufferSize",
    "SrvMaxReadSize",
    "SrvMaxWriteChunk",
    "SrvNT5SecuritySigBuildNumber",
    0
};

static LPSTR GlobalLongHex[] = {
    "SrvNamedPipeHandle",
    "SrvNamedPipeDeviceObject",
    "SrvNamedPipeFileObject",
    "SrvDfsDeviceObject",
    "SrvDfsFileObject",
    "SrvDfsFastIoDeviceControl",
    "SrvDiskConfiguration",
    "SrvSvcProcess",
//  "SrvWorkQueuesBase",
    "SrvWorkQueues",
    "eSrvWorkQueues",
    "SrvIpxSmartCard",
    0
};

static LPSTR GlobalStringVector[] = {
    "SrvNullSessionPipes",
    "SrvNullSessionShares",
    "SrvPipesNeedLicense",
    "SrvNoRemapPipeNames",
    0
};

static LPSTR GlobalStrings[] = {
    "SrvComputerName",
    "SrvNativeOS",
    "SrvNativeLanMan",
    "SrvSystemRoot",
    0
};

static LPSTR ScavengerLong[] = {
    "LastNonPagedPoolLimitHitCount",
    "LastNonPagedPoolFailureCount",
    "LastPagedPoolLimitHitCount",
    "LastPagedPoolFailureCount",
    "SrvScavengerCheckRfcbActive",
    "ScavengerUpdateQosCount",
    "ScavengerCheckRfcbActive",
    "FailedWorkItemAllocations",
    0
};

static LPSTR ScavengerBool[] = {
    "RunShortTermAlgorithm",
    "RunScavengerAlgorithm",
    "RunAlerterAlgorithm",
    "EventSwitch",
    0
};

struct BitFields {
    PCSTR name;
    ULONGLONG value;
};

#if defined( SRVDBG ) && SRVDBG == 1

#define    DF( name )    { #name, DEBUG_ ## name }
struct BitFields SrvDebugFlags[] = {
    DF( TRACE1 ),
    DF( TRACE2 ),
    DF( REFCNT ),
    DF( HEAP ),
    DF( WORKER1 ),
    DF( WORKER2 ),
    DF( NET1 ),
    DF( NET2 ),
    DF( FSP1 ),
    DF( FSP2 ),
    DF( FSD1 ),
    DF( FSD2 ),
    DF( SCAV1 ),
    DF( SCAV2 ),
    DF( BLOCK1 ),
    DF( IPX_PIPES ),
    DF( HANDLES ),
    DF( IPX ),
    DF( TDI ),
    DF( OPLOCK ),
    DF( NETWORK_ERRORS ),
    DF( FILE_CACHE ),
    DF( IPX2 ),
    DF( LOCKS ),
    DF( SEARCH ),
    DF( BRUTE_FORCE_REWIND ),
    DF( COMM ),
    DF( XACTSRV ),
    DF( LICENSE ),
    DF( API_ERRORS ),
    DF( STOP_ON_ERRORS ),
    DF( ERRORS ),
    DF( SMB_ERRORS ),
    DF( WORKITEMS ),
    DF( IPXNAMECLAIM ),
    DF( SENDS2OTHERCPU ),
    DF( REBALANCE ),
    DF( PNP ),
    DF( DFS ),
    DF( SIPX ),
    DF( CREATE ),
    DF( SECSIG ),
    DF( STUCK_OPLOCK ),
    0
};

#undef DF
#define    DF( name )    { #name, DEBUG_SMB_ ## name }

struct BitFields SmbDebugFlags[] = {
    DF( ERRORS ),
    DF( ADMIN1 ),
    DF( ADMIN2 ),
    DF( TREE1 ),
    DF( TREE2 ),
    DF( DIRECTORY1 ),
    DF( DIRECTORY2 ),
    DF( OPEN_CLOSE1 ),
    DF( OPEN_CLOSE2 ),
    DF( FILE_CONTROL1 ),
    DF( FILE_CONTROL2 ),
    DF( READ_WRITE1 ),
    DF( READ_WRITE2 ),
    DF( LOCK1 ),
    DF( LOCK2 ),
    DF( RAW1 ),
    DF( RAW2 ),
    DF( MPX1 ),
    DF( MPX2 ),
    DF( SEARCH1 ),
    DF( SEARCH2 ),
    DF( TRANSACTION1 ),
    DF( TRANSACTION2 ),
    DF( PRINT1 ),
    DF( PRINT2 ),
    DF( MESSAGE1 ),
    DF( MESSAGE2 ),
    DF( MISC1 ),
    DF( MISC2 ),
    DF( QUERY_SET1 ),
    DF( QUERY_SET2 ),
    DF( TRACE ),
    0
};

#endif // SRVDBG

/*
 * The MEMBERLIST structure, and the macros that follow, give an easy way to declare
 * the members of a structure to be printed.  Once you set up a MEMBERLIST[] for a
 * particular structure, you call PrintMemberList() to do a formatted dump of the struct
 */
typedef struct _MEMBERLIST {
    LPSTR name;                  // The name of the field
    ULONG offset;                // The offset of the field in the structure
    UCHAR type;                  // The type of variable to be printed
    LONG extra;                  // Any other extra info needed for this type
} MEMBERLIST;

// BE -> BOOL
// HE -> HEX ULONG
// PE -> POINTER
// UE -> Unsigned ULONG
// HC -> Unsigned char as hex
// DE -> Decimal Long
// SE -> Decimal Short
// WE -> UNICODE_STRING
// AE -> ANSI_STRING
// IE -> Symbol Address
// CE -> Character
// TE -> TABLE_HEADER structure, and follow the table
// LE -> LIST_ENTRY list
// BT -> BLOCK_HEADER 'Type' field
// BS -> BLOCK_HEADER 'State' field
// BC -> BLOCK_HEADER 'ReferenceCount' field
// U64-> LONGLONG
// IA -> IP Address

#define    ROOT( StructureName ) { "@" #StructureName, 0, 'R' }
#define    BE( StructureName, FieldName ) { #FieldName, FIELD_OFFSET( StructureName, FieldName ), 'B' }
#define    CE( StructureName, FieldName ) { #FieldName, FIELD_OFFSET( StructureName, FieldName ), 'C' }
#define    HE( StructureName, FieldName)  { #FieldName, FIELD_OFFSET( StructureName, FieldName ), 'H' }
#define    PE( StructureName, FieldName)  { #FieldName, FIELD_OFFSET( StructureName, FieldName ), 'P' }
#define    UE( StructureName, FieldName)  { #FieldName, FIELD_OFFSET( StructureName, FieldName ), 'U' }
#define    U64( StructureName, FieldName)  { #FieldName, FIELD_OFFSET( StructureName, FieldName ), '6' }
#define    DE( StructureName, FieldName)  { #FieldName, FIELD_OFFSET( StructureName, FieldName ), 'L' }
#define    SE( StructureName, FieldName)  { #FieldName, FIELD_OFFSET( StructureName, FieldName ), 'S' }
#define    WE( StructureName, FieldName)  { #FieldName, FIELD_OFFSET( StructureName, FieldName ), 'W' }
#define    AE( StructureName, FieldName) { #FieldName, FIELD_OFFSET( StructureName, FieldName ), 'A' }
#define    IE( StructureName, FieldName) { #FieldName, FIELD_OFFSET( StructureName, FieldName ), 'I' }
#define    TE( StructureName, FieldName) { #FieldName, FIELD_OFFSET( StructureName, FieldName ), 'T' }
#define    LE( StructureName, FieldName, PointedToStructure, PointedToMemberName ) \
                            { #FieldName, FIELD_OFFSET( StructureName, FieldName##.Flink ), 'Z', \
                              FIELD_OFFSET( PointedToStructure, PointedToMemberName ## .Flink ) }
#define    BT() { "BlockHeader.Type", FIELD_OFFSET( BLOCK_HEADER, Type) , 'K' }
#define    BS() { "BlockHeader.State", FIELD_OFFSET( BLOCK_HEADER, State), 'Q' }
#define    BC() { "BlockHeader.ReferenceCount", FIELD_OFFSET( BLOCK_HEADER, ReferenceCount), 'L' }
#define    IA( StructureName, FieldName)  { #FieldName, FIELD_OFFSET( StructureName, FieldName ), 'N' }

/*
 * The members of an SMB_HEADER
 */
MEMBERLIST ML_SMB_HEADER[] = {
    CE( NT_SMB_HEADER, Command ),
    HE( NT_SMB_HEADER, Status.NtStatus ),
    CE( NT_SMB_HEADER, Flags ),
    SE( NT_SMB_HEADER, Flags2 ),
    SE( NT_SMB_HEADER, Tid ),
    SE( NT_SMB_HEADER, Pid ),
    SE( NT_SMB_HEADER, Uid ),
    SE( NT_SMB_HEADER, Mid ),
    0
};


/*
 * The members in an MFCB
 */
MEMBERLIST ML_MFCB[] = {
    PE( MFCB, NonpagedMfcb ),
    UE( MFCB, ActiveRfcbCount ),
    BE( MFCB, CompatibilityOpen ),
    HE( MFCB, FileNameHashValue ),
    WE( MFCB, FileName ),
    PE( MFCB, MfcbHashTableEntry.Flink ),
    LE( MFCB, LfcbList, LFCB, MfcbListEntry ),
    0
};

/*
 * The members in the SrvStatistics structure
 */
MEMBERLIST ML_SRV_STATISTICS[] = {
    U64( SRV_STATISTICS, TotalBytesReceived ),
    U64( SRV_STATISTICS, TotalBytesSent ),
    DE( SRV_STATISTICS, SessionLogonAttempts ),
    DE( SRV_STATISTICS, SessionsTimedOut ),
    DE( SRV_STATISTICS, SessionsErroredOut ),
    DE( SRV_STATISTICS, SessionsLoggedOff ),
    DE( SRV_STATISTICS, SessionsForcedLogOff ),
    DE( SRV_STATISTICS, LogonErrors ),
    DE( SRV_STATISTICS, AccessPermissionErrors ),
    DE( SRV_STATISTICS, GrantedAccessErrors ),
    DE( SRV_STATISTICS, SystemErrors ),
    DE( SRV_STATISTICS, BlockingSmbsRejected ),
    DE( SRV_STATISTICS, WorkItemShortages ),
    DE( SRV_STATISTICS, TotalFilesOpened ),
    DE( SRV_STATISTICS, CurrentNumberOfOpenFiles ),
    DE( SRV_STATISTICS, CurrentNumberOfSessions ),
    DE( SRV_STATISTICS, CurrentNumberOfOpenSearches ),
    DE( SRV_STATISTICS, CurrentNonPagedPoolUsage ),
    DE( SRV_STATISTICS, NonPagedPoolFailures ),
    DE( SRV_STATISTICS, PeakNonPagedPoolUsage ),
    DE( SRV_STATISTICS, CurrentPagedPoolUsage ),
    DE( SRV_STATISTICS, PagedPoolFailures ),
    DE( SRV_STATISTICS, PeakPagedPoolUsage ),
    0
};

/*
 * The members in a NONPAGED_MFCB
 */
MEMBERLIST ML_NONPAGED_MFCB[] = {
    UE( NONPAGED_MFCB, Type ),
    PE( NONPAGED_MFCB, PagedBlock ),
    PE( NONPAGED_MFCB, Lock ),
    HE( NONPAGED_MFCB, OpenFileAttributes ),
    0
};

/*
 * The members in an LFCB
 */
MEMBERLIST ML_LFCB[] = {
    UE( LFCB, HandleCount ),
    PE( LFCB, Mfcb ),
    PE( LFCB, Connection ),
    PE( LFCB, Session ),
    PE( LFCB, TreeConnect ),
    HE( LFCB, GrantedAccess ),
    HE( LFCB, FileHandle ),
    PE( LFCB, FileObject ),
    PE( LFCB, DeviceObject ),
    HE( LFCB, FileMode ),
    HE( LFCB, JobId ),
    IE( LFCB, FastIoRead ),
    IE( LFCB, FastIoWrite ),
    IE( LFCB, FastIoUnlockSingle ),
    BE( LFCB, CompatibilityOpen ),
    0
};

/*
 * The members in an RFCB
 */
MEMBERLIST ML_RFCB[] = {
    BE( RFCB, BlockingModePipe ),
    BE( RFCB, ByteModePipe ),
    BE( RFCB, CachedOpen ),
    PE( RFCB, CachedOpenListEntry ),
    PE( RFCB, Connection ),
    BE( RFCB, DeferredOplockBreak ),
    SE( RFCB, Fid ),
    HE( RFCB, FileMode ),
    PE( RFCB, GlobalRfcbListEntry ),
    HE( RFCB, GrantedAccess ),
    PE( RFCB, Irp ),
    BE( RFCB, IsActive ),
    BE( RFCB, IsCacheable ),
    PE( RFCB, Lfcb ),
    BE( RFCB, LockAccessGranted ),
    PE( RFCB, Mfcb ),
    BE( RFCB, MpxGlommingAllowed ),
    CE( RFCB, NewOplockLevel ),
    DE( RFCB, NumberOfLocks ),
    BE( RFCB, OnOplockBreaksInProgressList ),
    BE( RFCB, OpenResponseSent ),
    UE( RFCB, OplockState ),
    PE( RFCB, PagedRfcb ),
    SE( RFCB, Pid ),
    UE( RFCB, RawWriteCount ),
    LE( RFCB, RawWriteSerializationList, WORK_CONTEXT, ListEntry ),
    BE( RFCB, ReadAccessGranted ),
    PE( RFCB, RetryOplockRequest ),
    HE( RFCB, SavedError ),
    HE( RFCB, ShareAccess ),
    HE( RFCB, ShiftedFid ),
    SE( RFCB, Tid ),
    SE( RFCB, Uid ),
    BE( RFCB, UnlockAccessGranted ),
    BE( RFCB, WriteAccessGranted ),
    BE( RFCB, AppendAccessGranted ),
    BE( RFCB, WrittenTo ),
    DE( RFCB, WriteMpx.ReferenceCount ),
    HE( RFCB, WriteMpx.Mask ),
    PE( RFCB, WriteMpx.FileObject ),
    SE( RFCB, WriteMpx.Mid ),
    SE( RFCB, WriteMpx.PreviousMid ),
    SE( RFCB, WriteMpx.SequenceNumber ),
    BE( RFCB, WriteMpx.Glomming ),
    BE( RFCB, WriteMpx.GlomPending ),
    PE( RFCB, WriteMpx.GlomDelayList ),
    DE( RFCB, WriteMpx.StartOffset ),
    SE( RFCB, WriteMpx.Length ),
    BE( RFCB, WriteMpx.GlomComplete ),
    BE( RFCB, WriteMpx.MpxGlommingAllowed ),
    PE( RFCB, WriteMpx.MdlChain ),
    DE( RFCB, WriteMpx.NumberOfRuns ),
    0
};
/*
 * The members in a PAGED_RFCB
 */
MEMBERLIST ML_PAGED_RFCB[] = {
    UE( PAGED_RFCB, FcbOpenCount ),
    HE( PAGED_RFCB, IpxSmartCardContext ),
    PE( PAGED_RFCB, LfcbListEntry.Flink ),
    0
};

/*
 * The members in an RFCB for quick display
 */
MEMBERLIST ML_RFCB_QUICK[] = {
    ROOT( RFCB ),
    PE( RFCB, Connection ),
    HE( RFCB, GlobalRfcbListEntry.ResumeHandle ),
    0
};

/*
 * The members in a SESSION
 */
MEMBERLIST ML_SESSION[] = {
    ROOT( SESSION ),
    WE( SESSION, NtUserName ),
    WE( SESSION, NtUserDomain ),
    UE( SESSION, CurrentFileOpenCount ),
    UE( SESSION, CurrentSearchOpenCount ),
    //HE( SESSION, UserHandle.dwUpper ),
    //HE( SESSION, UserHandle.dwLower ),
    PE( SESSION, Connection ),
    PE( SESSION, GlobalSessionListEntry.ListEntry.Flink ),
    SE( SESSION, MaxBufferSize ),
    SE( SESSION, MaxMpxCount ),
    SE( SESSION, Uid ),
    BE( SESSION, UsingUppercasePaths ),
    BE( SESSION, GuestLogon ),
    BE( SESSION, EncryptedLogon ),
    BE( SESSION, LogoffAlertSent ),
    BE( SESSION, TwoMinuteWarningSent ),
    BE( SESSION, FiveMinuteWarningSent ),
    BE( SESSION, IsNullSession ),
    BE( SESSION, IsAdmin ),
    BE( SESSION, IsLSNotified ),
    PE( SESSION, hLicense ),
    BE( SESSION, LogonSequenceInProgress ),
    0
};

/*
 * The members in a TRANSACTION
 */
MEMBERLIST ML_TRANSACTION[] = {
    BT(),
    BS(),
    BC(),
    PE( TRANSACTION, NonpagedHeader ),
    PE( TRANSACTION, Connection ),
    PE( TRANSACTION, Session ),
    PE( TRANSACTION, TreeConnect ),
    UE( TRANSACTION, StartTime ),
    UE( TRANSACTION, Timeout ),
    UE( TRANSACTION, cMaxBufferSize ),
    PE( TRANSACTION, InSetup ),
    PE( TRANSACTION, OutSetup ),
    PE( TRANSACTION, InParameters ),
    PE( TRANSACTION, OutParameters ),
    PE( TRANSACTION, InData ),
    PE( TRANSACTION, OutData ),
    UE( TRANSACTION, SetupCount ),
    UE( TRANSACTION, MaxSetupCount ),
    UE( TRANSACTION, ParameterCount ),
    UE( TRANSACTION, TotalParameterCount ),
    UE( TRANSACTION, MaxParameterCount ),
    UE( TRANSACTION, DataCount ),
    UE( TRANSACTION, TotalDataCount ),
    UE( TRANSACTION, MaxDataCount ),
    SE( TRANSACTION, Category ),
    SE( TRANSACTION, Function ),
    BE( TRANSACTION, InputBufferCopied ),
    BE( TRANSACTION, OutputBufferCopied ),
    BE( TRANSACTION, OutDataAllocated ),
    SE( TRANSACTION, Flags ),
    SE( TRANSACTION, Tid ),
    SE( TRANSACTION, Pid ),
    SE( TRANSACTION, Uid ),
    SE( TRANSACTION, OtherInfo ),
    UE( TRANSACTION, FileHandle ),
    PE( TRANSACTION, FileObject ),
    UE( TRANSACTION, ParameterDisplacement ),
    UE( TRANSACTION, DataDisplacement ),
    BE( TRANSACTION, PipeRequest ),
    BE( TRANSACTION, RemoteApiRequest ),
    BE( TRANSACTION, Inserted ),
    BE( TRANSACTION, MultipieceIpxSend ),
    BE( TRANSACTION, Executing ),
    0
};

/*
 * The members in a WORK_CONTEXT
 */
MEMBERLIST ML_WORK_CONTEXT[] = {
    BT(),
    BS(),
    BC(),
    PE( WORK_CONTEXT, Endpoint ),
    PE( WORK_CONTEXT, Connection ),
    PE( WORK_CONTEXT, Rfcb ),
    PE( WORK_CONTEXT, Share ),
    PE( WORK_CONTEXT, Session ),
    PE( WORK_CONTEXT, TreeConnect ),
    PE( WORK_CONTEXT, Irp ),
    UE( WORK_CONTEXT, SpinLock ),
    PE( WORK_CONTEXT, RequestBuffer ),
    PE( WORK_CONTEXT, ResponseBuffer ),
    PE( WORK_CONTEXT, RequestHeader ),
    PE( WORK_CONTEXT, RequestParameters ),
    PE( WORK_CONTEXT, ResponseHeader ),
    PE( WORK_CONTEXT, ResponseParameters ),
    CE( WORK_CONTEXT, NextCommand ),
    UE( WORK_CONTEXT, ProcessingCount ),
    IE( WORK_CONTEXT, FsdRestartRoutine ),
    IE( WORK_CONTEXT, FspRestartRoutine ),
    LE( WORK_CONTEXT, InProgressListEntry, WORK_CONTEXT, InProgressListEntry ),
    UE( WORK_CONTEXT, PartOfInitialAllocation ),
//    BE( WORK_CONTEXT, BlockingOperation ),
//   BE( WORK_CONTEXT, UsingExtraSmbBuffer ),
//  BE( WORK_CONTEXT, OplockOpen ),
    PE( WORK_CONTEXT, ClientAddress ),
    PE( WORK_CONTEXT, WaitForOplockBreak ),
    UE( WORK_CONTEXT, BytesAvailable ),
    0
};

/*
 * The members in a BUFFER
 */
MEMBERLIST ML_BUFFER[] = {
    PE( BUFFER, Buffer ),
    UE( BUFFER, BufferLength ),
    PE( BUFFER, Mdl ),
    PE( BUFFER, PartialMdl ),
    UE( BUFFER, DataLength ),
    0
};

/*
 * The members in an ENDPOINT
 */
MEMBERLIST ML_ENDPOINT[] = {
    WE( ENDPOINT, NetworkName ),
    WE( ENDPOINT, TransportName ),
    AE( ENDPOINT, TransportAddress ),
    WE( ENDPOINT, ServerName ),
    WE( ENDPOINT, DomainName ),
    WE( ENDPOINT, NetworkAddress ),
    PE( ENDPOINT, EndpointHandle ),
    PE( ENDPOINT, FileObject ),
    PE( ENDPOINT, DeviceObject ),
    PE( ENDPOINT, IpxMaxPacketSizeArray ),
    UE( ENDPOINT, MaxAdapters ),
    HE( ENDPOINT, NameSocketHandle ),
    PE( ENDPOINT, NameSocketFileObject ),
    PE( ENDPOINT, NameSocketDeviceObject ),
    UE( ENDPOINT, FreeConnectionCount ),
    UE( ENDPOINT, TotalConnectionCount ),
    TE( ENDPOINT, ConnectionTable ),
    PE( ENDPOINT, FreeConnectionList ),
    0
};

/*
 * The members in a SEARCH
 */
MEMBERLIST ML_SEARCH[] = {
    WE( SEARCH, SearchName ),
    WE( SEARCH, LastFileNameReturned ),
    HE( SEARCH, DirectoryHandle ),
    PE( SEARCH, LastUseListEntry.Flink ),
    PE( SEARCH, HashTableEntry.Flink ),
    PE( SEARCH, Session ),
    PE( SEARCH, TreeConnect ),
//  UE( SEARCH, SearchStorageType ),
    PE( SEARCH, DirectoryCache ),
    SE( SEARCH, NumberOfCachedFiles ),
    SE( SEARCH, SearchAttributes ),
    SE( SEARCH, CoreSequence ),
    SE( SEARCH, TableIndex ),
    SE( SEARCH, HashTableIndex ),
    SE( SEARCH, Pid ),
    SE( SEARCH, Flags2 ),
    BE( SEARCH, Wildcards ),
    BE( SEARCH, InUse ),
    0
};

/*
 * The members in a CONNECTION
 */
MEMBERLIST ML_CONNECTION[] = {
    WE( CONNECTION, ClientMachineNameString ),
    WE( CONNECTION, ClientOSType ),
    WE( CONNECTION, ClientLanManType ),
    IA( CONNECTION, ClientIPAddress ),
    UE( CONNECTION, SmbDialect ),
    UE( CONNECTION, SpinLock ),
    UE( CONNECTION, Interlock ),
    UE( CONNECTION, BalanceCount ),
    UE( CONNECTION, LastRequestTime ),
    UE( CONNECTION, Lock ),
    UE( CONNECTION, LicenseLock ),
    PE( CONNECTION, EndpointSpinLock ),
    PE( CONNECTION, CachedRfcb ),
    UE( CONNECTION, CachedFid ),
    BE( CONNECTION, BreakIIToNoneJustSent ),
    BE( CONNECTION, EnableRawIo ),
    UE( CONNECTION, Sid ),
    PE( CONNECTION, Endpoint ),
    DE( CONNECTION, MaximumSendSize ),
    PE( CONNECTION, NegotiateHandle ),
    PE( CONNECTION, FileObject ),
    PE( CONNECTION, DeviceObject ),
    PE( CONNECTION, InProgressWorkItemList.Flink ),
    UE( CONNECTION, LatestOplockBreakResponse ),
    UE( CONNECTION, OplockBreaksInProgress ),
    PE( CONNECTION, CurrentWorkQueue ),
    PE( CONNECTION, PreferredWorkQueue ),
    UE( CONNECTION, RawReadsInProgress ),
    BE( CONNECTION, OplocksAlwaysDisabled ),
    BE( CONNECTION, EnableOplocks ),
    PE( CONNECTION, EndpointFreeListEntry.Flink ),
    PE( CONNECTION, OplockWorkList ),
    UE( CONNECTION, CachedOpenCount ),
    LE( CONNECTION, CachedOpenList, RFCB, CachedOpenListEntry ),
    UE( CONNECTION, CachedDirectoryCount ),
    LE( CONNECTION, CachedDirectoryList, CACHED_DIRECTORY, ListEntry ),
    HE( CONNECTION, ClientCapabilities ),
    UE( CONNECTION, CachedTransactionCount ),
    BE( CONNECTION, OnNeedResourceQueue ),
    BE( CONNECTION, NotReusable ),
    BE( CONNECTION, DisconnectPending ),
    BE( CONNECTION, ReceivePending ),
    PE( CONNECTION, PagedConnection ),
    UE( CONNECTION, BytesAvailable ),
    SE( CONNECTION, CurrentNumberOfSessions ),
    0
};

MEMBERLIST ML_CONNECTION_IPX[] = {
    SE( CONNECTION, SequenceNumber ),
    SE( CONNECTION, LastResponseLength ),
    SE( CONNECTION, LastResponseBufferLength ),
    SE( CONNECTION, LastUid ),
    SE( CONNECTION, LastTid ),
    HE( CONNECTION, LastResponseStatus ),
    UE( CONNECTION, StartupTime ),
    PE( CONNECTION, LastResponse ),
    SE( CONNECTION, IpxAddress.Socket ),
    UE( CONNECTION, IpxDuplicateCount ),
    UE( CONNECTION, IpxDropDuplicateCount ),
    0
};

MEMBERLIST ML_CONNECTION_VC[] = {
    BE( CONNECTION, SmbSecuritySignatureActive ),
    UE( CONNECTION, SmbSecuritySignatureIndex ),
    BE( CONNECTION, NoResponseSignatureIndex ),
    0
};

/*
 * The members in a PAGED_CONNECTION
 */
MEMBERLIST ML_PAGED_CONNECTION[] = {
    BE( PAGED_CONNECTION, LoggedInvalidSmb ),
//  BE( PAGED_CONNECTION, ClientTooOld ),
    UE( PAGED_CONNECTION, ClientBuildNumber ),
    PE( PAGED_CONNECTION, TransactionList.Flink ),
    PE( PAGED_CONNECTION, CoreSearchList.Flink ),
    HE( PAGED_CONNECTION, ConnectionHandle ),
    SE( PAGED_CONNECTION, CurrentNumberOfCoreSearches ),
    0
};

/*
 * The members in a TREE_CONNECT
 */
MEMBERLIST ML_TREE_CONNECT[] = {
    PE( TREE_CONNECT, Connection ),
    PE( TREE_CONNECT, Share ),
    WE( TREE_CONNECT, ServerName ),
    LE( TREE_CONNECT, GlobalTreeConnectListEntry.ListEntry, TREE_CONNECT, GlobalTreeConnectListEntry.ListEntry ),
    UE( TREE_CONNECT, CurrentFileOpenCount ),
    LE( TREE_CONNECT, ShareListEntry, SHARE, TreeConnectList ),
    PE( TREE_CONNECT, PrintFileList.Flink ),
    SE( TREE_CONNECT, Tid ),
    BE( TREE_CONNECT, RemapPipeNames ),
    0
};

/*
 * The members in a WORK_QUEUE
 */
MEMBERLIST ML_WORK_QUEUE[] = {
    UE( WORK_QUEUE, Queue.MaximumCount ),
    UE( WORK_QUEUE, Queue.CurrentCount ),
    UE( WORK_QUEUE, Queue.Header.SignalState ),
    UE( WORK_QUEUE, CurrentClients ),
    UE( WORK_QUEUE, AvgQueueDepthSum ),
    UE( WORK_QUEUE, Threads ),
    UE( WORK_QUEUE, AvailableThreads ),
    UE( WORK_QUEUE, MaxThreads ),
    UE( WORK_QUEUE, FreeWorkItems ),
    UE( WORK_QUEUE, AllocatedWorkItems ),
    UE( WORK_QUEUE, MaximumWorkItems ),
    UE( WORK_QUEUE, MinFreeWorkItems ),
    UE( WORK_QUEUE, NeedWorkItem ),
    UE( WORK_QUEUE, StolenWorkItems ),
    UE( WORK_QUEUE, FreeRawModeWorkItems ),
    UE( WORK_QUEUE, AllocatedRawModeWorkItems ),
    UE( WORK_QUEUE, PagedPoolLookAsideList.MaxSize ),
    UE( WORK_QUEUE, NonPagedPoolLookAsideList.MaxSize ),
    UE( WORK_QUEUE, PagedPoolLookAsideList.AllocHit ),
    UE( WORK_QUEUE, PagedPoolLookAsideList.AllocMiss ),
    UE( WORK_QUEUE, NonPagedPoolLookAsideList.AllocHit ),
    UE( WORK_QUEUE, NonPagedPoolLookAsideList.AllocMiss ),
    PE( WORK_QUEUE, CachedFreeRfcb ),
    UE( WORK_QUEUE, FreeRfcbs ),
    UE( WORK_QUEUE, MaxFreeRfcbs ),
    PE( WORK_QUEUE, CachedFreeMfcb ),
    UE( WORK_QUEUE, FreeMfcbs ),
    UE( WORK_QUEUE, MaxFreeMfcbs ),
    HE( WORK_QUEUE, SpinLock ),
    PE( WORK_QUEUE, IrpThread ),
    CE( WORK_QUEUE, CreateMoreWorkItems.BlockHeader.Type ),
    U64( WORK_QUEUE, IdleTimeOut ),
    U64( WORK_QUEUE, stats.BytesReceived ),
    U64( WORK_QUEUE, stats.BytesSent ),
    U64( WORK_QUEUE, stats.ReadOperations ),
    U64( WORK_QUEUE, stats.BytesRead ),
    U64( WORK_QUEUE, stats.WriteOperations ),
    U64( WORK_QUEUE, stats.BytesWritten ),
    U64( WORK_QUEUE, saved.ReadOperations ),
    U64( WORK_QUEUE, saved.BytesRead ),
    U64( WORK_QUEUE, saved.WriteOperations ),
    U64( WORK_QUEUE, saved.BytesWritten ),
    UE( WORK_QUEUE, stats.WorkItemsQueued.Count ),
    UE( WORK_QUEUE, stats.SystemTime ),
    0
};

/*
 * The members in a TABLE_HEADER
 */
MEMBERLIST ML_TABLE_HEADER[] = {
    SE( TABLE_HEADER, TableSize ),
    SE( TABLE_HEADER, FirstFreeEntry ),
    SE( TABLE_HEADER, LastFreeEntry ),
    BE( TABLE_HEADER, Nonpaged ),
    PE( TABLE_HEADER, Table ),
    0
};

/*
 * The members in a TABLE_ENTRY
 */
MEMBERLIST ML_TABLE_ENTRY[] = {
    PE( TABLE_ENTRY, Owner ),
//  SE( TABLE_ENTRY, SequenceNumber ),
//  SE( TABLE_ENTRY, NextFreeEntry ),
    0
};

/*
 * The members in a SHARE
 */
MEMBERLIST ML_SHARE[] = {
    WE( SHARE, ShareName ),
    WE( SHARE, NtPathName ),
    WE( SHARE, DosPathName ),
    WE( SHARE, Remark ),
    UE( SHARE, MaxUses ),
    UE( SHARE, CurrentUses ),
    HE( SHARE, RootDirectoryHandle ),
    UE( SHARE, CurrentRootHandleReferences ),
    DE( SHARE, QueryNamePrefixLength ),
    PE( SHARE, SecurityDescriptor ),
    PE( SHARE, FileSecurityDescriptor ),
    BE( SHARE, PotentialSystemFile ),
    BE( SHARE, Removable ),
    BE( SHARE, SpecialShare ),
    BE( SHARE, IsDfs ),
    BE( SHARE, IsDfsRoot ),
    HE( SHARE, CSCState ),
    LE( SHARE, TreeConnectList, TREE_CONNECT, ShareListEntry ),
    0
};

/*
 * Forward References...
 */
BOOL DumpTable( IN PTABLE_HEADER pt );

/*
 * Print out an optional message, a UNICODE_STRING, and maybe a new-line
 */
BOOL
PrintStringW( IN LPSTR msg OPTIONAL, IN PUNICODE_STRING puStr, IN BOOL nl )
{
    PWCHAR    StringData;
    ULONG BytesRead;

    if( ARGUMENT_PRESENT(msg) )
        dprintf( msg );

    if( puStr->Length == 0 ) {
        dprintf( "<Length == 0>" );
        if( nl )
            dprintf( "\n" );
        return TRUE;
    }

    if( puStr->Buffer == NULL ) {
        dprintf( "<Buffer == 0>" );
        if( nl )
            dprintf( "\n" );
        return TRUE;
    }

    StringData = (PWCHAR)LocalAlloc( LPTR, puStr->Length + sizeof(UNICODE_NULL));
    if( StringData == NULL ) {
        dprintf( "Out of memory!\n" );
        return FALSE;
    }

    ReadMemory( (ULONG_PTR)puStr->Buffer,
               StringData,
               puStr->Length,
               &BytesRead);

    if (BytesRead)  {
        StringData[ puStr->Length / sizeof( WCHAR ) ] = '\0';
        dprintf("%ws%s", StringData, nl ? "\n" : "" );
    }

    LocalFree( (HLOCAL)StringData );

    return BytesRead;
}

/*
 * Print out an optional message, an ANSI_STRING, and maybe a new-line
 */
BOOL
PrintStringA( IN LPSTR msg OPTIONAL, IN PANSI_STRING pStr, IN BOOL nl )
{
    PCHAR    StringData;
    ULONG    BytesRead;

    if( msg )
        dprintf( msg );

    if( pStr->Length == 0 ) {
        if( nl )
            dprintf( "\n" );
        return TRUE;
    }

    StringData = (PCHAR)LocalAlloc( LPTR, pStr->Length + 1 );

    if( StringData == NULL ) {
        ERRPRT( "Out of memory!\n" );
        return FALSE;
    }

    ReadMemory((ULONG_PTR) pStr->Buffer,
               StringData,
               pStr->Length,
               &BytesRead );

    if ( BytesRead ) {
        StringData[ pStr->Length ] = '\0';
        dprintf("%s%s", StringData, nl ? "\n" : "" );
    }

    LocalFree((HLOCAL)StringData);

    return BytesRead;
}

/*
 * Get 'size' bytes from the debuggee program at 'dwAddress' and place it
 * in our address space at 'ptr'.  Use 'type' in an error printout if necessary
 */
BOOL
GetData( IN LPVOID ptr, IN ULONG_PTR dwAddress, IN ULONG size, IN PCSTR type )
{
    BOOL b;
    ULONG BytesRead;
    ULONG count;

    while( size > 0 ) {

        count = MIN( size, 3000 );

        b = ReadMemory( dwAddress, ptr, count, &BytesRead );

        if (!b || BytesRead != count ) {
            ERRPRT( "Unable to read %u bytes at %X, for %s\n", size, dwAddress, type );
            return FALSE;
        }

        dwAddress += count;
        size -= count;
        ptr = (LPVOID)((PBYTE)ptr + count);
    }

    return TRUE;
}

/*
 * Follow a LIST_ENTRY list beginning with a head at dwListHeadAddr in the debugee's
 * address space.  For each element in the list, print out the pointer value at 'offset'
 */
BOOL
PrintListEntryList( IN ULONG_PTR dwListHeadAddr, IN LONG offset )
{
    LIST_ENTRY    ListEntry;
    ULONG i=0;
    BOOL retval = TRUE;
    ULONG count = 20;

    if( !GetData( &ListEntry, dwListHeadAddr, sizeof( ListEntry ), "LIST_ENTRY" ) )
        return FALSE;

    while( count-- ) {

        if( (ULONG_PTR)ListEntry.Flink == dwListHeadAddr || (ULONG_PTR)ListEntry.Flink == 0 )
            break;

        if( !GetData( &ListEntry, (ULONG_PTR)ListEntry.Flink, sizeof( ListEntry ), "ListEntry" ) ) {
            retval = FALSE;
            break;
        }

        dprintf( "%16X%s", (ULONG_PTR)ListEntry.Flink + offset, (i && !(i&3)) ? "\n" : "" );
        i++;
    }


    if( count == 0 && (ULONG_PTR)ListEntry.Flink != dwListHeadAddr && ListEntry.Flink ) {
        dprintf( "\nTruncated list dump\n" );

    } else if( ! ( i && !(i&3) ) ) {
        dprintf( "\n" );
    }

    return retval;
}


/*
 * 'ptr' points to a structure in our address space which is described by the MEMBERLIST bp.
 * Print out the structure according to the MEMBERLIST
 */
VOID
PrintMemberList( IN VOID *ptr, IN MEMBERLIST *bp )
{
    int i;
    PCSTR nl = "\n";
    PCSTR sep = " ";
    PCSTR nlsep = "\n    ";
    DWORD d;

    for( i=0; bp->name; i++, bp++ ) {

        if( (i&1) == 0 )
            dprintf( "    " );

        if( bp->type == 'T' ) {
            dprintf( "%s -- TABLE FOLLOWS -->\n", bp->name );

        } else if( strlen( bp->name ) > 30 ) {
            dprintf( "%-.17s...%s ", bp->name, bp->name+strlen(bp->name)-10 );

        } else {
            dprintf( "%-30s ", bp->name );
        }

        switch( bp->type ) {
        case 'R':
//          dprintf( "%-16X%s", (ULONG_PTR)ptr, i&1 ? nl : sep );
            break;

        case 'C':
            dprintf( "%-16X%s",
                (*(UCHAR *)(((char *)ptr) + bp->offset )) & 0xFF ,
                i&1 ? nl : sep );
            break;

        case 'B':
            dprintf( "%-16s%s",
                *(BOOLEAN *)(((char *)ptr) + bp->offset ) ? "TRUE" : "FALSE",
                i&1 ? nl : sep );
            break;
        case 'H':
        case 'P':
            dprintf( "%-16X%s",
                *(ULONG *)(((char *)ptr) + bp->offset ),
                i&1 ? nl : sep );
            break;
        case 'N':
            //
            // IP Address
            //
            d = *(ULONG *)(((char *)ptr) + bp->offset );
            dprintf( "%-3.3u.%-3.3u.%-3.3u.%-3.3u %s",
                (d&0xFF),
                (d&0xFF00)>>8,
                (d&0xFF0000)>>16,
                (d&0xFF000000)>>24,
                i&1 ? nl : sep );
            break;
        case 'U':
        case 'L':
            dprintf( "%-16d%s",
                *(ULONG *)(((char *)ptr) + bp->offset ),
                i&1 ? nl : sep );
            break;
        case '6':
            {
            ULONGLONG l;
            RtlCopyMemory( &l, ((char *)ptr) + bp->offset, sizeof( l ) );
            dprintf( "%I64u%s", l, i&1 ? nl : sep );
            }
            break;
        case 'S':
            dprintf( "%-16X%s",
                *(SHORT *)(((char *)ptr) + bp->offset ) & 0xFFFF,
                i&1 ? nl : sep );
            break;
        case 'W':
            if( i&1 ) dprintf( nlsep );
            PrintStringW( NULL, (UNICODE_STRING *)(((char *)ptr) + bp->offset ), NL );
            i |= 1;
            break;
        case 'A':
            if( i&1 ) dprintf( nlsep );
            PrintStringA( NULL, (ANSI_STRING *)(((char *)ptr) + bp->offset ), NL );
            i |= 1;
            break;
        case 'I':
        {
            UCHAR SymbolName[ 200 ];
            ULONG_PTR Displacement;
            PVOID sym = (PVOID)(*(ULONG_PTR *)(((char *)ptr) + bp->offset ));

            GetSymbol( sym, SymbolName, &Displacement );
            dprintf( "%-16s\n", SymbolName );
            i |= 1;
        }
            break;

        case 'T':
            DumpTable( (PTABLE_HEADER)(((char *)ptr) + bp->offset) );
            dprintf( "  --- End Of %s Table ---\n", bp->name );
            i |= 1;
            break;

        case 'K':
        {
            UCHAR Type = *(UCHAR *)(((char *)ptr) + bp->offset );

            if( Type < 0 || Type >= BlockTypeMax )
                dprintf( "%-16X%s", Type, i&1 ? nl : sep );
            else
                dprintf( "%-16s%s", BlockType[ Type ], i&1 ? nl : sep );
        }
            break;

        case 'Q':
        {
            UCHAR State = *(UCHAR *)(((char *)ptr) + bp->offset );
            if( State < 0 || State >= BlockStateMax )
                dprintf( "%-16X%s", State, i&1 ? nl : sep );
            else
                dprintf( "%-16s%s", BlockState[ State ], i&1 ? nl : sep );
        }
            break;

        case 'Z':
            if( i&1 ) dprintf( nl );
            PrintListEntryList( *(ULONG *)(((char *)ptr) + bp->offset ), -(bp->extra) );
            i |= 1;
            break;

        default:
            ERRPRT( "Unrecognized field type %c for %s\n", bp->type, bp->name );
            break;
        }
    }

    if( i & 1 )
        dprintf( "\n" );
}

/*
 * Print out a single HEX character
 */
VOID
PrintHexChar( IN UCHAR c )
{
    dprintf( "%c%c", "0123456789abcdef"[ (c>>4)&0xf ], "0123456789abcdef"[ c&0xf ] );
}

/*
 * Print out 'buf' of 'cbuf' bytes as HEX characters
 */
VOID
PrintHexBuf( IN PUCHAR buf, IN ULONG cbuf )
{
    while( cbuf-- ) {
        PrintHexChar( *buf++ );
        dprintf( " " );
    }
}

/*
 *  Print out the TABLE structure at TABLE_HEADER
 */
BOOL
DumpTable( IN PTABLE_HEADER pt )
{
    LONG i;
    PTABLE_ENTRY pte;
    BOOL bEmpty = TRUE;

    PrintMemberList( pt, ML_TABLE_HEADER );

    if( pt->TableSize < 0 ) {
        ERRPRT( "    ILLEGAL TABLE SIZE\n" );
        return FALSE;
    }

    if( pt->FirstFreeEntry > pt->TableSize ) {
        ERRPRT( "    ILLEGAL FirstFreeEntry\n" );
        return FALSE;
    }

    if( pt->LastFreeEntry > pt->TableSize ) {
        ERRPRT( "    ILLEGAL LastFreeEntry\n" );
        return FALSE;
    }

    pte = (PTABLE_ENTRY)LocalAlloc( LPTR, pt->TableSize * sizeof( TABLE_ENTRY ) );
    if( pte == NULL ) {
        ERRPRT( "Out of memory!\n" );
        return FALSE;
    }

    if( !GetData( pte, (ULONG_PTR)pt->Table, pt->TableSize * sizeof(TABLE_ENTRY), "TABLE_ENTRY" ) ) {
        LocalFree( (HLOCAL)pte );
        return FALSE;
    }

    for( i=0; i < pt->TableSize; i++ ) {

        if( pte[i].Owner != NULL ) {
            bEmpty = FALSE;
            dprintf( "%d-%X ", i, pte[i].Owner );
        }

        if( pte[i].NextFreeEntry > pt->TableSize ) {
            ERRPRT( "  ILLEGAL NextFreeEntry %d-%d\n    ", i, pte[i].NextFreeEntry );
            LocalFree( (HLOCAL)pte );
            return FALSE;
        }
    }

    dprintf( "\n" );
    LocalFree( (HLOCAL)pte );

    if( bEmpty )
        dprintf( "    ** Empty Table**\n    " );

    return TRUE;
}

/*
 * Fetch the null terminated UNICODE string at dwAddress into buf
 */
BOOL
GetString( IN ULONG_PTR dwAddress, IN LPWSTR buf, IN ULONG MaxChars )
{
    do {
        if( !GetData( buf, dwAddress, sizeof( *buf ), "UNICODE Character" ) )
            return FALSE;

        dwAddress += sizeof( *buf );

    } while( --MaxChars && *buf++ != '\0' );

    return TRUE;
}

/*
 * Check out the BLOCK_HEADER structure, ensuring its Type is 'Desired'.
 * If bRefCount == TRUE, ensure the BLOCK_HEADER's reference is > 0
 */
BOOL
CheckBlockHeader( IN PBLOCK_HEADER ph, IN UCHAR Desired, IN BOOL bRefCount )
{
    if( ph->Type != Desired ) {
        ERRPRT( "BLOCK_HEADER.Type is %X, should be %X\n",
          ph->Type, Desired );
        return FALSE;
    }

    if( ph->State < 0 || ph->State >= BlockStateMax ) {
        ERRPRT( "  BLOCK_HEADER.State is %X:  INVALID\n", ph->State );
        return FALSE;
    }

    if( ph->Size == 0 ) {
        ERRPRT( "  BLOCK_HEADER ILLEGAL SIZE!\n" );
        return FALSE;
    }

    if( bRefCount && ph->ReferenceCount == 0 ) {
        ERRPRT( "  BLOCK_HEADER.ReferenceCount == 0!\n" );
        return FALSE;
    }

    return TRUE;
}

/*
 * Print out the BLOCK_HEADER, and optionally its ReferenceCount
 */
BOOL
PrintBlockHeader( IN PBLOCK_HEADER ph, IN BOOL bRefCount )
{
    dprintf( "BLOCK_HEADER Info:  " );
    if( ph->State < 0 || ph->State >= BlockStateMax ) {
        ERRPRT( "State is %X:  INVALID\n", ph->State );
        return FALSE;
    }

    dprintf( "%s", BlockState[ ph->State ] );

    if( ph->Type < 0 || ph->Type >= BlockTypeMax ) {
        ERRPRT( "\nBlockType is %X:  INVALID\n", ph->Type );
        return FALSE;
    }

    dprintf( ", %s", BlockType[ ph->Type ] );
    dprintf( ", Size %u", ph->Size );

    if( ph->Size == 0 ) {
        ERRPRT( "  BLOCK_HEADER ILLEGAL SIZE!\n" );
        return FALSE;
    }

    dprintf( ", ReferenceCount %u", ph->ReferenceCount );


    dprintf( "\n" );

    return TRUE;
}

/*
 * Print out the NONPAGED_HEADER structure, ensuring its type is 'Desired', that
 * it points back to its paged block at 'dwPagedBlock'.
 */
BOOL
PrintNonpagedHeader(
    IN PNONPAGED_HEADER ph,
    IN ULONG Desired,
    IN ULONG_PTR dwPagedBlock,
    IN BOOL bRefCount
)
{
    dprintf( "NONPAGED_HEADER Info:  " );
    if( ph->Type != Desired ) {
        ERRPRT( "NONPAGED_HEADER.Type is %X, should be %X\n",
          ph->Type, Desired );
        return FALSE;
    }
    if( bRefCount && ph->ReferenceCount == 0 ) {
        ERRPRT( "  NONPAGED_HEADER.ReferenceCount == 0!\n" );
        return FALSE;
    }
    if( (ULONG_PTR)ph->PagedBlock != dwPagedBlock ) {
        ERRPRT( "    NONPAGED_HEADER.PagedBlock is %X, should be %X\n", ph->PagedBlock, dwPagedBlock );
        return FALSE;
    }

    if( bRefCount )
        dprintf( "ReferenceCount %u\n", ph->ReferenceCount, ph->PagedBlock );

    return TRUE;
}

BOOL
DumpShare( IN ULONG_PTR dwAddress, IN SHARE_TYPE type, IN PCSTR ShareName OPTIONAL, OUT PLIST_ENTRY *Flink OPTIONAL )
{
    BOOL     b;
    SHARE    Share;

    if( !GetData( &Share, dwAddress, sizeof( Share ), "SHARE" ) ||
        !CheckBlockHeader( &Share.BlockHeader, BlockTypeShare, TRUE ) ) {

        return FALSE;
    }

    if( ARGUMENT_PRESENT( Flink ) ) {
        *Flink = Share.GlobalShareList.Flink;
    }

    if( type != (SHARE_TYPE)-1 && type != Share.ShareType ) {
        return TRUE;
    }

    if( ARGUMENT_PRESENT( ShareName ) ) {
        //
        // Only print this share structure out if the name is 'ShareName'
        //

        PWCHAR    StringData;
        ULONG BytesRead;
        CHAR   NameBuf[ MAX_PATH ];

        if( Share.ShareName.Length == 0 ) {
            return TRUE;
        }

        StringData = LocalAlloc(LPTR,Share.ShareName.Length + sizeof(UNICODE_NULL));
        if( StringData == NULL ) {
            dprintf( "Out of memory!\n" );
            return FALSE;
        }

        ReadMemory( (ULONG_PTR)Share.ShareName.Buffer, StringData, Share.ShareName.Length, &BytesRead );

        if (BytesRead == 0 )  {
            LocalFree( (HLOCAL)StringData );
            return FALSE;
        }

        StringData[ Share.ShareName.Length / sizeof( WCHAR ) ] = '\0';
        wcstombs( NameBuf, StringData, sizeof( NameBuf ) );
        LocalFree( (HLOCAL)StringData);

        if( _strcmpi( NameBuf, ShareName ) ) {
            return TRUE;
        }
    }

    dprintf( "\nSHARE at %X: ", dwAddress );

    PrintBlockHeader( &Share.BlockHeader, TRUE );
    dprintf( "    " );

    switch( Share.ShareType ) {
    case ShareTypeDisk:
        dprintf( "ShareTypeDisk\n" );
        break;
    case ShareTypePrint:
        dprintf( "ShareTypePrint, Type.hPrinter = %X  ", Share.Type.hPrinter );
        break;
    case ShareTypePipe:
        dprintf( "ShareTypePipe\n" );
        break;
    case ShareTypeWild:
        dprintf( "ShareTypeWild\n" );
        break;
    default:
        ERRPRT( "ShareType %X : INVALID!\n", Share.ShareType );
        return FALSE;
    }

    PrintMemberList( &Share, ML_SHARE );

    if( Share.CurrentUses > Share.MaxUses ) {
        ERRPRT( "    CurrentUses exceeds MaxUses!\n" );
        return FALSE;
    }

    dprintf( "\n" );


    return TRUE;
}

BOOL
DumpLock( IN ULONG_PTR dwAddress )
{
    SRV_LOCK sl;
    char namebuf[ 50 ];
    int i;

    if( !GetData( &sl, dwAddress, sizeof(sl), "ERESOURCE" ) )
        return FALSE;

    dprintf( "    ActiveCount %u, ",dwAddress, sl.ActiveCount );
    switch( sl.Flag ) {
    case ResourceNeverExclusive:
        dprintf( "ResourceNeverExclusive, " );
        break;
    case ResourceReleaseByOtherThread:
        dprintf( "ResourceReleaseByOtherThread, " );
        break;
    case ResourceOwnedExclusive:
        dprintf( "ResourceOwnedExclusive, " );
        break;
    default:
        ERRPRT( "Flag = %X%s, ", sl.Flag, sl.Flag ? "(?)" : "" );
        break;
    }
    dprintf( "SpinLock %d\n", sl.SpinLock );

    for( i=0; i < 2; i++ ) {
        if( sl.OwnerThreads[i].OwnerThread == 0 && sl.OwnerThreads[i].OwnerCount == 0 )
            continue;
        dprintf( "        OwnerThreads[%d].OwnerThread %X, OwnerCount %d\n",
            i, sl.OwnerThreads[i].OwnerThread, sl.OwnerThreads[i].OwnerCount );
    }

    return TRUE;
}

BOOL
DumpEndpoint( IN ULONG_PTR dwAddress, IN PLIST_ENTRY *Flink OPTIONAL )
{
    ENDPOINT    Endpoint;

    dprintf( "\nENDPOINT at %X: ", dwAddress );
    if( !GetData( &Endpoint, dwAddress, sizeof( Endpoint ), "ENDPOINT" ) ||
      !CheckBlockHeader( &Endpoint.BlockHeader, BlockTypeEndpoint, TRUE ) ||
      !PrintBlockHeader( &Endpoint.BlockHeader, TRUE ) ) {

        return FALSE;
    }

    PrintMemberList( &Endpoint, ML_ENDPOINT );

    dprintf( "    NetworkAddressData: %ws\n", Endpoint.NetworkAddressData );

    if( ARGUMENT_PRESENT( Flink ) )
        *Flink = Endpoint.GlobalEndpointListEntry.ListEntry.Flink;

    return TRUE;
}

BOOL
DumpSearch( IN ULONG_PTR dwAddress )
{
    SEARCH s;

    dprintf( "\nSEARCH at %X: ", dwAddress );

    if( !GetData( &s, dwAddress, sizeof(s), "SEARCH" ) ||
        !PrintBlockHeader( &s.BlockHeader, TRUE ) ) {
        return FALSE;
    }

    PrintMemberList( &s, ML_SEARCH );

    return TRUE;
}

BOOL
DumpBuffer( IN ULONG_PTR dwAddress )
{
    BUFFER b;

    dprintf( "\nBUFFER at %X:\n", dwAddress );

    if( !GetData( &b, dwAddress, sizeof(b), "BUFFER" ) )
        return FALSE;

    PrintMemberList( &b, ML_BUFFER );

    return TRUE;
}

BOOL
DumpSmb( IN ULONG_PTR dwAddress )
{
    NT_SMB_HEADER s;
    UCHAR WordCount;

    dprintf( "\nSMB_HEADER at %X\n", dwAddress );

    if( !GetData( &s, dwAddress, sizeof(s), "SMBHEADER" ) )
        return FALSE;

    PrintMemberList( &s, ML_SMB_HEADER );

    if( !GetData( &WordCount, dwAddress+sizeof( NT_SMB_HEADER ), sizeof( WordCount), "WordCount" )){
        ERRPRT( "Unable to retrieve WordCount at %X\n", dwAddress+sizeof(NT_SMB_HEADER) );
        return FALSE;
    }

    dprintf( "\nWordCount @ %X = %u\n", dwAddress + sizeof( NT_SMB_HEADER), WordCount );

    return TRUE;
}

BOOL
DumpTcon( IN ULONG_PTR dwAddress, IN DWORD offset, IN DWORD *value OPTIONAL )
{
    TREE_CONNECT Tcon;
    NONPAGED_HEADER NonpagedHeader;

    dprintf( "\nTREE_CONNECT at %X: ", dwAddress );

    if( !GetData( &Tcon, dwAddress, sizeof( Tcon ), "TREE_CONNECT" ) ||
      !CheckBlockHeader( &Tcon.BlockHeader, BlockTypeTreeConnect, FALSE ) ||
      !GetData( &NonpagedHeader, (ULONG_PTR)Tcon.NonpagedHeader, sizeof(NonpagedHeader),"NONPAGED_HEADER" ) ) {

        return FALSE;
    }

    if( !PrintBlockHeader( &Tcon.BlockHeader, FALSE ) ||
        !PrintNonpagedHeader( &NonpagedHeader, BlockTypeTreeConnect, dwAddress, TRUE ) ) {
        return FALSE;
    }

    PrintMemberList( &Tcon, ML_TREE_CONNECT );

    if( ARGUMENT_PRESENT( value ) )
        *value = *(DWORD *)(((UCHAR *)&Tcon) + offset);

    dprintf( "\n" );
    return TRUE;
}

BOOL
DumpConnection( IN ULONG_PTR dwAddress, IN DWORD offset, OUT DWORD *value OPTIONAL )
{
    CONNECTION Connection;
    PAGED_CONNECTION pc;
    WORK_CONTEXT wc;
    ULONG_PTR wcAddr;

    dprintf( "\nCONNECTION at %X: ", dwAddress );

    if( !GetData( &Connection, dwAddress, sizeof( Connection ), "CONNECTION" ) ||
      !CheckBlockHeader( &Connection.BlockHeader, BlockTypeConnection, TRUE ) ||
      !PrintBlockHeader( &Connection.BlockHeader, TRUE ) ) {

        return FALSE;
    }

    if( ARGUMENT_PRESENT( value ) )
        *value = *(DWORD *)(((UCHAR *)&Connection) + offset);

    dprintf( "    OemClientMachineName: %s\n", Connection.OemClientMachineName );

    PrintMemberList( &Connection, ML_CONNECTION );

    if( Connection.DeviceObject != NULL ) {
        //
        // Assume this is a VC oriented client
        //
        PrintMemberList( &Connection, ML_CONNECTION_VC );
    } else {
        //
        // Assume this is a direct host IPX client
        //
        PrintMemberList( &Connection, ML_CONNECTION_IPX );
    }

    dprintf( "\n  FileTable (contains RFCBs:)\n" );
    if( !DumpTable( &Connection.FileTable ) )
        return FALSE;

    /*
     * See if we can get the PAGED_CONNECTION data
     */
    dprintf( "\nPagedConnection Data->  " );

    if( !GetData( &pc, (ULONG_PTR)Connection.PagedConnection, sizeof(pc), "PAGED_CONNECTION" ) )
        return FALSE;

    PrintMemberList( &pc,ML_PAGED_CONNECTION );

    dprintf( "EncryptionKey: " );
    PrintHexBuf( pc.EncryptionKey, sizeof( pc.EncryptionKey ) );

    dprintf( "\n\n  SessionTable\n" );
    if( !DumpTable( &pc.SessionTable ) )
        return FALSE;

    dprintf( "\n  TreeConnectTable\n" );
    if( !DumpTable( &pc.TreeConnectTable ) )
        return FALSE;

    dprintf( "\n  SearchTable\n" );
    if( !DumpTable( &pc.SearchTable ) )
        return FALSE;

    //
    // Print out the in progress work item list
    //
    dwAddress += FIELD_OFFSET( CONNECTION, InProgressWorkItemList.Flink );

    if( (ULONG_PTR)Connection.InProgressWorkItemList.Flink != dwAddress ) {

        ULONG_PTR thisEntry;
        LIST_ENTRY le;

        dprintf( "\nIn-progress work contexts:\n" );

        thisEntry = (ULONG_PTR)Connection.InProgressWorkItemList.Flink;

        while( 1 ) {

            if( CheckControlC() ) {
                break;
            }

            if( thisEntry == dwAddress ) {
                break;
            }

            wcAddr = thisEntry - FIELD_OFFSET( WORK_CONTEXT, InProgressListEntry.Flink );

            RtlZeroMemory( &wc, sizeof( wc ) );
            GetData( &wc, wcAddr, sizeof( wc ), "WORK_CONTEXT" );

            dprintf( "  %p: Rfcb %p, Session %p, Share %p, TreeConnect %p\n",
                wcAddr, wc.Rfcb, wc.Session, wc.Share, wc.TreeConnect );

            if( !GetData( &le, thisEntry, sizeof( le ), "LIST_ENTRY" ) )
                break;

            thisEntry = (ULONG_PTR)le.Flink;
        }
    }

    dprintf( "\n" );

    return TRUE;
}

BOOL
DumpLfcb( IN ULONG_PTR dwAddress )
{
    LFCB l;

    if( !GetData( &l, dwAddress, sizeof( l ), "LFCB" ) ||
      !CheckBlockHeader( (PBLOCK_HEADER)&l.BlockHeader, BlockTypeLfcb, TRUE ) ||
      !PrintBlockHeader( (PBLOCK_HEADER)&l.BlockHeader, TRUE ) ) {
        return FALSE;
    }

    PrintMemberList( &l, ML_LFCB );
    return TRUE;
}

BOOL
DumpMfcb( IN ULONG_PTR dwAddress )
{
    MFCB m;
    NONPAGED_MFCB npm;

    if( !GetData( &m, dwAddress, sizeof( m ), "MFCB" ) ||
      !CheckBlockHeader( (PBLOCK_HEADER)&m.BlockHeader, BlockTypeMfcb, FALSE ) ||
      !PrintBlockHeader( (PBLOCK_HEADER)&m.BlockHeader, FALSE ) ||
      !GetData( &npm, (ULONG_PTR)m.NonpagedMfcb, sizeof( npm ), "NONPAGED_MFCB" ) ) {
        return FALSE;
    }

    PrintMemberList( &m, ML_MFCB );
    PrintMemberList( &npm, ML_NONPAGED_MFCB );
    return TRUE;
}

BOOL
DumpRfcb( ULONG_PTR dwAddress, PLIST_ENTRY *Flink )
{
    RFCB r;
    MFCB m;
    PAGED_RFCB p;
    BOOL PagedPresent;

    if( !GetData( &r, dwAddress, sizeof( r ), "RFCB" ) ||
      !CheckBlockHeader( (PBLOCK_HEADER)&r, BlockTypeRfcb, FALSE ) ) {
        return FALSE;
    }

    PagedPresent = GetData( &p,(ULONG_PTR)r.PagedRfcb, sizeof( p ), "PAGED_RFCB" );

    dprintf( "Rfcb @ %x:\n", dwAddress );
    if( Flink == NULL ) {
        if( !PrintBlockHeader( (PBLOCK_HEADER)&r, TRUE ) )
            return FALSE;
        PrintMemberList( &r, ML_RFCB );
        if( PagedPresent ) PrintMemberList( &p, ML_PAGED_RFCB );

    } else {

        PrintMemberList( &r, ML_RFCB_QUICK );
        *Flink = r.GlobalRfcbListEntry.ListEntry.Flink;
    }

    if( !GetData( &m, (ULONG_PTR)r.Mfcb, sizeof( m ), "MFCB" ) )
        return FALSE;

    PrintStringW( "File: ", &m.FileName, TRUE );

    return TRUE;
}

BOOL
DumpSession( IN ULONG_PTR dwAddress, IN DWORD offset, OUT DWORD *value OPTIONAL )
{
    SESSION Session;
    NONPAGED_HEADER NonpagedHeader;

    if( !GetData( &Session, dwAddress, sizeof( Session ), "SESSION" ) ||
      !CheckBlockHeader( &Session.BlockHeader, BlockTypeSession, FALSE ) ||
      !PrintBlockHeader( &Session.BlockHeader, FALSE ) ||
      !GetData( &NonpagedHeader, (ULONG_PTR)Session.NonpagedHeader, sizeof(NonpagedHeader),"NONPAGED_HEADER" ) ||
      !PrintNonpagedHeader( &NonpagedHeader, BlockTypeSession, dwAddress, TRUE ) ) {

        return FALSE;
    }

    if( ARGUMENT_PRESENT( value ) )
        *value = *(DWORD *)(((UCHAR *)&Session) + offset);

    PrintMemberList( &Session, ML_SESSION );

    dprintf(     "%-30s ", "NtUserSessionKey"  );
    PrintHexBuf( Session.NtUserSessionKey, sizeof( Session.NtUserSessionKey ) );
    dprintf( "\n    %-30s ", "LanManSessionKey" );
    PrintHexBuf( Session.LanManSessionKey, sizeof( Session.LanManSessionKey ) );
    dprintf( "\n\n" );

    return TRUE;
}

BOOL
DumpTransaction( IN ULONG_PTR dwAddress )
{
    TRANSACTION t;

    dprintf( "\nTRANSACTION at %X:\n", dwAddress );

    if( !GetData( &t, dwAddress, sizeof(t), "TRANSACTION" ) )
        return FALSE;

    PrintMemberList( &t, ML_TRANSACTION );

    return TRUE;
}

BOOL
DumpWorkContext( IN ULONG_PTR dwAddress )
{
    WORK_CONTEXT wc;

    dprintf( "\nWORK_CONTEXT at %X:\n", dwAddress );

    if( !GetData( &wc, dwAddress, sizeof(wc), "WORK_CONTEXT" ) )
        return FALSE;

    PrintMemberList( &wc, ML_WORK_CONTEXT );

    dprintf( "    Parameters addr %X, Parameters2 addr %X\n",
        dwAddress + FIELD_OFFSET( WORK_CONTEXT, Parameters ),
        dwAddress + FIELD_OFFSET( WORK_CONTEXT, Parameters2 ));

    if( wc.BlockingOperation )
        dprintf( "    BlockingOperation" );
    if( wc.UsingExtraSmbBuffer )
        dprintf( "    UsingExtraSmbBuffer" );
    if( wc.OplockOpen )
        dprintf( "    OplockOpen" );
    if( wc.ShareAclFailure )
        dprintf( "    ShareAclFailure" );
    if( wc.QueueToHead )
        dprintf( "    QueueToHead" );
    if( wc.NoResponseSmbSecuritySignature )
        dprintf( "    NoResponseSmbSecuritySignature" );
    if( wc.LargeIndication )
        dprintf( "    LargeIndication" );

    dprintf( "\n" );

    return TRUE;
}

VOID *
ThreadHandleToPointer( HANDLE hThread )
{
    return (VOID *)hThread;
}

BOOL
DumpWorkQueue( IN ULONG_PTR dwAddress )
{
    WORK_QUEUE WorkQueue;
    ULONG i;
    PHANDLE pHandles;

    dprintf( " at %X:\n", dwAddress );

    if( !GetData( &WorkQueue, dwAddress, sizeof( WorkQueue ), "WORK_QUEUE" ) )
        return FALSE;

    if( WorkQueue.Queue.Header.Type != QueueObject ) {
        ERRPRT( "WARNING: Queue.Header.Type is %X, should be %X\n",
            WorkQueue.Queue.Header.Type, QueueObject );
    }

    if( WorkQueue.Queue.Header.Size != sizeof( KQUEUE )/ sizeof( LONG ) ) {
        ERRPRT( "WARNING: Queue.Header.Size is %d, should be %d\n",
            WorkQueue.Queue.Header.Size, sizeof( KQUEUE ) );
    }

    PrintMemberList( &WorkQueue, ML_WORK_QUEUE );

    if( WorkQueue.Queue.Header.SignalState > 0 ) {
        dprintf( "  Queued WORK_CONTEXTs:\n" );
        if( !PrintListEntryList( dwAddress + FIELD_OFFSET(WORK_QUEUE, Queue.EntryListHead.Flink ),
             FIELD_OFFSET( KWAIT_BLOCK, Thread ))) {
        }
    }

    return TRUE;
}

VOID
PrintHelp( VOID )
{
    int i;

    for( i=0; Extensions[i]; i++ )
        dprintf( "   %s\n", Extensions[i] );
}
/*
 * Print out the usage message
 */
DECLARE_API( help )
{
    PrintHelp();
}

/*
 * Follow a LIST_ENTRY to the end
 */
DECLARE_API( df )
{
    LIST_ENTRY ListEntry;
    ULONG_PTR headAddress, dwAddress, prevAddress;
    ULONG count = 0;

    if( args == NULL || *args == '\0' ) {
        PrintHelp();
        return;
    }

    headAddress = GetExpression( args );

    if( !headAddress ||
        !GetData( &ListEntry, headAddress, sizeof( ListEntry ), "LIST_HEAD" ) ) {
        return;
    }

    prevAddress = headAddress;

    while( !CheckControlC() ) {

        dwAddress = (ULONG_PTR)ListEntry.Flink;

        if( dwAddress == headAddress ) {
            dprintf( "    %u elements in the list\n", count );
            return;
        }

        if( dwAddress == prevAddress ) {
            dprintf( "    Flink at %X points to itself.  Count %u\n", dwAddress, count );
        }

        if( !GetData( &ListEntry, dwAddress, sizeof( ListEntry ), "LIST_ENTRY" ) ) {
            dprintf( "    Flink at %X is bad --", prevAddress );
            dprintf( "  %u elements into list\n", count );
            return;
        }

        prevAddress = dwAddress;
        count++;
    }

    dprintf( "    CTRL-C: %u elements scanned\n", count );
}

DECLARE_API( pagedconnection )
{
    ULONG_PTR dwAddress;
    PAGED_CONNECTION pc;

    if( args == NULL || *args == '\0' ) {
        PrintHelp();
    } else {
        dwAddress = GetExpression( args );
        if( dwAddress && GetData( &pc, dwAddress, sizeof(pc), "PAGED_CONNECTION" ) ) {
            dprintf( "    sizeof( PAGED_CONNECTION ) = %d bytes\n", sizeof( pc ) );
            PrintMemberList( &pc, ML_PAGED_CONNECTION );
        }
    }
}

DECLARE_API( share )
{
    ULONG_PTR   dwAddress;
    BOOL    ShowMany = FALSE;
    SHARE_TYPE ShareType = (SHARE_TYPE)-1;
    LPCSTR ShareName = NULL;
    LIST_ENTRY SrvShareHashTable[ NSHARE_HASH_TABLE ];
    ULONG i;

    if( args == NULL || *args == '\0'  ) {
        ShowMany = TRUE;
    } else if( !_strcmpi( args, "disk" ) ) {
        ShowMany = TRUE;
        ShareType = ShareTypeDisk;
    } else if( !_strcmpi( args, "print" ) ) {
        ShowMany = TRUE;
        ShareType = ShareTypePrint;
    } else if( !_strcmpi( args, "pipe" ) ) {
        ShowMany = TRUE;
        ShareType = ShareTypePipe;
    } else if( args[0] == '=' ) {
        ShareName = args + 1;
        ShowMany = TRUE;
    } else if( !_strcmpi( args, "?" ) ) {
        PrintHelp();
        return;
    }

    if( ShowMany == FALSE ) {
        //
        // Get at the address that was passed to this on the command line.
        //
        dwAddress = GetExpression( args );

        if( dwAddress == 0 )
            return;

        DumpShare( dwAddress, ShareType, NULL, NULL );
        return;
    }

    //
    // Dump entries from the entire server share table!
    //

    dwAddress = GetExpression( "srv!SrvShareHashTable" );
    if( dwAddress == 0 ) {
        ERRPRT( "Unable to get address for srv!SrvShareHashTable\n" );
        return;
    }
    if( !GetData( SrvShareHashTable, dwAddress, sizeof( SrvShareHashTable ), "HASH TABLE" ) ) {
        ERRPRT( "Unable to read hash table\n" );
        return;
    }

    for( i = 0; i < NSHARE_HASH_TABLE; i++ ) {

        LIST_ENTRY *NextShare;

        NextShare = SrvShareHashTable[i].Flink;

        while( (ULONG_PTR)NextShare != dwAddress + i*sizeof( LIST_ENTRY ) ) {

            ULONG_PTR ShareEntry;

            ShareEntry = (ULONG_PTR)CONTAINING_RECORD( NextShare, SHARE, GlobalShareList );

            if( !DumpShare( ShareEntry, ShareType, ShareName, &NextShare ) )
                break;

        }
    }
}

DECLARE_API( lock )
{
    ULONG_PTR dwAddress;
    CHAR buf[ 100 ];
    int i;

    if( args && *args ) {
        dwAddress = GetExpression( args );
        DumpLock( dwAddress );
        return;
    }

    strcpy( buf, "srv!" );
    for( i=0; SrvLocks[i]; i++ ) {
        strcpy( &buf[4], SrvLocks[i] );
        dwAddress = GetExpression ( buf );
        if( dwAddress == 0 ) {
            ERRPRT( "Unable to get address of %s\n", SrvLocks[i] );
            continue;
        }
        dprintf( "\n%s\n", SrvLocks[i] );
        if( !DumpLock( dwAddress ) )
            break;
    }
}

DECLARE_API( endpoint )
{
    LIST_ENTRY *NextEndpoint;
    ORDERED_LIST_HEAD SrvEndpointList;
    ULONG_PTR dwAddress;
    int i;

    if( args && *args ) {
        dwAddress = GetExpression( args );
        DumpEndpoint( dwAddress, NULL );
        return;
    }

    dwAddress = GetExpression ( "srv!SrvEndpointList" );
    if( dwAddress == 0 ) {
        ERRPRT( "Unable to get address of srv!SrvEndpointList\n" );
        return;
    }
    if( !GetData( &SrvEndpointList, dwAddress, sizeof( SrvEndpointList ), "ORDERED_LIST_HEAD" ) ) {
        ERRPRT( "Unable to read data for srv!SrvEndpointList\n" );
        return;
    }
    if( SrvEndpointList.Initialized == 0 ) {
        ERRPRT( "srv!SrvEndpointList.Initialized == 0!\n" );
        return;
    }
    if( (ULONG_PTR)SrvEndpointList.ListHead.Flink == dwAddress ) {
        ERRPRT( "srv!SrvEndpointList list is empty\n" );
        return;
    }
    if( (ULONG_PTR)SrvEndpointList.ListHead.Flink == 0 ) {
        ERRPRT( "srv!SrvEndpointList.ListHead.Flink == 0: list is empty\n" );
        return;
    }

    NextEndpoint = SrvEndpointList.ListHead.Flink;

    do {
        ULONG_PTR EndpointEntry;

        if( CheckControlC() ) {
            dprintf( "\n" );
            break;
        }

        EndpointEntry = (ULONG_PTR)CONTAINING_RECORD( NextEndpoint, ENDPOINT, GlobalEndpointListEntry );

        if( !DumpEndpoint( EndpointEntry, &NextEndpoint ) )
            break;

    } while( (ULONG_PTR)NextEndpoint != dwAddress );
}

DECLARE_API( search )
{
    if( !args || !*args ) {
        ERRPRT( "SEARCH address required\n" );
    } else {
        DumpSearch( GetExpression( args ) );
    }
}


DECLARE_API( buffer )
{
    if( !args || !*args ) {
        ERRPRT( "BUFFER address required\n" );
    } else {
        DumpBuffer( GetExpression( args ) );
    }
}

DECLARE_API( smb )
{
    if( !args || !*args ) {
        ERRPRT( "BUFFER address required\n" );
    } else {
        DumpSmb( GetExpression( args ) );
    }
}


DECLARE_API( tcon )
{
    if( !args || !*args ) {
        ERRPRT( "Tcon address required\n" );
    } else {
        DumpTcon( GetExpression(args), 0, NULL );
    }
}

DECLARE_API ( connection )
{

    if( !args || !*args ) {
        ERRPRT( "Connection address required\n" );
    } else {
        DumpConnection( GetExpression(args), 0, NULL );
    }
}

DECLARE_API( lfcb )
{
    if( !args || !*args ) {
        ERRPRT( "LFCB address required\n" );
    } else {
        DumpLfcb( GetExpression(args) );
    }
}

DECLARE_API( mfcb )
{
    if( !args || !*args ) {
        ERRPRT( "MFCB address required\n" );
    } else {
        DumpMfcb( GetExpression(args) );
    }
}

DECLARE_API( rfcb )
{
    LIST_ENTRY *NextRfcb;
    ORDERED_LIST_HEAD SrvRfcbList;
    ULONG_PTR dwAddress;
    int i;

    if( args && *args ) {
        DumpRfcb( GetExpression(args), NULL );
        return;
    }

    dwAddress = GetExpression ( "srv!SrvRfcbList" );
    if( dwAddress == 0 ) {
        ERRPRT( "Unable to get address of srv!SrvSrvRfcbList\n" );
        return;
    }
    if( !GetData( &SrvRfcbList, dwAddress, sizeof( SrvRfcbList ), "ORDERED_LIST_HEAD" ) ) {
        ERRPRT( "Unable to read data for srv!SrvRfcbList\n" );
        return;
    }
    if( SrvRfcbList.Initialized == 0 ) {
        ERRPRT( "srv!SrvRfcbList.Initialized == 0!\n" );
        return;
    }
    if( (ULONG_PTR)SrvRfcbList.ListHead.Flink == dwAddress ) {
        ERRPRT( "srv!SrvRfcbList list is empty\n" );
        return;
    }
    if( (ULONG_PTR)SrvRfcbList.ListHead.Flink == 0 ) {
        ERRPRT( "srv!SrvRfcbList.ListHead.Flink == 0: list is empty\n" );
        return;
    }

    NextRfcb = SrvRfcbList.ListHead.Flink;

    do {
        ULONG_PTR RfcbEntry;

        RfcbEntry = (ULONG_PTR)CONTAINING_RECORD( NextRfcb, RFCB, GlobalRfcbListEntry );

        dprintf( "\n" );

        DumpRfcb( RfcbEntry, &NextRfcb );

        if( CheckControlC() ) {
            dprintf( "\n" );
            break;
        }

    } while( (ULONG_PTR)NextRfcb != dwAddress );
}

DECLARE_API( session )
{
    if( !args || !*args ) {
        ERRPRT( "Session address required\n" );
    } else {
        DumpSession( GetExpression(args), 0, NULL );
    }
}

DECLARE_API( globals )
{
    ULONG_PTR dwAddress;
    CHAR buf[ 200 ];
    int i;
    int c=0;
    GUID guid;

    strcpy( buf, "srv!" );

    dprintf( "BOOLEAN Values (%u bytes):\n", sizeof( BOOLEAN ) );
    for( i=0; GlobalBool[i]; i++, c++ ) {
        BOOLEAN b;

        strcpy( &buf[4], GlobalBool[i] );
        dwAddress = GetExpression ( buf );
        if( dwAddress == 0 ) {
            continue;
        }
        if( !GetData( &b, dwAddress, sizeof(b), GlobalBool[i] ) )
            return;

        dprintf( "%s%-35s %10s%s",
            c&1 ? "    " : "",
            GlobalBool[i],
            b ? " TRUE" : "FALSE",
            c&1 ? "\n" : "" );
    }

    if( CheckControlC() ) {
        dprintf( "\n" );
        return;
    }

    dprintf( "%s\nSHORT Values (%u bytes):\n", c&1 ? "\n" : "" ,sizeof( SHORT ) );
    c &= ~01;
    for( i=0; GlobalShort[i]; i++, c++ ) {
        SHORT s;

        strcpy( &buf[4], GlobalShort[i] );
        dwAddress = GetExpression ( buf );
        if( dwAddress == 0 ) {
            continue;
        }
        if( !GetData( &s, dwAddress, sizeof(s), GlobalShort[i] ) )
            return;

        dprintf( "%s%-35s %10d%s",
            c&1 ? "    " : "",
            GlobalShort[i],
            s,
            c&1 ? "\n" : "" );
    }

    if( CheckControlC() ) {
        dprintf( "\n" );
        return;
    }

    dprintf( "%s\nLONG Values (%u bytes):\n", c&1 ? "\n" : "", sizeof( LONG ) );
    c &= ~01;
    for( i=0; GlobalLong[i]; i++, c++ ) {
        LONG l;

        strcpy( &buf[4], GlobalLong[i] );
        dwAddress = GetExpression ( buf );
        if( dwAddress == 0 ) {
            continue;
        }
        if( !GetData( &l, dwAddress, sizeof(l), GlobalLong[i] ) )
            return;

        dprintf( "%s%-35s %10u%s",
            c&1 ? "    " : "",
            GlobalLong[i],
            l,
            c&1 ? "\n" : "" );
    }

    if( CheckControlC() ) {
        dprintf( "\n" );
        return;
    }

    for( i=0; GlobalLongHex[i]; i++, c++ ) {
        LONG l;

        strcpy( &buf[4], GlobalLongHex[i] );
        dwAddress = GetExpression ( buf );
        if( dwAddress == 0 ) {
            continue;
        }
        if( !GetData( &l, dwAddress, sizeof(l), GlobalLongHex[i] ) )
            return;

        dprintf( "%s%-35s %10X%s",
            c&1 ? "    " : "",
            GlobalLongHex[i],
            l,
            c&1 ? "\n" : "" );
    }

    if( CheckControlC() ) {
        dprintf( "\n" );
        return;
    }

    //
    // Dump out the server GUID
    //
    dwAddress = GetExpression( "srv!ServerGuid" );
    if( dwAddress != 0 &&
        GetData( &guid, dwAddress, sizeof(guid), "ServerGuid" ) ) {

        dprintf( "%s%s    ", c&1 ? "    " : "", "ServerGuid" );

        for( i=0; i < sizeof( guid ); i++ ) {
            dprintf( "%2.2X", ((CHAR *)&guid)[i] & 0xFF );
        }
    }

    for( i = 0; GlobalStrings[i]; i++ ) {
        UNICODE_STRING String;
        WCHAR wszbuf[35];

        dprintf( "\n%s%s:\n", c&1 ? "\n" : "", GlobalStrings[i] );
        c &= ~01;
        strcpy( &buf[4], GlobalStrings[i] );
        dwAddress = GetExpression ( buf );
        if( dwAddress == 0 ) {
            continue;
        }
        if( GetData( &String, dwAddress, sizeof( String ), GlobalStrings[i] ) ) {
            wszbuf[ sizeof(wszbuf)/sizeof(wszbuf[0]) - 1 ] = L'\0';
            if( !GetString( (ULONG_PTR)String.Buffer, wszbuf, sizeof(wszbuf)/sizeof(wszbuf[0])-1) )
                continue;

            dprintf( "    %-35ws%s", wszbuf, c&1 ? "\n" : "" );
            c++;
        }
    }

    if( CheckControlC() ) {
        dprintf( "\n" );
        return;
    }

    for( i=0; GlobalStringVector[i]; i++ ) {
        ULONG_PTR StringAddress;
        WCHAR wszbuf[ 35 ];

        dprintf( "\n%s%s:\n", c&1 ? "\n" : "", GlobalStringVector[i] );
        c &= ~01;

        strcpy( &buf[4], GlobalStringVector[i] );
        dwAddress = GetExpression ( buf );
        if( dwAddress == 0 ) {
            continue;
        }
        if( !GetData( &dwAddress, dwAddress, sizeof( dwAddress ), GlobalStringVector[i] ) ) {
            return;
        }

        if( dwAddress == 0 )
            continue;

        wszbuf[ sizeof(wszbuf)/sizeof(wszbuf[0]) - 1 ] = L'\0';

        while( 1 ) {
            if( !GetData( &StringAddress, dwAddress, sizeof(StringAddress), GlobalStringVector[i] ) )
                break;
            if( StringAddress == 0 )
                break;
            if( !GetString( StringAddress, wszbuf, sizeof(wszbuf) / sizeof(wszbuf[0]) - 1 ) )
                break;
            dprintf( "    %-35ws%s",
                wszbuf,
                c&1 ? "\n" : "" );
            dwAddress += sizeof( LPSTR );
            c++;
        }
    }
    dprintf( "\n" );
}

DECLARE_API( context )
{

    if( args == NULL || !*args ) {
        ERRPRT( "WORK_CONTEXT address required\n" );
    } else {
        DumpWorkContext( GetExpression( args ) );
    }
}

DECLARE_API( transaction )
{
    if( args == NULL || !*args ) {
        ERRPRT( "TRANSACTION address required\n" );
    } else {
        DumpTransaction( GetExpression( args ) );
    }
}

DECLARE_API( queue )
{
    ULONG_PTR dwAddress, dweAddress;
    ULONG nProcessors;
    ULONG i;
    BOOLEAN mp;

    if( args && *args ) {
        dprintf( "WorkQueue" );
        DumpWorkQueue( GetExpression( args ) );
        return;
    }

    dwAddress = GetExpression( "srv!SrvMultiProcessorDriver" );
    if( !GetData( &mp, dwAddress, sizeof( mp ), "srv!SrvMultiProcessorDriver" ) )
        return;

    if( mp == TRUE ) {
        dwAddress = GetExpression( "srv!SrvNumberOfProcessors" );
        if( !GetData( &nProcessors, dwAddress, sizeof(nProcessors), "srv!SrvNumberOfProcessors" ) )
            return;
        dwAddress = GetExpression( "srv!SrvWorkQueues" );
        if( !GetData( &dwAddress, dwAddress, sizeof(dwAddress), "srv!SrvWorkQueues" ))
            return;
        dweAddress = GetExpression( "srv!eSrvWorkQueues" );
        if( !GetData( &dweAddress, dweAddress, sizeof(dweAddress), "srv!eSrvWorkQueues" ))
            return;

        if( dwAddress + nProcessors*sizeof(WORK_QUEUE) != dweAddress ) {
            ERRPRT( "eSrvWorkQueues is %X, should be %X\n",
                dweAddress, dwAddress + nProcessors*sizeof(WORK_QUEUE) );
        }
    } else {
        dwAddress = GetExpression( "srv!SrvWorkQueues" );
        nProcessors = 1;
    }

    for( i=0; i < nProcessors; i++, dwAddress += sizeof( WORK_QUEUE ) ) {
        dprintf( "%sProcessor %d ", i?"\n":"", i );
        if( DumpWorkQueue( dwAddress ) == FALSE )
            break;
    }

    dwAddress = GetExpression( "srv!SrvBlockingWorkQueue" );
    dprintf( "\nBlockingWorkQueue " );
    DumpWorkQueue( dwAddress );
}

char *mystrtok ( char *string, char * control )
{
    static unsigned char *str;
    char *p, *s;

    if( string )
        str = string;

    if( str == NULL || *str == '\0' )
        return NULL;

    //
    // Skip leading delimiters...
    //
    for( ; *str; str++ ) {
        for( s=control; *s; s++ ) {
            if( *str == *s )
                break;
        }
        if( *s == '\0' )
            break;
    }

    //
    // Was it was all delimiters?
    //
    if( *str == '\0' ) {
        str = NULL;
        return NULL;
    }

    //
    // We've got a string, terminate it at first delimeter
    //
    for( p = str+1; *p; p++ ) {
        for( s = control; *s; s++ ) {
            if( *p == *s ) {
                s = str;
                *p = '\0';
                str = p+1;
                return s;
            }
        }
    }

    //
    // We've got a string that ends with the NULL
    //
    s = str;
    str = NULL;
    return s;
}

void
DoLongLongBits( PCSTR symbol, PCSTR args, struct BitFields b[] )
{
    ULONGLONG value;
    ULONG_PTR dwAddress;
    char *p;
    ULONG bytesWritten;
    int i;
    int bsize;

    dwAddress = GetExpression( symbol );
    if( !GetData( &value, dwAddress, sizeof(value), symbol ) )
            return;

    if( !args || !*args ) {
        for( i=0; b[i].name; i++ ) {

            if( i && i%3 == 0 )
                dprintf( "\n" );

            if( strlen( b[i].name ) > 15 ) {
               dprintf( "    %2u %-.7s...%s ", i, b[i].name,
                        b[i].name+strlen(b[i].name)-5 );
            } else {
               dprintf( "    %2u %-15s ", i, b[i].name );
            }

            dprintf( " %c", value & b[i].value ? 'T' : 'F' );
        }
        dprintf( "\n" );
        return;
    }

    for( bsize=0; b[ bsize ].name; bsize++ )
        ;

    if( !_strcmpi( args, "on" )  || !_strcmpi( args, "true" ) || !_strcmpi( args, "t" ) ) {
        value = (ULONGLONG)-1;

    } else if( !_strcmpi( args, "off" ) || !_strcmpi( args, "false" ) || !_strcmpi( args, "f" ) ) {
        value = 0;

    } else {
        char argbuf[ MAX_PATH ];

        strcpy( argbuf, args );

        for( p = mystrtok( argbuf, " \t,;" ); p && *p; p = mystrtok( NULL, " \t,;" ) ) {
            i = atoi( p );
            if( i < 0 || i >= bsize ) {
                dprintf( "%s: illegal index number\n", p );
                continue;
            }
            if( value & b[i].value ) {
                value &= ~b[i].value;
            } else {
                value |= b[i].value;
            }
        }
    }

    WriteMemory( dwAddress, &value, sizeof(value), &bytesWritten );

    if( bytesWritten != sizeof( value ) )
        dprintf( "Write error\n" );

}

DECLARE_API( srvdebug )
{
#if SRVDBG == 1
    DoLongLongBits( "srv!SrvDebug", args, SrvDebugFlags );
#else
    dprintf( "Not Available!\n" );
#endif
}

DECLARE_API( smbdebug )
{
#if SRVDBG == 1
    DoLongLongBits( "srv!SmbDebug", args, SmbDebugFlags );
#else
    dprintf( "Not Available!\n" );
#endif
}

DECLARE_API( statistics )
{
    ULONG_PTR dwAddress;
    SRV_STATISTICS s;

    dwAddress = GetExpression( "srv!SrvStatistics" );
    if( !GetData( &s, dwAddress, sizeof(s), "SrvStatistics" ) )
        return;

    PrintMemberList( &s, ML_SRV_STATISTICS );
}

DECLARE_API( scavenger )
{
    ULONG_PTR dwAddress;
    CHAR buf[ 100 ];
    int i;
    int c=0;

    strcpy( buf, "srv!" );

    dprintf( "BOOLEAN Values (%u bytes):\n", sizeof( BOOLEAN ) );
    for( i=0; ScavengerBool[i]; i++, c++ ) {
        BOOLEAN b;

        strcpy( &buf[4], ScavengerBool[i] );
        dwAddress = GetExpression ( buf );
        if( dwAddress == 0 ) {
            ERRPRT( "Unable to get address of %s\n", ScavengerBool[i] );
            continue;
        }
        if( !GetData( &b, dwAddress, sizeof(b), ScavengerBool[i] ) )
            return;

        dprintf( "%s%-30s %10s%s",
            c&1 ? "    " : "",
            ScavengerBool[i],
            b ? " TRUE" : "FALSE",
            c&1 ? "\n" : "" );
    }

    dprintf( "%s\nLONG Values (%u bytes):\n", c&1 ? "\n" : "", sizeof( LONG ) );
    c &= ~01;
    for( i=0; ScavengerLong[i]; i++, c++ ) {
        LONG l;

        strcpy( &buf[4], ScavengerLong[i] );
        dwAddress = GetExpression ( buf );
        if( dwAddress == 0 ) {
            ERRPRT( "Unable to get address of %s\n", ScavengerLong[i] );
            continue;
        }
        if( !GetData( &l, dwAddress, sizeof(l), ScavengerLong[i] ) )
            return;

        dprintf( "%s%-30s %10u%s",
            c&1 ? "    " : "",
            ScavengerLong[i],
            l,
            c&1 ? "\n" : "" );
    }
}

DECLARE_API( srv )
{
    ULONG_PTR dwAddress;
    BOOLEAN b;
    ULONG ul;
    ULONG bytesWritten;

    dwAddress = GetExpression( "srv!SrvProductTypeServer" );
    b = TRUE;
    WriteMemory( dwAddress, &b, sizeof(b), &bytesWritten );
    if( bytesWritten != sizeof(b) ) {
        ERRPRT( "Unable to update SrvProductTypeServer\n" );
        return;
    }

    dwAddress = GetExpression( "srv!SrvCachedOpenLimit" );
    ul = 5;
    WriteMemory( dwAddress, &ul, sizeof(ul), &bytesWritten );
    if( bytesWritten != sizeof(ul) ) {
        ERRPRT( "Unable to update SrvCachedOpenLimit\n" );
    }

}

DECLARE_API( wksta )
{
    ULONG_PTR dwAddress;
    BOOLEAN b;
    ULONG ul;
    ULONG bytesWritten;

    dwAddress = GetExpression( "srv!SrvProductTypeServer" );
    b = FALSE;
    WriteMemory( dwAddress, &b, sizeof(b), &bytesWritten );
    if( bytesWritten != sizeof(b) ) {
        ERRPRT( "Unable to update SrvProductTypeServer\n" );
        return;
    }

    dwAddress = GetExpression( "srv!SrvCachedOpenLimit" );
    ul = 0;
    WriteMemory( dwAddress, &ul, sizeof(ul), &bytesWritten );
    if( bytesWritten != sizeof(ul) ) {
        ERRPRT( "Unable to update SrvCachedOpenLimit\n" );
    }

}

DECLARE_API( client )
{
    ULONG_PTR epListAddress;
    LIST_ENTRY *NextEndpoint;
    ORDERED_LIST_HEAD SrvEndpointList;
    WORK_QUEUE WorkQueue;
    ULONG_PTR WorkQueueAddress = 0;
    LONG SrvConnectionNoSessionsTimeout = 0;
    ULONG_PTR dwAddress;

    epListAddress = GetExpression ( "srv!SrvEndpointList" );
    if( epListAddress == 0 ) {
        ERRPRT( "Unable to get address of srv!SrvEndpointList\n" );
        return;
    }
    if( !GetData( &SrvEndpointList,epListAddress,sizeof( SrvEndpointList ),"ORDERED_LIST_HEAD" )){
        ERRPRT( "Unable to read data for srv!SrvEndpointList\n" );
        return;
    }
    if( SrvEndpointList.Initialized == 0 ) {
        ERRPRT( "srv!SrvEndpointList.Initialized == 0!\n" );
        return;
    }
    if( (ULONG_PTR)SrvEndpointList.ListHead.Flink == epListAddress ) {
        ERRPRT( "srv!SrvEndpointList list is empty\n" );
        return;
    }
    if( (ULONG_PTR)SrvEndpointList.ListHead.Flink == 0 ) {
        ERRPRT( "srv!SrvEndpointList.ListHead.Flink == 0: list is empty\n" );
        return;
    }

    if( dwAddress = GetExpression( "srv!SrvConnectionNoSessionsTimeout" ) ) {
        GetData( &SrvConnectionNoSessionsTimeout, dwAddress, sizeof(ULONG_PTR), "SrvConnectionNoSessionsTimeout" );
        dprintf( "Session Idle Timeout: %d ticks\n", SrvConnectionNoSessionsTimeout );
    }

    NextEndpoint = SrvEndpointList.ListHead.Flink;

    //
    // Run the endpoint list, and run the connection list for each endpoint
    //
    do {
        ENDPOINT endpoint;
        CONNECTION connection;
        PTABLE_ENTRY table;
        USHORT i;
        LONG idleTime;

        dwAddress = (ULONG_PTR)CONTAINING_RECORD( NextEndpoint, ENDPOINT, GlobalEndpointListEntry );

        if( CheckControlC() ) {
            dprintf( "\n" );
            break;
        }

        if( !GetData( &endpoint, dwAddress, sizeof( endpoint ), "ENDPOINT" ) ||
            !CheckBlockHeader( &endpoint.BlockHeader, BlockTypeEndpoint, TRUE ) ) {
            break;
        }

        //
        // Now, run the connection table for this endpoint and print out the client names
        //  and connection structure address
        //
        if( endpoint.ConnectionTable.Table == NULL ) {
            continue;
        }

        table = (PTABLE_ENTRY)LocalAlloc( LPTR,
                    endpoint.ConnectionTable.TableSize*sizeof(TABLE_ENTRY) );

        if( table == NULL ) {
            continue;
        }

        if( !GetData( table, (ULONG_PTR)endpoint.ConnectionTable.Table,
                            endpoint.ConnectionTable.TableSize*sizeof(TABLE_ENTRY), "TABLE" ) ) {

            LocalFree( (HLOCAL)table );
            continue;
        }

        for( i = 0; i < endpoint.ConnectionTable.TableSize; i++ ) {
            if( table[i].Owner &&
                GetData( &connection,(ULONG_PTR)table[i].Owner, sizeof( connection ),"CONNECTION") &&
                connection.BlockHeader.ReferenceCount != 0 &&
                connection.OemClientMachineName[0] &&
                connection.OemClientMachineName[0] != ' ' ) {

                    if( args != NULL && *args != '\0' ) {

                        int j;

                        for( j = 0; args[j] ; j++ ) {
                            if( connection.OemClientMachineName[j] != args[j] )
                                break;
                        }

                        if( args[j] ) {
                            continue;
                        }
                    }

                    if( WorkQueueAddress != (ULONG_PTR)connection.CurrentWorkQueue ) {
                        if( GetData( &WorkQueue, (ULONG_PTR)connection.CurrentWorkQueue, sizeof( WorkQueue ), "WORK_QUEUE" ) ) {
                            WorkQueueAddress = (ULONG_PTR)connection.CurrentWorkQueue;
                        }
                    }

                    idleTime = WorkQueue.stats.SystemTime - connection.LastRequestTime;

                    dprintf( "%8X    %-16s, Idle %d ticks\n", table[i].Owner,connection.OemClientMachineName,idleTime);
                    if( idleTime > SrvConnectionNoSessionsTimeout ) {
                        dprintf( "*** Above client is due for idle disconnect, if no open files\n" );
                    }

                    if( CheckControlC() ) {
                        dprintf( "\n" );
                        return;
                    }
            }
        }

        LocalFree( (HLOCAL)table );

        NextEndpoint = endpoint.GlobalEndpointListEntry.ListEntry.Flink;

    } while( (ULONG_PTR)NextEndpoint != epListAddress );
}

DECLARE_API( errcodes )
{
    ULONG_PTR dwAddress;
    NTSTATUS status;
    int count = 0;

    dwAddress = GetExpression( "srv!SrvErrorLogIgnore" );

    while( 1 ) {
        if( !GetData( &status, dwAddress, sizeof( status ), "NTSTATUS" ) )
            return;
        if( status == 0 )
            break;
        dprintf( "   %X", status );
        dwAddress += sizeof( status );
        if( (++count & 7) == 0 )
            dprintf( "\n" );
    }
    dprintf( "\n" );
}

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    ChkTarget = SavedMajorVersion == 0x0c ? TRUE : FALSE;
}

DECLARE_API( version )
{
#if    DBG
    PCSTR kind = "Checked";
#else
    PCSTR kind = "Free";
#endif

    dprintf(
        "%s SMB Extension dll for Build %d debugging %s kernel for Build %d\n",
        kind,
        VER_PRODUCTBUILD,
        SavedMajorVersion == 0x0c ? "Checked" : "Free",
        SavedMinorVersion
    );
}

VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\udfs\cleanup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    Cleanup.c

Abstract:

    This module implements the File Cleanup routine for Udfs called by the
    dispatch driver.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]     31-Oct-1996

Revision History:

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_CLEANUP)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_CLEANUP)


NTSTATUS
UdfCommonCleanup (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for cleanup of a file/directory called by both
    the fsd and fsp threads.

    Cleanup is invoked whenever the last handle to a file object is closed.
    This is different than the Close operation which is invoked when the last
    reference to a file object is deleted.

    The function of cleanup is to essentially "cleanup" the file/directory
    after a user is done with it.  The Fcb/Dcb remains around (because MM
    still has the file object referenced) but is now available for another
    user to open (i.e., as far as the user is concerned the is now closed).

    See close for a more complete description of what close does.

    We do no synchronization in this routine until we get to the point
    where we modify the counts, share access and volume lock field.

    We need to update the Fcb and Vcb to show that a user handle has been closed.
    The following structures and fields are affected.

    Vcb:

        VolumeLockFileObject - Did the user lock the volume with this file object.
        VcbState - Check if we are unlocking the volume here.
        VcbCleanup - Count of outstanding handles on the volume.
        DirNotifyQueue - If this file object has pending DirNotify Irps.

    Fcb:

        ShareAccess - If this is a user handle.
        FcbCleanup - Count of outstanding handles on this Fcb.
        Oplock - Any outstanding oplocks on this file object.
        FileLock - Any outstanding filelocks on this file object.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation.

--*/

{
    PFILE_OBJECT FileObject;
    TYPE_OF_OPEN TypeOfOpen;

    BOOLEAN SendUnlockNotification = FALSE;
    BOOLEAN AttemptTeardown;
    BOOLEAN VcbAcquired = FALSE;

    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    KIRQL SavedIrql;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    //
    //  If we were called with our file system device object instead of a
    //  volume device object, just complete this request with STATUS_SUCCESS.
    //

    if (IrpContext->Vcb == NULL) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
        return STATUS_SUCCESS;
    }

    //
    //  Get the file object out of the Irp and decode the type of open.
    //

    FileObject = IoGetCurrentIrpStackLocation( Irp )->FileObject;

    TypeOfOpen = UdfDecodeFileObject( FileObject,
                                      &Fcb,
                                      &Ccb );

    //
    //  No work here for either an UnopenedFile object or a StreamFileObject.
    //

    if (TypeOfOpen <= StreamFileOpen) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );

        return STATUS_SUCCESS;
    }

    //
    //  Keep a local pointer to the Vcb.
    //

    Vcb = Fcb->Vcb;

    //
    //  If we're closing a volume handle,   and writes were made,
    //  hold the Vcb exclusive
    //

    if ((TypeOfOpen == UserVolumeOpen) && 
        FlagOn(FileObject->Flags, FO_FILE_MODIFIED))  {

        UdfAcquireVcbExclusive( IrpContext, Vcb, FALSE);
        VcbAcquired = TRUE;
    }
    
    //
    //  Synchronise with reads while we set the cleanup complete 
    //  flag on this fileobject.  Once this flag is set,  any further
    //  reads will be rejected (CdVerifyFcbOperation)
    //

    UdfAcquireFileExclusive( IrpContext, Fcb);

    //
    //  Set the flag in the FileObject to indicate that cleanup is complete.
    //

    SetFlag( FileObject->Flags, FO_CLEANUP_COMPLETE );

    UdfReleaseFile( IrpContext, Fcb);

    //
    //  Acquire the current file.
    //

    UdfAcquireFcbExclusive( IrpContext, Fcb, FALSE );
    
    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Case on the type of open that we are trying to cleanup.
        //

        switch (TypeOfOpen) {

        case UserDirectoryOpen:

            DebugTrace(( +1, Dbg,
                         "UdfCommonCleanup, Fcb %08x FO %08x DIR\n",
                         Fcb,
                         FileObject ));
            
            //
            //  Check if we need to complete any dir notify Irps on this file object.
            //

            FsRtlNotifyCleanup( Vcb->NotifySync,
                                &Vcb->DirNotifyList,
                                Ccb );

            break;

        case UserFileOpen:

            DebugTrace(( +1, Dbg,
                         "UdfCommonCleanup, Fcb %08x FO %08x FILE\n",
                         Fcb,
                         FileObject ));
            
            //
            //  Coordinate the cleanup operation with the oplock state.
            //  Oplock cleanup operations can always cleanup immediately so no
            //  need to check for STATUS_PENDING.
            //

            FsRtlCheckOplock( &Fcb->Oplock,
                              Irp,
                              IrpContext,
                              NULL,
                              NULL );

            //
            //  Unlock all outstanding file locks.
            //

            if (Fcb->FileLock != NULL) {

                FsRtlFastUnlockAll( Fcb->FileLock,
                                    FileObject,
                                    IoGetRequestorProcess( Irp ),
                                    NULL );
            }

            //
            //  Cleanup the cache map.
            //

            CcUninitializeCacheMap( FileObject, NULL, NULL );

            //
            //  Check the fast io state.
            //

            UdfLockFcb( IrpContext, Fcb );
            Fcb->IsFastIoPossible = UdfIsFastIoPossible( Fcb );
            UdfUnlockFcb( IrpContext, Fcb );

            break;

        case UserVolumeOpen :

            DebugTrace(( +1, Dbg,
                         "UdfCommonCleanup, Fcb %08x FO %08x VOL\n",
                         Fcb,
                         FileObject ));
                         
            //
            //  If this handle had write access, and actually wrote something,
            //  flush the device buffers, and then set the verify bit now
            //  just to be safe (in case there is no dismount).
            //

            if (FileObject->WriteAccess &&
                FlagOn(FileObject->Flags, FO_FILE_MODIFIED)) {

                (VOID)UdfHijackIrpAndFlushDevice( IrpContext,
                                                  Irp,
                                                  Vcb->TargetDeviceObject );

                UdfMarkRealDevForVerify( Vcb->Vpb->RealDevice);
            }

            break;

        default :

            UdfBugCheck( TypeOfOpen, 0, 0 );
        }

        //
        //  Now lock the Vcb in order to modify the fields in the in-memory
        //  structures.
        //

        UdfLockVcb( IrpContext, Vcb );

        //
        //  Decrement the cleanup counts in the Vcb and Fcb.
        //

        UdfDecrementCleanupCounts( IrpContext, Fcb );

        //
        //  If the cleanup count hit zero and the volume is not mounted, we
        //  will want to try to spark teardown.
        //

        AttemptTeardown = (Vcb->VcbCleanup == 0 && Vcb->VcbCondition == VcbNotMounted);
        
        //
        //  If this file object has locked the volume then perform the unlock operation.
        //  We do this regardless of explicit or implicit (no share DASD open) lock.
        //

        if (FileObject == Vcb->VolumeLockFileObject) {

            ASSERT( FlagOn( Vcb->VcbState, VCB_STATE_LOCKED));

            IoAcquireVpbSpinLock( &SavedIrql );

            ClearFlag( Vcb->VcbState, VCB_STATE_LOCKED );
            ClearFlag( Vcb->Vpb->Flags, VPB_LOCKED );
            Vcb->VolumeLockFileObject = NULL;
            SendUnlockNotification = TRUE;

            IoReleaseVpbSpinLock( SavedIrql );
        }

        UdfUnlockVcb( IrpContext, Vcb );

        //
        //  We must clean up the share access at this time, since we may not
        //  get a Close call for awhile if the file was mapped through this
        //  File Object.
        //

        IoRemoveShareAccess( FileObject, &Fcb->ShareAccess );

    } 
    finally {

        UdfReleaseFcb( IrpContext, Fcb );

        if (SendUnlockNotification) {

            FsRtlNotifyVolumeEvent( FileObject, FSRTL_VOLUME_UNLOCK );
        }

        if (VcbAcquired)  {

            UdfReleaseVcb( IrpContext, Vcb);
        }
    }

    DebugTrace(( -1, Dbg,
                 "UdfCommonCleanup, Fcb %08x FO %08x -> SUCCESS\n",
                 Fcb,
                 FileObject ));
    
    //
    //  If appropriate, try to spark teardown by purging the volume.  Should
    //  this very fileobject we were cleaning up be the last reason for the
    //  volume to remain, teardown will commence on completion of this Irp.
    //
    
    if (AttemptTeardown) {

        //
        //  Preacquire UdfData here,  since the purges will generate closes which
        //  may acquire UdfData if there is a possibility of tearing the volume
        //  down.
        //
        
        UdfAcquireUdfData( IrpContext);
        VcbAcquired = FALSE;
        
        try {
            
            UdfAcquireVcbExclusive( IrpContext, Vcb, FALSE );
            VcbAcquired = TRUE;
            
            UdfPurgeVolume( IrpContext, Vcb, FALSE );

        } finally {

            if (VcbAcquired) { UdfReleaseVcb( IrpContext, Vcb ); }
            
            UdfReleaseUdfData( IrpContext);
        }
    }

    //
    //  If this is a normal termination then complete the request
    //

    UdfCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\udfs\create.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    Create.c

Abstract:

    This module implements the File Create routine for Udfs called by the
    Fsd/Fsp dispatch routines.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]     9-October-1996

Revision History:

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_CREATE)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_CREATE)

//
//  Local support routines
//

NTSTATUS
UdfNormalizeFileNames (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN OpenByFileId,
    IN BOOLEAN IgnoreCase,
    IN TYPE_OF_OPEN RelatedTypeOfOpen,
    IN PCCB RelatedCcb OPTIONAL,
    IN PUNICODE_STRING RelatedFileName OPTIONAL,
    IN OUT PUNICODE_STRING FileName,
    IN OUT PUNICODE_STRING RemainingName
    );

NTSTATUS
UdfOpenExistingFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN OUT PFCB *CurrentFcb,
    IN PLCB OpenLcb,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN BOOLEAN IgnoreCase,
    IN PCCB RelatedCcb OPTIONAL
    );

NTSTATUS
UdfOpenObjectByFileId (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb,
    IN OUT PFCB *CurrentFcb
    );

NTSTATUS
UdfOpenObjectFromDirContext (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb,
    IN OUT PFCB *CurrentFcb,
    IN BOOLEAN ShortNameMatch,                             
    IN BOOLEAN IgnoreCase,
    IN PDIR_ENUM_CONTEXT DirContext,
    IN BOOLEAN PerformUserOpen,
    IN PCCB RelatedCcb OPTIONAL
    );

NTSTATUS
UdfCompleteFcbOpen (
    IN PIRP_CONTEXT IrpContext,
    PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb,
    IN OUT PFCB *CurrentFcb,
    IN PLCB OpenLcb,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN ULONG UserCcbFlags,
    IN ACCESS_MASK DesiredAccess
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfCommonCreate)
#pragma alloc_text(PAGE, UdfCompleteFcbOpen)
#pragma alloc_text(PAGE, UdfNormalizeFileNames)
#pragma alloc_text(PAGE, UdfOpenObjectByFileId)
#pragma alloc_text(PAGE, UdfOpenExistingFcb)
#pragma alloc_text(PAGE, UdfOpenObjectFromDirContext)
#endif


NTSTATUS
UdfCommonCreate (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for opening a file called by both the
    Fsp and Fsd threads.

    The file can be opened either by name or by file Id either with or without
    a relative name.  The file name field in the file object passed to this routine
    contains either a unicode string or a 64 bit value which is the file Id.
    If there is a related file object with a name then we will already have converted
    that name to Oem. 

    We will store the full name for the file in the file object on a successful
    open.  We will allocate a larger buffer if necessary and combine the
    related and file object names.  The only exception is the relative open
    when the related file object is for an OpenByFileId file.  If we need to
    allocate a buffer for a case insensitive name then we allocate it at
    the tail of the buffer we will store into the file object.  The upcased
    portion will begin immediately after the name defined by the FileName
    in the file object.

    Once we have the full name in the file object we don't want to split the
    name in the event of a retry.  We use a flag in the IrpContext to indicate
    that the name has been split.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - This is the status from this open operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PFILE_OBJECT FileObject;

    DIR_ENUM_CONTEXT DirContext;
    BOOLEAN CleanupDirContext = FALSE;

    BOOLEAN FoundEntry;

    PVCB Vcb;

    BOOLEAN OpenByFileId;
    BOOLEAN IgnoreCase;
    ULONG CreateDisposition;

    BOOLEAN ShortNameMatch;

    BOOLEAN VolumeOpen = FALSE;

    //
    //  We will be acquiring and releasing file Fcb's as we move down the
    //  directory tree during opens.  At any time we need to know the deepest
    //  point we have traversed down in the tree in case we need to cleanup
    //  any structures created here.
    //
    //  CurrentFcb - represents this point.  If non-null it means we have
    //      acquired it and need to release it in finally clause.
    //
    //  NextFcb - represents the NextFcb to walk to but haven't acquired yet.
    //
    //  CurrentLcb - represents the name of the CurrentFcb.
    //

    TYPE_OF_OPEN RelatedTypeOfOpen = UnopenedFileObject;
    PFILE_OBJECT RelatedFileObject;
    PCCB RelatedCcb = NULL;

    PFCB NextFcb;
    PFCB CurrentFcb = NULL;

    PLCB CurrentLcb = NULL;

    //
    //  During the open we need to combine the related file object name
    //  with the remaining name.  We also may need to upcase the file name
    //  in order to do a case-insensitive name comparison.  We also need
    //  to restore the name in the file object in the event that we retry
    //  the request.  We use the following string variables to manage the
    //  name.  We will can put these strings into either Unicode or Ansi
    //  form.
    //
    //  FileName - Pointer to name as currently stored in the file
    //      object.  We store the full name into the file object early in
    //      the open operation.
    //
    //  RelatedFileName - Pointer to the name in the related file object.
    //
    //  RemainingName - String containing remaining name to parse.
    //

    PUNICODE_STRING FileName;
    PUNICODE_STRING RelatedFileName;

    UNICODE_STRING RemainingName;
    UNICODE_STRING FinalName;

    PAGED_CODE();

    //
    //  If we were called with our file system device object instead of a
    //  volume device object, just complete this request with STATUS_SUCCESS.
    //

    if (IrpContext->Vcb == NULL) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
        return STATUS_SUCCESS;
    }

    //
    //  Get create parameters from the Irp.
    //

    OpenByFileId = BooleanFlagOn( IrpSp->Parameters.Create.Options, FILE_OPEN_BY_FILE_ID );
    IgnoreCase = !BooleanFlagOn( IrpSp->Flags, SL_CASE_SENSITIVE );
    CreateDisposition = (IrpSp->Parameters.Create.Options >> 24) & 0x000000ff;

    //
    //  Do some preliminary checks to make sure the operation is supported.
    //  We fail in the following cases immediately.
    //
    //      - Open a paging file.
    //      - Open a target directory.
    //      - Open a file with Eas.
    //      - Create a file.
    //

    if (FlagOn( IrpSp->Flags, SL_OPEN_PAGING_FILE | SL_OPEN_TARGET_DIRECTORY) ||
        (IrpSp->Parameters.Create.EaLength != 0) ||
        (CreateDisposition == FILE_CREATE)) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );
        return STATUS_ACCESS_DENIED;
    }

    //
    //  Copy the Vcb to a local.  Assume the starting directory is the root.
    //

    Vcb = IrpContext->Vcb;
    NextFcb = Vcb->RootIndexFcb;

    //
    //  Reference our input parameters to make things easier
    //

    FileObject = IrpSp->FileObject;
    RelatedFileObject = NULL;

    FileName = &FileObject->FileName;

    //
    //  Set up the file object's Vpb pointer in case anything happens.
    //  This will allow us to get a reasonable pop-up.
    //

    if ((FileObject->RelatedFileObject != NULL) && !OpenByFileId) {

        RelatedFileObject = FileObject->RelatedFileObject;
        FileObject->Vpb = RelatedFileObject->Vpb;

        RelatedTypeOfOpen = UdfDecodeFileObject( RelatedFileObject, &NextFcb, &RelatedCcb );

        //
        //  Fail the request if this is not a user file object.
        //

        if (RelatedTypeOfOpen < UserVolumeOpen) {

            UdfCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
            return STATUS_INVALID_PARAMETER;
        }

        //
        //  Remember the name in the related file object.
        //

        RelatedFileName = &RelatedFileObject->FileName;
    }

    //
    //  If we haven't initialized the names then make sure the strings are valid.
    //  If this an OpenByFileId then verify the file id buffer.
    //
    //  After this routine returns we know that the full name is in the
    //  FileName buffer and the buffer will hold the upcased portion
    //  of the name yet to parse immediately after the full name in the
    //  buffer.  Any trailing backslash has been removed and the flag
    //  in the IrpContext will indicate whether we removed the
    //  backslash.
    //

    Status = UdfNormalizeFileNames( IrpContext,
                                    Vcb,
                                    OpenByFileId,
                                    IgnoreCase,
                                    RelatedTypeOfOpen,
                                    RelatedCcb,
                                    RelatedFileName,
                                    FileName,
                                    &RemainingName );

    //
    //  Return the error code if not successful.
    //

    if (!NT_SUCCESS( Status )) {

        UdfCompleteRequest( IrpContext, Irp, Status );
        return Status;
    }

    //
    //  We want to acquire the Vcb.  Exclusively for a volume open, shared otherwise.
    //  The file name is empty for a volume open.
    //

    if ((FileName->Length == 0) &&
        (RelatedTypeOfOpen <= UserVolumeOpen) &&
        !OpenByFileId) {

        VolumeOpen = TRUE;
        UdfAcquireVcbExclusive( IrpContext, Vcb, FALSE );

    } else {

        UdfAcquireVcbShared( IrpContext, Vcb, FALSE );
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Verify that the Vcb is not in an unusable condition.  This routine
        //  will raise if not usable.
        //

        UdfVerifyVcb( IrpContext, Vcb );

        //
        //  If the Vcb is locked then we cannot open another file
        //

        if (FlagOn( Vcb->VcbState, VCB_STATE_LOCKED )) {

            try_leave( Status = STATUS_ACCESS_DENIED );
        }

        //
        //  If we are opening this file by FileId then process this immediately
        //  and exit.
        //

        if (OpenByFileId) {

            //
            //  The only create disposition we allow is OPEN.
            //

            if ((CreateDisposition != FILE_OPEN) &&
                (CreateDisposition != FILE_OPEN_IF)) {

                try_leave( Status = STATUS_ACCESS_DENIED );
            }

            try_leave( Status = UdfOpenObjectByFileId( IrpContext,
                                                       IrpSp,
                                                       Vcb,
                                                       &CurrentFcb ));
        }

        //
        //  If we are opening this volume Dasd then process this immediately
        //  and exit.
        //

        if (VolumeOpen) {

            //
            //  The only create disposition we allow is OPEN.
            //

            if ((CreateDisposition != FILE_OPEN) &&
                (CreateDisposition != FILE_OPEN_IF)) {

                try_leave( Status = STATUS_ACCESS_DENIED );
            }

            //
            //  If they wanted to open a directory, surprise.
            //

            if (FlagOn( IrpSp->Parameters.Create.Options, FILE_DIRECTORY_FILE )) {

                try_leave( Status = STATUS_NOT_A_DIRECTORY );
            }

            //
            //  Acquire the Fcb first.
            //

            CurrentFcb = Vcb->VolumeDasdFcb;
            UdfAcquireFcbExclusive( IrpContext, CurrentFcb, FALSE );

            try_leave( Status = UdfOpenExistingFcb( IrpContext,
                                                    IrpSp,
                                                    &CurrentFcb,
                                                    NULL,
                                                    UserVolumeOpen,
                                                    FALSE,
                                                    NULL ));
        }

        //
        //  Acquire the Fcb at the beginning of our search to keep it from being
        //  deleted beneath us.
        //

        UdfAcquireFcbExclusive( IrpContext, NextFcb, FALSE );
        CurrentFcb = NextFcb;

        //
        //  Do a prefix search if there is more of the name to parse.
        //

        if (RemainingName.Length != 0) {

            //
            //  Do the prefix search to find the longest matching name.
            //

            CurrentLcb = UdfFindPrefix( IrpContext,
                                        &CurrentFcb,
                                        &RemainingName,
                                        IgnoreCase );
        }

        //
        //  At this point CurrentFcb points at the lowest Fcb in the tree for this
        //  file name, CurrentLcb is that name, and RemainingName is the rest of the
        //  name we have to do any directory traversals for.
        //

        //
        //  If the remaining name length is zero then we have found our
        //  target.
        //

        if (RemainingName.Length == 0) {

            //
            //  If this is a file so verify the user didn't want to open
            //  a directory.
            //

            if (SafeNodeType( CurrentFcb ) == UDFS_NTC_FCB_DATA) {

                if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_TRAIL_BACKSLASH ) ||
                    FlagOn( IrpSp->Parameters.Create.Options, FILE_DIRECTORY_FILE )) {

                    try_leave( Status = STATUS_NOT_A_DIRECTORY );
                }

                //
                //  The only create disposition we allow is OPEN.
                //

                if ((CreateDisposition != FILE_OPEN) &&
                    (CreateDisposition != FILE_OPEN_IF)) {

                    try_leave( Status = STATUS_ACCESS_DENIED );
                }

                try_leave( Status = UdfOpenExistingFcb( IrpContext,
                                                         IrpSp,
                                                         &CurrentFcb,
                                                         CurrentLcb,
                                                         UserFileOpen,
                                                         IgnoreCase,
                                                         RelatedCcb ));

            //
            //  This is a directory.  Verify the user didn't want to open
            //  as a file.
            //

            } else if (FlagOn( IrpSp->Parameters.Create.Options, FILE_NON_DIRECTORY_FILE )) {

                try_leave( Status = STATUS_FILE_IS_A_DIRECTORY );

            //
            //  Open the file as a directory.
            //

            } else {

                //
                //  The only create disposition we allow is OPEN.
                //

                if ((CreateDisposition != FILE_OPEN) &&
                    (CreateDisposition != FILE_OPEN_IF)) {

                    try_leave( Status = STATUS_ACCESS_DENIED );
                }

                try_leave( Status = UdfOpenExistingFcb( IrpContext,
                                                         IrpSp,
                                                         &CurrentFcb,
                                                         CurrentLcb,
                                                         UserDirectoryOpen,
                                                         IgnoreCase,
                                                         RelatedCcb ));
            }
        }

        //
        //  We have more work to do.  We have a starting Fcb which we own shared.
        //  We also have the remaining name to parse.  Walk through the name
        //  component by component looking for the full name.
        //

        //
        //  Our starting Fcb better be a directory.
        //

        if (!FlagOn( CurrentFcb->FileAttributes, FILE_ATTRIBUTE_DIRECTORY )) {

            try_leave( Status = STATUS_OBJECT_PATH_NOT_FOUND );
        }

        //
        //  If we can't wait then post this request.
        //

        if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {

            UdfRaiseStatus( IrpContext, STATUS_CANT_WAIT );
        }

        //
        //  Prepare the enumeration context for use.
        //
        
        UdfInitializeDirContext( IrpContext, &DirContext );
        CleanupDirContext = TRUE;

        while (TRUE) {

            ShortNameMatch = FALSE;

            //
            //  Split off the next component from the name.
            //

            UdfDissectName( IrpContext,
                            &RemainingName,
                            &FinalName );

            //
            //  Go ahead and look this entry up in the directory.
            //

            FoundEntry = UdfFindDirEntry( IrpContext,
                                          CurrentFcb,
                                          &FinalName,
                                          IgnoreCase,
                                          FALSE,
                                          &DirContext );

            //
            //  If we didn't find the entry then check if the current name
            //  is a possible short name.
            //

            if (!FoundEntry && UdfCandidateShortName( IrpContext, &FinalName)) {

                //
                //  If the name looks like it could be a short name, try to find
                //  a matching real directory entry.
                //

                ShortNameMatch =
                FoundEntry = UdfFindDirEntry( IrpContext,
                                              CurrentFcb,
                                              &FinalName,
                                              IgnoreCase,
                                              TRUE,
                                              &DirContext );
            }

            //
            //  If we didn't find a match then check what the caller was trying to do to
            //  determine which error code to return.
            //
    
            if (!FoundEntry) {
    
                if ((CreateDisposition == FILE_OPEN) ||
                    (CreateDisposition == FILE_OVERWRITE)) {
    
                    try_leave( Status = STATUS_OBJECT_NAME_NOT_FOUND );
                }
    
                //
                //  Any other operation return STATUS_ACCESS_DENIED.
                //
    
                try_leave( Status = STATUS_ACCESS_DENIED );
            }

            //
            //  If this is an ignore case open then copy the exact case
            //  in the file object name.
            //

            if (IgnoreCase && !ShortNameMatch) {

                ASSERT( FinalName.Length == DirContext.ObjectName.Length );
                
                RtlCopyMemory( FinalName.Buffer,
                               DirContext.ObjectName.Buffer,
                               DirContext.ObjectName.Length );
            }

            //
            //  If we have found the last component then break out to open for the caller.
            //

            if (RemainingName.Length == 0) {

                break;
            }
            
            //
            //  The object we just found must be a directory.
            //

            if (!FlagOn( DirContext.Fid->Flags, NSR_FID_F_DIRECTORY )) {

                try_leave( Status = STATUS_OBJECT_PATH_NOT_FOUND );
            }

            //
            //  Now open an Fcb for this intermediate index Fcb.
            //

            UdfOpenObjectFromDirContext( IrpContext,
                                         IrpSp,
                                         Vcb,
                                         &CurrentFcb,
                                         ShortNameMatch,
                                         IgnoreCase,
                                         &DirContext,
                                         FALSE,
                                         NULL );
        }
        
        //
        //  Make sure our opener is about to get what they expect.
        //

        if ((FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_TRAIL_BACKSLASH ) ||
             FlagOn( IrpSp->Parameters.Create.Options, FILE_DIRECTORY_FILE )) &&
            !FlagOn( DirContext.Fid->Flags, NSR_FID_F_DIRECTORY )) {

            try_leave( Status = STATUS_NOT_A_DIRECTORY );
        
        }

        if (FlagOn( IrpSp->Parameters.Create.Options, FILE_NON_DIRECTORY_FILE ) &&
            FlagOn( DirContext.Fid->Flags, NSR_FID_F_DIRECTORY )) {

            try_leave( Status = STATUS_FILE_IS_A_DIRECTORY );
        }

        //
        //  The only create disposition we allow is OPEN.
        //

        if ((CreateDisposition != FILE_OPEN) &&
            (CreateDisposition != FILE_OPEN_IF)) {

            try_leave( Status = STATUS_ACCESS_DENIED );
        }

        //
        //  Open the object for the caller.
        //

        try_leave( Status = UdfOpenObjectFromDirContext( IrpContext,
                                                         IrpSp,
                                                         Vcb,
                                                         &CurrentFcb,
                                                         ShortNameMatch,
                                                         IgnoreCase,
                                                         &DirContext,
                                                         TRUE,
                                                         RelatedCcb ));
    } finally {
        
        //
        //  Cleanup the enumeration context if initialized.
        //

        if (CleanupDirContext) {

            UdfCleanupDirContext( IrpContext, &DirContext );
        }

        //
        //  The result of this open could be success, pending or some error
        //  condition.
        //

        if (AbnormalTermination()) {


            //
            //  In the error path we start by calling our teardown routine if we
            //  have a CurrentFcb.
            //

            if (CurrentFcb != NULL) {

                BOOLEAN RemovedFcb;

                UdfTeardownStructures( IrpContext, CurrentFcb, FALSE, &RemovedFcb );

                if (RemovedFcb) {

                    CurrentFcb = NULL;
                }
            }
            
            //
            //  No need to complete the request.
            //

            IrpContext = NULL;
            Irp = NULL;

        //
        //  If we posted this request through the oplock package we need
        //  to show that there is no reason to complete the request.
        //

        } else if (Status == STATUS_PENDING) {

            IrpContext = NULL;
            Irp = NULL;
        }

        //
        //  Release the Current Fcb if still acquired.
        //

        if (CurrentFcb != NULL) {

            UdfReleaseFcb( IrpContext, CurrentFcb );
        }

        //
        //  Release the Vcb.
        //

        UdfReleaseVcb( IrpContext, Vcb );

        //
        //  Call our completion routine.  It will handle the case where either
        //  the Irp and/or IrpContext are gone.
        //

        UdfCompleteRequest( IrpContext, Irp, Status );
    }

    return Status;
}


//
//  Local support routine
//

NTSTATUS
UdfNormalizeFileNames (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN OpenByFileId,
    IN BOOLEAN IgnoreCase,
    IN TYPE_OF_OPEN RelatedTypeOfOpen,
    IN PCCB RelatedCcb OPTIONAL,
    IN PUNICODE_STRING RelatedFileName OPTIONAL,
    IN OUT PUNICODE_STRING FileName,
    IN OUT PUNICODE_STRING RemainingName
    )

/*++

Routine Description:

    This routine is called to store the full name and upcased name into the
    filename buffer.  We only upcase the portion yet to parse.  We also
    check for a trailing backslash and lead-in double backslashes.  This
    routine also verifies the mode of the related open against the name
    currently in the filename.

Arguments:

    Vcb - Vcb for this volume.

    OpenByFileId - Indicates if the filename should be a 64 bit FileId.

    IgnoreCase - Indicates if this open is a case-insensitive operation.

    RelatedTypeOfOpen - Indicates the type of the related file object.

    RelatedCcb - Ccb for the related open.  Ignored if no relative open.

    RelatedFileName - FileName buffer for related open.  Ignored if no
        relative open.

    FileName - FileName to update in this routine.  The name should
        either be a 64-bit FileId or a Unicode string.

    RemainingName - Name with the remaining portion of the name.  This
        will begin after the related name and any separator.  For a
        non-relative open we also step over the initial separator.

Return Value:

    NTSTATUS - STATUS_SUCCESS if the names are OK, appropriate error code
        otherwise.

--*/

{
    ULONG RemainingNameLength;
    ULONG RelatedNameLength = 0;
    ULONG SeparatorLength = 0;

    ULONG BufferLength;

    UNICODE_STRING NewFileName;

    PAGED_CODE();

    //
    //  If this is the first pass then we need to build the full name and
    //  check for name compatibility.
    //

    if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_FULL_NAME )) {

        //
        //  Deal with the regular file name case first.
        //

        if (!OpenByFileId) {

            //
            //  This is here because the Win32 layer can't avoid sending me double
            //  beginning backslashes.
            //

            if ((FileName->Length > sizeof( WCHAR )) &&
                (FileName->Buffer[1] == L'\\') &&
                (FileName->Buffer[0] == L'\\')) {

                //
                //  If there are still two beginning backslashes, the name is bogus.
                //

                if ((FileName->Length > 2 * sizeof( WCHAR )) &&
                    (FileName->Buffer[2] == L'\\')) {

                    return STATUS_OBJECT_NAME_INVALID;
                }

                //
                //  Slide the name down in the buffer.
                //

                FileName->Length -= sizeof( WCHAR );

                RtlMoveMemory( FileName->Buffer,
                               FileName->Buffer + 1,
                               FileName->Length );
            }

            //
            //  Check for a trailing backslash.  Don't strip off if only character
            //  in the full name or for relative opens where this is illegal.
            //

            if (((FileName->Length > sizeof( WCHAR)) ||
                 ((FileName->Length == sizeof( WCHAR )) && (RelatedTypeOfOpen == UserDirectoryOpen))) &&
                (FileName->Buffer[ (FileName->Length/2) - 1 ] == L'\\')) {

                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_TRAIL_BACKSLASH );
                FileName->Length -= sizeof( WCHAR );
            }

            //
            //  Remember the length we need for this portion of the name.
            //

            RemainingNameLength = FileName->Length;

            //
            //  If this is a related file object then we verify the compatibility
            //  of the name in the file object with the relative file object.
            //

            if (RelatedTypeOfOpen != UnopenedFileObject) {

                //
                //  If the filename length was zero then it must be legal.
                //  If there are characters then check with the related
                //  type of open.
                //

                if (FileName->Length != 0) {

                    //
                    //  The name length must always be zero for a volume open.
                    //

                    if (RelatedTypeOfOpen <= UserVolumeOpen) {

                        return STATUS_INVALID_PARAMETER;

                    //
                    //  The remaining name cannot begin with a backslash.
                    //

                    } else if (FileName->Buffer[0] == L'\\' ) {

                        return STATUS_INVALID_PARAMETER;

                    //
                    //  If the related file is a user file then there
                    //  is no file with this path.
                    //

                    } else if (RelatedTypeOfOpen == UserFileOpen) {

                        return STATUS_OBJECT_PATH_NOT_FOUND;
                    }
                }

                //
                //  Remember the length of the related name when building
                //  the full name.  We leave the RelatedNameLength and
                //  SeparatorLength at zero if the relative file is opened
                //  by Id.
                //

                if (!FlagOn( RelatedCcb->Flags, CCB_FLAG_OPEN_BY_ID )) {

                    //
                    //  Add a separator if the name length is non-zero
                    //  unless the relative Fcb is at the root.
                    //

                    if ((FileName->Length != 0) &&
                        (RelatedCcb->Fcb != Vcb->RootIndexFcb)) {

                        SeparatorLength = sizeof( WCHAR );
                    }

                    RelatedNameLength = RelatedFileName->Length;
                }

            //
            //  The full name is already in the filename.  It must either
            //  be length 0 or begin with a backslash.
            //

            } else if (FileName->Length != 0) {

                if (FileName->Buffer[0] != L'\\') {

                    return STATUS_INVALID_PARAMETER;
                }

                //
                //  We will want to trim the leading backslash from the
                //  remaining name we return.
                //

                RemainingNameLength -= sizeof( WCHAR );
                SeparatorLength = sizeof( WCHAR );
            }

            //
            //  Now see if the buffer is large enough to hold the full name.
            //

            BufferLength = RelatedNameLength + SeparatorLength + RemainingNameLength;

            //
            //  Check for an overflow of the maximum filename size.
            //
            
            if (BufferLength > MAXUSHORT) {

                return STATUS_INVALID_PARAMETER;
            }

            //
            //  Now see if we need to allocate a new buffer.
            //

            if (FileName->MaximumLength < BufferLength) {

                NewFileName.Buffer = FsRtlAllocatePoolWithTag( UdfPagedPool,
                                                               BufferLength,
                                                               TAG_FILE_NAME );

                NewFileName.MaximumLength = (USHORT) BufferLength;

            } else {

                NewFileName.Buffer = FileName->Buffer;
                NewFileName.MaximumLength = FileName->MaximumLength;
            }

            //
            //  If there is a related name then we need to slide the remaining bytes up and
            //  insert the related name.  Otherwise the name is in the correct position
            //  already.
            //

            if (RelatedNameLength != 0) {

                //
                //  Store the remaining name in its correct position.
                //

                if (RemainingNameLength != 0) {

                    RtlMoveMemory( Add2Ptr( NewFileName.Buffer, RelatedNameLength + SeparatorLength, PVOID ),
                                   FileName->Buffer,
                                   RemainingNameLength );
                }

                RtlCopyMemory( NewFileName.Buffer,
                               RelatedFileName->Buffer,
                               RelatedNameLength );

                //
                //  Add the separator if needed.
                //

                if (SeparatorLength != 0) {

                    *(Add2Ptr( NewFileName.Buffer, RelatedNameLength, PWCHAR )) = L'\\';
                }

                //
                //  Update the filename value we got from the user.
                //

                if (NewFileName.Buffer != FileName->Buffer) {

                    if (FileName->Buffer != NULL) {

                        ExFreePool( FileName->Buffer );
                    }

                    FileName->Buffer = NewFileName.Buffer;
                    FileName->MaximumLength = NewFileName.MaximumLength;
                }

                //
                //  Copy the name length to the user's filename.
                //

                FileName->Length = (USHORT) (RelatedNameLength + SeparatorLength + RemainingNameLength);
            }

            //
            //  Now update the remaining name to parse.
            //

            RemainingName->MaximumLength =
            RemainingName->Length = (USHORT) RemainingNameLength;

            RemainingName->Buffer = Add2Ptr( FileName->Buffer,
                                             RelatedNameLength + SeparatorLength,
                                             PWCHAR );

            //
            //  Upcase the name if necessary.
            //

            if (IgnoreCase && (RemainingNameLength != 0)) {

                UdfUpcaseName( IrpContext,
                               RemainingName,
                               RemainingName );
            }

            //
            //  Do a quick check to make sure there are no wildcards.
            //

            if (FsRtlDoesNameContainWildCards( RemainingName )) {

                return STATUS_OBJECT_NAME_INVALID;
            }

        //
        //  For the open by file Id case we verify the name really contains
        //  a 64 bit value.
        //

        } else {

            //
            //  Check for validity of the buffer.
            //

            if (FileName->Length != sizeof( FILE_ID )) {

                return STATUS_INVALID_PARAMETER;
            }
        }

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_FULL_NAME );

    //
    //  If we are in the retry path then the full name is already in the
    //  file object name.  If this is a case-sensitive operation then
    //  we need to upcase the name from the end of any related file name already stored
    //  there.
    //

    } else {

        //
        //  Assume there is no relative name.
        //

        *RemainingName = *FileName;

        //
        //  Nothing to do if the name length is zero.
        //

        if (RemainingName->Length != 0) {

            //
            //  If there is a relative name then we need to walk past it.
            //

            if (RelatedTypeOfOpen != UnopenedFileObject) {

                //
                //  Nothing to walk past if the RelatedCcb is opened by FileId.
                //


                if (!FlagOn( RelatedCcb->Flags, CCB_FLAG_OPEN_BY_ID )) {

                    //
                    //  Related file name is a proper prefix of the full name.
                    //  We step over the related name and if we are then
                    //  pointing at a separator character we step over that.
                    //

                    RemainingName->Buffer = Add2Ptr( RemainingName->Buffer,
                                                     RelatedFileName->Length,
                                                     PWCHAR );

                    RemainingName->Length -= RelatedFileName->Length;
                }
            }

            //
            //  If we are pointing at a separator character then step past that.
            //

            if (RemainingName->Length != 0) {

                if (*(RemainingName->Buffer) == L'\\') {

                    RemainingName->Buffer = Add2Ptr( RemainingName->Buffer,
                                                     sizeof( WCHAR ),
                                                     PWCHAR );

                    RemainingName->Length -= sizeof( WCHAR );
                }
            }
        }

        //
        //  Upcase the name if necessary.
        //

        if (IgnoreCase && (RemainingName->Length != 0)) {

            UdfUpcaseName( IrpContext,
                           RemainingName,
                           RemainingName );
        }
    }

    return STATUS_SUCCESS;
}


//
//  Local support routine
//

NTSTATUS
UdfOpenObjectByFileId (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb,
    IN OUT PFCB *CurrentFcb
    )

/*++

Routine Description:

    This routine is called to open a file by the FileId.  The file Id is in
    the FileObject name buffer and has been verified to be 64 bits.

    We extract the Id number and then check to see whether we are opening a
    file or directory and compare that with the create options.  If this
    generates no error then optimistically look up the Fcb in the Fcb Table.

    If we don't find the Fcb then we take what is effectively a wild-a** guess.
    Since we would need more than 64bits to contain the root extent length along
    with the partition, lbn and dir/file flag we have to speculate that the
    opener knows what they are doing and try to crack an ICB hierarchy at the
    specified location.  This can fail for any number of reasons, which then have
    to be mapped to an open failure.
    
    If found then build the Fcb from this entry and store the new Fcb in the
    tree.

    Finally we call our worker routine to complete the open on this Fcb.

Arguments:

    IrpSp - Stack location within the create Irp.

    Vcb - Vcb for this volume.

    CurrentFcb - Address to store the Fcb for this open.  We only store the
        CurrentFcb here when we have acquired it so our caller knows to
        free or deallocate it.

Return Value:

    NTSTATUS - Status indicating the result of the operation.

--*/

{
    NTSTATUS Status = STATUS_ACCESS_DENIED;

    BOOLEAN UnlockVcb = FALSE;
    BOOLEAN Found;
    BOOLEAN FcbExisted;

    ICB_SEARCH_CONTEXT IcbContext;
    BOOLEAN CleanupIcbContext = FALSE;

    NODE_TYPE_CODE NodeTypeCode;
    TYPE_OF_OPEN TypeOfOpen;

    FILE_ID FileId;

    PFCB NextFcb = NULL;

    PAGED_CODE();

    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    //
    //  Extract the FileId from the FileObject.
    //

    RtlCopyMemory( &FileId, IrpSp->FileObject->FileName.Buffer, sizeof( FILE_ID ));

    //
    //  Now do a quick check that the reserved, unused chunk of the fileid is
    //  unused in this specimen.
    //

    if (UdfGetFidReservedZero( FileId )) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Go ahead and figure out the TypeOfOpen and NodeType.  We can
    //  get these from the input FileId.
    //

    if (UdfIsFidDirectory( FileId )) {

        TypeOfOpen = UserDirectoryOpen;
        NodeTypeCode = UDFS_NTC_FCB_INDEX;

    } else {

        TypeOfOpen = UserFileOpen;
        NodeTypeCode = UDFS_NTC_FCB_DATA;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Acquire the Vcb and check if there is already an Fcb.
        //  If not we will need to carefully hunt for the on-disc
        //  structures.
        //
        //  We will post the request if we don't find the Fcb and this
        //  request can't wait.
        //

        UdfLockVcb( IrpContext, Vcb );
        UnlockVcb = TRUE;

        NextFcb = UdfCreateFcb( IrpContext, FileId, NodeTypeCode, &FcbExisted );

        //
        //  Now, if the Fcb was not already here we have some work to do.
        //
        
        if (!FcbExisted) {

            //
            //  If we can't wait then post this request.
            //
    
            if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {
    
                UdfRaiseStatus( IrpContext, STATUS_CANT_WAIT );
            }
    
            //
            //  Use a try-finally to transform errors we get as a result of going
            //  off on a wild goose chase into a simple open failure.
            //
            
            try {

                NextFcb->FileId = FileId;
                
                UdfInitializeIcbContextFromFcb( IrpContext, &IcbContext, NextFcb );
                CleanupIcbContext = TRUE;
    
                UdfLookupActiveIcb( IrpContext, 
                                    &IcbContext, 
                                    NextFcb->RootExtentLength);
                
                UdfInitializeFcbFromIcbContext( IrpContext,
                                                NextFcb,
                                                &IcbContext,
                                                NULL);
    
                UdfCleanupIcbContext( IrpContext, &IcbContext );
                CleanupIcbContext = FALSE;

            } except( UdfExceptionFilter( IrpContext, GetExceptionInformation() )) {

                //
                //   Any error we receive is an indication that the given fileid is
                //   not valid.
                //

                Status = STATUS_INVALID_PARAMETER;
            }

            //
            //  Do a little dance to leave the exception handler if we had problems.
            //
            
            if (Status == STATUS_INVALID_PARAMETER) {

                try_leave( NOTHING );
            }
        }
        
        //
        //  We have the Fcb.  Check that the type of the file is compatible with
        //  the desired type of file to open.
        //

        if (FlagOn( NextFcb->FileAttributes, FILE_ATTRIBUTE_DIRECTORY )) {

            if (FlagOn( IrpSp->Parameters.Create.Options, FILE_NON_DIRECTORY_FILE )) {

                try_leave( Status = STATUS_FILE_IS_A_DIRECTORY );
            }

        } else if (FlagOn( IrpSp->Parameters.Create.Options, FILE_DIRECTORY_FILE )) {

            try_leave( Status = STATUS_NOT_A_DIRECTORY );
        }

        //
        //  We now know the Fcb and currently hold the Vcb lock.
        //  Try to acquire this Fcb without waiting.  Otherwise we
        //  need to reference it, drop the Vcb, acquire the Fcb, the
        //  Vcb and then dereference the Fcb.
        //

        if (!UdfAcquireFcbExclusive( IrpContext, NextFcb, TRUE )) {

            NextFcb->FcbReference += 1;
            UdfUnlockVcb( IrpContext, Vcb );

            UdfAcquireFcbExclusive( IrpContext, NextFcb, FALSE );

            UdfLockVcb( IrpContext, Vcb );
            NextFcb->FcbReference -= 1;
        }

        UdfUnlockVcb( IrpContext, Vcb );
        UnlockVcb = FALSE;

        //
        //  Move to this Fcb.
        //

        *CurrentFcb = NextFcb;

        //
        //  Check the requested access on this Fcb.
        //

        if (!UdfIllegalFcbAccess( IrpContext,
                                  TypeOfOpen,
                                  IrpSp->Parameters.Create.SecurityContext->DesiredAccess )) {

            //
            //  Call our worker routine to complete the open.
            //

            Status = UdfCompleteFcbOpen( IrpContext,
                                         IrpSp,
                                         Vcb,
                                         CurrentFcb,
                                         NULL,
                                         TypeOfOpen,
                                         CCB_FLAG_OPEN_BY_ID,
                                         IrpSp->Parameters.Create.SecurityContext->DesiredAccess );
        }

    } finally {

        if (UnlockVcb) {

            UdfUnlockVcb( IrpContext, Vcb );
        }

        if (CleanupIcbContext) {

            UdfCleanupIcbContext( IrpContext, &IcbContext );
        }
        
        //
        //  Destroy the new Fcb if it was not fully initialized.
        //

        if (NextFcb && !FlagOn( NextFcb->FcbState, FCB_STATE_INITIALIZED )) {

            UdfDeleteFcb( IrpContext, NextFcb );
        }

    }

    return Status;
}


//
//  Local support routine
//

NTSTATUS
UdfOpenExistingFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN OUT PFCB *CurrentFcb,
    IN PLCB OpenLcb,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN BOOLEAN IgnoreCase,
    IN PCCB RelatedCcb OPTIONAL
    )

/*++

Routine Description:

    This routine is called to open an Fcb which is already in the Fcb table.
    We will verify the access to the file and then call our worker routine
    to perform the final operations.

Arguments:

    IrpSp - Pointer to the stack location for this open.

    CurrentFcb - Address of Fcb to open.  We will clear this if the Fcb
        is released here.
        
    OpenLcb - Lcb used to find this Fcb.

    TypeOfOpen - Indicates whether we are opening a file, directory or volume.

    IgnoreCase - Indicates if this open is case-insensitive.

    RelatedCcb - Ccb for related file object if relative open.  We use
        this when setting the Ccb flags for this open.  It will tell
        us whether the name currently in the file object is relative or
        absolute.

Return Value:

    NTSTATUS - Status indicating the result of the operation.

--*/

{
    ULONG CcbFlags = 0;

    NTSTATUS Status = STATUS_ACCESS_DENIED;

    PAGED_CODE();

    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_EXCLUSIVE_FCB( *CurrentFcb );
    ASSERT_OPTIONAL_CCB( RelatedCcb );

    //
    //  Check that the desired access is legal.
    //

    if (!UdfIllegalFcbAccess( IrpContext,
                              TypeOfOpen,
                              IrpSp->Parameters.Create.SecurityContext->DesiredAccess )) {

        //
        //  Set the Ignore case.
        //

        if (IgnoreCase) {

            SetFlag( CcbFlags, CCB_FLAG_IGNORE_CASE );
        }

        //
        //  Check the related Ccb to see if this was an OpenByFileId and
        //  whether there was a version.
        //

        if (ARGUMENT_PRESENT( RelatedCcb )) {

            if (FlagOn( RelatedCcb->Flags, CCB_FLAG_OPEN_BY_ID | CCB_FLAG_OPEN_RELATIVE_BY_ID )) {

                SetFlag( CcbFlags, CCB_FLAG_OPEN_RELATIVE_BY_ID );
            }
        }

        //
        //  Call our worker routine to complete the open.
        //

        Status = UdfCompleteFcbOpen( IrpContext,
                                     IrpSp,
                                     (*CurrentFcb)->Vcb,
                                     CurrentFcb,
                                     OpenLcb,
                                     TypeOfOpen,
                                     CcbFlags,
                                     IrpSp->Parameters.Create.SecurityContext->DesiredAccess );
    }

    return Status;
}


//
//  Local support routine
//

NTSTATUS
UdfOpenObjectFromDirContext (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb,
    IN OUT PFCB *CurrentFcb,
    IN BOOLEAN ShortNameMatch,                             
    IN BOOLEAN IgnoreCase,
    IN PDIR_ENUM_CONTEXT DirContext,
    IN BOOLEAN PerformUserOpen,
    IN PCCB RelatedCcb OPTIONAL
    )

/*++

Routine Description:

    This routine is called to open an object found in a directory scan.  This
    can be a directory or a file as indicated in the scan's results.

    We first check that the desired access is legal for this file.  Then we
    construct the FileId for this and do a check to see if it is the Fcb
    Table.  It is always possible that either it was created since or simply
    wasn't in the prefix table at the time of the prefix table search.
    Lookup the active ICB, initialize the Fcb and store into the FcbTable
    if not present.

    Next we will add this to the prefix table of our parent if needed.

    Once we know that the new Fcb has been initialized then we move our pointer
    in the tree down to this position.

    This routine does not own the Vcb lock on entry.  We must be sure to release
    it on exit.

Arguments:

    IrpSp - Stack location for this request.

    Vcb - Vcb for the current volume.

    CurrentFcb - On input this is the parent of the Fcb to open.  On output we
        store the Fcb for the file being opened.
        
    ShortNameMatch - Indicates whether this object was opened by the shortname.

    IgnoreCase - Indicates the case sensitivity of the caller.

    DirContext - This is the context used to find the object.
    
    PerformUserOpen - Indicates if we are at the object the user wants to finally open.

    RelatedCcb - RelatedCcb for relative file object used to make this open.

Return Value:

    NTSTATUS - Status indicating the result of the operation.

--*/

{
    ULONG CcbFlags = 0;
    FILE_ID FileId;

    BOOLEAN UnlockVcb = FALSE;
    BOOLEAN FcbExisted;

    PFCB NextFcb = NULL;
    PFCB ParentFcb = NULL;

    TYPE_OF_OPEN TypeOfOpen;
    NODE_TYPE_CODE NodeTypeCode;

    ICB_SEARCH_CONTEXT IcbContext;
    BOOLEAN CleanupIcbContext = FALSE;

    PLCB OpenLcb;

    NTSTATUS Status;

    PAGED_CODE();

    //
    //  Figure out what kind of open we will be performing here.  The caller has already insured
    //  that the user is expecting us to do this.
    //

    if (FlagOn( DirContext->Fid->Flags, NSR_FID_F_DIRECTORY )) {

        TypeOfOpen = UserDirectoryOpen;
        NodeTypeCode = UDFS_NTC_FCB_INDEX;
    
    } else {
        
        TypeOfOpen = UserFileOpen;
        NodeTypeCode = UDFS_NTC_FCB_DATA;
    }

    //
    //  Check for illegal access to this file.
    //

    if (PerformUserOpen &&
        UdfIllegalFcbAccess( IrpContext,
                             TypeOfOpen,
                             IrpSp->Parameters.Create.SecurityContext->DesiredAccess )) {

        return STATUS_ACCESS_DENIED;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Check the related Ccb to see if this was an OpenByFileId.
        //

        if (ARGUMENT_PRESENT( RelatedCcb ) &&
            FlagOn( RelatedCcb->Flags, CCB_FLAG_OPEN_BY_ID | CCB_FLAG_OPEN_RELATIVE_BY_ID )) {

            SetFlag( CcbFlags, CCB_FLAG_OPEN_RELATIVE_BY_ID );
        }

        if (IgnoreCase) {

            SetFlag( CcbFlags, CCB_FLAG_IGNORE_CASE );
        }

        //
        //  Build the file Id for this object.
        //
        
        UdfSetFidFromLbAddr( FileId, DirContext->Fid->Icb.Start );

        if (TypeOfOpen == UserDirectoryOpen) {

            UdfSetFidDirectory( FileId );
        }

        //
        //  Lock the Vcb so we can examine the Fcb Table.
        //

        UdfLockVcb( IrpContext, Vcb );
        UnlockVcb = TRUE;

        //
        //  Get the Fcb for this file.
        //

        NextFcb = UdfCreateFcb( IrpContext, FileId, NodeTypeCode, &FcbExisted );

        //
        //  If the Fcb was created here then initialize from the values in the
        //  dirent.  We have optimistically assumed that there isn't any corrupt
        //  information to this point - we're about to discover it if there is.
        //

        if (!FcbExisted) {

            //
            //  Set the root extent length and go get the active ICB, initialize.
            //

            NextFcb->RootExtentLength = DirContext->Fid->Icb.Length.Length;

            UdfInitializeIcbContextFromFcb( IrpContext, &IcbContext, NextFcb );
            CleanupIcbContext = TRUE;

            UdfLookupActiveIcb( IrpContext, 
                                &IcbContext, 
                                NextFcb->RootExtentLength );
            
            UdfInitializeFcbFromIcbContext( IrpContext,
                                            NextFcb,
                                            &IcbContext,
                                            *CurrentFcb);

            UdfCleanupIcbContext( IrpContext, &IcbContext );
            CleanupIcbContext = FALSE;

        }

        //
        //  Now try to acquire the new Fcb without waiting.  We will reference
        //  the Fcb and retry with wait if unsuccessful.
        //

        if (!UdfAcquireFcbExclusive( IrpContext, NextFcb, TRUE )) {

            NextFcb->FcbReference += 1;

            UdfUnlockVcb( IrpContext, Vcb );

            UdfReleaseFcb( IrpContext, *CurrentFcb );
            UdfAcquireFcbExclusive( IrpContext, NextFcb, FALSE );
            UdfAcquireFcbExclusive( IrpContext, *CurrentFcb, FALSE );

            UdfLockVcb( IrpContext, Vcb );
            NextFcb->FcbReference -= 1;
        }

        //
        //  Move down to this new Fcb.  Remember that we still own the parent however.
        //

        ParentFcb = *CurrentFcb;
        *CurrentFcb = NextFcb;

        //
        //  Store this name into the prefix table for the parent.
        //

        OpenLcb = UdfInsertPrefix( IrpContext,
                                   NextFcb,
                                   ( ShortNameMatch?
                                     &DirContext->ShortObjectName :
                                     &DirContext->CaseObjectName ),
                                   ShortNameMatch,
                                   IgnoreCase,
                                   ParentFcb );

        //
        //  Now increment the reference counts for the parent and drop the Vcb.
        //

        DebugTrace(( +1, Dbg,
                     "UdfOpenObjectFromDirContext, PFcb %08x Vcb %d/%d Fcb %d/%d\n", ParentFcb,
                     Vcb->VcbReference,
                     Vcb->VcbUserReference,
                     ParentFcb->FcbReference,
                     ParentFcb->FcbUserReference ));

        UdfIncrementReferenceCounts( IrpContext, ParentFcb, 1, 1 );
        
        DebugTrace(( -1, Dbg, 
                     "UdfOpenObjectFromDirContext, Vcb %d/%d Fcb %d/%d\n",
                     Vcb->VcbReference,
                     Vcb->VcbUserReference,
                     ParentFcb->FcbReference,
                     ParentFcb->FcbUserReference ));

        UdfUnlockVcb( IrpContext, Vcb );
        UnlockVcb = FALSE;

        //
        //  Perform initialization associated with the directory context.
        //
            
        UdfInitializeLcbFromDirContext( IrpContext,
                                        OpenLcb,
                                        DirContext );

        //
        //  If we just opened VIDEO_TS directory,  on a UDF1.02 file system,
        //  then mark the Fcb to allow the >=1Gb single AD workaround
        //  to be used on it's children (works around some corrupt DVD-Videos)
        //

        if ((NextFcb->NodeTypeCode == UDFS_NTC_FCB_INDEX) &&
            (ParentFcb == Vcb->RootIndexFcb) &&
            (Vcb->UdfRevision == UDF_VERSION_102) &&
            (OpenLcb->FileName.Length == 16) &&
            (!_wcsnicmp( OpenLcb->FileName.Buffer, L"VIDEO_TS", 8)))  {

            DebugTrace(( 0, Dbg, "Enabled >= 1gig AD workaround\n"));
            
            SetFlag( NextFcb->FcbState, FCB_STATE_ALLOW_ONEGIG_WORKAROUND);
        }
        
        //
        //  Release the parent Fcb at this point.
        //

        UdfReleaseFcb( IrpContext, ParentFcb );
        ParentFcb = NULL;

        //
        //  Call our worker routine to complete the open.
        //

        if (PerformUserOpen) {

            Status = UdfCompleteFcbOpen( IrpContext,
                                         IrpSp,
                                         Vcb,
                                         CurrentFcb,
                                         OpenLcb,
                                         TypeOfOpen,
                                         CcbFlags,
                                         IrpSp->Parameters.Create.SecurityContext->DesiredAccess );
        }

    } finally {

        //
        //  Unlock the Vcb if held.
        //

        if (UnlockVcb) {

            UdfUnlockVcb( IrpContext, Vcb );
        }

        //
        //  Release the parent if held.
        //

        if (ParentFcb != NULL) {

            UdfReleaseFcb( IrpContext, ParentFcb );
        }

        //
        //  Destroy the new Fcb if it was not fully initialized.
        //

        if (NextFcb && !FlagOn( NextFcb->FcbState, FCB_STATE_INITIALIZED )) {

            UdfDeleteFcb( IrpContext, NextFcb );
        }

        //
        //  Clean up the Icb context if used.
        //

        if (CleanupIcbContext) {

            UdfCleanupIcbContext( IrpContext, &IcbContext );
        }
    }

    return Status;
}


//
//  Local support routine
//

NTSTATUS
UdfCompleteFcbOpen (
    IN PIRP_CONTEXT IrpContext,
    PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb,
    IN OUT PFCB *CurrentFcb,
    IN PLCB OpenLcb OPTIONAL,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN ULONG UserCcbFlags,
    IN ACCESS_MASK DesiredAccess
    )

/*++

Routine Description:

    This is the worker routine which takes an existing Fcb and completes
    the open.  We will do any necessary oplock checks and sharing checks.
    Finally we will create the Ccb and update the file object and any
    file object flags.

Arguments:

    IrpSp - Stack location for the current request.

    Vcb - Vcb for the current volume.

    CurrentFcb - Address of pointer to Fcb to open.  We clear this field if
        we release the resource for this file.
        
    OpenLcb - Lcb this Fcb is being opened by

    TypeOfOpen - Type of open for this request.

    UserCcbFlags - Flags to OR into the Ccb flags.

    DesiredAccess - Desired access for this open.

Return Value:

    NTSTATUS - STATUS_SUCCESS if we complete this request, STATUS_PENDING if
        the oplock package takes the Irp or SHARING_VIOLATION if there is a
        sharing check conflict.

--*/

{
    NTSTATUS Status;
    NTSTATUS OplockStatus = STATUS_SUCCESS;
    ULONG Information = FILE_OPENED;

    BOOLEAN LockVolume = FALSE;

    PFCB Fcb = *CurrentFcb;
    PCCB Ccb;

    PAGED_CODE();

    //
    //  Expand maximum allowed to something sensible for share access checking
    //

    if (MAXIMUM_ALLOWED == DesiredAccess)  {
    
        DesiredAccess = FILE_ALL_ACCESS & ~((TypeOfOpen != UserVolumeOpen ?
                                             (FILE_WRITE_ATTRIBUTES           |
                                              FILE_WRITE_DATA                 |
                                              FILE_WRITE_EA                   |
                                              FILE_ADD_FILE                   |                     
                                              FILE_ADD_SUBDIRECTORY           |
                                              FILE_APPEND_DATA) : 0)          |
                                            FILE_DELETE_CHILD                 |
                                            DELETE                            |
                                            WRITE_DAC );
    }

    //
    //  If this a volume open and the user wants to lock the volume then
    //  purge and lock the volume.
    //

    if ((TypeOfOpen <= UserVolumeOpen) &&
        !FlagOn( IrpSp->Parameters.Create.ShareAccess, FILE_SHARE_READ )) {

        //
        //  If there are open handles then fail this immediately.
        //

        if (Vcb->VcbCleanup != 0) {

            return STATUS_SHARING_VIOLATION;
        }

        //
        //  If we can't wait then force this to be posted.
        //

        if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {

            UdfRaiseStatus( IrpContext, STATUS_CANT_WAIT );
        }

        LockVolume = TRUE;

        //
        //  Purge the volume and make sure all of the user references
        //  are gone.
        //

        Status = UdfPurgeVolume( IrpContext, Vcb, FALSE );

        if (Status != STATUS_SUCCESS) {

            return Status;
        }

        //
        //  Now force all of the delayed close operations to go away.
        //

        UdfFspClose( Vcb );

        if (Vcb->VcbUserReference > Vcb->VcbResidualUserReference) {

            return STATUS_SHARING_VIOLATION;
        }
    }
    
    //
    //  If the Fcb already existed then we need to check the oplocks and
    //  the share access.
    //

    if (Fcb->FcbCleanup != 0) {

        //
        //  If this is a user file open then check whether there are any
        //  batch oplock.
        //

        if (TypeOfOpen == UserFileOpen) {

            //
            //  Store the address of the Fcb for a possible teardown into
            //  the IrpContext.  We will release this in the call to
            //  prepost the Irp.
            //

            IrpContext->TeardownFcb = CurrentFcb;

            if (FsRtlCurrentBatchOplock( &Fcb->Oplock )) {

                //
                //  We remember if a batch oplock break is underway for the
                //  case where the sharing check fails.
                //

                Information = FILE_OPBATCH_BREAK_UNDERWAY;

                OplockStatus = FsRtlCheckOplock( &Fcb->Oplock,
                                                 IrpContext->Irp,
                                                 IrpContext,
                                                 UdfOplockComplete,
                                                 UdfPrePostIrp );

                if (OplockStatus == STATUS_PENDING) {

                    return STATUS_PENDING;
                }
            }

            //
            //  Check the share access before breaking any exclusive oplocks.
            //

            Status = IoCheckShareAccess( DesiredAccess,
                                         IrpSp->Parameters.Create.ShareAccess,
                                         IrpSp->FileObject,
                                         &Fcb->ShareAccess,
                                         FALSE );

            if (!NT_SUCCESS( Status )) {

                return Status;
            }

            //
            //  Now check that we can continue based on the oplock state of the
            //  file.
            //

            OplockStatus = FsRtlCheckOplock( &Fcb->Oplock,
                                             IrpContext->Irp,
                                             IrpContext,
                                             UdfOplockComplete,
                                             UdfPrePostIrp );

            if (OplockStatus == STATUS_PENDING) {

                return STATUS_PENDING;
            }

            IrpContext->TeardownFcb = NULL;

        //
        //  Otherwise just do the sharing check.
        //

        } else {

            Status = IoCheckShareAccess( DesiredAccess,
                                         IrpSp->Parameters.Create.ShareAccess,
                                         IrpSp->FileObject,
                                         &Fcb->ShareAccess,
                                         FALSE );

            if (!NT_SUCCESS( Status )) {

                return Status;
            }
        }
    }

    //
    //  Create the Ccb now.
    //

    Ccb = UdfCreateCcb( IrpContext, Fcb, OpenLcb, UserCcbFlags );

    //
    //  Update the share access.
    //

    if (Fcb->FcbCleanup == 0) {

        IoSetShareAccess( DesiredAccess,
                          IrpSp->Parameters.Create.ShareAccess,
                          IrpSp->FileObject,
                          &Fcb->ShareAccess );

    } else {

        IoUpdateShareAccess( IrpSp->FileObject, &Fcb->ShareAccess );
    }

    //
    //  Set the file object type.
    //

    UdfSetFileObject( IrpContext, IrpSp->FileObject, TypeOfOpen, Fcb, Ccb );

    //
    //  Set the appropriate cache flags for a user file object.
    //

    if (TypeOfOpen == UserFileOpen) {

        if (FlagOn( IrpSp->Parameters.Create.Options, FILE_NO_INTERMEDIATE_BUFFERING )) {

            SetFlag( IrpSp->FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING );

        } else {

            SetFlag( IrpSp->FileObject->Flags, FO_CACHE_SUPPORTED );
        }
    }
    else if (TypeOfOpen == UserVolumeOpen)  {

        //
        //  DASD access is always noncached
        //
        
        SetFlag( IrpSp->FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING );
    }
    
    //
    //  Update the open and cleanup counts.  Check the fast io state here.
    //

    UdfLockVcb( IrpContext, Vcb );

    UdfIncrementCleanupCounts( IrpContext, Fcb );
    
    DebugTrace(( +1, Dbg,
                 "UdfCompleteFcbOpen, Fcb %08x Vcb %d/%d Fcb %d/%d\n", Fcb,
                 Vcb->VcbReference,
                 Vcb->VcbUserReference,
                 Fcb->FcbReference,
                 Fcb->FcbUserReference ));

    UdfIncrementReferenceCounts( IrpContext, Fcb, 1, 1 );
    
    DebugTrace(( -1, Dbg,
                 "UdfCompleteFcbOpen, Vcb %d/%d Fcb %d/%d\n",
                 Vcb->VcbReference,
                 Vcb->VcbUserReference,
                 Fcb->FcbReference,
                 Fcb->FcbUserReference ));

    if (LockVolume) {

        Vcb->VolumeLockFileObject = IrpSp->FileObject;
        SetFlag( Vcb->VcbState, VCB_STATE_LOCKED );
    }

    UdfUnlockVcb( IrpContext, Vcb );

    UdfLockFcb( IrpContext, Fcb );

    if (TypeOfOpen == UserFileOpen) {

        Fcb->IsFastIoPossible = UdfIsFastIoPossible( Fcb );

    } else {

        Fcb->IsFastIoPossible = FastIoIsNotPossible;
    }

    UdfUnlockFcb( IrpContext, Fcb );

    //
    //  Show that we opened the file.
    //

    IrpContext->Irp->IoStatus.Information = Information;

    //
    //  Point to the section object pointer in the non-paged Fcb.
    //

    IrpSp->FileObject->SectionObjectPointer = &Fcb->FcbNonpaged->SegmentObject;
    return OplockStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\udfs\close.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    Close.c

Abstract:

    This module implements the File Close routine for Udfs called by the
    Fsd/Fsp dispatch routines.

    The close operation interacts with both the async and delayed close queues
    in the UdfData structure.  Since close may be called recursively we may
    violate the locking order in acquiring the Vcb or Fcb.  In this case
    we may move the request to the async close queue.  If this is the last
    reference on the Fcb and there is a chance the user may reopen this
    file again soon we would like to defer the close.  In this case we
    may move the request to the delayed close queue.

    Once we are past the decode file operation there is no need for the
    file object.  If we are moving the request to either of the work
    queues then we remember all of the information from the file object and
    complete the request with STATUS_SUCCESS.  The Io system can then
    reuse the file object and we can complete the request when convenient.

    The async close queue consists of requests which we would like to
    complete as soon as possible.  They are queued using the original
    IrpContext where some of the fields have been overwritten with
    information from the file object.  We will extract this information,
    cleanup the IrpContext and then call the close worker routine.

    The delayed close queue consists of requests which we would like to
    defer the close for.  We keep size of this list within a range
    determined by the size of the system.  We let it grow to some maximum
    value and then shrink to some minimum value.  We allocate a small
    structure which contains the key information from the file object
    and use this information along with an IrpContext on the stack
    to complete the request.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]     04-Nov-1996

Revision History:

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_CLOSE)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_CLOSE)

//
//  Local support routines
//

BOOLEAN
UdfCommonClosePrivate (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFCB Fcb,
    IN ULONG UserReference,
    IN BOOLEAN FromFsd
    );

VOID
UdfQueueClose (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG UserReference,
    IN BOOLEAN DelayedClose
    );

PIRP_CONTEXT
UdfRemoveClose (
    IN PVCB Vcb OPTIONAL
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfCommonClose)
#pragma alloc_text(PAGE, UdfCommonClosePrivate)
#pragma alloc_text(PAGE, UdfQueueClose)
#pragma alloc_text(PAGE, UdfRemoveClose)
#endif


VOID
UdfFspClose (
    IN PVCB Vcb OPTIONAL
    )

/*++

Routine Description:

    This routine is called to process the close queues in the UdfData.  If the
    Vcb is passed then we want to remove all of the closes for this Vcb.
    Otherwise we will do as many of the delayed closes as we need to do.

Arguments:

    Vcb - If specified then we are looking for all of the closes for the
        given Vcb.

Return Value:

    None

--*/

{
    PIRP_CONTEXT IrpContext;
    IRP_CONTEXT StackIrpContext;

    THREAD_CONTEXT ThreadContext;

    PFCB Fcb;
    ULONG UserReference;

    ULONG VcbHoldCount = 0;
    PVCB CurrentVcb = NULL;

    BOOLEAN PotentialVcbTeardown = FALSE;

    PAGED_CODE();

    //
    //  Check input.
    //

    ASSERT_OPTIONAL_VCB( Vcb );

    FsRtlEnterFileSystem();

    //
    //  Continue processing until there are no more closes to process.
    //

    while (IrpContext = UdfRemoveClose( Vcb )) {

        //
        //  If we don't have an IrpContext then use the one on the stack.
        //  Initialize it for this request.
        //

        if (SafeNodeType( IrpContext ) != UDFS_NTC_IRP_CONTEXT ) {

            //
            //  Update the local values from the IrpContextLite.
            //

            Fcb = ((PIRP_CONTEXT_LITE) IrpContext)->Fcb;
            UserReference = ((PIRP_CONTEXT_LITE) IrpContext)->UserReference;

            //
            //  Update the stack irp context with the values from the
            //  IrpContextLite.
            //

            UdfInitializeStackIrpContext( &StackIrpContext,
                                          (PIRP_CONTEXT_LITE) IrpContext );

            //
            //  Free the IrpContextLite.
            //

            UdfFreeIrpContextLite( (PIRP_CONTEXT_LITE) IrpContext );

            //
            //  Remember we have the IrpContext from the stack.
            //

            IrpContext = &StackIrpContext;

        //
        //  Otherwise cleanup the existing IrpContext.
        //

        } else {

            //
            //  Remember the Fcb and user reference count.
            //

            Fcb = (PFCB) IrpContext->Irp;
            IrpContext->Irp = NULL;

            UserReference = (ULONG) IrpContext->ExceptionStatus;
            IrpContext->ExceptionStatus = STATUS_SUCCESS;
        }

        //
        //  We have an IrpContext.  Now we need to set the top level thread
        //  context.
        //

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FSP_FLAGS );

        //
        //  If we were given a Vcb then there is a request on top of this.
        //

        if (ARGUMENT_PRESENT( Vcb )) {

            ClearFlag( IrpContext->Flags,
                       IRP_CONTEXT_FLAG_TOP_LEVEL | IRP_CONTEXT_FLAG_TOP_LEVEL_UDFS );
        }

        UdfSetThreadContext( IrpContext, &ThreadContext );

        //
        //  If we have hit the maximum number of requests to process without
        //  releasing the Vcb then release the Vcb now.  If we are holding
        //  a different Vcb to this one then release the previous Vcb.
        //
        //  In either case acquire the current Vcb.
        //
        //  We use the MinDelayedCloseCount from the UdfData since it is
        //  a convenient value based on the system size.  Only thing we are trying
        //  to do here is prevent this routine starving other threads which
        //  may need this Vcb exclusively.
        //
        //  Note that the check for potential teardown below is unsafe.  We'll 
        //  repeat later within the UdfData lock.
        //

        PotentialVcbTeardown = !ARGUMENT_PRESENT( Vcb ) &&
                               (Fcb->Vcb->VcbCondition != VcbMounted) &&
                               (Fcb->Vcb->VcbCondition != VcbMountInProgress) &&
                               (Fcb->Vcb->VcbCleanup == 0);

        if (PotentialVcbTeardown ||
            (VcbHoldCount > UdfData.MinDelayedCloseCount) ||
            (Fcb->Vcb != CurrentVcb)) {

            if (CurrentVcb != NULL) {

                UdfReleaseVcb( IrpContext, CurrentVcb );
            }

            if (PotentialVcbTeardown) {

                UdfAcquireUdfData( IrpContext );
                
                //
                //  Repeat the checks with the global lock held.  The volume could have
                //  been remounted while we didn't hold the lock.
                //

                PotentialVcbTeardown = !ARGUMENT_PRESENT( Vcb ) &&
                                       (Fcb->Vcb->VcbCondition != VcbMounted) &&
                                       (Fcb->Vcb->VcbCondition != VcbMountInProgress) &&
                                       (Fcb->Vcb->VcbCleanup == 0);
                                       
                if (!PotentialVcbTeardown)  {

                    UdfReleaseUdfData( IrpContext);
                }
            }

            CurrentVcb = Fcb->Vcb;
            UdfAcquireVcbShared( IrpContext, CurrentVcb, FALSE );

            VcbHoldCount = 0;

        } else {

            VcbHoldCount += 1;
        }

        DebugTrace(( +1, Dbg,
                     "UdfFspClose, Fcb %08x %4s Vcb %d/%d Fcb %d/%d\n",
                     Fcb,
                     ( UserReference? "USER" : "SYS" ),
                     CurrentVcb->VcbReference,
                     CurrentVcb->VcbUserReference,
                     Fcb->FcbReference,
                     Fcb->FcbUserReference ));

        //
        //  Call our worker routine to perform the close operation.
        //

        UdfCommonClosePrivate( IrpContext, CurrentVcb, Fcb, UserReference, FALSE );

        //
        //  If the reference count on this Vcb is below our residual reference
        //  then check if we should dismount the volume.
        //

        if (PotentialVcbTeardown) {

            UdfReleaseVcb( IrpContext, CurrentVcb );
            UdfCheckForDismount( IrpContext, CurrentVcb, FALSE );

            CurrentVcb = NULL;

            UdfReleaseUdfData( IrpContext );
            PotentialVcbTeardown = FALSE;
        }

        //
        //  Complete the current request to cleanup the IrpContext.
        //

        UdfCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

        DebugTrace(( -1, Dbg, "UdfFspClose -> VOID\n" ));
    }

    //
    //  Release any Vcb we may still hold.
    //

    if (CurrentVcb != NULL) {

        UdfReleaseVcb( IrpContext, CurrentVcb );
    }

    FsRtlExitFileSystem();
}


NTSTATUS
UdfCommonClose (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the Fsd entry for the close operation.  We decode the file
    object to find the UDFS structures and type of open.  We call our internal
    worker routine to perform the actual work.  If the work wasn't completed
    then we post to one of our worker queues.  The Ccb isn't needed after this
    point so we delete the Ccb and return STATUS_SUCCESS to our caller in all
    cases.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    STATUS_SUCCESS

--*/

{
    TYPE_OF_OPEN TypeOfOpen;

    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;
    ULONG UserReference = 0;

    BOOLEAN DelayedClose;
    BOOLEAN ForceDismount = FALSE;
    BOOLEAN PotentialVcbTeardown = FALSE;

    PAGED_CODE();

    //
    //  Check input.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    //
    //  If we were called with our file system device object instead of a
    //  volume device object, just complete this request with STATUS_SUCCESS.
    //

    if (IrpContext->Vcb == NULL) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
        return STATUS_SUCCESS;
    }

    //
    //  Decode the file object to get the type of open and Fcb/Ccb.
    //

    TypeOfOpen = UdfDecodeFileObject( IoGetCurrentIrpStackLocation( Irp )->FileObject,
                                      &Fcb,
                                      &Ccb );

    //
    //  No work to do for unopened file objects.
    //

    if (TypeOfOpen == UnopenedFileObject) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );

        return STATUS_SUCCESS;
    }

    Vcb = Fcb->Vcb;

    //
    //  Clean up any CCB associated with this open.
    //

    if (Ccb != NULL) {

        UserReference = 1;

        //
        //  Was a FSCTL_DISMOUNT issued on this handle?  If so,  we need to
        //  force a dismount of the volume now.
        //
        
        ForceDismount = BooleanFlagOn( Ccb->Flags, CCB_FLAG_DISMOUNT_ON_CLOSE);

        //
        //  We can always deallocate the Ccb if present.
        //

        UdfDeleteCcb( IrpContext, Ccb );
    }

    //
    //  If this is the last reference to a user file or directory on a 
    //  currently mounted volume, then post it to the delayed close queue.  Note
    //  that the VcbCondition check is unsafe,  but it doesn't really matter -
    //  we just might delay the volume teardown a little by posting this close.
    //

    if ((Vcb->VcbCondition == VcbMounted) &&
        (Fcb->FcbReference == 1) &&
        ((TypeOfOpen == UserFileOpen) ||
         (TypeOfOpen == UserDirectoryOpen))) {

        UdfQueueClose( IrpContext, Fcb, UserReference, TRUE );
        IrpContext = NULL;

    //
    //  Otherwise try to process this close.  Post to the async close queue
    //  if we can't acquire all of the resources.
    //

    } else {

        //
        //  If we may be dismounting this volume then acquire the UdfData
        //  resource.
        //
        //  Since we now must make volumes go away as soon as reasonable after
        //  the last user handles closes, key off of the cleanup count.  It is
        //  OK to do this more than neccesary.  Since this Fcb could be holding
        //  a number of other Fcbs (and thus their references), a simple check
        //  on reference count is not appropriate.
        //
        //  Do an unsafe check first to avoid taking the (global) udfdata lock in the 
        //  common case.
        //

        if (((Vcb->VcbCleanup == 0) || ForceDismount) &&
            (Vcb->VcbCondition != VcbMounted))  {

            //
            //  Possible.  Acquire UdfData to synchronise with the remount path,  and
            //  then repeat the tests.
            //
            //  Note that we must send the notification outside of any locks,  since 
            //  the worker that processes the notify could also be calling into our 
            //  pnp path which wants both UdfData and VcbResource.  For a force dismount
            //  the volume will be marked invalid (no going back),  so we will definitely
            //  go ahead and dismount below.
            //
            
            if (ForceDismount)  {

                //
                //  Send notification.
                //
                
                FsRtlNotifyVolumeEvent( IoGetCurrentIrpStackLocation( Irp )->FileObject, 
                                        FSRTL_VOLUME_DISMOUNT );
            }

            //
            //  Possible.  Acquire UdfData to synchronise with the remount path
            //  before looking at the vcb condition again.
            //
            
            UdfAcquireUdfData( IrpContext );

            if (((Vcb->VcbCleanup == 0) || ForceDismount) &&
                (Vcb->VcbCondition != VcbMounted) &&
                (Vcb->VcbCondition != VcbMountInProgress) &&
                FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_TOP_LEVEL_UDFS )) {

                PotentialVcbTeardown = TRUE;
            }
            else {

                //
                //  We can't dismount this volume now,  there are other references or
                //  it's just been remounted.
                //

                UdfReleaseUdfData( IrpContext);
            }
        }

        if (ForceDismount)  {

            //
            //  Physically disconnect this Vcb from the device so a new mount can
            //  occur.  Vcb deletion cannot happen at this time since there is
            //  a handle on it associated with this very request,  but we'll call
            //  check for dismount again later anyway.
            //

            UdfCheckForDismount( IrpContext, Vcb, TRUE );
        }

        //
        //  Call the worker routine to perform the actual work.  This routine
        //  should never raise except for a fatal error.
        //

        if (!UdfCommonClosePrivate( IrpContext, Vcb, Fcb, UserReference, TRUE )) {

            //
            //  If we didn't complete the request then post the request as needed.
            //

            UdfQueueClose( IrpContext, Fcb, UserReference, FALSE );
            IrpContext = NULL;

        //
        //  Check whether we should be dismounting the volume and then complete
        //  the request.
        //

        } else if (PotentialVcbTeardown) {

            UdfCheckForDismount( IrpContext, Vcb, FALSE );
        }
    }

    //
    //  Always complete this request with STATUS_SUCCESS.
    //

    UdfCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );

    if (PotentialVcbTeardown) {

        UdfReleaseUdfData( IrpContext );
    }

    //
    //  Always return STATUS_SUCCESS for closes.
    //

    return STATUS_SUCCESS;
}


//
//  Local support routine
//

BOOLEAN
UdfCommonClosePrivate (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFCB Fcb,
    IN ULONG UserReference,
    IN BOOLEAN FromFsd
    )

/*++

Routine Description:

    This is the worker routine for the close operation.  We can be called in
    an Fsd thread or from a worker Fsp thread.  If called from the Fsd thread
    then we acquire the resources without waiting.  Otherwise we know it is
    safe to wait.

    We check to see whether we should post this request to the delayed close
    queue.  If we are to process the close here then we acquire the Vcb and
    Fcb.  We will adjust the counts and call our teardown routine to see
    if any of the structures should go away.

Arguments:

    Vcb - Vcb for this volume.

    Fcb - Fcb for this request.

    UserReference - Number of user references for this file object.  This is
        zero for an internal stream.

    FromFsd - This request was called from an Fsd thread.  Indicates whether
        we should wait to acquire resources.

Return Value:

    BOOLEAN - TRUE if this thread processed the close, FALSE otherwise.

--*/

{
    BOOLEAN CompletedClose;
    BOOLEAN RemovedFcb;

    PAGED_CODE();

    //
    //  Check inputs.
    //
    
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );
    ASSERT_FCB( Fcb );

    //
    //  Try to acquire the Vcb and Fcb.  If we can't acquire them then return
    //  and let our caller know he should post the request to the async
    //  queue.
    //

    if (UdfAcquireVcbShared( IrpContext, Vcb, FromFsd )) {

        if (!UdfAcquireFcbExclusive( IrpContext, Fcb, FromFsd )) {

            //
            //  We couldn't get the Fcb.  Release the Vcb and let our caller
            //  know to post this request.
            //

            UdfReleaseVcb( IrpContext, Vcb );
            return FALSE;
        }

    //
    //  We didn't get the Vcb.  Let our caller know to post this request.
    //

    } else {

        return FALSE;
    }

    //
    //  Lock the Vcb and decrement the reference counts.
    //

    UdfLockVcb( IrpContext, Vcb );
    
    DebugTrace(( +1, Dbg,
                 "UdfCommonClosePrivate, Fcb %08x %4s Vcb %d/%d Fcb %d/%d\n", Fcb,
                 ( UserReference? "USER" : "SYS" ),
                 Vcb->VcbReference,
                 Vcb->VcbUserReference,
                 Fcb->FcbReference,
                 Fcb->FcbUserReference ));

    UdfDecrementReferenceCounts( IrpContext, Fcb, 1, UserReference );

    DebugTrace(( +0, Dbg,
                 "UdfCommonClosePrivate, Vcb %d/%d Fcb %d/%d\n",
                 Vcb->VcbReference,
                 Vcb->VcbUserReference,
                 Fcb->FcbReference,
                 Fcb->FcbUserReference ));

    UdfUnlockVcb( IrpContext, Vcb );

    //
    //  Call our teardown routine to see if this object can go away.
    //  If we don't remove the Fcb then release it.
    //

    UdfTeardownStructures( IrpContext, Fcb, FALSE, &RemovedFcb );

    if (!RemovedFcb) {

        UdfReleaseFcb( IrpContext, Fcb );
    }

    DebugTrace(( -1, Dbg,
                 "UdfCommonClosePrivate, RemovedFcb %08x -> %c\n",
                 Fcb,
                 ( RemovedFcb? 'T' : 'F' )));

    //
    //  Release the Vcb and return to our caller.  Let him know we completed
    //  this request.
    //

    UdfReleaseVcb( IrpContext, Vcb );

    return TRUE;
}


VOID
UdfQueueClose (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG UserReference,
    IN BOOLEAN DelayedClose
    )

/*++

Routine Description:

    This routine is called to queue a request to either the async or delayed
    close queue.  For the delayed queue we need to allocate a smaller
    structure to contain the information about the file object.  We do
    that so we don't put the larger IrpContext structures into this long
    lived queue.  If we can allocate this structure then we put this
    on the async queue instead.

Arguments:

    Fcb - Fcb for this file object.

    UserReference - Number of user references for this file object.  This is
        zero for an internal stream.

    DelayedClose - Indicates whether this should go on the async or delayed
        close queue.

Return Value:

    None

--*/

{
    PIRP_CONTEXT_LITE IrpContextLite = NULL;
    BOOLEAN StartWorker = FALSE;

    PAGED_CODE();

    //
    //  Check inputs.
    //
    
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    //
    //  Start with the delayed queue request.  We can move this to the async
    //  queue if there is an allocation failure.
    //

    if (DelayedClose) {

        //
        //  Try to allocate non-paged pool for the IRP_CONTEXT_LITE.
        //

        IrpContextLite = UdfCreateIrpContextLite( IrpContext );
    }

    //
    //  We want to clear the top level context in this thread if
    //  necessary.  Call our cleanup routine to do the work.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_MORE_PROCESSING );
    UdfCleanupIrpContext( IrpContext, TRUE );

    //
    //  Synchronize with the UdfData lock.
    //

    UdfLockUdfData();

    DebugTrace(( +1, Dbg,
                 "UdfQueueClose, Fcb %08x %4s %5s\n",
                 Fcb,
                 ( UserReference? "USER" : "SYS" ),
                 ( IrpContextLite? "DELAY" : "ASYNC" )));


    //
    //  If we have an IrpContext then put the request on the delayed close queue.
    //

    if (IrpContextLite != NULL) {

        //
        //  Initialize the IrpContextLite.
        //

        IrpContextLite->NodeTypeCode = UDFS_NTC_IRP_CONTEXT_LITE;
        IrpContextLite->NodeByteSize = sizeof( IRP_CONTEXT_LITE );
        IrpContextLite->Fcb = Fcb;
        IrpContextLite->UserReference = UserReference;
        IrpContextLite->RealDevice = IrpContext->RealDevice;

        //
        //  Add this to the delayed close list and increment
        //  the count.
        //

        InsertTailList( &UdfData.DelayedCloseQueue,
                        &IrpContextLite->DelayedCloseLinks );

        UdfData.DelayedCloseCount += 1;

        //
        //  If we are above our threshold then start the delayed
        //  close operation.
        //

        if (UdfData.DelayedCloseCount > UdfData.MaxDelayedCloseCount) {

            UdfData.ReduceDelayedClose = TRUE;

            if (!UdfData.FspCloseActive) {

                UdfData.FspCloseActive = TRUE;
                StartWorker = TRUE;
            }
        }

        //
        //  Unlock the global data.
        //

        UdfUnlockUdfData();

        //
        //  Cleanup the IrpContext.
        //

        UdfCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

    //
    //  Otherwise drop into the async case below.
    //

    } else {

        //
        //  Store the information about the file object into the IrpContext.
        //

        IrpContext->Irp = (PIRP) Fcb;
        IrpContext->ExceptionStatus = (NTSTATUS) UserReference;

        //
        //  Add this to the async close list and increment the count.
        //

        InsertTailList( &UdfData.AsyncCloseQueue,
                        &IrpContext->WorkQueueItem.List );

        UdfData.AsyncCloseCount += 1;

        //
        //  Remember to start the Fsp close thread if not currently started.
        //

        if (!UdfData.FspCloseActive) {

            UdfData.FspCloseActive = TRUE;
            StartWorker = TRUE;
        }

        //
        //  Unlock the global data.
        //

        UdfUnlockUdfData();
    }

    //
    //  Start the FspClose thread if we need to.
    //

    if (StartWorker) {

        ExQueueWorkItem( &UdfData.CloseItem, CriticalWorkQueue );
    }

    DebugTrace(( -1, Dbg, "UdfQueueClose -> VOID\n" ));

    //
    //  Return to our caller.
    //

    return;
}


//
//  Local support routine
//

PIRP_CONTEXT
UdfRemoveClose (
    IN PVCB Vcb OPTIONAL
    )

/*++

Routine Description:

Arguments:

    This routine is called to scan the async and delayed close queues looking
    for a suitable entry.  If the Vcb is specified then we scan both queues
    looking for an entry with the same Vcb.  Otherwise we will look in the
    async queue first for any close item.  If none found there then we look
    in the delayed close queue provided that we have triggered the delayed
    close operation.

Return Value:

    PIRP_CONTEXT - NULL if no work item found.  Otherwise it is the pointer to
        either the IrpContext or IrpContextLite for this request.

--*/

{
    PIRP_CONTEXT IrpContext = NULL;
    PIRP_CONTEXT NextIrpContext;
    PIRP_CONTEXT_LITE NextIrpContextLite;

    PLIST_ENTRY Entry;

    PAGED_CODE();

    ASSERT_OPTIONAL_VCB( Vcb );

    //
    //  Lock the UdfData to perform the scan.
    //

    UdfLockUdfData();

    //
    //  First check the list of async closes.
    //

    Entry = UdfData.AsyncCloseQueue.Flink;

    while (Entry != &UdfData.AsyncCloseQueue) {

        //
        //  Extract the IrpContext.
        //

        NextIrpContext = CONTAINING_RECORD( Entry,
                                            IRP_CONTEXT,
                                            WorkQueueItem.List );

        //
        //  If no Vcb was specified or this Vcb is for our volume
        //  then perform the close.
        //

        if (!ARGUMENT_PRESENT( Vcb ) || (NextIrpContext->Vcb == Vcb)) {

            RemoveEntryList( Entry );
            UdfData.AsyncCloseCount -= 1;

            IrpContext = NextIrpContext;
            break;
        }

        //
        //  Move to the next entry.
        //

        Entry = Entry->Flink;
    }

    //
    //  If we didn't find anything look through the delayed close
    //  queue.
    //
    //  We will only check the delayed close queue if we were given
    //  a Vcb or the delayed close operation is active.
    //

    if ((IrpContext == NULL) &&
        (ARGUMENT_PRESENT( Vcb ) ||
         (UdfData.ReduceDelayedClose &&
          (UdfData.DelayedCloseCount > UdfData.MinDelayedCloseCount)))) {

        Entry = UdfData.DelayedCloseQueue.Flink;

        while (Entry != &UdfData.DelayedCloseQueue) {

            //
            //  Extract the IrpContext.
            //

            NextIrpContextLite = CONTAINING_RECORD( Entry,
                                                    IRP_CONTEXT_LITE,
                                                    DelayedCloseLinks );

            //
            //  If no Vcb was specified or this Vcb is for our volume
            //  then perform the close.
            //

            if (!ARGUMENT_PRESENT( Vcb ) || (NextIrpContextLite->Fcb->Vcb == Vcb)) {

                RemoveEntryList( Entry );
                UdfData.DelayedCloseCount -= 1;

                IrpContext = (PIRP_CONTEXT) NextIrpContextLite;
                break;
            }

            //
            //  Move to the next entry.
            //

            Entry = Entry->Flink;
        }
    }

    //
    //  If the Vcb wasn't specified and we couldn't find an entry
    //  then turn off the Fsp thread.
    //

    if (!ARGUMENT_PRESENT( Vcb ) && (IrpContext == NULL)) {

        UdfData.FspCloseActive = FALSE;
        UdfData.ReduceDelayedClose = FALSE;
    }

    //
    //  Unlock the global data.
    //

    UdfUnlockUdfData();

    return IrpContext;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\udfs\dirctrl.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    DirCtrl.c

Abstract:

    This module implements the File Directory Control routines for Udfs called
    by the Fsd/Fsp dispatch drivers.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]     27-Nov-1996

Revision History:

    Tom Jolly       [TomJolly]   1-March-2000   UDF 2.01 support
    
// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_DIRCTRL)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_DIRCTRL)

//
//  Local structures
//

//
//  The following is used for the more complete enumeration required in the DirectoryControl path
//  and encapsulates the structures for enumerating both directories and ICBs, as well as converted
//  data from the ICB.
//

typedef struct _COMPOUND_DIR_ENUM_CONTEXT {

    //
    //  Standard enumeration contexts.  For this enumeration we walk the directory and lift the
    //  associated ICB for each entry.
    //
    
    DIR_ENUM_CONTEXT DirContext;
    ICB_SEARCH_CONTEXT IcbContext;

    //
    //  Timestamps converted from the ICB into NT-native form.
    //

    TIMESTAMP_BUNDLE Timestamps;

    //
    //  File index corresponding to the current position in the enumeration.
    //

    LARGE_INTEGER FileIndex;

} COMPOUND_DIR_ENUM_CONTEXT, *PCOMPOUND_DIR_ENUM_CONTEXT;

//
//  Local macros
//

//
//  Constants defining the space of FileIndices for directory enumeration.
//

//
//  The virtual (synthesized) file indices
//

#define UDF_FILE_INDEX_VIRTUAL_SELF         0

//
//  The file index where the physical directory entries begin
//

#define UDF_FILE_INDEX_PHYSICAL             1

//
//  Provide initialization and cleanup for compound enumeration contexts.
//

INLINE
VOID
UdfInitializeCompoundDirContext (
    IN PIRP_CONTEXT IrpContext,
    IN PCOMPOUND_DIR_ENUM_CONTEXT CompoundDirContext
    )
{

    UdfInitializeDirContext( IrpContext, &CompoundDirContext->DirContext );
    UdfFastInitializeIcbContext( IrpContext, &CompoundDirContext->IcbContext );

    RtlZeroMemory( &CompoundDirContext->Timestamps, sizeof( TIMESTAMP_BUNDLE ));

    CompoundDirContext->FileIndex.QuadPart = 0;
}

INLINE
VOID
UdfCleanupCompoundDirContext (
    IN PIRP_CONTEXT IrpContext,
    IN PCOMPOUND_DIR_ENUM_CONTEXT CompoundDirContext
    )
{

    UdfCleanupDirContext( IrpContext, &CompoundDirContext->DirContext );
    UdfCleanupIcbContext( IrpContext, &CompoundDirContext->IcbContext );
}

//
//  UDF directories are unsorted (UDF 1.0.1 2.3.5.3) and do not contain self
//  entries.  For directory enumeration we must provide a way for a restart to
//  occur at a random entry (SL_INDEX_SPECIFIED), but the key used is only
//  32bits.  Since the directory is unsorted, the filename is unsuitable for
//  quickly finding a restart point (even assuming that it was sorted,
//  discovering a directory entry is still not fast).  Additionally, we must
//  synthesize the self-entry.  So, here is how we map the space of file
//  indices to directory entries:
//
//    File Index              Directory Entry
//  
//    0                       self ('.')
//    1                       at byte offset 0 in the stream
//    N                       at byte offset N-1 in the stream
//  
//  The highest 32bit FileIndex returned will be stashed in the Ccb.
//  
//  For FileIndex > 2^32, we will return FileIndex 0 in the query structure.
//  On a restart, we will notice a FileIndex of zero and use the saved high
//  32bit FileIndex as the starting point for a linear scan to find the named
//  directory entry in the restart request.  In this way we only penalize the
//  improbable case of a directory stream > 2^32 bytes.
//
//  The following inline routines assist with this mapping.
//

INLINE
LONGLONG
UdfFileIndexToPhysicalOffset(
    LONGLONG FileIndex
    )
{

    return FileIndex - UDF_FILE_INDEX_PHYSICAL;
}

INLINE
LONGLONG
UdfPhysicalOffsetToFileIndex(
    LONGLONG PhysicalOffset
    )
{

    return PhysicalOffset + UDF_FILE_INDEX_PHYSICAL;
}

INLINE
BOOLEAN
UdfIsFileIndexVirtual(
   LONGLONG FileIndex
   )
{

    return FileIndex < UDF_FILE_INDEX_PHYSICAL;
}

//
//  Local support routines
//

NTSTATUS
UdfQueryDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PFCB Fcb,
    IN PCCB Ccb
    );

NTSTATUS
UdfNotifyChangeDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PCCB Ccb
    );

NTSTATUS
UdfInitializeEnumeration (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN PFCB Fcb,
    IN OUT PCCB Ccb,
    IN OUT PCOMPOUND_DIR_ENUM_CONTEXT CompoundDirContext,
    OUT PBOOLEAN ReturnNextEntry,
    OUT PBOOLEAN ReturnSingleEntry,
    OUT PBOOLEAN InitialQuery
    );

BOOLEAN
UdfEnumerateIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PCCB Ccb,
    IN OUT PCOMPOUND_DIR_ENUM_CONTEXT CompoundDirContext,
    IN BOOLEAN ReturnNextEntry
    );

VOID
UdfLookupFileEntryInEnumeration (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCOMPOUND_DIR_ENUM_CONTEXT CompoundDirContext
    );

BOOLEAN
UdfLookupInitialFileIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCOMPOUND_DIR_ENUM_CONTEXT CompoundDirContext,
    IN PLONGLONG InitialIndex
    );

BOOLEAN
UdfLookupNextFileIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCOMPOUND_DIR_ENUM_CONTEXT CompoundDirContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfCommonDirControl)
#pragma alloc_text(PAGE, UdfEnumerateIndex)
#pragma alloc_text(PAGE, UdfInitializeEnumeration)
#pragma alloc_text(PAGE, UdfLookupFileEntryInEnumeration)
#pragma alloc_text(PAGE, UdfLookupInitialFileIndex)
#pragma alloc_text(PAGE, UdfLookupNextFileIndex)
#pragma alloc_text(PAGE, UdfNotifyChangeDirectory)
#pragma alloc_text(PAGE, UdfQueryDirectory)
#endif


NTSTATUS
UdfCommonDirControl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the entry point for the directory control operations.  These
    are directory enumerations and directory notify calls.  We verify the
    user's handle is for a directory and then call the appropriate routine.

Arguments:

    Irp - Irp for this request.

Return Value:

    NTSTATUS - Status returned from the lower level routines.

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PFCB Fcb;
    PCCB Ccb;

    PAGED_CODE();

    //
    //  Decode the user file object and fail this request if it is not
    //  a user directory.
    //

    if (UdfDecodeFileObject( IrpSp->FileObject,
                             &Fcb,
                             &Ccb ) != UserDirectoryOpen) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  We know this is a directory control so we'll case on the
    //  minor function, and call a internal worker routine to complete
    //  the irp.
    //

    switch (IrpSp->MinorFunction) {

    case IRP_MN_QUERY_DIRECTORY:

        Status = UdfQueryDirectory( IrpContext, Irp, IrpSp, Fcb, Ccb );
        break;

    case IRP_MN_NOTIFY_CHANGE_DIRECTORY:

        Status = UdfNotifyChangeDirectory( IrpContext, Irp, IrpSp, Ccb );
        break;

    default:

        UdfCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );
        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    return Status;
}


//
//  Local support routines
//

NTSTATUS
UdfQueryDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PFCB Fcb,
    IN PCCB Ccb
    )

/*++

Routine Description:

    This routine performs the query directory operation.  It is responsible
    for either completing of enqueuing the input Irp.  We store the state of the
    search in the Ccb.

Arguments:

    Irp - Supplies the Irp to process

    IrpSp - Stack location for this Irp.

    Fcb - Fcb for this directory.

    Ccb - Ccb for this directory open.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Information = 0;

    ULONG LastEntry = 0;
    ULONG NextEntry = 0;

    ULONG FileNameBytes;
    ULONG BytesConverted;

    LARGE_INTEGER PreviousFileIndex;

    COMPOUND_DIR_ENUM_CONTEXT CompoundDirContext;

    PNSR_FID ThisFid;
    PICBFILE ThisFe;
    
    BOOLEAN InitialQuery;
    BOOLEAN ReturnNextEntry;
    BOOLEAN ReturnSingleEntry;
    BOOLEAN Found;
    BOOLEAN EasCorrupt;

    PCHAR UserBuffer;
    ULONG BytesRemainingInBuffer;

    ULONG BaseLength;

    PFILE_BOTH_DIR_INFORMATION DirInfo;
    PFILE_NAMES_INFORMATION NamesInfo;
    PFILE_ID_FULL_DIR_INFORMATION IdFullDirInfo;
    PFILE_ID_BOTH_DIR_INFORMATION IdBothDirInfo;
    FILE_INFORMATION_CLASS InfoClass = IrpSp->Parameters.QueryDirectory.FileInformationClass;

    PAGED_CODE();

    DebugTrace(( 0, Dbg, "UdfQueryDirectory\n" ));
    
    //
    //  Check if we support this search mode.  Also remember the size of the base part of
    //  each of these structures.
    //

    switch ( InfoClass) {

    case FileDirectoryInformation:

        BaseLength = FIELD_OFFSET( FILE_DIRECTORY_INFORMATION,
                                   FileName[0] );
        break;

    case FileFullDirectoryInformation:

        BaseLength = FIELD_OFFSET( FILE_FULL_DIR_INFORMATION,
                                   FileName[0] );
        break;

    case FileIdFullDirectoryInformation:

        BaseLength = FIELD_OFFSET( FILE_ID_FULL_DIR_INFORMATION,
                                   FileName[0] );
        break;

    case FileNamesInformation:

        BaseLength = FIELD_OFFSET( FILE_NAMES_INFORMATION,
                                   FileName[0] );
        break;

    case FileBothDirectoryInformation:

        BaseLength = FIELD_OFFSET( FILE_BOTH_DIR_INFORMATION,
                                   FileName[0] );
        break;

    case FileIdBothDirectoryInformation:

        BaseLength = FIELD_OFFSET( FILE_ID_BOTH_DIR_INFORMATION,
                                   FileName[0] );
        break;

    default:

        UdfCompleteRequest( IrpContext, Irp, STATUS_INVALID_INFO_CLASS );
        return STATUS_INVALID_INFO_CLASS;
    }

    //
    //  Get the user buffer.
    //

    UdfMapUserBuffer( IrpContext, &UserBuffer);

    //
    //  Initialize our search context.
    //

    UdfInitializeCompoundDirContext( IrpContext, &CompoundDirContext );
    
    //
    //  Acquire the directory.
    //

    UdfAcquireFileShared( IrpContext, Fcb );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Verify the Fcb is still good.
        //

        UdfVerifyFcbOperation( IrpContext, Fcb );

        //
        //  Start by getting the initial state for the enumeration.  This will set up the Ccb with
        //  the initial search parameters and let us know the starting offset in the directory
        //  to search.
        //

        Status = UdfInitializeEnumeration( IrpContext,
                                           IrpSp,
                                           Fcb,
                                           Ccb,
                                           &CompoundDirContext,
                                           &ReturnNextEntry,
                                           &ReturnSingleEntry,
                                           &InitialQuery );
        if (!NT_SUCCESS( Status )) {

            try_leave( Status );
        }


        //
        //  At this point we are about to enter our query loop.  We have
        //  determined the index into the directory file to begin the
        //  search.  LastEntry and NextEntry are used to index into the user
        //  buffer.  LastEntry is the last entry we've added, NextEntry is
        //  current one we're working on.  If NextEntry is non-zero, then
        //  at least one entry was added.
        //

        while (TRUE) {

            //
            //  If the user had requested only a single match and we have
            //  returned that, then we stop at this point.  We update the Ccb with
            //  the status based on the last entry returned.
            //

            if ((NextEntry != 0) && ReturnSingleEntry) {

                try_leave( Status );
            }

            //
            //  We try to locate the next matching dirent.  Our search if based on a starting
            //  dirent offset, whether we should return the current or next entry, whether
            //  we should be doing a short name search and finally whether we should be
            //  checking for a version match.
            //

            PreviousFileIndex = CompoundDirContext.FileIndex;
            
            try {
            
                Found = UdfEnumerateIndex( IrpContext, Ccb, &CompoundDirContext, ReturnNextEntry );
            }
            except (((0 != NextEntry) && 
                     ((GetExceptionCode() == STATUS_FILE_CORRUPT_ERROR) || 
                      (GetExceptionCode() == STATUS_CRC_ERROR)))
                     ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)  {

                DebugTrace((0, Dbg, "UdfQueryDirectory - Corrupt. Returning buffer so far,  setting back enumeration\n"));
                
                //
                //  We encountered corruption in the directory.  We will swallow this 
                //  error since we have already placed some previous entries in the user 
                //  buffer,  and raise it when we're called again.  This is
                //  to return as much as possible in the case of corrupt directories, 
                //  particularly discs which are padded wrong at the end of the dir.
                //

                ReturnNextEntry = TRUE;

                //
                //  Point to the previous Fid,  so that we will advance again to the point
                //  of corruption on next call (we only do bounds checking on advance,  not 
                //  when restarting *at* a particular entry).
                //

                CompoundDirContext.FileIndex = PreviousFileIndex;

                try_leave( Status = STATUS_SUCCESS);
            }

            //
            //  Initialize the value for the next search.
            //

            ReturnNextEntry = TRUE;

            //
            //  If we didn't receive a dirent, then we are at the end of the
            //  directory.  If we have returned any files, we exit with
            //  success, otherwise we return STATUS_NO_MORE_FILES.
            //

            if (!Found) {

                if (NextEntry == 0) {

                    Status = STATUS_NO_MORE_FILES;

                    if (InitialQuery) {

                        Status = STATUS_NO_SUCH_FILE;
                    }
                }

                try_leave( Status );
            }

            //
            //  Remember the dirent/file entry for the file we just found.
            //

            ThisFid = CompoundDirContext.DirContext.Fid;

            //
            //  Here are the rules concerning filling up the buffer:
            //
            //  1.  The Io system garentees that there will always be
            //      enough room for at least one base record.
            //
            //  2.  If the full first record (including file name) cannot
            //      fit, as much of the name as possible is copied and
            //      STATUS_BUFFER_OVERFLOW is returned.
            //
            //  3.  If a subsequent record cannot completely fit into the
            //      buffer, none of it (as in 0 bytes) is copied, and
            //      STATUS_SUCCESS is returned.  A subsequent query will
            //      pick up with this record.
            //

            //
            //  We can look directly at the dirent that we found.
            //

            FileNameBytes = CompoundDirContext.DirContext.CaseObjectName.Length;

            //
            //  If the slot for the next entry would be beyond the length of the
            //  user's buffer just exit (we know we've returned at least one entry
            //  already). This will happen when we align the pointer past the end.
            //

            if (NextEntry > IrpSp->Parameters.QueryDirectory.Length) {
                
                ReturnNextEntry = FALSE;
                try_leave( Status = STATUS_SUCCESS );
            }

            //
            //  Compute the number of bytes remaining in the buffer.  Round this
            //  down to a WCHAR boundary so we can copy full characters.
            //

            BytesRemainingInBuffer = IrpSp->Parameters.QueryDirectory.Length - NextEntry;
            ClearFlag( BytesRemainingInBuffer, 1 );

            //
            //  If this won't fit and we have returned a previous entry then just
            //  return STATUS_SUCCESS.
            //

            if ((BaseLength + FileNameBytes) > BytesRemainingInBuffer) {

                //
                //  If we already found an entry then just exit.
                //

                if (NextEntry != 0) {

                    ReturnNextEntry = FALSE;
                    try_leave( Status = STATUS_SUCCESS );
                }

                //
                //  Reduce the FileNameBytes to just fit in the buffer.
                //

                FileNameBytes = BytesRemainingInBuffer - BaseLength;

                //
                //  Use a status code of STATUS_BUFFER_OVERFLOW.  Also set
                //  ReturnSingleEntry so that we will exit the loop at the top.
                //

                Status = STATUS_BUFFER_OVERFLOW;
                ReturnSingleEntry = TRUE;
            }

            //
            //  Zero and initialize the base part of the current entry.
            //

            SafeZeroMemory( IrpContext, Add2Ptr( UserBuffer, NextEntry, PVOID ), BaseLength );

            //
            //  Most query types require that we lookup the FE referenced by the FID
            //  to extract attribute information.  Do this outside the user buffer exception 
            //  handler block to avoid the risk of masking real driver errors.
            //

            EasCorrupt = FALSE;
            ThisFe = NULL;

            if (InfoClass != FileNamesInformation) {

                //
                //  We will swallow certain corruption errors here in the interest of
                //  allowing users to access other objects in the directory.  The
                //  errors will be reported later if the user attempts to open the corrupt 
                //  object.
                //

                try {

                    UdfLookupFileEntryInEnumeration( IrpContext,
                                                     Fcb,
                                                     &CompoundDirContext );
                    //
                    //  Directly reference the file entry we just looked up.
                    //
                    
                    ThisFe = (PICBFILE) CompoundDirContext.IcbContext.Active.View;
                    
                    //
                    //  Now go gather all of the timestamps for this guy.
                    //
                    
                    UdfUpdateTimestampsFromIcbContext ( IrpContext,
                                                        &CompoundDirContext.IcbContext,
                                                        &CompoundDirContext.Timestamps );
                }
                except (UdfQueryDirExceptionFilter( GetExceptionInformation()))  {

                    //
                    //  The currently mapped ICB will have been left in IcbContext->Current,
                    //  and we could look at it and pull out timestamps / filesizes,
                    //  but it could be complete trash,  so we'll just zero these fields 
                    //  in this dir record.
                    //

                    DebugTrace(( 0, Dbg, "Ignoring corrupt FE (referenced by FID in dir FCB 0x%p) during dir enum\n",  Fcb));

                    //
                    //  We either failed verification of the core FE fields,  or looking
                    //  up the EAs for timestamps.  Either way,  the EAs are definitely dead
                    //  which means the create time is invalid
                    //

                    EasCorrupt = TRUE;

                    IrpContext->ExceptionStatus = STATUS_SUCCESS;
                }
            }            
            
            //
            //  Protect access to the user buffer with an exception handler.
            //  Since (at our request) IO doesn't buffer these requests, we have
            //  to guard against a user messing with the page protection and other
            //  such trickery.
            //

            try {
    
                //
                //  Now we have an entry to return to our caller. We'll case on the type of 
                //  information requested and fill up the user buffer if everything fits.
                //
    
                switch (InfoClass) {
    
                case FileBothDirectoryInformation:
                case FileFullDirectoryInformation:
                case FileIdBothDirectoryInformation:
                case FileIdFullDirectoryInformation:
                case FileDirectoryInformation:
    
                    DirInfo = Add2Ptr( UserBuffer, NextEntry, PFILE_BOTH_DIR_INFORMATION );

                    //
                    //  We should already have looked up the FE,  unless it was corrupt. If we 
                    //  actually have an FE here that means that the core content verified ok,  
                    //  so pull out the relevant information.
                    //

                    if (NULL != ThisFe)  {                    

                        DirInfo->LastWriteTime =
                        DirInfo->ChangeTime = CompoundDirContext.Timestamps.ModificationTime;
        
                        DirInfo->LastAccessTime = CompoundDirContext.Timestamps.AccessTime;
        
                        if (!EasCorrupt)  {

                            DirInfo->CreationTime = CompoundDirContext.Timestamps.CreationTime;
                        }
                        else {
                        
                            DirInfo->CreationTime = UdfCorruptFileTime;
                        }

                        //
                        //  Set the attributes and sizes separately for directories and
                        //  files.
                        //
        
                        if (ThisFe->Icbtag.FileType == ICBTAG_FILE_T_DIRECTORY) {
        
                            DirInfo->EndOfFile.QuadPart = DirInfo->AllocationSize.QuadPart = 0;
        
                            SetFlag( DirInfo->FileAttributes, FILE_ATTRIBUTE_DIRECTORY );
        
                        } else {
        
                            DirInfo->EndOfFile.QuadPart = ThisFe->InfoLength;
                            DirInfo->AllocationSize.QuadPart = LlBlockAlign( Fcb->Vcb, ThisFe->InfoLength );
                        }
                    }
                    else {

                        //
                        //  FE is corrupt.  Fill in arbirary but valid times.
                        //

                        DirInfo->CreationTime =
                        DirInfo->ChangeTime =
                        DirInfo->LastWriteTime =
                        DirInfo->LastAccessTime = UdfCorruptFileTime;
                    }
                    
                    //
                    //  All Cdrom files are readonly.  We also copy the existence
                    //  bit to the hidden attribute, assuming that synthesized FIDs
                    //  are never hidden.
                    //

                    SetFlag( DirInfo->FileAttributes, FILE_ATTRIBUTE_READONLY );
    
                    if (ThisFid && FlagOn( ThisFid->Flags, NSR_FID_F_HIDDEN )) {
    
                        SetFlag( DirInfo->FileAttributes, FILE_ATTRIBUTE_HIDDEN );
                    }

                    //
                    //  The file index for real file indices > 2^32 is zero.  When asked to
                    //  restart at an index of zero, we will know to use a stashed starting
                    //  point to beging to search, by name, for the correct restart point.
                    //
                    
                    if (CompoundDirContext.FileIndex.HighPart == 0) {
                        
                        DirInfo->FileIndex = CompoundDirContext.FileIndex.LowPart;
                    
                    } else {
    
                        DirInfo->FileIndex = 0;
                    }
    
                    DirInfo->FileNameLength = FileNameBytes;
    
                    break;
    
                case FileNamesInformation:
    
                    NamesInfo = Add2Ptr( UserBuffer, NextEntry, PFILE_NAMES_INFORMATION );
    
                    if (CompoundDirContext.FileIndex.HighPart == 0) {
                        
                        NamesInfo->FileIndex = CompoundDirContext.FileIndex.LowPart;
                    
                    } else {
    
                        NamesInfo->FileIndex = 0;
                    }
    
                    NamesInfo->FileNameLength = FileNameBytes;
    
                    break;
                }

                //
                //  Fill in the FileId
                //

                switch (InfoClass) {

                case FileIdBothDirectoryInformation:

                    IdBothDirInfo = Add2Ptr( UserBuffer, NextEntry, PFILE_ID_BOTH_DIR_INFORMATION );
                    UdfSetFidFromFidAndFe( IdBothDirInfo->FileId, ThisFid, ThisFe );
                    break;

                case FileIdFullDirectoryInformation:

                    IdFullDirInfo = Add2Ptr( UserBuffer, NextEntry, PFILE_ID_FULL_DIR_INFORMATION );
                    UdfSetFidFromFidAndFe( IdFullDirInfo->FileId, ThisFid, ThisFe );
                    break;

                default:
                    break;
                }
    
                //
                //  Now copy as much of the name as possible.
                //
    
                if (FileNameBytes != 0) {
    
                    //
                    //  This is a Unicode name, we can copy the bytes directly.
                    //
    
                    RtlCopyMemory( Add2Ptr( UserBuffer, NextEntry + BaseLength, PVOID ),
                                   CompoundDirContext.DirContext.ObjectName.Buffer,
                                   FileNameBytes );
                }

                //
                //  Fill in the short name if we got STATUS_SUCCESS.  The short name
                //  may already be in the file context, otherwise we will check
                //  whether the long name is 8.3.  Special case the self and parent
                //  directory names.
                //
    
                if ((Status == STATUS_SUCCESS) &&
                    (InfoClass == FileBothDirectoryInformation ||
                     InfoClass == FileIdBothDirectoryInformation) &&
                    FlagOn( CompoundDirContext.DirContext.Flags, DIR_CONTEXT_FLAG_SEEN_NONCONSTANT )) {
    
                    //
                    //  If we already have the short name then copy into the user's buffer.
                    //
    
                    if (CompoundDirContext.DirContext.ShortObjectName.Length != 0) {
    
                        RtlCopyMemory( DirInfo->ShortName,
                                       CompoundDirContext.DirContext.ShortObjectName.Buffer,
                                       CompoundDirContext.DirContext.ShortObjectName.Length );
    
                        DirInfo->ShortNameLength = (CCHAR) CompoundDirContext.DirContext.ShortObjectName.Length;
    
                    //
                    //  If the short name length is currently zero then check if
                    //  the long name is not 8.3.  We can copy the short name in
                    //  unicode form directly into the caller's buffer.
                    //
    
                    } else {
    
                        if (!UdfIs8dot3Name( IrpContext,
                                             CompoundDirContext.DirContext.ObjectName )) {
    
                            UNICODE_STRING ShortName;
    
                            ShortName.Buffer = DirInfo->ShortName;
                            ShortName.MaximumLength = BYTE_COUNT_8_DOT_3;
                            
                            UdfGenerate8dot3Name( IrpContext,
                                                  &CompoundDirContext.DirContext.PureObjectName,
                                                  &ShortName );
    
                            DirInfo->ShortNameLength = (CCHAR) ShortName.Length;
                        }
                    }
                }

                //
                //  Update the information with the number of bytes stored in the
                //  buffer.  We quad-align the existing buffer to add any necessary
                //  pad bytes.
                //

                Information = NextEntry + BaseLength + FileNameBytes;

                //
                //  Go back to the previous entry and fill in the update to this entry.
                //

                *(Add2Ptr( UserBuffer, LastEntry, PULONG )) = NextEntry - LastEntry;

                //
                //  Set up our variables for the next dirent.
                //

                InitialQuery = FALSE;

                LastEntry = NextEntry;
                NextEntry = QuadAlign( Information );
            
            } 
            except (!FsRtlIsNtstatusExpected(GetExceptionCode()) ?
                      EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {

                  //
                  //  We must have had a problem filling in the user's buffer, so stop
                  //  and fail this request.
                  //
                  
                  Information = 0;
                  try_leave( Status = GetExceptionCode());
            }
        }

    } 
    finally {

        if (!AbnormalTermination() && !NT_ERROR( Status )) {
        
            //
            //  Update the Ccb to show the current state of the enumeration.
            //
    
            UdfLockFcb( IrpContext, Fcb );
    
            Ccb->CurrentFileIndex = CompoundDirContext.FileIndex.QuadPart;

            //
            //  Update our notion of a high 32bit file index.  We only do this once to avoid the hit
            //  of thrashing the Fcb mutex to do this for every entry.  If it is ever neccesary to use
            //  this information, the difference of a few dozen entries from the optimal pick-up point
            //  will be trivial.
            //
            
            if (CompoundDirContext.FileIndex.HighPart == 0 &&
                CompoundDirContext.FileIndex.LowPart > Ccb->HighestReturnableFileIndex) {

                    Ccb->HighestReturnableFileIndex = CompoundDirContext.FileIndex.LowPart;
            }

            //
            //  Mark in the CCB whether or not to skip the current entry on next call
            //  (if we  returned it in the current buffer).
            //
                
            ClearFlag( Ccb->Flags, CCB_FLAG_ENUM_RETURN_NEXT );
    
            if (ReturnNextEntry) {
    
                SetFlag( Ccb->Flags, CCB_FLAG_ENUM_RETURN_NEXT );
            }
    
            UdfUnlockFcb( IrpContext, Fcb );
        }

        //
        //  Cleanup our search context.
        //

        UdfCleanupCompoundDirContext( IrpContext, &CompoundDirContext );

        //
        //  Release the Fcb.
        //

        UdfReleaseFile( IrpContext, Fcb );
    }

    DebugTrace(( 0, Dbg, "UdfQueryDirectory -> %x\n", Status ));
    
    //
    //  Complete the request here.
    //

    Irp->IoStatus.Information = Information;

    UdfCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


//
//  Local support routines
//

NTSTATUS
UdfNotifyChangeDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PCCB Ccb
    )

/*++

Routine Description:

    This routine performs the notify change directory operation.  It is
    responsible for either completing of enqueuing the input Irp.  Although there
    will never be a notify signalled on a readonly disk we still support this call.

    We have already checked that this is not an OpenById handle.

Arguments:

    Irp - Supplies the Irp to process

    IrpSp - Io stack location for this request.

    Ccb - Handle to the directory being watched.

Return Value:

    NTSTATUS - STATUS_PENDING, any other error will raise.

--*/

{
    PAGED_CODE();

    //
    //  Always set the wait bit in the IrpContext so the initial wait can't fail.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );

    //
    //  Acquire the Vcb shared.
    //

    UdfAcquireVcbShared( IrpContext, IrpContext->Vcb, FALSE );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Verify the Vcb.
        //

        UdfVerifyVcb( IrpContext, IrpContext->Vcb );

        //
        //  Call the Fsrtl package to process the request.  We cast the
        //  unicode strings to ansi strings as the dir notify package
        //  only deals with memory matching.
        //

        FsRtlNotifyFullChangeDirectory( IrpContext->Vcb->NotifySync,
                                        &IrpContext->Vcb->DirNotifyList,
                                        Ccb,
                                        (PSTRING) &IrpSp->FileObject->FileName,
                                        BooleanFlagOn( IrpSp->Flags, SL_WATCH_TREE ),
                                        FALSE,
                                        IrpSp->Parameters.NotifyDirectory.CompletionFilter,
                                        Irp,
                                        NULL,
                                        NULL );

    } finally {

        //
        //  Release the Vcb.
        //

        UdfReleaseVcb( IrpContext, IrpContext->Vcb );
    }

    //
    //  Cleanup the IrpContext.
    //

    UdfCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

    return STATUS_PENDING;
}


//
//  Local support routine
//

NTSTATUS
UdfInitializeEnumeration (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN PFCB Fcb,
    IN OUT PCCB Ccb,
    IN OUT PCOMPOUND_DIR_ENUM_CONTEXT CompoundDirContext,
    OUT PBOOLEAN ReturnNextEntry,
    OUT PBOOLEAN ReturnSingleEntry,
    OUT PBOOLEAN InitialQuery
    )

/*++

Routine Description:

    This routine is called to initialize the enumeration variables and structures.
    We look at the state of a previous enumeration from the Ccb as well as any
    input values from the user.  On exit we will position the DirContext at
    a file in the directory and let the caller know whether this entry or the
    next entry should be returned.

Arguments:

    IrpSp - Irp stack location for this request.

    Fcb - Fcb for this directory.

    Ccb - Ccb for the directory handle.

    CompoundDirContext - Context to use for this enumeration.

    ReturnNextEntry - Address to store whether we should return the entry at
        the context position or the next entry.

    ReturnSingleEntry - Address to store whether we should only return
        a single entry.

    InitialQuery - Address to store whether this is the first enumeration
        query on this handle.

Return Value:

    None.

--*/

{
    NTSTATUS Status;

    PUNICODE_STRING FileName;
    UNICODE_STRING SearchExpression;

    PUNICODE_STRING RestartName = NULL;
    
    ULONG CcbFlags;

    LONGLONG FileIndex;
    ULONG HighFileIndex;
    BOOLEAN KnownIndex;

    BOOLEAN Found;

    PAGED_CODE();

    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB_INDEX( Fcb );
    ASSERT_CCB( Ccb );

    //
    //  If this is the initial query then build a search expression from the input
    //  file name.
    //

    if (!FlagOn( Ccb->Flags, CCB_FLAG_ENUM_INITIALIZED )) {

        FileName = IrpSp->Parameters.QueryDirectory.FileName;

        CcbFlags = 0;

        //
        //  If the filename is not specified or is a single '*' then we will
        //  match all names.
        //

        if ((FileName == NULL) ||
            (FileName->Buffer == NULL) ||
            (FileName->Length == 0) ||
            ((FileName->Length == sizeof( WCHAR )) &&
             (FileName->Buffer[0] == L'*'))) {

            SetFlag( CcbFlags, CCB_FLAG_ENUM_MATCH_ALL );

            SearchExpression.Length =
            SearchExpression.MaximumLength = 0;
            SearchExpression.Buffer = NULL;

        //
        //  Otherwise build the name from the name in the stack location.
        //  This involves checking for wild card characters and upcasing the
        //  string if this is a case-insensitive search.
        //

        } else {

            //
            //  The name better have at least one character.
            //

            if (FileName->Length == 0) {

                UdfRaiseStatus( IrpContext, STATUS_INVALID_PARAMETER );
            }

            //
            //  Check for wildcards in the separate components.
            //

            if (FsRtlDoesNameContainWildCards( FileName)) {

                SetFlag( CcbFlags, CCB_FLAG_ENUM_NAME_EXP_HAS_WILD );
            }
            
            //
            //  Now create the search expression to store in the Ccb.
            //

            SearchExpression.Buffer = FsRtlAllocatePoolWithTag( UdfPagedPool,
                                                                FileName->Length,
                                                                TAG_ENUM_EXPRESSION );

            SearchExpression.MaximumLength = FileName->Length;

            //
            //  Either copy the name directly or perform the upcase.
            //

            if (FlagOn( Ccb->Flags, CCB_FLAG_IGNORE_CASE )) {

                Status = RtlUpcaseUnicodeString( &SearchExpression,
                                                 FileName,
                                                 FALSE );

                //
                //  This should never fail.
                //

                ASSERT( Status == STATUS_SUCCESS );

            } else {

                RtlCopyMemory( SearchExpression.Buffer,
                               FileName->Buffer,
                               FileName->Length );
            }

            SearchExpression.Length = FileName->Length;
        }

        //
        //  But we do not want to return the constant "." and ".." entries for
        //  the root directory, for consistency with the rest of Microsoft's
        //  filesystems.
        //

        if (Fcb == Fcb->Vcb->RootIndexFcb) {

            SetFlag( CcbFlags, CCB_FLAG_ENUM_NOMATCH_CONSTANT_ENTRY );
        }

        //
        //  Now lock the Fcb in order to update the Ccb with the inital
        //  enumeration values.
        //

        UdfLockFcb( IrpContext, Fcb );

        //
        //  Check again that this is the initial search.
        //

        if (!FlagOn( Ccb->Flags, CCB_FLAG_ENUM_INITIALIZED )) {

            //
            //  Update the values in the Ccb.
            //

            Ccb->CurrentFileIndex = 0;
            Ccb->SearchExpression = SearchExpression;

            //
            //  Set the appropriate flags in the Ccb.
            //

            SetFlag( Ccb->Flags, CcbFlags | CCB_FLAG_ENUM_INITIALIZED );

        //
        //  Otherwise cleanup any buffer allocated here.
        //

        } else {

            if (!FlagOn( CcbFlags, CCB_FLAG_ENUM_MATCH_ALL )) {

                UdfFreePool( &SearchExpression.Buffer );
            }
        }

    //
    //  Otherwise lock the Fcb so we can read the current enumeration values.
    //

    } else {

        UdfLockFcb( IrpContext, Fcb );
    }

    //
    //  Capture the current state of the enumeration.
    //
    //  If the user specified an index then use his offset.  We always
    //  return the next entry in this case.  If  no name is specified,
    //  then we can't perform the restart.
    //

    if (FlagOn( IrpSp->Flags, SL_INDEX_SPECIFIED ) &&
        IrpSp->Parameters.QueryDirectory.FileName != NULL) {

        KnownIndex = FALSE;
        FileIndex = IrpSp->Parameters.QueryDirectory.FileIndex;
        RestartName = IrpSp->Parameters.QueryDirectory.FileName;
        *ReturnNextEntry = TRUE;

        //
        //  We will use the highest file index reportable to the caller as a
        //  starting point as required if we cannot directly land at the
        //  specified location.
        //
        
        HighFileIndex = Ccb->HighestReturnableFileIndex;

    //
    //  If we are restarting the scan then go from the self entry.
    //

    } else if (FlagOn( IrpSp->Flags, SL_RESTART_SCAN )) {

        KnownIndex = TRUE;
        FileIndex = 0;
        *ReturnNextEntry = FALSE;

    //
    //  Otherwise use the values from the Ccb.
    //

    } else {

        KnownIndex = TRUE;
        FileIndex = Ccb->CurrentFileIndex;
        *ReturnNextEntry = BooleanFlagOn( Ccb->Flags, CCB_FLAG_ENUM_RETURN_NEXT );
    }

    //
    //  Unlock the Fcb.
    //

    UdfUnlockFcb( IrpContext, Fcb );

    //
    //  We have the starting offset in the directory and whether to return
    //  that entry or the next.  If we are at the beginning of the directory
    //  and are returning that entry, then tell our caller this is the
    //  initial query.
    //

    *InitialQuery = FALSE;

    if ((FileIndex == 0) &&
        !(*ReturnNextEntry)) {

        *InitialQuery = TRUE;
    }

    //
    //  Determine the offset in the stream to position the context and
    //  whether this offset is known to be a file offset.
    //
    //  If this offset is known to be safe then go ahead and position the
    //  context.  This handles the cases where the offset is the beginning
    //  of the stream, the offset is from a previous search or this is the
    //  initial query.
    //

    if (KnownIndex) {

        Found = UdfLookupInitialFileIndex( IrpContext, Fcb, CompoundDirContext, &FileIndex );

        ASSERT( Found );

        //
        //  Avoid a raise in UdfUpdateDirNames if we're re-starting from a CCB index
        //  after the parent entry,  but in a new call to querydirectory (new DirContext)
        //
        
        if (1 <= FileIndex)  {
        
            SetFlag( CompoundDirContext->DirContext.Flags, DIR_CONTEXT_FLAG_SEEN_PARENT );
        }
        
    //
    //  Try to directly jump to the specified file index.  Otherwise we walk through
    //  the directory from the beginning (or the saved highest known offset if that is
    //  useful) until we reach the entry which contains this offset.
    //

    } else {
        
        //
        //  We need to handle the special case of a restart from a synthesized
        //  entry - this is the one time where the restart index can be zero
        //  without requiring us to search above the 2^32 byte mark.
        //
        
        if (UdfFullCompareNames( IrpContext,
                                 RestartName,
                                 &UdfUnicodeDirectoryNames[SELF_ENTRY] ) == EqualTo) {

            FileIndex = UDF_FILE_INDEX_VIRTUAL_SELF;

            Found = UdfLookupInitialFileIndex( IrpContext, Fcb, CompoundDirContext, &FileIndex );
    
            ASSERT( Found );
            
        //
        //  We are restarting from a physical entry.  If the restart index is zero, we were
        //  unable to inform the caller as to the "real" file index due to the dispartity
        //  between the ULONG FileIndex in the return structures and the LONGLONG offsets
        //  possible in directory streams.  In this case, we will go as high as we were able
        //  to inform the caller of and search linearly from that point forward.
        //
        //  It is also possible (realistic? unknown) that the restart index is somewhere in the
        //  middle of an entry and we won't find anything useable.  In this case we try to find
        //  the entry which contains this index, using it as the real restart point.
        //
        
        } else {

            //
            //  See if we need the high water mark.
            //
            
            if (FileIndex == 0) {

                //
                //  We know that this is good.
                //
                
                FileIndex = Max( Ccb->HighestReturnableFileIndex, UDF_FILE_INDEX_PHYSICAL );;
                KnownIndex = TRUE;
            
            }
            
            //
            //  The file index is now useful, falling into two cases
            //
            //      1) KnownIndex == FALSE - searching by index
            //      2) KnownIndex == TRUE  - searching by name
            //
            //  Go set up our inquiry.
            //

            Found = UdfLookupInitialFileIndex( IrpContext, Fcb, CompoundDirContext, &FileIndex );
            
            if (KnownIndex) {
                
                //
                //  Walk forward to discover an entry named per the caller's expectation.
                //
                
                do {
    
                    UdfUpdateDirNames( IrpContext,
                                       &CompoundDirContext->DirContext,
                                       BooleanFlagOn( Ccb->Flags, CCB_FLAG_IGNORE_CASE ));
                    
                    if (UdfFullCompareNames( IrpContext,
                                             &CompoundDirContext->DirContext.CaseObjectName,
                                             RestartName ) == EqualTo) {

                        break;
                    }

                    Found = UdfLookupNextFileIndex( IrpContext, Fcb, CompoundDirContext );
    
                } while (Found);
            
            } else if (!Found) {

                LONGLONG LastFileIndex;

                //
                //  Perform the search for the entry by index from the beginning of the physical directory.
                //

                LastFileIndex = UDF_FILE_INDEX_PHYSICAL;

                Found = UdfLookupInitialFileIndex( IrpContext, Fcb, CompoundDirContext, &LastFileIndex );

                ASSERT( Found );

                //
                //  Keep walking through the directory until we run out of
                //  entries or we find an entry which ends beyond the input
                //  index value (index search case) or corresponds to the
                //  name we are looking for (name search case).
                //
    
                do {
    
                    //
                    //  If we have passed the index value then exit.
                    //

                    if (CompoundDirContext->FileIndex.QuadPart > FileIndex) {

                        Found = FALSE;
                        break;
                    }

                    //
                    //  Remember the current position in case we need to go back.
                    //

                    LastFileIndex = CompoundDirContext->FileIndex.QuadPart;

                    //
                    //  Exit if the next entry is beyond the desired index value.
                    //

                    if (LastFileIndex + ISONsrFidSize( CompoundDirContext->DirContext.Fid ) > FileIndex) {

                        break;
                    }
    
                    Found = UdfLookupNextFileIndex( IrpContext, Fcb, CompoundDirContext );
    
                } while (Found);
    
                //
                //  If we didn't find the entry then go back to the last known entry.
                //
    
                if (!Found) {
    
                    UdfCleanupDirContext( IrpContext, &CompoundDirContext->DirContext );
                    UdfInitializeDirContext( IrpContext, &CompoundDirContext->DirContext );
    
                    Found = UdfLookupInitialFileIndex( IrpContext, Fcb, CompoundDirContext, &LastFileIndex );

                    ASSERT( Found );
                }
            }
        }
    }

    //
    //  Only update the dirent name if we will need it for some reason.
    //  Don't update this name if we are returning the next entry, and
    //  don't update it if it was already done.
    //

    if (!(*ReturnNextEntry) &&
        CompoundDirContext->DirContext.PureObjectName.Buffer == NULL) {

        //
        //  If the caller specified an index that corresponds to a
        //  deleted file, they are trying to be tricky. Don't let them.
        //

        if (CompoundDirContext->DirContext.Fid &&
            FlagOn( CompoundDirContext->DirContext.Fid->Flags, NSR_FID_F_DELETED )) {

            return STATUS_INVALID_PARAMETER;
        }
        
        //
        //  Update the names in the dirent.
        //

        UdfUpdateDirNames( IrpContext,
                           &CompoundDirContext->DirContext,
                           BooleanFlagOn( Ccb->Flags, CCB_FLAG_IGNORE_CASE ));
    }

    //
    //  Look at the flag in the IrpSp indicating whether to return just
    //  one entry.
    //

    *ReturnSingleEntry = FALSE;

    if (FlagOn( IrpSp->Flags, SL_RETURN_SINGLE_ENTRY )) {

        *ReturnSingleEntry = TRUE;
    }

    return STATUS_SUCCESS;
}


//
//  Local support routine
//

BOOLEAN
UdfEnumerateIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PCCB Ccb,
    IN OUT PCOMPOUND_DIR_ENUM_CONTEXT CompoundDirContext,
    IN BOOLEAN ReturnNextEntry
    )

/*++

Routine Description:

    This routine is the worker routine for index enumeration.  We are positioned
    at some dirent in the directory and will either return the first match
    at that point or look to the next entry.  The Ccb contains details about
    the type of matching to do.

Arguments:

    Ccb - Ccb for this directory handle.

    CompoundDirContext - context already positioned at some entry in the directory.

    ReturnNextEntry - Indicates if we are returning this entry or should start
        with the next entry.

Return Value:

    BOOLEAN - TRUE if next entry is found, FALSE otherwise.

--*/

{
    BOOLEAN Found = FALSE;
    PDIR_ENUM_CONTEXT DirContext;

    PAGED_CODE();

    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_CCB( Ccb );

    //
    //  Directly reference the directory enumeration context for convenience.
    //

    DirContext = &CompoundDirContext->DirContext;

    //
    //  Loop until we find a match or exaust the directory.
    //

    while (TRUE) {

        //
        //  Move to the next entry unless we want to consider the current
        //  entry.
        //

        if (ReturnNextEntry) {

            if (!UdfLookupNextFileIndex( IrpContext, Ccb->Fcb, CompoundDirContext )) {

                break;
            }
        
            if (FlagOn( DirContext->Fid->Flags, NSR_FID_F_DELETED )) {

                continue;
            }

            UdfUpdateDirNames( IrpContext,
                               DirContext,
                               BooleanFlagOn( Ccb->Flags, CCB_FLAG_IGNORE_CASE ));
        } else {

            ReturnNextEntry = TRUE;
        }
            
        //
        //  Don't bother if we have a constant entry and are ignoring them.
        //
        
        if (!FlagOn( DirContext->Flags, DIR_CONTEXT_FLAG_SEEN_NONCONSTANT ) &&
            FlagOn( Ccb->Flags, CCB_FLAG_ENUM_NOMATCH_CONSTANT_ENTRY )) {

            continue;
        }

        //
        //  If we match all names then return to our caller.
        //

        if (FlagOn( Ccb->Flags, CCB_FLAG_ENUM_MATCH_ALL )) {

            DirContext->ShortObjectName.Length = 0;
            Found = TRUE;

            break;
        }

        //
        //  Check if the long name matches the search expression.
        //

        if (UdfIsNameInExpression( IrpContext,
                                   &DirContext->CaseObjectName,
                                   &Ccb->SearchExpression,
                                   BooleanFlagOn( Ccb->Flags, CCB_FLAG_ENUM_NAME_EXP_HAS_WILD ))) {

            //
            //  Let our caller know we found an entry.
            //

            DirContext->ShortObjectName.Length = 0;
            Found = TRUE;

            break;
        }

        //
        //  The long name didn't match so we need to check for a
        //  possible short name match.  There is no match if the
        //  long name is one of the constant entries or already
        //  is 8dot3.
        //

        if (!(!FlagOn( DirContext->Flags, DIR_CONTEXT_FLAG_SEEN_NONCONSTANT ) ||
              UdfIs8dot3Name( IrpContext,
                              DirContext->CaseObjectName ))) {

            //
            //  Allocate the shortname if it isn't already done.
            //
            
            if (DirContext->ShortObjectName.Buffer == NULL) {

                DirContext->ShortObjectName.Buffer = FsRtlAllocatePoolWithTag( UdfPagedPool,
                                                                               BYTE_COUNT_8_DOT_3,
                                                                               TAG_SHORT_FILE_NAME );
                DirContext->ShortObjectName.MaximumLength = BYTE_COUNT_8_DOT_3;
            }

            UdfGenerate8dot3Name( IrpContext,
                                  &DirContext->PureObjectName,
                                  &DirContext->ShortObjectName );

            //
            //  Check if this name matches.
            //

            if (UdfIsNameInExpression( IrpContext,
                                       &DirContext->ShortObjectName,
                                       &Ccb->SearchExpression,
                                       BooleanFlagOn( Ccb->Flags, CCB_FLAG_ENUM_NAME_EXP_HAS_WILD ))) {
                
                //
                //  Let our caller know we found an entry.
                //

                Found = TRUE;

                break;
            }
        }
    }

    return Found;
}


//
//  Local support routine
//

VOID
UdfLookupFileEntryInEnumeration (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCOMPOUND_DIR_ENUM_CONTEXT CompoundDirContext
    )

/*++

Routine Description:

    This routine retrieves the file entry associated with the current location in
    the enumeration of a compound directory context.
  
Arguments:

    Fcb - the directory being enumerated.
    
    CompoundDirContext - a corresponding context for the enumeration.
    
Return Value:

    None.  Status may be raised on discovery of corruption.

--*/

{
    PNSR_FID Fid;
    PICBFILE Fe;
    ULONG Length;

    Fid = CompoundDirContext->DirContext.Fid;

    //
    //  Figure out where the ICB we want is.
    //
    
    if (UdfIsFileIndexVirtual( CompoundDirContext->FileIndex.QuadPart )) {

        //
        //  Synthesize!  We only have to synthesize the self entry.  The name is already done,
        //  so the remaining work is trivial.
        //

        ASSERT( Fid == NULL );

        //
        //  Lift the FE corresponding to this directory
        //

        UdfCleanupIcbContext( IrpContext, &CompoundDirContext->IcbContext );
        
        UdfInitializeIcbContextFromFcb( IrpContext,
                                        &CompoundDirContext->IcbContext,
                                        Fcb );

        Length = Fcb->RootExtentLength;

    } else {

        //
        //  Lift the FE corresponding to this FID.
        //

        ASSERT( Fid != NULL );

        UdfCleanupIcbContext( IrpContext, &CompoundDirContext->IcbContext );

        UdfInitializeIcbContext( IrpContext,
                                 &CompoundDirContext->IcbContext,
                                 Fcb->Vcb,
                                 DESTAG_ID_NSR_FILE,
                                 Fid->Icb.Start.Partition,
                                 Fid->Icb.Start.Lbn,
                                 BlockSize( IrpContext->Vcb) );

        Length = Fid->Icb.Length.Length;
    }

    //
    //  Retrieve the ICB for inspection.
    //
    
    UdfLookupActiveIcb( IrpContext, 
                        &CompoundDirContext->IcbContext,
                        Length);

    Fe = (PICBFILE) CompoundDirContext->IcbContext.Active.View;

    //
    //  Perform some basic verification that the FE is of the proper type and that
    //  FID and FE agree as to the type of the object.  We explicitly check that
    //  a legal filesystem-level FE type is discovered, even though we don't support
    //  them in other paths.  Note that we leave the IcbContext->IcbType as FILE even
    //  though we may have picked up an extended file entry.
    //

    if (((Fe->Destag.Ident != DESTAG_ID_NSR_FILE) &&
         ((Fe->Destag.Ident != DESTAG_ID_NSR_EXT_FILE) || (!UdfExtendedFEAllowed( IrpContext->Vcb)))) ||

        (((Fid && FlagOn( Fid->Flags, NSR_FID_F_DIRECTORY )) ||
          Fid == NULL) &&
         Fe->Icbtag.FileType != ICBTAG_FILE_T_DIRECTORY) ||

        (Fe->Icbtag.FileType != ICBTAG_FILE_T_FILE &&
         Fe->Icbtag.FileType != ICBTAG_FILE_T_DIRECTORY &&
         Fe->Icbtag.FileType != ICBTAG_FILE_T_BLOCK_DEV &&
         Fe->Icbtag.FileType != ICBTAG_FILE_T_CHAR_DEV &&
         Fe->Icbtag.FileType != ICBTAG_FILE_T_FIFO &&
         Fe->Icbtag.FileType != ICBTAG_FILE_T_C_ISSOCK &&
         Fe->Icbtag.FileType != ICBTAG_FILE_T_PATHLINK &&
         Fe->Icbtag.FileType != ICBTAG_FILE_T_REALTIME)
       )  {

        UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
    }
}


//
//  Local support routine
//

BOOLEAN
UdfLookupInitialFileIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCOMPOUND_DIR_ENUM_CONTEXT CompoundDirContext,
    IN PLONGLONG InitialIndex
    )

/*++

Routine Description:

    This routine begins the enumeration of a directory by setting the context
    at the first avaliable virtual directory entry.
  
Arguments:

    Fcb - the directory being enumerated.
    
    CompoundDirContext - a corresponding context for the enumeration.
    
    InitialIndex - an optional starting file index to base the enumeration.
    
Return Value:

   TRUE will be returned if a valid entry is found at this offset, FALSE otherwise.

--*/

{
    LONGLONG DirOffset;

    if (UdfIsFileIndexVirtual( *InitialIndex )) {

        //
        //  We only synthesize a single virtual directory entry.  Position the context
        //  at the virtual self entry.
        //
        
        CompoundDirContext->FileIndex.QuadPart = UDF_FILE_INDEX_VIRTUAL_SELF;
        
        return TRUE;
    }

    CompoundDirContext->FileIndex.QuadPart = *InitialIndex;

    //
    //  Find the base offset in the directory and look it up.
    //
    
    DirOffset = UdfFileIndexToPhysicalOffset( *InitialIndex );
        
    return UdfLookupInitialDirEntry( IrpContext,
                                     Fcb,
                                     &CompoundDirContext->DirContext,
                                     &DirOffset );
}


//
//  Local support routine
//

BOOLEAN
UdfLookupNextFileIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCOMPOUND_DIR_ENUM_CONTEXT CompoundDirContext
    )

/*++

Routine Description:

    This routine advances the enumeration of a virtual directory by one entry.

Arguments:

    Fcb - the directory being enumerated.
    
    CompoundDirContext - a corresponding context for the enumeration.

Return Value:

    BOOLEAN True if another Fid is avaliable, False if we are at the end.

--*/

{
    ULONG Advance;
    BOOLEAN Result;

    //
    //  Advance from the synthesized to the physical directory.
    //
    
    if (UdfIsFileIndexVirtual( CompoundDirContext->FileIndex.QuadPart )) {

        Result = UdfLookupInitialDirEntry( IrpContext,
                                           Fcb,
                                           &CompoundDirContext->DirContext,
                                           NULL );
        
        if (Result) {
            
            CompoundDirContext->FileIndex.QuadPart = UDF_FILE_INDEX_PHYSICAL;
        }

        return Result;
    }
    
    Advance = ISONsrFidSize( CompoundDirContext->DirContext.Fid );
    
    //
    //  Advance to the next entry in this directory.
    //
    
    Result = UdfLookupNextDirEntry( IrpContext, Fcb, &CompoundDirContext->DirContext );

    if (Result) {

        CompoundDirContext->FileIndex.QuadPart += Advance;
    }
    
    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\udfs\devctrl.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    DevCtrl.c

Abstract:

    This module implements the File System Device Control routines for Udfs
    called by the dispatch driver.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    {DanLo]     28-Jan-1997

Revision History:

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_DEVCTRL)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_DEVCTRL)

//
//  Local support routines
//

NTSTATUS
UdfDvdReadStructure (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFCB Fcb
    );

NTSTATUS
UdfDvdTransferKey (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFCB Fcb
    );

NTSTATUS
UdfDevCtrlCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfCommonDevControl)
#pragma alloc_text(PAGE, UdfDvdReadStructure)
#pragma alloc_text(PAGE, UdfDvdTransferKey)
#endif


NTSTATUS
UdfCommonDevControl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for doing Device control operations called
    by both the fsd and fsp threads

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;

    TYPE_OF_OPEN TypeOfOpen;
    PFCB Fcb;
    PCCB Ccb;

    PIO_STACK_LOCATION IrpSp;

    PVOID TargetBuffer;

    PAGED_CODE();

    //
    //  Extract and decode the file object.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    TypeOfOpen = UdfDecodeFileObject( IrpSp->FileObject,
                                      &Fcb,
                                      &Ccb );

    //
    //  A few IOCTLs actually require some intervention on our part to
    //  translate some information from file-based to device-based units.
    //

    if (TypeOfOpen == UserFileOpen) {

        UdfAcquireFileShared( IrpContext, Fcb );

        try {

            UdfVerifyFcbOperation( IrpContext, Fcb);

            switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {
                case IOCTL_DVD_READ_KEY:
                case IOCTL_DVD_SEND_KEY:

                    Status = UdfDvdTransferKey( IrpContext, Irp, Fcb );
                    break;

                case IOCTL_DVD_READ_STRUCTURE:

                    Status = UdfDvdReadStructure( IrpContext, Irp, Fcb );
                    break;

                case IOCTL_STORAGE_SET_READ_AHEAD:

                    //
                    //  We're just going to no-op this for now.
                    //
                    
                    Status = STATUS_SUCCESS;
                    UdfCompleteRequest( IrpContext, Irp, Status );
                    break;

                default:

                    Status = STATUS_INVALID_PARAMETER;
                    UdfCompleteRequest( IrpContext, Irp, Status );
                    break;
            }
        }
        finally {

            UdfReleaseFile( IrpContext, Fcb);
        }

        return Status;
    }

    //
    //  Now the only type of opens we accept are user volume opens.
    //

    if (TypeOfOpen != UserVolumeOpen) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Handle the case of the disk type ourselves.  We're really just going to
    //  lie about this, but it is a good lie.
    //

    if (IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_CDROM_DISK_TYPE) {

        //
        //  Verify the Vcb in this case to detect if the volume has changed.
        //

        UdfVerifyVcb( IrpContext, Fcb->Vcb );

        //
        //  Check the size of the output buffer.
        //

        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof( CDROM_DISK_DATA )) {

            UdfCompleteRequest( IrpContext, Irp, STATUS_BUFFER_TOO_SMALL );
            return STATUS_BUFFER_TOO_SMALL;
        }

        //
        //  Copy the data from the Vcb.
        //

        ((PCDROM_DISK_DATA) Irp->AssociatedIrp.SystemBuffer)->DiskData = CDROM_DISK_DATA_TRACK;

        Irp->IoStatus.Information = sizeof( CDROM_DISK_DATA );
        UdfCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
        return STATUS_SUCCESS;
    }

    //
    //  Copy the arguments and set up the completion routine
    //

    IoCopyCurrentIrpStackLocationToNext( Irp );
    
    IoSetCompletionRoutine( Irp,
                            UdfDevCtrlCompletionRoutine,
                            NULL,
                            TRUE,
                            TRUE,
                            TRUE );

    //
    //  Send the request.
    //

    Status = IoCallDriver( IrpContext->Vcb->TargetDeviceObject, Irp );

    //
    //  Cleanup our Irp Context.  The driver has completed the Irp.
    //

    UdfCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

    return Status;
}


NTSTATUS
UdfDvdTransferKey (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine handles the special form of the Dvd key negotiation IOCTLs
    performed in the context of a file.  For these IOCTLs, the incoming parameter
    is in file-relative form, which must be translated to a device-relatvie form
    before it can continue.

Arguments:

    Irp - Supplies the Irp to process
    
    Fcb - Supplies the file being operated with

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    PDVD_COPY_PROTECT_KEY TransferKey;

    LARGE_INTEGER Offset;
    BOOLEAN Result;

    PIO_STACK_LOCATION IrpSp;

    //
    //  Grab the input buffer and confirm basic validity.
    //
    
    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    TransferKey = (PDVD_COPY_PROTECT_KEY) Irp->AssociatedIrp.SystemBuffer;

    if ((IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(DVD_COPY_PROTECT_KEY)) ||
        (TransferKey->Parameters.TitleOffset.QuadPart >= Fcb->FileSize.QuadPart)) {

        UdfCompleteRequest( IrpContext, Irp, Status );
        return Status;
    }

    //
    //  Now, convert the file byte offset in the structure to a physical sector.
    //

    Result = FsRtlLookupLargeMcbEntry( &Fcb->Mcb,
                                       LlSectorsFromBytes( Fcb->Vcb, TransferKey->Parameters.TitleOffset.QuadPart ),
                                       &Offset.QuadPart,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL );

    //
    //  If we failed the lookup, we know that this must be some form of unrecorded
    //  extent on the media.  This IOCTL is ill-defined at this point, so we have
    //  to give up.
    //
    
    if (!Result || Offset.QuadPart == -1) {
        
        UdfCompleteRequest( IrpContext, Irp, Status );
        return Status;
    }
    
    //
    //  The input is buffered from user space, so we know we can just rewrite it.
    //

    TransferKey->Parameters.TitleOffset.QuadPart = LlBytesFromSectors( Fcb->Vcb, Offset.QuadPart );

    //
    //  Copy the arguments and set up the completion routine
    //

    IoCopyCurrentIrpStackLocationToNext( Irp );

    IoSetCompletionRoutine( Irp,
                            UdfDevCtrlCompletionRoutine,
                            NULL,
                            TRUE,
                            TRUE,
                            TRUE );

    //
    //  Send the request.
    //

    Status = IoCallDriver( IrpContext->Vcb->TargetDeviceObject, Irp );

    //
    //  Cleanup our Irp Context.  The driver has completed the Irp.
    //

    UdfCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

    return Status;
}


NTSTATUS
UdfDvdReadStructure (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFCB Fcb

    )

/*++

Routine Description:

    This routine handles the special form of the Dvd structure reading IOCTLs
    performed in the context of a file.  For these IOCTLs, the incoming parameter
    is in file-relative form, which must be translated to a device-relatvie form
    before it can continue.

Arguments:

    Irp - Supplies the Irp to process
    
    Fcb - Supplies the file being operated with

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    PDVD_READ_STRUCTURE ReadStructure;

    LARGE_INTEGER Offset;
    BOOLEAN Result;

    PIO_STACK_LOCATION IrpSp;
    
    //
    //  Grab the input buffer and confirm basic validity.
    //
    
    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    ReadStructure = (PDVD_READ_STRUCTURE) Irp->AssociatedIrp.SystemBuffer;

    if ((IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof(DVD_READ_STRUCTURE)) ||
        (ReadStructure->BlockByteOffset.QuadPart >= Fcb->FileSize.QuadPart))  {

        UdfCompleteRequest( IrpContext, Irp, Status );
        return Status;
    }

    //
    //  Now, convert the file byte offset in the structure to a physical sector.
    //

    Result = FsRtlLookupLargeMcbEntry( &Fcb->Mcb,
                                       LlSectorsFromBytes( Fcb->Vcb, ReadStructure->BlockByteOffset.QuadPart ),
                                       &Offset.QuadPart,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL );

    //
    //  If we failed the lookup, we know that this must be some form of unrecorded
    //  extent on the media.  This IOCTL is ill-defined at this point, so we have
    //  to give up.
    //
    
    if (!Result || Offset.QuadPart == -1) {
        
        UdfCompleteRequest( IrpContext, Irp, Status );
        return Status;
    }
    
    //
    //  The input is buffered from user space, so we know we can just rewrite it.
    //

    ReadStructure->BlockByteOffset.QuadPart = LlBytesFromSectors( Fcb->Vcb, Offset.QuadPart );

    //
    //  Copy the arguments and set up the completion routine
    //

    IoCopyCurrentIrpStackLocationToNext( Irp );

    IoSetCompletionRoutine( Irp,
                            UdfDevCtrlCompletionRoutine,
                            NULL,
                            TRUE,
                            TRUE,
                            TRUE );

    //
    //  Send the request.
    //

    Status = IoCallDriver( IrpContext->Vcb->TargetDeviceObject, Irp );

    //
    //  Cleanup our Irp Context.  The driver has completed the Irp.
    //

    UdfCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

    return Status;
}


//
//  Local support routine
//

NTSTATUS
UdfDevCtrlCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )

{
    //
    //  Add the hack-o-ramma to fix formats.
    //

    if (Irp->PendingReturned) {

        IoMarkIrpPending( Irp );
    }

    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Contxt );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\udfs\deviosup.c ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    DevIoSup.c

Abstract:

    This module implements the low lever disk read/write support for Udfs.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]   	11-Jun-1996
    Tom Jolly       [tomjolly]  21-Jan-2000

Revision History:

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_DEVIOSUP)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_DEVIOSUP)

//
//  Local structure definitions
//

//
//  An array of these structures is passed to UdfMultipleAsync describing
//  a set of runs to execute in parallel.
//

typedef struct _IO_RUN {

    //
    //  Disk offset to read from and number of bytes to read.  These
    //  must be a multiple of a sector and the disk offset is also a
    //  multiple of sector.
    //

    LONGLONG DiskOffset;
    ULONG DiskByteCount;

    //
    //  Current position in user buffer.  This is the final destination for
    //  this portion of the Io transfer.
    //

    PVOID UserBuffer;

    //
    //  Buffer to perform the transfer to.  If this is the same as the
    //  user buffer above then we are using the user's buffer.  Otherwise
    //  we either allocated a temporary buffer or are using a different portion
    //  of the user's buffer.
    //
    //  TransferBuffer - Read full sectors into this location.  This can
    //      be a pointer into the user's buffer at the exact location the
    //      data should go.  It can also be an earlier point in the user's
    //      buffer if the complete I/O doesn't start on a sector boundary.
    //      It may also be a pointer into an allocated buffer.
    //
    //  TransferByteCount - Count of bytes to transfer to user's buffer.  A
    //      value of zero indicates that we did do the transfer into the
    //      user's buffer directly.
    //
    //  TransferBufferOffset - Offset in this buffer to begin the transfer
    //      to the user's buffer.
    //

    PVOID TransferBuffer;
    ULONG TransferByteCount;
    ULONG TransferBufferOffset;

    //
    //  This is the Mdl describing the locked pages in memory.  It may
    //  be allocated to describe the allocated buffer.  Or it may be
    //  the Mdl in the originating Irp.  The MdlOffset is the offset of
    //  the current buffer from the beginning of the buffer described by
    //  the Mdl below.  If the TransferMdl is not the same as the Mdl
    //  in the user's Irp then we know we have allocated it.
    //

    PMDL TransferMdl;
    PVOID TransferVirtualAddress;

    //
    //  Associated Irp used to perform the Io.
    //

    PIRP SavedIrp;

} IO_RUN;
typedef IO_RUN *PIO_RUN;

#define MAX_PARALLEL_IOS            5

//
//  Local support routines
//

BOOLEAN
UdfPrepareBuffers (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN PVOID UserBuffer,
    IN ULONG UserBufferOffset,
    IN LONGLONG StartingOffset,
    IN ULONG ByteCount,
    IN PIO_RUN IoRuns,
    IN PULONG RunCount,
    IN PULONG ThisByteCount,
    OUT PBOOLEAN SparseRuns
    );

BOOLEAN
UdfFinishBuffers (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_RUN IoRuns,
    IN ULONG RunCount,
    IN BOOLEAN FinalCleanup
    );

VOID
UdfMultipleAsync (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG RunCount,
    IN PIO_RUN IoRuns
    );

VOID
UdfSingleAsync (
    IN PIRP_CONTEXT IrpContext,
    IN LONGLONG ByteOffset,
    IN ULONG ByteCount
    );

VOID
UdfWaitSync (
    IN PIRP_CONTEXT IrpContext
    );

NTSTATUS
UdfMultiSyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
UdfMultiAsyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
UdfSingleSyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
UdfSingleAsyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );


#ifdef EXPERIMENTAL_MOUNT_OPEN_R_MEDIA
#pragma alloc_text(PAGE, UdfSendSptCdb)
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfCreateUserMdl)
#pragma alloc_text(PAGE, UdfMultipleAsync)
#pragma alloc_text(PAGE, UdfNonCachedRead)
#pragma alloc_text(PAGE, UdfFinishBuffers)
#pragma alloc_text(PAGE, UdfPrepareBuffers)
#pragma alloc_text(PAGE, UdfSingleAsync)
#pragma alloc_text(PAGE, UdfWaitSync)
#pragma alloc_text(PAGE, UdfPerformDevIoCtrl)
#pragma alloc_text(PAGE, UdfReadSectors)
#endif


NTSTATUS
UdfNonCachedRead (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN LONGLONG StartingOffset,
    IN ULONG ByteCount
    )

/*++

Routine Description:

    This routine performs the non-cached reads of sectors.  This is done by
    performing the following in a loop.

        Fill in the IoRuns array for the next block of Io.
        Send the Io to the device.
        Perform any cleanup on the Io runs array.

    We will not do async Io to any request that generates non-aligned Io.
    Also we will not perform async Io if it will exceed the size of our
    IoRuns array.  These should be the unusual cases but we will raise
    or return CANT_WAIT in this routine if we detect this case.

Arguments:

    Fcb - Fcb representing the file to read.

    StartingOffset - Logical offset in the file to read from.

    ByteCount - Number of bytes to read.

Return Value:

    NTSTATUS - Status indicating the result of the operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    IO_RUN IoRuns[MAX_PARALLEL_IOS];
    ULONG RunCount = 0;
    ULONG CleanupRunCount = 0;

    PVOID UserBuffer;
    ULONG UserBufferOffset = 0;
    LONGLONG CurrentOffset = StartingOffset;
    ULONG RemainingByteCount = ByteCount;
    ULONG ThisByteCount;

    BOOLEAN Unaligned;
    BOOLEAN SparseRuns;
    BOOLEAN FlushIoBuffers = FALSE;
    BOOLEAN FirstPass = TRUE;

    PAGED_CODE();

    //
    //  We want to make sure the user's buffer is locked in all cases.
    //

    if (IrpContext->Irp->MdlAddress == NULL) {

        UdfCreateUserMdl( IrpContext, ByteCount, TRUE, IoWriteAccess );
    }

    //
    //  Use a try-finally to perform the final cleanup.
    //

    try {

        UdfMapUserBuffer( IrpContext, &UserBuffer);

        //
        //  Loop while there are more bytes to transfer.
        //

        do {

            //
            //  Call prepare buffers to set up the next entries
            //  in the IoRuns array.  Remember if there are any
            //  unaligned entries.
            //

            RtlZeroMemory( IoRuns, sizeof( IoRuns ));

            Unaligned = UdfPrepareBuffers( IrpContext,
                                           IrpContext->Irp,
                                           Fcb,
                                           Ccb,
                                           UserBuffer,
                                           UserBufferOffset,
                                           CurrentOffset,
                                           RemainingByteCount,
                                           IoRuns,
                                           &CleanupRunCount,
                                           &ThisByteCount,
                                           &SparseRuns );


            RunCount = CleanupRunCount;

            //
            //  Quickly finish if we wound up having no IO to perform.  This will
            //  occur in the presence of unrecorded sectors.
            //

            ASSERT( !(SparseRuns && FlagOn( Fcb->FcbState, FCB_STATE_EMBEDDED_DATA )));

            if (RunCount == 0) {

                try_leave( Status = IrpContext->Irp->IoStatus.Status = STATUS_SUCCESS );
            }

            //
            //  If this is an async request and there aren't enough entries
            //  in the Io array then post the request.  This routine will
            //  always raise if we are doing any unaligned Io for an
            //  async request.
            //

            if ((ThisByteCount < RemainingByteCount) &&
                !FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {

                UdfRaiseStatus( IrpContext, STATUS_CANT_WAIT );
            }

            //
            //  If the entire Io is contained in a single run then
            //  we can pass the Io down to the driver.  Send the driver down
            //  and wait on the result if this is synchronous.  We cannot
            //  do this simple form (just chucking the IRP down) if some
            //  sparse runs were encountered.
            //

            if ((RunCount == 1) && !Unaligned && !SparseRuns && FirstPass) {

                UdfSingleAsync( IrpContext,
                                IoRuns[0].DiskOffset,
                                IoRuns[0].DiskByteCount );

                //
                //  No cleanup needed for the IoRuns array here.
                //

                CleanupRunCount = 0;

                //
                //  Wait if we are synchronous, otherwise return
                //

                if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {

                    UdfWaitSync( IrpContext );

                    Status = IrpContext->Irp->IoStatus.Status;

                //
                //  Our completion routine will free the Io context but
                //  we do want to return STATUS_PENDING.
                //

                } else {

                    ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ALLOC_IO );
                    Status = STATUS_PENDING;
                }

                try_leave( NOTHING );
            }

            //
            //  Otherwise we will perform multiple Io to read in the data.
            //
            
            UdfMultipleAsync( IrpContext, RunCount, IoRuns );

            //
            //  If this is a synchronous request then perform any necessary
            //  post-processing.
            //

            if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {

                //
                //  Wait for the request to complete.
                //

                UdfWaitSync( IrpContext );

                Status = IrpContext->Irp->IoStatus.Status;

                //
                //  Exit this loop if there is an error.
                //

                if (!NT_SUCCESS( Status )) {

                    try_leave( NOTHING );
                }

                //
                //  Perform post read operations on the IoRuns if
                //  necessary.
                //

                if (Unaligned &&
                    UdfFinishBuffers( IrpContext, IoRuns, RunCount, FALSE )) {

                    FlushIoBuffers = TRUE;
                }

                //
                //  No cleanup needed on the IoRuns now.
                //

                CleanupRunCount = 0;

                //
                //  Exit this loop if there are no more bytes to transfer
                //  or we have any error.
                //

                RemainingByteCount -= ThisByteCount;
                CurrentOffset += ThisByteCount;
                UserBuffer = Add2Ptr( UserBuffer, ThisByteCount, PVOID );
                UserBufferOffset += ThisByteCount;

            //
            //  Otherwise this is an asynchronous request.  Always return
            //  STATUS_PENDING.
            //

            } else {

                ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ALLOC_IO );
                CleanupRunCount = 0;
                try_leave( Status = STATUS_PENDING );
                break;
            }

            FirstPass = FALSE;
        } while (RemainingByteCount != 0);

        //
        //  Flush the hardware cache if we performed any copy operations.
        //

        if (FlushIoBuffers) {

            KeFlushIoBuffers( IrpContext->Irp->MdlAddress, TRUE, FALSE );
        }

    } finally {

        DebugUnwind( "UdfNonCachedRead" );

        //
        //  Perform final cleanup on the IoRuns if necessary.
        //

        if (CleanupRunCount != 0) {

            UdfFinishBuffers( IrpContext, IoRuns, CleanupRunCount, TRUE );
        }
    }

    return Status;
}


NTSTATUS
UdfCreateUserMdl (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG BufferLength,
    IN BOOLEAN RaiseOnError,
    IN ULONG Operation
    )

/*++

Routine Description:

    This routine locks the specified buffer for read access (we only write into
    the buffer).  The file system requires this routine since it does not
    ask the I/O system to lock its buffers for direct I/O.  This routine
    may only be called from the Fsd while still in the user context.

    This routine is only called if there is not already an Mdl.

Arguments:

    BufferLength - Length of user buffer.

    RaiseOnError - Indicates if our caller wants this routine to raise on
        an error condition.

Return Value:

    NTSTATUS - Status from this routine.  Error status only returned if
        RaiseOnError is FALSE.

--*/

{
    NTSTATUS Status = STATUS_INSUFFICIENT_RESOURCES;
    PMDL Mdl;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( IrpContext->Irp );
    ASSERT( IrpContext->Irp->MdlAddress == NULL );

    //
    // Allocate the Mdl, and Raise if we fail.
    //

    Mdl = IoAllocateMdl( IrpContext->Irp->UserBuffer,
                         BufferLength,
                         FALSE,
                         FALSE,
                         IrpContext->Irp );

    if (Mdl != NULL) {

        //
        //  Now probe the buffer described by the Irp.  If we get an exception,
        //  deallocate the Mdl and return the appropriate "expected" status.
        //

        try {

            MmProbeAndLockPages( Mdl, IrpContext->Irp->RequestorMode, Operation );

            Status = STATUS_SUCCESS;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            Status = GetExceptionCode();

            IoFreeMdl( Mdl );
            IrpContext->Irp->MdlAddress = NULL;

            if (!FsRtlIsNtstatusExpected( Status )) {

                Status = STATUS_INVALID_USER_BUFFER;
            }
        }
    }

    //
    //  Check if we are to raise or return
    //

    if (Status != STATUS_SUCCESS) {

        if (RaiseOnError) {

            UdfRaiseStatus( IrpContext, Status );
        }
    }

    //
    //  Return the status code.
    //

    return Status;
}


#ifdef EXPERIMENTAL_MOUNT_OPEN_R_MEDIA

typedef struct  {
    SCSI_PASS_THROUGH   Spt;
    UCHAR               SenseInfoBuffer[18];
    UCHAR               DataBuffer[0];
    // Allocate buffer space after this
} SPT_WITH_BUFFERS, *PSPT_WITH_BUFFERS;


NTSTATUS
UdfSendSptCdb(
    IN PDEVICE_OBJECT Device,
    IN PCDB Cdb,
    IN PUCHAR Buffer,
    IN OUT PULONG BufferSize,
    IN BOOLEAN InputOperation,
    IN ULONG TimeOut,
    IN OPTIONAL PVOID TempBuffer,
    IN OPTIONAL ULONG TempBufferSize,
    OUT PULONG SenseKeyCodeQualifier,
    OUT PUSHORT ProgressIndication
    )

/*++

Routine Description:

    Sends the caller supplied SCSI CDB to the specified device.
    
Arguments:

    Device - target device object
    
    Cdb - command to send
    
    Buffer - Buffer containing input data, or to receive data returned from
             the device (depending on InputOperation parameter)
             
    BufferSize - Size of the above buffer.  For input operations this value will
                 be updated to reflect actual length of data returned by the device.

    InputOperation - if TRUE then the operation is querying the drive for data.  FALSE
                     and we are sending data to the device.

    TimeOut - Time to wait for this operation to complete (seconds)

    TempBuffer - Scratch buffer used for building the request.  If NULL or too small
                 a buffer will be allocated.

    TempBufferSize - Size of above buffer.

    SenseKeyCodeQualifier - In error cases contains the detailed error information 
                            from the device (see SCSI spec).  0x00QqCcKk

    ProgressIndication - Returns the progress value from the drive for certain error
                         classes (see SCSI spec). 

Return Value:

    NTSTATUS - Status returned by next lower driver or...

    STATUS_BUFFER_OVERFLOW - the device returned too much data to fit in caller's 
                             buffer. *BufferSize will be update to indicate the amount
                             of data returned by the drive.

--*/

{
    PSPT_WITH_BUFFERS P;
    ULONG PacketSize;
    PSENSE_DATA SenseBuffer;
    BOOLEAN CopyData;
    UCHAR CdbSize;
    BOOLEAN FromPool = FALSE;
    
    USHORT Progress;
    ULONG SenseInfo;

    NTSTATUS Status;

    ASSERT( NULL != Cdb);
    ASSERT( (0 == TempBufferSize) || (NULL != TempBuffer));
    ASSERT( (0 == *BufferSize) || (NULL != Buffer));

    if (ProgressIndication)  {
    
        *ProgressIndication = 0;
    }
    
    if (SenseKeyCodeQualifier)  {
    
        *SenseKeyCodeQualifier = 0;
    }

    //
    //  Calculate CDB length from operation code.
    //

    switch ((Cdb->AsByte[0] >> 5) & 0x7) {
    case 0:
        CdbSize =  6;
        break;
    case 1:
    case 2:
        CdbSize = 10;
        break;
    case 5:
        CdbSize = 12;
        break;
    default:
        ASSERT(FALSE);
        break;
    }

    if (*BufferSize && InputOperation)  {

        RtlZeroMemory( Buffer, *BufferSize);
    }

    //
    //  If the caller temp buffer is not large enough to contain the
    //  request packet,  allocate.
    //
    
    PacketSize = sizeof( SPT_WITH_BUFFERS) + *BufferSize;

    if (PacketSize > TempBufferSize)  {
    
        P = FsRtlAllocatePoolWithTag( PagedPool,
                                      PacketSize,
                                      TAG_IOCTL_BUFFER);
        FromPool = TRUE;
    }
    else {

        P = TempBuffer;
    }

    //
    //  Fill in the packet.
    //
    
    RtlZeroMemory( P, PacketSize);
    RtlCopyMemory( P->Spt.Cdb, Cdb, CdbSize);

    P->Spt.Length             = sizeof(SCSI_PASS_THROUGH);
    P->Spt.CdbLength          = CdbSize;
    P->Spt.SenseInfoLength    = SENSE_BUFFER_SIZE;
    P->Spt.DataIn             = (InputOperation ? 1 : 0);
    P->Spt.DataTransferLength = (*BufferSize);
    P->Spt.TimeOutValue       = TimeOut;
    P->Spt.SenseInfoOffset =
        FIELD_OFFSET(SPT_WITH_BUFFERS, SenseInfoBuffer[0]);
    P->Spt.DataBufferOffset =
        FIELD_OFFSET(SPT_WITH_BUFFERS, DataBuffer[0]);

    //
    //  If we're sending the device data, copy the user's buffer into the packet.
    //

    if ((*BufferSize != 0) && !InputOperation) {
        
        RtlCopyMemory( &(P->DataBuffer[0]), Buffer, *BufferSize);
    }

    //
    //  Send it.
    //
    
    Status = UdfPerformDevIoCtrl( NULL, 
                                  IOCTL_SCSI_PASS_THROUGH, 
                                  Device, 
                                  P,
                                  PacketSize,
                                  P,
                                  PacketSize,   
                                  FALSE,
                                  TRUE,
                                  NULL);
    if (!NT_SUCCESS(Status))  {

        DebugTrace((0,Dbg,"UdfSendSptCdb() failed %x\n", Status));  

        // TODO: DO WE NEED TO LOOK AT SENSE DATA IN THIS CASE?

        if (FromPool)  {

            ExFreePool( P);
        }

        return Status;
    }

    SenseBuffer = (PSENSE_DATA)P->SenseInfoBuffer;
    CopyData = FALSE;

    if (SenseBuffer->SenseKey & 0xf) {

        //
        //  Some error (possibly recovered).
        //
        
        Status = STATUS_IO_DEVICE_ERROR;
        CopyData = TRUE;

    } else if (P->Spt.ScsiStatus != 0) {

        //
        //  SCSI protocol error.
        //
        
        Status = STATUS_INVALID_PARAMETER;

    } else {

        CopyData = TRUE;
        Status = STATUS_SUCCESS;
    }

    //
    //  Extract sense information for the caller if there was an error.
    //

    if (!NT_SUCCESS(Status)) {

        SenseInfo = SenseBuffer->SenseKey |
                    (SenseBuffer->AdditionalSenseCode << 8) |
                    (SenseBuffer->AdditionalSenseCodeQualifier << 16);

#ifdef UDF_SANITY

        if (SenseInfo & 0xff)  {

            DebugTrace(( 0, Dbg, "Request: 0x%x -> QQ/CC/KK %06x\n", Cdb->AsByte[0], SenseInfo));
        }
#endif

        //
        //  If the sense key specific part is valid we'll return the
        //  data portion as a possible progress indication.
        //
        
        if (SenseBuffer->SenseKeySpecific[0] & 0x80)  {
        
            Progress = SenseBuffer->SenseKeySpecific[2] |
                       (SenseBuffer->SenseKeySpecific[1] << 8);

#ifdef UDF_SANITY
            //
            //  If this wasn't a not ready code,  then this is probably a 
            //  packet parameter format error.  Print it.  Most drives don't
            //  seem to utilise this detailed error reporting.... sigh.
            //
            
            if (SenseBuffer->SenseKey != SCSI_SENSE_NOT_READY)  {

                if (SenseBuffer->SenseKeySpecific[0] & 0x40) {

                    DebugTrace((0, Dbg, "CDB error at 0x%x\n", Progress));
                }
                else {
                
                    DebugTrace((0, Dbg, "CDB data parameter error at 0x%x\n", Progress));
                }

                if (SenseBuffer->SenseKeySpecific[0] & 8)  {
                
                    DebugTrace(( 0, Dbg, "Bit position %d\n", SenseBuffer->SenseKeySpecific[0] & 7));
                }
            }
#endif
            if (ProgressIndication)  {

                *ProgressIndication = Progress;
            }    
        }
        
        if (SenseKeyCodeQualifier)  {

            *SenseKeyCodeQualifier = SenseInfo;
        }
    }

    //
    //  If this was an input operation,  copy the return data to caller buffer.
    //
    
    if (CopyData && InputOperation) {

        if (*BufferSize < P->Spt.DataTransferLength)  {

            Status = STATUS_BUFFER_OVERFLOW;
        }

        *BufferSize = P->Spt.DataTransferLength;

        if (STATUS_BUFFER_OVERFLOW != Status)  {        
        
            RtlCopyMemory(Buffer, P->DataBuffer, *BufferSize);
        }
    }

    if (FromPool)  {

        ExFreePool( P);
    }

    return Status;
}

#endif


NTSTATUS
UdfPerformDevIoCtrl (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG IoControlCode,
    IN PDEVICE_OBJECT Device,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN BOOLEAN InternalDeviceIoControl,
    IN BOOLEAN OverrideVerify,
    OUT PIO_STATUS_BLOCK Iosb OPTIONAL
    )

/*++

Routine Description:

    This routine is called to perform DevIoCtrl functions internally within
    the filesystem.  We take the status from the driver and return it to our
    caller.

Arguments:

    IoControlCode - Code to send to driver.

    Device - This is the device to send the request to.

    OutPutBuffer - Pointer to output buffer.

    OutputBufferLength - Length of output buffer above.

    InternalDeviceIoControl - Indicates if this is an internal or external
        Io control code.

    OverrideVerify - Indicates if we should tell the driver not to return
        STATUS_VERIFY_REQUIRED for mount and verify.

    Iosb - If specified, we return the results of the operation here.

Return Value:

    NTSTATUS - Status returned by next lower driver.

--*/

{
    NTSTATUS Status;
    PIRP Irp;
    KEVENT Event;
    IO_STATUS_BLOCK LocalIosb;
    PIO_STATUS_BLOCK IosbToUse = &LocalIosb;

    PAGED_CODE();

    //
    //  Check if the user gave us an Iosb.
    //

    if (ARGUMENT_PRESENT( Iosb )) {

        IosbToUse = Iosb;
    }

    IosbToUse->Status = 0;
    IosbToUse->Information = 0;

    KeInitializeEvent( &Event, NotificationEvent, FALSE );

    Irp = IoBuildDeviceIoControlRequest( IoControlCode,
                                         Device,
                                         InputBuffer,
                                         InputBufferLength,
                                         OutputBuffer,
                                         OutputBufferLength,
                                         InternalDeviceIoControl,
                                         &Event,
                                         IosbToUse );

    if (Irp == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if (OverrideVerify) {

        SetFlag( IoGetNextIrpStackLocation( Irp )->Flags, SL_OVERRIDE_VERIFY_VOLUME );
    }

    Status = IoCallDriver( Device, Irp );

    //
    //  We check for device not ready by first checking Status
    //  and then if status pending was returned, the Iosb status
    //  value.
    //

    if (Status == STATUS_PENDING) {

        (VOID) KeWaitForSingleObject( &Event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      (PLARGE_INTEGER)NULL );

        Status = IosbToUse->Status;
    }

    ASSERT( !(OverrideVerify && (STATUS_VERIFY_REQUIRED == Status)));

    return Status;

    UNREFERENCED_PARAMETER( IrpContext );
}


NTSTATUS
UdfReadSectors (
    IN PIRP_CONTEXT IrpContext,
    IN LONGLONG StartingOffset,
    IN ULONG ByteCount,
    IN BOOLEAN ReturnError,
    IN OUT PVOID Buffer,
    IN PDEVICE_OBJECT TargetDeviceObject
    )

/*++

Routine Description:

    This routine is called to transfer sectors from the disk to a
    specified buffer.  It is used for mount and volume verify operations.

    This routine is synchronous, it will not return until the operation
    is complete or until the operation fails.

    The routine allocates an IRP and then passes this IRP to a lower
    level driver.  Errors may occur in the allocation of this IRP or
    in the operation of the lower driver.

Arguments:

    StartingOffset - Logical offset on the disk to start the read.  This
        must be on a sector boundary, no check is made here.

    ByteCount - Number of bytes to read.  This is an integral number of
        sectors, or otherwise a value we know the driver can handle,
        no check is made here to confirm this.

    ReturnError - Indicates whether we should return TRUE or FALSE
        to indicate an error or raise an error condition.  This only applies
        to the result of the IO.  Any other error may cause a raise.

    Buffer - Buffer to transfer the disk data into.

    TargetDeviceObject - The device object for the volume to be read.

Return Value:

    The final status of the operation.

--*/

{
    PLONGLONG UseStartingOffset;
    LONGLONG LocalStartingOffset;
    NTSTATUS Status;
    KEVENT  Event;
    PIRP Irp;

    PAGED_CODE();

    DebugTrace(( +1, Dbg,
                 "UdfReadSectors, %x%08x +%x -> %08x from DO %08x\n",
                 ((PLARGE_INTEGER)&StartingOffset)->HighPart,
                 ((PLARGE_INTEGER)&StartingOffset)->LowPart,
                 ByteCount,
                 Buffer,
                 TargetDeviceObject ));
    
    //
    //  For the time being, we assume that we only read sector-at-a-time.
    //  This simplifies sparing, and is the only way I am aware of this
    //  code would not be ready for blocksize != sectorsize.  It just is
    //  not worth writing dead (but straightforward) code right now.
    //

    ASSERT( IrpContext->Vcb == NULL || ByteCount == SectorSize( IrpContext->Vcb ));

    //
    //  If the volume is spared (and at a point where sparing is possible),
    //  check if a mapping needs to be performed.
    //
    
    if (IrpContext->Vcb &&
        IrpContext->Vcb->Pcb &&
        IrpContext->Vcb->Pcb->SparingMcb) {
        
        LONGLONG SparingPsn;
    
        if (FsRtlLookupLargeMcbEntry( IrpContext->Vcb->Pcb->SparingMcb,
                                      LlSectorsFromBytes( IrpContext->Vcb, StartingOffset ),
                                      &SparingPsn,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL ) &&
            SparingPsn != -1) {

            StartingOffset = BytesFromSectors( IrpContext->Vcb, (ULONG) SparingPsn );
        }
    }
    
    //
    //  Initialize the event.
    //

    KeInitializeEvent( &Event, NotificationEvent, FALSE );

    //
    //  Correct the starting offset by the method 2 fixup if neccesary.  This also
    //  assumes sector-at-a-time and sector == block so we don't need to fragment
    //  the request or check if it spans a packet boundary.
    //
    //  We assume that no fixups are required until a Vcb exists.  This is true
    //  since volume recognition may proceed in the first packet.
    //

    UseStartingOffset = &StartingOffset;

    if (IrpContext->Vcb &&
        FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_METHOD_2_FIXUP )) {

        LocalStartingOffset = UdfMethod2TransformByteOffset( IrpContext->Vcb, StartingOffset );
        UseStartingOffset = &LocalStartingOffset;

        DebugTrace(( 0, Dbg,
                     "UdfReadSectors, Method2 Fixup to %x%08x\n",
                     ((PLARGE_INTEGER)UseStartingOffset)->HighPart,
                     ((PLARGE_INTEGER)UseStartingOffset)->LowPart ));
    }

    //
    //  Attempt to allocate the IRP.  If unsuccessful, raise
    //  STATUS_INSUFFICIENT_RESOURCES.
    //

    Irp = IoBuildSynchronousFsdRequest( IRP_MJ_READ,
                                        TargetDeviceObject,
                                        Buffer,
                                        ByteCount,
                                        (PLARGE_INTEGER) UseStartingOffset,
                                        &Event,
                                        &IrpContext->Irp->IoStatus );

    if (Irp == NULL) {

        UdfRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
    }

    //
    //  Ignore the change line (verify) for mount and verify requests
    //

    SetFlag( IoGetNextIrpStackLocation( Irp )->Flags, SL_OVERRIDE_VERIFY_VOLUME );

    //
    //  Send the request down to the driver.  If an error occurs return
    //  it to the caller.
    //

    Status = IoCallDriver( TargetDeviceObject, Irp );

    //
    //  If the status was STATUS_PENDING then wait on the event.
    //

    if (Status == STATUS_PENDING) {

        Status = KeWaitForSingleObject( &Event,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        NULL );

        //
        //  On a successful wait pull the status out of the IoStatus block.
        //

        if (NT_SUCCESS( Status )) {

            Status = IrpContext->Irp->IoStatus.Status;
        }
    }

    DebugTrace(( -1, Dbg, "UdfReadSectors -> %08x\n", Status ));
    
    //
    //  Check whether we should raise in the error case.
    //

    if (!NT_SUCCESS( Status ) && !ReturnError) {

        UdfNormalizeAndRaiseStatus( IrpContext, Status );
    }

    return Status;
}


//
//  Local support routine
//

BOOLEAN
UdfPrepareBuffers (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN PVOID UserBuffer,
    IN ULONG UserBufferOffset,
    IN LONGLONG StartingOffset,
    IN ULONG ByteCount,
    IN PIO_RUN IoRuns,
    IN PULONG RunCount,
    IN PULONG ThisByteCount,
    IN PBOOLEAN SparseRuns
    )

/*++

Routine Description:

    This routine is the worker routine which looks up each run of an IO
    request and stores an entry for it in the IoRuns array.  If the run
    begins on an unaligned disk boundary then we will allocate a buffer
    and Mdl for the unaligned portion and put it in the IoRuns entry.

    This routine will raise CANT_WAIT if an unaligned transfer is encountered
    and this request can't wait.

Arguments:

    Irp - Originating Irp for this request.

    Fcb - This is the Fcb for this data stream.  It may be a file, directory,
        path table or the volume file.

    UserBuffer - Current position in the user's buffer.

    UserBufferOffset - Offset from the start of the original user buffer.

    StartingOffset - Offset in the stream to begin the read.

    ByteCount - Number of bytes to read.  We will fill the IoRuns array up
        to this point.  We will stop early if we exceed the maximum number
        of parallel Ios we support.

    IoRuns - Pointer to the IoRuns array.  The entire array is zeroes when
        this routine is called.

    RunCount - Number of entries in the IoRuns array filled here.

    ThisByteCount - Number of bytes described by the IoRun entries.  Will
        not exceed the ByteCount passed in.
        
    SparseRuns - Will indicate whether sparse runs were a component of the
        range returned.  While not part of the IoRuns, this will affect
        our ability to do simple IO.

Return Value:

    BOOLEAN - TRUE if one of the entries in an unaligned buffer (provided
        this is synchronous).  FALSE otherwise.

--*/

{
    PVCB Vcb;

    BOOLEAN Recorded;
    
    BOOLEAN FoundUnaligned = FALSE;
    PIO_RUN ThisIoRun = IoRuns;

    //
    //  Following indicate where we are in the current transfer.  Current
    //  position in the file and number of bytes yet to transfer from
    //  this position.
    //

    ULONG RemainingByteCount = ByteCount;
    LONGLONG CurrentFileOffset = StartingOffset;

    //
    //  Following indicate the state of the user's buffer.  We have
    //  the destination of the next transfer and its offset in the
    //  buffer.  We also have the next available position in the buffer
    //  available for a scratch buffer.  We will align this up to a sector
    //  boundary.
    //

    PVOID CurrentUserBuffer = UserBuffer;
    ULONG CurrentUserBufferOffset = UserBufferOffset;

    PVOID ScratchUserBuffer = UserBuffer;
    ULONG ScratchUserBufferOffset = UserBufferOffset;

    //
    //  The following is the next contiguous bytes on the disk to
    //  transfer.  Read from the allocation package.
    //

    LONGLONG DiskOffset;
    ULONG CurrentByteCount;

    PAGED_CODE();

    Vcb = Fcb->Vcb;

    //
    //  Initialize the RunCount, ByteCount and SparseRuns.
    //

    *RunCount = 0;
    *ThisByteCount = 0;
    *SparseRuns = FALSE;

    //
    //  Loop while there are more bytes to process or there are
    //  available entries in the IoRun array.
    //

    while (TRUE) {

        *RunCount += 1;

        //
        //  Initialize the current position in the IoRuns array.
        //  Find the user's buffer for this portion of the transfer.
        //

        ThisIoRun->UserBuffer = CurrentUserBuffer;

        //
        //  Find the allocation information for the current offset in the
        //  stream.
        //

        Recorded = UdfLookupAllocation( IrpContext,
                                        Fcb,
                                        Ccb,
                                        CurrentFileOffset,
                                        &DiskOffset,
                                        &CurrentByteCount );

        //
        //  Limit ourselves to the data requested.
        //

        if (CurrentByteCount > RemainingByteCount) {

            CurrentByteCount = RemainingByteCount;
        }

        //
        //  Handle the case of unrecorded data first.
        //

        if (!Recorded) {

            //
            //  Note that we did not consume an entry.
            //

            *RunCount -= 1;

            //
            //  Immediately zero the user buffer and indicate that we found sparse
            //  runs to the caller.
            //

            RtlZeroMemory( CurrentUserBuffer, CurrentByteCount );
            *SparseRuns = TRUE;

            //
            //  Push the scratch buffer pointers forward so that we don't stomp
            //  on the zeroed buffer.
            //

            ScratchUserBuffer = Add2Ptr( CurrentUserBuffer,
                                         CurrentByteCount,
                                         PVOID );

            ScratchUserBufferOffset += CurrentByteCount;

        //
        //  Handle the case where this is an unaligned transfer.  The
        //  following must all be true for this to be an aligned transfer.
        //
        //      Disk offset on a 2048 byte boundary (Start of transfer)
        //
        //      Byte count is a multiple of 2048 (Length of transfer)
        //
        //      Current buffer offset is also on a 2048 byte boundary.
        //
        //  If the ByteCount is at least one sector then do the
        //  unaligned transfer only for the tail.  We can use the
        //  user's buffer for the aligned portion.
        //

        } else if (SectorOffset( Vcb, DiskOffset ) ||
                   SectorOffset( Vcb, CurrentUserBufferOffset ) ||
                   (SectorOffset( Vcb, CurrentByteCount ) &&
                    CurrentByteCount < SectorSize( Vcb ))) {

            //
            //  If we can't wait then raise.
            //

            if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {

                UdfRaiseStatus( IrpContext, STATUS_CANT_WAIT );
            }

            //
            //  Remember the offset and the number of bytes out of
            //  the transfer buffer to copy into the user's buffer.
            //  We will truncate the current read to end on a sector
            //  boundary.
            //

            ThisIoRun->TransferBufferOffset = SectorOffset( Vcb, DiskOffset );

            //
            //  Make sure this transfer ends on a sector boundary.
            //

            ThisIoRun->DiskOffset = LlSectorTruncate( Vcb, DiskOffset );

            //
            //  Check if we can use a free portion of the user's buffer.
            //  If we can copy the bytes to an earlier portion of the
            //  buffer then read into that location and slide the bytes
            //  up.
            //
            //  We can use the user's buffer if:
            //
            //      The temporary location in the buffer is before the
            //      final destination.
            //
            //      There is at least one sector of data to read.
            //

            if ((ScratchUserBufferOffset + ThisIoRun->TransferBufferOffset < CurrentUserBufferOffset) &&
                (ThisIoRun->TransferBufferOffset + CurrentByteCount >= SectorSize( Vcb ))) {

                ThisIoRun->DiskByteCount = SectorTruncate( Vcb, ThisIoRun->TransferBufferOffset + CurrentByteCount );
                CurrentByteCount = ThisIoRun->DiskByteCount - ThisIoRun->TransferBufferOffset;
                ThisIoRun->TransferByteCount = CurrentByteCount;

                //
                //  Point to the user's buffer and Mdl for this transfer.
                //

                ThisIoRun->TransferBuffer = ScratchUserBuffer;
                ThisIoRun->TransferMdl = Irp->MdlAddress;
                ThisIoRun->TransferVirtualAddress = Add2Ptr( Irp->UserBuffer,
                                                             ScratchUserBufferOffset,
                                                             PVOID );

                ScratchUserBuffer = Add2Ptr( ScratchUserBuffer,
                                             ThisIoRun->DiskByteCount,
                                             PVOID );

                ScratchUserBufferOffset += ThisIoRun->DiskByteCount;

            //
            //  Otherwise we need to allocate an auxilary buffer for the next sector.
            //

            } else {

                //
                //  Read up to a page containing the partial data
                //

                ThisIoRun->DiskByteCount = SectorAlign( Vcb, ThisIoRun->TransferBufferOffset + CurrentByteCount );

                if (ThisIoRun->DiskByteCount > PAGE_SIZE) {

                    ThisIoRun->DiskByteCount = PAGE_SIZE;
                }

                if (ThisIoRun->TransferBufferOffset + CurrentByteCount > ThisIoRun->DiskByteCount) {

                    CurrentByteCount = ThisIoRun->DiskByteCount - ThisIoRun->TransferBufferOffset;
                }

                ThisIoRun->TransferByteCount = CurrentByteCount;

                //
                //  Allocate a buffer for the non-aligned transfer.
                //

                ThisIoRun->TransferBuffer = FsRtlAllocatePoolWithTag( UdfNonPagedPool,
                                                                      PAGE_SIZE,
                                                                      TAG_IO_BUFFER );

                //
                //  Allocate and build the Mdl to describe this buffer.
                //

                ThisIoRun->TransferMdl = IoAllocateMdl( ThisIoRun->TransferBuffer,
                                                        PAGE_SIZE,
                                                        FALSE,
                                                        FALSE,
                                                        NULL );

                ThisIoRun->TransferVirtualAddress = ThisIoRun->TransferBuffer;

                if (ThisIoRun->TransferMdl == NULL) {

                    IrpContext->Irp->IoStatus.Information = 0;
                    UdfRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
                }

                MmBuildMdlForNonPagedPool( ThisIoRun->TransferMdl );
            }

            //
            //  Remember we found an unaligned transfer.
            //

            FoundUnaligned = TRUE;

        //
        //  Otherwise we use the buffer and Mdl from the original request.
        //

        } else {

            //
            //  Truncate the read length to a sector-aligned value.  We know
            //  the length must be at least one sector or we wouldn't be
            //  here now.
            //

            CurrentByteCount = SectorTruncate( Vcb, CurrentByteCount );

            //
            //  Read these sectors from the disk.
            //

            ThisIoRun->DiskOffset = DiskOffset;
            ThisIoRun->DiskByteCount = CurrentByteCount;

            //
            //  Use the user's buffer and Mdl as our transfer buffer
            //  and Mdl.
            //

            ThisIoRun->TransferBuffer = CurrentUserBuffer;
            ThisIoRun->TransferMdl = Irp->MdlAddress;
            ThisIoRun->TransferVirtualAddress = Add2Ptr( Irp->UserBuffer,
                                                         CurrentUserBufferOffset,
                                                         PVOID );

            ScratchUserBuffer = Add2Ptr( CurrentUserBuffer,
                                         CurrentByteCount,
                                         PVOID );

            ScratchUserBufferOffset += CurrentByteCount;
        }

        //
        //  Update our position in the transfer and the RunCount and
        //  ByteCount for the user.
        //

        RemainingByteCount -= CurrentByteCount;

        //
        //  Break out if no more positions in the IoRuns array or
        //  we have all of the bytes accounted for.
        //

        *ThisByteCount += CurrentByteCount;

        if ((RemainingByteCount == 0) || (*RunCount == MAX_PARALLEL_IOS)) {

            break;
        }

        //
        //  Update our pointers for the user's buffer.
        //

        ThisIoRun = IoRuns + *RunCount;
        CurrentUserBuffer = Add2Ptr( CurrentUserBuffer, CurrentByteCount, PVOID );
        CurrentUserBufferOffset += CurrentByteCount;
        CurrentFileOffset += CurrentByteCount;
    }

    return FoundUnaligned;
}


//
//  Local support routine
//

BOOLEAN
UdfFinishBuffers (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_RUN IoRuns,
    IN ULONG RunCount,
    IN BOOLEAN FinalCleanup
    )

/*++

Routine Description:

    This routine is called to perform any data transferred required for
    unaligned Io or to perform the final cleanup of the IoRuns array.

    In all cases this is where we will deallocate any buffer and mdl
    allocated to perform the unaligned transfer.  If this is not the
    final cleanup then we also transfer the bytes to the user buffer
    and flush the hardware cache.

    We walk backwards through the run array because we may be shifting data
    in the user's buffer.  Typical case is where we allocated a buffer for
    the first part of a read and then used the user's buffer for the
    next section (but stored it at the beginning of the buffer.

Arguments:

    IoRuns - Pointer to the IoRuns array.

    RunCount - Number of entries in the IoRuns array filled here.

    FinalCleanup - Indicates if we should be deallocating temporary buffers
        (TRUE) or transferring bytes for a unaligned transfers and
        deallocating the buffers (FALSE).  Flush the system cache if
        transferring data.

Return Value:

    BOOLEAN - TRUE if this request needs the Io buffers to be flushed, FALSE otherwise.

--*/

{
    BOOLEAN FlushIoBuffers = FALSE;

    ULONG RemainingEntries = RunCount;
    PIO_RUN ThisIoRun = &IoRuns[RunCount - 1];

    PAGED_CODE();

    //
    //  Walk through each entry in the IoRun array.
    //

    while (RemainingEntries != 0) {

        //
        //  We only need to deal with the case of an unaligned transfer.
        //

        if (ThisIoRun->TransferByteCount != 0) {

            //
            //  If not the final cleanup then transfer the data to the
            //  user's buffer and remember that we will need to flush
            //  the user's buffer to memory.
            //

            if (!FinalCleanup) {

                //
                //  If we are shifting in the user's buffer then use
                //  MoveMemory.
                //

                if (ThisIoRun->TransferMdl == IrpContext->Irp->MdlAddress) {

                    RtlMoveMemory( ThisIoRun->UserBuffer,
                                   Add2Ptr( ThisIoRun->TransferBuffer,
                                            ThisIoRun->TransferBufferOffset,
                                            PVOID ),
                                   ThisIoRun->TransferByteCount );

                } else {

                    RtlCopyMemory( ThisIoRun->UserBuffer,
                                   Add2Ptr( ThisIoRun->TransferBuffer,
                                            ThisIoRun->TransferBufferOffset,
                                            PVOID ),
                                   ThisIoRun->TransferByteCount );
                }

                FlushIoBuffers = TRUE;
            }

            //
            //  Free any Mdl we may have allocated.  If the Mdl isn't
            //  present then we must have failed during the allocation
            //  phase.
            //

            if (ThisIoRun->TransferMdl != IrpContext->Irp->MdlAddress) {

                if (ThisIoRun->TransferMdl != NULL) {

                    IoFreeMdl( ThisIoRun->TransferMdl );
                }

                //
                //  Now free any buffer we may have allocated.  If the Mdl
                //  doesn't match the original Mdl then free the buffer.
                //

                if (ThisIoRun->TransferBuffer != NULL) {

                    UdfFreePool( &ThisIoRun->TransferBuffer );
                }
            }
        }

        //
        //  Now handle the case where we failed in the process
        //  of allocating associated Irps and Mdls.
        //

        if (ThisIoRun->SavedIrp != NULL) {

            if (ThisIoRun->SavedIrp->MdlAddress != NULL) {

                IoFreeMdl( ThisIoRun->SavedIrp->MdlAddress );
            }

            IoFreeIrp( ThisIoRun->SavedIrp );
        }

        //
        //  Move to the previous IoRun entry.
        //

        ThisIoRun -= 1;
        RemainingEntries -= 1;
    }

    //
    //  If we copied any data then flush the Io buffers.
    //

    return FlushIoBuffers;
}


//
//  Local support routine
//

VOID
UdfMultipleAsync (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG RunCount,
    IN PIO_RUN IoRuns
    )

/*++

Routine Description:

    This routine first does the initial setup required of a Master IRP that is
    going to be completed using associated IRPs.  This routine should not
    be used if only one async request is needed, instead the single read
    async routines should be called.

    A context parameter is initialized, to serve as a communications area
    between here and the common completion routine.

    Next this routine reads or writes one or more contiguous sectors from
    a device asynchronously, and is used if there are multiple reads for a
    master IRP.  A completion routine is used to synchronize with the
    completion of all of the I/O requests started by calls to this routine.

    Also, prior to calling this routine the caller must initialize the
    IoStatus field in the Context, with the correct success status and byte
    count which are expected if all of the parallel transfers complete
    successfully.  After return this status will be unchanged if all requests
    were, in fact, successful.  However, if one or more errors occur, the
    IoStatus will be modified to reflect the error status and byte count
    from the first run (by Vbo) which encountered an error.  I/O status
    from all subsequent runs will not be indicated.

Arguments:

    RunCount - Supplies the number of multiple async requests
        that will be issued against the master irp.

    IoRuns - Supplies an array containing the Offset and ByteCount for the
        separate requests.

Return Value:

    None.

--*/

{
    PIO_COMPLETION_ROUTINE CompletionRoutine;
    PIO_STACK_LOCATION IrpSp;
    PMDL Mdl;
    PIRP Irp;
    PIRP MasterIrp;
    ULONG UnwindRunCount;

    PAGED_CODE();

    //
    //  Set up things according to whether this is truely async.
    //

    CompletionRoutine = UdfMultiSyncCompletionRoutine;

    if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {

        CompletionRoutine = UdfMultiAsyncCompletionRoutine;
    }

    //
    //  Initialize some local variables.
    //

    MasterIrp = IrpContext->Irp;

    //
    //  Itterate through the runs, doing everything that can fail.
    //  We let the cleanup in CdFinishBuffers clean up on error.
    //

    for (UnwindRunCount = 0;
         UnwindRunCount < RunCount;
         UnwindRunCount += 1) {

        //
        //  Create an associated IRP, making sure there is one stack entry for
        //  us, as well.
        //

        IoRuns[UnwindRunCount].SavedIrp =
        Irp = IoMakeAssociatedIrp( MasterIrp, (CCHAR)(IrpContext->Vcb->TargetDeviceObject->StackSize + 1) );

        if (Irp == NULL) {

            IrpContext->Irp->IoStatus.Information = 0;
            UdfRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
        }

        //
        // Allocate and build a partial Mdl for the request.
        //

        Mdl = IoAllocateMdl( IoRuns[UnwindRunCount].TransferVirtualAddress,
                             IoRuns[UnwindRunCount].DiskByteCount,
                             FALSE,
                             FALSE,
                             Irp );

        if (Mdl == NULL) {

            IrpContext->Irp->IoStatus.Information = 0;
            UdfRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
        }

        IoBuildPartialMdl( IoRuns[UnwindRunCount].TransferMdl,
                           Mdl,
                           IoRuns[UnwindRunCount].TransferVirtualAddress,
                           IoRuns[UnwindRunCount].DiskByteCount );

        //
        //  Get the first IRP stack location in the associated Irp
        //

        IoSetNextIrpStackLocation( Irp );
        IrpSp = IoGetCurrentIrpStackLocation( Irp );

        //
        //  Setup the Stack location to describe our read.
        //

        IrpSp->MajorFunction = IRP_MJ_READ;
        IrpSp->Parameters.Read.Length = IoRuns[UnwindRunCount].DiskByteCount;
        IrpSp->Parameters.Read.ByteOffset.QuadPart = IoRuns[UnwindRunCount].DiskOffset;

        //
        // Set up the completion routine address in our stack frame.
        //

        IoSetCompletionRoutine( Irp,
                                CompletionRoutine,
                                IrpContext->IoContext,
                                TRUE,
                                TRUE,
                                TRUE );

        //
        //  Setup the next IRP stack location in the associated Irp for the disk
        //  driver beneath us.
        //

        IrpSp = IoGetNextIrpStackLocation( Irp );

        //
        //  Setup the Stack location to do a read from the disk driver.
        //

        IrpSp->MajorFunction = IRP_MJ_READ;
        IrpSp->Parameters.Read.Length = IoRuns[UnwindRunCount].DiskByteCount;
        IrpSp->Parameters.Read.ByteOffset.QuadPart = IoRuns[UnwindRunCount].DiskOffset;
    }

    //
    //  We only need to set the associated IRP count in the master irp to
    //  make it a master IRP.  But we set the count to one more than our
    //  caller requested, because we do not want the I/O system to complete
    //  the I/O.  We also set our own count.
    //

    IrpContext->IoContext->IrpCount = RunCount;
    IrpContext->IoContext->MasterIrp = MasterIrp;

    //
    //  We set the count in the master Irp to 1 since typically we
    //  will clean up the associated irps ourselves.  Setting this to one
    //  means completing the last associated Irp with SUCCESS (in the async
    //  case) will complete the master irp.
    //

    MasterIrp->AssociatedIrp.IrpCount = 1;

    //
    //  Now that all the dangerous work is done, issue the Io requests
    //

    for (UnwindRunCount = 0;
         UnwindRunCount < RunCount;
         UnwindRunCount++) {

        Irp = IoRuns[UnwindRunCount].SavedIrp;
        IoRuns[UnwindRunCount].SavedIrp = NULL;

        //
        //  If IoCallDriver returns an error, it has completed the Irp
        //  and the error will be caught by our completion routines
        //  and dealt with as a normal IO error.
        //

        (VOID) IoCallDriver( IrpContext->Vcb->TargetDeviceObject, Irp );
    }

    return;
}


//
//  Local support routine
//

VOID
UdfSingleAsync (
    IN PIRP_CONTEXT IrpContext,
    IN LONGLONG ByteOffset,
    IN ULONG ByteCount
    )

/*++

Routine Description:

    This routine reads one or more contiguous sectors from a device
    asynchronously, and is used if there is only one read necessary to
    complete the IRP.  It implements the read by simply filling
    in the next stack frame in the Irp, and passing it on.  The transfer
    occurs to the single buffer originally specified in the user request.

Arguments:

    ByteOffset - Supplies the starting Logical Byte Offset to begin reading from

    ByteCount - Supplies the number of bytes to read from the device

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION IrpSp;
    PIO_COMPLETION_ROUTINE CompletionRoutine;

    PAGED_CODE();

    //
    //  Set up things according to whether this is truely async.
    //

    if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {

        CompletionRoutine = UdfSingleSyncCompletionRoutine;

    } else {

        CompletionRoutine = UdfSingleAsyncCompletionRoutine;
    }

    //
    // Set up the completion routine address in our stack frame.
    //

    IoSetCompletionRoutine( IrpContext->Irp,
                            CompletionRoutine,
                            IrpContext->IoContext,
                            TRUE,
                            TRUE,
                            TRUE );

    //
    //  Setup the next IRP stack location in the associated Irp for the disk
    //  driver beneath us.
    //

    IrpSp = IoGetNextIrpStackLocation( IrpContext->Irp );

    //
    //  Setup the Stack location to do a read from the disk driver.
    //

    IrpSp->MajorFunction = IrpContext->MajorFunction;
    IrpSp->Parameters.Read.Length = ByteCount;
    IrpSp->Parameters.Read.ByteOffset.QuadPart = ByteOffset;

    //
    //  Issue the Io request
    //

    //
    //  If IoCallDriver returns an error, it has completed the Irp
    //  and the error will be caught by our completion routines
    //  and dealt with as a normal IO error.
    //

    (VOID)IoCallDriver( IrpContext->Vcb->TargetDeviceObject, IrpContext->Irp );
}


//
//  Local support routine
//

VOID
UdfWaitSync (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine waits for one or more previously started I/O requests
    from the above routines, by simply waiting on the event.

Arguments:

Return Value:

    None

--*/

{
    PAGED_CODE();

    KeWaitForSingleObject( &IrpContext->IoContext->SyncEvent,
                           Executive,
                           KernelMode,
                           FALSE,
                           NULL );

    KeClearEvent( &IrpContext->IoContext->SyncEvent );

    return;
}


//
//  Local support routine
//

NTSTATUS
UdfMultiSyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the completion routine for all synchronous reads
    started via UdfMultipleAsync.

    The completion routine has has the following responsibilities:

        If the individual request was completed with an error, then
        this completion routine must see if this is the first error
        and remember the error status in the Context.

        If the IrpCount goes to 1, then it sets the event in the Context
        parameter to signal the caller that all of the asynch requests
        are done.

Arguments:

    DeviceObject - Pointer to the file system device object.

    Irp - Pointer to the associated Irp which is being completed.  (This
        Irp will no longer be accessible after this routine returns.)

    Context - The context parameter which was specified for all of
        the multiple asynch I/O requests for this MasterIrp.

Return Value:

    The routine returns STATUS_MORE_PROCESSING_REQUIRED so that we can
    immediately complete the Master Irp without being in a race condition
    with the IoCompleteRequest thread trying to decrement the IrpCount in
    the Master Irp.

--*/

{
    PUDF_IO_CONTEXT IoContext = Context;

    //
    //  If we got an error (or verify required), remember it in the Irp
    //

    if (!NT_SUCCESS( Irp->IoStatus.Status )) {

        InterlockedExchange( &IoContext->Status, Irp->IoStatus.Status );
        IoContext->MasterIrp->IoStatus.Information = 0;
    }

    //
    //  We must do this here since IoCompleteRequest won't get a chance
    //  on this associated Irp.
    //

    IoFreeMdl( Irp->MdlAddress );
    IoFreeIrp( Irp );

    if (InterlockedDecrement( &IoContext->IrpCount ) == 0) {

        //
        //  Update the Master Irp with any error status from the associated Irps.
        //

        IoContext->MasterIrp->IoStatus.Status = IoContext->Status;
        KeSetEvent( &IoContext->SyncEvent, 0, FALSE );
    }

    UNREFERENCED_PARAMETER( DeviceObject );

    return STATUS_MORE_PROCESSING_REQUIRED;
}


//
//  Local support routine
//

NTSTATUS
UdfMultiAsyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the completion routine for all asynchronous reads
    started via UdfMultipleAsync.

    The completion routine has has the following responsibilities:

        If the individual request was completed with an error, then
        this completion routine must see if this is the first error
        and remember the error status in the Context.

Arguments:

    DeviceObject - Pointer to the file system device object.

    Irp - Pointer to the associated Irp which is being completed.  (This
        Irp will no longer be accessible after this routine returns.)

    Context - The context parameter which was specified for all of
             the multiple asynch I/O requests for this MasterIrp.

Return Value:

    Currently always returns STATUS_SUCCESS.

--*/

{
    PUDF_IO_CONTEXT IoContext = Context;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  If we got an error (or verify required), remember it in the Irp
    //

    if (!NT_SUCCESS( Irp->IoStatus.Status )) {

        InterlockedExchange( &IoContext->Status, Irp->IoStatus.Status );
    }

    //
    //  Decrement IrpCount and see if it goes to zero.
    //

    if (InterlockedDecrement( &IoContext->IrpCount ) == 0) {

        //
        //  Mark the master Irp pending
        //

        IoMarkIrpPending( IoContext->MasterIrp );

        //
        //  Update the Master Irp with any error status from the associated Irps.
        //

        IoContext->MasterIrp->IoStatus.Status = IoContext->Status;

        //
        //  Update the information field with the correct value.
        //

        IoContext->MasterIrp->IoStatus.Information = 0;

        if (NT_SUCCESS( IoContext->MasterIrp->IoStatus.Status )) {

            IoContext->MasterIrp->IoStatus.Information = IoContext->RequestedByteCount;
        }

        //
        //  Now release the resource
        //

        ExReleaseResourceForThreadLite( IoContext->Resource,
                                    IoContext->ResourceThreadId );

        //
        //  and finally, free the context record.
        //

        UdfFreeIoContext( IoContext );

        //
        //  Return success in this case.
        //

        return STATUS_SUCCESS;

    } else {

        //
        //  We need to cleanup the associated Irp and its Mdl.
        //

        IoFreeMdl( Irp->MdlAddress );
        IoFreeIrp( Irp );

        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    UNREFERENCED_PARAMETER( DeviceObject );
}


//
//  Local support routine
//

NTSTATUS
UdfSingleSyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the completion routine for all reads started via UdfSingleAsync.

    The completion routine has has the following responsibilities:

        It sets the event in the Context parameter to signal the caller
        that all of the asynch requests are done.

Arguments:

    DeviceObject - Pointer to the file system device object.

    Irp - Pointer to the Irp for this request.  (This Irp will no longer
        be accessible after this routine returns.)

    Context - The context parameter which was specified in the call to
        UdfSingleAsynch.

Return Value:

    The routine returns STATUS_MORE_PROCESSING_REQUIRED so that we can
    immediately complete the Master Irp without being in a race condition
    with the IoCompleteRequest thread trying to decrement the IrpCount in
    the Master Irp.

--*/

{
    //
    //  Store the correct information field into the Irp.
    //

    if (!NT_SUCCESS( Irp->IoStatus.Status )) {

        Irp->IoStatus.Information = 0;
    }

    KeSetEvent( &((PUDF_IO_CONTEXT)Context)->SyncEvent, 0, FALSE );

    return STATUS_MORE_PROCESSING_REQUIRED;

    UNREFERENCED_PARAMETER( DeviceObject );
}


//
//  Local support routine
//

NTSTATUS
UdfSingleAsyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the completion routine for all asynchronous reads
    started via UdfSingleAsynch.

Arguments:

    DeviceObject - Pointer to the file system device object.

    Irp - Pointer to the Irp for this request.  (This Irp will no longer
        be accessible after this routine returns.)

    Context - The context parameter which was specified in the call to
        UdfSingleAsynch.

Return Value:

    Currently always returns STATUS_SUCCESS.

--*/

{
    //
    //  Update the information field with the correct value for bytes read.
    //

    Irp->IoStatus.Information = 0;

    if (NT_SUCCESS( Irp->IoStatus.Status )) {

        Irp->IoStatus.Information = ((PUDF_IO_CONTEXT) Context)->RequestedByteCount;
    }

    //
    //  Mark the Irp pending
    //

    IoMarkIrpPending( Irp );

    //
    //  Now release the resource
    //

    ExReleaseResourceForThreadLite( ((PUDF_IO_CONTEXT) Context)->Resource,
                                ((PUDF_IO_CONTEXT) Context)->ResourceThreadId );

    //
    //  and finally, free the context record.
    //

    UdfFreeIoContext( (PUDF_IO_CONTEXT) Context );
    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER( DeviceObject );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\udfs\fileinfo.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    FileInfo.c

Abstract:

    This module implements the File Information routines for Udfs called by
    the Fsd/Fsp dispatch drivers.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]     16-Jan-1997

Revision History:

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_FILEINFO)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_FILEINFO)

//
//  Local macros
//

INLINE
ULONG
UdfGetExtraFileAttributes (
    IN PCCB Ccb
    )

/*++

Routine Description:

    Safely figure out extra name-based file attributes given a context block.

Arguments:

    Ccb - a context block to examine.

Return Value:

    ULONG - file attributes for a file based on how it was opened (seperate from
        those based on the object that was opened).

--*/

{
    return ( Ccb->Lcb != NULL? Ccb->Lcb->FileAttributes : 0 );
}

//
//  Local support routines
//

VOID
UdfQueryBasicInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN OUT PFILE_BASIC_INFORMATION Buffer,
    IN OUT PULONG Length
    );

VOID
UdfQueryStandardInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_STANDARD_INFORMATION Buffer,
    IN OUT PULONG Length
    );

VOID
UdfQueryInternalInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_INTERNAL_INFORMATION Buffer,
    IN OUT PULONG Length
    );

VOID
UdfQueryEaInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_EA_INFORMATION Buffer,
    IN OUT PULONG Length
    );

VOID
UdfQueryPositionInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN OUT PFILE_POSITION_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
UdfQueryNameInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN OUT PFILE_NAME_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
UdfQueryAlternateNameInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN OUT PFILE_NAME_INFORMATION Buffer,
    IN OUT PULONG Length
    );

VOID
UdfQueryNetworkInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    IN OUT PULONG Length
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfCommonQueryInfo)
#pragma alloc_text(PAGE, UdfCommonSetInfo)
#pragma alloc_text(PAGE, UdfFastQueryBasicInfo)
#pragma alloc_text(PAGE, UdfFastQueryStdInfo)
#pragma alloc_text(PAGE, UdfFastQueryNetworkInfo)
#pragma alloc_text(PAGE, UdfQueryAlternateNameInfo)
#pragma alloc_text(PAGE, UdfQueryBasicInfo)
#pragma alloc_text(PAGE, UdfQueryEaInfo)
#pragma alloc_text(PAGE, UdfQueryInternalInfo)
#pragma alloc_text(PAGE, UdfQueryNameInfo)
#pragma alloc_text(PAGE, UdfQueryNetworkInfo)
#pragma alloc_text(PAGE, UdfQueryPositionInfo)
#pragma alloc_text(PAGE, UdfQueryStandardInfo)
#endif


NTSTATUS
UdfCommonQueryInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for query file information called by both the
    fsd and fsp threads.

Arguments:

    Irp - Supplies the Irp to process.

Return Value:

    NTSTATUS - The return status for this operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    ULONG Length;
    FILE_INFORMATION_CLASS FileInformationClass;
    PFILE_ALL_INFORMATION Buffer;

    TYPE_OF_OPEN TypeOfOpen;
    PFCB Fcb;
    PCCB Ccb;

    BOOLEAN ReleaseFcb = FALSE;

    PAGED_CODE();

    //
    //  Reference our input parameters to make things easier
    //

    Length = IrpSp->Parameters.QueryFile.Length;
    FileInformationClass = IrpSp->Parameters.QueryFile.FileInformationClass;
    Buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    //  Decode the file object
    //

    TypeOfOpen = UdfDecodeFileObject( IrpSp->FileObject, &Fcb, &Ccb );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  We only support query on file and directory handles.
        //

        switch (TypeOfOpen) {

        case UserDirectoryOpen :
        case UserFileOpen :

            //
            //  Acquire shared access to this file.  NOTE that this could be
            //  a recursive acquire,  if we already preacquired in
            //  UdfAcquireForCreateSection().
            //

            UdfAcquireFileShared( IrpContext, Fcb );
            ReleaseFcb = TRUE;

            ASSERT( FlagOn( Fcb->FcbState, FCB_STATE_INITIALIZED ));
            
            //
            //  Make sure the Fcb is in a usable condition.  This will raise
            //  an error condition if the volume is unusable
            //

            UdfVerifyFcbOperation( IrpContext, Fcb );

            //
            //  Based on the information class we'll do different
            //  actions.  Each of hte procedures that we're calling fills
            //  up the output buffer, if possible.  They will raise the
            //  status STATUS_BUFFER_OVERFLOW for an insufficient buffer.
            //  This is considered a somewhat unusual case and is handled
            //  more cleanly with the exception mechanism rather than
            //  testing a return status value for each call.
            //

            switch (FileInformationClass) {

            case FileAllInformation:

                //
                //  We don't allow this operation on a file opened by file Id.
                //

                if (FlagOn( Ccb->Flags, CCB_FLAG_OPEN_BY_ID )) {

                    Status = STATUS_INVALID_PARAMETER;
                    break;
                }

                //
                //  In this case go ahead and call the individual routines to
                //  fill in the buffer.  Only the name routine will
                //  pointer to the output buffer and then call the
                //  individual routines to fill in the buffer.
                //

                Length -= (sizeof( FILE_ACCESS_INFORMATION ) +
                           sizeof( FILE_MODE_INFORMATION ) +
                           sizeof( FILE_ALIGNMENT_INFORMATION ));

                UdfQueryBasicInfo( IrpContext, Fcb, Ccb, &Buffer->BasicInformation, &Length );
                UdfQueryStandardInfo( IrpContext, Fcb, &Buffer->StandardInformation, &Length );
                UdfQueryInternalInfo( IrpContext, Fcb, &Buffer->InternalInformation, &Length );
                UdfQueryEaInfo( IrpContext, Fcb, &Buffer->EaInformation, &Length );
                UdfQueryPositionInfo( IrpContext, IrpSp->FileObject, &Buffer->PositionInformation, &Length );
                Status = UdfQueryNameInfo( IrpContext, IrpSp->FileObject, &Buffer->NameInformation, &Length );

                break;

            case FileBasicInformation:

                UdfQueryBasicInfo( IrpContext, Fcb, Ccb, (PFILE_BASIC_INFORMATION) Buffer, &Length );
                break;

            case FileStandardInformation:

                UdfQueryStandardInfo( IrpContext, Fcb, (PFILE_STANDARD_INFORMATION) Buffer, &Length );
                break;

            case FileInternalInformation:

                UdfQueryInternalInfo( IrpContext, Fcb, (PFILE_INTERNAL_INFORMATION) Buffer, &Length );
                break;

            case FileEaInformation:

                UdfQueryEaInfo( IrpContext, Fcb, (PFILE_EA_INFORMATION) Buffer, &Length );
                break;

            case FilePositionInformation:

                UdfQueryPositionInfo( IrpContext, IrpSp->FileObject, (PFILE_POSITION_INFORMATION) Buffer, &Length );
                break;

            case FileNameInformation:

                //
                //  We don't allow this operation on a file opened by file Id.
                //

                if (!FlagOn( Ccb->Flags, CCB_FLAG_OPEN_BY_ID )) {

                    Status = UdfQueryNameInfo( IrpContext, IrpSp->FileObject, (PFILE_NAME_INFORMATION) Buffer, &Length );

                } else {

                    Status = STATUS_INVALID_PARAMETER;
                }

                break;

            case FileAlternateNameInformation:

                if (!FlagOn( Ccb->Flags, CCB_FLAG_OPEN_BY_ID )) {

                    Status = UdfQueryAlternateNameInfo( IrpContext, Fcb, Ccb, (PFILE_NAME_INFORMATION) Buffer, &Length );

                } else {

                    Status = STATUS_INVALID_PARAMETER;
                }

                break;

            case FileNetworkOpenInformation:

                UdfQueryNetworkInfo( IrpContext, Fcb, Ccb, (PFILE_NETWORK_OPEN_INFORMATION) Buffer, &Length );
                break;

            default :

                Status = STATUS_INVALID_PARAMETER;
            }

            break;

        default :

            Status = STATUS_INVALID_PARAMETER;
        }

        //
        //  Set the information field to the number of bytes actually filled in
        //  and then complete the request
        //

        Irp->IoStatus.Information = IrpSp->Parameters.QueryFile.Length - Length;

    } finally {

        //
        //  Release the file.
        //

        if (ReleaseFcb) {

            UdfReleaseFile( IrpContext, Fcb );
        }
    }

    //
    //  Complete the request if we didn't raise.
    //

    UdfCompleteRequest( IrpContext, Irp, Status );

    return Status;
}


NTSTATUS
UdfCommonSetInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for set file information called by both the
    fsd and fsp threads.  We only support operations which set the file position.

Arguments:

    Irp - Supplies the Irp to process.

Return Value:

    NTSTATUS - The return status for this operation.

--*/

{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    TYPE_OF_OPEN TypeOfOpen;
    PFCB Fcb;
    PCCB Ccb;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PFILE_POSITION_INFORMATION Buffer;

    PAGED_CODE();

    //
    //  Decode the file object
    //

    TypeOfOpen = UdfDecodeFileObject( IrpSp->FileObject, &Fcb, &Ccb );

    //
    //  We only support a SetPositionInformation on a user file.
    //

    if ((TypeOfOpen != UserFileOpen) ||
        (IrpSp->Parameters.QueryFile.FileInformationClass != FilePositionInformation)) {

        UdfCompleteRequest( IrpContext, Irp, Status );
        return Status;
    }

    //
    //  Acquire shared access to this file.
    //

    UdfAcquireFileShared( IrpContext, Fcb );

    try {

        //
        //  Make sure the Fcb is in a usable condition.  This
        //  will raise an error condition if the fcb is unusable
        //

        UdfVerifyFcbOperation( IrpContext, Fcb );

        Buffer = Irp->AssociatedIrp.SystemBuffer;

        //
        //  Check if the file does not use intermediate buffering.  If it
        //  does not use intermediate buffering then the new position we're
        //  supplied must be aligned properly for the device
        //

        if (FlagOn( IrpSp->FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING ) &&
            ((Buffer->CurrentByteOffset.LowPart & IrpSp->DeviceObject->AlignmentRequirement) != 0)) {

            try_leave( NOTHING );
        }

        //
        //  The input parameter is fine so set the current byte offset and
        //  complete the request
        //

        //
        //  Lock the Fcb to provide synchronization.
        //

        UdfLockFcb( IrpContext, Fcb );
        IrpSp->FileObject->CurrentByteOffset = Buffer->CurrentByteOffset;
        UdfUnlockFcb( IrpContext, Fcb );

        Status = STATUS_SUCCESS;

    } finally {

        UdfReleaseFile( IrpContext, Fcb );
    }

    //
    //  Complete the request if there was no raise.
    //

    UdfCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


BOOLEAN
UdfFastQueryBasicInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is for the fast query call for basic file information.

Arguments:

    FileObject - Supplies the file object used in this operation

    Wait - Indicates if we are allowed to wait for the information

    Buffer - Supplies the output buffer to receive the basic information

    IoStatus - Receives the final status of the operation

Return Value:

    BOOLEAN - TRUE if the operation succeeded and FALSE if the caller
        needs to take the long route.

--*/

{
    BOOLEAN Result = FALSE;
    TYPE_OF_OPEN TypeOfOpen;

    PFCB Fcb;
    PCCB Ccb;

    PAGED_CODE();

    ASSERT_FILE_OBJECT( FileObject );

    FsRtlEnterFileSystem();

    //
    //  Decode the file object to find the type of open and the data
    //  structures.
    //

    TypeOfOpen = UdfDecodeFileObject( FileObject, &Fcb, &Ccb );

    //
    //  We only support this request on user file or directory objects.
    //

    ASSERT( FlagOn( Fcb->FcbState, FCB_STATE_INITIALIZED ));
    
    if (TypeOfOpen != UserFileOpen && TypeOfOpen != UserDirectoryOpen) {

        FsRtlExitFileSystem();
        return FALSE;
    }

    //
    //  Acquire the file shared to access the Fcb.
    //

    if (!ExAcquireResourceSharedLite( Fcb->Resource, Wait )) {

        FsRtlExitFileSystem();
        return FALSE;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Only deal with 'good' Fcb's.
        //

        if (UdfVerifyFcbOperation( NULL, Fcb )) {

            //
            //  Fill in the input buffer from the Fcb fields.
            //

            Buffer->CreationTime = Fcb->Timestamps.CreationTime;
            Buffer->LastWriteTime =
            Buffer->ChangeTime =  Fcb->Timestamps.ModificationTime;
            Buffer->LastAccessTime = Fcb->Timestamps.AccessTime;

            Buffer->FileAttributes = Fcb->FileAttributes | UdfGetExtraFileAttributes( Ccb );

            //
            //  Update the IoStatus block with the size of this data.
            //

            IoStatus->Status = STATUS_SUCCESS;
            IoStatus->Information = sizeof( FILE_BASIC_INFORMATION );

            Result = TRUE;
        }

    } finally {

        ExReleaseResourceLite( Fcb->Resource );

        FsRtlExitFileSystem();
    }

    return Result;
}


BOOLEAN
UdfFastQueryStdInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is for the fast query call for standard file information.

Arguments:

    FileObject - Supplies the file object used in this operation

    Wait - Indicates if we are allowed to wait for the information

    Buffer - Supplies the output buffer to receive the basic information

    IoStatus - Receives the final status of the operation

Return Value:

    BOOLEAN - TRUE if the operation succeeded and FALSE if the caller
        needs to take the long route.

--*/

{
    BOOLEAN Result = FALSE;
    TYPE_OF_OPEN TypeOfOpen;

    PFCB Fcb;

    PAGED_CODE();

    ASSERT_FILE_OBJECT( FileObject );

    FsRtlEnterFileSystem();

    //
    //  Decode the file object to find the type of open and the data
    //  structures.
    //

    TypeOfOpen = UdfFastDecodeFileObject( FileObject, &Fcb );

    //
    //  We only support this request on initialized user file or directory objects.
    //

    if (TypeOfOpen != UserFileOpen && TypeOfOpen != UserDirectoryOpen) {

        FsRtlExitFileSystem();
        return FALSE;
    }

    //
    //  Acquire the file shared to access the Fcb.
    //

    if (!ExAcquireResourceSharedLite( Fcb->Resource, Wait )) {

        FsRtlExitFileSystem();
        return FALSE;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Only deal with 'good' Fcb's.
        //

        if (UdfVerifyFcbOperation( NULL, Fcb )) {

            //
            //  Check whether this is a directory.
            //

            if (FlagOn( Fcb->FileAttributes, FILE_ATTRIBUTE_DIRECTORY )) {

                Buffer->AllocationSize.QuadPart =
                Buffer->EndOfFile.QuadPart = 0;

                Buffer->Directory = TRUE;

            } else {

                Buffer->AllocationSize.QuadPart = Fcb->AllocationSize.QuadPart;
                Buffer->EndOfFile.QuadPart = Fcb->FileSize.QuadPart;

                Buffer->Directory = FALSE;
            }

            Buffer->NumberOfLinks = Fcb->LinkCount;
            Buffer->DeletePending = FALSE;

            //
            //  Update the IoStatus block with the size of this data.
            //

            IoStatus->Status = STATUS_SUCCESS;
            IoStatus->Information = sizeof( FILE_STANDARD_INFORMATION );

            Result = TRUE;
        }

    } finally {

        ExReleaseResourceLite( Fcb->Resource );

        FsRtlExitFileSystem();
    }

    return Result;
}


BOOLEAN
UdfFastQueryNetworkInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is for the fast query call for network file information.

Arguments:

    FileObject - Supplies the file object used in this operation

    Wait - Indicates if we are allowed to wait for the information

    Buffer - Supplies the output buffer to receive the basic information

    IoStatus - Receives the final status of the operation

Return Value:

    BOOLEAN - TRUE if the operation succeeded and FALSE if the caller
        needs to take the long route.

--*/

{
    BOOLEAN Result = FALSE;
    TYPE_OF_OPEN TypeOfOpen;

    PFCB Fcb;
    PCCB Ccb;

    PAGED_CODE();

    ASSERT_FILE_OBJECT( FileObject );

    FsRtlEnterFileSystem();

    //
    //  Decode the file object to find the type of open and the data
    //  structures.
    //

    TypeOfOpen = UdfDecodeFileObject( FileObject, &Fcb, &Ccb );

    //
    //  We only support this request on user file or directory objects.
    //

    if (TypeOfOpen != UserFileOpen && TypeOfOpen != UserDirectoryOpen) {

        FsRtlExitFileSystem();
        return FALSE;
    }

    //
    //  Acquire the file shared to access the Fcb.
    //

    if (!ExAcquireResourceSharedLite( Fcb->Resource, Wait )) {

        FsRtlExitFileSystem();
        return FALSE;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Only deal with 'good' Fcb's.
        //

        if (UdfVerifyFcbOperation( NULL, Fcb )) {

            //
            //  Fill in the input buffer from the Fcb fields.
            //

            Buffer->CreationTime = Fcb->Timestamps.CreationTime;
            Buffer->LastWriteTime =
            Buffer->ChangeTime =  Fcb->Timestamps.ModificationTime;
            Buffer->LastAccessTime = Fcb->Timestamps.AccessTime;

            Buffer->FileAttributes = Fcb->FileAttributes | UdfGetExtraFileAttributes( Ccb );

            //
            //  Check whether this is a directory.
            //

            if (FlagOn( Fcb->FileAttributes, FILE_ATTRIBUTE_DIRECTORY )) {

                Buffer->AllocationSize.QuadPart =
                Buffer->EndOfFile.QuadPart = 0;

            } else {

                Buffer->AllocationSize.QuadPart = Fcb->AllocationSize.QuadPart;
                Buffer->EndOfFile.QuadPart = Fcb->FileSize.QuadPart;
            }

            //
            //  Update the IoStatus block with the size of this data.
            //

            IoStatus->Status = STATUS_SUCCESS;
            IoStatus->Information = sizeof( FILE_NETWORK_OPEN_INFORMATION );

            Result = TRUE;
        }

    } finally {

        ExReleaseResourceLite( Fcb->Resource );

        FsRtlExitFileSystem();
    }

    return Result;
}


//
//  Local support routine
//

VOID
UdfQueryBasicInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN OUT PFILE_BASIC_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

 Description:

    This routine performs the query basic information function for Udfs

Arguments:

    Fcb - Supplies the Fcb being queried, it has been verified
    
    Ccb - Supplies the Ccb associated with the fileobject being queried

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  We support all times on Udfs.
    //

    Buffer->CreationTime = Fcb->Timestamps.CreationTime;
    Buffer->LastWriteTime =
    Buffer->ChangeTime =  Fcb->Timestamps.ModificationTime;
    Buffer->LastAccessTime = Fcb->Timestamps.AccessTime;

    Buffer->FileAttributes = Fcb->FileAttributes | UdfGetExtraFileAttributes( Ccb );

    //
    //  Update the length and status output variables
    //

    *Length -= sizeof( FILE_BASIC_INFORMATION );

    return;
}


//
//  Local support routine
//

VOID
UdfQueryStandardInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_STANDARD_INFORMATION Buffer,
    IN OUT PULONG Length
    )
/*++

Routine Description:

    This routine performs the query standard information function for Udfs.

Arguments:

    Fcb - Supplies the Fcb being queried, it has been verified

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  Delete is never pending on a readonly file.
    //

    Buffer->NumberOfLinks = Fcb->LinkCount;
    Buffer->DeletePending = FALSE;

    //
    //  We get the sizes from the header.  Return a size of zero
    //  for all directories.
    //

    if (FlagOn( Fcb->FileAttributes, FILE_ATTRIBUTE_DIRECTORY )) {

        Buffer->AllocationSize.QuadPart =
        Buffer->EndOfFile.QuadPart = 0;

        Buffer->Directory = TRUE;

    } else {

        Buffer->AllocationSize.QuadPart = Fcb->AllocationSize.QuadPart;
        Buffer->EndOfFile.QuadPart = Fcb->FileSize.QuadPart;

        Buffer->Directory = FALSE;
    }

    //
    //  Update the length and status output variables
    //

    *Length -= sizeof( FILE_STANDARD_INFORMATION );

    return;
}


//
//  Local support routine
//

VOID
UdfQueryInternalInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_INTERNAL_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine performs the query internal information function for Udfs.

Arguments:

    Fcb - Supplies the Fcb being queried, it has been verified

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  Index number is the file Id number in the Fcb.
    //

    Buffer->IndexNumber = Fcb->FileId;
    *Length -= sizeof( FILE_INTERNAL_INFORMATION );

    return;
}


//
//  Local support routine
//

VOID
UdfQueryEaInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_EA_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine performs the query Ea information function for Udfs.

Arguments:

    Fcb - Supplies the Fcb being queried, it has been verified

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  No Ea's on Udfs volumes.  At least not that our EA support would understand.
    //

    Buffer->EaSize = 0;
    *Length -= sizeof( FILE_EA_INFORMATION );

    return;
}


//
//  Local support routine
//

VOID
UdfQueryPositionInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN OUT PFILE_POSITION_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine performs the query position information function for Udfs.

Arguments:

    FileObject - Supplies the File object being queried

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  Get the current position found in the file object.
    //

    Buffer->CurrentByteOffset = FileObject->CurrentByteOffset;

    //
    //  Update the length and status output variables
    //

    *Length -= sizeof( FILE_POSITION_INFORMATION );

    return;
}


//
//  Local support routine
//

NTSTATUS
UdfQueryNameInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN OUT PFILE_NAME_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine performs the query name information function for Udfs.

Arguments:

    FileObject - Supplies the file object containing the name.

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    NTSTATUS - STATUS_BUFFER_OVERFLOW if the entire name can't be copied.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG LengthToCopy;

    PAGED_CODE();

    ASSERT(*Length >= sizeof(ULONG));
    
    //
    //  Simply copy the name in the file object to the user's buffer.
    //

    //
    //  Place the size of the filename in the user's buffer and reduce the remaining
    //  size to match.
    //

    Buffer->FileNameLength = LengthToCopy = FileObject->FileName.Length;
    *Length -= sizeof(ULONG);

    if (LengthToCopy > *Length) {

        LengthToCopy = *Length;
        Status = STATUS_BUFFER_OVERFLOW;
    }

    RtlCopyMemory( Buffer->FileName, FileObject->FileName.Buffer, LengthToCopy );

    //
    //  Reduce the available bytes by the amount stored into this buffer.  In the overflow
    //  case, this simply drops to zero.  The returned filenamelength will indicate to the
    //  caller how much space is required.
    //

    *Length -= LengthToCopy;

    return Status;
}


//
//  Local support routine
//

NTSTATUS
UdfQueryAlternateNameInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN OUT PFILE_NAME_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine performs the query alternate name information function.
    We lookup the dirent for this file and then check if there is a
    short name.

Arguments:

    Fcb - Supplies the Fcb being queried, it has been verified.

    Ccb - Ccb for this open handle.

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned.

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    NTSTATUS - STATUS_SUCCESS if the whole name would fit into the user buffer,
               STATUS_OBJECT_NAME_NOT_FOUND if we can't return the name,
               STATUS_BUFFER_OVERFLOW otherwise.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    DIR_ENUM_CONTEXT DirContext;

    PLCB Lcb;
    
    PFCB ParentFcb;
    BOOLEAN ReleaseParentFcb = FALSE;

    BOOLEAN CleanupDirContext = FALSE;
    BOOLEAN Result;

    PUNICODE_STRING ShortName;

    UNICODE_STRING LocalShortName;
    WCHAR LocalShortNameBuffer[ BYTE_COUNT_8_DOT_3 / sizeof(WCHAR) ];
    
    PAGED_CODE();

    //
    //  Initialize the buffer length to zero.
    //

    Buffer->FileNameLength = 0;

    //
    //  If there was no associated Lcb then there is no short name.
    //

    Lcb = Ccb->Lcb;
    
    if (Lcb == NULL) {

        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    //
    //  Use a try-finally to cleanup the structures.
    //

    try {

        if (FlagOn( Lcb->Flags, LCB_FLAG_SHORT_NAME )) {

            //
            //  This caller opened the file by a generated short name, so simply hand it back.
            //

            ShortName = &Lcb->FileName;
        
        } else {

            //
            //  The open occured by a regular name.  Now, if this name is already 8.3 legal then
            //  there is no short name.
            //

            if (UdfIs8dot3Name( IrpContext, Lcb->FileName )) {

                try_leave( Status = STATUS_OBJECT_NAME_NOT_FOUND );
            }

            //
            //  This name has a generated short name.  In order to calculate this name we have to
            //  retrieve the FID for this file, since UDF specifies that a short name is uniquified
            //  with a CRC of the original in-FID byte representation of the filename.
            //
            //  N.B.: if this is a common operation, we may wish to cache the CRC in the Lcb.
            //

            ParentFcb = Lcb->ParentFcb;
            UdfAcquireFileShared( IrpContext, ParentFcb );
            ReleaseParentFcb = TRUE;

            //
            //  Now go find the FID for this filename in the parent.
            //

            UdfInitializeDirContext( IrpContext, &DirContext );
            CleanupDirContext = TRUE;

            Result = UdfFindDirEntry( IrpContext,
                                      ParentFcb,
                                      &Lcb->FileName,
                                      BooleanFlagOn( Lcb->Flags, LCB_FLAG_IGNORE_CASE ),
                                      FALSE,
                                      &DirContext );
            
            //
            //  We should always be able to find this entry, but don't bugcheck because
            //  we messed this up.
            //
            
            ASSERT( Result );
            
            if (!Result) {
                
                try_leave( Status = STATUS_OBJECT_NAME_NOT_FOUND );
            }

            //
            //  Build the local unicode string to use and fill it in.
            //

            ShortName = &LocalShortName;

            LocalShortName.Buffer = LocalShortNameBuffer;
            LocalShortName.Length = 0;
            LocalShortName.MaximumLength = sizeof( LocalShortNameBuffer );

            UdfGenerate8dot3Name( IrpContext,
                                  &DirContext.CaseObjectName,
                                  ShortName );
        }
        
        //
        //  We now have the short name.  We have left it in Unicode form so copy it directly.
        //

        Buffer->FileNameLength = ShortName->Length;

        if (Buffer->FileNameLength + sizeof( ULONG ) > *Length) {

            Buffer->FileNameLength = *Length - sizeof( ULONG );
            Status = STATUS_BUFFER_OVERFLOW;
        }

        RtlCopyMemory( Buffer->FileName, ShortName->Buffer, Buffer->FileNameLength );

    } finally {

        if (CleanupDirContext) {

            UdfCleanupDirContext( IrpContext, &DirContext );
        }

        if (ReleaseParentFcb) {

            UdfReleaseFile( IrpContext, ParentFcb );
        }
    }

    //
    //  Reduce the available bytes by the amount stored into this buffer.
    //

    if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {

        *Length -= sizeof( ULONG ) + Buffer->FileNameLength;
    }

    return Status;
}


//
//  Local support routine
//

VOID
UdfQueryNetworkInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

 Description:

    This routine performs the query network open information function for Udfs.

Arguments:

    Fcb - Supplies the Fcb being queried, it has been verified

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  We support all times on Udfs.
    //

    Buffer->CreationTime = Fcb->Timestamps.CreationTime;
    Buffer->LastWriteTime =
    Buffer->ChangeTime =  Fcb->Timestamps.ModificationTime;
    Buffer->LastAccessTime = Fcb->Timestamps.AccessTime;

    Buffer->FileAttributes = Fcb->FileAttributes | UdfGetExtraFileAttributes( Ccb );

    //
    //  We get the sizes from the header.  Return a size of zero
    //  for all directories.
    //

    if (FlagOn( Fcb->FileAttributes, FILE_ATTRIBUTE_DIRECTORY )) {

        Buffer->AllocationSize.QuadPart =
        Buffer->EndOfFile.QuadPart = 0;

    } else {

        Buffer->AllocationSize.QuadPart = Fcb->AllocationSize.QuadPart;
        Buffer->EndOfFile.QuadPart = Fcb->FileSize.QuadPart;
    }

    //
    //  Update the length and status output variables
    //

    *Length -= sizeof( FILE_NETWORK_OPEN_INFORMATION );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\udfs\filobsup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    FilObSup.c

Abstract:

    This module implements the Udfs File object support routines.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]     23-Sep-1996

Revision History:

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_FILOBSUP)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_FILOBSUP)

//
//  Local constants.
//

#define TYPE_OF_OPEN_MASK               (0x00000007)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfDecodeFileObject)
#pragma alloc_text(PAGE, UdfFastDecodeFileObject)
#pragma alloc_text(PAGE, UdfSetFileObject)
#endif


VOID
UdfSetFileObject (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN PFCB Fcb OPTIONAL,
    IN PCCB Ccb OPTIONAL
    )

/*++

Routine Description:

    This routine will initialize the FileObject context fields based on the
    input type and data structures.

Arguments:

    FileObject - Supplies the file object pointer being initialized.

    TypeOfOpen - Sets the type of open.

    Fcb - Fcb for this file object.  Ignored for UnopenedFileObject.

    Ccb - Ccb for the handle corresponding to this file object.  Will not
        be present for stream file objects.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    //  We only have values 0 to 7 available so make sure we didn't
    //  inadvertantly add a new type.
    //

    ASSERTMSG( "FileObject types exceed available bits\n", BeyondValidType <= 8 );

    //
    //  Setting a file object to type UnopenedFileObject means just
    //  clearing all of the context fields.  All the other input
    //

    if (TypeOfOpen == UnopenedFileObject) {

        FileObject->FsContext =
        FileObject->FsContext2 = NULL;

        return;
    }

    //
    //  Check that the 3 low-order bits of the Ccb are clear.
    //

    ASSERTMSG( "Ccb is not quad-aligned\n", !FlagOn( ((ULONG_PTR) Ccb), TYPE_OF_OPEN_MASK ));

    //
    //  We will or the type of open into the low order bits of FsContext2
    //  along with the Ccb value.
    //  The Fcb is stored into the FsContext field.
    //

    FileObject->FsContext = Fcb;
    FileObject->FsContext2 = Ccb;

    SetFlag( ((ULONG_PTR) FileObject->FsContext2), TypeOfOpen );

    //
    //  Set the Vpb field in the file object.
    //

    FileObject->Vpb = Fcb->Vcb->Vpb;

    return;
}



TYPE_OF_OPEN
UdfDecodeFileObject (
    IN PFILE_OBJECT FileObject,
    OUT PFCB *Fcb,
    OUT PCCB *Ccb
    )

/*++

Routine Description:

    This routine takes a file object and extracts the Fcb and Ccb (possibly NULL)
    and returns the type of open.

Arguments:

    FileObject - Supplies the file object pointer being initialized.

    Fcb - Address to store the Fcb contained in the file object.

    Ccb - Address to store the Ccb contained in the file object.

Return Value:

    TYPE_OF_OPEN - Indicates the type of file object.

--*/

{
    TYPE_OF_OPEN TypeOfOpen;

    PAGED_CODE();

    //
    //  If this is an unopened file object then return NULL for the
    //  Fcb/Ccb.  Don't trust any other values in the file object.
    //

    TypeOfOpen = (TYPE_OF_OPEN) FlagOn( (ULONG_PTR) FileObject->FsContext2,
                                        TYPE_OF_OPEN_MASK );

    if (TypeOfOpen == UnopenedFileObject) {

        *Fcb = NULL;
        *Ccb = NULL;

    } else {

        //
        //  The Fcb is pointed to by the FsContext field.  The Ccb is in
        //  FsContext2 (after clearing the low three bits).  The low three
        //  bits are the file object type.
        //

        *Fcb = FileObject->FsContext;
        *Ccb = FileObject->FsContext2;

        ClearFlag( (ULONG_PTR) *Ccb, TYPE_OF_OPEN_MASK );
    }

    //
    //  Now return the type of open.
    //

    return TypeOfOpen;
}


TYPE_OF_OPEN
UdfFastDecodeFileObject (
    IN PFILE_OBJECT FileObject,
    OUT PFCB *Fcb
    )

/*++

Routine Description:

    This procedure takes a pointer to a file object, that has already been
    opened by Udfs and does a quick decode operation.  It will only return
    a non null value if the file object is a user file open

Arguments:

    FileObject - Supplies the file object pointer being interrogated

    Fcb - Address to store Fcb if this is a user file object.  NULL
        otherwise.

Return Value:

    TYPE_OF_OPEN - type of open of this file object.

--*/

{
    PAGED_CODE();

    ASSERT_FILE_OBJECT( FileObject );

    //
    //  The Fcb is in the FsContext field.  The type of open is in the low
    //  bits of the Ccb.
    //

    *Fcb = FileObject->FsContext;

    return (TYPE_OF_OPEN) FlagOn( (ULONG_PTR) FileObject->FsContext2, TYPE_OF_OPEN_MASK );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\udfs\flush.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    Flush.c

Abstract:

    This module implements device flush functionality for UDF.

// @@BEGIN_DDKSPLIT

Author:

    Tom Jolly   [08-15-2000]

Revision History:

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_FLUSH)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_FLUSH)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfHijackIrpAndFlushDevice)
#endif

//
//  Local support routine
//

NTSTATUS
UdfHijackCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )

{
    //
    //  Set the event so that our call will wake up.
    //

    KeSetEvent( (PKEVENT)Contxt, 0, FALSE );

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
UdfHijackIrpAndFlushDevice (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PDEVICE_OBJECT TargetDeviceObject
    )

/*++

Routine Description:

    This routine is called when we need to send a flush to a device but
    we don't have a flush Irp.  What this routine does is make a copy
    of its current Irp stack location, but changes the Irp Major code
    to a IRP_MJ_FLUSH_BUFFERS amd then send it down, but cut it off at
    the knees in the completion routine, fix it up and return to the
    user as if nothing had happened.

Arguments:

    Irp - The Irp to hijack

    TargetDeviceObject - The device to send the request to.

Return Value:

    NTSTATUS - The Status from the flush in case anybody cares.

--*/

{
    KEVENT Event;
    NTSTATUS Status;
    PIO_STACK_LOCATION NextIrpSp;

    PAGED_CODE();

    //
    //  Get the next stack location, and copy over the stack location
    //

    NextIrpSp = IoGetNextIrpStackLocation( Irp );

    *NextIrpSp = *IoGetCurrentIrpStackLocation( Irp );

    NextIrpSp->MajorFunction = IRP_MJ_FLUSH_BUFFERS;
    NextIrpSp->MinorFunction = 0;

    //
    //  Set up the completion routine
    //

    KeInitializeEvent( &Event, NotificationEvent, FALSE );

    IoSetCompletionRoutine( Irp,
                            UdfHijackCompletionRoutine,
                            &Event,
                            TRUE,
                            TRUE,
                            TRUE );

    //
    //  Send the request.
    //

    Status = IoCallDriver( TargetDeviceObject, Irp );

    if (Status == STATUS_PENDING) {

        KeWaitForSingleObject( &Event, Executive, KernelMode, FALSE, NULL );

        Status = Irp->IoStatus.Status;
    }

    //
    //  If the driver doesn't support flushes, return SUCCESS.
    //

    if (Status == STATUS_INVALID_DEVICE_REQUEST) {
        Status = STATUS_SUCCESS;
    }

    Irp->IoStatus.Status = 0;
    Irp->IoStatus.Information = 0;

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\udfs\dirsup.c ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    DirSup.c

Abstract:

    This module implements the support for walking across on-disk directory
    structures.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]   11-Jun-1996

Revision History:

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_DIRSUP)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_DIRSUP)

//
//  Local support routines.
//

BOOLEAN
UdfLookupDirEntryPostProcessing (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PDIR_ENUM_CONTEXT DirContext,
    IN BOOLEAN ReturnError
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfCleanupDirContext)
#pragma alloc_text(PAGE, UdfFindDirEntry)
#pragma alloc_text(PAGE, UdfInitializeDirContext)
#pragma alloc_text(PAGE, UdfLookupDirEntryPostProcessing)
#pragma alloc_text(PAGE, UdfLookupInitialDirEntry)
#pragma alloc_text(PAGE, UdfLookupNextDirEntry)
#pragma alloc_text(PAGE, UdfUpdateDirNames)
#endif


VOID
UdfInitializeDirContext (
    IN PIRP_CONTEXT IrpContext,
    IN PDIR_ENUM_CONTEXT DirContext
    )

/*++

Routine Description:

    This routine initializes a directory enumeartion context.
    
    Call this exactly once in the lifetime of a context.

Arguments:

    DirContext - a context to initialize

Return Value:

    None.

--*/

{
    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );

    //
    //  Provide defaults for fields, nothing too special.
    //

    RtlZeroMemory( DirContext, sizeof(DIR_ENUM_CONTEXT) );
}


VOID
UdfCleanupDirContext (
    IN PIRP_CONTEXT IrpContext,
    IN PDIR_ENUM_CONTEXT DirContext
    )

/*++

Routine Description:

    This routine cleans up a directory enumeration context for reuse.

Arguments:

    DirContext - a context to clean.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    //  Check input.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    
    //
    //  Dump the allocation we store the triple of names in.
    //

    UdfFreePool( &DirContext->NameBuffer );

    //
    //  And the short name.
    //

    UdfFreePool( &DirContext->ShortObjectName.Buffer );

    //
    //  Unpin the view.
    //

    UdfUnpinData( IrpContext, &DirContext->Bcb );

    //
    //  Free a buffered Fid that may remain.
    //
    
    if (FlagOn( DirContext->Flags, DIR_CONTEXT_FLAG_FID_BUFFERED )) {

        UdfFreePool( &DirContext->Fid );
    }
    
    //
    //  Zero everything else out.
    //

    RtlZeroMemory( DirContext, sizeof( DIR_ENUM_CONTEXT ) );
}


BOOLEAN
UdfLookupInitialDirEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PDIR_ENUM_CONTEXT DirContext,
    IN PLONGLONG InitialOffset OPTIONAL
    )

/*++

Routine Description:

    This routine begins the enumeration of a directory by setting the context
    at the first avaliable directory entry.

Arguments:

    Fcb - the directory being enumerated.
    
    DirContext - a corresponding context for the enumeration.
    
    InitialOffset - an optional starting byte offset to base the enumeration.

Return Value:

    If InitialOffset is unspecified, TRUE will always be returned.  Failure will result
    in a raised status indicating corruption.
    
    If InitialOffset is specified, TRUE will be returned if a valid entry is found at this
    offset, FALSE otherwise.

--*/

{
    BOOLEAN Result;

    PAGED_CODE();
    
    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB_INDEX( Fcb );
    
    //
    //  Create the internal stream if it isn't already in place.
    //

    if (Fcb->FileObject == NULL) {

        UdfCreateInternalStream( IrpContext, Fcb->Vcb, Fcb );
    }

    //
    //  Reset the flags.
    //

    DirContext->Flags = 0;
    
    if (InitialOffset) {

        //
        //  If we are beginning in the middle of the stream, adjust the sanity check flags.
        //
        
        if (*InitialOffset != 0) {

            DirContext->Flags = DIR_CONTEXT_FLAG_SEEN_NONCONSTANT | DIR_CONTEXT_FLAG_SEEN_PARENT;
        }

        //
        //  Now set up the range we will map.  This is constrained by the size of a cache view.
        //
        
        DirContext->BaseOffset.QuadPart = GenericTruncate( *InitialOffset, VACB_MAPPING_GRANULARITY );
        DirContext->ViewOffset = (ULONG) GenericOffset( *InitialOffset, VACB_MAPPING_GRANULARITY );

    } else {
        
        //
        //  Map at the beginning.
        //
    
        DirContext->BaseOffset.QuadPart = 0;
        DirContext->ViewOffset = 0;
    }

    //
    //  Contain the view length by the size of the stream and map.
    //

    DirContext->ViewLength = VACB_MAPPING_GRANULARITY;

    if (DirContext->BaseOffset.QuadPart + DirContext->ViewLength > Fcb->FileSize.QuadPart) {

        DirContext->ViewLength = (ULONG) (Fcb->FileSize.QuadPart - DirContext->BaseOffset.QuadPart);
    }
    
    UdfUnpinData( IrpContext, &DirContext->Bcb );
    
    CcMapData( Fcb->FileObject,
               &DirContext->BaseOffset,
               DirContext->ViewLength,
               TRUE,
               &DirContext->Bcb,
               &DirContext->View );

    DirContext->Fid = Add2Ptr( DirContext->View, DirContext->ViewOffset, PNSR_FID );

    //
    //  The state of the context is now valid.  Tail off into our common post-processor
    //  to finish the work.
    //

    return UdfLookupDirEntryPostProcessing( IrpContext,
                                            Fcb,
                                            DirContext,
                                            (BOOLEAN) (InitialOffset != NULL));
}


BOOLEAN
UdfLookupNextDirEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PDIR_ENUM_CONTEXT DirContext
    )

/*++

Routine Description:

    This routine advances the enumeration of a directory by one entry.

Arguments:

    Fcb - the directory being enumerated.
    
    DirContext - a corresponding context for the enumeration.

Return Value:

    BOOLEAN True if another Fid is avaliable, False if we are at the end.

--*/

{
    PAGED_CODE();
    
    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB_INDEX( Fcb );

    //
    //  If we have reached the end, stop.
    //
    
    if (DirContext->BaseOffset.QuadPart + DirContext->NextFidOffset == Fcb->FileSize.QuadPart) {

        return FALSE;
    }

    //
    //  If the previous Fid was buffered, dismantle it now.
    //
    
    if (FlagOn( DirContext->Flags, DIR_CONTEXT_FLAG_FID_BUFFERED )) {

        ClearFlag( DirContext->Flags, DIR_CONTEXT_FLAG_FID_BUFFERED );
        UdfFreePool( &DirContext->Fid );
    }
    
    //
    //  Move the pointers based on the knowledge generated in the previous iteration.
    //

    DirContext->ViewOffset = DirContext->NextFidOffset;
    DirContext->Fid = Add2Ptr( DirContext->View, DirContext->ViewOffset, PNSR_FID );

    //
    //  The state of the context is now valid.  Tail off into our common post-processor
    //  to finish the work.
    //

    return UdfLookupDirEntryPostProcessing( IrpContext,
                                            Fcb,
                                            DirContext,
                                            FALSE );
}


VOID
UdfUpdateDirNames (
    IN PIRP_CONTEXT IrpContext,
    IN PDIR_ENUM_CONTEXT DirContext,
    IN BOOLEAN IgnoreCase
    )

/*++

Routine Description:

    This routine fills in the non-short names of a directory enumeration context
    for the Fid currently referenced.

Arguments:

    DirContext - a corresponding context to fill in.
    
    IgnoreCase - whether the caller wants to be insensitive to case.

Return Value:

    None.
    
--*/

{
    PUCHAR NameDstring;
    BOOLEAN ContainsIllegal;
    
    USHORT NameLength;
    USHORT RequiredBufferLength;
    USHORT PresentLength;
     
    PAGED_CODE();

    //
    //  Check input.
    //

    ASSERT_IRP_CONTEXT( IrpContext );

    DebugTrace(( +1, Dbg, "UdfUpdateDirNames\n" ));

    //
    //  Handle the case of the self directory entry.
    //

    if (DirContext->Fid == NULL) {

        //
        //  Simply synthesize
        //
        
        //
        //  It doesn't hurt to be pedantic about initialization, so do it all.
        //
        
        DirContext->PureObjectName.Length =
        DirContext->CaseObjectName.Length =
        DirContext->ObjectName.Length = UdfUnicodeDirectoryNames[SELF_ENTRY].Length;
        
        DirContext->PureObjectName.MaximumLength =
        DirContext->CaseObjectName.MaximumLength =
        DirContext->ObjectName.MaximumLength = UdfUnicodeDirectoryNames[SELF_ENTRY].MaximumLength;

        DirContext->PureObjectName.Buffer = 
        DirContext->CaseObjectName.Buffer = 
        DirContext->ObjectName.Buffer = UdfUnicodeDirectoryNames[SELF_ENTRY].Buffer;

        //
        //  All done.
        //

        DebugTrace((  0, Dbg, "Self Entry case\n" ));
        DebugTrace(( -1, Dbg, "UdfUpdateDirNames -> VOID\n" ));
        
        return;
    }
    
    //
    //  Handle the case of the parent directory entry.
    //

    if (FlagOn( DirContext->Fid->Flags, NSR_FID_F_PARENT )) {

        //
        //  Parent entries must occur at the front of the directory and
        //  have a fid length of zero (13346 4/14.4.4).
        //

        if (FlagOn( DirContext->Flags, DIR_CONTEXT_FLAG_SEEN_NONCONSTANT ) ||
            DirContext->Fid->FileIDLen != 0) {

            UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
        }

        //
        //  Note that we have seen the parent entry.
        //

        SetFlag( DirContext->Flags, DIR_CONTEXT_FLAG_SEEN_PARENT );
        
        //
        //  It doesn't hurt to be pedantic about initialization, so do it all.
        //
        
        DirContext->PureObjectName.Length =
        DirContext->CaseObjectName.Length =
        DirContext->ObjectName.Length = UdfUnicodeDirectoryNames[PARENT_ENTRY].Length;
        
        DirContext->PureObjectName.MaximumLength =
        DirContext->CaseObjectName.MaximumLength =
        DirContext->ObjectName.MaximumLength = UdfUnicodeDirectoryNames[PARENT_ENTRY].MaximumLength;

        DirContext->PureObjectName.Buffer = 
        DirContext->CaseObjectName.Buffer = 
        DirContext->ObjectName.Buffer = UdfUnicodeDirectoryNames[PARENT_ENTRY].Buffer;

        //
        //  All done.
        //

        DebugTrace((  0, Dbg, "Parent Entry case\n" ));
        DebugTrace(( -1, Dbg, "UdfUpdateDirNames -> VOID\n" ));
        
        return;
    }

    //
    //  We now know that we will need to convert the name in a real FID, so figure out where
    //  it sits in the descriptor.
    //
    
    NameDstring = Add2Ptr( DirContext->Fid, ISONsrFidConstantSize + DirContext->Fid->ImpUseLen, PUCHAR );
     
    //
    //  Every directory must record a parent entry.
    //
    
    if (!FlagOn( DirContext->Flags, DIR_CONTEXT_FLAG_SEEN_PARENT)) {
    
        UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
    }
    
    //
    //  Note that we are proceeding into the non-constant portion of a directory.
    //
    
    SetFlag( DirContext->Flags, DIR_CONTEXT_FLAG_SEEN_NONCONSTANT );
    
    //
    //  Make sure the dstring is good CS0
    //
    
    UdfCheckLegalCS0Dstring( IrpContext,
                             NameDstring,
                             DirContext->Fid->FileIDLen,
                             0,
                             FALSE );
    
    //
    //  Don't bother allocating tiny buffers - always make sure we get enough for an 8.3 name.
    //

    RequiredBufferLength =
    NameLength = Max( BYTE_COUNT_8_DOT_3, UdfCS0DstringUnicodeSize( IrpContext,
                                                                    NameDstring,
                                                                    DirContext->Fid->FileIDLen) );

    //
    //  Illegality is both actual illegal characters and too many characters.
    //
    
    ContainsIllegal = (!UdfCS0DstringIsLegalFileName( NameDstring, DirContext->Fid->FileIDLen ) ||
                       (NameLength / sizeof( WCHAR )) > MAX_LEN);

    
    //
    //  If we're illegal, we will need more characters to hold the uniqifying stamp.
    //
    
    if (ContainsIllegal) {

        RequiredBufferLength = (NameLength += (CRC_LEN * sizeof(WCHAR)));
    }
    
    
    //
    //  If we need to build a case insensitive name, need more space.
    //
        
    if (IgnoreCase) {

        RequiredBufferLength += NameLength;
    }
    
    //
    //  If we need to render the names due to illegal characters, more space again.
    //
        
    if (ContainsIllegal) {

        RequiredBufferLength += NameLength;
    
    } else {

        //
        //  Make sure the names aren't seperated. If more illegal names are found we can
        //  resplit the buffer but until then avoid the expense of having to copy bytes
        //  ... odds are that illegal characters are going to be a rarish occurance.
        //
        
        DirContext->PureObjectName.Buffer = DirContext->ObjectName.Buffer;
    }

    //
    //  We expect the name lengths and hence buffer size to be multiple of WCHAR
    //
    
    ASSERT( 0 == (RequiredBufferLength & 1));

    DebugTrace(( 0, Dbg,
                 "Ob %s%sneeds %d bytes (%d byte chunks), have %d\n",
                 (IgnoreCase? "Ic " : ""),
                 (ContainsIllegal? "Ci " : ""),
                 RequiredBufferLength,
                 NameLength,
                 DirContext->AllocLength ));

    //
    //  Check if we need more space for the names.  We will need more if the name size is greater
    //  than the maximum we can currently store, or if we have stumbled across illegal characters
    //  and the current Pure name is not seperated from the exposed Object name.
    //
    //  Note that IgnoreCase remains constant across usage of a context so we don't have to wonder
    //  if it has been seperated from the ObjectName - it'll always be correct.
    //

    if ((NameLength > DirContext->ObjectName.MaximumLength) ||
        (ContainsIllegal && (DirContext->ObjectName.Buffer == DirContext->PureObjectName.Buffer))) {

        USHORT DividedBufferLength = 0;
        
        DebugTrace(( 0, Dbg, "Resizing buffers\n" ));

        //
        //  Figure out if we can break up the current allocation in a different way before falling 
        //  back to a new allocation.  Ensure we use even byte size chunks,  or else we can land 
        //  up with alignment faults on IA64.
        //

        if (DirContext->AllocLength >= RequiredBufferLength)  {
        
            DividedBufferLength = (DirContext->AllocLength / (1 +
                                                             (IgnoreCase? 1 : 0) +
                                                             (ContainsIllegal? 1 : 0))) & ~(USHORT)1;
        }

        if (DividedBufferLength >= NameLength)  {

            //
            //  So we can still use the current allocation,  re-divided.
            //

            DirContext->PureObjectName.MaximumLength =
            DirContext->CaseObjectName.MaximumLength =
            DirContext->ObjectName.MaximumLength = DividedBufferLength;

            DebugTrace(( 0, Dbg, 
                         "... by resplit into %d byte chunks\n",
                         DirContext->ObjectName.MaximumLength ));
            
            //
            //  Set the buffer pointers up.  Required adjustment will occur below.
            //
                
            DirContext->PureObjectName.Buffer = 
            DirContext->CaseObjectName.Buffer = 
            DirContext->ObjectName.Buffer = DirContext->NameBuffer;
        
        } else {

            DebugTrace(( 0, Dbg, "... by allocating new pool\n" ));
            
            //
            //  Oh well, no choice but to fall back into the pool.  Drop our previous hunk.
            //
            
            UdfFreePool( &DirContext->NameBuffer );
            DirContext->AllocLength = 0;
            
            //
            //  The names share an allocation for efficiency.
            //
            
            DirContext->PureObjectName.MaximumLength =
            DirContext->CaseObjectName.MaximumLength =
            DirContext->ObjectName.MaximumLength = NameLength;
    
            DirContext->NameBuffer =
            DirContext->PureObjectName.Buffer = 
            DirContext->CaseObjectName.Buffer = 
            DirContext->ObjectName.Buffer = FsRtlAllocatePoolWithTag( UdfPagedPool,
                                                                      RequiredBufferLength,
                                                                      TAG_FILE_NAME );
            DirContext->AllocLength = RequiredBufferLength;
        }
        
        //
        //  In the presence of the "as appropriate" names, adjust the buffer locations.  Note
        //  that ObjectName.Buffer is always the base of the allocated space.
        //
        
        if (IgnoreCase) {

            DirContext->CaseObjectName.Buffer = Add2Ptr( DirContext->ObjectName.Buffer, 
                                                         DirContext->ObjectName.MaximumLength,
                                                         PWCHAR );
        }

        if (ContainsIllegal) {
            
            DirContext->PureObjectName.Buffer = Add2Ptr( DirContext->CaseObjectName.Buffer,
                                                         DirContext->CaseObjectName.MaximumLength,
                                                         PWCHAR );
        }
    }

    ASSERT( RequiredBufferLength <= DirContext->AllocLength );

    //
    //  Convert the dstring.
    //
    
    UdfConvertCS0DstringToUnicode( IrpContext,
                                   NameDstring,
                                   DirContext->Fid->FileIDLen,
                                   0,
                                   &DirContext->PureObjectName );

    //
    //  If illegal characters were present, run the name through the UDF transmogrifier.
    //

    if (ContainsIllegal) {

        UdfRenderNameToLegalUnicode( IrpContext,
                                     &DirContext->PureObjectName,
                                     &DirContext->ObjectName );

    //
    //  The ObjectName is the same as the PureObjectName.
    //

    } else {

        DirContext->ObjectName.Length = DirContext->PureObjectName.Length;
    }

    //
    //  Upcase the result if required.
    //

    if (IgnoreCase) {

        UdfUpcaseName( IrpContext,
                       &DirContext->ObjectName,
                       &DirContext->CaseObjectName );
    }

    DebugTrace(( -1, Dbg, "UdfUpdateDirNames -> VOID\n" ));
    
    return;
}


BOOLEAN
UdfFindDirEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PUNICODE_STRING Name,
    IN BOOLEAN IgnoreCase,
    IN BOOLEAN ShortName,
    IN PDIR_ENUM_CONTEXT DirContext
    )

/*++

Routine Description:

    This routine walks the directory specified for an entry which matches the input
    criteria.

Arguments:

    Fcb - the directory to search
    
    Name - name to search for
    
    IgnoreCase - whether this search should be case-insensitive (Name will already
        be upcased)
        
    ShortName - whether the name should be searched for according to short name rules
    
    DirContext - context structure to use and return results in

Return Value:

    BOOLEAN True if a matching directory entry is being returned, False otherwise.

--*/

{
    PUNICODE_STRING MatchName;

    PAGED_CODE();

    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB_INDEX( Fcb );

    DebugTrace(( +1, Dbg,
                 "UdfFindDirEntry, Fcb=%08x Name=\"%wZ\" Ignore=%u Short=%u, DC=%08x\n",
                 Fcb,
                 Name,
                 IgnoreCase,
                 ShortName,
                 DirContext ));

    //
    //  Depending on the kind of search we are performing a different flavor of the found name
    //  wil be used in the comparison.
    //
    
    if (ShortName) {

        MatchName = &DirContext->ShortObjectName;
    
    } else {

        MatchName = &DirContext->CaseObjectName;
    }


    //
    //  Go get the first entry.
    //

    UdfLookupInitialDirEntry( IrpContext,
                              Fcb,
                              DirContext,
                              NULL );

    //
    //  Now loop looking for a good match.
    //
    
    do {

        //
        //  If it is deleted, we obviously aren't interested in it.
        //
        
        if (FlagOn( DirContext->Fid->Flags, NSR_FID_F_DELETED )) {

            continue;
        }

        UdfUpdateDirNames( IrpContext,
                           DirContext,
                           IgnoreCase );
            
        
        //
        //  If this is a constant entry, just keep going.
        //
        
        if (!FlagOn( DirContext->Flags, DIR_CONTEXT_FLAG_SEEN_NONCONSTANT )) {
            
            continue;
        }

        DebugTrace(( 0, Dbg,
                     "\"%wZ\" (pure \"%wZ\") @ +%08x\n",
                     &DirContext->ObjectName,
                     &DirContext->PureObjectName,
                     DirContext->ViewOffset ));

        //
        //  If we are searching for generated shortnames, a small subset of the names
        //  in the directory are actually candidates for a match.  Go get the name.
        //
        
        if (ShortName) {

            //
            //  Now, only if this Fid's name is non 8.3 is it neccesary to work with it.
            //
            
            if (!UdfIs8dot3Name( IrpContext, DirContext->ObjectName )) {

                //
                //  Allocate the shortname if it isn't already done.
                //
                
                if (DirContext->ShortObjectName.Buffer == NULL) {

                    DirContext->ShortObjectName.Buffer = FsRtlAllocatePoolWithTag( UdfPagedPool,
                                                                                   BYTE_COUNT_8_DOT_3,
                                                                                   TAG_SHORT_FILE_NAME );
                    DirContext->ShortObjectName.MaximumLength = BYTE_COUNT_8_DOT_3;
                }

                UdfGenerate8dot3Name( IrpContext,
                                      &DirContext->PureObjectName,
                                      &DirContext->ShortObjectName );

                DebugTrace(( 0, Dbg,
                             "built shortname \"%wZ\"\n", &DirContext->ShortObjectName ));

            } else {

                //
                //  As an 8.3 name already, this name will not have caused us to have to generate
                //  a short name, so it can't be the case that the caller is looking for it.
                //
                
                continue;
            }
        }

        if (UdfFullCompareNames( IrpContext,
                                 MatchName,
                                 Name ) == EqualTo) {

            //
            //  Got a match, so give it up.
            //

            DebugTrace((  0, Dbg, "HIT\n" ));
            DebugTrace(( -1, Dbg, "UdfFindDirEntry -> TRUE\n" ));

            return TRUE;
        }

    } while ( UdfLookupNextDirEntry( IrpContext,
                                     Fcb,
                                     DirContext ));

    //
    //  No match was found.
    //

    DebugTrace(( -1, Dbg, "UdfFindDirEntry -> FALSE\n" ));

    return FALSE;
}


//
//  Local support routine
//

BOOLEAN
UdfLookupDirEntryPostProcessing (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PDIR_ENUM_CONTEXT DirContext,
    IN BOOLEAN ReturnError
    )

/*++

Routine Description:

    This routine is the core engine of directory stream enumeration. It receives
    a context which has been advanced and does the integrity checks and final
    extraction of the Fid with respect to file cache granularity restrictions.

    NOTE: we assume that a Fid cannot span a cache view.  The maximum size of a
    Fid is just over 32k, so this is a good and likely permanent assumption.

Arguments:

    Fcb - the directory being enumerated.
    
    DirContext - a corresponding context for the enumeration.
    
    ReturnError - whether errors should be returned (or raised)

Return Value:

    BOOLEAN according to the successful extraction of the Fid.  If ReturnError is
    FALSE, then failure will result in a raised status.

--*/

{
    BOOLEAN Result = TRUE;
    
    PNSR_FID FidBufferC = NULL;
    PNSR_FID FidBuffer = NULL;

    PNSR_FID FidC;
    PNSR_FID Fid;

    ULONG FidSize;

    ULONG FidBytesInPreviousView = 0;
    
    PAGED_CODE();
    
    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB_INDEX( Fcb );
    
    try {
        
        //
        //  First check that the stream can contain another FID.
        //
    
        if (DirContext->BaseOffset.QuadPart +
            DirContext->ViewOffset +
            ISONsrFidConstantSize > Fcb->FileSize.QuadPart) {
    
            DebugTrace(( 0, Dbg,
                         "UdfLookupDirEntryPostProcessing: DC %p, constant header overlaps end of dir\n",
                         DirContext ));

            try_leave( Result = FALSE );
        }
            
        //
        //  We now build up the constant portion of the FID for use.  It may be the case that
        //  this spans a view boundary and must be buffered, or is entirely in the next view
        //  and we simply need to advance.
        //
    
        if (GenericTruncatePtr( Add2Ptr( DirContext->Fid, ISONsrFidConstantSize - 1, PUCHAR ), VACB_MAPPING_GRANULARITY ) !=
            DirContext->View) {
            
            FidBytesInPreviousView = GenericRemainderPtr( DirContext->Fid, VACB_MAPPING_GRANULARITY );
            
            //
            //  Only buffer if there are really bytes in the previous view.
            //
            
            if (FidBytesInPreviousView) {
                
                FidC =
                FidBufferC = FsRtlAllocatePoolWithTag( UdfPagedPool,
                                                       ISONsrFidConstantSize,
                                                       TAG_FID_BUFFER );
        
                RtlCopyMemory( FidBufferC,
                               DirContext->Fid,
                               FidBytesInPreviousView );
            }
    
            //
            //  Now advance into the next view to pick up the rest.
            //
            
            DirContext->BaseOffset.QuadPart += VACB_MAPPING_GRANULARITY;
            DirContext->ViewOffset = 0;
            
            //
            //  Contain the view length by the size of the stream and map.
            //
        
            DirContext->ViewLength = VACB_MAPPING_GRANULARITY;
        
            if (DirContext->BaseOffset.QuadPart + DirContext->ViewLength > Fcb->FileSize.QuadPart) {
        
                DirContext->ViewLength = (ULONG) (Fcb->FileSize.QuadPart - DirContext->BaseOffset.QuadPart);
            }
            
            UdfUnpinData( IrpContext, &DirContext->Bcb );
            
            CcMapData( Fcb->FileObject,
                       &DirContext->BaseOffset,
                       DirContext->ViewLength,
                       TRUE,
                       &DirContext->Bcb,
                       &DirContext->View );

            //
            //  We are guaranteed that this much lies in the stream.  Build the rest of the
            //  constant header.
            //
    
            if (FidBytesInPreviousView) {
                
                RtlCopyMemory( Add2Ptr( FidBufferC, FidBytesInPreviousView, PUCHAR ),
                               DirContext->View,
                               ISONsrFidConstantSize - FidBytesInPreviousView );
            
            //
            //  In fact, this FID is perfectly aligned to the front of this view.  No buffering
            //  is required, and we just set the FID pointer.
            //

            } else {


                DirContext->Fid = DirContext->View;
            }
        }
         
        //
        //  If no buffering was required, we can use the cache directly.
        //
            
        if (!FidBytesInPreviousView) {
    
            FidC = DirContext->Fid;
        }
    
        //
        //  Now we can check that the Fid data lies within the stream bounds and is sized
        //  within a logical block (per UDF).  This will complete the size-wise integrity
        //  verification.
        //

        if (((DirContext->BaseOffset.QuadPart +
              DirContext->ViewOffset -
              FidBytesInPreviousView +
              ISONsrFidSize( FidC ) > Fcb->FileSize.QuadPart) &&
             DebugTrace(( 0, Dbg,
                          "UdfLookupDirEntryPostProcessing: DC %p, FID (FidC %p, FBIPV %u) overlaps end of dir\n",
                          DirContext,
                          FidC,
                          FidBytesInPreviousView )))
              ||

            (ISONsrFidSize( FidC ) > BlockSize( Fcb->Vcb ) &&
             DebugTrace(( 0, Dbg,
             "UdfLookupDirEntryPostProcessing: DC %p, FID (FidC %p) larger than a logical block\n",
                          DirContext,
                          FidC )))) {

            try_leave( Result = FALSE );

        }

        //
        //  Final Fid rollup.
        //
        
        //
        //  The Fid may span a view boundary and should be buffered.  If we already buffered, we know
        //  we have to do this.
        //

        if (FidBytesInPreviousView ||
            GenericTruncatePtr( Add2Ptr( DirContext->Fid, ISONsrFidSize( FidC ) - 1, PUCHAR ), VACB_MAPPING_GRANULARITY ) !=
            DirContext->View) {
        
            Fid =
            FidBuffer = FsRtlAllocatePoolWithTag( UdfPagedPool,
                                                  ISONsrFidSize( FidC ),
                                                  TAG_FID_BUFFER );

            //
            //  Pull the fidsize out now in case we're still pointing to the cache (ie. no
            //  buffering was required for fixed portion) but are about to change the mapping
            //  below (need to buffer for variable portion).
            //
            
            FidSize = ISONsrFidSize( FidC);
            
            //
            //  If we already buffered and advanced for the header, just prefill
            //  the final Fid buffer with the bytes that are now unavaliable.
            //
            
            if (FidBytesInPreviousView) {

                RtlCopyMemory( FidBuffer,
                               FidBufferC,
                               FidBytesInPreviousView );

            } else {
                
                //
                //  Buffer and advance the view.
                //
                
                FidBytesInPreviousView = GenericRemainderPtr( DirContext->Fid, VACB_MAPPING_GRANULARITY );
                
                RtlCopyMemory( FidBuffer,
                               DirContext->Fid,
                               FidBytesInPreviousView );
                
                //
                //  Now advance into the next view to pick up the rest.
                //
                
                DirContext->BaseOffset.QuadPart += VACB_MAPPING_GRANULARITY;
                DirContext->ViewOffset = 0;
                
                //
                //  Contain the view length by the size of the stream and map.
                //
            
                DirContext->ViewLength = VACB_MAPPING_GRANULARITY;
            
                if (DirContext->BaseOffset.QuadPart + DirContext->ViewLength > Fcb->FileSize.QuadPart) {
            
                    DirContext->ViewLength = (ULONG) (Fcb->FileSize.QuadPart - DirContext->BaseOffset.QuadPart);
                }
                
                UdfUnpinData( IrpContext, &DirContext->Bcb );
                
                CcMapData( Fcb->FileObject,
                           &DirContext->BaseOffset,
                           DirContext->ViewLength,
                           TRUE,
                           &DirContext->Bcb,
                           &DirContext->View );
            }
    
            //
            //  We are guaranteed that this much lies in the stream.
            //
    
            RtlCopyMemory( Add2Ptr( FidBuffer, FidBytesInPreviousView, PUCHAR ),
                           DirContext->View,
                           FidSize - FidBytesInPreviousView );
    
        } else {

            Fid = DirContext->Fid;
        }
        
        //
        //  We finally have the whole Fid safely extracted from the cache, so the
        //  integrity check is now the last step before success.  For simplicity's
        //  sake we trust the Lbn field.
        //
    
        Result = UdfVerifyDescriptor( IrpContext,
                                      &Fid->Destag,
                                      DESTAG_ID_NSR_FID,
                                      ISONsrFidSize( Fid ),
                                      Fid->Destag.Lbn,
                                      ReturnError );

        //
        //  Prepare to return a buffered Fid.
        //
        
        if (FidBuffer && Result) {

            SetFlag( DirContext->Flags, DIR_CONTEXT_FLAG_FID_BUFFERED );
            DirContext->Fid = FidBuffer;
            FidBuffer = NULL;
        }
        
    } finally {

        UdfFreePool( &FidBuffer );
        UdfFreePool( &FidBufferC );
    }

    if (!ReturnError && !Result) {

        UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
    }

    //
    //  On success update the next Fid information in the context.
    //  Note that  we must drop in a hint as to where the next Fid
    //  will be found so that the next advance will know how much
    //  of a buffered Fid isn't in this view.
    //

    if (Result) {

        DirContext->NextFidOffset = DirContext->ViewOffset +
                                    ISONsrFidSize( Fid );
        
        if (FidBytesInPreviousView) {
            
            DirContext->NextFidOffset -= FidBytesInPreviousView;
        }
    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\udfs\fsctrl.c ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    FsCtrl.c

Abstract:

    This module implements the File System Control routines for Udfs called
    by the Fsd/Fsp dispatch drivers.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]   11-Jun-1996

Revision History:

    Tom Jolly       [TomJolly]   1-March-2000   UDF 2.01 support
    
// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_FSCTRL)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_FSCTRL)

//
//  Local constants
//

BOOLEAN UdfDisable = FALSE;

//
//  CRC of the PVD on Disney's Snow White title,  so we can 
//  ignore the volsetseqmax on that disc only.
//

#define UDF_SNOW_WHITE_PVD_CRC ((USHORT)0x1d05)
#define UDF_SNOW_WHITE_PVD_CRC_VARIANT_2 ((USHORT)0x534e)

//
//  Local macros
//

INLINE
VOID
UdfStoreFileSetDescriptorIfPrevailing (
    IN OUT PNSR_FSD *StoredFSD,
    IN OUT PNSR_FSD *NewFSD
    )
{
    PNSR_FSD TempFSD;

    //
    //  If we haven't stored a fileset descriptor or the fileset number
    //  of the stored descriptor is less than the new descriptor, swap the
    //  pointers around.
    //

    if (*StoredFSD == NULL || (*StoredFSD)->FileSet < (*NewFSD)->FileSet) {

        TempFSD = *StoredFSD;
        *StoredFSD = *NewFSD;
        *NewFSD = TempFSD;
    }
}

//
//  Local support routines
//

VOID
UdfDetermineVolumeBounding ( 
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PULONG S,
    IN PULONG N
    );

NTSTATUS
UdfDismountVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
UdfFindAnchorVolumeDescriptor (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN OUT PNSR_ANCHOR *AnchorVolumeDescriptor
    );

NTSTATUS
UdfFindFileSetDescriptor (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PLONGAD LongAd,
    IN OUT PNSR_FSD *FileSetDescriptor
    );

NTSTATUS
UdfFindVolumeDescriptors (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PEXTENTAD Extent,
    IN OUT PPCB *Pcb,
    IN OUT PNSR_PVD *PrimaryVolumeDescriptor,
    IN OUT PNSR_LVOL *LogicalVolumeDescriptor
    );

NTSTATUS
UdfInvalidateVolumes (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
UdfIsPathnameValid (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

BOOLEAN
UdfIsRemount (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    OUT PVCB *OldVcb
    );

UdfIsVolumeDirty (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
UdfIsVolumeMounted (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
UdfLockVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

VOID
UdfRemountOldVcb(
    IN PIRP_CONTEXT IrpContext,
    IN PVCB OldVcb,
    IN PVCB NewVcb,
    IN PDEVICE_OBJECT DeviceObjectWeTalkTo
    );

NTSTATUS
UdfMountVolume(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
UdfOplockRequest (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

BOOLEAN
UdfRecognizeVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN PULONG BoundS,
    IN OUT PBOOLEAN Bridge,
    OUT PUSHORT NSRVerFound
    );

VOID
UdfScanForDismountedVcb (
    IN PIRP_CONTEXT IrpContext
    );

NTSTATUS
UdfUnlockVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

VOID
UdfUpdateVolumeLabel (
    IN PIRP_CONTEXT IrpContext,
    IN PWCHAR VolumeLabel,
    IN OUT PUSHORT VolumeLabelLength,
    IN PUCHAR Dstring,
    IN UCHAR FieldLength
    );

VOID
UdfUpdateVolumeSerialNumber (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PULONG VolumeSerialNumber,
    IN PNSR_FSD Fsd
    );

NTSTATUS
UdfUserFsctl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
UdfVerifyVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
UdfAllowExtendedDasdIo(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

#ifdef EXPERIMENTAL_MOUNT_OPEN_R_MEDIA

NTSTATUS
UdfCheckForOpenRMedia( 
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PULONG S,
    IN PULONG N
    );

#pragma alloc_text(PAGE, UdfCheckForOpenRMedia)
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfCommonFsControl)
#pragma alloc_text(PAGE, UdfDetermineVolumeBounding)
#pragma alloc_text(PAGE, UdfDismountVolume)
#pragma alloc_text(PAGE, UdfFindAnchorVolumeDescriptor)
#pragma alloc_text(PAGE, UdfFindFileSetDescriptor)
#pragma alloc_text(PAGE, UdfFindVolumeDescriptors)
#pragma alloc_text(PAGE, UdfIsPathnameValid)
#pragma alloc_text(PAGE, UdfIsRemount)
#pragma alloc_text(PAGE, UdfIsVolumeDirty)
#pragma alloc_text(PAGE, UdfIsVolumeMounted)
#pragma alloc_text(PAGE, UdfLockVolume)
#pragma alloc_text(PAGE, UdfMountVolume)
#pragma alloc_text(PAGE, UdfOplockRequest)
#pragma alloc_text(PAGE, UdfRecognizeVolume)
#pragma alloc_text(PAGE, UdfScanForDismountedVcb)
#pragma alloc_text(PAGE, UdfStoreVolumeDescriptorIfPrevailing)
#pragma alloc_text(PAGE, UdfUnlockVolume)
#pragma alloc_text(PAGE, UdfUpdateVolumeLabel)
#pragma alloc_text(PAGE, UdfUpdateVolumeSerialNumber)
#pragma alloc_text(PAGE, UdfUserFsctl)
#pragma alloc_text(PAGE, UdfVerifyVolume)
#pragma alloc_text(PAGE, UdfAllowExtendedDasdIo)
#endif


VOID
UdfStoreVolumeDescriptorIfPrevailing (
    IN OUT PNSR_VD_GENERIC *StoredVD,
    IN OUT PNSR_VD_GENERIC NewVD
    )

/*++

Routine Description:

    This routine updates Volume Descriptor if the new descriptor
    is more prevailing than the one currently stored.

Arguments:

    StoredVD - pointer to a currently stored descriptor

    NewVD - pointer to a candidate descriptor

Return Value:

    None.

--*/

{
    PNSR_VD_GENERIC TempVD;

    //
    //  If we haven't stored a volume descriptor or the sequence number
    //  of the stored descriptor is less than the new descriptor, make a copy
    //  of it and store it.
    //

    if ((NULL == *StoredVD) || ((*StoredVD)->Sequence < NewVD->Sequence)) {

        if ( NULL == *StoredVD)  {

            *StoredVD = (PNSR_VD_GENERIC) FsRtlAllocatePoolWithTag( UdfNonPagedPool,
                                                                    sizeof(NSR_VD_GENERIC),
                                                                    TAG_NSR_VDSD );
        }

        RtlCopyMemory( *StoredVD,  NewVD,  sizeof( NSR_VD_GENERIC));
    }
}


NTSTATUS
UdfCommonFsControl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for doing FileSystem control operations called
    by both the fsd and fsp threads

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PAGED_CODE();

    //
    //  Check the input parameters
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    //
    //  Get a pointer to the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  We know this is a file system control so we'll case on the
    //  minor function, and call a internal worker routine to complete
    //  the irp.
    //

    switch (IrpSp->MinorFunction) {

    case IRP_MN_MOUNT_VOLUME:

        Status = UdfMountVolume( IrpContext, Irp );
        break;

    case IRP_MN_VERIFY_VOLUME:

        Status = UdfVerifyVolume( IrpContext, Irp );
        break;

    case IRP_MN_USER_FS_REQUEST:

        Status = UdfUserFsctl( IrpContext, Irp );
        break;

    default:

        UdfCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );
        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    return Status;
}


//
//  Local support routine
//

NTSTATUS
UdfUserFsctl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )
/*++

Routine Description:

    This is the common routine for implementing the user's requests made
    through NtFsControlFile.

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PAGED_CODE();

    //
    //  Case on the control code.
    //

    switch ( IrpSp->Parameters.FileSystemControl.FsControlCode ) {

    case FSCTL_REQUEST_OPLOCK_LEVEL_1 :
    case FSCTL_REQUEST_OPLOCK_LEVEL_2 :
    case FSCTL_REQUEST_BATCH_OPLOCK :
    case FSCTL_OPLOCK_BREAK_ACKNOWLEDGE :
    case FSCTL_OPBATCH_ACK_CLOSE_PENDING :
    case FSCTL_OPLOCK_BREAK_NOTIFY :
    case FSCTL_OPLOCK_BREAK_ACK_NO_2 :
    case FSCTL_REQUEST_FILTER_OPLOCK :

        Status = UdfOplockRequest( IrpContext, Irp );
        break;

    case FSCTL_LOCK_VOLUME :

        Status = UdfLockVolume( IrpContext, Irp );
        break;

    case FSCTL_UNLOCK_VOLUME :

        Status = UdfUnlockVolume( IrpContext, Irp );
        break;

    case FSCTL_DISMOUNT_VOLUME :

        Status = UdfDismountVolume( IrpContext, Irp );
        break;

    case FSCTL_IS_VOLUME_DIRTY :

        Status = UdfIsVolumeDirty( IrpContext, Irp );
        break;

    case FSCTL_IS_VOLUME_MOUNTED :

        Status = UdfIsVolumeMounted( IrpContext, Irp );
        break;

    case FSCTL_IS_PATHNAME_VALID :

        Status = UdfIsPathnameValid( IrpContext, Irp );
        break;

    case FSCTL_INVALIDATE_VOLUMES :

        Status = UdfInvalidateVolumes( IrpContext, Irp );
        break;

    case FSCTL_ALLOW_EXTENDED_DASD_IO:
    
        Status = UdfAllowExtendedDasdIo( IrpContext, Irp );
        break;

    //
    //  We don't support any of the known or unknown requests.
    //

    default:

        UdfCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );
        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    return Status;
}


//
//  Local support routine
//

NTSTATUS
UdfOplockRequest (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine to handle oplock requests made via the
    NtFsControlFile call.

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PFCB Fcb;
    PCCB Ccb;

    ULONG OplockCount = 0;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PAGED_CODE();

    //
    //  We only permit oplock requests on files.
    //

    if (UdfDecodeFileObject( IrpSp->FileObject,
                             &Fcb,
                             &Ccb ) != UserFileOpen ) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Make this a waitable Irpcontext so we don't fail to acquire
    //  the resources.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );
    ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_FORCE_POST );

    //
    //  Switch on the function control code.  We grab the Fcb exclusively
    //  for oplock requests, shared for oplock break acknowledgement.
    //

    switch (IrpSp->Parameters.FileSystemControl.FsControlCode) {

    case FSCTL_REQUEST_OPLOCK_LEVEL_1 :
    case FSCTL_REQUEST_OPLOCK_LEVEL_2 :
    case FSCTL_REQUEST_BATCH_OPLOCK :
    case FSCTL_REQUEST_FILTER_OPLOCK :

        UdfAcquireFcbExclusive( IrpContext, Fcb, FALSE );

        if (IrpSp->Parameters.FileSystemControl.FsControlCode == FSCTL_REQUEST_OPLOCK_LEVEL_2) {

            if (Fcb->FileLock != NULL) {

                OplockCount = (ULONG) FsRtlAreThereCurrentFileLocks( Fcb->FileLock );
            }

        } else {

            OplockCount = Fcb->FcbCleanup;
        }

        break;

    case FSCTL_OPLOCK_BREAK_ACKNOWLEDGE:
    case FSCTL_OPBATCH_ACK_CLOSE_PENDING:
    case FSCTL_OPLOCK_BREAK_NOTIFY:
    case FSCTL_OPLOCK_BREAK_ACK_NO_2:

        UdfAcquireFcbShared( IrpContext, Fcb, FALSE );
        break;

    default:

        UdfCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Use a try finally to free the Fcb.
    //

    try {

        //
        //  Verify the Fcb.
        //

        UdfVerifyFcbOperation( IrpContext, Fcb );

        //
        //  Call the FsRtl routine to grant/acknowledge oplock.
        //

        Status = FsRtlOplockFsctrl( &Fcb->Oplock,
                                    Irp,
                                    OplockCount );

        //
        //  Set the flag indicating if Fast I/O is possible
        //

        UdfLockFcb( IrpContext, Fcb );
        Fcb->IsFastIoPossible = UdfIsFastIoPossible( Fcb );
        UdfUnlockFcb( IrpContext, Fcb );

        //
        //  The oplock package will complete the Irp.
        //

        Irp = NULL;

    } finally {

        //
        //  Release all of our resources
        //

        UdfReleaseFcb( IrpContext, Fcb );
    }

    //
    //  Complete the request if there was no exception.
    //

    UdfCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


//
//  Local support routine
//

NTSTATUS
UdfLockVolumeInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject OPTIONAL
    )

/*++

Routine Description:

    This routine performs the actual lock volume operation.  It will be called
    by anyone wishing to try to protect the volume for a long duration.  PNP
    operations are such a user.
    
    The volume must be held exclusive by the caller.

Arguments:

    Vcb - The volume being locked.
    
    FileObject - File corresponding to the handle locking the volume.  If this
        is not specified, a system lock is assumed.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    NTSTATUS FinalStatus = (FileObject? STATUS_ACCESS_DENIED: STATUS_DEVICE_BUSY);
    ULONG RemainingUserReferences = (FileObject? 1: 0);
    
    KIRQL SavedIrql;

    ASSERT_EXCLUSIVE_VCB( Vcb );
    
    //
    //  The cleanup count for the volume only reflects the fileobject that
    //  will lock the volume.  Otherwise, we must fail the request.
    //
    //  Since the only cleanup is for the provided fileobject, we will try
    //  to get rid of all of the other user references.  If there is only one
    //  remaining after the purge then we can allow the volume to be locked.
    //
    
    UdfPurgeVolume( IrpContext, Vcb, FALSE );

    //
    //  Now back out of our synchronization and wait for the lazy writer
    //  to finish off any lazy closes that could have been outstanding.
    //
    //  Since we purged, we know that the lazy writer will issue all
    //  possible lazy closes in the next tick - if we hadn't, an otherwise
    //  unopened file with a large amount of dirty data could have hung
    //  around for a while as the data trickled out to the disk.
    //
    //  This is even more important now since we send notification to
    //  alert other folks that this style of check is about to happen so
    //  that they can close their handles.  We don't want to enter a fast
    //  race with the lazy writer tearing down his references to the file.
    //

    UdfReleaseVcb( IrpContext, Vcb );

    Status = CcWaitForCurrentLazyWriterActivity();

    //
    //  This is intentional. If we were able to get the Vcb before, just
    //  wait for it and take advantage of knowing that it is OK to leave
    //  the flag up.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );
    UdfAcquireVcbExclusive( IrpContext, Vcb, FALSE );
    
    if (!NT_SUCCESS( Status )) {

        return Status;
    }

    UdfFspClose( Vcb );
        
    //
    //  If the volume is already explicitly locked then fail.  We use the
    //  Vpb locked flag as an 'explicit lock' flag in the same way as Fat.
    //

    IoAcquireVpbSpinLock( &SavedIrql );

    if (!FlagOn( Vcb->Vpb->Flags, VPB_LOCKED ) && 
        (Vcb->VcbCleanup == RemainingUserReferences) &&
        (Vcb->VcbUserReference == Vcb->VcbResidualUserReference + RemainingUserReferences)) {

        SetFlag( Vcb->VcbState, VCB_STATE_LOCKED );
        SetFlag( Vcb->Vpb->Flags, VPB_LOCKED );
        Vcb->VolumeLockFileObject = FileObject;
        FinalStatus = STATUS_SUCCESS;
    }

    IoReleaseVpbSpinLock( SavedIrql );

    return FinalStatus;
}


NTSTATUS
UdfUnlockVolumeInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject OPTIONAL
    )

/*++

Routine Description:

    This routine performs the actual unlock volume operation. 
    
    The volume must be held exclusive by the caller.

Arguments:

    Vcb - The volume being locked.
    
    FileObject - File corresponding to the handle locking the volume.  If this
        is not specified, a system lock is assumed.

Return Value:

    NTSTATUS - The return status for the operation
    
    Attempting to remove a system lock that did not exist is OK.

--*/

{
    NTSTATUS Status = STATUS_NOT_LOCKED;
    KIRQL SavedIrql;

    IoAcquireVpbSpinLock( &SavedIrql ); 

    if (FlagOn(Vcb->Vpb->Flags, VPB_LOCKED) && 
        (FileObject == Vcb->VolumeLockFileObject)) {

        ClearFlag( Vcb->VcbState, VCB_STATE_LOCKED );
        ClearFlag( Vcb->Vpb->Flags, VPB_LOCKED);
        Vcb->VolumeLockFileObject = NULL;
        Status = STATUS_SUCCESS;
    }
    
    IoReleaseVpbSpinLock( SavedIrql );  

    return Status;
}


//
//  Local support routine
//

NTSTATUS
UdfLockVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the lock volume operation.  It is responsible for
    either completing of enqueuing the input Irp.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    PAGED_CODE();

    //
    //  Decode the file object, the only type of opens we accept are
    //  user volume opens.
    //

    if (UdfDecodeFileObject( IrpSp->FileObject, &Fcb, &Ccb ) != UserVolumeOpen) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        return STATUS_INVALID_PARAMETER;
    }
    
    DebugTrace(( +1, Dbg, "UdfLockVolume()\n"));

    //
    //  Send our notification so that folks that like to hold handles on
    //  volumes can get out of the way.
    //

    FsRtlNotifyVolumeEvent( IrpSp->FileObject, FSRTL_VOLUME_LOCK );

    //
    //  Acquire exclusive access to the Vcb.
    //

    Vcb = Fcb->Vcb;
    UdfAcquireVcbExclusive( IrpContext, Vcb, FALSE );

    try {

        //
        //  Verify the Vcb.
        //

        UdfVerifyVcb( IrpContext, Vcb );

        Status = UdfLockVolumeInternal( IrpContext, Vcb, IrpSp->FileObject );

    } finally {

        //
        //  Release the Vcb.
        //

        UdfReleaseVcb( IrpContext, Vcb );

        if (AbnormalTermination() || !NT_SUCCESS( Status )) {

            FsRtlNotifyVolumeEvent( IrpSp->FileObject, FSRTL_VOLUME_LOCK_FAILED );
        }
        
        DebugTrace(( -1, Dbg, "UdfLockVolume() -> 0x%X\n", Status));
    }

    //
    //  Complete the request if there haven't been any exceptions.
    //

    UdfCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


//
//  Local support routine
//

NTSTATUS
UdfUnlockVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the unlock volume operation.  It is responsible for
    either completing of enqueuing the input Irp.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    PAGED_CODE();

    //
    //  Decode the file object, the only type of opens we accept are
    //  user volume opens.
    //

    if (UdfDecodeFileObject( IrpSp->FileObject, &Fcb, &Ccb ) != UserVolumeOpen ) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Acquire exclusive access to the Vcb.
    //

    Vcb = Fcb->Vcb;

    UdfAcquireVcbExclusive( IrpContext, Vcb, FALSE );

    //
    //  We won't check for a valid Vcb for this request.  An unlock will always
    //  succeed on a locked volume.
    //

    Status = UdfUnlockVolumeInternal( IrpContext, Vcb, IrpSp->FileObject );    
    
    //
    //  Release all of our resources
    //

    UdfReleaseVcb( IrpContext, Vcb );

    //
    //  Send notification that the volume is avaliable.
    //

    if (NT_SUCCESS( Status )) {

        FsRtlNotifyVolumeEvent( IrpSp->FileObject, FSRTL_VOLUME_UNLOCK );
    }

    //
    //  Complete the request if there haven't been any exceptions.
    //

    UdfCompleteRequest( IrpContext, Irp, Status );
    return Status;
}



//
//  Local support routine
//

NTSTATUS
UdfDismountVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the dismount volume operation.  It is responsible for
    either completing of enqueuing the input Irp.  We only dismount a volume which
    has been locked.  The intent here is that someone has locked the volume (they are the
    only remaining handle).  We set the volume state to invalid so that it will be torn
    down quickly.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    PAGED_CODE();

    if (UdfDecodeFileObject( IrpSp->FileObject, &Fcb, &Ccb ) != UserVolumeOpen ) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    DebugTrace(( +1, Dbg, "UdfDismountVolume()\n"));

    Vcb = Fcb->Vcb;

    //
    //  Make this request waitable.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT);
    
    //
    //  Acquire exclusive access to the Vcb,  and take the global resource
    //  to sync. against mounts,  verifies etc.
    //

    UdfAcquireUdfData( IrpContext);    
    UdfAcquireVcbExclusive( IrpContext, Vcb, FALSE );

    //
    //  Mark the volume as invalid, but only do it if the vcb is locked
    //  by this handle and the volume is currently mounted.  No more
    //  operations will occur on this vcb except cleanup/close.
    //

    if (Vcb->VcbCondition != VcbMounted)  {

        Status = STATUS_VOLUME_DISMOUNTED;
    }
    else {

        //
        //  Invalidate the volume right now.
        //
        //  The intent here is to make every subsequent operation
        //  on the volume fail and grease the rails toward dismount.
        //
            
        UdfLockVcb( IrpContext, Vcb );
        
        if (Vcb->VcbCondition != VcbDismountInProgress) {
            Vcb->VcbCondition = VcbInvalid;
        }
        
        UdfUnlockVcb( IrpContext, Vcb );

        //
        //  Set flag to tell the close path that we want to force dismount
        //  the volume when this handle is closed.
        //
        
        SetFlag( Ccb->Flags, CCB_FLAG_DISMOUNT_ON_CLOSE);

        Status = STATUS_SUCCESS;
    }

    //
    //  Release all of our resources
    //

    UdfReleaseVcb( IrpContext, Vcb );
    UdfReleaseUdfData( IrpContext);
    
    DebugTrace(( -1, Dbg, "UdfDismountVolume() -> 0x%x\n", Status));
    
    //
    //  Complete the request if there haven't been any exceptions.
    //

    UdfCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


NTSTATUS
UdfAllowExtendedDasdIo(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine marks the CCB to indicate that the handle
    may be used to read past the end of the volume file.  The
    handle must be a dasd handle.

Arguments:

    Irp - Supplies the Irp being processed.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    PIO_STACK_LOCATION IrpSp;
    NTSTATUS Status = STATUS_SUCCESS;
    PFCB Fcb;
    PCCB Ccb;

    //
    //  Get the current Irp stack location and save some references.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Extract and decode the file object and check for type of open.
    //

    if (UserVolumeOpen != UdfDecodeFileObject( IrpSp->FileObject, &Fcb, &Ccb )) {

        Status = STATUS_INVALID_PARAMETER;
    }
    else {

        SetFlag( Ccb->Flags, CCB_FLAG_ALLOW_EXTENDED_DASD_IO );
    }        

    UdfCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


//
//  Local support routine
//

UdfIsVolumeDirty (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines if a volume is currently dirty.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    PULONG VolumeState;
    
    //
    //  Get the current stack location and extract the output
    //  buffer information.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Get a pointer to the output buffer.
    //

    if (Irp->AssociatedIrp.SystemBuffer != NULL) {

        VolumeState = Irp->AssociatedIrp.SystemBuffer;

    } else {

        UdfCompleteRequest( IrpContext, Irp, STATUS_INVALID_USER_BUFFER );
        return STATUS_INVALID_USER_BUFFER;
    }

    //
    //  Make sure the output buffer is large enough and then initialize
    //  the answer to be that the volume isn't dirty.
    //

    if (IrpSp->Parameters.FileSystemControl.OutputBufferLength < sizeof(ULONG)) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    *VolumeState = 0;

    //
    //  Decode the file object
    //

    TypeOfOpen = UdfDecodeFileObject( IrpSp->FileObject, &Fcb, &Ccb );

    if (TypeOfOpen != UserVolumeOpen) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    if (Fcb->Vcb->VcbCondition != VcbMounted) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_VOLUME_DISMOUNTED );
        return STATUS_VOLUME_DISMOUNTED;
    }

    //
    //  Now set up to return the clean state.  If we paid attention to the dirty
    //  state of the media we could be more accurate, but since this is a readonly
    //  implementation at the moment we think it is clean all of the time.
    //
    
    Irp->IoStatus.Information = sizeof( ULONG );

    UdfCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
    return STATUS_SUCCESS;
}


//
//  Local support routine
//

NTSTATUS
UdfIsVolumeMounted (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines if a volume is currently mounted.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PFCB Fcb;
    PCCB Ccb;

    PAGED_CODE();

    //
    //  Decode the file object.
    //

    UdfDecodeFileObject( IrpSp->FileObject, &Fcb, &Ccb );

    if (Fcb != NULL) {

        //
        //  Disable PopUps, we want to return any error.
        //

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DISABLE_POPUPS );

        //
        //  Verify the Vcb.  This will raise in the error condition.
        //

        UdfVerifyVcb( IrpContext, Fcb->Vcb );
    }

    UdfCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );

    return STATUS_SUCCESS;
}


//
//  Local support routine
//

NTSTATUS
UdfIsPathnameValid (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines if pathname is a valid UDFS pathname.
    We always succeed this request.

Arguments:

    Irp - Supplies the Irp to process.

Return Value:

    None

--*/

{
    PAGED_CODE();

    UdfCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
    return STATUS_SUCCESS;
}


//
//  Local support routine
//

NTSTATUS
UdfInvalidateVolumes (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine searches for all the volumes mounted on the same real device
    of the current DASD handle, and marks them all bad.  The only operation
    that can be done on such handles is cleanup and close.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    KIRQL SavedIrql;

    BOOLEAN UnlockVcb = FALSE;

    LUID TcbPrivilege = {SE_TCB_PRIVILEGE, 0};

    HANDLE Handle;

    PVCB Vcb;

    PLIST_ENTRY Links;

    PFILE_OBJECT FileToMarkBad;
    PDEVICE_OBJECT DeviceToMarkBad;

    //
    //  We only allow this operation to be sent to our file system devices.
    //
    
    if (!UdfDeviceIsFsDo( IrpSp->DeviceObject))  {

        UdfCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    //  Check for the correct security access.
    //  The caller must have the SeTcbPrivilege.
    //

    if (!SeSinglePrivilegeCheck( TcbPrivilege, Irp->RequestorMode )) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_PRIVILEGE_NOT_HELD );

        return STATUS_PRIVILEGE_NOT_HELD;
    }

    //
    //  Try to get a pointer to the device object from the handle passed in.
    //

#if defined(_WIN64)
    if (IoIs32bitProcess( Irp )) {
        
        if (IrpSp->Parameters.FileSystemControl.InputBufferLength != sizeof( UINT32 )) {

            UdfCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
            return STATUS_INVALID_PARAMETER;
        }

        Handle = (HANDLE) LongToHandle( *((PUINT32) Irp->AssociatedIrp.SystemBuffer) );
    
    } else {
#endif
        if (IrpSp->Parameters.FileSystemControl.InputBufferLength != sizeof( HANDLE )) {

            UdfCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
            return STATUS_INVALID_PARAMETER;
        }
        Handle = *((PHANDLE) Irp->AssociatedIrp.SystemBuffer);
#if defined(_WIN64)
    }
#endif

    Status = ObReferenceObjectByHandle( Handle,
                                        0,
                                        *IoFileObjectType,
                                        KernelMode,
                                        &FileToMarkBad,
                                        NULL );

    if (!NT_SUCCESS(Status)) {

        UdfCompleteRequest( IrpContext, Irp, Status );
        return Status;
    }

    //
    //  Grab the DeviceObject from the FileObject.
    //

    DeviceToMarkBad = FileToMarkBad->DeviceObject;

    //
    //  We only needed the device object involved, not a reference to the file.
    //

    ObDereferenceObject( FileToMarkBad );

    //
    //  Make sure this request can wait.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );
    ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_FORCE_POST );

    UdfAcquireUdfData( IrpContext );

    //
    //  Nothing can go wrong now.
    //

    //
    //  Now walk through all the mounted Vcb's looking for candidates to
    //  mark invalid.
    //
    //  On volumes we mark invalid, check for dismount possibility (which is
    //  why we have to get the next link so early).
    //

    Links = UdfData.VcbQueue.Flink;

    while (Links != &UdfData.VcbQueue) {

        Vcb = CONTAINING_RECORD( Links, VCB, VcbLinks);

        Links = Links->Flink;

        //
        //  If we get a match, mark the volume Bad, and also check to
        //  see if the volume should go away.
        //

        UdfLockVcb( IrpContext, Vcb );

        if (Vcb->Vpb->RealDevice == DeviceToMarkBad) {

            //
            //  Take the VPB spinlock,  and look to see if this volume is the 
            //  one currently mounted on the actual device.  If it is,  pull it 
            //  off immediately.
            //

            IoAcquireVpbSpinLock( &SavedIrql );
    
            if (DeviceToMarkBad->Vpb == Vcb->Vpb) {

                PVPB NewVpb = Vcb->SwapVpb;

                ASSERT( FlagOn( Vcb->Vpb->Flags, VPB_MOUNTED));
                ASSERT( NULL != NewVpb);

                RtlZeroMemory( NewVpb, sizeof( VPB ) );

                NewVpb->Type = IO_TYPE_VPB;
                NewVpb->Size = sizeof( VPB );
                NewVpb->RealDevice = DeviceToMarkBad;
                NewVpb->Flags = FlagOn( DeviceToMarkBad->Vpb->Flags, VPB_REMOVE_PENDING );

                DeviceToMarkBad->Vpb = NewVpb;
                Vcb->SwapVpb = NULL;
            }

            IoReleaseVpbSpinLock( SavedIrql );

            if (Vcb->VcbCondition != VcbDismountInProgress) {

                UdfSetVcbCondition( Vcb, VcbInvalid);
            }

            UdfUnlockVcb( IrpContext, Vcb );

            UdfAcquireVcbExclusive( IrpContext, Vcb, FALSE);
            
            UdfPurgeVolume( IrpContext, Vcb, FALSE );

            UnlockVcb = UdfCheckForDismount( IrpContext, Vcb, FALSE );
            
            if (UnlockVcb)  {

                UdfReleaseVcb( IrpContext, Vcb);
            }

        } else {

            UdfUnlockVcb( IrpContext, Vcb );
        }
    }

    UdfReleaseUdfData( IrpContext );

    UdfCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
    return STATUS_SUCCESS;
}


VOID
UdfRemountOldVcb(
    IN PIRP_CONTEXT IrpContext,
    IN PVCB OldVcb,
    IN PVCB NewVcb,
    IN PDEVICE_OBJECT DeviceObjectWeTalkTo
    )
{
    KIRQL SavedIrql;
    
    ObDereferenceObject( OldVcb->TargetDeviceObject );

    IoAcquireVpbSpinLock( &SavedIrql);
    
    NewVcb->Vpb->RealDevice->Vpb = OldVcb->Vpb;

    OldVcb->Vpb->RealDevice = NewVcb->Vpb->RealDevice;
    OldVcb->TargetDeviceObject = DeviceObjectWeTalkTo;

    UdfSetVcbCondition( OldVcb, VcbMounted);

    UdfSetMediaChangeCount( OldVcb, NewVcb->MediaChangeCount);

    ClearFlag( OldVcb->VcbState, VCB_STATE_VPB_NOT_ON_DEVICE);

    IoReleaseVpbSpinLock( SavedIrql);
}


//
//  Local support routine
//

NTSTATUS
UdfMountVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the mount volume operation.  It is responsible for
    either completing of enqueuing the input Irp.

    Its job is to verify that the volume denoted in the IRP is a UDF volume,
    and create the VCB and root directory FCB structures.  The algorithm it
    uses is essentially as follows:

    1. Create a new Vcb Structure, and initialize it enough to do I/O
       through the on-disk volume descriptors.

    2. Read the disk and check if it is a UDF volume.

    3. If it is not a UDF volume then delete the Vcb and
       complete the IRP with STATUS_UNRECOGNIZED_VOLUME

    4. Check if the volume was previously mounted and if it was then do a
       remount operation.  This involves deleting the VCB, hook in the
       old VCB, and complete the IRP.

    5. Otherwise create a Vcb and root directory FCB

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;

    PVOLUME_DEVICE_OBJECT VolDo = NULL;
    PVCB Vcb = NULL;
    PVCB OldVcb = NULL;
    PPCB Pcb = NULL;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PDEVICE_OBJECT DeviceObjectWeTalkTo = IrpSp->Parameters.MountVolume.DeviceObject;
    PVPB Vpb = IrpSp->Parameters.MountVolume.Vpb;

    PFILE_OBJECT FileObjectToNotify = NULL;

    ULONG MediaChangeCount = 0;

    DISK_GEOMETRY DiskGeometry;

    PNSR_ANCHOR AnchorVolumeDescriptor = NULL;
    PNSR_PVD PrimaryVolumeDescriptor = NULL;
    PNSR_LVOL LogicalVolumeDescriptor = NULL;
    PNSR_FSD FileSetDescriptor = NULL;

    BOOLEAN BridgeMedia;
    BOOLEAN SetDoVerifyOnFail;

    USHORT NSRVerFound = UDF_NSR_NO_VRS_FOUND;

    ULONG BoundS;
    ULONG BoundN;

    PAGED_CODE();

    //
    //  Check the input parameters
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    //
    //  Check that we are talking to a Cdrom or Disk device.  This request should
    //  always be waitable.
    //

    ASSERT( Vpb->RealDevice->DeviceType == FILE_DEVICE_CD_ROM ||
            Vpb->RealDevice->DeviceType == FILE_DEVICE_DISK || 
            Vpb->RealDevice->DeviceType == FILE_DEVICE_VIRTUAL_DISK );

    ASSERT( FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT ));

    DebugTrace(( +1, Dbg | UDFS_DEBUG_LEVEL_VERFYSUP,  "UdfMountVolume (Vpb %p, Dev %p)\n",
                 Vpb, Vpb->RealDevice));

    //
    //  Update the real device in the IrpContext from the Vpb.  There was no available
    //  file object when the IrpContext was created.
    //

    IrpContext->RealDevice = Vpb->RealDevice;
    
    SetDoVerifyOnFail = UdfRealDevNeedsVerify( IrpContext->RealDevice);

    //
    //  Check if we have disabled the mount process.
    //

    if (UdfDisable) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_UNRECOGNIZED_VOLUME );
        DebugTrace(( 0, Dbg, "UdfMountVolume, disabled\n" ));
        DebugTrace(( -1, Dbg, "UdfMountVolume -> STATUS_UNRECOGNIZED_VOLUME\n" ));

        return STATUS_UNRECOGNIZED_VOLUME;
    }

    //
    //  Don't even attempt to mount floppy discs
    //
    
    if (FlagOn( Vpb->RealDevice->Characteristics, FILE_FLOPPY_DISKETTE)) {

        UdfCompleteRequest( IrpContext, Irp, STATUS_UNRECOGNIZED_VOLUME );
        return STATUS_UNRECOGNIZED_VOLUME;
    }

    //
    //  Do a CheckVerify here to lift the MediaChange ticker from the driver
    //

    Status = UdfPerformDevIoCtrl( IrpContext,
                                  ( Vpb->RealDevice->DeviceType == FILE_DEVICE_CD_ROM ?
                                    IOCTL_CDROM_CHECK_VERIFY :
                                    IOCTL_DISK_CHECK_VERIFY ),
                                  DeviceObjectWeTalkTo,
                                  NULL,
                                  0,
                                  &MediaChangeCount,
                                  sizeof(ULONG),
                                  FALSE,
                                  TRUE,
                                  NULL );

    if (!NT_SUCCESS( Status )) {
        
        UdfCompleteRequest( IrpContext, Irp, Status );
        DebugTrace(( 0, Dbg,
                     "UdfMountVolume, CHECK_VERIFY handed back status %08x (so don't continue)\n",
                     Status ));
        DebugTrace(( -1, Dbg,
                     "UdfMountVolume -> %08x\n",
                     Status ));

        return Status;
    }
    
    //
    //  Now let's make Jeff delirious and call to get the disk geometry.  This
    //  will fix the case where the first change line is swallowed.
    //
    //  This IOCTL does not have a generic STORAGE equivalent, so we must figure
    //  our which variant to pass down from the real underlying device object (as
    //  opposed to the top of the driver filter stack we will really be attaching
    //  on top of).
    //

    Status = UdfPerformDevIoCtrl( IrpContext,
                                  ( Vpb->RealDevice->DeviceType == FILE_DEVICE_CD_ROM ?
                                    IOCTL_CDROM_GET_DRIVE_GEOMETRY :
                                    IOCTL_DISK_GET_DRIVE_GEOMETRY ),
                                  DeviceObjectWeTalkTo,
                                  NULL,
                                  0,
                                  &DiskGeometry,
                                  sizeof( DISK_GEOMETRY ),
                                  FALSE,
                                  TRUE,
                                  NULL );

    //
    //  If this call failed, we might be able to get away with a heuristic guess as to
    //  what the sector size is (per CDFS), but that is playing with fire.  Nearly every
    //  failure here will be a permanent problem of some form.
    //

    if (!NT_SUCCESS( Status )) {

        UdfCompleteRequest( IrpContext, Irp, Status );
        DebugTrace(( 0, Dbg, "UdfMountVolume, GET_DRIVE_GEOMETRY failed\n" ));
        DebugTrace(( -1, Dbg,
                     "UdfMountVolume -> %08x\n",
                     Status ));

        return Status;
    }

    //
    //  Acquire the global resource to do mount operations.
    //

    UdfAcquireUdfData( IrpContext );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Do a quick check to see if there any Vcb's which can be removed.
        //

        UdfScanForDismountedVcb( IrpContext );

        //
        //  Make sure that the driver/drive is not screwing up underneath of us by
        //  feeding us garbage for the sector size.
        //

        if (DiskGeometry.BytesPerSector == 0 ||
            (DiskGeometry.BytesPerSector & ~( 1 << UdfHighBit( DiskGeometry.BytesPerSector ))) != 0) {

            DebugTrace(( 0, 0,
                         "UdfMountVolume, bad DiskGeometry (%08x) .BytesPerSector == %08x\n",
                         &DiskGeometry,
                         DiskGeometry.BytesPerSector ));

            ASSERT( FALSE );

            try_leave( Status = STATUS_DRIVER_INTERNAL_ERROR );
        }

        //
        //  Now find the multi-session bounds on this media.
        //

        UdfDetermineVolumeBounding( IrpContext,
                                    DeviceObjectWeTalkTo,
                                    &BoundS,
                                    &BoundN );

        //
        //  Now go confirm that this volume may be a UDF image by looking for a
        //  valid ISO 13346 Volume Recognition Sequence in the last and first
        //  sessions.
        //

        if (!UdfRecognizeVolume( IrpContext,
                                 DeviceObjectWeTalkTo,
                                 DiskGeometry.BytesPerSector,
                                 &BoundS,
                                 &BridgeMedia,
                                 &NSRVerFound)) {

#ifdef EXPERIMENTAL_MOUNT_OPEN_R_MEDIA

            if (DeviceObjectWeTalkTo->DeviceType == FILE_DEVICE_CD_ROM)  {
                
                DebugTrace(( 0, Dbg, "UdfMountVolume, recognition failed but continuing to look for open R volume\n"));
            }
            else
#endif
            {
                DebugTrace(( 0, Dbg, "UdfMountVolume, recognition failed so not mounting\n" ));

                try_leave( Status = STATUS_UNRECOGNIZED_VOLUME );
            }
        }

        //
        //  Create the DeviceObject for this mount attempt
        //

        Status = IoCreateDevice( UdfData.DriverObject,
                                 sizeof( VOLUME_DEVICE_OBJECT ) - sizeof( DEVICE_OBJECT ),
                                 NULL,
                                 FILE_DEVICE_CD_ROM_FILE_SYSTEM,
                                 0,
                                 FALSE,
                                 (PDEVICE_OBJECT *) &VolDo );

        if (!NT_SUCCESS( Status )) {

            DebugTrace(( 0, Dbg, "UdfMountVolume, couldn't get voldo! (%08x)\n", Status ));
            try_leave( Status );
        }

        //
        //  Our alignment requirement is the larger of the processor alignment requirement
        //  already in the volume device object and that in the DeviceObjectWeTalkTo
        //

        if (DeviceObjectWeTalkTo->AlignmentRequirement > VolDo->DeviceObject.AlignmentRequirement) {

            VolDo->DeviceObject.AlignmentRequirement = DeviceObjectWeTalkTo->AlignmentRequirement;
        }

        //
        //  Initialize the overflow queue for the volume
        //

        VolDo->OverflowQueueCount = 0;
        InitializeListHead( &VolDo->OverflowQueue );

        VolDo->PostedRequestCount = 0;
        KeInitializeSpinLock( &VolDo->OverflowQueueSpinLock );

        //
        //  Now before we can initialize the Vcb we need to set up the
        //  device object field in the VPB to point to our new volume device
        //  object.
        //

        Vpb->DeviceObject = (PDEVICE_OBJECT) VolDo;

        //
        //  Initialize the Vcb.  This routine will raise on an allocation
        //  failure.
        //

        UdfInitializeVcb( IrpContext,
                          &VolDo->Vcb,
                          DeviceObjectWeTalkTo,
                          Vpb,
                          &DiskGeometry,
                          MediaChangeCount );

        //
        //  We must initialize the stack size in our device object before
        //  the following reads, because the I/O system has not done it yet.
        //

        ((PDEVICE_OBJECT) VolDo)->StackSize = (CCHAR) (DeviceObjectWeTalkTo->StackSize + 1);

        //
        //  Set the correct sector size.  IO defaults to 512b for DISK_FS and 2k for
        //  CDROM_FS....
        //

        ((PDEVICE_OBJECT) VolDo)->SectorSize = (USHORT) DiskGeometry.BytesPerSector;

        ClearFlag( VolDo->DeviceObject.Flags, DO_DEVICE_INITIALIZING );

        //
        //  Pick up a local pointer to the new Vcb.  Here is where we start
        //  thinking about cleanup of structures if the mount is failed.
        //

        Vcb = &VolDo->Vcb;
        Vpb = NULL;
        VolDo = NULL;

        //
        //  Store the session bounds we determined earlier.
        //
        
        Vcb->BoundS = BoundS;
        Vcb->BoundN = BoundN;

        //
        //  Store the Vcb in the IrpContext as we didn't have one before.
        //

        IrpContext->Vcb = Vcb;

        UdfAcquireVcbExclusive( IrpContext, Vcb, FALSE );

        //
        //  Store the NSR version that we found
        //

        Vcb->NsrVersion = NSRVerFound;

        //
        //  Let's reference the Vpb to make sure we are the one to
        //  have the last dereference.
        //

        Vcb->Vpb->ReferenceCount += 1;

        //
        //  Clear the verify bit for the start of mount.
        //

        UdfMarkRealDevVerifyOk( Vcb->Vpb->RealDevice);

        //
        //  Now find the Anchor Volume Descriptor so we can discover the Volume Set
        //  Descriptor Sequence extent.
        //

        Status = UdfFindAnchorVolumeDescriptor( IrpContext,
                                                Vcb,
                                                &AnchorVolumeDescriptor );

        if (!NT_SUCCESS(Status)) {

            DebugTrace(( 0, Dbg, "UdfMountVolume, couldn't find anchor descriptors\n" ));
            try_leave( Status );
        }

        //
        //  Now search for the prevailing copies of the PVD, LVD, and related PD in the
        //  extents indicated by the AVD.
        //

        Status = UdfFindVolumeDescriptors( IrpContext,
                                           Vcb,
                                           &AnchorVolumeDescriptor->Main,
                                           &Pcb,
                                           &PrimaryVolumeDescriptor,
                                           &LogicalVolumeDescriptor );

        //
        //  If we discovered invalid structures on the main extent, we may still
        //  be able to use the reserve extent.  By definition the two extents
        //  must be logically equal, so just plow into it on any error.
        //

        if (!NT_SUCCESS( Status )) {

            Status = UdfFindVolumeDescriptors( IrpContext,
                                               Vcb,
                                               &AnchorVolumeDescriptor->Reserve,
                                               &Pcb,
                                               &PrimaryVolumeDescriptor,
                                               &LogicalVolumeDescriptor );
        }

        if (!NT_SUCCESS(Status)) {

            DebugTrace(( 0, Dbg, "UdfMountVolume, couldn't find good VSD descriptors (PVD/LVD/PD) status %X\n", Status ));
            try_leave( Status );
        }

        //
        //  Now go complete initialization of the Pcb.  After this point, we can perform
        //  physical partition mappings and know that the partition table is good.
        //

        Status = UdfCompletePcb( IrpContext,
                                 Vcb,
                                 Pcb );

        if (!NT_SUCCESS(Status)) {

            DebugTrace(( 0, Dbg, "UdfMountVolume, Pcb completion failed\n" ));
            try_leave( Status );
        }

        Vcb->Pcb = Pcb;
        Pcb = NULL;

        //
        //  Set up all the support we need to do reads into the volume.
        //

        UdfUpdateVcbPhase0( IrpContext, Vcb );

        //
        //  Now go get the fileset descriptor that will finally reveal the location
        //  of the root directory on this volume.
        //

        Status = UdfFindFileSetDescriptor( IrpContext,
                                           Vcb,
                                           &LogicalVolumeDescriptor->FSD,
                                           &FileSetDescriptor );

        if (!NT_SUCCESS(Status)) {

            try_leave( NOTHING );
        }

        //
        //  Now that we have everything together, update the Vpb with identification
        //  of this volume.
        //

        UdfUpdateVolumeLabel( IrpContext,
                              Vcb->Vpb->VolumeLabel,
                              &Vcb->Vpb->VolumeLabelLength,
                              LogicalVolumeDescriptor->VolumeID,
                              sizeof( LogicalVolumeDescriptor->VolumeID ));

        UdfUpdateVolumeSerialNumber( IrpContext,
                                     &Vcb->Vpb->SerialNumber,
                                     FileSetDescriptor );

        //
        //  Check if this is a remount operation.  If so then clean up
        //  the data structures passed in and created here.
        //

        if (UdfIsRemount( IrpContext, Vcb, &OldVcb )) {

            KIRQL SavedIrql;

            DebugTrace((0, Dbg | UDFS_DEBUG_LEVEL_VERFYSUP, "Remounting Vcb %p (Vpb %p)\n",
                        OldVcb , OldVcb->Vpb));
            //
            //  Link the old Vcb to point to the new device object that we
            //  should be talking to, dereferencing the previous.  Call a nonpaged
            //  routine to do this since we take the Vpb spinlock.
            //

            UdfRemountOldVcb( IrpContext, 
                              OldVcb, 
                              Vcb,
                              DeviceObjectWeTalkTo);

            //
            //  Push the state of the method 2 bit across.  In changing the device,
            //  we may now be on one with a different requirement.
            //

            ClearFlag( OldVcb->VcbState, VCB_STATE_METHOD_2_FIXUP );
            SetFlag( OldVcb->VcbState, FlagOn( Vcb->VcbState, VCB_STATE_METHOD_2_FIXUP ));
            
            //
            //  See if we will need to provide notification of the remount.  This is the readonly
            //  filesystem's form of dismount/mount notification - we promise that whenever a
            //  volume is "dismounted", that a mount notification will occur when it is revalidated.
            //  Note that we do not send mount on normal remounts - that would duplicate the media
            //  arrival notification of the device driver.
            //
    
            if (FlagOn( OldVcb->VcbState, VCB_STATE_NOTIFY_REMOUNT )) {
    
                ClearFlag( OldVcb->VcbState, VCB_STATE_NOTIFY_REMOUNT );
                
                FileObjectToNotify = OldVcb->RootIndexFcb->FileObject;
                ObReferenceObject( FileObjectToNotify );
            }
            
            DebugTrace(( 0, Dbg, "UdfMountVolume, remounted old Vcb %08x\n", OldVcb ));

            try_leave( Status = STATUS_SUCCESS );
        }

        //
        //  Initialize the Vcb and associated structures from our volume descriptors
        //

        UdfUpdateVcbPhase1( IrpContext,
                            Vcb,
                            FileSetDescriptor );

        //
        //  Drop an extra reference on the root dir file so we'll be able to send
        //  notification.
        //

        if (Vcb->RootIndexFcb) {

            FileObjectToNotify = Vcb->RootIndexFcb->FileObject;
            ObReferenceObject( FileObjectToNotify );
        }

        //
        //  The new mount is complete.  Remove the additional references on this
        //  Vcb since, at this point, we have added the real references this volume
        //  will have during its lifetime.  We also need to drop the additional
        //  reference on the device we mounted.
        //

        Vcb->VcbReference -= Vcb->VcbResidualReference;
        ASSERT( Vcb->VcbReference == Vcb->VcbResidualReference );

        ObDereferenceObject( Vcb->TargetDeviceObject );

        UdfSetVcbCondition( Vcb, VcbMounted);

        UdfReleaseVcb( IrpContext, Vcb );
        Vcb = NULL;

        Status = STATUS_SUCCESS;

    } finally {

        DebugUnwind( "UdfMountVolume" );

        //
        //  If we are not mounting the device,  then set the verify bit again.
        //
        
        if ((AbnormalTermination() || (Status != STATUS_SUCCESS)) && 
            SetDoVerifyOnFail)  {

            UdfMarkRealDevForVerify( IrpContext->RealDevice);
        }

        //
        //  If we didn't complete the mount then cleanup any remaining structures.
        //

        if (Vpb != NULL) { Vpb->DeviceObject = NULL; }

        if (Pcb != NULL) {

            UdfDeletePcb( Pcb );
        }

        if (Vcb != NULL) {

            //
            //  Make sure there is no Vcb in the IrpContext since it could go away
            //

            IrpContext->Vcb = NULL;

            Vcb->VcbReference -= Vcb->VcbResidualReference;

            if (UdfDismountVcb( IrpContext, Vcb )) {

                UdfReleaseVcb( IrpContext, Vcb );
            }

        } else if (VolDo != NULL) {

            IoDeleteDevice( (PDEVICE_OBJECT)VolDo );
            Vpb->DeviceObject = NULL;
        }
        
        //
        //  Release the global resource.
        //

        UdfReleaseUdfData( IrpContext );

        //
        //  Free any structures we may have been allocated
        //

        UdfFreePool( &AnchorVolumeDescriptor );
        UdfFreePool( &PrimaryVolumeDescriptor );
        UdfFreePool( &LogicalVolumeDescriptor );
        UdfFreePool( &FileSetDescriptor );
    }

    //
    //  Now send mount notification.
    //
    
    if (FileObjectToNotify) {

        FsRtlNotifyVolumeEvent( FileObjectToNotify, FSRTL_VOLUME_MOUNT );
        ObDereferenceObject( FileObjectToNotify );
    }

    //
    //  Complete the request if no exception.
    //

    UdfCompleteRequest( IrpContext, Irp, Status );
    DebugTrace(( -1, Dbg, "UdfMountVolume -> %08x\n", Status ));

    return Status;
}


//
//  Local support routine
//

NTSTATUS
UdfVerifyVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the verify volume operation.  It is responsible for
    either completing of enqueuing the input Irp.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PVPB Vpb = IrpSp->Parameters.VerifyVolume.Vpb;
    PVCB Vcb = &((PVOLUME_DEVICE_OBJECT) IrpSp->Parameters.VerifyVolume.DeviceObject)->Vcb;

    PPCB Pcb = NULL;

    PNSR_ANCHOR AnchorVolumeDescriptor = NULL;
    PNSR_PVD PrimaryVolumeDescriptor = NULL;
    PNSR_LVOL LogicalVolumeDescriptor = NULL;
    PNSR_FSD FileSetDescriptor = NULL;

    ULONG MediaChangeCount = Vcb->MediaChangeCount;
    ULONG Index;

    PFILE_OBJECT FileObjectToNotify = NULL;

    BOOLEAN ReturnError;
    BOOLEAN ReleaseVcb = FALSE;

    IO_STATUS_BLOCK Iosb;

    WCHAR VolumeLabel[ MAXIMUM_VOLUME_LABEL_LENGTH / sizeof( WCHAR )];
    USHORT VolumeLabelLength;
    ULONG VolumeSerialNumber;

    NTSTATUS Status;

    PAGED_CODE();

    //
    //  Check input.
    //

    ASSERT_IRP_CONTEXT( IrpContext );

    //
    //  Check that we are talking to a Cdrom or Disk device.  This request should
    //  always be waitable.
    //

    ASSERT( Vpb->RealDevice->DeviceType == FILE_DEVICE_CD_ROM ||
            Vpb->RealDevice->DeviceType == FILE_DEVICE_DISK );

    ASSERT_VCB( Vcb );
    ASSERT( FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT ));

    //
    //  Update the real device in the IrpContext from the Vpb.  There was no available
    //  file object when the IrpContext was created.
    //

    IrpContext->RealDevice = Vpb->RealDevice;

    DebugTrace(( +1, Dbg, "UdfVerifyVolume, Vcb %08x\n", Vcb ));

    //
    //  Acquire the global to synchronise against mounts and teardown.
    //

    UdfAcquireUdfData( IrpContext );

    try {

        UdfAcquireVcbExclusive( IrpContext, Vcb, FALSE );
        ReleaseVcb = TRUE;

        //
        //  Verify that there is a disk here.
        //

        Status = UdfPerformDevIoCtrl( IrpContext,
                                      ( Vpb->RealDevice->DeviceType == FILE_DEVICE_CD_ROM ?
                                        IOCTL_CDROM_CHECK_VERIFY :
                                        IOCTL_DISK_CHECK_VERIFY ),
                                      Vcb->TargetDeviceObject,
                                      NULL,
                                      0,
                                      &MediaChangeCount,
                                      sizeof(ULONG),
                                      FALSE,
                                      TRUE,
                                      &Iosb );

        if (!NT_SUCCESS( Status )) {

            DebugTrace(( 0, Dbg, "UdfVerifyVolume, CHECK_VERIFY failed\n" ));

            //
            //  If we will allow a raw mount then return WRONG_VOLUME to
            //  allow the volume to be mounted by raw.
            //

            if (FlagOn( IrpSp->Flags, SL_ALLOW_RAW_MOUNT )) {

                DebugTrace(( 0, Dbg, "UdfVerifyVolume, ... allowing raw mount\n" ));

                Status = STATUS_WRONG_VOLUME;
            }

            try_leave( Status );
        }

        if (Iosb.Information != sizeof(ULONG)) {

            //
            //  Be safe about the count in case the driver didn't fill it in
            //

            MediaChangeCount = 0;
        }

        //
        //  Verify that the device actually saw a change. If the driver does not
        //  support the MCC, then we must verify the volume in any case.
        //

        if (MediaChangeCount == 0 || (Vcb->MediaChangeCount != MediaChangeCount)) {

            //
            //  Now we need to navigate the disc to find the relavent decriptors.  This is
            //  much the same as the mount process.
            //

            //
            //  Find the AVD.
            //

            Status = UdfFindAnchorVolumeDescriptor( IrpContext,
                                                    Vcb,
                                                    &AnchorVolumeDescriptor );

            if (!NT_SUCCESS(Status)) {
                
                DebugTrace(( 0, Dbg, "UdfVerifyVolume, No AVD visible\n" ));
                try_leave( Status = STATUS_WRONG_VOLUME );
            }
            
            //
            //  Get the prevailing descriptors out of the VDS, building a fresh Pcb.
            //

            Status = UdfFindVolumeDescriptors( IrpContext,
                                               Vcb,
                                               &AnchorVolumeDescriptor->Main,
                                               &Pcb,
                                               &PrimaryVolumeDescriptor,
                                               &LogicalVolumeDescriptor );

            //
            //  Try the reserve sequence in case of error.
            //

            if (Status == STATUS_DISK_CORRUPT_ERROR) {

                Status = UdfFindVolumeDescriptors( IrpContext,
                                                   Vcb,
                                                   &AnchorVolumeDescriptor->Reserve,
                                                   &Pcb,
                                                   &PrimaryVolumeDescriptor,
                                                   &LogicalVolumeDescriptor );
            }

            //
            //  If we're totally unable to find a VDS, give up.
            //

            if (!NT_SUCCESS(Status)) {

                DebugTrace(( 0, Dbg, "UdfVerifyVolume, PVD/LVD/PD pickup failed\n" ));

                try_leave( Status = STATUS_WRONG_VOLUME );
            }

            //
            //  Now go complete initialization of the Pcb so we can compare it.
            //

            Status = UdfCompletePcb( IrpContext,
                                     Vcb,
                                     Pcb );

            if (!NT_SUCCESS(Status)) {

                DebugTrace(( 0, Dbg, "UdfVerifyVolume, Pcb completion failed\n" ));

                try_leave( Status = STATUS_WRONG_VOLUME );
            }

            //
            //  Now let's compare this new Pcb to the previous Vcb's Pcb to see if they
            //  appear to be equivalent.
            //

            if (!UdfEquivalentPcb( IrpContext,
                                   Pcb,
                                   Vcb->Pcb)) {

                DebugTrace(( 0, Dbg, "UdfVerifyVolume, Pcbs are not equivalent\n" ));

                try_leave( Status = STATUS_WRONG_VOLUME );
            }

            //
            //  At this point we know that the Vcb's Pcb is OK for mapping to find the fileset
            //  descriptor, so we can drop the new one we built for comparison purposes.
            //

            UdfDeletePcb( Pcb );
            Pcb = NULL;

            //
            //  Go pick up the fileset descriptor.
            //

            Status = UdfFindFileSetDescriptor( IrpContext,
                                               Vcb,
                                               &LogicalVolumeDescriptor->FSD,
                                               &FileSetDescriptor );

            if (!NT_SUCCESS(Status)) {

                try_leave( Status = STATUS_WRONG_VOLUME );
            }

            //
            //  Now that everything is in place, build a volume label and serial number from these
            //  descriptors and perform the final check that this Vcb is (or is not) the right one
            //  for the media now in the drive.
            //

            UdfUpdateVolumeLabel( IrpContext,
                                  VolumeLabel,
                                  &VolumeLabelLength,
                                  LogicalVolumeDescriptor->VolumeID,
                                  sizeof( LogicalVolumeDescriptor->VolumeID ));

            UdfUpdateVolumeSerialNumber( IrpContext,
                                         &VolumeSerialNumber,
                                         FileSetDescriptor );

            if ((Vcb->Vpb->SerialNumber != VolumeSerialNumber) ||
                (Vcb->Vpb->VolumeLabelLength != VolumeLabelLength) ||
                (VolumeLabelLength != RtlCompareMemory( Vcb->Vpb->VolumeLabel,
                                                        VolumeLabel,
                                                        VolumeLabelLength))) {

                DebugTrace(( 0, Dbg, "UdfVerifyVolume, volume label/sn mismatch\n" ));

                try_leave( Status = STATUS_WRONG_VOLUME );
            }
        }

        //
        //  The volume is OK, clear the verify bit.
        //

        DebugTrace(( 0, Dbg, "UdfVerifyVolume, looks like the same volume\n" ));

        UdfSetVcbCondition( Vcb, VcbMounted);

        UdfMarkRealDevVerifyOk( Vpb->RealDevice);

        //
        //  See if we will need to provide notification of the remount.  This is the readonly
        //  filesystem's form of dismount/mount notification.
        //

        if (FlagOn( Vcb->VcbState, VCB_STATE_NOTIFY_REMOUNT )) {

            ClearFlag( Vcb->VcbState, VCB_STATE_NOTIFY_REMOUNT );
            
            FileObjectToNotify = Vcb->RootIndexFcb->FileObject;
            ObReferenceObject( FileObjectToNotify );
        }
        
    } finally {

        //
        //  If we did not raise an exception, update the current Vcb.
        //

        if (!AbnormalTermination()) {

            //
            //  Update the media change count to note that we have verified the volume
            //  at this value
            //

            UdfSetMediaChangeCount( Vcb, MediaChangeCount);

            //
            //  Mark the Vcb as not mounted.
            //

            if (Status == STATUS_WRONG_VOLUME) {

                UdfSetVcbCondition( Vcb, VcbNotMounted);
                
                //
                //  Now, if there are no user handles to the volume, try to spark
                //  teardown by purging the volume.
                //

                if (Vcb->VcbCleanup == 0) {

                    if (NT_SUCCESS( UdfPurgeVolume( IrpContext, Vcb, FALSE ))) {

                        ReleaseVcb = UdfCheckForDismount( IrpContext, Vcb, FALSE );
                    }
                }
            }
        }

        DebugTrace(( -1, Dbg, "UdfVerifyVolume -> %08x\n", Status ));

        if (ReleaseVcb) {
            
            UdfReleaseVcb( IrpContext, Vcb );
        }

        UdfReleaseUdfData( IrpContext );

        //
        //  Delete the Pcb if built.
        //

        if (Pcb != NULL) {

            UdfDeletePcb( Pcb );
        }

        UdfFreePool( &AnchorVolumeDescriptor );
        UdfFreePool( &PrimaryVolumeDescriptor );
        UdfFreePool( &LogicalVolumeDescriptor );
        UdfFreePool( &FileSetDescriptor );
    }

    //
    //  Now send mount notification.
    //
    
    if (FileObjectToNotify) {

        FsRtlNotifyVolumeEvent( FileObjectToNotify, FSRTL_VOLUME_MOUNT );
        ObDereferenceObject( FileObjectToNotify );
    }
    
    //
    //  Complete the request if no exception.
    //

    UdfCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


//
//  Local support routine
//

BOOLEAN
UdfIsRemount (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    OUT PVCB *OldVcb
    )

/*++

Routine Description:

    This routine walks through the links of the Vcb chain in the global
    data structure.  The remount condition is met when the following
    conditions are all met:

            1 - The 32 serial for this VPB matches that in a previous
                VPB.

            2 - The volume label for this VPB matches that in the previous
                VPB.

            3 - The system pointer to the real device object in the current
                VPB matches that in the same previous VPB.

            4 - Finally the previous Vcb cannot be invalid or have a dismount
                underway.

    If a VPB is found which matches these conditions, then the address of
    the Vcb for that VPB is returned via the pointer OldVcb.

    Skip over the current Vcb.

Arguments:

    Vcb - This is the Vcb we are checking for a remount.

    OldVcb -  A pointer to the address to store the address for the Vcb
              for the volume if this is a remount.  (This is a pointer to
              a pointer)

Return Value:

    BOOLEAN - TRUE if this is in fact a remount, FALSE otherwise.

--*/

{
    PLIST_ENTRY Link;

    PVPB Vpb = Vcb->Vpb;
    PVPB OldVpb;

    BOOLEAN Remount = FALSE;

    PAGED_CODE();

    //
    //  Check input.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    DebugTrace(( +1, Dbg, "UdfIsRemount, Vcb %08x\n", Vcb ));

    for (Link = UdfData.VcbQueue.Flink;
         Link != &UdfData.VcbQueue;
         Link = Link->Flink) {

        *OldVcb = CONTAINING_RECORD( Link, VCB, VcbLinks );

        //
        //  Skip ourselves.
        //

        if (Vcb == *OldVcb) { continue; }

        //
        //  Look at the Vpb and state of the previous Vcb.
        //

        OldVpb = (*OldVcb)->Vpb;

        if ((OldVpb != Vpb) &&
            (OldVpb->RealDevice == Vpb->RealDevice) &&
            ((*OldVcb)->VcbCondition == VcbNotMounted)) {

            //
            //  Go ahead and compare serial numbers and volume label.
            //

            if ((OldVpb->SerialNumber == Vpb->SerialNumber) &&
                       (Vpb->VolumeLabelLength == OldVpb->VolumeLabelLength) &&
                       (RtlEqualMemory( OldVpb->VolumeLabel,
                                        Vpb->VolumeLabel,
                                        Vpb->VolumeLabelLength ))) {

                //
                //  Got it.
                //

                DebugTrace(( 0, Dbg, "UdfIsRemount, matched OldVcb %08x\n", *OldVcb ));

                Remount = TRUE;
                break;
            }
        }
    }

    DebugTrace(( -1, Dbg, "UdfIsRemount -> %c\n", (Remount? 'T' : 'F' )));

    return Remount;
}


//
//  Local support routine
//

NTSTATUS
UdfFindFileSetDescriptor (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PLONGAD LongAd,
    IN OUT PNSR_FSD *FileSetDescriptor
    )

/*++

Routine Description:

    This routine walks a Fileset Descriptor Sequence looking for the default
    descriptor.  This will reveal the location of the root directory on the
    volume.

Arguments:

    Vcb - Vcb of volume to search

    LongAd - Long allocation descriptor describing the start of the sequence

    FileSetDescriptor - Address of caller's pointer to an FSD

Return Value:

    STATUS_SUCCESS if all descriptors are found, read, and are valid.

    STATUS_DISK_CORRUPT_ERROR if corrupt/bad descriptors are found (may be raised)

--*/

{
    PNSR_FSD FSD = NULL;
    ULONGLONG Offset;
    ULONG Lbn, Len;

    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    //
    //  Check inputs
    //

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT( *FileSetDescriptor == NULL );

    DebugTrace(( +1, Dbg,
                 "UdfFindFileSetDescriptor, Vcb %08x, LongAd %08x %x/%08x +%08x (type %x)\n",
                 Vcb,
                 LongAd,
                 LongAd->Start.Partition,
                 LongAd->Start.Lbn,
                 LongAd->Length.Length,
                 LongAd->Length.Type ));
    
    //
    //  If the extent we begin from is not a whole number of recorded logical blocks,
    //  we can't continue.
    //

    if (LongAd->Length.Length == 0 ||
        LongAd->Length.Type != NSRLENGTH_TYPE_RECORDED ||
        BlockOffset( Vcb, LongAd->Length.Length )) {

        DebugTrace(( +0, Dbg,
                     "UdfFindFileSetDescriptor, bad longad length\n" ));
        DebugTrace(( -1, Dbg,
                     "UdfFindFileSetDescriptor ->  STATUS_DISK_CORRUPT_ERROR\n" ));
        
        return STATUS_DISK_CORRUPT_ERROR;
    }

    //
    //  Use a try-finally for cleanup
    //

    try {

        try {
            
            for ( //
                  //  Home ourselves in the search and make a pass through the sequence.
                  //

                  Len = LongAd->Length.Length,
                  Lbn = LongAd->Start.Lbn;

                  Len;

                  //
                  //  Advance to the next descriptor offset in the sequence.
                  //

                  Len -= BlockSize( Vcb ),
                  Lbn++) {

                //
                //  Allocate a buffer to read fileset descriptors.
                //

                if (FSD == NULL) {

                    FSD = FsRtlAllocatePoolWithTag( UdfNonPagedPool,
                                                    UdfRawBufferSize( Vcb, sizeof(NSR_FSD) ),
                                                    TAG_NSR_FSD );
                }

                //
                //  Lookup the physical offset for this block.  We could be mapping
                //  through a VAT here so we can't just assume that all the
                //  blocks in the extent are physically contiguous.  The FSD seems to 
                //  be the exception here - there's nothing that says it must be in
                //  physical partition,  and it can have a terminator, => 2 blocks
                //  minumum.  There is no single block virtual extent limitation in UDF 1.50.
                //
                
                Offset = LlBytesFromSectors( Vcb, UdfLookupPsnOfExtent( IrpContext,
                                                                        Vcb,
                                                                        LongAd->Start.Partition,
                                                                        Lbn,
                                                                        BlockSize( Vcb)));

                Status = UdfReadSectors( IrpContext,
                                         Offset,
                                         UdfRawReadSize( Vcb, sizeof(NSR_FSD) ),
                                         TRUE,
                                         FSD,
                                         Vcb->TargetDeviceObject );

                if (!NT_SUCCESS( Status ) ||
                    FSD->Destag.Ident == DESTAG_ID_NOTSPEC) {

                    //
                    //  These are both an excellent sign that this is an unrecorded sector, which
                    //  is defined to terminate the sequence. (3/8.4.2)
                    //

                    break;
                }

                if ((FSD->Destag.Ident != DESTAG_ID_NSR_FSD &&
                     FSD->Destag.Ident != DESTAG_ID_NSR_TERM) ||

                    !UdfVerifyDescriptor( IrpContext,
                                          &FSD->Destag,
                                          FSD->Destag.Ident,
                                          sizeof(NSR_FSD),
                                          Lbn,
                                          TRUE)) {

                    //
                    //  If we spot an illegal descriptor type in the stream, there is no reasonable
                    //  way to guess that we can continue (the disc may be trash beyond this point).
                    //  Clearly, we also cannot trust the next extent pointed to by a corrupt
                    //  descriptor.
                    //

                    try_leave( Status = STATUS_DISK_CORRUPT_ERROR );
                }

                if (FSD->Destag.Ident == DESTAG_ID_NSR_TERM) {

                    //
                    //  This is a way to terminate the sequence.
                    //

                    break;
                }

                //
                //  Reset the pointers to the possible next extent
                //

                LongAd = &FSD->NextExtent;

                if (LongAd->Length.Length) {

                    //
                    //  A fileset descriptor containing a nonzero next extent pointer also
                    //  terminates this extent of the FSD sequence. (4/8.3.1)
                    //
                    //  If the extent referred to is not fully recorded, this will
                    //  terminate the sequence.
                    //

                    if (LongAd->Length.Type != NSRLENGTH_TYPE_RECORDED) {

                        break;
                    }

                    Len = LongAd->Length.Length;

                    //
                    //  The extent must be a multiple of a block size.
                    //

                    if (BlockOffset( Vcb, Len )) {

                        DebugTrace(( +0, Dbg,
                                     "UdfFindFileSetDescriptor, interior extent not blocksize in length\n" ));
                        try_leave ( Status = STATUS_DISK_CORRUPT_ERROR );
                    }

                    Lbn = LongAd->Start.Lbn;

                    //
                    //  Note that we must correct the values to take into account
                    //  the changes that will be made next time through the for loop.
                    //

                    Len += BlockSize( Vcb );
                    Lbn -= 1;
                }

                UdfStoreFileSetDescriptorIfPrevailing( FileSetDescriptor, &FSD );
            }
        
        } 
        finally {

            DebugUnwind( "UdfFindFileSetDescriptor");
            
            //
            //  Free up the buffer space we may have allocated
            //

            UdfFreePool( &FSD );

        }
    
    } except( UdfExceptionFilter( IrpContext, GetExceptionInformation() )) {

        //
        //  Transmute raised apparent file corruption to disk corruption - we are not
        //  yet touching the visible filesystem.
        //

        Status = IrpContext->ExceptionStatus;
        
        DebugTrace(( +0, Dbg,
                     "UdfFindFileSetDescriptor, exception %08x thrown\n", Status ));

        if (Status == STATUS_FILE_CORRUPT_ERROR) {

            DebugTrace(( +0, Dbg,
                         "UdfFindFileSetDescriptor, translating file corrupt to disk corrupt\n" ));
            Status = STATUS_DISK_CORRUPT_ERROR;
        }
    }

    //
    //  Success is when we've really found something.  If we failed to find the
    //  descriptor, commute whatever intermediate status was involved and clean up.
    //

    if (*FileSetDescriptor == NULL) {
        
        Status = STATUS_UNRECOGNIZED_VOLUME;
    }

    if (!NT_SUCCESS( Status )) {

        UdfFreePool( FileSetDescriptor );
    }
    
    DebugTrace(( -1, Dbg,
                 "UdfFindFileSetDescriptor -> %08x\n", Status ));
    return Status;
}


//
//  Local support routine
//

NTSTATUS
UdfFindVolumeDescriptors (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PEXTENTAD Extent,
    IN OUT PPCB *Pcb,
    IN OUT PNSR_PVD *PrimaryVolumeDescriptor,
    IN OUT PNSR_LVOL *LogicalVolumeDescriptor
    )

/*++

Routine Description:

    This routine walks the indicated Volume Descriptor Sequence searching for the
    active descriptors for this volume and generates an initializing Pcb from the
    referenced partitions.  No updating of the Vcb occurs.

Arguments:

    Vcb - Vcb of volume to search

    Extent - Extent to search

    Pcb - Address of a caller's pointer to a Pcb

    PrimaryVolumeDescriptor - Address of caller's pointer to a PVD

    LogicalVolumeDescriptor - Address of caller's pointer to an LVD

Return Value:

    STATUS_SUCCESS if all descriptors are found, read, and are valid.

    STATUS_DISK_CORRUPT_ERROR if corrupt descriptors are found.

    STATUS_UNRECOGNIZED_VOLUME if noncompliant descriptors are found.
    
    Descriptors are only returned on success.

--*/

{
    PNSR_VD_GENERIC GenericVD = NULL;
    ULONGLONG Offset;
    ULONG Len;
    ULONG MaxSize;
    ULONG UnitSize = UdfRawReadSize( Vcb, sizeof(NSR_VD_GENERIC) );

    NTSTATUS Status = STATUS_SUCCESS;
    ULONG ThisPass = 1;
    ULONG MaxVdpExtents;
    
    PAGED_CODE();

    //
    //  Check the input parameters
    //

    ASSERT_IRP_CONTEXT( IrpContext);
    ASSERT_VCB( Vcb );
    ASSERT_OPTIONAL_PCB( *Pcb );

    DebugTrace(( +1, Dbg,
                 "UdfFindVolumeDescriptors, Vcb %08x, Extent %08x +%08x\n",
                 Vcb,
                 Extent->Lsn,
                 Extent->Len ));

    //
    //  If the extent we begin from is not at least the size of an aligned descriptor
    //  or is sized in base units other than aligned descriptors, we can't continue.
    //

    if (Extent->Len < UnitSize ||
        Extent->Len % UnitSize) {

        DebugTrace(( 0, Dbg,
                     "UdfFindVolumeDescriptors, Base extent length %08x is mismatched with read size %08x\n",
                     Extent->Len,
                     UnitSize ));

        DebugTrace(( -1, Dbg,
                     "UdfFindVolumeDescriptors -> STATUS_DISK_CORRUPT_ERROR\n" ));

        return STATUS_DISK_CORRUPT_ERROR;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        DebugTrace(( 0, Dbg,
                     "UdfFindVolumeDescriptors, starting pass 1, find LVD/PVD\n" ));

        //
        //  We will make at least one pass through the Volume Descriptor Sequence to find
        //  the prevailing versions of the two controlling descriptors - the PVD and LVD.
        //  In order to avoid picking up partition descriptors that aren't actually going
        //  to be referenced by the LVD, we will pick them up in a second pass if we find
        //  a PVD and LVD that look reasonable and then stick them in a Pcb.
        //

        for (ThisPass = 1; ThisPass <= 2; ThisPass++) {

            MaxVdpExtents = 16;

            for ( //
                  //  Home ourselves in the search and make a pass through the sequence.
                  //

                  Offset = LlBytesFromSectors( Vcb, Extent->Lsn ),
                  Len = Extent->Len;

                  //
                  //  If we have reached the end of the extent's indicated valid
                  //  length, we are done. This usually will not happen.
                  //

                  Len;

                  //
                  //  Advance to the next descriptor offset in the sequence.
                  //

                  Offset += UnitSize,
                  Len -= UnitSize 
                )  {

                //
                //  Allocate a buffer to read generic volume descriptors.
                //

                if (GenericVD == NULL) {

                    GenericVD = (PNSR_VD_GENERIC) FsRtlAllocatePoolWithTag( UdfNonPagedPool,
                                                                            UdfRawBufferSize( Vcb, sizeof(NSR_VD_GENERIC) ),
                                                                            TAG_NSR_VDSD );
                }

                Status = UdfReadSectors( IrpContext,
                                         Offset,
                                         UnitSize,
                                         TRUE,
                                         GenericVD,
                                         Vcb->TargetDeviceObject );

                //
                //  Thise is a decent sign that this is an unrecorded sector and is
                //  defined to terminate the sequence.
                //

                if (!NT_SUCCESS( Status )) {

                    break;
                }

                //
                //  Calculate the maximum size we expect this descriptor to be.  For LVDs 
                //  the descriptor can be followed by upto 2 partition maps,  pushing it 
                //  over the 512 byte ECMA desc. limit which we were assuming was the max.
                //
                
                MaxSize = sizeof( NSR_VD_GENERIC);
                
                if (DESTAG_ID_NSR_LVOL == GenericVD->Destag.Ident)  {
                
                    MaxSize += 2 * sizeof( PARTMAP_UDF_GENERIC);

                    ASSERT( BlockSize( Vcb) >= 1024);
                }

                if (GenericVD->Destag.Ident > DESTAG_ID_MAXIMUM_PART3 ||

                    !UdfVerifyDescriptor( IrpContext,
                                          &GenericVD->Destag,
                                          GenericVD->Destag.Ident,
                                          MaxSize,
                                          (ULONG) SectorsFromLlBytes( Vcb, Offset ),
                                          TRUE)) {

                    //
                    //  If we spot an illegal descriptor type in the stream, there is no reasonable
                    //  way to guess that we can continue (the disc may be trash beyond this point).
                    //  Likewise, even if we have a single corrupt descriptor we cannot continue because
                    //  this may be corruption of a descriptor we may have otherwise required for operation
                    //  (i.e., one of the prevailing descriptors).
                    //

                    DebugTrace(( 0, Dbg,
                                 "UdfFindVolumeDescriptors, descriptor didn't verify\n" ));

                    try_leave( Status = STATUS_DISK_CORRUPT_ERROR );
                }

                if (GenericVD->Destag.Ident == DESTAG_ID_NSR_TERM) {

                    //
                    //  The Terminating Descriptor (3/10.9) is the usual way to stop a search.
                    //

                    break;
                }

                if (GenericVD->Destag.Ident == DESTAG_ID_NSR_VDP) {
                
                    //
                    //  Follow a Volume Desciptor Pointer (3/10.3) to the next extent of the sequence.
                    //  We will only follow a maximum of 16 extents,  to guard against loops.
                    //

                    if (0 == --MaxVdpExtents)  {
                    
                        try_leave( Status = STATUS_DISK_CORRUPT_ERROR );
                    }

                    //
                    //  Bias the values by UnitSize,  so that the next loop iteration will change them
                    //  to the correct values.
                    //

                    Offset = LlBytesFromSectors( Vcb, ((PNSR_VDP) GenericVD)->Next.Lsn ) - UnitSize;
                    Len = ((PNSR_VDP) GenericVD)->Next.Len;

                    //
                    //  We cannot do anything if the extent is invalid
                    //

                    if (Len < UnitSize ||
                        Len % UnitSize) {

                        DebugTrace(( 0, Dbg,
                                     "UdfFindVolumeDescriptors, following extent length %08x is mismatched with read size %08x\n",
                                     Extent->Len,
                                     UnitSize ));

                        try_leave( Status = STATUS_DISK_CORRUPT_ERROR );
                    }

                    Len += UnitSize;
                    continue;
                }

                DebugTrace(( 0, Dbg,
                             "UdfFindVolumeDescriptors, descriptor tag %08x\n",
                             GenericVD->Destag.Ident ));

                if (ThisPass == 1) {

                    //
                    //  Our first pass is to find prevailing LVD and PVD.
                    //

                    switch (GenericVD->Destag.Ident) {

                        case DESTAG_ID_NSR_PVD:

                            UdfStoreVolumeDescriptorIfPrevailing( (PNSR_VD_GENERIC *) PrimaryVolumeDescriptor,
                                                                  GenericVD );
                            break;

                        case DESTAG_ID_NSR_LVOL:

                            UdfStoreVolumeDescriptorIfPrevailing( (PNSR_VD_GENERIC *) LogicalVolumeDescriptor,
                                                                  GenericVD );
                            break;

                        default:

                            break;
                    }

                } else {

                    PNSR_PART PartitionDescriptor = (PNSR_PART) GenericVD;
                    USHORT ExpectedNsrVer;

                    //
                    //  Our second pass is to pick up all relevant NSR02/3 PD
                    //

                    if (PartitionDescriptor->Destag.Ident != DESTAG_ID_NSR_PART)  {
                    
                        continue;
                    }

                    //
                    //  Look at the NSR standard revision
                    //
                    
                    if (UdfEqualEntityId( &PartitionDescriptor->ContentsID, &UdfNSR02Identifier, NULL ))  {

                        ExpectedNsrVer = VsdIdentNSR02;
                    }
                    else if (UdfEqualEntityId( &PartitionDescriptor->ContentsID, &UdfNSR03Identifier, NULL ))  {
                    
                        ExpectedNsrVer = VsdIdentNSR03;
                    }
                    else {

                        //
                        //  Unknown NSR revision
                        //
                        
                        ExpectedNsrVer = VsdIdentBad;
                    }

                    //
                    //  Check that the NSR version in this PD matches what we found in the VRS earlier.
                    //
                    
                    if (ExpectedNsrVer != Vcb->NsrVersion)  {
                        
#ifdef EXPERIMENTAL_MOUNT_OPEN_R_MEDIA

                        //
                        //  If we didn't find a VRS (i.e. open CD/DVD-R media) then we ignore this, since
                        //  we didn't have a VRS to infer the NSR version from.  Just store what we
                        //  found here.
                        //
                        
                        if (Vcb->NsrVersion == UDF_NSR_NO_VRS_FOUND)  {
                            
                            Vcb->NsrVersion = ExpectedNsrVer;
                        }
                        else
#endif
                        {
                            DebugTrace(( 0, Dbg, "UdfFindVolumeDescriptors: NSR version in PartitionDescriptor (%d) != NSR found in VRS (%d)\n", 
                                         ExpectedNsrVer, Vcb->NsrVersion));

                            try_leave( Status = STATUS_UNRECOGNIZED_VOLUME );
                        }
                    }
                                        
                    UdfAddToPcb( *Pcb, (PNSR_PART) GenericVD );
                }
            } // inner descriptor loop.

            //
            //  Now that a pass through the VDS has been completed, analyze the results.
            //

            if (ThisPass == 1) {

                PNSR_PVD PVD;
                PNSR_LVOL LVD;
                USHORT MaxVerBasedOnNSR;

                //
                //  Reference the descriptors for ease of use
                //

                PVD = *PrimaryVolumeDescriptor;
                LVD = *LogicalVolumeDescriptor;

                //
                //  Check that the descriptors indicate a logical volume which appears to
                //  be a valid UDF volume.
                //

                if ((PVD == NULL &&
                     DebugTrace(( 0, Dbg,
                                  "UdfFindVolumeDescriptors, don't have a PVD\n" ))) ||
                    (LVD == NULL &&
                     DebugTrace(( 0, Dbg,
                                  "UdfFindVolumeDescriptors, don't have an LVD\n" ))))  {

                    try_leave( Status = STATUS_UNRECOGNIZED_VOLUME );
                }

                //
                //  Store away the UDF revision in the VCB for future reference,  and clamp the
                //  maximum acceptable revision based on the previously encountered NSR version.
                //
                
                Vcb->UdfRevision = ((PUDF_SUFFIX_DOMAIN)&(LVD->DomainID.Suffix))->UdfRevision;
                MaxVerBasedOnNSR = (VsdIdentNSR03 > Vcb->NsrVersion) ? UDF_VERSION_150 : UDF_VERSION_RECOGNIZED;
                
                DebugTrace((0,Dbg,"UdfFindVolumeDescriptors() Pass 1: Found LVD specifying DomainID %x\n", ((PUDF_SUFFIX_DOMAIN)&(LVD->DomainID.Suffix))->UdfRevision));
                
                if (
                    //
                    //  Now check the PVD
                    //

                    //
                    //  The Volume Set Sequence fields indicates how many volumes form
                    //  the volume set and what number this volume is in that sequence.
                    //  We are a level 2 implementation, meaning that the volumes we read
                    //  consist of a single volume. (3/11)
                    //

                    (PVD->VolSetSeq > 1 &&
                     DebugTrace(( 0, Dbg,
                                  "UdfFindVolumeDescriptors, PVD VolSetSeq %08x - not volume 1 of a volume set\n",
                                  PVD->VolSetSeq ))) ||
                    (((PVD->VolSetSeqMax > 1) && (PVD->Destag.CRC != UDF_SNOW_WHITE_PVD_CRC) &&
                      (PVD->Destag.CRC != UDF_SNOW_WHITE_PVD_CRC_VARIANT_2)) &&
                     DebugTrace(( 0, Dbg,
                                  "UdfFindVolumeDescriptors, PVD VolSetSeqMax %08x - volume in a non-unit volume set\n",
                                  PVD->VolSetSeqMax ))) ||

                    (PVD->CharSetList != UDF_CHARSETLIST &&
                     DebugTrace(( 0, Dbg,
                                  "UdfFindVolumeDescriptors, PVD CharSetList %08x != CS0 only\n",
                                  PVD->CharSetList ))) ||
                    (PVD->CharSetListMax != UDF_CHARSETLIST &&
                     DebugTrace(( 0, Dbg,
                                  "UdfFindVolumeDescriptors, PVD CharSetListMax %08x != CS0 only\n",
                                  PVD->CharSetListMax ))) ||
                    //
                    //  The two character sets must be UDF CS0.  CS0 is a "by convention"
                    //  character set in ISO 13346, which UDF specifies for our domain.
                    //

                    (!UdfEqualCharspec( &PVD->CharsetDesc, &UdfCS0Identifier, CHARSPEC_T_CS0 ) &&
                     DebugTrace(( 0, Dbg,
                                 "UdfFindVolumeDescriptors, PVD CharsetDesc != CS0 only\n" ))) ||
                    (!UdfEqualCharspec( &PVD->CharsetExplan, &UdfCS0Identifier, CHARSPEC_T_CS0 ) &&
                     DebugTrace(( 0, Dbg,
                                  "UdfFindVolumeDescriptors, PVD CharsetExplan != CS0 only\n" ))) ||

                    //
                    //  Now check the LVD
                    //

                    //
                    //  The LVD is a variant sized structure.  Check that the claimed size fits in a single
                    //  logical sector.  Although an LVD may legally exceed a single sector, we will never
                    //  want to deal with such a volume.
                    //

                    (ISONsrLvolSize( LVD ) > SectorSize( Vcb ) &&
                     DebugTrace(( 0, Dbg,
                                  "UdfFindVolumeDescriptors, LVD is bigger than a sector\n" ))) ||

                    //
                    //  The character set used in the LVD must be UDF CS0 as well.
                    //

                    (!UdfEqualCharspec( &LVD->Charset, &UdfCS0Identifier, CHARSPEC_T_CS0 ) &&
                     DebugTrace(( 0, Dbg,
                                 "UdfFindVolumeDescriptors, LVD Charset != CS0 only\n" ))) ||

                    //
                    //  The specified block size must equal the physical sector size.
                    //

                    (LVD->BlockSize != SectorSize( Vcb ) &&
                     DebugTrace(( 0, Dbg,
                                  "UdfFindVolumeDescriptors, LVD BlockSize %08x != SectorSize %08x\n" ))) ||

                    //
                    //  The domain must be within the version we read
                    //

                    (!UdfDomainIdentifierContained( &LVD->DomainID,
                                                    &UdfDomainIdentifier,
                                                    UDF_VERSION_MINIMUM,
                                                    MaxVerBasedOnNSR ) &&
                     DebugTrace(( 0, Dbg,
                                  "UdfFindVolumeDescriptors, domain ID indicates unreadable volume\n" ))) ||

                    //
                    //  Although we can handle any number of partitions, UDF only specifies
                    //  a single partition or special dual partition formats.
                    //

                    (LVD->MapTableCount > 2 &&
                     DebugTrace(( 0, Dbg,
                                  "UdfFindVolumeDescriptors, LVD MapTableCount %08x greater than allowed (2)\n",
                                  LVD->MapTableCount )))
                    ) {

                    DebugTrace(( 0, Dbg,
                                 "UdfFindVolumeDescriptors, ... so returning STATUS_UNRECOGNIZED_VOLUME\n" ));

                    try_leave( Status = STATUS_UNRECOGNIZED_VOLUME );
                }
                
                //
                //  Now that we have performed the simple field checks, build a Pcb.
                //

                Status = UdfInitializePcb( IrpContext, Vcb, Pcb, LVD );

                if (!NT_SUCCESS(Status)) {

                    DebugTrace(( 0, Dbg,
                                 "UdfFindVolumeDescriptors, Pcb intialization failed (!)\n" ));

                    try_leave( Status );
                }
            }

            //
            //  Go onto Pass 2 to find the Partition Descriptors
            //

            DebugTrace(( 0, Dbg,
                         "UdfFindVolumeDescriptors, starting pass 2, find associated PD\n" ));
        }

    } finally {

        DebugUnwind( "UdfFindVolumeDescriptors" );

        //
        //  Free up the buffer space we may have allocated
        //

        UdfFreePool( &GenericVD );
    }

    DebugTrace(( -1, Dbg,
                 "UdfFindVolumeDescriptors -> %08x\n", Status ));

    //
    //  Success is when we've really found something.  If we failed to find both
    //  descriptors, commute whatever intermediate status was involved and clean up.
    //

    if (*PrimaryVolumeDescriptor == NULL || *LogicalVolumeDescriptor == NULL) {
        
        Status = STATUS_UNRECOGNIZED_VOLUME;
    }

    if (!NT_SUCCESS( Status )) {
        
        UdfFreePool(PrimaryVolumeDescriptor);
        UdfFreePool(LogicalVolumeDescriptor);
    }
    
    return Status;
}


//
//  Local support routine
//

NTSTATUS
UdfFindAnchorVolumeDescriptor (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN OUT PNSR_ANCHOR *AnchorVolumeDescriptor
    )

/*++

Routine Description:

    This routine will find the Anchor Volume Descriptor for a piece of media

Arguments:

    Vcb - Vcb of volume to search

    AnchorVolumeDescriptor - Caller's pointer to an AVD

Return Value:

    Boolean TRUE if AVD is discovered, FALSE otherwise.

--*/

{
    ULONG ThisPass;
    ULONG ReadLsn;
    ULONG Lsn;
    BOOLEAN Found = FALSE;
    NTSTATUS Status;

    PAGED_CODE();

    //
    //  Check the input parameters
    //

    ASSERT_IRP_CONTEXT( IrpContext);
    ASSERT_VCB( Vcb );

    ASSERT(*AnchorVolumeDescriptor == NULL);

    DebugTrace(( +1, Dbg, "UdfFindAnchorVolumeDescriptors()\n"));

    //
    //  Discover the Anchor Volume Descriptor, which will point towards the
    //  Volume Set Descriptor Sequence.  The AVD may exist at sector 256 or
    //  in the last sector of the volume.
    //

    *AnchorVolumeDescriptor = (PNSR_ANCHOR) FsRtlAllocatePoolWithTag( UdfNonPagedPool,
                                                                      UdfRawBufferSize( Vcb, sizeof(NSR_ANCHOR) ),
                                                                      TAG_NSR_VDSD );


    //
    //  Search the three possible locations for an AVD to exist on the volume,
    //  plus check for the possibility of a method 2 fixup requirement.
    //

    for ( ThisPass = 0; ThisPass < 11; ThisPass++ ) {

        if (ThisPass == 0) {

            ReadLsn = Lsn = ANCHOR_SECTOR + Vcb->BoundS;

#ifdef EXPERIMENTAL_MOUNT_OPEN_R_MEDIA
        } 
        else if (ThisPass == 1) {

            //
            //  Open CD-R media typically only has a single AVDP at 512.  Only 
            //  consider this if we failed to find a VRS on the media.
            //

            if (Vcb->NsrVersion == UDF_NSR_NO_VRS_FOUND)  {
                
                ReadLsn = Lsn = 2*ANCHOR_SECTOR + Vcb->BoundS;
            }
            else {
                
                continue;
            }
#else
        } else if (ThisPass == 1) {

            continue;
#endif
        } else if (ThisPass == 2) {

            //
            //  It is so unlikely that we will get a disk that doesn't have
            //  an anchor at 256 that this is a pretty good indication we
            //  have a CD-RW here and the drive is method 2 goofy.  Take
            //  a shot.
            //

            ReadLsn = UdfMethod2TransformSector( Vcb, ANCHOR_SECTOR );
            Lsn = ANCHOR_SECTOR;
            
        } else if (ThisPass >= 3) {

            ULONG SubPass = (ThisPass > 6) ? (ThisPass - 4) : ThisPass;

            //
            //  Our remaining two chances depend on being able to determine
            //  the last recorded sector for the volume.  If we were unable
            //  to do this, stop.
            //
 
            if (!Vcb->BoundN) {

                break;
            }
            
            //
            //  Note that although we're only looking at 2 sectors (N, N-256),
            //  because of the fuzziness of N on CD media (can include runout
            //  of 2 sectors) and method 2 addressing bugs in some drives,  we
            //  potentially have to look at 8 locations... We work fowards to 
            //  try and avoid reading invalid sectors (which can take some time).
            //

            ReadLsn = Lsn = Vcb->BoundN - ( SubPass == 3? (ANCHOR_SECTOR + 2): // 3,7
                                          ( SubPass == 4? ANCHOR_SECTOR:       // 4,8
                                          ( SubPass == 5? 2 : 0 )));           // 5,9 6,10

            //
            //  Also try the method 2 transformed version of each address (pass 7..10)
            //  If we get this far,  it might take a while...
            //
            
            if (6 < ThisPass)  {
            
                ReadLsn = UdfMethod2TransformSector( Vcb, Lsn);
            }
        }

        DebugTrace(( 0, Dbg, "Pass: %d  Trying Lsn/ReadLsn %X / %X\n", ThisPass, Lsn, ReadLsn));
        
        //
        //  We may have more chances to succeed if failure occurs.
        //

        Status = UdfReadSectors( IrpContext,
                                 LlBytesFromSectors( Vcb, ReadLsn ),
                                 UdfRawReadSize( Vcb, sizeof(NSR_ANCHOR) ),
                                 TRUE,
                                 *AnchorVolumeDescriptor,
                                 Vcb->TargetDeviceObject );

        if ( NT_SUCCESS( Status ) && 
             UdfVerifyDescriptor( IrpContext,
                                  &(*AnchorVolumeDescriptor)->Destag,
                                  DESTAG_ID_NSR_ANCHOR,
                                  sizeof(NSR_ANCHOR),
                                  Lsn,
                                  TRUE)
           )  {
                
            //
            //  Got one!  Set the method 2 fixup appropriately.
            //

            if (ReadLsn != Lsn) {

                DebugTrace(( 0, Dbg, "************************************************\n"));
                DebugTrace(( 0, Dbg, "METHOD 2 FIXUPS ACTIVATED FOR Vcb @ %08x\n", Vcb ));
                DebugTrace(( 0, Dbg, "************************************************\n"));

                SetFlag( Vcb->VcbState, VCB_STATE_METHOD_2_FIXUP );
            
            } else {
                
                ClearFlag( Vcb->VcbState, VCB_STATE_METHOD_2_FIXUP );
            }
            
            Status = STATUS_SUCCESS;
            break;
        }
    }

    if (11 == ThisPass)  {
    
        Status = STATUS_UNRECOGNIZED_VOLUME;
    }
    
    DebugTrace(( -1, Dbg, "UdfFindAnchorVolumeDescriptors() -> %X\n",  Status));
    
    return Status;
}


//
//  Local support routine
//

BOOLEAN
UdfRecognizeVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN OUT PULONG BoundS,
    IN OUT PBOOLEAN Bridge,
    OUT PUSHORT NSRVerFound
    )

/*++

Routine Description:

    This routine walks the Volume Recognition Sequence to determine
    whether this volume contains an NSR02 (ISO 13346 Section 4) image.

Arguments:

    DeviceObject - device we are checking

    SectorSize - size of a physical sector on this device

    Bridge - will return whether there appear to be ISO 9660 structures
        on the media

    NSRVerFound - returns either VsdIdentNSR02 or VsdIdentNSR03 if successful

Return Value:

    Boolean TRUE if we found NSR02/3, FALSE otherwise.

--*/

{
    NTSTATUS Status;

    BOOLEAN FoundBEA;
    BOOLEAN FoundNSR;
    BOOLEAN Resolved;

    ULONG AssumedDescriptorSize = sizeof(VSD_GENERIC);
    
    USHORT ThisRecordType;

    PVSD_GENERIC VolumeStructureDescriptor;
    PVSD_GENERIC VolumeStructureDescriptorBuffer;

    ULONGLONG Offset;
    ULONGLONG StartOffset;

    PAGED_CODE();

    //
    //  Check the input parameters
    //

    ASSERT_IRP_CONTEXT( IrpContext);

    VolumeStructureDescriptorBuffer = (PVSD_GENERIC) FsRtlAllocatePoolWithTag( UdfNonPagedPool,
                                                                         UdfRawBufferSizeN( SectorSize,
                                                                                            sizeof(VSD_GENERIC) ),
                                                                         TAG_NSR_VSD );

    DebugTrace(( +1, Dbg,
                 "UdfRecognizeVolume, DevObj %08x SectorSize %08x\n",
                 DeviceObject,
                 SectorSize ));

    //
    //  Use try-finally to facilitate cleanup
    //

    try {

Retry:

        FoundBEA = 
        FoundNSR =
        Resolved = FALSE;

        StartOffset = 
        Offset = (SectorSize * (ULONGLONG)(*BoundS)) + VRA_BOUNDARY_LOCATION;

        while (!Resolved) {

            //
            //  It's possible that the sector size is > 2k which is the descriptor 
            //  size.  Only read if we've processed all 2k blocks in the prev. sector 
            //
            
            if (0 == (Offset & (SectorSize - 1)))  {

                VolumeStructureDescriptor = VolumeStructureDescriptorBuffer;
                
                Status = UdfReadSectors( IrpContext,
                                         Offset,
                                         UdfRawReadSizeN( SectorSize,
                                                          sizeof(VSD_GENERIC) ),
                                         TRUE,
                                         VolumeStructureDescriptor,
                                         DeviceObject );

                if (!NT_SUCCESS( Status )) {

                    break;
                }
            }
            
            //
            //  Now check the type of the descriptor. All ISO 13346 VSDs are
            //  of Type 0, 9660 PVDs are Type 1, 9660 SVDs are Type 2, and 9660
            //  terminating descriptors are Type 255.
            //

            if (VolumeStructureDescriptor->Type == 0) {

                //
                //  In order to properly recognize the volume, we must know all of the
                //  Structure identifiers in ISO 13346 so that we can terminate if a
                //  badly formatted (or, shockingly, non 13346) volume is presented to us.
                //

                ThisRecordType = (USHORT)UdfFindInParseTable( VsdIdentParseTable,
                                                              VolumeStructureDescriptor->Ident,
                                                              VSD_LENGTH_IDENT );
                switch ( ThisRecordType ) {
                
                    case VsdIdentBEA01:

                        //
                        //  Only one BEA may exist and its version must be 1 (2/9.2.3)
                        //

                        DebugTrace(( 0, Dbg, "UdfRecognizeVolume, got a BEA01\n" ));


                        if ((FoundBEA &&
                             DebugTrace(( 0, Dbg,
                                          "UdfRecognizeVolume, ... but it is a duplicate!\n" ))) ||

                            (VolumeStructureDescriptor->Version != 1 &&
                             DebugTrace(( 0, Dbg,
                                          "UdfRecognizeVolume, ... but it has a wacky version number %02x != 1!\n",
                                          VolumeStructureDescriptor->Version )))) {

                            Resolved = TRUE;
                            break;
                        }

                        FoundBEA = TRUE;
                        break;

                    case VsdIdentTEA01:

                        //
                        //  If we reach the TEA it must be the case that we don't recognize
                        //

                        DebugTrace(( 0, Dbg, "UdfRecognizeVolume, got a TEA01\n" ));
                        Resolved = TRUE;
                        break;

                    case VsdIdentNSR02:
                    case VsdIdentNSR03:

                        //
                        //  We recognize NSR02/3 version 1 embedded after a BEA (3/9.1.3).  For
                        //  simplicity we will not bother being a complete nitpick and check
                        //  for a bounding TEA, although we will be optimistic in the case where
                        //  we fail to match the version.
                        //

                        DebugTrace(( 0, Dbg, "UdfRecognizeVolume, got an NSR0%c\n", ((VsdIdentNSR02 == ThisRecordType) ? '2' : '3')));

                        if ((FoundBEA ||
                             !DebugTrace(( 0, Dbg, "UdfRecognizeVolume, ... but we haven't seen a BEA01 yet!\n" ))) &&

                            (VolumeStructureDescriptor->Version == 1 ||
                             !DebugTrace(( 0, Dbg, "UdfRecognizeVolume, ... but it has a wacky version number %02x != 1\n",
                                           VolumeStructureDescriptor->Version )))
                           )  {
                            
                            FoundNSR = Resolved = TRUE;
                            *NSRVerFound = ThisRecordType;       // Report the NSR version we found here
                            break;
                        }

                        break;

                    case VsdIdentCD001:
                    case VsdIdentCDW01:
                    case VsdIdentNSR01:
                    case VsdIdentCDW02:
                    case VsdIdentBOOT2:

                        DebugTrace(( 0, Dbg, "UdfRecognizeVolume, got a valid but uninteresting 13346 descriptor (%d)\n", ThisRecordType ));

                        //
                        //  Valid but uninteresting (to us) descriptors
                        //

                        break;

                    default:

                        DebugTrace(( 0, Dbg, "UdfRecognizeVolume, got an invalid 13346 descriptor (%d)\n", ThisRecordType ));

                        //
                        //  This probably was a false alert, but in any case there is nothing
                        //  on this volume for us.  Exception is if this media sector size
                        //  is >= 4k,  and this was the second descriptor.  We'll allow
                        //  a failure here,  and switch to reading in whole sector increments.
                        //

                        if ((Offset == (StartOffset + sizeof(VSD_GENERIC))) &&
                            (SectorSize > sizeof( VSD_GENERIC))) {

                            Offset -= AssumedDescriptorSize;
                            AssumedDescriptorSize = SectorSize;
                        }
                        else {
                        
                            Resolved = TRUE;
                        }
                        break;
                }

            } 
            else if (!FoundBEA && (VolumeStructureDescriptor->Type < 3 ||
                     VolumeStructureDescriptor->Type == 255)) {

                DebugTrace(( 0, Dbg, "UdfRecognizeVolume, got a 9660 descriptor\n" ));

                //
                //  Only HSG (CDROM) and 9660 (CD001) are possible, and they are only legal
                //  before the ISO 13346 BEA/TEA extent.  By design, an ISO 13346 VSD precisely
                //  overlaps a 9660 PVD/SVD in the appropriate fields.
                //
                //  Note that we aren't being strict about the structure of the 9660 descriptors
                //  since that really isn't very interesting.  We care more about the 13346.
                //
                //

                switch (UdfFindInParseTable( VsdIdentParseTable,
                                             VolumeStructureDescriptor->Ident,
                                             VSD_LENGTH_IDENT )) {
                    case VsdIdentCDROM:
                    case VsdIdentCD001:

                        DebugTrace(( 0, Dbg, "UdfRecognizeVolume, ... seems we have 9660 here\n" ));

                        //
                        //  Note to our caller that we seem to have ISO 9660 here
                        //

                        *Bridge = TRUE;

                        break;

                    default:

                        DebugTrace(( 0, Dbg, "UdfRecognizeVolume, ... but it looks wacky\n" ));

                        //
                        //  This probably was a false alert, but in any case there is nothing
                        //  on this volume for us.  Exception is if this media sector size
                        //  is >= 4k,  and this was the second descriptor.  We'll allow
                        //  a failure here,  and switch to reading in whole sector increments.
                        //

                        if ((Offset == (StartOffset + sizeof(VSD_GENERIC))) &&
                            (SectorSize > sizeof( VSD_GENERIC))) {

                            Offset -= AssumedDescriptorSize;
                            AssumedDescriptorSize = SectorSize;
                        }
                        else {
                        
                            Resolved = TRUE;
                        }
                        break;
                }

            } else {

                //
                //  Something else must be recorded on this volume.
                //

                DebugTrace(( 0, Dbg, "UdfRecognizeVolume, got an unrecognizeable descriptor, probably not 13346/9660\n" ));
                break;
            }

            Offset += AssumedDescriptorSize;
            VolumeStructureDescriptor = Add2Ptr( VolumeStructureDescriptor, 
                                                 sizeof( VSD_GENERIC), 
                                                 PVSD_GENERIC);
        }

        //
        //  If this was the first pass,  and we weren't looking at the start
        //  of the disc (i.e. later session),  and we didn't find anything,
        //  then try the first track in the first session.
        //

        if (!FoundNSR && (0 != *BoundS))  {

            DebugTrace(( 0, Dbg, "UdfRecognizeVolume, failed to find VRS in last session,  trying first\n" ));

            *BoundS = 0;

            goto Retry;
        }
    } 
    finally {

        DebugUnwind( "UdfRecognizeVolume" );

        //
        //  Free up our temporary buffer
        //

        UdfFreePool( &VolumeStructureDescriptorBuffer );

        if (AbnormalTermination()) {

            //
            //  Commute a status we raised for empty devices so that other filesystems
            //  can have a crack at this.
            //

            if (UdfIsRawDevice(IrpContext, IrpContext->ExceptionStatus)) {

                IrpContext->ExceptionStatus = STATUS_UNRECOGNIZED_VOLUME;
            }
        }
    }

    DebugTrace(( -1, Dbg, "UdfRecognizeVolume -> %u\n", FoundNSR ));

    return FoundNSR;
}


//
//  Local support routine
//

VOID
UdfScanForDismountedVcb (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine walks through the list of Vcb's looking for any which may
    now be deleted.  They may have been left on the list because there were
    outstanding references.

Arguments:

Return Value:

    None

--*/

{
    PVCB Vcb;
    PLIST_ENTRY Links;

    PAGED_CODE();

    //
    //  Check input.
    //

    ASSERT_IRP_CONTEXT( IrpContext );

    ASSERT_EXCLUSIVE_UDFDATA;

    //
    //  Walk through all of the Vcb's attached to the global data.
    //

    Links = UdfData.VcbQueue.Flink;

    while (Links != &UdfData.VcbQueue) {

        Vcb = CONTAINING_RECORD( Links, VCB, VcbLinks );

        //
        //  Move to the next link now since the current Vcb may be deleted.
        //

        Links = Links->Flink;

        //
        //  If dismount is already underway then check if this Vcb can
        //  go away.
        //

        if ((Vcb->VcbCondition == VcbDismountInProgress) ||
            (Vcb->VcbCondition == VcbInvalid) ||
            ((Vcb->VcbCondition == VcbNotMounted) && (Vcb->VcbReference <= Vcb->VcbResidualReference))) {

            UdfCheckForDismount( IrpContext, Vcb, FALSE );
        }
    }

    return;
}


#ifdef EXPERIMENTAL_MOUNT_OPEN_R_MEDIA

NTSTATUS
UdfCheckForOpenRMedia( 
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PULONG S,
    IN PULONG N
    )
/*++

Routine Description:

    Examines the media in the target device to determine whether or not it
    is C/DVD-R media in an open state (i.e. current open track is packet
    mode... etc) that could be UDF.  If so,  updates S and N.
    
Arguments:

    S - an address to store the start of the volume for the purposes of finding descriptors
    
    N - an address to store the end of the volume for the purposes of finding descriptors

Return Value:

    NTSTATUS from underlying drivers.

--*/
{
    CDB Cdb;

    NTSTATUS Status;
    
    UCHAR Buffer[256];
    ULONG BufferSize = sizeof( Buffer);
    ULONG FixedPacketSize;
    ULONG Feature;
    
    PTRACK_INFORMATION TrackInfo = (PTRACK_INFORMATION)Buffer;
    DISK_INFORMATION DiscInfo;

    //
    //  Issue a read disc information.
    //

    RtlZeroMemory( &Cdb, sizeof( Cdb));

    Cdb.READ_DISK_INFORMATION.OperationCode = SCSIOP_READ_DISK_INFORMATION;
    Cdb.READ_DISK_INFORMATION.AllocationLength[0] = (UCHAR)(BufferSize >> 8);
    Cdb.READ_DISK_INFORMATION.AllocationLength[1] = (UCHAR)(BufferSize & 0xff);

    Status = UdfSendSptCdb( TargetDeviceObject,
                            &Cdb, 
                            Buffer,
                            &BufferSize, 
                            TRUE, 
                            5, 
                            NULL,
                            0,
                            NULL,
                            NULL);

    if (!NT_SUCCESS(Status))  {

        //
        //  Wouldn't expect this to fail except on really old CD-ROM drives.
        //

        DebugTrace((0, Dbg, "READ_DISC_INFORMATION failed 0x%x\n", Status));
        return Status;
    }

    //
    //  Preserve the disc info.
    //

    RtlCopyMemory( &DiscInfo, Buffer, sizeof( DiscInfo));

    //
    //  Fail if disc state and last session/border aren't both incomplete.
    //

    if (!(DiscInfo.LastSessionStatus == 1) &&
         (DiscInfo.DiskStatus == 1))  {

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    //  Read track information for the last track on the media. 
    //

    RtlZeroMemory( &Cdb, sizeof( Cdb));
    BufferSize = sizeof( Buffer);

    Cdb.READ_TRACK_INFORMATION.OperationCode = SCSIOP_READ_TRACK_INFORMATION;
    Cdb.READ_TRACK_INFORMATION.AllocationLength[0] = (UCHAR)(BufferSize >> 8); 
    Cdb.READ_TRACK_INFORMATION.AllocationLength[1] = (UCHAR)(BufferSize & 0xff); 
    Cdb.READ_TRACK_INFORMATION.Track = 1;               // blockaddress field => track/rzone number
    Cdb.READ_TRACK_INFORMATION.BlockAddress[3] = 0xff;  // = invisible / open track
        
    Status = UdfSendSptCdb( TargetDeviceObject,
                            &Cdb, 
                            Buffer,
                            &BufferSize, 
                            TRUE, 
                            5, 
                            NULL,
                            0,
                            NULL,
                            NULL);

    if (!NT_SUCCESS(Status))  {

        //
        //  Wouldn't expect this to fail except on really old CD-ROM drives.
        //

        DebugTrace((0, Dbg, "READ_TRACK_INFORMATION failed 0x%x\n", Status));
        return Status;
    }

    //
    //  Check that the last track is...
    //  - variable packet mode
    //  - not reserved / damaged / FP / blank and that either the NWA or LRA is valid.
    //

    if (TrackInfo->Damage || TrackInfo->FP || TrackInfo->Blank || !TrackInfo->Packet ||
        TrackInfo->RT || !(TrackInfo->NWA_V || (TrackInfo->Reserved3 & 1)))  {

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    //  If the last recorded block address is valid,  use that.
    //
    
    if (TrackInfo->Reserved3 & 1)  {

        SwapCopyUchar4( N, TrackInfo->FixedPacketSize + 8);
    }
    else {

        //
        //  Pull out the NWA.
        //

        SwapCopyUchar4( N, TrackInfo->NextWritableAddress);

        //
        //  Skip back past the runout blocks.  We expect that DVD-R drives
        //  will return the LRA,  so we assume CD-R here (7 blocks runout).
        //
        
        *N -= 8;
    }       

    //
    //  Set S to zero,  since we expect an AVDP at sector 512.
    //
    
    *S = 0;

    DebugTrace(( 0, Dbg, "UdfCheckForOpenRMedia -> N = 0x%x\n", *N));
        
    return STATUS_SUCCESS;
}

#endif


VOID
UdfDetermineVolumeBounding (
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PULONG S,
    IN PULONG N
    )

/*++

Routine Description:

    This routine will figure out where the base offset to discover volume descriptors
    lies and where the end of the disc is.  In the case where this is a non-CD media,
    this will tend to not to set the end bound since there is no uniform way to figure
    that piece of information out.
    
    The bounding information is used to start the hunt for CD-UDF (UDF 1.5) volumes.
    Anyone who puts CD-UDF on non-CD media deserves what they get.

Arguments:

    Vcb - the volume we are operating on
    
    S - an address to store the start of the volume for the purposes of finding descriptors
    
    N - an address to store the end of the volume for the purposes of finding descriptors

Return Value:

    None.
    
    Benign inability find the S/N information will result in 0/0 being returned.

--*/

{
    NTSTATUS Status;
    PCDROM_TOC CdromToc;
    PTRACK_DATA TrackData;
    CDROM_READ_TOC_EX Command;

    PAGED_CODE();

    //
    //  Check input.
    //

    ASSERT_IRP_CONTEXT( IrpContext );
        
    //
    //  Whack the inputs to the benign state.
    //
    
    *S = *N = 0;

    //
    //  Currently we do nothing here for non CD class devices.  This does
    //  mean that we can't mount (e.g.) WORM/RAM/MO media which has been
    //  recorded with sequential UDF and a VAT.
    //

    if (TargetDeviceObject->DeviceType != FILE_DEVICE_CD_ROM)  {

        DebugTrace(( 0, Dbg, "Not determining volume bounds / session info - not CDROM class device\n"));
        return;
    }
    
    //
    //  Allocate a buffer for the last session information.
    //

    CdromToc = FsRtlAllocatePoolWithTag( UdfPagedPool,
                                         sizeof( CDROM_TOC ),
                                         TAG_CDROM_TOC );

    RtlZeroMemory( CdromToc, sizeof( CDROM_TOC ));

    DebugTrace(( +1, Dbg,
               "UdfDetermineVolumeBounding, S %08x N %08x\n",
               S,
               N ));
    //
    //  Zero the command block.  This conveniently corresponds to an
    //  LBA mode READ_TOC request.
    //
    
    RtlZeroMemory( &Command, sizeof( Command));

    //
    //  Try to retrieve the CDROM last session information.
    //

    try {

        //
        //  Pull up the TOC.  The information for track AA (start of leadout)
        //  will get us the end of disc within some tolerance dependent on how
        //  much the device manufacturer paid attention to specifications.
        //  (-152, -150, -2, and 0 are possible offsets to the real end).
        //

        Status = UdfPerformDevIoCtrl( IrpContext,
                                      IOCTL_CDROM_READ_TOC_EX,
                                      TargetDeviceObject,
                                      &Command,
                                      sizeof( Command),
                                      CdromToc,
                                      sizeof( CDROM_TOC ),
                                      FALSE,
                                      TRUE,
                                      NULL );

        //
        //  If this failed,  try again with the MSF variant of the command
        //

        if (!NT_SUCCESS(Status) && 
            (STATUS_INSUFFICIENT_RESOURCES != Status))  {

            Command.Msf = 1;

            Status = UdfPerformDevIoCtrl( IrpContext,
                                          IOCTL_CDROM_READ_TOC_EX,
                                          TargetDeviceObject,
                                          &Command,
                                          sizeof( Command),
                                          CdromToc,
                                          sizeof( CDROM_TOC ),
                                          FALSE,
                                          TRUE,
                                          NULL );
        }

        //
        //  Raise an exception if there was an allocation failure.
        //

        if (Status == STATUS_INSUFFICIENT_RESOURCES) {

            DebugTrace(( 0, Dbg, "UdfDetermineVolumeBounding, READ_TOC failed INSUFFICIENT_RESOURCES\n" ));
            UdfRaiseStatus( IrpContext, Status );
        }

        //
        //  For other errors, just fail.  Perhaps this will turn out to be benign, in any case
        //  the mount will rapidly and correctly fail if it really was dependant on this work.
        //
        
        if (!NT_SUCCESS( Status )) {

#ifdef EXPERIMENTAL_MOUNT_OPEN_R_MEDIA

            //
            //  On 'open' CD/DVD-R media the TOC is not available.  So look for media
            //  in this state which might be packet written UDF+VAT.  This will only
            //  succeed on CD/DVD-R drives.  Regardless of success/failure here,  we're
            //  done.
            //

            Status = UdfCheckForOpenRMedia( IrpContext, TargetDeviceObject, S, N);
#endif
            try_leave( NOTHING );
        }

        //
        //  Sanity chck that the TOC is well-bounded.
        //
        
        if (CdromToc->LastTrack - CdromToc->FirstTrack >= MAXIMUM_NUMBER_TRACKS) {

            DebugTrace(( 0, Dbg, "UdfDetermineVolumeBounding, TOC malf (too many tracks)\n" ));
            try_leave( NOTHING );
        }

#if DBG
        {
            ULONG Track;
            
            for ( Track = 0;  Track <= (ULONG)(CdromToc->LastTrack - CdromToc->FirstTrack + 1); Track++)  {

                DebugTrace(( 0, Dbg, "  TOC[%02x]:  Num: %x  Ctrl/Adr: %x/%x  Addr: %08x\n", Track, CdromToc->TrackData[Track].TrackNumber, CdromToc->TrackData[Track].Control, CdromToc->TrackData[Track].Adr, *(PULONG)(CdromToc->TrackData[Track].Address)));
            }
        }
#endif

        TrackData = &CdromToc->TrackData[(CdromToc->LastTrack - CdromToc->FirstTrack + 1)];

        //
        //  Last track better have number 0xAA ...
        //
        
        if (TrackData->TrackNumber != 0xaa) {

            DebugTrace(( 0, Dbg, "UdfDetermineVolumeBounding, TOC malf (aa not last)\n" ));

            //
            //  Some drives do this wrong, apparently,  so we won't enforce it.
            //
            
            //  try_leave( NOTHING );
        }

        //
        //  Now, find the AA (leadout 'track') info 
        //

        if (Command.Msf)  {

            //  
            //  Convert MSF to a logical block address.  75 frames/sectors
            //  per second, 60 seconds per minute.  The MSF address is stored LSB (the F byte) high
            //  in the word.
            //
            //  NOTE: MSF is only capable of representing 256*(256+256*60)*75 = 0x11ce20 sectors.
            //  This is 2.3gb, much less than the size of DVD media, which will respond to CDROM_TOC.
            //  Caveat user.  And actually the maximum 'legal' value is 63/59/74.
            //

            *N = (TrackData->Address[3] + (TrackData->Address[2] + TrackData->Address[1] * 60) * 75) - 1;
            
            //
            //  We must bias back by 0/2/0 MSF since that is the defined location of sector 0.  This
            //  works out to 150 sectors.
            //

            if (*N <= 150) {

                *N = 0;
                try_leave( NOTHING );
            }

            *N -= 150;
        }
        else {

            //
            //  The non-MSF (LBA) request succeeded,  so just fix the endianness.
            //

            SwapCopyUchar4( N, &TrackData->Address);

            if (0 != *N)  {

                *N -= 1;
            }
        }

        //
        //  Seems that some DVD drives always return AA start 0x6dd39 (which is the max legally
        //  representable MSF value 99/59/74) to TOC queries,  even in LBA mode.  If this 
        //  is what we have for the leadout address,  then lets see what READ_CAPACITY says.
        //  We'll also issue read capacity if the address is > than this,  since we must
        //  be dealing with DVD or DDCD media,  so the drive must support the command and
        //  it should give a definitive answer.
        //

        if (0x6dd38 <= *N)  {

            PDISK_GEOMETRY_EX Geometry = (PVOID)CdromToc;
            ULONG Blocks;
        
            Status = UdfPerformDevIoCtrl( IrpContext,
                                          IOCTL_CDROM_GET_DRIVE_GEOMETRY_EX,
                                          TargetDeviceObject,
                                          NULL,
                                          0,
                                          CdromToc,
                                          sizeof( CDROM_TOC ),
                                          FALSE,
                                          TRUE,
                                          NULL );

            if (NT_SUCCESS( Status))  {

                Blocks = (ULONG)(Geometry->DiskSize.QuadPart / Geometry->Geometry.BytesPerSector) - 1;

                if (Blocks > *N)  {

                    DebugTrace((0, Dbg, "Using READ_CAPACITY media size of 0x%X in place of maxed out READ_TOC value\n", Blocks));

                    *N = Blocks;
                }
            }
            else {

                DebugTrace(( 0, Dbg, "GET_DRIVE_GEO failed,  %x\n", Status));
            }
        }

        //
        //  Query the last session information from the driver.  Not that this
        //  actually issues an LBA mode READ_TOC_EX and pulls the address from
        //  there.
        //

        Status = UdfPerformDevIoCtrl( IrpContext,
                                      IOCTL_CDROM_GET_LAST_SESSION,
                                      TargetDeviceObject,
                                      NULL,
                                      0,
                                      CdromToc,
                                      sizeof( CDROM_TOC ),
                                      FALSE,
                                      TRUE,
                                      NULL );
        //
        //  Raise an exception if there was an allocation failure.
        //

        if (Status == STATUS_INSUFFICIENT_RESOURCES) {

            DebugTrace(( 0, Dbg, "UdfDetermineVolumeBounding, GET_LAST_SESSION failed INSUFFICIENT_RESOURCES\n" ));
            UdfRaiseStatus( IrpContext, Status );
        }

        //
        //  Now, if we got anything interesting out of this try, return it.  If this                                                
        //  failed for any other reason, we don't really care - it just means that
        //  if this was CDUDF media, we're gonna fail to figure it out pretty quickly.
        //
        //  Life is tough.
        //

        if (NT_SUCCESS( Status ) &&
            CdromToc->FirstTrack != CdromToc->LastTrack) {

            //
            //  The 0 entry in TrackData tells us about the first track in the last 
            //  session as a logical block address.
            //

            SwapCopyUchar4( S, &CdromToc->TrackData[0].Address );

            //
            //  Save grief if the session info is messed up.
            //
            
            if (*N <= *S) {

                DebugTrace(( 0, Dbg, "UdfDetermineVolumeBounding, N (0x%x) before S (0x%x), whacking both back!\n", *N, *S ));
                *S = *N = 0;
            }
        }

        DebugTrace(( 0, Dbg, "UdfDetermineVolumeBounding, S 0x%08x, N (== AA start - 150) 0x%08x\n", *S, *N));

    } 
    finally {

        DebugUnwind( "UdfDetermineVolumeBounding" );
        
        if (CdromToc != NULL) {
            
            UdfFreePool( &CdromToc );
        }
    }

    DebugTrace(( -1, Dbg, "UdfDetermineVolumeBounding -> VOID\n" ));
}


//
//  Local support routine
//

VOID
UdfUpdateVolumeLabel (
    IN PIRP_CONTEXT IrpContext,
    IN PWCHAR VolumeLabel,
    IN OUT PUSHORT VolumeLabelLength,
    IN PUCHAR Dstring,
    IN UCHAR FieldLength
    )

/*++

Routine Description:

    This routine will retrieve an NT volume label from a logical volume descriptor.

Arguments:

    VolumeLabel - a volume label to fill in.

    VolumeLabelLength - returns the length of the returned volume label.

    Dstring - the dstring field containing the volume id.

    FieldLength - the length of the dstring field.

Return Value:

    None.

--*/

{
    BOOLEAN Result;

    PAGED_CODE();

    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );

    DebugTrace(( +1, Dbg,
                 "UdfUpdateVolumeLabel, Label %08x, Dstring %08x FieldLength %02x\n",
                 VolumeLabel,
                 Dstring,
                 FieldLength ));

    //
    //  Check that the dstring is usable as a volume identification.
    //

    Result = UdfCheckLegalCS0Dstring( IrpContext,
                                      Dstring,
                                      0,
                                      FieldLength,
                                      TRUE );


    //
    //  Update the label directly if the dstring is good.
    //

    if (Result) {

        UNICODE_STRING TemporaryUnicodeString;

        TemporaryUnicodeString.Buffer = VolumeLabel;
        TemporaryUnicodeString.MaximumLength = MAXIMUM_VOLUME_LABEL_LENGTH;
        TemporaryUnicodeString.Length = 0;

        UdfConvertCS0DstringToUnicode( IrpContext,
                                       Dstring,
                                       0,
                                       FieldLength,
                                       &TemporaryUnicodeString );

        //
        //  Now retrieve the name for return to the caller.
        //

        *VolumeLabelLength = TemporaryUnicodeString.Length;

        DebugTrace(( 0, Dbg,
                     "UdfUpdateVolumeLabel, Labeled as \"%wZ\"\n",
                     &TemporaryUnicodeString ));

    //
    //  Treat as label.
    //

    } else {

        *VolumeLabelLength = 0;

        DebugTrace(( 0, Dbg,
                     "UdfUpdateVolumeLabel, invalid label.\n" ));
    }

    DebugTrace(( -1, Dbg,
                 "UdfUpdateVolumeLabel -> VOID\n" ));
}


//
//  Local support routine
//

VOID
UdfUpdateVolumeSerialNumber (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PULONG VolumeSerialNumber,
    IN PNSR_FSD Fsd
    )

/*++

Routine Description:

    This routine will compute the volume serial number for a set of descriptors.

Arguments:

    VolumeSerialNumber - returns the volume serial number corresponding to these descriptors.

    Fsd - the fileset descriptor to examine.

Return Value:

    None.

--*/

{
    ULONG VsnLe;
    PAGED_CODE();

    //
    //  Check input.
    //

    ASSERT_IRP_CONTEXT( IrpContext );

    //
    //  The serial number is just off of the FSD. This matches Win9x.
    //

    VsnLe = UdfSerial32( (PCHAR) Fsd, sizeof( NSR_FSD ));
    SwapCopyUchar4( VolumeSerialNumber, &VsnLe );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\udfs\fspdisp.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    FspDisp.c

Abstract:

    This module implements the main dispatch procedure/thread for the Udfs
    Fsp

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]     23-Sep-1996

Revision History:

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_FSPDISP)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_FSPDISP)


VOID
UdfFspDispatch (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This is the main FSP thread routine that is executed to receive
    and dispatch IRP requests.  Each FSP thread begins its execution here.
    There is one thread created at system initialization time and subsequent
    threads created as needed.

Arguments:

    IrpContext - IrpContext for a request to process.

Return Value:

    None

--*/

{
    THREAD_CONTEXT ThreadContext;
    NTSTATUS Status;

    PIRP Irp = IrpContext->Irp;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PVOLUME_DEVICE_OBJECT VolDo = NULL;

    //
    //  If this request has an associated volume device object, remember it.
    //

    if (IrpSp->FileObject != NULL) {

        VolDo = CONTAINING_RECORD( IrpSp->DeviceObject,
                                   VOLUME_DEVICE_OBJECT,
                                   DeviceObject );
    }

    //
    //  Now case on the function code.  For each major function code,
    //  either call the appropriate worker routine.  This routine that
    //  we call is responsible for completing the IRP, and not us.
    //  That way the routine can complete the IRP and then continue
    //  post processing as required.  For example, a read can be
    //  satisfied right away and then read can be done.
    //
    //  We'll do all of the work within an exception handler that
    //  will be invoked if ever some underlying operation gets into
    //  trouble.
    //

    while (TRUE) {

        //
        //  Set all the flags indicating we are in the Fsp.
        //

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FSP_FLAGS );

        FsRtlEnterFileSystem();

        UdfSetThreadContext( IrpContext, &ThreadContext );

        while (TRUE) {

            try {

                //
                //  Reinitialize for the next try at completing this
                //  request.
                //

                Status =
                IrpContext->ExceptionStatus = STATUS_SUCCESS;

                //
                //  Initialize the Io status field in the Irp.
                //

                Irp->IoStatus.Status = STATUS_SUCCESS;
                Irp->IoStatus.Information = 0;

                //
                //  Case on the major irp code.
                //

                switch (IrpContext->MajorFunction) {

                    case IRP_MJ_CLEANUP :
                        
                        Status = UdfCommonCleanup( IrpContext, Irp );
                        break;
        
                    case IRP_MJ_CLOSE :

                        //
                        //  Closes should never be posted.
                        //
                        
                        ASSERT( FALSE );
                        break;

                    case IRP_MJ_CREATE :
                        
                        Status = UdfCommonCreate( IrpContext, Irp );
                        break;
        
                    case IRP_MJ_DEVICE_CONTROL :
    
                        Status = UdfCommonDevControl( IrpContext, Irp );
                        break;
    
                    case IRP_MJ_DIRECTORY_CONTROL :
    
                        Status = UdfCommonDirControl( IrpContext, Irp );
                        break;
    
                    case IRP_MJ_FILE_SYSTEM_CONTROL :
    
                        Status = UdfCommonFsControl( IrpContext, Irp );
                        break;
    
                    case IRP_MJ_LOCK_CONTROL :

                        Status = UdfCommonLockControl( IrpContext, Irp );
                        break;

                    case IRP_MJ_PNP :

                        ASSERT( FALSE );
                        Status = UdfCommonPnp( IrpContext, Irp );
                        break;

                    case IRP_MJ_QUERY_INFORMATION :

                        Status = UdfCommonQueryInfo( IrpContext, Irp );
                        break;
                
                    case IRP_MJ_QUERY_VOLUME_INFORMATION :

                        Status = UdfCommonQueryVolInfo( IrpContext, Irp );
                        break;
                
                    case IRP_MJ_READ :
    
                        Status = UdfCommonRead( IrpContext, Irp );
                        break;
    
                    case IRP_MJ_WRITE :
                    
                        Status = UdfCommonWrite( IrpContext, Irp );
                        break;
                        
                    case IRP_MJ_SET_INFORMATION :
                
                        Status = UdfCommonSetInfo( IrpContext, Irp );
                        break;
                
                    default :
    
                        Status = STATUS_INVALID_DEVICE_REQUEST;
                        UdfCompleteRequest( IrpContext, Irp, Status );
                }

            } except( UdfExceptionFilter( IrpContext, GetExceptionInformation() )) {

                Status = UdfProcessException( IrpContext, Irp, GetExceptionCode() );
            }

            //
            //  Break out of the loop if we didn't get CANT_WAIT.
            //

            if (Status != STATUS_CANT_WAIT) { break; }

            //
            //  We are retrying this request.  Cleanup the IrpContext for the retry.
            //

            SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_MORE_PROCESSING );
            UdfCleanupIrpContext( IrpContext, FALSE );
        }

        FsRtlExitFileSystem();

        //
        //  If there are any entries on this volume's overflow queue, service
        //  them.
        //

        if (VolDo != NULL) {

            KIRQL SavedIrql;
            PVOID Entry = NULL;

            //
            //  We have a volume device object so see if there is any work
            //  left to do in its overflow queue.
            //

            KeAcquireSpinLock( &VolDo->OverflowQueueSpinLock, &SavedIrql );

            if (VolDo->OverflowQueueCount > 0) {

                //
                //  There is overflow work to do in this volume so we'll
                //  decrement the Overflow count, dequeue the IRP, and release
                //  the Event
                //

                VolDo->OverflowQueueCount -= 1;

                Entry = RemoveHeadList( &VolDo->OverflowQueue );
            }

            KeReleaseSpinLock( &VolDo->OverflowQueueSpinLock, SavedIrql );

            //
            //  There wasn't an entry, break out of the loop and return to
            //  the Ex Worker thread.
            //

            if (Entry == NULL) { break; }

            //
            //  Extract the IrpContext , Irp, set wait to TRUE, and loop.
            //

            IrpContext = CONTAINING_RECORD( Entry,
                                            IRP_CONTEXT,
                                            WorkQueueItem.List );

            Irp = IrpContext->Irp;
            IrpSp = IoGetCurrentIrpStackLocation( Irp );

            continue;
        }

        break;
    }

    //
    //  Decrement the PostedRequestCount if there was a volume device object.
    //

    if (VolDo) {

        InterlockedDecrement( &VolDo->PostedRequestCount );
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\udfs\iso13346.h ===
/***    ISO13346.H - ISO 13346 File System Disk Format
 *
 *      Microsoft Confidential
 *      Copyright (c) 1996-2000 Microsoft Corporation
 *      All Rights Reserved
 *
 *      This file defines the ISO 13346 Data Structures.
 *
 *      The UDF file system uses these data structures to interpret the
 *      media's contents.
 *
 */

//
//  All 13346 structures are aligned on natural boundaries even though it will
//  not be obvious to the compiler.  Disable compiler smarts for the duration
//  of the ISO definitions.
//
//  As an example, the LONGAD definition is {ULONG {ULONG USHORT} UCHAR[6]} and
//  normal packing will pad out the internal NSRLBA, nevermind that the UCHAR
//  reserved field is doing exactly that.
//

#pragma pack(1)

/***    ISO 13346 Part 1: General
 *
 *
 */

/***    charspec - Character Set Specification (1/7.2.1)
 *
 */

typedef struct  CHARSPEC {
    UCHAR       Type;                   // Character Set Type (CHARSPEC_T_...)
    UCHAR       Info[63];               // Character Set Information
} CHARSPEC, *PCHARSPEC;

//  CHARSPEC_T_... - Values for charspec_Type Character Set Types (1/7.2.1.1)

#define CHARSPEC_T_CS0  0               // By Agreement
#define CHARSPEC_T_CS1  1               // Unicode (according to ISO 2022)
#define CHARSPEC_T_CS2  2               // 38 Glyphs
#define CHARSPEC_T_CS3  3               // 65 Glyphs
#define CHARSPEC_T_CS4  4               // 95 Glyphs
#define CHARSPEC_T_CS5  5               // 191 Glyphs
#define CHARSPEC_T_CS6  6               // Unicode or ISO 2022
#define CHARSPEC_T_CS7  7               // Unicode or ISO 2022
#define CHARSPEC_T_CS8  8               // 53 Glyphs

/***    timestamp - Timestamp Structure (1/7.3)
 *
 */

typedef struct  TIMESTAMP {
    SHORT       Zone:12;                // Time Zone (+-1440 minutes from CUT)
    USHORT      Type:4;                 // Timestamp Type (TIMESTAMP_T_...)
    USHORT      Year;                   // Year (1..9999)
    UCHAR       Month;                  // Month (1..12)
    UCHAR       Day;                    // Day (1..31)
    UCHAR       Hour;                   // Hour (0..23)
    UCHAR       Minute;                 // Minute (0..59)
    UCHAR       Second;                 // Second (0..59)
    UCHAR       CentiSecond;            // Centiseconds (0..99)
    UCHAR       Usec100;                // Hundreds of microseconds (0..99)
    UCHAR       Usec;                   // microseconds (0..99)
} TIMESTAMP, *PTIMESTAMP;

//  TIMESTAMP_T_... - Values for timestamp_Type (1/7.3.1)

#define TIMESTAMP_T_CUT         0       // Coordinated Universal Time
#define TIMESTAMP_T_LOCAL       1       // Local Time
#define TIMESTAMP_T_AGREEMENT   2       // Time format by agreement

//  TIMESTAMP_Z_... Values for timestamp_Zone

#define TIMESTAMP_Z_MIN         (-1440) // Minimum timezone offset (minutes)
#define TIMESTAMP_Z_MAX         ( 1440) // Maximum timezone offset (minutes)
#define TIMESTAMP_Z_NONE        (-2047) // No timezone in timestamp_Zone


/****   regid - Entity Identifier (1/7.4)
 *
 */

typedef struct  REGID {
    UCHAR       Flags;                  // Flags (REGID_F_...)
    UCHAR       Identifier[23];         // Identifier
    UCHAR       Suffix[8];              // Identifier Suffix
} REGID, *PREGID;

//  REGID_F_... - Definitions for regid_Flags bits

#define REGID_F_DIRTY           (0x01)  // Information Modified
#define REGID_F_PROTECTED       (0x02)  // Changes Locked Out

//  REGID_LENGTH_... - regid field lengths

#define REGID_LENGTH_IDENT      23      // Length of regid_Identifier (bytes)
#define REGID_LENGTH_SUFFIX     8       // Length of regid_Suffix (bytes)

//  REGID_ID_... - Values for regid_Identifier[0]

#define REGID_ID_ISO13346       (0x2B)  // regid_Identifier within ISO 13346
#define REGID_ID_NOTREGISTERED  (0x2D)  // regid_Identifier is not registered


/***    Various Structures from Parts 3 and 4 moved here for compilation.
 *
 */


/***    extentad - Extent Address Descriptor (3/7.1)
 *
 */

typedef struct  EXTENTAD {
    ULONG       Len;                    // Extent Length in Bytes
    ULONG       Lsn;                    // Extent Logical Sector Number
} EXTENTAD, *PEXTENTAD;


/***    nsr_lba - Logical Block Address (4/7.1) (lb_addr)
 *
 */

typedef struct  NSRLBA {
    ULONG       Lbn;                    // Logical Block Number
    USHORT      Partition;              // Partition Reference Number
} NSRLBA, *PNSRLBA;


/***    nsr_length - Format of a NSR allocation descriptor length field (4/14.14.1.1)
 *
 *
 */

typedef struct NSRLENGTH {
    ULONG       Length:30;
    ULONG       Type:2;
} NSRLENGTH, *PNSRLENGTH;

#define NSRLENGTH_TYPE_RECORDED         0
#define NSRLENGTH_TYPE_UNRECORDED       1
#define NSRLENGTH_TYPE_UNALLOCATED      2
#define NSRLENGTH_TYPE_CONTINUATION     3


/***    Short Allocation Descriptor (4/14.14.1)
 *
 *      Note that a SHORTAD precisely overlaps a LONGAD.  Use this by defining
 *      a generic allocation descriptor structure.
 */

typedef struct  SHORTAD {
    NSRLENGTH   Length;                 // Extent Length
    ULONG       Start;                  // Extent Logical Block Number
} SHORTAD, *PSHORTAD;

typedef SHORTAD AD_GENERIC, *PAD_GENERIC;


/***    Long Allocation Descriptor (4/14.14.2)
 *
 */

typedef struct  LONGAD {
    NSRLENGTH   Length;                 // Extent Length
    NSRLBA      Start;                  // Extent Location
    UCHAR       ImpUse[6];              // Implementation Use
} LONGAD, *PLONGAD;


/***    Extended Allocation Descriptor (4/14.14.3)
 *
 */

typedef struct  EXTAD {
    NSRLENGTH   ExtentLen;              // Extent Length
    NSRLENGTH   RecordedLen;            // Recorded Length
    ULONG       InfoLen;                // Information Length
    NSRLBA      Start;                  // Extent Location
    UCHAR       ImpUse[2];              // Implementation Use
} EXTAD, *PEXTAD;

/***    ISO 13346 Part 2: Volume and Boot Block Recognition
 *
 *
 */


/***    vsd_generic - Generic Volume Structure Descriptor (2/9.1)
 *
 */

typedef struct  VSD_GENERIC {
    UCHAR       Type;                   // Structure Type
    UCHAR       Ident[5];               // Standard Identifier
    UCHAR       Version;                // Standard Version
    UCHAR       Data[2041];             // Structure Data
} VSD_GENERIC, *PVSD_GENERIC;

//  VSD_LENGTH_... - vsd field lengths

#define VSD_LENGTH_IDENT        5       // Length of regid_Identifier (bytes)

//  VSD_IDENT_... - Values for vsd_generic_Ident

#define VSD_IDENT_BEA01     "BEA01"     // Begin Extended Area
#define VSD_IDENT_TEA01     "TEA01"     // Terminate Extended Area
#define VSD_IDENT_CDROM     "CDROM"     // High Sierra Group (pre-ISO 9660)
#define VSD_IDENT_CD001     "CD001"     // ISO 9660
#define VSD_IDENT_CDW01     "CDW01"     // ECMA 168
#define VSD_IDENT_CDW02     "CDW02"     // ISO 13490
#define VSD_IDENT_NSR01     "NSR01"     // ECMA 167
#define VSD_IDENT_NSR02     "NSR02"     // ISO 13346
#define VSD_IDENT_BOOT2     "BOOT2"     // Boot Descriptor
#define VSD_IDENT_NSR03     "NSR03"     // ECMA 167 3rd Edition

typedef enum _VSD_IDENT {
    VsdIdentBad = 0,
    VsdIdentBEA01,
    VsdIdentTEA01,
    VsdIdentCDROM,
    VsdIdentCD001,
    VsdIdentCDW01,
    VsdIdentCDW02,
    VsdIdentNSR01,
    VsdIdentNSR02,
    VsdIdentBOOT2,
    VsdIdentNSR03
} VSD_IDENT, *PVSD_IDENT;

/***    vsd_bea01 - Begin Extended Area Descriptor (2/9.2)
 *
 */

typedef struct  VSD_BEA01 {
    UCHAR       Type;                   // Structure Type
    UCHAR       Ident[5];               // Standard Identifier ('BEA01')
    UCHAR       Version;                // Standard Version
    UCHAR       Data[2041];             // Structure Data
} VSD_BEA01, *PVSD_BEA01;


/***    vsd_tea01 - Terminate Extended Area Descriptor (2/9.3)
 *
 */

typedef struct  VSD_TEA01 {
    UCHAR       Type;                   // Structure Type
    UCHAR       Ident[5];               // Standard Identifier ('TEA01')
    UCHAR       Version;                // Standard Version
    UCHAR       Data[2041];             // Structure Data
} VSD_TEA01, *PVSD_TEA01;


/***    vsd_boot2 - Boot Descriptor (2/9.4)
 *
 */

typedef struct  VSD_BOOT2 {
    UCHAR       Type;                   // Structure Type
    UCHAR       Ident[5];               // Standard Identifier ('BOOT2')
    UCHAR       Version;                // Standard Version
    UCHAR       Res8;                   // Reserved Zero
    REGID       Architecture;           // Architecture Type
    REGID       BootIdent;              // Boot Identifier
    ULONG       BootExt;                // Boot Extent Start
    ULONG       BootExtLen;             // Boot Extent Length
    ULONG       LoadAddr[2];            // Load Address
    ULONG       StartAddr[2];           // Start Address
    TIMESTAMP   Timestamp;              // Creation Time
    USHORT      Flags;                  // Flags (VSD_BOOT2_F_...)
    UCHAR       Res110[32];             // Reserved Zeros
    UCHAR       BootUse[1906];          // Boot Use
} VSD_BOOT2, *PVSD_BOOT2;

//  VSD_BOOT2_F_... - Definitions for vsd_boot2_Flags bits

#define VSD_BOOT2_F_ERASE   (0x0001)    // Ignore previous similar BOOT2 vsds

//
//  Aligning this byte offset to a sector boundary by rounding up will
//  yield the starting offset of the Volume Recognition Area (2/8.3)
//

#define VRA_BOUNDARY_LOCATION (32767 + 1)

/***    ISO 13346 Part 3: Volume Structure
 *
 *
 */

/***    destag - Descriptor Tag (3/7.1 and 4/7.2)
 *
 *      destag_Checksum = Byte sum of bytes 0-3 and 5-15 of destag.
 *
 *      destag_CRC = CRC (X**16 + X**12 + X**5 + 1)
 *
 */

typedef struct  DESTAG {
    USHORT      Ident;                  // Tag Identifier
    USHORT      Version;                // Descriptor Version
    UCHAR       Checksum;               // Tag Checksum
    UCHAR       Res5;                   // Reserved
    USHORT      Serial;                 // Tag Serial Number
    USHORT      CRC;                    // Descriptor CRC
    USHORT      CRCLen;                 // Descriptor CRC Length
    ULONG       Lbn;                    // Tag Location (Logical Block Number)
} DESTAG, *PDESTAG;

//  DESTAG_ID_... - Values for destag_Ident
//  Descriptor Tag Values from NSR Part 3 (3/7.2.1)

#define DESTAG_ID_NOTSPEC           0   // Format Not Specified
#define DESTAG_ID_NSR_PVD           1   // (3/10.1) Primary Volume Descriptor
#define DESTAG_ID_NSR_ANCHOR        2   // (3/10.2) Anchor Volume Desc Pointer
#define DESTAG_ID_NSR_VDP           3   // (3/10.3) Volume Descriptor Pointer
#define DESTAG_ID_NSR_IMPUSE        4   // (3/10.4) Implementation Use Vol Desc
#define DESTAG_ID_NSR_PART          5   // (3/10.5) Partition Descriptor
#define DESTAG_ID_NSR_LVOL          6   // (3/10.6) Logical Volume Descriptor
#define DESTAG_ID_NSR_UASD          7   // (3/10.8) Unallocated Space Desc
#define DESTAG_ID_NSR_TERM          8   // (3/10.9) Terminating Descriptor
#define DESTAG_ID_NSR_LVINTEG       9   // (3/10.10) Logical Vol Integrity Desc

#define DESTAG_ID_MINIMUM_PART3     1   // The lowest legal DESTAG in Part 3
#define DESTAG_ID_MAXIMUM_PART3     9   // The highest legal DESTAG in Part 3

//  DESTAG_ID_... - Values for destag_Ident, continued...
//  Descriptor Tag Values from NSR Part 4 (4/7.2.1)

#define DESTAG_ID_NSR_FSD           256 // (4/14.1) File Set Descriptor
#define DESTAG_ID_NSR_FID           257 // (4/14.4) File Identifier Descriptor
#define DESTAG_ID_NSR_ALLOC         258 // (4/14.5) Allocation Extent Desc
#define DESTAG_ID_NSR_ICBIND        259 // (4/14.7) ICB Indirect Entry
#define DESTAG_ID_NSR_ICBTRM        260 // (4/14.8) ICB Terminal Entry
#define DESTAG_ID_NSR_FILE          261 // (4/14.9) File Entry
#define DESTAG_ID_NSR_EA            262 // (4/14.10) Extended Attribute Header
#define DESTAG_ID_NSR_UASE          263 // (4/14.11) Unallocated Space Entry
#define DESTAG_ID_NSR_SBP           264 // (4/14.12) Space Bitmap Descriptor
#define DESTAG_ID_NSR_PINTEG        265 // (4/14.13) Partition Integrity
#define DESTAG_ID_NSR_EXT_FILE      266 // (4/14.17) Extended File Entry (ECMA167r3+)

#define DESTAG_ID_MINIMUM_PART4         256 // The lowest legal DESTAG in Part 4
#define DESTAG_ID_MAXIMUM_PART4         265 // The highest legal DESTAG in Part 4 (NSR02)
#define DESTAG_ID_MAXIMUM_PART4_NSR03   266 // The highest legal DESTAG in Part 4 (NSR03)

//  DESTAG_VER_... - Values for destag_Version (3/7.2.2)

#define DESTAG_VER_NSR02          2   // Current Descriptor Tag Version
#define DESTAG_VER_NSR03          3   // Current Descriptor Tag Version

//  DESTAG_SERIAL_... - Values for destag_Serial (3/7.2.5)

#define DESTAG_SERIAL_NONE          0   // No Serial Number specified


/***    Anchor Points (3/8.4.2.1)
 *
 */

#define ANCHOR_SECTOR   256


/***    vsd_nsr02 - NSR02/3 Volume Structure Descriptor (3/9.1)
 *
 */

typedef struct  VSD_NSR02 {
    UCHAR       Type;                   // Structure Type
    UCHAR       Ident[5];               // Standard Identifier ('NSR02' or 'NSR03')
    UCHAR       Version;                // Standard Version
    UCHAR       Res7;                   // Reserved 0 Byte
    UCHAR       Data[2040];             // Structure Data
} VSD_NSR02, *PVSD_NSR02;


//  Values for vsd_nsr02_Type

#define VSD_NSR02_TYPE_0        0       // Reserved 0

//  Values for vsd_nsr02_Version

#define VSD_NSR02_VER           1       // Standard Version 1


/***    nsr_vd_generic - Generic Volume Descriptor of 512 bytes
 *
 */

typedef struct  NSR_VD_GENERIC {
    DESTAG      Destag;                 // Descriptor Tag
    ULONG       Sequence;               // Volume Descriptor Sequence Number
    UCHAR       Data20[492];            // Descriptor Data
} NSR_VD_GENERIC, *PNSR_VD_GENERIC;


/***    nsr_pvd - NSR Primary Volume Descriptor (3/10.1)
 *
 *      nsr_pvd_destag.destag_Ident = DESTAG_ID_NSR_PVD
 *
 */

typedef struct  NSR_PVD {
    DESTAG      Destag;                 // Descriptor Tag (NSR_PVD)
    ULONG       VolDescSeqNum;          // Volume Descriptor Sequence Number
    ULONG       Number;                 // Primary Volume Descriptor Number
    UCHAR       VolumeID[32];           // Volume Identifier
    USHORT      VolSetSeq;              // Volume Set Sequence Number
    USHORT      VolSetSeqMax;           // Maximum Volume Set Sequence Number
    USHORT      Level;                  // Interchange Level
    USHORT      LevelMax;               // Maximum Interchange Level
    ULONG       CharSetList;            // Character Set List (See 1/7.2.11)
    ULONG       CharSetListMax;         // Maximum Character Set List
    UCHAR       VolSetID[128];          // Volume Set Identifier
    CHARSPEC    CharsetDesc;            // Descriptor Character Set
    CHARSPEC    CharsetExplan;          // Explanatory Character Set
    EXTENTAD    Abstract;               // Volume Abstract Location
    EXTENTAD    Copyright;              // Volume Copyright Notice Location
    REGID       Application;            // Application Identifier
    TIMESTAMP   RecordTime;             // Recording Time
    REGID       ImpUseID;               // Implementation Identifier
    UCHAR       ImpUse[64];             // Implementation Use
    ULONG       Predecessor;            // Predecessor Vol Desc Seq Location
    USHORT      Flags;                  // Flags
    UCHAR       Res490[22];             // Reserved Zeros
} NSR_PVD, *PNSR_PVD;

//  NSRPVD_F_... - Definitions for nsr_pvd_Flags

#define NSRPVD_F_COMMON_VOLID   (0x0001)// Volume ID is common across Vol Set


/***    nsr_anchor - Anchor Volume Descriptor Pointer (3/10.2)
 *
 *      nsr_anchor_destag.destag_Ident = DESTAG_ID_NSR_ANCHOR
 *
 */

typedef struct  NSR_ANCHOR {
    DESTAG      Destag;                 // Descriptor Tag (NSR_ANCHOR)
    EXTENTAD    Main;                   // Main Vol Desc Sequence Location
    EXTENTAD    Reserve;                // Reserve Vol Desc Sequence Location
    UCHAR       Res32[480];             // Reserved Zeros
} NSR_ANCHOR, *PNSR_ANCHOR;


/***    nsr_vdp - Volume Descriptor Pointer (3/10.3)
 *
 *      nsr_vdp_destag.destag_Ident = DESTAG_ID_NSR_VDP
 *
 */

typedef struct  NSR_VDP {
    DESTAG      Destag;                 // Descriptor Tag (NSR_VDP)
    ULONG       VolDescSeqNum;          // Vol Desc Sequence Number
    EXTENTAD    Next;                   // Next Vol Desc Sequence Location
    UCHAR       Res28[484];             // Reserved Zeros
} NSR_VDP, *PNSR_VDP;


/***    nsr_impuse - Implementation Use Volume Descriptor (3/10.4)
 *
 *      nsr_impuse_destag.destag_Ident = DESTAG_ID_NSR_IMPUSE
 *
 */

typedef struct  NSR_IMPUSE {
    DESTAG      Destag;                 // Descriptor Tag (NSR_IMPUSE)
    ULONG       VolDescSeqNum;          // Vol Desc Sequence Number
    REGID       ImpUseID;               // Implementation Identifier
    UCHAR       ImpUse[460];            // Implementation Use
} NSR_IMPUSE, *PNSR_IMPUSE;


/***    nsr_part - Partition Descriptor (3/10.5)
 *
 *      nsr_part_destag.destag_Ident = DESTAG_ID_NSR_PART
 *
 */

typedef struct  NSR_PART {
    DESTAG      Destag;                 // Descriptor Tag (NSR_PART)
    ULONG       VolDescSeqNum;          // Vol Desc Sequence Number
    USHORT      Flags;                  // Partition Flags (NSR_PART_F_...)
    USHORT      Number;                 // Partition Number
    REGID       ContentsID;             // Partition Contents ID
    UCHAR       ContentsUse[128];       // Partition Contents Use
    ULONG       AccessType;             // Access Type
    ULONG       Start;                  // Partition Starting Location
    ULONG       Length;                 // Partition Length (sector count)
    REGID       ImpUseID;               // Implementation Identifier
    UCHAR       ImpUse[128];            // Implementation Use
    UCHAR       Res356[156];            // Reserved Zeros
} NSR_PART, *PNSR_PART;


//  NSR_PART_F_... - Definitions for nsr_part_Flags

#define NSR_PART_F_ALLOCATION   (0x0001)    // Volume Space Allocated

//  Values for nsr_part_ContentsID.regid_Identifier

#define NSR_PART_CONTID_FDC01   "+FDC01"    // ISO 9293-1987
#define NSR_PART_CONTID_CD001   "+CD001"    // ISO 9660
#define NSR_PART_CONTID_CDW01   "+CDW01"    // ECMA 168
#define NSR_PART_CONTID_CDW02   "+CDW02"    // ISO 13490
#define NSR_PART_CONTID_NSR01   "+NSR01"    // ECMA 167
#define NSR_PART_CONTID_NSR02   "+NSR02"    // ISO 13346
#define NSR_PART_CONTID_NSR03   "+NSR03"    // ECMA 167 r3

typedef enum NSR_PART_CONTID {
    NsrPartContIdBad = 0,
    NsrPartContIdFDC01,
    NsrPartContIdCD001,
    NsrPartContIdCDW01,
    NsrPartContIdCDW02,
    NsrPartContIdNSR01,
    NsrPartContIdNSR02,
    NsrPartContIdNSR03    
} NSR_PART_CONTID, *PNSR_PART_CONTID;

//  Values for nsr_part_AccessType

#define NSR_PART_ACCESS_NOSPEC  0       // Partition Access Unspecified
#define NSR_PART_ACCESS_RO      1       // Read Only Access
#define NSR_PART_ACCESS_WO      2       // Write-Once Access
#define NSR_PART_ACCESS_RW_PRE  3       // Read/Write with preparation
#define NSR_PART_ACCESS_RW_OVER 4       // Read/Write, fully overwritable


/***    nsr_lvol - Logical Volume Descriptor (3/10.6)
 *
 *      nsr_lvol_destag.destag_Ident = DESTAG_ID_NSR_LVOL
 *
 *      The Logical Volume Contents Use field is specified here as a
 *      File Set Descriptor Sequence (FSD) address.  See (4/3.1).
 *
 */

typedef struct  NSR_LVOL {
    DESTAG      Destag;                 // Descriptor Tag (NSR_LVOL)
    ULONG       VolDescSeqNum;          // Vol Desc Sequence Number
    CHARSPEC    Charset;                // Descriptor Character Set
    UCHAR       VolumeID[128];          // Logical Volume ID
    ULONG       BlockSize;              // Logical Block Size (in bytes)
    REGID       DomainID;               // Domain Identifier
    LONGAD      FSD;                    // Logical Volume Contents Use
    ULONG       MapTableLength;         // Map Table Length (bytes)
    ULONG       MapTableCount;          // Map Table Partition Maps Count
    REGID       ImpUseID;               // Implementaion Identifier
    UCHAR       ImpUse[128];            // Implementation Use
    EXTENTAD    Integrity;              // Integrity Sequence Extent
    UCHAR       MapTable[0];            // Partition Map Table (variant!)

//  The true length of this structure may vary!

} NSR_LVOL, *PNSR_LVOL;

#define ISONsrLvolConstantSize (FIELD_OFFSET( NSR_LVOL, MapTable ))
#define ISONsrLvolSize( L ) (QuadAlign( ISONsrLvolConstantSize + (L)->MapTableLength ))

/***    partmap_generic - Generic Partition Map (3/10.7.1)
 *
 */

typedef struct  PARTMAP_GENERIC {
    UCHAR       Type;                   // Partition Map Type
    UCHAR       Length;                 // Partition Map Length
    UCHAR       Map[0];                 // Partion Mapping (variant!)

//  The true length of this structure may vary!

} PARTMAP_GENERIC, *PPARTMAP_GENERIC;

//  Values for partmap_g_Type

#define PARTMAP_TYPE_NOTSPEC        0   // Partition Map Format Not Specified
#define PARTMAP_TYPE_PHYSICAL       1   // Partition Map in Volume Set (Type 1)
#define PARTMAP_TYPE_PROXY          2   // Partition Map by identifier (Type 2)


/***    partmap_physical - Normal (Type 1) Partition Map (3/10.7.2)
 *
 *      A Normal Partion Map specifies a partition number on a volume
 *      within the same volume set.
 *
 */

typedef struct  PARTMAP_PHYSICAL {
    UCHAR       Type;                   // Partition Map Type = 1
    UCHAR       Length;                 // Partition Map Length = 6
    USHORT      VolSetSeq;              // Partition Volume Set Sequence Number
    USHORT      Partition;              // Partition Number
} PARTMAP_PHYSICAL, *PPARTMAP_PHYSICAL;


/***    partmap_proxy - Proxy (Type 2) Partition Map (3/10.7.3)
 *
 *      A Proxy Partition Map is commonly not interchangeable.
 *
 */

typedef struct  PARTMAP_PROXY {
    UCHAR       Type;                   // Partition Map Type = 2
    UCHAR       Length;                 // Partition Map Length = 64
    UCHAR       PartID[62];             // Partition Identifier (Proxy)
} PARTMAP_PROXY, *PPARTMAP_PROXY;


/***    nsr_uasd - Unallocated Space Descriptor (3/10.8)
 *
 *      nsr_uasd_destag.destag_Ident = DESTAG_ID_NSR_UASD
 *
 *      The true length of nsr_uasd_Extents is (nsr_uasd_ExtentCount * 8), and
 *      the last logical sector of nsr_uasd_Extents is zero padded.
 *
 */

typedef struct  NSR_UASD {
    DESTAG      Destag;                 // Descriptor Tag (NSR_UASD)
    ULONG       VolDescSeqNum;          // Vol Desc Sequence Number
    ULONG       ExtentCount;            // Number of Allocation Descriptors
    EXTENTAD    Extents[0];             // Allocation Descriptors (variant!)

//  The true length of this structure may vary!
//  The true length of nsr_uasd_Extents is (nsr_uasd_ExtentCount * 8) bytes.
//  The last logical sector of nsr_uasd_Extents is zero padded.

} NSR_UASD, *PNSR_UASD;


/***    nsr_term - Terminating Descriptor (3/10.9 and 4/14.2)
 *
 *      nsr_term_destag.destag_Ident = DESTAG_ID_NSR_TERM
 *
 */

typedef struct  NSR_TERM {
    DESTAG      Destag;                 // Descriptor Tag (NSR_TERM)
    UCHAR       Res16[496];             // Reserved Zeros
} NSR_TERM, *PNSR_TERM;


/***    nsr_lvhd - Logical Volume Header Descriptor (4/14.15)
 *
 *      This descriptor is found in the Logical Volume Content Use
 *      field of a Logical Volume Integrity Descriptor.
 *
 *      This definition is moved to here to avoid forward reference.
 */

typedef struct  NSR_LVHD {
    ULONG       UniqueID[2];            // Unique ID
    UCHAR       Res8[24];               // Reserved Zeros
} NSR_LVHD, *PNSR_LVHD;


/***    nsr_integ - Logical Volume Integrity Descriptor (3/10.10)
 *
 *      nsr_integ_destag.destag_Ident = DESTAG_ID_NSR_LVINTEG
 *
 *      WARNING: WARNING: WARNING: nsr_integ is a multi-variant structure!
 *
 *      The starting address of nsr_integ_Size is not acurrate.
 *      Compensate for this nsr_integ_Size problem by adding the value of
 *      (nsr_integ_PartitionCount-1) to the ULONG ARRAY INDEX.
 *
 *      The starting address of nsr_integ_ImpUse[0] is not accurate.
 *      Compensate for this nsr_integ_ImpUse problem by adding the value of
 *      ((nsr_integ_PartitionCount-1)<<3) to the UCHAR ARRAY INDEX.
 *
 *      This descriptor is padded with zero bytes to the end of the last
 *      logical sector it occupies.
 *
 *      The Logical Volume Contents Use field is specified here as a
 *      Logical Volume Header Descriptor.  See (4/3.1) second last point.
 */

typedef struct  NSR_INTEG {
    DESTAG      Destag;                 // Descriptor Tag (NSR_LVINTEG)
    TIMESTAMP   Time;                   // Recording Date
    ULONG       Type;                   // Integrity Type (INTEG_T_...)
    EXTENTAD    Next;                   // Next Integrity Extent
    NSR_LVHD    LVHD;                   // Logical Volume Contents Use
    ULONG       PartitionCount;         // Number of Partitions
    ULONG       ImpUseLength;           // Length of Implementation Use
    ULONG       Free[1];                // Free Space Table

//  nsr_integ_Free has a variant length = (4*nsr_integ_PartitionCount)

    ULONG       Size[1];                // Size Table

//  nsr_integ_Size has a variant starting offset due to nsr_integ_Free
//  nsr_integ_Size has a variant length = (4*nsr_integ_PartitionCount)

    UCHAR       ImpUse[0];              // Implementation Use

//  nsr_integ_ImpUse has a variant starting offset due to nsr_integ_Free and
//  nsr_integ_Size.
//  nsr_integ_ImpUse has a variant length = (nsr_integ_ImpUseLength)

} NSR_INTEG, *PNSR_INTEG;

// Values for nsr_integ_Type

#define NSR_INTEG_T_OPEN        0           // Open Integrity Descriptor
#define NSR_INTEG_T_CLOSE       1           // Close Integrity Descriptor


/***    ISO 13346 Part 4: File Structure
 *
 *      See DESTAG structure in Part 3 for definitions found in (4/7.2).
 *
 */


/***    nsr_fsd - File Set Descriptor (4/14.1)
 *
 *      nsr_fsd_destag.destag_Ident = DESTAG_ID_NSR_FSD
 */

typedef struct  NSR_FSD {
    DESTAG      Destag;                     // Descriptor Tag (NSR_LVOL)
    TIMESTAMP   Time;                       // Recording Time
    USHORT      Level;                      // Interchange Level
    USHORT      LevelMax;                   // Maximum Interchange Level
    ULONG       CharSetList;                // Character Set List (See 1/7.2.11)
    ULONG       CharSetListMax;             // Maximum Character Set List
    ULONG       FileSet;                    // File Set Number
    ULONG       FileSetDesc;                // File Set Descriptor Number
    CHARSPEC    CharspecVolID;              // Volume ID Character Set
    UCHAR       VolID[128];                 // Volume ID
    CHARSPEC    CharspecFileSet;            // File Set Character Set
    UCHAR       FileSetID[32];              // File Set ID
    UCHAR       Copyright[32];              // Copyright File Name
    UCHAR       Abstract[32];               // Abstract File Name
    LONGAD      IcbRoot;                    // Root Directory ICB Address
    REGID       DomainID;                   // Domain Identifier
    LONGAD      NextExtent;                 // Next FSD Extent
    
    LONGAD      StreamDirectoryICB;         // >= UDF 2.00 only.  System stream dir.
                                            // These bytes must be zero on discs 
                                            // comforming to earlier revisions.
    
    UCHAR       Res464[32];                 // Reserved Zeros
} NSR_FSD, *PNSR_FSD;


/***    nsr_part_h - Partition Header Descriptor (4/14.3)
 *
 *      No Descriptor Tag.
 *
 *      This descriptor is found in the nsr_part_ContentsUse field of
 *      an NSR02 Partition Descriptor.  See NSR_PART_CONTID_NSR02.
 *
 */

typedef struct  NSR_PART_H {
    SHORTAD     UASTable;                   // Unallocated Space Table
    SHORTAD     UASBitmap;                  // Unallocated Space Bitmap
    SHORTAD     IntegTable;                 // Integrity Table
    SHORTAD     FreedTable;                 // Freed Space Table
    SHORTAD     FreedBitmap;                // Freed Space Bitmap
    UCHAR       Res40[88];                  // Reserved Zeros
} NSR_PART_H, *PNSR_PART_H;


/***    nsr_fid - File Identifier Descriptor (4/14.4)
 *
 *      nsr_fid_destag.destag_Ident = DESTAG_ID_NSR_FID
 *
 *      WARNING: WARNING: WARNING: nsr_fid is a multi-variant structure!
 *
 *      The starting address of nsr_fid_FileID is not acurrate.
 *      Compensate for this nsr_fid_FileID problem by adding the value of
 *      (nsr_fid_ImpUseLen-1) to the UCHAR ARRAY INDEX.
 *
 *      The starting address of nsr_fid_Padding is not acurrate.
 *      Compensate for this nsr_fid_Padding problem by adding the value of
 *      (nsr_fid_ImpUseLen+nsr_fid_FileIDLen-2) to the UCHAR ARRAY INDEX.
 *
 *      The true total size of nsr_fid_s is
 *          ((38 + nsr_fid_FileIDLen + nsr_fid_ImpUseLen) + 3) & ~3)
 *
 */

typedef struct  NSR_FID {
    DESTAG      Destag;                     // Descriptor Tag (NSR_FID)
    USHORT      Version;                    // File Version Number
    UCHAR       Flags;                      // File Flags (NSR_FID_F_...)
    UCHAR       FileIDLen;                  // File ID Length
    LONGAD      Icb;                        // ICB (long) Address
    USHORT      ImpUseLen;                  // Implementation Use Length

    UCHAR       ImpUse[1];                  // Implementation Use Area

//  nsr_fid_ImpUse has a variant length = nsr_fid_ImpUseLen

    UCHAR       FileID[1];                  // File Identifier

//  nsr_fid_FileID has a variant starting offset due to nsr_fid_ImpUse
//  nsr_fid_FileID has a variant length = nsr_fid_FileIDLen

    UCHAR       Padding[1];                 // Padding

//  nsr_fid_Paddinghas a variant starting offset due to nsr_fid_ImpUse and
//  nsr_fid_FileID
//  nsr_fid_Padding has a variant length. Round up to the next ULONG boundary.

} NSR_FID, *PNSR_FID;

#define ISONsrFidConstantSize (ULONG)(FIELD_OFFSET( NSR_FID, ImpUse ))
#define ISONsrFidSize( F ) (LongAlign( ISONsrFidConstantSize + (F)->FileIDLen + (F)->ImpUseLen ))

//  NSR_FID_F_... - Definitions for nsr_fid_Flags (Characteristics, 4/14.4.3)

#define NSR_FID_F_HIDDEN        (0x01)  // Hidden Bit
#define NSR_FID_F_DIRECTORY     (0x02)  // Directory Bit
#define NSR_FID_F_DELETED       (0x04)  // Deleted Bit
#define NSR_FID_F_PARENT        (0x08)  // Parent Directory Bit
#define NSR_FID_F_META          (0x10)  // (ECMAr3) Indicates impl. use
                                        // metadata stream.

#define NSR_FID_OFFSET_FILEID   38      // Field Offset of nsr_fid_FileID[];


/***    nsr_alloc - Allocation Extent Descriptor (4/14.5)
 *
 *      nsr_alloc_destag.destag_Ident = DESTAG_ID_NSR_ALLOC
 *
 *      This descriptor is immediately followed by AllocLen bytes
 *      of allocation descriptors, which is not part of this
 *      descriptor (so CRC calculation doesn't include it).
 *
 */

typedef struct  NSR_ALLOC {
    DESTAG      Destag;                 // Descriptor Tag (NSR_ALLOC)
    ULONG       Prev;                   // Previous Allocation Descriptor
    ULONG       AllocLen;               // Length of Allocation Descriptors
} NSR_ALLOC, *PNSR_ALLOC;


/***    icbtag - Information Control Block Tag (4/14.6)
 *
 *      An ICBTAG is commonly preceeded by a Descriptor Tag (DESTAG).
 *
 */

typedef struct  ICBTAG {
    ULONG       PriorDirectCount;// Prior Direct Entry Count
    USHORT      StratType;       // Strategy Type (ICBTAG_STRAT_...)
    USHORT      StratParm;       // Strategy Parameter (2 bytes)
    USHORT      MaxEntries;      // Maximum Number of Entries in ICB
    UCHAR       Res10;           // Reserved Zero
    UCHAR       FileType;        // File Type (ICBTAG_FILE_T_...)
    NSRLBA      IcbParent;       // Parent ICB Location
    USHORT      Flags;           // ICB Flags (ICBTAG_F_...)
} ICBTAG, *PICBTAG;


//  ICBTAG_STRAT_T_... - ICB Strategy Types

#define ICBTAG_STRAT_NOTSPEC    0       // ICB Strategy Not Specified
#define ICBTAG_STRAT_TREE       1       // Strategy 1 (4/A.2) (Plain Tree)
#define ICBTAG_STRAT_MASTER     2       // Strategy 2 (4/A.3) (Master ICB)
#define ICBTAG_STRAT_BAL_TREE   3       // Strategy 3 (4/A.4) (Balanced Tree)
#define ICBTAG_STRAT_DIRECT     4       // Strategy 4 (4/A.5) (One Direct)

//  ICBTAG_FILE_T_... - Values for icbtag_FileType

#define ICBTAG_FILE_T_NOTSPEC    0      // Not Specified
#define ICBTAG_FILE_T_UASE       1      // Unallocated Space Entry
#define ICBTAG_FILE_T_PINTEG     2      // Partition Integrity Entry
#define ICBTAG_FILE_T_INDIRECT   3      // Indirect Entry
#define ICBTAG_FILE_T_DIRECTORY  4      // Directory
#define ICBTAG_FILE_T_FILE       5      // Ordinary File
#define ICBTAG_FILE_T_BLOCK_DEV  6      // Block Special Device
#define ICBTAG_FILE_T_CHAR_DEV   7      // Character Special Device
#define ICBTAG_FILE_T_XA         8      // Extended Attributes
#define ICBTAG_FILE_T_FIFO       9      // FIFO file
#define ICBTAG_FILE_T_C_ISSOCK  10      // Socket
#define ICBTAG_FILE_T_TERMINAL  11      // Terminal Entry
#define ICBTAG_FILE_T_PATHLINK  12      // Symbolic Link with a pathname

//  ICBTAG_F_... - Values for icbtag_Flags

#define ICBTAG_F_ALLOC_MASK     (0x0007)// Mask for Allocation Descriptor Info
#define ICBTAG_F_ALLOC_SHORT          0 // Short Allocation Descriptors Used
#define ICBTAG_F_ALLOC_LONG           1 // Long Allocation Descriptors Used
#define ICBTAG_F_ALLOC_EXTENDED       2 // Extended Allocation Descriptors Used
#define ICBTAG_F_ALLOC_IMMEDIATE      3 // File Data Recorded Immediately

#define ISOAllocationDescriptorSize(T) ( (T) == ICBTAG_F_ALLOC_SHORT ? sizeof(SHORTAD) : \
                                         (T) == ICBTAG_F_ALLOC_LONG ? sizeof(LONGAD) :   \
                                         sizeof(EXTAD) )

#define ICBTAG_F_SORTED         (0x0008)// Directory is Sorted (4/8.6.1)
#define ICBTAG_F_NO_RELOCATE    (0x0010)// Data is not relocateable
#define ICBTAG_F_ARCHIVE        (0x0020)// Archive Bit
#define ICBTAG_F_SETUID         (0x0040)// S_ISUID Bit
#define ICBTAG_F_SETGID         (0x0080)// S_ISGID Bit
#define ICBTAG_F_STICKY         (0x0100)// C_ISVTX Bit
#define ICBTAG_F_CONTIGUOUS     (0x0200)// File Data is Contiguous
#define ICBTAG_F_SYSTEM         (0x0400)// System Bit
#define ICBTAG_F_TRANSFORMED    (0x0800)// Data Transformed
#define ICBTAG_F_MULTIVERSIONS  (0x1000)// Multi-version Files in Directory


/***    icbind - Indirect ICB Entry (4/14.7)
 *
 */

typedef struct  ICBIND {
    DESTAG      Destag;                 // Descriptor Tag (ID_NSR_ICBIND)
    ICBTAG      Icbtag;                 // ICB Tag (ICBTAG_FILE_T_INDIRECT)
    LONGAD      Icb;                    // ICB Address
} ICBIND, *PICBIND;


/***    icbtrm - Terminal ICB Entry (4/14.8)
 *
 */

typedef struct  ICBTRM {
    DESTAG      Destag;                 // Descriptor Tag (ID_NSR_ICBTRM)
    ICBTAG      Icbtag;                 // ICB Tag (ICBTAG_FILE_T_TERMINAL)
} ICBTRM, *PICBTRM;


/***    icbfile - File ICB Entry (4/14.9)
 *
 *      WARNING: WARNING: WARNING: icbfile is a multi-variant structure!
 *
 *      The starting address of icbfile_Allocs is not acurrate.
 *      Compensate for this icbfile_Allocs problem by adding the value of
 *      (icbfile_XALength-1) to the UCHAR ARRAY INDEX.
 *
 *      icbfile_XALength is a multiple of 4.
 *
 */

typedef struct  ICBFILE {
    DESTAG      Destag;                 // Descriptor Tag (ID_NSR_FILE)
    ICBTAG      Icbtag;                 // ICB Tag (ICBTAG_FILE_T_FILE)
    ULONG       UID;                    // User ID of file's owner
    ULONG       GID;                    // Group ID of file's owner
    ULONG       Permissions;            // File Permissions
    USHORT      LinkCount;              // File hard-link count
    UCHAR       RecordFormat;           // Record Format
    UCHAR       RecordDisplay;          // Record Display Attributes
    ULONG       RecordLength;           // Record Length
    ULONGLONG   InfoLength;             // Information Length (file size)
    ULONGLONG   BlocksRecorded;         // Logical Blocks Recorded
    TIMESTAMP   AccessTime;             // Last-Accessed Time
    TIMESTAMP   ModifyTime;             // Last-Modification Time
    TIMESTAMP   AttributeTime;          // Last-Attribute-Change Time
    ULONG       Checkpoint;             // File Checkpoint
    LONGAD      IcbEA;                  // Extended Attribute ICB
    REGID       ImpUseID;               // Implementation Use Identifier
    ULONGLONG   UniqueID;               // Unique ID
    ULONG       EALength;               // Length of Extended Attributes
    ULONG       AllocLength;            // Length of Allocation Descriptors
    UCHAR       EAs[1];                 // Extended Attributes

//  icbfile_EAs has a variant length = icbfile_EALength

    UCHAR       Allocs[0];              // Allocation Descriptors.

//  icbfile_Allocs has a variant starting offset due to icbfile_EAs.
//  icbfile_Allocs has a variant length = icbfile_AllocLen.

} ICBFILE, *PICBFILE;


/***    icbextfile - Extended File ICB Entry (4/14.17 ECMA167r3 and later)
 *
 *      WARNING: WARNING: WARNING: icbextfile is a multi-variant structure!
 *
 *      The starting address of icbfile_Allocs is not acurrate.
 *      Compensate for this icbfile_Allocs problem by adding the value of
 *      (icbfile_XALength-1) to the UCHAR ARRAY INDEX.
 *
 *      icbfile_XALength is a multiple of 4.
 *
 */

typedef struct  ICBEXTFILE {
    DESTAG      Destag;                 // Descriptor Tag (DESTAG_ID_NSR_EXT_FILE)
    ICBTAG      Icbtag;                 // ICB Tag (ICBTAG_FILE_T_FILE)
    ULONG       UID;                    // User ID of file's owner
    ULONG       GID;                    // Group ID of file's owner
    ULONG       Permissions;            // File Permissions
    USHORT      LinkCount;              // File hard-link count
    UCHAR       RecordFormat;           // Record Format
    UCHAR       RecordDisplay;          // Record Display Attributes
    ULONG       RecordLength;           // Record Length
    ULONGLONG   InfoLength;             // Information Length (file size)
    ULONGLONG   ObjectSize;             // Object Size (Sum of InfoLengths for all streams)
    
                                        // THE ABOVE FIELD IS NEW IN THE EXT FE vs BASIC
                                        // FE.  FIELDS AFTER THIS POINT ARE DISPLACED AND SHOULD
                                        // BE ACCESSED USING THE MACROS BELOW WHEN 
                                        // MANIPULATING RAW, MAPPED, FEs
                                        
    ULONGLONG   BlocksRecorded;         // Logical Blocks Recorded
    TIMESTAMP   AccessTime;             // Last-Accessed Time
    TIMESTAMP   ModifyTime;             // Last-Modification Time
    TIMESTAMP   CreationTime;           // Creation Time
    TIMESTAMP   AttributeTime;          // Last-Attribute-Change Time
    ULONG       Checkpoint;             // File Checkpoint
    ULONG       Reserved;
    LONGAD      IcbEA;                  // Extended Attribute ICB
    LONGAD      IcbStream;              // Stream Directory ICB
    REGID       ImpUseID;               // Implementation Use Identifier
    ULONGLONG   UniqueID;               // Unique ID
    ULONG       EALength;               // Length of Extended Attributes
    ULONG       AllocLength;            // Length of Allocation Descriptors
    UCHAR       EAs[1];                 // Extended Attributes

//  icbfile_EAs has a variant length = icbfile_EALength

    UCHAR       Allocs[0];              // Allocation Descriptors.

//  icbfile_Allocs has a variant starting offset due to icbfile_EAs.
//  icbfile_Allocs has a variant length = icbfile_AllocLen.

} ICBEXTFILE, *PICBEXTFILE;

//
//  Macros for accessing FEs and EXT FEs transparently.  Note that we
//  only need these for fields after the first new (in ext fe) field (which is
//  ObjectSize) and only for fields that we actually access.
//
//  All of the following macros expect a parameter of type PICBFILE
//

#define FeBlocksRecorded( F)        (((F)->Destag.Ident == DESTAG_ID_NSR_FILE) ? \
                                     (F)->BlocksRecorded : ((PICBEXTFILE)(F))->BlocksRecorded)
                                     
#define PFeAccessTime( F)           (((F)->Destag.Ident == DESTAG_ID_NSR_FILE) ? \
                                     &(F)->AccessTime : &((PICBEXTFILE)(F))->AccessTime)
                                     
#define PFeModifyTime( F)           (((F)->Destag.Ident == DESTAG_ID_NSR_FILE) ? \
                                     &(F)->ModifyTime : &((PICBEXTFILE)(F))->ModifyTime)
                                     
#define PFeCreationTime( F)         (((F)->Destag.Ident == DESTAG_ID_NSR_FILE) ? \
                                     &(F)->ModifyTime : &((PICBEXTFILE)(F))->CreationTime)
                                     
#define FeEALength( F)              (((F)->Destag.Ident == DESTAG_ID_NSR_FILE) ? \
                                     (F)->EALength : ((PICBEXTFILE)(F))->EALength)
                                     
#define FeAllocLength( F)           (((F)->Destag.Ident == DESTAG_ID_NSR_FILE) ? \
                                     (F)->AllocLength : ((PICBEXTFILE)(F))->AllocLength)

#define FeEAs( F)                   (((F)->Destag.Ident == DESTAG_ID_NSR_FILE) ? \
                                     (F)->EAs : ((PICBEXTFILE)(F))->EAs)

#define FeEAsFieldOffset( F)        (((F)->Destag.Ident == DESTAG_ID_NSR_FILE) ? \
                                     FIELD_OFFSET( ICBFILE, EAs ) : FIELD_OFFSET( ICBEXTFILE, EAs ))

#define UdfFEIsExtended( F)         ((F)->Destag.Ident == DESTAG_ID_NSR_EXT_FILE)

//  Definitions for icbfile_Permissions (4/14.9.6)

#define ICBFILE_PERM_OTH_X  (0x00000001)    // Other: Execute OK
#define ICBFILE_PERM_OTH_W  (0x00000002)    // Other: Write OK
#define ICBFILE_PERM_OTH_R  (0x00000004)    // Other: Read OK
#define ICBFILE_PERM_OTH_A  (0x00000008)    // Other: Set Attributes OK
#define ICBFILE_PERM_OTH_D  (0x00000010)    // Other: Delete OK
#define ICBFILE_PERM_GRP_X  (0x00000020)    // Group: Execute OK
#define ICBFILE_PERM_GRP_W  (0x00000040)    // Group: Write OK
#define ICBFILE_PERM_GRP_R  (0x00000080)    // Group: Read OK
#define ICBFILE_PERM_GRP_A  (0x00000100)    // Group: Set Attributes OK
#define ICBFILE_PERM_GRP_D  (0x00000200)    // Group: Delete OK
#define ICBFILE_PERM_OWN_X  (0x00000400)    // Owner: Execute OK
#define ICBFILE_PERM_OWN_W  (0x00000800)    // Owner: Write OK
#define ICBFILE_PERM_OWN_R  (0x00001000)    // Owner: Read OK
#define ICBFILE_PERM_OWN_A  (0x00002000)    // Owner: Set Attributes OK
#define ICBFILE_PERM_OWN_D  (0x00004000)    // Owner: Delete OK

//  (4/14.9.7) Record Format
//      Skipped

//  (4/14.9.8) Record Display Attributes
//      Skipped


/***    nsr_eah - Extended Attributes Header Descriptor (4/14.10.1)
 *
 */

typedef struct  NSR_EAH {
    DESTAG      Destag;                 // Descriptor Tag (ID_NSR_XA)
    ULONG       EAImp;                  // Implementation Attributes Location
    ULONG       EAApp;                  // Application Attributes Location
} NSR_EAH, *PNSR_EAH;


/***    nsr_ea_g - Generic Extended Attributes Format (4/14.10.2)
 *
 */

typedef struct  NSR_EA_GENERIC {
    ULONG       EAType;                 // Extended Attribute Type
    UCHAR       EASubType;              // Extended Attribute Sub Type
    UCHAR       Res5[3];                // Reserved Zeros
    ULONG       EALength;               // Extended Attribute Length
    UCHAR       EAData[0];              // Extended Attribute Data (variant!)

} NSR_EA_GENERIC, *PNSR_EA_GENERIC;

//
//  Extended Attribute Types (14.4.10)
//

#define EA_TYPE_CHARSET     1
#define EA_TYPE_ALTPERM     3
#define EA_TYPE_FILETIMES   5
#define EA_TYPE_INFOTIMES   6
#define EA_TYPE_DEVICESPEC  12
#define EA_TYPE_IMPUSE      2048
#define EA_TYPE_APPUSE      65536

#define EA_SUBTYPE_BASE     1


//  (4/14.10.3) Character Set Information Extended Attribute Format
//      Skipped

//  (4/14.10.4) Alternate Permissions Extended Attribute Format
//      Skipped

//  (4/14.10.5) File Times Extended Attribute Format

typedef struct  NSR_EA_FILETIMES {
    ULONG       EAType;                 // Extended Attribute Type
    UCHAR       EASubType;              // Extended Attribute Sub Type
    UCHAR       Res5[3];                // Reserved Zeros
    ULONG       EALength;               // Extended Attribute Length
    ULONG       DataLength;             // EAData Length
    ULONG       Existence;              // Specifies which times are recorded
    TIMESTAMP   Stamps[0];              // Timestamps (variant!)

} NSR_EA_FILETIMES, *PNSR_EA_FILETIMES;


//  Definitions for nsr_ea_filetimes_Existence (4/14.10.5.6)

#define EA_FILETIMES_E_CREATION     (0x00000001)
#define EA_FILETIMES_E_DELETION     (0x00000004)
#define EA_FILETIMES_E_EFFECTIVE    (0x00000008)
#define EA_FILETIMES_E_LASTBACKUP   (0x00000020)


//  (4/14.10.6) Information Times Extended Attribute Format
//
//  Exactly the same as an NSR_EA_FILETIMES

//  Definitions for nsr_ea_infotimes_Existence (4/14.10.6.6)

#define EA_INFOTIMES_E_CREATION     (0x00000001)
#define EA_INFOTIMES_E_MODIFICATION (0x00000002)
#define EA_INFOTIMES_E_EXPIRATION   (0x00000004)
#define EA_INFOTIMES_E_EFFECTIVE    (0x00000008)


//  (4/14.10.7) Device Specification Extended Attribute Format
//      Skipped

//  (4/14.10.8) Implementation Use Extended Attribute Format
//      Skipped

//  (4/14.10.9) Application Use Extended Attribute Format
//      Skipped


/***    icbuase - Unallocated Space Entry (4/14.11)
 *
 *      icbuase_destag.destag_Ident = DESTAG_ID_NSR_UASE
 *      icbuase_icbtag.icbtag_FileType = ICBTAG_FILE_T_UASE
 *
 */

typedef struct  ICBUASE {
    DESTAG      Destag;                 // Descriptor Tag (ID_NSR_ICBUASE)
    ICBTAG      Icbtag;                 // ICB Tag (ICBTAG_FILE_T_UASE)
    ULONG       AllocLen;               // Allocation Descriptors Length
    UCHAR       Allocs[0];              // Allocation Descriptors (variant!)

//  The true length of this structure may vary!
//  icbuase_Allocs has a variant length = icbuase_AllocLen;

} ICBUASE, *PICBUASE;


/***    nsr_sbd - Space Bitmap Descriptor (4/14.12)
 *
 *      nsr_sbd_destag.destag_Ident = DESTAG_ID_NSR_SBD
 *
 */

typedef struct  NSR_SBD {
    DESTAG      Destag;                 // Descriptor Tag (DESTAG_ID_NSR_SBD)
    ULONG       BitCount;               // Number of bits in Space Bitmap
    ULONG       ByteCount;              // Number of bytes in Space Bitmap
    UCHAR       Bits[0];                // Space Bitmap (variant!)

//  The true length of this structure may vary!
//  nsr_sbd_Bits has a variant length = nsr_sbd_ByteCount;

} NSR_SBD, *PNSR_SBD;


/***    icbpinteg - Partition Integrity ICB Entry (4/14.13)
 *
 */

typedef struct  ICBPINTEG {
    DESTAG      Destag;                 // Descriptor Tag (ID_NSR_PINTEG)
    ICBTAG      Icbtag;                 // ICB Tag (ICBTAG_FILE_T_PINTEG)
    TIMESTAMP   Recording;              // Recording Time
    UCHAR       IntegType;              // Integrity Type (ICBPINTEG_T_...)
    UCHAR       Res49[175];             // Reserved Zeros
    REGID       ImpUseID;               // Implemetation Use Identifier
    UCHAR       ImpUse[256];            // Implemetation Use Area
} ICBPINTEG, *PICBPINTEG;

//  ICBPINTEG_T_... - Values for icbpinteg_IntegType

#define ICBPINTEG_T_OPEN        0       // Open Partition Integrity Entry
#define ICBPINTEG_T_CLOSE       1       // Close Partition Integrity Entry
#define ICBPINTEG_T_STABLE      2       // Stable Partition Integrity Entry


/***    (4/14.14.1) Short Allocation Descriptor
 ***    (4/14.14.2) Long Allocation Descriptor
 ***    (4/14.14.3) Extended Allocation Descriptor
 *
 *      See SHORTAD, LONGAD, EXTAD, already defined above.
 *
 */


/***    nsr_lvhd - Logical Volume Header Descriptor (4/14.15)
 *
 *      The definition is moved to before Logical Volume Integrity
 *      Descriptor.
 *
 */


/***    nsr_path - Path Component (4/14.16)
 *
 */

typedef struct  NSR_PATH {
    UCHAR       Type;                   // Path Component Type (NSR_PATH_T_...)
    UCHAR       CompLen;                // Path Component Length
    UCHAR       CompVer;                // Path Component Version
    UCHAR       Comp[0];                // Path Component Identifier (variant!)

//  nsr_path_Comp has a variant length = nsr_path_CompLen

} NSR_PATH, *PNSR_PATH;

//  NSR_PATH_T_... - Values for nsr_path_Type

#define NSR_PATH_T_RESERVED     0       // Reserved Value
#define NSR_PATH_T_OTHER_ROOT   1       // Another root directory, by agreement
#define NSR_PATH_T_ROOTDIR      2       // Root Directory ('\')
#define NSR_PATH_T_PARENTDIR    3       // Parent Directory ('..')
#define NSR_PATH_T_CURDIR       4       // Current Directory ('.')
#define NSR_PATH_T_FILE         5       // File


/***    ISO 13346 Part 5: Record Structure
 *
 *      Skipped
 *
 */

//
//  Restore the standard structure packing.
//

#pragma pack()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\udfs\namesup.c ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

    NameSup.c

Abstract:

    This module implements the Udfs Name support routines

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]     9-October-1996

Revision History:

// @@END_DDKSPLIT

--*/

#include "UdfProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (UDFS_BUG_CHECK_NAMESUP)

//
//  The local debug trace level
//

#define Dbg                              (UDFS_DEBUG_LEVEL_NAMESUP)

//
//  Local constants
//

static CONST CHAR UdfCrcChar[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ#_~-@";

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UdfCandidateShortName)
#pragma alloc_text(PAGE, UdfCheckLegalCS0Dstring)
#pragma alloc_text(PAGE, UdfConvertCS0DstringToUnicode)
#pragma alloc_text(PAGE, UdfDissectName)
#pragma alloc_text(PAGE, UdfFullCompareNames)
#pragma alloc_text(PAGE, UdfGenerate8dot3Name)
#pragma alloc_text(PAGE, UdfIs8dot3Name)
#pragma alloc_text(PAGE, UdfIsNameInExpression)
#pragma alloc_text(PAGE, UdfRenderNameToLegalUnicode)
#endif


INLINE
ULONG
NativeDosCharLength (
    IN WCHAR Wchar
    )

/*++

Routine Description:

    This routine is a translation layer for asking how big a given UNICODE
    character will be when converted to OEM.  Aside from adding more material
    to the kernel export table, this is how ya do it.

Arguments:

    Wchar - pointer to the character

Return Value:

    Size in bytes.

--*/

{
    NTSTATUS Status;
    CHAR OemBuf[2];
    ULONG Length;

    Status = RtlUpcaseUnicodeToOemN( OemBuf,
                                     sizeof(OemBuf),
                                     &Length,
                                     &Wchar,
                                     sizeof(WCHAR));
    
    ASSERT( NT_SUCCESS( Status ));

    return Length;
}


VOID
UdfDissectName (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PUNICODE_STRING RemainingName,
    OUT PUNICODE_STRING FinalName
    )

/*++

Routine Description:

    This routine is called to strip off leading components of the name strings.  We search
    for either the end of the string or separating characters.  The input remaining
    name strings should have neither a trailing or leading backslash.

Arguments:

    RemainingName - Remaining name.

    FinalName - Location to store next component of name.

Return Value:

    None.

--*/

{
    ULONG NameLength;
    PWCHAR NextWchar;

    PAGED_CODE();

    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );

    //
    //  Find the offset of the next component separators.
    //

    for (NameLength = 0, NextWchar = RemainingName->Buffer;
         (NameLength < RemainingName->Length) && (*NextWchar != L'\\');
         NameLength += sizeof( WCHAR) , NextWchar += 1);

    //
    //  Adjust all the strings by this amount.
    //

    FinalName->Buffer = RemainingName->Buffer;

    FinalName->MaximumLength = FinalName->Length = (USHORT) NameLength;

    //
    //  If this is the last component then set the RemainingName lengths to zero.
    //

    if (NameLength == RemainingName->Length) {

        RemainingName->Length = 0;

    //
    //  Otherwise we adjust the string by this amount plus the separating character.
    //

    } else {

        RemainingName->MaximumLength -= (USHORT) (NameLength + sizeof( WCHAR ));
        RemainingName->Length -= (USHORT) (NameLength + sizeof( WCHAR ));
        RemainingName->Buffer = Add2Ptr( RemainingName->Buffer,
                                         NameLength + sizeof( WCHAR ),
                                         PWCHAR );
    }

    return;
}


BOOLEAN
UdfIs8dot3Name (
    IN PIRP_CONTEXT IrpContext,
    IN UNICODE_STRING FileName
    )

/*++

Routine Description:

    This routine checks if the name follows the 8.3 name conventions.  We check for
    the name length and whether the characters are valid.

Arguments:

    FileName - String of bytes containing the name.

Return Value:

    BOOLEAN - TRUE if this name is a legal 8.3 name, FALSE otherwise.

--*/

{
    CHAR DbcsNameBuffer[ BYTE_COUNT_8_DOT_3 ];
    STRING DbcsName;

    PWCHAR NextWchar;
    ULONG Count;

    ULONG DotCount = 0;
    BOOLEAN LastCharDot = FALSE;

    PAGED_CODE();

    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );

    //
    //  The length must be less than 24 bytes.
    //

    ASSERT( FileName.Length != 0 );
    if (FileName.Length > BYTE_COUNT_8_DOT_3) {

        return FALSE;
    }

    //
    //  Walk though and check for a space character.
    //

    NextWchar = FileName.Buffer;
    Count = 0;

    do {

        //
        //  No spaces allowed.
        //

        if (*NextWchar == L' ') { return FALSE; }

        if (*NextWchar == L'.') {

            //
            //  Not an 8.3 name if more than 1 dot or more than 8 characters
            //  remaining.  (It is legal for the dot to be in the ninth
            //  position)
            //

            if ((DotCount > 0) ||
                (Count > 8 * sizeof( WCHAR ))) {

                return FALSE;
            }

            DotCount += 1;
            LastCharDot = TRUE;

        } else {

            LastCharDot = FALSE;
        }

        Count += 2;
        NextWchar += 1;

    } while (Count < FileName.Length);

    //
    //  We can't have a period at the end of the name.
    //

    if (LastCharDot) {

        return FALSE;
    }

    //
    //  Create an Oem name to use to check for a valid short name.
    //

    DbcsName.MaximumLength = BYTE_COUNT_8_DOT_3;
    DbcsName.Buffer = DbcsNameBuffer;

    if (!NT_SUCCESS( RtlUnicodeStringToCountedOemString( &DbcsName,
                                                         &FileName,
                                                         FALSE ))) {

        return FALSE;
    }

    //
    //  We have now initialized the Oem string.  Call the FsRtl package to check for a
    //  valid FAT name.
    //

    return FsRtlIsFatDbcsLegal( DbcsName, FALSE, FALSE, FALSE );
}


BOOLEAN
UdfCandidateShortName (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING Name
    )

/*++

Routine Description:

    This routine is called to determine if the input name could be a generated
    short name.

Arguments:

    Name - Pointer to the name to stare at.

Return Value:

    BOOLEAN True if it is possible that this is a shortname, False otherwise.

--*/

{
    ULONG Index, SubIndex;
    BOOLEAN LooksShort = FALSE;
    
    PAGED_CODE();

    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );

    //
    //  The length can't be larger than an 8.3 name and must be
    //  at least as big as the uniqifier stamp.
    //

    ASSERT( Name->Length != 0 );
    
    if (Name->Length > BYTE_COUNT_8_DOT_3 ||
        Name->Length < DOS_CRC_LEN * sizeof(WCHAR)) {

        return FALSE;
    }
    
    //
    //  Walk across the name looking for the uniquifier stamp.  The stamp
    //  is of the form #<hex><hex><hex> so if we can stop before the end
    //  of the full name.
    //
    
    for ( Index = 0;
          Index <= (Name->Length / sizeof(WCHAR)) - DOS_CRC_LEN;
          Index++ ) {

        //
        //  Is the current character the stamp UDF uses to offset the stamp?
        //
        
        if (Name->Buffer[Index] == CRC_MARK) {
        
            //
            //  We may potentially have just a CRC at the end
            //  of the name OR have a period following.  If we
            //  do, it is reasonable to think the name may be
            //  a generated shorty.
            //
            //  #123 (a very special case - orignal name was ".")
            //  FOO#123
            //  FOO#123.TXT
            //
            
            if (Index == (Name->Length / sizeof(WCHAR)) - DOS_CRC_LEN ||
                Name->Buffer[Index + DOS_CRC_LEN] == PERIOD) {

                LooksShort = TRUE;
                break;
            }
        }
    }

    return LooksShort;
}


VOID
UdfGenerate8dot3Name (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING FileName,
    OUT PUNICODE_STRING ShortFileName
    )

/*++

Routine Description:

    This routine is called to generate a short name from the given long name.  We will
    generate a short name from the given long name.

    The short form is to convert all runs of illegal characters to "_" and tack
    on a base41 representation of the CRC of the original name.  The algorithm is
    nearly directly lifted from the UDF (2.01 proposed!) standard, so apologies for the
    style clash.
    
Arguments:

    FileName - String of bytes containing the name.

    ShortFileName - Pointer to the string to store the short name into.
        
Return Value:

    None.

--*/

{
    INT16 index;
    INT16 targetIndex;
    INT16 crcIndex;
    INT16 extLen;
    INT16 nameLen;
    INT16 charLen;
    INT16 overlayBytes;
    INT16 bytesLeft;
    UNICODE_CHAR current;
    BOOLEAN needsCRC;
    UNICODE_CHAR ext[DOS_EXT_LEN];

    //
    //  So as to lift as directly as possible from the standard, chunk things around.
    //
 
    PWCHAR dosName = ShortFileName->Buffer;
    PWCHAR udfName = FileName->Buffer;
    SHORT udfNameLen = FileName->Length / sizeof(WCHAR);
    
    needsCRC = FALSE;

    /* Start at the end of the UDF file name and scan for a period */
    /* ('.').  This will be where the DOS extension starts (if     */
    /* any).                                                       */
    index = udfNameLen;
    while (index-- > 0) {
        if (udfName[index] == PERIOD)
            break;
    }

    if (index < 0) {
        /* There name was scanned to the beginning of the buffer   */
        /* and no extension was found.                             */
        extLen = 0;
        nameLen = udfNameLen;
    }
    else {
        /* A DOS extension was found, process it first.            */
        extLen = udfNameLen - index - 1;
        nameLen = index;
        targetIndex = 0;
        bytesLeft = DOS_EXT_LEN;

        while (++index < udfNameLen && bytesLeft > 0) {
            /* Get the current character and convert it to upper   */
            /* case.                                               */
            current = UnicodeToUpper(udfName[index]);
            if (current == SPACE) {
                /* If a space is found, a CRC must be appended to  */
                /* the mangled file name.                          */
                needsCRC = TRUE;
            }
            else {
                /* Determine if this is a valid file name char and */
                /* calculate its corresponding BCS character byte  */
                /* length (zero if the char is not legal or        */
                /* undisplayable on this system).                  */
                charLen = (IsFileNameCharLegal(current)) ?
                    (USHORT)NativeDosCharLength(current) : 0;

                /* If the char is larger than the available space  */
                /* in the buffer, pretend it is undisplayable.     */
                if (charLen > bytesLeft)
                    charLen = 0;

                if (charLen == 0) {
                    /* Undisplayable or illegal characters are     */
                    /* substituted with an underscore ("_"), and   */
                    /* required a CRC code appended to the mangled */
                    /* file name.                                  */
                    needsCRC = TRUE;
                    charLen = 1;
                    current = ILLEGAL_CHAR_MARK;

                    /* Skip over any following undiplayable or     */
                    /* illegal chars.                              */
                    while (index + 1 < udfNameLen &&
                        (!IsFileNameCharLegal(udfName[index + 1]) ||
                        NativeDosCharLength(udfName[index + 1]) == 0))
                        index++;
                }

                /* Assign the resulting char to the next index in  */
                /* the extension buffer and determine how many BCS */
                /* bytes are left.                                 */
                ext[targetIndex++] = current;
                bytesLeft -= charLen;
            }
        }

        /* Save the number of Unicode characters in the extension  */
        extLen = targetIndex;

        /* If the extension was too large, or it was zero length   */
        /* (i.e. the name ended in a period), a CRC code must be   */
        /* appended to the mangled name.                           */
        if (index < udfNameLen || extLen == 0)
            needsCRC = TRUE;
    }

    /* Now process the actual file name.                           */
    index = 0;
    targetIndex = 0;
    crcIndex = 0;
    overlayBytes = -1;
    bytesLeft = DOS_NAME_LEN;
    while (index < nameLen && bytesLeft > 0) {
        /* Get the current character and convert it to upper case. */
        current = UnicodeToUpper(udfName[index]);
        if (current == SPACE || current == PERIOD) {
            /* Spaces and periods are just skipped, a CRC code     */
            /* must be added to the mangled file name.             */
            needsCRC = TRUE;
        }
        else {
            /* Determine if this is a valid file name char and     */
            /* calculate its corresponding BCS character byte      */
            /* length (zero if the char is not legal or            */
            /* undisplayable on this system).                      */
            charLen = (IsFileNameCharLegal(current)) ?
                (USHORT)NativeDosCharLength(current) : 0;

            /* If the char is larger than the available space in   */
            /* the buffer, pretend it is undisplayable.            */
            if (charLen > bytesLeft)
                charLen = 0;

            if (charLen == 0) {
                /* Undisplayable or illegal characters are         */
                /* substituted with an underscore ("_"), and       */
                /* required a CRC code appended to the mangled     */
                /* file name.                                      */
                needsCRC = TRUE;
                charLen = 1;
                current = ILLEGAL_CHAR_MARK;

                /* Skip over any following undiplayable or illegal */
                /* chars.                                          */
                while (index + 1 < nameLen &&
                    (!IsFileNameCharLegal(udfName[index + 1]) ||
                    NativeDosCharLength(udfName[index + 1]) == 0))
                    index++;

                /* Terminate loop if at the end of the file name.  */
                if (index >= nameLen)
                    break;
            }

            /* Assign the resulting char to the next index in the  */
            /* file name buffer and determine how many BCS bytes   */
            /* are left.                                           */
            dosName[targetIndex++] = current;
            bytesLeft -= charLen;

            /* This figures out where the CRC code needs to start  */
            /* in the file name buffer.                            */
            if (bytesLeft >= DOS_CRC_LEN) {
                /* If there is enough space left, just tack it     */
                /* onto the end.                                   */
                crcIndex = targetIndex;
            }
            else {
                /* If there is not enough space left, the CRC      */
                /* must overlay a character already in the file    */
                /* name buffer.  Once this condition has been      */
                /* met, the value will not change.                 */
                if (overlayBytes < 0) {
                    /* Determine the index and save the length of  */
                    /* the BCS character that is overlayed.  It    */
                    /* is possible that the CRC might overlay      */
                    /* half of a two-byte BCS character depending  */
                    /* upon how the character boundaries line up.  */
                    overlayBytes = (bytesLeft + charLen > DOS_CRC_LEN)
                        ? 1 : 0;
                    crcIndex = targetIndex - 1;
                }
            }
        }

        /* Advance to the next character.                          */
        index++;
    }

    /* If the scan did not reach the end of the file name, or the  */
    /* length of the file name is zero, a CRC code is needed.      */
    if (index < nameLen || index == 0)
        needsCRC = TRUE;

    /* If the name has illegal characters or and extension, it     */
    /* is not a DOS device name.                                   */
    if (needsCRC == FALSE && extLen == 0) {
        /* If this is the name of a DOS device, a CRC code should  */
        /* be appended to the file name.                           */
        if (IsDeviceName(udfName, udfNameLen))
            needsCRC = TRUE;
    }

    /* Append the CRC code to the file name, if needed.            */
    if (needsCRC) {
        /* Get the CRC value for the original Unicode string       */
        UINT16 udfCRCValue;

        //
        //  In UDF 2.00, the sample code changed to take the CRC
        //  from the UNICODE expansion of the CS0 as opposed to
        //  the CS0 itself.  In UDF 2.01, the wording of the spec
        //  will actually match this.
        //
        //  Additionally, the checksum changes to be byte-order
        //  independent.
        //
        
        udfCRCValue = UdfComputeCrc16Uni(udfName, udfNameLen);

        /* Determine the character index where the CRC should      */
        /* begin.                                                  */
        targetIndex = crcIndex;

        /* If the character being overlayed is a two-byte BCS      */
        /* character, replace the first byte with an underscore.   */
        if (overlayBytes > 0)
            dosName[targetIndex++] = ILLEGAL_CHAR_MARK;

        //
        //  UDF 2.01 changes to a base 41 encoding.  UDF 1.50 and
        //  UDF 2.00 exchanged the # delimeter with the high 4bits
        //  of the CRC.
        //

        dosName[targetIndex++] = CRC_MARK;
        
        dosName[targetIndex++] =
            UdfCrcChar[udfCRCValue / (41 * 41)];
        udfCRCValue %= (41 * 41);
        
        dosName[targetIndex++] =
            UdfCrcChar[udfCRCValue / 41];
        udfCRCValue %= 41;
        
        dosName[targetIndex++] =
            UdfCrcChar[udfCRCValue];
    }

    /* Append the extension, if any.                               */
    if (extLen > 0) {
        /* Tack on a period and each successive byte in the        */
        /* extension buffer.                                       */
        dosName[targetIndex++] = PERIOD;
        for (index = 0; index < extLen; index++)
            dosName[targetIndex++] = ext[index];
    }

    ASSERT( (targetIndex * sizeof(WCHAR)) <= ShortFileName->MaximumLength );
 
    ShortFileName->Length = (USHORT) (targetIndex * sizeof(WCHAR));

    //
    //  Now we upcase the whole name at once.
    //

    UdfUpcaseName( IrpContext,
                   ShortFileName,
                   ShortFileName );
}


VOID
UdfConvertCS0DstringToUnicode (
    IN PIRP_CONTEXT IrpContext,
    IN PUCHAR Dstring,
    IN UCHAR Length OPTIONAL,
    IN UCHAR FieldLength OPTIONAL,
    IN OUT PUNICODE_STRING Name
    )

/*++

Routine Description:

    This routine will convert the CS0 input dstring (1/7.2.12) to Unicode.  We assume that
    the length is sane.
    
    This "compression" in CS0 is really just a special case hack for ASCII.

Arguments:

    Dstring - the input dstring field
    
    Length - length of the dstring.  If unspecified, we assume that the characters come
        from a proper 1/7.2.12 dstring that specifies length in the last character of the
        field.
    
    FieldLength - length of the dstring field.  If unspecified, we assume that the characters
        come from an uncounted length of CS0 characters and that the Length parameter is
        specified.
    
    Name - the output Unicode string

Return Value:

    None.

--*/

{
    ULONG CompressID;
    ULONG UnicodeIndex, ByteIndex;
    PWCHAR Unicode = Name->Buffer;

    UCHAR NameLength;
    ULONG CopyNameLength;

    PAGED_CODE();
   
    //
    //  Check input.
    //

    ASSERT_IRP_CONTEXT( IrpContext );

    CompressID = *Dstring;

    //
    //  If the length is unspecified, this is a real 1/7.2.12 dstring and the length is in
    //  the last character of the field.
    //
    
    ASSERT( Length || FieldLength );

    if (Length) {

        NameLength = FieldLength = Length;
    
    } else {

        NameLength = *(Dstring + FieldLength - 1);
    }
    
    //
    //  If the caller specified a size, they should have made sure the buffer is big enough.
    //  Otherwise, we will trim to fit.
    //
    
    ASSERT( Length == 0 || Name->MaximumLength >= UdfCS0DstringUnicodeSize( IrpContext, Dstring, NameLength ) );
 
    //
    //  Decide how many UNICODE bytes to "copy".
    //
    
    CopyNameLength = Min( Name->MaximumLength, UdfCS0DstringUnicodeSize( IrpContext, Dstring, NameLength ));
    
    //
    //  Reset the name length and advance over the compression ID in the dstring.
    //
    
    Name->Length = 0;
    Dstring++;
 
    //
    //  Loop through all the bytes.
    //

    while (CopyNameLength > Name->Length) {
      
        if (CompressID == 16) {
       
            //
            //  We're little endian, and this is the single place in the entire UDF/ISO standard
            //  where they use big endian.
            //
            //  Thank you.  Thank you very much.
            //
            //  Do an unaligned swapcopy of this 16bit value.
            //

            SwapCopyUchar2( Unicode, Dstring );
            Dstring += sizeof(WCHAR);
       
        } else {

            //
            //  Drop the byte into the low bits.
            //
                
            *Unicode = *Dstring;
            Dstring += sizeof(CHAR);
        }

        Name->Length += sizeof(WCHAR);
        Unicode++;
    }

    return;
}


BOOLEAN
UdfCheckLegalCS0Dstring (
    PIRP_CONTEXT IrpContext,
    PUCHAR Dstring,
    UCHAR Length OPTIONAL,
    UCHAR FieldLength OPTIONAL,
    BOOLEAN ReturnOnError
    )

/*++

Routine Description:

    This routine inspects a CS0 Dstring for conformance.
    
Arguments:

    Dstring - a dstring to check
    
    Length - length of the dstring.  If unspecified, we assume that the characters come
        from a proper 1/7.2.12 dstring that specifies length in the last character of the
        field.
    
    FieldLength - length of the dstring field.  If unspecified, we assume that the characters
        come from an uncounted length of CS0 characters and that the Length parameter is
        specified.
    
    ReturnOnError - whether to return or raise on a discovered error
    
Return Value:

    None. Raised status if corruption is found.
    
--*/

{
    UCHAR NameLength;

    //
    //  Check input.
    //

    ASSERT_IRP_CONTEXT( IrpContext );

    //
    //  If the length is unspecified, this is a real 1/7.2.12 dstring and the length is in
    //  the last character of the field.
    //
    
    ASSERT( Length || FieldLength );

    if (Length) {

        NameLength = FieldLength = Length;
    
    } else {

        NameLength = *(Dstring + FieldLength - 1);
    }

    DebugTrace(( +1, Dbg,
                 "UdfCheckLegalCS0Dstring, Dstring %08x Length %02x FieldLength %02x (NameLength %02x)\n",
                 Dstring,
                 Length,
                 FieldLength,
                 NameLength ));

    //
    //  The string must be "compressed" in 8bit or 16bit chunks.  If it
    //  is in 16bit chunks, we better have an integral number of them -
    //  remember we have the compression ID, so the length will be odd.
    //
    
    if ((NameLength <= 1 &&
         DebugTrace(( 0, Dbg,
                      "UdfCheckLegalCS0Dstring, NameLength is too small!\n" ))) ||

        (NameLength > FieldLength &&
         DebugTrace(( 0, Dbg,
                      "UdfCheckLegalCS0Dstring, NameLength is bigger than the field itself!\n" ))) ||

        ((*Dstring != 8 && *Dstring != 16) &&
         DebugTrace(( 0, Dbg,
                      "UdfCheckLegalCS0Dstring, claims encoding %02x, unknown! (not 0x8 or 0x10)\n",
                      *Dstring ))) ||

        ((*Dstring == 16 && !FlagOn( NameLength, 1)) &&
         DebugTrace(( 0, Dbg,
                     "UdfCheckLegalCS0Dstring, NameLength not odd, encoding 0x10!\n" )))) {

        if (ReturnOnError) {

            DebugTrace(( -1, Dbg, "UdfCheckLegalCS0Dstring -> FALSE\n" ));

            return FALSE;
        }

        DebugTrace(( -1, Dbg, "UdfCheckLegalCS0Dstring -> raised status\n" ));

        UdfRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
    }

    DebugTrace(( -1, Dbg, "UdfCheckLegalCS0Dstring -> TRUE\n" ));

    return TRUE;
}


VOID
UdfRenderNameToLegalUnicode (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING Name,
    IN PUNICODE_STRING RenderedName
    )

/*++

Routine Description:

    This routine will take a Unicode string containing illegal characters and
    run it through the UDF standard algorithim to render it into a "legal"
    name.
    
    The short form is to convert all runs of illegal characters to "_" and tack
    on a hex representation of the CRC of the original name.  The algorithm is
    nearly directly lifted from the UDF (2.01 proposed!) standard, so apologies
    for the style clash.
    
Arguments:

    Name - the actual name
    
    RenderedName - the name rendered into legal characters
    
Return Value:

    BOOLEAN - TRUE if the expressions match, FALSE otherwise.

--*/

{
    INT16 index;
    INT16 targetIndex;
    INT16 crcIndex;
    INT16 extLen;
    INT16 nameLen;
    INT16 charLen;
    INT16 overlayBytes;
    INT16 bytesLeft;
    UNICODE_CHAR current;
    BOOLEAN needsCRC;
    BOOLEAN foundDot;
    UNICODE_CHAR ext[EXT_LEN];

    //
    //  So as to lift as directly as possible from the standard, chunk things around.
    //
 
    PWCHAR newName = RenderedName->Buffer;
    PWCHAR udfName = Name->Buffer;
    SHORT udfNameLen = Name->Length / sizeof(WCHAR);

    /* Remove trailing periods ('.') and spaces (' '), Windows     */
    /* does not like them.                                         */
    foundDot = FALSE;
    index = udfNameLen;
    while (index-- > 0) {
        if (udfName[index] == PERIOD)
            foundDot = TRUE;
        else if (udfName[index] != SPACE)
            break;
    }

    needsCRC = FALSE;
    bytesLeft = MAX_LEN;
    extLen = 0;

    /* If any trailing periods or spaces were found, a CRC code    */
    /* needs to be added to the resulting file name.               */
    nameLen = index + 1;
    if (nameLen < udfNameLen)
        needsCRC = TRUE;

    if (needsCRC == FALSE || foundDot == FALSE) {
        /* Look for an extension in the file name.  We do not      */
        /* need to look for one if there were any trailing periods */
        /* or spaces removed.                                      */
        INT16 endIndex;
        INT16 prevCharLen = 1;
        INT16 extBytes = 0;

        targetIndex = 0;
        index = nameLen;

        /* Determine how many bytes we need to scan to find the    */
        /* extension delimiter.  The extension has a maximum of    */
        /* five characters, but we do not want to scan past the    */
        /* beginning of the buffer.                                */
        endIndex = (udfNameLen > EXT_LEN + 1) ?
            udfNameLen - EXT_LEN - 1 : 1;

        /* Start at the end of the name and scan backward, looking */
        /* for the extension delimiter (".").                      */
        while (index-- > endIndex) {
            /* Get the character to test.                          */
            current = udfName[index];

            if (current == '.') {
                /* The extension delimiter was found, figure out   */
                /* how many characters the extension contains and  */
                /* the length of the resulting file name without   */
                /* the extension.                                  */
                extLen = nameLen - index - 1;
                nameLen = index;
                break;
            }

            /* Determine the byte length of the current character  */
            /* when converted to native format.                    */
            charLen = (IsFileNameCharLegal(current)) ?
                NativeCharLength(current) : 0;

            if (charLen == 0) {
                /* If the character byte length is zero, it is     */
                /* illegal or unprintable, place an underscore     */
                /* ("_") in the extension buffer if the previous   */
                /* character tested was legal.  Not that the       */
                /* characters placed in the extension buffer are   */
                /* in reverse order.                               */
                if (prevCharLen != 0) {
                    ext[targetIndex++] = ILLEGAL_CHAR_MARK;
                    extBytes++;
                }
            }
            else {
                /* The current character is legal and printable,   */
                /* put it in the extension buffer.  Note that the  */
                /* characters placed in the extension buffer are   */
                /* in reverse order.                               */
                ext[targetIndex++] = current;
                extBytes += charLen;
            }

            /* Save the byte length of the current character, so   */
            /* we can determine if it was a legal character during */
            /* the next test.                                      */
            prevCharLen = charLen;
        }

        /* If an extension was found, determine how many bytes     */
        /* remain in the file name buffer once we account for it.  */
        if (extLen > 0)
            bytesLeft -= extBytes + 1;
    }

    index = 0;
    targetIndex = 0;
    crcIndex = 0;
    overlayBytes = -1;
    while (index < nameLen && bytesLeft > 0) {
        /* Get the current character and convert it to upper case. */
        current = udfName[index];

        /* Determine if this is a valid file name char and         */
        /* calculate its corresponding native character byte       */
        /* length (zero if the char is not legal or undiplayable   */
        /* on this system).                                        */
        charLen = (IsFileNameCharLegal(current)) ?
            NativeCharLength(current) : 0;

        /* If the char is larger than the available space in the   */
        /* buffer, pretend it is undisplayable.                    */
        if (charLen > bytesLeft)
            charLen = 0;

        if (charLen == 0) {
            /* Undisplayable or illegal characters are substituted */
            /* with an underscore ("_"), and requires a CRC code   */
            /* appended to the mangled file name.                  */
            needsCRC = TRUE;
            charLen = 1;
            current = '_';

            /* Skip over any following undiplayable or illegal     */
            /* chars.                                              */
            while (index + 1 < udfNameLen &&
                (!IsFileNameCharLegal(udfName[index + 1]) ||
                NativeCharLength(udfName[index + 1]) == 0))
                index++;

            /* Terminate loop if at the end of the file name.      */
            if (index >= udfNameLen)
                break;
        }

        /* Assign the resulting char to the next index in the file */
        /* name buffer and determine how many native bytes are     */
        /* left.                                                   */
        newName[targetIndex++] = current;
        bytesLeft -= charLen;

        /* This figures out where the CRC code needs to start in   */
        /* the file name buffer.                                   */
        if (bytesLeft >= CRC_LEN) {
            /* If there is enough space left, just tack it onto    */
            /* the end.                                            */
            crcIndex = targetIndex;
        }
        else {
            /* If there is not enough space left, the CRC must     */
            /* overlay a character already in the file name        */
            /* buffer.  Once this condition has been met, the      */
            /* value will not change.                              */
            if (overlayBytes < 0) {
                /* Determine the index and save the length of the  */
                /* native character that is overlayed.  It is      */
                /* possible that the CRC might overlay half of a   */
                /* two-byte native character depending upon how    */
                /* the character boundaries line up.               */
                overlayBytes = (bytesLeft + charLen > CRC_LEN)
                    ? 1 : 0;
                crcIndex = targetIndex - 1;
            }
        }

        /* Advance to the next character.                          */
        index++;
    }

    /* If the scan did not reach the end of the file name, or the  */
    /* length of the file name is zero, a CRC code is needed.      */
    if (index < nameLen || index == 0)
        needsCRC = TRUE;

    /* If the name has illegal characters or and extension, it     */
    /* is not a DOS device name.                                   */
    if (needsCRC == FALSE && extLen == 0) {
        /* If this is the name of a DOS device, a CRC code should  */
        /* be appended to the file name.                           */
        if (IsDeviceName(udfName, udfNameLen))
            needsCRC = TRUE;
    }

    /* Append the CRC code to the file name, if needed.            */
    if (needsCRC) {
        /* Get the CRC value for the original Unicode string       */
        UINT16 udfCRCValue = UdfComputeCrc16Uni(udfName, udfNameLen);

        /* Determine the character index where the CRC should      */
        /* begin.                                                  */
        targetIndex = crcIndex;

        /* If the character being overlayed is a two-byte native   */
        /* character, replace the first byte with an underscore.   */
        if (overlayBytes > 0)
            newName[targetIndex++] = ILLEGAL_CHAR_MARK;

        /* Append the encoded CRC value with delimiter.            */
        newName[targetIndex++] = CRC_MARK;
        newName[targetIndex++] = UdfCrcChar[(udfCRCValue & 0xf000) >> 12];
        newName[targetIndex++] = UdfCrcChar[(udfCRCValue & 0x0f00) >> 8];
        newName[targetIndex++] = UdfCrcChar[(udfCRCValue & 0x00f0) >> 4];
        newName[targetIndex++] = UdfCrcChar[(udfCRCValue & 0x000f)];
    }


    /* If an extension was found, append it here.                  */
    if (extLen > 0) {
        /* Add the period ('.') for the extension delimiter.       */
        newName[targetIndex++] = PERIOD;

        /* Append the characters in the extension buffer.  They    */
        /* were stored in reverse order, so we need to begin with  */
        /* the last character and work forward.                    */
        while (extLen-- > 0)
            newName[targetIndex++] = ext[extLen];
    }

    ASSERT( (targetIndex * sizeof(WCHAR)) <= RenderedName->MaximumLength );
 
    RenderedName->Length = (USHORT) (targetIndex * sizeof(WCHAR));
}


BOOLEAN
UdfIsNameInExpression (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING CurrentName,
    IN PUNICODE_STRING SearchExpression,
    IN BOOLEAN Wild
    )

/*++

Routine Description:

    This routine will compare two Unicode strings.  We assume that if this
    is to be a case-insensitive search then they are already upcased.

Arguments:

    CurrentName - Filename from the disk.

    SearchExpression - Filename expression to use for match.
    
    Wild - True if wildcards are present in SearchExpression.

Return Value:

    BOOLEAN - TRUE if the expressions match, FALSE otherwise.

--*/

{
    BOOLEAN Match = TRUE;
    
    PAGED_CODE();

    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );

    //
    //  If there are wildcards in the expression then we call the
    //  appropriate FsRtlRoutine.
    //

    if (Wild) {

        Match = FsRtlIsNameInExpression( SearchExpression,
                                         CurrentName,
                                         FALSE,
                                         NULL );

    //
    //  Otherwise do a direct memory comparison for the name string.
    //

    } else {

        if ((CurrentName->Length != SearchExpression->Length) ||
            (!RtlEqualMemory( CurrentName->Buffer,
                              SearchExpression->Buffer,
                              CurrentName->Length ))) {

            Match = FALSE;
        }
    }

    return Match;
}


FSRTL_COMPARISON_RESULT
UdfFullCompareNames (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING NameA,
    IN PUNICODE_STRING NameB
    )

/*++

Routine Description:

    This function compares two names as fast as possible.  Note that since
    this comparison is case sensitive we can do a direct memory comparison.

Arguments:

    NameA & NameB - The names to compare.

Return Value:

    COMPARISON - returns

        LessThan    if NameA < NameB lexicalgraphically,
        GreaterThan if NameA > NameB lexicalgraphically,
        EqualTo     if NameA is equal to NameB

--*/

{
    ULONG i;
    ULONG MinLength = NameA->Length;
    FSRTL_COMPARISON_RESULT Result = LessThan;

    PAGED_CODE();

    //
    //  Check inputs.
    //

    ASSERT_IRP_CONTEXT( IrpContext );

    //
    //  Figure out the minimum of the two lengths
    //

    if (NameA->Length > NameB->Length) {

        MinLength = NameB->Length;
        Result = GreaterThan;

    } else if (NameA->Length == NameB->Length) {

        Result = EqualTo;
    }

    //
    //  Loop through looking at all of the characters in both strin