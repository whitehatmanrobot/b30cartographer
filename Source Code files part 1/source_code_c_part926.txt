   m_idbSmallImageOpen;
    UINT    m_idbLargeImage;
    long    m_viewOptions;              // for GetResultViewType
    UINT    m_idiSnapinImage;           // the icon used by ISnapinAbout

public:
    const   CLSID & m_clsidSnapin;      // the snapin class ID
    const   LPCTSTR m_szClsidSnapin;
    const   GUID &  m_guidNodetype;     // root node type
    const   LPCTSTR m_szGuidNodetype;

    const   LPCTSTR m_szClassName;
    const   LPCTSTR m_szProgID;
    const   LPCTSTR m_szVersionIndependentProgID;


public:
    CSnapinDescriptor();
    CSnapinDescriptor(UINT idsName, UINT idsDescription, UINT idiSnapinImage, UINT idbSmallImage, 
                      UINT idbSmallImageOpen, UINT idbLargeImage,
               const CLSID &clsidSnapin, LPCTSTR szClsidSnapin,
               const GUID &guidNodetype, LPCTSTR szGuidNodetype,
               LPCTSTR szClassName, LPCTSTR szProgID, LPCTSTR szVersionIndependentProgID,
               long viewOptions);

    void    GetName(CStr &str);
    void    GetRegisteredDefaultName(CStr &str);
    void    GetRegisteredIndirectName(CStr &str);
    UINT    GetDescription()        {return m_idsDescription;}
    HBITMAP GetSmallImage();
    HBITMAP GetSmallImageOpen();
    HBITMAP GetLargeImage();
    long    GetViewOptions();
    HICON   GetSnapinImage();
};

/*+-------------------------------------------------------------------------*
 * class CSnapinComponentDataImpl
 *
 *
 * PURPOSE: Implements IComponentData for the built-in snapins.
 *
 *+-------------------------------------------------------------------------*/
class CSnapinComponentDataImpl :
    public IComponentData,
    public CComObjectRoot,
    public ISnapinAbout,
    public ISnapinHelp,
    public IPersistStream,
    public IExtendPropertySheet2,
    public CSerialObjectRW
{
    friend class CSnapinComponentImpl;
public:

    CSnapinComponentDataImpl();
    virtual  CSnapinDescriptor&  GetDescriptor() = 0;

    // IComponentData
    STDMETHODIMP Initialize(LPUNKNOWN pUnknown);
    STDMETHODIMP Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event,
                   LPARAM arg, LPARAM param);
    STDMETHODIMP Destroy();
    STDMETHODIMP QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                            LPDATAOBJECT* ppDataObject);
    STDMETHODIMP GetDisplayInfo( SCOPEDATAITEM* pScopeDataItem);
    STDMETHODIMP CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

    // IPersistStream
    STDMETHODIMP GetClassID(CLSID *pClassID);
    STDMETHODIMP IsDirty(void);
    STDMETHODIMP Load(LPSTREAM pStm);
    STDMETHODIMP Save(LPSTREAM pStm , BOOL fClearDirty);
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize  );

    // ISnapinHelp
    STDMETHODIMP GetHelpTopic (LPOLESTR* ppszCompiledHelpFile);

    // IExtendPropertySheet2
    STDMETHODIMP CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, LONG_PTR handle, LPDATAOBJECT lpIDataObject) = 0;
    STDMETHODIMP GetWatermarks(LPDATAOBJECT lpIDataObject, HBITMAP * lphWatermark, HBITMAP * lphHeader, HPALETTE * lphPalette,  BOOL* bStretch);
    STDMETHODIMP QueryPagesFor(LPDATAOBJECT lpDataObject);

    // override
    virtual      UINT GetHeaderBitmap() {return 0;}
    virtual      UINT GetWatermark() {return 0;}

    // CSerialObject methods
    virtual UINT    GetVersion()     {return 1;}
    virtual HRESULT ReadSerialObject (IStream &stm, UINT nVersion);
    virtual HRESULT WriteSerialObject(IStream &stm);

protected:
    HRESULT         OnPreload(HSCOPEITEM scopeItem);


private: // attributes - not persisted
    IConsole2Ptr                m_spConsole2;
    IConsoleNameSpace2Ptr       m_spConsoleNameSpace2;
    bool                        m_bDirty;
protected:
    UINT                        m_iImage;
    UINT                        m_iOpenImage;

    void SetDirty(BOOL bState = TRUE) { m_bDirty = bState; }

private: // attributes - persisted
    CStringTableString  m_strName;  // the name of the root node, which is the only node created by the snapin
    CStringTableString  m_strView;  // the view displayed by the node.

public:
    void         SetName(LPCTSTR sz);
    LPCTSTR      GetName() {return m_strName.data();}
    void         SetView(LPCTSTR sz);
    LPCTSTR      GetView() {return m_strView.data();}
};

/*+-------------------------------------------------------------------------*
 * class CSnapinComponentImpl
 *
 *
 * PURPOSE: Implements IComponent for the built-in snapins.
 *
 *+-------------------------------------------------------------------------*/
class CSnapinComponentImpl : public CComObjectRoot, public IComponent
{
public:
BEGIN_COM_MAP(CSnapinComponentImpl)
    COM_INTERFACE_ENTRY(IComponent)
END_COM_MAP()

    void  Init(IComponentData *pComponentData);

    // IComponent
    STDMETHODIMP Initialize(LPCONSOLE lpConsole);
    STDMETHODIMP Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event,
                   LPARAM arg, LPARAM param);
    STDMETHODIMP Destroy(MMC_COOKIE cookie);
    STDMETHODIMP QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                            LPDATAOBJECT* ppDataObject);
    STDMETHODIMP GetResultViewType(MMC_COOKIE cookie, LPOLESTR* ppViewType,
                              long* pViewOptions);
    STDMETHODIMP GetDisplayInfo( RESULTDATAITEM*  pResultDataItem);
    STDMETHODIMP CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

protected:
    CSnapinComponentDataImpl *  GetComponentData();

protected:
    virtual SC                  ScOnSelect(BOOL bScope, BOOL bSelect);

protected: // attributes - not persisted
    IConsole2Ptr                m_spConsole2;
    IComponentDataPtr           m_spComponentData;
};

/*+-------------------------------------------------------------------------*
 * class CSnapinDataObject
 *
 *
 * PURPOSE: Implements IDataObject for the built-in snapins.
 *
 *+-------------------------------------------------------------------------*/
class CSnapinDataObject : public CComObjectRoot, public IDataObject
{
public:
BEGIN_COM_MAP(CSnapinDataObject)
    COM_INTERFACE_ENTRY(IDataObject)
END_COM_MAP()

    CSnapinDataObject();

    // IDataObject
    STDMETHODIMP GetDataHere(FORMATETC *pformatetc, STGMEDIUM *pmedium);
private:
    STDMETHODIMP GetData(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium){ return E_NOTIMPL; };
    STDMETHODIMP EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc){ return E_NOTIMPL; };
    STDMETHODIMP QueryGetData(LPFORMATETC lpFormatetc) { return E_NOTIMPL; };
    STDMETHODIMP GetCanonicalFormatEtc(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut){ return E_NOTIMPL; };
    STDMETHODIMP SetData(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease){ return E_NOTIMPL; };
    STDMETHODIMP DAdvise(LPFORMATETC lpFormatetc, DWORD advf, LPADVISESINK pAdvSink, LPDWORD pdwConnection){ return E_NOTIMPL; };
    STDMETHODIMP DUnadvise(DWORD dwConnection){ return E_NOTIMPL; };
    STDMETHODIMP EnumDAdvise(LPENUMSTATDATA* ppEnumAdvise){ return E_NOTIMPL; };

    HRESULT      WriteString(IStream *pStream, LPCOLESTR sz);

public:
    void              Initialize(IComponentData *pComponentData, DATA_OBJECT_TYPES type);
    DATA_OBJECT_TYPES GetType() const {return m_type;}

private:
    bool              m_bInitialized;
    IComponentDataPtr m_spComponentData;    // back pointer to the parent.
    DATA_OBJECT_TYPES m_type;

// Clipboard formats that are required by the console
    static void       RegisterClipboardFormats();
    static UINT       s_cfNodeType;
    static UINT       s_cfNodeTypeString;
    static UINT       s_cfDisplayName;
    static UINT       s_cfCoClass;
    static UINT       s_cfSnapinPreloads;


};


SC ScLoadAndAllocateString(UINT ids, LPOLESTR *lpstrOut);

/*+-------------------------------------------------------------------------*
 * class CSnapinWrapper
 *
 *
 * PURPOSE: A template class, used to instantiate the snapin.
 *
 *+-------------------------------------------------------------------------*/
template <class CSnapin, const CLSID *pCLSID_Snapin>
class CSnapinWrapper : public CSnapin, public CComCoClass<CSnapin, pCLSID_Snapin>
{
    typedef CSnapinWrapper<CSnapin, pCLSID_Snapin> ThisClass;

BEGIN_COM_MAP(ThisClass)
    COM_INTERFACE_ENTRY(IComponentData)
    COM_INTERFACE_ENTRY(ISnapinAbout)
    COM_INTERFACE_ENTRY(ISnapinHelp)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IExtendPropertySheet2)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(ThisClass)

    // registry
    static HRESULT WINAPI UpdateRegistry(BOOL bRegister)
    {
        USES_CONVERSION;

        CStr strName;
        GetSnapinDescriptor().GetRegisteredDefaultName (strName);

        CStr strIndirectName;
        GetSnapinDescriptor().GetRegisteredIndirectName (strIndirectName);

        _ATL_REGMAP_ENTRY rgEntries[] =
        {
            { L"VSnapinClsid",              T2COLE(          GetSnapinDescriptor().m_szClsidSnapin)},
            { L"VNodetype",                 T2COLE(          GetSnapinDescriptor().m_szGuidNodetype)},
            { L"VSnapinName",               T2COLE((LPCTSTR) strName)},
            { L"VSnapinNameIndirect",       T2COLE((LPCTSTR) strIndirectName)},
            { L"VClassName",                T2COLE(          GetSnapinDescriptor().m_szClassName)},
            { L"VProgID",                   T2COLE(          GetSnapinDescriptor().m_szProgID)},
            { L"VVersionIndependentProgID", T2COLE(          GetSnapinDescriptor().m_szVersionIndependentProgID)},
            { L"VFileName",                 T2COLE(          g_szMmcndmgrDll)},
            {NULL, NULL}
        };

        return _Module.UpdateRegistryFromResource(IDR_FOLDERSNAPIN, bRegister, rgEntries);
    }

    

    STDMETHODIMP GetSnapinDescription(LPOLESTR* lpDescription)
    {
        DECLARE_SC(sc, TEXT("CSnapinWrapper::GetSnapinDescription"));
        
        sc = ScLoadAndAllocateString(GetSnapinDescriptor().GetDescription(), lpDescription);
        return sc.ToHr();
    }

    STDMETHODIMP GetProvider(LPOLESTR* lpDescription)
    {
        DECLARE_SC(sc, TEXT("CSnapinWrapper::GetProvider"));
        
        sc = ScLoadAndAllocateString(IDS_BUILTIN_SNAPIN_PROVIDER, lpDescription);
        return sc.ToHr();
    }

    STDMETHODIMP GetSnapinVersion(LPOLESTR* lpDescription)
    {
        return E_NOTIMPL;
    }

    STDMETHODIMP GetSnapinImage(HICON* hAppIcon)
    {
        DECLARE_SC (sc, TEXT("CSnapinWrapper::GetSnapinImage"));

        sc = ScCheckPointers(hAppIcon);
        if(sc)
            return sc.ToHr();
    
        *hAppIcon = GetDescriptor().GetSnapinImage();
    
        return sc.ToHr();
    }

    STDMETHODIMP GetStaticFolderImage(HBITMAP* hSmallImage, HBITMAP* hSmallImageOpen,
                                               HBITMAP* hLargeImage, COLORREF* cMask)
    {
        DECLARE_SC (sc, TEXT("CSnapinWrapper::GetStaticFolderImage"));

        sc = ScCheckPointers(hSmallImage, hSmallImageOpen, hLargeImage, cMask);
        if(sc)
            return sc.ToHr();

        *hSmallImage     = GetDescriptor().GetSmallImage();
        *hSmallImageOpen = GetDescriptor().GetSmallImageOpen();
        *hLargeImage     = GetDescriptor().GetLargeImage();
        *cMask           = RGB(255, 0, 255);

        return sc.ToHr();
    }


    virtual  CSnapinDescriptor&  GetDescriptor()
    {
        return GetSnapinDescriptor();
    }

    CSnapinWrapper()
    {
        CStr strName;
        GetDescriptor().GetName(strName);
        SetName(strName);
    }

};

//____________________________________________________________________________
//
//  Class:      CFolderSnapinData
//
//  PURPOSE:
//____________________________________________________________________________
//
class CFolderSnapinData : public CSnapinComponentDataImpl
{
    typedef CSnapinComponentDataImpl BC;
public:

    CFolderSnapinData();

    // IComponentData
    STDMETHODIMP CreateComponent(LPCOMPONENT* ppComponent);

    // IExtendPropertySheet2
    STDMETHODIMP CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, LONG_PTR handle, LPDATAOBJECT lpIDataObject);

    void SetDirty(BOOL bState = TRUE) { BC::SetDirty(bState); }

    static CSnapinDescriptor&  GetSnapinDescriptor();
};

typedef CSnapinWrapper<CFolderSnapinData, &CLSID_FolderSnapin> CFolderSnapin;

//____________________________________________________________________________
//
//  Class:      CFolderSnapinComponent
//
//  PURPOSE:
//____________________________________________________________________________
//
class CFolderSnapinComponent : public CSnapinComponentImpl
{
};

//____________________________________________________________________________
//
//  Class:      CHTMLSnapinData
//
//  PURPOSE:
//____________________________________________________________________________
//
class CHTMLSnapinData : public CSnapinComponentDataImpl
{
    typedef CSnapinComponentDataImpl BC;
public:

    CHTMLSnapinData();
    ~CHTMLSnapinData();

    // IComponentData
    STDMETHODIMP CreateComponent(LPCOMPONENT* ppComponent);
    STDMETHODIMP Destroy();

    // IExtendPropertySheet2
    STDMETHODIMP CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, LONG_PTR handle, LPDATAOBJECT lpIDataObject);

    virtual      UINT GetWatermark() {return IDB_SETUPWIZARD1;}


    static CSnapinDescriptor&  GetSnapinDescriptor();

private:
    CHTMLPage1 *m_pHtmlPage1;
    CHTMLPage2 *m_pHtmlPage2;
};

typedef CSnapinWrapper<CHTMLSnapinData, &CLSID_HTMLSnapin> CHTMLSnapin;

//____________________________________________________________________________
//
//  Class:      CHTMLSnapinComponent
//
//  PURPOSE:
//____________________________________________________________________________
//
class CHTMLSnapinComponent : public CSnapinComponentImpl
{
    typedef CSnapinComponentImpl BC;
public:
    virtual SC   ScOnSelect(BOOL bScope, BOOL bSelect);

    STDMETHODIMP GetResultViewType(MMC_COOKIE cookie, LPOLESTR* ppViewType,
                              long* pViewOptions);

};

//____________________________________________________________________________
//
//  Class:      COCXSnapinData
//
//  PURPOSE:
//____________________________________________________________________________
//
class COCXSnapinData : public CSnapinComponentDataImpl
{
    typedef CSnapinComponentDataImpl BC;
public:

    COCXSnapinData();
    ~COCXSnapinData();

    // IComponentData
    STDMETHODIMP CreateComponent(LPCOMPONENT* ppComponent);
    STDMETHODIMP Destroy();

    // IExtendPropertySheet2
    STDMETHODIMP CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, LONG_PTR handle, LPDATAOBJECT lpIDataObject);

    virtual      UINT GetHeaderBitmap() {return IDB_OCX_WIZARD_HEADER;}
    virtual      UINT GetWatermark()    {return IDB_SETUPWIZARD;}


    static CSnapinDescriptor&  GetSnapinDescriptor();

private:
    CActiveXPage0* m_pActiveXPage0;
    CActiveXPage1* m_pActiveXPage1;
    CActiveXPage2* m_pActiveXPage2;

};

typedef CSnapinWrapper<COCXSnapinData, &CLSID_OCXSnapin> COCXSnapin;

//____________________________________________________________________________
//
//  Class:      COCXSnapinComponent
//
//  PURPOSE:
//____________________________________________________________________________
//
class COCXSnapinComponent : public CSnapinComponentImpl, IPersistStorage
{
public:
    COCXSnapinComponent() : m_bLoaded(FALSE), m_bInitialized(FALSE) {}

    BEGIN_COM_MAP(COCXSnapinComponent)
        COM_INTERFACE_ENTRY(IPersistStorage)
        COM_INTERFACE_ENTRY_CHAIN(CSnapinComponentImpl)
    END_COM_MAP()

    // IPersistStorage
    STDMETHODIMP HandsOffStorage();
    STDMETHODIMP InitNew(IStorage* pStg);
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load(IStorage* pStg);
    STDMETHODIMP Save(IStorage* pStg, BOOL fSameAsLoad);
    STDMETHODIMP SaveCompleted(IStorage* pStgNew);
    STDMETHODIMP GetClassID(CLSID *pClassID);

    // IComponenent override
    STDMETHODIMP Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event,
                        LPARAM arg, LPARAM param);

protected:
    STDMETHODIMP OnInitOCX(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param);

private:
    IStoragePtr         m_spStg;        // Storage provided by MMC
    IStoragePtr         m_spStgInner;   // Nested storage given to OCX

    IPersistStreamPtr   m_spIPStm;      // Persist interfaces from OCX
    IPersistStoragePtr  m_spIPStg;      // only one will be used

    BOOL                m_bLoaded;      // MMC called Load
    BOOL                m_bInitialized; // MMC called InitNew
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\helparr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       HelpArr.h
//
//  Resource file: \\kernel\razzle2\src\admin\activec\nodemgr\nodemgr.rc
//
//  Help file: mmc.hlp
//
//  Help Source file: mmcnd_cs.rtf
//
//  Help IDs file:	mmcndmgr.h
//
//  Authored:	John Mikesell (a-jmike) 06/08/99
//--------------------------------------------------------------------------

#ifndef _HELPARR_H_
#define _HELPARR_H_

#ifndef IDH_DISABLEHELP
#define IDH_DISABLEHELP	((DWORD)-1)
#endif

#define IDH_ACTIVEX_PROPPAGE1_DISPLAYTX	1001
#define IDH_COLUMNS_COLUMNS_ADD_BTN	1002
#define IDH_COLUMNS_COLUMNS_DISPLAYED_LIST	1003
#define IDH_COLUMNS_COLUMNS_HIDDEN_LIST	1004
#define IDH_COLUMNS_COLUMNS_MOVEDOWN_BTN	1005
#define IDH_COLUMNS_COLUMNS_MOVEUP_BTN	1006
#define IDH_COLUMNS_COLUMNS_REMOVE_BTN	1007
#define IDH_COLUMNS_COLUMNS_RESET_BTN	1008
#define IDH_CUSTOMIZE_VIEW_CUST_CONSOLE_TREE	1009
#define IDH_CUSTOMIZE_VIEW_CUST_DESC_BAR	1010
#define IDH_CUSTOMIZE_VIEW_CUST_SNAPIN_BUTTONS	1011
#define IDH_CUSTOMIZE_VIEW_CUST_SNAPIN_MENUS	1012
#define IDH_CUSTOMIZE_VIEW_CUST_STATUS_BAR	1013
#define IDH_CUSTOMIZE_VIEW_CUST_STD_BUTTONS	1014
#define IDH_CUSTOMIZE_VIEW_CUST_STD_MENUS	1015
#define IDH_CUSTOMIZE_VIEW_CUST_TASKPAD_TABS	1016
#define IDH_HTML_PROPPAGE1_CHANGEICONBT	1019
#define IDH_HTML_PROPPAGE1_DISPLAYTX	1020
#define IDH_HTML_PROPPAGE1_FINDTARGETBT	1021
#define IDH_HTML_PROPPAGE1_TARGETTX	1022
#define IDH_MONITOR_PROPPAGE1_CTRLPROPERTIES	1023
#define IDH_NOPROPS_PROPPAGE_NOPROPS	1024
#define IDH_ORDER_DIALOG_LIST	1025
#define IDH_ORDER_DIALOG_MOVE_DOWN	1026
#define IDH_ORDER_DIALOG_MOVE_UP	1027
#define IDH_RETARGET_TASKPAD_RetargetRootTree	1028
#define IDH_SHORTCUT_PROPPAGE1_CHANGEICONBT	1029
#define IDH_SHORTCUT_PROPPAGE1_FINDTARGETBT	1030
#define IDH_SHORTCUT_PROPPAGE1_RUNTX	1031
#define IDH_SHORTCUT_PROPPAGE1_STARTINTX	1032
#define IDH_SHORTCUT_PROPPAGE1_TARGETTX	1033
#define IDH_SNAPIN_ABOUT_COMPANY_NAME	1034
#define IDH_SNAPIN_ABOUT_DESCRIPTION	1035
#define IDH_SNAPIN_ABOUT_SNAPIN_NAME	1036
#define IDH_SNAPIN_ABOUT_VERSION	1037
#define IDH_SNAPIN_DESCR	1038
#define IDH_SNAPIN_EXTENSION_PROPP_EXTENSION_LIST	1039
#define IDH_SNAPIN_EXTENSION_PROPP_SNAPIN_ABOUT	1040
#define IDH_SNAPIN_EXTENSION_PROPP_SNAPIN_COMBOEX	1041
#define IDH_SNAPIN_EXTENSION_PROPP_SNAPIN_DESCR	1042
#define IDH_SNAPIN_EXTENSION_PROPP_SNAPIN_ENABLEALL	1043
#define IDH_SNAPIN_MANAGER_ADD_SNAPIN_LV	1044
#define IDH_SNAPIN_STANDALONE_PROPP_SNAPIN_ABOUT	1045
#define IDH_SNAPIN_STANDALONE_PROPP_SNAPIN_ADDED_LIST	1046
#define IDH_SNAPIN_STANDALONE_PROPP_SNAPIN_COMBOEX	1047
#define IDH_SNAPIN_STANDALONE_PROPP_SNAPIN_DESCR	1048
#define IDH_SNAPIN_STANDALONE_PROPP_SNAPIN_MANAGER_ADD	1049
#define IDH_SNAPIN_STANDALONE_PROPP_SNAPIN_MANAGER_DELETE	1050
#define IDH_SNAPIN_STANDALONE_PROPP_TOOLBAR	1051
#define IDH_TASK_PROPS_CMDLINE_PAGE_BrowseForArguments	1052
#define IDH_TASK_PROPS_CMDLINE_PAGE_BrowseForCommand	1053
#define IDH_TASK_PROPS_CMDLINE_PAGE_BrowseForWorkingDir	1054
#define IDH_TASK_PROPS_CMDLINE_PAGE_Command	1055
#define IDH_TASK_PROPS_CMDLINE_PAGE_CommandArgs	1056
#define IDH_TASK_PROPS_CMDLINE_PAGE_CommandWindowStateCombo	1057
#define IDH_TASK_PROPS_CMDLINE_PAGE_CommandWorkingDir	1058
#define IDH_TASK_PROPS_NAME_PAGE_TaskDescription	1059
#define IDH_TASK_PROPS_NAME_PAGE_TaskName	1060
#define IDH_TASK_PROPS_SYMBOL_PAGE_DESCRIPTION	1061
#define IDH_TASK_PROPS_SYMBOL_PAGE_DESCRIPTION2	1062
#define IDH_TASK_PROPS_SYMBOL_PAGE_GLYPH_LIST	1063
#define IDH_TASKPAD_ADVANCED_DontUseForSimilarNodes	1064
#define IDH_TASKPAD_ADVANCED_SetDefaultForNodetype	1065
#define IDH_TASKPAD_ADVANCED_UseForSimilarNodes	1066
#define IDH_TASKPAD_GENERAL_Options	1067
#define IDH_TASKPAD_GENERAL_STYLE_DESCRIPTION	1068
#define IDH_TASKPAD_GENERAL_Style_HorizontalList	1069
#define IDH_TASKPAD_GENERAL_Style_SizeCombo	1070
#define IDH_TASKPAD_GENERAL_Style_TasksOnly	1071
#define IDH_TASKPAD_GENERAL_Style_TextDesc	1072
#define IDH_TASKPAD_GENERAL_Style_TooltipDesc	1073
#define IDH_TASKPAD_GENERAL_Style_VerticalList	1074
#define IDH_TASKPAD_GENERAL_TASKPAD_DESCRIPTION	1075
#define IDH_TASKPAD_GENERAL_TASKPAD_TITLE	1076
#define IDH_TASKPAD_GENERAL_TaskpadPreview	1077
#define IDH_TASKS_LIST_TASKS	1078
#define IDH_TASKS_MODIFY	1079
#define IDH_TASKS_MOVE_DOWN	1080
#define IDH_TASKS_MOVE_UP	1081
#define IDH_TASKS_NEW_TASK_BT	1082
#define IDH_TASKS_REMOVE_TASK	1083
#define IDH_SNAPIN_EXTENSION_PROPP_SNAPIN_DOWNLOAD 1084
#define IDH_SNAPIN_MANAGER_ADD_SNAPIN_DESCR        1085
#define IDH_Style_HideNormalTab 4162

const DWORD g_aHelpIDs_IDD_SNAPIN_ABOUT[]=	
{	
IDC_APPICON,	IDH_DISABLEHELP,
IDC_COMPANY_NAME,	IDH_SNAPIN_ABOUT_COMPANY_NAME,
IDC_DESCRIPTION,	IDH_SNAPIN_ABOUT_DESCRIPTION,
IDC_LINE,	IDH_DISABLEHELP,
IDC_SNAPIN_NAME,	IDH_SNAPIN_ABOUT_SNAPIN_NAME,
IDC_VERSION,	IDH_SNAPIN_ABOUT_VERSION,
    0, 0	
};	
	
	
const DWORD g_aHelpIDs_IDD_ACTIVEX_PROPPAGE1[]=	
{	
IDC_DISPLAYTX,	IDH_ACTIVEX_PROPPAGE1_DISPLAYTX,
    0, 0	
};	
	
const DWORD g_aHelpIDs_IDD_SHORTCUT_PROPPAGE1[]=	
{	
IDC_TARGETTX,	IDH_SHORTCUT_PROPPAGE1_TARGETTX,
IDC_FINDTARGETBT,	IDH_SHORTCUT_PROPPAGE1_FINDTARGETBT,
IDC_CHANGEICONBT,	IDH_SHORTCUT_PROPPAGE1_CHANGEICONBT,
    0, 0	
};	
	
const DWORD g_aHelpIDs_IDD_HTML_PROPPAGE1[]=	
{	
IDC_DISPLAYTX,	IDH_HTML_PROPPAGE1_DISPLAYTX,
IDC_TARGETTX,	IDH_HTML_PROPPAGE1_TARGETTX,
IDC_FINDTARGETBT,	IDH_HTML_PROPPAGE1_FINDTARGETBT,
IDC_CHANGEICONBT,	IDH_HTML_PROPPAGE1_CHANGEICONBT,
    0, 0	
};	
	
const DWORD g_aHelpIDs_IDD_MONITOR_PROPPAGE1[]=	
{	
IDC_CTRLPROPERTIES,	IDH_MONITOR_PROPPAGE1_CTRLPROPERTIES,
    0, 0	
};	
	
const DWORD g_aHelpIDs_IDD_NOPROPS_PROPPAGE[]=	
{	
IDC_NOPROPS,	IDH_NOPROPS_PROPPAGE_NOPROPS,
    0, 0	
};	
	
const DWORD g_aHelpIDs_IDD_SNAPIN_MANAGER_ADD[]=	
{	
IDC_SNAPIN_LV,	IDH_SNAPIN_MANAGER_ADD_SNAPIN_LV,
IDC_SNAPIN_DESCR,	IDH_SNAPIN_MANAGER_ADD_SNAPIN_DESCR,
    0, 0	
};	
	
const DWORD g_aHelpIDs_IDD_SNAPIN_STANDALONE_PROPP[]=	
{	
IDC_SNAPIN_DESCR,	IDH_SNAPIN_STANDALONE_PROPP_SNAPIN_DESCR,
IDC_SNAPIN_MANAGER_ADD,	IDH_SNAPIN_STANDALONE_PROPP_SNAPIN_MANAGER_ADD,
IDC_SNAPIN_MANAGER_DELETE,	IDH_SNAPIN_STANDALONE_PROPP_SNAPIN_MANAGER_DELETE,
IDC_SNAPIN_ADDED_LIST,	IDH_SNAPIN_STANDALONE_PROPP_SNAPIN_ADDED_LIST,
IDC_SNAPIN_ABOUT,	IDH_SNAPIN_STANDALONE_PROPP_SNAPIN_ABOUT,
IDC_SNAPIN_COMBOEX,	IDH_SNAPIN_STANDALONE_PROPP_SNAPIN_COMBOEX,
IDC_TOOLBAR,	IDH_SNAPIN_STANDALONE_PROPP_TOOLBAR,
IDC_VTHELPER,	IDH_DISABLEHELP,
    0, 0	
};	
	
	
const DWORD g_aHelpIDs_IDD_SNAPIN_EXTENSION_PROPP[]=	
{	
IDC_SNAPIN_LABEL,	IDH_SNAPIN_EXTENSION_PROPP_SNAPIN_COMBOEX,
IDC_SNAPIN_DESCR,	IDH_SNAPIN_EXTENSION_PROPP_SNAPIN_DESCR,
IDC_SNAPIN_ABOUT,	IDH_SNAPIN_EXTENSION_PROPP_SNAPIN_ABOUT,
IDC_SNAPIN_COMBOEX,	IDH_SNAPIN_EXTENSION_PROPP_SNAPIN_COMBOEX,
IDC_SNAPIN_DOWNLOAD,	IDH_SNAPIN_EXTENSION_PROPP_SNAPIN_DOWNLOAD,
IDC_EXTENSION_LIST,	IDH_SNAPIN_EXTENSION_PROPP_EXTENSION_LIST,
IDC_VTHELPER,	        IDH_DISABLEHELP,
IDC_EXTENSION_LABEL,	IDH_SNAPIN_EXTENSION_PROPP_EXTENSION_LIST,
IDC_SNAPIN_ENABLEALL,	IDH_SNAPIN_EXTENSION_PROPP_SNAPIN_ENABLEALL,
    0, 0	
};	
	

// HELP: Gave proper IDs instead of numbers from nodemgr.rc
const DWORD g_aHelpIDs_IDD_COLUMNS[]=	
{	
IDC_HIDDEN_COLUMNS,	IDH_COLUMNS_COLUMNS_HIDDEN_LIST,
IDC_ADD_COLUMNS,	IDH_COLUMNS_COLUMNS_ADD_BTN,
IDC_REMOVE_COLUMNS,	IDH_COLUMNS_COLUMNS_REMOVE_BTN,
IDC_RESTORE_DEFAULT_COLUMNS,	IDH_COLUMNS_COLUMNS_RESET_BTN,
IDC_DISPLAYED_COLUMNS,	IDH_COLUMNS_COLUMNS_DISPLAYED_LIST,
IDC_MOVEUP_COLUMN,	IDH_COLUMNS_COLUMNS_MOVEUP_BTN,
IDC_MOVEDOWN_COLUMN,    IDH_COLUMNS_COLUMNS_MOVEDOWN_BTN,
65535,	                IDH_DISABLEHELP,
    0, 0	
};	
	
const DWORD g_aHelpIDs_IDD_CUSTOMIZE_VIEW[]=	
{	
IDC_CUST_VIEW_CAPTION,             -1,                // prevent help from showing for static text
IDC_CUST_CONSOLE_TREE,	IDH_CUSTOMIZE_VIEW_CUST_CONSOLE_TREE,
IDC_CUST_STD_MENUS,	IDH_CUSTOMIZE_VIEW_CUST_STD_MENUS,
IDC_CUST_STD_BUTTONS,	IDH_CUSTOMIZE_VIEW_CUST_STD_BUTTONS,
IDC_CUST_STATUS_BAR,	IDH_CUSTOMIZE_VIEW_CUST_STATUS_BAR,
IDC_CUST_DESC_BAR,	IDH_CUSTOMIZE_VIEW_CUST_DESC_BAR,
IDC_CUST_TASKPAD_TABS,	IDH_CUSTOMIZE_VIEW_CUST_TASKPAD_TABS,
IDC_CUST_SNAPIN_MENUS,	IDH_CUSTOMIZE_VIEW_CUST_SNAPIN_MENUS,
IDC_CUST_SNAPIN_BUTTONS,IDH_CUSTOMIZE_VIEW_CUST_SNAPIN_BUTTONS,
    0, 0	
};	
	
const DWORD g_aHelpIDs_IDD_ORDER_DIALOG[]=	
{	
IDC_MOVE_UP,	IDH_ORDER_DIALOG_MOVE_UP,
IDC_MOVE_DOWN,	IDH_ORDER_DIALOG_MOVE_DOWN,
    0, 0	
};	
	
		
const DWORD g_aHelpIDs_IDD_TASK_PROPS_CMDLINE_PAGE[]=	
{	
IDC_CommandLabel,	IDH_TASK_PROPS_CMDLINE_PAGE_Command,
IDC_Command,	IDH_TASK_PROPS_CMDLINE_PAGE_Command,
IDC_CommandArgsLabel,	IDH_TASK_PROPS_CMDLINE_PAGE_CommandArgs,
IDC_CommandArgs,	IDH_TASK_PROPS_CMDLINE_PAGE_CommandArgs,
IDC_CommandWorkingDirLabel,	IDH_TASK_PROPS_CMDLINE_PAGE_CommandWorkingDir,
IDC_CommandWorkingDir,	IDH_TASK_PROPS_CMDLINE_PAGE_CommandWorkingDir,
IDC_CommandWindowStateComboLabel,	IDH_TASK_PROPS_CMDLINE_PAGE_CommandWindowStateCombo,
IDC_CommandWindowStateCombo,	IDH_TASK_PROPS_CMDLINE_PAGE_CommandWindowStateCombo,
IDC_BrowseForCommand,	IDH_TASK_PROPS_CMDLINE_PAGE_BrowseForCommand,
IDC_BrowseForArguments,	IDH_TASK_PROPS_CMDLINE_PAGE_BrowseForArguments,
IDC_BrowseForWorkingDir,	IDH_TASK_PROPS_CMDLINE_PAGE_BrowseForWorkingDir,
    0, 0	
};	
	
const DWORD g_aHelpIDs_IDD_TASK_PROPS_NAME_PAGE[]=	
{	
IDC_TaskNameLabel,	IDH_TASK_PROPS_NAME_PAGE_TaskName,
IDC_TaskName,	IDH_TASK_PROPS_NAME_PAGE_TaskName,
IDC_TaskDescription,	IDH_TASK_PROPS_NAME_PAGE_TaskDescription,
    0, 0	
};	
	
const DWORD g_aHelpIDs_IDD_TASK_PROPS_SYMBOL_PAGE[]=	
{	
IDC_DESCRIPTION,	IDH_TASK_PROPS_SYMBOL_PAGE_DESCRIPTION,
IDC_DESCRIPTION2,	IDH_TASK_PROPS_SYMBOL_PAGE_DESCRIPTION2,
IDC_GLYPH_LIST,	IDH_TASK_PROPS_SYMBOL_PAGE_GLYPH_LIST,
    0, 0	
};	
	
	
const DWORD g_aHelpIDs_IDD_TASKPAD_ADVANCED[]=	
{	
IDC_DontUseForSimilarNodes,	IDH_TASKPAD_ADVANCED_DontUseForSimilarNodes,
IDC_UseForSimilarNodes,	IDH_TASKPAD_ADVANCED_UseForSimilarNodes,
IDC_SetDefaultForNodetype,	IDH_TASKPAD_ADVANCED_SetDefaultForNodetype,
    0, 0	
};	
	
const DWORD g_aHelpIDs_IDD_TASKPAD_GENERAL[]=	
{	
IDC_TASKPAD_TITLE,	IDH_TASKPAD_GENERAL_TASKPAD_TITLE,
IDC_TASKPAD_DESCRIPTION,	IDH_TASKPAD_GENERAL_TASKPAD_DESCRIPTION,
IDC_Style_VerticalList,	IDH_TASKPAD_GENERAL_Style_VerticalList,
IDC_Style_HorizontalList,	IDH_TASKPAD_GENERAL_Style_HorizontalList,
IDC_Style_TasksOnly,	IDH_TASKPAD_GENERAL_Style_TasksOnly,
IDC_Style_TextDesc,	IDH_TASKPAD_GENERAL_Style_TextDesc,
IDC_Style_TooltipDesc,	IDH_TASKPAD_GENERAL_Style_TooltipDesc,
IDC_Style_SizeCombo,	IDH_TASKPAD_GENERAL_Style_SizeCombo,
IDC_Options,	IDH_TASKPAD_GENERAL_Options,
IDC_STYLE_DESCRIPTION,	IDH_TASKPAD_GENERAL_STYLE_DESCRIPTION,
IDC_TaskpadPreview,	IDH_TASKPAD_GENERAL_TaskpadPreview,
IDC_Style_HideNormalTab, IDH_Style_HideNormalTab,
    0, 0	
};	
	
const DWORD g_aHelpIDs_IDD_TASKS[]=	
{	
IDC_LIST_TASKS,	IDH_TASKS_LIST_TASKS,
IDC_NEW_TASK_BT,	IDH_TASKS_NEW_TASK_BT,
IDC_REMOVE_TASK,	IDH_TASKS_REMOVE_TASK,
IDC_MODIFY,	IDH_TASKS_MODIFY,
IDC_MOVE_UP,	IDH_TASKS_MOVE_UP,
IDC_MOVE_DOWN,	IDH_TASKS_MOVE_DOWN,
    0, 0	
};	

// Handle context sensitive dialog help for the nodemgr subsystem
void HelpWmHelp(LPHELPINFO pHelpInfo, const DWORD* pHelpIDs);
void HelpContextMenuHelp(HWND hWnd, ULONG_PTR p);

#define CONTEXT_HELP_HANDLER()                                                  \
        MESSAGE_HANDLER   (WM_HELP,         OnWmHelp)                           \
        MESSAGE_HANDLER(WM_CONTEXTMENU,     OnWmContextMenu)                    \


#define IMPLEMENT_CONTEXT_HELP(g_helpIds)                                         \
                                                                                  \
LRESULT OnWmHelp( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )       \
{                                                                                 \
    HelpWmHelp(reinterpret_cast<LPHELPINFO>(lParam), g_helpIds);                  \
    return true;                                                                  \
}                                                                                 \
                                                                                  \
LRESULT OnWmContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled ) \
{                                                                                 \
    HelpContextMenuHelp((HWND)wParam,                                             \
               (ULONG_PTR)(LPVOID) g_helpIds);                                    \
    return TRUE;                                                                  \
}



#endif // _HELPAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\helpdoc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       helpdoc.cpp
//
//--------------------------------------------------------------------------


/*
 * There are two ways by which help collection is recognized dirty. First is if a snapin
 * is added/removed or extension is enabled/disabled, but this is only for this instance
 * of console file.
 * Second is if the modification time of console file is different from modification time
 * of collection. This is because an author may have added/removed a snapin without bringing
 * up help and saves console file. So the modification time on console file is later than
 * collection. Next time he/she opens console file and brings help, the help collection is
 * regenerated.
 */

// mmchelp.cpp : implmentation of the HelpTopics class
//
#include "stdafx.h"
#include "strings.h"
#include "helpdoc.h"
#include "nodemgr.h"
#include "regutil.h"
#include "scopndcb.h"


#ifdef DBG
CTraceTag	tagHelpCollection (_T("Help"), _T(".COL construction"));
#endif


BOOL GetBaseFileName(LPCWSTR pszFilePath, LPWSTR pszBaseName, int cBaseName);
BOOL MatchFileTimes(FILETIME& ftime1, FILETIME& ftime2);

HRESULT CHelpDoc::Initialize(HELPDOCINFO* pDocInfo)
{
    ASSERT(pDocInfo != NULL);
    m_pDocInfo = pDocInfo;

    return BuildFilePath();
}


HRESULT CHelpDoc::BuildFilePath()
{
    USES_CONVERSION;

    do // false loop
    {
        // Get temp directory
        DWORD dwRet = GetTempPath(MAX_PATH, m_szFilePath);
        if (dwRet == 0 || dwRet > MAX_PATH)
            break;

        // Make sure that the temp path exists and it is a dir
        dwRet = GetFileAttributes(m_szFilePath);
        if ( (0xFFFFFFFF == dwRet) || !(FILE_ATTRIBUTE_DIRECTORY & dwRet) )
            break;

        // Get base name of console file (if no name use "default")
        WCHAR szBaseName[MAX_PATH];

        if (m_pDocInfo->m_pszFileName && m_pDocInfo->m_pszFileName[0])
        {
			TCHAR szShortFileName[MAX_PATH] = {0};
			if ( 0 == GetShortPathName( OLE2CT( m_pDocInfo->m_pszFileName ), szShortFileName, countof(szShortFileName) - 1 ) )
				wcscpy(szBaseName, L"default"); // Does not need to be localized
			else
				GetBaseFileName( T2CW(szShortFileName), szBaseName, MAX_PATH);
        }
        else
        {
            wcscpy(szBaseName, L"default"); // Does not need to be localized
        }

        TCHAR* pszBaseName = OLE2T(szBaseName);
        if (lstrlen(m_szFilePath) + lstrlen(pszBaseName) >= MAX_PATH - 4)
            break;

        // construct help file path
        lstrcat(m_szFilePath, pszBaseName);
        lstrcat(m_szFilePath, _T(".col"));

        return S_OK;

    } while (0);

    // clear path on failure
    m_szFilePath[0] = 0;

    return E_FAIL;
}


bool entry_title_comp(EntryPair* pE1, EntryPair* pE2)
{
    return pE1->second < pE2->second;
}

//------------------------------------------------------------------------------
// Enumerate the snapins in the snap-in cache. Call AddSnapInToList for each one.
// Open the snap-ins registry key for AddSnapInToList to use. When all the
// snap-ins have been added, sort the resulting entries by snap-in name.
//------------------------------------------------------------------------------
HRESULT CHelpDoc::CreateSnapInList()
{
    DECLARE_SC(sc, TEXT("CHelpDoc::CreateSnapInList"));

    CSnapInsCache* pSnapInsCache = theApp.GetSnapInsCache();
    ASSERT(pSnapInsCache != NULL);

    m_entryMap.clear();
    m_entryList.clear();

    // open MMC\Snapins key
    sc = ScFromWin32 ( m_keySnapIns.Open(HKEY_LOCAL_MACHINE, SNAPINS_KEY, KEY_READ) );
    if (sc)
        return sc.ToHr();

    // mark all snapins which have external references
    sc = pSnapInsCache->ScMarkExternallyReferencedSnapins();
    if (sc)
        return sc.ToHr();

    // Add each snap-in and its static extensions to the list
    CSnapInsCache::iterator c_it;
    for (c_it = pSnapInsCache->begin(); c_it != pSnapInsCache->end(); ++c_it)
    {
        const CSnapIn *pSnapin = c_it->second;
        if (!pSnapin)
            return (sc = E_UNEXPECTED).ToHr();

        bool bIsExternallyReferenced = false;
        sc = pSnapin->ScTempState_IsExternallyReferenced( bIsExternallyReferenced );
        if (sc)
            return sc.ToHr();

        // skip if snapin is not externally referenced
        if ( !bIsExternallyReferenced )
            continue;

        AddSnapInToList(pSnapin->GetSnapInCLSID());

        // we do not need to add extensions, since they are in cache anyway
        // and must be marked as externally referenced, (so will be added by the code above)
        // but it is worth to assert that

#ifdef DBG

        {
            CExtSI* pExt = pSnapin->GetExtensionSnapIn();
            while (pExt != NULL)
            {
                CSnapIn *pSnapin = pExt->GetSnapIn();
                sc = ScCheckPointers( pSnapin, E_UNEXPECTED );
                if (sc)
                {
                    sc.TraceAndClear();
                    break;
                }

                bool bExtensionExternallyReferenced = false;
                sc = pSnapin->ScTempState_IsExternallyReferenced( bExtensionExternallyReferenced );
                if (sc)
                {
                    sc.TraceAndClear();
                    break;
                }

                // assert it is in the cache and is marked properly
                CSnapInPtr spSnapin;
                ASSERT( SC(S_OK) == pSnapInsCache->ScFindSnapIn( pExt->GetCLSID(), &spSnapin ) );
                ASSERT( bExtensionExternallyReferenced );

                pExt = pExt->Next();
            }
        }

#endif // DBG

    }

    m_keySnapIns.Close();

    // our snap-in set is now up to date
    pSnapInsCache->SetHelpCollectionDirty(false);

    // copy items from map to list container so they can be sorted
    EntryMap::iterator it;
    for (it = m_entryMap.begin(); it != m_entryMap.end(); it++ )
    {
        m_entryList.push_back(&(*it));
    }

    sort(m_entryList.begin(), m_entryList.end(), entry_title_comp);

    return sc.ToHr();
}


//-----------------------------------------------------------------
// Add an entry to the snap-in list for the specified snap-in CLSID.
// Then recursively add any dynamic-only extensions that are registered
// to extend this snap-in. This list is indexed by snap-in CLSID to
// speed up checking for duplicate snap-ins.
//-----------------------------------------------------------------
void CHelpDoc::AddSnapInToList(const CLSID& rclsid)
{
    DECLARE_SC(sc, TEXT("CHelpDoc::AddSnapInToList"));

    // check if already included
    if (m_entryMap.find(rclsid) != m_entryMap.end())
        return;

    // open the snap-in key
    OLECHAR szCLSID[40];
    int iRet = StringFromGUID2(rclsid, szCLSID, countof(szCLSID));
    ASSERT(iRet != 0);

    USES_CONVERSION;

    CRegKeyEx keyItem;
    LONG lStat = keyItem.Open(m_keySnapIns, OLE2T(szCLSID), KEY_READ);
    if (lStat != ERROR_SUCCESS)
        return;

    // get the snap-in name
	WTL::CString strName;
    sc = ScGetSnapinNameFromRegistry (keyItem, strName);
#ifdef DBG
    if (sc)
    {
        USES_CONVERSION;
        sc.SetSnapinName(W2T (szCLSID)); // only guid is valid ...
        TraceSnapinError(_T("Failure reading \"NameString\" value from registry"), sc);
        sc.Clear();
    }
#endif // DBG

    // Add to snap-in list
    if (lStat == ERROR_SUCCESS)
    {
        wstring s(T2COLE(strName));
        m_entryMap[rclsid] = s;
    }

    // Get list of registered extensions
    CExtensionsCache  ExtCache;
    HRESULT hr = MMCGetExtensionsForSnapIn(rclsid, ExtCache);
    ASSERT(SUCCEEDED(hr));
    if (hr != S_OK)
        return;

    // Pass each dynamic extension to AddSnapInToList
    //  Note that the EXT_TYPE_DYNAMIC flag will be set for any extension
    //  that is dynamic-only for at least one nodetype. It may also be a
    //  static extension for another node type, so we don't check that the
    //  EXT_TYPE_STATIC flag is not set.
    CExtensionsCacheIterator ExtIter(ExtCache);
    for (; ExtIter.IsEnd() == FALSE; ExtIter.Advance())
    {
        if (ExtIter.GetValue() & CExtSI::EXT_TYPE_DYNAMIC)
        {
            CLSID clsid = ExtIter.GetKey();
            AddSnapInToList(clsid);
        }
    }
}


//----------------------------------------------------------------------
// Add a single file to a help collection. The file is added as a title
// and if bAddFolder is specified a folder is also added.
//----------------------------------------------------------------------
HRESULT CHelpDoc::AddFileToCollection(
            LPCWSTR pszTitle,
            LPCWSTR pszFilePath,
            BOOL    bAddFolder )
{
	DECLARE_SC (sc, _T("CHelpDoc::AddFileToCollection"));

	/*
	 * redirect the help file to the user's UI language, if necessary
	 */
	WTL::CString strFilePath = pszFilePath;
	LANGID langid = ENGLANGID;
	sc = ScRedirectHelpFile (strFilePath, langid);
	if (sc)
		return (sc.ToHr());

	Trace (tagHelpCollection, _T("AddFileToCollection: %s - %s (langid=0x%04x)"), pszTitle, (LPCTSTR) strFilePath, langid);

	USES_CONVERSION;
	pszFilePath = T2CW (strFilePath);

    DWORD dwError = 0;
    m_spCollection->AddTitle (pszTitle, pszFilePath, pszFilePath, L"", L"",
							  langid, FALSE, NULL, &dwError, TRUE, L"");
    if (dwError != 0)
		return ((sc = E_FAIL).ToHr());

    if (bAddFolder)
    {
        // Folder ID parameter has the form "=title"
        WCHAR szTitleEq[MAX_PATH+1];
        szTitleEq[0] = L'=';
        wcscpy(szTitleEq+1, pszTitle);

        m_spCollection->AddFolder(szTitleEq, 1, &dwError, langid);
		if (dwError != 0)
			return ((sc = E_FAIL).ToHr());
    }

	return (sc.ToHr());
}


/*+-------------------------------------------------------------------------*
 * CHelpDoc::ScRedirectHelpFile
 *
 * This method is for MUI support.  On MUI systems, where the user's UI
 * language is not US English, we will attempt to redirect the help file to
 *
 *		<dir>\mui\<langid>\<helpfile>
 *
 * <dir>		Takes one of two values:  If the helpfile passed in is fully
 * 				qualified, <dir> is the supplied directory.  If the helpfile
 * 				passed in is unqualified, then <dir> is %SystemRoot%\Help.
 * <langid>		The langid of the user's UI language, formatted as %04x
 * <helpfile>	The name of the original .chm file.
 *
 * This function returns:
 *
 * S_OK			if the helpfile was successfully redirected
 * S_FALSE		if the helpfile wasn't redirected
 *--------------------------------------------------------------------------*/

SC CHelpDoc::ScRedirectHelpFile (
	WTL::CString&	strHelpFile,	/* I/O:help file (maybe redirected)		*/
	LANGID&			langid)			/* O:language ID of output help file	*/
{
	DECLARE_SC (sc, _T("CHelpDoc::ScRedirectHelpFile"));

    typedef LANGID (WINAPI* GetUILangFunc)(void);
	static GetUILangFunc	GetUserDefaultUILanguage_   = NULL;
	static GetUILangFunc	GetSystemDefaultUILanguage_ = NULL;
	static bool				fAttemptedGetProcAddress    = false;

	/*
	 * validate input
	 */
	if (strHelpFile.IsEmpty())
		return (sc = E_FAIL);

	/*
	 * assume no redirection is required
	 */
	sc     = S_FALSE;
	langid = ENGLANGID;
	Trace (tagHelpCollection, _T("Checking for redirection of %s"), (LPCTSTR) strHelpFile);

	/*
	 * GetUser/SystemDefaultUILanguage are unsupported on systems < Win2K,
	 * so load them dynamically
	 */
    if (!fAttemptedGetProcAddress)
    {
        fAttemptedGetProcAddress = true;

        HMODULE hMod = GetModuleHandle (_T("kernel32.dll"));

        if (hMod)
		{
            GetUserDefaultUILanguage_   = (GetUILangFunc) GetProcAddress (hMod, "GetUserDefaultUILanguage");
            GetSystemDefaultUILanguage_ = (GetUILangFunc) GetProcAddress (hMod, "GetSystemDefaultUILanguage");
		}
    }

	/*
	 * if we couldn't load the MUI APIs, don't redirect
	 */
	if ((GetUserDefaultUILanguage_ == NULL) || (GetSystemDefaultUILanguage_ == NULL))
	{
		Trace (tagHelpCollection, _T("Couldn't load GetUser/SystemDefaultUILanguage, not redirecting"));
		return (sc);
	}

	/*
	 * find out what languages the system and user are using
	 */
	const LANGID langidUser   = GetUserDefaultUILanguage_();
	const LANGID langidSystem = GetSystemDefaultUILanguage_();

	/*
	 * we only redirect if we're running on MUI and MUI is always hosted on
	 * the US English release, so if the system UI language isn't US English,
	 * don't redirect
	 */
	if (langidSystem != ENGLANGID)
	{
		langid = langidSystem;
		Trace (tagHelpCollection, _T("System UI language is not US English (0x%04x), not redirecting"), langidSystem);
		return (sc);
	}

	/*
	 * if the user's language is US English, don't redirect
	 */
	if (langidUser == ENGLANGID)
	{
		Trace (tagHelpCollection, _T("User's UI language is US English, not redirecting"));
		return (sc);
	}

	/*
	 * the user's language is different from the default, see if we can
	 * find a help file that matches the user's UI langugae
	 */
	ASSERT (langidUser != langidSystem);
	WTL::CString strName;
	WTL::CString strPathPrefix;

	/*
	 * look for a path seperator to see if this is a fully qualified filename
	 */
	int iLastSep = strHelpFile.ReverseFind (_T('\\'));

	/*
	 * if it's fully qualified, construct a MUI directory name, e.g.
	 *
	 * 		<path>\mui\<langid>\<filename>
	 */
	if (iLastSep != -1)
	{
		strName       = strHelpFile.Mid  (iLastSep+1);
		strPathPrefix = strHelpFile.Left (iLastSep);
	}

	/*
	 * otherwise, it's not fully qualified, default to %SystemRoot%\Help, e.g.
	 *
	 * 		%SystemRoot%\Help\mui\<langid>\<filename>
	 */
	else
	{
		strName = strHelpFile;
		ExpandEnvironmentStrings (_T("%SystemRoot%\\Help"),
								  strPathPrefix.GetBuffer(MAX_PATH), MAX_PATH);
		strPathPrefix.ReleaseBuffer();
	}

	WTL::CString strRedirectedHelpFile;
	strRedirectedHelpFile.Format (_T("%s\\mui\\%04x\\%s"),
								  (LPCTSTR) strPathPrefix,
								  langidUser,
								  (LPCTSTR) strName);

	/*
	 * see if the redirected help file exists
	 */
	DWORD dwAttr = GetFileAttributes (strRedirectedHelpFile);

	if ((dwAttr == 0xFFFFFFFF) ||
		(dwAttr & (FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_OFFLINE)))
	{
#ifdef DBG
		Trace (tagHelpCollection, _T("Attempting redirection to %s, %s"),
			   (LPCTSTR) strRedirectedHelpFile,
			   (dwAttr == 0xFFFFFFFF)              ? _T("not found")		  :
			   (dwAttr & FILE_ATTRIBUTE_DIRECTORY) ? _T("found as directory") :
													 _T("file offline"));
#endif
		return (sc);
	}

	/*
	 * if we get here, we've found a help file that matches the user's UI
	 * language; return it and the UI language ID
	 */
	Trace (tagHelpCollection, _T("Help redirected to %s"), (LPCTSTR) strRedirectedHelpFile);
	strHelpFile = strRedirectedHelpFile;
	langid      = langidUser;

	/*
	 * we redirected, return S_OK
	 */
	return (sc = S_OK);
}


//-------------------------------------------------------------------------------
// Delete the current help file collection. First delete it as a collection, then
// delete the file itself. It is possible that the file doesn't exist when this
// is called, so it's not a failure if it can't be deleted.
//-------------------------------------------------------------------------------
void
CHelpDoc::DeleteHelpFile()
{
    // Delete existing help file
    HANDLE hFile = ::CreateFile(m_szFilePath, GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
                                  FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        ::CloseHandle(hFile);

        IHHCollectionWrapperPtr spOldCollection;
        spOldCollection.CreateInstance(CLSID_HHCollectionWrapper);

        USES_CONVERSION;

        WCHAR* pszFilePath = T2OLE(m_szFilePath);
        DWORD dwError = spOldCollection->Open(pszFilePath);
        if (dwError == 0)
            spOldCollection->RemoveCollection(FALSE);

        ::DeleteFile(m_szFilePath);
    }
}


//----------------------------------------------------------------------------
// Create a new help doc file for the current MMC console. This function
// enumerates all of the snap-in's used in the console and all their possible
// extension snap-ins. It queries each snap-in for a single help topic file and
// any linked help files. These files are added to a collection file which
// is then saved with the same base file name, creation time, and modification
// time as the console file.
//-----------------------------------------------------------------------------
HRESULT CHelpDoc::CreateHelpFile()
{
    USES_CONVERSION;

    HelpCollectionEntrySet HelpFiles;
    DWORD dwError;

    ASSERT(m_spCollection == NULL);
    m_spCollection.CreateInstance(CLSID_HHCollectionWrapper);
    ASSERT(m_spCollection != NULL);

    if (m_spCollection == NULL)
        return E_FAIL;

    HRESULT hr = CreateSnapInList();
    if (hr != S_OK)
        return hr;

    IMallocPtr spIMalloc;
    hr = CoGetMalloc(MEMCTX_TASK, &spIMalloc);
    ASSERT(hr == S_OK);
    if (hr != S_OK)
        return hr;

    // Delete existing file before rebuilding it, or help files will
    // be appended to the existing files
    DeleteHelpFile();

    // open new collection file
    WCHAR* pszFilePath = T2OLE(m_szFilePath);
    dwError = m_spCollection->Open(pszFilePath);
    ASSERT(dwError == 0);
    if (dwError != 0)
        return E_FAIL;

    // Have collection automatically find linked files
    m_spCollection->SetFindMergedCHMS(TRUE);

    AddFileToCollection(L"mmc", T2CW(SC::GetHelpFile()), TRUE);

    /*
     * Build a set of unique help files provided by the snap-ins
     */
    EntryPtrList::iterator it;
    for (it = m_entryList.begin(); it != m_entryList.end(); ++it)
    {
        TRACE(_T("Help snap-in: %s\n"), (*it)->second.c_str());

        USES_CONVERSION;
        HRESULT hr;

        OLECHAR szHelpFilePath[MAX_PATH];
        const CLSID& clsid = (*it)->first;

        // Create an instance of the snap-in to query
        IUnknownPtr spIUnknown;
        hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC, IID_IUnknown, (void**)&spIUnknown);
        if (FAILED(hr))
            continue;

        // use either ISnapinHelp or ISnapinHelp2 to get the main topic file
        ISnapinHelpPtr spIHelp = spIUnknown;
        ISnapinHelp2Ptr spIHelp2 = spIUnknown;

        if (spIHelp == NULL && spIHelp2 == NULL)
            continue;

        LPWSTR pszHelpFile = NULL;

        hr = (spIHelp2 != NULL) ? spIHelp2->GetHelpTopic(&pszHelpFile) :
                                  spIHelp->GetHelpTopic(&pszHelpFile);

        if (hr == S_OK)
        {
            /*
             * Put this help file in the collection entry set.  The
             * set will prevent duplicating help file names.
             */
            HelpFiles.insert (CHelpCollectionEntry (pszHelpFile, clsid));
            spIMalloc->Free(pszHelpFile);

            // if IsnapinHelp2, query for additional help files
            pszHelpFile = NULL;
            if (spIHelp2 == NULL ||
                spIHelp2->GetLinkedTopics(&pszHelpFile) != S_OK ||
                pszHelpFile == NULL)
                continue;

            // There may be multiple names separated by ';'s
            // Add each as a separate title.
            // Note: there is no call to AddFolder because linked files
            // do not appear in the TOC.
            WCHAR *pchStart = wcstok(pszHelpFile, L";");
            while (pchStart != NULL)
            {
                // Must use base file name as title ID
                WCHAR szTitleID[MAX_PATH];

                if (GetBaseFileName(pchStart, szTitleID, MAX_PATH))
                {
                    AddFileToCollection(szTitleID, pchStart, FALSE);
                }

                // position to start of next string
                pchStart = wcstok(NULL, L";");
            }

            spIMalloc->Free(pszHelpFile);
        }
    }

    /*
     * Put all of the help files provided by the snap-ins in the help collection.
     */
    HelpCollectionEntrySet::iterator itHelpFile;
    for (itHelpFile = HelpFiles.begin(); itHelpFile != HelpFiles.end(); ++itHelpFile)
    {
        const CHelpCollectionEntry& file = *itHelpFile;

        AddFileToCollection(file.m_strCLSID.c_str(), file.m_strHelpFile.c_str(), TRUE);
    }

    dwError = m_spCollection->Save();
    ASSERT(dwError == 0);

    dwError = m_spCollection->Close();
    ASSERT(dwError == 0);

    // Force creation/modify times to match the console file
    HANDLE hFile = ::CreateFile(m_szFilePath, GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL, NULL);
    ASSERT(hFile != INVALID_HANDLE_VALUE);

    if (hFile != INVALID_HANDLE_VALUE)
    {
        BOOL bStat = ::SetFileTime(hFile, &m_pDocInfo->m_ftimeCreate, NULL, &m_pDocInfo->m_ftimeModify);
        ASSERT(bStat);

        ::CloseHandle(hFile);

        ASSERT(IsHelpFileValid());
    }

    return S_OK;
}

//-----------------------------------------------------------------------------
// Determine if the current help doc file is valid. A help file is valid if it
// has the base file name, creation time, and modification time as the MMC
// console doc file.
//-----------------------------------------------------------------------------
BOOL CHelpDoc::IsHelpFileValid()
{
    // Try to open the help file
    HANDLE hFile = ::CreateFile(m_szFilePath, GENERIC_READ, 0, NULL, OPEN_EXISTING,
                                  FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE)
        return FALSE;

    // Check file creation and modification times
    FILETIME ftimeCreate;
    FILETIME ftimeModify;

    BOOL bStat = ::GetFileTime(hFile, &ftimeCreate, NULL, &ftimeModify);
    ASSERT(bStat);

    ::CloseHandle(hFile);

    return MatchFileTimes(ftimeCreate,m_pDocInfo->m_ftimeCreate) &&
           MatchFileTimes(ftimeModify,m_pDocInfo->m_ftimeModify);
}


//--------------------------------------------------------------------------
// If the current help doc file is valid then update its creation and
// modification times to match the new doc info.
//--------------------------------------------------------------------------
HRESULT CHelpDoc::UpdateHelpFile(HELPDOCINFO* pNewDocInfo)
{
    if (IsHelpFileValid())
    {
        HANDLE hFile = ::CreateFile(m_szFilePath, GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
                                  FILE_ATTRIBUTE_NORMAL, NULL);

        if (hFile == INVALID_HANDLE_VALUE)
            return E_FAIL;

        BOOL bStat = ::SetFileTime(hFile, &pNewDocInfo->m_ftimeCreate, NULL, &pNewDocInfo->m_ftimeModify);
        ASSERT(bStat);

        ::CloseHandle(hFile);
    }

    return S_OK;
}


//------------------------------------------------------------------------
// Delete the current help doc file
//------------------------------------------------------------------------
HRESULT CNodeCallback::OnDeleteHelpDoc(HELPDOCINFO* pCurDocInfo)
{
    CHelpDoc HelpDoc;

    HRESULT hr = HelpDoc.Initialize(pCurDocInfo);
    if (FAILED(hr))
        return hr;

    HelpDoc.DeleteHelpFile();

    return S_OK;
}


CHelpCollectionEntry::CHelpCollectionEntry(LPOLESTR pwzHelpFile, const CLSID& clsid)
{
    if (!IsPartOfString (m_strHelpFile, pwzHelpFile))
        m_strHelpFile.erase();  // see KB Q172398

    m_strHelpFile = pwzHelpFile;

    WCHAR szCLSID[40];
    StringFromGUID2 (clsid, szCLSID, countof(szCLSID));

    m_strCLSID.erase(); // see KB Q172398
    m_strCLSID = szCLSID;
}


// ----------------------------------------------------------------------
// CNodeCallack method implementation
// ----------------------------------------------------------------------

//------------------------------------------------------------------------
// Get the pathname of the help doc for an MMC console doc. If the current
// help doc is valid and there are no snap-in changes, return the current
// doc. Otherwise, create a new help doc and return it.
//------------------------------------------------------------------------
HRESULT CNodeCallback::OnGetHelpDoc(HELPDOCINFO* pHelpInfo, LPOLESTR* ppszHelpFile)
{
    CHelpDoc HelpDoc;

    HRESULT hr = HelpDoc.Initialize(pHelpInfo);
    if (FAILED(hr))
        return hr;

    CSnapInsCache* pSnapInsCache = theApp.GetSnapInsCache();
    ASSERT(pSnapInsCache != NULL);

    hr = S_OK;

    // Rebuild file if snap-in set changed or current file is not up to date
    if (pSnapInsCache->IsHelpCollectionDirty() || !HelpDoc.IsHelpFileValid())
    {
        hr = HelpDoc.CreateHelpFile();
    }

    // if ok, allocate and return file path string (OLESTR)
    if (SUCCEEDED(hr))
    {
        *ppszHelpFile = reinterpret_cast<LPOLESTR>
                     (CoTaskMemAlloc((lstrlen(HelpDoc.GetFilePath()) + 1) * sizeof(wchar_t)));

        if (*ppszHelpFile == NULL)
            return E_OUTOFMEMORY;

        USES_CONVERSION;
        wcscpy(*ppszHelpFile, T2COLE(HelpDoc.GetFilePath()));
    }

    return hr;
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::DoesStandardSnapinHelpExist
//
//  Synopsis:    Given the selection context, see if Standard MMC style help
//               exists (snapin implements ISnapinHelp[2] interface.
//               If not we wantto put "Help On <Snapin> which is MMC1.0 legacy
//               help mechanism.
//
//  Arguments:   [hNode]               - [in] the node selection context.
//               [bStandardHelpExists] - [out] Does standard help exists or not?
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
HRESULT
CNodeCallback::DoesStandardSnapinHelpExist(HNODE hNode, bool& bStandardHelpExists)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::OnHasHelpDoc"));
    sc = ScCheckPointers( (void*) hNode);
    if (sc)
        return sc.ToHr();

    CNode *pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers(pNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    bStandardHelpExists = false;

    // QI ComponentData for ISnapinHelp
    CMTNode* pMTNode = pNode->GetMTNode();
    sc = ScCheckPointers(pMTNode, E_UNEXPECTED);
    if(sc)
        return sc.ToHr();

    CComponentData* pCD = pMTNode->GetPrimaryComponentData();
    sc = ScCheckPointers(pCD, E_UNEXPECTED);
    if(sc)
        return sc.ToHr();

    IComponentData *pIComponentData = pCD->GetIComponentData();
    sc = ScCheckPointers(pIComponentData, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    ISnapinHelp* pIHelp = NULL;
    sc = pIComponentData->QueryInterface(IID_ISnapinHelp, (void**)&pIHelp);

    // if no ISnapinHelp, try ISnapinHelp2
    if (sc)
    {
        sc = pIComponentData->QueryInterface(IID_ISnapinHelp2, (void**)&pIHelp);
        if (sc)
        {
            // no ISnapinHelp2 either
            sc.Clear(); // not an error.
            return sc.ToHr();
        }
    }

    // make sure we got a valid pointer
    sc = ScCheckPointers(pIHelp, E_UNEXPECTED);
    if(sc)
    {
        sc.Clear();
        return sc.ToHr();
    }

    bStandardHelpExists = true;

    pIHelp->Release();

    return (sc).ToHr();
}

//-----------------------------------------------------------------------
// Update the current help doc file to match the new MMC console doc
//-----------------------------------------------------------------------
HRESULT CNodeCallback::OnUpdateHelpDoc(HELPDOCINFO* pCurDocInfo, HELPDOCINFO* pNewDocInfo)
{
    CHelpDoc HelpDoc;

    HRESULT hr = HelpDoc.Initialize(pCurDocInfo);
    if (FAILED(hr))
        return hr;

    return HelpDoc.UpdateHelpFile(pNewDocInfo);
}


BOOL GetBaseFileName(LPCWSTR pszFilePath, LPWSTR pszBaseName, int cBaseName)
{
    ASSERT(pszFilePath != NULL && pszBaseName != NULL);

    // Find last '\'
    LPCWSTR pszTemp = wcsrchr(pszFilePath, L'\\');

    // if no '\' found, find drive letter terminator':'
    if (pszTemp == NULL)
        pszTemp = wcsrchr(pszFilePath, L':');

    // if neither found, there is no path
    // else skip over last char of path
    if (pszTemp == NULL)
        pszTemp = pszFilePath;
    else
        pszTemp++;

    // find last '.' (assume that extension follows)
    WCHAR *pchExtn = wcsrchr(pszTemp, L'.');

    // How many chars excluding extension ?
    int cCnt = pchExtn ? (pchExtn - pszTemp) : wcslen(pszTemp);
    ASSERT(cBaseName > cCnt);
    if (cBaseName <= cCnt)
        return FALSE;

    // Copy to output buffer
    memcpy(pszBaseName, pszTemp, cCnt * sizeof(WCHAR));
    pszBaseName[cCnt] = L'\0';

    return TRUE;
}


//
// Compare two file times. Two file times are a match if they
// differ by no more than 2 seconds. This difference is allowed
// because a FAT file system stores times with a 2 sec resolution.
//
inline BOOL MatchFileTimes(FILETIME& ftime1, FILETIME& ftime2)
{
    // file system time resolution (2 sec) in 100's of nanosecs
    const static LONGLONG FileTimeResolution = 20000000;

    LONGLONG& ll1 = *(LONGLONG*)&ftime1;
    LONGLONG& ll2 = *(LONGLONG*)&ftime2;

    return (abs(ll1 - ll2) <= FileTimeResolution);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\fldrsnap.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999 - 1999
 *
 *  File:       fldrsnap.cpp
 *
 *  Contents:   Implementation file for built-in snapins that implement
 *              the Folder, ActiveX Control, and Web Link nodes.
 *                  These replace earlier code that had special "built-in"
 *              nodetypes.
 *
 *  History:    23-Jul-98 vivekj     Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "tstring.h"
#include "fldrsnap.h"
#include "imageid.h"
#include <comcat.h>             // COM Component Categoories Manager
#include "compcat.h"
#include "guids.h"
#include "regutil.h"

#include "newnode.h"

// These must now be the same - CMTNode::ScConvertLegacyNode depends on it.
#define SZ_OCXSTREAM  (L"ocx_streamorstorage")
#define SZ_OCXSTORAGE (L"ocx_streamorstorage")


/*+-------------------------------------------------------------------------*
 *
 * ScLoadAndAllocateString
 *
 * PURPOSE: Loads the string specified by the string ID and returns a string
 *          whose storage has been allocated by CoTaskMemAlloc.
 *
 * PARAMETERS:
 *    UINT       ids :
 *    LPOLESTR * lpstrOut :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
ScLoadAndAllocateString(UINT ids, LPOLESTR *lpstrOut)
{
    DECLARE_SC(sc, TEXT("ScLoadAndAllocateString"));

    sc = ScCheckPointers(lpstrOut);
    if(sc)
        return sc.ToHr();

    USES_CONVERSION;
    CStr str;

    str.LoadString(GetStringModule(), ids);

    *lpstrOut = (LPOLESTR) CoTaskMemAlloc( (str.GetLength() +1) *sizeof(OLECHAR) );
    if(*lpstrOut)
        wcscpy(*lpstrOut, T2CW(str));
    else
        sc = E_OUTOFMEMORY;

    return sc.ToHr();
}


//############################################################################
//############################################################################
//
//  Implementation of class CSnapinDescriptor
//
//############################################################################
//############################################################################
/*+-------------------------------------------------------------------------*
 *
 * CSnapinDescriptor::CSnapinDescriptor
 *
 * PURPOSE: Constructor
 *
 *+-------------------------------------------------------------------------*/
CSnapinDescriptor::CSnapinDescriptor()
: m_idsName(0), m_idsDescription(0), m_idiSnapinImage(0), m_idbSmallImage(0), m_idbSmallImageOpen(0),
  m_idbLargeImage(0), m_clsidSnapin(GUID_NULL), m_szClsidSnapin(TEXT("")),
  m_guidNodetype(GUID_NULL), m_szGuidNodetype(TEXT("")), m_szClassName(TEXT("")),
  m_szProgID(TEXT("")), m_szVersionIndependentProgID(TEXT("")), m_viewOptions(0)
{
}

CSnapinDescriptor::CSnapinDescriptor(UINT idsName, UINT idsDescription, UINT idiSnapinImage,
                                     UINT idbSmallImage,UINT idbSmallImageOpen, UINT idbLargeImage,
                                       const CLSID &clsidSnapin, LPCTSTR szClsidSnapin,
                                       const GUID &guidNodetype, LPCTSTR szGuidNodetype,
                                       LPCTSTR szClassName, LPCTSTR szProgID,
                                       LPCTSTR szVersionIndependentProgID,
                                       long viewOptions)

: m_idsName(idsName), m_idsDescription(idsDescription), m_idiSnapinImage(idiSnapinImage),
  m_idbSmallImage(idbSmallImage), m_idbSmallImageOpen(idbSmallImageOpen),
  m_idbLargeImage(idbLargeImage), m_clsidSnapin(clsidSnapin), m_szClsidSnapin(szClsidSnapin),
  m_guidNodetype(guidNodetype), m_szGuidNodetype(szGuidNodetype), m_szClassName(szClassName),
  m_szProgID(szProgID), m_szVersionIndependentProgID(szVersionIndependentProgID),
  m_viewOptions(viewOptions)
{
}


/*+-------------------------------------------------------------------------*
 * ScFormatIndirectSnapInName
 *
 * Returns the name of the snap-in in the indirect form supported by
 * SHLoadRegUIString:
 *
 *		@<dllname>,-<strId>
 *--------------------------------------------------------------------------*/

SC ScFormatIndirectSnapInName (
	HINSTANCE	hInst,					/* I:module containing the resource	*/
	int			idNameString,			/* I:ID of name's string resource	*/
	CStr&		strName)				/* O:formatted indirect name string	*/
{
	DECLARE_SC (sc, _T("ScFormatIndirectSnapInName"));

	/*
	 * allocate a buffer for GetModuleFileName
	 */
	const int cbBuffer = MAX_PATH;
	WTL::CString strStringModule;
	LPTSTR pBuffer = strStringModule.GetBuffer (cbBuffer);

	/*
	 * if we couldn't allocate a buffer, return an error
	 */
	if (pBuffer == NULL)
		return (sc = E_OUTOFMEMORY);

	/*
	 * get the name of the module that provides strings
	 */
	const DWORD cbCopied = GetModuleFileName (hInst, pBuffer, cbBuffer);
	strStringModule.ReleaseBuffer();

	/*
	 * if GetModuleFileName failed, return its failure code
	 */
	if (cbCopied == 0)
	{
		sc.FromLastError();

		/*
		 * just in case GetModuleFileName didn't set the last error, make
		 * sure the SC contains some kind of failure code
		 */
		if (!sc.IsError())
			sc = E_FAIL;

		return (sc);
	}

	/*
	 * if a path is present, SHLoadRegUIString won't search for the DLL
	 * based on the current UI language; remove the path portion of the
	 * module name so it will
	 */
	int nLastPathSep = strStringModule.ReverseFind (_T('\\'));
	if (nLastPathSep != -1)
		strStringModule = strStringModule.Mid (nLastPathSep + 1);

	/*
	 * format the name the way SHLoadRegUIString expects it
	 */
	strStringModule.MakeLower();
	strName.Format (_T("@%s,-%d"), (LPCTSTR) strStringModule, idNameString);

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CSnapinDescriptor::GetRegisteredIndirectName
 *
 * Returns the name of the snap-in in the indirect form supported by
 * SHLoadRegUIString:
 *
 *		@<dllname>,-<strId>
 *--------------------------------------------------------------------------*/

void
CSnapinDescriptor::GetRegisteredIndirectName(CStr &strIndirectName)
{
	DECLARE_SC (sc, _T("CSnapinDescriptor::GetRegisteredIndirectName"));

	sc = ScFormatIndirectSnapInName (GetStringModule(), m_idsName, strIndirectName);
	if (sc)
		sc.TraceAndClear();
}


/*+-------------------------------------------------------------------------*
 * CSnapinDescriptor::GetRegisteredDefaultName
 *
 * Returns the name of the snap-in in the indirect form supported by
 * SHLoadRegUIString:
 *
 *		@<dllname>,-<strId>
 *--------------------------------------------------------------------------*/

void
CSnapinDescriptor::GetRegisteredDefaultName(CStr &str)
{
	str.LoadString (GetStringModule(), m_idsName);
}


/*+-------------------------------------------------------------------------*
 * CSnapinDescriptor::GetName
 *
 * Returns the human-readable name of the snap-in.
 *--------------------------------------------------------------------------*/

void
CSnapinDescriptor::GetName(CStr &str)
{
	DECLARE_SC (sc, _T("CSnapinDescriptor::GetName"));

	/*
	 * get the name from the registry
	 */
	sc = ScGetSnapinNameFromRegistry (m_szClsidSnapin, str);
	if (sc)
		sc.TraceAndClear();
}

HBITMAP
CSnapinDescriptor::GetSmallImage()
{
    WTL::CBitmap bmp;
    bmp.LoadBitmap(MAKEINTRESOURCE(m_idbSmallImage));
    return (bmp.Detach());
}

HBITMAP
CSnapinDescriptor::GetSmallImageOpen()
{
    WTL::CBitmap bmp;
    bmp.LoadBitmap(MAKEINTRESOURCE(m_idbSmallImageOpen));
    return (bmp.Detach());
}

HBITMAP
CSnapinDescriptor::GetLargeImage()
{
    WTL::CBitmap bmp;
    bmp.LoadBitmap(MAKEINTRESOURCE(m_idbLargeImage));
    return (bmp.Detach());
}

HICON
CSnapinDescriptor::GetSnapinImage()
{
    return LoadIcon( _Module.GetModuleInstance(), MAKEINTRESOURCE(m_idiSnapinImage));
}


long
CSnapinDescriptor::GetViewOptions()
{
    return m_viewOptions;
}

//############################################################################
//############################################################################
//
//  Implementation of class CSnapinComponentDataImpl
//
//############################################################################
//############################################################################
/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentDataImpl::CSnapinComponentDataImpl
 *
 * PURPOSE: Constructor
 *
 *+-------------------------------------------------------------------------*/
CSnapinComponentDataImpl::CSnapinComponentDataImpl()
: m_bDirty(false)
{
}


void
CSnapinComponentDataImpl::SetName(LPCTSTR sz)
{
    m_strName = sz;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentDataImpl::SetView
 *
 * PURPOSE: Sets the view.
 *
 * PARAMETERS:
 *    LPCTSTR  sz :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CSnapinComponentDataImpl::SetView(LPCTSTR sz)
{
    m_strView = sz;
}


STDMETHODIMP
CSnapinComponentDataImpl::Initialize(LPUNKNOWN pUnknown)
{
    m_spConsole2          = pUnknown;
    m_spConsoleNameSpace2 = pUnknown;

    return S_OK;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentDataImpl::Notify
 *
 * PURPOSE:  Notification handler for the IComponentData implementation.
 *
 * PARAMETERS:
 *    LPDATAOBJECT     lpDataObject : As per MMC docs.
 *    MMC_NOTIFY_TYPE  event :
 *    LPARAM           arg :
 *    LPARAM           param :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CSnapinComponentDataImpl::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event,
               LPARAM arg, LPARAM param)
{
    USES_CONVERSION;

    switch(event)
    {

    case MMCN_RENAME: // the root node is being renamed
        m_strName = OLE2T((LPOLESTR)param);
        SetDirty();
        return S_OK;

    case MMCN_PRELOAD:
        return OnPreload((HSCOPEITEM) arg);
    }

    return S_FALSE;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentDataImpl::OnPreload
 *
 * PURPOSE: sets the icon of the root node (which is the only node.)
 *
 * PARAMETERS:
 *    HSCOPEITEM  scopeItem :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CSnapinComponentDataImpl::OnPreload(HSCOPEITEM scopeItem)
{
    SCOPEDATAITEM item;
    ZeroMemory (&item, sizeof(SCOPEDATAITEM));
    item.mask           = SDI_CHILDREN;
    item.ID             = scopeItem;
    item.cChildren      = 0; // make sure no "+" sign is displayed.

    m_spConsoleNameSpace2->SetItem (&item);

    return S_OK;
}


/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentDataImpl::Destroy
 *
 * PURPOSE: Gives up all references to MMC.
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CSnapinComponentDataImpl::Destroy()
{
    m_spConsole2          = NULL;
    m_spConsoleNameSpace2 = NULL;
    return S_OK;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentDataImpl::QueryDataObject
 *
 * PURPOSE: Returns a data object for the specified node.
 *
 * PARAMETERS:
 *    MMC_COOKIE         cookie : NULL for the root node.
 *    DATA_OBJECT_TYPES  type :
 *    LPDATAOBJECT*      ppDataObject :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CSnapinComponentDataImpl::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                                          LPDATAOBJECT* ppDataObject)
{
    ASSERT(cookie == NULL);
    if(cookie != NULL)
        return E_UNEXPECTED;

    CComObject<CSnapinDataObject> * pDataObject;
    CComObject<CSnapinDataObject>::CreateInstance(&pDataObject);
    if(pDataObject == NULL)
        return E_UNEXPECTED;

    pDataObject->Initialize(this, type);

    return pDataObject->QueryInterface(IID_IDataObject, (void**)ppDataObject);
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentDataImpl::GetDisplayInfo
 *
 * PURPOSE: Gets the display info for the root (the only) node.
 *
 * PARAMETERS:
 *    SCOPEDATAITEM* pScopeDataItem : [IN/OUT]: The structure to fill in
 *                  based on the mask value.
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CSnapinComponentDataImpl::GetDisplayInfo( SCOPEDATAITEM* pScopeDataItem)
{
    SCOPEDATAITEM &sdi = *pScopeDataItem;
    DWORD mask = sdi.mask;

    if(mask & SDI_STR)
    {
        sdi.displayname = (LPOLESTR) GetName();
    }
    if(mask & SDI_IMAGE)
    {
        sdi.nImage     = m_iImage;
    }
    if(mask & SDI_OPENIMAGE)
    {
        sdi.nImage = m_iOpenImage;
    }
    if(mask & SDI_STATE)
    {
    }
    if(mask & SDI_CHILDREN)
    {
        sdi.cChildren =0;
    }

    return S_OK;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentDataImpl::CompareObjects
 *
 * PURPOSE: Determines whether two data objects correspond to the same
 *          underlying object.
 *
 * PARAMETERS:
 *    LPDATAOBJECT  lpDataObjectA :
 *    LPDATAOBJECT  lpDataObjectB :
 *
 * RETURNS:
 *    STDMETHODIMP : S_OK if they correspond to the same object, else S_FALSE.
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CSnapinComponentDataImpl::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    return (lpDataObjectA == lpDataObjectB) ? S_OK : S_FALSE;
}


// IPersistStream
/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentDataImpl::GetClassID
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    CLSID * pClassID :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CSnapinComponentDataImpl::GetClassID(CLSID *pClassID)
{
    return E_NOTIMPL;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentDataImpl::IsDirty
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    voi d :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CSnapinComponentDataImpl::IsDirty(void)
{
    TraceDirtyFlag(TEXT("CSnapinComponentDataImpl (MMC Built-in snapin)"), m_bDirty);

    return m_bDirty ? S_OK : S_FALSE;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentDataImpl::Load
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    LPSTREAM  pStm :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CSnapinComponentDataImpl::Load(LPSTREAM pStm)
{
    return CSerialObject::Read(*pStm);
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentDataImpl::Save
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    LPSTREAM  pStm :
 *    BOOL      fClearDirty :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CSnapinComponentDataImpl::Save(LPSTREAM pStm , BOOL fClearDirty)
{
    HRESULT hr = CSerialObjectRW::Write(*pStm);
    if (SUCCEEDED(hr) && fClearDirty)
        SetDirty(FALSE);

    return hr;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentDataImpl::GetSizeMax
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    ULARGE_INTEGER* pcbSize :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CSnapinComponentDataImpl::GetSizeMax(ULARGE_INTEGER* pcbSize  )
{
    return E_NOTIMPL;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentDataImpl::GetWatermarks
 *
 * PURPOSE: Sets the header for the wizard
 *
 * PARAMETERS:
 *    LPDATAOBJECT  lpIDataObject :
 *    HBITMAP *     lphWatermark :
 *    HBITMAP *     lphHeader :
 *    HPALETTE *    lphPalette :
 *    BOOL*         bStretch :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CSnapinComponentDataImpl::GetWatermarks(LPDATAOBJECT lpIDataObject, HBITMAP * lphWatermark, HBITMAP * lphHeader, HPALETTE * lphPalette,  BOOL* bStretch)
{
    DECLARE_SC(sc, TEXT("COCXSnapinData::ScGetWatermarks"));

    // validate inputs
    sc = ScCheckPointers(lpIDataObject, lphWatermark, lphHeader, lphPalette);
    if(sc)
        return sc.ToHr();

    // initialize outputs
    *lphWatermark = GetWatermark() ? ::LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(GetWatermark()))
                                      : NULL;
    // if there is a header, use it.
    *lphHeader    = GetHeaderBitmap() ? ::LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(GetHeaderBitmap()))
                                      : NULL;
    *lphPalette   = NULL;

    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentDataImpl::QueryPagesFor
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    LPDATAOBJECT  lpDataObject :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CSnapinComponentDataImpl::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
    CSnapinDataObject *pDataObject = dynamic_cast<CSnapinDataObject *>(lpDataObject);
    if(pDataObject == NULL)
        return E_UNEXPECTED;


    if(pDataObject->GetType() != CCT_SNAPIN_MANAGER)
        return S_FALSE;

    return S_OK; // properties exist only in the snap-in manager.
}


/*+-------------------------------------------------------------------------*
 * CSnapinComponentDataImpl::GetHelpTopic
 *
 * Default implementation of ISnapinHelp::GetHelpTopic for built-in snap-
 * ins (folder, OCX, web page).
 *
 * We need to implement ISnapinHelp in the built-ins to avoid getting
 * "Help for <snap-in>" on the Help menu (bug 453700).  They don't really
 * have help info, so we simply return S_FALSE so the help engine doesn't
 * complain.
 *--------------------------------------------------------------------------*/

STDMETHODIMP CSnapinComponentDataImpl::GetHelpTopic (
    LPOLESTR*   /*ppszCompiledHelpTopic*/)
{
    return (S_FALSE);       // no help topic
}



// CSerialObject methods
/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentDataImpl::ReadSerialObject
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    IStream & stm :
 *    UINT      nVersion :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CSnapinComponentDataImpl::ReadSerialObject (IStream &stm, UINT nVersion)
{
    if(nVersion==1)
    {
        stm >> m_strName;
        stm >> m_strView;
        return S_OK;
    }
    else
        return S_FALSE; //unknown version, skip.
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentDataImpl::WriteSerialObject
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    IStream & stm :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CSnapinComponentDataImpl::WriteSerialObject(IStream &stm)
{
    stm << m_strName;
    stm << m_strView;
    return S_OK;
}


//############################################################################
//############################################################################
//
//  Implementation of class CSnapinComponentImpl
//
//############################################################################
//############################################################################

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentImpl::Init
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    IComponentData * pComponentData :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CSnapinComponentImpl::Init(IComponentData *pComponentData)
{
    m_spComponentData = pComponentData;
}


// IComponent
/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentImpl::Initialize
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    LPCONSOLE  lpConsole :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CSnapinComponentImpl::Initialize(LPCONSOLE lpConsole)
{
    m_spConsole2 = lpConsole;
    return S_OK;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentImpl::Notify
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    LPDATAOBJECT     lpDataObject :
 *    MMC_NOTIFY_TYPE  event :
 *    LPARAM           arg :
 *    LPARAM           param :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CSnapinComponentImpl::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event,
                             LPARAM arg, LPARAM param)
{
    switch(event)
    {
    case MMCN_SELECT:
        {
            BOOL bScope  = (BOOL) LOWORD(arg);
            BOOL bSelect = (BOOL) HIWORD(arg);

            SC sc = ScOnSelect(bScope, bSelect);
            if(sc)
                return sc.ToHr();
        }
        return S_OK;
        break;


    default:
        break;

    }
    return S_FALSE;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentImpl::ScOnSelect
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    BOOL  bScope :
 *    BOOL  bSelect :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CSnapinComponentImpl::ScOnSelect(BOOL bScope, BOOL bSelect)
{
    DECLARE_SC(sc, TEXT("CSnapinComponentImpl::ScOnSelect"));

    IConsoleVerbPtr spConsoleVerb;
    sc = m_spConsole2->QueryConsoleVerb(&spConsoleVerb);
    if(sc)
        return sc;

    sc = spConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, (bSelect && bScope));
    if(sc)
        return sc;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentImpl::Destroy
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    MMC_COOKIE  cookie :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CSnapinComponentImpl::Destroy(MMC_COOKIE cookie)
{
    m_spConsole2 = NULL;
    m_spComponentData = NULL;
    return S_OK;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentImpl::QueryDataObject
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    MMC_COOKIE         cookie :
 *    DATA_OBJECT_TYPES  type :
 *    LPDATAOBJECT*      ppDataObject :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CSnapinComponentImpl::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                                      LPDATAOBJECT* ppDataObject)
{
    return E_NOTIMPL;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentImpl::GetComponentData
 *
 * PURPOSE:
 *
 * RETURNS:
 *    CSnapinComponentDataImpl *
 *
 *+-------------------------------------------------------------------------*/
CSnapinComponentDataImpl *
CSnapinComponentImpl::GetComponentData()
{
    CSnapinComponentDataImpl *pCD = dynamic_cast<CSnapinComponentDataImpl *>(m_spComponentData.GetInterfacePtr());

    ASSERT(pCD != NULL);
    return pCD;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentImpl::GetResultViewType
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    MMC_COOKIE  cookie :
 *    LPOLESTR*   ppViewType :
 *    long*       pViewOptions : Set to MMC_VIEW_OPTIONS_NOLISTVIEWS  for the HTML and OCX snapins,
 *                               0 for the folder snapin.
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CSnapinComponentImpl::GetResultViewType(MMC_COOKIE cookie, LPOLESTR* ppViewType,
                                        long* pViewOptions)
{
    // check parameters
    if(!ppViewType || !pViewOptions)
        return E_UNEXPECTED;

    if(!GetComponentData())
        return E_UNEXPECTED;

    USES_CONVERSION;
    *ppViewType = (LPOLESTR)CoTaskMemAlloc( (_tcslen(GetComponentData()->GetView())+1) * sizeof(OLECHAR) );
    *pViewOptions = GetComponentData()->GetDescriptor().GetViewOptions();
    wcscpy(*ppViewType, T2OLE((LPTSTR)GetComponentData()->GetView()));
    return S_OK;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentImpl::GetDisplayInfo
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    RESULTDATAITEM* pResultDataItem :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CSnapinComponentImpl::GetDisplayInfo( RESULTDATAITEM*  pResultDataItem)
{
    RESULTDATAITEM &rdi = *pResultDataItem;
    DWORD mask = rdi.mask;

    if(mask & RDI_STR)
    {
        rdi.str = (LPOLESTR) GetComponentData()->GetName();
    }
    if(mask & RDI_IMAGE)
    {
        rdi.nImage  = GetComponentData()->m_iImage;
    }

    return S_OK;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinComponentImpl::CompareObjects
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    LPDATAOBJECT  lpDataObjectA :
 *    LPDATAOBJECT  lpDataObjectB :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CSnapinComponentImpl::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    return E_NOTIMPL;
}

//############################################################################
//############################################################################
//
//  Implementation of class CSnapinDataObject
//
//############################################################################
//############################################################################
// Clipboard formats that are required by the console
UINT CSnapinDataObject::s_cfNodeType;
UINT CSnapinDataObject::s_cfNodeTypeString;
UINT CSnapinDataObject::s_cfDisplayName;
UINT CSnapinDataObject::s_cfCoClass;
UINT CSnapinDataObject::s_cfSnapinPreloads;

/*+-------------------------------------------------------------------------*
 *
 * CSnapinDataObject::RegisterClipboardFormats
 *
 * PURPOSE:
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CSnapinDataObject::RegisterClipboardFormats()
{
    static bool bRegistered = false;
    if(!bRegistered)
    {
        USES_CONVERSION;

        CSnapinDataObject::s_cfNodeType       = RegisterClipboardFormat(OLE2T(CCF_NODETYPE));
        CSnapinDataObject::s_cfNodeTypeString = RegisterClipboardFormat(OLE2T(CCF_SZNODETYPE));
        CSnapinDataObject::s_cfDisplayName    = RegisterClipboardFormat(OLE2T(CCF_DISPLAY_NAME));
        CSnapinDataObject::s_cfCoClass        = RegisterClipboardFormat(OLE2T(CCF_SNAPIN_CLASSID));
        CSnapinDataObject::s_cfSnapinPreloads = RegisterClipboardFormat(OLE2T(CCF_SNAPIN_PRELOADS));

        bRegistered = true;
    }
}

CSnapinDataObject::CSnapinDataObject() : m_bInitialized(false)
{
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinDataObject::GetDataHere
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    FORMATETC * pformatetc :
 *    STGMEDIUM * pmedium :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CSnapinDataObject::GetDataHere(FORMATETC *pformatetc, STGMEDIUM *pmedium)
{
    DECLARE_SC(sc, TEXT("CSnapinDataObject::GetDataHere"));

    // validate inputs
    sc = ScCheckPointers(pformatetc, pmedium);
    if(sc)
        return sc.ToHr();

    USES_CONVERSION;
    RegisterClipboardFormats();

    // Based on the CLIPFORMAT write data to the stream
    const CLIPFORMAT cf = pformatetc->cfFormat;

    // ensure the medium is an HGLOBAL
    if(pformatetc->tymed != TYMED_HGLOBAL)
        return (sc = DV_E_TYMED).ToHr();

    IStreamPtr spStream;
    HGLOBAL hGlobal = pmedium->hGlobal;

    pmedium->pUnkForRelease = NULL;      // by OLE spec

    sc = CreateStreamOnHGlobal( hGlobal, FALSE, &spStream );
    if(sc)
        return sc.ToHr();

    CSnapinComponentDataImpl *pComponentDataImpl =
        dynamic_cast<CSnapinComponentDataImpl *>(m_spComponentData.GetInterfacePtr());
    ASSERT(pComponentDataImpl != NULL);

    if (cf == s_cfNodeType)
    {
        spStream<<pComponentDataImpl->GetDescriptor().m_guidNodetype;
    }
    else if (cf == s_cfCoClass)
    {
        spStream<<pComponentDataImpl->GetDescriptor().m_clsidSnapin;
    }
    else if(cf == s_cfNodeTypeString)
    {
        WriteString(spStream, T2OLE((LPTSTR)pComponentDataImpl->GetDescriptor().m_szGuidNodetype));
    }
    else if (cf == s_cfDisplayName)
    {
        WriteString(spStream, T2OLE((LPTSTR)pComponentDataImpl->GetName()));
    }
    else if (cf == s_cfSnapinPreloads)
    {
        BOOL bPreload = true;
        spStream->Write ((void *)&bPreload, sizeof(BOOL), NULL);
    }
    else
    {
        return (sc = DV_E_CLIPFORMAT).ToHr(); // invalid format.
    }

    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinDataObject::WriteString
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    IStream *  pStream :
 *    LPCOLESTR  sz :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CSnapinDataObject::WriteString(IStream *pStream, LPCOLESTR sz)
{
    HRESULT hr = S_OK;
    ASSERT(pStream != NULL);
    if(pStream == NULL)
    {
        //TraceError(TEXT("CSnapinDataObject::WriteString"));
        return E_UNEXPECTED;
    }

    UINT cbToWrite = wcslen(sz)*sizeof(WCHAR);
    ULONG cbActuallyWritten=0;
    hr = pStream->Write (sz, cbToWrite, &cbActuallyWritten);
    ASSERT(cbToWrite==cbActuallyWritten);
    return hr;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinDataObject::Initialize
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    IComponentData *   pComponentData :
 *    DATA_OBJECT_TYPES  type :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CSnapinDataObject::Initialize(IComponentData *pComponentData, DATA_OBJECT_TYPES type)
{
    ASSERT(pComponentData != NULL);
    m_spComponentData = pComponentData;
    m_type            = type;
    m_bInitialized    = true;
}

//############################################################################
//############################################################################
//
//  Implementation of class CFolderSnapinData
//
//############################################################################
//############################################################################
STDMETHODIMP
CFolderSnapinData::CreateComponent(LPCOMPONENT* ppComponent)
{
    typedef CComObject<CFolderSnapinComponent> CComponent;
    CComponent *    pComponent = NULL;
    CComObject<CFolderSnapinComponent>::CreateInstance(&pComponent);
    ASSERT(pComponent != NULL);
    if(pComponent == NULL)
    {
        //TraceError(TEXT("CFolderSnapinData::CreateComponent"));
        return E_UNEXPECTED;
    }

    pComponent->Init(this);

    return pComponent->QueryInterface(IID_IComponent, (void **)ppComponent); // does the Addref.
}


CFolderSnapinData::CFolderSnapinData()
{
    m_iImage     = eStockImage_Folder;
    m_iOpenImage = eStockImage_OpenFolder;
}


const CLSID       CLSID_FolderSnapin         = {0xC96401CC, 0x0E17,0x11D3, {0x88,0x5B,0x00,0xC0,0x4F,0x72,0xC7,0x17}};
static const GUID GUID_FolderSnapinNodetype  = {0xc96401ce, 0xe17, 0x11d3, { 0x88, 0x5b, 0x0, 0xc0, 0x4f, 0x72, 0xc7, 0x17 } };
static LPCTSTR szClsid_FolderSnapin          = TEXT("{C96401CC-0E17-11D3-885B-00C04F72C717}");
static LPCTSTR szGuidFolderSnapinNodetype    = TEXT("{C96401CE-0E17-11D3-885B-00C04F72C717}");


CSnapinDescriptor &
CFolderSnapinData::GetSnapinDescriptor()
{
    static CSnapinDescriptor snapinDescription(IDS_FOLDER,
                   IDS_FOLDERSNAPIN_DESC, IDI_FOLDER, IDB_FOLDER_16, IDB_FOLDEROPEN_16, IDB_FOLDER_32,
                   CLSID_FolderSnapin, szClsid_FolderSnapin, GUID_FolderSnapinNodetype,
                   szGuidFolderSnapinNodetype, TEXT("Folder"), TEXT("Snapins.FolderSnapin"),
                   TEXT("Snapins.FolderSnapin.1"), 0 /*viewOptions*/ );
    return snapinDescription;
}

// IExtendPropertySheet2
STDMETHODIMP
CFolderSnapinData::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, LONG_PTR handle, LPDATAOBJECT lpIDataObject)
{
    return S_FALSE;
}

//############################################################################
//############################################################################
//
//  Implementation of class CHTMLSnapinData
//
//############################################################################
//############################################################################
STDMETHODIMP
CHTMLSnapinData::CreateComponent(LPCOMPONENT* ppComponent)
{
    typedef CComObject<CHTMLSnapinComponent> CComponent;
    CComponent *    pComponent = NULL;
    CComObject<CHTMLSnapinComponent>::CreateInstance(&pComponent);
    ASSERT(pComponent != NULL);
    if(pComponent == NULL)
    {
        //TraceError(TEXT("CHTMLSnapinData::CreateComponent"));
        return E_UNEXPECTED;
    }

    pComponent->Init(this);

    return pComponent->QueryInterface(IID_IComponent, (void **)ppComponent); // does the Addref.
}


CHTMLSnapinData::CHTMLSnapinData()
{
    m_pHtmlPage1 = NULL;
    m_pHtmlPage2 = NULL;
    m_iImage     = eStockImage_HTML;
    m_iOpenImage = eStockImage_HTML;
}

CHTMLSnapinData::~CHTMLSnapinData()
{
}

STDMETHODIMP
CHTMLSnapinData::Destroy()
{
    if(m_pHtmlPage1 != NULL)
    {
        delete m_pHtmlPage1;
        m_pHtmlPage1 = NULL;
    }
    if(m_pHtmlPage2 != NULL)
    {
        delete m_pHtmlPage2;
        m_pHtmlPage2 = NULL;
    }

    return BC::Destroy();
}



const CLSID       CLSID_HTMLSnapin         = {0xC96401D1, 0x0E17,0x11D3, {0x88,0x5B,0x00,0xC0,0x4F,0x72,0xC7,0x17}};
static const GUID GUID_HTMLSnapinNodetype  = {0xc96401d2, 0xe17, 0x11d3, { 0x88, 0x5b, 0x0, 0xc0, 0x4f, 0x72, 0xc7, 0x17 } };
static LPCTSTR szClsid_HTMLSnapin          = TEXT("{C96401D1-0E17-11D3-885B-00C04F72C717}");
static LPCTSTR szGuidHTMLSnapinNodetype    = TEXT("{C96401D2-0E17-11D3-885B-00C04F72C717}");


CSnapinDescriptor &
CHTMLSnapinData::GetSnapinDescriptor()
{
    static CSnapinDescriptor snapinDescription(IDS_HTML,
                   IDS_HTMLSNAPIN_DESC, IDI_HTML, IDB_HTML_16, IDB_HTML_16, IDB_HTML_32,
                   CLSID_HTMLSnapin, szClsid_HTMLSnapin, GUID_HTMLSnapinNodetype,
                   szGuidHTMLSnapinNodetype, TEXT("HTML"), TEXT("Snapins.HTMLSnapin"),
                   TEXT("Snapins.HTMLSnapin.1"), MMC_VIEW_OPTIONS_NOLISTVIEWS  /*viewOptions*/ );
    return snapinDescription;
}

// IExtendPropertySheet2

/*+-------------------------------------------------------------------------*
 *
 * CHTMLSnapinData::CreatePropertyPages
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    LPPROPERTYSHEETCALLBACK  lpProvider :
 *    LONG_PTR                 handle :
 *    LPDATAOBJECT             lpIDataObject :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CHTMLSnapinData::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, LONG_PTR handle, LPDATAOBJECT lpIDataObject)
{
    HPROPSHEETPAGE hPage;

    ASSERT(lpProvider != NULL);
    if(lpProvider == NULL)
    {
        //TraceError(TEXT("CHTMLSnapinData::CreatePropertyPages"));
        return E_UNEXPECTED;
    }

    ASSERT(m_pHtmlPage1 == NULL);
    ASSERT(m_pHtmlPage2 == NULL);

    // create property pages
    m_pHtmlPage1 = new CHTMLPage1;
    m_pHtmlPage2 = new CHTMLPage2;

    // pass in pointer to data structure
    m_pHtmlPage1->Initialize(this);
    m_pHtmlPage2->Initialize(this);

    // Add Pages to property sheet
    hPage=CreatePropertySheetPage(&m_pHtmlPage1->m_psp);
    lpProvider->AddPage(hPage);

    hPage=CreatePropertySheetPage(&m_pHtmlPage2->m_psp);
    lpProvider->AddPage(hPage);

    return S_OK;
}


//############################################################################
//############################################################################
//
//  Implementation of class CHTMLSnapinComponent
//
//############################################################################
//############################################################################
/*+-------------------------------------------------------------------------*
 *
 * CHTMLSnapinComponent::ScOnSelect
 *
 * PURPOSE: Handles the MMCN_SELECT notification. Enables the Refresh verb,
 *          which uses the default MMC handler to refresh the page.
 *
 * PARAMETERS:
 *    BOOL  bScope :
 *    BOOL  bSelect :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CHTMLSnapinComponent::ScOnSelect(BOOL bScope, BOOL bSelect)
{
    DECLARE_SC(sc, TEXT("CHTMLSnapinComponent::ScOnSelect"));

    // call the base class method
    sc = BC::ScOnSelect(bScope, bSelect);
    if(sc)
        return sc;

    IConsoleVerbPtr spConsoleVerb;

    sc = ScCheckPointers(m_spConsole2, E_UNEXPECTED);
    if(sc)
        return sc;

    sc = m_spConsole2->QueryConsoleVerb(&spConsoleVerb);
    if(sc)
        return sc;

    sc = ScCheckPointers(spConsoleVerb, E_UNEXPECTED);
    if(sc)
        return sc;

    // enable the Refresh verb - the default MMC handler is adequate to refresh the page.
    sc = spConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, (bSelect && bScope));
    if(sc)
        return sc;

    //NOTE: (vivekj): I'm intentionally not setting the HIDDEN state to false here, because
    // we have an explicit test in our verb code for MMC1.0 snapins that wrote code like this,
    // and this provides a useful compatibility test.

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CHTMLSnapinComponent::GetResultViewType
 *
 * PURPOSE: Performs parameter substitution on the URL for the environment variables
 *          %windir% and %systemroot% (only) and returns the expanded URL.
 *
 * NOTE:    We don't expand ALL variables using ExpandEnvironmentString. Doing so could
 *          break compatibility with URL's that have %var% but DON'T want to be
 *          expanded.
 *
 * PARAMETERS:
 *    MMC_COOKIE  cookie :
 *    LPOLESTR*   ppViewType :
 *    long*       pViewOptions :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CHTMLSnapinComponent::GetResultViewType(MMC_COOKIE cookie, LPOLESTR* ppViewType, long* pViewOptions)
{
    DECLARE_SC(sc, TEXT("CHTMLSnapinComponent::GetResultViewType"));

    // check parameters
    if(!ppViewType || !pViewOptions)
        return (sc = E_UNEXPECTED).ToHr();

    if(!GetComponentData())
        return (sc = E_UNEXPECTED).ToHr();

    // add support for expanding the environment variables %WINDIR% and %SYSTEMROOT% to maintain compatibility with MMC1.2
    CStr strTarget = GetComponentData()->GetView();
    CStr strRet    = strTarget; // the return value
    CStr strTemp   = strTarget; // both initialized to the same value.

    strTemp.MakeLower(); // NOTE: this lowercase conversion is used only for comparison. The original case is preserved in the output.

    // Find out if %windir% or %systemroot% is in the target string
    int nWndDir = strTemp.Find(MMC_WINDIR_VARIABLE_PERC);
    int nSysDir = strTemp.Find(MMC_SYSTEMROOT_VARIABLE_PERC);

    if (nWndDir != -1 || nSysDir != -1)
    {
        const UINT BUFFERLEN = 4096;

        // Get start pos and length of replacement string
        int nStpos = (nWndDir != -1) ? nWndDir : nSysDir;
        int nLen = (nWndDir != -1) ? _tcslen(MMC_WINDIR_VARIABLE_PERC) : _tcslen(MMC_SYSTEMROOT_VARIABLE_PERC);

        // Setup temp variable to hold BUFFERLEN chars
        CStr strRoot;
        LPTSTR lpsz = strRoot.GetBuffer(BUFFERLEN);

        if (lpsz != NULL)
        {
            int iReturn = -1;

            if (nWndDir != -1)
               iReturn = GetWindowsDirectory(lpsz, BUFFERLEN);
            else
               iReturn = GetEnvironmentVariable(MMC_SYSTEMROOT_VARIABLE, lpsz, BUFFERLEN);

            // release string buffer
            strRoot.ReleaseBuffer();

            // Build up new target string based on environemnt variable.
            if (iReturn != 0)
            {
                strRet =  strTarget.Left(nStpos);
                strRet += strRoot;
                strRet += strTarget.Mid(nStpos + nLen, strTarget.GetLength() - (nStpos + nLen));
            }
        }
    }

    USES_CONVERSION;
    *ppViewType = (LPOLESTR)CoTaskMemAlloc( (_tcslen(strRet)+1) * sizeof(OLECHAR) );
    *pViewOptions = GetComponentData()->GetDescriptor().GetViewOptions();
    wcscpy(*ppViewType, T2COLE(strRet));


    return sc.ToHr();
}

//############################################################################
//############################################################################
//
//  Implementation of class COCXSnapinData
//
//############################################################################
//############################################################################
STDMETHODIMP
COCXSnapinData::CreateComponent(LPCOMPONENT* ppComponent)
{
    typedef CComObject<COCXSnapinComponent> CComponent;
    CComponent *    pComponent = NULL;
    CComObject<COCXSnapinComponent>::CreateInstance(&pComponent);
    ASSERT(pComponent != NULL);
    if(pComponent == NULL)
    {
        //TraceError(TEXT("COCXSnapinData::CreateComponent"));
        return E_UNEXPECTED;
    }

    pComponent->Init(this);

    return pComponent->QueryInterface(IID_IComponent, (void **)ppComponent); // does the Addref.
}


COCXSnapinData::COCXSnapinData()
{
    m_pActiveXPage0 = NULL;
    m_pActiveXPage1 = NULL;
    m_pActiveXPage2 = NULL;
    m_iImage     = eStockImage_OCX;
    m_iOpenImage = eStockImage_OCX;
}

COCXSnapinData::~COCXSnapinData()
{
}

STDMETHODIMP
COCXSnapinData::Destroy()
{
    if(m_pActiveXPage0 != NULL)
    {
        delete m_pActiveXPage0;
        m_pActiveXPage0 = NULL;
    }
    if(m_pActiveXPage1 != NULL)
    {
        delete m_pActiveXPage1;
        m_pActiveXPage1 = NULL;
    }
    if(m_pActiveXPage2 != NULL)
    {
        delete m_pActiveXPage2;
        m_pActiveXPage2 = NULL;
    }

    return BC::Destroy();
}

const CLSID       CLSID_OCXSnapin         = {0xC96401CF, 0x0E17,0x11D3, {0x88,0x5B,0x00,0xC0,0x4F,0x72,0xC7,0x17}};
static const GUID GUID_OCXSnapinNodetype  = {0xc96401d0, 0xe17, 0x11d3, { 0x88, 0x5b, 0x0, 0xc0, 0x4f, 0x72, 0xc7, 0x17 } };
static LPCTSTR szClsid_OCXSnapin          = TEXT("{C96401CF-0E17-11D3-885B-00C04F72C717}");
static LPCTSTR szGuidOCXSnapinNodetype    = TEXT("{C96401D0-0E17-11D3-885B-00C04F72C717}");


CSnapinDescriptor &
COCXSnapinData::GetSnapinDescriptor()
{
    static CSnapinDescriptor snapinDescription(IDS_ACTIVEXCONTROL,
                   IDS_OCXSNAPIN_DESC, IDI_OCX, IDB_OCX_16, IDB_OCX_16, IDB_OCX_32,
                   CLSID_OCXSnapin, szClsid_OCXSnapin, GUID_OCXSnapinNodetype,
                   szGuidOCXSnapinNodetype, TEXT("OCX"), TEXT("Snapins.OCXSnapin"),
                   TEXT("Snapins.OCXSnapin.1"), MMC_VIEW_OPTIONS_NOLISTVIEWS  /*viewOptions*/ );
    return snapinDescription;
}

// IExtendPropertySheet2
STDMETHODIMP
COCXSnapinData::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, LONG_PTR handle, LPDATAOBJECT lpIDataObject)
{
    HPROPSHEETPAGE hPage;

    ASSERT(lpProvider != NULL);
    if(lpProvider == NULL)
    {
        //TraceError(TEXT("CHTMLSnapinData::CreatePropertyPages"));
        return E_UNEXPECTED;
    }

    ASSERT(m_pActiveXPage0 == NULL);
    ASSERT(m_pActiveXPage1 == NULL);
    ASSERT(m_pActiveXPage2 == NULL);

    // create property pages
    m_pActiveXPage0 = new CActiveXPage0;
    m_pActiveXPage1 = new CActiveXPage1;
    m_pActiveXPage2 = new CActiveXPage2;

    // pass in pointer to data structure
    m_pActiveXPage0->Initialize(this);
    m_pActiveXPage1->Initialize(this);
    m_pActiveXPage2->Initialize(this);

    // Add Pages to property sheet
    hPage=CreatePropertySheetPage(&m_pActiveXPage0->m_psp);
    lpProvider->AddPage(hPage);

    hPage=CreatePropertySheetPage(&m_pActiveXPage1->m_psp);
    lpProvider->AddPage(hPage);

    hPage=CreatePropertySheetPage(&m_pActiveXPage2->m_psp);
    lpProvider->AddPage(hPage);

    return S_OK;
}

//############################################################################
//############################################################################
//
//  Implementation of class COCXSnapinComponent
//
//############################################################################
//############################################################################
/*+-------------------------------------------------------------------------*
 *
 * COCXSnapinComponent::Notify
 *
 * PURPOSE: Implements the CComponent::Notify method
 *
 * PARAMETERS:
 *    LPDATAOBJECT     lpDataObject :
 *    MMC_NOTIFY_TYPE  event :
 *    LPARAM           arg :
 *    LPARAM           param :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
COCXSnapinComponent::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;
    switch(event)
    {
    // Handle just the OCX initialization notify
    case MMCN_INITOCX:
        return OnInitOCX(lpDataObject, arg, param);
        break;

    default:
        // Pass other notifications on to base class
        return CSnapinComponentImpl::Notify(lpDataObject, event, arg, param);
        break;
    }

    return hr;
}


/*+-------------------------------------------------------------------------*
 *
 * COCXSnapinComponent::OnInitOCX
 *
 * PURPOSE: Handles the MMCN_INITOCX message.
 *
 * PARAMETERS:
 *    LPDATAOBJECT  lpDataObject :
 *    LPARAM        arg :
 *    LPARAM        param :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
COCXSnapinComponent::OnInitOCX(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;

    ASSERT(param != NULL);
    IUnknown* pUnknown = reinterpret_cast<IUnknown*>(param);

    ASSERT(m_bLoaded || m_bInitialized);

    // Load or initialze the OCX
    if (m_bLoaded || m_bInitialized)
    {
        IPersistStreamInitPtr spIPStmInit;

        // Query for stream support
        m_spIPStm = pUnknown;

        // if none, try streamInit
        if (m_spIPStm == NULL)
        {
            spIPStmInit = pUnknown;

            // if streamInit found, cast to normal stream pointer
            // so common methods can be called from single pointer
            if (spIPStmInit != NULL)
                m_spIPStm = (IPersistStream*)spIPStmInit.GetInterfacePtr();
        }

        // if either type of stream persistance supported
        if (m_spIPStm != NULL)
        {
            // if load method was called, then ask OCX to load from inner stream
            // Note that inner stream will not exist if OCX was never created
            if (m_bLoaded)
            {
                IStreamPtr spStm;
                HRESULT hr2 = m_spStg->OpenStream(SZ_OCXSTREAM, NULL, STGM_READ|STGM_SHARE_EXCLUSIVE, NULL, &spStm);

                if (SUCCEEDED(hr2))
                    hr = m_spIPStm->Load(spStm);
                else
                    m_bLoaded = FALSE;
            }

            // if no load was done and OCX requires an InitNew, give it one now
            if (!m_bLoaded && spIPStmInit != NULL)
                hr = spIPStmInit->InitNew();
        }
        else
        {
            // Query for storage support
            m_spIPStg = pUnknown;

            // if storage supported, ask OCX to load from inner storage
            // Note that inner storage will not exist if OCX was never created
            if (m_spIPStg != NULL)
            {
                if (m_bLoaded)
                {
                    ASSERT(m_spStgInner == NULL);
                    HRESULT hr2 = m_spStg->OpenStorage(SZ_OCXSTORAGE, NULL, STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                                                        NULL, NULL, &m_spStgInner);
                    if (SUCCEEDED(hr2))
                        hr = m_spIPStg->Load(m_spStgInner);
                    else
                        m_bLoaded = FALSE;
                }

                // if no load done, create an inner storage and init from it
                if (!m_bLoaded)
                {
                    ASSERT(m_spStgInner == NULL);
                    hr = m_spStg->CreateStorage(SZ_OCXSTORAGE, STGM_READWRITE|STGM_SHARE_EXCLUSIVE, NULL,
                                                        NULL, &m_spStgInner);
                    if (SUCCEEDED(hr))
                        hr = m_spIPStg->InitNew(m_spStgInner);
                }
            }
        }
    }

    return hr;
}

STDMETHODIMP COCXSnapinComponent::InitNew(IStorage* pStg)
{
    if (pStg == NULL)
        return E_POINTER;

    if (m_bInitialized)
        return CO_E_ALREADYINITIALIZED;

    // Hold onto storage
    m_spStg = pStg;
    m_bInitialized = TRUE;

    return S_OK;
}


HRESULT COCXSnapinComponent::Load(IStorage* pStg)
{
    if (pStg == NULL)
        return E_POINTER;

    if (m_bInitialized)
        return CO_E_ALREADYINITIALIZED;

    // Hold onto storage
    m_spStg = pStg;
    m_bLoaded = TRUE;
    m_bInitialized = TRUE;

    return S_OK;
}


HRESULT COCXSnapinComponent::IsDirty()
{
    HRESULT hr = S_FALSE;

    if (m_spIPStm != NULL)
    {
        hr = m_spIPStm->IsDirty();
    }
    else if (m_spIPStg != NULL)
    {
        hr = m_spIPStg->IsDirty();
    }

    return hr;
}


HRESULT COCXSnapinComponent::Save(IStorage* pStg, BOOL fSameAsLoad)
{
    DECLARE_SC(sc, TEXT("COCXSnapinComponent::Save"));

    // parameter check
    sc = ScCheckPointers( pStg );
    if (sc)
        return sc.ToHr();

    // to be able to save we need to be initialized
    sc = ScCheckPointers( m_spStg, E_UNEXPECTED );
    if (sc)
        return sc.ToHr();

    // if need to use the new storage - make a copy 
    if (!fSameAsLoad)
    {
        sc = m_spStg->CopyTo(0, NULL, NULL, pStg);
        if (sc)
            return sc.ToHr();

        // release cached storage (in case we have it) - it must change
        m_spStgInner = NULL;

        // hold onto the new storage
        m_spStg = pStg;

        // assignment uses QI - recheck!
        sc = ScCheckPointers( m_spStg, E_UNEXPECTED );
        if (sc)
            return sc.ToHr();
    }

    // if storage support, ask OCX to save to inner storage
    if (m_spIPStg)
    {
        bool bSameStorageForSnapin = true;
        // if saving to different storage, create new inner storage on it and pass to OCX
        if ( m_spStgInner == NULL )
        {
            sc = pStg->CreateStorage(SZ_OCXSTORAGE, STGM_CREATE|STGM_WRITE|STGM_SHARE_EXCLUSIVE, NULL, NULL, &m_spStgInner);
            if (sc)
                return sc.ToHr();

            bSameStorageForSnapin = false;
        }

        // recheck the pointer 
        sc = ScCheckPointers( m_spStgInner, E_UNEXPECTED );
        if (sc)
            return sc.ToHr();

        // save to the storage
        sc = m_spIPStg->Save( m_spStgInner, (fSameAsLoad && bSameStorageForSnapin) );
        if (sc)
            return sc.ToHr();
    }
    // else if stream support, create/open stream and save to it
    else if (m_spIPStm)
    {
        // if stream support, create internal stream and pass to OCX
        IStreamPtr spStm;
        sc = m_spStg->CreateStream(SZ_OCXSTREAM, STGM_CREATE|STGM_WRITE|STGM_SHARE_EXCLUSIVE, NULL, NULL, &spStm);
        if (sc)
            return sc.ToHr();

        sc = m_spIPStm->Save(spStm, TRUE);
        if (sc)
            return sc.ToHr();
    }
    else
    {
        // we are here if the OCX was never created (i.e., this component never owned the result pane)
        // if node was loaded and has to save to a new file, just copy the current storage to the new one
    }

    return sc.ToHr();
}


HRESULT COCXSnapinComponent::HandsOffStorage()
{
    // Release storage if holding ref
    // if ocx is holding storage, forward call to it
    if (m_spIPStg != NULL && m_spStgInner != NULL)
        m_spIPStg->HandsOffStorage();

    // Free our own refs
    m_spStgInner = NULL;
    m_spStg = NULL;

    return S_OK;
}


HRESULT COCXSnapinComponent::SaveCompleted(IStorage* pStgNew)
{
    HRESULT hr = S_OK;

    if (m_spIPStg != NULL)
    {
        // if new storage provided
        if (pStgNew != NULL && pStgNew != m_spStg)
        {
            // Create new inner storage and give to OCX
            IStoragePtr spStgInner;
            hr = pStgNew->CreateStorage(SZ_OCXSTORAGE, STGM_CREATE|STGM_WRITE|STGM_SHARE_EXCLUSIVE, NULL, NULL, &spStgInner);
            if (SUCCEEDED(hr))
                hr = m_spIPStg->SaveCompleted(spStgInner);

            // Free current inner storage and hold onto new one
            m_spStgInner = spStgInner;
        }
        else
        {
            m_spIPStg->SaveCompleted(NULL);
        }
    }

    if (pStgNew != NULL)
        m_spStg = pStgNew;

    return hr;
}


HRESULT COCXSnapinComponent::GetClassID(CLSID *pClassID)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\helpdoc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       helpdoc.h
//
//--------------------------------------------------------------------------

#ifndef _HELPDOC_H
#define _HELPDOC_H

#pragma warning(disable:4786)

#include "tstring.h"
#include "hcolwrap.h"
#include "collect.h"

using namespace std;

DEFINE_COM_SMARTPTR(IHHCollectionWrapper);  // IHHCollectionWrapperPtr

class CHelpCollectionEntry
{
public:
    wstring m_strHelpFile;
    wstring m_strCLSID;

    CHelpCollectionEntry() {}
    CHelpCollectionEntry(LPOLESTR pwzHelpFile, const CLSID& clsid);

    bool operator==(const CHelpCollectionEntry& other) const
        { return (m_strHelpFile == other.m_strHelpFile); }

    bool operator< (const CHelpCollectionEntry& other) const
        { return (m_strHelpFile <  other.m_strHelpFile); }
};

typedef map<CLSID, wstring>             EntryMap;
typedef pair<const CLSID, wstring>      EntryPair;
typedef vector<EntryPair*>              EntryPtrList;
typedef set<CHelpCollectionEntry>       HelpCollectionEntrySet;


class CHelpDoc
{

public:
    CHelpDoc() {};

    HRESULT Initialize(HELPDOCINFO* pDocInfo);

    BOOL    IsHelpFileValid();
    HRESULT CreateHelpFile();
    void    DeleteHelpFile();
    HRESULT UpdateHelpFile(HELPDOCINFO* pNewDocInfo);
    LPCTSTR GetFilePath() { return m_szFilePath; }

private:
    IHHCollectionWrapperPtr m_spCollection;
    HELPDOCINFO*    m_pDocInfo;
    EntryMap        m_entryMap;
    EntryPtrList    m_entryList;
    MMC_ATL::CRegKey    m_keySnapIns;
    TCHAR           m_szFilePath[MAX_PATH];

private:
    HRESULT BuildFilePath();
    HRESULT CreateSnapInList();
    HRESULT AddFileToCollection(
            LPCWSTR pszTitle,
            LPCWSTR pszFilePath,
            BOOL    bAddFolder );
    void    AddSnapInToList(const CLSID& rclsid);

	SC CHelpDoc::ScRedirectHelpFile (
		WTL::CString&	strHelpFile,	/* I/O:help file (maybe redirected)		*/
		LANGID&			langid);		/* O:language ID of output help file	*/
};


#endif //_HELPDOC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\iconcontrol.cpp ===
// IconCtrl.cpp : Implementation of CIconControl

#include "stdafx.h"
#include "ndmgr.h"
#include "IconControl.h"
#include "findview.h"
#include "util.h"

/////////////////////////////////////////////////////////////////////////////
// CIconControl

const CLSID CLSID_IconControl = {0xB0395DA5, 0x06A15, 0x4E44, {0x9F, 0x36, 0x9A, 0x9D, 0xC7, 0xA2, 0xF3, 0x41}};


//+-------------------------------------------------------------------
//
//  Member:      CIconControl::ScConnectToAMCViewForImageInfo
//
//  Synopsis:    Find the CAMCView that hosts this control and ask
//               for the icon information.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CIconControl::ScConnectToAMCViewForImageInfo ()
{
    DECLARE_SC(sc, _T("CIconControl::ScGetAMCView"));

    HWND hWnd = FindMMCView((*dynamic_cast<CComControlBase*>(this)));
    if (!hWnd)
        return (sc = E_FAIL);

	// check if we need the notch on the right side
	m_fLayoutRTL = (::GetWindowLong(hWnd, GWL_EXSTYLE) & WS_EX_LAYOUTRTL);

    m_fAskedForImageInfo = true;
    sc = SendMessage(hWnd, MMC_MSG_GET_ICON_INFO, (WPARAM)&m_hIcon, 0);

    if (!m_hIcon)
        return (sc = E_FAIL);

    m_fImageInfoValid = true;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CIconControl::OnDraw
//
//  Synopsis:    Called by the host to draw.
//
//  Arguments:
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
HRESULT CIconControl::OnDraw(ATL_DRAWINFO& di)
{
    DECLARE_SC(sc, _T("CIconControl::OnDraw"));
    RECT& rc = *(RECT*)di.prcBounds;

    // If never got the icon, ask CAMCView.
    if (!m_fAskedForImageInfo)
    {
        sc = ScConnectToAMCViewForImageInfo();
        if (sc)
            return sc.ToHr();
    }

    // Our attempt to get icon failed, so just return.
    if (!m_fImageInfoValid)
    {
        sc.TraceAndClear();
        return sc.ToHr();
    }

    // Draw the outline. Looks like: 
    //      xxxxxxxxxxxxxxxxxxxxxx
    //      x                    x
    //      x                    x
    //      x                   xx
    //      x                  x
    //      xxxxxxxxxxxxxxxxxxxx    <------- "Notch"

    // color the complete area
    COLORREF bgColor = GetSysColor(COLOR_ACTIVECAPTION);
    WTL::CBrush brush;
    brush.CreateSolidBrush(bgColor);                   // background brush

    WTL::CDC dc(di.hdcDraw); 

    // clear the DC
    dc.FillRect(&rc, brush);

    if(m_bDisplayNotch)  //Draw the notch if needed
    {
        WTL::CRgn rgn;
        int roundHeight = 10; // hack

        // clear out a quarter circle
        int left  = (m_fLayoutRTL==false ? rc.right : rc.left) - roundHeight;
        int right = (m_fLayoutRTL==false ? rc.right : rc.left) + roundHeight;
        int bottom= rc.bottom  + roundHeight;
        int top   = rc.bottom  - roundHeight;

        rgn.CreateRoundRectRgn(left, top, right, bottom, roundHeight*2, roundHeight*2);

        {
            COLORREF bgColor = GetSysColor(COLOR_WINDOW);
            WTL::CBrush brush;
            brush.CreateSolidBrush(bgColor);                   // background brush

            dc.FillRgn(rgn, brush);
        }
    }

    dc.Detach(); // release the DC before exiting!!

	const int LEFT_MARGIN = 10;
	const int TOP_MARGIN = 5;
	POINT ptIconPos = { (m_fLayoutRTL==false ? rc.left + LEFT_MARGIN : rc.right - LEFT_MARGIN -1 ), rc.top + TOP_MARGIN };

	// if we are on rtl mode - need to make dc behave that way as well 
	// For a time we draw an icon ( to appear in place and be flipped correctly )
	// (IE does not have RTL dc by default)
	DWORD dwLayout=0L;
	if ( m_fLayoutRTL && !( (dwLayout=GetLayout(di.hdcDraw)) & LAYOUT_RTL) ) 
	{
		LPtoDP( di.hdcDraw, &ptIconPos, 1/*nPoint*/);
		SetLayout(di.hdcDraw, dwLayout|LAYOUT_RTL);
		DPtoLP( di.hdcDraw, &ptIconPos, 1/*nPoint*/);
	}

	if (! DrawIconEx(di.hdcDraw, ptIconPos.x, ptIconPos.y, m_hIcon, 0, 0, 0, NULL, DI_NORMAL))
    {
        sc.FromLastError();
        sc.TraceAndClear();
        return sc.ToHr();
    }

	// Restore the DC to its previous layout state.
	if ( m_fLayoutRTL && !( dwLayout & LAYOUT_RTL ) ) 
	{
		SetLayout(di.hdcDraw, dwLayout);
	}

    return sc.ToHr();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\menubtn.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       menubtn.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    5/17/1997   WayneSc   Created
//____________________________________________________________________________
//

#include "stdafx.h"
#include "menubtn.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//////////////////////////////////////////////////////////////////////////////
// IMenuButton implementation

DEBUG_DECLARE_INSTANCE_COUNTER(CMenuButton);

CMenuButton::CMenuButton()
{
    m_pControlbar = NULL;
    m_pMenuButtonsMgr = NULL;

    DEBUG_INCREMENT_INSTANCE_COUNTER(CMenuButton);
}

CMenuButton::~CMenuButton()
{
    m_pControlbar = NULL;
    m_pMenuButtonsMgr = NULL;

    DEBUG_DECREMENT_INSTANCE_COUNTER(CMenuButton);
}

void CMenuButton::SetControlbar(CControlbar* pControlbar)
{
    m_pControlbar = pControlbar;
}

CControlbar* CMenuButton::GetControlbar()
{
    return m_pControlbar;
}

CMenuButtonsMgr* CMenuButton::GetMenuButtonsMgr(void)
{
    if ((NULL == m_pMenuButtonsMgr) && (NULL != m_pControlbar) )
    {
        m_pMenuButtonsMgr = m_pControlbar->GetMenuButtonsMgr();
    }

    return m_pMenuButtonsMgr;
}


//+-------------------------------------------------------------------
//
//  Member:     AddButton
//
//  Synopsis:   Add a menu button, called by snapin.
//
//  Arguments:  [idCommand]     - Command ID for the menu button.
//              [lpButtonText]  - The text for menu button.
//              [lpTooltipText] - Status / Tool tip text.
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CMenuButton::AddButton(int idCommand, LPOLESTR lpButtonText, LPOLESTR lpTooltipText)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IMenuButton::AddButton"));

    if (lpButtonText == NULL || lpTooltipText == NULL)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Invalid Args"), sc);
        return sc.ToHr();
    }

    CMenuButtonsMgr* pMenuButtonsMgr = GetMenuButtonsMgr();
    if (NULL == pMenuButtonsMgr)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    sc = pMenuButtonsMgr->ScAddMenuButton(this, idCommand, lpButtonText, lpTooltipText);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:     SetButton
//
//  Synopsis:   Modify a menu button name or status text, called by snapin.
//
//  Arguments:  [idCommand]     - Command ID for the menu button.
//              [lpButtonText]  - The text for menu button.
//              [lpTooltipText] - Status / Tool tip text.
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CMenuButton::SetButton(int idCommand, LPOLESTR lpButtonText, LPOLESTR lpTooltipText)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IMenuButton::SetButton"));

    if (lpButtonText == NULL || lpTooltipText == NULL)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Invalid Args"), sc);
        return sc.ToHr();
    }

    CMenuButtonsMgr* pMenuButtonsMgr = GetMenuButtonsMgr();
    if (NULL == pMenuButtonsMgr)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    sc = pMenuButtonsMgr->ScModifyMenuButton(this, idCommand, lpButtonText, lpTooltipText);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:     SetButtonState
//
//  Synopsis:   Modify a menu button state, called by snapin.
//
//  Arguments:  [idCommand] - Command ID for the menu button.
//              [nState]    - The state to be modified.
//              [bState]    - Set or Reset the state.
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CMenuButton::SetButtonState(int idCommand, MMC_BUTTON_STATE nState, BOOL bState)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IMenuButton::SetButtonState"));

    if (nState == CHECKED || nState == INDETERMINATE)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Invalid Button States"), sc);
        return sc.ToHr();
    }

    if (m_pControlbar == NULL)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    // ENABLED, HIDDEN, BUTTONPRESSED
    CMenuButtonsMgr* pMenuButtonsMgr = GetMenuButtonsMgr();
    if (NULL == pMenuButtonsMgr)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    sc = pMenuButtonsMgr->ScModifyMenuButtonState(this, idCommand, nState, bState);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:     ScAttach
//
//  Synopsis:   Attach this MenuButton object to the UI.
//
//  Arguments:  None
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CMenuButton::ScAttach(void)
{
    DECLARE_SC(sc, _T("CMenuButton::ScAttach"));

    CMenuButtonsMgr* pMenuButtonsMgr = GetMenuButtonsMgr();
    if (NULL == pMenuButtonsMgr)
        return (sc = E_UNEXPECTED);

    sc = pMenuButtonsMgr->ScAttachMenuButton(this);
    if (sc)
        return sc.ToHr();

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:     ScDetach
//
//  Synopsis:   Detach this MenuButton object from the UI.
//
//  Arguments:  None
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CMenuButton::ScDetach(void)
{
    DECLARE_SC(sc, _T("CMenuButton::ScDetach"));

    CMenuButtonsMgr* pMenuButtonsMgr = GetMenuButtonsMgr();
    if (NULL == pMenuButtonsMgr)
        return (sc = E_UNEXPECTED);

    sc = pMenuButtonsMgr->ScDetachMenuButton(this);
    if (sc)
        return sc;

    SetControlbar(NULL);

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:     ScNotifyMenuBtnClick
//
//  Synopsis:   Notify the Controbar (snapin) that menu button is clicked.
//
//  Arguments:  [hNode]          - The node that owns the result pane.
//              [bScope]         - Scope or Result.
//              [lParam]         - If result (pane) lParam of result item.
//              [menuButtonData] - MENUBUTTONDATA
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CMenuButton:: ScNotifyMenuBtnClick(HNODE hNode, bool bScope,
                                      LPARAM lParam,
                                      MENUBUTTONDATA& menuButtonData)

{
    DECLARE_SC(sc, _T("CMenuButton::ScNotifyMenuBtnClick"));

    if (NULL == m_pControlbar)
        return (sc = E_UNEXPECTED);

    sc = m_pControlbar->ScNotifySnapinOfMenuBtnClick(hNode, bScope, lParam, &menuButtonData);
    if (sc)
        return sc.ToHr();

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\menubtn.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       menubtn.h
//
//--------------------------------------------------------------------------

#ifndef _MENUBTN_H_
#define _MENUBTN_H_

#include "toolbars.h"       // for CMenuButtonNotify

#ifdef DBG
#include "ctrlbar.h"  // Needed for GetSnapinName()
#endif


//forward prototypes
class CControlbar;
class CMenuButton;
class CMenuButtonsMgr;

//+-------------------------------------------------------------------
//
//  class:     CMenuButton
//
//  Purpose:   The IMenuButton implementation this is owned
//             by the CControlbar and talks to the CMenuButtonsMgr
//             to create/manipulate the menus.
//             The CMenuButtonNotify interface receives the menubutton
//             click notification.
//
//  History:    10-12-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
class CMenuButton : public IMenuButton,
                    public CMenuButtonNotify,
                    public CComObjectRoot
{
public:
    CMenuButton();
    ~CMenuButton();

public:
// ATL COM map
BEGIN_COM_MAP(CMenuButton)
    COM_INTERFACE_ENTRY(IMenuButton)
END_COM_MAP()


// CMenuButton methods
public:
    STDMETHOD(AddButton)(int idCommand, LPOLESTR lpButtonText, LPOLESTR lpTooltipText);
    STDMETHOD(SetButton)(int idCommand, LPOLESTR lpButtonText, LPOLESTR lpTooltipText);
    STDMETHOD(SetButtonState)(int idCommand, MMC_BUTTON_STATE nState, BOOL bState);

public:
    // Helpers
    void SetControlbar(CControlbar* pControlbar);
    CControlbar* GetControlbar(void);
    CMenuButtonsMgr* GetMenuButtonsMgr(void);

    SC ScAttach(void);
    SC ScDetach(void);

public:
    // CMenuButtonsMgr methods.
    virtual SC ScNotifyMenuBtnClick(HNODE hNode, bool bScope, LPARAM lParam,
                                    MENUBUTTONDATA& menuButtonData);

#ifdef DBG     // Debug information.
public:
    LPCTSTR GetSnapinName ()
    {
        if (m_pControlbar)
            return m_pControlbar->GetSnapinName();

        return _T("Unknown");
    }
#endif

// Attributes
private:
    CControlbar*            m_pControlbar;     // pointer to IControlbar (1 IControlbar to 1 IMenuButton)
    CMenuButtonsMgr*        m_pMenuButtonsMgr; // The Menu buttons mgr that manages the UI.
}; // class CMenuButton


#endif  // _MENUBTN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\iconcontrol.h ===
// IconControl.h : Declaration of the CIconControl

#ifndef __ICONCONTROL_H_
#define __ICONCONTROL_H_

extern const CLSID CLSID_IconControl;

/////////////////////////////////////////////////////////////////////////////
// CIconControl
class ATL_NO_VTABLE CIconControl :
        public CComObjectRootEx<CComSingleThreadModel>,
        public CComControl<CIconControl>,
        public IPersistStreamInitImpl<CIconControl>,
        public IOleControlImpl<CIconControl>,
        public IOleObjectImpl<CIconControl>,
        public IOleInPlaceActiveObjectImpl<CIconControl>,
        public IViewObjectExImpl<CIconControl>,
        public IOleInPlaceObjectWindowlessImpl<CIconControl>,
        public IPersistStorageImpl<CIconControl>,
        public ISpecifyPropertyPagesImpl<CIconControl>,
        public IQuickActivateImpl<CIconControl>,
        public IDataObjectImpl<CIconControl>,
        public IPersistPropertyBagImpl<CIconControl>,
        public IObjectSafetyImpl<CIconControl, INTERFACESAFE_FOR_UNTRUSTED_DATA>,
        public CComCoClass<CIconControl, &CLSID_IconControl>
{
public:
        CIconControl() : m_fImageInfoValid(false), m_fAskedForImageInfo(false), m_hIcon(NULL), 
						 m_bDisplayNotch(true), m_fLayoutRTL(false)
        {
        }

        virtual ~CIconControl()
        {
            if (m_hIcon)
                DestroyIcon(m_hIcon);
        }

        DECLARE_MMC_CONTROL_REGISTRATION(
            g_szMmcndmgrDll,                                        // implementing DLL
            CLSID_IconControl,
            _T("MMC IconControl class"),
            _T("MMC.IconControl.1"),
            _T("MMC.IconControl"),
            LIBID_NODEMGRLib,
            _T("1"),
            _T("1.0"))

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CIconControl)
        COM_INTERFACE_ENTRY(IViewObjectEx)
        COM_INTERFACE_ENTRY(IViewObject2)
        COM_INTERFACE_ENTRY(IViewObject)
        COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY(IOleInPlaceObject)
        COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
        COM_INTERFACE_ENTRY(IOleControl)
        COM_INTERFACE_ENTRY(IOleObject)
        COM_INTERFACE_ENTRY(IPersistPropertyBag)
        COM_INTERFACE_ENTRY(IPersistStreamInit)
        COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
        COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY(IQuickActivate)
        COM_INTERFACE_ENTRY(IPersistStorage)
        COM_INTERFACE_ENTRY(IDataObject)
        COM_INTERFACE_ENTRY(IObjectSafety)
END_COM_MAP()

BEGIN_PROP_MAP(CIconControl)
        PROP_DATA_ENTRY("Notch",           m_bDisplayNotch,          VT_UI4) // the "Notch" is the quarter circle at the bottom-right of the panel
        // PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
        // PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
        // Example entries
        // PROP_ENTRY("Property Description", dispid, clsid)
        // PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_MSG_MAP(CIconControl)
        CHAIN_MSG_MAP(CComControl<CIconControl>)
        DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);



// IViewObjectEx
   DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

public:
   HRESULT OnDraw(ATL_DRAWINFO& di);

// Helpers
private:
    SC ScConnectToAMCViewForImageInfo();

private:
    HICON           m_hIcon;
    bool            m_fImageInfoValid : 1;
    bool            m_fAskedForImageInfo : 1;
    UINT            m_bDisplayNotch; // the "Notch" is the quarter circle at the bottom-right of the panel
	bool            m_fLayoutRTL;
};
#endif //__ICONCONTROL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\menuitem.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       menuitem.cpp
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
// MenuItem.cpp : CMenuItem class implementation.

#include "stdafx.h"

#include "MenuItem.h"
#include "..\inc\stddbg.h" // ASSERT_OBJECTPTR
#include "util.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

DEBUG_DECLARE_INSTANCE_COUNTER(CMenuItem);

//############################################################################
//############################################################################
//
//  Traces
//
//############################################################################
//############################################################################
#ifdef DBG
CTraceTag tagMenuItem(TEXT("Menu Items"), TEXT("Menu Item Path"));
#endif

//############################################################################
//############################################################################
//
//  Implementation of class CMMCMenuItem
//
//############################################################################
//############################################################################
/*+-------------------------------------------------------------------------*
 * class CMMCMenuItem
 *
 *
 * PURPOSE: Encapsulates a single CMenuItem, and exposes the MenuItem interface.
 *
 *+-------------------------------------------------------------------------*/
class CMMCMenuItem:
    public CMMCIDispatchImpl<MenuItem>,
    public CTiedComObject<CMenuItem>
{
    typedef CMMCMenuItem        ThisClass;
    typedef CMenuItem           CMyTiedObject;

public:

    BEGIN_MMC_COM_MAP(ThisClass)
    END_MMC_COM_MAP()

    // give a public access to IsTied();
    bool IsTied() { return CTiedComObject<CMenuItem>::IsTied(); }

    // MenuItem interface methods
public:
    MMC_METHOD0(Execute);
    MMC_METHOD1(get_DisplayName,             PBSTR /*pbstrName*/);
    MMC_METHOD1(get_LanguageIndependentName, PBSTR /*LanguageIndependentName*/);
    MMC_METHOD1(get_Path,                    PBSTR /*pbstrPath*/);
    MMC_METHOD1(get_LanguageIndependentPath, PBSTR /*LanguageIndependentPath*/);
    MMC_METHOD1(get_Enabled,                 PBOOL /*pBool*/);
};


//############################################################################
//############################################################################
//
//  Implementation of class CMenuItem
//
//############################################################################
//############################################################################

CMenuItem::CMenuItem(   LPCTSTR                 lpszName,
                        LPCTSTR                 lpszStatusBarText,
                        LPCTSTR                 lpszLanguageIndependentName,
                        LPCTSTR                 lpszPath,
                        LPCTSTR                 lpszLanguageIndependentPath,
                        long                    nCommandID,
                        long                    nMenuItemID,
                        long                    nFlags,
                        MENU_OWNER_ID           ownerID,
                        IExtendContextMenu *    pExtendContextMenu,
                        IDataObject *           pDataObject,
                        DWORD                   fSpecialFlags,
                        bool                    bPassCommandBackToSnapin /*= false*/) :

    m_strName(lpszName),
    m_strStatusBarText(lpszStatusBarText),
    m_strPath(lpszPath),
    m_strLanguageIndependentName(lpszLanguageIndependentName),
    m_strLanguageIndependentPath(lpszLanguageIndependentPath),
    m_nCommandID(nCommandID),
    m_nMenuItemID(nMenuItemID),
    m_nFlags(nFlags),
    m_OwnerID(ownerID),
    m_fSpecialFlags(fSpecialFlags),
    m_PopupMenuHandle(NULL),
    m_SubMenu(),            // default c-tor
    m_spExtendContextMenu(pExtendContextMenu),
    m_pDataObject(pDataObject), //AddRef'ed in the c-tor body
    m_bEnabled(true),
    m_spMenuItem(),         // default c-tor   
    m_bPassCommandBackToSnapin(bPassCommandBackToSnapin)
{
    // Caller must check range on ID and State

    // NULL is a special dataobject
    if (! IS_SPECIAL_DATAOBJECT(m_pDataObject))
        m_pDataObject->AddRef();

    DEBUG_INCREMENT_INSTANCE_COUNTER(CMenuItem);
}

CMenuItem::~CMenuItem()
{
    POSITION pos = m_SubMenu.GetHeadPosition();
    while(pos)
    {
        CMenuItem* pItem = m_SubMenu.GetNext(pos);
        ASSERT( pItem != NULL );
        delete pItem;
    }
    m_SubMenu.RemoveAll();

    m_spExtendContextMenu = NULL;

    if (! IS_SPECIAL_DATAOBJECT(m_pDataObject))
        m_pDataObject->Release();

    m_spMenuItem = NULL;

    DEBUG_DECREMENT_INSTANCE_COUNTER(CMenuItem);
}


void CMenuItem::AssertValid()
{
    ASSERT(this != NULL);
    if (m_nCommandID == -1 ||
        m_nMenuItemID == OWNERID_INVALID ||
        m_nFlags == -1
        )
    {
        ASSERT( FALSE );
    }
}


/*+-------------------------------------------------------------------------*
 *
 * CMenuItem::ScGetMenuItem
 *
 * PURPOSE: Creates an returns a tied MenuItem COM object.
 *
 * PARAMETERS:
 *    PPMENUITEM  ppMenuItem :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CMenuItem::ScGetMenuItem(PPMENUITEM ppMenuItem)
{
    DECLARE_SC(sc, TEXT("CMenuItem::ScGetMenuItem"));

    sc = ScCheckPointers(ppMenuItem);
    if(sc)
        return sc;

    // initialize out parameter
    *ppMenuItem = NULL;

    // create a CMMCMenuItem if needed.
    sc = CTiedComObjectCreator<CMMCMenuItem>::ScCreateAndConnect(*this, m_spMenuItem);
    if(sc)
        return sc;

    if(m_spMenuItem == NULL)
    {
        sc = E_UNEXPECTED;
        return sc;
    }

    // addref the pointer for the client.
    m_spMenuItem->AddRef();
    *ppMenuItem = m_spMenuItem;

    return sc;
}


//+-------------------------------------------------------------------
//
//  class:      CManageActCtx
//
//  Purpose:    To deactivate UI theme context (if set) and restore
//              the context automatically.
//
//  Usage:      1. Call Activate to set the activation context to V5
//              common controls. This is needed before calling into snapins
//              so that snapin created windows are not themed accidentally.
//
//              The snapin can theme its windows by calling appropriate
//              fusion apis while calling create-window.
//
//              2. Call Deactivate to restore the activation context.
//              This is needed after calling into snapins, so that
//              if we called from themed context then it is restored.
//
// Explanation:
//              When MMC calls into the snapin if the last winproc which
//              received a window message is themed and will result in a
//              call to snapin then we will call the snapin in themed
//              context. If snapin creates & displays any UI then it will
//              be themed. This function is to de-activate the theming
//              before calling the snapin.
//
//
//--------------------------------------------------------------------
class CManageActCtx
{
public:
	CManageActCtx() : m_ulpCookie(0) { }
	~CManageActCtx() 
	{ 
		if (m_ulpCookie != 0) 
			MmcDownlevelDeactivateActCtx(0, m_ulpCookie); 
	}

	BOOL Activate(HANDLE hActCtx) 
	{
		if (m_ulpCookie != 0) 
		{
			ULONG_PTR ulpTemp = m_ulpCookie;
			m_ulpCookie = 0;
			MmcDownlevelDeactivateActCtx(0, ulpTemp);
		}

		return MmcDownlevelActivateActCtx(hActCtx, &m_ulpCookie);
	}

	VOID Deactivate() 
	{
		ULONG_PTR ulpTemp = m_ulpCookie;

		if (ulpTemp != 0) 
		{
			m_ulpCookie = 0;
			MmcDownlevelDeactivateActCtx(0, ulpTemp);
		}
	}

private:
	ULONG_PTR m_ulpCookie;
};


/*+-------------------------------------------------------------------------*
 *
 * CMenuItem::ScExecute
 *
 * PURPOSE: Executes the menu item.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CMenuItem::ScExecute()
{
    DECLARE_SC(sc, TEXT("CMenuItem::ScExecute"));

    Trace(tagMenuItem, TEXT("\"%s\""), m_strPath);

    // check whether the item is disabled.
    BOOL bEnabled = FALSE;
    sc = Scget_Enabled(&bEnabled);
    if (sc)
        return sc;

    if (!bEnabled)
        return sc = E_FAIL;

    // if the command is to be passed to snapin  - nothing can be done here
    if ( m_bPassCommandBackToSnapin )
        return sc;

    sc = ScCheckPointers(m_spExtendContextMenu.GetInterfacePtr(), E_UNEXPECTED);
    if(sc)
        return sc;

    MenuItemPtr spMenuItem;
    sc = ScGetMenuItem( &spMenuItem );
    if (sc)
        return sc;

	// Deactivate if theming (fusion or V6 common-control) context before calling snapins.
	CManageActCtx mac;
	if (! mac.Activate(NULL) )
		return (sc = E_FAIL);

	try
	{
		sc = m_spExtendContextMenu->Command(GetCommandID(), m_pDataObject);
	}
	catch(...)
	{
		// Do nothing.
	}

	mac.Deactivate();

    if (sc)
        return sc;

    // get the pointer for com event emitting
    CConsoleEventDispatcher *pConsoleEventDispatcher = NULL;
    sc = CConsoleEventDispatcherProvider::ScGetConsoleEventDispatcher( pConsoleEventDispatcher );
    if(sc)
    {
        sc.TraceAndClear(); // event does not affect item execution itself
        return sc;
    }

    // fire event about successful execution (do not rely on 'this' to be valid)
    if (pConsoleEventDispatcher != NULL)
    {
        // check if com object still points to a valid object
        CMMCMenuItem *pMMCMenuItem = dynamic_cast<CMMCMenuItem *>( spMenuItem.GetInterfacePtr() );

        // check the pointer
        sc = ScCheckPointers( pMMCMenuItem, E_UNEXPECTED );
        if (sc)
        {
            spMenuItem = NULL;  // invalid anyway - do not pass to the script
            sc.TraceAndClear(); // does not affect the result
        }
        else if ( !pMMCMenuItem->IsTied() ) // validate menu item
        {
            spMenuItem = NULL;  // gone away - change to NULL instead of passing invalid object
        }

        // fire it!
        sc = pConsoleEventDispatcher->ScOnContextMenuExecuted( spMenuItem );
        if (sc)
            sc.TraceAndClear(); // does not affect the result
    }
    else
    {
        // needs to be set prior to using
        (sc = E_UNEXPECTED).TraceAndClear();
    }

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CMenuItem::Scget_DisplayName
 *
 * PURPOSE: Returns the display name of the menu item, which includes acclerators.
 *          Eg '&Properties  ALT+ENTER'
 *
 * PARAMETERS:
 *    PBSTR  pbstrName :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CMenuItem::Scget_DisplayName(PBSTR pbstrName)
{
    DECLARE_SC(sc, TEXT("CMenuItem::Scget_DisplayName"));

    sc = ScCheckPointers(pbstrName);
    if(sc)
        return sc;

    CComBSTR bstrName = GetMenuItemName();

    // give the
    *pbstrName = bstrName.Detach();

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CMenuItem::Scget_LanguageIndependentName
 *
 * PURPOSE: Returns the language-independent name of the menu item. If there is no 
 *          language independent name, returns the display name without accelerators.
 *
 * PARAMETERS: 
 *    PBSTR  LanguageIndependentName :
 *
 * RETURNS: 
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CMenuItem::Scget_LanguageIndependentName(PBSTR LanguageIndependentName)
{
    DECLARE_SC(sc, TEXT("CMenuItem::Scget_LanguageIndependentName"));

    sc = ScCheckPointers(LanguageIndependentName);
    if(sc)
        return sc;

    // initialize the out parameter
    *LanguageIndependentName = NULL;

    CComBSTR bstrLanguageIndependentName = GetLanguageIndependentName();

    // set the output param
    *LanguageIndependentName = bstrLanguageIndependentName.Detach();

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CMenuItem::Scget_Path
 *
 * PURPOSE: Returns the path of the menu item starting from the root. Does not include
 *          accelerators. Eg View->Large
 *
 * PARAMETERS:
 *    PBSTR  pbstrPath :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CMenuItem::Scget_Path(PBSTR pbstrPath)
{
    DECLARE_SC(sc, TEXT("CMenuItem::Scget_Path"));

    sc = ScCheckPointers(pbstrPath);
    if(sc)
        return sc.ToHr();

    CComBSTR bstrPath = (LPCTSTR)m_strPath;

    // give the
    *pbstrPath = bstrPath.Detach();

    return sc.ToHr();
}


/*+-------------------------------------------------------------------------*
 *
 * CMenuItem::Scget_LanguageIndependentPath
 *
 * PURPOSE: Returns the language independent path of the menu item starting from the root. 
 *          Eg _VIEW->_LARGE
 *
 * PARAMETERS: 
 *    PBSTR   LanguageIndependentPath :
 *
 * RETURNS: 
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC  
CMenuItem::Scget_LanguageIndependentPath(PBSTR  LanguageIndependentPath)
{
    DECLARE_SC(sc, TEXT("CMenuItem::Scget_LanguageIndependentPath"));

    sc = ScCheckPointers(LanguageIndependentPath);
    if(sc)
        return sc;

    // initialize the out parameter
    *LanguageIndependentPath = NULL;

    CComBSTR bstrLanguageIndependentPath = (LPCTSTR)GetLanguageIndependentPath();

    // set the output param
    *LanguageIndependentPath = bstrLanguageIndependentPath.Detach();

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CMenuItem::Scget_Enabled
 *
 * PURPOSE: Returns whether the menu item is enabled.
 *
 * PARAMETERS:
 *    PBOOL  pBool :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
SC
CMenuItem::Scget_Enabled(PBOOL pBool)
{
    DECLARE_SC(sc, TEXT("CMenuItem::Scget_Enabled"));

    sc = ScCheckPointers(pBool);
    if(sc)
        return sc.ToHr();

    // the item is enabled only if it was never disabled via the Disable object model
    // method and it is not grayed out or disabled via the MF_ flags.
    *pBool = m_bEnabled &&
             ((m_nFlags & MF_DISABLED) == 0) &&
             ((m_nFlags & MF_GRAYED) == 0);

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CMenuItem::ScFindMenuItemByPath
 *
 * PURPOSE: finds the menu item by matching the path
 *
 * PARAMETERS:
 *    LPCTSTR lpstrPath [in] manu item path
 *
 * RETURNS:
 *    CMenuItem*    - found item (NULL == not found)
 *
\***************************************************************************/
CMenuItem*
CMenuItem::FindItemByPath( LPCTSTR lpstrPath )
{
    // first check if this item does not meet requirements
    if ( 0 == m_strLanguageIndependentPath.Compare(lpstrPath)
      || 0 == m_strPath.Compare(lpstrPath) )
        return this;

    // recurse into subitems
    POSITION pos = GetMenuItemSubmenu().GetHeadPosition();
    while(pos)
    {
        CMenuItem* pItem = GetMenuItemSubmenu().GetNext(pos);
        if (!pItem)
        {
            ASSERT(FALSE);
            return NULL;
        }

        CMenuItem* pItemFound = pItem->FindItemByPath( lpstrPath );
        if (pItemFound)
            return pItemFound;
    }

    // not found 
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\mmcatl.h ===
//############################################################################
//############################################################################
//
// this should be provided by ATL, but it's not
//
//############################################################################
//############################################################################
#ifndef REFLECTED_NOTIFY_CODE_HANDLER
#define REFLECTED_NOTIFY_CODE_HANDLER(cd, func) \
    if(uMsg == OCM_NOTIFY && cd == ((LPNMHDR)lParam)->code) \
    { \
        bHandled = TRUE; \
        lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
        if(bHandled) \
            return TRUE; \
    }
#endif

#define GET_PARENT_OBJECT(className, member) \
        className* pThis = \
            ((className*)((BYTE*)this - offsetof(className, member)))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\mmcmt.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       mmcmt.cpp
//
//--------------------------------------------------------------------------

/*
	mmcmt.cpp
	
	Implementation of thread synchronization classes
*/

#include "stdafx.h"


/////////////////////////////////////////////////////////////////////////////
// CSyncObject

CSyncObject::CSyncObject() :
	m_hObject( NULL )
{
}


CSyncObject::~CSyncObject()
{
	if( m_hObject != NULL )
	{
		::CloseHandle( m_hObject );
		m_hObject = NULL;
	}
}


BOOL CSyncObject::Lock( DWORD dwTimeout )
{
	// this is a band-aid fix. Whis locking architecture is not working at all.
	// Raid #374770 ( Windows Bugs ntraid9 4/23/2001 )
	// fixes need to be made to:
	// a) remove m_hObject member from this class
	// b) remove CMutex - not used anywhere
	// c) make Lock a pure virtual method and require everyone to override it.
	// d) remove this locking from context menu - it is not needed there

	if( m_hObject && ::WaitForSingleObject( m_hObject, dwTimeout) == WAIT_OBJECT_0 )
		return TRUE;
	else
		return FALSE;
}



/////////////////////////////////////////////////////////////////////////////
// CMutex

CMutex::CMutex( BOOL bInitiallyOwn ) :
	CSyncObject()
{
	m_hObject = ::CreateMutex( NULL, bInitiallyOwn, NULL );
	ASSERT( m_hObject );
}



BOOL CMutex::Unlock()
{
	return ::ReleaseMutex( m_hObject );
}



/////////////////////////////////////////////////////////////////////////////
// CSingleLock

CSingleLock::CSingleLock( CSyncObject* pObject, BOOL bInitialLock )
{
	ASSERT( pObject != NULL );

	m_pObject = pObject;
	m_hObject = *pObject;
	m_bAcquired = FALSE;

	if (bInitialLock)
		Lock();
}


BOOL CSingleLock::Lock( DWORD dwTimeOut )
{
	ASSERT( m_pObject != NULL || m_hObject != NULL );
	ASSERT( !m_bAcquired );

	m_bAcquired = m_pObject->Lock( dwTimeOut );
	return m_bAcquired;
}


BOOL CSingleLock::Unlock()
{
	ASSERT( m_pObject != NULL );
	if (m_bAcquired)
		m_bAcquired = !m_pObject->Unlock();

	// successfully unlocking means it isn't acquired
	return !m_bAcquired;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\mmcmt.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       mmcmt.h
//
//--------------------------------------------------------------------------

#ifndef __MMCMT_H_
#define __MMCMT_H_

/*
	mmcmt.h
	
	Simple thread synchronization classes
*/


/////////////////////////////////////////////////////////////////////////////
// CSyncObject

class CSyncObject
{
	friend class CMutex;

	public:
		CSyncObject();
		virtual ~CSyncObject();
	
		operator HANDLE() const { return m_hObject; }
	
		virtual BOOL Lock(DWORD dwTimeout = INFINITE);
		virtual BOOL Unlock() = 0;
		virtual BOOL Unlock(LONG /* lCount */, LPLONG /* lpPrevCount=NULL */) { return TRUE; }

	protected:
		HANDLE  m_hObject;
};


/////////////////////////////////////////////////////////////////////////////
// CMutex

class CMutex : public CSyncObject
{
	public:
		CMutex(BOOL bInitiallyOwn = FALSE);

		BOOL Unlock();
};


/////////////////////////////////////////////////////////////////////////////
// CCriticalSection

class CCriticalSection : public CSyncObject
{
	public:
		CCriticalSection();
		virtual ~CCriticalSection();
	
		operator CRITICAL_SECTION*() { return &m_sect; }
	
		BOOL Lock();
		BOOL Unlock();

	protected:
		CRITICAL_SECTION m_sect;
};


inline CCriticalSection::CCriticalSection() :
	CSyncObject()
{
	::InitializeCriticalSection( &m_sect );
}

inline CCriticalSection::~CCriticalSection()
{
	::DeleteCriticalSection( &m_sect );
}

inline BOOL CCriticalSection::Lock()
{
	::EnterCriticalSection( &m_sect ); 
	return TRUE;
}

inline BOOL CCriticalSection::Unlock()
{
	::LeaveCriticalSection( &m_sect ); 
	return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
// CSingleLock

class CSingleLock
{
	public:
		CSingleLock(CSyncObject* pObject, BOOL bInitialLock = FALSE);
		~CSingleLock() { Unlock(); }

		BOOL Lock(DWORD dwTimeOut = INFINITE);
		BOOL Unlock();
		BOOL IsLocked() { return m_bAcquired; }
	
	protected:
		CSyncObject* m_pObject;
		HANDLE  m_hObject;
		BOOL    m_bAcquired;
};


#endif	// __MMCMT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\menuitem.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       menuitem.h
//
//--------------------------------------------------------------------------

// MenuItem.h : Declaration of the CMenuItem class.

/////////////////////////////////////////////////////////////////////////////
// MenuItem.h : See MenuItem.cpp for implementation.

#ifndef _MENUITEM_H
#define _MENUITEM_H

#ifndef DECLSPEC_UUID
#if _MSC_VER >= 1100
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif
#include "ndmgr.h"
#include "cmenuinfo.h"

// menu owner IDs
#define OWNERID_NATIVE          0
#define OWNERID_PRIMARY_MIN     1
#define OWNERID_PRIMARY_MAX     0x7FFFFFFF
#define OWNERID_THIRD_PARTY_MIN 0x80000000
#define OWNERID_THIRD_PARTY_MAX 0xFFFFFFFE
#define OWNERID_INVALID         0xFFFFFFFF
inline BOOL IsSystemOwnerID( MENU_OWNER_ID ownerid )
    { return (OWNERID_NATIVE == ownerid); }
inline BOOL IsPrimaryOwnerID( MENU_OWNER_ID ownerid )
    { return (OWNERID_PRIMARY_MIN <= ownerid && OWNERID_PRIMARY_MAX >= ownerid ); }
inline BOOL IsThirdPartyOwnerID( MENU_OWNER_ID ownerid )
    { return (OWNERID_THIRD_PARTY_MIN <= ownerid && OWNERID_THIRD_PARTY_MAX >= ownerid ); }

inline BOOL IsSpecialInsertionPointID( long lInsertionPointID )
    { return (lInsertionPointID & CCM_INSERTIONPOINTID_MASK_SPECIAL); }
inline BOOL IsSharedInsertionPointID( long lInsertionPointID )
    { return (lInsertionPointID & CCM_INSERTIONPOINTID_MASK_SHARED); }
inline BOOL IsCreatePrimaryInsertionPointID( long lInsertionPointID )
    { return (lInsertionPointID & CCM_INSERTIONPOINTID_MASK_CREATE_PRIMARY); }
inline BOOL IsAddPrimaryInsertionPointID( long lInsertionPointID )
    { return (lInsertionPointID & CCM_INSERTIONPOINTID_MASK_ADD_PRIMARY); }
inline BOOL IsAdd3rdPartyInsertionPointID( long lInsertionPointID )
    { return (lInsertionPointID & CCM_INSERTIONPOINTID_MASK_ADD_3RDPARTY); }
inline BOOL IsReservedInsertionPointID( long lInsertionPointID )
    { return (lInsertionPointID & CCM_INSERTIONPOINTID_MASK_RESERVED); }

inline BOOL IsReservedCommandID( long lCommandID )
    { return (lCommandID & CCM_COMMANDID_MASK_RESERVED); }


#define MENUITEM_BASE_ID 1000

/*+-------------------------------------------------------------------------*
 * class CMenuItem
 *
 *
 * PURPOSE: Encapsulates all information, including how to execute,
 *          for a menu item.
 *
 *+-------------------------------------------------------------------------*/
class CMenuItem :
    public CTiedObject
{
    DECLARE_NOT_COPIABLE(CMenuItem)
    DECLARE_NOT_ASSIGNABLE(CMenuItem)
public:
    CMenuItem(  LPCTSTR                 lpszName,
                LPCTSTR                 lpszStatusBarText,
                LPCTSTR                 lpszLanguageIndependentName,
                LPCTSTR                 lpszPath,
                LPCTSTR                 lpszLanguageIndependentPath,
                long                    nCommandID,
                long                    nMenuItemID,
                long                    nFlags,
                MENU_OWNER_ID           ownerID,
                IExtendContextMenu *    pExtendContextMenu,
                IDataObject *           pDataObject,
                DWORD                   fSpecialFlags,
                bool                    bPassCommandBackToSnapin = false );
    virtual ~CMenuItem();

// Interfaces
public:
// use MFC's standard object validity technique
    virtual void AssertValid();

public:
    void    GetMenuItemName(LPTSTR pBuffer, int* pLen);
    LPCTSTR GetMenuItemName() const             { return m_strName; }
    LPCTSTR GetMenuItemStatusBarText() const    { return m_strStatusBarText; }
    LPCTSTR GetLanguageIndependentName() const  { return m_strLanguageIndependentName;}
    LPCTSTR GetPath()  const                    { return m_strPath;}
    LPCTSTR GetLanguageIndependentPath() const  { return m_strLanguageIndependentPath;}
    long    GetCommandID() const                { return m_nCommandID; }
    long    GetMenuItemID() const               { return m_nMenuItemID; }
    long    GetMenuItemFlags() const            { return m_nFlags; }
    void    SetMenuItemFlags( long nFlags )     { m_nFlags = nFlags; }
    MENU_OWNER_ID GetMenuItemOwner() const      { return m_OwnerID; }
    MenuItemList& GetMenuItemSubmenu()          { return m_SubMenu; }
    DWORD   GetSpecialFlags() const             { return m_fSpecialFlags;}
    HMENU   GetPopupMenuHandle()                { return m_PopupMenuHandle; }
    void    SetPopupMenuHandle( HMENU hmenu )   { m_PopupMenuHandle = hmenu; }
    BOOL    IsPopupMenu()                       { return (MF_POPUP & m_nFlags); }
    BOOL    IsSpecialItemDefault()              { return (m_fSpecialFlags & CCM_SPECIAL_DEFAULT_ITEM); }
    BOOL    IsSpecialSeparator()                { return (m_fSpecialFlags & CCM_SPECIAL_SEPARATOR); }
    BOOL    IsSpecialSubmenu()                  { return (m_fSpecialFlags & CCM_SPECIAL_SUBMENU); }
    BOOL    IsSpecialInsertionPoint()           { return (m_fSpecialFlags & CCM_SPECIAL_INSERTION_POINT); }
    BOOL    HasChildList()                      { return ((m_nFlags & MF_POPUP) || IsSpecialInsertionPoint()); }

    CMenuItem* FindItemByPath( LPCTSTR lpstrPath );

    // creates and returns a ContextMenu interface.
    SC      ScGetMenuItem(PPMENUITEM ppMenuItem);

    // MenuItem methods.
    virtual SC  ScExecute();     // executes the menu item.
    virtual SC  Scget_DisplayName(PBSTR pbstrName);
    virtual SC  Scget_LanguageIndependentName(PBSTR LanguageIndependentName);
    virtual SC  Scget_Path(PBSTR  pbstrPath);
    virtual SC  Scget_LanguageIndependentPath(PBSTR  LanguageIndependentPath);
    virtual SC  Scget_Enabled(PBOOL pBool);

    bool NeedsToPassCommandBackToSnapin() { return m_bPassCommandBackToSnapin; }
private:
    CStr                    m_strName;
    CStr                    m_strStatusBarText;
    CStr                    m_strPath;
    CStr                    m_strLanguageIndependentName;
    CStr                    m_strLanguageIndependentPath;
    long                    m_nCommandID;
    long                    m_nMenuItemID;
    long                    m_nFlags;
    MENU_OWNER_ID           m_OwnerID;
    long                    m_fSpecialFlags;
    HMENU                   m_PopupMenuHandle;
    MenuItemList            m_SubMenu;
    IExtendContextMenuPtr   m_spExtendContextMenu;  // the callback called when the item is executed.
    IDataObject*            m_pDataObject;

    BOOL                    m_bEnabled;

    MenuItemPtr             m_spMenuItem;
    bool                    m_bPassCommandBackToSnapin;
};


/*+-------------------------------------------------------------------------*
 *
 * CRootMenuItem
 *
 * PURPOSE: The root menu item.
 *
 * RETURNS:
 *    class
 *
 *+-------------------------------------------------------------------------*/
class
CRootMenuItem : public CMenuItem
{
public:
    CRootMenuItem() : CMenuItem(NULL/*lpszName*/, NULL/*lpszStatusBarText*/, NULL/*lpszLanguageIndependentName*/, 
                                NULL/*lpszPath*/, NULL/*lpszLanguageIndependentPath*/, 0/*nCommandID*/,
                                0/*nMenuItemID*/,MF_POPUP/*nFlags*/,0/*ownerID*/, NULL/*pExtendContextMenu*/, 
                                NULL/*pDataObject*/, 0/*fSpecialFlags*/) 
    {
    }

    virtual SC ScExecute() const {SC sc; return sc;} // does nothing.

};

/////////////////////////////////////////////////////////////////////////////
// SnapinStruct

class SnapinStruct
{
    // cannot assign - will unbalance m_pIDataObject refs
    DECLARE_NOT_COPIABLE(SnapinStruct)
    DECLARE_NOT_ASSIGNABLE(SnapinStruct)
public: 
    IExtendContextMenuPtr pIExtendContextMenu;
    MENU_OWNER_ID       m_OwnerID;
    IDataObject*        m_pIDataObject;

    SnapinStruct(   IExtendContextMenu* pintf,
                    IDataObject* pIDataObject,
                    MENU_OWNER_ID ownerID)
    :   pIExtendContextMenu( pintf ),
        m_OwnerID( ownerID )
    {
        ASSERT( NULL != pintf && NULL != pIDataObject );
        m_pIDataObject = pIDataObject;

        if (! IS_SPECIAL_DATAOBJECT(m_pIDataObject))
            m_pIDataObject->AddRef();
    }

    ~SnapinStruct()
    {
        if (! IS_SPECIAL_DATAOBJECT(m_pIDataObject))
            m_pIDataObject->Release();
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\mmcprotocol.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       mmcprotocol.h
//
//  Purpose: Creates a temporary pluggable internet protocol, mmc:
//
//  History: 14-April-2000 Vivekj added
//--------------------------------------------------------------------------

extern const CLSID CLSID_MMCProtocol;

class CMMCProtocol : 
    public IInternetProtocol,
    public IInternetProtocolInfo,
    public CComObjectRoot,
    public CComCoClass<CMMCProtocol, &CLSID_MMCProtocol>
{
    typedef CMMCProtocol ThisClass;

public:
    BEGIN_COM_MAP(ThisClass)
        COM_INTERFACE_ENTRY(IInternetProtocol)
        COM_INTERFACE_ENTRY(IInternetProtocolRoot)
	    COM_INTERFACE_ENTRY(IInternetProtocolInfo)
    END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(ThisClass)

    DECLARE_MMC_OBJECT_REGISTRATION (
		g_szMmcndmgrDll,						// implementing DLL
        CLSID_MMCProtocol     ,				    // CLSID
        _T("MMC Plugable Internet Protocol"),   // class name
        _T("NODEMGR.MMCProtocol.1"),		    // ProgID
        _T("NODEMGR.MMCProtocol"))		        // version-independent ProgID


    static SC ScRegisterProtocol();
    static SC ScParseTaskpadURL( LPCWSTR strURL, GUID& guid );
    static SC ScParsePageBreakURL( LPCWSTR strURL, bool& bPageBreak );
    static SC ScGetTaskpadXML( const GUID& guid, std::wstring& strResultData );
    static void ExpandMMCVars(std::wstring& str);
    static void AppendMMCPath(std::wstring& str);

    // IInternetProtocolRoot interface

    STDMETHODIMP Start(LPCWSTR szUrl, IInternetProtocolSink *pOIProtSink, IInternetBindInfo *pOIBindInfo, DWORD grfPI, HANDLE_PTR dwReserved);
    STDMETHODIMP Continue(PROTOCOLDATA *pProtocolData);
    STDMETHODIMP Abort(HRESULT hrReason, DWORD dwOptions);
    STDMETHODIMP Terminate(DWORD dwOptions);
    STDMETHODIMP Suspend();
    STDMETHODIMP Resume();

    // IInternetProtocol interface

    STDMETHODIMP Read(void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHODIMP Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
    STDMETHODIMP LockRequest(DWORD dwOptions);    
    STDMETHODIMP UnlockRequest();

    // IInternetProtocolInfo interface
    STDMETHODIMP ParseUrl(  LPCWSTR pwzUrl, PARSEACTION ParseAction, DWORD dwParseFlags, LPWSTR pwzResult, DWORD cchResult, DWORD *pcchResult, DWORD dwReserved);
    STDMETHODIMP CombineUrl(LPCWSTR pwzBaseUrl, LPCWSTR pwzRelativeUrl,DWORD dwCombineFlags, LPWSTR pwzResult, DWORD cchResult, DWORD *pcchResult, DWORD dwReserved);
    STDMETHODIMP CompareUrl(LPCWSTR pwzUrl1, LPCWSTR pwzUrl2,DWORD dwCompareFlags);
    STDMETHODIMP QueryInfo( LPCWSTR pwzUrl, QUERYOPTION OueryOption,DWORD dwQueryFlags, LPVOID pBuffer, DWORD cbBuffer, DWORD *pcbBuf, DWORD dwReserved);

private:
    std::wstring             m_strData;      // contents of the specified URL             
    size_t                   m_uiReadOffs;   // present read location
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\mmcprotocol.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       mmcprotocol.h
//
//  Purpose: Creates a temporary pluggable internet protocol, mmc://
//
//  History: 14-April-2000 Vivekj added
//--------------------------------------------------------------------------

#include<stdafx.h>

#include<mmcprotocol.h>
#include "tasks.h"
#include "typeinfo.h" // for COleCacheCleanupObserver

// {3C5F432A-EF40-4669-9974-9671D4FC2E12}
static const CLSID CLSID_MMCProtocol = { 0x3c5f432a, 0xef40, 0x4669, { 0x99, 0x74, 0x96, 0x71, 0xd4, 0xfc, 0x2e, 0x12 } };
static const WCHAR szMMC[] =  _W(MMC_PROTOCOL_SCHEMA_NAME);
static const WCHAR szMMCC[] = _W(MMC_PROTOCOL_SCHEMA_NAME) _W(":");
static const WCHAR szPageBreak[] = _W(MMC_PAGEBREAK_RELATIVE_URL);

static const WCHAR szMMCRES[] = L"%mmcres%";
static const WCHAR chUNICODE = 0xfeff;

#ifdef DBG
CTraceTag tagProtocol(_T("MMC iNet Protocol"), _T("MMCProtocol"));
#endif //DBG

/***************************************************************************\
 *
 * FUNCTION:  HasSchema
 *
 * PURPOSE: helper: determines if URL contains schema (like "something:" or "http:" )
 *
 * PARAMETERS:
 *    LPCWSTR strURL
 *
 * RETURNS:
 *    bool ; true == does contain schema
 *
\***************************************************************************/
inline bool HasSchema(LPCWSTR strURL)
{
    if (strURL == NULL)
        return false;

    // skip spaces and schema name
    while ( iswspace(*strURL) || iswalnum(*strURL) )
        strURL++;

    // valid schema ends with ':'
    return *strURL == L':';
}

/***************************************************************************\
 *
 * FUNCTION:  HasMMCSchema
 *
 * PURPOSE: helper: determines if URL contains mmc schema ( begins with "mmc:" )
 *
 * PARAMETERS:
 *    LPCWSTR strURL
 *
 * RETURNS:
 *    bool ; true == does contain mmc schema
 *
\***************************************************************************/
inline bool HasMMCSchema(LPCWSTR strURL)
{
    if (strURL == NULL)
        return false;

    // skip spaces
    while ( iswspace(*strURL) )
        strURL++;

    return (0 == _wcsnicmp( strURL, szMMCC, wcslen(szMMCC) ) );
}

/***************************************************************************\
 *
 * CLASS:  CMMCProtocolRegistrar
 *
 * PURPOSE: register/ unregisters mmc protocol.
 *          Also class provides cleanup functionality. Because it registers as
 *          COleCacheCleanupObserver, it will receive the event when MMC
 *          is about to uninitialize OLE, and will revoke registered mmc protocol
 *
\***************************************************************************/
class CMMCProtocolRegistrar : public COleCacheCleanupObserver
{
    bool               m_bRegistered;
    IClassFactoryPtr   m_spClassFactory;
public:
    // c-tor.
    CMMCProtocolRegistrar() : m_bRegistered(false) {}

    // registration / unregistration
    SC ScRegister();
    SC ScUnregister();

    // event sensor - unregisters mmc protocol
    virtual SC ScOnReleaseCachedOleObjects()
    {
        DECLARE_SC(sc, TEXT("ScOnReleaseCachedOleObjects"));

        return sc = ScUnregister();
    }
};

/***************************************************************************\
 *
 * METHOD:  CMMCProtocolRegistrar::ScRegister
 *
 * PURPOSE: registers the protocol if required
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCProtocolRegistrar::ScRegister()
{
    DECLARE_SC(sc, TEXT("CMMCProtocolRegistrar::ScRegister"));

    // one time registration only
    if(m_bRegistered)
        return sc;

    // get internet session
    IInternetSessionPtr spInternetSession;
    sc = CoInternetGetSession(0, &spInternetSession, 0);
    if(sc)
        return sc;

    // doublecheck
    sc = ScCheckPointers(spInternetSession, E_FAIL);
    if(sc)
        return sc;

    // ask CComModule for the class factory
    sc = _Module.GetClassObject(CLSID_MMCProtocol, IID_IClassFactory, (void **)&m_spClassFactory);
    if(sc)
        return sc;

    // register the namespace
    sc = spInternetSession->RegisterNameSpace(m_spClassFactory, CLSID_MMCProtocol, szMMC, 0, NULL, 0);
    if(sc)
        return sc;

    // start observing cleanup requests - to unregister in time
    COleCacheCleanupManager::AddOleObserver(this);

    m_bRegistered = true; // did it.
    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMMCProtocolRegistrar::ScUnregister
 *
 * PURPOSE: unregisters the protocol if one was registered
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCProtocolRegistrar::ScUnregister()
{
    DECLARE_SC(sc, TEXT("CMMCProtocolRegistrar::ScUnregister"));

    if (!m_bRegistered)
        return sc;

    // unregister
    IInternetSessionPtr spInternetSession;
    sc = CoInternetGetSession(0, &spInternetSession, 0);
    if(sc)
    {
        sc.Clear(); // no session - no headache
    }
    else // need to unregister
    {
        // recheck
        sc = ScCheckPointers(spInternetSession, E_UNEXPECTED);
        if(sc)
            return sc;

        // unregister the namespace
        sc = spInternetSession->UnregisterNameSpace(m_spClassFactory, szMMC);
        if(sc)
            return sc;
    }

    m_spClassFactory.Release();
    m_bRegistered = false;

    return sc;
}



/***************************************************************************\
 *
 * METHOD:  CMMCProtocol::ScRegisterProtocol
 *
 * PURPOSE: Registers mmc protocol. IE will resove "mmc:..." ULRs to it
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC
CMMCProtocol::ScRegisterProtocol()
{
    DECLARE_SC(sc, TEXT("CMMCProtocol::ScRegisterProtocol"));

    // registrar (unregisters on cleanup event) - needs to be static
    static CMMCProtocolRegistrar registrar;

    // let the registrar do the job
    return sc = registrar.ScRegister();
}

//*****************************************************************************
// IInternetProtocolRoot interface
//*****************************************************************************

/***************************************************************************\
 *
 * METHOD:  CMMCProtocol::Start
 *
 * PURPOSE: Starts data download thru this protocol
 *
 * PARAMETERS:
 *    LPCWSTR szUrl
 *    IInternetProtocolSink *pOIProtSink
 *    IInternetBindInfo *pOIBindInfo
 *    DWORD grfPI
 *    HANDLE_PTR dwReserved
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
STDMETHODIMP
CMMCProtocol::Start(LPCWSTR szUrl, IInternetProtocolSink *pOIProtSink, IInternetBindInfo *pOIBindInfo, DWORD grfPI, HANDLE_PTR dwReserved)
{
    DECLARE_SC(sc, TEXT("CMMCProtocol::Start"));

    // check inputs
    sc = ScCheckPointers(szUrl, pOIProtSink, pOIBindInfo);
    if(sc)
        return sc.ToHr();

    // reset position for reading
    m_uiReadOffs = 0;

    bool bPageBreakRequest = false;

    // see if it was a pagebreak requested
    sc = ScParsePageBreakURL( szUrl, bPageBreakRequest );
    if(sc)
        return sc.ToHr();

    if ( bPageBreakRequest )
    {
        // just report success (S_OK/S_FALSE) in case we were just parsing
        if ( grfPI & PI_PARSE_URL )
            return sc.ToHr();

        // construct a pagebreak
        m_strData  = L"<HTML/>";

        sc = pOIProtSink->ReportProgress(BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE, L"text/html");
        if (sc)
            sc.TraceAndClear(); // ignore and continue
    }
    else
    {
        //if  not a pagebreak - then taskpad
        GUID guidTaskpad = GUID_NULL;
        sc = ScParseTaskpadURL( szUrl, guidTaskpad );
        if(sc)
            return sc.ToHr();

        // report the S_FALSE instead of error in case we were just parsing
        if ( grfPI & PI_PARSE_URL )
            return ( sc.IsError() ? (sc = S_FALSE) : sc ).ToHr();

        if (sc)
            return sc.ToHr();

        // load the contents
        sc = ScGetTaskpadXML( guidTaskpad, m_strData );
        if (sc)
            return sc.ToHr();

        sc = pOIProtSink->ReportProgress(BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE, L"text/html");
        if (sc)
            sc.TraceAndClear(); // ignore and continue
    }

    const DWORD grfBSCF = BSCF_LASTDATANOTIFICATION | BSCF_DATAFULLYAVAILABLE;
    const DWORD dwDataSize = m_strData.length() * sizeof (WCHAR);
    sc = pOIProtSink->ReportData(grfBSCF, dwDataSize , dwDataSize);
    if (sc)
        sc.TraceAndClear(); // ignore and continue

    sc = pOIProtSink->ReportResult(0, 0, 0);
    if (sc)
        sc.TraceAndClear(); // ignore and continue

    return sc.ToHr();
}

STDMETHODIMP CMMCProtocol::Continue(PROTOCOLDATA *pProtocolData)    { return E_NOTIMPL; }
STDMETHODIMP CMMCProtocol::Abort(HRESULT hrReason, DWORD dwOptions) { return S_OK; }
STDMETHODIMP CMMCProtocol::Terminate(DWORD dwOptions)               { return S_OK; }
STDMETHODIMP CMMCProtocol::LockRequest(DWORD dwOptions)             { return S_OK; }
STDMETHODIMP CMMCProtocol::UnlockRequest()                          { return S_OK; }
STDMETHODIMP CMMCProtocol::Suspend()                                { return E_NOTIMPL; }
STDMETHODIMP CMMCProtocol::Resume()                                 { return E_NOTIMPL; }

STDMETHODIMP CMMCProtocol::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
{
    return E_NOTIMPL;
}



//*****************************************************************************
// IInternetProtocol interface
//*****************************************************************************

/***************************************************************************\
 *
 * METHOD:  CMMCProtocol::Read
 *
 * PURPOSE: Reads data from the protocol
 *
 * PARAMETERS:
 *    void *pv
 *    ULONG cb
 *    ULONG *pcbRead
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
STDMETHODIMP CMMCProtocol::Read(void *pv, ULONG cb, ULONG *pcbRead)
{
    DECLARE_SC(sc, TEXT("CMMCProtocol::Read"));

    // parameter check;
    sc = ScCheckPointers(pv, pcbRead);
    if(sc)
        return sc.ToHr();

    // init out parameter;
    *pcbRead = 0;

    size_t size = ( m_strData.length() ) * sizeof(WCHAR);

    if ( size <= m_uiReadOffs )
        return (sc = S_FALSE).ToHr(); // no more data

    // calculate the size we'll return
    *pcbRead = size - m_uiReadOffs;
    if (size - m_uiReadOffs > cb)
        *pcbRead = cb;

    if (*pcbRead)
        memcpy( pv, reinterpret_cast<const BYTE*>( m_strData.begin() ) + m_uiReadOffs, *pcbRead );

    m_uiReadOffs += *pcbRead;

    if ( size <= m_uiReadOffs )
        return (sc = S_FALSE).ToHr(); // no more data

    return sc.ToHr();
}

//*****************************************************************************
// IInternetProtocolInfo interface
//*****************************************************************************

STDMETHODIMP
CMMCProtocol::ParseUrl(  LPCWSTR pwzUrl, PARSEACTION ParseAction, DWORD dwParseFlags, LPWSTR pwzResult, DWORD cchResult, DWORD *pcchResult, DWORD dwReserved)
{
    DECLARE_SC(sc, TEXT("CMMCProtocol::ParseUrl"));

    if (ParseAction == PARSE_SECURITY_URL)
    {
        // get system directory (like "c:\winnt\system32\")
        std::wstring windir;
        AppendMMCPath(windir);
        windir += L'\\';

        // we are as secure as windir is - report the url (like "c:\winnt\system32\")
        *pcchResult = windir.length() + 1;

        // check if we have enough place for the result and terminating zero
        if ( cchResult <= windir.length() )
            return S_FALSE; // not enough

        wcscpy(pwzResult, windir.c_str());
        return (sc = S_OK).ToHr();
    }

    return INET_E_DEFAULT_ACTION;
}


/***************************************************************************\
 *
 * METHOD:  CMMCProtocol::CombineUrl
 *
 * PURPOSE: combines base + relative url to resulting url
 *          we do local variable substitution here
 *
 * PARAMETERS:
 *    LPCWSTR pwzBaseUrl
 *    LPCWSTR pwzRelativeUrl
 *    DWORD dwCombineFlags
 *    LPWSTR pwzResult
 *    DWORD cchResult
 *    DWORD *pcchResult
 *    DWORD dwReserved
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
STDMETHODIMP CMMCProtocol::CombineUrl(LPCWSTR pwzBaseUrl, LPCWSTR pwzRelativeUrl, DWORD dwCombineFlags, LPWSTR pwzResult, DWORD cchResult, DWORD *pcchResult, DWORD dwReserved)
{
    DECLARE_SC(sc, TEXT("CMMCProtocol::CombineUrl"));

#ifdef DBG
    USES_CONVERSION;
    Trace(tagProtocol, _T("CombineUrl: [%s] + [%s]"), W2CT(pwzBaseUrl), W2CT(pwzRelativeUrl));
#endif //DBG

    std::wstring temp1;
    if (HasMMCSchema(pwzBaseUrl))
    {
        // our stuff

        temp1 = pwzRelativeUrl;
        ExpandMMCVars(temp1);

        if ( ! HasSchema( temp1.c_str() ) )
        {
            // combine everything into relative URL
            temp1.insert( 0, pwzBaseUrl );
        }

        // form 'new' relative address
        pwzRelativeUrl = temp1.c_str();

        // say we are refered from http - let it do the dirty job ;)
        pwzBaseUrl = L"http://";
    }

    // since we stripped out ourselfs from pwzBaseUrl - it will not recurse back,
    // but will do original html stuff
    sc = CoInternetCombineUrl( pwzBaseUrl, pwzRelativeUrl, dwCombineFlags, pwzResult, cchResult, pcchResult, dwReserved );
    if (sc)
        return sc.ToHr();

    Trace(tagProtocol, _T("CombineUrl: == [%s]"), W2CT(pwzResult));

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CMMCProtocol::CompareUrl
 *
 * PURPOSE: compares URLs if they are the same
 *
 * PARAMETERS:
 *    LPCWSTR pwzUrl1
 *    LPCWSTR pwzUrl2
 *    DWORD dwCompareFlags
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
STDMETHODIMP CMMCProtocol::CompareUrl(LPCWSTR pwzUrl1, LPCWSTR pwzUrl2,DWORD dwCompareFlags)
{
    DECLARE_SC(sc, TEXT("CMMCProtocol::CompareUrl"));

    return INET_E_DEFAULT_ACTION;
}

/***************************************************************************\
 *
 * METHOD:  CMMCProtocol::QueryInfo
 *
 * PURPOSE: Queries info about URL
 *
 * PARAMETERS:
 *    LPCWSTR pwzUrl
 *    QUERYOPTION QueryOption
 *    DWORD dwQueryFlags
 *    LPVOID pBuffer
 *    DWORD cbBuffer
 *    DWORD *pcbBuf
 *    DWORD dwReserved
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
STDMETHODIMP CMMCProtocol::QueryInfo( LPCWSTR pwzUrl, QUERYOPTION QueryOption,DWORD dwQueryFlags, LPVOID pBuffer, DWORD cbBuffer, DWORD *pcbBuf, DWORD dwReserved)
{
    DECLARE_SC(sc, TEXT("CMMCProtocol::QueryInfo"));

    if (QueryOption == QUERY_USES_NETWORK)
    {
        if (cbBuffer >= 4)
        {
            *(LPDWORD)pBuffer = FALSE; // does not use the network
            *pcbBuf = 4;
            return S_OK;
        }
    }
    else if (QueryOption == QUERY_IS_SAFE)
    {
        if (cbBuffer >= 4)
        {
            *(LPDWORD)pBuffer = TRUE; // only serves trusted content
            *pcbBuf = 4;
            return S_OK;
        }
    }


    return INET_E_DEFAULT_ACTION;
}

/***************************************************************************\
 *
 * METHOD:  CMMCProtocol::ScParseTaskpadURL
 *
 * PURPOSE: Extracts taskpad guid from URL given to the protocol
 *
 * PARAMETERS:
 *    LPCWSTR strURL [in] - URL
 *    GUID& guid     [out] - extracted guid
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCProtocol::ScParseTaskpadURL( LPCWSTR strURL, GUID& guid )
{
    DECLARE_SC(sc, TEXT("CMMCProtocol::ScParseTaskpadURL"));

    guid = GUID_NULL;

    sc = ScCheckPointers(strURL);
    if (sc)
        return sc;

    // taskpad url should be in form "mmc:{guid}"

    // check for "mmc:"
    if ( 0 != _wcsnicmp( strURL, szMMCC, wcslen(szMMCC) ) )
        return sc = E_FAIL;

    // skip "mmc:"
    strURL += wcslen(szMMCC);

    // get the url
    sc = CLSIDFromString( const_cast<LPWSTR>(strURL), &guid );
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMMCProtocol::ScParsePageBreakURL
 *
 * PURPOSE: Checks if URL given to the protocol is a request for a pagebreak
 *
 * PARAMETERS:
 *    LPCWSTR strURL    [in] - URL
 *    bool& bPageBreak  [out] - true it it is a request for pagebreak
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCProtocol::ScParsePageBreakURL( LPCWSTR strURL, bool& bPageBreak )
{
    DECLARE_SC(sc, TEXT("CMMCProtocol::ScParsePageBreakURL"));

    bPageBreak = false;

    sc = ScCheckPointers(strURL);
    if (sc)
        return sc;

    // pagebreak url should be in form "mmc:pagebreak.<number>"

    // check for "mmc:"
    if ( 0 != _wcsnicmp( strURL, szMMCC, wcslen(szMMCC) ) )
        return sc; // not an error - return value updated

    // skip "mmc:"
    strURL += wcslen(szMMCC);

    // get the url
    bPageBreak = ( 0 == wcsncmp( strURL, szPageBreak, wcslen(szPageBreak) ) );

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMMCProtocol::ScGetTaskpadXML
 *
 * PURPOSE: given the guid uploads taskpad XML string to the string
 *
 * PARAMETERS:
 *    const GUID& guid              [in] - taskpad guid
 *    std::wstring& strResultData   [out] - taskpad xml string
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCProtocol::ScGetTaskpadXML( const GUID& guid, std::wstring& strResultData )
{
    DECLARE_SC(sc, TEXT("CMMCProtocol::ScGetTaskpadXML"));

    strResultData.erase();

    CScopeTree* pScopeTree = CScopeTree::GetScopeTree();

    sc = ScCheckPointers(pScopeTree, E_FAIL);
    if(sc)
        return sc.ToHr();

    CConsoleTaskpadList * pConsoleTaskpadList = pScopeTree->GetConsoleTaskpadList();
    sc = ScCheckPointers(pConsoleTaskpadList, E_FAIL);
    if(sc)
        return sc.ToHr();

    for(CConsoleTaskpadList::iterator iter = pConsoleTaskpadList->begin(); iter!= pConsoleTaskpadList->end(); ++iter)
    {
        CConsoleTaskpad &consoleTaskpad = *iter;

        // check if this is the one we are looking for
        if ( !IsEqualGUID( guid, consoleTaskpad.GetID() ) )
            continue;

        // convert the taskpad to a string
        CStr strTaskpadHTML;
        sc = consoleTaskpad.ScGetHTML(strTaskpadHTML); // create a string version of the taskpad
        if(sc)
            return sc.ToHr();

        // form the result string
        USES_CONVERSION;
        strResultData = chUNICODE;
        strResultData += T2CW(strTaskpadHTML);

        return sc;
    }

    // not found
    return sc = E_FAIL;
}

/***************************************************************************\
 *
 * METHOD:  CMMCProtocol::AppendMMCPath
 *
 * PURPOSE: helper. Appends the mmcndmgr.dll dir (no file name) to the string
 *          It may append something like: "c:\winnt\system32"
 *
 * PARAMETERS:
 *    std::wstring& str [in/out] - string to edit
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
void CMMCProtocol::AppendMMCPath(std::wstring& str)
{
    TCHAR szModule[_MAX_PATH+10] = { 0 };
    GetModuleFileName(_Module.GetModuleInstance(), szModule, _MAX_PATH);

    USES_CONVERSION;
    LPCWSTR strModule = T2CW(szModule);

    LPCWSTR dirEnd = wcsrchr( strModule, L'\\' );
    if (dirEnd != NULL)
        str.append(strModule, dirEnd);
}

/***************************************************************************\
 *
 * METHOD:  CMMCProtocol::ExpandMMCVars
 *
 * PURPOSE: helper. expands any %mmcres% contained in the string
 *          It expands it to something like "res://c:\winnt\system32\mmcndmgr.dll"
 *
 * PARAMETERS:
 *    std::wstring& str [in/out] - string to edit
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
void CMMCProtocol::ExpandMMCVars(std::wstring& str)
{
    // first - form the values
    TCHAR szModule[_MAX_PATH+10] = { 0 };
    GetModuleFileName(_Module.GetModuleInstance(), szModule, _MAX_PATH);

    USES_CONVERSION;
    LPCWSTR strModule = T2CW(szModule);

    std::wstring mmcres = L"res://";
    mmcres += strModule;

    // second - replace the instances

    int pos;
    while (std::wstring::npos != (pos = str.find(szMMCRES) ) )
    {
        // make one substitution
        str.replace( pos, wcslen(szMMCRES), mmcres) ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\mfccllct.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       mfccllct.h
//
//--------------------------------------------------------------------------

#ifndef __MFCCLLCT_H
#define __MFCCLLCT_H


namespace MMC       // Temporary for the MFC->ATL conversion
{


class CPtrList 
{
protected:
    struct CNode
    {
        CNode* pNext;
        CNode* pPrev;
        void* data;
    };
public:

// Construction
    CPtrList(int nBlockSize = 10);

// Attributes (head and tail)
    // count of elements
    int GetCount() const;
    BOOL IsEmpty() const;

    // peek at head or tail
    void*& GetHead();
    void* GetHead() const;
    void*& GetTail();
    void* GetTail() const;

// Operations
    // get head or tail (and remove it) - don't call on empty list!
    void* RemoveHead();
    void* RemoveTail();

    // add before head or after tail
    POSITION AddHead(void* newElement);
    POSITION AddTail(void* newElement);

    // add another list of elements before head or after tail
    void AddHead(CPtrList* pNewList);
    void AddTail(CPtrList* pNewList);

    // remove all elements
    void RemoveAll();

    // iteration
    POSITION GetHeadPosition() const;
    POSITION GetTailPosition() const;
    void*& GetNext(POSITION& rPosition); // return *Position++
    void* GetNext(POSITION& rPosition) const; // return *Position++
    void*& GetPrev(POSITION& rPosition); // return *Position--
    void* GetPrev(POSITION& rPosition) const; // return *Position--

    // getting/modifying an element at a given position
    void*& GetAt(POSITION position);
    void* GetAt(POSITION position) const;
    void SetAt(POSITION pos, void* newElement);
    void RemoveAt(POSITION position);

    // inserting before or after a given position
    POSITION InsertBefore(POSITION position, void* newElement);
    POSITION InsertAfter(POSITION position, void* newElement);

    // helper functions (note: O(n) speed)
    POSITION Find(void* searchValue, POSITION startAfter = NULL) const;
                        // defaults to starting at the HEAD
                        // return NULL if not found
    POSITION FindIndex(int nIndex) const;
                        // get the 'nIndex'th element (may return NULL)

// Implementation
protected:
    CNode* m_pNodeHead;
    CNode* m_pNodeTail;
    int m_nCount;
    CNode* m_pNodeFree;
    struct CPlex* m_pBlocks;
    int m_nBlockSize;

    CNode* NewNode(CNode*, CNode*);
    void FreeNode(CNode*);

public:
    ~CPtrList();
#ifdef _DBG
    void AssertValid() const;
#endif
    // local typedefs for class templates
    typedef void* BASE_TYPE;
    typedef void* BASE_ARG_TYPE;
};

inline int CPtrList::GetCount() const
    { return m_nCount; }
inline BOOL CPtrList::IsEmpty() const
    { return m_nCount == 0; }
inline void*& CPtrList::GetHead()
    { ASSERT(m_pNodeHead != NULL);
        return m_pNodeHead->data; }
inline void* CPtrList::GetHead() const
    { ASSERT(m_pNodeHead != NULL);
        return m_pNodeHead->data; }
inline void*& CPtrList::GetTail()
    { ASSERT(m_pNodeTail != NULL);
        return m_pNodeTail->data; }
inline void* CPtrList::GetTail() const
    { ASSERT(m_pNodeTail != NULL);
        return m_pNodeTail->data; }
inline POSITION CPtrList::GetHeadPosition() const
    { return (POSITION) m_pNodeHead; }
inline POSITION CPtrList::GetTailPosition() const
    { return (POSITION) m_pNodeTail; }
inline void*& CPtrList::GetNext(POSITION& rPosition) // return *Position++
    { CNode* pNode = (CNode*) rPosition;
        ASSERT(_IsValidAddress(pNode, sizeof(CNode)));
        rPosition = (POSITION) pNode->pNext;
        return pNode->data; }
inline void* CPtrList::GetNext(POSITION& rPosition) const // return *Position++
    { CNode* pNode = (CNode*) rPosition;
        ASSERT(_IsValidAddress(pNode, sizeof(CNode)));
        rPosition = (POSITION) pNode->pNext;
        return pNode->data; }
inline void*& CPtrList::GetPrev(POSITION& rPosition) // return *Position--
    { CNode* pNode = (CNode*) rPosition;
        ASSERT(_IsValidAddress(pNode, sizeof(CNode)));
        rPosition = (POSITION) pNode->pPrev;
        return pNode->data; }
inline void* CPtrList::GetPrev(POSITION& rPosition) const // return *Position--
    { CNode* pNode = (CNode*) rPosition;
        ASSERT(_IsValidAddress(pNode, sizeof(CNode)));
        rPosition = (POSITION) pNode->pPrev;
        return pNode->data; }
inline void*& CPtrList::GetAt(POSITION position)
    { CNode* pNode = (CNode*) position;
        ASSERT(_IsValidAddress(pNode, sizeof(CNode)));
        return pNode->data; }
inline void* CPtrList::GetAt(POSITION position) const
    { CNode* pNode = (CNode*) position;
        ASSERT(_IsValidAddress(pNode, sizeof(CNode)));
        return pNode->data; }
inline void CPtrList::SetAt(POSITION pos, void* newElement)
    { CNode* pNode = (CNode*) pos;
        ASSERT(_IsValidAddress(pNode, sizeof(CNode)));
        pNode->data = newElement; }


}       // MMC namespace

      
#endif  // __MFCCLLCT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\moreutil.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       moreutil.cpp
//
//--------------------------------------------------------------------------

/*
    moreutil.cpp
    
    Utility functions for the nodemgr without MFC
*/


#include "stdafx.h"
#include "macros.h"


BOOL _IsValidAddress( const void* lp, UINT nBytes, BOOL bReadWrite )
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\mmcres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by nodemgr.rc
//
#define IDD_SNAPIN_ABOUT                107
#define IDD_TASKS                       108
#define IDB_SETUPWIZARD                 137
#define IDB_CHECKBOX                    138
#define IDD_ACTIVEX_WIZPAGE1            143
#define IDD_ACTIVEX_WIZPAGE2            144
#define IDD_HTML_WIZPAGE1               145
#define IDD_HTML_WIZPAGE2               146
#define IDD_ACTIVEX_WIZPAGE0            149
#define IDD_NOPROPS_PROPPAGE            156
#define IDB_SNP_MANAGER                 158
#define IDD_SNAPIN_MANAGER_ADD          159
#define IDB_IMAGELIST                   200
#define IDB_SETUPWIZARD1                201
#define IDC_CTRLPROPERTIES              204
#define IDC_CATEGORY_COMBOEX            212
#define IDB_TPPreview_HorzLrg           216
#define IDB_TPPreview_HorzMed           217
#define IDB_TPPreview_HorzSml           218
#define IDB_TPPreview_HorzLrgD          219
#define IDB_TPPreview_HorzMedD          220
#define IDB_TPPreview_HorzSmlD          221
#define IDB_TPPreview_Tasks             222
#define IDB_TPPreview_TasksD            223
#define IDB_TPPreview_VertLrg           224
#define IDB_TPPreview_VertMed           225
#define IDB_TPPreview_VertSml           226
#define IDB_TPPreview_VertLrgD          227
#define IDB_TPPreview_VertMedD          228
#define IDB_TPPreview_VertSmlD          229
#define IDB_TASKPAD_WIZARD_HEADER       230
#define IDR_FOLDERSNAPIN                232
#define IDB_OCX_WIZARD_HEADER           234
#define IDC_CONTROLXLS                  1000
#define IDC_TASKPAD_TITLE               1001
#define IDC_Options                     1012
#define IDC_NEW_TASK_BT                 1014
#define IDC_REMOVE_TASK                 1015
#define IDC_MODIFY                      1017
#define IDC_START_TASK_WIZARD           1018
#define IDC_MOVE_UP                     1020
#define IDC_MOVE_DOWN                   1021
#define IDC_DISPLAYTX                   1022
#define IDC_TARGETTX                    1023
#define IDC_BROWSEBT                    1024
#define IDC_INFOBT                      1025
#define IDC_ALLOP                       1026
#define IDC_CHECK1                      1032
#define IDC_MONITOROP                   1033
#define IDC_FixedLevelCount             1034
#define IDC_CustomContextFormat         1041
#define IDC_FINDTARGETBT                1047
#define IDC_CHANGEICONBT                1048
#define IDC_SNAPIN_LV                   1049
#define IDC_TOOLBAR                     1053
#define IDD_SNAPIN_STANDALONE_PROPP     1055
#define IDD_SNAPIN_EXTENSION_PROPP      1056
#define IDD_TASKPAD_GENERAL             1057
#define IDD_TASKPAD_ADVANCED            1059
#define IDD_COLUMNS                     1070
#define IDD_TASK_WIZARD_WELCOME         1072
#define IDB_TASKPAD_WIZARD_WELCOME      1073
#define IDD_TASK_WIZARD_NAME_PAGE       1074
#define IDD_TASK_WIZARD_SYMBOL_PAGE     1075
#define IDD_TASK_WIZARD_CMDLINE_PAGE    1076
#define IDD_TASK_WIZARD_MENU_PAGE       1077
#define IDD_TASK_PROPS_CMDLINE_PAGE     1080
#define IDD_TASK_PROPS_NAME_PAGE        1081
#define IDD_TASK_PROPS_SYMBOL_PAGE      1082
#define IDD_TASKPAD_WIZARD_WELCOME      1083
#define IDD_TASKPAD_WIZARD_STYLE_PAGE   1084
#define IDD_TASKPAD_WIZARD_NAME_PAGE    1085
#define IDD_CUSTOMIZE_VIEW              1086
#define IDD_TASKPAD_WIZARD_TITLE_PAGE   1087
#define IDB_FOLDER_32                   1087
#define IDB_FOLDER_16                   1088
#define IDD_TASK_WIZARD_TYPE_PAGE       1089
#define IDD_TASK_WIZARD_FINISH          1090
#define IDB_FOLDEROPEN_16               1090
#define IDB_OCX_16                      1091
#define IDB_HTML_16                     1092
#define IDB_OCX_32                      1093
#define IDB_HTML_32                     1094
#define IDD_TASKPAD_WIZARD_FINISH       1097
#define IDI_FOLDER                      1097
#define IDD_TASKPAD_WIZARD_NODETYPE_PAGE 1098
#define IDI_HTML                        1098
#define IDD_TASK_WIZARD_FAVORITE_PAGE   1099
#define IDI_OCX                         1099
#define IDC_APPICON                     4000
#define IDC_COMPANY_NAME                4002
#define IDC_DESCRIPTION                 4003
#define IDC_VERSION                     4004
#define IDC_DESCRIPTION2                4004
#define IDC_LINE                        4005
#define IDC_SNAPIN_NAME                 4006
#define IDC_SNAPIN_DESCR                4007
#define IDC_SNAPIN_MANAGER_ADD          4008
#define IDC_SNAPIN_MANAGER_DELETE       4009
#define IDC_SNAPIN_DESCR_LABEL          4010
#define IDC_SNAPIN_ADDED_LIST           4011
#define IDC_SNAPIN_ABOUT                4014
#define IDC_SNAPIN_COMBOEX              4018
#define IDC_EXTENSION_LIST              4020
#define IDC_VTHELPER                    4021
#define IDC_SNAPIN_LABEL                4022
#define IDC_EXTENSION_LABEL             4023
#define IDC_NOPROPS                     4024
#define IDC_SNAPIN_ENABLEALL            4025
#define IDC_SNAPIN_DOWNLOAD             4026
#define IDC_STYLE_DESCRIPTION           4033
#define IDC_LIST_TASKS                  4036
#define IDC_FixedLevelCountSpin         4044
#define IDC_UseFixedFormat              4046
#define IDC_UseCustomContextFormat      4047
#define IDC_NoCaption                   4048
#define IDC_BrowseForCommand            4050
#define IDC_BrowseForWorkingDir         4051
#define IDC_Command                     4052
#define IDC_CommandArgs                 4053
#define IDC_CommandArgsLabel            4054
#define IDC_CommandLabel                4055
#define IDC_CommandWindowStateCombo     4058
#define IDC_CommandWindowStateComboLabel 4059
#define IDC_CommandWorkingDir           4060
#define IDC_CommandWorkingDirLabel      4061
#define IDC_CommandList                 4067
#define IDC_CommandListLabel            4068
#define IDC_ScopeTree                   4069
#define IDC_TaskName                    4071
#define IDC_TaskNameLabel               4072
#define IDC_BrowseForArguments          4080
#define IDC_HIDDEN_COLUMNS              4084
#define IDC_ADD_COLUMNS                 4085
#define IDC_REMOVE_COLUMNS              4086
#define IDC_RESTORE_DEFAULT_COLUMNS     4087
#define IDC_DISPLAYED_COLUMNS           4088
#define IDC_MOVEUP_COLUMN               4089
#define IDC_MOVEDOWN_COLUMN             4090
#define IDC_TASKPAD_DESCRIPTION         4091
#define IDC_TaskpadPreview              4092
#define IDC_WELCOME                     4099
#define IDC_COMPLETING                  4100
#define IDC_ResultList                  4110
#define IDC_GLYPH_LIST                  4113
#define IDC_MENU_TASK                   4115
#define IDC_CMDLINE_TASK                4116
#define IDB_RESTART_TASK_WIZARD         4124
#define IDC_CustomTitleSample           4125
#define IDC_UseForSimilarNodes          4128
#define IDC_SetDefaultForNodetype       4129
#define IDC_TaskDescription             4130
#define IDC_CUST_SNAPIN_MENUS           4138
#define IDC_CUST_STD_BUTTONS            4139
#define IDC_CUST_SNAPIN_BUTTONS         4140
#define IDC_CUST_STATUS_BAR             4141
#define IDC_CUST_DESC_BAR               4142
#define IDC_CUST_CONSOLE_TREE           4143
#define IDC_CUST_STD_MENUS              4144
#define IDC_CUST_TASKPAD_TABS           4145
#define IDC_DontUseForSimilarNodes      4146
#define IDC_Style_VerticalList          4147
#define IDC_Style_HorizontalList        4148
#define IDC_Style_TasksOnly             4149
#define IDC_Style_TooltipDesc           4150
#define IDC_Style_TextDesc              4151
#define IDC_Style_SizeCombo             4152
#define IDC_TASK_SOURCE_COMBO           4153
#define IDC_RESULT_TASK_DESCR           4154
#define IDC_NAVIGATION_TASK             4155
#define IDC_FAVORITE_STATIC             4157
#define IDC_CONSOLE_TREE_CAPTION        4159
#define IDC_SNAPIN_INFO                 4160
#define IDC_SNAPIN_DESC                 4161
#define IDC_Style_HideNormalTab         4162
#define IDB_SELECT_TASK_ICON            4163
#define IDC_CustomIcon                  4165
#define IDC_CustomIconRadio             4166
#define IDC_MMCIconsRadio               4167
#define IDC_DESCRIPTION2Label           4168
#define IDC_DESCRIPTIONLabel            4169
#define IDC_CustomIconWell              4170
#define IDC_CUST_VIEW_CAPTION           4171

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        1100
#define _APS_NEXT_COMMAND_VALUE         13578
#define _APS_NEXT_CONTROL_VALUE         4171
#define _APS_NEXT_SYMED_VALUE           5001
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\moreutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       moreutil.h
//
//--------------------------------------------------------------------------

#ifndef __MMCUTIL_H__
#define __MMCUTIL_H__

/*
	mmcutil.h
	
	Some extra macros and definitions to aid the anti-MFC effort
*/


#if 1
#define MMC_TRY
#define MMC_CATCH
#else
#define MMC_TRY																			\
	try {

#define MMC_CATCH									 	                                 \
    }                                                	                                 \
    catch ( std::bad_alloc )                         	                                 \
    {                                                	                                 \
        ASSERT( FALSE );                             	                                 \
        return E_OUTOFMEMORY;                        	                                 \
    }                                                	                                 \
    catch ( std::exception )                         	                                 \
    {                                                	                                 \
        ASSERT( FALSE );                             	                                 \
        return E_UNEXPECTED;                         	                                 \
	}
#endif


BOOL _IsValidAddress(const void* lp, UINT nBytes, BOOL bReadWrite = TRUE);
  
#endif	// __MMCUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\mtnode.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       MTNode.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    9/17/1996   RaviR   Created
//____________________________________________________________________________
//


#include "stdafx.h"
#include "nodemgr.h"
#include "comdbg.h"
#include "regutil.h"
#include "bitmap.h"
#include "dummysi.h"
#include "tasks.h"
#include "policy.h"
#include "bookmark.h"
#include "nodepath.h"
#include "siprop.h"
#include "util.h"
#include "addsnpin.h"
#include "about.h"
#include "nodemgrdebug.h"

extern const CLSID CLSID_FolderSnapin;
extern const CLSID CLSID_OCXSnapin;
extern const CLSID CLSID_HTMLSnapin;


#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// {118B559C-6D8C-11d0-B503-00C04FD9080A}
const GUID IID_PersistData =
{ 0x118b559c, 0x6d8c, 0x11d0, { 0xb5, 0x3, 0x0, 0xc0, 0x4f, 0xd9, 0x8, 0xa } };

//############################################################################
//############################################################################
//
//  Implementation of class CStorage
//
//############################################################################
//############################################################################

/*+-------------------------------------------------------------------------*
 * class CStorage
 *
 *
 * PURPOSE: Wrapper for IStorage. Provides several utility functions.
 *
 *+-------------------------------------------------------------------------*/
class CStorage
{
    IStoragePtr m_spStorage;

public:
    CStorage() {}

    CStorage(IStorage *pStorage)
    {
        m_spStorage = pStorage;
    }

    CStorage & operator = (const CStorage &rhs)
    {
        m_spStorage = rhs.m_spStorage;
        return *this;
    }

    void Attach(IStorage *pStorage)
    {
        m_spStorage = pStorage;
    }

    IStorage *Get()
    {
        return m_spStorage;
    }

    // create this storage below the specified storage
    SC  ScCreate(CStorage &storageParent, const wchar_t* name, DWORD grfMode, const wchar_t* instanceName)
    {
        SC sc;
        sc = CreateDebugStorage(storageParent.Get(), name, grfMode, instanceName, &m_spStorage);
        return sc;
    }

    SC  ScMoveElementTo(const wchar_t *name, CStorage &storageDest, const wchar_t *newName, DWORD grfFlags)
    {
        SC sc;
        if(!Get() || ! storageDest.Get())
            goto PointerError;

        sc = m_spStorage->MoveElementTo(name, storageDest.Get(), newName, grfFlags);
        // error STG_E_FILENOTFOUND must be treated differently, since it is expected
        // to occur and means the end of move operation (loop) in ScConvertLegacyNode.
        // Do not trace in this case.
        if(sc == SC(STG_E_FILENOTFOUND))
            goto Cleanup;
        if(sc)
            goto Error;

        Cleanup:
            return sc;
        PointerError:
            sc = E_POINTER;
        Error:
            TraceError(TEXT("CStorage::ScMoveElementTo"), sc);
            goto Cleanup;
    }

};

//############################################################################
//############################################################################
//
//  Implementation of class CStream
//
//############################################################################
//############################################################################
/*+-------------------------------------------------------------------------*
 * class CStream
 *
 *
 * PURPOSE: Wrapper for IStream. Provides several utility functions.
 *
 *+-------------------------------------------------------------------------*/
class CStream
{
    IStreamPtr m_spStream;
    typedef IStream *PSTREAM;

public:
    CStream() {}

    CStream(IStream *pStream)
    {
        m_spStream = pStream;
    }

    CStream & operator = (const CStream &rhs)
    {
        m_spStream = rhs.m_spStream;
        return *this;
    }

    void Attach(IStream *pStream)
    {
        m_spStream = pStream;
    }

    IStream *Get()
    {
        return m_spStream;
    }

    operator IStream&()
    {
        return *m_spStream;
    }

    // create this stream below the specified storage
    SC ScCreate(CStorage& storageParent, const wchar_t* name, DWORD grfMode, const wchar_t* instanceName)
    {
        SC sc;
        sc = CreateDebugStream(storageParent.Get(), name, grfMode, instanceName, &m_spStream);
        return sc;
    }


    /*+-------------------------------------------------------------------------*
     *
     * ScRead
     *
     * PURPOSE: Reads the specified object from the stream.
     *
     * PARAMETERS:
     *    void *  pv :      The location of the object.
     *    size_t  size :    The size of the object.
     *
     * RETURNS:
     *    SC
     *
     *+-------------------------------------------------------------------------*/
    SC  ScRead(void *pv, size_t size, bool bIgnoreErrors = false)
    {
        DECLARE_SC(sc, TEXT("CStream::ScRead"));

        // parameter check
        sc = ScCheckPointers(pv);
        if (sc)
            return sc;

        // internal pointer check
        sc = ScCheckPointers(m_spStream, E_POINTER);
        if (sc)
            return sc;

        // read the data
        ULONG bytesRead = 0;
        sc = m_spStream->Read(pv, size, &bytesRead);

        // if we need to ignore errors, just return.
        if(bIgnoreErrors)
            return sc.Clear(), sc;

        if (sc)
            return sc;

        // since this function does not return the number of bytes read,
        // failure to read as may as requested should be treated as error
        if (sc == SC(S_FALSE) || bytesRead != size)
            return sc = E_FAIL;

        return sc;
    }

    /*+-------------------------------------------------------------------------*
     *
     * ScWrite
     *
     * PURPOSE: Writes the specified object to the stream
     *
     * PARAMETERS:
     *    const   void :
     *    size_t  size :
     *
     * RETURNS:
     *    SC
     *
     *+-------------------------------------------------------------------------*/
    SC  ScWrite(const void *pv, size_t size)
    {
        DECLARE_SC(sc, TEXT("CStream::ScWrite"));

        // parameter check
        sc = ScCheckPointers(pv);
        if (sc)
            return sc;

        // internal pointer check
        sc = ScCheckPointers(m_spStream, E_POINTER);
        if (sc)
            return sc;

        // write the data

        ULONG   bytesWritten = 0;
        sc = m_spStream->Write(pv, size, &bytesWritten);
        if (sc)
            return sc;

        // since this function does not return the number of bytes written,
        // failure to write as may as requested should be treated as error
        if (bytesWritten != size)
            return sc = E_FAIL;

        return sc;
    }
};



/////////////////////////////////////////////////////////////////////////////
// Forward declaration of helper functions defined below

SC  ScLoadBitmap (CStream &stream, HBITMAP* pBitmap);
void PersistBitmap (CPersistor &persistor, LPCTSTR name, HBITMAP& hBitmap);

static inline SC ScWriteEmptyNode(CStream &stream)
{
    SC          sc;
    int         nt = 0;

    sc = stream.ScWrite(&nt, sizeof(nt));
    if(sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(TEXT("ScWriteEmptyNode"), sc);
    goto Cleanup;
}

static inline CLIPFORMAT GetPreLoadFormat (void)
{
    static CLIPFORMAT s_cfPreLoads = 0;
    if (s_cfPreLoads == 0) {
        USES_CONVERSION;
        s_cfPreLoads = (CLIPFORMAT) RegisterClipboardFormat (W2T(CCF_SNAPIN_PRELOADS));
    }
    return s_cfPreLoads;
}

//############################################################################
//############################################################################
//
//  Implementation of class CMTNode
//
//############################################################################
//############################################################################
DEBUG_DECLARE_INSTANCE_COUNTER(CMTNode);

// Static member
MTNODEID CMTNode::m_NextID = ROOTNODEID;


CMTNode::CMTNode()
: m_ID(GetNextID()), m_pNext(NULL), m_pChild(NULL), m_pParent(NULL),
  m_bIsDirty(true), m_cRef(1), m_usFlags(0), m_bLoaded(false),
  m_bookmark(NULL)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CMTNode);
	Reset();
    m_nImage = eStockImage_Folder;
    m_nOpenImage = eStockImage_OpenFolder;
    m_nState = 0;
}


void CMTNode::Reset()
{
	m_idOwner               = TVOWNED_MAGICWORD;
	m_lUserParam            = 0;
	m_pPrimaryComponentData = NULL;
	m_bInit                 = false;
	m_bExtensionsExpanded   = false;
	m_usExpandFlags         = 0;

    ResetExpandedAtLeastOnce();
}


CMTNode::~CMTNode()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CMTNode);
    DECLARE_SC(sc, TEXT("CMTNode::~CMTNode"));

    if (IsPropertyPageDisplayed() == TRUE)
        MMCIsMTNodeValid(this, TRUE);

    ASSERT(m_pNext == NULL);
    ASSERT(m_pParent == NULL);
    ASSERT(m_cRef == 0);

    CScopeTree *pScopeTree = CScopeTree::GetScopeTree();
    sc = ScCheckPointers(pScopeTree, E_UNEXPECTED);
    if (!sc)
    {
        sc = pScopeTree->ScUnadviseMTNode(this);
    }

    if (m_pChild != NULL)
    {
        // Don't recurse the siblings of the child.
        CMTNode* pMTNodeCurr = m_pChild;
        while (pMTNodeCurr)
        {
            m_pChild = pMTNodeCurr->Next();
            pMTNodeCurr->AttachNext(NULL);
            pMTNodeCurr->AttachParent(NULL);
            pMTNodeCurr->Release();
            pMTNodeCurr = m_pChild;
        }

        m_pChild = NULL;
    }

    // DON'T CHANGE THE ORDER OF THESE NULL ASSIGNMENTS!!!!!!!!!
    m_spTreeStream = NULL;
    m_spViewStorage = NULL;
    m_spCDStorage = NULL;
    m_spNodeStorage = NULL;
    m_spPersistData = NULL;

    if (m_pParent != NULL)
    {
        if (m_pParent->m_pChild == this)
        {
            m_pParent->m_pChild = NULL;
            if (GetStaticParent() == this)
                m_pParent->SetDirty();
        }
    }
}

// Was MMCN_REMOVE_CHILDREN sent to the snapin owning this node or its parent
bool CMTNode::AreChildrenBeingRemoved ()
{
    if (_IsFlagSet(FLAG_REMOVING_CHILDREN))
        return true;

    if (Parent())
        return Parent()->AreChildrenBeingRemoved ();

    return false;
}

CMTNode* CMTNode::FromScopeItem (HSCOPEITEM item)
{
    CMTNode* pMTNode = reinterpret_cast<CMTNode*>(item);

    try
    {
        pMTNode = dynamic_cast<CMTNode*>(pMTNode);
    }
    catch (...)
    {
        pMTNode = NULL;
    }

    return (pMTNode);
}

/*+-------------------------------------------------------------------------*
 * class CMMCSnapIn
 *
 *
 * PURPOSE: The COM 0bject that exposes the SnapIn interface.
 *
 *+-------------------------------------------------------------------------*/
class CMMCSnapIn :
    public CMMCIDispatchImpl<SnapIn>, // the View interface
    public CTiedComObject<CMTSnapInNode>
{
    typedef CMTSnapInNode CMyTiedObject;
    typedef std::auto_ptr<CSnapinAbout> SnapinAboutPtr;

public:
    BEGIN_MMC_COM_MAP(CMMCSnapIn)
    END_MMC_COM_MAP()

public:
    MMC_METHOD1(get_Name,       PBSTR      /*pbstrName*/);
    STDMETHOD(get_Vendor)( PBSTR pbstrVendor );
    STDMETHOD(get_Version)( PBSTR pbstrVersion );
    MMC_METHOD1(get_Extensions, PPEXTENSIONS  /*ppExtensions*/);
    MMC_METHOD1(get_SnapinCLSID,PBSTR      /*pbstrSnapinCLSID*/);
    MMC_METHOD1(get_Properties, PPPROPERTIES /*ppProperties*/);
    MMC_METHOD1(EnableAllExtensions, BOOL    /*bEnable*/);

    // not an interface method,
    // just a convenient way to reach for tied object's method
    MMC_METHOD1(GetSnapinClsid, CLSID& /*clsid*/);

    CMTSnapInNode *GetMTSnapInNode();

private:
    ::SC ScGetSnapinAbout(CSnapinAbout*& pAbout);

private:
    SnapinAboutPtr m_spSnapinAbout;
};


/*+-------------------------------------------------------------------------*
 * class CExtension
 *
 *
 * PURPOSE: The COM 0bject that exposes the SnapIn interface.
 *
 *          This extension is not tied to any object. An extension snapin instance
 *          can be uniquely identified by combination of its class-id & its primary
 *          snapin's class-id. So this object just stores this data.
 *          See addsnpin.h for more comments.
 *
 *+-------------------------------------------------------------------------*/
class CExtension :
    public CMMCIDispatchImpl<Extension>
{
    typedef std::auto_ptr<CSnapinAbout> SnapinAboutPtr;

public:
    BEGIN_MMC_COM_MAP(CExtension)
    END_MMC_COM_MAP()

public:
    STDMETHODIMP get_Name( PBSTR  pbstrName);
    STDMETHODIMP get_Vendor( PBSTR  pbstrVendor);
    STDMETHODIMP get_Version( PBSTR  pbstrVersion);
    STDMETHODIMP get_Extensions( PPEXTENSIONS ppExtensions);
    STDMETHODIMP get_SnapinCLSID( PBSTR  pbstrSnapinCLSID);
    STDMETHODIMP EnableAllExtensions(BOOL bEnable);
    STDMETHODIMP Enable(BOOL bEnable = TRUE);

    CExtension() : m_clsidAbout(GUID_NULL) {}

    void Init(const CLSID& clsidExtendingSnapin, const CLSID& clsidThisExtension, const CLSID& clsidAbout)
    {
        m_clsidExtendingSnapin = clsidExtendingSnapin;
        m_clsidThisExtension   = clsidThisExtension;
        m_clsidAbout           = clsidAbout;
    }

    LPCOLESTR GetVersion()
    {
        CSnapinAbout *pSnapinAbout = GetSnapinAbout();
        if (! pSnapinAbout)
            return NULL;

        return pSnapinAbout->GetVersion();
    }

    LPCOLESTR GetVendor()
    {
        CSnapinAbout *pSnapinAbout = GetSnapinAbout();
        if (! pSnapinAbout)
            return NULL;

        return pSnapinAbout->GetCompanyName();
    }

private:
    CSnapinAbout* GetSnapinAbout()
    {
        // If about object is already created just return it.
        if (m_spExtensionAbout.get())
            return m_spExtensionAbout.get();

        if (m_clsidAbout == GUID_NULL)
            return NULL;

        // Else create & initialize the about object.
        m_spExtensionAbout = SnapinAboutPtr (new CSnapinAbout);
        if (! m_spExtensionAbout.get())
            return NULL;

        if (m_spExtensionAbout->GetSnapinInformation(m_clsidAbout))
            return m_spExtensionAbout.get();

        return NULL;
    }

private:
    CLSID         m_clsidThisExtension;
    CLSID         m_clsidExtendingSnapin;

    CLSID         m_clsidAbout;

    SnapinAboutPtr m_spExtensionAbout;
};


//############################################################################
//############################################################################
//
//  Implementation of class CExtensions
//
//############################################################################
//############################################################################
/*+-------------------------------------------------------------------------*
 * class CExtensions
 *
 *
 * PURPOSE: Implements the Extensions automation interface.
 *
 * The Scget_Extensions uses this class as a template parameter to the typedef
 * below. The typedef is an array of Extension objects, that needs atleast below
 * empty class declared. Scget_Extensions adds the extensions to the array.
 *
 *    typedef CComObject< CMMCArrayEnum<Extensions, Extension> > CMMCExtensions;
 *
 *+-------------------------------------------------------------------------*/
class CExtensions :
    public CMMCIDispatchImpl<Extensions>,
    public CTiedObject                     // enumerators are tied to it
{
protected:
    typedef void CMyTiedObject;
};


// Helper functions used by both CMMCSnapIn as well as CExtension.
SC Scget_Extensions(const CLSID& clsidPrimarySnapin, PPEXTENSIONS  ppExtensions);
SC ScEnableAllExtensions (const CLSID& clsidPrimarySnapin, BOOL bEnable);


//+-------------------------------------------------------------------
//
//  Member:      Scget_Extensions
//
//  Synopsis:    Helper function, given class-id of primary creates &
//               returns the extensions collection for this snapin.
//
//  Arguments:   [clsidPrimarySnapin] -
//               [ppExtensions]       - out param, extensions collection.
//
//  Returns:     SC
//
//  Note:        Collection does not include dynamic extensions.
//
//--------------------------------------------------------------------
SC Scget_Extensions(const CLSID& clsidPrimarySnapin, PPEXTENSIONS  ppExtensions)
{
    DECLARE_SC(sc, TEXT("Scget_Extensions"));
    sc = ScCheckPointers(ppExtensions);
    if (sc)
        return sc;

    *ppExtensions = NULL;

    // Create the extensions collection (which also implements the enumerator).
    typedef CComObject< CMMCArrayEnum<Extensions, Extension> > CMMCExtensions;
    CMMCExtensions *pMMCExtensions = NULL;
    sc = CMMCExtensions::CreateInstance(&pMMCExtensions);
    if (sc)
        return sc;

    sc = ScCheckPointers(pMMCExtensions, E_UNEXPECTED);
    if (sc)
        return sc;

    typedef CComPtr<Extension> CMMCExtensionPtr;
    typedef std::vector<CMMCExtensionPtr> ExtensionSnapins;
    ExtensionSnapins extensions;

    // Now get the extensions for this collection from this snapin.
    CExtensionsCache extnsCache;
    sc = MMCGetExtensionsForSnapIn(clsidPrimarySnapin, extnsCache);
    if (sc)
        return sc;

    // Create Extension object for each non-dynamic extension.
    CExtensionsCacheIterator it(extnsCache);

    for (; it.IsEnd() == FALSE; it.Advance())
    {
        // Collection does not include dynamic extensions.
        if (CExtSI::EXT_TYPE_DYNAMIC & it.GetValue())
            continue;

        typedef CComObject<CExtension> CMMCExtensionSnap;
        CMMCExtensionSnap *pExtension = NULL;

        sc = CMMCExtensionSnap::CreateInstance(&pExtension);
        if (sc)
            return sc;

        sc = ScCheckPointers(pExtension, E_UNEXPECTED);
        if (sc)
            return sc;

        CLSID clsidAbout;
        sc = ScGetAboutFromSnapinCLSID(it.GetKey(), clsidAbout);
        if (sc)
            sc.TraceAndClear();

        // Make the Extension aware of its primary snapin & about object.
        pExtension->Init(clsidPrimarySnapin, it.GetKey(), clsidAbout);

        extensions.push_back(pExtension);
    }

    // Fill this data into the extensions collection.
    pMMCExtensions->Init(extensions.begin(), extensions.end());

    sc = pMMCExtensions->QueryInterface(ppExtensions);
    if (sc)
        return sc;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      ScEnableAllExtensions
//
//  Synopsis:    Helper function, given class-id of primary enables
//               all extensions or un-checks the enable all so that
//               individual extension can be disabled.
//
//  Arguments:   [clsidPrimarySnapin] -
//               [bEnable]            - enable or disable.
//
//  Returns:     SC
//
//  Note:        Collection does not include dynamic extensions.
//
//--------------------------------------------------------------------
SC ScEnableAllExtensions (const CLSID& clsidPrimarySnapin, BOOL bEnable)
{
    DECLARE_SC(sc, _T("ScEnableAllExtensions"));

    // Create snapin manager.
    CScopeTree *pScopeTree = CScopeTree::GetScopeTree();
    sc = ScCheckPointers(pScopeTree, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    CSnapinManager snapinMgr(pScopeTree->GetRoot());

    // Ask the snapinMgr to enable/disable its extensions.
    sc = snapinMgr.ScEnableAllExtensions(clsidPrimarySnapin, bEnable);
    if (sc)
        return sc.ToHr();

    // Update the scope tree with changes made by snapin manager.
    sc = pScopeTree->ScAddOrRemoveSnapIns(snapinMgr.GetDeletedNodesList(),
                                          snapinMgr.GetNewNodes());
    if (sc)
        return sc.ToHr();

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CExtension::get_Name
//
//  Synopsis:    Return the name of this extension.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
STDMETHODIMP CExtension::get_Name (PBSTR  pbstrName)
{
    DECLARE_SC(sc, _T("CExtension::get_Name"));
    sc = ScCheckPointers(pbstrName);
    if (sc)
        return sc.ToHr();

    *pbstrName = NULL;

    tstring tszSnapinName;
    bool bRet = GetSnapinNameFromCLSID(m_clsidThisExtension, tszSnapinName);
    if (!bRet)
        return (sc = E_FAIL).ToHr();

    USES_CONVERSION;
    *pbstrName = SysAllocString(T2COLE(tszSnapinName.data()));
    if ( (! *pbstrName) && (tszSnapinName.length() > 0) )
        return (sc = E_OUTOFMEMORY).ToHr();

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CExtension::get_Vendor
//
//  Synopsis:    Get the vendor information for this extension if it exists.
//
//  Arguments:   [pbstrVendor] - out param, ptr to vendor info.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CExtension::get_Vendor (PBSTR  pbstrVendor)
{
    DECLARE_SC(sc, _T("CExtension::get_Vendor"));
    sc = ScCheckPointers(pbstrVendor);
    if (sc)
        return sc.ToHr();

    LPCOLESTR lpszVendor = GetVendor();

    *pbstrVendor = SysAllocString(lpszVendor);
    if ((lpszVendor) && (! *pbstrVendor))
        return (sc = E_OUTOFMEMORY).ToHr();

    return (sc.ToHr());
}


//+-------------------------------------------------------------------
//
//  Member:      CExtension::get_Version
//
//  Synopsis:    Get the version info for this extension if it exists.
//
//  Arguments:   [pbstrVersion] - out param, ptr to version info.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CExtension::get_Version (PBSTR  pbstrVersion)
{
    DECLARE_SC(sc, _T("CExtension::get_Version"));
    sc = ScCheckPointers(pbstrVersion);
    if (sc)
        return sc.ToHr();

    LPCOLESTR lpszVersion = GetVersion();

    *pbstrVersion = SysAllocString(lpszVersion);
    if ((lpszVersion) && (! *pbstrVersion))
        return (sc = E_OUTOFMEMORY).ToHr();

    return (sc.ToHr());
}

//+-------------------------------------------------------------------
//
//  Member:      CExtension::get_SnapinCLSID
//
//  Synopsis:    Get the extension snapin class-id.
//
//  Arguments:   [pbstrSnapinCLSID] - out param, snapin class-id.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CExtension::get_SnapinCLSID (PBSTR  pbstrSnapinCLSID)
{
    DECLARE_SC(sc, _T("CExtension::get_SnapinCLSID"));
    sc = ScCheckPointers(pbstrSnapinCLSID);
    if (sc)
        return sc.ToHr();

    CCoTaskMemPtr<OLECHAR> szSnapinClsid;

    sc = StringFromCLSID(m_clsidThisExtension, &szSnapinClsid);
    if (sc)
        return sc.ToHr();

    *pbstrSnapinCLSID = SysAllocString(szSnapinClsid);
    if (! *pbstrSnapinCLSID)
        sc = E_OUTOFMEMORY;

    return (sc.ToHr());
}


//+-------------------------------------------------------------------
//
//  Member:      CExtension::ScEnable
//
//  Synopsis:    Enable or disable this extension
//
//  Arguments:   [bEnable] - enable or disable.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
STDMETHODIMP CExtension::Enable (BOOL bEnable /*= TRUE*/)
{
    DECLARE_SC(sc, _T("CExtension::ScEnable"));

    /*
     * 1. Create snapin manager.
     * 2. Ask snapin mgr to disable this snapin.
     */

    // Create snapin manager.
    CScopeTree *pScopeTree = CScopeTree::GetScopeTree();
    sc = ScCheckPointers(pScopeTree, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    CSnapinManager snapinMgr(pScopeTree->GetRoot());

    // Ask the snapinMgr to disable this extension.
    sc = snapinMgr.ScEnableExtension(m_clsidExtendingSnapin, m_clsidThisExtension, bEnable);
    if (sc)
        return sc.ToHr();

    // Update the scope tree with changes made by snapin manager.
    sc = pScopeTree->ScAddOrRemoveSnapIns(snapinMgr.GetDeletedNodesList(),
                                          snapinMgr.GetNewNodes());
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CExtension::Scget_Extensions
//
//  Synopsis:    Get the extensions collection for this snapin.
//
//  Arguments:   [ppExtensions] - out ptr to extensions collection.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
HRESULT CExtension::get_Extensions( PPEXTENSIONS  ppExtensions)
{
    DECLARE_SC(sc, _T("CExtension::get_Extensions"));
    sc = ScCheckPointers(ppExtensions);
    if (sc)
        return sc.ToHr();

    *ppExtensions = NULL;

    sc = ::Scget_Extensions(m_clsidThisExtension, ppExtensions);
    if (sc)
        return sc.ToHr();

    return (sc.ToHr());
}


//+-------------------------------------------------------------------
//
//  Member:      CExtension::EnableAllExtensions
//
//  Synopsis:    Enable/Disable all the extensions of this snapin.
//
//  Arguments:
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CExtension::EnableAllExtensions(BOOL bEnable)
{
    DECLARE_SC(sc, TEXT("CExtension::EnableAllExtensions"));

    sc = ::ScEnableAllExtensions(m_clsidThisExtension, bEnable);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CMTSnapInNode::ScGetCMTSnapinNode
//
//  Synopsis:    Static function, given PSNAPIN (SnapIn interface)
//               return the CMTSnapInNode of that snapin.
//
//  Arguments:   [pSnapIn] - Snapin interface.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CMTSnapInNode::ScGetCMTSnapinNode(PSNAPIN pSnapIn, CMTSnapInNode **ppMTSnapInNode)
{
    DECLARE_SC(sc, _T("CMTSnapInNode::GetCMTSnapinNode"));
    sc = ScCheckPointers(pSnapIn, ppMTSnapInNode);
    if (sc)
        return sc;

    *ppMTSnapInNode = NULL;

    CMMCSnapIn *pMMCSnapIn = dynamic_cast<CMMCSnapIn*>(pSnapIn);
    if (!pMMCSnapIn)
        return (sc = E_UNEXPECTED);

    *ppMTSnapInNode = pMMCSnapIn->GetMTSnapInNode();

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CMTSnapInNode::Scget_Name
//
//  Synopsis:    Return the name of this snapin.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CMTSnapInNode::Scget_Name (PBSTR pbstrName)
{
    DECLARE_SC(sc, _T("CMTSnapInNode::Scget_Name"));
    sc = ScCheckPointers(pbstrName);
    if (sc)
        return sc;

    *pbstrName = NULL;

    CSnapIn *pSnapin =  GetPrimarySnapIn();
    sc = ScCheckPointers(pSnapin, E_UNEXPECTED);
    if (sc)
        return sc;

    WTL::CString strSnapInName;
    sc = pSnapin->ScGetSnapInName(strSnapInName);
    if (sc)
        return sc;

    USES_CONVERSION;
    *pbstrName = strSnapInName.AllocSysString();
    if ( (! *pbstrName) && (strSnapInName.GetLength() > 0) )
        return (sc = E_OUTOFMEMORY);

    return (sc);
}



//+-------------------------------------------------------------------
//
//  Member:      CMTSnapInNode::Scget_Extensions
//
//  Synopsis:    Get the extensions collection for this snapin.
//
//  Arguments:   [ppExtensions] - out ptr to extensions collection.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CMTSnapInNode::Scget_Extensions( PPEXTENSIONS  ppExtensions)
{
    DECLARE_SC(sc, _T("CMTSnapInNode::Scget_Extensions"));
    sc = ScCheckPointers(ppExtensions);
    if (sc)
        return sc;

    *ppExtensions = NULL;

    CSnapIn *pSnapin =  GetPrimarySnapIn();
    sc = ScCheckPointers(pSnapin, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = ::Scget_Extensions(pSnapin->GetSnapInCLSID(), ppExtensions);
    if (sc)
        return sc;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CMTSnapInNode::ScGetSnapinClsid
//
//  Synopsis:    Gets the CLSID of snapin
//
//  Arguments:   CLSID& clsid [out] - class id of snapin.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CMTSnapInNode::ScGetSnapinClsid(CLSID& clsid)
{
    DECLARE_SC(sc, TEXT("CMTSnapInNode::ScGetAboutClsid"));

    // init out param
    clsid = GUID_NULL;

    CSnapIn *pSnapin =  GetPrimarySnapIn();
    sc = ScCheckPointers(pSnapin, E_UNEXPECTED);
    if (sc)
        return sc;

    clsid = pSnapin->GetSnapInCLSID();

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      CMTSnapInNode::Scget_SnapinCLSID
//
//  Synopsis:    Get the CLSID for this snapin.
//
//  Arguments:   [pbstrSnapinCLSID] - out ptr to CLSID.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CMTSnapInNode::Scget_SnapinCLSID(     PBSTR      pbstrSnapinCLSID)
{
    DECLARE_SC(sc, TEXT("CMTSnapInNode::Scget_SnapinCLSID"));
    sc = ScCheckPointers(pbstrSnapinCLSID);
    if (sc)
        return sc;

    CSnapIn *pSnapin =  GetPrimarySnapIn();
    sc = ScCheckPointers(pSnapin, E_UNEXPECTED);
    if (sc)
        return sc;

    CCoTaskMemPtr<OLECHAR> szSnapinClsid;

    sc = StringFromCLSID(pSnapin->GetSnapInCLSID(), &szSnapinClsid);
    if (sc)
        return sc.ToHr();

    *pbstrSnapinCLSID = SysAllocString(szSnapinClsid);
    if (! *pbstrSnapinCLSID)
        sc = E_OUTOFMEMORY;

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CMTSnapInNode::ScEnableAllExtensions
//
//  Synopsis:    Enable or not enable all extensions of this snapin.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CMTSnapInNode::ScEnableAllExtensions (BOOL bEnable)
{
    DECLARE_SC(sc, _T("CMTSnapInNode::ScEnableAllExtensions"));

    CSnapIn *pSnapin =  GetPrimarySnapIn();
    sc = ScCheckPointers(pSnapin, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = ::ScEnableAllExtensions(pSnapin->GetSnapInCLSID(), bEnable);
    if (sc)
        return sc;

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CMTSnapInNode::Scget_Properties
 *
 * Returns a pointer to the snap-in's Properties object
 *--------------------------------------------------------------------------*/

SC CMTSnapInNode::Scget_Properties( PPPROPERTIES ppProperties)
{
    DECLARE_SC (sc, _T("CMTSnapInNode::Scget_Properties"));

    /*
     * validate parameters
     */
    sc = ScCheckPointers (ppProperties);
    if (sc)
        return (sc);

    *ppProperties = m_spProps;

    /*
     * If the snap-in doesn't support ISnapinProperties, don't return
     * a Properties interface.  This is not an error, but rather a valid
     * unsuccessful return, so we return E_NOINTERFACE directly instead
     * of assigning to sc first.
     */
    if (m_spProps == NULL)
        return (E_NOINTERFACE);

    /*
     * put a ref on for the client
     */
    (*ppProperties)->AddRef();

    return (sc);
}



/*+-------------------------------------------------------------------------*
 *
 * CMTSnapInNode::ScGetSnapIn
 *
 * PURPOSE: Returns a pointer to the SnapIn object.
 *
 * PARAMETERS:
 *    PPSNAPIN  ppSnapIn :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CMTSnapInNode::ScGetSnapIn(PPSNAPIN ppSnapIn)
{
    DECLARE_SC(sc, TEXT("CMTSnapInNode::ScGetSnapIn"));

    sc = ScCheckPointers(ppSnapIn);
    if(sc)
        return sc;

    // initialize out parameter
    *ppSnapIn = NULL;

    // create a CMMCView if needed.
    sc = CTiedComObjectCreator<CMMCSnapIn>::ScCreateAndConnect(*this, m_spSnapIn);
    if(sc)
        return sc;

    if(m_spSnapIn == NULL)
    {
        sc = E_UNEXPECTED;
        return sc;
    }

    // addref the pointer for the client.
    m_spSnapIn->AddRef();
    *ppSnapIn = m_spSnapIn;

    return sc;
}


HRESULT CMTNode::OpenStorageForNode()
{
    if (m_spNodeStorage != NULL)
        return S_OK;

    ASSERT(m_spPersistData != NULL);
    if (m_spPersistData == NULL)
        return E_POINTER;

    // Get the storage for all of the nodes
    IStorage* const pAllNodes = m_spPersistData->GetNodeStorage();
    ASSERT(pAllNodes != NULL);
    if (pAllNodes == NULL)
        return E_POINTER;

    // Create the outer storage for this node
    WCHAR name[MAX_PATH];
    HRESULT hr = OpenDebugStorage(pAllNodes, GetStorageName(name),
        STGM_READWRITE | STGM_SHARE_EXCLUSIVE, L"\\node\\#", &m_spNodeStorage);
    return hr == S_OK ? S_OK : E_FAIL;
}

HRESULT CMTNode::OpenStorageForView()
{
    if (m_spViewStorage != NULL)
        return S_OK;

    // Get the storage for all of the nodes
    IStorage* const pNodeStorage = GetNodeStorage();
    ASSERT(pNodeStorage != NULL);
    if (pNodeStorage == NULL)
        return E_FAIL;

    // Create the outer storage for this node
    WCHAR name[MAX_PATH];
    HRESULT hr = OpenDebugStorage(pNodeStorage, L"view",
                        STGM_READWRITE | STGM_SHARE_EXCLUSIVE, L"\\node\\#\\view",
                                                     &m_spViewStorage);
    return hr == S_OK ? S_OK : E_FAIL;
}

HRESULT CMTNode::OpenStorageForCD()
{
    if (m_spCDStorage != NULL)
        return S_OK;

    // Get the storage for all of the nodes
    IStorage* const pNodeStorage = GetNodeStorage();
    ASSERT(pNodeStorage != NULL);
    if (pNodeStorage == NULL)
        return E_FAIL;

    // Create the outer storage for this node
    WCHAR name[MAX_PATH];
    HRESULT hr = OpenDebugStorage(pNodeStorage, L"data",
                        STGM_READWRITE | STGM_SHARE_EXCLUSIVE, L"\\node\\#\\data",
                                                     &m_spCDStorage);
    return hr == S_OK ? S_OK : E_FAIL;
}

HRESULT CMTNode::OpenTreeStream()
{
    if (m_spTreeStream != NULL)
    {
        const LARGE_INTEGER loc = {0,0};
        ULARGE_INTEGER newLoc;
        HRESULT hr = m_spTreeStream->Seek(loc, STREAM_SEEK_SET, &newLoc);
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
            return E_FAIL;

        return S_OK;
    }

    HRESULT hr = OpenStorageForNode();
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return E_FAIL;

    hr = OpenStorageForView();
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return E_FAIL;

    hr = OpenStorageForCD();
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return E_FAIL;

    IStorage* const pTreeNodes = GetNodeStorage();
    ASSERT(pTreeNodes != NULL);
    if (pTreeNodes == NULL)
        return E_POINTER;

    hr = OpenDebugStream(pTreeNodes, L"tree",
                STGM_READWRITE | STGM_SHARE_EXCLUSIVE, L"\\node\\#\\tree", &m_spTreeStream);
    ASSERT(SUCCEEDED(hr) && m_spTreeStream != NULL);
    return SUCCEEDED(hr) ? S_OK : E_FAIL;
}

/*+-------------------------------------------------------------------------*
 *
 * CMTSnapInNode::NextStaticNode
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *
 * RETURNS:   NULL if not found, else the next CMTSnapInNode.
 *    inline
 *
 * NOTE: This performance is poor! Improve by indexing all CMTSnapInNodes
 *       separately.
 *+-------------------------------------------------------------------------*/
CMTNode*
CMTNode::NextStaticNode()
{
    CMTNode *pNext = this;

    while (pNext)
    {
        if (pNext->IsStaticNode())
            return pNext;
        pNext = pNext->Next();
    }
    return NULL;
}




HRESULT CMTNode::IsDirty()
{
    if (GetDirty())
    {
        TraceDirtyFlag(TEXT("CMTNode"), true);
        return S_OK;
    }

    HRESULT hr;
    CMTNode* const pChild = m_pChild->NextStaticNode();
    if (pChild)
    {
        hr = pChild->IsDirty();
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
            return hr;
        if (hr != S_FALSE)
        {
            TraceDirtyFlag(TEXT("CMTNode"), true);
            return hr;
        }
    }

    CMTNode* const pNext = m_pNext->NextStaticNode();
    if (pNext)
    {
        hr = pNext->IsDirty();
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
            return hr;
        if (hr != S_FALSE)
        {
            TraceDirtyFlag(TEXT("CMTNode"), true);
            return hr;
        }
    }

    TraceDirtyFlag(TEXT("CMTNode"), false);
    return S_FALSE;
}


/*+-------------------------------------------------------------------------*
 *
 * CMTNode::InitNew
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    PersistData* d :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CMTNode::InitNew(PersistData* d)
{
    SC      sc;
    CStream treeStream;

    if ( (m_spPersistData != NULL) || (d==NULL) || !IsStaticNode())
        goto FailedError;

    m_spPersistData = d;
    if (m_spPersistData == NULL)
        goto ArgumentError;

    sc = InitNew();
    if(sc)
        goto Error;

    // Get the stream for persistence of the tree

    treeStream.Attach( m_spPersistData->GetTreeStream());

    // recurse thru children
    {
        CMTNode* const pChild = m_pChild->NextStaticNode();
        if (pChild)
        {
            sc = pChild->InitNew(d);
            if(sc)
                goto Error;
        }
        else
        {
            sc = ScWriteEmptyNode(treeStream);
            if(sc)
                goto Error;
        }
    }

    // chain to next node.
    {
        CMTNode* const pNext = m_pNext->NextStaticNode();
        if (pNext)
        {
            sc = pNext->InitNew(d);
            if(sc)
                goto Error;
        }
        else
        {
            sc = ScWriteEmptyNode(treeStream);
            if(sc)
                goto Error;
        }
    }

Cleanup:
    return HrFromSc(sc);
FailedError:
    sc = E_FAIL;
    goto Error;
ArgumentError:
    sc = E_INVALIDARG;
Error:
    TraceError(TEXT("CMTNode::InitNew"), sc);
    goto Cleanup;

}

/*+-------------------------------------------------------------------------*
 *
 * CMTNode::Persist
 *
 * PURPOSE: Persists the CMTNode to the specified persistor.
 *
 * PARAMETERS:
 *    CPersistor& persistor :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CMTNode::Persist(CPersistor& persistor)
{
    MTNODEID id = GetID();       // persist the node id
    persistor.PersistAttribute(XML_ATTR_MT_NODE_ID, id);
    SetID(id);

    // Save the children
    CPersistor persistorSubNode(persistor, XML_TAG_SCOPE_TREE_NODES);
    if (persistor.IsStoring())
    {
        CMTNode* pChild = m_pChild->NextStaticNode();
        while (pChild)
        {
            persistorSubNode.Persist(*pChild);
            // get next node
            pChild = pChild->Next();
            // advance if it is not a static node
            pChild = (pChild ? pChild->NextStaticNode() : NULL);
        }
        ClearDirty();
    }
    else
    {
        XMLListCollectionBase::Persist(persistorSubNode);
    }

    UINT nImage = m_nImage;
    if (nImage > eStockImage_Max)       // if SnapIn changed icon dynamically, then
        nImage = eStockImage_Folder;    // this value will be bogus next time:
                                            // replace w/ 0 (closed folder)
    persistor.PersistAttribute(XML_ATTR_MT_NODE_IMAGE, nImage);
    persistor.PersistString(XML_ATTR_MT_NODE_NAME,  m_strName);
}

/*+-------------------------------------------------------------------------*
 *
 * CMTNode::OnNewElement
 *
 * PURPOSE: called for each new child node found in XML doc
 *
 * PARAMETERS:
 *    CPersistor& persistor :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CMTNode::OnNewElement(CPersistor& persistor)
{
    DECLARE_SC(sc, TEXT("CMTNode::OnNewElement"));

    // load the child
    CMTNode* pChild;
    // attach to the list
    PersistNewNode(persistor, &pChild);
    if (pChild)
    {
        pChild->SetParent(this);
        CMTNode** ppLast = &m_pChild;
        while (*ppLast) ppLast = &(*ppLast)->m_pNext;
        *ppLast = pChild;
    }
}


/*+-------------------------------------------------------------------------*
 *
 * CMTNode::ScLoad
 *
 * PURPOSE: Loads the MTNode from the specified stream.
 *          COMPATIBILITY issues: MMC1.0 through MMC1.2 used special built-in
 *          node types to represent Folder, Web Link, and ActiveX control nodes.
 *          MMC2.0 and higher use snap-ins instead. The only special node is
 *          Console Root, which is still saved and loaded as a Folder node with
 *          ID = 1.
 *
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC CMTNode::ScLoad(PersistData* d, CMTNode** ppNode)
{
    DECLARE_SC(sc, TEXT("CMTNode::ScLoad"));
    CMTSnapInNode* pmtSnapInNode = NULL;
    CStream        treeStream;

    // check parameters
    sc = ScCheckPointers(d, ppNode);
    if(sc)
        return sc;

    *ppNode = NULL;

    // Read the type of node from the stream.
    treeStream.Attach(d->GetTreeStream());

    int nt;
    sc = treeStream.ScRead(&nt, sizeof(nt));
    if(sc)
        return sc;

    if (!nt)
        return sc;

    if (!(nt == NODE_CODE_SNAPIN || nt == NODE_CODE_FOLDER ||
          nt == NODE_CODE_HTML   || nt == NODE_CODE_OCX))
        return (sc = E_FAIL); // invalid node type.

    // Read the storage key
    MTNODEID id;
    sc = treeStream.ScRead(&id, sizeof(id));
    if(sc)
        return sc;

    // Create a node of the appropriate type. Everything, including Console Root
    // uses CMTSnapInNode.
    if( nt == NODE_CODE_FOLDER || nt == NODE_CODE_SNAPIN || nt == NODE_CODE_HTML || nt == NODE_CODE_OCX )
    {
        pmtSnapInNode = new CMTSnapInNode (NULL);

        ASSERT(pmtSnapInNode != NULL);
        if (pmtSnapInNode == NULL)
            return E_POINTER;

        *ppNode = pmtSnapInNode;
    }
    else
        return (sc = E_UNEXPECTED); // should never happen

    (*ppNode)->m_bLoaded = true;

    ASSERT((*ppNode)->m_spPersistData == NULL);
    ASSERT(d != NULL);
    (*ppNode)->m_spPersistData = d;
    ASSERT((*ppNode)->m_spPersistData != NULL);
    if ((*ppNode)->m_spPersistData == NULL)
        return E_INVALIDARG;


    (*ppNode)->SetID(id);
    if (id >= m_NextID)
        m_NextID = id+1;

    // Open the stream for the nodes data
    sc = (*ppNode)->OpenTreeStream();
    if (sc)
    {
        (*ppNode)->Release();
        *ppNode = NULL;
        return sc;
    }

    // Load the node
    // If old style node, then convert to snap-in type node

    switch (nt)
    {
    case NODE_CODE_SNAPIN:
        sc = (*ppNode)->ScLoad();
        break;

    // All folder nodes, INCLUDING old-style console root nodes, are upgraded to snap-ins.
    case NODE_CODE_FOLDER:
            if(pmtSnapInNode == NULL)
                return (sc = E_UNEXPECTED);

            sc = pmtSnapInNode->ScConvertLegacyNode(CLSID_FolderSnapin);
            break;
    case NODE_CODE_HTML:
        sc = pmtSnapInNode->ScConvertLegacyNode(CLSID_HTMLSnapin);
        break;

    case NODE_CODE_OCX:
        sc = pmtSnapInNode->ScConvertLegacyNode(CLSID_OCXSnapin);
        break;

    default:
        ASSERT(0 && "Invalid node type");
        sc = E_FAIL;
    }

    if (sc)
    {
        (*ppNode)->Release();
        *ppNode = NULL;
        return sc;
    }

    // load the children
    CMTNode* pChild;
    sc = ScLoad(d, &pChild);
    if (sc)
    {
        (*ppNode)->Release();
        *ppNode = NULL;
        return sc;
    }
    if (pChild)
        pChild->SetParent(*ppNode);
    (*ppNode)->m_pChild = pChild;

    // Load siblings
    CMTNode* pNext;
    sc = ScLoad(d, &(*ppNode)->m_pNext);
    if (sc)
    {
        (*ppNode)->Release();
        *ppNode = NULL;
        return sc;
    }

    (*ppNode)->SetDirty(false);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CMTNode::PersistNewNode
 *
 * PURPOSE: Loads the MTNode from the persistor.
 *
 *+-------------------------------------------------------------------------*/
void CMTNode::PersistNewNode(CPersistor &persistor, CMTNode** ppNode)
{
    DECLARE_SC(sc, TEXT("CMTNode::PersistNewNode"));

    CMTSnapInNode* pmtSnapInNode = NULL;

    const int CONSOLE_ROOT_ID = 1;
    // check parameters
    sc = ScCheckPointers(ppNode);
    if (sc)
        sc.Throw();

    *ppNode = NULL;

    // Create a node of the snapin type. Everything uses CMTSnapInNode.

    pmtSnapInNode = new CMTSnapInNode(NULL);
    sc = ScCheckPointers(pmtSnapInNode,E_OUTOFMEMORY);
    if (sc)
        sc.Throw();

    *ppNode = pmtSnapInNode;

    (*ppNode)->m_bLoaded = true;

    ASSERT((*ppNode)->m_spPersistData == NULL);

    try
    {
        persistor.Persist(**ppNode);
    }
    catch(...)
    {
        // ensure cleanup here
        (*ppNode)->Release();
        *ppNode = NULL;
        throw;
    }
    // update index for new nodes
    MTNODEID id = (*ppNode)->GetID();
    if (id >= m_NextID)
        m_NextID = id+1;

    (*ppNode)->SetDirty(false);
}

HRESULT CMTNode::DestroyElements()
{
    if (!IsStaticNode())
        return S_OK;

    HRESULT hr;

    if (m_pChild != NULL)
    {
        hr = m_pChild->DestroyElements();
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
            return hr;
    }

    return DoDestroyElements();
}

HRESULT CMTNode::DoDestroyElements()
{
    if (m_spPersistData == NULL)
        return S_OK;

    IStorage* const pNodeStorage = m_spPersistData->GetNodeStorage();
    ASSERT(pNodeStorage != NULL);
    if (pNodeStorage == NULL)
        return S_OK;

    WCHAR name[MAX_PATH];
    HRESULT hr = pNodeStorage->DestroyElement(GetStorageName(name));

    SetDirty();
    CMTNode* const psParent = m_pParent != NULL ? m_pParent->GetStaticParent() : NULL;
    if (psParent != NULL)
        psParent->SetDirty();

    return S_OK;
}

void CMTNode::SetParent(CMTNode* pParent)
{
    m_pParent = pParent;
    if (m_pNext)
        m_pNext->SetParent(pParent);
}


HRESULT CMTNode::CloseView(int idView)
{
    if (!IsStaticNode())
        return S_OK;

    HRESULT hr;
    CMTNode* const pChild = m_pChild->NextStaticNode();
    if (pChild)
    {
        hr = pChild->CloseView(idView);
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
            return E_FAIL;
    }

    CMTNode* const pNext = m_pNext->NextStaticNode();
    if (pNext)
    {
        hr = pNext->CloseView(idView);
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
            return E_FAIL;
    }

    return S_OK;
}


HRESULT CMTNode::DeleteView(int idView)
{
    if (!IsStaticNode())
        return S_OK;

    HRESULT hr;
    CMTNode* const pChild = m_pChild->NextStaticNode();
    if (pChild)
    {
        hr = pChild->DeleteView(idView);
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
            return E_FAIL;
    }

    CMTNode* const pNext = m_pNext->NextStaticNode();
    if (pNext)
    {
        hr = pNext->DeleteView(idView);
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
            return E_FAIL;
    }

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     GetBookmark
//
//  Synopsis:   Get bookmark for this MTNode.
//
//  Arguments:  None.
//
//  Returns:    auto pointer to CBookmark.
//
//  History:    04-23-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
CBookmark* CMTNode::GetBookmark()
{
    DECLARE_SC(sc, TEXT("CMTNode::GetBookmark"));

    // If the bookmark is not created, create one.
    if (NULL == m_bookmark.get())
    {
        m_bookmark = std::auto_ptr<CBookmarkEx>(new CBookmarkEx);
        if (NULL == m_bookmark.get())
            return NULL;

        m_bookmark->Reset();

        SC sc = m_bookmark->ScInitialize(this, GetStaticParent(), false /*bFastRetrievalOnly*/);
        if(sc)
            sc.TraceAndClear(); // change
    }

    return m_bookmark.get();
}

void
CMTNode::SetCachedDisplayName(LPCTSTR pszName)
{
    if (m_strName.str() != pszName)
    {
        m_strName = pszName;
        SetDirty();

        if (Parent())
            Parent()->OnChildrenChanged();
    }
}

UINT
CMTNode::GetState(void)
{
   UINT nState = 0;
   if (WasExpandedAtLeastOnce())
   {
       nState |= MMC_SCOPE_ITEM_STATE_EXPANDEDONCE;
   }

   return nState;
}


/*+-------------------------------------------------------------------------*
 *
 * CMTNode::ScLoad
 *
 * PURPOSE: Loads the node from the tree stream
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CMTNode::ScLoad()
{
    ASSERT (IsStaticNode());
    SC      sc;
    CStream stream;

    stream.Attach(GetTreeStream());

    HRESULT hr;

    IStringTablePrivate* pStringTable = CScopeTree::GetStringTable();
    ASSERT (pStringTable != NULL);


    /*
     * read the "versioned stream" marker
     */
    StreamVersionIndicator nVersionMarker;
    sc = stream.ScRead(&nVersionMarker, sizeof(nVersionMarker));
    if(sc)
        goto Error;

    /*
     * Determine the stream version number.  If this is a versioned
     * stream, the version is the next DWORD in the stream, otherwise
     * it must be it's a version 1 stream
     */
    StreamVersionIndicator nVersion;

    if (nVersionMarker == VersionedStreamMarker)
    {
        sc = stream.ScRead(&nVersion, sizeof(nVersion));
        if(sc)
            goto Error;
    }
    else
        nVersion = Stream_V0100;


    switch (nVersion)
    {
        /*
         * MMC 1.0 stream
         */
        case Stream_V0100:
        {
            /*
             * Version 1 streams didn't have a version marker; they began with
             * the image index as the first DWORD.  The first DWORD has
             * already been read (version marker), so we can recycle that
             * value for the image index.
             */
            m_nImage = nVersionMarker;

            /*
             * Continue reading with the display name (length then characters)
             */
            unsigned int stringLength = 0;
            sc = stream.ScRead(&stringLength, sizeof(stringLength));
            if(sc)
                goto Error;

            if (stringLength)
            {
                wchar_t* str = reinterpret_cast<wchar_t*>(alloca((stringLength+1)*2));
                ASSERT(str != NULL);
                if (str == NULL)
                    return E_POINTER;
                sc = stream.ScRead(str, stringLength*2);
                if(sc)
                    goto Error;

                str[stringLength] = 0;

                USES_CONVERSION;
                m_strName = W2T (str);
            }

            break;
        }

        /*
         * MMC 1.1 stream
         */
        case Stream_V0110:
        {
            /*
             * read the image index
             */
            sc = stream.ScRead(&m_nImage, sizeof(m_nImage));
            if(sc)
                goto Error;

            /*
             * read the name (stream insertion operators will throw
             * _com_error's, so we need an exception block here)
             */
            try
            {
                IStream *pStream = stream.Get();
                if(!pStream)
                    goto PointerError;

                *pStream >> m_strName;
            }
            catch (_com_error& err)
            {
                hr = err.Error();
                ASSERT (false && "Caught _com_error");
                return (hr);
            }
            break;
        }

        default:
#ifdef DBG
            TCHAR szTraceMsg[80];
            wsprintf (szTraceMsg, _T("Unexpected stream version 0x08x\n"), nVersion);
            TRACE (szTraceMsg);
            ASSERT (FALSE);
#endif
            return (E_FAIL);
            break;
    }

Cleanup:
    return sc;
PointerError:
    sc = E_POINTER;
Error:
    TraceError(TEXT("CMTNode::Load"), sc);
    goto Cleanup;
}

HRESULT CMTNode::Init(void)
{
    DECLARE_SC(sc, TEXT("CMTNode::Init"));

    if (m_bInit == TRUE)
        return S_FALSE;

    ASSERT(WasExpandedAtLeastOnce() == FALSE);

    if (!m_pPrimaryComponentData)
        return E_FAIL;


    CMTSnapInNode* pMTSnapIn = GetStaticParent();
    HMTNODE hMTNode = CMTNode::ToHandle(pMTSnapIn);

    if (!m_pPrimaryComponentData->IsInitialized())
    {

        sc = m_pPrimaryComponentData->Init(hMTNode);
        if(sc)
            return sc.ToHr();

        sc = pMTSnapIn->ScInitIComponentData(m_pPrimaryComponentData);
        if (sc)
            return sc.ToHr();
    }

    // Init the extensions
    m_bInit = TRUE;

    BOOL fProblem = FALSE;

    // Get node's node-type
    GUID guidNodeType;
    sc = GetNodeType(&guidNodeType);
    if (sc)
        return sc.ToHr();


    CExtensionsIterator it;
    // TODO: try to use the easier form of it.ScInitialize()
    sc = it.ScInitialize(m_pPrimaryComponentData->GetSnapIn(), guidNodeType, g_szNameSpace,
                            m_arrayDynExtCLSID.GetData(), m_arrayDynExtCLSID.GetSize());
    if(sc)
        return sc.ToHr();
    else
    {
        CComponentData* pCCD = NULL;

        for (; it.IsEnd() == FALSE; it.Advance())
        {
            pCCD = pMTSnapIn->GetComponentData(it.GetCLSID());
            if (pCCD == NULL)
            {
                CSnapInPtr spSnapIn;

                // If a dynamic extension, we have to get the snap-in ourselves
                // otherwise the iterator has it
                if (it.IsDynamic())
                {
                    CSnapInsCache* const pCache = theApp.GetSnapInsCache();
                    ASSERT(pCache != NULL);

                    SC sc = pCache->ScGetSnapIn(it.GetCLSID(), &spSnapIn);
                    ASSERT(!sc.IsError());

                    // On failure, continue with other extensions
                    if (sc)
                        continue;
                }
                else
                {
                    spSnapIn = it.GetSnapIn();
                }

                ASSERT(spSnapIn != NULL);

                pCCD = new CComponentData(spSnapIn);
                pMTSnapIn->AddComponentDataToArray(pCCD);
            }

            ASSERT(pCCD != NULL);

            if (pCCD != NULL && pCCD->IsInitialized() == FALSE)
            {
                sc = pCCD->Init(hMTNode);

                if ( !sc.IsError() )
                    sc = pMTSnapIn->ScInitIComponentData(pCCD);

                if ( sc )
                {
                    sc.TraceAndClear();
                    fProblem = TRUE;
                }
            }
        }

        pMTSnapIn->CompressComponentDataArray();

    }

    if (fProblem == TRUE)
    {
        Dbg(DEB_TRACE, _T("Failed to load some extensions"));
    }

    return S_OK;
}

HRESULT CMTNode::Expand(void)
{
    DECLARE_SC(sc, TEXT("CMTNode::Expand"));

    CComponentData* pCCD = m_pPrimaryComponentData;
    if (WasExpandedAtLeastOnce() == FALSE)
        Init();

    SetExpandedAtLeastOnce();

    ASSERT(pCCD != NULL);
    if (pCCD == NULL)
        return E_FAIL;

    // Get the data object for the cookie from the owner snap-in
    IDataObjectPtr spDataObject;
    HRESULT hr = pCCD->QueryDataObject(GetUserParam(), CCT_SCOPE, &spDataObject);
    CHECK_HRESULT(hr);
    if (FAILED(hr))
        return hr;

//  hr = pCCD->Notify (spDataObject, MMCN_EXPAND, TRUE,
//                     reinterpret_cast<LPARAM>(this));
    hr = Expand (pCCD, spDataObject, TRUE);

    CHECK_HRESULT(hr);
    if (FAILED(hr))
        return hr;

    // Mark the folder for the master tree item as expanded
    CMTSnapInNode* pSIMTNode = GetStaticParent();

    //
    // Deal with extension snap-ins
    //

    m_bExtensionsExpanded = TRUE;

    // Get node's node-type
    GUID guidNodeType;
    hr = GetNodeType(&guidNodeType);
    if (FAILED(hr))
        return hr;

    CExtensionsIterator it;

    // TODO: try to use the easier form of it.ScInitialize()
    sc = it.ScInitialize(GetPrimarySnapIn(), guidNodeType, g_szNameSpace,
                    m_arrayDynExtCLSID.GetData(), m_arrayDynExtCLSID.GetSize());
    if (sc)
        return S_FALSE;     // The snapin is not loaded on the m/c.

    if (it.IsEnd())  // No extensions.
        return S_OK;

    BOOL fProblem = FALSE;

    for (; it.IsEnd() == FALSE; it.Advance())
    {
        CComponentData* pCCD = pSIMTNode->GetComponentData(it.GetCLSID());
        if (pCCD == NULL)
            continue;

//      hr = pCCD->Notify (spDataObject, MMCN_EXPAND, TRUE,
//                         reinterpret_cast<LPARAM>(this));
        hr = Expand (pCCD, spDataObject, TRUE);
        CHECK_HRESULT(hr);

        // continue even if an error occurs with extension snapins
        if (FAILED(hr))
            fProblem = TRUE;
    }

    return (fProblem == TRUE) ? S_FALSE : S_OK;
}


CNode* CMTNode::GetNode(CViewData* pViewData, BOOL fRootNode)
{
    CMTSnapInNode* pMTSnapInNode = GetStaticParent();
    if (pMTSnapInNode == NULL)
        return (NULL);

    if (fRootNode)
    {
        /*
         * create a static parent node for this non-static
         * root node (it will be deleted in the CNode dtor)
         */
        CNode* pNodeTemp = pMTSnapInNode->GetNode(pViewData, FALSE);
        if (pNodeTemp == NULL)
            return NULL;
    }

    CNode* pNode = new CNode(this, pViewData, fRootNode);

    if (pNode != NULL)
    {
        CComponent* pCC = pMTSnapInNode->GetComponent(pViewData->GetViewID(),
                                    GetPrimaryComponentID(), GetPrimarySnapIn());
        if (pCC==NULL)
        {
            delete pNode;
            return NULL;
        }
        else
            pNode->SetPrimaryComponent(pCC);
    }

    return pNode;
}

HRESULT CMTNode::AddExtension(LPCLSID lpclsid)
{
    DECLARE_SC(sc, TEXT("CMTNode::AddExtension"));
    sc = ScCheckPointers(lpclsid);
    if (sc)
        return sc.ToHr();

    CMTSnapInNode* pMTSnapIn = GetStaticParent();
    CSnapInsCache* const pCache = theApp.GetSnapInsCache();

    sc = ScCheckPointers(pMTSnapIn, pCache, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    do // not a loop
    {
        // Get node's node-type
        GUID guidNodeType;
        sc = GetNodeType(&guidNodeType);
        if (sc)
            return sc.ToHr();

        // Must be a namespace extension
        if (!ExtendsNodeNameSpace(guidNodeType, lpclsid))
            return (sc = E_INVALIDARG).ToHr();

        // Check if extension is already enabled
        CExtensionsIterator it;
        // TODO: try to use the easier form of it.ScInitialize()
        sc = it.ScInitialize(GetPrimarySnapIn(), guidNodeType, g_szNameSpace,
                             m_arrayDynExtCLSID.GetData(), m_arrayDynExtCLSID.GetSize());
        for (; it.IsEnd() == FALSE; it.Advance())
        {
            if (IsEqualCLSID(*lpclsid, it.GetCLSID()))
                return (sc = S_FALSE).ToHr();
        }

        // Add extension to dynamic list
        m_arrayDynExtCLSID.Add(*lpclsid);

        // No errors returned if node is not initialized in MMC1.2.
        if (!m_bInit)
            break;

        HMTNODE hMTNode = CMTNode::ToHandle(pMTSnapIn);

        CSnapInPtr spSI;

        CComponentData* pCCD = pMTSnapIn->GetComponentData(*lpclsid);
        if (pCCD == NULL)
        {
            sc = pCache->ScGetSnapIn(*lpclsid, &spSI);
            if (sc)
                return sc.ToHr();

            pCCD = new CComponentData(spSI);
            sc = ScCheckPointers(pCCD, E_OUTOFMEMORY);
            if (sc)
                return sc.ToHr();

            pMTSnapIn->AddComponentDataToArray(pCCD);
        }

        sc = ScCheckPointers(pCCD, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        if (pCCD->IsInitialized() == FALSE)
        {
            sc = pCCD->Init(hMTNode);

            if (sc)
            {
                // Init failed.
                pMTSnapIn->CompressComponentDataArray();
                return sc.ToHr();
            }
            else
            {
                // Above Init is successful.
                sc = pMTSnapIn->ScInitIComponentData(pCCD);
                sc.TraceAndClear(); // to maintain compatibility
            }
        }

        // Create and initialize a CComponent for all initialized nodes
        CNodeList& nodes = pMTSnapIn->GetNodeList();
        POSITION pos = nodes.GetHeadPosition();
        CNode* pNode = NULL;

        while (pos)
        {
            pNode = nodes.GetNext(pos);
            CSnapInNode* pSINode = dynamic_cast<CSnapInNode*>(pNode);
			sc = ScCheckPointers(pSINode, E_UNEXPECTED);
			if (sc)
            {
                sc.TraceAndClear();
                continue;
            }

            // Create component if hasn't been done yet
            CComponent* pCC = pSINode->GetComponent(pCCD->GetComponentID());
            if (pCC == NULL)
            {
                // Create and initialize one
                pCC = new CComponent(pCCD->GetSnapIn());

                sc = ScCheckPointers(pCC, E_OUTOFMEMORY);
                if (sc)
                    return sc.ToHr();

                pCC->SetComponentID(pCCD->GetComponentID());
                pSINode->AddComponentToArray(pCC);

                sc = pCC->Init(pCCD->GetIComponentData(), hMTNode, CNode::ToHandle(pNode),
                                 pCCD->GetComponentID(), pNode->GetViewID());

                sc.Trace_(); // Just trace for MMC1.2 compatibility.
            }
        }

        // if extensions are already expanded, expand the new one now
        if (AreExtensionsExpanded())
        {
            // Get the data object for the cookie from the owner snap-in
            IDataObjectPtr spDataObject;
            sc = GetPrimaryComponentData()->QueryDataObject(GetUserParam(), CCT_SCOPE, &spDataObject);
            if (sc)
                return sc.ToHr();

//              hr = pCCD->Notify (spDataObject, MMCN_EXPAND, TRUE,
//                                 reinterpret_cast<LPARAM>(this));
            sc = Expand (pCCD, spDataObject, TRUE);
            if (sc)
                sc.Trace_(); // Just trace for MMC1.2 compatibility.
        }
    }
    while(0);

    return sc.ToHr();
}


HRESULT CMTNode::IsExpandable()
{
    DECLARE_SC(sc, TEXT("CMTNode::IsExpandable"));

    // if already expanded, we know if there are children
    if (WasExpandedAtLeastOnce())
        return (Child() != NULL) ? S_OK : S_FALSE;

    // Even if not expanded there might be static children
    if (Child() != NULL)
        return S_OK;

    // if primary snap-in can add children, return TRUE
    // Note: When primary declares no children, it is also declaring
    // there will be no dynamic namespace extensions
    if (!(m_usExpandFlags & FLAG_NO_CHILDREN_FROM_PRIMARY))
        return S_OK;

    // Check enabled static extensions if haven't already
    if (!(m_usExpandFlags & FLAG_NAMESPACE_EXTNS_CHECKED))
    {
        m_usExpandFlags |= FLAG_NAMESPACE_EXTNS_CHECKED;

        do
        {
            // Do quick check for no extensions first
            if (GetPrimarySnapIn()->GetExtensionSnapIn() == NULL)
            {
                m_usExpandFlags |= FLAG_NO_NAMESPACE_EXTNS;
                break;
            }

            // Use iterator to find statically enabled namespace extens
            GUID guidNodeType;
            HRESULT hr = GetNodeType(&guidNodeType);
            ASSERT(SUCCEEDED(hr));
            if (FAILED(hr))
                break;

            CExtensionsIterator it;
            // TODO: try to use the easier form of it.ScInitialize()
            sc = it.ScInitialize(GetPrimarySnapIn(), guidNodeType, g_szNameSpace, NULL, 0);

            // if no extensions found, set the flag
            if (sc.IsError() || it.IsEnd())
                m_usExpandFlags |= FLAG_NO_NAMESPACE_EXTNS;
        }
        while (FALSE);
    }

    // if no namespace extensions, there will be no children
    if (m_usExpandFlags & FLAG_NO_NAMESPACE_EXTNS)
        return S_FALSE;

    return S_OK;
}


HRESULT CMTNode::Expand (
    CComponentData* pComponentData,
    IDataObject*    pDataObject,
    BOOL            bExpanding)
{
    HRESULT hr          = E_FAIL;
    bool    fSendExpand = true;

    if (CScopeTree::_IsSynchronousExpansionRequired())
    {
        MMC_EXPANDSYNC_STRUCT   ess;
        ess.bHandled   = FALSE;
        ess.bExpanding = bExpanding;
        ess.hItem      = reinterpret_cast<HSCOPEITEM>(this);

        hr = pComponentData->Notify (pDataObject, MMCN_EXPANDSYNC, 0,
                                     reinterpret_cast<LPARAM>(&ess));

        fSendExpand = !ess.bHandled;
    }

    if (fSendExpand)
    {
        hr = pComponentData->Notify (pDataObject, MMCN_EXPAND, bExpanding,
                                     reinterpret_cast<LPARAM>(this));
    }

    return (hr);
}

SC CMTNode::ScQueryDispatch(DATA_OBJECT_TYPES type,
                                      PPDISPATCH ppScopeNodeObject)
{
    DECLARE_SC(sc, _T("CMTNode::QueryDispatch"));
    sc = ScCheckPointers(ppScopeNodeObject);
    if (sc)
        return sc;

    *ppScopeNodeObject = NULL;

    CMTSnapInNode* pMTSINode = GetStaticParent();
    sc = ScCheckPointers(pMTSINode, E_UNEXPECTED);
    if (sc)
        return sc;

    CComponentData* pCCD = pMTSINode->GetComponentData(GetPrimarySnapInCLSID());
    sc = ScCheckPointers(pCCD, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = pCCD->ScQueryDispatch(GetUserParam(), type, ppScopeNodeObject);

    return sc;
}


/*+-------------------------------------------------------------------------*
 * CMTNode::SetDisplayName
 *
 *
 *--------------------------------------------------------------------------*/

void CMTNode::SetDisplayName (LPCTSTR pszName)
{
    // This function should never be called as it does nothing. Display names
    DECLARE_SC(sc, TEXT("CMTNode::SetDisplayName"));

    if (pszName != (LPCTSTR) MMC_TEXTCALLBACK)
    {
        sc = E_INVALIDARG;
        TraceError(TEXT("The string should be MMC_TEXTCALLBACK"), sc);
        sc.Clear();
    }
}


/*+-------------------------------------------------------------------------*
 *
 * CMTNode::GetDisplayName
 *
 * PURPOSE: Returns the display name of the node.
 *
 * RETURNS:
 *    LPCTSTR
 *
 *+-------------------------------------------------------------------------*/
tstring
CMTNode::GetDisplayName()
{
    CComponentData* pCCD = GetPrimaryComponentData();
    if (pCCD)
    {
        SCOPEDATAITEM ScopeDataItem;
        ZeroMemory(&ScopeDataItem, sizeof(ScopeDataItem));
        ScopeDataItem.mask   = SDI_STR;
        ScopeDataItem.lParam = GetUserParam();

        HRESULT hr = pCCD->GetDisplayInfo(&ScopeDataItem);
        CHECK_HRESULT(hr);

        /*
         * if we succeeded, cache the name returned to us for
         * persistence
         */
        if (SUCCEEDED(hr))
        {
            USES_CONVERSION;
            if (ScopeDataItem.displayname)
                SetCachedDisplayName(OLE2T(ScopeDataItem.displayname));
            else
                SetCachedDisplayName(_T(""));
        }
    }

    return GetCachedDisplayName();
}

/***************************************************************************\
 *
 * METHOD:  CMTNode::ScGetPropertyFromINodeProperties
 *
 * PURPOSE: gets SnapIn property thru INodeProperties interface
 *
 * PARAMETERS:
 *    LPDATAOBJECT pDataObject  [in] - data object
 *    BSTR bstrPropertyName     [in] - property name
 *    PBSTR  pbstrPropertyValue [out] - property value
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMTNode::ScGetPropertyFromINodeProperties(LPDATAOBJECT pDataObject, BSTR bstrPropertyName, PBSTR  pbstrPropertyValue)
{
    DECLARE_SC(sc, TEXT("CMTNode::ScGetPropertyFromINodeProperties"));

    SC sc_no_trace; // for 'valid' error - not to be traced

    // parameter check
    sc = ScCheckPointers(pDataObject, bstrPropertyName, pbstrPropertyValue);
    if(sc)
        return sc;

    // get the CComponentData
    CComponentData *pComponentData = GetPrimaryComponentData();
    sc = ScCheckPointers(pComponentData, E_UNEXPECTED);
    if(sc)
        return sc;

    // QI for INodeProperties from IComponentData
    INodePropertiesPtr spNodeProperties = pComponentData->GetIComponentData();

    // at this point we should have a valid interface if it is supported
    sc_no_trace = ScCheckPointers(spNodeProperties, E_NOINTERFACE);
    if(sc_no_trace)
        return sc_no_trace;

    // get the property
    sc_no_trace = spNodeProperties->GetProperty(pDataObject,  bstrPropertyName, pbstrPropertyValue);

    return sc_no_trace;
}

//############################################################################
//############################################################################
//
//  Implementation of class CComponentData
//
//############################################################################
//############################################################################


//____________________________________________________________________________
//
//  Class:      CComponentData Inlines
//____________________________________________________________________________
//

DEBUG_DECLARE_INSTANCE_COUNTER(CComponentData);

CComponentData::CComponentData(CSnapIn * pSnapIn)
    : m_spSnapIn(pSnapIn), m_ComponentID(-1), m_bIComponentDataInitialized(false)

{
    TRACE_CONSTRUCTOR(CComponentData);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CComponentData);

    ASSERT(m_spSnapIn != NULL);
}

CComponentData::~CComponentData()
{
    TRACE_DESTRUCTOR(CComponentData);
    DEBUG_DECREMENT_INSTANCE_COUNTER(CComponentData);

    if (m_spIComponentData != NULL)
        m_spIComponentData->Destroy();
}

HRESULT CComponentData::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    ASSERT(m_spIComponentData != NULL);
    if (m_spIComponentData == NULL)
        return E_FAIL;

    HRESULT hr = S_OK;
    __try
    {
        hr = m_spIComponentData->Notify(lpDataObject, event, arg, param);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_FAIL;
        if (m_spSnapIn)
            TraceSnapinException(m_spSnapIn->GetSnapInCLSID(), TEXT("IComponentData::Notify"), event);
    }

    return hr;
}


SC CComponentData::ScQueryDispatch(MMC_COOKIE cookie,
                                   DATA_OBJECT_TYPES type,
                                   PPDISPATCH ppScopeNodeObject)
{
    DECLARE_SC(sc, _T("CComponentData::ScQueryDispatch"));
    sc = ScCheckPointers(m_spIComponentData, E_UNEXPECTED);
    if (sc)
        return sc;

    IComponentData2Ptr spCompData2 = m_spIComponentData;
    sc = ScCheckPointers(spCompData2.GetInterfacePtr(), E_NOINTERFACE);
    if (sc)
        return sc;

    ASSERT(type != CCT_RESULT); // Cant Ask Disp for resultpane objects.
    sc = spCompData2->QueryDispatch(cookie, type, ppScopeNodeObject);

    return sc;
}



/*+-------------------------------------------------------------------------*
 *
 * CreateSnapIn
 *
 * PURPOSE: Create a name space snapin (standalone or extension).
 *
 * PARAMETERS:
 *    clsid                 - class id of the snapin to be created.
 *    ppICD                 - IComponentData ptr of created snapin.
 *    fCreateDummyOnFailure - Create dummy snapin if Create snapin fails.
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT CreateSnapIn (const CLSID& clsid, IComponentData** ppICD,
                    bool fCreateDummyOnFailure /* =true */)
{
    DECLARE_SC(sc, TEXT("CreateSnapIn"));

    EDummyCreateReason eReason = eSnapCreateFailed;
    IComponentDataPtr  spICD;

    sc = ScCheckPointers(ppICD);
    if(sc)
        return sc.ToHr();

    // initialize the out parameter
    *ppICD = NULL;

    CPolicy policy;
    sc = policy.ScInit();
    if (sc)
    {
        eReason = eSnapPolicyFailed;
    }
    else if (policy.IsPermittedSnapIn(clsid))
    {
        /*
         * Bug 258270: creating the snap-in might result in MSI running to
         * install it.  The MSI status window is modeless, but may spawn a
         * modal dialog.  If we don't manually disable MMC's main window,
         * the user might start clicking around in the scope tree while that
         * modal dialog is up, leading to reentrancy and all of the resulting
         * calamity that one would expect.
         */
        bool fReenableMMC = false;
        CScopeTree* pScopeTree = CScopeTree::GetScopeTree();
        HWND hwndMain = (pScopeTree) ? pScopeTree->GetMainWindow() : NULL;

        if (IsWindow (hwndMain))
        {
            fReenableMMC = IsWindowEnabled (hwndMain);

            if (fReenableMMC)
                EnableWindow (hwndMain, false);
        }

        //create the snapin
        sc = spICD.CreateInstance(clsid, NULL,MMC_CLSCTX_INPROC);
        if(!sc.IsError() && (spICD==NULL))
           sc = E_NOINTERFACE;

        /*
         * re-enable the main window if we disabled it
         */
        if (fReenableMMC)
            EnableWindow (hwndMain, true);

        if (sc)
        {
            ReportSnapinInitFailure(clsid);

            // Create a dummy snapin with snapin
            // creation failed message.
            eReason = eSnapCreateFailed;
        }
        else // creation succeeded. return
        {
            *ppICD = spICD.Detach();
            return sc.ToHr();
        }
    }
    else
    {
        // Display a message that policies does not
        // allow this snapin to be created.
        DisplayPolicyErrorMessage(clsid, FALSE);

        // Create a dummy snapin with policy
        // restriction message.
        sc = E_FAIL;
        eReason = eSnapPolicyFailed;
    }

    // If we've reached here, an error occurred

    // create dummy snap-in that only displays error message
    if (fCreateDummyOnFailure)
    {
        sc = ScCreateDummySnapin (&spICD, eReason, clsid);
        if(sc)
            return sc.ToHr();

        sc = ScCheckPointers(spICD, E_UNEXPECTED);
        if(sc)
            return sc.ToHr();

        *ppICD = spICD.Detach();
    }

    return sc.ToHr();
}


CExtSI* AddExtension(CSnapIn* pSnapIn, CLSID& rclsid, CSnapInsCache* pCache)
{
    ASSERT(pSnapIn != NULL);

    // See if extension is already present
    CExtSI* pExt = pSnapIn->FindExtension(rclsid);

    // if not, create one
    if (pExt == NULL)
    {
        // Create cache entry for extension snapin
        if (pCache == NULL)
            pCache = theApp.GetSnapInsCache();

        ASSERT(pCache != NULL);

        CSnapInPtr spExtSnapIn;
        SC sc = pCache->ScGetSnapIn(rclsid, &spExtSnapIn);
        ASSERT(!sc.IsError() && spExtSnapIn != NULL);

        // Attach extension to snap-in
        if (!sc.IsError())
            pExt = pSnapIn->AddExtension(spExtSnapIn);
    }
    else
    {
        // Clear deletion flag
        pExt->MarkDeleted(FALSE);
    }

    return pExt;
}


HRESULT LoadRequiredExtensions (
    CSnapIn*        pSnapIn,
    IComponentData* pICD,
    CSnapInsCache*  pCache /*=NULL*/)
{
    SC sc;

    ASSERT(pSnapIn != NULL);

    // if already loaded, just return
    if (pSnapIn->RequiredExtensionsLoaded())
        goto Cleanup;

    do
    {
        // Set extensions loaded, so we don't try again
        pSnapIn->SetRequiredExtensionsLoaded();

        // if snapin was enabling all extensions
        // clear the flags before asking again
        if (pSnapIn->DoesSnapInEnableAll())
        {
            pSnapIn->SetSnapInEnablesAll(FALSE);
            pSnapIn->SetAllExtensionsEnabled(FALSE);
        }

        // Mark all required extensions for deletion
        CExtSI* pExt = pSnapIn->GetExtensionSnapIn();
        while (pExt != NULL)
        {
            if (pExt->IsRequired())
                pExt->MarkDeleted(TRUE);

            pExt = pExt->Next();
        }

        // Check for interface
        IRequiredExtensionsPtr spReqExtn = pICD;

        // if snap-in wants all extensions enabled
        if (spReqExtn != NULL && spReqExtn->EnableAllExtensions() == S_OK)
        {
            // Set the "enable all" flags
            pSnapIn->SetSnapInEnablesAll(TRUE);
            pSnapIn->SetAllExtensionsEnabled(TRUE);
        }

        // if either user or snap-in wants all extensions
        if (pSnapIn->AreAllExtensionsEnabled())
        {
            // Get list of all extensions
            CExtensionsCache  ExtCache;
            sc = MMCGetExtensionsForSnapIn(pSnapIn->GetSnapInCLSID(), ExtCache);
            if (sc)
                goto Cleanup;

            // Add each extension to snap-in's extension list
            CExtensionsCacheIterator ExtIter(ExtCache);
            for (; ExtIter.IsEnd() == FALSE; ExtIter.Advance())
            {
                // Only add extensions that can be statically enabled
                if ((ExtIter.GetValue() & CExtSI::EXT_TYPE_STATIC) == 0)
                    continue;

                GUID clsid = ExtIter.GetKey();
                CExtSI* pExt = AddExtension(pSnapIn, clsid, pCache);

                // Mark required if enabled by the snap-in
                if (pExt != NULL && pSnapIn->DoesSnapInEnableAll())
                    pExt->SetRequired();
            }
        }

        CPolicy policy;
        sc = policy.ScInit();
        if (sc)
            goto Error;

        // if snap-in supports the interface and didn't enable all
        // ask for specific required extensions
        // Note: this is done even if the user has enabled all because
        //       we need to know which ones the snap-in requires
        if (spReqExtn != NULL && !pSnapIn->DoesSnapInEnableAll())
        {
            CLSID clsid;
            sc = spReqExtn->GetFirstExtension(&clsid);

            // Do while snap-in provides extension CLSIDs
            while (HrFromSc(sc) == S_OK)
            {
                // See if the extension is restricted by policy.
                // If so display a message.
                if (! policy.IsPermittedSnapIn(clsid))
                    DisplayPolicyErrorMessage(clsid, TRUE);

                // Add as required extension
                CExtSI* pExt = AddExtension(pSnapIn, clsid, pCache);
                if (pExt != NULL)
                    pExt->SetRequired();

                sc = spReqExtn->GetNextExtension(&clsid);
            }
        }

        // Delete extensions that are no longer required
        // Note: Because required extensions are updated when snap-in is first loaded
        //       we don't have to worry about adding/deleting any nodes now.
        pSnapIn->PurgeExtensions();

    } while (FALSE);

Cleanup:
    return HrFromSc(sc);

Error:
    TraceError(TEXT("LoadRequiredExtensions"), sc);
    goto Cleanup;
}


HRESULT CComponentData::Init(HMTNODE hMTNode)
{
    ASSERT(hMTNode != 0);

    if (IsInitialized() == TRUE)
        return S_OK;

    ASSERT(m_spSnapIn != NULL);
    HRESULT hr = S_OK;

    do
    {
        if (m_spIComponentData == NULL)
        {
            if (m_spSnapIn == NULL)
            {
                hr = E_POINTER;
                break;
            }

            IUnknownPtr spUnknown;
            hr = CreateSnapIn(m_spSnapIn->GetSnapInCLSID(), &m_spIComponentData);
            ASSERT(SUCCEEDED(hr));
            ASSERT(m_spIComponentData != NULL);

            if (FAILED(hr))
                break;
            if(m_spIComponentData == NULL)
            {
                hr = E_FAIL;
                break;
            }
        }

        hr = m_spIFramePrivate.CreateInstance(CLSID_NodeInit,
#if _MSC_VER >= 1100
                        NULL,
#endif
                        MMC_CLSCTX_INPROC);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        Debug_SetNodeInitSnapinName(m_spSnapIn, m_spIFramePrivate.GetInterfacePtr());

        // Init frame.
        ASSERT(m_ComponentID != -1);
        ASSERT(m_spIFramePrivate != NULL);
        ASSERT(m_spSnapIn != NULL);

        if ((m_spIFramePrivate == NULL) || (m_spSnapIn == NULL))
        {
            hr = E_UNEXPECTED;
            CHECK_HRESULT(hr);
            break;
        }

        m_spIFramePrivate->SetComponentID(m_ComponentID);
        m_spIFramePrivate->CreateScopeImageList(m_spSnapIn->GetSnapInCLSID());
        m_spIFramePrivate->SetNode(hMTNode, NULL);

        // Load extensions requested by snap-in and proceed regardless of outcome
        LoadRequiredExtensions(m_spSnapIn, m_spIComponentData);

        hr = m_spIComponentData->Initialize(m_spIFramePrivate);
        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

    } while (0);

    if (FAILED(hr))
    {
        m_spIComponentData = NULL;
        m_spIFramePrivate = NULL;
    }

    return hr;
}



//############################################################################
//############################################################################
//
//  Implementation of class CMTSnapInNode
//
//############################################################################
//############################################################################

DEBUG_DECLARE_INSTANCE_COUNTER(CMTSnapInNode);

CMTSnapInNode::CMTSnapInNode(Properties* pProps)
      : m_spProps            (pProps),
        m_fCallbackForDisplayName(false)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CMTSnapInNode);

    // Open and Closed images
    SetImage(eStockImage_Folder);
    SetOpenImage(eStockImage_OpenFolder);

	m_ePreloadState    = ePreload_Unknown;
    m_bHasBitmaps      = FALSE;
    m_resultImage      = CMTNode::GetImage();


    /*
     * attach this node to it's properties collection
     */
    if (m_spProps != NULL)
    {
        CSnapinProperties* pSIProps = CSnapinProperties::FromInterface (m_spProps);

        if (pSIProps != NULL)
            pSIProps->ScSetSnapInNode (this);
    }
}

CMTSnapInNode::~CMTSnapInNode() throw()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CMTSnapInNode);

    for (int i=0; i < m_ComponentDataArray.size(); i++)
        delete m_ComponentDataArray[i];

    // DON'T CHANGE THIS ORDER!!!!!
    m_ComponentStorage.Clear();

    /*
     * detach this node from it's properties collection
     */
    if (m_spProps != NULL)
    {
        CSnapinProperties* pSIProps = CSnapinProperties::FromInterface (m_spProps);

        if (pSIProps != NULL)
            pSIProps->ScSetSnapInNode (NULL);
    }

	/*
	 * clean up the image lists (they aren't self-cleaning!)
	 */
	m_imlSmall.Destroy();
	m_imlLarge.Destroy();
}

HRESULT CMTSnapInNode::Init(void)
{
    DECLARE_SC (sc, _T("CMTSnapInNode::Init"));

    if (IsInitialized() == TRUE)
        return S_FALSE;

    HRESULT hr = CMTNode::Init();
    if (FAILED(hr))
        return hr;

    /*
     * initialize the snap-in with its properties interface
     */
    sc = ScInitProperties ();
    if (sc)
        return (sc.ToHr());

    if (IsPreloadRequired())
    {
        CComponentData* pCCD = GetPrimaryComponentData();
        ASSERT(pCCD != NULL);

        IDataObjectPtr spDataObject;
        hr = pCCD->QueryDataObject(GetUserParam(), CCT_SCOPE, &spDataObject);
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
            return hr;

        HSCOPEITEM hsi = reinterpret_cast<HSCOPEITEM>(this);

        pCCD->Notify(spDataObject, MMCN_PRELOAD, hsi, 0);
    }

    return S_OK;
}


/*+-------------------------------------------------------------------------*
 * CMTSnapInNode::ScInitProperties
 *
 * Initializes the snap-in with its properties interface, if it supports
 * ISnapinProperties.
 *--------------------------------------------------------------------------*/

SC CMTSnapInNode::ScInitProperties ()
{
    DECLARE_SC (sc, _T("CMTSnapInNode::ScInitProperties"));

    /*
     * get the snap-in's IComponentData
     */
    CComponentData* pCCD = GetPrimaryComponentData();
    if (pCCD == NULL)
        return (sc = E_UNEXPECTED);

    IComponentDataPtr spComponentData = pCCD->GetIComponentData();
    if (spComponentData == NULL)
        return (sc = E_UNEXPECTED);

    /*
     * If the snap-in supports ISnapinProperties, give it its Properties
     * interface.
     */
    ISnapinPropertiesPtr spISP = spComponentData;

    if (spISP != NULL)
    {
        /*
         * If we didn't persist properties for this snap-in we won't have
         * a CSnapinProperties object yet; create one now.
         */
        CSnapinProperties* pSIProps = NULL;
        sc = ScCreateSnapinProperties (&pSIProps);
        if (sc)
            return (sc);

        if (pSIProps == NULL)
            return (sc = E_UNEXPECTED);

        /*
         * Initialize the snap-in with the initial properties.
         */
        sc = pSIProps->ScInitialize (spISP, pSIProps, this);
        if (sc)
            return (sc);
    }

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CMTSnapInNode::ScCreateSnapinProperties
 *
 * Creates the CSnapinProperties object for this node.  It is safe to call
 * this method multiple times; subsequent invocations will short out.
 *--------------------------------------------------------------------------*/

SC CMTSnapInNode::ScCreateSnapinProperties (
    CSnapinProperties** ppSIProps)      /* O:pointer to the CSnapinProperties object (optional) */
{
    DECLARE_SC (sc, _T("CMTSnapInNode::ScCreateSnapinProperties"));

    /*
     * create a CSnapinProperties if we don't already have one
     */
    if (m_spProps == NULL)
    {
        /*
         * create the properties object
         */
        CComObject<CSnapinProperties>* pSIProps;
        sc = CComObject<CSnapinProperties>::CreateInstance (&pSIProps);
        if (sc)
            return (sc);

        if (pSIProps == NULL)
            return (sc = E_UNEXPECTED);

        /*
         * keep a reference to the object
         */
        m_spProps = pSIProps;
    }

    /*
     * return a pointer to the implementing object, if desired
     */
    if (ppSIProps != NULL)
        *ppSIProps = CSnapinProperties::FromInterface (m_spProps);

    return (sc);
}


/*+-------------------------------------------------------------------------*
 *
 * CMTSnapInNode::SetDisplayName
 *
 * PURPOSE: Sets the display name of the node.
 *
 * PARAMETERS:
 *    LPCTSTR  pszName :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CMTSnapInNode::SetDisplayName(LPCTSTR pszName)
{
    bool fDisplayCallback = (pszName == (LPCTSTR)MMC_TEXTCALLBACK);

    /*
     * if our callback setting has changed, we're dirty
     */
    if (m_fCallbackForDisplayName != fDisplayCallback)
    {
        m_fCallbackForDisplayName = fDisplayCallback;
        SetDirty();
    }

    /*
     * if we're not now callback, cache the name (if we're callback,
     * the name will be cached the next time GetDisplayName is called)
     */
    if (!m_fCallbackForDisplayName)
        SetCachedDisplayName(pszName);
}

/*+-------------------------------------------------------------------------*
 *
 * CMTSnapInNode::GetDisplayName
 *
 * PURPOSE: Returns the display name of the node.
 *
 * RETURNS:
 *    LPCTSTR
 *
 *+-------------------------------------------------------------------------*/
tstring
CMTSnapInNode::GetDisplayName()
{
    if (m_fCallbackForDisplayName)
        return (CMTNode::GetDisplayName());

    return GetCachedDisplayName();
}

HRESULT CMTSnapInNode::IsExpandable()
{
    // if haven't intiailized the snap-in we have to assume that
    // there could be children
    if (!IsInitialized())
        return S_OK;

    return CMTNode::IsExpandable();
}


void CMTSnapInNode::CompressComponentDataArray()
{
    int nSize = m_ComponentDataArray.size();
    int nSkipped = 0;

    for (int i=0; i<nSize; ++i)
    {
        ASSERT(m_ComponentDataArray[i] != NULL);

        if (m_ComponentDataArray[i]->IsInitialized() == FALSE)
        {
            // if component failed to intialize, delete it
            // and skip over it
            delete m_ComponentDataArray[i];
            ++nSkipped;
        }
        else
        {
            // if components have been skiped, move the good component to the
            // first vacant slot and adjust the component's ID
            if (nSkipped)
            {
                m_ComponentDataArray[i-nSkipped] = m_ComponentDataArray[i];
                m_ComponentDataArray[i-nSkipped]->ResetComponentID(i-nSkipped);
            }
        }
     }

     // reduce array size by number skipped
     if (nSkipped)
        m_ComponentDataArray.resize(nSize - nSkipped);
}

void CMTSnapInNode::AddNode(CNode * pNode)
{
    #ifdef DBG
    {
        POSITION pos = m_NodeList.Find(pNode);
        ASSERT(pos == NULL);
    }
    #endif

    if (!FindNode(pNode->GetViewID()))
        m_NodeList.AddHead(pNode);
}

void CMTSnapInNode::RemoveNode(CNode * pNode)
{
    POSITION pos = m_NodeList.Find(pNode);

    if (pos != NULL)
        m_NodeList.RemoveAt(pos);
}

CSnapInNode* CMTSnapInNode::FindNode(int nViewID)
{
    POSITION pos = m_NodeList.GetHeadPosition();
    while (pos)
    {
        CSnapInNode* pSINode =
            dynamic_cast<CSnapInNode*>(m_NodeList.GetNext(pos));
        ASSERT(pSINode != NULL);

        if (pSINode->GetViewID() == nViewID)
        {
            return pSINode;
        }
    }

    return NULL;
}

UINT CMTSnapInNode::GetResultImage(CNode* pNode, IImageListPrivate* pResultImageList)
{
    if (pResultImageList == NULL)
        return GetImage();
    if ((m_bHasBitmaps == FALSE) && (m_resultImage != MMC_IMAGECALLBACK))
        return GetImage();

    int ret = 0;
    IFramePrivate* pFramePrivate = dynamic_cast<IFramePrivate*>(pResultImageList);
    COMPONENTID id = 0;
    pFramePrivate->GetComponentID (&id);
    COMPONENTID tempID = (COMPONENTID)-GetID(); // use Ravi's negative of ID scheme
    pFramePrivate->SetComponentID (tempID);

    if (m_bHasBitmaps)
	{
		const int nResultImageIndex = 0;

		/*
		 * if we haven't added this node's images to the result image list,
		 * add it now
		 */
		if (FAILED (pResultImageList->MapRsltImage (tempID, nResultImageIndex, &ret)))
		{
			/*
			 * Extract icons from the imagelist dynamically for device independence.
			 * (There ought to be a way to copy images from one imagelist to
			 * another, but there's not.  ImageList_Copy looks like it should
			 * work, but it only supports copying images within the same image
			 * list.)
			 */
			HRESULT hr;
			CSmartIcon icon;

			/*
			 * Set our icon from the small imagelist.  ImageListSetIcon
			 * will also set the large icon by stretching the small, but
			 * we'll fix that below.
			 */
			icon.Attach (m_imlSmall.GetIcon (0));
			hr = pResultImageList->ImageListSetIcon (
							reinterpret_cast<PLONG_PTR>((HICON)icon),
							nResultImageIndex);

			if (hr == S_OK)
			{
				/*
				 * Replace the large icon that ImageListSetIcon generated
				 * by stretching the small icon above, with the large icon
				 * that was created with the correct dimensions.
				 */
				icon.Attach (m_imlLarge.GetIcon (0));
				hr = pResultImageList->ImageListSetIcon (
								reinterpret_cast<PLONG_PTR>((HICON)icon),
								ILSI_LARGE_ICON (nResultImageIndex));
			}

			if (hr == S_OK)
				pResultImageList->MapRsltImage (tempID, nResultImageIndex, &ret);
		}
    }
	else if (m_resultImage == MMC_IMAGECALLBACK)
	{
        // ask snapin
        // first call IComponent::Notify w/ MMCN_ADD_IMAGES;
        CComponent* pComponent = pNode->GetPrimaryComponent ();
        if (pComponent) {
            IDataObjectPtr spDataObject;
            HRESULT hr = pComponent->QueryDataObject (GetUserParam(), CCT_RESULT, &spDataObject);
            if (spDataObject) {
                hr = pComponent->Notify (spDataObject, MMCN_ADD_IMAGES,
                                        (LPARAM)pResultImageList, (LPARAM)this);
                if (hr == S_OK) {
                    RESULTDATAITEM rdi;
                    ZeroMemory (&rdi, sizeof(rdi));
                    rdi.mask   = SDI_IMAGE;
                    rdi.lParam = GetUserParam();
                    rdi.nImage = 0;
                    hr = pComponent->GetDisplayInfo (&rdi);

                    // map user's number to our number
                    pResultImageList->MapRsltImage (tempID, rdi.nImage, &ret);
                }
            }
        }
    }
    pFramePrivate->SetComponentID (id);         // change back
    return (UINT)ret;
}


/*+-------------------------------------------------------------------------*
 * CMTSnapInNode::ScHandleCustomImages
 *
 * Retrieves images from a snap-in's About object and delegates to the
 * overload of this function to assemble the images into their appropriate
 * internal state.
 *--------------------------------------------------------------------------*/

SC CMTSnapInNode::ScHandleCustomImages (const CLSID& clsidSnapin)
{
	DECLARE_SC (sc, _T("CMTSnapInNode::ScHandleCustomImages"));

	m_bHasBitmaps = false;

	/*
	 * open the SnapIns key
	 */
    MMC_ATL::CRegKey keySnapins;
    sc.FromWin32 (keySnapins.Open (HKEY_LOCAL_MACHINE, SNAPINS_KEY, KEY_READ));
	if (sc)
		return (sc);

	OLECHAR szSnapinCLSID[40];
	if (StringFromGUID2 (clsidSnapin, szSnapinCLSID, countof(szSnapinCLSID)) == 0)
		return (sc = E_UNEXPECTED);

	/*
	 * open the key for the requested snap-in
	 */
    USES_CONVERSION;
	MMC_ATL::CRegKey keySnapin;
	sc.FromWin32 (keySnapin.Open (keySnapins, OLE2T(szSnapinCLSID), KEY_READ));
	if (sc)
		return (sc);

    // from snapin clsid, get "about" clsid, if any.
    TCHAR szAboutCLSID[40] = {0};
	DWORD dwCnt = sizeof(szAboutCLSID);
	sc.FromWin32 (keySnapin.QueryValue (szAboutCLSID, _T("About"), &dwCnt));
	if (sc)
		return (sc);

	if (szAboutCLSID[0] == 0)
		return (sc = E_FAIL);

    // create an instance of the About object
    ISnapinAboutPtr spISA;
    sc = spISA.CreateInstance (T2OLE (szAboutCLSID), NULL, MMC_CLSCTX_INPROC);
	if (sc)
		return (sc);

	sc = ScCheckPointers (spISA, E_UNEXPECTED);
	if (sc)
		return (sc);

    // get the images
    // Documentation explicitly states these images are NOT owned by
    // MMC, despite the are out parameters. So we cannot release them,
    // even though most snapins will leak them anyway.
    // see bugs #139613 & #140637
    HBITMAP hbmpSmallImage = NULL;
    HBITMAP hbmpSmallImageOpen = NULL;
    HBITMAP hbmpLargeImage = NULL;
	COLORREF crMask;
    sc = spISA->GetStaticFolderImage (&hbmpSmallImage,
									  &hbmpSmallImageOpen,
									  &hbmpLargeImage,
									  &crMask);
	if (sc)
		return (sc);

	/*
	 * if the snap-in didn't give us a complete set of bitmaps,
	 * use default images but don't fail
	 */
    if (hbmpSmallImage == NULL || hbmpSmallImageOpen == NULL || hbmpLargeImage == NULL)
        return (sc);

	sc = ScHandleCustomImages (hbmpSmallImage, hbmpSmallImageOpen, hbmpLargeImage, crMask);
	if (sc)
		return (sc);

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CMTSnapInNode::ScHandleCustomImages
 *
 * Takes custom images for this snap-in and adds them to an imagelist for
 * device-independence.
 *--------------------------------------------------------------------------*/

SC CMTSnapInNode::ScHandleCustomImages (
	HBITMAP		hbmSmall,			// I:small image
	HBITMAP		hbmSmallOpen,		// I:small open image
	HBITMAP		hbmLarge,			// I:large image
	COLORREF	crMask)				// I:mask color, common between all bitmaps
{
	DECLARE_SC (sc, _T("CMTSnapInNode::ScHandleCustomImages"));

	/*
	 * validate input
	 */
	sc = ScCheckPointers (hbmSmall, hbmSmallOpen, hbmLarge);
	if (sc)
		return (sc);

	/*
	 * we need to make copies of the input bitmaps because the calls to
	 * ImageList_AddMasked (below) messes up the background color
	 */
    WTL::CBitmap bmpSmallCopy = CopyBitmap (hbmSmall);
	if (bmpSmallCopy.IsNull())
		return (sc.FromLastError());

    WTL::CBitmap bmpSmallOpenCopy = CopyBitmap (hbmSmallOpen);
	if (bmpSmallOpenCopy.IsNull())
		return (sc.FromLastError());

    WTL::CBitmap bmpLargeCopy = CopyBitmap (hbmLarge);
	if (bmpLargeCopy.IsNull())
		return (sc.FromLastError());

	/*
	 * preserve the images in imagelists for device independence
	 */
	ASSERT (m_imlSmall.IsNull());
	if (!m_imlSmall.Create (16, 16, ILC_COLOR8 | ILC_MASK, 2, 1)	||
		(m_imlSmall.Add (bmpSmallCopy,     crMask) == -1)			||
		(m_imlSmall.Add (bmpSmallOpenCopy, crMask) == -1))
	{
		return (sc.FromLastError());
	}

	ASSERT (m_imlLarge.IsNull());
	if (!m_imlLarge.Create (32, 32, ILC_COLOR8 | ILC_MASK, 1, 1)	||
		(m_imlLarge.Add (bmpLargeCopy,     crMask) == -1))
	{
		return (sc.FromLastError());
	}

    m_bHasBitmaps = TRUE;

	sc = ScAddImagesToImageList ();
	if (sc)
		return (sc);

	return (sc);
}


void CMTSnapInNode::SetPrimarySnapIn(CSnapIn * pSI)
{
	DECLARE_SC (sc, _T("CMTSnapInNode::SetPrimarySnapIn"));

    ASSERT(m_ComponentDataArray.size() == 0);
    CComponentData* pCCD = new CComponentData(pSI);
    int nID = AddComponentDataToArray(pCCD);
    ASSERT(nID == 0);
    SetPrimaryComponentData(pCCD);

    if (m_bHasBitmaps == FALSE) {
        sc = ScHandleCustomImages (pSI->GetSnapInCLSID());
		if (sc)
			sc.TraceAndClear();

		if (m_bHasBitmaps)
			SetDirty();
    }
}

/***************************************************************************\
 *
 * METHOD:  CMTSnapInNode::ScInitIComponent
 *
 * PURPOSE: Either loads component (if has a stream/storage)
 *          or initializes with a fresh stream/storage
 *
 * PARAMETERS:
 *    CComponent* pCComponent   [in] component to initialize
 *    int viewID                [in] view id of the component
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMTSnapInNode::ScInitIComponent(CComponent* pCComponent, int viewID)
{
    DECLARE_SC(sc, TEXT("CMTSnapInNode::ScInitIComponent"));

    // parameter chack
    sc = ScCheckPointers( pCComponent );
    if (sc)
        return sc;

    IComponent* pComponent = pCComponent->GetIComponent();
    sc = ScCheckPointers( pComponent, E_UNEXPECTED );
    if (sc)
        return sc;

    CLSID clsid = pCComponent->GetCLSID();

    // initialize the snapin object
    sc = ScInitComponentOrComponentData(pComponent, &m_ComponentPersistor, viewID, clsid );
    if (sc)
        return sc;

    pCComponent->SetIComponentInitialized();

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMTSnapInNode::ScInitIComponentData
 *
 * PURPOSE: Either loads component data (if has a stream/storage)
 *          or initializes with a fresh stream/storage
 *
 * PARAMETERS:
 *    CComponentData* pCComponentData
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMTSnapInNode::ScInitIComponentData(CComponentData* pCComponentData)
{
    DECLARE_SC(sc, TEXT("CMTSnapInNode::ScInitIComponentData"));

    // parameter check
    sc = ScCheckPointers( pCComponentData );
    if (sc)
        return sc;

    // Get the IComponentData to later obtain IPersist* from
    IComponentData* const pIComponentData = pCComponentData->GetIComponentData();
    sc = ScCheckPointers( pIComponentData, E_UNEXPECTED );
    if (sc)
        return sc;

    const CLSID& clsid = pCComponentData->GetCLSID();

    // initialize the snapin object
    sc = ScInitComponentOrComponentData(pIComponentData, &m_CDPersistor, CDPersistor::VIEW_ID_DOCUMENT, clsid );
    if (sc)
        return sc;

    pCComponentData->SetIComponentDataInitialized();

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMTSnapInNode::ScInitComponentOrComponentData
 *
 * PURPOSE: Either loads snapin object (component or component data)
 *          or initializes with a fresh stream/storage
 *
 * PARAMETERS:
 *    IUnknown *pSnapin         [in] - snapin to initialize
 *    CMTSnapinNodeStreamsAndStorages *pStreamsAndStorages
 *                              [in] - collection of streams/storages
 *    int idView                [in] - view id of component
 *    const CLSID& clsid        [in] class is of the snapin
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMTSnapInNode::ScInitComponentOrComponentData(IUnknown *pSnapin, CMTSnapinNodeStreamsAndStorages *pStreamsAndStorages, int idView, const CLSID& clsid )
{
    DECLARE_SC(sc, TEXT("CMTSnapInNode::ScInitComponentOrComponentData"));

    // parameter check
    sc = ScCheckPointers( pSnapin, pStreamsAndStorages );
    if (sc)
        return sc;

    IPersistStreamPtr       spIPersistStream;
    IPersistStreamInitPtr   spIPersistStreamInit;
    IPersistStoragePtr      spIPersistStorage;

    // determine the interface supported and load/init

    if ( (spIPersistStream = pSnapin) != NULL) // QI first for an IPersistStream
    {
        if ( pStreamsAndStorages->HasStream( idView, clsid ) )
        {
            // load
            IStreamPtr spStream;
            sc = pStreamsAndStorages->ScGetIStream( idView, clsid, &spStream);
            if (sc)
                return sc;

            sc = spIPersistStream->Load( spStream );
            if(sc)
                return sc;
        }
        // for this interface there in no initialization if we have nothing to load from
    }
    else if ( (spIPersistStreamInit = pSnapin) != NULL) // QI for an IPersistStreamInit
    {
        if ( pStreamsAndStorages->HasStream( idView, clsid ) )
        {
            // load
            IStreamPtr spStream;
            sc = pStreamsAndStorages->ScGetIStream( idView, clsid, &spStream);
            if (sc)
                return sc;

            sc = spIPersistStreamInit->Load( spStream );
            if(sc)
                return sc;
        }
        else
        {
            // init new
            sc = spIPersistStreamInit->InitNew();
            if (sc)
                return sc;
        }
    }
    else if ( (spIPersistStorage = pSnapin) != NULL) // QI for an IPersistStorage
    {
        bool bHasStorage = pStreamsAndStorages->HasStorage( idView, clsid );

        IStoragePtr spStorage;
        sc = pStreamsAndStorages->ScGetIStorage( idView, clsid, &spStorage);
        if (sc)
            return sc;

        if ( bHasStorage )
        {
            sc = spIPersistStorage->Load( spStorage );
            if (sc)
                return sc;
        }
        else
        {
            sc = spIPersistStorage->InitNew( spStorage );
            if (sc)
                return sc;
        }
    }

    return sc;
}


/**************************************************************************
// CMTSnapinNode::CloseView
//
// This method does any clean-up that is required before deleting
// a view. For now all we do is close any OCXs assocoiated with the view.
// This is done so the OCX can close before the view is hidden.
***************************************************************************/
HRESULT CMTSnapInNode::CloseView(int idView)
{
    // Locate associated node in specified view
    CNodeList& nodes = GetNodeList();
    ASSERT(&nodes != NULL);
    if (&nodes == NULL)
        return E_FAIL;

    POSITION pos = nodes.GetHeadPosition();
    while (pos)
    {
        CNode* pNode = nodes.GetNext(pos);
        ASSERT(pNode != NULL);
        if (pNode == NULL)
            continue;

        // if match found, tell node to close its controls
        if (pNode->GetViewID() == idView)
        {
            CSnapInNode* pSINode = dynamic_cast<CSnapInNode*>(pNode);
            ASSERT(pSINode != NULL);

            pSINode->CloseControls();
            break;
        }
    }

    HRESULT hr = CMTNode::CloseView(idView);
    ASSERT(hr == S_OK);
    return hr == S_OK ? S_OK : E_FAIL;
}


HRESULT CMTSnapInNode::DeleteView(int idView)
{
    HRESULT hr;

    m_ComponentPersistor.RemoveView(idView);

    hr = CMTNode::DeleteView(idView);
    ASSERT(hr == S_OK);
    return hr == S_OK ? S_OK : E_FAIL;
}

SC CMTSnapInNode::ScLoad()
{
    SC      sc;
    CStream stream;
    CLSID   clsid;

    sc = CMTNode::ScLoad();
    if(sc)
        goto Error;

    stream.Attach(GetTreeStream());

    sc = stream.ScRead(&clsid, sizeof(clsid));
    if(sc)
        goto Error;

    // read bitmaps, if any

    // we are ignoring error here, because we had gaps in the save code
    // in the past and now we have console files to deal with
    // see bug 96402 "Private:  AV in FrontPage Server Extensions & HP ManageX"
	ASSERT (sizeof(m_bHasBitmaps) == sizeof(BOOL));
    sc = stream.ScRead(&m_bHasBitmaps, sizeof(BOOL), true /*bIgnoreErrors*/);
    if(sc)
        goto Error;

    if (m_bHasBitmaps == TRUE)
    {

		WTL::CBitmap bmpSmall;
        sc = ScLoadBitmap (stream, &bmpSmall.m_hBitmap);
        if(sc)
            goto Error;

		WTL::CBitmap bmpSmallOpen;
        sc = ScLoadBitmap (stream, &bmpSmallOpen.m_hBitmap);
        if(sc)
            goto Error;

		WTL::CBitmap bmpLarge;
        sc = ScLoadBitmap (stream, &bmpLarge.m_hBitmap);
        if(sc)
            goto Error;

		COLORREF crMask;
        sc = stream.ScRead(&crMask, sizeof(COLORREF));
        if(sc)
            goto Error;

		sc = ScHandleCustomImages (bmpSmall, bmpSmallOpen, bmpLarge, crMask);
		if (sc)
			goto Error;
    }

    {
        CSnapInsCache* const pCache = theApp.GetSnapInsCache();
        ASSERT(pCache != NULL);
        if (pCache == NULL)
            return E_FAIL;

        CSnapInPtr spSI;
        sc = pCache->ScGetSnapIn(clsid, &spSI);
        if (sc)
            goto Error;
        sc = ScCheckPointers(spSI, E_UNEXPECTED);
        if (sc)
            goto Error;

        SetPrimarySnapIn(spSI);
        pCache->SetDirty(FALSE);
    }

    // see if we have to do the preload thing
	{
		BOOL bPreload = FALSE;
		sc = stream.ScRead(&bPreload, sizeof(BOOL), true /*bIgnoreErrors*/); // the preload bit is optional, do no error out.
		if(sc)
			goto Error;

		SetPreloadRequired (bPreload);
	}

    // read all the streams and storages for this node
    sc = ScReadStreamsAndStoragesFromConsole();
	if(sc)
		goto Error;

Cleanup:
    return sc == S_OK ? S_OK : E_FAIL;
Error:
    TraceError(TEXT("CMTSnapInNode::Load"), sc);
    goto Cleanup;

}

HRESULT CMTSnapInNode::IsDirty()
{
	DECLARE_SC (sc, _T("CMTSnapInNode::IsDirty"));

    HRESULT hr = CMTNode::IsDirty();
    ASSERT(SUCCEEDED(hr));
    if (hr != S_FALSE)
    {
        TraceDirtyFlag(TEXT("CMTSnapinNode"), true);
        return hr;
    }

    hr = AreIComponentDatasDirty();
    ASSERT(hr == S_OK || hr == S_FALSE);
    if (hr == S_OK)
    {
        TraceDirtyFlag(TEXT("CMTSnapinNode"), true);
        return S_OK;
    }
    if (hr != S_FALSE)
    {
        TraceDirtyFlag(TEXT("CMTSnapinNode"), true);
        return E_FAIL;
    }

    hr = AreIComponentsDirty();
    ASSERT(hr == S_OK || hr == S_FALSE);
    if (hr == S_OK)
    {
        TraceDirtyFlag(TEXT("CMTSnapinNode"), true);
        return S_OK;
    }
    if (hr != S_FALSE)
    {
        TraceDirtyFlag(TEXT("CMTSnapinNode"), true);
        return E_FAIL;
    }

	/*
	 * See if "preload" bit changed.  If an error occurred while querying
	 * the snap-in, we'll assume that the preload bit hasn't changed.
	 */
	PreloadState ePreloadState = m_ePreloadState;
	SC scNoTrace = ScQueryPreloadRequired (ePreloadState);

    if (scNoTrace.IsError() || (ePreloadState == m_ePreloadState))
    {
        TraceDirtyFlag(TEXT("CMTSnapinNode"), false);
        return S_FALSE;
    }

    TraceDirtyFlag(TEXT("CMTSnapinNode"), true);
    return S_OK;
}


/*+-------------------------------------------------------------------------*
 * CMTSnapInNode::AreIComponentDatasDirty
 *
 * Returns S_OK if any of the IComponentDatas attached to this snap-in node
 * (i.e. those of this snap-in and its extensions) is dirty, S_FALSE otherwise.
 *--------------------------------------------------------------------------*/

HRESULT CMTSnapInNode::AreIComponentDatasDirty()
{
    CComponentData* const pCCD = GetPrimaryComponentData();

#if 1
    /*
     * we used to check the primary component data explicitly, but that
     * (if it exists) is always the first element in the IComponentData
     * array.  The loop below will handle it in a more generic manner.
     */
    ASSERT ((pCCD == NULL) || (pCCD == m_ComponentDataArray[0]));
#else
    IComponentData* const pICCD = pCCD != NULL ?
                                           pCCD->GetIComponentData() : NULL;

    if ((pICCD != NULL) && (IsIUnknownDirty (pICCD) == S_OK))
        return (S_OK);
#endif

    /*
     * check all of the IComponentDatas attached to this snap-in node
     * to see if any one is dirty
     */
    UINT cComponentDatas = m_ComponentDataArray.size();

    for (UINT i = 0; i < cComponentDatas; i++)
    {
        IComponentData* pICCD = (m_ComponentDataArray[i] != NULL)
                                    ? m_ComponentDataArray[i]->GetIComponentData()
                                    : NULL;

        if ((pICCD != NULL) && (IsIUnknownDirty (pICCD) == S_OK))
            return (S_OK);
    }

    return (S_FALSE);
}


/*+-------------------------------------------------------------------------*
 * CMTSnapInNode::AreIComponentsDirty
 *
 * Returns S_OK if any of the IComponents attached to this snap-in node
 * (in any view) is dirty, S_FALSE otherwise.
 *--------------------------------------------------------------------------*/

HRESULT CMTSnapInNode::AreIComponentsDirty()
{
    CNodeList& nodes = GetNodeList();
    ASSERT(&nodes != NULL);
    if (&nodes == NULL)
        return E_FAIL;

    POSITION pos = nodes.GetHeadPosition();

    while (pos)
    {
        CNode* pNode = nodes.GetNext(pos);
        ASSERT(pNode != NULL);
        if (pNode == NULL)
            return E_FAIL;

        CSnapInNode* pSINode = dynamic_cast<CSnapInNode*>(pNode);
        ASSERT(pSINode != NULL);
        if (pSINode == NULL)
            return E_FAIL;

        const CComponentArray& components = pSINode->GetComponentArray();
        const int end = components.size();
        for (int i = 0; i < end; i++)
        {
            CComponent* pCC = components[i];
            if ((NULL == pCC) || (pCC->IsInitialized() == FALSE) )
                continue;

            IComponent* pComponent = pCC->GetIComponent();
            if (NULL == pComponent)
                continue;

            HRESULT hr = IsIUnknownDirty(pComponent);
            ASSERT(hr == S_OK || hr == S_FALSE);
            if (hr == S_OK)
                return S_OK;
            if (hr != S_FALSE)
                return E_FAIL;
        }
    }

    return S_FALSE;
}


/*+-------------------------------------------------------------------------*
 * CMTSnapInNode::IsIUnknownDirty
 *
 * Checks an IUnknown* for any of the three persistence interfaces
 * (IPersistStream, IPersistStreamInit, and IPersistStorage, in that order)
 * and if any of them is supported, returns the result of that interface's
 * IsDirty method.
 *--------------------------------------------------------------------------*/

HRESULT CMTSnapInNode::IsIUnknownDirty(IUnknown* pUnk)
{
    ASSERT(pUnk != NULL);
    if (pUnk == NULL)
        return E_POINTER;

    // 1. Check for IPersistStream
    IPersistStreamPtr spIPS = pUnk;
    if (spIPS != NULL)
        return spIPS->IsDirty();

    // 2. Check for IPersistStreamInit
    IPersistStreamInitPtr spIPSI = pUnk;
    if (spIPSI != NULL)
        return spIPSI->IsDirty();

    // 3. Check for IPersistStorage
    IPersistStoragePtr spIPStg = pUnk;
    if (spIPStg != NULL)
        return spIPStg->IsDirty();

    return S_FALSE;
}

// local functions
inline long LongScanBytes (long bits)
{
    bits += 31;
    bits /= 8;
    bits &= ~3;
    return bits;
}

SC ScLoadBitmap (CStream &stream, HBITMAP* pBitmap)
{
    DECLARE_SC(sc, TEXT("ScLoadBitmap"));

    // parameter check
    sc = ScCheckPointers(pBitmap);
    if (sc)
        return sc;

	/*
	 * The bitmap we're going to CreateDIBitmap into should be empty.
	 * If it's not, it may indicate a bitmap leak.  If you've investigated
	 * an instance where this assert fails and determined that *pBitmap
	 * isn't being leaked (be very sure!), set *pBitmap to NULL before
	 * calling ScLoadBitmap.  DO NOT remove this assert because you
	 * think it's hyperactive.
	 */
	ASSERT (*pBitmap == NULL);

    // initialization
    *pBitmap = NULL;

    DWORD dwSize;
    sc = stream.ScRead(&dwSize, sizeof(DWORD));
    if(sc)
        return sc;

    CAutoArrayPtr<BYTE> spDib(new BYTE[dwSize]);
    sc = ScCheckPointers(spDib, E_OUTOFMEMORY);
    if (sc)
        return sc;

    // have a typed pointer for member access
    typedef const BITMAPINFOHEADER * const LPCBITMAPINFOHEADER;
    LPCBITMAPINFOHEADER pDib = reinterpret_cast<LPCBITMAPINFOHEADER>(&spDib[0]);

    sc = stream.ScRead(spDib, dwSize);
    if(sc)
        return sc;

    BYTE * bits = (BYTE*) (pDib+1);
    int depth = pDib->biBitCount*pDib->biPlanes;
    if (depth <= 8)
        bits += (1<<depth)*sizeof(RGBQUAD);

    // get a screen dc
    WTL::CClientDC dc(NULL);
    if (dc == NULL)
        return sc.FromLastError(), sc;

    HBITMAP hbitmap = CreateDIBitmap (dc, pDib, CBM_INIT, bits, (BITMAPINFO*)pDib, DIB_RGB_COLORS);
    if (hbitmap == NULL)
        return sc.FromLastError(), sc;

    // return the bitmap
    *pBitmap = hbitmap;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * PersistBitmap
 *
 * PURPOSE:  Saves Bitmap to / loads from XML doc.
 *
 * PARAMETERS:
 *    CPersistor &persistor :
 *    LPCTSTR   name : name attribute of instance in XML
 *    HBITMAP   hBitmap :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void PersistBitmap(CPersistor &persistor, LPCTSTR name, HBITMAP& hBitmap)
{
    DECLARE_SC(sc, TEXT("PersistBitmap"));

    // combined from ScSaveBitmap & ScLoadBitmap

    // get a screen dc
    WTL::CClientDC dc(NULL);
    if (dc == NULL)
        sc.FromLastError(), sc.Throw();

    CXMLAutoBinary binBlock;


    if (persistor.IsStoring())
    {
        // check pointers
        sc = ScCheckPointers(hBitmap);
        if (sc)
            sc.Throw();

        // create memory dc
        WTL::CDC memdc;
        memdc.CreateCompatibleDC(dc);
        if (memdc == NULL)
            sc.FromLastError(), sc.Throw();

        // get bitmap info
        BITMAP bm;
        if (0 == GetObject (hBitmap, sizeof(BITMAP), (LPSTR)&bm))
            sc.FromLastError(), sc.Throw();

        // TODO:  lousy palette stuff

        int depth;
        switch(bm.bmPlanes*bm.bmBitsPixel)
        {
        case 1:
            depth = 1;
            break;
        case 2:
        case 3:
        case 4:
            depth = 4;
            break;
        case 5:
        case 6:
        case 7:
        case 8:
            depth = 8;
            break;
        default:
            depth = 24;
            break;
        }

        DWORD dwSize = sizeof(BITMAPINFOHEADER) + bm.bmHeight*LongScanBytes(depth*bm.bmWidth);
        DWORD colors = 0;
        if(depth  <= 8)
        {
            colors  = 1<<depth;
            dwSize += colors*sizeof(RGBQUAD);
        }

        sc = binBlock.ScAlloc(dwSize);
        if (sc)
            sc.Throw();

        CXMLBinaryLock sLock(binBlock); // will unlock in destructor

        BITMAPINFOHEADER* dib = NULL;
        sc = sLock.ScLock(&dib);
        if (sc)
            sc.Throw();

        sc = ScCheckPointers(dib, E_UNEXPECTED);
        if (sc)
            sc.Throw();

        BYTE * bits = colors*sizeof(RGBQUAD) + (BYTE *)&dib[1];

        dib->biSize          = sizeof(BITMAPINFOHEADER);
        dib->biWidth         = bm.bmWidth;
        dib->biHeight        = bm.bmHeight;
        dib->biPlanes        = 1;
        dib->biBitCount      = (WORD)depth;
        dib->biCompression   = 0;
        dib->biSizeImage     = dwSize; // includes palette and bih ??
        dib->biXPelsPerMeter = 0;
        dib->biYPelsPerMeter = 0;
        dib->biClrUsed       = colors;
        dib->biClrImportant  = colors;

        HBITMAP hold = memdc.SelectBitmap (hBitmap);
        if (hold == NULL)
            sc.FromLastError(), sc.Throw();

        int lines = GetDIBits (memdc, hBitmap, 0, bm.bmHeight, (LPVOID)bits, (BITMAPINFO*)dib, DIB_RGB_COLORS);
        // see if we were successful
        if (!lines)
            sc.FromLastError();
        else if(lines != bm.bmHeight)
            sc = E_UNEXPECTED; // should not happen

        // clean up gdi resources.
        memdc.SelectBitmap(hold);

        if(sc)
            sc.Throw();
    }

    persistor.Persist(binBlock, name);

    if (persistor.IsLoading())
    {
		/*
		 * The bitmap we're going to CreateDIBitmap into should be empty.
		 * If it's not, it may indicate a bitmap leak.  If you've investigated
		 * an instance where this assert fails and determined that hBitmap
		 * isn't being leaked (be very sure!), set hBitmap to NULL before
		 * calling PersistBitmap.  DO NOT remove this assert because you
		 * think it's hyperactive.
		 */
		ASSERT (hBitmap == NULL);
        hBitmap = NULL;

        CXMLBinaryLock sLock(binBlock); // will unlock in destructor

        BITMAPINFOHEADER* dib = NULL;
        sc = sLock.ScLock(&dib);
        if (sc)
            sc.Throw();

        sc = ScCheckPointers(dib, E_UNEXPECTED);
        if (sc)
            sc.Throw();

        BYTE * bits = (BYTE *)&dib[1];
        int depth = dib->biBitCount*dib->biPlanes;
        if (depth <= 8)
            bits += (1<<depth)*sizeof(RGBQUAD);

        HBITMAP hbitmap = CreateDIBitmap (dc,
                                          dib, CBM_INIT,
                                          bits,
                                          (BITMAPINFO*)dib,
                                          DIB_RGB_COLORS);

        if (hbitmap == NULL)
            sc.FromLastError(), sc.Throw();

        hBitmap = hbitmap;
    }
}


/*+-------------------------------------------------------------------------*
 *
 * CMTSnapInNode::Persist
 *
 * PURPOSE:  Persist snapin node
 *
 * PARAMETERS:
 *    CPersistor &persistor :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CMTSnapInNode::Persist(CPersistor& persistor)
{
    DECLARE_SC(sc, TEXT("CMTSnapInNode::Persist"));

    // save the base class.
    CMTNode::Persist(persistor);

    CLSID clsid;
    ZeroMemory(&clsid,sizeof(clsid));

    if (persistor.IsLoading())
    {
        // check if bitmaps are here
        m_bHasBitmaps = persistor.HasElement(XML_TAG_NODE_BITMAPS, NULL);

        /*
         * load persisted properties, if present
         */
        if (persistor.HasElement (CSnapinProperties::_GetXMLType(), NULL))
        {
            /*
             * create a properties object, since we don't have one yet
             */
            ASSERT (m_spProps == NULL);
            CSnapinProperties* pSIProps = NULL;
            sc = ScCreateSnapinProperties (&pSIProps);
            if (sc)
                sc.Throw();

            if (pSIProps == NULL)
                (sc = E_UNEXPECTED).Throw();

            /*
             * load the properties
             */
            persistor.Persist (*pSIProps);
        }
    }
    else
    {
        clsid = GetPrimarySnapInCLSID();

        /*
         * persist properties, if present
         */
        if (m_spProps != NULL)
        {
            CSnapinProperties* pSIProps = CSnapinProperties::FromInterface(m_spProps);

            if (pSIProps != NULL)
                persistor.Persist (*pSIProps);
        }
    }

    persistor.PersistAttribute(XML_ATTR_MT_NODE_SNAPIN_CLSID, clsid);

    if (m_bHasBitmaps)
    {
        CPersistor persistorBitmaps(persistor, XML_TAG_NODE_BITMAPS);

		/*
		 * Early versions of XML persistence saved device-dependent
		 * bitmaps.  If there's a BinaryData element named "SmallOpen",
		 * this is a console saved by early XML persistence -- read it
		 * in a special manner.
		 */
		if (persistor.IsLoading() &&
			persistorBitmaps.HasElement (XML_TAG_VALUE_BIN_DATA,
										 XML_NAME_NODE_BITMAP_SMALL_OPEN))
		{
			WTL::CBitmap bmpSmall, bmpSmallOpen, bmpLarge;
			std::wstring strMask;

			PersistBitmap(persistorBitmaps, XML_NAME_NODE_BITMAP_SMALL,      bmpSmall.m_hBitmap);
			PersistBitmap(persistorBitmaps, XML_NAME_NODE_BITMAP_SMALL_OPEN, bmpSmallOpen.m_hBitmap);
			PersistBitmap(persistorBitmaps, XML_NAME_NODE_BITMAP_LARGE,      bmpLarge.m_hBitmap);
			persistorBitmaps.PersistAttribute(XML_ATTR_NODE_BITMAPS_MASK, strMask);

			COLORREF crMask = wcstoul(strMask.c_str(), NULL, 16);
			sc = ScHandleCustomImages (bmpSmall, bmpSmallOpen, bmpLarge, crMask);
			if (sc)
				sc.Throw();
		}

		/*
		 * We either writing or reading a modern XML file that has persisted
		 * the images in device-independent imagelist.  Read/write them that way.
		 */
		else
		{
			persistorBitmaps.Persist (m_imlSmall, XML_NAME_NODE_BITMAP_SMALL);
			persistorBitmaps.Persist (m_imlLarge, XML_NAME_NODE_BITMAP_LARGE);

			if (persistor.IsLoading())
			{
				sc = ScAddImagesToImageList();
				if (sc)
					sc.Throw();
			}
		}
    }

    // setup snapins CD
	if (persistor.IsLoading())
	{
        CSnapInsCache* const pCache = theApp.GetSnapInsCache();
        if (pCache == NULL)
            sc.Throw(E_FAIL);

        CSnapInPtr spSI;
        sc = pCache->ScGetSnapIn(clsid, &spSI);
        if (sc)
            sc.Throw();
        if (spSI != NULL)
            SetPrimarySnapIn(spSI);
        else
            sc.Throw(E_UNEXPECTED);
        pCache->SetDirty(FALSE);
    }

    // when storing, ask snapins to save their data first
    if ( persistor.IsStoring() )
    {
        sc = ScSaveIComponentDatas();
        if (sc)
            sc.Throw();

        sc = ScSaveIComponents();
        if (sc)
            sc.Throw();
    }

    persistor.Persist(m_CDPersistor);
    persistor.Persist(m_ComponentPersistor);

	/*
	 * Save/load the preload bit.  Do this last to avoid busting old .msc files.
	 */
	BOOL bPreload = false;
    if (persistor.IsStoring() && IsInitialized())
		bPreload = IsPreloadRequired ();

    persistor.PersistAttribute(XML_ATTR_MT_NODE_PRELOAD, CXMLBoolean(bPreload));

    if (persistor.IsLoading())
		SetPreloadRequired (bPreload);
}


/*+-------------------------------------------------------------------------*
 * CMTSnapInNode::ScAddImagesToImageList
 *
 * Adds the small and small(open) bitmaps for the snap-in to the scope
 * tree's imagelist.
 *--------------------------------------------------------------------------*/

SC CMTSnapInNode::ScAddImagesToImageList()
{
	DECLARE_SC (sc, _T("CMTSnapInNode::ScAddImagesToImageList"));

	/*
	 * get the scope tree's imagelist
	 */
	CScopeTree* pScopeTree = CScopeTree::GetScopeTree();
	sc = ScCheckPointers (pScopeTree, E_UNEXPECTED);
	if (sc)
		return (sc);

	WTL::CImageList imlScopeTree = pScopeTree->GetImageList();
	if (imlScopeTree.IsNull())
		return (sc = E_UNEXPECTED);

	/*
	 * add images to scope tree's imagelist, first closed...
	 */
	CSmartIcon icon;
	icon.Attach (m_imlSmall.GetIcon (0));
	if (icon == NULL)
		return (sc.FromLastError());

    SetImage (imlScopeTree.AddIcon (icon));

	/*
	 * ...then open
	 */
	icon.Attach (m_imlSmall.GetIcon (1));
	if (icon == NULL)
		return (sc.FromLastError());

    SetOpenImage (imlScopeTree.AddIcon (icon));

	return (sc);
}


CComponent* CMTSnapInNode::GetComponent(UINT nViewID, COMPONENTID nID,
                                        CSnapIn* pSnapIn)
{
    CNodeList& nodes = GetNodeList();
    POSITION pos = nodes.GetHeadPosition();
    CNode* pNode = NULL;

    while (pos)
    {
        pNode = nodes.GetNext(pos);
        if (pNode != NULL && pNode->GetViewID() == (int)nViewID)
            break;
    }

    if(pNode == NULL)
        return NULL;

    ASSERT(pNode != NULL);
    ASSERT(pNode->GetViewID() == (int)nViewID);

    if (pNode->GetViewID() != (int)nViewID)
        return NULL;

    CSnapInNode* pSINode = dynamic_cast<CSnapInNode*>(pNode);
    CComponent* pCC = pSINode->GetComponent(nID);

    if (pCC == NULL)
        pCC = pSINode->CreateComponent(pSnapIn, nID);

    return pCC;
}

CNode* CMTSnapInNode::GetNode(CViewData* pViewData, BOOL fRootNode)
{
    /*
     * check for another CSnapInNode that already exists in this view
     */
    CSnapInNode* pExistingNode = FindNode (pViewData->GetViewID());
    CSnapInNode* pNewNode;

    /*
     * if this is the first CSnapInNode for this view, create a unique one
     */
    if (fRootNode || (pExistingNode == NULL))
        pNewNode = new CSnapInNode (this, pViewData, fRootNode);

    /*
     * otherwise, copy the node that's here
     */
    else
        pNewNode = new CSnapInNode (*pExistingNode);

    return (pNewNode);
}


/***************************************************************************\
 *
 * METHOD:  CMTSnapInNode::Reset
 *
 * PURPOSE: Resets the node in order to reload extensions. basically it forces
 *          save-load-init sequence to refresh the snapin node
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void CMTSnapInNode::Reset()
{
    DECLARE_SC(sc, TEXT("CMTSnapInNode::Reset"));

    CSnapIn * pSnapIn = GetPrimarySnapIn();
    ASSERT(pSnapIn != NULL);

    // we will perform resetting of components and component datas
    // by storing / loading them "the XML way"
    // following that there is nothing what makes this node different
    // from one loaded from XML, so we will change it's type

    sc = ScSaveIComponentDatas();
    if (sc)
        sc.TraceAndClear(); // continue even on error

    sc = ScSaveIComponents();
    if (sc)
        sc.TraceAndClear(); // continue even on error

    // need to reset component XML streams/storage
    sc = m_CDPersistor.ScReset();
    if (sc)
        sc.TraceAndClear(); // continue even on error

    sc = m_ComponentPersistor.ScReset();
    if (sc)
        sc.TraceAndClear(); // continue even on error

    // First Reset all the nodes
    POSITION pos = m_NodeList.GetHeadPosition();
    while (pos)
    {
        CSnapInNode* pSINode =
            dynamic_cast<CSnapInNode*>(m_NodeList.GetNext(pos));
        ASSERT(pSINode != NULL);

        pSINode->Reset();
    }

    for (int i=0; i < m_ComponentDataArray.size(); i++)
        delete m_ComponentDataArray[i];

    m_ComponentDataArray.clear();

    CMTNode::Reset();

    ResetExpandedAtLeastOnce();

    SetPrimarySnapIn(pSnapIn);

    pos = m_NodeList.GetHeadPosition();
    while (pos)
    {
        CSnapInNode* pSINode =
            dynamic_cast<CSnapInNode*>(m_NodeList.GetNext(pos));
        ASSERT(pSINode != NULL);

        CComponent* pCC = new CComponent(pSnapIn);
        pCC->SetComponentID(GetPrimaryComponentID());
        pSINode->AddComponentToArray(pCC);

        pSINode->SetPrimaryComponent(pCC);
    }

    Init();

    pos = m_NodeList.GetHeadPosition();
    while (pos)
    {
        CSnapInNode* pSINode =
            dynamic_cast<CSnapInNode*>(m_NodeList.GetNext(pos));
        ASSERT(pSINode != NULL);
        pSINode->InitComponents();
    }
}



/*+-------------------------------------------------------------------------*
 * class CLegacyNodeConverter
 *
 *
 * PURPOSE: Used to emulate the legacy node snapins' Save routines.
 *
 *+-------------------------------------------------------------------------*/
class CLegacyNodeConverter : public CSerialObjectRW
{

public:
    CLegacyNodeConverter(LPCTSTR szName, LPCTSTR szView)
    : m_strName(szName), m_strView(szView)
    {
    }

    ~CLegacyNodeConverter()
    {
        // must call detach or the strings will be removed from the string table.
        m_strName.Detach();
        m_strView.Detach();
    }



public:
    // CSerialObject methods
    virtual UINT    GetVersion()     {return 1;}
    virtual HRESULT ReadSerialObject (IStream &stm, UINT nVersion) {ASSERT(0 && "Should not come here."); return E_UNEXPECTED;}
    virtual HRESULT WriteSerialObject(IStream &stm);

private: // attributes - persisted
    CStringTableString  m_strName;  // the name of the root node, which is the only node created by the snapin
    CStringTableString  m_strView;  // the view displayed by the node.
};


/*+-------------------------------------------------------------------------*
 *
 * CLegacyNodeConverter::WriteSerialObject
 *
 * PURPOSE: Writes out the name and view strings using the format expected
 *          by the built in snapins.
 *
 * PARAMETERS:
 *    IStream & stm :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CLegacyNodeConverter::WriteSerialObject(IStream &stm)
{
    stm << m_strName;
    stm << m_strView;

    return S_OK;
}

/*+-------------------------------------------------------------------------*
 *
 * CMTSnapInNode::ScConvertLegacyNode
 *
 * PURPOSE: Reads in an legacy node and converts it to a built-in snapin node.
 *          1) The original tree stream is read and the target URL or OCX is read.
 *          2) The new Data stream with the munged CLSID name is created
 *             and the data required by the snapin is placed there. Because
 *             the bitmap etc is already loaded, and because the original
 *             stream is thrown away, we don't need to emulate the "tree"
 *             stream. Also, because this snapin has no view specific information,
 *             the views storage is not used.
 *
 * PARAMETERS: clsid: The CLSID of the built in snapin.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CMTSnapInNode::ScConvertLegacyNode(const CLSID &clsid)
{
    USES_CONVERSION;
    SC              sc;
    std::wstring    strView;
    CStream         stream;
    CStream         nodeStream = NULL;
    int             iStorageOrStream=0;
    IStreamPtr      spCDStream;

    bool bIsHTMLNode = (&clsid == &CLSID_HTMLSnapin);
    bool bIsOCXNode  = (&clsid == &CLSID_OCXSnapin);

    // 1. load the base class
    sc = CMTNode::ScLoad();
    if(sc)
        goto Error;

    // get the tree stream.
    stream.Attach(GetTreeStream());

    // 2. read the URL or OCX string as needed.
    if(bIsHTMLNode)
    {
        WCHAR* szView = NULL;

        // get the string length of the label, and read the string.
        unsigned int stringLength;
        sc = stream.ScRead(&stringLength, sizeof(stringLength));
        if(sc)
            goto Error;

        szView = reinterpret_cast<wchar_t*>(alloca((stringLength+1)*sizeof(WCHAR))); // allocates on stack, don't free.
        if (szView == NULL)
            goto PointerError;

        sc = stream.ScRead(szView, stringLength*2);
        if(sc)
            goto Error;

        szView[stringLength] = TEXT('\0'); // null terminate the string.

        strView = szView;
    }
    else if(bIsOCXNode)
    {
        CLSID clsidOCX;

        // Read OCX clsid
        sc = stream.ScRead(&clsidOCX, sizeof(clsidOCX));
        if(sc)
            goto Error;

        {
            WCHAR   szCLSID[40];
            if (0 == StringFromGUID2 (clsidOCX, szCLSID, countof(szCLSID)))
            {
                sc = E_UNEXPECTED;
                goto Error;
            }

            strView = szCLSID;
        }
    }

    // at this point, strView contains either the URL or OCX CLSID.



    // 3. Write node name
    sc = m_CDPersistor.ScGetIStream( clsid, &spCDStream );
    if (sc)
        goto Error;

    nodeStream.Attach( spCDStream );
    if(NULL == nodeStream.Get())
        goto PointerError;

    // 4. Write out the Data stream.
    {
		tstring strName = GetDisplayName();
        CLegacyNodeConverter converter(strName.data(), OLE2CT(strView.data()));

        // call the converter to write out the stream.
        sc = converter.Write(nodeStream);
        if(sc)
            goto Error;
    }

    // at this point, the "data" stream  should be correctly written out.

    // 5. For OCX nodes, convert the view streams and storages
    /*      OLD                                             NEW
            2 (node storage)                                2 (node storage)
                data                                            data
                tree                                            tree
                view                                            view
                    1  <--- streams and storages   ---------        1
                    2  <--- written by OCX, 1 per view --   \           1jvmv2n4y1k471h9ujk86lite7 (OCX snap-in)
                                                         \   -------->      ocx_stream (or ocx_storage)
                                                          \
                                                           ------>  2   1jvmv2n4y1k471h9ujk86lite7 (OCX snap-in)
                                                                            ocx_stream (or ocx_storage)


    */
    if(bIsOCXNode)
    {
        for(iStorageOrStream = 1 /*NOT zero*/; ; iStorageOrStream++)
        {
            // create the name of the storage
            CStr strStorageOrStream;
            strStorageOrStream.Format(TEXT("%d"), iStorageOrStream);

            // at this point strStorageOrStream should contain a number like "1"
            CStorage storageView(GetViewStorage());

            // rename the storage or stream labelled "1" to "temp" under the same parent.
            sc = storageView.ScMoveElementTo(T2COLE(strStorageOrStream), storageView, L"temp", STGMOVE_MOVE);
            if(sc == SC(STG_E_FILENOTFOUND))    // loop end condition - no more streams or storages
            {
                sc.Clear();
                break;
            }

            if(sc)
                goto Error;

            // now we create the storage with the same name, eg "1"
            {
                WCHAR name[MAX_PATH];
                GetComponentStorageName(name, clsid); // the name of the snapin component

                CStorage storageNewView, storageSnapIn;
                sc = storageNewView.ScCreate(storageView, T2COLE(strStorageOrStream),
                                          STGM_WRITE|STGM_SHARE_EXCLUSIVE|STGM_CREATE,
                                          L"\\node\\#\\view\\#\\storage" /*CHANGE*/);
                if(sc)
                    goto Error;

                // create the snapin's storage underneath the view's storage
                sc = storageSnapIn.ScCreate(storageNewView, name,
                                            STGM_WRITE|STGM_SHARE_EXCLUSIVE|STGM_CREATE,
                                            L"\\node\\#\\view\\#\\storage\\#\\snapinStorage");
                if(sc)
                    goto Error;

                // move the "temp" stream or storage to the storage called L"ocx_streamorstorage"
                // (which is what the OCX snapin expects.)

                sc = storageView.ScMoveElementTo(L"temp", storageSnapIn, L"ocx_streamorstorage", STGMOVE_MOVE);
                if(sc)
                    goto Error;
            }

        }
    }


    // 6. now do the same thing that CMTSnapInNode::ScLoad would do.
    {
        CSnapInsCache* const pCache = theApp.GetSnapInsCache();
        ASSERT(pCache != NULL);
        if (pCache == NULL)
            goto FailedError;

        CSnapInPtr spSI;
        sc = pCache->ScGetSnapIn(clsid, &spSI);
        ASSERT(!sc.IsError() && spSI != NULL);

        if (!sc.IsError() && spSI != NULL)
            SetPrimarySnapIn(spSI);

        pCache->SetDirty(FALSE);

        if(sc)
            goto Error;
    }

    // always set the preload bit.
    SetPreloadRequired (true);

    // Some actions (loading bitmaps for example) performed here invalidate the node
    // and set the dirty flag. Since coverting legacy node may be done any time again
    // the converted node should not be assumed as changed.
    ClearDirty();

    // read all the streams and storages for this node
    sc = ScReadStreamsAndStoragesFromConsole();
	if(sc)
		goto Error;

Cleanup:
    return sc;

FailedError:
    sc = E_FAIL;
    goto Error;
PointerError:
    sc = E_POINTER;
Error:
    TraceError(TEXT("CMTSnapInNode::ScConvertLegacyNode"), sc);
    goto Cleanup;
}

HRESULT copyStream(IStream* dest, IStream* src)
{
    ASSERT(dest != NULL);
    ASSERT(src != NULL);
    if (dest == NULL || src == NULL)
        return E_POINTER;

    const LARGE_INTEGER loc = {0,0};
    ULARGE_INTEGER newLoc;
    HRESULT hr = src->Seek(loc, STREAM_SEEK_SET, &newLoc);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return E_FAIL;

    hr = dest->Seek(loc, STREAM_SEEK_SET, &newLoc);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return E_FAIL;

    const ULARGE_INTEGER size = {0,0};
    hr = dest->SetSize(size);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;

    STATSTG statstg;
    hr = src->Stat(&statstg, STATFLAG_NONAME);
    ASSERT(hr == S_OK);
    if (hr != S_OK)
        return E_FAIL;

    ULARGE_INTEGER cr;
    ULARGE_INTEGER cw;
    hr = src->CopyTo(dest, statstg.cbSize, &cr, &cw);
#if 0 // for debugging...
    for (long i = 0; true; i++)
    {
        BYTE b;
        long bytesRead;
        hr = src->Read(&b, sizeof(b), &bytesRead);
        if (hr != S_OK)
            return S_OK;
        long bytesWritten;
        hr = dest->Write(&b, bytesRead, &bytesWritten);
        ASSERT(hr == S_OK);
        ASSERT(bytesWritten == bytesRead);
        if (hr != S_OK || bytesWritten != bytesRead)
            return E_FAIL;
    }
#endif
    return S_OK;
}

//############################################################################
//############################################################################
//
//  Helper functions
//
//############################################################################
//############################################################################

void    DisplayPolicyErrorMessage(const CLSID& clsid, bool bExtension)
{
    CStr strMessage;

    if (bExtension)
        strMessage.LoadString(GetStringModule(), IDS_EXTENSION_NOTALLOWED);
    else
        strMessage.LoadString(GetStringModule(), IDS_SNAPIN_NOTALLOWED);

    // Get the snapin name for the error message.
    CSnapInsCache* pSnapInsCache = theApp.GetSnapInsCache();
    ASSERT(pSnapInsCache != NULL);
    CSnapInPtr spSnapIn;

    SC sc = pSnapInsCache->ScFindSnapIn(clsid, &spSnapIn);
    if (!sc.IsError() && (NULL != spSnapIn))
    {
		WTL::CString strName;
		sc = spSnapIn->ScGetSnapInName (strName);

		if (!sc.IsError())
		{
			strMessage += _T("\n");
			strMessage += strName;
			strMessage += _T(".");
		}
    }

    ::MessageBox(NULL, strMessage, _T("MMC"), MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL);
}

/***************************************************************************\
 *
 * METHOD:  CMMCSnapIn::get_Vendor
 *
 * PURPOSE: returns vendor info for snapin. Implements OM property SnapIn.Vendor
 *
 * PARAMETERS:
 *    PBSTR pbstrVendor [out] - vendor info
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
STDMETHODIMP CMMCSnapIn::get_Vendor( PBSTR pbstrVendor )
{
    DECLARE_SC(sc, TEXT("CMMCSnapIn::get_Vendor"));

    sc = ScCheckPointers(pbstrVendor);
    if (sc)
        return sc.ToHr();

    // init out parameter
    *pbstrVendor = NULL;

    // get the snapin about
    CSnapinAbout *pSnapinAbout = NULL;
    sc = ScGetSnapinAbout(pSnapinAbout);
    if (sc)
        return sc.ToHr();

    // recheck the pointer
    sc = ScCheckPointers(pSnapinAbout, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    *pbstrVendor = ::SysAllocString( pSnapinAbout->GetCompanyName() );

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CMMCSnapIn::get_Version
 *
 * PURPOSE: returns version info for snapin. Implements OM property SnapIn.Version
 *
 * PARAMETERS:
 *    PBSTR pbstrVersion [out] - version info
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
STDMETHODIMP CMMCSnapIn::get_Version( PBSTR pbstrVersion )
{
    DECLARE_SC(sc, TEXT("CMMCSnapIn::get_Version"));

    sc = ScCheckPointers(pbstrVersion);
    if (sc)
        return sc.ToHr();

    // init out parameter
    *pbstrVersion = NULL;

    // get the snapin about
    CSnapinAbout *pSnapinAbout = NULL;
    sc = ScGetSnapinAbout(pSnapinAbout);
    if (sc)
        return sc.ToHr();

    // recheck the pointer
    sc = ScCheckPointers(pSnapinAbout, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    *pbstrVersion = ::SysAllocString( pSnapinAbout->GetVersion() );

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CMMCSnapIn::GetMTSnapInNode
 *
 * PURPOSE: helper. returns mtnode for the snapin
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    CMTSnapInNode *    - node
 *
\***************************************************************************/
CMTSnapInNode * CMMCSnapIn::GetMTSnapInNode()
{
    CMTSnapInNode *pMTSnapInNode = NULL;
    SC sc = ScGetTiedObject(pMTSnapInNode);
    if (sc)
        return NULL;

    return pMTSnapInNode;
}

/***************************************************************************\
 *
 * METHOD:  CMMCSnapIn::ScGetSnapinAbout
 *
 * PURPOSE: helper. returns snapins about object
 *
 * PARAMETERS:
 *    CSnapinAbout*& pAbout [out] - snapins about object
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCSnapIn::ScGetSnapinAbout(CSnapinAbout*& pAbout)
{
    DECLARE_SC(sc, TEXT("CMMCSnapIn::ScGetSnapinAbout"));

    // init out param
    pAbout = NULL;

    // If the snapin object is already created just return it.
    if (NULL != (pAbout = m_spSnapinAbout.get()))
        return sc;

    // get snapins clsid
    CLSID clsidSnapin = GUID_NULL;
    sc = GetSnapinClsid(clsidSnapin);
    if (sc)
        return sc;

    CLSID clsidAbout; // get the about class-id.
    sc = ScGetAboutFromSnapinCLSID(clsidSnapin, clsidAbout);
    if (sc)
        return sc;

    if (clsidSnapin == GUID_NULL)
        return sc = E_FAIL;

    // Create about object
    m_spSnapinAbout = SnapinAboutPtr (new CSnapinAbout);
    if (! m_spSnapinAbout.get())
        return sc = E_OUTOFMEMORY;

    // and initialize it.
    if (!m_spSnapinAbout->GetSnapinInformation(clsidAbout))
        return sc = E_FAIL;

    pAbout = m_spSnapinAbout.get();

    return sc;
}


/*+-------------------------------------------------------------------------*
 * CMTSnapInNode::IsPreloadRequired
 *
 * Returns true if the snap-in wants MMCN_PRELOAD notifications, false
 * otherwise.
 *--------------------------------------------------------------------------*/

BOOL CMTSnapInNode::IsPreloadRequired () const
{
	DECLARE_SC (sc, _T("CMTSnapInNode::IsPreloadRequired"));

	/*
	 * if we don't know whether the snap-in wants MMCN_PRELOAD (because
	 * we haven't asked it yet), ask now
	 */
	if (m_ePreloadState == ePreload_Unknown)
	{
		/*
		 * assume preload isn't required
		 */
		m_ePreloadState = ePreload_False;

		sc = ScQueryPreloadRequired (m_ePreloadState);
		if (sc)
			sc.TraceAndClear();
	}

	return (m_ePreloadState == ePreload_True);
}


/*+-------------------------------------------------------------------------*
 * CMTSnapInNode::ScQueryPreloadRequired
 *
 * Asks the snap-in whether it requires preload notification by asking its
 * data object for the CCF_SNAPIN_PRELOADS format.
 *
 * Returns in ePreload:
 *
 * 		ePreload_True	snap-in requires MMCN_PRELOAD
 * 		ePreload_False	snap-in doesn't require MMCN_PRELOAD
 *
 * If anything fails during the process of asking the snap-in for
 * CCF_SNAPIN_PRELOADS, the value of ePreload is unchanged.
 *--------------------------------------------------------------------------*/

SC CMTSnapInNode::ScQueryPreloadRequired (
	PreloadState&	ePreload) const		/* O:preload state for snap-in		*/
{
	DECLARE_SC (sc, _T("CMTSnapInNode::ScQueryPreloadRequired"));

	/*
	 * make sure we have a primary ComponentData
	 */
    CComponentData* pCCD = GetPrimaryComponentData();
	sc = ScCheckPointers (pCCD, E_UNEXPECTED);
	if (sc)
		return (sc);

	/*
	 * get the data object for this node
	 */
	IDataObjectPtr spDataObject;
	sc = pCCD->QueryDataObject(GetUserParam(), CCT_SCOPE, &spDataObject);
	if (sc)
		return (sc);

	sc = ScCheckPointers (spDataObject, E_UNEXPECTED);
	if (sc)
		return (sc);

	/*
	 * CCF_SNAPIN_PRELOADS is an optional clipboard format, so it's not
	 * an error if ExtractData fails.
	 */
	BOOL bPreload = (ePreload == ePreload_True) ? TRUE : FALSE;
	if (SUCCEEDED (ExtractData (spDataObject, GetPreLoadFormat(),
								(BYTE*)&bPreload, sizeof(BOOL))))
	{
		ePreload = (bPreload) ? ePreload_True : ePreload_False;
	}

	return (sc);
}

/***************************************************************************\
 *
 * METHOD:  CMTSnapInNode::ScReadStreamsAndStoragesFromConsole
 *
 * PURPOSE: Enumerates old (structured storage based) console.
 *          Enumerates the streams and storages under the snapin node.
 *          For each stream/storage found adds a copy to m_CDPpersistor
 *          or m_ComponentPersistor, indexed by a hash value (name in storage).
 *          These entries will be recognized and stored by a CLSID when
 *          CLSID is known ( when request by CLSID is made )
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMTSnapInNode::ScReadStreamsAndStoragesFromConsole()
{
    DECLARE_SC(sc, TEXT("CMTSnapInNode::ScReadStreamsAndStoragesFromConsole"));

    IStorage* pNodeCDStorage = GetStorageForCD();
    sc = ScCheckPointers( pNodeCDStorage, E_POINTER );
    if (sc)
        return sc;

    IEnumSTATSTGPtr spEnum;
    sc = pNodeCDStorage->EnumElements( 0, NULL, 0, &spEnum );
    if (sc)
        return sc;

    // recheck pointer
    sc = ScCheckPointers( spEnum, E_POINTER );
    if (sc)
        return sc;

    // reset enumeration
    sc = spEnum->Reset();
    if (sc)
        return sc;

    // enumerate the items ( each entry is for separate component data )
    while (1)
    {
        STATSTG statstg;
        ZeroMemory( &statstg, sizeof(statstg) );

        ULONG cbFetched = 0;
        sc = spEnum->Next( 1, &statstg, &cbFetched );
        if (sc)
            return sc;

        if ( sc != S_OK ) // - done
        {
            sc.Clear();
            break;
        }

        // attach to the out param
        CCoTaskMemPtr<WCHAR> spName( statstg.pwcsName );

        // make a copy of streams and storages
        if ( statstg.type == STGTY_STREAM )
        {
            IStreamPtr spStream;
            sc = OpenDebugStream(pNodeCDStorage, spName, STGM_READ | STGM_SHARE_EXCLUSIVE,
                                 L"\\node\\#\\data\\clsid", &spStream);
            if (sc)
                return sc;

            sc = m_CDPersistor.ScInitIStream( spName, spStream );
            if (sc)
                return sc;
        }
        else if ( statstg.type == STGTY_STORAGE )
        {
            IStoragePtr spStorage;
            sc = OpenDebugStorage(pNodeCDStorage, spName, STGM_READ | STGM_SHARE_EXCLUSIVE,
                                  L"\\node\\#\\data\\clsid", &spStorage);
            if (sc)
                return sc;

            sc = m_CDPersistor.ScInitIStorage( spName, spStorage );
            if (sc)
                return sc;
        }
    }

    // view streams/storages
    IStorage *pNodeComponentStorage = GetViewStorage();
    sc = ScCheckPointers( pNodeComponentStorage, E_POINTER );
    if (sc)
        return sc;

    spEnum = NULL;
    sc = pNodeComponentStorage->EnumElements( 0, NULL, 0, &spEnum );
    if (sc)
        return sc;

    // recheck pointer
    sc = ScCheckPointers( spEnum, E_POINTER );
    if (sc)
        return sc;

    // reset enumeration
    sc = spEnum->Reset();
    if (sc)
        return sc;

    // enumerate the items ( each entry is for separate view )
    while (1)
    {
        STATSTG statstg;
        ZeroMemory( &statstg, sizeof(statstg) );

        ULONG cbFetched = 0;
        sc = spEnum->Next( 1, &statstg, &cbFetched );
        if (sc)
            return sc;

        if ( sc != S_OK ) //  done
        {
            sc.Clear();
            break;
        }

        // attach to the out param
        CCoTaskMemPtr<WCHAR> spName( statstg.pwcsName );

        // read the view storage
        if ( statstg.type == STGTY_STORAGE )
        {
            int idView = CMTNode::GetViewIdFromStorageName(spName);

            IStoragePtr spViewStorage;
            sc = OpenDebugStorage(pNodeComponentStorage, spName, STGM_READ | STGM_SHARE_EXCLUSIVE,
                                  L"\\node\\#\\view\\#", &spViewStorage);
            if (sc)
                return sc;

            // enumerate what's inside a view storage

            IEnumSTATSTGPtr spViewEnum;
            sc = spViewStorage->EnumElements( 0, NULL, 0, &spViewEnum );
            if (sc)
                return sc;

            // recheck pointer
            sc = ScCheckPointers( spViewEnum, E_POINTER );
            if (sc)
                return sc;

            // reset enumeration
            sc = spViewEnum->Reset();
            if (sc)
                return sc;

            // enumerate the items ( each entry is for separate component in a view )
            while (1)
            {
                STATSTG statstg;
                ZeroMemory( &statstg, sizeof(statstg) );

                ULONG cbFetched = 0;
                sc = spViewEnum->Next( 1, &statstg, &cbFetched );
                if (sc)
                    return sc;

                if ( sc != S_OK ) // - done
                {
                    sc.Clear();
                    break;
                }

                // attach to the out param
                CCoTaskMemPtr<WCHAR> spName( statstg.pwcsName );

                // make a copy of streams and storages
                if ( statstg.type == STGTY_STREAM )
                {
                    IStreamPtr spStream;
                    sc = OpenDebugStream(spViewStorage, spName, STGM_READ | STGM_SHARE_EXCLUSIVE,
                                         L"\\node\\#\\view\\#\\clsid", &spStream);
                    if (sc)
                        return sc;

                    sc = m_ComponentPersistor.ScInitIStream( idView, spName, spStream );
                    if (sc)
                        return sc;
                }
                else if ( statstg.type == STGTY_STORAGE )
                {
                    IStoragePtr spStorage;
                    sc = OpenDebugStorage(spViewStorage, spName, STGM_READ | STGM_SHARE_EXCLUSIVE,
                                          L"\\node\\#\\view\\#\\clsid", &spStorage);
                    if (sc)
                        return sc;

                    sc = m_ComponentPersistor.ScInitIStorage( idView, spName, spStorage );
                    if (sc)
                        return sc;
                }
            }
        }
    }

    // by now we should have loaded everything from the console file
    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMTSnapInNode::ScSaveIComponentDatas
 *
 * PURPOSE: Saves IComponentDatass for all snapins under this static scope node
 *
 * PARAMETERS:
 *
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMTSnapInNode::ScSaveIComponentDatas( )
{
    DECLARE_SC(sc, TEXT("CMTSnapInNode::ScSaveIComponentDatas"));

    // if node is not initialized ( not expanded ) - nothing to save
    // old data will be persisted.
    if ( !IsInitialized() )
        return sc;

    // go for every component data we have
    for( int i = 0; i< GetNumberOfComponentDatas(); i++ )
    {
        CComponentData* pCD = GetComponentData(i);
        sc = ScCheckPointers(pCD, E_UNEXPECTED);
        if (sc)
            return sc;

        sc = ScSaveIComponentData( pCD );
        if (sc)
            return sc;
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMTSnapInNode::ScSaveIComponentData
 *
 * PURPOSE: Determines snapin's IComponentData persistence capabilities (QI for IPersistXXXX)
 *          And asks it to save giving maintained stream/storage as a media.
 *
 * PARAMETERS:
 *    CComponentData* pCD   [in]  component data
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMTSnapInNode::ScSaveIComponentData( CComponentData* pCD )
{
    DECLARE_SC(sc, TEXT("CMTSnapInNode::ScSaveIComponentData"));

    sc = ScCheckPointers(pCD);
    if (sc)
        return sc;

    // check if the component is initialized
    if ( !pCD->IsIComponentDataInitialized() )
    {
        // compatibility with mmc1.2 - give another chance.
        sc = ScInitIComponentData(pCD);
        if (sc)
            return sc;
    }

    // Check first for an IComponentData
    IComponentData* const pICCD = pCD->GetIComponentData();
    sc = ScCheckPointers( pICCD, E_UNEXPECTED );
    if (sc)
        return sc;

    // Get the snapin name for the error message.
	CSnapInPtr spSnapin = pCD->GetSnapIn();

    // now ask the snapin to save the data
    sc = ScAskSnapinToSaveData( pICCD, &m_CDPersistor, CDPersistor::VIEW_ID_DOCUMENT, pCD->GetCLSID(), spSnapin );
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMTSnapInNode::ScSaveIComponents
 *
 * PURPOSE: Saves IComponents for all snapins under this static scope node
 *
 * PARAMETERS:
 *
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMTSnapInNode::ScSaveIComponents( )
{
    DECLARE_SC(sc, TEXT("CMTSnapInNode::ScSaveIComponents"));

    // if node is not initialized ( not expanded ) - nothing to save
    // old data will be persisted.
    if ( !IsInitialized() )
        return sc;

    // go for every CNode in every view
    CNodeList& nodes = GetNodeList();
    POSITION pos = nodes.GetHeadPosition();

    while (pos)
    {
        CNode* pNode = nodes.GetNext( pos );
        sc = ScCheckPointers( pNode, E_UNEXPECTED );
        if (sc)
            return sc;

        CSnapInNode* pSINode = dynamic_cast<CSnapInNode*>(pNode);
        sc = ScCheckPointers(pSINode, E_UNEXPECTED);
        if (sc)
            return sc;

        const int viewID = pNode->GetViewID();
        const CComponentArray& components = pSINode->GetComponentArray();
        const int size = components.size();

        for (int i = 0; i < size; i++)
        {
            CComponent* pCC = components[i];
            if ( pCC != NULL )
            {
                sc = ScSaveIComponent( pCC, viewID);
                if (sc)
                    return sc;
            }
        }
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMTSnapInNode::ScSaveIComponent
 *
 * PURPOSE: Determines snapin's IComponent persistence capabilities (QI for IPersistXXXX)
 *          And asks it to save giving maintained stream/storage as a media.
 *
 * PARAMETERS:
 *    CComponent* pCComponent [in] component
 *    int viewID              [in] view id for which the component is created
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMTSnapInNode::ScSaveIComponent( CComponent* pCComponent, int viewID )
{
    DECLARE_SC(sc, TEXT("CMTSnapInNode::ScSaveIComponent"));

    // parameter check
    sc = ScCheckPointers( pCComponent );
    if (sc)
        return sc;

    const CLSID& clsid = pCComponent->GetCLSID();

    // check if the component is initialized (compatibility with mmc 1.2)
    // give another chance to load
    if ( !pCComponent->IsIComponentInitialized() )
    {
        sc = ScInitIComponent(pCComponent, viewID);
        if (sc)
            return sc;
    }

    // get IComponent
    IComponent* pComponent = pCComponent->GetIComponent();
    sc = ScCheckPointers(pComponent, E_UNEXPECTED);
    if (sc)
        return sc;

    // Get the snapin to get name for the error message.
	CSnapInPtr spSnapin = pCComponent->GetSnapIn();

    // now ask the snapin to save the data
    sc = ScAskSnapinToSaveData( pComponent, &m_ComponentPersistor, viewID, clsid, spSnapin );
    if (sc)
        return sc;

    return sc;
}


/***************************************************************************\
 *
 * METHOD:  CMTSnapInNode::ScAskSnapinToSaveData
 *
 * PURPOSE: Determines snapin persistence capabilities (QI for IPersistXXXX)
 *          And asks it to save giving maintained stream/storage as a media.
 *          This method is called to save both Components and ComponentDatas
 *
 * PARAMETERS:
 *    IUnknown *pSnapin         [in] snapin which data needs to be saved
 *    CMTSnapinNodeStreamsAndStorages *pStreamsAndStorages
 *                              [in] collection of streams/storage where to save
 *    int idView                [in] view id - key for saved data
 *    const CLSID& clsid        [in] class id - key for saved data
 *    CSnapIn *pCSnapin         [in] pointer to CSnapin, used for display name on error
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMTSnapInNode::ScAskSnapinToSaveData( IUnknown *pSnapin,
                                        CMTSnapinNodeStreamsAndStorages *pStreamsAndStorages,
                                        int idView , const CLSID& clsid, CSnapIn *pCSnapin )
{
    DECLARE_SC(sc, TEXT("CMTSnapInNode::ScAskSnapinToSaveData"));

    sc = ScCheckPointers( pSnapin, pStreamsAndStorages );
    if (sc)
        return sc;

    IPersistStreamPtr spIPS;
    IPersistStoragePtr spIPStg;
    IPersistStreamInitPtr spIPSI;

    // QI for IPersistStream
    if ( (spIPS = pSnapin) != NULL)
    {
        // get the object for persistence
        CXML_IStream *pXMLStream = NULL;
        sc = pStreamsAndStorages->ScGetXmlStream( idView, clsid, pXMLStream );
        if (sc)
            return sc;

        // recheck the pointer
        sc = ScCheckPointers( pXMLStream, E_UNEXPECTED );
        if (sc)
            return sc;

        // save data to stream
        sc = pXMLStream->ScRequestSave( spIPS.GetInterfacePtr() );
        if (sc)
            goto DisplaySnapinError;
    }
    else if ( (spIPSI = pSnapin) != NULL) // QI for IPersistStreamInit
    {
        // get the object for persistence
        CXML_IStream *pXMLStream = NULL;
        sc = pStreamsAndStorages->ScGetXmlStream( idView, clsid, pXMLStream );
        if (sc)
            return sc;

        // recheck the pointer
        sc = ScCheckPointers( pXMLStream, E_UNEXPECTED );
        if (sc)
            return sc;

        // save data to stream
        sc = pXMLStream->ScRequestSave( spIPSI.GetInterfacePtr() );
        if (sc)
            goto DisplaySnapinError;
    }
    else if ( (spIPStg = pSnapin) != NULL) // QI for IPersistStorage
    {
        // get the object for persistence
        CXML_IStorage *pXMLStorage = NULL;
        sc = pStreamsAndStorages->ScGetXmlStorage( idView, clsid, pXMLStorage );
        if (sc)
            return sc;

        // recheck the pointer
        sc = ScCheckPointers( pXMLStorage, E_UNEXPECTED );
        if (sc)
            return sc;

        // save data to storage
        sc = pXMLStorage->ScRequestSave( spIPStg.GetInterfacePtr() );
        if (sc)
            goto DisplaySnapinError;
    }

   return sc;

// display snapin failure
DisplaySnapinError:

    // need to inform the world...

    CStr strMessage;
    strMessage.LoadString(GetStringModule(), IDS_SNAPIN_SAVE_FAILED);

	if (pCSnapin != NULL)
	{
		WTL::CString strName;
		if (!pCSnapin->ScGetSnapInName(strName).IsError())
		{
			strMessage += _T("\n");
			strMessage += strName;
			strMessage += _T(".");
		}
	}

    ::MessageBox(NULL, strMessage, _T("Error"), MB_OK | MB_ICONEXCLAMATION);

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\mtnode.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       MTNode.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    9/13/1996   RaviR   Created
//
//____________________________________________________________________________

#ifndef _MTNODE_H_
#define _MTNODE_H_
#pragma once

#include "refcount.h"       // CRefCountedPtr
#include "xmlimage.h"		// CXMLImageList

#define MMC_SYSTEMROOT_VARIABLE _T("systemroot")
#define MMC_SYSTEMROOT_VARIABLE_PERC _T("%systemroot%")
#define MMC_WINDIR_VARIABLE_PERC _T("%windir%")

///////////////////////////////////////////////////////////////////////////////
// Classes referd to here declared in other local files.

class CSnapIn;          // from SnapIn.h
class CSnapInsCache;    // from SnapIn.h
class CComponent;       // from Node.h
class CNode;            // from Node.h
    class CSnapInNode;      // from Node.h

class CDoc;
class CSPImageCache;    // from ScopImag.h
class CExtensionsCache;
class CPersistor;

class CBookmark;        // from bookmark.h
class CSnapinProperties;    // from siprop.h

///////////////////////////////////////////////////////////////////////////////
// Classes declared in this file

class CComponentData;

class CMTNode;
    class CMTSnapInNode;

///////////////////////////////////////////////////////////////////////////////
// typedefs

typedef CMTNode * PMTNODE;
typedef CTypedPtrList<MMC::CPtrList, CNode*> CNodeList;
typedef CList<HMTNODE, HMTNODE> CHMTNODEList;
typedef CComponentData* PCCOMPONENTDATA;
typedef std::vector<PCCOMPONENTDATA> CComponentDataArray;
typedef CArray<GUID, GUID&> CGuidArray;

HRESULT CreateSnapIn (const CLSID& clsid, IComponentData** ppICD,
                      bool fCreateDummyOnFailure = true);
HRESULT LoadRequiredExtensions(CSnapIn* pSnapIn, IComponentData* pICD, CSnapInsCache* pCache = NULL);
HRESULT AddRequiredExtension(CSnapIn* pSnapIn, CLSID& rcslid);
void    DisplayPolicyErrorMessage(const CLSID& clsid, bool bExtension);


#include "snapinpersistence.h"

//____________________________________________________________________________
//
//  Class:      CComponentData
//____________________________________________________________________________
//

class CComponentData
{
	DECLARE_NOT_COPIABLE   (CComponentData)
	DECLARE_NOT_ASSIGNABLE (CComponentData)

public:
// Constructor & Destructor
    CComponentData(CSnapIn * pSnapIn);
   ~CComponentData();

// Attributes
    void SetComponentID(COMPONENTID nID)
    {
        ASSERT(nID >= 0);
        ASSERT(nID < 1000);
        m_ComponentID = nID;
    }
    void SetIComponentData(IComponentData* pICD) { m_spIComponentData = pICD; }
    BOOL IsInitialized()
    {
        return (m_spIFramePrivate != NULL);
    }
    CSnapIn* GetSnapIn(void) const { return m_spSnapIn; }
    const CLSID& GetCLSID() const { return m_spSnapIn->GetSnapInCLSID(); }
    IComponentData* GetIComponentData(void) const { return m_spIComponentData; }
    IFramePrivate* GetIFramePrivate(void) const { return m_spIFramePrivate; }
    IImageListPrivate* GetIImageListPrivate(void);
    COMPONENTID GetComponentID(void) const { return m_ComponentID; }

    LPUNKNOWN GetUnknownToLoad(void) const { return m_spIComponentData; }

    // IComponentData interface methods
    HRESULT Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    HRESULT QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    HRESULT GetNodeType(MMC_COOKIE cookie, GUID* pGuid);
    HRESULT GetDisplayInfo(SCOPEDATAITEM* pScopeDataItem);

    // IComponentData2 helpers
    SC ScQueryDispatch(MMC_COOKIE, DATA_OBJECT_TYPES type, PPDISPATCH ppScopeNodeObject);

// Operations
    // Initialization
    HRESULT Init(HMTNODE hMTNode);

    void ResetComponentID(COMPONENTID id)
    {
        m_spIFramePrivate->SetComponentID(m_ComponentID = id);
    }

    // loaded from stream/storage; initailized with the new one; or does not need initialization
    bool IsIComponentDataInitialized() 
    { 
        return m_bIComponentDataInitialized; 
    }

    // loaded from stream/storage; initailized with the new one; or does not need initialization
    void SetIComponentDataInitialized()
    { 
        m_bIComponentDataInitialized = true; 
    }

private:
// Implementation
    CSnapInPtr              m_spSnapIn;
    IComponentDataPtr       m_spIComponentData;
    IFramePrivatePtr        m_spIFramePrivate;
    COMPONENTID             m_ComponentID;
    bool                    m_bIComponentDataInitialized;

}; // class CComponentData


/*+-------------------------------------------------------------------------*
 * class CMTNode
 *
 *
 * PURPOSE:
 *
 *+-------------------------------------------------------------------------*/
class CMTNode : public XMLListCollectionBase
{
	DECLARE_NOT_COPIABLE   (CMTNode)
	DECLARE_NOT_ASSIGNABLE (CMTNode)

protected:
    // codes corresponding to legacy node types.
    enum eNodeCodes
    {
        NODE_CODE_SNAPIN     = 1,
        NODE_CODE_FOLDER     = 2,   //  codes 2,3,4 are no longer correspond to
        NODE_CODE_HTML       = 3,   //  MTNode derived classes, but are retained
        NODE_CODE_OCX        = 4,   //  for converting old .msc files
        NODE_CODE_ENUMERATED = 10
    };

public:
    static CMTNode*     FromScopeItem (HSCOPEITEM item);
    static HSCOPEITEM   ToScopeItem   (const CMTNode* pMTNode)  { return (reinterpret_cast<HSCOPEITEM>(pMTNode)); }
    static CMTNode*     FromHandle    (HMTNODE        hMTNode)  { return (reinterpret_cast<CMTNode*>(hMTNode)); }
    static HMTNODE      ToHandle      (const CMTNode* pMTNode)  { return (reinterpret_cast<HMTNODE>(const_cast<CMTNode*>(pMTNode))); }

// Constructor
    CMTNode();

    virtual HRESULT     Init(void);

// Attributes
    virtual BOOL        IsStaticNode() const            {return FALSE;}
    BOOL                IsDynamicNode() const           {return !IsStaticNode();}
    virtual HRESULT     IsExpandable();

    HRESULT             QueryDataObject(DATA_OBJECT_TYPES type, LPDATAOBJECT* ppdtobj);
    // Images
    UINT                GetImage(void)                  { return m_nImage; }
    UINT                GetOpenImage(void)              { return m_nOpenImage; }
    UINT                GetState(void);
    void                SetImage(UINT nImage)           { m_nImage = nImage; }
    void                SetOpenImage(UINT nImage)       { m_nOpenImage = nImage; }
    void                SetState(UINT nState)           { m_nState = nState; }

    void                SetOwnerID(long id)             { m_idOwner = id; }
    long                GetOwnerID(void) const          { return m_idOwner; }
    void                SetPrimaryComponentData(CComponentData* pDI)    { m_pPrimaryComponentData = pDI; }
    CComponentData*     GetPrimaryComponentData() const                 { return m_pPrimaryComponentData; }

    virtual tstring     GetDisplayName();
    virtual void        SetDisplayName(LPCTSTR pszName);

protected:
    tstring             GetCachedDisplayName() const    {return m_strName.str();}
    void                SetCachedDisplayName(LPCTSTR pszName);

public:
    BOOL                IsInitialized()                 { return m_bInit; }
    int                 GetDynExtCLSID ( LPCLSID *ppCLSID );
    void                SetNoPrimaryChildren(BOOL bState = TRUE);
    HRESULT             OnRename(long fRename, LPOLESTR pszNewName);
    SC                  ScQueryDispatch(DATA_OBJECT_TYPES type, PPDISPATCH ppScopeNodeObject);
    HRESULT             AddExtension(LPCLSID lpclsid);

    CSnapIn*            GetPrimarySnapIn(void) const    { return m_pPrimaryComponentData->GetSnapIn(); }
    COMPONENTID         GetPrimaryComponentID();

    CMTSnapInNode*      GetStaticParent(void);
    const CLSID&        GetPrimarySnapInCLSID(void);
    LPARAM              GetUserParam(void) const        { return m_lUserParam; }
    void                SetUserParam(LPARAM lParam)     { m_lUserParam = lParam; }
    HRESULT             GetNodeType(GUID* pGuid);
    SC                  ScGetPropertyFromINodeProperties(LPDATAOBJECT pDataObject, BSTR bstrPropertyName, PBSTR  pbstrPropertyValue);

// Operations
    virtual CNode *     GetNode(CViewData* pViewData,
                           BOOL fRootNode = FALSE);     // Method to create a node  for this Master Node.
    HRESULT             Expand(void);
    HRESULT             Expand (CComponentData*, IDataObject*, BOOL);
    virtual bool        AllowNewWindowFromHere() const  { return (true); }


    // Reference counting methods.
    USHORT AddRef();
    USHORT Release();

    // Tree traversal methods.
    PMTNODE             Next() const                    {return m_pNext;}
    PMTNODE             Child() const                   {return m_pChild;}
    PMTNODE             Parent() const                  {return m_pParent;}
    void                AttachNext(PMTNODE pmn)         {m_pNext = pmn;}
    void                AttachChild(PMTNODE pmn)        {m_pChild = pmn;}
    void                AttachParent(PMTNODE pmn)       {m_pParent = pmn;}

    CMTNode *           NextStaticNode();

    // Iterators that expand
    PMTNODE             GetNext() const                 {return Next();}
    PMTNODE             GetChild();

    void                CreatePathList(CHMTNODEList& path);
                        // Returns true if the stucture of tree needs to be saved,
                        // or if any of the nodes need to be saved.
                        // Derived classes which want to do more complex IsDirty() testing
                        // may over-ride this function.
    virtual HRESULT     IsDirty();

    HRESULT             InitNew(PersistData*);          // Saves the stream information for later use and sets the dirty flag.
    static SC           ScLoad(PersistData*, CMTNode** ppRootNode);     // Creates a new tree structure from the provided storage and returns it in ppRootNode.

    void                ResetExpandedAtLeastOnce()              {_SetFlag(FLAG_EXPANDED_AT_LEAST_ONCE, FALSE);}
    void                SetExpandedAtLeastOnce()                {_SetFlag(FLAG_EXPANDED_AT_LEAST_ONCE, TRUE);}
    BOOL                WasExpandedAtLeastOnce()                {return _IsFlagSet(FLAG_EXPANDED_AT_LEAST_ONCE);}
    void                SetPropertyPageIsDisplayed(BOOL bSet)   {_SetFlag(FLAG_PROPERTY_PAGE_IS_DISPLAYED, bSet);}
    BOOL                IsPropertyPageDisplayed()               {return _IsFlagSet(FLAG_PROPERTY_PAGE_IS_DISPLAYED);}

    // Flag to monitor if MMCN_REMOVE_CHILDREN was sent to the snapin owning the node
    void                SetRemovingChildren(bool b)             {_SetFlag(FLAG_REMOVING_CHILDREN, b);}
    bool                AreChildrenBeingRemoved();

    // Unique ID helper functions. (Each node will be assigned an unique id
    // within the .msc file.)
    static MTNODEID     GetNextID() throw()             {return m_NextID++;}
    static void         ResetID() throw()               {m_NextID = ROOTNODEID;}
    CMTNode*            Find(MTNODEID id);
    MTNODEID            GetID() const throw()           {return m_ID;}
    void                SetID(MTNODEID key)             {m_ID = key;}

    HRESULT             DestroyElements();              // recursive function
    HRESULT             DoDestroyElements();            // non-recursvie part
                                                        // Deletes any persistence data stored in the current file

    void                SetDirty(bool bIsDirty = true)  {m_bIsDirty = bIsDirty;}
    void                ClearDirty()                    {m_bIsDirty = false;}
    virtual void        NotifyAddedToTree()             {}
    virtual HRESULT     CloseView(int viewID);
    virtual HRESULT     DeleteView(int viewID);
    virtual bool        DoDelete(HWND hwnd)             { return true; }
    virtual void        OnChildrenChanged()             {}

    CMTNode*            GetLastChild();

    virtual CSnapInNode*    FindNode(int nViewID)           { return NULL; }

    // Unique ID for the node instance.
    CBookmark*          GetBookmark();

    virtual void        Reset();

protected:
    virtual ~CMTNode();


    virtual HRESULT     InitNew()                       {return S_OK;}  // Provides the derived nodes the opportunity to initialize the persistent resources.
    virtual SC          ScLoad();
public:
    virtual void        Persist(CPersistor& persistor);     // persists the node
    virtual void        OnNewElement(CPersistor& persistor);
    static void         PersistNewNode(CPersistor &persistor, CMTNode** ppNode);
    DEFINE_XML_TYPE(XML_TAG_MT_NODE);

    static wchar_t*     GetViewStorageName(wchar_t* name, int idView);
    static wchar_t*     GetComponentStreamName(wchar_t* name, const CLSID& clsid);
    static wchar_t*     GetComponentStorageName(wchar_t* name, const CLSID& clsid);
    static int          GetViewIdFromStorageName(const wchar_t* name);

protected:
    // Allows the tree to re-attach to a persistence source.
    IStream*            GetTreeStream()                 {return m_spTreeStream;}
    BOOL                GetDirty()                      {return m_bIsDirty;}
    wchar_t*            GetStorageName(wchar_t* name)   {return _ltow(GetID(), name, 36);}

    IStorage*           GetNodeStorage()        {return m_spNodeStorage;}
    IStorage*           GetViewStorage()        {return m_spViewStorage;}
    IStorage*           GetStorageForCD()       {return m_spCDStorage;}
    PersistData*        GetPersistData()        {return m_spPersistData;}
    bool                Loaded()                {return m_bLoaded;}

    bool                AreExtensionsExpanded(void) const { return m_bExtensionsExpanded; }


// Implementation
private:
    PMTNODE             m_pNext;
    PMTNODE             m_pChild;
    PMTNODE             m_pParent;

    std::auto_ptr<CBookmarkEx> m_bookmark;        // For node instance persistance

    PersistDataPtr      m_spPersistData;
    IStoragePtr         m_spNodeStorage;
    IStoragePtr         m_spViewStorage;
    IStoragePtr         m_spCDStorage;
    IStreamPtr          m_spTreeStream;
    bool                m_bIsDirty;

    USHORT              m_cRef;
    USHORT              m_usFlags;  // m_bExpandedAtLeastOnce;
    enum ENUM_FLAGS
    {
        FLAG_EXPANDED_AT_LEAST_ONCE = 0x0001,
        FLAG_PROPERTY_PAGE_IS_DISPLAYED = 0x0002,
        FLAG_REMOVING_CHILDREN = 0x0004,
    };

    void                _SetFlag(ENUM_FLAGS flag, BOOL bSet);
    BOOL                _IsFlagSet(ENUM_FLAGS flag){return ((m_usFlags & flag) == flag);}

    MTNODEID            m_ID;                       // Unique id for this node within the .msc file.
    bool                m_bLoaded;                  // when true, load should be called instead of init new
    static MTNODEID     m_NextID;                   // The last unique identifier given out.

    HRESULT             OpenStorageForNode();       // Opens the storage for this specific instance of a node.
    HRESULT             OpenStorageForView();       // Opens the view storage for this specific instance of a node.
    HRESULT             OpenStorageForCD();         // Opens the view storage for this specific instance of a node.
private:
    HRESULT             OpenTreeStream();           // Opens the stream to be used to contain this nodes data.

    void                SetParent(CMTNode* pParent);// Sets the parent for this and all next nodes.


protected:
    UINT                m_nImage;
    UINT                m_nOpenImage;
    UINT                m_nState;
    CStringTableString  m_strName;  // Display name

protected:
    enum StreamVersionIndicator
    {
        Stream_V0100 = 1,       // MMC 1.0
        Stream_V0110 = 2,       // MMC 1.1

        Stream_CurrentVersion = Stream_V0110,
        VersionedStreamMarker = 0xFFFFFFFF,
    };

private:
    long                m_idOwner;  // One of the SnapIns.
    LPARAM              m_lUserParam;
    CComponentData*     m_pPrimaryComponentData;
    BOOL                m_bInit;
    bool                m_bExtensionsExpanded;
    CGuidArray          m_arrayDynExtCLSID;
    unsigned short      m_usExpandFlags;
    enum ENUM_EXPAND_FLAGS
    {
        FLAG_NO_CHILDREN_FROM_PRIMARY = 0x0001,
        FLAG_NO_NAMESPACE_EXTNS       = 0x0002,
        FLAG_NAMESPACE_EXTNS_CHECKED  = 0x0004
    };
}; // class CMTNode


/*+-------------------------------------------------------------------------*
 * class ViewRootStorage
 *
 *
 * PURPOSE:
 *
 *+-------------------------------------------------------------------------*/
class ViewRootStorage
{
public:
    ViewRootStorage() {}
    ~ViewRootStorage()
    {
        Clear();
    }
    void Initialize(IStorage* pRootStorage)
    {
        ASSERT(m_spRootStorage == NULL);
        ASSERT(pRootStorage != NULL);
        m_spRootStorage = pRootStorage;
    }
    IStorage* GetRootStorage()
    {
        return m_spRootStorage;
    }
    bool Insert(IStorage* pViewStorage, int idView)
    {
        ASSERT(pViewStorage != NULL);
        if ( NULL == m_Views.Find(idView))
        {
            return m_Views.Insert(IStoragePtr(pViewStorage), idView);
        }
        return true;
    }
    bool Remove(int idView)
    {
        const bool bRemoved = m_Views.Remove(idView);
        return bRemoved;
    }
    IStorage* FindViewStorage(int idView) const
    {
        CAdapt<IStoragePtr> *pspStorage = m_Views.Find(idView);
        return (pspStorage ? pspStorage->m_T : NULL);
    }
    void Clear()
    {
        m_Views.Clear();
        m_spRootStorage = NULL;
    }
private:
    // CAdapt is used to hide operator&() - which will be invoked by map 
    // implementation to get address of the element.
    // Smart pointer's operator&() releases reference plus returns wrong type for a map.
    Map<CAdapt<IStoragePtr>, int> m_Views;
    IStoragePtr m_spRootStorage;
}; // class ViewRootStorage


/*+-------------------------------------------------------------------------*
 * class CMTSnapInNode
 *
 *
 * PURPOSE: The root node of a primary snap-in. Added to the console and
 *          the scope tree by MMC. Only a snap-in that is added from the
 *          Add/Remove snapin page of the Snapin manager has a static node;
 *          extensions of any type do not.
 *
 *+-------------------------------------------------------------------------*/

class CMTSnapInNode : public CMTNode, public CTiedObject
{
	DECLARE_NOT_COPIABLE   (CMTSnapInNode)
	DECLARE_NOT_ASSIGNABLE (CMTSnapInNode)

public:
// Constructor & Destructor
    CMTSnapInNode(Properties* pProps);
   ~CMTSnapInNode();

    // SnapIn object model methods
public:
    SC ScGetSnapIn(PPSNAPIN ppSnapIn);

    SC Scget_Name(       PBSTR      pbstrName);
    SC Scget_Extensions( PPEXTENSIONS  ppExtensions);
    SC Scget_SnapinCLSID(PBSTR      pbstrSnapinCLSID);
    SC Scget_Properties( PPPROPERTIES ppProperties);
    SC ScEnableAllExtensions (BOOL bEnable);

    // helper for CMMCSnapIn
    SC ScGetSnapinClsid(CLSID& clsid);

    static SC ScGetCMTSnapinNode(PSNAPIN pSnapIn, CMTSnapInNode **ppMTSnapInNode);


public:
// Attributes
    virtual BOOL IsStaticNode() const { return TRUE; }
    UINT GetResultImage(CNode* pNode, IImageListPrivate* pImageList);
    void SetResultImage(UINT index) { m_resultImage = index; }
    void SetPrimarySnapIn(CSnapIn * pSI);
    CNodeList& GetNodeList(void) { return m_NodeList; }
    virtual HRESULT IsExpandable();

// Operations
    // Initialize
    virtual HRESULT Init(void);

    // Create a node  for this master node.
    virtual CNode * GetNode(CViewData* pViewData, BOOL fRootNode = FALSE);

    virtual tstring GetDisplayName();
    virtual void    SetDisplayName(LPCTSTR pszName);


    void AddNode(CNode * pNode);
    void RemoveNode(CNode * pNode);
    virtual CSnapInNode* FindNode(int nViewID);

    int GetNumberOfComponentDatas() { return m_ComponentDataArray.size(); }
    COMPONENTID AddComponentDataToArray(CComponentData* pCCD);
    CComponentData* GetComponentData(const CLSID& clsid);
    CComponentData* GetComponentData(COMPONENTID nID);
    CComponent* GetComponent(UINT nViewID, COMPONENTID nID, CSnapIn* pSnapIn);

    virtual HRESULT CloseView(int viewID);
    virtual HRESULT DeleteView(int viewID);

    // Loads from existing stream/storage or initializes with the new one
    SC   ScInitIComponentData( CComponentData* pCD );
    SC   ScInitIComponent(CComponent* pComponent, int viewID);

    virtual void Reset();
    void CompressComponentDataArray();
    BOOL IsPreloadRequired () const;
    void SetPreloadRequired (bool bPreload) { m_ePreloadState = (bPreload) ? ePreload_True : ePreload_False;}

    SC   ScConvertLegacyNode(const CLSID &clsid);

// Implementation
protected:
//    virtual HRESULT InitNew();
    virtual HRESULT IsDirty();
    virtual SC      ScLoad();
    virtual void    Persist(CPersistor& persistor);

private:
    SC ScInitProperties();
    SC ScCreateSnapinProperties(CSnapinProperties** ppSIProps);
	SC ScAddImagesToImageList();

    SC ScReadStreamsAndStoragesFromConsole();
    // Loads from existing sream/storage of initializes with the new one.
    SC ScInitComponentOrComponentData( IUnknown *pSnapin, CMTSnapinNodeStreamsAndStorages *pStreamsAndStorages,
                                       int idView , const CLSID& clsid );
private:
    enum PersistType
    {
        PT_None,
        PT_IStream,
        PT_IStreamInit,
        PT_IStorage
    };

	enum PreloadState
	{
		ePreload_Unknown = -1,		// don't know if MMCN_PRELOAD is required yet
		ePreload_False   =  0,		// MMCN_PRELOAD not required
		ePreload_True    =  1,		// MMCN_PRELOAD required
	};

	SC ScQueryPreloadRequired (PreloadState& ePreload) const;

    SC ScHandleCustomImages (const CLSID& clsidSnapin);
    SC ScHandleCustomImages (HBITMAP hbmSmall, HBITMAP hbmSmallOpen, HBITMAP hbmLarge, COLORREF crMask);

    HRESULT AreIComponentDatasDirty();
    HRESULT AreIComponentsDirty();
    HRESULT IsIUnknownDirty(IUnknown* pUnk);

    SC ScSaveIComponentDatas();
    SC ScSaveIComponentData( CComponentData* pCD );
    SC ScSaveIComponents();
    SC ScSaveIComponent( CComponent* pCComponent, int viewID );
    SC ScAskSnapinToSaveData( IUnknown *pSnapin, CMTSnapinNodeStreamsAndStorages *pStreamsAndStorages, 
                              int idView , const CLSID& clsid, CSnapIn *pCSnapin );

private:
    PropertiesPtr       m_spProps;
    SnapInPtr           m_spSnapIn;

    CComponentDataArray m_ComponentDataArray;
    CNodeList           m_NodeList;
    ViewRootStorage     m_ComponentStorage;

	CXMLImageList		m_imlSmall;			// small, open images
	CXMLImageList		m_imlLarge;			// large image

    UINT                m_resultImage;
    CDPersistor         m_CDPersistor;
    CComponentPersistor m_ComponentPersistor;

	mutable PreloadState m_ePreloadState;
    BOOL                m_bHasBitmaps;
    bool                m_fCallbackForDisplayName;  // snap-in gave us MMC_TEXTCALLBACK for node name?

}; // class CMTSnapInNode


#include "mtnode.inl"

#endif // _MTNODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\msgview.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      msgview.cpp
 *
 *  Contents:  Implementation file for CMessageView
 *
 *  History:   28-Apr-99 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "msgview.h"
#include "util.h"

using std::_MAX;
using std::_MIN;


/*+-------------------------------------------------------------------------*
 * CMessageView::CMessageView
 *
 *
 *--------------------------------------------------------------------------*/

CMessageView::CMessageView ()
    :   m_hIcon      (NULL),
        m_yScroll    (0),
        m_yScrollMax (0),
        m_yScrollMin (0),
        m_cyPage     (0),
        m_cyLine     (0),
        m_sizeWindow (0, 0),
        m_sizeIcon   (0, 0),
        m_sizeMargin (0, 0),
		m_nAccumulatedScrollDelta (0)
{
    /*
     * can't be windowless
     */
    m_bWindowOnly = true;

	/*
	 * get the system metrics we'll use
	 */
	UpdateSystemMetrics();

    DEBUG_INCREMENT_INSTANCE_COUNTER(CMessageView);
}


/*+-------------------------------------------------------------------------*
 * CMessageView::~CMessageView
 *
 *
 *--------------------------------------------------------------------------*/

CMessageView::~CMessageView ()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CMessageView);
}


/*+-------------------------------------------------------------------------*
 * CMessageView::OnCreate
 *
 * WM_CREATE handler for CMessageView.
 *--------------------------------------------------------------------------*/

LRESULT CMessageView::OnCreate (UINT msg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    CreateFonts();
	RecalcLayout ();

	return (0);
}


/*+-------------------------------------------------------------------------*
 * CMessageView::OnDestroy
 *
 * WM_DESTROY handler for CMessageView.
 *--------------------------------------------------------------------------*/

LRESULT CMessageView::OnDestroy (UINT msg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    DeleteFonts();
    return (0);
}


/*+-------------------------------------------------------------------------*
 * CMessageView::OnSize
 *
 * WM_SIZE handler for CMessageView.
 *--------------------------------------------------------------------------*/

LRESULT CMessageView::OnSize (UINT msg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    /*
     * The transient appearance/disappearance of WS_VSCROLL makes the client
     * rect volatile and can mess up our calculations.  We'll use the more
     * stable window rect instead.
     */
    WTL::CRect rectWindow;
    GetWindowRect (rectWindow);

    if (GetExStyle() & WS_EX_CLIENTEDGE)
        rectWindow.DeflateRect (GetSystemMetrics (SM_CXEDGE),
                                GetSystemMetrics (SM_CYEDGE));

    WTL::CSize sizeWindow (rectWindow.Width(), rectWindow.Height());

    /*
     * if the overall size has changed, we have some work to do
     */
    if (m_sizeWindow != sizeWindow)
    {
        /*
         * load m_sizeWindow right away so scrollbar future calculations
         * will have the right values in the member variable
         */
        std::swap (m_sizeWindow, sizeWindow);

        /*
         * if the width has changed, we'll might need to recalculate
         * all of the text heights
         */
        if (m_sizeWindow.cx != sizeWindow.cx)
            RecalcLayout ();

        /*
         * if the height changed, there's scrollbar work
         */
        if (m_sizeWindow.cy != sizeWindow.cy)
        {
            int dy = m_sizeWindow.cy - sizeWindow.cy;

            /*
             * if the window's grown, we might need to scroll to keep the
             * bottom of our content glued to the bottom of the window
             */
            if ((dy > 0) && (m_yScroll > 0) &&
                        ((m_yScroll + m_sizeWindow.cy) > GetOverallHeight()))
                ScrollToPosition (m_yScroll - dy);

            /*
             * otherwise, just update the scrollbar
             */
            else
                UpdateScrollSizes();
        }
    }

    return (0);
}


/*+-------------------------------------------------------------------------*
 * CMessageView::OnSettingChange
 *
 * WM_SETTINGCHANGE handler for CMessageView.
 *--------------------------------------------------------------------------*/

LRESULT CMessageView::OnSettingChange (UINT msg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (wParam == SPI_SETNONCLIENTMETRICS)
    {
        DeleteFonts ();
        CreateFonts ();
	}

	UpdateSystemMetrics();
    RecalcLayout ();

    return (0);
}


/*+-------------------------------------------------------------------------*
 * CMessageView::UpdateSystemMetrics
 *
 * Updates the system metrics used by the message view control.
 *--------------------------------------------------------------------------*/

void CMessageView::UpdateSystemMetrics ()
{
	m_sizeMargin.cx = GetSystemMetrics (SM_CXVSCROLL);
	m_sizeMargin.cy = GetSystemMetrics (SM_CYVSCROLL);
	m_sizeIcon.cx   = GetSystemMetrics (SM_CXICON);
	m_sizeIcon.cy   = GetSystemMetrics (SM_CYICON);
}


/*+-------------------------------------------------------------------------*
 * CMessageView::OnKeyDown
 *
 * WM_KEYDOWN handler for CMessageView.
 *--------------------------------------------------------------------------*/

LRESULT CMessageView::OnKeyDown (UINT msg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    return (0);
}


/*+-------------------------------------------------------------------------*
 * CMessageView::OnVScroll
 *
 * WM_VSCROLL handler for CMessageView.
 *--------------------------------------------------------------------------*/

LRESULT CMessageView::OnVScroll (UINT msg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	VertScroll (LOWORD (wParam), HIWORD (wParam), 1);
	return (0);
}


/*+-------------------------------------------------------------------------*
 * CMessageView::OnMouseWheel
 *
 * WM_MOUSEWHEEL handler for CMessageView.
 *--------------------------------------------------------------------------*/

LRESULT CMessageView::OnMouseWheel (UINT msg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	m_nAccumulatedScrollDelta += GET_WHEEL_DELTA_WPARAM (wParam);

	/*
	 * scroll one line up or down for each WHEEL_DELTA unit in our
	 * accumulated delta
	 */
	const int nScrollCmd    = (m_nAccumulatedScrollDelta < 0) ? SB_LINEDOWN : SB_LINEUP;
	const int nScrollRepeat = abs(m_nAccumulatedScrollDelta) / WHEEL_DELTA;
	VertScroll (nScrollCmd, 0, nScrollRepeat);

	m_nAccumulatedScrollDelta %= WHEEL_DELTA;

	return (0);
}


/*+-------------------------------------------------------------------------*
 * CMessageView::VertScroll
 *
 * Vertical scroll handler for CMessageView.
 *--------------------------------------------------------------------------*/

void CMessageView::VertScroll (
	int	nScrollCmd,				/* I:how to scroll (e.g. SB_LINEUP)			*/
	int	nScrollPos,				/* I:absolute position (SB_THUMBTRACK only)	*/
	int	nRepeat)				/* I:repeat count							*/
{
    int yScroll = m_yScroll;

    switch (nScrollCmd)
    {
        case SB_LINEUP:
            yScroll -= nRepeat * m_cyLine;
            break;

        case SB_LINEDOWN:
            yScroll += nRepeat * m_cyLine;
            break;

        case SB_PAGEUP:
            yScroll -= nRepeat * m_cyPage;
            break;

        case SB_PAGEDOWN:
            yScroll += nRepeat * m_cyPage;
            break;

        case SB_TOP:
            yScroll = m_yScrollMin;
            break;

        case SB_BOTTOM:
            yScroll = m_yScrollMax;
            break;

        case SB_THUMBTRACK:
            yScroll = nScrollPos;
            break;
    }

    ScrollToPosition (yScroll);
}


/*+-------------------------------------------------------------------------*
 * CMessageView::OnDraw
 *
 * Draw handler for CMessageView.
 *--------------------------------------------------------------------------*/

HRESULT CMessageView::OnDraw(ATL_DRAWINFO& di)
{
	/*
	 * use CDCHandle instead of CDC so the dtor won't delete the DC
	 * (we didn't create it, so we can't delete it)
	 */
    WTL::CDCHandle dc = di.hdcDraw;

    /*
     * handle scrolling
     */
    dc.SetViewportOrg (0, -m_yScroll);

    /*
     * set up colors
     */
    COLORREF clrText = dc.SetTextColor (GetSysColor (COLOR_WINDOWTEXT));
    COLORREF clrBack = dc.SetBkColor   (GetSysColor (COLOR_WINDOW));

    /*
     * get the clipping region for the DC
     */
    WTL::CRect rectT;
    WTL::CRect rectClip;
    dc.GetClipBox (rectClip);

    /*
     * if there is a title and it intersects the clipping region, draw it
     */
    if ((m_TextElement[Title].str.length() > 0) &&
                rectT.IntersectRect (rectClip, m_TextElement[Title].rect))
        DrawTextElement (dc, m_TextElement[Title]);

    /*
     * if there is a body and it intersects the clipping region, draw it
     */
    if ((m_TextElement[Body].str.length() > 0) &&
                rectT.IntersectRect (rectClip, m_TextElement[Body].rect))
        DrawTextElement (dc, m_TextElement[Body]);

    /*
     * if there is an icon and it intersects the clipping region, draw it
     */
    if ((m_hIcon != NULL) && rectT.IntersectRect (rectClip, m_rectIcon))
        dc.DrawIcon (m_rectIcon.TopLeft(), m_hIcon);

    /*
     * restore the DC
     */
    dc.SetTextColor (clrText);
    dc.SetBkColor   (clrBack);

#define SHOW_MARGINS 0
#if (defined(DBG) && SHOW_MARGINS)
    {
        HBRUSH hbr = GetSysColorBrush (COLOR_GRAYTEXT);
        WTL::CRect rectAll;
		WTL::CRect rectTemp;

		rectTemp.UnionRect  (m_TextElement[Body].rect, m_TextElement[Title].rect);
        rectAll.UnionRect   (rectTemp, m_rectIcon);
		rectAll.InflateRect (m_sizeMargin);

        dc.FrameRect (m_TextElement[Title].rect, hbr);
        dc.FrameRect (m_TextElement[Body].rect,  hbr);
        dc.FrameRect (m_rectIcon,                hbr);
        dc.FrameRect (rectAll,                   hbr);
    }
#endif

    return (S_OK);
}


/*+-------------------------------------------------------------------------*
 * CMessageView::SetTitleText
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CMessageView::SetTitleText (LPCOLESTR pszTitleText)
{
    return (SetTextElement (m_TextElement[Title], pszTitleText));
}


/*+-------------------------------------------------------------------------*
 * CMessageView::SetBodyText
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CMessageView::SetBodyText (LPCOLESTR pszBodyText)
{
    return (SetTextElement (m_TextElement[Body], pszBodyText));
}


/*+-------------------------------------------------------------------------*
 * CMessageView::SetTextElement
 *
 *
 *--------------------------------------------------------------------------*/

HRESULT CMessageView::SetTextElement (TextElement& te, LPCOLESTR pszNewText)
{
    USES_CONVERSION;
    tstring strNewText;

    if (pszNewText != NULL)
        strNewText = W2CT(pszNewText);

    if (te.str != strNewText)
    {
        te.str = strNewText;
        RecalcLayout();
        Invalidate();
    }

    return (S_OK);
}


/*+-------------------------------------------------------------------------*
 * CMessageView::SetIcon
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CMessageView::SetIcon (IconIdentifier id)
{
    bool fHadIconBefore = (m_hIcon != NULL);

    if (id == Icon_None)
        m_hIcon = NULL;

    else if ((id >= Icon_First) && (id <= Icon_Last))
        m_hIcon = LoadIcon (NULL, MAKEINTRESOURCE (id));

    else
        return (E_INVALIDARG);

    /*
     * if we had an icon before, but we don't have one now (or vice versa)
     * we need to recalculate the layout and redraw everything
     */
    if (fHadIconBefore != (m_hIcon != NULL))
    {
        RecalcLayout();
        Invalidate();
    }

    /*
     * otherwise, just redraw draw the icon
     */
    else
        InvalidateRect (m_rectIcon);


    return (S_OK);
}


/*+-------------------------------------------------------------------------*
 * CMessageView::Clear
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CMessageView::Clear ()
{
    m_TextElement[Title].str.erase();
    m_TextElement[Body].str.erase();
    m_hIcon = NULL;

    RecalcLayout();
    Invalidate();

    return (S_OK);
}


/*+-------------------------------------------------------------------------*
 * CMessageView::RecalcLayout
 *
 *
 *--------------------------------------------------------------------------*/

void CMessageView::RecalcLayout()
{
    RecalcIconLayout();
    RecalcTitleLayout();
    RecalcBodyLayout();
    UpdateScrollSizes();
}


/*+-------------------------------------------------------------------------*
 * CMessageView::RecalcIconLayout
 *
 *
 *--------------------------------------------------------------------------*/

void CMessageView::RecalcIconLayout()
{
    m_rectIcon = WTL::CRect (WTL::CPoint (m_sizeMargin.cx, m_sizeMargin.cy),
                             (m_hIcon != NULL) ? m_sizeIcon : WTL::CSize(0,0));
}


/*+-------------------------------------------------------------------------*
 * CMessageView::RecalcTitleLayout
 *
 *
 *--------------------------------------------------------------------------*/

void CMessageView::RecalcTitleLayout()
{
    WTL::CRect& rect = m_TextElement[Title].rect;

    /*
     * prime the title rectangle for calculating the text height
	 * (leave room for a vertical scrollbar on the right so its appearance
	 * and disappearance don't affect the layout of the text)
     */
    rect.SetRect (
        m_rectIcon.right,
        m_rectIcon.top,
        _MAX (0, (int) (m_sizeWindow.cx - m_sizeMargin.cx - GetSystemMetrics(SM_CXVSCROLL))),
        0);

    /*
     * if there is an icon, leave a gutter between the icon and title
     */
    if ((m_hIcon != NULL) && (rect.right > 0))
    {
        rect.left += m_cyLine;
        rect.right = _MAX (rect.left, rect.right);
    }

    /*
     * compute the height of the title
     */
    if (m_TextElement[Title].str.length() > 0)
        rect.bottom = rect.top + CalcTextElementHeight (m_TextElement[Title], rect.Width());

    /*
     * if the title is shorter than the icon, center it vertically
     */
    if (rect.Height() < m_rectIcon.Height())
        rect.OffsetRect (0, (m_rectIcon.Height() - rect.Height()) / 2);
}


/*+-------------------------------------------------------------------------*
 * CMessageView::RecalcBodyLayout
 *
 *
 *--------------------------------------------------------------------------*/

void CMessageView::RecalcBodyLayout()
{
    WTL::CRect& rect = m_TextElement[Body].rect;

    /*
     * prime the body rectangle for calculating the text height
     */
    rect.UnionRect (m_rectIcon, m_TextElement[Title].rect);
    rect.OffsetRect (0, rect.Height());

    /*
     * compute the height of the body; it starts empty, but adds the
	 * height of the body text if we have any
     */
	rect.bottom = rect.top;
    if (m_TextElement[Body].str.length() > 0)
        rect.bottom += CalcTextElementHeight (m_TextElement[Body], rect.Width());

    /*
     * if there's an icon or title, we need to leave
     * a line's worth of space before the body
     */
    if (!rect.IsRectEmpty())
        rect.OffsetRect (0, m_cyLine);
}


/*+-------------------------------------------------------------------------*
 * CMessageView::CalcTextElementHeight
 *
 *
 *--------------------------------------------------------------------------*/

int CMessageView::CalcTextElementHeight (const TextElement& te, int cx)
{
    TextElement teWork = te;
    teWork.rect.SetRect (0, 0, cx, 0);

    DrawTextElement (WTL::CWindowDC(m_hWnd), teWork, DT_CALCRECT);
    teWork.font.Detach();

    return (teWork.rect.Height());
}


/*+-------------------------------------------------------------------------*
 * CMessageView::DrawTextElement
 *
 *
 *--------------------------------------------------------------------------*/

void CMessageView::DrawTextElement (HDC hdc, TextElement& te, DWORD dwFlags)
{
	/*
	 * use CDCHandle instead of CDC so the dtor won't delete the DC
	 * (we didn't create it, so we can't delete it)
	 */
    WTL::CDCHandle dc = hdc;

    HFONT hFont = dc.SelectFont (te.font);
    dc.DrawText (te.str.data(), te.str.length(), te.rect,
                 DT_LEFT | DT_TOP | DT_WORDBREAK | DT_NOPREFIX | dwFlags);
    dc.SelectFont (hFont);
}


/*+-------------------------------------------------------------------------*
 * CMessageView::CreateFonts
 *
 *
 *--------------------------------------------------------------------------*/

void CMessageView::CreateFonts ()
{
	/*
     * create a font that's a little larger than the
     * one used for icon titles to use for the body text
	 */
    NONCLIENTMETRICS ncm;
    ncm.cbSize = sizeof (ncm);
    SystemParametersInfo (SPI_GETNONCLIENTMETRICS, 0, &ncm, false);

    m_TextElement[Body].font.CreateFontIndirect (&ncm.lfMessageFont);

    /*
     * create a bold version for the title
     */
    ncm.lfMessageFont.lfWeight = FW_BOLD;
    m_TextElement[Title].font.CreateFontIndirect (&ncm.lfMessageFont);

    /*
     * get the height of a line of text
     */
    SIZE siz;
    TCHAR ch = _T('0');
    WTL::CWindowDC dc(m_hWnd);
    HFONT hFontOld = dc.SelectFont (m_TextElement[Title].font);
    dc.GetTextExtent (&ch, 1, &siz);
    dc.SelectFont (hFontOld);
    m_cyLine = siz.cy;
}


/*+-------------------------------------------------------------------------*
 * CMessageView::DeleteFonts
 *
 *
 *--------------------------------------------------------------------------*/

void CMessageView::DeleteFonts ()
{
    m_TextElement[Title].font.DeleteObject();
    m_TextElement[Body].font.DeleteObject();
}


/*+-------------------------------------------------------------------------*
 * CMessageView::UpdateScrollSizes
 *
 *
 *--------------------------------------------------------------------------*/

void CMessageView::UpdateScrollSizes ()
{
    WTL::CRect rect;
    GetClientRect (rect);

    int cyTotal  = GetOverallHeight();
    m_yScrollMax = _MAX (0, cyTotal - rect.Height());

    /*
     * The height of a page is a whole number of lines.  If the window
     * can display N lines at a time, a page will be N-1 lines so there's
     * some continuity after a page up or down.
     */
    if (m_cyLine > 0)
        m_cyPage = rect.Height();// _MAX (0, ((rect.Height() / m_cyLine) - 1) * m_cyLine);
    else
        m_cyPage  = 0;


    /*
     * update the scrollbar
     */
    SCROLLINFO si;
    si.cbSize = sizeof(si);
    si.fMask  = SIF_PAGE | SIF_RANGE | SIF_POS;
    si.nMax   = cyTotal;
    si.nMin   = m_yScrollMin;
    si.nPage  = m_cyPage;
    si.nPos   = m_yScroll;

    SetScrollInfo (SB_VERT, &si);
}


/*+-------------------------------------------------------------------------*
 * CMessageView::ScrollToPosition
 *
 *
 *--------------------------------------------------------------------------*/

void CMessageView::ScrollToPosition (int yScroll)
{
    yScroll = _MIN (m_yScrollMax, _MAX (m_yScrollMin, yScroll));

    if (m_yScroll != yScroll)
    {
        int dy = m_yScroll - yScroll;
        m_yScroll = yScroll;

        ScrollWindow (0, dy);
        UpdateScrollSizes();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\msimodul.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       msimodul.h
//
//--------------------------------------------------------------------------

// msimodl.h : header file for class CMsiModule
//

#ifndef __MSIMODL_H__
#define __MSIMODL_H__ 

#include <msi.h>
#include <msiquery.h>

class CMsiModule
{
    typedef UINT (*EnumQualCompFncPtr)(LPTSTR, DWORD, LPTSTR, DWORD*, LPTSTR, DWORD*);
    typedef UINT (*ProvideQualCompFncPtr)(LPCTSTR, LPCTSTR, DWORD, LPTSTR, DWORD*);
    typedef UINT (*LocateCompFncPtr)(LPCTSTR, LPTSTR, DWORD*);

public:
    CMsiModule(void) : hMsiDll(NULL), pfnEnumQualComp(NULL), pfnProvideQualComp(NULL) 
    {
        hMsiDll = LoadLibrary(TEXT("msi.dll"));

        if (hMsiDll != NULL)
        {

	#ifdef _UNICODE
            pfnEnumQualComp = reinterpret_cast<EnumQualCompFncPtr>
                                (GetProcAddress(hMsiDll, "MsiEnumComponentQualifiersW"));
            ASSERT(pfnEnumQualComp != NULL);

            pfnProvideQualComp = reinterpret_cast<ProvideQualCompFncPtr>
                                    (GetProcAddress(hMsiDll, "MsiProvideQualifiedComponentW"));
            ASSERT(pfnProvideQualComp != NULL);

            pfnLocateComp = reinterpret_cast<LocateCompFncPtr>
                                    (GetProcAddress(hMsiDll, "MsiLocateComponentW"));
            ASSERT(pfnLocateComp != NULL); 
	#else
            pfnEnumQualComp = reinterpret_cast<EnumQualCompFncPtr>
                                (GetProcAddress(hMsiDll, "MsiEnumComponentQualifiersA"));
            ASSERT(pfnEnumQualComp != NULL);

            pfnProvideQualComp = reinterpret_cast<ProvideQualCompFncPtr>
                                    (GetProcAddress(hMsiDll, "MsiProvideQualifiedComponentA"));
            ASSERT(pfnProvideQualComp != NULL);

            pfnLocateComp = reinterpret_cast<LocateCompFncPtr>
                                    (GetProcAddress(hMsiDll, "MsiLocateComponentA"));
            ASSERT(pfnLocateComp != NULL); 

	#endif // _UNICODE

       }
    }
    
    ~CMsiModule(void) { if (hMsiDll != NULL) FreeLibrary(hMsiDll); }

    BOOL IsPresent(void) { return (hMsiDll != NULL); }

    UINT EnumComponentQualifiers( LPTSTR szComponent, DWORD iIndex, 
                                     LPTSTR lpQualifierBuf, DWORD *pcchQualifierBuf,  
                                     LPTSTR lpApplicationDataBuf, DWORD *pcchApplicationDataBuf)
    {
        if (pfnEnumQualComp == NULL)
            return ERROR_CALL_NOT_IMPLEMENTED;

        return pfnEnumQualComp(szComponent, iIndex, lpQualifierBuf, pcchQualifierBuf,
                                 lpApplicationDataBuf, pcchApplicationDataBuf);
    }

    UINT ProvideQualifiedComponent( LPCTSTR szComponent, LPCTSTR szQualifier, DWORD dwInstallMode, 
                                       LPTSTR lpPathBuf, DWORD *pcchPathBuf)
    {
        if (pfnProvideQualComp == NULL)
            return ERROR_CALL_NOT_IMPLEMENTED;

        return pfnProvideQualComp(szComponent, szQualifier, dwInstallMode, lpPathBuf, pcchPathBuf);
    }

    UINT LocateComponent( LPCTSTR szComponent, LPTSTR lpPathBuf, DWORD *pcchPathBuf)
    {
        if (pfnLocateComp == NULL)
            return ERROR_CALL_NOT_IMPLEMENTED;

        return pfnLocateComp(szComponent, lpPathBuf, pcchPathBuf);
    }
                                     
private:      
    HMODULE hMsiDll;
    EnumQualCompFncPtr pfnEnumQualComp;
    ProvideQualCompFncPtr pfnProvideQualComp;
    LocateCompFncPtr pfnLocateComp;

};


CMsiModule& MsiModule()
{
    static CMsiModule MsiModuleInstance;

    return MsiModuleInstance;
}


#endif // __MSIMODL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\msgview.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      msgview.h
 *
 *  Contents:  Interface file for CMessageView
 *
 *  History:   28-Apr-99 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef __MESSAGEVIEW_H_
#define __MESSAGEVIEW_H_

#include "tstring.h"


/////////////////////////////////////////////////////////////////////////////
// CMessageView
class ATL_NO_VTABLE CMessageView :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CMessageView, &CLSID_MessageView>,
    public CComControl<CMessageView>,
	public IMessageView,
    public IPersistStreamInitImpl<CMessageView>,
    public IOleControlImpl<CMessageView>,
    public IOleObjectImpl<CMessageView>,
    public IOleInPlaceActiveObjectImpl<CMessageView>,
    public IViewObjectExImpl<CMessageView>,
    public IOleInPlaceObjectWindowlessImpl<CMessageView>
{
public:
    CMessageView();
   ~CMessageView();

DECLARE_NOT_AGGREGATABLE(CMessageView)

DECLARE_MMC_OBJECT_REGISTRATION (
	g_szMmcndmgrDll,					// implementing DLL
    CLSID_MessageView,              	// CLSID
    _T("MessageView Class"),            // class name
    _T("MessageView.MessageView.1"),    // ProgID
    _T("MessageView.MessageView"))      // version-independent ProgID

BEGIN_COM_MAP(CMessageView)
    COM_INTERFACE_ENTRY(IMessageView)
    COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY_IMPL(IOleControl)
    COM_INTERFACE_ENTRY_IMPL(IOleObject)
    COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
END_COM_MAP()

BEGIN_PROPERTY_MAP(CMessageView)
    // Example entries
    // PROP_ENTRY("Property Description", dispid, clsid)
//  PROP_PAGE(CLSID_StockColorPage)
END_PROPERTY_MAP()


BEGIN_MSG_MAP(CMessageView)
    MESSAGE_HANDLER (WM_CREATE,         OnCreate)
    MESSAGE_HANDLER (WM_DESTROY,        OnDestroy)
    MESSAGE_HANDLER (WM_SIZE,           OnSize)
    MESSAGE_HANDLER (WM_SETTINGCHANGE,  OnSettingChange)
    MESSAGE_HANDLER (WM_KEYDOWN,        OnKeyDown)
    MESSAGE_HANDLER (WM_VSCROLL,        OnVScroll)
    MESSAGE_HANDLER (WM_MOUSEWHEEL,     OnMouseWheel)
	CHAIN_MSG_MAP (CComControl<CMessageView>)
END_MSG_MAP()

#define MESSAGE_HANDLER_FUNC(func)  LRESULT (func)(UINT msg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

    MESSAGE_HANDLER_FUNC (OnCreate);
    MESSAGE_HANDLER_FUNC (OnDestroy);
    MESSAGE_HANDLER_FUNC (OnSize);
    MESSAGE_HANDLER_FUNC (OnSettingChange);
    MESSAGE_HANDLER_FUNC (OnKeyDown);
    MESSAGE_HANDLER_FUNC (OnVScroll);
    MESSAGE_HANDLER_FUNC (OnMouseWheel);

    DECLARE_WND_CLASS_EX(NULL, CS_HREDRAW, COLOR_WINDOW);

// IViewObjectEx
    STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
    {
        ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
        *pdwStatus = VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE;
        return S_OK;
    }

// IMessageView
    STDMETHOD(SetTitleText)(LPCOLESTR pszTitleText);
    STDMETHOD(SetBodyText)(LPCOLESTR pszBodyText);
    STDMETHOD(SetIcon)(IconIdentifier id);
    STDMETHOD(Clear)();


public:
    HRESULT OnDraw(ATL_DRAWINFO& di);

private:
    void RecalcLayout();
    void RecalcIconLayout();
    void RecalcTitleLayout();
    void RecalcBodyLayout();
	void UpdateSystemMetrics();

    struct TextElement;
    void DrawTextElement (HDC hdc, TextElement& te, DWORD dwFlags = 0);
    int CalcTextElementHeight (const TextElement& te, int cx);
    HRESULT SetTextElement (TextElement& te, LPCOLESTR pszNewText);

    void CreateFonts ();
    void DeleteFonts ();

	void VertScroll (int nScrollCmd, int nScrollPos, int nRepeat);
    void ScrollToPosition (int yScroll);
    void UpdateScrollSizes ();

    int GetOverallHeight() const
        { return (m_TextElement[Body].rect.bottom + m_sizeMargin.cy); }


private:
    enum { Title, Body, ElementCount };

    struct TextElement
    {
        TextElement() : rect (0,0,0,0) {}

        tstring		str;
        WTL::CFont	font;
        WTL::CRect	rect;
    };

    TextElement m_TextElement[ElementCount];

    HICON       m_hIcon;
    WTL::CRect  m_rectIcon;

    // for scrolling
    int         m_yScroll;
    int         m_yScrollMax;
    int         m_yScrollMin;
    int         m_cyPage;
    int         m_cyLine;
	int			m_nAccumulatedScrollDelta;		// for WM_MOUSEWHEEL processing

    WTL::CSize  m_sizeWindow;
    WTL::CSize	m_sizeIcon;
    WTL::CSize	m_sizeMargin;
};

#endif //__MESSAGEVIEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\multisel.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       multisel.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "objfmts.h"
#include "multisel.h"
#include "nmutil.h"
#include "regutil.h"
#include "copypast.h"
#include "dbg.h"
#include "rsltitem.h"

DEBUG_DECLARE_INSTANCE_COUNTER(CSnapinSelData);
DEBUG_DECLARE_INSTANCE_COUNTER(CSnapinSelDataList);

UINT GetRelation(CMTNode* pMTNodeSrc, CMTNode* pMTNodeDest);

CLIPFORMAT GetMultiSelectSnapinsCF()
{
    static CLIPFORMAT s_cf = 0;
    if (s_cf == 0)
    {
        USES_CONVERSION;
        s_cf = (CLIPFORMAT) RegisterClipboardFormat(W2T(CCF_MULTI_SELECT_SNAPINS));
    }

    return s_cf;
}

CLIPFORMAT GetMultiSelectStaticDataCF()
{
    static CLIPFORMAT s_cf = 0;
    if (s_cf == 0)
    {
        USES_CONVERSION;
        s_cf = (CLIPFORMAT) RegisterClipboardFormat(W2T(CCF_MULTI_SELECT_STATIC_DATA));
    }

    return s_cf;
}

CLIPFORMAT GetMultiSelObjectTypesCF()
{
    static CLIPFORMAT s_cf = 0;
    if (s_cf == 0)
    {
        USES_CONVERSION;
        s_cf = (CLIPFORMAT) RegisterClipboardFormat(W2T(CCF_OBJECT_TYPES_IN_MULTI_SELECT));
    }

    return s_cf;
}

CLIPFORMAT GetMMCMultiSelDataObjectCF()
{
    static CLIPFORMAT s_cf = 0;
    if (s_cf == 0)
    {
        USES_CONVERSION;
        s_cf = (CLIPFORMAT) RegisterClipboardFormat(W2T(CCF_MMC_MULTISELECT_DATAOBJECT));
    }

    return s_cf;
}

CLIPFORMAT GetMMCDynExtensionsCF()
{
    static CLIPFORMAT s_cf = 0;
    if (s_cf == 0)
    {
        USES_CONVERSION;
        s_cf = (CLIPFORMAT) RegisterClipboardFormat(W2T(CCF_MMC_DYNAMIC_EXTENSIONS));
    }

    return s_cf;
}

HRESULT
DataObject_GetHGLOBALData(
    IDataObject* piDataObject,
    CLIPFORMAT cfClipFormat,
    HGLOBAL* phGlobal)
{
    ASSERT(piDataObject != NULL);
    ASSERT(phGlobal != NULL);
    if (piDataObject == NULL || phGlobal == NULL)
        return E_INVALIDARG;

    FORMATETC fmt = {cfClipFormat, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM stgm = {TYMED_HGLOBAL, NULL, NULL};

    HRESULT hr = piDataObject->GetData(&fmt, &stgm);

    if (SUCCEEDED(hr) && (stgm.tymed == TYMED_HGLOBAL) && (stgm.hGlobal != NULL))
    {
        *phGlobal = stgm.hGlobal;
    }
    else
    {
        ReleaseStgMedium(&stgm);
        if (SUCCEEDED(hr))
            hr = (stgm.tymed != TYMED_HGLOBAL) ? DV_E_TYMED : E_UNEXPECTED;
    }

    return hr;
}

DEBUG_DECLARE_INSTANCE_COUNTER(CMultiSelectDataObject);

CMultiSelectDataObject::~CMultiSelectDataObject()
{
    if (m_pMS)
        m_pMS->Release();

    if (m_ppDataObjects != NULL)
    {
        delete [] m_ppDataObjects;
    }

    DEBUG_DECREMENT_INSTANCE_COUNTER(CMultiSelectDataObject);
}

STDMETHODIMP
CMultiSelectDataObject::GetData(
    FORMATETC*  pfmt,
    STGMEDIUM*  pmedium)
{
    if (m_ppDataObjects == NULL && m_ppMTNodes == NULL)
        return HRESULT_FROM_WIN32(ERROR_TIMEOUT);

    pmedium->hGlobal = NULL; // init

    if (pfmt->tymed & TYMED_HGLOBAL)
    {
        if (pfmt->cfFormat == GetMultiSelectSnapinsCF())
        {
            UINT size = sizeof(DWORD) + m_count * sizeof(LPDATAOBJECT);
            pmedium->hGlobal = ::GlobalAlloc(GPTR, size);
            SMMCDataObjects* pData =
                reinterpret_cast<SMMCDataObjects*>(pmedium->hGlobal);
            if (pData == NULL)
                return E_OUTOFMEMORY;

            pData->count = m_count;
            for (UINT i=0; i<m_count; ++i)
            {
                pData->lpDataObject[i] = m_ppDataObjects[i];
            }
        }
        else if (pfmt->cfFormat == GetMultiSelectStaticDataCF())
        {
            ASSERT(m_nSize >= 0);
            typedef CMTNode* _PMTNODE;

            // m_ppDataObjects  m_count
            UINT cb = sizeof(DWORD) + sizeof(_PMTNODE) * m_nSize;
            pmedium->hGlobal = ::GlobalAlloc(GPTR, cb);

            BYTE* pb = reinterpret_cast<BYTE*>(pmedium->hGlobal);
            if (pb == NULL)
                return E_OUTOFMEMORY;

            *((DWORD*)pb) = m_nSize;

            if (m_nSize > 0)
            {
                pb += sizeof(DWORD);
                _PMTNODE* ppMTNodes = (_PMTNODE*)pb;
                CopyMemory(ppMTNodes, m_ppMTNodes, m_nSize * sizeof(_PMTNODE));
            }
        }
        else if (pfmt->cfFormat == GetMMCMultiSelDataObjectCF())
        {
            pmedium->hGlobal = ::GlobalAlloc(GPTR, sizeof(DWORD));
            if (pmedium->hGlobal == NULL)
                return E_OUTOFMEMORY;

            *((DWORD*)pmedium->hGlobal) = 1;
        }
        else
        {
            pmedium->tymed = TYMED_NULL;
            pmedium->hGlobal = NULL;
            pmedium->pUnkForRelease = NULL;

            return DATA_E_FORMATETC;
        }

        if (pmedium->hGlobal != NULL)
        {
            pmedium->tymed          = TYMED_HGLOBAL;
            pmedium->pUnkForRelease = NULL;

            return S_OK;
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }

    return DV_E_TYMED;
}

STDMETHODIMP
CMultiSelectDataObject::GetDataHere(
    FORMATETC*  pfmt,
    STGMEDIUM*  pmedium)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CMultiSelectDataObject::EnumFormatEtc(
    DWORD dwDirection,
    IEnumFORMATETC **ppenumFormatEtc)
{
    if (m_ppDataObjects == NULL && m_ppMTNodes == NULL)
        return HRESULT_FROM_WIN32(ERROR_TIMEOUT);

    if (dwDirection == DATADIR_SET)
        return E_FAIL;

    FORMATETC fmte[] = {
        {GetMultiSelectSnapinsCF(), NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
        {GetMMCMultiSelDataObjectCF(), NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
    };

    HRESULT hr = ::GetObjFormats(countof(fmte), fmte, (void**)ppenumFormatEtc);

    return hr;
}

STDMETHODIMP CMultiSelectDataObject::QueryGetData(LPFORMATETC pfmt)
{
    if (m_ppDataObjects == NULL && m_ppMTNodes == NULL)
        return HRESULT_FROM_WIN32(ERROR_TIMEOUT);

    //
    //  Check the aspects we support.
    //

    if (!(DVASPECT_CONTENT & pfmt->dwAspect))
        return DATA_E_FORMATETC;

    ASSERT(GetMultiSelectSnapinsCF() != 0);

    if (pfmt->cfFormat == GetMMCMultiSelDataObjectCF() ||
        pfmt->cfFormat == GetMultiSelectSnapinsCF())
        return S_OK;

    return S_FALSE;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


void CSnapinSelDataList::Add(CSnapinSelData& snapinSelData, BOOL bStaticNode)
{
    BOOL bCreateNew = TRUE;

    if (bStaticNode == FALSE &&
        snapinSelData.GetID() != TVOWNED_MAGICWORD)
    {
        POSITION pos = GetHeadPosition();

        while (pos)
        {
            CSnapinSelData* pSnapinSelData = GetNext(pos);
            if (pSnapinSelData->GetID() == snapinSelData.GetID())
            {
                pSnapinSelData->IncrementNumOfItems();
                pSnapinSelData->AddScopeNodes( snapinSelData.GetScopeNodes() );
                bCreateNew = FALSE;
                break;
            }
        }
    }

    if (bCreateNew == TRUE)
    {
        CSnapinSelData* pSnapinSelData = new CSnapinSelData;
        pSnapinSelData->SetNumOfItems(snapinSelData.GetNumOfItems());
        pSnapinSelData->AddScopeNodes(snapinSelData.GetScopeNodes());
        pSnapinSelData->SetIsScopeItem(snapinSelData.IsScopeItem());
        pSnapinSelData->SetCookie(snapinSelData.GetCookie());
        pSnapinSelData->SetID(snapinSelData.GetID());
        pSnapinSelData->SetSnapIn(snapinSelData.GetSnapIn());

        AddHead(pSnapinSelData);
    }
}


DEBUG_DECLARE_INSTANCE_COUNTER(CMultiSelection);

CMultiSelection::CMultiSelection(CNode* pNode)
    :   m_pNode(pNode), m_pMTSINode(NULL), m_bHasNodes(FALSE),
        m_pSINode(dynamic_cast<CSnapInNode*>(pNode)),
        m_bInUse(FALSE), m_cRef(1)
{
    ASSERT(pNode != NULL);

#ifdef DBG
    m_bInit = FALSE;
#endif

    DEBUG_INCREMENT_INSTANCE_COUNTER(CMultiSelection);
}

CMultiSelection::~CMultiSelection()
{
    ASSERT(m_bInUse == FALSE);

    if (m_spDataObjectMultiSel != NULL)
    {
        CMultiSelectDataObject* pObj =
            dynamic_cast<CMultiSelectDataObject*>(
                static_cast<IDataObject*>(m_spDataObjectMultiSel));
        ASSERT(pObj != NULL);
        if (pObj)
            pObj->SetDataObjects(NULL, 0);
    }

    DEBUG_DECREMENT_INSTANCE_COUNTER(CMultiSelection);
}

HRESULT CMultiSelection::Init()
{
#ifdef DBG
    m_bInit = TRUE;
#endif
    // compute m_pSINode, m_pMTSINode, m_pszExtensionTypeKey

    if (m_pNode != NULL)
    {
        if (m_pSINode == NULL)
            m_pSINode = m_pNode->GetStaticParent();

        ASSERT(m_pMTSINode == NULL);
        ASSERT(m_pNode->GetMTNode() != NULL);
        if (m_pNode->GetMTNode() == NULL)
            return E_UNEXPECTED;

        m_pMTSINode = m_pNode->GetMTNode()->GetStaticParent();
        ASSERT(m_pMTSINode != NULL);
        if (m_pMTSINode == NULL)
            return E_UNEXPECTED;
    }

    return S_OK;
}

bool CMultiSelection::RemoveStaticNode(CMTNode* pMTNode)
{
    int iMax = m_rgStaticNodes.size()-1;
    if (iMax < 0)
        return false;

    if (::GetRelation(pMTNode, m_rgStaticNodes[0]) == 2)
    {
        m_rgStaticNodes.clear();
        return m_snapinSelDataList.IsEmpty();
    }

    for (int i=iMax; i >= 0; --i)
    {
        if (m_rgStaticNodes[i] == pMTNode)
        {
            CMTNodePtrArray::iterator iter = m_rgStaticNodes.begin();
            std::advance(iter, iMax);
            m_rgStaticNodes[i] = m_rgStaticNodes[iMax];
            m_rgStaticNodes.erase(iter);
            break;
        }
    }

    return m_rgStaticNodes.size();
}


CComponent* CMultiSelection::_GetComponent(CSnapinSelData* pSnapinSelData)
{
    CComponent* pCC = NULL;

    if ((pSnapinSelData->GetNumOfItems() > 1) ||
        (pSnapinSelData->GetID() > 0) ||
        (pSnapinSelData->IsScopeItem() == FALSE))
    {
        CSnapInNode* pSINode = _GetStaticNode();
        if (pSINode == NULL)
            return NULL;

        pCC = pSINode->GetComponent(pSnapinSelData->GetID());
        ASSERT(pCC != NULL);
    }
    else
    {
        ASSERT(pSnapinSelData->IsScopeItem() == TRUE);

        CNode* pNode = CNode::FromHandle ((HNODE) pSnapinSelData->GetCookie());
        ASSERT(pNode != NULL);
        if (pNode != NULL)
            pCC = pNode->GetPrimaryComponent();
    }

    return pCC;
}

HRESULT CMultiSelection::_ComputeSelectionDataList()
{
#ifdef DBG
    ASSERT(m_bInit == TRUE);
#endif

    ASSERT(m_pNode != NULL);
    ASSERT(m_pNode->GetViewData() != NULL);

    HWND hwnd = m_pNode->GetViewData() ?
                    m_pNode->GetViewData()->GetListCtrl() : NULL;

    ASSERT(hwnd != NULL);
    if (hwnd == NULL)
        return E_UNEXPECTED;

    ASSERT(::IsWindow(hwnd));
    if (!(::IsWindow(hwnd)))
        return E_UNEXPECTED;

    if (m_pNode->GetViewData()->IsVirtualList() == TRUE)
    {
        CSnapinSelData snapinSelData;
        snapinSelData.SetID(m_pNode->GetPrimaryComponent()->GetComponentID());
        snapinSelData.SetNumOfItems(ListView_GetSelectedCount(hwnd));
        if (snapinSelData.GetNumOfItems() == 1)
            snapinSelData.SetCookie(ListView_GetNextItem(hwnd, -1, LVIS_SELECTED));

        m_snapinSelDataList.Add(snapinSelData, FALSE);
    }
    else
    {
        int iSel = ListView_GetNextItem(hwnd, -1, LVIS_SELECTED);
        if (iSel < 0)
            return S_FALSE;

        for (; iSel >= 0; iSel = ListView_GetNextItem(hwnd, iSel, LVIS_SELECTED))
        {
            LPARAM lParam = ListView_GetItemData(hwnd, iSel);
            CResultItem* pri = CResultItem::FromHandle(lParam);
            ASSERT(pri != NULL);
            if (pri == NULL)
                return E_FAIL;

            CSnapinSelData snapinSelData;
            snapinSelData.SetID(pri->GetOwnerID());
            snapinSelData.IncrementNumOfItems();
            snapinSelData.SetCookie(pri->GetSnapinData());

            BOOL bStaticNode = FALSE;
            if (pri->IsScopeItem())
            {
                CNode* pNodeContext = CNode::FromResultItem (pri);
                ASSERT(pNodeContext != NULL);
                if (pNodeContext->IsInitialized() == FALSE)
                {
                    HRESULT hr = pNodeContext->InitComponents();
                    ASSERT(SUCCEEDED(hr));
                    if (FAILED(hr))
                    {
                        m_rgStaticNodes.clear();
                        m_snapinSelDataList.RemoveAll();
                        return hr;
                    }
                }

                // its a scope node - store to scope node array for this data object
                snapinSelData.AddScopeNodes(CSnapinSelData::CNodePtrArray(1, pNodeContext));

                m_bHasNodes = TRUE;
                snapinSelData.SetID(::GetComponentID(NULL, pri));
                snapinSelData.SetIsScopeItem(TRUE);

                if (snapinSelData.GetID() == TVOWNED_MAGICWORD)
                {
                    ASSERT(pNodeContext->GetMTNode() != NULL);
                    m_rgStaticNodes.push_back(pNodeContext->GetMTNode());
                    continue;
                }

                if (snapinSelData.GetID() == 0)
                {
                    ASSERT(pri->IsScopeItem());
                    bStaticNode = pNodeContext->IsStaticNode();

                    if (bStaticNode)
                    {
                        ASSERT(pNodeContext->GetMTNode() != NULL);
                        m_rgStaticNodes.push_back(pNodeContext->GetMTNode());
                    }
                }
            }

            // Add to the list
            m_snapinSelDataList.Add(snapinSelData, bStaticNode);
        }
    }

    POSITION pos = m_snapinSelDataList.GetHeadPosition();
    HRESULT hr = S_OK;

    while (pos)
    {
        CSnapinSelData* pSnapinSelData = m_snapinSelDataList.GetNext(pos);

        if (pSnapinSelData->GetNumOfItems() == 1)
        {
            // Get object type for single snapin item sel
            hr = _GetObjectTypeForSingleSel(pSnapinSelData);
            if (FAILED(hr))
                return hr;
        }
        else if (pSnapinSelData->GetNumOfItems() > 1)
        {
            // Get object type(s) for multiple snapin items sel
            hr = _GetObjectTypesForMultipleSel(pSnapinSelData);
            if (FAILED(hr))
                return hr;
        }
    }

    return hr;
}


HRESULT
CMultiSelection::_GetObjectTypeForSingleSel(
    CSnapinSelData* pSnapinSelData)
{
    ASSERT(pSnapinSelData->GetNumOfItems() == 1);

    if (m_pNode->GetViewData()->IsVirtualList() == FALSE)
    {
        ASSERT(pSnapinSelData->GetCookie() != 0);

        if (pSnapinSelData->GetNumOfItems() != 1 ||
            pSnapinSelData->GetCookie() == 0)
            return E_INVALIDARG;
    }

    HRESULT         hr = S_OK;
    IDataObjectPtr  spDO;

    CComponent* pCC = _GetComponent(pSnapinSelData);
    if (pCC == NULL)
        return E_UNEXPECTED;

    if (pSnapinSelData->GetID() == TVOWNED_MAGICWORD)
    {
        ASSERT(pSnapinSelData->IsScopeItem() == TRUE);
    }
    else if (pSnapinSelData->IsScopeItem() == TRUE)
    {
        CNode* pNode = CNode::FromHandle ((HNODE) pSnapinSelData->GetCookie());
        ASSERT(pNode != NULL);
        if (pNode == NULL)
            return E_FAIL;

        CComponentData* pCCD = NULL;

        if (pNode->IsStaticNode())
        {
            CMTNode* pMTNode = pNode->GetMTNode();
            ASSERT(pMTNode != NULL);
            if (pMTNode == NULL)
                return E_FAIL;

            pCCD = pMTNode->GetPrimaryComponentData();
        }
        else
        {
            CMTSnapInNode* pMTSINode = _GetStaticMasterNode();
            ASSERT(pMTSINode != NULL);
            if (pMTSINode == NULL)
                return E_UNEXPECTED;

            pCCD = pMTSINode->GetComponentData(pSnapinSelData->GetID());
        }

        ASSERT(pCCD != NULL);
        if (pCCD == NULL)
            return E_UNEXPECTED;

        hr = pCCD->QueryDataObject(pNode->GetUserParam(), CCT_SCOPE, &spDO);
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
            return hr;

        pSnapinSelData->SetSnapIn(pCCD->GetSnapIn());
    }
    else
    {
        hr = pCC->QueryDataObject(pSnapinSelData->GetCookie(), CCT_RESULT, &spDO);
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
            return hr;

        pSnapinSelData->SetSnapIn(pCC->GetSnapIn());
    }

    do // not a loop
    {
        if (pCC == NULL)
            break;

        pSnapinSelData->SetComponent(pCC);

        IFramePrivate* pIFP = pCC->GetIFramePrivate();
        ASSERT(pIFP != NULL);
        if (pIFP == NULL)
            break;

        IConsoleVerbPtr spConsoleVerb;
        hr = pIFP->QueryConsoleVerb(&spConsoleVerb);

        if (SUCCEEDED(hr))
        {
            ASSERT(spConsoleVerb != NULL);
            pSnapinSelData->SetConsoleVerb(spConsoleVerb);

            CConsoleVerbImpl* pCVI = dynamic_cast<CConsoleVerbImpl*>(
                                static_cast<IConsoleVerb*>(spConsoleVerb));
            ASSERT(pCVI != NULL);
            if (pCVI)
                pCVI->SetDisabledAll();
        }

        Dbg(DEB_USER1, _T("MMCN_SELECT> MS-1 \n"));
        pCC->Notify(spDO, MMCN_SELECT, MAKELONG((WORD)FALSE, (WORD)TRUE), 0);

    } while (0);

    GUID guid;
    hr = ExtractObjectTypeGUID(spDO, &guid);
    ASSERT(SUCCEEDED(hr));

    if (SUCCEEDED(hr))
    {
        pSnapinSelData->SetDataObject(spDO);
        pSnapinSelData->AddObjectType(guid);
    }

    return hr;
}

HRESULT
CMultiSelection::_GetObjectTypesForMultipleSel(
    CSnapinSelData* pSnapinSelData)
{
    ASSERT(m_pSINode != NULL);
    ASSERT(m_pMTSINode != NULL);

    ASSERT(pSnapinSelData != NULL);
    if (pSnapinSelData == NULL)
        return E_POINTER;

    CComponent* pCC = _GetComponent(pSnapinSelData);
    if (pCC == NULL)
        return E_UNEXPECTED;

    pSnapinSelData->SetSnapIn(pCC->GetSnapIn());

    IDataObjectPtr  spDO;
    HRESULT hr = pCC->QueryDataObject(MMC_MULTI_SELECT_COOKIE,
                                      CCT_UNINITIALIZED, &spDO);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;

    do // not a loop
    {
        if (pCC == NULL)
            break;

        pSnapinSelData->SetComponent(pCC);

        IFramePrivate* pIFP = pCC->GetIFramePrivate();
        ASSERT(pIFP != NULL);
        if (pIFP == NULL)
            break;

        IConsoleVerbPtr spConsoleVerb;
        hr = pIFP->QueryConsoleVerb(&spConsoleVerb);

        if (SUCCEEDED(hr))
        {
            ASSERT(spConsoleVerb != NULL);
            pSnapinSelData->SetConsoleVerb(spConsoleVerb);

            CConsoleVerbImpl* pCVI = dynamic_cast<CConsoleVerbImpl*>(
                                static_cast<IConsoleVerb*>(spConsoleVerb));
            ASSERT(pCVI != NULL);
            if (pCVI)
                pCVI->SetDisabledAll();
        }

        Dbg(DEB_USER1, _T("MMCN_SELECT> MS-2 \n"));
        pCC->Notify(spDO, MMCN_SELECT, MAKELONG((WORD)FALSE, (WORD)TRUE), 0);

    } while (0);

    if (spDO == NULL)
        return E_UNEXPECTED;

    // Get the data
    HGLOBAL hGlobal = NULL;
    hr = DataObject_GetHGLOBALData(spDO, GetMultiSelObjectTypesCF(),
                                   &hGlobal);
    if (FAILED(hr))
        return hr;

    BYTE* pb = reinterpret_cast<BYTE*>(::GlobalLock(hGlobal));
    DWORD count = *((DWORD*)pb);
    pb += sizeof(DWORD);
    GUID* pGuid = reinterpret_cast<GUID*>(pb);

    for (DWORD index=0; index < count; ++index)
    {
        pSnapinSelData->AddObjectType(pGuid[index]);
    }

    ::GlobalUnlock(hGlobal);
    ::GlobalFree(hGlobal);

    pSnapinSelData->SetDataObject(spDO);

    return S_OK;
}

HRESULT
CMultiSelection::GetMultiSelDataObject(
    IDataObject** ppDataObject)
{
    if (m_spDataObjectMultiSel == NULL)
    {
        HRESULT hr = S_OK;

        if (HasData() == FALSE)
        {
            hr = _ComputeSelectionDataList();
            if (FAILED(hr))
                return hr;

            ASSERT(HasData() == TRUE);
            if (HasData() == FALSE)
                return E_FAIL;
        }

        // CreateDataObjectForMultiSelection
        CComObject<CMultiSelectDataObject>* pMSDObject;
        hr = CComObject<CMultiSelectDataObject>::CreateInstance(&pMSDObject);
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
            return hr;

        ASSERT(pMSDObject != NULL);
        if (pMSDObject == NULL)
            return E_FAIL;

        pMSDObject->SetMultiSelection(this);

        UINT count = m_snapinSelDataList.GetCount();
        if (count > 0)
        {
            LPDATAOBJECT* ppDOs = new LPDATAOBJECT[count];
            POSITION pos = m_snapinSelDataList.GetHeadPosition();

            for (int i=0; pos; ++i)
            {
                CSnapinSelData* pSnapinSelData = m_snapinSelDataList.GetNext(pos);
                ASSERT(pSnapinSelData != NULL);
                ASSERT(i < count);
                ppDOs[i] = pSnapinSelData->GetDataObject();
                ASSERT(ppDOs[i] != NULL);
            }

            pMSDObject->SetDataObjects(ppDOs, count);
        }
        int nSize = m_rgStaticNodes.size();
        if (nSize > 0)
        {
            pMSDObject->SetStaticNodes(m_rgStaticNodes, nSize);
        }

        m_spDataObjectMultiSel = pMSDObject;
    }

    *ppDataObject = m_spDataObjectMultiSel;
    m_spDataObjectMultiSel.AddRef();
    return S_OK;
}

HRESULT
CMultiSelection::GetExtensionSnapins(
    LPCTSTR pszExtensionTypeKey,
    CList<GUID, GUID&>& extnClsidList)
{
    DECLARE_SC(sc, TEXT("CMultiSelection::GetExtensionSnapins"));

    ASSERT(&extnClsidList != NULL);

    extnClsidList.RemoveAll(); //init

    HRESULT hr = S_OK;

    if (HasData() == FALSE)
    {
        hr = _ComputeSelectionDataList();
        if (FAILED(hr))
            return hr;

        if (hr == S_FALSE)
            return hr;

        ASSERT(HasData() == TRUE);
        if (HasData() == FALSE)
            return E_FAIL;
    }

    if (HasSnapinData() == FALSE)
        return S_FALSE;

    //
    // Add the extension snapin clsids for the first object type
    // to extnClsidList.
    //
    {
        CSnapinSelData* pSnapinSelData = m_snapinSelDataList.GetHead();

        CList<GUID, GUID&>& objTypeGuidsList = pSnapinSelData->GetObjectTypeGuidList();
        ASSERT(objTypeGuidsList.IsEmpty() == FALSE);
        if (objTypeGuidsList.IsEmpty() == TRUE)
            return E_FAIL;

        // Get dynamic extensions requested by the snap-in
        CArray<GUID, GUID&> DynExtens;
        ExtractDynExtensions(pSnapinSelData->GetDataObject(), DynExtens);

        POSITION pos = objTypeGuidsList.GetHeadPosition();
        BOOL bFirstTime = TRUE;

        while (pos)
        {
            GUID& objectTypeGuid = objTypeGuidsList.GetNext(pos);

            CExtensionsIterator it;
            sc = it.ScInitialize(pSnapinSelData->GetSnapIn(), objectTypeGuid, pszExtensionTypeKey, DynExtens.GetData(), DynExtens.GetSize());
            if (sc)
                return hr;

            if (bFirstTime == TRUE)
            {
                bFirstTime = FALSE;

                for (; it.IsEnd() == FALSE; it.Advance())
                {
                    extnClsidList.AddHead(const_cast<GUID&>(it.GetCLSID()));
                }
            }
            else
            {
                CArray<CLSID, CLSID&> rgClsid;
                for (; it.IsEnd() == FALSE; it.Advance())
                {
                    rgClsid.Add(const_cast<CLSID&>(it.GetCLSID()));
                }

                POSITION pos = extnClsidList.GetHeadPosition();
                POSITION posCurr = 0;
                while (pos)
                {
                    posCurr = pos;
                    CLSID& clsid = extnClsidList.GetNext(pos);
                    BOOL bPresent = FALSE;
                    for (int k=0; k <= rgClsid.GetUpperBound(); ++k)
                    {
                        if (::IsEqualCLSID(rgClsid[k], clsid) == TRUE)
                        {
                            bPresent = TRUE;
                            break;
                        }
                    }

                    if (bPresent == FALSE)
                    {
                        // Remove from list
                        ASSERT(posCurr != 0);
                        extnClsidList.RemoveAt(posCurr);
                    }
                } // end while
            } // end else

            // No point continuing if the extension clsid list is empty.
            if (extnClsidList.IsEmpty() == TRUE)
                break;
        }
    }


    if (extnClsidList.IsEmpty() == TRUE)
        return S_FALSE;

    // If only items from one snapin were selected return.
    if (m_snapinSelDataList.GetCount() == 1)
        return S_OK;


    // loop through the extension clsids
    POSITION pos = extnClsidList.GetHeadPosition();
    while (pos)
    {
        // Get the first extension clsid
        POSITION posCurr = pos;
        CLSID& clsidSnapin = extnClsidList.GetNext(pos);

        // See if this clsid extends selected items put up by other snapins.
        BOOL bExtends = FALSE;
        POSITION posSDL = m_snapinSelDataList.GetHeadPosition();
        m_snapinSelDataList.GetNext(posSDL); // skip the first one.

        while (posSDL)
        {
            CSnapinSelData* pSnapinSelData = m_snapinSelDataList.GetNext(posSDL);
            CList<GUID, GUID&>& objTypeGuidsList = pSnapinSelData->GetObjectTypeGuidList();

            // Get dynamic extensions requested by the snap-in
            CArray<GUID, GUID&> DynExtens;
            ExtractDynExtensions(pSnapinSelData->GetDataObject(), DynExtens);

            POSITION pos2 = objTypeGuidsList.GetHeadPosition();
            while (pos2)
            {
                bExtends = FALSE; // re-init

                GUID& guidObjectType = objTypeGuidsList.GetNext(pos2);

                CExtensionsIterator it;
                sc = it.ScInitialize(pSnapinSelData->GetSnapIn(), guidObjectType, pszExtensionTypeKey, DynExtens.GetData(), DynExtens.GetSize());
                if (sc)
                    break;

                for (; it.IsEnd() == FALSE; it.Advance())
                {
                    if (::IsEqualCLSID(clsidSnapin, it.GetCLSID()) == TRUE)
                    {
                        bExtends = TRUE;
                        break;
                    }
                }

                if (bExtends == FALSE)
                    break;
            }

            if (bExtends == FALSE)
                break;
        }

        ASSERT(posCurr != 0);
        if (bExtends == FALSE)
            extnClsidList.RemoveAt(posCurr);
    }

    return S_OK;
}

BOOL CMultiSelection::IsAnExtensionSnapIn(const CLSID& rclsid)
{
    POSITION pos = m_snapinSelDataList.GetHeadPosition();
    while (pos)
    {
        CSnapinSelData* pSSD = m_snapinSelDataList.GetNext(pos);
        ASSERT(pSSD != NULL);
        if (pSSD->GetSnapIn() != NULL &&
            ::IsEqualCLSID(rclsid, pSSD->GetSnapIn()->GetSnapInCLSID()))
        {
            return TRUE;
        }
    }

    return FALSE;
}

//+-------------------------------------------------------------------
//
//  Member:      CMultiSelection::ScVerbInvoked
//
//  Synopsis:    A verb was invoked, inform the snapin about invocation.
//
//  Arguments:   [verb] - that is invoked.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CMultiSelection::ScVerbInvoked (MMC_CONSOLE_VERB verb)
{
    DECLARE_SC(sc, _T("CMultiSelection::ScVerbInvoked"));

    /*
     * If you make any modifications do not forget to Release
     * the ref as shown below.
     */
    AddRef();
    sc = _ScVerbInvoked(verb);
    Release();

    if (sc)
        return sc;
    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CMultiSelection::_ScVerbInvoked
//
//  Synopsis:    A verb was invoked, inform the snapin about invocation.
//
//  Arguments:   [verb] - that is invoked.
//
//  Returns:     SC
//
//  Note:        We handle only Delete & Print. If you want to handle
//               any other notifications, make sure the IComponent::Notify
//               gets right arg & param values (they are unused for Delete & Print).
//
//--------------------------------------------------------------------
SC CMultiSelection::_ScVerbInvoked (MMC_CONSOLE_VERB verb)
{
    DECLARE_SC(sc, _T("CMultiSelection::_ScVerbInvoked"));

    if (! HasSnapinData())
        return (sc = E_UNEXPECTED);

    MMC_NOTIFY_TYPE eNotifyCode;
    switch(verb)
    {
    case MMC_VERB_DELETE:
        eNotifyCode = MMCN_DELETE;
        break;

    case MMC_VERB_PRINT:
        eNotifyCode = MMCN_PRINT;
        break;

    default:
        /*
         * We handle only Delete & Print. If you want to handle
         * any other notifications, make sure the IComponent::Notify
         * gets right arg & param values (they are unused for Delete & Print).
         */
        sc = E_INVALIDARG;
        return sc;
    }

    POSITION pos = m_snapinSelDataList.GetHeadPosition();
    while (pos)
    {
        BOOL bFlag = FALSE;
        CSnapinSelData* pSSD = m_snapinSelDataList.GetNext(pos);
        sc = ScCheckPointers(pSSD, E_UNEXPECTED);
        if (sc)
            return sc;

        IConsoleVerb *pConsoleVerb = pSSD->GetConsoleVerb();
        sc = ScCheckPointers(pConsoleVerb, E_UNEXPECTED);
        if (sc)
            return sc;

        pConsoleVerb->GetVerbState(verb, ENABLED, &bFlag);

        // If snapin did not enable verb for this item then skip it.
        if (!bFlag)
            continue;

        CComponent *pComponent = pSSD->GetComponent();
        sc = ScCheckPointers(pComponent, E_UNEXPECTED);
        if (sc)
            return sc;

        sc = pComponent->Notify( pSSD->GetDataObject(),
                                 eNotifyCode, 0, 0);

        // Trace & Ignore snapin returned errors.
        if (sc)
            sc.TraceAndClear();
    }

    return (sc);
}

bool IsMultiSelectDataObject(IDataObject* pdtobjCBSelData)
{
    if (!pdtobjCBSelData)
        return FALSE;

    FORMATETC fmt;
    ZeroMemory(&fmt, sizeof(fmt));
    fmt.dwAspect = DVASPECT_CONTENT;
    fmt.cfFormat = GetMMCMultiSelDataObjectCF();

    return (pdtobjCBSelData->QueryGetData(&fmt) == S_OK);
}



HRESULT ExtractDynExtensions(IDataObject* pdataObj, CGuidArray& arGuid)
{
    ASSERT(pdataObj != NULL);

    static CLIPFORMAT cfDynExtensions = 0;
    if (cfDynExtensions == 0)
    {
        USES_CONVERSION;
        cfDynExtensions = (CLIPFORMAT) RegisterClipboardFormat(W2T(CCF_MMC_DYNAMIC_EXTENSIONS));
        ASSERT(cfDynExtensions != 0);
    }

    // Get the data
    HGLOBAL hGlobal = NULL;
    HRESULT hr = DataObject_GetHGLOBALData(pdataObj, cfDynExtensions, &hGlobal);
    if (FAILED(hr))
        return hr;

    SMMCDynamicExtensions* pExtenData = reinterpret_cast<SMMCDynamicExtensions*>(::GlobalLock(hGlobal));
    ASSERT(pExtenData != NULL);

    for (DWORD index=0; index < pExtenData->count; ++index)
    {
        arGuid.Add(pExtenData->guid[index]);
    }

    ::GlobalUnlock(hGlobal);
    ::GlobalFree(hGlobal);

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:      CMultiSelection::ScIsVerbEnabledInclusively
//
//  Synopsis:    Is the given verb enabled under current multi-selection.
//               Should be used only if items from more than one snapin
//               is selected.
//               Inclusive means, bEnable will be true if any one snapin
//               enables given verb.
//
//
//  Arguments:   [mmcVerb]    - The verb to check.
//               [bEnable]    - Enabled or not, Return value.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CMultiSelection::ScIsVerbEnabledInclusively(MMC_CONSOLE_VERB mmcVerb, BOOL& bEnable)
{
    DECLARE_SC(sc, _T("CMultiSelection::ScIsVerbEnabledInclusively"));
    bEnable = false;

    if (IsSingleSnapinSelection())
        return (sc = E_UNEXPECTED);

    POSITION pos = m_snapinSelDataList.GetHeadPosition();
    while (pos)
    {
        CSnapinSelData* pSSD = m_snapinSelDataList.GetNext(pos);
        sc = ScCheckPointers(pSSD, E_UNEXPECTED);
        if (sc)
            return sc;

        IConsoleVerb *pConsoleVerb = pSSD->GetConsoleVerb();
        sc = ScCheckPointers(pConsoleVerb, E_UNEXPECTED);
        if (sc)
            return sc;

        sc = pConsoleVerb->GetVerbState(mmcVerb, ENABLED, &bEnable);
        if (sc)
            return sc;

        if (bEnable)
            return sc;
    }

    return (sc);
}

/***************************************************************************\
 *
 * METHOD:  CMultiSelection::ScGetSnapinDataObjects
 *
 * PURPOSE: Adds all contained data objects to CMMCClipBoardDataObject
 *
 * PARAMETERS:
 *    CMMCClipBoardDataObject *pResultObject [in] - container to add data objects
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMultiSelection::ScGetSnapinDataObjects(CMMCClipBoardDataObject *pResultObject)
{
    DECLARE_SC(sc, TEXT("CMultiSelection::ScGetSnapinDataObjects"));

    // for each snapin...
    POSITION pos = m_snapinSelDataList.GetHeadPosition();
    while (pos)
    {
        CSnapinSelData* pSSD = m_snapinSelDataList.GetNext(pos);
        sc = ScCheckPointers(pSSD, E_UNEXPECTED);
        if (sc)
            return sc;

        // get snapin data
        CComponent *pComponent = pSSD->GetComponent();
        IConsoleVerb *pConsoleVerb = pSSD->GetConsoleVerb();
        sc = ScCheckPointers(pComponent, pConsoleVerb, E_UNEXPECTED);
        if (sc)
            return sc;

        // get verbs
        bool bCopyEnabled = false;
        bool bCutEnabled = false;

        BOOL bEnable = FALSE;
        sc = pConsoleVerb->GetVerbState(MMC_VERB_COPY, ENABLED, &bEnable);
        bCopyEnabled = bEnable;
        if (sc)
            return sc;

        sc = pConsoleVerb->GetVerbState(MMC_VERB_CUT, ENABLED, &bEnable);
        bCutEnabled = bEnable;
        if (sc)
            return sc;

        // construct the array of scope nodes in this data object
        CSnapinSelData::CNodePtrArray nodes;

        // if regular result items exist - add active scope node
        if ( pSSD->GetNumOfItems() != pSSD->GetScopeNodes().size() )
            nodes.push_back(m_pNode);

        // add scope items from result pane
        nodes.insert( nodes.end(), pSSD->GetScopeNodes().begin(), pSSD->GetScopeNodes().end() );

        // add to the MMC DO
        sc = pResultObject->ScAddSnapinDataObject( nodes,
                                                   pComponent->GetIComponent(),
                                                   pSSD->GetDataObject(),
                                                   bCopyEnabled, bCutEnabled );
        if (sc)
            return sc;
    }

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\multisel.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       multisel.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    6/12/1997   RaviR   Created
//____________________________________________________________________________
//


#ifndef _MULTISEL_H_
#define _MULTISEL_H_

class CSnapIn;
class CNode;
class CSnapInNode;
class CMTSnapInNode;
class CMultiSelection;
class CComponent;
class CComponentPtrArray;
class CScopeTree;
class CMMCClipBoardDataObject;

// local classes
class CSnapinSelData;
class CSnapinSelDataList;
class CMultiSelectDataObject;


class CSnapinSelData
{
public:
    CSnapinSelData()
    :   m_nNumOfItems(0),
        m_lCookie(111),   // 0)
        m_bScopeItem(FALSE),
        m_ID(-1),
        m_pComponent(NULL),
        m_pSnapIn(NULL)
    {
        DEBUG_INCREMENT_INSTANCE_COUNTER(CSnapinSelData);
    }

    ~CSnapinSelData()
    {
        DEBUG_DECREMENT_INSTANCE_COUNTER(CSnapinSelData);
    }

    UINT GetNumOfItems() const
    {
        return m_nNumOfItems;
    }

    MMC_COOKIE GetCookie() const
    {
        return m_lCookie;
    }

    BOOL IsScopeItem() const
    {
        return m_bScopeItem;
    }

    void IncrementNumOfItems()
    {
        ++m_nNumOfItems;
    }

    void SetNumOfItems(UINT count)
    {
        m_nNumOfItems = count;
    }

    void SetCookie(MMC_COOKIE lCookie)
    {
        m_lCookie = lCookie;
    }

    void SetIsScopeItem(BOOL bScopeItem)
    {
        m_bScopeItem = bScopeItem;
    }

    void AddObjectType(GUID& guid)
    {
        m_objectTypeGuidList.AddHead(guid);
    }

    CList<GUID, GUID&>& GetObjectTypeGuidList()
    {
        return m_objectTypeGuidList;
    }

    void SetSnapIn(CSnapIn* pSnapIn)
    {
        m_pSnapIn = pSnapIn;
    }

    CSnapIn* GetSnapIn()
    {
        return m_pSnapIn;
    }

    COMPONENTID GetID()
    {
        return m_ID;
    }

    void SetID(COMPONENTID id)
    {
        m_ID = id;
    }

    void SetDataObject(IDataObject* pDO)
    {
        m_spDataObject = pDO;
    }

    IDataObject* GetDataObject()
    {
        ASSERT(m_spDataObject != NULL);
        return m_spDataObject;
    }

    void SetComponent(CComponent* pComponent)
    {
        ASSERT(m_pComponent == NULL);
        m_pComponent = pComponent;
    }

    CComponent* GetComponent()
    {
        ASSERT(m_pComponent != NULL);
        return m_pComponent;
    }

    void SetConsoleVerb(IConsoleVerb* pConsoleVerb)
    {
        m_spConsoleVerb = pConsoleVerb;
    }

    IConsoleVerb* GetConsoleVerb()
    {
        return m_spConsoleVerb;
    }


    // methods to access array of scope nodes included in multiselection
    // this data is particularly valuable, when data is put on clipboard
    // to be detect if contined data is affected by CNode being deleted
    typedef std::vector<CNode *> CNodePtrArray;

    void AddScopeNodes(const CNodePtrArray& nodes)  { m_vecScopeNodes.insert( m_vecScopeNodes.end(), nodes.begin(), nodes.end() ); }
    const CNodePtrArray& GetScopeNodes()            { return m_vecScopeNodes; }

private:
    UINT                m_nNumOfItems;
    BOOL                m_bScopeItem;
    MMC_COOKIE          m_lCookie;
    COMPONENTID         m_ID;
    CSnapIn*            m_pSnapIn;
    CComponent*         m_pComponent;
    IConsoleVerbPtr     m_spConsoleVerb;
    IDataObjectPtr      m_spDataObject;
    CList<GUID, GUID&>  m_objectTypeGuidList;

    CNodePtrArray        m_vecScopeNodes;

}; // class CSnapinSelData


class CSnapinSelDataList : public CList<CSnapinSelData*, CSnapinSelData*>
{
public:
    CSnapinSelDataList()
    {
        DEBUG_INCREMENT_INSTANCE_COUNTER(CSnapinSelDataList);
    }

    ~CSnapinSelDataList()
    {
        POSITION pos = GetHeadPosition();
        while (pos)
        {
            delete GetNext(pos);
        }

        DEBUG_DECREMENT_INSTANCE_COUNTER(CSnapinSelDataList);
    }

    void Add(CSnapinSelData& snapinSelData, BOOL bStaticNode);
};

class CMultiSelection
{
public:
    CMultiSelection(CNode* pNode);

    void AddRef()
    {
        ++m_cRef;
    }
    void Release()
    {
        ASSERT(m_cRef > 0);
        --m_cRef;
        if (m_cRef == 0)
        {
            ReleaseMultiSelDataObject();
            delete this;
        }
    }

    HRESULT Init();
    HRESULT GetMultiSelDataObject(IDataObject** ppDataObject);
    HRESULT GetExtensionSnapins(LPCTSTR pszExtensionTypeKey,
                                CList<GUID, GUID&>& snapinGuidList);
    bool IsSingleSnapinSelection()
    {
        if (m_rgStaticNodes.size() > 0 || m_snapinSelDataList.GetCount() > 1)
            return false;

        return true;
    }
    IDataObject* GetSingleSnapinSelDataObject()
    {
        if (!IsSingleSnapinSelection())
            return NULL;

        CSnapinSelData* pSnapinSelData = m_snapinSelDataList.GetHead();
        ASSERT(pSnapinSelData != NULL);
        return pSnapinSelData->GetDataObject();
    }
    CComponent* GetPrimarySnapinComponent()
    {
        if (!IsSingleSnapinSelection())
            return NULL;

        CSnapinSelData* pSnapinSelData = m_snapinSelDataList.GetHead();
        return pSnapinSelData->GetComponent();
    }
    BOOL IsAnExtensionSnapIn(const CLSID& rclsid);
    BOOL HasNodes()
    {
        return m_bHasNodes;
    }
    BOOL HasStaticData()
    {
        return (m_rgStaticNodes.size() > 0);
    }
    BOOL HasSnapinData()
    {
        return (m_snapinSelDataList.IsEmpty() == FALSE);
    }
    BOOL HasData()
    {
        if (HasSnapinData() == FALSE)
            return HasStaticData();
        return TRUE;
    }
    void SetScopeTree(CScopeTree* pCScopeTree)
    {
        m_pCScopeTree = pCScopeTree;
    }
    CScopeTree* GetScopeTree()
    {
        ASSERT(m_pCScopeTree != NULL);
        return m_pCScopeTree;
    }
    BOOL IsInUse()
    {
        return m_bInUse;
    }

    SC ScVerbInvoked(MMC_CONSOLE_VERB verb);
    bool RemoveStaticNode(CMTNode* pMTNode);
    void ReleaseMultiSelDataObject()
    {
        m_spDataObjectMultiSel = NULL;
        ASSERT(m_spDataObjectMultiSel == NULL);
    }

    SC ScIsVerbEnabledInclusively(MMC_CONSOLE_VERB mmcVerb, BOOL& bEnable);

    SC ScGetSnapinDataObjects(CMMCClipBoardDataObject *pResultObject);

private:
    DWORD               m_cRef;
    CNode*              m_pNode;
    CSnapInNode*        m_pSINode;
    CMTSnapInNode*      m_pMTSINode;
    CScopeTree*         m_pCScopeTree;

    CSnapinSelDataList  m_snapinSelDataList;
    CMTNodePtrArray     m_rgStaticNodes;
    IDataObjectPtr      m_spDataObjectMultiSel;

    BOOL                m_bHasNodes;
    BOOL                m_bInUse;

    CMTSnapInNode* _GetStaticMasterNode()
    {
        return m_pMTSINode;
    }

    CSnapInNode* _GetStaticNode()
    {
        return m_pSINode;
    }

    void _SetInUse(BOOL b)
    {
        m_bInUse = b;
    }

    SC _ScVerbInvoked(MMC_CONSOLE_VERB verb);
    bool _IsTargetCut();

#ifdef DBG
    BOOL m_bInit;
#endif

    HRESULT _ComputeSelectionDataList();
    CComponent* _GetComponent(CSnapinSelData* pSnapinSelData);
    HRESULT _GetObjectTypeForSingleSel(CSnapinSelData* pSnapinSelData);
    HRESULT _GetObjectTypesForMultipleSel(CSnapinSelData* pSnapinSelData);
    HRESULT _FindSnapinsThatExtendObjectTypes(CSnapinSelDataList& snapinSelDataList,
                                          CList<GUID, GUID&>& snapinGuidList);

    ~CMultiSelection();

}; // class CMultiSelection


class CMultiSelectDataObject : public IDataObject,
                               public CComObjectRoot
{
public:
// ATL Maps
DECLARE_NOT_AGGREGATABLE(CMultiSelectDataObject)
BEGIN_COM_MAP(CMultiSelectDataObject)
    COM_INTERFACE_ENTRY(IDataObject)
END_COM_MAP()


#ifdef DBG
    int dbg_cRef;
    ULONG InternalAddRef()
    {
        ++dbg_cRef;
        int tmp1 = dbg_cRef;
        int tmp2 = tmp1 * 4;
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        --dbg_cRef;
        int tmp1 = dbg_cRef;
        int tmp2 = tmp1 * 4;
        return CComObjectRoot::InternalRelease();
    }
#endif // DBG


// Construction/Destruction
    CMultiSelectDataObject() : m_ppDataObjects(NULL), m_count(0),
        m_ppMTNodes(NULL), m_nSize(0), m_pMS(NULL)
    {

#ifdef DBG
dbg_cRef = 0;
#endif
        DEBUG_INCREMENT_INSTANCE_COUNTER(CMultiSelectDataObject);
    }

    ~CMultiSelectDataObject();

    void SetDataObjects(LPDATAOBJECT* ppDataObjects, UINT count)
    {
        if (ppDataObjects != NULL)
        {
            ASSERT(m_ppDataObjects == NULL);
            ASSERT(m_count == 0);
            m_ppDataObjects = ppDataObjects;
            m_count = count;
        }
        else
        {
            ASSERT(count == 0);
            delete [] m_ppDataObjects;
            m_ppDataObjects = NULL;
            m_count = 0;
        }
    }

    void SetStaticNodes(CMTNodePtrArray &rgMTNodes, int nSize)
    {
        typedef CMTNode* _PMTNODE;
        ASSERT(m_ppMTNodes == NULL);
        ASSERT(m_nSize == 0);
        m_ppMTNodes = new _PMTNODE[nSize];
        if(m_ppMTNodes != NULL)
        {
            m_nSize = nSize;
            for(int i=0; i<nSize; i++)
                m_ppMTNodes[i] = rgMTNodes[i];
        }
    }

    void SetMultiSelection(CMultiSelection* pMS)
    {
        ASSERT(pMS != NULL);
        m_pMS = pMS;
        m_pMS->AddRef();
    }
    CMultiSelection* GetMultiSelection()
    {
        ASSERT(m_pMS != NULL);
        return m_pMS;
    }


// Standard IDataObject methods
public:
// Implemented
    STDMETHOD(GetDataHere)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);
    STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium);
    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc);
    STDMETHOD(QueryGetData)(LPFORMATETC lpFormatetc);

// Not Implemented
    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut) { return E_NOTIMPL; };
    STDMETHOD(SetData)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease) { return E_NOTIMPL; };
    STDMETHOD(DAdvise)(LPFORMATETC lpFormatetc, DWORD advf,LPADVISESINK pAdvSink, LPDWORD pdwConnection) { return E_NOTIMPL; };
    STDMETHOD(DUnadvise)(DWORD dwConnection) { return E_NOTIMPL; };
    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* ppEnumAdvise) { return E_NOTIMPL; }

private:
    LPDATAOBJECT* m_ppDataObjects;
    UINT m_count;

    CMTNode** m_ppMTNodes;
    int m_nSize;

    CMultiSelection* m_pMS; // To be used only for Drag-Drop

}; // class CMultiSelectDataObject


bool IsMultiSelectDataObject(IDataObject* pdtobjCBSelData);

#endif // _MULTISEL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\mtnode.inl ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 00
 *
 *  File:      mtnode.inl
 *
 *  Contents:
 *
 *  History:   8-Mar-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#pragma once

//_____________________________________________________________________________
//
//  Inlines for class:  CMTNode
//_____________________________________________________________________________
//

inline USHORT CMTNode::AddRef()
{
    return (++m_cRef);
}

inline USHORT CMTNode::Release()
{
    // Note: The return value from this is important
    // as a return value of zero is interpreted as
    // object destroyed.

    ASSERT(m_cRef > 0);
    --m_cRef;
    if (m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

inline PMTNODE CMTNode::GetChild()
{
    if (!WasExpandedAtLeastOnce())
        Expand();

    return Child();
}

inline CMTSnapInNode* CMTNode::GetStaticParent(void)
{
    CMTNode* p = this;

    while (!p->IsStaticNode())
        p = p->Parent();

    ASSERT(p != NULL);
    CMTSnapInNode* pMTSnapInNode = dynamic_cast<CMTSnapInNode*>(p);
    ASSERT (pMTSnapInNode != NULL);

    return pMTSnapInNode;
}


inline void CMTNode::CreatePathList(CHMTNODEList& path)
{
    CMTNode* pMTNode = this;

    for (; pMTNode != NULL; pMTNode = pMTNode->Parent())
        path.AddHead(ToHandle(pMTNode));
}


inline CMTNode* CMTNode::Find(MTNODEID id)
{
	CMTNode* pStartNode = this; // this is to avoid traversing the tree above the initial node passed
	CMTNode* pNode = this;

	while ( pNode->GetID() != id )
	{
		if ( NULL != pNode->Child() )
		{
			// dive down to the lowest child
			pNode = pNode->Child();
		}
		else 
		{
			// get to the next sub-branch 
			// ( but first - climb up till you get to the junction )
			while ( NULL == pNode->Next() )
			{
				pNode = pNode->Parent();
				// if there are no more nodes - we are done ( search failed )
				// ... or if we looked thru all children and siblings [ this
				// mostly for compatibility - CMTNode::Find is never used else than
				// from topmost node].
				if ( (NULL == pNode) || (pNode == pStartNode->Parent()) )
					return NULL;
			}
			pNode = pNode->Next();
		}
	}

	return pNode;
}

inline CMTNode* CMTNode::GetLastChild()
{
    CMTNode* pMTNode = Child();
    if (pMTNode == NULL)
        return NULL;

    while (pMTNode->Next() != NULL)
    {
        pMTNode = pMTNode->Next();
    }

    return pMTNode;
}

inline wchar_t* CMTNode::GetViewStorageName(wchar_t* name, int idView)
{
    ASSERT(name != NULL);
    _ltow(idView, name, 36);
    return name;
}

/***************************************************************************\
 *
 * METHOD:  CMTNode::GetViewIdFromStorageName
 *
 * PURPOSE: function reconstructs view id from the component storage name
 *          in structured storage based console. This is opposit to what
 *          GetViewStorageName [above] does.
 *
 * PARAMETERS:
 *    const wchar_t* name [in] name of storage element
 *
 * RETURNS:
 *    int    - view id
 *
\***************************************************************************/
inline int CMTNode::GetViewIdFromStorageName(const wchar_t* name)
{
    ASSERT(name != NULL);
    if (name == NULL)
        return 0;
    
    wchar_t *stop = NULL;
    return wcstol( name, &stop, 36/*base*/ );
}

inline wchar_t* CMTNode::GetComponentStreamName(wchar_t* name, const CLSID& clsid)
{
    ASSERT(name != NULL);
    ASSERT(&clsid != NULL);
    wchar_t* pName = name;
    const long* pl = reinterpret_cast<const long*>(&clsid);
    for (int i = 0; i < 4; i++)
    {
        _ltow(*pl++, pName, 36);
        pName += wcslen(pName);
    }
    return name;
}

inline wchar_t* CMTNode::GetComponentStorageName(wchar_t* name, const CLSID& clsid)
{
    return GetComponentStreamName(name, clsid);
}


inline void CMTNode::_SetFlag(ENUM_FLAGS flag, BOOL bSet)
{
    ASSERT((flag & (flag-1)) == 0);
    if (bSet == TRUE)
        m_usFlags |= flag;
    else
        m_usFlags &= ~flag;
}

inline const CLSID& CMTNode::GetPrimarySnapInCLSID(void)
{
    if (m_pPrimaryComponentData == NULL)
        return (GUID_NULL);

    CSnapIn* const pSnapIn = m_pPrimaryComponentData->GetSnapIn();
    if (pSnapIn == NULL)
        return (GUID_NULL);

    return pSnapIn->GetSnapInCLSID();
}

inline HRESULT CMTNode::GetNodeType(GUID* pGuid)
{
    HRESULT hr = m_pPrimaryComponentData->GetNodeType(GetUserParam(), pGuid);
    CHECK_HRESULT(hr);
    return hr;
}

inline HRESULT CMTNode::OnRename(long fRename, LPOLESTR pszNewName)
{
    IDataObjectPtr spDataObject;
    HRESULT hr = QueryDataObject(CCT_SCOPE, &spDataObject);
    if (FAILED(hr))
        return hr;

    hr = m_pPrimaryComponentData->Notify(spDataObject,
                  MMCN_RENAME, fRename, reinterpret_cast<LPARAM>(pszNewName));
    CHECK_HRESULT(hr);
    return hr;
}

inline HRESULT CMTNode::QueryDataObject(DATA_OBJECT_TYPES type,
                                                LPDATAOBJECT* ppdtobj)
{
    if (ppdtobj == NULL)
        return (E_INVALIDARG);

    *ppdtobj = NULL; // init

    CMTSnapInNode* pMTSINode = GetStaticParent();
    CComponentData* pCCD = pMTSINode->GetComponentData(GetPrimarySnapInCLSID());
    if (pCCD == NULL)
        return E_FAIL;

    HRESULT hr = pCCD->QueryDataObject(GetUserParam(),
                                       type, ppdtobj);
    CHECK_HRESULT(hr);
    return hr;
}

inline COMPONENTID CMTNode::GetPrimaryComponentID()
{
    return m_pPrimaryComponentData->GetComponentID();
}

inline int CMTNode::GetDynExtCLSID ( LPCLSID *ppCLSID )
{
    ASSERT(ppCLSID != NULL);
    *ppCLSID = m_arrayDynExtCLSID.GetData();
    return m_arrayDynExtCLSID.GetSize();
}

inline void CMTNode::SetNoPrimaryChildren(BOOL bState)
{
    if (bState)
        m_usExpandFlags |= FLAG_NO_CHILDREN_FROM_PRIMARY;
    else
        m_usExpandFlags &= ~FLAG_NO_CHILDREN_FROM_PRIMARY;
}



//____________________________________________________________________________
//
//  Class:      CComponentData Inlines
//____________________________________________________________________________
//

inline HRESULT CComponentData::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject)
{
	DECLARE_SC (sc, _T("CComponentData::QueryDataObject"));
	sc = ScCheckPointers (m_spIComponentData, E_FAIL);
	if (sc)
		return (sc.ToHr());

    ASSERT(type != CCT_RESULT);
    return ((sc = m_spIComponentData->QueryDataObject(cookie, type, ppDataObject)).ToHr());
}

inline HRESULT CComponentData::GetDisplayInfo(SCOPEDATAITEM* pScopeDataItem)
{
	DECLARE_SC (sc, _T("CComponentData::GetDisplayInfo"));
	sc = ScCheckPointers (m_spIComponentData, E_FAIL);
	if (sc)
		return (sc.ToHr());

    return ((sc = m_spIComponentData->GetDisplayInfo(pScopeDataItem)).ToHr());
}

inline HRESULT CComponentData::GetNodeType(MMC_COOKIE cookie, GUID* pGuid)
{
    IDataObjectPtr spdtobj;
    HRESULT hr = QueryDataObject(cookie, CCT_SCOPE, &spdtobj);
    if (SUCCEEDED(hr))
        hr = ExtractObjectTypeGUID(spdtobj, pGuid);

    return hr;
}


//____________________________________________________________________________
//
//  Class:      CMTSnapInNode Inlines
//____________________________________________________________________________
//

inline CComponentData* CMTSnapInNode::GetComponentData(const CLSID& clsid)
{
    for (int i=0; i < m_ComponentDataArray.size(); i++)
    {
        if (m_ComponentDataArray[i] != NULL &&
            IsEqualCLSID(clsid, m_ComponentDataArray[i]->GetCLSID()) == TRUE)
            return m_ComponentDataArray[i];
    }
    return NULL;
}

inline CComponentData* CMTSnapInNode::GetComponentData(COMPONENTID nID)
{
    if (nID < m_ComponentDataArray.size())
        return m_ComponentDataArray[nID];

    return NULL;
}

inline COMPONENTID CMTSnapInNode::AddComponentDataToArray(CComponentData* pCCD)
{
    m_ComponentDataArray.push_back(pCCD);
    int nID = m_ComponentDataArray.size() -1;
    pCCD->SetComponentID(nID);
    return nID;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\nmutil.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      nmutil.h
 *
 *  Contents:  
 *
 *  History:   
 *
 *--------------------------------------------------------------------------*/

#ifndef _MMC_UTIL_H_
#define _MMC_UTIL_H_
#pragma once

class CComponentPtrArray;
class CResultItem;

COMPONENTID GetComponentID(CNode* pNode, CResultItem* pri = 0);
CComponent* GetComponent(CNode* pNode, CResultItem* pri = 0);
void GetComponentsForMultiSel(CNode* pNode, CComponentPtrArray& rgComps);


#endif // _MMC_UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\newnode.h ===
// NewNode.h : structures for console created nodes
//

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      NewNode.h
//
//  Contents:  Definitions for internal data types that can be created by the
//             user.
//
//  History:   12-Aug-96 WayneSc    Created
//
//--------------------------------------------------------------------------

#ifndef __NEWNODE_H__
#define __NEWNODE_H__

#include "dlgs.h"
#include "ccomboex.h"

#define NODE_NOCHANGE       0
#define NODE_NAME_CHANGE    1
#define NODE_TARGET_CHANGE  2

                             
class CSnapinComponentDataImpl;
                             
template<class T>
class CBasePropertyPage : public T
{
    typedef CBasePropertyPage<T>        ThisClass;
    typedef T                           BaseClass;

public:
    CBasePropertyPage() : m_pHelpIDs(NULL) {}
    void Initialize(IComponentData *pComponentData) 
    {
        // do not use a smart pointer - causes a circular reference
        // the lifetime is managed because the CBasePropertyObject is owned by the IComponentData
        m_pComponentData = pComponentData; 
    } 

public: 
    BEGIN_MSG_MAP(ThisClass)
        CONTEXT_HELP_HANDLER()
        CHAIN_MSG_MAP(BaseClass)
    END_MSG_MAP()

    IMPLEMENT_CONTEXT_HELP(GetHelpIDs());

    void OnPropertySheetExit(HWND hWndOwner, int nFlag);

protected:
    void SetHelpIDs(const DWORD* pHelpIDs)
    {
        m_pHelpIDs = pHelpIDs;
    }

    const DWORD* GetHelpIDs(void) const
    {
        return m_pHelpIDs;
    }

private:
    const DWORD* m_pHelpIDs;

protected:
    CSnapinComponentDataImpl *GetComponentDataImpl()
    {
        CSnapinComponentDataImpl *pRet = dynamic_cast<CSnapinComponentDataImpl *>(m_pComponentData);
        ASSERT(pRet);
        return pRet;
    }

    IComponentData* m_pComponentData;
};

/////////////////////////////////////////////////////////////////////////////
// CHTMLPage1 dialog

class CHTMLPage1 : public CBasePropertyPage<CWizard97WelcomeFinishPage<CHTMLPage1> >
{
    typedef CHTMLPage1                              ThisClass;
    typedef CBasePropertyPage<CWizard97WelcomeFinishPage<CHTMLPage1> >  BaseClass;

    // Construction
    public:
        CHTMLPage1();
        ~CHTMLPage1();
       
    
    // Dialog Data
        enum { IDD = IDD_HTML_WIZPAGE1 };
        WTL::CEdit m_strTarget;
    
    
    // Overrides
    public:
        BOOL OnSetActive();
        BOOL OnKillActive();
    
    // Implementation
    protected:
        BEGIN_MSG_MAP(ThisClass)
            COMMAND_ID_HANDLER( IDC_BROWSEBT, OnBrowseBT )
            COMMAND_HANDLER( IDC_TARGETTX, EN_UPDATE, OnUpdateTargetTX )
            MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
            CHAIN_MSG_MAP(BaseClass)
        END_MSG_MAP()
    
        // Generated message map functions
        LRESULT OnBrowseBT( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
        LRESULT OnUpdateTargetTX( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
        LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    
    //Operators
    protected:
        void _ValidatePage(void);
    
};
/////////////////////////////////////////////////////////////////////////////
// CHTMLPage2 dialog

class CHTMLPage2 : public CBasePropertyPage<CWizard97WelcomeFinishPage<CHTMLPage2> >
{
    typedef CHTMLPage2                              ThisClass;
    typedef CBasePropertyPage<CWizard97WelcomeFinishPage<CHTMLPage2> >  BaseClass;

    // Construction
    public:
        CHTMLPage2();
        ~CHTMLPage2();
    
    //Operators
    public:
        // Dialog Data
        enum { IDD = IDD_HTML_WIZPAGE2 };
        WTL::CEdit m_strDisplay;
    
        BOOL OnSetActive();
        BOOL OnKillActive();
        BOOL OnWizardFinish();
    
    // Implementation
    protected:
        BEGIN_MSG_MAP( CShortcutPage2 );
            COMMAND_HANDLER( IDC_DISPLAYTX, EN_UPDATE, OnUpdateDisplayTX )
            MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
            CHAIN_MSG_MAP(BaseClass)
        END_MSG_MAP();

        LRESULT OnInitDialog( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
        LRESULT OnUpdateDisplayTX( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    
        void _ValidatePage(void);
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CActiveXPage0 dialog

class CActiveXPage0 : public CBasePropertyPage<CWizard97WelcomeFinishPage<CActiveXPage0> >
{
    typedef CActiveXPage0                               ThisClass;
    typedef CBasePropertyPage<CWizard97WelcomeFinishPage<CActiveXPage0> >   BaseClass;

    // Construction
public:
    CActiveXPage0();
    ~CActiveXPage0();
                
        // Dialog Data
    enum { IDD = IDD_ACTIVEX_WIZPAGE0 };
    
protected: // implementation

    BEGIN_MSG_MAP(ThisClass)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        CHAIN_MSG_MAP(BaseClass)
    END_MSG_MAP()

    LRESULT OnInitDialog( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );

    // Overrides
public:
    BOOL OnSetActive();
    BOOL OnKillActive();
};


/////////////////////////////////////////////////////////////////////////////
// CActiveXPage1 dialog

class CActiveXPage1 : public CBasePropertyPage<CWizard97InteriorPage<CActiveXPage1> >
{
    typedef CActiveXPage1                           ThisClass;
    typedef CBasePropertyPage<CWizard97InteriorPage<CActiveXPage1> >    BaseClass;

    // Construction
    public:
        CActiveXPage1();
        ~CActiveXPage1();
    
        // Dialog Data
        enum 
        { 
            IDD          = IDD_ACTIVEX_WIZPAGE1,
            IDS_Title    = IDS_OCXWiz_ControlPageTitle,
            IDS_Subtitle = IDS_OCXWiz_ControlPageSubTitle,
        };


        WTL::CButton    m_InfoBT;
        int     m_nConsoleView;
    
    
        BOOL OnSetActive();
        BOOL OnKillActive();
    
    // Implementation
    protected:
        BEGIN_MSG_MAP(ThisClass)
            COMMAND_HANDLER(IDC_CATEGORY_COMBOEX, CBN_SELENDOK, OnCategorySelect)            
            NOTIFY_HANDLER( IDC_CONTROLXLS, NM_CLICK, OnComponentSelect )
            MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
            MESSAGE_HANDLER( WM_DESTROY, OnDestroy )
            CHAIN_MSG_MAP(BaseClass)
        END_MSG_MAP()

        LRESULT OnComponentSelect( int idCtrl, LPNMHDR pnmh, BOOL& bHandled );
        LRESULT OnCategorySelect( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );

        LRESULT OnInitDialog( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
        LRESULT OnDestroy( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
        LRESULT BuildCategoryList(CArray <CATEGORYINFO*, CATEGORYINFO*>& arpCategories);
        LRESULT BuildComponentList(CArray <CComponentCategory::COMPONENTINFO*, 
                                    CComponentCategory::COMPONENTINFO*>& arpComponents);
        void _ValidatePage(void);
    
        WTL::CListViewCtrl* m_pListCtrl;
        CComboBoxEx2*       m_pComboBox;
        CComponentCategory* m_pComponentCategory;
};


/////////////////////////////////////////////////////////////////////////////
// CActiveXPage2 dialog

class CActiveXPage2 : public CBasePropertyPage<CWizard97WelcomeFinishPage<CActiveXPage2> >
{
    typedef CActiveXPage2                                ThisClass;
    typedef CBasePropertyPage<CWizard97WelcomeFinishPage<CActiveXPage2> >    BaseClass;

    // Construction
    public:
        CActiveXPage2();
        ~CActiveXPage2();
    
        // Dialog Data
        enum { IDD = IDD_ACTIVEX_WIZPAGE2 };
        WTL::CEdit m_strDisplay;
    
    
        BOOL OnSetActive();
        BOOL OnKillActive();
        BOOL OnWizardFinish();
    
    // Implementation
    protected:
        BEGIN_MSG_MAP(ThisClass)
            COMMAND_HANDLER( IDC_DISPLAYTX, EN_UPDATE, OnUpdateTargetTX )
            MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
            CHAIN_MSG_MAP(BaseClass)
        END_MSG_MAP()
    
        // Generated message map functions
        LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
        LRESULT OnUpdateTargetTX( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );

        void _ValidatePage(void);
};



#endif // __NEWNODE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\newnode.cpp ===
// NewNode.cpp : implementation file
//

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      NewNode.cpp
//
//  Contents:  Wizards / Propertysheets for console owned nodes
//
//  History:   01-Aug-96 WayneSc    Created
//
//--------------------------------------------------------------------------

#include "stdafx.h"

#include <comcat.h>         // COM Component Categoories Manager
#include "CompCat.h"        // Component Category help functions
#include "guids.h"          // AMC Category guids


#include "NewNode.h"
#include "amcmsgid.h"
#include "ndmgrp.h"

#include "fldrsnap.h"
                                            
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// Listview compare function forward
int CALLBACK ListViewCompareFunc(LPARAM lParam1,LPARAM lParam2,LPARAM lParamSort);
void LoadFilterString(CStr &str, int iStrID);


/////////////////////////////////////////////////////////////////////////////
// CHTMLPage1 property page


CHTMLPage1::CHTMLPage1()
{
//    SetHelpIDs(g_aHelpIDs_IDD_HTML_WIZPAGE1);
}


CHTMLPage1::~CHTMLPage1()
{
}


LRESULT CHTMLPage1::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    CWizardPage::OnInitWelcomePage(m_hWnd); // set up the correct title font
    
    HWND const hTarget = ::GetDlgItem( *this, IDC_TARGETTX );
    ASSERT( hTarget != NULL );
    m_strTarget.Attach( hTarget );
    m_strTarget.SetWindowText( _T( "" ) );
    m_strTarget.SetLimitText( 128 );

    _ValidatePage();
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CHTMLPage1 message handlers

void CHTMLPage1::_ValidatePage(void)
{
    TRACE_METHOD(CHTMLPage1, _ValidatePage);

    DWORD dwFlags=0;

    // Check to see if we have a valid string
    TCHAR buff[ 256 ];
    int nChars = m_strTarget.GetWindowText( buff, sizeof(buff) / sizeof(TCHAR) );

    if( nChars != 0 && _tcslen( buff ) > 0 )
        dwFlags|=PSWIZB_NEXT;


    HWND hWnd=::GetParent(m_hWnd);
    ::SendMessage(hWnd, PSM_SETWIZBUTTONS, 0, dwFlags);
}


BOOL CHTMLPage1::OnSetActive()
{
    TRACE_METHOD(CHTMLPage1, OnSetActive);
    
    CWizardPage::OnWelcomeSetActive(m_hWnd); 

    USES_CONVERSION;

    m_strTarget.SetWindowText(GetComponentDataImpl()->GetView());
    _ValidatePage();

    return TRUE;
}


BOOL CHTMLPage1::OnKillActive()
{
    // the line below has been commented because this wizard has only two pages and so we
    // want to enable the Finish button, not the Next button.
    // CWizardPage::OnWelcomeKillActive(m_hWnd); 
    
    TRACE_METHOD(CHTMLPage1, OnKillActive);
    USES_CONVERSION;

    TCHAR buff[ 256 ];
    int nChars = m_strTarget.GetWindowText( buff, sizeof(buff) / sizeof(TCHAR) );
    if (nChars == 0)
        buff[0] = 0; // initialize to empty if failed

    // set the view and the name to be the same intially.
    GetComponentDataImpl()->SetView(buff);
    GetComponentDataImpl()->SetName(buff);

    LPTSTR psz = _tcsrchr(GetComponentDataImpl()->GetView(), TEXT('\\'));
    if (psz!=NULL)
    {
        psz++;
        GetComponentDataImpl()->SetName(psz); // use only the string after the last "\". Thus c:\mmc.xml gives mmc.xml as the display name.
    }

    return TRUE;
}




LRESULT CHTMLPage1::OnUpdateTargetTX( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    TRACE_METHOD(CHTMLPage1, OnUpdateTargetTX);

    _ValidatePage();

    return 0;
}


LRESULT CHTMLPage1::OnBrowseBT( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    TRACE_METHOD(CHTMLPage1, OnBrowseBT);

    TCHAR szFile[MAX_PATH] = { 0 };
    TCHAR szInitialPath[MAX_PATH];

    CStr strFilter;
    LoadFilterString(strFilter, IDS_HTML_FILES);

    CStr strTitle;
    strTitle.LoadString(GetStringModule(), IDS_BROWSE_WEBLINK);

    // Copy the current command target value to the file name
    m_strTarget.GetWindowText (szInitialPath, sizeof(szInitialPath) / sizeof(TCHAR) );

    OPENFILENAME ofn;
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = m_hWnd;
    ofn.hInstance = NULL;
    ofn.lpstrFilter = strFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 1;   // use 1st filter in lpstrFilter
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = sizeof(szFile);
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrTitle = strTitle;
    ofn.Flags = OFN_EXPLORER | OFN_HIDEREADONLY;
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt = _T("htm");
    ofn.lCustData = 0;
    ofn.lpfnHook = NULL;
    ofn.lpTemplateName = NULL;
    ofn.lpstrInitialDir = szInitialPath;

    if (!GetOpenFileName(&ofn))
    {
        if (CommDlgExtendedError() != 0)
        {
            ASSERT(0 && "GetOpenFileName failed");
            Dbg(DEB_ERROR, _T("GetOpenFileName failed, 0x%08lx\n"),CommDlgExtendedError());
        }

        return 0;
    }

    // lpstrFile has the full path of the file to open

    TRACE(_T("Open: %ws\n"), ofn.lpstrFile);
    m_strTarget.SetWindowText( ofn.lpstrFile );

    return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CHTMLPage2 property page


CHTMLPage2::CHTMLPage2()
{
//    SetHelpIDs(g_aHelpIDs_IDD_HTML_WIZPAGE2);
}


CHTMLPage2::~CHTMLPage2()
{
}


LRESULT CHTMLPage2::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    USES_CONVERSION;
    HWND const hDisplay = ::GetDlgItem( *this, IDC_DISPLAYTX );
    ASSERT( hDisplay != NULL );
    m_strDisplay.Attach( hDisplay );
    m_strDisplay.SetWindowText( GetComponentDataImpl()->GetName());
    m_strDisplay.SetLimitText( 128 );

    _ValidatePage();
    return TRUE;
}



void CHTMLPage2::_ValidatePage(void)
{
    TRACE_METHOD(CHTMLPage2, _ValidatePage);

    DWORD dwFlags=PSWIZB_BACK|PSWIZB_DISABLEDFINISH;

    // Check to see if we have a valid string
    TCHAR buff[ 256 ];
    int nChars = m_strDisplay.GetWindowText( buff, sizeof(buff) / sizeof(TCHAR) );

    if( nChars != 0 && _tcslen( buff ) > 0 )
        dwFlags|=PSWIZB_FINISH;


    HWND hWnd=::GetParent(m_hWnd);
    ::SendMessage(hWnd, PSM_SETWIZBUTTONS, 0, dwFlags);
}


BOOL CHTMLPage2::OnSetActive()
{
    TRACE_METHOD(CHTMLPage2, OnSetActive);
    USES_CONVERSION;

    m_strDisplay.SetWindowText( GetComponentDataImpl()->GetName());
    _ValidatePage();

    return TRUE;
}


BOOL CHTMLPage2::OnKillActive()
{
    TRACE_METHOD(CHTMLPage2, OnKillActive);

    TCHAR buff[ 256 ];
    m_strDisplay.GetWindowText( buff, sizeof(buff) / sizeof(TCHAR) );
    GetComponentDataImpl()->SetName(buff);

    return TRUE;
}


BOOL CHTMLPage2::OnWizardFinish()
{
    TRACE_METHOD(CHTMLPage2, OnWizardFinish);

    OnKillActive();
    return TRUE;
}


LRESULT CHTMLPage2::OnUpdateDisplayTX( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    TRACE_METHOD(CHTMLPage2, OnUpdateDisplayTX);

    _ValidatePage();
    return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CActiveXPage0 property page


CActiveXPage0::CActiveXPage0()
{
//    SetHelpIDs(g_aHelpIDs_IDD_ACTIVEX_WIZPAGE0);
}


CActiveXPage0::~CActiveXPage0()
{
}


BOOL CActiveXPage0::OnSetActive()
{
    CWizardPage::OnWelcomeSetActive(m_hWnd); 
    
    return TRUE;
}


BOOL CActiveXPage0::OnKillActive()
{
    CWizardPage::OnWelcomeKillActive(m_hWnd); 
    return TRUE;
}

LRESULT CActiveXPage0::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{        
    CWizardPage::OnInitWelcomePage(m_hWnd); // set up the correct title font
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CActiveXPage1 property page


CActiveXPage1::CActiveXPage1()
{
    m_pListCtrl = NULL;
    m_pComponentCategory = NULL;
//    SetHelpIDs(g_aHelpIDs_IDD_ACTIVEX_WIZPAGE1);
}


CActiveXPage1::~CActiveXPage1()
{
}


void CActiveXPage1::_ValidatePage(void)
{
    DWORD dwFlags = PSWIZB_BACK;

    // Check to see if we have a valid string
    if (m_pListCtrl != NULL && m_pListCtrl->GetSelectedCount()>0)
        dwFlags|=PSWIZB_NEXT;

    HWND hWnd=::GetParent(m_hWnd);
    ::SendMessage(hWnd, PSM_SETWIZBUTTONS, 0, dwFlags);
}


BOOL CActiveXPage1::OnSetActive()
{
    _ValidatePage();
    return TRUE;
}


BOOL CActiveXPage1::OnKillActive()
{
    LV_ITEM lvi;
    memset( &lvi,'\0',sizeof(LV_ITEM) );

    lvi.mask = LVIF_PARAM;
    lvi.iItem = m_pListCtrl->GetNextItem( -1, LVNI_SELECTED );

    if (lvi.iItem != -1)
    {
        if (m_pListCtrl->GetItem(&lvi))
        {
            CComponentCategory::COMPONENTINFO* pComponentInfo=(CComponentCategory::COMPONENTINFO*)lvi.lParam;

            USES_CONVERSION;
            GetComponentDataImpl()->SetName(((LPTSTR)(LPCTSTR)pComponentInfo->m_strName));
            LPOLESTR szClsid = NULL;
            StringFromCLSID(pComponentInfo->m_clsid, &szClsid);
            ASSERT(szClsid != NULL);
            if(szClsid != NULL)
            {
                GetComponentDataImpl()->SetView(OLE2T(szClsid));
                CoTaskMemFree(szClsid);
            }
        }
    }

    return TRUE;
}


LRESULT CActiveXPage1::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{        
    /*
     * this could take a while - throw up the hourglass
     */
    // Display hour glass during long initialization
    SetCursor (LoadCursor (NULL, IDC_WAIT));

    m_nConsoleView = -1;

    m_pListCtrl = new WTL::CListViewCtrl;
	if ( m_pListCtrl == NULL )
		return TRUE;

    m_pComboBox = new CComboBoxEx2;
	if ( m_pComboBox == NULL )
		return TRUE;

    m_pComponentCategory = new CComponentCategory;
	if ( m_pComponentCategory == NULL )
		return TRUE;


    // subclass the categories combo box
    m_pComboBox->Attach(::GetDlgItem(*this, IDC_CATEGORY_COMBOEX));

    // sub class the controls list
    m_pListCtrl->Attach(::GetDlgItem( *this, IDC_CONTROLXLS));

    // set the imagelist
    m_pListCtrl->SetImageList( m_pComponentCategory->m_iml, LVSIL_SMALL );

    // create single column in list view
    // Reduce column width by width of vertical scroll bar so that we
    // don't need a horizontal scroll bar
    RECT rc;
    m_pListCtrl->GetClientRect(&rc);

    LV_COLUMN lvc;
    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_SUBITEM;
    lvc.fmt = LVCFMT_LEFT;
    lvc.cx = rc.right - GetSystemMetrics(SM_CXVSCROLL);
    lvc.iSubItem = 0;
    m_pListCtrl->InsertColumn(0, &lvc);

    // enumerate the categories and add them to the combo box 
    m_pComponentCategory->EnumComponentCategories();
    BuildCategoryList(m_pComponentCategory->m_arpCategoryInfo);

    // enumerate all the controls and add them to the list box
    m_pComponentCategory->EnumComponents();
    m_pComponentCategory->FilterComponents(NULL);
    BuildComponentList(m_pComponentCategory->m_arpComponentInfo);

     // remove the hourglass
    SetCursor (LoadCursor (NULL, IDC_ARROW));

    return TRUE;
}


LRESULT CActiveXPage1::OnDestroy( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    delete m_pComponentCategory;
    delete m_pListCtrl;
    delete m_pComboBox;
    return 0;
}


//
// Populate the category combo box from the category list
//
LRESULT CActiveXPage1::BuildCategoryList(CArray <CATEGORYINFO*, CATEGORYINFO*>& arpCategories)
{
    USES_CONVERSION;

    COMBOBOXEXITEM ComboItem;
        
    for (int i = 0; i <= arpCategories.GetUpperBound(); i++)
    {
        CATEGORYINFO* pCatInfo = arpCategories.GetAt(i);

        ComboItem.mask = CBEIF_LPARAM | CBEIF_TEXT;
        ComboItem.lParam = reinterpret_cast<LPARAM>(pCatInfo);
        ComboItem.pszText = OLE2T(pCatInfo->szDescription);

        // CComboBoxEx doesn't support CBS_SORT and has no add method, only insert.
        // So we need to find the insertion point ourselves. Because it's a short
        // list, just do a linear search.
        int iInsert;
        for (iInsert = 0; iInsert < i; iInsert++)
        {
            CATEGORYINFO* pCatEntry = reinterpret_cast<CATEGORYINFO*>(m_pComboBox->GetItemData(iInsert));
            if (_wcsicmp(pCatInfo->szDescription, pCatEntry->szDescription) < 0)
                break;
        }
        ComboItem.iItem = iInsert;

        int iItem = m_pComboBox->InsertItem(&ComboItem);
        ASSERT(iItem >= 0);
    }

    // Add special "All Categories" entry at the top and select it
    // Note that this item is recognized by a NULL category info ptr 
    CStr strAllCat;
    strAllCat.LoadString(GetStringModule(), IDS_ALL_CATEGORIES);

    ComboItem.mask = CBEIF_LPARAM | CBEIF_TEXT;
    ComboItem.lParam = NULL;
    ComboItem.pszText = const_cast<LPTSTR>((LPCTSTR)strAllCat);
    ComboItem.iItem = 0;

    int iItem = m_pComboBox->InsertItem(&ComboItem);
    ASSERT(iItem >= 0);

    m_pComboBox->SetCurSel(0);

    return S_OK;
}      


//
// Populate the component listview with the filtered items in the component list
//
LRESULT CActiveXPage1::BuildComponentList(
            CArray <CComponentCategory::COMPONENTINFO*, 
            CComponentCategory::COMPONENTINFO*>& arpComponents )
{
    // Get currently selected item data
    LPARAM lParamSel = 0;

    int iSelect = m_pListCtrl->GetNextItem(-1, LVNI_SELECTED);
    if (iSelect != -1)
        lParamSel = m_pListCtrl->GetItemData(iSelect);

    // clear and reload comp list
    m_pListCtrl->DeleteAllItems();

    for (int i=0; i <= arpComponents.GetUpperBound(); i++)
    {
        CComponentCategory::COMPONENTINFO* pCompInfo = arpComponents.GetAt(i);

        if (pCompInfo->m_bSelected)
        {
            LV_ITEM         lvi;

            lvi.mask        = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
            lvi.iItem       = i;
            lvi.state       = 0;
            lvi.stateMask   = 0;
            lvi.iSubItem    = 0;
            lvi.pszText     = const_cast<LPTSTR>(static_cast<LPCTSTR>(pCompInfo->m_strName));
            lvi.iImage      = pCompInfo->m_uiBitmap;
            lvi.lParam      = (LPARAM)(LPVOID)pCompInfo;

            int iRet = m_pListCtrl->InsertItem(&lvi);
            ASSERT(iRet != -1);
        }
    }

    // if list isn't empty, select an item
    if (m_pListCtrl->GetItemCount() != 0)
    {
        // first item is the default
        iSelect = 0;

        // try finding previously selected item
        if (lParamSel != NULL)
        {
            LV_FINDINFO FindInfo;

            FindInfo.flags = LVFI_PARAM;
            FindInfo.lParam = lParamSel;

            iSelect = m_pListCtrl->FindItem(&FindInfo, -1 );
        }

        LV_ITEM lvi;

        lvi.mask = LVIF_STATE;
        lvi.iItem = iSelect;
        lvi.iSubItem = 0;
        lvi.state = LVIS_SELECTED | LVIS_FOCUSED;
        lvi.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

        m_pListCtrl->SetItem(&lvi);
        m_pListCtrl->EnsureVisible(iSelect, FALSE);
     }

    _ValidatePage();

    return S_OK;
}


//
// handle component selection change
//
LRESULT CActiveXPage1::OnComponentSelect( int idCtrl, LPNMHDR pnmh, BOOL& bHandled )
{
    _ValidatePage();

    return 0;
}


//
// Handle category selection change
//
LRESULT CActiveXPage1::OnCategorySelect( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    int iItem = m_pComboBox->GetCurSel();
    ASSERT(iItem >= 0);
    if (iItem < 0)
        return 0;

    // get the category info pointer (item's lparam)
    COMBOBOXEXITEM ComboItem;
    ComboItem.mask = CBEIF_LPARAM;
    ComboItem.iItem = iItem;

    BOOL bStat = m_pComboBox->GetItem(&ComboItem);
    ASSERT(bStat);

    CATEGORYINFO* pCatInfo = reinterpret_cast<CATEGORYINFO*>(ComboItem.lParam);

    // filter the component of this category
    m_pComponentCategory->FilterComponents(pCatInfo);

    // rebuild the component list
    BuildComponentList(m_pComponentCategory->m_arpComponentInfo);

    return 0;
}



/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CActiveXPage2 property page


CActiveXPage2::CActiveXPage2()
{
//    SetHelpIDs(g_aHelpIDs_IDD_ACTIVEX_WIZPAGE2);
}


CActiveXPage2::~CActiveXPage2()
{
}


LRESULT CActiveXPage2::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HWND const hDisplay = ::GetDlgItem( *this, IDC_DISPLAYTX );
    ASSERT( hDisplay != NULL );
    m_strDisplay.Attach( hDisplay );
    m_strDisplay.SetWindowText( _T( "" ) );
    m_strDisplay.SetLimitText( 128 );

    _ValidatePage();
    return 0;
}


void CActiveXPage2::_ValidatePage(void)
{
    DWORD dwFlags=PSWIZB_BACK|PSWIZB_DISABLEDFINISH;

    // Check to see if we have a valid string
    TCHAR buff[ 256 ];
    int nChars = m_strDisplay.GetWindowText( buff, sizeof(buff) / sizeof(TCHAR) );

    if( nChars != 0 && _tcslen( buff ) > 0 )
        dwFlags|=PSWIZB_FINISH;


    HWND hWnd=::GetParent(m_hWnd);
    ::SendMessage(hWnd, PSM_SETWIZBUTTONS, 0, dwFlags);
}


BOOL CActiveXPage2::OnSetActive()
{
    USES_CONVERSION;
    m_strDisplay.SetWindowText(GetComponentDataImpl()->GetName());
    _ValidatePage();

    return TRUE;
}


BOOL CActiveXPage2::OnKillActive()
{
    TCHAR buff[ 256 ];
    m_strDisplay.GetWindowText( buff, sizeof(buff) / sizeof(TCHAR) );
    GetComponentDataImpl()->SetName(buff);

    return TRUE;
}


LRESULT CActiveXPage2::OnUpdateTargetTX( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    _ValidatePage();
    return 0;
}


BOOL CActiveXPage2::OnWizardFinish()
{
    OnKillActive();
    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CBasePropertyPage

template<class T>
void CBasePropertyPage<T>::OnPropertySheetExit(HWND hWndOwner, int nFlag)
{
    m_spComponentData = NULL;
}

// Helper function to reformat filter resource string
// ( resource string uses '\' instead of null to separate strings
//   and doesn't terminate in double null. )

void LoadFilterString(CStr &strFilter, int iStrID)
{
    // Get resource string
    strFilter.LoadString(GetStringModule(), iStrID);

    // Append extra NULL to mark end of multi-string
    strFilter += _T('\0');

    // Change filter separators from '\' to nulls
    LPTSTR psz = const_cast<LPTSTR>((LPCTSTR)strFilter);
    while (*psz != _T('\0'))
    {
        if (*psz == _T('\\'))
            *psz = _T('\0');
        psz++;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\nmtempl.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       NMTempl.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    12/11/1996   RaviR   Created
//____________________________________________________________________________
//

#ifndef NMTEMPL_H
#define NMTEMPL_H


//____________________________________________________________________________
//
//  Template:      XMapIterator
//____________________________________________________________________________
//


template<typename _MAP, typename _KEY, typename _VALUE> class XMapIterator
{
public:
    typedef _MAP MAP;
    typedef _KEY KEY;
    typedef _VALUE VALUE;

// Constructor
    inline XMapIterator(MAP& map) : m_map(map), m_pos(NULL), m_bEnd(FALSE)
    { 
        Reset(); 
    }

// Attributes
    inline BOOL IsEnd() 
    { 
        return m_bEnd; 
    }

    inline operator VALUE () 
    { 
        return m_value; 
    }

    inline KEY& GetKey(void) 
    { 
        return m_key; 
    }

    inline VALUE& GetValue(void) 
    { 
        return m_value; 
    }

// Operations
    inline void Reset() 
    { 
        m_bEnd = FALSE;
        m_pos = m_map.GetStartPosition(); 

        if (m_pos)
            m_map.GetNextAssoc(m_pos, m_key, m_value); 
        else 
            m_bEnd = TRUE;
    }

    inline void Advance() 
    { 
        ASSERT(IsEnd() == FALSE); 

        if (m_pos)
            m_map.GetNextAssoc(m_pos, m_key, m_value); 
        else 
            m_bEnd = TRUE;
    }

// Implementation
private:   
    VALUE       m_value;
    KEY         m_key;
    MAP&        m_map;
    POSITION    m_pos;
    BOOL        m_bEnd;
};




HRESULT 
DataObject_GetHGLOBALData(
    IDataObject* piDataObject, 
    CLIPFORMAT cfClipFormat,
    HGLOBAL* phGlobal);


template <typename DATATYPE>
HRESULT ExtractData(IDataObject* pDO, CLIPFORMAT cf, DATATYPE* pDATATYPE)
{
    ASSERT(pDO != NULL);
    ASSERT(pDATATYPE!= NULL);

    if (pDO == NULL || pDATATYPE == NULL)
        return E_POINTER;

    HGLOBAL hGlobal = NULL;
    HRESULT hr = DataObject_GetHGLOBALData(pDO, cf, &hGlobal);
    if (FAILED(hr))
        return hr;

    DATATYPE* pdata = reinterpret_cast<DATATYPE*>(::GlobalLock(hGlobal));
    ASSERT(pdata != NULL);
    *pDATATYPE = *pdata;
    ::GlobalUnlock(hGlobal);
    ::GlobalFree(hGlobal);
    
    return S_OK;
}




#endif // NMTEMPL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\nmutil.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      nmutil.cpp
 *
 *  Contents:  
 *
 *  History:   
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "nmutil.h"
#include "rsltitem.h"


COMPONENTID GetComponentID (CNode* pNode, CResultItem* pri /* =0 */)
{
    ASSERT(pNode != NULL || ((pri != NULL) && (pri->IsScopeItem())));

    CNode* pNodeContext = pNode;

    if ((pri != NULL) && pri->IsScopeItem())
        pNodeContext = CNode::FromResultItem (pri);

    ASSERT(pNodeContext != NULL);
    ASSERT(pNodeContext->IsInitialized() == TRUE);
    ASSERT(pNodeContext->GetPrimaryComponent() != NULL);
    return pNodeContext->GetPrimaryComponent()->GetComponentID();
}


CComponent* GetComponent (CNode* pNode, CResultItem* pri /* =0 */)
{
    ASSERT(pNode != NULL);

    if (pri != NULL)
    {
        if (pri->IsScopeItem())
        {
            CNode* pNode = CNode::FromResultItem (pri);
            if (pNode == NULL)
                return (NULL);

            if (pNode->IsInitialized() == FALSE)
            {
                HRESULT hr = pNode->InitComponents();
                if (FAILED(hr))
                    return NULL;
            }

            return pNode->GetPrimaryComponent();
        }
        else 
        {
            return pNode->GetComponent (pri->GetOwnerID());
        }
    }

    return pNode->GetPrimaryComponent();
}

void GetComponentsForMultiSel (CNode* pNode, CComponentPtrArray& rgComps)
{
    ASSERT(pNode != NULL);
    ASSERT(pNode->GetViewData() != NULL);
    ASSERT(rgComps.GetSize() == 0);

    HWND hwnd = pNode->GetViewData()->GetListCtrl();
    BOOL bVirtual = pNode->GetViewData()->IsVirtualList();

    ASSERT(hwnd != NULL);
    ASSERT(::IsWindow(hwnd));

    int iNext = ListView_GetNextItem(hwnd, -1, LVNI_SELECTED);

    CComponent* pCC;
    long lData;

    if (bVirtual)
    {
        pCC = pNode->GetPrimaryComponent();
    }
    else
    {
        lData = ListView_GetItemData(hwnd, iNext);
        ASSERT(lData != 0);
        pCC = ::GetComponent(pNode, CResultItem::FromHandle (lData));
    }

    if (pCC == NULL)
    {
        rgComps.RemoveAll();
        return;
    }
    
    rgComps.AddComponent(pCC);

    // if virtual list, all items are from the same component
    if (bVirtual)
        return;

    while ((iNext = ListView_GetNextItem(hwnd, iNext, LVNI_SELECTED)) != -1)
    {
        lData = ListView_GetItemData(hwnd, iNext);
        ASSERT(lData != 0);
        CComponent* pCCTemp = GetComponent(pNode, CResultItem::FromHandle (lData));
        
        if (pCCTemp == NULL)
        {
            rgComps.RemoveAll();
            return;
        }

        if (pCCTemp != pCC)
            rgComps.AddComponent(pCCTemp);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\node.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       Node.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    9/16/1996   RaviR   Created
//
//____________________________________________________________________________

#include "stdafx.h"
#include "macros.h"
#include "strings.h"
#include "ndmgr.h"
#include "regutil.h"
#include "taskenum.h"
#include "nodemgr.h"
#include "multisel.h"
#include "rsltitem.h"
#include "colwidth.h"
#include "viewpers.h"
#include "tasks.h"
#include "conview.h"
#include "columninfo.h"
#include "util.h" // for CoTaskDupString
#include "mmcprotocol.h"
#include "nodemgrdebug.h"
#include "copypast.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/*+-------------------------------------------------------------------------*
 * class CConsoleTaskpadViewExtension
 *
 *
 * PURPOSE: Implements console taskpads as a view extension
 *
 *+-------------------------------------------------------------------------*/
class CConsoleTaskpadViewExtension
{
public:
    /*+-------------------------------------------------------------------------*
     *
     * ScGetViews
     *
     * PURPOSE: Adds all console taskpad views to the view extension callback.
     *
     * PARAMETERS:
     *    CNode *   pNode                                   :
     *    LPVIEWEXTENSIONCALLBACK    pViewExtensionCallback :
     *
     * RETURNS:
     *    SC
     *
     *+-------------------------------------------------------------------------*/
    static SC ScGetViews(CNode *pNode, LPVIEWEXTENSIONCALLBACK   pViewExtensionCallback)
    {
        DECLARE_SC(sc, TEXT("CConsoleTaskpadViewExtension::ScGetViews"));

        CScopeTree* pScopeTree = CScopeTree::GetScopeTree();

        sc = ScCheckPointers(pNode, pViewExtensionCallback, pScopeTree, E_FAIL);
        if(sc)
            return sc;

        // get a filtered list of taskpads that apply to this node.
        CConsoleTaskpadFilteredList filteredList;

        sc = pScopeTree->GetConsoleTaskpadList()->ScGetTaskpadList(pNode, filteredList);
        if(sc)
            return sc;

        for(CConsoleTaskpadFilteredList::iterator iter = filteredList.begin(); iter!= filteredList.end(); ++iter)
        {
            CConsoleTaskpad *pConsoleTaskpad = *iter;
            sc = ScAddViewForTaskpad(pConsoleTaskpad, pViewExtensionCallback);
            if(sc)
                return sc;
        }


        return sc;
    }


    /*+-------------------------------------------------------------------------*
     * ScGetTaskpadViewExtension
     *
     * Returns S_OK if the given CLSID matches the CLSID of any taskpad view
     * extension for the given node, S_FALSE or error otherwise.
     *--------------------------------------------------------------------------*/

    static SC ScGetViewExtensionTaskpad (CNode* pNode, const CLSID& clsid, CConsoleTaskpad*& pConsoleTaskpad)
    {
        DECLARE_SC (sc, _T("CConsoleTaskpadViewExtension::ScGetTaskpadViewExtension"));

        /*
         * initialize output
         */
        pConsoleTaskpad = NULL;

        /*
         * check input
         */
        sc = ScCheckPointers (pNode);
        if(sc)
            return sc;

        CScopeTree* pScopeTree = CScopeTree::GetScopeTree();
        sc = ScCheckPointers (pScopeTree, E_UNEXPECTED);
        if (sc)
            return (sc);

        // get a filtered list of taskpads that apply to this node.
        CConsoleTaskpadFilteredList filteredList;

        sc = pScopeTree->GetConsoleTaskpadList()->ScGetTaskpadList(pNode, filteredList);
        if(sc)
            return sc;

        for(CConsoleTaskpadFilteredList::iterator iter = filteredList.begin(); iter!= filteredList.end(); ++iter)
        {
            CConsoleTaskpad* pTempConsoleTaskpad = *iter;
            sc = ScCheckPointers (pTempConsoleTaskpad, E_UNEXPECTED);
            if (sc)
                return (sc);

            /*
             * if the CLSID matches the ID of this taskpad, CLSID refers to
             * a taskpad view extension
             */
            if (clsid == pTempConsoleTaskpad->GetID())
            {
                pConsoleTaskpad = pTempConsoleTaskpad;
                break;
            }
        }

        return (sc);
    }

private:


    /*+-------------------------------------------------------------------------*
     *
     * ScAddViewForTaskpad
     *
     * PURPOSE: Adds a view based on a console taskpad to the view extension
     *          callback.
     *
     * PARAMETERS:
     *    CConsoleTaskpad *        pConsoleTaskpad :
     *    LPVIEWEXTENSIONCALLBACK  pViewExtensionCallback :
     *
     * RETURNS:
     *    SC
     *
     *+-------------------------------------------------------------------------*/
    static SC ScAddViewForTaskpad(CConsoleTaskpad *pConsoleTaskpad, LPVIEWEXTENSIONCALLBACK pViewExtensionCallback)
    {
        DECLARE_SC(sc, TEXT("CConsoleTaskpadViewExtension::ScAddViewForTaskpad"));

        // validate inputs
        sc = ScCheckPointers(pConsoleTaskpad, pViewExtensionCallback);
        if(sc)
            return sc;

        MMC_EXT_VIEW_DATA extViewData = {0};

        // get the string form of the taskpad ID.
        CCoTaskMemPtr<WCHAR> spszTaskpadID;
        sc = StringFromCLSID (pConsoleTaskpad->GetID(), &spszTaskpadID);
        if (sc)
            return sc;

        std::wstring strTaskpad = _W(MMC_PROTOCOL_SCHEMA_NAME) _W(":");
        strTaskpad += spszTaskpadID;

        extViewData.pszURL = strTaskpad.c_str();

        extViewData.bReplacesDefaultView = pConsoleTaskpad->FReplacesDefaultView() ? TRUE : FALSE; // convert from bool to BOOL
        extViewData.viewID       = pConsoleTaskpad->GetID();                            // set the GUID identifier of the view

        USES_CONVERSION;
        tstring strName = pConsoleTaskpad->GetName();
        extViewData.pszViewTitle = T2COLE(strName.data()); // set the title of the view

        if(!extViewData.pszViewTitle)
            return (sc = E_OUTOFMEMORY).ToHr();

        sc = pViewExtensionCallback->AddView(&extViewData);

        return sc;
    }

};

//############################################################################
//############################################################################
//
//  Implementation of class CComponent
//
//############################################################################
//############################################################################

DEBUG_DECLARE_INSTANCE_COUNTER(CComponent);

void CComponent::Construct(CSnapIn * pSnapIn, CComponent* pComponent)
{
    ASSERT(pSnapIn);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CComponent);

    m_spSnapIn = pSnapIn;
    m_ComponentID = -1;
    m_bIComponentInitialized = false;

    if (pComponent)
    {
        ASSERT(pComponent->m_spIComponent != NULL);
        ASSERT(pComponent->m_spIFrame != NULL);

        m_spIComponent = pComponent->m_spIComponent;
        m_spIFrame = pComponent->m_spIFrame;
        m_spIRsltImageList = pComponent->m_spIRsltImageList;

        m_ComponentID = pComponent->GetComponentID();
    }
}

CComponent::~CComponent()
{
    DECLARE_SC(sc, TEXT("CComponent::~CComponent"));

    DEBUG_DECREMENT_INSTANCE_COUNTER(CComponent);

    if (m_spIFrame)
    {
        sc = m_spIFrame->SetHeader(NULL);
        if (sc)
            sc.TraceAndClear();
    }

    if (m_spIComponent)
    {
        sc = m_spIComponent->Destroy(NULL);
        if (sc)
            sc.TraceAndClear();
    }
}

HRESULT CComponent::Init(IComponentData* pIComponentData, HMTNODE hMTNode,
                         HNODE lNode,
                         COMPONENTID nComponentID, int viewID)
{
    DECLARE_SC(sc, TEXT("CComponent::Init"));

    ASSERT(hMTNode != 0);
    ASSERT(lNode != 0);

    sc = ScCheckPointers( pIComponentData, E_POINTER );
    if (sc)
        return sc.ToHr();

    do
    {
        sc = pIComponentData->CreateComponent(&m_spIComponent);
        if (sc)
            break;

        // recheck the pointers
        sc = ScCheckPointers( m_spIComponent, E_UNEXPECTED );
        if (sc)
            break;

        // Create an IFrame for this IComponent
        #if _MSC_VER>=1100
        sc = m_spIFrame.CreateInstance(CLSID_NodeInit, NULL, MMC_CLSCTX_INPROC);
        #else
        sc = m_spIFrame.CreateInstance(CLSID_NodeInit, MMC_CLSCTX_INPROC);
        #endif
        if (sc)
            break;

        // recheck the pointer
        sc = ScCheckPointers( m_spIFrame, E_UNEXPECTED );
        if (sc)
            break;

        Debug_SetNodeInitSnapinName(m_spSnapIn, m_spIFrame.GetInterfacePtr());

        // Cache the IComponent in the NodeInit object
        sc = m_spIFrame->SetComponent(m_spIComponent);
        if (sc)
            break;

        // recheck the pointer
        sc = ScCheckPointers( m_spSnapIn, E_UNEXPECTED );
        if (sc)
            break;

        // Create scope image list
        sc = m_spIFrame->CreateScopeImageList(m_spSnapIn->GetSnapInCLSID());
        if (sc)
            break;

        sc = m_spIFrame->SetNode(hMTNode, lNode);
        if (sc)
            break;

        ASSERT(nComponentID == GetComponentID());
        sc = m_spIFrame->SetComponentID(nComponentID);
        if (sc)
            break;

        // Result Image list is optional
        m_spIRsltImageList = m_spIFrame;
        sc = ScCheckPointers( m_spIRsltImageList, E_FAIL );
        if (sc)
            sc.TraceAndClear();

        // Complete IComponent initialization.
        // Init m_spIComponent with m_spIFrame.
        sc = m_spIComponent->Initialize(m_spIFrame);
        if (sc)
            break;

        CMTNode* const pMTNode = CMTNode::FromHandle (hMTNode);
        sc = ScCheckPointers( pMTNode, E_UNEXPECTED );
        if (sc)
            break;

        CMTSnapInNode* const pSnapInNode = pMTNode->GetStaticParent();
        sc = ScCheckPointers( pSnapInNode, E_UNEXPECTED );
        if (sc)
            break;

        sc = pSnapInNode->ScInitIComponent(this, viewID);
        if (sc)
            break;

    } while (0);

    if (sc)
    {
        m_spIComponent = NULL;
        m_spIFrame = NULL;
        m_spIRsltImageList = NULL;
    }

    return sc.ToHr();
}

inline HRESULT CComponent::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event,
                                  LONG_PTR arg, LPARAM param)
{
    ASSERT(m_spIComponent != NULL);
    if (m_spIComponent == NULL)
        return E_FAIL;

    HRESULT hr = S_OK;
    __try
    {
        hr = m_spIComponent->Notify(lpDataObject, event, arg, param);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_FAIL;

        if (m_spSnapIn)
            TraceSnapinException(m_spSnapIn->GetSnapInCLSID(), TEXT("IComponent::Notify"), event);
    }

    return hr;
}

SC CComponent::ScQueryDispatch(MMC_COOKIE cookie,
                                      DATA_OBJECT_TYPES type,
                                      PPDISPATCH ppSelectedObject)
{
    DECLARE_SC(sc, _T("CComponent::ScQueryDispatch"));
    sc = ScCheckPointers(m_spIComponent, E_UNEXPECTED);
    if (sc)
        return sc;

    IComponent2Ptr spComponent2 = m_spIComponent;
    sc = ScCheckPointers(spComponent2.GetInterfacePtr(), E_NOINTERFACE);
    if (sc)
        return sc;

    sc = spComponent2->QueryDispatch(cookie, type, ppSelectedObject);

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CComponent::ScResetConsoleVerbStates
//
//  Synopsis:    Reset the verbstates in the CConsoleVerbImpl (the one
//               snapin is aware of).
//
//  Arguments:   None
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CComponent::ScResetConsoleVerbStates ()
{
    DECLARE_SC(sc, _T("CComponent::ScResetConsoleVerbStates"));

    IFramePrivate* pIFP = GetIFramePrivate();
    sc = ScCheckPointers(pIFP, E_UNEXPECTED);
    if (sc)
        return sc;

    IConsoleVerbPtr spConsoleVerb;
    sc = pIFP->QueryConsoleVerb(&spConsoleVerb);
    if (sc)
        return sc;

    sc = ScCheckPointers(spConsoleVerb, E_UNEXPECTED);
    if (sc)
        return sc;

    CConsoleVerbImpl* pCVI = dynamic_cast<CConsoleVerbImpl*>(
                                             static_cast<IConsoleVerb*>(spConsoleVerb));
    sc = ScCheckPointers(pCVI, E_UNEXPECTED);
    if (sc)
        return sc;

    pCVI->SetDisabledAll();

    return (sc);
}


//############################################################################
//############################################################################
//
//  Implementation of class CNode
//
//############################################################################
//############################################################################


DEBUG_DECLARE_INSTANCE_COUNTER(CNode);

CNode::CNode (
    CMTNode*    pMTNode,
    CViewData*  pViewData,
    bool        fRootNode) :
    m_pMTNode           (pMTNode),
    m_pViewData         (pViewData),
    m_hri               (0),
    m_dwFlags           (0),
    m_pPrimaryComponent (NULL),
    m_bInitComponents   (TRUE),
    m_fRootNode         (fRootNode),
    m_fStaticNode       (false)
{
    CommonConstruct();
}

CNode::CNode (
    CMTNode*    pMTNode,
    CViewData*  pViewData,
    bool        fRootNode,
    bool        fStaticNode) :
    m_pMTNode           (pMTNode),
    m_pViewData         (pViewData),
    m_hri               (0),
    m_dwFlags           (0),
    m_pPrimaryComponent (NULL),
    m_bInitComponents   (TRUE),
    m_fRootNode         (fRootNode),
    m_fStaticNode       (fStaticNode)
{
    CommonConstruct();
}

CNode::CNode(const CNode& other) :
    m_pMTNode           (other.m_pMTNode),
    m_pViewData         (other.m_pViewData),
    m_hri               (other.m_hri),
    m_dwFlags           (other.m_dwFlags),
    m_pPrimaryComponent (other.m_pPrimaryComponent),
    m_bInitComponents   (other.m_bInitComponents),
    m_fRootNode         (other.m_fRootNode),
    m_fStaticNode       (other.m_fStaticNode)
{
    CommonConstruct();
}


void CNode::CommonConstruct ()
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CNode);

    ASSERT (m_pMTNode != NULL);
    m_pMTNode->AddRef();
}


CNode::~CNode()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CNode);

    CDataObjectCleanup::ScUnadviseNode( this );

    /*
     * if this is a non-static root node, delete the static
     * parent node that was created for us in CMTNode::GetNode
     */
    if (IsRootNode() && !IsStaticNode())
        delete GetStaticParent();

    ASSERT (m_pMTNode != NULL);
    m_pMTNode->Release();
}


/*+-------------------------------------------------------------------------*
 * CNode::FromResultItem
 *
 * Converts a CResultItem to the CNode it references.  This should only
 * be called for CResultItems that represent scope items.
 *
 * This function is out-of-line to eliminate coupling between node.h and
 * rsltitem.h.
 *--------------------------------------------------------------------------*/

CNode* CNode::FromResultItem (CResultItem* pri)
{
    CNode* pNode = NULL;

    if (pri != NULL)
    {
        /*
         * only call for scope items
         */
        ASSERT (pri->IsScopeItem());

        if (pri->IsScopeItem())
            pNode = CNode::FromHandle (pri->GetScopeNode());
    }

    return (pNode);
}

HRESULT
CNode::OnExpand(bool fExpand)
{
    HRESULT hr = S_OK;

    if (fExpand == FALSE)
    {
        return (WasExpandedAtLeastOnce() == TRUE) ? S_OK : S_FALSE;
    }

    if (WasExpandedAtLeastOnce() == TRUE)
        return S_FALSE;

    CMTNode* pMTNode = GetMTNode();

    if (pMTNode->WasExpandedAtLeastOnce() == FALSE)
        hr = pMTNode->Expand();

    return hr;
}

void CNode::ResetControlbars(BOOL bSelect, SELECTIONINFO* pSelInfo)
{
    ASSERT(pSelInfo != NULL);

    CViewData* pVD = GetViewData();
    ASSERT(pVD != NULL);
    if (!pVD)
        return;

    // Reset controlbars
    CControlbarsCache* pCtrlbarsCache =
        dynamic_cast<CControlbarsCache*>(GetControlbarsCache());
    ASSERT(pCtrlbarsCache != NULL);

    if (pCtrlbarsCache != NULL)
    {
        if (pSelInfo->m_bScope == TRUE)
            pCtrlbarsCache->OnScopeSelChange(this, bSelect);
        else if (pSelInfo->m_bBackground == FALSE)
            pCtrlbarsCache->OnResultSelChange(this, pSelInfo->m_lCookie,
                                              bSelect);
    }
}


//+-------------------------------------------------------------------
//
//  Member:      CNode::ScInitializeVerbs
//
//  Synopsis:    Selection has changed so initialize the verbs for given
//               selection information.
//
//  Arguments:   [bSelect]  - [in] Select or Deselect of an item.
//               [pSelInfo] - [in] SELECTIONINFO ptr.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CNode::ScInitializeVerbs (bool bSelect, SELECTIONINFO* pSelInfo)
{
    DECLARE_SC(sc, _T("CNode::ScInitializeVerbs"));
    sc = ScCheckPointers(pSelInfo);
    if (sc)
        return sc;

    CViewData *pViewData = GetViewData();
    sc = ScCheckPointers(pViewData, E_UNEXPECTED);
    if (sc)
        return sc;

    CVerbSet *pVerbSet = dynamic_cast<CVerbSet*>(pViewData->GetVerbSet());
    sc = ScCheckPointers(pVerbSet, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = pVerbSet->ScInitialize(this, pSelInfo->m_bScope, bSelect,
                                pSelInfo->m_bBackground, pSelInfo->m_lCookie);
    if (sc)
        return sc;

    return (sc);
}


HRESULT CNode::GetDispInfo(LV_ITEMW* plvi)
{
    ASSERT(plvi != NULL);

    if (plvi->iSubItem == 0)
    {
        if (plvi->mask & LVIF_IMAGE)
        {
            plvi->iImage = GetResultImage();
            ASSERT (plvi->iImage != -1);
            if (plvi->iImage == -1)
                plvi->iImage = 0;
        }

        if (plvi->mask & LVIF_TEXT)
        {
            tstring strName = GetDisplayName();

            if (!strName.empty())
            {
                USES_CONVERSION;
                wcsncpy (plvi->pszText, T2CW (strName.data()), plvi->cchTextMax);
            }
            else
                plvi->pszText[0] = 0;
        }
    }
    else if ((plvi->mask & LVIF_TEXT) && (plvi->cchTextMax > 0))
    {
        plvi->pszText[0] = 0;
    }

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     ScGetDataObject
//
//  Synopsis:   Given scope/result and cookie (lParam, if it is result item),
//              get the dataobject of the item.
//
//  Arguments:
//              [bScopePane]        - [in] Scope or Result.
//              [lResultItemCookie] - [in] If Result pane is selected the item param.
//              [bScopeItem]        - [out] Is the dataobject returned for scope or result item.
//                                          The scope item can be in result pane.
//              [ppDataObject]      - [out] The data-object (return val)
//              [ppCComponent]      - [out] NULL def parameter. The CComponent of the item. In case
//                                          of multiselection, the items may belong to more than one
//                                          component so a NULL is returned.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CNode::ScGetDataObject(bool bScopePane, LPARAM lResultItemCookie, bool& bScopeItem,
                          LPDATAOBJECT* ppDataObject, CComponent **ppCComponent /*= NULL*/)
{
    DECLARE_SC(sc, _T("CNode::ScGetDataObject"));
    IDataObjectPtr spDataObject;
    CComponent    *pCC = NULL;

    if (ppDataObject == NULL)
        return (sc = E_POINTER);

    *ppDataObject = NULL; // init
    if (ppCComponent)
        *ppCComponent = NULL;

    bScopeItem = bScopePane;

    // In MMC1.0 when result pane background is selected, for any
    // toolbar operation we pass the dataobject of scope selected item.
    // The following code is added for this compatibility.
    if (lResultItemCookie == LVDATA_BACKGROUND) // =>Result background has focus
    {
        bScopeItem = TRUE;
    }

    if (bScopeItem) // => Scope pane has focus
    {
        CMTNode* pMTNode = GetMTNode();
        if (NULL == pMTNode)
            return (sc = E_UNEXPECTED);
        sc = pMTNode->QueryDataObject(CCT_SCOPE, &spDataObject);
        if (sc)
            return sc;

        pCC = GetPrimaryComponent();
    }
    else if (lResultItemCookie == LVDATA_CUSTOMOCX) // => Custom OCX has focus
    {
        *ppDataObject = DOBJ_CUSTOMOCX;
        pCC = GetPrimaryComponent();
    }
    else if (lResultItemCookie == LVDATA_CUSTOMWEB) // => Web has focus
    {
        *ppDataObject = DOBJ_CUSTOMWEB;
        pCC = GetPrimaryComponent();
    }
    else if (lResultItemCookie == LVDATA_MULTISELECT) // => multi selection
    {
        // Do not calculate CComponent for multisel dataobject as there are multiple
        // items and they can be from different snapins (so different components).
        CViewData* pVD = GetViewData();
        if (NULL == pVD)
            return (sc = E_UNEXPECTED);

        CMultiSelection* pMS = pVD->GetMultiSelection();
        if (NULL == pMS)
            return (sc = E_UNEXPECTED);

        sc = pMS->GetMultiSelDataObject(ppDataObject);
        if (sc)
            return sc;
    }
    else // result item has focus
    {
        CViewData* pVD = GetViewData();
        if (NULL == pVD)
            return (sc = E_UNEXPECTED);

        if (! pVD->IsVirtualList())
        {
            CResultItem* pri = CResultItem::FromHandle (lResultItemCookie);

            if (pri != NULL)
            {
                bScopeItem = pri->IsScopeItem();
                lResultItemCookie = pri->GetSnapinData();

                if (! bScopeItem)
                    pCC = GetComponent(pri->GetOwnerID());
            }
        }
        else
            pCC = GetPrimaryComponent();

        if (bScopeItem)
        {
            CNode* pNode = CNode::FromHandle((HNODE) lResultItemCookie);
            CMTNode* pMTNode = pNode ? pNode->GetMTNode() : NULL;

            if (NULL == pMTNode)
                return (sc = E_UNEXPECTED);

            sc = pMTNode->QueryDataObject(CCT_SCOPE, &spDataObject);
            if (sc)
                return sc;

            pCC = pNode->GetPrimaryComponent();
            sc = ScCheckPointers(pCC, E_UNEXPECTED);
            if (sc)
                return sc;
        }
        else
        {
            if (NULL == pCC)
                return (sc = E_UNEXPECTED);
            sc = pCC->QueryDataObject(lResultItemCookie, CCT_RESULT, &spDataObject);
            if (sc)
                return sc;
        }
    }

    // if required, get the component of this node
    if (ppCComponent)
    {
        *ppCComponent = pCC;
        sc = ScCheckPointers( *ppCComponent, E_UNEXPECTED );
        if (sc)
            return sc;
    }

    if (SUCCEEDED(sc.ToHr()) && *ppDataObject == NULL)
        *ppDataObject = spDataObject.Detach();

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      CNode::ScGetDropTargetDataObject
//
//  Synopsis:    Given the context get the data object that allows the
//               to be drop target (allows paste).
//
//               In MMC1.2 the drop target is always scope node. In MMC2.0
//               it can be any non-virtual (??) result item. If the snapin
//               has RVTI_LIST_OPTIONS_ALLOWPASTE set, then if the item selected
//               is in result pane then data object corresponds to result item
//               else it is scope item.
//
//  Arguments:
//              [bScopePane]        - Scope or Result.
//              [lResultItemCookie] - If Result pane is selected the item param.
//              [ppDataObject]      - The data-object (return val)
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CNode::ScGetDropTargetDataObject(bool bScopePane, LPARAM lResultItemCookie, LPDATAOBJECT *ppDataObject)
{
    DECLARE_SC(sc, _T("CNode::ScGetDropTargetDataObject"));
    sc = ScCheckPointers(ppDataObject);
    if (sc)
        return sc;

    *ppDataObject = NULL;

    CViewData *pViewData = GetViewData();
    sc = ScCheckPointers(pViewData, E_UNEXPECTED);
    if (sc)
        return sc;

    if (pViewData->GetListOptions() & RVTI_LIST_OPTIONS_ALLOWPASTE)
    {
        bool bScopeItem;
        // MMC2.0 use the given context.
        sc = ScGetDataObject(bScopePane, lResultItemCookie, bScopeItem, ppDataObject);
        if (sc)
            return sc;
    }
    else
    {
        // MMC1.2 Always scope node.
        sc = QueryDataObject(CCT_SCOPE, ppDataObject);
        if (sc)
            return sc;
    }

    return (sc);
}


/*+-------------------------------------------------------------------------*
 *
 * CNode::ScGetPropertyFromINodeProperties
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    BOOL    bForScopeItem :
 *    LPARAM  resultItemParam :
 *    BSTR    bstrPropertyName :
 *    PBSTR   pbstrPropertyValue :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CNode::ScGetPropertyFromINodeProperties(LPDATAOBJECT pDataObject, BOOL bForScopeItem, LPARAM resultItemParam, BSTR bstrPropertyName, PBSTR  pbstrPropertyValue)
{
    //DECLARE_SC(sc, TEXT("CNode::ScGetPropertyFromINodeProperties"));
    SC sc; // do not use DECLARE_SC here - want to silently ignore errors

    sc = ScCheckPointers(pDataObject, bstrPropertyName, pbstrPropertyValue);
    if(sc)
        return sc;

    if(bForScopeItem)
    {
        // get the MTNode
        CMTNode * pMTNode = GetMTNode();

        sc = ScCheckPointers(pMTNode, E_UNEXPECTED);
        if(sc)
            return sc;

        // ask MTNode to get it
        sc = pMTNode->ScGetPropertyFromINodeProperties(pDataObject, bstrPropertyName, pbstrPropertyValue);
        if(sc)
            return sc;

        // done!
        return sc;
    }

    // for result item.

    CComponent *pComponent = GetPrimaryComponent();

    sc = ScCheckPointers(pComponent);
    if(sc)
    {
        SC scRet = sc; // returns but does not trace the error
        sc.Clear();
        return scRet;
    }

    // get the IComponent and QI for INodeProperties
    INodePropertiesPtr spNodeProperties  = pComponent->GetIComponent();

    // at this point we should have a valid interface if it is supported
    sc = ScCheckPointers(spNodeProperties, E_NOINTERFACE);
    if(sc)
        return sc;

    sc = spNodeProperties->GetProperty(pDataObject,  bstrPropertyName, pbstrPropertyValue);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CNode::ScExecuteShellCommand
 *
 * PURPOSE: Executes a shell command with the specified parameters in the
 *          specified directory with the correct window size
 *
 * PARAMETERS:
 *    BSTR  Command :
 *    BSTR  Directory :
 *    BSTR  Parameters :
 *    BSTR  WindowState :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CNode::ScExecuteShellCommand(BSTR Command, BSTR Directory, BSTR Parameters, BSTR WindowState)
{
    DECLARE_SC(sc, TEXT("CNode::ScExecuteShellCommand"));

    sc = ScCheckPointers(Command, Directory, Parameters, WindowState);
    if(sc)
        return sc;

    USES_CONVERSION;

    CStr strParameters = W2T(Parameters);
    CStr strWindowState= W2T(WindowState);

    if(strWindowState.GetLength()==0)
        strWindowState= XML_ENUM_WINDOW_STATE_RESTORED; // normal

    SHELLEXECUTEINFO sei;
    ZeroMemory (&sei, sizeof(sei));

    sei.cbSize       = sizeof(sei);
    sei.lpFile       = W2T(Command);
    sei.lpParameters = strParameters;
    sei.lpDirectory  = W2T(Directory);
    sei.fMask        = SEE_MASK_NOCLOSEPROCESS | SEE_MASK_DOENVSUBST;

    sei.nShow        = (strWindowState == XML_ENUM_WINDOW_STATE_MAXIMIZED) ? SW_SHOWMAXIMIZED :
                       (strWindowState == XML_ENUM_WINDOW_STATE_MINIMIZED) ? SW_SHOWMINIMIZED :
                                                                             SW_SHOWNORMAL ;

    if (ShellExecuteEx(&sei))
        CloseHandle (sei.hProcess);
    else
        sc = ScFromWin32((GetLastError ()));

    return sc;
}

//############################################################################
//############################################################################
//
//  Implementation of class COCX
//
//############################################################################
//############################################################################

DEBUG_DECLARE_INSTANCE_COUNTER(COCX);


//############################################################################
//############################################################################
//
//  Implementation of class COCXNode
//
//############################################################################
//############################################################################

DEBUG_DECLARE_INSTANCE_COUNTER(COCXNode);


HRESULT CNode::InitComponents()
{
    DECLARE_SC(sc, TEXT("CNode::InitComponents"));

    if (m_bInitComponents == FALSE)
        return S_OK;

    HRESULT hr = S_OK;

    // Initialize the component.

    CMTNode * pMTNode = GetMTNode();
    if (pMTNode == NULL)
        return (E_UNEXPECTED);

    // Ensure the master node is initialized.
    if (!pMTNode->IsInitialized())
        hr = pMTNode->Init();

    if (FAILED(hr))
        return hr;

    CMTSnapInNode* pMTSnapInNode = pMTNode->GetStaticParent();
    if (pMTSnapInNode == NULL)
        return (E_UNEXPECTED);

    HMTNODE hMTNode = CMTNode::ToHandle(pMTSnapInNode);
    HNODE   hNode   = CNode::ToHandle(GetStaticParent());

    CSnapIn* pSnapIn = pMTNode->GetPrimarySnapIn();
    if (pSnapIn == NULL)
        return (E_UNEXPECTED);

    CComponentData* pCCD = pMTSnapInNode->GetComponentData(pSnapIn->GetSnapInCLSID());
    if (pCCD == NULL)
        return E_FAIL;

    if (m_pPrimaryComponent == NULL)
        m_pPrimaryComponent = pMTSnapInNode->GetComponent(GetViewID(),
                                            pCCD->GetComponentID(), pSnapIn);

    if(m_pPrimaryComponent == NULL)
        return E_UNEXPECTED;

    ASSERT(m_pPrimaryComponent != NULL);

    //
    // Init PRIMARY Component.
    //

    if (!m_pPrimaryComponent->IsInitialized())
    {
        ASSERT(pCCD->GetComponentID() == m_pPrimaryComponent->GetComponentID());

        hr = m_pPrimaryComponent->Init(pCCD->GetIComponentData(), hMTNode, hNode,
                                       pCCD->GetComponentID(), GetViewID());

        // Abort if PRIMARY Component fails to init.
        if (FAILED(hr))
            return hr;
    }

    m_bInitComponents = FALSE;

    //
    // Now initalize the extension components. (create them if necessary)
    //

    // Get the node-type of this node
    GUID guidNodeType;
    //hr = pCCD->GetNodeType(pMTNode->GetUserParam(), &guidNodeType);
    hr = pMTNode->GetNodeType(&guidNodeType);
    CHECK_HRESULT(hr);
    if (FAILED(hr))
        return hr;

    LPCLSID pDynExtCLSID;
    int cDynExt = pMTNode->GetDynExtCLSID(&pDynExtCLSID);

    CExtensionsIterator it;
    // TODO: try to use the easier form of it.ScInitialize()
    sc = it.ScInitialize(pSnapIn, guidNodeType, g_szNameSpace, pDynExtCLSID, cDynExt);
    if(sc)
        return S_FALSE;

    BOOL fProblem = FALSE;

    for (; it.IsEnd() == FALSE; it.Advance())
    {
        pCCD = pMTSnapInNode->GetComponentData(it.GetCLSID());
        if (pCCD == NULL)
            continue;

        CComponent* pCC = pMTSnapInNode->GetComponent(GetViewID(),
                                pCCD->GetComponentID(), pCCD->GetSnapIn());

        if (pCC->IsInitialized() == TRUE)
            continue;

        hr = pCC->Init(pCCD->GetIComponentData(), hMTNode, hNode,
                       pCCD->GetComponentID(), GetViewID());

        CHECK_HRESULT(hr);
        if (FAILED(hr))
            fProblem = TRUE;    // Continue even on error.
    }

    if (fProblem == TRUE)
    {
        // TODO: Put up an error message.
        hr = S_FALSE;
    }

    return hr;
}

/*+-------------------------------------------------------------------------*
 *
 * CNode::OnInitOCX
 *
 * PURPOSE: Sends the MMCN_INITOCX notification when an OCX is created.
 *
 * PARAMETERS:
 *    IUnknown* pUnk :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CNode::OnInitOCX(IUnknown* pUnk)
{
    DECLARE_SC(sc, TEXT("CNode::OnInitOCX"));

    IDataObjectPtr spdtobj;
    sc = QueryDataObject(CCT_SCOPE, &spdtobj);
    if(sc)
        return sc.ToHr();

    CComponent* pCC = GetPrimaryComponent();
    sc = ScCheckPointers(pCC);
    if(sc)
        return sc.ToHr();

    sc = pCC->Notify(spdtobj, MMCN_INITOCX, 0, reinterpret_cast<LPARAM>(pUnk));
    sc.Clear(); // must ignore errors here - Disk management returns E_UNEXPECTED.!

    return sc.ToHr();
}

HRESULT CNode::OnCacheHint(int nStartIndex, int nEndIndex)
{
    CComponent* pCC = GetPrimaryComponent();
    ASSERT(pCC != NULL);
    if (pCC == NULL)
        return E_FAIL;

    IResultOwnerDataPtr spIResultOwnerData = pCC->GetIComponent();
    if (spIResultOwnerData == NULL)
        return S_FALSE;

    return spIResultOwnerData->CacheHint(nStartIndex, nEndIndex);
}

/***************************************************************************\
 *
 * METHOD:  CNode::ScInitializeViewExtension
 *
 * PURPOSE: Sets callback representing view extension
 *
 * PARAMETERS:
 *    const CLSID& clsid    - [in] view extension CLSID
 *    CViewData *pViewData  - [in] view data
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CNode::ScInitializeViewExtension(const CLSID& clsid, CViewData *pViewData)
{
    DECLARE_SC(sc, TEXT("CNode::ScInitializeViewExtension"));

    sc = ScCheckPointers(pViewData);
    if (sc)
        return sc;

    /*
     * Get the CConsoleTaskpad that goes with it this view extension.
     * If this is an ordinary (i.e. not taskpad) view extension,
     * ScGetViewExtensionTaskpad will set pConsoleTaskpad to NULL.
     */
    CConsoleTaskpad* pConsoleTaskpad = NULL;
    sc = CConsoleTaskpadViewExtension::ScGetViewExtensionTaskpad (this, clsid, pConsoleTaskpad);
    if (sc)
        return (sc);

    typedef CComObject<CConsoleTaskCallbackImpl> t_ViewExtensionCallbackImpl;
    t_ViewExtensionCallbackImpl* pViewExtensionCallbackImpl = NULL;
    sc = t_ViewExtensionCallbackImpl::CreateInstance(&pViewExtensionCallbackImpl);
    if (sc)
        return sc;

    // recheck pointer
    sc = ScCheckPointers(pViewExtensionCallbackImpl, E_UNEXPECTED);
    if (sc)
        return sc;

    pViewData->m_spTaskCallback = pViewExtensionCallbackImpl; // this addrefs/releases the object.

    /*
     * If this is a taskpad, initialize the view extension callback as
     * a taskpad view extension.  Otherwise initialize it as an ordinary
     * view extension.
     */
    if (pConsoleTaskpad != NULL)
    {
        sc = pViewExtensionCallbackImpl->ScInitialize (pConsoleTaskpad,
                                                       CScopeTree::GetScopeTree(),
                                                       this);
    }
    else
        sc = pViewExtensionCallbackImpl->ScInitialize(clsid);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CNode::ScSetViewExtension
 *
 * PURPOSE: Forces a display of the given view extension.
 *
 * PARAMETERS:
 *    GUID * pGuidViewId : [IN]: The view extension to display.
 *    bool   bUseDefaultTaskpad : [IN}
 *    bool bSetViewSettingDirty : [IN] (See below notes)
 *
 * Note:
 * The view-extension-ID comes from
 *
 * 1. Viewsetting if one exists.
 * 2. Given by CONUI when user changes tab for different taskpad.
 * 3. There are cases in which a new view-extension installed (after the console
 *    file was created) that will be default. (This will be calculated in this method).
 *
 * In cases 1 & 3 viewsetting should not be made dirty.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CNode::ScSetViewExtension(GUID *pGuidViewId, bool bUseDefaultTaskpad, bool bSetViewSettingDirty)
{
    DECLARE_SC(sc, TEXT("CNode::ScSetViewExtension"));

    CViewData *     pViewData        = GetViewData();

    sc = ScCheckPointers(pGuidViewId, pViewData);
    if(sc)
        return sc;

    // collect the view extensions
    CViewExtCollection      vecExtensions;
    CViewExtInsertIterator  itExtensions(vecExtensions, vecExtensions.begin());
    sc = ScGetViewExtensions(itExtensions);
    if (sc)
        sc.Trace_();

    if ( bUseDefaultTaskpad )
    {
        // setup proper taskpad (tab to be selected)
        CViewExtCollection::iterator it = vecExtensions.begin();
        if (it != vecExtensions.end())
            *pGuidViewId = it->viewID; // first one if such exist
        else
            *pGuidViewId = GUID_NULL;  // default
    }
    else // locate the extension we need to select
    {
        // see if the extension really exist
        CViewExtCollection::iterator it = vecExtensions.begin();
        bool bDefaultIsReplaced = false;
        while (it != vecExtensions.end() && !IsEqualGUID(*pGuidViewId, it->viewID) )
        {
            bDefaultIsReplaced = bDefaultIsReplaced || it->bReplacesDefaultView;
            ++it;
        }

        // found it?
        bool bFound = (it != vecExtensions.end());
        // one more chance - we were looking for default and one will be added!
        bFound = bFound || ( IsEqualGUID( *pGuidViewId, GUID_NULL ) && !bDefaultIsReplaced );

        if ( !bFound )
        {
            sc = E_FAIL;
        }
    }

    if (sc) // extension missing! need to find the substitute
    {
         sc.Clear(); // ignore error

        // default to first extension or NORMAL view here
        CViewExtCollection::iterator it = vecExtensions.begin();
        if (it != vecExtensions.end())
            *pGuidViewId = it->viewID;  // first available
        else
            *pGuidViewId = GUID_NULL;   // "normal" if it's the only choice
    }

    // set the view extension if one really exist
    if (*pGuidViewId != GUID_NULL)
    {
        sc = ScInitializeViewExtension(*pGuidViewId, GetViewData());
        if (sc)
            sc.TraceAndClear(); // ignore and proceed
    }
    else
    {
        pViewData->m_spTaskCallback = NULL;
    }

    sc = ScSetTaskpadID(*pGuidViewId, bSetViewSettingDirty);
    if (sc)
        return sc;

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      ScGetResultPane
//
//  Synopsis:    Get the result pane data from snapin or persisted data.
//
//  Arguments:   [strResultPane]    -  Result pane name (If it is OCX/WEB)
//               [pViewOptions]     -  View options.
//               [pGuidTaskpadID]   -  If there is a task-pad the ID.
//
//  Returns:     SC
//
//  History:     04-29-1999       AnandhaG       Created
//
//--------------------------------------------------------------------
SC
CNode::ScGetResultPane(CResultViewType &rvt, GUID *pGuidTaskpadID)
{
    DECLARE_SC(sc, TEXT("CNode::ScGetResultPane"));
    sc = ScCheckPointers(pGuidTaskpadID);
    if (sc)
        return sc;

    CComponent *pComponent = GetPrimaryComponent();
    CViewData  *pViewData  = GetViewData();
    sc = ScCheckPointers(pComponent, pViewData, E_UNEXPECTED);
    if(sc)
        return sc;

    IComponent* pIComponent = pComponent->GetIComponent();
    sc = ScCheckPointers(pIComponent,  E_FAIL);
    if (sc)
        return sc;

    // 1. Setup any persisted/default console taskpads or view extensions.
    sc = ScSetupTaskpad(pGuidTaskpadID);
    if (sc)
        return sc;

    // 2. Get the persisted CResultViewType information.
    sc = ScGetResultViewType(rvt);
    if (sc)
        return sc;
    bool bResultViewDataIsPersisted = (sc == S_OK);

    bool bSnapinChangingView        = pViewData->IsSnapinChangingView();
    CResultViewType rvtOriginal;
    CStr strResultPane = _T(""); // init

    // 3. If there is persisted result-view-type data then ask the snapin if it
    //    wants to restore the result-view with this data. If snapin is changing
    //    its view (by re-selection of node) then dont ask this question.
    if (!bSnapinChangingView && bResultViewDataIsPersisted )
    {
        // 3.a) Ask snapin if it wants to restore the result-view with persisted data.
        sc = ScRestoreResultView(rvt);
        if (sc)
            return sc;

        if (S_OK == sc.ToHr()) // snapin accepted the resultviewtype settings so return.
            return sc;

        // 3.b) Snapin refused the persisted CResultViewType data so...

        // cache the data to see if we need to modify the settings
        rvtOriginal = rvt;
        // Throw away the data as it is not accepted by snapin.
        sc = rvt.ScReset();
        if (sc)
            return sc;
    }

    // 4. Ask the snapin for result-view-type data.
    IComponent2Ptr spIComponent2 = pIComponent;
    if(spIComponent2 != NULL)
    {
        // should be able to move all this to a separate function.
        RESULT_VIEW_TYPE_INFO rvti;
        ZeroMemory(&rvti, sizeof(rvti));

        // the snapin supports IComponent2. Use it to get the result view type.
        sc = spIComponent2->GetResultViewType2(GetUserParam(), &rvti);
        if(sc)
            return sc;

        // at this point, we have a valid RESULT_VIEW_TYPE_INFO structure. Initialize the contents into rvt, which zeros out the structure
        // and releases all the allocated strings
        sc = rvt.ScInitialize(rvti);
        if(sc)
            return sc;
    }
    else
    {
        // the snapin does not support IComponent2. Use IComponent to
        // get the result view type from the snapin.
        LPOLESTR pszView = NULL;
        long lViewOptions = 0;

        sc = pIComponent->GetResultViewType(GetUserParam(), &pszView, &lViewOptions);
        if(sc)
            return sc;

        sc = rvt.ScInitialize(pszView, lViewOptions);  // this also calls CoTaskMemFree on pszView
        if(sc)
            return sc;
    }

    /*
     * 5. Persist ResultViewType information only if
     * a. Snapin is changing the view OR
     * b. Snapin rejected the persisted view setting (we already
     *    made sure it is not changing the view above) and new view setting
     *    given is different from original one.
     */

    if ( bSnapinChangingView ||
        (bResultViewDataIsPersisted && (rvtOriginal != rvt)) )
    {
        sc = ScSetResultViewType(rvt);
        if (sc)
            return sc;
    }

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      ScRestoreResultView
//
//  Synopsis:    Restore the result pane from given persisted data.
//
//  Arguments:   [rvt]    -  CResultViewType data used to restore result pane.
//
//  Returns:     SC, S_OK if successfully restored.
//                   S_FALSE if snapin refused to restore.
//
//  History:     04-29-1999       AnandhaG       Created
//
//--------------------------------------------------------------------
SC CNode::ScRestoreResultView(const CResultViewType& rvt)
{
    DECLARE_SC(sc, _T("CNode::ScRestoreResultView"));

    CComponent* pComponent = GetPrimaryComponent();
    sc = ScCheckPointers(pComponent, E_UNEXPECTED);
    if (sc)
        return sc;

    IComponent2Ptr spIComponent2 = pComponent->GetIComponent();
    if( (spIComponent2 != NULL) && (!rvt.IsMMC12LegacyData()))
    {
        RESULT_VIEW_TYPE_INFO rvti;
        ZeroMemory(&rvti, sizeof(rvti));

        sc = rvt.ScGetResultViewTypeInfo (rvti);
        if (sc)
            return sc;

        // the snapin supports IComponent2. Use it to get the result view type.
        sc = spIComponent2->RestoreResultView(GetUserParam(), &rvti);
        if(sc)
        {
            // If snapin returns error, trace it and translate it to S_FALSE (snapin refused to restore).
            TraceSnapinError(TEXT("Snapin returned error from IComponent2::RestoreResultView"), sc);
            sc = S_FALSE;
            return sc;
        }

    }
    else
    {
        // the snapin does not support IComponent2. Use IComponent to
        // to restore the result view.
        LPCOLESTR pszView = NULL;
        long lViewOptions = 0;

        sc = rvt.ScGetOldTypeViewOptions(&lViewOptions);
        if (sc)
            return sc;

        IDataObjectPtr spdtobj;
        sc = QueryDataObject(CCT_SCOPE, &spdtobj);
        if (sc)
            return sc;

        // Notify MMC of persisted view being restored.
        MMC_RESTORE_VIEW mrv;
        ::ZeroMemory(&mrv, sizeof(mrv));
        mrv.cookie       = GetUserParam();
        mrv.dwSize       = sizeof(mrv);
        mrv.lViewOptions = lViewOptions;

        if (rvt.HasOCX())
        {
            pszView = rvt.GetOCX();
        }
        else if (rvt.HasWebBrowser())
        {
            pszView = rvt.GetURL();
        }

        if (pszView)
        {
            mrv.pViewType = (LPOLESTR)CoTaskMemAlloc( (wcslen(pszView) + 1) * sizeof(OLECHAR) );
            sc = ScCheckPointers(mrv.pViewType, E_OUTOFMEMORY);
            if (sc)
                return sc;
            wcscpy(mrv.pViewType, pszView);
            pszView = NULL; // Dont want to abuse it later.
        }

        // If the snapin handles this notification we use the persisted
        // data else call GetResultViewType of the snapin.
        BOOL bHandledRestoreView = FALSE;

        pComponent->Notify(spdtobj, MMCN_RESTORE_VIEW, (LPARAM)&mrv, (LPARAM)&bHandledRestoreView);
        CoTaskMemFree(mrv.pViewType);

        sc = (bHandledRestoreView) ? S_OK : S_FALSE;
    }

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:     ScRestoreViewMode
//
//  Synopsis:   If the view mode is persisted restore it.
//
//  Arguments:  None.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CNode::ScRestoreViewMode()
{
    DECLARE_SC(sc, _T("CNode::ScRestoreViewMode"));


    ULONG ulViewMode = 0;
    sc = ScGetViewMode(ulViewMode);
    if (sc != S_OK) // data not found or some error.
        return sc;

    CViewData *pViewData = GetViewData();
    sc = ScCheckPointers(pViewData, E_UNEXPECTED);
    if (sc)
        return sc;

    // tell conui to change the list mode.
    CConsoleView* pConsoleView = pViewData->GetConsoleView();
    sc = ScCheckPointers(pConsoleView, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = pConsoleView->ScChangeViewMode (ulViewMode);
    if (sc)
        return sc;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CNode::ScSetupTaskpad
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    GUID *          pTaskpadID :      [OUT]: The guid of the taskpad, else GUID_NULL
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CNode::ScSetupTaskpad(GUID *pGuidTaskpadID)
{
    DECLARE_SC(sc, _T("CNode::SetupTaskpad"));
    sc = ScCheckPointers(pGuidTaskpadID);
    if (sc)
        return sc.ToHr();

    *pGuidTaskpadID = GUID_NULL;

    // Get the persisted taskpad id if there is one.
    sc = ScGetTaskpadID(*pGuidTaskpadID);
    if (sc)
        return sc;

    // restore the taskpad if we've got a ViewSettings object.
    // do not use default tab even in case view seting does not have a valid guid
    // it only means the "Default" tab needs to be selected
    // see bug #97001 - MMC does not persist select CTP when user returns to a node
    bool bUseDefaultTaskpad = ( sc == S_FALSE );

    // See ScSetViewExtension for parameter meaning.
    sc = ScSetViewExtension(pGuidTaskpadID, bUseDefaultTaskpad, /*bSetViewSettingDirty*/ false);

    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CNode::ShowStandardListView
 *
 * PURPOSE:
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT CNode::ShowStandardListView()
{
    CComponent* pCC = GetPrimaryComponent();
    ASSERT(pCC != NULL);
    if (pCC == NULL)
        return E_FAIL;

    IDataObjectPtr spDataObject = NULL;
    HRESULT hr = QueryDataObject(CCT_SCOPE, &spDataObject);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;

    IExtendContextMenuPtr spIExtendContextMenu = pCC->GetIComponent();
    if(!spIExtendContextMenu.GetInterfacePtr())
        return S_FALSE;

    hr = spIExtendContextMenu->Command(MMCC_STANDARD_VIEW_SELECT, spDataObject);
    return hr;
}

HRESULT
CNode::OnListPad(LONG_PTR arg, LPARAM param)
{
    HRESULT hr = S_OK;

    IDataObjectPtr spdtobj;
    hr = QueryDataObject(CCT_SCOPE, &spdtobj);
    ASSERT(SUCCEEDED(hr));
    if (SUCCEEDED(hr))
    {
        CComponent* pCC = GetPrimaryComponent();
        ASSERT(pCC != NULL);
        hr = pCC->Notify(spdtobj, MMCN_LISTPAD, arg, param);
        CHECK_HRESULT(hr);
    }

    return hr;
}

HRESULT
CNode::OnGetPrimaryTask(IExtendTaskPad **ppExtendTaskPad)
{
    HRESULT hr = S_OK;

    IExtendTaskPadPtr spExtendTaskPad = GetPrimaryComponent()->GetIComponent();
    if (spExtendTaskPad == NULL)
       return E_NOINTERFACE;

    *ppExtendTaskPad = spExtendTaskPad.Detach();

    return hr;
}

IFramePrivate *
CNode::GetIFramePrivate()
{
    CComponent* pCC = GetPrimaryComponent();
    if (pCC == NULL)
        return (NULL);

    IFramePrivate* pFramePrivate = pCC->GetIFramePrivate();

    ASSERT (pFramePrivate != NULL);
    return (pFramePrivate);
}

HRESULT
CNode::GetTaskEnumerator(LPOLESTR pszTaskGroup, IEnumTASK** ppEnumTask)
{
    DECLARE_SC(sc, TEXT("CNode::GetTaskEnumerator"));

    ASSERT(pszTaskGroup != NULL);
    ASSERT(ppEnumTask != NULL);

    if (!pszTaskGroup|| !ppEnumTask)
        return E_INVALIDARG;

    *ppEnumTask = NULL; // init

    if (GetPrimaryComponent() == NULL)
    {
        ASSERT(0 && "UNexpected");
        return S_FALSE;
    }

    CMTNode* pMTNode = GetMTNode();
    ASSERT(pMTNode != NULL);

    CMTSnapInNode* pMTSnapIn = pMTNode->GetStaticParent();
    ASSERT(pMTSnapIn != NULL);

    CComponentData* pComponentData = pMTNode->GetPrimaryComponentData();
    ASSERT(pComponentData != NULL);

    GUID guidNodeType;
    HRESULT hr = pMTNode->GetNodeType(&guidNodeType);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;

    //
    // Add primary task pad.
    //

    IExtendTaskPadPtr spExtendTaskPad =
        GetPrimaryComponent()->GetIComponent();

    if (spExtendTaskPad == NULL)
        return S_FALSE;

    IDataObjectPtr spDataObject;
    hr = pMTNode->QueryDataObject(CCT_SCOPE, &spDataObject);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;

    IEnumTASKPtr spEnumTASK;
    hr = spExtendTaskPad->EnumTasks(spDataObject, pszTaskGroup, &spEnumTASK);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;

    CComObject<CTaskEnumerator>* pTaskEnumerator = new CComObject<CTaskEnumerator>;
    ASSERT(pTaskEnumerator != NULL);
    pTaskEnumerator->AddTaskEnumerator(pComponentData->GetCLSID(), spEnumTASK);

    IEnumTASKPtr spEnumTask = pTaskEnumerator;
    ASSERT(spEnumTask != NULL);
    if (spEnumTask)
        *ppEnumTask = spEnumTask.Detach();

    //
    // Add extension task pads.
    //
    CArray<GUID,GUID&> DynExtens;
    ExtractDynExtensions(spDataObject, DynExtens);

    CExtensionsIterator it;
    sc = it.ScInitialize(pComponentData->GetSnapIn(), guidNodeType, g_szTask, DynExtens.GetData(), DynExtens.GetSize());
    if (sc.IsError() || it.IsEnd() == TRUE)
        return S_OK;

    for (; it.IsEnd() == FALSE; it.Advance())
    {
        CComponentData* pCCD = pMTSnapIn->GetComponentData(it.GetCLSID());

        if (pCCD == NULL)
        {
            // See if taskpad extension supports IComponentData. If so, we will add the it to
            // the static node's component list and reuse the same instance each time its needed.
            IComponentDataPtr spIComponentData;
            hr = CreateSnapIn(it.GetCLSID(), &spIComponentData, FALSE);
            if (SUCCEEDED(hr))
            {
                CSnapInPtr spSnapIn;

                // If a dynamic extension, we have to get the snap-in ourselves
                // otherwise the iterator has it
                if (it.IsDynamic())
                {
                    CSnapInsCache* const pCache = theApp.GetSnapInsCache();
                    ASSERT(pCache != NULL);

                    SC sc = pCache->ScGetSnapIn(it.GetCLSID(), &spSnapIn);
                    ASSERT(!sc.IsError());

                    // On failure, continue with other extensions
                    if (sc)
                        continue;
                }
                else
                {
                    spSnapIn = it.GetSnapIn();
                }

                ASSERT(spSnapIn != NULL);

                pCCD = new CComponentData(spSnapIn);

                if (pCCD != NULL)
                {
                    pCCD->SetIComponentData(spIComponentData);
                    pMTSnapIn->AddComponentDataToArray(pCCD);

                }
            }
        }

        // Initialize and load component data if not already done
        if (pCCD != NULL && pCCD->IsInitialized() == FALSE)
        {
            sc = pCCD->Init(CMTNode::ToHandle(pMTSnapIn));

            if ( !sc.IsError() )
            {
                sc = pMTSnapIn->ScInitIComponentData(pCCD);
                if (sc)
                {
                    sc.TraceAndClear();
                    // On failure, continue with other extensions
                    continue;
                }
            }
            else
            {
                // if failed to initialize, remove it from the component data array
                pMTSnapIn->CompressComponentDataArray();
                sc.TraceAndClear();
                // On failure, continue with other extensions
                continue;
            }
        }

        IExtendTaskPadPtr spExtendTaskPad;

        if (pCCD)
        {
            CComponent* pCC = pMTSnapIn->GetComponent(GetViewID(),
                                    pCCD->GetComponentID(), pCCD->GetSnapIn());
            ASSERT(pCC != NULL);
            if (pCC)
            {
                // Ensure the IComponent is initialized.
                if (!pCC->IsInitialized())
                {
                    ASSERT(pCCD->GetComponentID() == pCC->GetComponentID());

                    hr = pCC->Init(pCCD->GetIComponentData(),
                                   CMTNode::ToHandle(pMTSnapIn),
                                   ToHandle(this),
                                   pCCD->GetComponentID(),
                                   GetViewID());

                    // Abort if PRIMARY Component fails to init.
                    if (FAILED(hr))
                        return hr;
                }

                spExtendTaskPad = pCC->GetIComponent();
            }
        }
        else
        {
            hr = spExtendTaskPad.CreateInstance(it.GetCLSID(),
                #if _MSC_VER >= 1100
                NULL,
                #endif
                MMC_CLSCTX_INPROC);

            ASSERT(SUCCEEDED(hr));
            if (FAILED(hr))
                continue;
        }

        if (spExtendTaskPad != NULL)
        {
            IEnumTASKPtr spEnumTASK;
            HRESULT hr = spExtendTaskPad->EnumTasks(spDataObject, pszTaskGroup,
                                                 &spEnumTASK);
            ASSERT(SUCCEEDED(hr));
            if (hr == S_OK)
                pTaskEnumerator->AddTaskEnumerator(it.GetCLSID(), spEnumTASK);
        }

    } // end for


    // Return S_OK rather than hr because a failed extension shouldn't prevent the
    // taskpad from coming up
    return S_OK;

}

HRESULT
CNode::GetListPadInfo(IExtendTaskPad* pExtendTaskPad, LPOLESTR szTaskGroup,
                                    MMC_ILISTPAD_INFO* pIListPadInfo)
{
    if ((GetPrimaryComponent()    == NULL)  )
    {
        ASSERT(0 && "Asking for ListPadInfo on a node that has no snapin");
        return S_FALSE;
    }

    // get primary snapin's IComponentData...
    CMTNode* pMTNode = GetMTNode();
    ASSERT(pMTNode != NULL);
    CComponentData* pComponentData = pMTNode->GetPrimaryComponentData();
    ASSERT(pComponentData != NULL);

    // ... so we can get CLSID
    pIListPadInfo->szClsid = NULL;
    HRESULT hr = StringFromCLSID (pComponentData->GetCLSID(), &pIListPadInfo->szClsid);
    ASSERT (pIListPadInfo->szClsid != NULL);
    if (pIListPadInfo->szClsid == NULL) {
        if (hr) return hr;
        else    return E_FAIL;  // just in case.
    }

    // finally call taskpad extension for info
    return pExtendTaskPad->GetListPadInfo (szTaskGroup, (MMC_LISTPAD_INFO*)pIListPadInfo);
}

void
CNode::OnTaskNotify(LONG_PTR arg, LPARAM param)
{
    CSnapInNode* pSINode = dynamic_cast<CSnapInNode*>(GetStaticParent());
    ASSERT(pSINode != NULL);

    IDataObjectPtr spDataObject;
    QueryDataObject(CCT_SCOPE, &spDataObject);

    IExtendTaskPadPtr spExtendTaskPad;
    CComponent* pCC;
    LPOLESTR pszClsid = reinterpret_cast<LPOLESTR>(arg);
    if (pszClsid[0] == 0)
    {
        pCC = GetPrimaryComponent();
        if (!pCC)
            return;
        spExtendTaskPad = pCC->GetIComponent();
    }
    else
    {
        CLSID clsid;
        HRESULT hr = ::CLSIDFromString(pszClsid, &clsid);
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
            return;

        // try to get IExtendTaskPad from IComponent, first;
        // if that fails, just create using CLSID
        pCC = pSINode->GetComponent(const_cast<const CLSID&>(clsid));
        if (pCC)
            spExtendTaskPad = pCC->GetIComponent();
        if (spExtendTaskPad == NULL)
            hr = spExtendTaskPad.CreateInstance(clsid,
                                      #if _MSC_VER >= 1100
                                      NULL,
                                      #endif
                                      MMC_CLSCTX_INPROC);
    }

    ASSERT (spExtendTaskPad != NULL);
    if (spExtendTaskPad != NULL)
    {
        VARIANT** ppvarg = reinterpret_cast<VARIANT**>(param);
        spExtendTaskPad->TaskNotify(spDataObject, ppvarg[0], ppvarg[1]);
    }
}

HRESULT
CNode::OnScopeSelect(bool bSelect, SELECTIONINFO* pSelInfo)
{
    DECLARE_SC (sc, _T("CNode::OnScopeSelect"));
    sc = ScCheckPointers(pSelInfo);
    if (sc)
        return sc.ToHr();

    /*
     * Bug 178484: reset the sort parameters when scope selection changes
     */
    if (bSelect)
    {
        CComponent *pCC = GetPrimaryComponent();
        sc = ScCheckPointers(pCC, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        IFramePrivate *pFrame = pCC->GetIFramePrivate();
        sc = ScCheckPointers(pFrame, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        pFrame->ResetSortParameters();
    }

    if (bSelect == TRUE && WasExpandedAtLeastOnce() == FALSE)
    {
        sc = OnExpand(TRUE);
        if (sc)
            return (sc.ToHr());
    }

    ASSERT(IsInitialized() == TRUE);

    sc = OnSelect(pSelInfo->m_pView, bSelect, pSelInfo->m_bResultPaneIsWeb);
    if (sc)
        return (sc.ToHr());

    return (sc.ToHr());
}


HRESULT CNode::OnActvate(LONG_PTR lActivate)
{
    return (DeepNotify (MMCN_ACTIVATE, lActivate, 0));
}


HRESULT CNode::OnMinimize(LONG_PTR fMinimized)
{
    return (DeepNotify (MMCN_MINIMIZED, fMinimized, 0));
}


//+-------------------------------------------------------------------
//
//  Member:     SendShowEvent
//
//  Synopsis:   Send MMCN_SHOW notification to snapin, persist column
//              data if necessary.
//
//  Arguments:  [bSelect] - TRUE if the node is selected.
//
//--------------------------------------------------------------------
HRESULT CNode::SendShowEvent(BOOL bSelect)
{
    DECLARE_SC(sc, _T("CNode::SendShowEvent"));

    CComponent* pCC = m_pPrimaryComponent;
    ASSERT(pCC != NULL);

    // Get the data object for the node and pass it to the primary snap-in
    // and all the namespace extensions to the node.
    IDataObjectPtr spDataObject;
    HRESULT hr = QueryDataObject(CCT_SCOPE, &spDataObject);
    if (FAILED(hr))
        return hr;

    CMTNode* pMTNode = GetMTNode();

    IFramePrivatePtr     spFrame = pCC->GetIFramePrivate();
    sc = ScCheckPointers(spFrame, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    IImageListPrivatePtr spImageList;
    hr = spFrame->QueryResultImageList(reinterpret_cast<LPIMAGELIST*>(&spImageList));
    ASSERT(SUCCEEDED(hr));
    ASSERT(spImageList != NULL);

    HSCOPEITEM hScopeItem = CMTNode::ToScopeItem(pMTNode);

    if (bSelect == TRUE)
    {
        hr = pCC->Notify(spDataObject, MMCN_ADD_IMAGES,
                         reinterpret_cast<LPARAM>((LPIMAGELIST)spImageList),
                         hScopeItem);
        CHECK_HRESULT(hr);
        //if (FAILED(hr))
        //    return hr;
    }

    hr = pCC->Notify(spDataObject, MMCN_SHOW, bSelect, hScopeItem);

    CHECK_HRESULT(hr);
    if (FAILED(hr))
        return hr;

    if (bSelect)
    {
        CViewData *pViewData = GetViewData();
        sc = ScCheckPointers(pViewData, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        if (pViewData->HasList() || pViewData->HasListPad())
        {
            sc = ScRestoreSortFromPersistedData();
            if (sc)
                return sc.ToHr();

            // Now try to restore the view mode.
            sc =ScRestoreViewMode();
            if (sc)
                return sc.ToHr();
        }
    }

    return hr;
}


HRESULT CNode::DeepNotify(MMC_NOTIFY_TYPE event, LONG_PTR arg, LPARAM param)
{
    DECLARE_SC(sc, TEXT("CNode::DeepNotify"));

    CComponent* pCC = m_pPrimaryComponent;
    ASSERT(pCC != NULL);
    if (pCC == NULL)
        return E_UNEXPECTED;

    // Get the data object for the node and pass it to the primary snap-in
    // and all the namespace extensions to the node.
    IDataObjectPtr spDataObject;
    HRESULT hr = QueryDataObject(CCT_SCOPE, &spDataObject);
    if (FAILED(hr))
        return hr;

    hr = pCC->Notify(spDataObject, event, arg, param);
    CHECK_HRESULT(hr);
    //if (FAILED(hr))
    //    return hr;

    //
    //  Notify extensions.
    //

    CMTNode* pMTNode = GetMTNode();

    // Get the node-type of this node
    GUID guidNodeType;
    hr = pMTNode->GetNodeType(&guidNodeType);
    CHECK_HRESULT(hr);
    if (FAILED(hr))
        return hr;

    LPCLSID pDynExtCLSID;
    int cDynExt = pMTNode->GetDynExtCLSID(&pDynExtCLSID);

    CExtensionsIterator it;
    sc = it.ScInitialize(pMTNode->GetPrimarySnapIn(), guidNodeType, g_szNameSpace, pDynExtCLSID, cDynExt);
    if (sc)
        return S_FALSE;

    BOOL fProblem = FALSE;
    CSnapInNode* pSINode = GetStaticParent();

    for (; it.IsEnd() == FALSE; it.Advance())
    {
        CComponent* pCC = pSINode->GetComponent(it.GetCLSID());
        if (pCC == NULL)
            continue;

        hr = pCC->Notify(spDataObject, event, arg, param);
        CHECK_HRESULT(hr);

        // continue even if an error occurs with extension snapins
        if (FAILED(hr))
            fProblem = TRUE;
    }

    return (fProblem == TRUE) ? S_FALSE : S_OK;
}

HRESULT CNode::OnSelect(LPUNKNOWN lpView, BOOL bSelect,
                                  BOOL bResultPaneIsWeb)
{
    DECLARE_SC(sc, TEXT("CNode::OnSelect"));

#ifdef DBG
    if (lpView == NULL)
        ASSERT(bSelect == FALSE);
    else
        ASSERT(bSelect == TRUE);
#endif

    sc = ScCheckPointers(m_pPrimaryComponent, E_UNEXPECTED);
    if (sc)
    {
        sc.TraceAndClear();
        return sc.ToHr();
    }

    CComponent* pCC = m_pPrimaryComponent;
    sc = ScCheckPointers(pCC, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    IFramePrivate *pFrame = pCC->GetIFramePrivate();
    sc = ScCheckPointers(pFrame, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // set the correct view in the primary snap-in before it adds items
    if (bSelect == TRUE)
        pFrame->SetResultView(lpView);

    IDataObjectPtr spDataObject;
    sc = QueryDataObject(CCT_SCOPE, &spDataObject);
    if (sc)
        return sc.ToHr();

    CMTNode*  pMTNode    = GetMTNode();
    LPARAM    hScopeItem = CMTNode::ToScopeItem(pMTNode);

    // Send only the MMCN_SHOW message if result pane is the web view.
    if (bResultPaneIsWeb)
    {
        return pCC->Notify(spDataObject, MMCN_SHOW, bSelect, hScopeItem);
    }

    // Send necessary events like MMCN_ADD_IMAGES and MMCN_SHOW to snapin
    sc = SendShowEvent(bSelect);
    if (sc)
        return sc.ToHr();

    // set the correct view in the primary snap-in after it's notified
    if (bSelect == FALSE)
        pFrame->SetResultView(NULL);    //
    // Deal with extension ssnap-ins
    //

    // Get the node-type of this node
    GUID guidNodeType;
    sc = pMTNode->GetNodeType(&guidNodeType);
    if (sc)
        return sc.ToHr();

    LPCLSID pDynExtCLSID;
    int cDynExt = pMTNode->GetDynExtCLSID(&pDynExtCLSID);

    CExtensionsIterator it;
    sc = it.ScInitialize(pMTNode->GetPrimarySnapIn(), guidNodeType, g_szNameSpace, pDynExtCLSID, cDynExt);
    if (sc)
        return S_FALSE;

    BOOL fProblem = FALSE;
    CSnapInNode* pSINode = GetStaticParent();

    for (; it.IsEnd() == FALSE; it.Advance())
    {
        CComponent* pCCExtnSnapin = pSINode->GetComponent(it.GetCLSID());
        if (pCCExtnSnapin == NULL)
            continue;

        IFramePrivate *pFrameExtnSnapin = pCCExtnSnapin->GetIFramePrivate();
        sc = ScCheckPointers(pFrameExtnSnapin, E_UNEXPECTED);
        if (sc)
        {
            sc.TraceAndClear();
            continue;
        }

        // set the correct view in the snap-in before it adds items
        if (bSelect == FALSE)
        {
            pFrameExtnSnapin->SetResultView(NULL);
            continue;
        }
        else
        {
            pFrameExtnSnapin->SetResultView(lpView);

            IImageListPrivatePtr spImageList;
            sc = pCCExtnSnapin->GetIFramePrivate()->QueryResultImageList(
                                   reinterpret_cast<LPIMAGELIST*>(&spImageList));
            if (sc)
            {
                sc.TraceAndClear();
                fProblem = TRUE;
                continue;
            }

            sc = ScCheckPointers(spImageList, E_UNEXPECTED);
            if (sc)
            {
                sc.TraceAndClear();
                fProblem = TRUE;
                continue;
            }

            SC scNoTrace = pCCExtnSnapin->Notify(spDataObject, MMCN_ADD_IMAGES,
                                       reinterpret_cast<LPARAM>((LPIMAGELIST)spImageList),
                                       hScopeItem);
            if (scNoTrace)
            {
                TraceSnapinError(TEXT("Snapin returned error from IComponent::Notify MMCN_ADD_IMAGES"), scNoTrace);
            }
        }
    }

    return (fProblem == TRUE) ? S_FALSE : S_OK;
}

void CNode::Reset()
{
    m_pPrimaryComponent = NULL;
    m_bInitComponents = TRUE;
}

HRESULT CNode::GetDispInfoForListItem(LV_ITEMW* plvi)
{
    ASSERT(plvi != NULL);

    RESULTDATAITEM rdi;
    ZeroMemory(&rdi, sizeof(rdi));

    if (plvi->mask & LVIF_TEXT)
    {
        ASSERT (!IsBadWritePtr (plvi->pszText, plvi->cchTextMax * sizeof (TCHAR)));
        rdi.mask |= RDI_STR;
    }

    if (plvi->mask & LVIF_IMAGE)
        rdi.mask |= RDI_IMAGE;

    if (plvi->mask & LVIF_STATE)
        rdi.mask |= RDI_STATE;

    rdi.nCol = plvi->iSubItem;


    CComponent* pCC = NULL;

    // if virtual list
    if (GetViewData()->IsVirtualList())
    {
        pCC = GetPrimaryComponent();
        ASSERT(pCC != NULL);

        // all we can pass is the item index
        rdi.nIndex = plvi->iItem;

        // no default for virtual lists
        rdi.nImage = MMCLV_NOICON;
    }
    else
    {
        CResultItem* pri = CResultItem::FromHandle (plvi->lParam);

        if (pri != NULL)
        {
            if (pri->IsScopeItem()) // Folder
            {
                // convert to real type
                CNode* pNodeSubFldr = CNode::FromResultItem (pri);
                ASSERT(IsBadReadPtr(pNodeSubFldr, sizeof(CNode)) == FALSE);

                if (pNodeSubFldr->IsStaticNode() == TRUE) // Static folders
                {
                    return pNodeSubFldr->GetDispInfo(plvi);
                }
                else                                      // Enumerated folders
                {
                    // Remap the LParam information.
                    rdi.lParam = pNodeSubFldr->GetUserParam();
                    rdi.bScopeItem = TRUE;

                    pCC = pNodeSubFldr->GetPrimaryComponent();
                    rdi.nImage = pNodeSubFldr->GetResultImage();
                }
            }
            else // Leaf item
            {
                // Remap the LParam information.
                rdi.nImage = pri->GetImageIndex();
                rdi.lParam = pri->GetSnapinData();
                pCC = GetPrimaryComponent();
                ASSERT(GetComponent(pri->GetOwnerID()) == GetPrimaryComponent());
                ASSERT(pCC != NULL);
            }
        }
    }

    HRESULT hr = pCC->GetDisplayInfo(&rdi);

    if (hr == S_OK)
    {
        if (rdi.mask & RDI_IMAGE)
        {
            if (rdi.nImage == MMCLV_NOICON)
            {
                plvi->iImage = rdi.bScopeItem ? eStockImage_Folder : eStockImage_File;
            }
            else
            {
                IImageListPrivate *pIL = pCC->GetIImageListPrivate();
                HRESULT hr2 = pIL->MapRsltImage(pCC->GetComponentID(), rdi.nImage,
                                                          &(plvi->iImage));
                if (FAILED(hr2))
                {
                    Dbg(DEB_USER1, "can't map image provided by snapin. Using default image.\n");
                    plvi->iImage = rdi.bScopeItem ? eStockImage_Folder : eStockImage_File;
                }
            }
        }

        // Move all other info from rdi into lviItem
        if (rdi.mask & RDI_STR)
        {
            if (!IsBadStringPtrW (rdi.str, plvi->cchTextMax))
			{
                wcsncpy (plvi->pszText, rdi.str, plvi->cchTextMax);

				// always terminate the string!
				// see bug #416888 (ntraid9) 6/15/2001
				if ( plvi->cchTextMax != 0 )
					plvi->pszText[ plvi->cchTextMax - 1 ] = 0;
			}
            else if (plvi->cchTextMax > 0)
                plvi->pszText[0] = 0;
        }

        if (rdi.mask & RDI_STATE)
            plvi->state = rdi.nState;
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:      CNode::ScSaveSortData
//
//  Synopsis:    Save the given sort data for persistence.
//
//  Arguments:   [nCol] - sort column.
//               [dwOptions] - sort options.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CNode::ScSaveSortData (int nCol, DWORD dwOptions)
{
    DECLARE_SC(sc, _T("CNode::ScSaveSortData"));
    CViewData *pViewData = GetViewData();
    sc = ScCheckPointers(pViewData, E_UNEXPECTED);
    if (sc)
        return sc;

    CLSID          guidSnapin;
    CXMLAutoBinary columnID;
    sc = ScGetSnapinAndColumnDataID(guidSnapin, columnID);
    if (sc)
        return sc;

    CXMLBinaryLock sLock(columnID);
    SColumnSetID* pColID = NULL;
    sc = sLock.ScLock(&pColID);
    if (sc)
        return sc;

    sc = ScCheckPointers(pColID, E_UNEXPECTED);
    if (sc)
        return sc;

    CColumnSortInfo colSortInfo;
    colSortInfo.m_nCol          = nCol;
    colSortInfo.m_dwSortOptions = dwOptions;
    colSortInfo.m_lpUserParam   = NULL;

    sc = pViewData->ScSaveColumnSortData(guidSnapin, *pColID, colSortInfo);
    if (sc)
        return sc;

    // Column data when saved includes the width/order data (column info list) and sort data.
    // The width/order data should always be saved regardless of whether sort data is
    // persisted or not. So save the width/order data.
    CColumnInfoList   columnInfoList;
    TStringVector    strColNames; // unused

    // get the current data
    sc = ScGetCurrentColumnData( columnInfoList, strColNames );
    if (sc)
        return sc;

    sc = pViewData->ScSaveColumnInfoList(guidSnapin, *pColID, columnInfoList);
    if (sc)
        return sc;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:     OnColumnClicked
//
//  Synopsis:   Ask snapin to sort.
//
//  Arguments:  [nCol] - Column to be sorted.
//
//  Note:       When column is clicked sort options and user param
//              are unknown. So we set them to 0 (zero). In InternalSort
//              the sort option is computed.
//
//  Returns:    HRESULT
//
//  History:                RaviR    Created
//              07-27-1999  AnandhaG renamed OnSort to OnColumnClicked
//--------------------------------------------------------------------
HRESULT CNode::OnColumnClicked(LONG_PTR nCol)
{
    CComponent* pComponent = GetPrimaryComponent();
    ASSERT(pComponent != NULL);
    if (NULL == pComponent)
    return E_FAIL;

    IResultDataPrivatePtr pResult = pComponent->GetIFramePrivate();
    ASSERT(pResult != NULL);
    if (NULL == pResult)
        return E_FAIL;

    HRESULT hr = pResult->InternalSort( nCol, 0, NULL,
                                        TRUE /*column header clicked*/);

    if (hr == S_OK)
    {
        BOOL bAscending = TRUE;
        hr = pResult->GetSortDirection(&bAscending);
        if (hr == S_OK)
            hr = ScSaveSortData(nCol, bAscending ? 0 : RSI_DESCENDING).ToHr();
    }

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     RestoreSort
//
//  Synopsis:   Sort the list view with persisted data.
//              Restore the sort with saved column # and
//              sort-options (User param is NULL as this
//              is user initiated MMCN_COLUMN_CLICK)*/
//
//  Arguments:  [nCol]           - Column to be sorted.
//              [dwSortOptions]  - Sortoptions, ascend/descend...
//
//  Note:       Unlike OnColumnClicked this method wont set columns dirty
//              after successful sort.
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------
HRESULT CNode::RestoreSort(INT nCol, DWORD dwSortOptions)
{
    CComponent* pComponent = GetPrimaryComponent();
    ASSERT(pComponent != NULL);
    if (NULL == pComponent)
    return E_FAIL;

    IResultDataPrivatePtr pResult = pComponent->GetIFramePrivate();
    ASSERT(pResult != NULL);
    if (NULL == pResult)
        return E_FAIL;

    HRESULT hr = pResult->InternalSort( nCol, dwSortOptions,
                                        NULL /*NULL user param as this is user initiated*/,
                                        FALSE /* Let us not send MMCN_COLUMN_CLICK*/);

    return S_OK;
}


//+-------------------------------------------------------------------
//
//  Member:      CNode::ScRestoreSortFromPersistedData
//
//  Synopsis:    Get persisted sort data if any and apply it to list-view.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CNode::ScRestoreSortFromPersistedData ()
{
    DECLARE_SC(sc, _T("CNode::ScRestoreSortFromPersistedData"));
    CViewData *pViewData = GetViewData();

    if (! pViewData->HasList() && ! pViewData->HasListPad() )
        return (sc = S_FALSE); // OCX gets MMCN_SHOW which may try to restore sort so this is no failure.

    // To get CColumnSetData first get the column-id & snapin guid.
    CLSID          guidSnapin;
    CXMLAutoBinary columnID;
    sc = ScGetSnapinAndColumnDataID(guidSnapin, columnID);
    if (sc)
        return sc;

    CXMLBinaryLock sLock(columnID);
    SColumnSetID* pColID = NULL;
    sc = sLock.ScLock(&pColID);
    if (sc)
        return sc;

    sc = ScCheckPointers(pColID, E_UNEXPECTED);
    if (sc)
        return sc;

    // Get persisted data.
    CColumnSetData columnSetData;
    BOOL bRet = pViewData->RetrieveColumnData(guidSnapin, *pColID, columnSetData);

    if (!bRet)
        return (sc = S_FALSE);

    CColumnInfoList* pColInfoList = columnSetData.get_ColumnInfoList();
    if (!pColInfoList)
        return (sc = S_FALSE);

    IFramePrivatePtr spFrame = GetIFramePrivate();
    sc = ScCheckPointers(spFrame, E_UNEXPECTED);
    if (sc)
        return sc;

    // First check if the number of columns inserted are same as the
    // number that is persisted. If not remove the persisted data.
    IHeaderCtrlPrivatePtr  spHeader = spFrame;
    sc = ScCheckPointers(spHeader, E_UNEXPECTED);
    if (sc)
        return sc;

    int cColumns = 0;
    sc = spHeader->GetColumnCount(&cColumns);
    if (sc)
        return sc;

    // If the persisted columns and number of columns inserted
    // do not match remove the persisted data.
    if (pColInfoList->size() != cColumns)
    {
        pViewData->DeleteColumnData(guidSnapin, *pColID);
        return sc;
    }

    // Set sorting column, order
    CColumnSortList* pSortList = columnSetData.get_ColumnSortList();

    if (pSortList && ( pSortList->size() > 0))
    {
        CColumnSortList::iterator itSortInfo = pSortList->begin();

        // Restore the sort with saved column # and
        // sort-options (User param is NULL as this
        // is user initiated MMCN_COLUMN_CLICK)*/
        RestoreSort(itSortInfo->getColumn(), itSortInfo->getSortOptions());
    }

    return (sc);
}


/***************************************************************************\
 *
 * METHOD:  CNode::ScGetCurrentColumnData
 *
 * PURPOSE: collects current column data to collections passed as args
 *          [ initially code used to be in OnColumns method ]
 *
 * PARAMETERS:
 *    CColumnInfoList& columnInfoList
 *    TStringVector& strColNames
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CNode::ScGetCurrentColumnData( CColumnInfoList& columnInfoList, TStringVector& strColNames)
{
    DECLARE_SC(sc, TEXT("CNode::ScGetCurrentColumnData"));
    columnInfoList.clear();
    strColNames.clear();

    IHeaderCtrlPrivatePtr spHeader = GetIFramePrivate();
    sc = ScCheckPointers(spHeader, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = spHeader->GetColumnInfoList(&columnInfoList);
    if (sc)
        return sc;

    int cColumns = columnInfoList.size();

    USES_CONVERSION;

    for (int i = 0; i < cColumns; i++)
    {
        CCoTaskMemPtr<OLECHAR> spColumnText;

        sc = spHeader->GetColumnText(i, &spColumnText);
        if (sc)
            return sc;

        strColNames.push_back(OLE2T(spColumnText));
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CNode::ScSetUpdatedColumnData
 *
 * PURPOSE: updates column by data specified in collections passed as args
 *          [ initially code used to be in OnColumns method ]
 *
 * PARAMETERS:
 *    CColumnInfoList& oldColumnInfoList - column data befor the change
 *    CColumnInfoList& newColumnInfoList - updated column data
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CNode::ScSetUpdatedColumnData( CColumnInfoList& oldColumnInfoList, CColumnInfoList& newColumnInfoList)
{
    DECLARE_SC(sc, TEXT("CNode::ScSetUpdatedColumnData"));

    CColumnInfoList::iterator itColInfo1, itColInfo2;

    // Check if there is any change in visible/hidden columns.
    // If so send MMCN_COLUMNS_CHANGE notification
    for (itColInfo1 = newColumnInfoList.begin(); itColInfo1 != newColumnInfoList.end(); ++itColInfo1)
    {
        // Get the same column from old list.
        itColInfo2 = find_if(oldColumnInfoList.begin(), oldColumnInfoList.end(),
                             bind2nd( ColPosCompare(), itColInfo1->GetColIndex()) );

        if (itColInfo2 == oldColumnInfoList.end())
            return sc = E_UNEXPECTED;

        // Compare the hidden flag.
        if ( itColInfo2->IsColHidden() != itColInfo1->IsColHidden() )
        {
            // Send MMCN_COLUMNS_CHANGED notification
            sc = OnColumnsChange(newColumnInfoList);
            if (sc)
                return sc;

            break; // done anyway
        }
    }

    sc = ScSaveColumnInfoList(newColumnInfoList);
    if (sc)
        return sc;

    IHeaderCtrlPrivatePtr spHeader = GetIFramePrivate();
    sc = ScCheckPointers(spHeader, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = spHeader->ModifyColumns(newColumnInfoList);
    if (sc)
        return sc;

    sc = ScRestoreSortFromPersistedData();
    if (sc)
        return sc;

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:     OnColumns
//
//  Synopsis:   Display Columns customization dialog and if necessary
//              apply changes made by the user.
//
//--------------------------------------------------------------------
void CNode::OnColumns()
{
    DECLARE_SC(sc, TEXT("CNode::OnColumns"));

    // first - get the columns
    CColumnInfoList   columnInfoList;
    TStringVector    strColNames;

    // 1. get the current data
    sc = ScGetCurrentColumnData( columnInfoList, strColNames );
    if (sc)
        return;

    // 2. Cache the column data.
    CColumnInfoList columnInfoListOld = columnInfoList;

    // 3. get the default column settings.
    CViewData *pViewData = GetViewData();
    IHeaderCtrlPrivatePtr spHeader = GetIFramePrivate();
    sc = ScCheckPointers(pViewData, spHeader, E_UNEXPECTED);
    if (sc)
        return;

    CColumnInfoList defaultColumnInfoList;
    sc = spHeader->GetDefaultColumnInfoList(defaultColumnInfoList);
    if (sc)
        return;

    // 5. display the dialog
    CColumnsDlg dlg(&columnInfoList, &strColNames, defaultColumnInfoList);
    INT_PTR nRet = dlg.DoModal();

    if (nRet == -1)
    {
        sc = E_UNEXPECTED;
        return;
    }

    if (nRet == IDOK)
    {
        // update columns by modified data
        sc = ScSetUpdatedColumnData( columnInfoListOld, columnInfoList );
        if (sc)
            return;
    }

    // If reset is true then throw away present persisted column data
    // and apply the default settings.
    if (nRet == IDC_RESTORE_DEFAULT_COLUMNS)
    {
        // To get CColumnSetData first get the column-id & snapin guid.
        CLSID          guidSnapin;
        CXMLAutoBinary columnID;
        sc = ScGetSnapinAndColumnDataID(guidSnapin, columnID);
        if (sc)
            return;

        CXMLBinaryLock sLock(columnID);
        SColumnSetID* pColID = NULL;
        sc = sLock.ScLock(&pColID);
        if (sc)
            return;

        sc = ScCheckPointers(pColID, E_UNEXPECTED);
        if (sc)
            return;

        pViewData->DeleteColumnData(guidSnapin, *pColID);

        sc = spHeader->ModifyColumns(defaultColumnInfoList);
        if (sc)
            return;
    }
}

/***************************************************************************\
 *
 * METHOD:  CNode::ScShowColumn
 *
 * PURPOSE: shows/hides column. notifies snapin on action
 *
 * PARAMETERS:
 *    int iColIndex - index of column to change
 *    bool bVisible - show/hide flag
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CNode::ScShowColumn(int iColIndex, bool bShow)
{
    DECLARE_SC(sc, TEXT("CNode::ScShowColumn"));

    // first - get the current column data
    CColumnInfoList   columnInfoList;
    TStringVector    strColNames;

    sc = ScGetCurrentColumnData( columnInfoList, strColNames );
    if (sc)
        return sc;

    // Save the column data.
    CColumnInfoList columnInfoListOld = columnInfoList;


    // find the column and change its status
    CColumnInfoList::iterator itColInfo = find_if(columnInfoList.begin(), columnInfoList.end(),
                                                  bind2nd( ColPosCompare(), iColIndex) );

    // check if we did find the column
    if (itColInfo == columnInfoList.end())
        return sc = E_INVALIDARG; // assume it's not a valid index

    // now modify the column status acording to parameters
    if (bShow)
    {
        itColInfo->SetColHidden(false);
        // move column to the end
        columnInfoList.splice(columnInfoList.end(), columnInfoList, itColInfo);
    }
    else
    {
        itColInfo->SetColHidden();
    }

    // update columns by modified data
    sc = ScSetUpdatedColumnData( columnInfoListOld, columnInfoList);
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CNode::ScGetSortColumn
 *
 * PURPOSE: return currently used sort column
 *
 * PARAMETERS:
 *    int *piSortCol - sort column index [retval]
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CNode::ScGetSortColumn(int *piSortCol)
{
    DECLARE_SC(sc, TEXT("CNode::ScGetSortColumn"));

    // parameter check
    sc = ScCheckPointers(piSortCol);
    if (sc)
        return sc;

    // retrieve IResultDataPrivate interface
    CComponent* pComponent = GetPrimaryComponent();
    sc = ScCheckPointers(pComponent, E_UNEXPECTED);
    if (sc)
        return sc;

    IResultDataPrivatePtr pResult = pComponent->GetIFramePrivate();
    sc = ScCheckPointers(pResult, E_UNEXPECTED);
    if (sc)
        return sc;

    // forward the call to IResultDataPrivate
    sc = pResult->GetSortColumn(piSortCol);
    if (sc)
        return sc;

    return sc;
}


/***************************************************************************\
 *
 * METHOD:  CNode::ScSetSortColumn
 *
 * PURPOSE: sorts result data by specified column
 *          [uses private result data interface to implement]
 *
 * PARAMETERS:
 *    int iSortCol      - index of column to sort by
 *    bool bAscending   - sorting order
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CNode::ScSetSortColumn(int iSortCol, bool bAscending)
{
    DECLARE_SC(sc, TEXT("CNode::ScSetSortColumn"));

    // retrieve IResultDataPrivate interface
    CComponent* pComponent = GetPrimaryComponent();
    sc = ScCheckPointers(pComponent, E_UNEXPECTED);
    if (sc)
        return sc;

    IResultDataPrivatePtr pResult = pComponent->GetIFramePrivate();
    sc = ScCheckPointers(pResult, E_UNEXPECTED);
    if (sc)
        return sc;

    DWORD dwSortOptions = bAscending ? 0 : RSI_DESCENDING;

    // forward the call to IResultDataPrivate
    sc = pResult->InternalSort( iSortCol, dwSortOptions, NULL, FALSE );
    if (sc)
        return sc;

    // If sort went thru - save.
    if (sc == SC(S_OK))
        sc = ScSaveSortData(iSortCol, dwSortOptions);

    if (sc)
        return sc;

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:     OnColumnsChange
//
//  Synopsis:   Send MMCN_COLUMNS_CHANGE notification to snapin.
//
//  Arguments:  [colInfoList]  - Columns data.
//
//--------------------------------------------------------------------
HRESULT CNode::OnColumnsChange(CColumnInfoList& colInfoList)
{
    CComponent* pCC = m_pPrimaryComponent;
    ASSERT(pCC != NULL);

    // Get the data object for the node and pass it to the primary snap-in
    // and all the namespace extensions to the node.
    IDataObjectPtr spDataObject;
    HRESULT hr = QueryDataObject(CCT_SCOPE, &spDataObject);
    if (FAILED(hr))
        return hr;

    int nVisibleColumns = 0;

    // Count the number of columns that are visible.
    CColumnInfoList::iterator itColInfo;
    for (itColInfo = colInfoList.begin(); itColInfo != colInfoList.end();
        ++itColInfo)
    {
        if (! itColInfo->IsColHidden())
            nVisibleColumns++;
    }

    int size = sizeof(MMC_VISIBLE_COLUMNS) + nVisibleColumns * sizeof(INT);
    HGLOBAL hGlobal = ::GlobalAlloc(GPTR, size);
    if (! hGlobal)
        return E_OUTOFMEMORY;

    MMC_VISIBLE_COLUMNS* pColData = reinterpret_cast<MMC_VISIBLE_COLUMNS*>(hGlobal);
    pColData->nVisibleColumns = nVisibleColumns;

    // Get the list of visible columns into MMC_VISIBLE_COLUMNS struct.
    int i = 0;
    for (itColInfo = colInfoList.begin(); itColInfo != colInfoList.end();
        ++itColInfo)
    {
        if (! itColInfo->IsColHidden())
            pColData->rgVisibleCols[i++] = itColInfo->GetColIndex();
    }

    LPARAM lParam = reinterpret_cast<LPARAM>(pColData);
    hr = pCC->Notify(spDataObject, MMCN_COLUMNS_CHANGED, 0, lParam);

    ::GlobalFree(hGlobal);

    CHECK_HRESULT(hr);
    if (FAILED(hr))
        return hr;


    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     ScSaveColumnInfoList
//
//  Synopsis:   Save the column data in internal data structures.
//
//  Arguments:  [colInfoList]  - Columns data.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CNode::ScSaveColumnInfoList(CColumnInfoList& columnInfoList)
{
    DECLARE_SC(sc, TEXT("CNode::ScSaveColumnInfoList"));

    CViewData *pViewData = GetViewData();
    sc = ScCheckPointers(pViewData, E_UNEXPECTED);
    if (sc)
        return sc;

    CLSID          clsidSnapin;
    CXMLAutoBinary columnID;
    sc = ScGetSnapinAndColumnDataID(clsidSnapin, columnID);
    if (sc)
        return sc;

    CXMLBinaryLock sLock(columnID);
    SColumnSetID* pColID = NULL;
    sc = sLock.ScLock(&pColID);
    if (sc)
        return sc;

    sc = ScCheckPointers(pColID, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = pViewData->ScSaveColumnInfoList(clsidSnapin, *pColID, columnInfoList);
    if (sc)
        return sc;

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:     ScGetSnapinAndColumnDataID
//
//  Synopsis:   Returns the snapin guid & column-id in CXMLAutoBinary for this node.
//
//  Arguments:  [snapinGuid] - [out], snapin guid.
//              [columnID]   - [out], column-id in CXMLAutoBinary.
//
//  Note:       Pass in a CXMLAutoBinary object, will return column id in that object.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CNode::ScGetSnapinAndColumnDataID(GUID& snapinGuid, CXMLAutoBinary& columnID)
{
    DECLARE_SC(sc, TEXT("CNode::ScGetSnapinAndColumnDataID"));

    // Get Snapin Guid
    snapinGuid = GetPrimarySnapInCLSID();

    columnID.ScFree(); // clear any data.

    IDataObjectPtr spDataObject;
    sc = QueryDataObject(CCT_SCOPE, &spDataObject);
    if (sc)
        return sc;

    HGLOBAL hGlobal;
    sc = ExtractColumnConfigID(spDataObject, hGlobal);

    if (! sc.IsError())
    {
        int cbSize = GlobalSize(hGlobal);
        if (0 == cbSize)
            return sc.FromLastError();

        columnID.Attach(hGlobal, cbSize);
    }
    else
    {
        // Let us use the NodeTypeGUID as the Column Data Identifier
        CLSID clsidColID;
        sc = GetNodeType(&clsidColID);
        if (sc)
            return sc;

        int cbSize = sizeof(SColumnSetID) + sizeof(CLSID) - 1;
        sc = columnID.ScAlloc(cbSize, true);
        if (sc)
            return sc;

        CXMLBinaryLock sLock(columnID);
        SColumnSetID* pColID = NULL;
        sc = sLock.ScLock(&pColID);
        if (sc)
            return sc;

        sc = ScCheckPointers(pColID, E_UNEXPECTED);
        if (sc)
            return sc;

        pColID->cBytes = sizeof(CLSID);
        pColID->dwFlags = 0;

        CopyMemory(pColID->id, (BYTE*)&clsidColID, pColID->cBytes);
    }

    return sc;
}

/*+-------------------------------------------------------------------------*
 * class CViewExtensionCallback
 *
 *
 * PURPOSE: Implements IViewExtensionCallback
 *
 *+-------------------------------------------------------------------------*/
class CViewExtensionCallback :
    public CComObjectRoot,
    public IViewExtensionCallback
{

public:
    typedef CViewExtensionCallback ThisClass;

BEGIN_COM_MAP(ThisClass)
    COM_INTERFACE_ENTRY(IViewExtensionCallback)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(ThisClass)

IMPLEMENTS_SNAPIN_NAME_FOR_DEBUG()

    CViewExtensionCallback() : m_pItExt(NULL) {}

    SC ScInitialize(CViewExtInsertIterator & itExt)
    {
        DECLARE_SC(sc, TEXT("CViewExtensionCallback::ScInitialize"));
        m_pItExt = &itExt;
        return sc;
    }

    SC ScDeinitialize()
    {
        DECLARE_SC (sc, _T("CViewExtensionCallback::ScDeinitialize"));
        m_pItExt       = NULL;
        return (sc);
    }


public:
    STDMETHODIMP AddView(PMMC_EXT_VIEW_DATA pExtViewData) {return ScAddView(pExtViewData).ToHr();}

private:

    SC ScAddView(PMMC_EXT_VIEW_DATA pExtViewData)
    {
        DECLARE_SC(sc, TEXT("CViewExtensionCallback::ScAddView"));

        sc = ScCheckPointers(pExtViewData, pExtViewData->pszURL, pExtViewData->pszViewTitle);
        if(sc)
            return sc; // TODO add snapin error

        sc = ScCheckPointers(m_pItExt, E_UNEXPECTED);
        if(sc)
            return sc; // TODO add snapin error, e.g. "IExtendViewCallback::AddView called outside of IExtendView::GetViews"

        /*
         * prep the input to IConsoleView::ScAddViewExtension
         */
        CViewExtensionData ved;
        ved.strURL               = pExtViewData->pszURL;
        ved.strName              = pExtViewData->pszViewTitle;
        ved.viewID               = pExtViewData->viewID;
        ved.bReplacesDefaultView = pExtViewData->bReplacesDefaultView;

        /*
         * std::basic_string's can't assign from NULL, so we have to check first
         */
        if (pExtViewData->pszTooltipText)
            ved.strTooltip = pExtViewData->pszTooltipText;

        /*
         * validate output:  URL and title are required, tooltip is optional
         */
        if (ved.strURL.empty())
        {
            TraceSnapinError(TEXT("Invalid parameter to IViewExtensionCallback::AddView (empty URL)"), E_INVALIDARG);
            return (sc = E_INVALIDARG);
        }

        if (ved.strName.empty())
        {
            TraceSnapinError(TEXT("Invalid parameter to IViewExtensionCallback::AddView (empty title)"), E_INVALIDARG);
            return (sc = E_INVALIDARG);
        }

        /*
         * add the extension to the view
         */
        *(*m_pItExt)++ = ved;

        return sc;
    }

private:
    CViewExtInsertIterator *m_pItExt;

};


/*+-------------------------------------------------------------------------*
 * CNode::ScGetViewExtensions
 *
 *
 *--------------------------------------------------------------------------*/

SC CNode::ScGetViewExtensions (CViewExtInsertIterator itExt)
{
    DECLARE_SC (sc, _T("CNode::ScGetViewExtensions"));

    IDataObjectPtr spDataObject;
    bool bScopeItem ;
    sc = ScGetDataObject(/*bScopePane*/ true, NULL /*lResultItemCookie*/, bScopeItem, &spDataObject);
    if(sc)
        return sc;

    CSnapIn* pSnapIn = GetPrimarySnapIn();
    sc = ScCheckPointers (pSnapIn, E_FAIL);
    if (sc)
        return (sc);

    CArray<GUID, GUID&> DynExtens;
    ExtractDynExtensions(spDataObject, DynExtens);

    GUID guidNodeType;
    sc = ::ExtractObjectTypeGUID(spDataObject, &guidNodeType);
    if(sc)
        return sc;

    CExtensionsIterator it;
    sc = it.ScInitialize(pSnapIn, guidNodeType, g_szView, DynExtens.GetData(), DynExtens.GetSize());
    if(sc)
        return sc;

    typedef CComObject<CViewExtensionCallback> t_ViewExtensionCallback;

    t_ViewExtensionCallback *pViewExtensionCallback = NULL;
    sc = t_ViewExtensionCallback::CreateInstance(&pViewExtensionCallback);
    if(sc)
        return sc;

    if(NULL == pViewExtensionCallback)
        return (sc = E_UNEXPECTED);

    sc = pViewExtensionCallback->ScInitialize(itExt);
    if(sc)
        return sc;

    IViewExtensionCallbackPtr spViewExtensionCallback = pViewExtensionCallback;

    // add all the console taskpads first
    sc = CConsoleTaskpadViewExtension::ScGetViews(this, spViewExtensionCallback);
    if(sc)
        return sc;

    for (; !it.IsEnd(); it.Advance())
    {
        // any errors in this block should just go on to the next snap-in. Can't let one snap-in
        // hose all the others.

        /*
         * create the extension
         */
        IExtendViewPtr spExtendView;
        sc = spExtendView.CreateInstance(it.GetCLSID(), NULL, MMC_CLSCTX_INPROC);
        if(sc)
        {
            #ifdef DBG
            USES_CONVERSION;
            tstring strMsg = _T("Failed to create snapin ");
            CCoTaskMemPtr<WCHAR> spszCLSID;
            if (SUCCEEDED (StringFromCLSID (it.GetCLSID(), &spszCLSID)))
                strMsg += W2T(spszCLSID);
            TraceSnapinError(strMsg.data(), sc);
            #endif
            sc.Clear();
            continue;
        }

        /*
         * get the view extension data from the extension
         */
        sc = spExtendView->GetViews(spDataObject, spViewExtensionCallback);
        if(sc)
        {
            TraceSnapinError(TEXT("Snapin returned error on call to IExtendView::GetView"), sc);
            sc.Clear();
            continue;
        }
    }

    /*
     * View extensions aren't supposed to hold onto IExtendViewCallback,
     * but buggy view extensions might.  This will neuter the callback
     * so buggy view extensions won't reference stale data.
     */
    sc = pViewExtensionCallback->ScDeinitialize();
    if (sc)
        return (sc);

    return (sc);
}

/*******************************************************\
|  helper function to avoid too many stack allocations
\*******************************************************/
static std::wstring T2W_ForLoop(const tstring& str)
{
#if defined(_UNICODE)
    return str;
#else
    USES_CONVERSION;
    return A2CW(str.c_str());
#endif
}

/***************************************************************************\
|
| Implementation of subclass CNode::CDataObjectCleanup
| Responsible for data object clenup
|
| Cleanup works by these rules:
|
|  1. Data object created for cut , copy or dragdrop registers every node added to it
|  2. Nodes are registered in the static multimap, mapping node to the data object it belongs to.
|  3. Node destructor checks the map and triggers cleanup for all affected data objects.
|  4. Data Object cleanup is:   a) unregistering its nodes,
|               b) release contained data objects
|               b) entering invalid state (allowing only removal of cut objects to succeed)
|               c) revoking itself from clipboard if it is on the clipboard.
|  It will not do any of following: a) release references to IComponents as long as is alive
|               b) prevent MMCN_CUTORMOVE to be send by invoking RemoveCutItems()
|
\***************************************************************************/


// declare static variable
CNode::CDataObjectCleanup::CMapOfNodes CNode::CDataObjectCleanup::s_mapOfNodes;

/***************************************************************************\
 *
 * METHOD:  CNode::CDataObjectCleanup::ScRegisterNode
 *
 * PURPOSE: registers node to trigger clipboard clenup on destructor
 *
 * PARAMETERS:
 *    CNode *pNode                      [in] - node to register
 *    CMMCClipBoardDataObject *pObject  [in] - data object to remove from clipboard
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CNode::CDataObjectCleanup::ScRegisterNode(CNode *pNode, CMMCClipBoardDataObject *pObject)
{
    DECLARE_SC(sc, TEXT("CNode::CClipboardClenup::ScRegisterNode"));

    // parameter check
    sc = ScCheckPointers( pNode, pObject );
    if (sc)
        return sc;

    // add to the multimap
    s_mapOfNodes.insert( CMapOfNodes::value_type( pNode, pObject ) );

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CNode::CDataObjectCleanup::ScUnadviseDataObject
 *
 * PURPOSE: Removes nodes-'clenup triggers' kept for the object
 *
 * PARAMETERS:
 *    CMMCClipBoardDataObject *pObject [in] object going away
 *    bool bForceDataObjectCleanup     [in] whether need to ask DO to clenup / unregister itself
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CNode::CDataObjectCleanup::ScUnadviseDataObject(CMMCClipBoardDataObject *pObject, bool bForceDataObjectCleanup /*= true*/)
{
    DECLARE_SC(sc, TEXT("CNode::CDataObjectCleanup::ScUnadviseDataObject"));

    // remove all nodes associated with the data object
    CMapOfNodes::iterator it = s_mapOfNodes.begin();
    while ( it != s_mapOfNodes.end() )
    {
        // remove or skip the entry
        if ( it->second == pObject )
            it = s_mapOfNodes.erase( it );
        else
            ++it;
    }

    // invalidate data object when required
    if ( bForceDataObjectCleanup )
    {
        sc = pObject->ScInvalidate();
        if (sc)
            return sc;
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CNode::CDataObjectCleanup::ScUnadviseNode
 *
 * PURPOSE: Does data object claenup triggered by the node
 *
 * PARAMETERS:
 *    CNode *pNode [in] - node initiating cleanup
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CNode::CDataObjectCleanup::ScUnadviseNode(CNode *pNode)
{
    DECLARE_SC(sc, TEXT("CNode::CClipboardClenup::ScUnadviseNode"));

    // parameter check
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc;

    // find the node in the map
    CMapOfNodes::iterator it;
    while ( s_mapOfNodes.end() != ( it = s_mapOfNodes.find(pNode) ) )
    {
        // one node triggers clenup for whole data object
        sc = ScUnadviseDataObject( it->second );
        if (sc)
            return sc;
    }

    return sc;
}


//############################################################################
//############################################################################
//
//  Implementation of class CSnapInNode
//
//############################################################################
//############################################################################

DEBUG_DECLARE_INSTANCE_COUNTER(CSnapInNode);

CSnapInNode::CSnapInNode(
    CMTSnapInNode*  pMTNode,
    CViewData*      pViewData,
    bool            fRootNode)
    : CNode(pMTNode, pViewData, fRootNode, true)
{
    m_spData.CreateInstance();

    ASSERT(pMTNode != NULL);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CSnapInNode);

    pMTNode->AddNode(this);
}

CSnapInNode::CSnapInNode(const CSnapInNode& other) :
    CNode (other),
    m_spData (other.m_spData)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CSnapInNode);
}

void CSnapInNode::Reset()
{
    m_spData->Reset();
    ResetFlags();
    CNode::Reset();
}

CSnapInNode::~CSnapInNode()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CSnapInNode);

    CMTSnapInNode* pMTSINode = dynamic_cast<CMTSnapInNode*>(GetMTNode());
    ASSERT(pMTSINode != NULL);

    if (pMTSINode)
        pMTSINode->RemoveNode(this);
}

void CSnapInNode::AddComponentToArray(CComponent* pCC)
{
    ASSERT((pCC->GetComponentID() >= GetComponentArray().size()) ||
            (GetComponentArray().size() > 0) &&
            (GetComponentArray()[pCC->GetComponentID()] == NULL));

    if (pCC->GetComponentID() >= GetComponentArray().size())
        GetComponentArray().resize(pCC->GetComponentID() + 1);

    GetComponentArray()[pCC->GetComponentID()] = pCC;
}

CComponent* CSnapInNode::CreateComponent(CSnapIn* pSnapIn, int nID)
{
    ASSERT(pSnapIn != NULL);

    CComponent* pCC = new CComponent(pSnapIn);
	if ( pCC != NULL )
	{
		pCC->SetComponentID(nID);
		AddComponentToArray(pCC);
	}
    return pCC;
}

//+-------------------------------------------------------------------
//
//  Member:      CSnapInNode::GetResultImage
//
//  Synopsis:    Get the image-index in result-image list for this node.
//
//  Note:        The CSnapInNode member ImageListPrivate is not set all
//               the time (if the window is rooted at snapin node), so
//               set it temporarily when we need the icon index.
//               The member is set while adding sub-folders
//               The only other case this will affect is when called for
//               the image index for static snapin nodes displayed in result-pane.
//               But when static snapin nodes are displayed in result-pane the
//               AddSubFolders added it so the imagelist is already set.
//
//  Arguments:
//
//  Returns:     Image index for this item in result-pane.
//
//--------------------------------------------------------------------
UINT CSnapInNode::GetResultImage()
{
    IImageListPrivate *pImageList = GetImageList();

    if (!pImageList)
    {
        CComponent *pCC = GetPrimaryComponent();
        if (pCC)
            pImageList = pCC->GetIImageListPrivate();
    }

    CMTSnapInNode* pMTSnapInNode = dynamic_cast<CMTSnapInNode*>(GetMTNode());

    if (pMTSnapInNode)
        return pMTSnapInNode->GetResultImage ((CNode*)this, pImageList);

    return CNode::GetResultImage();
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapInNode::GetControl
 *
 * PURPOSE:       Given the CLSID of the OCX, see if we have stored this
 *                OCX, if so return the OCXWrapper's IUnknown ptr.
 *
 * PARAMETERS:
 *    CLSID clsid: class-id of the OCX.
 *
 * RETURNS:
 *    LPUNKNOWN of wrapper OCX.
 *
 *+-------------------------------------------------------------------------*/
LPUNKNOWN CSnapInNode::GetControl(CLSID& clsid)
{
    for (int i=0; i <= GetOCXArray().GetUpperBound(); i++)
    {
        if (GetOCXArray()[i].IsControlCLSID(clsid) == TRUE)
            return GetOCXArray()[i].GetControlUnknown();
    }

    return NULL;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapInNode::SetControl
 *
 * PURPOSE:       Given the CLSID of the OCX and of the wrapper.
 *
 * PARAMETERS:
 *    CLSID clsid : of a OCX.
 *    IUnknown *pUnknown: of OCX wrapper.
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CSnapInNode::SetControl(CLSID& clsid, IUnknown* pUnknown)
{
    // check for slot in cache
    int iLast = GetOCXArray().GetUpperBound();
    for (int i=0; i <= iLast;  i++)
    {
        if (GetOCXArray()[i].IsControlCLSID(clsid) == TRUE)
            break;
    }

    // if not in cache, add one more entry
    if (i > iLast)
        GetOCXArray().SetSize(i + 1);

    GetOCXArray()[i].SetControl(clsid, pUnknown);
}


/*+-------------------------------------------------------------------------*
 *
 * CSnapInNode::GetControl
 *
 * PURPOSE:       Given the IUnknown of the OCX, see if we have stored this
 *                OCX, if so return the OCXWrapper's IUnknown ptr.
 *
 * PARAMETERS:
 *    IUnknown *pUnkOCX : of a OCX.
 *
 * RETURNS:
 *    LPUNKNOWN of wrapper OCX.
 *
 *+-------------------------------------------------------------------------*/
LPUNKNOWN CSnapInNode::GetControl(LPUNKNOWN pUnkOCX)
{
    for (int i=0; i <= GetOCXArray().GetUpperBound(); i++)
    {
        // Compare IUnknowns.
        if (GetOCXArray()[i].IsSameOCXIUnknowns(pUnkOCX) == TRUE)
            return GetOCXArray()[i].GetControlUnknown();
    }

    return NULL;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapInNode::SetControl
 *
 * PURPOSE:       Given the IUnknown of the OCX and of the wrapper.
 *
 * PARAMETERS:
 *    IUnknown *pUnkOCX : of a OCX.
 *    IUnknown *pUnknown: of OCX wrapper.
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CSnapInNode::SetControl(LPUNKNOWN pUnkOCX, IUnknown* pUnknown)
{
    // check for slot in cache
    int iLast = GetOCXArray().GetUpperBound();
    for (int i=0; i <= iLast;  i++)
    {
        if (GetOCXArray()[i].IsSameOCXIUnknowns(pUnkOCX) == TRUE)
            break; // found the OCX, so replace with given OCXwrapper.
    }

    // if not in cache, add one more entry
    if (i > iLast)
        GetOCXArray().SetSize(i + 1);

    GetOCXArray()[i].SetControl(pUnkOCX, pUnknown);
}


//+-------------------------------------------------------------------
//
//  Member:      CNode::ScGetConsoleTaskpad
//
//  Synopsis:    Get the console taskpad identified by given GUID for this node.
//
//  Arguments:   [guidTaskpad] - [in param]
//               [ppTaskpad]   - [out param]
//
//  Returns:     SC, S_FALSE if none exists
//
//--------------------------------------------------------------------
SC CNode::ScGetConsoleTaskpad (const GUID& guidTaskpad, CConsoleTaskpad **ppTaskpad)
{
    DECLARE_SC(sc, _T("CNode::ScGetConsoleTaskpad"));
    sc = ScCheckPointers(ppTaskpad);
    if (sc)
        return sc;

    *ppTaskpad = NULL;

    CScopeTree* pScopeTree = CScopeTree::GetScopeTree();
    sc = ScCheckPointers(pScopeTree, E_UNEXPECTED);
    if(sc)
        return sc;

    CConsoleTaskpadList *pConsoleTaskpadList = pScopeTree->GetConsoleTaskpadList();
    sc = ScCheckPointers(pConsoleTaskpadList, E_UNEXPECTED);
    if (sc)
        return sc;

    // get a filtered list of taskpads that apply to this node.
    CConsoleTaskpadFilteredList filteredList;

    sc = pConsoleTaskpadList->ScGetTaskpadList(this, filteredList);
    if(sc)
        return sc;

    for(CConsoleTaskpadFilteredList::iterator iter = filteredList.begin(); iter!= filteredList.end(); ++iter)
    {
        CConsoleTaskpad *pTaskpad = *iter;
        sc = ScCheckPointers(pTaskpad, E_UNEXPECTED);
        if (sc)
            return sc;

        if (pTaskpad->GetID() == guidTaskpad)
        {
            *ppTaskpad = pTaskpad;
            return sc;               // found
        }
    }

    return (sc = S_FALSE);    // not found
}



/*************************************************************************
 *
 * There is only one CViewSettingsPersistor object per document.
 *
 * The object stored as static variable inside CNode as CNode needs
 * to access this object frequently.
 *
 * The Document needs to initialize/save the object by loading/savind
 * from/to console file. It calls below ScQueryViewSettingsPersistor.
 *
 * The object is created with first call to ScQueryViewSettingsPersistor.
 * The object is destroyed when DocumentClosed event is received.
 *
 *************************************************************************/
CComObject<CViewSettingsPersistor>* CNode::m_pViewSettingsPersistor = NULL;

//+-------------------------------------------------------------------
//
//  Member:      CNode::ScQueryViewSettingsPersistor
//
//  Synopsis:    Static method to get IPersistStream to load CViewSettingsPersistor
//               object from old style console file.
//
//               If the CViewSettingsObject is not created then create one.
//
//  Arguments:   [ppStream] - [out]
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CNode::ScQueryViewSettingsPersistor (IPersistStream **ppStream)
{
    DECLARE_SC(sc, _T("CNode::ScQueryViewSettingsPersistor"));
    sc = ScCheckPointers(ppStream);
    if (sc)
        return sc;

   // Create new CViewSettingsPersistor if none exists
   if (NULL == m_pViewSettingsPersistor)
   {
        sc = CComObject<CViewSettingsPersistor>::CreateInstance (&m_pViewSettingsPersistor);
        if (sc)
            goto ObjectCreationFailed;

        sc = ScCheckPointers(m_pViewSettingsPersistor, E_UNEXPECTED);
        if (sc)
            goto ObjectCreationFailed;

        m_pViewSettingsPersistor->AddRef();
    }

    sc = ScCheckPointers(m_pViewSettingsPersistor, E_UNEXPECTED);
    if (sc)
        goto ObjectCreationFailed;

    *ppStream = static_cast<IPersistStream*>(m_pViewSettingsPersistor);
    if (NULL == *ppStream)
        return (sc = E_UNEXPECTED);

    (*ppStream)->AddRef();

Cleanup:
    return (sc);

ObjectCreationFailed:
    CStr strMsg;
    strMsg.LoadString(GetStringModule(), IDS_ViewSettingCouldNotBePersisted);
    ::MessageBox(NULL, strMsg, NULL, MB_OK|MB_SYSTEMMODAL);
    goto Cleanup;
}


//+-------------------------------------------------------------------
//
//  Member:      CNode::ScQueryViewSettingsPersistor
//
//  Synopsis:    Static method to get CXMLObject to load or save
//               CViewSettingsPersistor object from XML console file.
//
//               If the CViewSettingsObject is not created then create one.
//
//  Arguments:   [ppXMLObject] - [out]
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CNode::ScQueryViewSettingsPersistor (CXMLObject **ppXMLObject)
{
    DECLARE_SC(sc, _T("CNode::ScQueryViewSettingsPersistor"));
    sc = ScCheckPointers(ppXMLObject);
    if (sc)
        return sc;

    // Create new CViewSettingsPersistor if none exists
    if (NULL == m_pViewSettingsPersistor) // Create new one
    {
         sc = CComObject<CViewSettingsPersistor>::CreateInstance (&m_pViewSettingsPersistor);
         if (sc)
             goto ObjectCreationFailed;

         sc = ScCheckPointers(m_pViewSettingsPersistor, E_UNEXPECTED);
         if (sc)
             goto ObjectCreationFailed;

         m_pViewSettingsPersistor->AddRef();
     }

     sc = ScCheckPointers(m_pViewSettingsPersistor, E_UNEXPECTED);
     if (sc)
         goto ObjectCreationFailed;

     *ppXMLObject = static_cast<CXMLObject*>(m_pViewSettingsPersistor);
     if (NULL == *ppXMLObject)
         return (sc = E_UNEXPECTED);

 Cleanup:
     return (sc);

 ObjectCreationFailed:
     CStr strMsg;
     strMsg.LoadString(GetStringModule(), IDS_ViewSettingCouldNotBePersisted);
     ::MessageBox(NULL, strMsg, NULL, MB_OK|MB_SYSTEMMODAL);
     goto Cleanup;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CNode::ScDeleteViewSettings
//
//  Synopsis:    Delete the CViewSettings object for given view-id as the
//               view is being closed.
//
//  Arguments:   [nViewID] -
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CNode::ScDeleteViewSettings (int nViewID)
{
    DECLARE_SC(sc, _T("CNode::ScDeleteViewSettings"));

    sc = ScCheckPointers(m_pViewSettingsPersistor, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = m_pViewSettingsPersistor->ScDeleteDataOfView(nViewID);
    if (sc)
        return sc;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CNode::ScOnDocumentClosing
//
//  Synopsis:    The document is closing, destroy any document related
//               objects like CViewSettingsPersistor.
//
//  Arguments:   None
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CNode::ScOnDocumentClosing ()
{
    DECLARE_SC(sc, _T("CNode::ScOnDocumentClosing"));

    if (m_pViewSettingsPersistor)
    {
        m_pViewSettingsPersistor->Release();
        m_pViewSettingsPersistor = NULL;
    }

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CNode::ScSetFavoriteViewSettings
//
//  Synopsis:    A favorite is selected and it sets viewsettings
//               before re-selecting the node so that after re-selection
//               the new settings are set for the view.
//
//  Arguments:   [nViewID]      -
//               [bookmark]     -
//               [viewSettings] -
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CNode::ScSetFavoriteViewSettings (int nViewID, const CBookmark& bookmark,
                                     const CViewSettings& viewSettings)
{
    DECLARE_SC(sc, _T("CNode::ScSetFavoriteViewSettings"));
    sc = ScCheckPointers(m_pViewSettingsPersistor, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = m_pViewSettingsPersistor->ScSetFavoriteViewSettings (nViewID, bookmark, viewSettings);
    if (sc)
        return sc;

    return (sc);
}



//+-------------------------------------------------------------------
//
//  Member:      CNode::ScGetViewMode
//
//  Synopsis:    Get the viewmode if any persisted for this node.
//
//  Arguments:   [ulViewMode] - [out]
//
//  Returns:     SC, S_FALSE if none persisted.
//
//--------------------------------------------------------------------
SC CNode::ScGetViewMode (ULONG& ulViewMode)
{
    DECLARE_SC(sc, _T("CNode::ScGetViewMode"));

    CMTNode *pMTNode = GetMTNode();
    sc = ScCheckPointers(pMTNode, E_UNEXPECTED);
    if (sc)
        return sc;

    CBookmark *pBookmark = pMTNode->GetBookmark();
    CViewData *pViewData = GetViewData();
    sc = ScCheckPointers(m_pViewSettingsPersistor, pBookmark, pViewData, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = m_pViewSettingsPersistor->ScGetViewMode (pViewData->GetViewID(),
                                                  *pBookmark,
                                                  ulViewMode);
    if (sc)
        return sc;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CNode::ScSetViewMode
//
//  Synopsis:    Set the viewmode in persisted viewsettings.
//
//  Arguments:   [ulViewMode] - [in]
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CNode::ScSetViewMode (ULONG ulViewMode)
{
    DECLARE_SC(sc, _T("CNode::ScSetViewMode"));

    CMTNode *pMTNode = GetMTNode();
    sc = ScCheckPointers(pMTNode, E_UNEXPECTED);
    if (sc)
        return sc;

    CBookmark *pBookmark = pMTNode->GetBookmark();
    CViewData *pViewData = GetViewData();
    sc = ScCheckPointers(m_pViewSettingsPersistor, pBookmark, pViewData, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = m_pViewSettingsPersistor->ScSetViewMode (pViewData->GetViewID(),
                                                  *pBookmark,
                                                  ulViewMode);
    if (sc)
        return sc;

    return (sc);
}



//+-------------------------------------------------------------------
//
//  Member:      CNode::ScGetResultViewType
//
//  Synopsis:    Get the CResultViewType if any persisted for this node.
//
//  Arguments:   [rvt] - [out]
//
//  Returns:     SC, S_FALSE if none persisted.
//
//--------------------------------------------------------------------
SC CNode::ScGetResultViewType (CResultViewType& rvt)
{
    DECLARE_SC(sc, _T("CNode::ScGetResultViewType"));

    CMTNode *pMTNode = GetMTNode();
    sc = ScCheckPointers(pMTNode, E_UNEXPECTED);
    if (sc)
        return sc;

    CBookmark *pBookmark = pMTNode->GetBookmark();
    CViewData *pViewData = GetViewData();
    sc = ScCheckPointers(m_pViewSettingsPersistor, pBookmark, pViewData, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = m_pViewSettingsPersistor->ScGetResultViewType (pViewData->GetViewID(),
                                                        *pBookmark,
                                                        rvt);
    if (sc)
        return sc;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CNode::ScSetResultViewType
//
//  Synopsis:    Set the CResultViewType in persisted viewsettings.
//
//  Arguments:   [rvt] - [in]
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CNode::ScSetResultViewType (const CResultViewType& rvt)
{
    DECLARE_SC(sc, _T("CNode::ScSetResultViewType"));

    CMTNode *pMTNode = GetMTNode();
    sc = ScCheckPointers(pMTNode, E_UNEXPECTED);
    if (sc)
        return sc;

    CBookmark *pBookmark = pMTNode->GetBookmark();
    CViewData *pViewData = GetViewData();
    sc = ScCheckPointers(m_pViewSettingsPersistor, pBookmark, pViewData, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = m_pViewSettingsPersistor->ScSetResultViewType (pViewData->GetViewID(),
                                                        *pBookmark,
                                                        rvt);
    if (sc)
        return sc;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CNode::ScGetTaskpadID
//
//  Synopsis:    Get the taskpad-id if any persisted for this node.
//               First see if there are any node-specific taskpad-id
//               else get the node-type-specific setting if one exists.
//
//  Arguments:   [rvt] - [out]
//
//  Returns:     SC, S_FALSE if none persisted.
//
//--------------------------------------------------------------------
SC CNode::ScGetTaskpadID (GUID& guidTaskpad)
{
    DECLARE_SC(sc, _T("CNode::ScGetTaskpadID"));

    CMTNode *pMTNode = GetMTNode();
    sc = ScCheckPointers(pMTNode, E_UNEXPECTED);
    if (sc)
        return sc;

    CViewData *pViewData = GetViewData();
    CBookmark *pBookmark = pMTNode->GetBookmark();
    sc = ScCheckPointers(m_pViewSettingsPersistor, pViewData, pBookmark, E_UNEXPECTED);
    if (sc)
        return sc;

    // 1. Try to get node-specific taskpad-id
    sc = m_pViewSettingsPersistor->ScGetTaskpadID (pViewData->GetViewID(),
                                                   *pBookmark,
                                                   guidTaskpad);
    if (sc == S_OK)
        return sc;

    // 2. Try to get nodetype specific taskpad-id.
    GUID guidNodeType;
    sc = pMTNode->GetNodeType(&guidNodeType);
    if (sc)
        return sc;

    sc = m_pViewSettingsPersistor->ScGetTaskpadID(pViewData->GetViewID(),
                                                  guidNodeType,
                                                  guidTaskpad);
    if (sc)
        return sc;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CNode::ScSetTaskpadID
//
//  Synopsis:    Set the taskpad-id in persisted viewsettings. Also see if
//               the taskpad is node-specific or nodetype-specific and persist
//               accordingly.
//
//  Arguments:   [guidTaskpad]   - [in]
//               [bSetDirty]     - [in], set the console file dirty.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CNode::ScSetTaskpadID (const GUID& guidTaskpad, bool bSetDirty)
{
    DECLARE_SC(sc, _T("CNode::ScSetTaskpadID"));

    CMTNode *pMTNode = GetMTNode();
    sc = ScCheckPointers(pMTNode, E_UNEXPECTED);
    if (sc)
        return sc;

    CViewData *pViewData = GetViewData();
    sc = ScCheckPointers(m_pViewSettingsPersistor, pViewData, E_UNEXPECTED);
    if (sc)
        return sc;

    // Need to know if this task-pad is nodespecific or not.
    bool bNodeSpecific = false;
    CConsoleTaskpad *pTaskpad = NULL;
    sc = ScGetConsoleTaskpad (guidTaskpad, &pTaskpad);

    if (sc == S_OK) // S_OK if taskpad exists
    {
        sc = ScCheckPointers(pTaskpad, E_UNEXPECTED);
        if (sc)
            return sc;

        bNodeSpecific = pTaskpad->IsNodeSpecific();
    }
   // else  it may be viewextension or normal view (which are nodetype-specific).

    CBookmark *pBookmark = pMTNode->GetBookmark();
    sc = ScCheckPointers(pBookmark, E_UNEXPECTED);
    if (sc)
        return sc;

    if (bNodeSpecific)
    {
        // Per node taskpad
        sc = m_pViewSettingsPersistor->ScSetTaskpadID (pViewData->GetViewID(),
                                                       *pBookmark,
                                                       guidTaskpad,
                                                       bSetDirty);
    }
    else
    {
        // Per nodetype taskpad.
        GUID guidNodeType;
        sc = pMTNode->GetNodeType(&guidNodeType);
        if (sc)
            return sc;

        sc = m_pViewSettingsPersistor->ScSetTaskpadID(pViewData->GetViewID(),
                                                      guidNodeType,
                                                      *pBookmark,
                                                      guidTaskpad,
                                                      bSetDirty);
    }

    if (sc)
        return sc;

    return (sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\node.inl ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 00
 *
 *  File:      node.inl
 *
 *  Contents:  Inline functions for node.h
 *
 *  History:   9-Mar-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#pragma once


//_____________________________________________________________________________
//
//  Inlines for class:  CComponent
//_____________________________________________________________________________
//

inline CComponent::CComponent(CSnapIn * pSnapIn)
{
    Construct(pSnapIn, NULL);
}

inline HRESULT CComponent::Initialize(LPCONSOLE lpConsole)
{
    ASSERT(m_spIComponent != NULL);
    if (m_spIComponent == NULL)
        return E_FAIL;

    return m_spIComponent->Initialize(lpConsole);
}


inline HRESULT CComponent::Destroy(MMC_COOKIE cookie)
{
    ASSERT(m_spIComponent != NULL);
    if (m_spIComponent == NULL)
        return E_FAIL;

    return m_spIComponent->Destroy(cookie);
}

inline HRESULT CComponent::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                                           LPDATAOBJECT* ppDataObject)
{
    ASSERT(m_spIComponent != NULL);
    if (m_spIComponent == NULL)
        return E_FAIL;

    ASSERT(type == CCT_RESULT || type == CCT_UNINITIALIZED);
    return m_spIComponent->QueryDataObject(cookie, type, ppDataObject);
}

inline HRESULT CComponent::GetResultViewType(MMC_COOKIE cookie, LPOLESTR* ppszViewType, long* pViewOptions)
{
    ASSERT(m_spIComponent != NULL);
    if (m_spIComponent == NULL)
        return E_FAIL;

    return m_spIComponent->GetResultViewType(cookie, ppszViewType, pViewOptions);
}

inline HRESULT CComponent::GetDisplayInfo(RESULTDATAITEM* pResultDataItem)
{
    ASSERT(m_spIComponent != NULL);
    if (m_spIComponent == NULL)
        return E_FAIL;

    return m_spIComponent->GetDisplayInfo(pResultDataItem);
}


//_____________________________________________________________________________
//
//  Inlines for class:  COCX
//_____________________________________________________________________________
//

inline COCX::COCX(void)
    : m_clsid(CLSID_NULL)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(COCX);
}

inline COCX::~COCX(void)
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(COCX);
}

inline void COCX::SetControl(CLSID& clsid, IUnknown* pUnknown)
{
    m_clsid = clsid;
    m_spOCXWrapperUnknown = pUnknown;
}

inline void COCX::SetControl(LPUNKNOWN pUnkOCX, LPUNKNOWN pUnkOCXWrapper)
{
    m_spOCXUnknown = pUnkOCX;
    m_spOCXWrapperUnknown = pUnkOCXWrapper;
}


//____________________________________________________________________________
//
//  Inlines for class:      CNode
//____________________________________________________________________________
//


/*+-------------------------------------------------------------------------*
 * CNode::ToHandle
 * CNode::FromHandle
 *
 * Converts between HNODE's and CNode*'s.  Currently this is a direct mapping
 * via casting, but enventually there will be an indirect mapping that will
 * allow detection of stale HNODEs.
 *--------------------------------------------------------------------------*/

inline CNode* CNode::FromHandle (HNODE hNode)
{
    return (reinterpret_cast<CNode*>(hNode));
}

inline HNODE CNode::ToHandle (const CNode* pNode)
{
    return (reinterpret_cast<HNODE>(const_cast<CNode*>(pNode)));
}

inline void CNode::ResetFlags(void)
{
    //m_dwFlags &= ~flag_expanded_at_least_once;
    m_dwFlags = 0;
}

inline void CNode::SetExpandedAtLeastOnce(void)
{
    m_dwFlags |= flag_expanded_at_least_once;
}

inline BOOL CNode::WasExpandedAtLeastOnce(void)
{
    return (m_dwFlags & flag_expanded_at_least_once) ? TRUE : FALSE;
}

inline void CNode::SetExpandedVisually(bool bExpanded)
{
    if (bExpanded)
        m_dwFlags |= flag_expanded_visually;
    else
        m_dwFlags &= ~flag_expanded_visually;
}

inline bool CNode::WasExpandedVisually(void)
{
    return (m_dwFlags & flag_expanded_visually) ? true : false;
}

inline const CLSID& CNode::GetPrimarySnapInCLSID(void)
{
    CSnapIn* const pSnapIn = GetPrimarySnapIn();
    if (pSnapIn == NULL)
        return (GUID_NULL);

    return pSnapIn->GetSnapInCLSID();
}

inline CComponent* CNode::GetPrimaryComponent(void)
{
    ASSERT ((m_pPrimaryComponent != NULL) && m_pPrimaryComponent->IsInitialized());
    return m_pPrimaryComponent;
}

inline LPARAM CNode::GetUserParam(void)
{
    DECLARE_SC (sc, _T("CNode::GetUserParam"));

    CMTNode* pMTNode = GetMTNode();
    sc = ScCheckPointers (pMTNode, E_UNEXPECTED);
    if (sc)
        return (0);

    return (pMTNode->GetUserParam());
}

inline HRESULT CNode::GetNodeType(GUID* pGuid)
{
    DECLARE_SC (sc, _T("CNode::GetNodeType"));

    sc = ScCheckPointers (pGuid);
    if (sc)
        return (sc.ToHr());

    CMTNode* pMTNode = GetMTNode();
    sc = ScCheckPointers (pMTNode, E_UNEXPECTED);
    if (sc)
        return (sc.ToHr());

    return pMTNode->GetNodeType(pGuid);
}

inline HRESULT CNode::QueryDataObject(DATA_OBJECT_TYPES type,
                                                LPDATAOBJECT* ppdtobj)
{
    DECLARE_SC (sc, _T("CNode::QueryDataObject"));

    sc = ScCheckPointers (ppdtobj);
    if (sc)
        return (sc.ToHr());

    CMTNode* pMTNode = GetMTNode();
    sc = ScCheckPointers (pMTNode, E_UNEXPECTED);
    if (sc)
        return (sc.ToHr());

    return pMTNode->QueryDataObject(type, ppdtobj);
}

/*--------------------------------------------------------------------------*
 * CNode::ExtractColumnConfigID
 *
 *
 *--------------------------------------------------------------------------*/
inline HRESULT CNode::ExtractColumnConfigID(IDataObject* pDataObj, HGLOBAL& hGlobal)
{
    ASSERT(pDataObj != NULL);
    // Get the data
    return (DataObject_GetHGLOBALData (pDataObj, GetColumnConfigIDCF(),&hGlobal));
}

/*--------------------------------------------------------------------------*
 * CNode::GetColumnConfigIDCF
 *
 *
 *--------------------------------------------------------------------------*/
inline CLIPFORMAT CNode::GetColumnConfigIDCF()
{
    static CLIPFORMAT cfColumnConfigID = 0;

    if (cfColumnConfigID == 0)
    {
        USES_CONVERSION;
        cfColumnConfigID = (CLIPFORMAT) RegisterClipboardFormat (W2T (CCF_COLUMN_SET_ID));
        ASSERT (cfColumnConfigID != 0);
    }

    return (cfColumnConfigID);
}

inline CSnapInNode* CNode::GetStaticParent(void)
{
    CMTSnapInNode* pMTSINode = GetMTNode()->GetStaticParent();

    CNodeList& nodeList = pMTSINode->GetNodeList();
    POSITION pos = nodeList.GetHeadPosition();
    CNode* pNode = NULL;

    while (pos)
    {
        pNode = nodeList.GetNext(pos);
        if (pNode->GetViewID() == GetViewID())
            break;
    }
    ASSERT(pNode != NULL);

    return dynamic_cast<CSnapInNode*>(pNode);
}

inline CComponent* CNode::GetComponent(COMPONENTID nID)
{
    CMTSnapInNode* pMTSnapInNode = GetMTNode()->GetStaticParent();

    CComponent* pCC = pMTSnapInNode->GetComponent(GetViewID(), nID,
                                                  GetPrimarySnapIn());
    ASSERT(pCC != NULL);

    return pCC;
}

inline LPUNKNOWN CNode::GetControl(CLSID& clsid)
{
    DECLARE_SC(sc, TEXT("CNode::GetControl"));
    CSnapInNode* pSINode = GetStaticParent();

    sc = ScCheckPointers(pSINode, E_UNEXPECTED);
    if (sc)
        return NULL;

    return pSINode->GetControl(clsid);
}

inline void CNode::SetControl(CLSID& clsid, IUnknown* pUnknown)
{
    DECLARE_SC(sc, TEXT("CNode::SetControl"));

    CSnapInNode* pSINode = GetStaticParent();
    sc = ScCheckPointers(pSINode, E_UNEXPECTED);
    if (sc)
        return;

    pSINode->SetControl(clsid, pUnknown);
}

inline LPUNKNOWN CNode::GetControl(LPUNKNOWN pUnkOCX)
{
    DECLARE_SC(sc, TEXT("CNode::GetControl"));
    CSnapInNode* pSINode = GetStaticParent();
    sc = ScCheckPointers(pSINode, E_UNEXPECTED);
    if (sc)
        return NULL;

    return pSINode->GetControl(pUnkOCX);
}

inline void CNode::SetControl(LPUNKNOWN pUnkOCX, IUnknown* pUnknown)
{
    DECLARE_SC(sc, TEXT("CNode::SetControl"));
    CSnapInNode* pSINode = GetStaticParent();
    sc = ScCheckPointers(pSINode, E_UNEXPECTED);
    if (sc)
        return;

    pSINode->SetControl(pUnkOCX, pUnknown);
}

//_____________________________________________________________________________
//
//  Inlines for class:  CSnapInNode
//_____________________________________________________________________________
//

inline CComponent* CSnapInNode::GetComponent(const CLSID& clsid)
{
    for (int i=0; i < GetComponentArray().size(); i++)
    {
        if (GetComponentArray()[i] != NULL &&
            IsEqualCLSID(clsid, GetComponentArray()[i]->GetCLSID()) == TRUE)
            return GetComponentArray()[i];
    }
    return NULL;
}

inline CComponent* CSnapInNode::GetComponent(COMPONENTID nID)
{
    if (nID < GetComponentArray().size())
        return GetComponentArray()[nID];

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\node.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       Node.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    9/16/1996   RaviR   Created
//
//____________________________________________________________________________

#ifndef _MMC_NODE_H_
#define _MMC_NODE_H_
#pragma once

#include "amcmsgid.h"
#include "refcount.h"   // for CRefCountedObject

// A vector of strings to store column names
typedef std::vector<tstring> TStringVector;



///////////////////////////////////////////////////////////////////////////////
// Classes declared in this file

class CComponent;
class CDataNotifyInfo;

class CNode;
    class CSnapInNode;


///////////////////////////////////////////////////////////////////////////////
// Forward declarations
class CConsoleTaskpad;
class CResultItem;
class CResultViewType;
class CMMCClipBoardDataObject;
class CViewSettingsPersistor;

///////////////////////////////////////////////////////////////////////////////
// Class declarations

//____________________________________________________________________________
//
//  class:      CComponent
//____________________________________________________________________________
//

class CComponent
{
    DECLARE_NOT_COPIABLE  (CComponent);
    DECLARE_NOT_ASSIGNABLE(CComponent);
public:
// Constructor & Destructor
    CComponent(CSnapIn * pSnapIn);
    virtual ~CComponent();

// Attributes
    const CLSID& GetCLSID() const
    {
        if (m_spSnapIn == NULL)
            return (GUID_NULL);

        return m_spSnapIn->GetSnapInCLSID();
    }

    CSnapIn* GetSnapIn(void) const
    {
        return m_spSnapIn;
    }

    IComponent* GetIComponent(void) const
    {
        return m_spIComponent;
    }

    IFramePrivate* GetIFramePrivate(void) const
    {
        return m_spIFrame;
    }

    IImageListPrivate* GetIImageListPrivate(void) const
    {
        return m_spIRsltImageList;
    }

// Operations
    // Initialization
    HRESULT Init(IComponentData* pIComponentData, HMTNODE hMTNode, HNODE lNode,
                 COMPONENTID nComponentID, int viewID);

    BOOL IsInitialized()
    {
        return (m_spIFrame != NULL);
    }

    LPUNKNOWN GetUnknownToLoad(void) const
    {
        return m_spIComponent;
    }

    // IComponent interface methods
    HRESULT Initialize(LPCONSOLE lpConsole);
    HRESULT Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LONG_PTR arg, LPARAM param);
    HRESULT Destroy(MMC_COOKIE cookie);
    HRESULT QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                            LPDATAOBJECT* ppDataObject);
    HRESULT GetResultViewType(MMC_COOKIE cookie, LPOLESTR* ppszViewType, long* pViewOptions);
    HRESULT GetDisplayInfo(RESULTDATAITEM* pResultDataItem);

    // IComponent2 helper
    SC      ScQueryDispatch(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, PPDISPATCH ppSelectedObject);

    void SetComponentID(COMPONENTID nID)
    {
        ASSERT(nID < 1000);
        m_ComponentID = nID;
    }

    COMPONENTID GetComponentID(void) const
    {
        return m_ComponentID;
    }

    void ResetComponentID(COMPONENTID id)
    {
        m_spIFrame->SetComponentID(m_ComponentID = id);
    }

    SC  ScResetConsoleVerbStates ();

    // loaded from stream/storage; initailized with the new one; or does not need initialization
    bool IsIComponentInitialized() 
    { 
        return m_bIComponentInitialized; 
    }

    // loaded from stream/storage; initailized with the new one; or does not need initialization
    void SetIComponentInitialized()
    { 
        m_bIComponentInitialized = true; 
    }

private:
// Implementation
    CSnapInPtr              m_spSnapIn;

    IComponentPtr           m_spIComponent;
    IFramePrivatePtr        m_spIFrame;
    IImageListPrivatePtr    m_spIRsltImageList;

    COMPONENTID             m_ComponentID;
    bool                    m_bIComponentInitialized;

    // Helper methods
    void Construct(CSnapIn * pSnapIn, CComponent* pComponent);

}; // class CComponent

class CComponentPtrArray : public CArray<CComponent*, CComponent*>
{
public:
    void AddComponent(CComponent* pCC)
    {
        for (int i = GetUpperBound(); i >= 0; --i)
        {
            if (GetAt(i) == pCC)
                return;
        }

        Add(pCC);
    }
};


//____________________________________________________________________________
//
//  class:      CNode
//
//  PURPOSE:    Each master tree node class (ie CMTxxx) has a matching CNode-derived
//              class. The CNode-derived class objects encapsulate the view-dependent
//              settings of the CMTNode derived object.
//
//____________________________________________________________________________
//

class CNode
{
    DECLARE_NOT_ASSIGNABLE(CNode);

// Constructor & Destructor
protected:
    // only from CSnapInNode
    CNode(CMTNode * pMTNode, CViewData* pViewData, bool fRootNode, bool fStaticNode);
public:
    CNode(CMTNode * pMTNode, CViewData* pViewData, bool fRootNode);
    CNode(const CNode& other);
    virtual ~CNode();

// converters
    static CNode*       FromHandle (HNODE hNode);
    static CNode*       FromResultItem (CResultItem* pri);
    static HNODE        ToHandle (const CNode* pNode);

// Attributes
    CViewData*          GetViewData(void)const      {ASSERT(m_pViewData != NULL); return m_pViewData;}
    int                 GetViewID(void)             {ASSERT(m_pViewData != NULL);return m_pViewData->GetViewID();}
    virtual UINT        GetResultImage()            {return m_pMTNode->GetImage();}
    void                SetDisplayName(LPCTSTR pName){m_pMTNode->SetDisplayName(pName);}
    void                SetResultItem(HRESULTITEM hri){m_hri = hri;}
    long                GetOwnerID(void) const{return m_pMTNode->GetOwnerID();}

    void                ResetFlags();
    void                SetExpandedAtLeastOnce();
    BOOL                WasExpandedAtLeastOnce();
    void                SetExpandedVisually(bool bExpanded);
    bool                WasExpandedVisually(void);
    bool                AllowNewWindowFromHere() const { return (m_pMTNode->AllowNewWindowFromHere()); }

    tstring             GetDisplayName(){return m_pMTNode->GetDisplayName();}
    CMTNode*            GetMTNode() const           {return m_pMTNode;}
    HRESULTITEM         GetResultItem() const       {return m_hri;}
    virtual BOOL        NeedsViewToBePersisted(void){return FALSE;}

    virtual CComponent* GetComponent(COMPONENTID nID);
    CComponent*         GetPrimaryComponent(void);
    HRESULT             InitComponents();

    // Overridables
    SC                  ScGetResultPane(CResultViewType &rvt, GUID *pGuidTaskpadID);
    BOOL                IsDynamicNode() const       {return !IsStaticNode();}
    BOOL                IsStaticNode() const        {return (m_fStaticNode);}

    BOOL                IsConsoleRoot(){return (GetMTNode()->Parent() == NULL);}
    BOOL                IsRootNode() const          {return m_fRootNode;}
    virtual LPUNKNOWN   GetControl(CLSID& clsid);
    virtual LPUNKNOWN   GetControl(LPUNKNOWN pUnkOCX);

    virtual void        SetControl(CLSID& clsid, IUnknown* pUnknown);
    virtual void        SetControl(LPUNKNOWN pUnkOCX, IUnknown* pUnknown);

    CSnapIn*            GetPrimarySnapIn(void)      {return GetPrimaryComponent()->GetSnapIn();}
    BOOL                IsInitialized(void)         {return !m_bInitComponents;}
    IUnknown*           GetControlbarsCache(void)
                                    {return m_pViewData->GetControlbarsCache();}

    HRESULT             OnSelect(LPUNKNOWN lpView, BOOL bSelect, BOOL bResultPaneIsWeb);
    HRESULT             OnScopeSelect(bool bSelect, SELECTIONINFO* pSelInfo);
    HRESULT             OnListPad(LONG_PTR arg, LPARAM param);
    HRESULT             IsTargetNode(CNode *pNodeTest)        {return E_FAIL;} // do not change.
    HRESULT             OnExpand(bool fExpand);
    HRESULT             OnGetPrimaryTask(IExtendTaskPad **ppExtendTaskPad);
    IFramePrivate *     GetIFramePrivate();
    HRESULT             GetTaskEnumerator(LPOLESTR pszTaskGroup, IEnumTASK** ppEnumTask);
    HRESULT             GetListPadInfo(IExtendTaskPad* pExtendTaskPad, LPOLESTR szTaskGroup,
                                    MMC_ILISTPAD_INFO* pIListPadInfo);
    void                ResetControlbars(BOOL bSelect, SELECTIONINFO* pSelInfo);

    void                ResetVerbSets(BOOL bSelect, SELECTIONINFO* pSelInfo);
    HRESULT             GetDataInfo(BOOL bSelect, SELECTIONINFO* pSelInfo, CDataNotifyInfo* pDNI);
    SC                  ScInitializeVerbs (bool bSelect, SELECTIONINFO* pSelInfo);

    void                OnTaskNotify(LONG_PTR arg, LPARAM param);
    virtual void        OnWebContextMenu()                       {};
    LPARAM              GetUserParam(void);
    HRESULT             GetDispInfoForListItem(LV_ITEMW* plvi);
    HRESULT             GetDispInfo(LV_ITEMW* plvi);

    HRESULT             OnColumnClicked(LONG_PTR nCol);
    HRESULT             OnInitOCX(IUnknown* pUnk);
    HRESULT             OnCacheHint(int nStartIndex, int nEndIndex);

    HRESULT             SendShowEvent(BOOL bSelect);

    HRESULT             OnColumnsChange(CColumnInfoList& colInfoList);
    SC                  ScSetViewExtension(GUID *pGuidViewId, bool bUseDefaultTaskpad, bool bSetViewSettingsDirty);
    SC                  ScGetDataObject(bool bScopePane, LPARAM lResultItemCookie, bool& bScopeItem, LPDATAOBJECT* ppDataObject, CComponent **ppCComponent = NULL);
    SC                  ScGetPropertyFromINodeProperties(LPDATAOBJECT pDataObject, BOOL bForScopeItem, LPARAM resultItemParam, BSTR bstrPropertyName, PBSTR  pbstrPropertyValue);
    SC                  ScExecuteShellCommand(BSTR Command, BSTR Directory, BSTR Parameters, BSTR WindowState);
    SC                  ScGetDropTargetDataObject(bool bScope, LPARAM lResultItemCookie, LPDATAOBJECT *ppDataObject);

    CSnapInNode*        GetStaticParent(void);
    HRESULT             QueryDataObject(DATA_OBJECT_TYPES type, LPDATAOBJECT* ppdtobj);
    HRESULT             GetNodeType(GUID* pGuid);
    SC                  ScSetupTaskpad(GUID *pGuidTaskpadID);
    HRESULT             RestoreSort(INT nCol, DWORD dwSortOptions);
    SC                  ScRestoreSortFromPersistedData();
    SC                  ScSaveSortData (int nCol, DWORD dwOptions);
    SC                  ScGetSnapinAndColumnDataID(GUID& snapinGuid, CXMLAutoBinary& columnID);
    SC                  ScRestoreResultView(const CResultViewType& rvt);
    SC                  ScRestoreViewMode();
    SC                  ScSaveColumnInfoList(CColumnInfoList& columnInfoList);
    const CLSID&        GetPrimarySnapInCLSID(void);
    HRESULT             ExtractColumnConfigID(IDataObject* pDataObj, HGLOBAL& phGlobal);
    CLIPFORMAT          GetColumnConfigIDCF();

    void                SetPrimaryComponent(CComponent* p) { ASSERT(m_pPrimaryComponent == NULL); m_pPrimaryComponent = p; }

    SC                  ScGetCurrentColumnData( CColumnInfoList& columnInfoList, TStringVector& strColNames);
    SC                  ScShowColumn(int iColIndex, bool bShow);
    SC                  ScSetUpdatedColumnData( CColumnInfoList& oldColumnInfoList, CColumnInfoList& newColumnInfoList);
    SC                  ScGetSortColumn(int *piSortCol);
    SC                  ScSetSortColumn(int iSortCol, bool bAscending);
    SC                  ScGetViewExtensions(CViewExtInsertIterator it);

    HRESULT             ShowStandardListView();
    HRESULT             OnActvate(LONG_PTR lActivate);
    HRESULT             OnMinimize(LONG_PTR fMinimized);

    void                Reset();
    void                SetInitComponents(BOOL b)          { m_bInitComponents = b; }
    void                OnColumns();

    /***************************************************************************\
     *
     * CLASS:  CDataObjectCleanup
     *
     * PURPOSE: Groups methods to register/trigger data object clenup when
     *          CNode, which data is put to data object goes away
     *
     * USAGE:   Used from CMMCClipBoardDataObject to register nodes put to it
     *          And used from ~CNode to trigger the cleanup
     *
    \***************************************************************************/
    class CDataObjectCleanup
    {
    public:
        static SC ScRegisterNode(CNode *pNode, CMMCClipBoardDataObject *pObject);
        static SC ScUnadviseDataObject(CMMCClipBoardDataObject *pObject, bool bForceDataObjectCleanup = true);
        static SC ScUnadviseNode(CNode *pNode);

        // mapping CNode to data object which contains it's data
        typedef std::multimap<CNode *, CMMCClipBoardDataObject *> CMapOfNodes;

    private:
        static CMapOfNodes s_mapOfNodes;
    };

    // CViewSettingsPersistor's persistence interfaces.
    static SC ScQueryViewSettingsPersistor(IPersistStream **ppStream);
    static SC ScQueryViewSettingsPersistor(CXMLObject     **ppXMLObject);
    static SC ScOnDocumentClosing();
    static SC ScDeleteViewSettings(int nVieWID);
    static SC ScSetFavoriteViewSettings (int nViewID, const CBookmark& bookmark, const CViewSettings& viewSettings);

    SC   ScSetViewMode (ULONG ulViewMode);
    SC   ScSetTaskpadID(const GUID& guidTaskpad, bool bSetDirty);

// Implementation
private:
    HRESULT             DeepNotify (MMC_NOTIFY_TYPE event, LONG_PTR arg, LPARAM param);
    SC                  ScInitializeViewExtension(const CLSID& clsid, CViewData *pViewData);

    void                CommonConstruct();

    // Get & Set persisted ViewSettings data.
    SC   ScGetTaskpadID(GUID& guidTaskpad);
    SC   ScGetConsoleTaskpad (const GUID& guidTaskpad, CConsoleTaskpad **ppTaskpad);

    SC   ScGetViewMode (ULONG& ulViewMode);

    SC   ScGetResultViewType   (CResultViewType& rvt);
    SC   ScSetResultViewType   (const CResultViewType& rvt);

private:
    CMTNode* const      m_pMTNode;              // ptr back to the master node.
    HRESULTITEM         m_hri;                  // this node's result item handle
    CViewData*          m_pViewData;
    DWORD               m_dwFlags;

    enum
    {
        flag_expanded_at_least_once = 0x00000001,
        flag_expanded_visually      = 0x00000002,
    };

    CComponent*     m_pPrimaryComponent;
    bool            m_bInitComponents : 1;
    const bool      m_fRootNode       : 1;
    const bool      m_fStaticNode     : 1;

    static CComObject<CViewSettingsPersistor>* m_pViewSettingsPersistor;
};


//____________________________________________________________________________
//
//  class:      COCX
//
//  Purpose:    Store the IUnknown ptr of OCX wrapper and an identifier for
//              the OCX. The identifier may be CLSID of the OCX or
//              the IUnknown ptr of the OCX.
//
//              In essence a OCXWrapper can be saved using CLSID of OCX as
//              the key (IComponent::GetResultViewType) or IUnknown* of OCX
//              as the key (IComponent2::GetResultViewType2).
//
//              Therefore we have overloaded version of SetControl below.
//
//____________________________________________________________________________
//

class COCX
{
public:
// Constructor & Destructor
    COCX(void);
    ~COCX(void);

// Attributes
    void SetControl(CLSID& clsid, IUnknown* pUnknown);
    BOOL IsControlCLSID(CLSID clsid) { return IsEqualCLSID(clsid, m_clsid); }
    IUnknown* GetControlUnknown()    { return m_spOCXWrapperUnknown;}

    void SetControl(LPUNKNOWN pUnkOCX, LPUNKNOWN pUnkOCXWrapper);

    //
    // Compare the IUnknown given and the one stored.
    //
    bool IsSameOCXIUnknowns(IUnknown *pOtherOCXUnknown) { return m_spOCXUnknown.IsEqualObject(pOtherOCXUnknown);}

// Implementation
private:

    // Only one of CLSID or m_spOCXUnknown is valid, see class purpose for details.
    CLSID               m_clsid;
    CComPtr<IUnknown>   m_spOCXUnknown;

    CComPtr<IUnknown>   m_spOCXWrapperUnknown;

}; // COCX


//____________________________________________________________________________
//
//  class:      CSnapInNode
//____________________________________________________________________________
//

class CSnapInNode : public CNode
{
public:
// Constructor & Destructor
    CSnapInNode(CMTSnapInNode* pMTNode, CViewData* pViewData, bool fRootNode);
    CSnapInNode(const CSnapInNode& other);
    ~CSnapInNode();

// Attributes
    virtual UINT GetResultImage();
    virtual BOOL NeedsViewToBePersisted(void) { return TRUE; }

    virtual void SetControl(CLSID& clsid, IUnknown* pUnknown);
    virtual LPUNKNOWN GetControl(CLSID& clsid);
    void CloseControls() { GetOCXArray().RemoveAll(); }
    virtual void SetControl(LPUNKNOWN pUnkOCX, IUnknown* pUnknown);
    virtual LPUNKNOWN GetControl(LPUNKNOWN pUnkOCX);

    CComponentArray& GetComponentArray(void)  { return m_spData->GetComponentArray(); }


// Operations
    // User interactions
    BOOL Activate(LPUNKNOWN pUnkResultsPane);
    BOOL DeActivate(HNODE hNode);
    BOOL Show(HNODE hNode);
    void Reset();

    int GetNumberOfComponents()
    {
        return GetComponentArray().size();
    }

    void AddComponentToArray(CComponent* pCC);
    CComponent* CreateComponent(CSnapIn* pSnapIn, int nID);
    CComponent* GetComponent(const CLSID& clsid);
    virtual CComponent* GetComponent(COMPONENTID nID);
    void DeleteComponent(COMPONENTID nID)
    {
        ASSERT(nID >= 0);
        int iMax = GetComponentArray().size() -1;
        ASSERT(nID <= iMax);

        if (nID < iMax)
        {
            delete GetComponentArray()[nID];
            GetComponentArray()[nID] = GetComponentArray()[iMax];
            GetComponentArray()[iMax] = 0;
            GetComponentArray()[iMax]->ResetComponentID(nID);
        }
        GetComponentArray().resize(iMax);
    }

    void SetResultImageList (IImageListPrivate* pImageList) { m_spData->SetImageList(pImageList); }

// Implementation
private:
    class CDataImpl
    {
    public:
        CDataImpl() :
            m_pImageList(NULL)
        {}

        ~CDataImpl()
        {
            Reset();
        }

        void Reset()
        {
            for (int i=0; i < m_ComponentArray.size(); i++)
                delete m_ComponentArray[i];

            m_ComponentArray.clear();
        }

    private:
        IImageListPrivate* m_pImageList;    // result image list

        // Components array.
        CComponentArray         m_ComponentArray;
        CArray<COCX, COCX&>     m_rgOCX;

    public:
        void                    SetImageList(IImageListPrivate *pImageList)
                                                    {m_pImageList = pImageList;}
        IImageListPrivate *     GetImageList()     {return m_pImageList;}
        CComponentArray &       GetComponentArray(){return m_ComponentArray;}
        CArray<COCX, COCX&> &   GetOCXArray()      {return m_rgOCX;}

    };  // CSnapInNode::CDataImpl

    typedef CRefCountedObject<CDataImpl>    CData;
    CData::SmartPtr                         m_spData;

    IImageListPrivate *         GetImageList()     {return m_spData->GetImageList();}
    CArray<COCX, COCX&> &       GetOCXArray()      {return m_spData->GetOCXArray();}

}; // CSnapInNode


#include "node.inl"

#endif // _MMC_NODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\nodeinit.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       nodeinit.cpp
//
//--------------------------------------------------------------------------

// NodeInit.cpp : Implementation of CNodeMgrApp and DLL registration.

#include "stdafx.h"

#include "menuitem.h"           // MENUITEM_BASE_ID
#include "scopimag.h"
#include <bitmap.h>
#include "NodeMgr.h"
#include "amcmsgid.h"
#include "scopndcb.h"
#include "conframe.h"
#include "conview.h"
#include "constatbar.h"
#include "util.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

DEBUG_DECLARE_INSTANCE_COUNTER(CNodeInitObject);

IScopeTreePtr CNodeInitObject::m_spScopeTree = NULL;


/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CNodeInitObject::InterfaceSupportsErrorInfo(REFIID riid)
{
    if (riid == IID_IConsole)
        return S_OK;
    return S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// IFramePrivate implementation


CNodeInitObject::CNodeInitObject()
{
    Construct();
}

CNodeInitObject::~CNodeInitObject()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CNodeInitObject);
    TRACE_DESTRUCTOR (CNodeInitObject);
    Destruct();
}

void CNodeInitObject::Construct()
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CNodeInitObject);
    TRACE_CONSTRUCTOR (CNodeInitObject);

    m_pLVImage = NULL;
    m_pTVImage = NULL;
    m_pToolbar = NULL;
    m_pImageListPriv = NULL;
    m_componentID = -1;

    m_pMTNode = NULL;
    m_pNode = NULL;
    m_bExtension = FALSE;

    m_spComponent = NULL;
    m_spConsoleVerb = NULL;

    m_sortParams.bAscending = TRUE;
    m_sortParams.nCol = -1;
    m_sortParams.lpResultCompare = NULL;
    m_sortParams.lpResultCompareEx = NULL;
    m_sortParams.lpUserParam = NULL;

    // IContextMenuProvider attributes
    VERIFY(SUCCEEDED(EmptyMenuList()));
}

void CNodeInitObject::Destruct()
{
    // Release all interfaces from the snap-in
    SAFE_RELEASE(m_pLVImage);
    SAFE_RELEASE(m_pTVImage);
    SAFE_RELEASE(m_pToolbar);
    SAFE_RELEASE(m_pImageListPriv);

// IContextMenuProvider attributes
    VERIFY( SUCCEEDED(EmptyMenuList()) );
}


STDMETHODIMP CNodeInitObject::ResetSortParameters()
{
    m_sortParams.nCol = -1;
    return (S_OK);
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::SetHeader
//
//  Synopsis:    This method is obsolete in MMC1.2
//
//  Arguments:
//
//  Note:        Should be called by IComponent object.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::SetHeader(IHeaderCtrl* pHeader)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsole2::SetHeader"));

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::SetToolbar
//
//  Synopsis:    The toolbar interface used by IComponent.
//
//  Arguments:   [pToolbar]
//
//  Note:        Should be called by IComponent object.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::SetToolbar(IToolbar* pToolbar)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsole2::SetToolbar"));

    if (GetComponent() == NULL)
    {
        sc = E_UNEXPECTED;
        TraceSnapinError(_T("This method is valid for IConsole of IComponent"), sc);
        return sc.ToHr();
    }

    // Release the OLD one
    SAFE_RELEASE(m_pToolbar);

    if (pToolbar != NULL)
    {
        m_pToolbar = pToolbar;
        m_pToolbar->AddRef();
    }

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::QueryScopeImageList
//
//  Synopsis:    Get scope-pane's image list.
//
//  Arguments:
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::QueryScopeImageList(LPIMAGELIST* ppImageList)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsole2::QueryScopeImageList"));

    if (ppImageList == NULL)
    {
         sc = E_INVALIDARG;
         TraceSnapinError(_T("NULL LPIMAGELIST ptr"), sc);
         return sc.ToHr();
    }

    sc = ScCheckPointers(m_pImageListPriv, E_FAIL);
    if (sc)
        return sc.ToHr();

    *ppImageList = (IImageList*)m_pImageListPriv;
    m_pImageListPriv->AddRef();

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::CreateScopeImageList
//
//  Synopsis:    Create the ScopeImage list.
//
//  Arguments:
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::CreateScopeImageList(REFCLSID refClsidSnapIn)
{
    DECLARE_SC(sc, _T("CNodeInitObject::CreateScopeImageList"));

    if (m_pImageListPriv != NULL)
        return sc.ToHr();      // Already exists.

    try
    {
        CScopeTree* pScopeTree =
            dynamic_cast<CScopeTree*>((IScopeTree*)m_spScopeTree);

        sc = ScCheckPointers(pScopeTree, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        CSnapInImageList *psiil =
            new CSnapInImageList(pScopeTree->GetImageCache(),
                                 refClsidSnapIn);

        m_pImageListPriv = (LPIMAGELISTPRIVATE)psiil;
    }
    catch( std::bad_alloc )
    {
        sc = E_OUTOFMEMORY;
    }

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::QueryResultImageList
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::QueryResultImageList(LPIMAGELIST *ppImageList)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsole2::QueryResultImageList"));

    LPCONSOLE pConsole = (LPCONSOLE)this;
    sc = ScCheckPointers(pConsole, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = pConsole->QueryInterface(IID_IImageList, (void**)ppImageList);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::UpdateAllViews
//
//  Synopsis:    Update all the views.
//
//  Arguments:   [lpDataObject] -
//               [data]
//               [hint]
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::UpdateAllViews(LPDATAOBJECT lpDataObject,
                              LPARAM data, LONG_PTR hint)

{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsole2::UpdateAllViews"));

    COMPONENTID id;
    GetComponentID(&id);

    sc = ScCheckPointers(m_pMTNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    CMTSnapInNode* pMTSINode = m_pMTNode->GetStaticParent();

    sc = ScCheckPointers(pMTSINode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    CNodeList& nodes = pMTSINode->GetNodeList();
    POSITION pos = nodes.GetHeadPosition();

    while (pos)
    {
        CSnapInNode* pSINode = dynamic_cast<CSnapInNode*>(nodes.GetNext(pos));

        sc = ScCheckPointers(pSINode, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        CComponent* pCC = pSINode->GetComponent(id);

        sc = ScCheckPointers(pCC, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        pCC->Notify(lpDataObject, MMCN_VIEW_CHANGE, data, hint);
    }

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::InsertColumn
//
//  Synopsis:    Insert a column is ListView.
//
//  Arguments:   [nCol]      - Column index.
//               [lpszTitle] - Name of the column.
//               [nFormat]   - Column style.
//               [nWidth]    - Column width.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::InsertColumn(int nCol, LPCWSTR lpszTitle, int nFormat, int nWidth)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IHeaderCtrl2::InsertColumn"));

    if (nCol < 0)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Column index is negative"), sc);
        return sc.ToHr();
    }

    if (!lpszTitle || !*lpszTitle)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Column name is NULL"), sc);
        return sc.ToHr();
    }

    if (nCol == 0 && nFormat != LVCFMT_LEFT)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Column zero must be LVCFMT_LEFT"), sc);
        return sc.ToHr();
    }

    if (nFormat != LVCFMT_LEFT && nFormat != LVCFMT_CENTER && nFormat != LVCFMT_RIGHT)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Unknown format for the Column"), sc);
        return sc.ToHr();
    }

    // Cannot hide column 0.
    if ( (0 == nCol) && (HIDE_COLUMN == nWidth))
        nWidth = AUTO_WIDTH;

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // Insert the column into the listview
    sc = m_spListViewPrivate->InsertColumn(nCol, lpszTitle, nFormat, nWidth);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::DeleteColumn
//
//  Synopsis:    Delete a column
//
//  Arguments:   [nCol] - column index.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::DeleteColumn(int nCol)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IHeaderCtrl2::DeleteColumn"));

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_spListViewPrivate->DeleteColumn(nCol);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::SetColumnText
//
//  Synopsis:    Modify column text.
//
//  Arguments:   [title] - new name.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::SetColumnText(int nCol, LPCWSTR title)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IHeaderCtrl2::SetColumnText"));

     if (!title || !*title)
     {
         sc = E_INVALIDARG;
         TraceSnapinError(_T("NULL column text"), sc);
         return sc.ToHr();
     }

     sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
     if (sc)
         return sc.ToHr();

     sc = m_spListViewPrivate->SetColumn(nCol, title, MMCLV_NOPARAM, MMCLV_NOPARAM);

     return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::GetColumnText
//
//  Synopsis:    Get the name of a column.
//
//  Arguments:   [nCol]  - Index of Column whose name is sought.
//               [pText] - Name.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::GetColumnText(int nCol, LPWSTR* pText)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IHeaderCtrl2::GetColumnText"));

    if (pText == NULL)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL text ptr"), sc);
        return sc.ToHr();
    }

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_spListViewPrivate->GetColumn(nCol, pText, MMCLV_NOPTR, MMCLV_NOPTR);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::SetColumnWidth
//
//  Synopsis:    Change width of a column
//
//  Arguments:   [nCol]   - Column index.
//               [nWidth] - new width.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::SetColumnWidth(int nCol, int nWidth)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IHeaderCtrl2::SetColumnWidth"));

    if (nCol < 0)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Negative column index"), sc);
        return sc.ToHr();
    }

    // job on parameter checking nWidth
    if (nWidth < 0 && ( (nWidth != MMCLV_AUTO) && (nWidth != HIDE_COLUMN) ) )
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Invalid column width"), sc);
        return sc.ToHr();
    }

    // Cannot hide column 0.
    if ( (0 == nCol) && (HIDE_COLUMN == nWidth))
        nWidth = AUTO_WIDTH;

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_spListViewPrivate->SetColumn(nCol, MMCLV_NOPTR, MMCLV_NOPARAM, nWidth);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::GetColumnWidth
//
//  Synopsis:    Get width of a column.
//
//  Arguments:   [nCol]   - col index.
//               [pWidth] - width.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::GetColumnWidth(int nCol, int* pWidth)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IHeaderCtrl2::GetColumnWidth"));

    if (nCol < 0 )
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Negative column index"), sc);
        return sc.ToHr();
    }

    if (pWidth == NULL)
    {
        sc = E_POINTER;
        TraceSnapinError(_T("NULL width pointer"), sc);
        return sc.ToHr();
    }

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_spListViewPrivate->GetColumn(nCol, MMCLV_NOPTR, MMCLV_NOPTR, pWidth);

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::GetColumnCount
//
//  Synopsis:    Returns the number of columns in listview.
//
//  Arguments:   [pnCol] - [out param], number of cols.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::GetColumnCount (INT* pnCol)
{
    DECLARE_SC(sc, _T("CNodeInitObject::GetColumnCount"));
    sc = ScCheckPointers(pnCol);
    if (sc)
        return sc.ToHr();

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_spListViewPrivate->GetColumnCount(pnCol);
    if (sc)
        return sc.ToHr();

    return (sc.ToHr());
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::GetColumnInfoList
//
//  Synopsis:    Get the CColumnInfoList for current list-view headers.
//
//  Arguments:   [pColumnsList] - [out param], ptr to CColumnInfoList.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::GetColumnInfoList (CColumnInfoList *pColumnsList)
{
    DECLARE_SC(sc, _T("CNodeInitObject::GetColumnInfoList"));
    sc = ScCheckPointers(pColumnsList);
    if (sc)
        return sc.ToHr();

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_spListViewPrivate->GetColumnInfoList(pColumnsList);
    if (sc)
        return sc.ToHr();

    return (sc.ToHr());
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::ModifyColumns
//
//  Synopsis:    Modify the columns with given data.
//
//  Arguments:   [columnsList] -
//
//  Returns:     SC
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::ModifyColumns (const CColumnInfoList& columnsList)
{
    DECLARE_SC(sc, _T("CNodeInitObject::ModifyColumns"));
    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_spListViewPrivate->ModifyColumns(columnsList);
    if (sc)
        return sc.ToHr();

    return (sc.ToHr());
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::GetDefaultColumnInfoList
//
//  Synopsis:    Get the original column settings supplied by the snapin.
//
//  Arguments:   [columnsList] - [out] the column settings
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::GetDefaultColumnInfoList (CColumnInfoList& columnsList)
{
    DECLARE_SC(sc, _T("CNodeInitObject::RestoreDefaultColumnSettings"));
    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_spListViewPrivate->GetDefaultColumnInfoList(columnsList);
    if (sc)
        return sc.ToHr();

    return (sc.ToHr());
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::ImageListSetIcon
//
//  Synopsis:    Set an icon in imagelist.
//
//  Arguments:   [pIcon] - HICON ptr.
//               [nLoc]  - index of this item.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::ImageListSetIcon(PLONG_PTR pIcon, LONG nLoc)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IImageList::ImageListSetIcon"));

    if (!pIcon)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL pIcon ptr"), sc);
        return sc.ToHr();
    }

    if(nLoc < 0)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Negative index"), sc);
        return sc.ToHr();
    }

    COMPONENTID id;
    GetComponentID(&id);

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_spListViewPrivate->SetIcon(id, reinterpret_cast<HICON>(pIcon), nLoc);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::ImageListSetStrip
//
//  Synopsis:    Add strip of icons to image list.
//
//  Arguments:   [pBMapSm]   - Ptr to HBITMAP of 16x16.
//               [pBMapLg]   - Ptr to HBITMAP of 32x32.
//               [nStartLoc] - Start index.
//               [cMask]     - mask.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::ImageListSetStrip (
	PLONG_PTR	pBMapSm,
	PLONG_PTR	pBMapLg,
	LONG		nStartLoc,
	COLORREF	cMask)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IImageList::ImageListSetStrip"));

	HBITMAP hbmSmall = (HBITMAP) pBMapSm;
	HBITMAP hbmLarge = (HBITMAP) pBMapLg;

	/*
	 * valid start index?
	 */
    if (nStartLoc < 0)
    {
		sc = E_INVALIDARG;
        TraceSnapinError (_T("Negative start index"), sc);
        return (sc.ToHr());
    }

	/*
	 * valid bitmaps?
	 */
	sc = ScCheckPointers (hbmSmall, hbmLarge);
	if (sc)
	{
        TraceSnapinError (_T("Invalid bitmap"), sc);
		return (sc.ToHr());
	}

    BITMAP bmSmall;
    if (!GetObject (hbmSmall, sizeof(BITMAP), &bmSmall))
    {
		sc.FromLastError();
        TraceSnapinError (_T("Invalid Small bitmap object"), sc);
        return (sc.ToHr());
    }

    BITMAP bmLarge;
    if (!GetObject (hbmLarge, sizeof(BITMAP), &bmLarge))
    {
		sc.FromLastError();
        TraceSnapinError (_T("Invalid Large bitmap object"), sc);
        return (sc.ToHr());
    }

	/*
	 * are the small and large bitmaps of the integral dimensions,
	 * and do they have the same number of images?
	 */
    if ( (bmSmall.bmHeight != 16) || (bmLarge.bmHeight != 32) ||
		 (bmSmall.bmWidth   % 16) || (bmLarge.bmWidth   % 32) ||
		((bmSmall.bmWidth   / 16) != (bmLarge.bmWidth   / 32)))
    {
		sc = E_INVALIDARG;
        TraceSnapinError (_T("Invalid Bitmap size"), sc);
        return (sc.ToHr());
    }

    COMPONENTID id;
    GetComponentID(&id);

	/*
	 * m_spListViewPrivate == NULL is unexpected, however because we send
	 * MMCN_ADD_IMAGES when the result pane is an OCX (see CNode::OnSelect),
	 * this function often gets called when m_spListViewPrivate == NULL.
	 * Tracing this failure would be too noisy, since most OCX-based snap-ins
	 * would trigger it, so we'll return E_UNEXPECTED here without tracing.
	 * This is equivalent to MMC 1.2 behavior.
	 */
	if (m_spListViewPrivate == NULL)
		return (E_UNEXPECTED);

	/*
	 * add them to the imagelist
	 */
    sc = m_spListViewPrivate->SetImageStrip (id, hbmSmall, hbmLarge, nStartLoc, cMask);
    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::MapRsltImage
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::MapRsltImage(COMPONENTID id, int nSnapinIndex, int *pnConsoleIndex)
{
    DECLARE_SC(sc, _T("CNodeInitObject::MapRsltImage"));
    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // Ret val can be E_, no need to check.
    sc = m_spListViewPrivate->MapImage(id, nSnapinIndex, pnConsoleIndex);
    HRESULT hr = sc.ToHr();
    sc.Clear();

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::UnmapRsltImage
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::UnmapRsltImage(COMPONENTID id, int nConsoleIndex, int *pnSnapinIndex)
{
    DECLARE_SC(sc, _T("CNodeInitObject::UnmapRsltImage"));
    return (sc = E_NOTIMPL).ToHr();		// not needed now
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::SetChangeTimeOut
//
//  Synopsis:    Change timeout interval for filter attributes.
//
//  Arguments:   [uTimeout] - timeout
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::SetChangeTimeOut(unsigned long uTimeout)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IHeaderCtrl2::SetChangeTimeOut"));

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_spListViewPrivate->SetChangeTimeOut(uTimeout);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::SetColumnFilter
//
//  Synopsis:    Set filter for a column.
//
//  Arguments:   [nColumn]     - Column index.
//               [dwType]      - Filter type.
//               [pFilterData] - Filter data.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::SetColumnFilter(UINT nColumn, DWORD dwType, MMC_FILTERDATA* pFilterData)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IHeaderCtrl2::SetColumnFilter"));

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_spListViewPrivate->SetColumnFilter(nColumn, dwType, pFilterData);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::GetColumnFilter
//
//  Synopsis:    Get filter data.
//
//  Arguments:   [nColumn]     - Column index.
//               [pdwType]      - Filter type.
//               [pFilterData] - Filter data.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::GetColumnFilter(UINT nColumn, LPDWORD pdwType, MMC_FILTERDATA* pFilterData)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IHeaderCtrl2::GetColumnFilter"));

    if (pdwType == NULL)
    {
        sc = E_POINTER;
        TraceSnapinError(_T("NULL filtertype ptr"), sc);
        return sc.ToHr();
    }

    if (NULL == pFilterData)
    {
        sc = E_POINTER;
        TraceSnapinError(_T("NULL FilterData ptr"), sc);
        return sc.ToHr();
    }

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_spListViewPrivate->GetColumnFilter(nColumn, pdwType, pFilterData);

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::ShowTopic
//
//  Synopsis:    Display specified help topic.
//
//  Arguments:   [pszHelpTopic]
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::ShowTopic(LPOLESTR pszHelpTopic)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IDisplayHelp::ShowTopic"));

    // Get the AMCView window
    CConsoleView* pConsoleView = GetConsoleView();
    sc = ScCheckPointers(pConsoleView, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    USES_CONVERSION;
    sc = pConsoleView->ScShowSnapinHelpTopic (W2T (pszHelpTopic));

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::AddExtension
//
//  Synopsis:    Add a dynamic extension snapin to given HSCOPEITEM.
//
//  Arguments:   [hItem]   -
//               [lpclsid] - CLSID of snapin to be added.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::AddExtension(HSCOPEITEM hItem, LPCLSID lpclsid)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsoleNameSpace2::AddExtension"));

    COMPONENTID nID;
    GetComponentID(&nID);

    if (nID == -1)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    if (lpclsid == NULL)
    {
        sc = E_POINTER;
        TraceSnapinError(_T("NULL LPCLSID ptr"), sc);
        return sc.ToHr();
    }

    CMTNode *pMTNode = CMTNode::FromScopeItem (hItem);

    if (pMTNode == NULL)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Invalid hItem"), sc);
        return sc.ToHr();
    }

    // Can not add extensions to other components' nodes
    // Do we need to protect TV owned nodes that do not represent this snapin?
    if (pMTNode->GetOwnerID() != nID && pMTNode->GetOwnerID() != TVOWNED_MAGICWORD)
    {
        sc = E_INVALIDARG;
        return sc.ToHr();
    }

    sc = pMTNode->AddExtension(lpclsid);

    return sc.ToHr();
}


///////////////////////////////////////////////////////////////////////////////
// Private methods

HRESULT CNodeInitObject::CheckArgument(VARIANT* pArg)
{
    if (pArg == NULL)
        return E_POINTER;

    // VT_NULL is acceptable
    if (pArg->vt == VT_NULL)
        return S_OK;

    // VT_UNKNOWN with a valid pointer is acceptable
    if (pArg->punkVal != NULL)
    {
        if (pArg->vt == VT_UNKNOWN)
            return S_OK;
        else
            return E_INVALIDARG;
    }
    else
    {
        return E_POINTER;
    }

    // any other VT type is unacceptable
    return E_INVALIDARG;
}


///////////////////////////////////////////////////////////////////////////////
//
//
//
//

///////////////////////////////////////////////////////////////////////////////



STDMETHODIMP CNodeInitObject::QueryScopeTree(IScopeTree** ppScopeTree)
{
    MMC_TRY

    ASSERT(ppScopeTree != NULL);

    if (ppScopeTree == NULL)
        return E_POINTER;

    ASSERT(m_spScopeTree != NULL);
    if (m_spScopeTree == NULL)
        return E_UNEXPECTED;

    *ppScopeTree = m_spScopeTree;
    (*ppScopeTree)->AddRef();

    return S_OK;

    MMC_CATCH
}

STDMETHODIMP CNodeInitObject::SetScopeTree(IScopeTree* pScopeTree)
{
    MMC_TRY

    m_spScopeTree = pScopeTree;
    return S_OK;

    MMC_CATCH
}

HRESULT CNodeInitObject::GetSnapInAndNodeType(LPDATAOBJECT pDataObject,
                                    CSnapIn** ppSnapIn, GUID* pguidObjectType)
{
    ASSERT(pDataObject != NULL);
    ASSERT(ppSnapIn != NULL);
    ASSERT(pguidObjectType != NULL);


    CLSID clsidSnapin;
    HRESULT hr = ExtractSnapInCLSID(pDataObject, &clsidSnapin);
    if (FAILED(hr))
        return hr;

    CSnapIn* pSnapIn = NULL;
    SC sc = theApp.GetSnapInsCache()->ScGetSnapIn(clsidSnapin, &pSnapIn);
    if (sc)
        return sc.ToHr();
    // else
    ASSERT(pSnapIn != NULL);
    *ppSnapIn = pSnapIn;

    hr = ExtractObjectTypeGUID(pDataObject, pguidObjectType);

    return hr;
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::SelectScopeItem
//
//  Synopsis:    Select given scope-item.
//
//  Arguments:   [hScopeItem]
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::SelectScopeItem(HSCOPEITEM hScopeItem)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsole2::SelectScopeItem"));

    CViewData* pVD = (NULL == m_pNode ) ? NULL : m_pNode->GetViewData();

    try
    {
        CMTNode* pMTNode = CMTNode::FromScopeItem (hScopeItem);
        MTNODEID id = pMTNode->GetID();

        // If the currently selected node is same as the node being
        // asked to be selected, there is high probability that the
        // snapin is trying to change the view.
        // So set the viewchanging flag.
        CNode* pSelNode = (NULL == pVD) ? NULL : pVD->GetSelectedNode();
        CMTNode* pSelMTNode = (NULL == pSelNode) ? NULL : pSelNode->GetMTNode();

        if (pVD && pSelMTNode && (pSelMTNode == pMTNode) )
        {
            pVD->SetSnapinChangingView();
        }

        // Get the AMCView window
        CConsoleView* pConsoleView = GetConsoleView();

        sc = ScCheckPointers(pConsoleView, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        CConsoleView::ViewPane ePane = pConsoleView->GetFocusedPane ();
        SC sc = pConsoleView->ScSelectNode (id);

        if (sc)
            return sc.ToHr();

        // ePane == ePane_None means active view is unknown
        if (ePane != CConsoleView::ePane_None)
            pConsoleView->ScSetFocusToPane (ePane);

    }
    catch (...)
    {
        sc = E_INVALIDARG;
    }


    // Always reset the view changing flag.
    if (pVD)
    {
        pVD->ResetSnapinChangingView();
    }

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::QueryConsoleVerb
//
//  Synopsis:    Get the IConsoleVerb for setting standard verbs.
//
//  Arguments:   [ppConsoleVerb]
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::QueryConsoleVerb(LPCONSOLEVERB* ppConsoleVerb)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsole2::QueryConsoleVerb"));

    if (ppConsoleVerb == NULL)
    {
        sc = E_POINTER;
        TraceSnapinError(_T("NULL LPCONSOLEVERB ptr"), sc);
        return sc.ToHr();
    }

    if (m_pNode == NULL)
    {
        sc = E_FAIL;
        TraceSnapinError(_T("You can query console verb only from the IConsole associated with IComponents"), sc);
        return sc.ToHr();
    }

    if (m_spConsoleVerb == NULL)
    {
        // Create new CConsoleVerbImpl.
        CComObject<CConsoleVerbImpl>* pVerb;
        sc = CComObject<CConsoleVerbImpl>::CreateInstance(&pVerb);
        if (sc)
            return sc.ToHr();

        if (NULL == pVerb)
        {
            sc = E_OUTOFMEMORY;
            return sc.ToHr();
        }

        CViewData* pViewData = m_pNode->GetViewData();
        if (NULL == pViewData)
        {
            sc = E_UNEXPECTED;
            return sc.ToHr();
        }

        pVerb->SetVerbSet(m_pNode->GetViewData()->GetVerbSet());

        m_spConsoleVerb = pVerb;
        if (NULL == m_spConsoleVerb)
        {
            sc = E_NOINTERFACE;
            return sc.ToHr();
        }

    }

    *ppConsoleVerb = (IConsoleVerb*)m_spConsoleVerb;
    (*ppConsoleVerb)->AddRef();

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::NewWindow
//
//  Synopsis:    Create a new window from given node.
//
//  Arguments:   [hScopeItem] - Root of new window.
//               [lOptions]   - New window options.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::NewWindow(HSCOPEITEM hScopeItem, unsigned long lOptions)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsole2::NewWindow"));

    if (!hScopeItem)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL HSCOPEITEM"), sc);
        return sc.ToHr();
    }

    CConsoleFrame* pFrame = GetConsoleFrame();
    if (pFrame == NULL)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    CMTNode* pMTNode = CMTNode::FromScopeItem (hScopeItem);
    if (NULL == pMTNode)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    try
    {
        CreateNewViewStruct cnvs;
        cnvs.idRootNode     = pMTNode->GetID();
        cnvs.lWindowOptions = lOptions;
        cnvs.fVisible       = true;

        sc = pFrame->ScCreateNewView(&cnvs).ToHr();
    }
    catch (...)
    {
        sc = E_FAIL;
    }

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::Expand
//
//  Synopsis:    Visually expand or collapse an item.
//
//  Arguments:   [hScopeItem] - Item to be expanded/collapsed.
//               [bExpand]    - Expand/Collapse.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::Expand( HSCOPEITEM hScopeItem, BOOL bExpand)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsole2::Expand"));

    if (m_pNode == NULL || m_pNode->GetViewData() == NULL)
    {
        sc = E_FAIL;
        return sc.ToHr();
    }

    long id = 0;

    CMTNode* pMTNode = CMTNode::FromScopeItem (hScopeItem);
    if (pMTNode == NULL)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL HSCOPEITEM"), sc);
        return sc.ToHr();
    }

    id = pMTNode->GetID();

    {
        /*
         * tell this node's view to expand the node (use only this node's
         * view, don't default to the active view if we have no node)
         */
        CConsoleView* pConsoleView = GetConsoleView (false);
        if (pConsoleView == NULL)
        {
            sc = E_UNEXPECTED;
            return sc.ToHr();
        }

        sc = pConsoleView->ScExpandNode (id, bExpand, true);
    }

    return (sc.ToHr());
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::IsTaskpadViewPreferred
//
//  Synopsis:    Obsolete method.
//
//  Arguments:
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::IsTaskpadViewPreferred()
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsole2::IsTaskpadViewPreferred"));

    /*
     * taskpads always "preferred"
     */
    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::SetStatusText
//
//  Synopsis:    Change status bar text.
//
//  Arguments:   [pszStatusBarText]
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::SetStatusText (LPOLESTR pszStatusBarText)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsole2::SetStatusText"));

    if (m_pMTNode == NULL)
    {
        sc = E_FAIL;
        return sc.ToHr();
    }

    if (m_pNode == NULL)
    {
        sc = E_FAIL;
        return sc.ToHr();
    }

    CViewData* pViewData = m_pNode->GetViewData();
    if (NULL == pViewData)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    CNode* pSelectedNode = pViewData->GetSelectedNode();

    if (pSelectedNode == NULL)
    {
        sc = E_FAIL;
        return sc.ToHr();
    }

    CMTNode* pMTSelectedNode = pSelectedNode->GetMTNode();
    if (NULL == pMTSelectedNode)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    /*
     * fail if not from the selected node's branch of the scope tree
     */
    if (m_pMTNode->GetStaticParent() != pMTSelectedNode->GetStaticParent())
    {
        sc = E_FAIL;
        return sc.ToHr();
    }

    COMPONENTID nOwnerID = pSelectedNode->GetOwnerID();
    COMPONENTID nID;
    GetComponentID(&nID);

    /*
     * fail if not either the selected component or the static node
     */
    if (!((nOwnerID == nID) || ((nOwnerID == TVOWNED_MAGICWORD) && (nID == 0))))
    {
        sc = E_FAIL;
        return sc.ToHr();
    }

    CConsoleStatusBar* pStatusBar = pViewData->GetStatusBar();

    if (pStatusBar == NULL)
    {
        sc = E_FAIL;
        return sc.ToHr();
    }

    USES_CONVERSION;
    sc = pStatusBar->ScSetStatusText (W2CT (pszStatusBarText));

    return (sc.ToHr());
}

/*+-------------------------------------------------------------------------*
 *
 * CNodeInitObject::RenameScopeItem
 *
 * PURPOSE: Puts the specified scope item into rename mode.
 *
 * PARAMETERS:
 *    HSCOPEITEM  hScopeItem :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CNodeInitObject::RenameScopeItem(HSCOPEITEM hScopeItem)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, TEXT("IConsole3::RenameScopeItem"));

    CMTNode* pMTNode = CMTNode::FromScopeItem (hScopeItem);
    if (pMTNode == NULL)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL HSCOPEITEM"), sc);
        return sc.ToHr();
    }

    // get the console view object
    CConsoleView* pConsoleView = GetConsoleView (true); // default to the active view if m_pNode == NULL
    if (pConsoleView == NULL)
        return (sc = E_UNEXPECTED).ToHr();

    sc = pConsoleView->ScRenameScopeNode(CMTNode::ToHandle(pMTNode) /*convert to HMTNODE*/);

    return sc.ToHr();
}


/*+-------------------------------------------------------------------------*
 * CNodeInitObject::GetStatusBar
 *
 * Returns the status bar interface for the CNodeInitObject.
 *--------------------------------------------------------------------------*/

CConsoleStatusBar* CNodeInitObject::GetStatusBar(
    bool fDefaultToActive /* =true */) const
{
    CConsoleStatusBar* pStatusBar = NULL;

    /*
     * if we have a node, get the status bar from its view data
     */
    if (m_pNode != NULL)
    {
        ASSERT (m_pNode->GetViewData() != NULL);
        pStatusBar = m_pNode->GetViewData()->GetStatusBar();
    }

    /*
     * if we don't have a status bar yet, ask the main frame which one to use
     */
    if ((pStatusBar == NULL) && fDefaultToActive)
    {
        CConsoleFrame* pFrame = GetConsoleFrame();
        ASSERT (pFrame != NULL);

        if (pFrame != NULL)
            pFrame->ScGetActiveStatusBar(pStatusBar);
    }

    return (pStatusBar);
}


/*+-------------------------------------------------------------------------*
 * CNodeInitObject::GetConsoleView
 *
 * Returns the status bar interface for the CNodeInitObject.
 *--------------------------------------------------------------------------*/

CConsoleView* CNodeInitObject::GetConsoleView (
    bool fDefaultToActive /* =true */) const
{
    CConsoleView* pConsoleView = NULL;

    /*
     * if we have a node, get the console view from its view data
     */
    if (m_pNode != NULL)
    {
        ASSERT (m_pNode->GetViewData() != NULL);
        pConsoleView = m_pNode->GetViewData()->GetConsoleView();
    }

    /*
     * if we don't have a console view yet and we want to default to the
     * active view, ask the main frame which one to use
     */
    if ((pConsoleView == NULL) && fDefaultToActive)
    {
        CConsoleFrame* pFrame = GetConsoleFrame();
        ASSERT (pFrame != NULL);

        if (pFrame != NULL)
            pFrame->ScGetActiveConsoleView (pConsoleView);
    }

    return (pConsoleView);
}


/*+-------------------------------------------------------------------------*
 * CNodeInitObject::GetConsoleFrame
 *
 * Returns the CConsoleFrame interface for the console.
 *--------------------------------------------------------------------------*/

CConsoleFrame* CNodeInitObject::GetConsoleFrame() const
{
    CConsoleFrame*  pFrame = NULL;
    CScopeTree*     pTree  = dynamic_cast<CScopeTree*>(m_spScopeTree.GetInterfacePtr());
    ASSERT (pTree != NULL);

    if (pTree != NULL)
        pFrame = pTree->GetConsoleFrame();

    return (pFrame);
}


/*+-------------------------------------------------------------------------*
 * STRING_TABLE_FORWARDER_PROLOG
 *
 * Standard prolog code for IStringTable forwarder functions.
 *--------------------------------------------------------------------------*/

#define STRING_TABLE_FORWARDER_PROLOG(clsid, pSTP)              \
    CLSID clsid;                                                \
    VERIFY (SUCCEEDED (GetSnapinCLSID (clsid)));                \
                                                                \
    IStringTablePrivate* pSTP = CScopeTree::GetStringTable();   \
                                                                \
    if (pSTP == NULL)                                           \
        return (E_FAIL);                                        \
    else                                                        \
        (void) 0



//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::AddString
//
//  Synopsis:    Add a string to the string table.
//
//  Arguments:   [pszAdd] - string to add
//               [pID]    - ret, string id.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::AddString (
    LPCOLESTR       pszAdd,
    MMC_STRING_ID*  pID)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IStringTable::AddString"));

    STRING_TABLE_FORWARDER_PROLOG (clsid, pStringTablePrivate);
    sc = pStringTablePrivate->AddString (pszAdd, pID, &clsid);

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::GetString
//
//  Synopsis:    Get the string represented by given id.
//
//  Arguments:   [id]
//               [cchBuffer] - Size of buffer.
//               [lpBuffer]
//               [pchchOut]
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::GetString (
    MMC_STRING_ID   id,
    ULONG           cchBuffer,
    LPOLESTR        lpBuffer,
    ULONG*          pcchOut)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IStringTable::GetString"));

    STRING_TABLE_FORWARDER_PROLOG (clsid, pStringTablePrivate);
    sc = pStringTablePrivate->GetString (id, cchBuffer, lpBuffer, pcchOut, &clsid);

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::GetStringLength
//
//  Synopsis:    Get the length of string represented by given string id.
//
//  Arguments:   [id] - string id.
//               [pcchString] - ret ptr to len.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::GetStringLength (
    MMC_STRING_ID   id,
    ULONG*          pcchString)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IStringTable::GetStringLength"));

    STRING_TABLE_FORWARDER_PROLOG (clsid, pStringTablePrivate);
    sc = pStringTablePrivate->GetStringLength (id, pcchString, &clsid);

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::DeleteString
//
//  Synopsis:    Delete the string represented by given string id.
//
//  Arguments:   [id]
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::DeleteString (
    MMC_STRING_ID   id)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IStringTable::DeleteString"));

    STRING_TABLE_FORWARDER_PROLOG (clsid, pStringTablePrivate);
    sc = pStringTablePrivate->DeleteString (id, &clsid);

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::DeleteAllStrings
//
//  Synopsis:    Delete all strings (for this snapin).
//
//  Arguments:
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::DeleteAllStrings ()
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IStringTable::DeleteAllStrings"));

    STRING_TABLE_FORWARDER_PROLOG (clsid, pStringTablePrivate);
    sc = pStringTablePrivate->DeleteAllStrings (&clsid);

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::FindString
//
//  Synopsis:    Find if given string exists, if so ret its string-id.
//
//  Arguments:   [pszFind] - string to find.
//               [pID]     - string id (retval).
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::FindString (
    LPCOLESTR       pszFind,
    MMC_STRING_ID*  pID)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IStringTable::FindString"));

    STRING_TABLE_FORWARDER_PROLOG (clsid, pStringTablePrivate);
    sc = pStringTablePrivate->FindString (pszFind, pID, &clsid);

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::Enumerate
//
//  Synopsis:    Get an enumerator to (this snapins) string table.
//
//  Arguments:   [ppEnum]
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::Enumerate (
    IEnumString**   ppEnum)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IStringTable::Enumerate"));

    STRING_TABLE_FORWARDER_PROLOG (clsid, pStringTablePrivate);
    sc = pStringTablePrivate->Enumerate (ppEnum, &clsid);

    return sc.ToHr();
}


/*+-------------------------------------------------------------------------*
 * CNodeInitObject::GetSnapinCLSID
 *
 *
 *--------------------------------------------------------------------------*/

HRESULT CNodeInitObject::GetSnapinCLSID (CLSID& clsid) const
{
    SC sc; // We do not want to break if this function returns failure
           // so we do not use DECLARE_SC.

    ASSERT (!IsBadWritePtr (&clsid, sizeof (CLSID)));

    if (NULL == m_pMTNode)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    CSnapIn* pSnapin = m_pMTNode->GetPrimarySnapIn();

    if (NULL == pSnapin)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    clsid = pSnapin->GetSnapInCLSID();

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CNodeInitObject::ReleaseCachedOleObjects
 *
 * PURPOSE: Releases cached OLE objects. Calls are made from CONUI
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
HRESULT CNodeInitObject::ReleaseCachedOleObjects()
{
    DECLARE_SC(sc, TEXT("CNodeInitObject::GetSnapinCLSID"));

    sc = COleCacheCleanupManager::ScReleaseCachedOleObjects();
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\nodeinit.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       nodeinit.h
//
//--------------------------------------------------------------------------

// NodeInit.h : Declaration of the CNodeInitObject

#ifndef _NODEINIT_H_
#define _NODEINIT_H_

class CMenuItem;
class SnapinStruct;
class CCommandSink;
class CImageIndexMap;
class CMTNode;
class CNode;
class CSnapIn;
class CConsoleFrame;
class CConsoleView;
class CConsoleStatusBar;
class CContextMenu;
class CMenuItem;

interface IExtendContextMenu;

typedef CList<CMenuItem*, CMenuItem*> MenuItemList;
typedef CList<SnapinStruct*, SnapinStruct*> SnapinStructList;

typedef long MENU_OWNER_ID;

/////////////////////////////////////////////////////////////////////////////
// NodeMgr

#include <pshpack8.h>

class CNodeInitObject :
    public IFramePrivate,
    public IHeaderCtrlPrivate,
    public IContextMenuProvider,
    public IResultDataPrivate,
    public IScopeDataPrivate,
    public IImageListPrivate,
    public ISupportErrorInfo,
    public IDisplayHelp,
    public IStringTable,
    public CPropertySheetProvider,
    public CColumnData,
    public CComObjectRoot,
    public CComCoClass<CNodeInitObject, &CLSID_NodeInit>
{
// Constructor/Destructor
public:
    CNodeInitObject();
    ~CNodeInitObject();

    friend CColumnData;

BEGIN_COM_MAP(CNodeInitObject)
    COM_INTERFACE_ENTRY(IFramePrivate)
    COM_INTERFACE_ENTRY(IConsole)
    COM_INTERFACE_ENTRY(IConsole2)
    COM_INTERFACE_ENTRY(IConsole3)
    COM_INTERFACE_ENTRY(IHeaderCtrl)
    COM_INTERFACE_ENTRY(IHeaderCtrl2)
    COM_INTERFACE_ENTRY(IHeaderCtrlPrivate)
    COM_INTERFACE_ENTRY(IContextMenuProvider)
//  THis interface used to be exposed on this class, and removing it may
//  expose compatibility problems [vivekj]
//  COM_INTERFACE_ENTRY(IContextMenuCallback)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IResultData)
    COM_INTERFACE_ENTRY(IResultData2)
    COM_INTERFACE_ENTRY(IResultDataPrivate)
    COM_INTERFACE_ENTRY(IConsoleNameSpace)
    COM_INTERFACE_ENTRY(IConsoleNameSpace2)
    COM_INTERFACE_ENTRY(IScopeDataPrivate)
    COM_INTERFACE_ENTRY(IImageList)
    COM_INTERFACE_ENTRY(IImageListPrivate)
    COM_INTERFACE_ENTRY(IPropertySheetProviderPrivate)
    COM_INTERFACE_ENTRY(IPropertySheetProvider)
    COM_INTERFACE_ENTRY(IPropertySheetCallback)
    COM_INTERFACE_ENTRY(IPropertySheetNotify)
    COM_INTERFACE_ENTRY(IDisplayHelp)
    COM_INTERFACE_ENTRY(IStringTable)
    COM_INTERFACE_ENTRY_FUNC(IID_IColumnData, 0, ColumnInterfaceFunc)
END_COM_MAP()
// Use DECLARE_NOT_AGGREGATABLE(CNodeInitObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(CNodeInitObject)

DECLARE_MMC_OBJECT_REGISTRATION (
    g_szMmcndmgrDll,                    // implementing DLL
    CLSID_NodeInit,                     // CLSID
    _T("NodeInit 1.0 Object"),          // class name
    _T("NODEMGR.NodeInitObject.1"),     // ProgID
    _T("NODEMGR.NodeInitObject"))       // version-independent ProgID

IMPLEMENTS_SNAPIN_NAME_FOR_DEBUG()

public:
// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

public:
#ifdef DBG
    int dbg_cRef;
    ULONG InternalAddRef()
    {
        ++dbg_cRef;
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        --dbg_cRef;
        return CComObjectRoot::InternalRelease();
    }
    int dbg_InstID;
#endif // DBG

// IFramePrivate
public:
    STDMETHOD(CreateScopeImageList)(REFCLSID refClsidSnapIn);
    STDMETHOD(SetResultView)(LPUNKNOWN pUnknown);
    STDMETHOD(IsResultViewSet)(BOOL* pbIsLVSet);
    STDMETHOD(SetTaskPadList)(LPUNKNOWN pUnknown);
    STDMETHOD(GetComponentID)(COMPONENTID* lpComponentID);
    STDMETHOD(SetComponentID)(COMPONENTID id);
    STDMETHOD(SetNode)(HMTNODE hMTNode, HNODE hNode = NULL);
    STDMETHOD(QueryScopeTree)(IScopeTree** ppScopeTree);
    STDMETHOD(SetScopeTree)(IScopeTree* pScopeTree);
    STDMETHOD(SetComponent)(LPCOMPONENT lpComponent);
    STDMETHOD(SetUsedByExtension)(BOOL bExtension);
    STDMETHOD(IsUsedByExtension)(void);
    STDMETHOD(GetMainWindow)(HWND* phwnd);

    HWND GetMainWindow()
    {
        ASSERT(m_spScopeTree != NULL);
		if (m_spScopeTree == NULL)
			return NULL;

        CScopeTree* const pst = dynamic_cast<CScopeTree*>(&*m_spScopeTree);
        ASSERT(pst != NULL);
        return (pst != NULL && m_spScopeTree != NULL) ?
            pst->GetMainWindow() : NULL;
    }

    CMTNode* GetMTNode() { return m_pMTNode;}

    STDMETHOD(InitViewData)(LONG_PTR lViewData);
    STDMETHOD(CleanupViewData)(LONG_PTR lViewData);
    STDMETHOD(ResetSortParameters)();

    STDMETHOD(ReleaseCachedOleObjects)();

// IConsole2
public:
    STDMETHOD(Expand)(HSCOPEITEM hItem, BOOL bExpand);
    STDMETHOD(IsTaskpadViewPreferred)();
    STDMETHOD(SetStatusText)(LPOLESTR pszStatusText);

// IConsole3
public:
    STDMETHOD(RenameScopeItem)(HSCOPEITEM hScopeItem);

protected:
    static IScopeTreePtr    m_spScopeTree;
    IConsoleVerbPtr         m_spConsoleVerb;
    CMTNode*                m_pMTNode;
    CNode*                  m_pNode;
    BOOL                    m_bExtension;

// IFrame
public:
    STDMETHOD(QueryResultView)(LPUNKNOWN* ppIUnknown);
    STDMETHOD(SetHeader)(IHeaderCtrl* pHeader);
    STDMETHOD(SetToolbar)(IToolbar* pToolbar);
    STDMETHOD(QueryScopeImageList)(LPIMAGELIST *ppImageList);
    STDMETHOD(QueryResultImageList)(LPIMAGELIST *ppImageList);
    STDMETHOD(MessageBox)(LPCWSTR lpszText, LPCWSTR lpszTitle, UINT fuStyle, int* piRetval);
    STDMETHOD(UpdateAllViews)(LPDATAOBJECT lpDataObject, LPARAM data, LONG_PTR hint);
    STDMETHOD(QueryConsoleVerb)(LPCONSOLEVERB* ppConsoleVerb);
    STDMETHOD(SelectScopeItem)(HSCOPEITEM hScopeItem);
    STDMETHOD(NewWindow)(HSCOPEITEM hScopeItem, unsigned long lOptions);

// IFrames members
protected:
    LPUNKNOWN           m_pLVImage;
    LPUNKNOWN           m_pTVImage;
    LPUNKNOWN           m_pToolbar;
    LPIMAGELISTPRIVATE  m_pImageListPriv;
    COMPONENTID         m_componentID;
    IComponentPtr       m_spComponent;

    IUnknownPtr         m_spResultViewUnk;      // IUnknown for the result view

public:
    CConsoleFrame*     GetConsoleFrame() const;
    CConsoleView*      GetConsoleView(bool fDefaultToActive = true) const;
    CConsoleStatusBar* GetStatusBar  (bool fDefaultToActive = true) const;

///////////////////////////////////////////////////////////////////////////////
// IHeaderCtrl interface

protected:
    STDMETHOD(InsertColumn)(int nCol, LPCWSTR lpszTitle, int nFormat, int nWidth);
    STDMETHOD(DeleteColumn)(int nCol);
    STDMETHOD(SetColumnWidth)(int nCol, int nWidth);
    STDMETHOD(GetColumnText)(int nCol, LPWSTR* pText);
    STDMETHOD(SetColumnText)(int nCol, LPCWSTR title);
    STDMETHOD(GetColumnWidth)(int nCol, int* pWidth);

// IHeaderCtrl2 interface
    STDMETHOD(SetChangeTimeOut)(unsigned long uTimeout);
    STDMETHOD(SetColumnFilter)(UINT nColumn, DWORD dwType, MMC_FILTERDATA* pFilterData);
    STDMETHOD(GetColumnFilter)(UINT nColumn, LPDWORD pType, MMC_FILTERDATA* pFilterData);

// IHeaderCtrlPrivate interface.
    STDMETHOD(GetColumnCount)(INT* pnCol);
    STDMETHOD(GetColumnInfoList)(/*[out]*/ CColumnInfoList *pColumnsList);
    STDMETHOD(ModifyColumns)(/*[in]*/ const CColumnInfoList& columnsList);
    STDMETHOD(GetDefaultColumnInfoList)(/*[out]*/ CColumnInfoList& columnsList);

private:
    CCLVSortParams          m_sortParams;


///////////////////////////////////////////////////////////////////////////////
// IDisplayHelp interface

protected:
    STDMETHOD(ShowTopic)(LPOLESTR pszHelpTopic);


///////////////////////////////////////////////////////////////////////////////
// IStringTable interface

protected:
    STDMETHOD(AddString)        (LPCOLESTR pszAdd, MMC_STRING_ID* pID);
    STDMETHOD(GetString)        (MMC_STRING_ID id, ULONG cchBuffer, LPOLESTR lpBuffer, ULONG* pcchOut);
    STDMETHOD(GetStringLength)  (MMC_STRING_ID id, ULONG* pcchString);
    STDMETHOD(DeleteString)     (MMC_STRING_ID id);
    STDMETHOD(DeleteAllStrings) ();
    STDMETHOD(FindString)       (LPCOLESTR pszFind, MMC_STRING_ID* pID);
    STDMETHOD(Enumerate)        (IEnumString** ppEnum);

    HRESULT GetSnapinCLSID (CLSID& pclsid) const;

///////////////////////////////////////////////////////////////////////////////
// IResultDataPrivate interface

protected:
    IMMCListViewPtr m_spListViewPrivate;

    STDMETHOD(Arrange)(long style);
    STDMETHOD(InsertItem)(LPRESULTDATAITEM item);
    STDMETHOD(DeleteItem)(HRESULTITEM itemID, int nCol);
    STDMETHOD(FindItemByLParam)(LPARAM lParam, HRESULTITEM *pItemID);
    STDMETHOD(DeleteAllRsltItems)();
    STDMETHOD(SetItem)(LPRESULTDATAITEM item);
    STDMETHOD(GetItem)(LPRESULTDATAITEM item);
    STDMETHOD(ModifyItemState)(int nIndex, HRESULTITEM ItemID, UINT uAdd, UINT uRemove);
    STDMETHOD(ModifyViewStyle)(MMC_RESULT_VIEW_STYLE add, MMC_RESULT_VIEW_STYLE remove);
    STDMETHOD(GetNextItem)(LPRESULTDATAITEM item);
    STDMETHOD(SetViewMode)(LONG nViewMode);
    STDMETHOD(GetViewMode)(LONG* nViewMode);
    STDMETHOD(ResetResultData)();
    STDMETHOD(GetListStyle)(long * pStyle);
    STDMETHOD(SetListStyle)(long Style);
    STDMETHOD(UpdateItem)(HRESULTITEM itemID);
    STDMETHOD(Sort)(int nCol, DWORD dwSortOptions, LPARAM lUserParam);
    STDMETHOD(InternalSort)(INT nCol, DWORD dwSortOptions, LPARAM lUserParam, BOOL bColumnClicked);
    STDMETHOD(SetDescBarText)(LPOLESTR DescText);
    STDMETHOD(SetItemCount)(int nItemCount, DWORD dwOptions);
    STDMETHOD(SetLoadMode)(BOOL bState);
    STDMETHOD(GetSortColumn)(INT* pnCol);
    STDMETHOD(GetSortDirection)(BOOL* pbAscending);

    // IResultData2
    STDMETHOD(RenameResultItem)(HRESULTITEM itemID);

///////////////////////////////////////////////////////////////////////////////
// IScopeData interface

protected:
// IConsoleNameSpace methods
    STDMETHOD(InsertItem)(LPSCOPEDATAITEM item);
    STDMETHOD(DeleteItem)(HSCOPEITEM hItem, long fDeleteThis);
    STDMETHOD(SetItem)(LPSCOPEDATAITEM  item);
    STDMETHOD(GetItem)(LPSCOPEDATAITEM  item);
    STDMETHOD(GetChildItem)(HSCOPEITEM item, HSCOPEITEM* pItemChild,
                            MMC_COOKIE* pCookie);
    STDMETHOD(GetNextItem)(HSCOPEITEM item, HSCOPEITEM* pItemNext,
                            MMC_COOKIE* pCookie);
    STDMETHOD(GetParentItem)(HSCOPEITEM item, HSCOPEITEM* pItemParent,
                            MMC_COOKIE* pCookie);

// IConsoleNameSpace2 method(s)
    STDMETHOD(Expand)(HSCOPEITEM hItem);
    STDMETHOD(AddExtension)(HSCOPEITEM hItem, LPCLSID lpclsid);

private:

    enum EGetItem
    {
        egiParent = 1,
        egiChild = 2,
        egiNext = 3
    };

    HRESULT GetRelativeItem(EGetItem egi, HSCOPEITEM item, HSCOPEITEM* pItem,
                            MMC_COOKIE* pCookie);


///////////////////////////////////////////////////////////////////////////////
// IContextMenuCallback interface

public:
    STDMETHOD(AddItem) ( CONTEXTMENUITEM* pItem );

///////////////////////////////////////////////////////////////////////////////
// IContextMenuProvider interface

public:
    STDMETHOD(EmptyMenuList) ();
    STDMETHOD(AddThirdPartyExtensionItems) (
                                IDataObject* piDataObject );
    STDMETHOD(AddPrimaryExtensionItems) (
                                IUnknown*    piCallback,
                                IDataObject* piDataObject );
    STDMETHOD(ShowContextMenu) (HWND    hwndParent,
                                LONG    xPos,
                                LONG    yPos,
                                LONG*   plSelected);

private:
    ContextMenuPtr              m_spContextMenu;
    CContextMenu *              GetContextMenu();

///////////////////////////////////////////////////////////////////////////////
// IImageListPrivate interface
public:
    STDMETHOD(ImageListSetIcon)(PLONG_PTR pIcon, LONG nLoc);
    STDMETHOD(ImageListSetStrip)(PLONG_PTR pBMapSm, PLONG_PTR pBMapLg,
                                 LONG nStartLoc, COLORREF cMask);

    STDMETHOD(MapRsltImage)(COMPONENTID id, int nSnapinIndex, int *pnConsoleIndex);
    STDMETHOD(UnmapRsltImage)(COMPONENTID id, int nConsoleIndex, int *pnSnapinIndex);

///////////////////////////////////////////////////////////////////////////////
// IToobar interface

///////////////////////////////////////////////////////////////////////////////
// Node Manager internal members
private:
    void Construct();
    void Destruct();

    HRESULT CheckArgument(VARIANT* pArg);

    SC      ScIsVirtualList(bool& bVirtual);
public:
    HRESULT static GetSnapInAndNodeType(LPDATAOBJECT pDataObject,
                                 CSnapIn** ppSnapIn, GUID* pguidObjectType);

    IComponent* GetComponent() { return m_spComponent;}
};

#include <poppack.h>

inline STDMETHODIMP CNodeInitObject::GetComponentID(COMPONENTID* lpComponentID)
{
    MMC_TRY

    ASSERT(m_componentID != -1); // The component ID has not been set yet!!!
    ASSERT(lpComponentID);

    *lpComponentID = m_componentID;

    return S_OK;

    MMC_CATCH
}

inline STDMETHODIMP CNodeInitObject::SetComponentID(COMPONENTID id)
{
    MMC_TRY

/* for dynamic icon, we need to change this value temporarily
    if (m_componentID != -1)
    {
        ASSERT(FALSE);  // ID already has been set!!!
        return E_UNEXPECTED;
    }

    ASSERT(id != -1);
*/
    m_componentID = id;
    return S_OK;

    MMC_CATCH
}

inline STDMETHODIMP CNodeInitObject::SetNode(HMTNODE hMTNode, HNODE hNode)
{
    MMC_TRY

    m_pMTNode = CMTNode::FromHandle(hMTNode);
    m_pNode   = CNode::FromHandle(hNode);
    return S_OK;

    MMC_CATCH
}

inline STDMETHODIMP CNodeInitObject::SetComponent(LPCOMPONENT lpComponent)
{
    MMC_TRY

    if (lpComponent == NULL)
    {
        ASSERT(FALSE);
        return E_INVALIDARG;
    }

    m_spComponent = lpComponent;

    return S_OK;

    MMC_CATCH
}

inline STDMETHODIMP CNodeInitObject::SetUsedByExtension(BOOL bExtension)
{
    MMC_TRY

    m_bExtension = bExtension;
    return S_OK;

    MMC_CATCH
}

inline STDMETHODIMP CNodeInitObject::IsUsedByExtension(void)
{
    MMC_TRY

    return m_bExtension ? S_OK : S_FALSE;

    MMC_CATCH
}

inline SC  CNodeInitObject::ScIsVirtualList(bool& bVirtual)
{
    DECLARE_SC(sc, TEXT("CNodeInitObject::ScIsVirtualList"));
    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc;

    long lStyle = m_spListViewPrivate->GetListStyle();

    bVirtual = (lStyle & LVS_OWNERDATA);

    return sc;
}


inline STDMETHODIMP CNodeInitObject::GetMainWindow(HWND* phwnd)
{
    MMC_TRY

    if (phwnd == NULL)
        return E_POINTER;
    *phwnd = GetMainWindow();
    ASSERT(*phwnd != NULL);
    return (*phwnd != NULL) ? S_OK : E_UNEXPECTED;

    MMC_CATCH
}

// Used for getting snapin name for debug info.

inline void Debug_SetNodeInitSnapinName(CSnapInPtr pSnapIn, IFramePrivate* pIFrame)
{
#ifdef DBG
    CNodeInitObject* pNodeInitObj = dynamic_cast<CNodeInitObject*>(pIFrame);

    if ((pSnapIn != NULL) && (pNodeInitObj != NULL))
    {
        WTL::CString strSnapInName;
        SC sc = pSnapIn->ScGetSnapInName(strSnapInName);
        if (sc)
            return;

        if (!strSnapInName.IsEmpty())
        {
            pNodeInitObj->SetSnapinName(strSnapInName);
            CColumnData* pColumnData = dynamic_cast<CColumnData*>(pNodeInitObj);
            if (pColumnData)
                pColumnData->SetSnapinName(strSnapInName);
        }
    };
#endif
}


#endif // _NODEINIT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\nodemgr.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       nodemgr.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    1/27/1997   RaviR   Created
//____________________________________________________________________________
//



#ifndef MMC_NODEMGR_H_
#define MMC_NODEMGR_H_

class CSnapInsCache;

class CNodeMgrApp : public COleCacheCleanupObserver
{
public:
    CNodeMgrApp() : m_pSnapInsCache(NULL), m_bProcessingSnapinChanges(FALSE)
    {
        // register to be notified when everything cached needs to be released.
        COleCacheCleanupManager::AddOleObserver(this);
    }

    ~CNodeMgrApp()
    {
    }
    
    virtual SC ScOnReleaseCachedOleObjects();

    virtual void Init();
    virtual void DeInit();

    CSnapInsCache* GetSnapInsCache(void) 
    { 
        return m_pSnapInsCache; 
    }

    void SetSnapInsCache(CSnapInsCache* pSIC);

    void SetProcessingSnapinChanges(BOOL bProcessing)
    {
        m_bProcessingSnapinChanges = bProcessing;
    }

    BOOL ProcessingSnapinChanges()
    {
        return m_bProcessingSnapinChanges;
    }

private:
    CSnapInsCache* m_pSnapInsCache;
    BOOL m_bProcessingSnapinChanges;

}; // CNodeMgrApp


EXTERN_C CNodeMgrApp theApp;

#endif // MMC_NODEMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\nodemgr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       nodemgr.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"

#ifdef BUILD_FOR_1381
#if defined(_UNICODE)
    inline LPOLESTR CharNextO(LPCOLESTR lp) {return CharNextW(lp);}
#elif defined(OLE2ANSI)
    inline LPOLESTR CharNextO(LPCOLESTR lp) {return CharNext(lp);}
#else
    //CharNextW doesn't work on Win95 so we use this
    inline LPOLESTR CharNextO(LPCOLESTR lp) {return (LPOLESTR)(lp+1);}
#endif
#endif

#include "atlimpl.cpp"
#include "atlwin.cpp"
#include "atlctl.cpp"

#include "initguid.h"
#include "doccnfg.h"
#include "NodeMgr.h"
#include "msgview.h"
#include "fldrsnap.h"
#include "tasksymbol.h"
#include "power.h"
#include "viewext.h"
#include "IconControl.h"
#include "mmcprotocol.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define IID_DEFINED

/*
 * define our own Win64 symbol to make it easy to include 64-bit only
 * code in the 32-bit build, so we can exercise some code on 32-bit Windows
 * where the debuggers are better
 */
#ifdef _WIN64
#define MMC_WIN64
#endif


DECLARE_INFOLEVEL(AMCNodeMgr)

CComModule _Module;



//############################################################################
//############################################################################
//
//  The nodemgr proxy exports to support  IMMCClipboardDataObject interface marshalling.
//
//############################################################################
//############################################################################
extern "C" BOOL WINAPI NDMGRProxyDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/);
STDAPI NDMGRProxyDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI NDMGRProxyDllCanUnloadNow(void);
STDAPI NDMGRProxyDllRegisterServer(void);
STDAPI NDMGRProxyDllUnregisterServer(void);

//############################################################################
//############################################################################
//
//  Implementation of class CMMCVersionInfo
//
//############################################################################
//############################################################################

class CMMCVersionInfo:
    public IMMCVersionInfo,
    public CComObjectRoot,
    public CComCoClass<CMMCVersionInfo, &CLSID_MMCVersionInfo>
{
    typedef CMMCVersionInfo ThisClass;
public:
    BEGIN_COM_MAP(ThisClass)
        COM_INTERFACE_ENTRY(IMMCVersionInfo)
    END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(ThisClass)

    DECLARE_MMC_OBJECT_REGISTRATION (
		g_szMmcndmgrDll,					// implementing DLL
        CLSID_MMCVersionInfo,           	// CLSID
        _T("MMCVersionInfo 1.0 Object"),    // class name
        _T("NODEMGR.MMCVersionInfo.1"),     // ProgID
        _T("NODEMGR.MMCVersionInfo"))       // version-independent ProgID

    STDMETHOD(GetMMCVersion)(long *pVersionMajor, long *pVersionMinor)
    {
        DECLARE_SC(sc, TEXT("CMMCVersionInfo::GetMMCVersion"));

        sc = ScCheckPointers(pVersionMajor, pVersionMinor);
        if(sc)
            return sc.ToHr();

        *pVersionMajor = MMC_VERSION_MAJOR;
        *pVersionMinor = MMC_VERSION_MINOR;

        return sc.ToHr();
    }
};
/****************************************************************************/
// forward declarations
class CMMCEventConnector;

/***************************************************************************\
 *
 * CLASS:  CEventForwarder
 *
 * PURPOSE: Helper class. It is used to plug into AppEvents as an event sink
 *          to forward received events to CMMCEventConnector class.
 *          It implements IDispatch interface by:
 *              - Having own implementation of QueryInterface
 *              - Forwarding AddRef and Release to CMMCEventConnector's
 *                WeakAddRef and WeakRelease
 *              - Forwarding Invoke to CMMCEventConnector's ScInvokeOnSinks
 *              - using CMMCEventConnector to imlement the rest of IDispatch
 * USAGE:   Used as member object in CMMCEventConnector;
 *
\***************************************************************************/
class CEventForwarder : public IDispatch
{
public:
    CEventForwarder(CMMCEventConnector& connector) : m_Connector(connector)
    {
        static CMMCTypeInfoHolderWrapper wrapper(GetInfoHolder());
    }

    // IUnknown implementation
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject);

    // IDispatch implementation
    STDMETHOD(GetTypeInfoCount)( unsigned int FAR*  pctinfo );
    STDMETHOD(GetTypeInfo)( unsigned int  iTInfo, LCID  lcid, ITypeInfo FAR* FAR*  ppTInfo );
    STDMETHOD(GetIDsOfNames)( REFIID  riid, OLECHAR FAR* FAR*  rgszNames, unsigned int  cNames,
                              LCID   lcid, DISPID FAR*  rgDispId );
    STDMETHOD(Invoke)( DISPID  dispIdMember, REFIID  riid, LCID  lcid, WORD  wFlags,
                       DISPPARAMS FAR*  pDispParams, VARIANT FAR*  pVarResult,
                       EXCEPINFO FAR*  pExcepInfo, unsigned int FAR*  puArgErr );
private:
    CMMCEventConnector& m_Connector;
    static CComTypeInfoHolder m_TypeInfo;
public:
    // the porpose of this static function is to ensure m_TypeInfo is a static variable,
    // since static wrapper will hold on its address - it must be always valid
    static CComTypeInfoHolder& GetInfoHolder() { return m_TypeInfo; }
};

/***************************************************************************\
 *
 * CLASS:  CMMCEventConnector
 *
 * PURPOSE: Implementation of coclass AppEventsDHTMLConnector
 *          Objects of this class are used as event source for application events,
 *          in cases when it's easyier to have cocreatible object to connect to
 *          these events and MMC application is already created (DHTML scripts)
 *          Class does not generate event's itself, it plugs into Allpication
 *          as an event sink for AppEvents dispinterface and keeps forwarding the events
 *
\***************************************************************************/
class CMMCEventConnector :
    public CMMCIDispatchImpl<_EventConnector, &CLSID_AppEventsDHTMLConnector>,
    public CComCoClass<CMMCEventConnector, &CLSID_AppEventsDHTMLConnector>,
    // support for connection points (script events)
    public IConnectionPointContainerImpl<CMMCEventConnector>,
    public IConnectionPointImpl<CMMCEventConnector, &DIID_AppEvents, CComDynamicUnkArray>,
    public INodeManagerProvideClassInfoImpl<&CLSID_AppEventsDHTMLConnector, &DIID_AppEvents, &LIBID_MMC20>,
    public IObjectSafetyImpl<CMMCEventConnector, INTERFACESAFE_FOR_UNTRUSTED_CALLER>
    {
public:
    BEGIN_MMC_COM_MAP(CMMCEventConnector)
        COM_INTERFACE_ENTRY(IProvideClassInfo)
        COM_INTERFACE_ENTRY(IProvideClassInfo2)
        COM_INTERFACE_ENTRY(IConnectionPointContainer)
        COM_INTERFACE_ENTRY(IObjectSafety)
    END_MMC_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(CMMCEventConnector)

    DECLARE_MMC_OBJECT_REGISTRATION (
		g_szMmcndmgrDll,						// implementing DLL
        CLSID_AppEventsDHTMLConnector,   		// CLSID
        _T("AppEventsDHTMLConnector 1.0 Object"),	// class name
        _T("NODEMGR.AppEventsDHTMLConnector.1"),	// ProgID
        _T("NODEMGR.AppEventsDHTMLConnector"))		// version-independent ProgID

    BEGIN_CONNECTION_POINT_MAP(CMMCEventConnector)
        CONNECTION_POINT_ENTRY(DIID_AppEvents)
    END_CONNECTION_POINT_MAP()

private:

public:
    CMMCEventConnector();
    ~CMMCEventConnector();

    ULONG InternalRelease(); // overriding the one from CComObjectRoot
    ULONG WeakAddRef();
    ULONG WeakRelease();

    STDMETHOD(ConnectTo)(PAPPLICATION Application);
    STDMETHOD(Disconnect)();

    // invokes same event w/ same params on all connected sinks
    ::SC ScInvokeOnSinks(   DISPID  dispIdMember, REFIID  riid, LCID  lcid, WORD  wFlags,
                            DISPPARAMS FAR*  pDispParams, VARIANT FAR*  pVarResult,
                            EXCEPINFO FAR*  pExcepInfo, unsigned int FAR*  puArgErr );

private:
    CEventForwarder         m_Forwarder;
    DWORD                   m_dwWeakRefs;
    DWORD                   m_dwCookie;
    IConnectionPointPtr     m_spConnectionPoint;
};

//############################################################################
//############################################################################
//
//  COM Object map
//
//############################################################################
//############################################################################

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_MMCVersionInfo,  CMMCVersionInfo)
    OBJECT_ENTRY(CLSID_TaskSymbol,      CTaskSymbol)
    OBJECT_ENTRY(CLSID_NodeInit,        CNodeInitObject)
    OBJECT_ENTRY(CLSID_ScopeTree,       CScopeTree)
    OBJECT_ENTRY(CLSID_MMCDocConfig,    CMMCDocConfig)
    OBJECT_ENTRY(CLSID_MessageView,     CMessageView)
    OBJECT_ENTRY(CLSID_FolderSnapin,    CFolderSnapin)
    OBJECT_ENTRY(CLSID_HTMLSnapin,      CHTMLSnapin)
    OBJECT_ENTRY(CLSID_OCXSnapin,       COCXSnapin)
    OBJECT_ENTRY(CLSID_ConsolePower,    CConsolePower)
    OBJECT_ENTRY(CLSID_AppEventsDHTMLConnector,  CMMCEventConnector)
    OBJECT_ENTRY(CLSID_ViewExtSnapin,   CViewExtensionSnapin)
    OBJECT_ENTRY(CLSID_IconControl,     CIconControl)
    OBJECT_ENTRY(CLSID_ComCacheCleanup, CMMCComCacheCleanup)
    OBJECT_ENTRY(CLSID_MMCProtocol,     CMMCProtocol)
END_OBJECT_MAP()

CNodeMgrApp theApp;



void CNodeMgrApp::Init()
{
    DECLARE_SC(sc, TEXT("CNodeMgrApp::Init"));

    /* register the mmc:// protocol */
    /* the protocol is required for taskpads and pagebreaks */
    sc = CMMCProtocol::ScRegisterProtocol();
    if(sc)
        sc.TraceAndClear();
}

void CNodeMgrApp::DeInit()
{
    SetSnapInsCache(NULL);
}

/***************************************************************************\
 *
 * METHOD:  CNodeMgrApp::ScOnReleaseCachedOleObjects
 *
 * PURPOSE: Called prior to ole de-initialization to release any cached ole objects
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CNodeMgrApp::ScOnReleaseCachedOleObjects()
{
    DECLARE_SC(sc, TEXT("CNodeMgrApp::ScOnReleaseCachedOleObjects"));

    // release snapin cache - thats all the class have cached...
    SetSnapInsCache(NULL);

    return sc;
}

void CNodeMgrApp::SetSnapInsCache(CSnapInsCache* pSIC)
{
    if (m_pSnapInsCache != NULL)
        delete m_pSnapInsCache;

    m_pSnapInsCache = pSIC;
}



/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        // NATHAN FIX !!w
        //_set_new_handler( _standard_new_handler );
        _Module.Init(ObjectMap, hInstance);
        theApp.Init();
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        theApp.DeInit();
        _Module.Term();
    }

    NDMGRProxyDllMain(hInstance, dwReason, NULL);

    return TRUE;    // ok
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    if (_Module.GetLockCount()!=0)
        return S_FALSE;

    return NDMGRProxyDllCanUnloadNow();
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    if (IsEqualIID(IID_IMMCClipboardDataObject, rclsid))
        return NDMGRProxyDllGetClassObject(rclsid, riid, ppv);

    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry


// Use own routine to register typelib because we don't want
// a full pathname, just a module name
static HRESULT RegisterTypeLib()
{
    USES_CONVERSION;

    TCHAR szModule[_MAX_PATH+10] = { 0 };

    GetModuleFileName(_Module.GetModuleInstance(), szModule, _MAX_PATH);

    ITypeLib* pTypeLib;
    LPOLESTR lpszModule = T2OLE(szModule);
    HRESULT hr = LoadTypeLib(lpszModule, &pTypeLib);
    ASSERT(SUCCEEDED(hr));

    if (SUCCEEDED(hr))
    {
        hr = ::RegisterTypeLib(pTypeLib, const_cast<LPWSTR>(T2CW (g_szMmcndmgrDll)), NULL);
        ASSERT(SUCCEEDED(hr));
    }

    if (pTypeLib != NULL)
        pTypeLib->Release();

    return hr;
}

STDAPI DllRegisterServer(void)
{
	DECLARE_SC (sc, _T("DllRegisterServer"));

    // registers objects
    sc =  _Module.RegisterServer(FALSE);
	if (sc)
	{
		sc.Trace_();
		return ((sc = SELFREG_E_CLASS).ToHr());
	}

	CRegKeyEx regkeySoftware;
	CRegKeyEx regkeyMMC;
	CRegKeyEx regkeySnapIns;
	CRegKeyEx regkeyNodeTypes;

	if ((sc = regkeySoftware. ScOpen   (HKEY_LOCAL_MACHINE, _T("Software\\Microsoft"))).IsError() ||
		(sc = regkeyMMC.      ScCreate (regkeySoftware,		_T("MMC"))).			    IsError() ||
		(sc = regkeySnapIns.  ScCreate (regkeyMMC,			_T("SnapIns"))).		    IsError() ||
		(sc = regkeyNodeTypes.ScCreate (regkeyMMC,			_T("NodeTypes"))).          IsError())
	{
		sc.Trace_();
		return ((sc = SELFREG_E_CLASS).ToHr());
	}

    sc = ::RegisterTypeLib();
	if (sc)
	{
		sc.Trace_();
		return ((sc = SELFREG_E_TYPELIB).ToHr());
	}

    sc = NDMGRProxyDllRegisterServer();
    if (sc)
        return sc.ToHr();

    /*
     * register mmc.exe to complete the process
     * note: mmc.exe is never unregistered
     */


	// fix to windows bug #233372. ntbug09, 11/28/00
	// [ mmc.exe launched from current directory, not from where it is supposed to be]

	// get the path of node manager dll
	TCHAR szPath[_MAX_PATH];
	DWORD dwPathLen = ::GetModuleFileName(_Module.GetModuleInstance(), szPath, countof(szPath) );
	szPath[countof(szPath) -1] = 0;

	// if node manager path is found - put same directory to mmc path
	tstring strMMCPath;
	if ( dwPathLen > 0 )
	{
		tstring strNodeMgr = szPath;
		int iLastSlashPos = strNodeMgr.rfind('\\');
		if (iLastSlashPos != tstring::npos)
			strMMCPath = strNodeMgr.substr(0, iLastSlashPos + 1);
	}
	else
	{
		sc = E_UNEXPECTED;
		sc.TraceAndClear(); // ignore and continue without a path
	}

	strMMCPath += _T("mmc.exe");

#if defined(MMC_WIN64)
	LPCTSTR szRegParams = _T("-64 -RegServer");
#else
	LPCTSTR szRegParams = _T("-32 -RegServer");
#endif

    HINSTANCE hInst = ShellExecute (NULL, NULL, strMMCPath.c_str(), szRegParams,
                                    NULL, SW_SHOWNORMAL);
    if ((DWORD_PTR) hInst <= 32)
    {
        switch ((DWORD_PTR) hInst)
        {
            case 0:
                sc = E_OUTOFMEMORY;
                break;

            case ERROR_FILE_NOT_FOUND:
            case ERROR_PATH_NOT_FOUND:
            case ERROR_BAD_FORMAT:
                sc.FromWin32 ((DWORD_PTR) hInst);
                break;

            default:
                sc = E_FAIL;
                break;
        }

        return (sc.ToHr());
    }

	return (sc.ToHr());
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Adds entries to the system registry

STDAPI DllUnregisterServer(void)
{
    HRESULT hRes = S_OK;
    _Module.UnregisterServer();

    NDMGRProxyDllUnregisterServer();

    return hRes;
}

/***************************************************************************\
 *
 * STATIC OBJECT:  CEventForwarder::m_TypeInfo
 *
 * PURPOSE: manages ITypeInfo used by CEventForwarder
 *
\***************************************************************************/
CComTypeInfoHolder CEventForwarder::m_TypeInfo =
{ &DIID_AppEvents, &LIBID_MMC20, 1, 0, NULL, 0, NULL, 0 };

/***************************************************************************\
 *
 * METHOD:  CEventForwarder::AddRef
 *
 * PURPOSE: Implements IUnknown::AddRef
 *          This class is always contained within m_Connector, so it
 *          relies on outer object to count the references.
 *          To differentiate between regular references and those occuring
 *          beacuse of connecting to the sink, it calls WeakAddRef,
 *          not the regular AddRef on connector
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    ULONG    - reference count
 *
\***************************************************************************/
STDMETHODIMP_(ULONG) CEventForwarder::AddRef()
{
    return m_Connector.WeakAddRef();
}

/***************************************************************************\
 *
 * METHOD:  CEventForwarder::Release
 *
 * PURPOSE: Implements IUnknown::Release
 *          This class is always contained within m_Connector, so it
 *          relies on outer object to count the references.
 *          To differentiate between regular references and those occuring
 *          beacuse of connecting to the sink, it calls WeakRelease,
 *          not the regular Release on connector
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    ULONG    - reference count
 *
\***************************************************************************/
STDMETHODIMP_(ULONG) CEventForwarder::Release()
{
    return m_Connector.WeakRelease();
}


/***************************************************************************\
 *
 * METHOD:  CEventForwarder::QueryInterface
 *
 * PURPOSE: Implements IUnknown::QueryInterface
 *          returns self, when requested for IUnknow, IDispatch, AppEvents
 *
 * PARAMETERS:
 *    REFIID iid
 *    void ** ppvObject
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
STDMETHODIMP CEventForwarder::QueryInterface(REFIID iid, void ** ppvObject)
{
    DECLARE_SC(sc, TEXT(""));

    // parameter check
    sc = ScCheckPointers(ppvObject);
    if (sc)
        return sc.ToHr();

    // initialization
    *ppvObject = NULL;

    // check IID
    if (IsEqualGUID(iid, IID_IUnknown)
     || IsEqualGUID(iid, IID_IDispatch)
     || IsEqualGUID(iid, DIID_AppEvents))
    {
        *ppvObject = this;
        AddRef();
        return sc.ToHr();
    }

    // not an error - do not assign to sc
    return E_NOINTERFACE;
}

/***************************************************************************\
 *
 * METHOD:  CEventForwarder::GetTypeInfoCount
 *
 * PURPOSE: implements method on IDispatch
 *
 * PARAMETERS:
 *    unsigned int FAR*  pctinfo
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
STDMETHODIMP CEventForwarder::GetTypeInfoCount( unsigned int FAR*  pctinfo )
{
    if (pctinfo == NULL) return E_INVALIDARG;
    *pctinfo = 1;
    return S_OK;
}

/***************************************************************************\
 *
 * METHOD:  CEventForwarder::GetTypeInfo
 *
 * PURPOSE: implements method on IDispatch
 *
 * PARAMETERS:
 *    unsigned int  iTInfo
 *    LCID  lcid
 *    ITypeInfo FAR* FAR*  ppTInfo
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
STDMETHODIMP CEventForwarder::GetTypeInfo( unsigned int  iTInfo, LCID  lcid, ITypeInfo FAR* FAR*  ppTInfo )
{
    return m_TypeInfo.GetTypeInfo( iTInfo, lcid, ppTInfo );
}


/***************************************************************************\
 *
 * METHOD:  CEventForwarder::GetIDsOfNames
 *
 * PURPOSE:implements method on IDispatch
 *
 * PARAMETERS:
 *    riid
 *    rgszNames
 *    cNames
 *    lcid
 *    rgDispId
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
STDMETHODIMP CEventForwarder::GetIDsOfNames( REFIID  riid, OLECHAR FAR* FAR*  rgszNames, unsigned int  cNames,
                                             LCID   lcid, DISPID FAR*  rgDispId )
{
    return m_TypeInfo.GetIDsOfNames( riid, rgszNames, cNames, lcid, rgDispId );
}


/***************************************************************************\
 *
 * METHOD:  CEventForwarder::Invoke
 *
 * PURPOSE: implements method on IDispatch. Forwards calls to connector.
 *          In order to distinguish between calls made on itself, connector
 *          must provide method, which has different name : ScInvokeOnSinks
 *
 * PARAMETERS:
 *    DISPID  dispIdMember
 *    REFIID  riid
 *    LCID  lcid
 *    WORD  wFlags
 *    DISPPARAMS FAR*  pDispParams
 *    VARIANT FAR*  pVarResult
 *    EXCEPINFO FAR*  pExcepInfo
 *    unsigned int FAR*  puArgErr
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
STDMETHODIMP CEventForwarder::Invoke( DISPID  dispIdMember, REFIID  riid, LCID  lcid, WORD  wFlags,
                                      DISPPARAMS FAR*  pDispParams, VARIANT FAR*  pVarResult,
                                      EXCEPINFO FAR*  pExcepInfo, unsigned int FAR*  puArgErr )
{
    DECLARE_SC(sc, TEXT("CEventForwarder::Invoke"));

    sc = m_Connector.ScInvokeOnSinks( dispIdMember, riid, lcid, wFlags, pDispParams,
                                      pVarResult, pExcepInfo, puArgErr );
    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CMMCEventConnector::CMMCEventConnector
 *
 * PURPOSE: constructor
 *
\***************************************************************************/
CMMCEventConnector::CMMCEventConnector() :
m_Forwarder(*this),
m_dwCookie(0),
m_dwWeakRefs(0)
{
}

/***************************************************************************\
 *
 * METHOD:  CMMCEventConnector::~CMMCEventConnector
 *
 * PURPOSE: Destructor
 *
\***************************************************************************/
CMMCEventConnector::~CMMCEventConnector()
{
    Disconnect(); // most likely not needed. Just for sanity
}

/***************************************************************************\
 *
 * METHOD:  CMMCEventConnector::InternalRelease
 *
 * PURPOSE: Overrides method from CComObjectRoot to detect when last "real"
 *          reference is released. Refs made because of connecting to the
 *          sink does not count - we would have a deadlock else
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    ULONG   - ref count
 *
\***************************************************************************/
ULONG CMMCEventConnector::InternalRelease()
{
    ULONG uRefsLeft = CComObjectRoot::InternalRelease();

    if ((uRefsLeft != 0) && (uRefsLeft == m_dwWeakRefs))
    {
        // seems like we are alive just because we still connected to the connection point
        // disconnect ( no-one uses it anyway )
        InternalAddRef(); // Addref to have balance
        Disconnect();     // disconnect from the connection point
        uRefsLeft = CComObjectRoot::InternalRelease(); // release again
    }

    return uRefsLeft;
}

/***************************************************************************\
 *
 * METHOD:  CMMCEventConnector::WeakAddRef
 *
 * PURPOSE: counts reference from connection points. AddRefs regularly as well
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    ULONG   - ref count
 *
\***************************************************************************/
ULONG CMMCEventConnector::WeakAddRef()
{
    ++m_dwWeakRefs;
    return AddRef();
}

/***************************************************************************\
 *
 * METHOD:  CMMCEventConnector::WeakRelease
 *
 * PURPOSE: counts reference from connection points. Releases regularly as well
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    ULONG   - ref count
 *
\***************************************************************************/
ULONG CMMCEventConnector::WeakRelease()
{
    --m_dwWeakRefs;
    return Release();
}

/***************************************************************************\
 *
 * METHOD:  CMMCEventConnector::ScInvokeOnSinks
 *
 * PURPOSE: This method has a signature of IDispath::Invoke and is
 *          called from connection point to inform about the event
 *          Method's job is to fork the call to each own connected sink
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCEventConnector::ScInvokeOnSinks( DISPID  dispIdMember, REFIID  riid, LCID  lcid, WORD  wFlags,
                                        DISPPARAMS FAR*  pDispParams, VARIANT FAR*  pVarResult,
                                        EXCEPINFO FAR*  pExcepInfo, unsigned int FAR*  puArgErr )
{
    DECLARE_SC(sc, TEXT("CMMCEventConnector::ScInvokeOnSinks"));

    // find connection point
    IConnectionPointPtr spConnectionPoint;
    sc = FindConnectionPoint(DIID_AppEvents, &spConnectionPoint);
    if (sc)
        return sc;

    // get connections
    IEnumConnectionsPtr spEnumConnections;
    sc = spConnectionPoint->EnumConnections(&spEnumConnections);
    if (sc)
        return sc.ToHr();

    // recheck the pointer
    sc = ScCheckPointers(spEnumConnections, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // reset iterator
    sc = spEnumConnections->Reset();
    if (sc)
        return sc.ToHr();

    // iterate thru sinks until Next returns S_FALSE.
    CONNECTDATA connectdata;
    SC sc_last_error;
    while (1) // will use <break> to exit
    {
        // get the next sink
        ZeroMemory(&connectdata, sizeof(connectdata));
        sc = spEnumConnections->Next( 1, &connectdata, NULL );
        if (sc)
            return sc.ToHr();

        // done if no more sinks
        if (sc == SC(S_FALSE))
            break;

        // recheck the pointer
        sc = ScCheckPointers(connectdata.pUnk, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        // QI for IDispatch
        IDispatchPtr spDispatch = (IDispatch *)connectdata.pUnk;
        connectdata.pUnk->Release();

        // recheck the pointer
        sc = ScCheckPointers(spDispatch, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        // invoke on the sink
        sc = spDispatch->Invoke( dispIdMember, riid, lcid, wFlags, pDispParams,
                            pVarResult, pExcepInfo, puArgErr );
        if (sc)
        {
            sc_last_error = sc; // continue even if some calls failed
            sc.TraceAndClear();
        }
    }

    return sc_last_error.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CMMCEventConnector::ConnectTo
 *
 * PURPOSE: Connects to Application object and starts forwarding its events
 *
 * PARAMETERS:
 *    PAPPLICATION Application
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
STDMETHODIMP CMMCEventConnector::ConnectTo(PAPPLICATION Application)
{
    DECLARE_SC(sc, TEXT("ConnectTo"));

    // disconnect from former connections
    sc = Disconnect();
    if (sc)
        return sc.ToHr();

    // check if com object supports IConnectionPointContainer;
    IConnectionPointContainerPtr spContainer = Application;
    sc = ScCheckPointers(spContainer);
    if (sc)
        return sc.ToHr();

    // get connection point
    sc = spContainer->FindConnectionPoint(DIID_AppEvents, &m_spConnectionPoint);
    if (sc)
        return sc.ToHr();

    sc = m_spConnectionPoint->Advise(&m_Forwarder, &m_dwCookie);
    if (sc)
        return sc.ToHr();

    return S_OK;
}

/***************************************************************************\
 *
 * METHOD:  CMMCEventConnector::Disconnect
 *
 * PURPOSE: Disconnects from connection point if is connected to one
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
STDMETHODIMP CMMCEventConnector::Disconnect()
{
    DECLARE_SC(sc, TEXT("CMMCEventConnector::Disconnect"));

    if (m_dwCookie)
    {
        if (m_spConnectionPoint != NULL)
        {
            sc = m_spConnectionPoint->Unadvise(m_dwCookie);
            if (sc)
                sc.TraceAndClear();
        }
        m_dwCookie = 0;
        m_spConnectionPoint = NULL;
    }

    return sc.ToHr();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\nodemgrdebug.h ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       nodemgrdebug.h
//
//  Contents:   Debugging helpers for MMC & Snapins.
//
//  History:    10-May-2000 AnandhaG     Created
//
//--------------------------------------------------------------------
#pragma once

/*+-------------------------------------------------------------------------*
 *
 * TraceSnapinException
 *
 * PURPOSE:     When a snapin throws an exception and is caught by MMC this
 *              function traces that exception.
 *
 * PARAMETERS:
 *    CLSID& clsidSnapin     - Class id of the offending snapin, used to get name.
 *    LPCTSTR szFunctionName - the method in snapin called by mmc.
 *    int event              - MMC_NOTIFY_EVENT
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
inline void TraceSnapinException(const CLSID& clsidSnapin, LPCTSTR szFunctionName, int event)
{
#ifdef DBG
    SC sc = E_FAIL;
    sc.SetFunctionName(szFunctionName);

    tstring strSnapinName = TEXT("Unknown");
    GetSnapinNameFromCLSID(clsidSnapin, strSnapinName);

    sc.SetSnapinName(strSnapinName.data());

	WTL::CString strErrorMessage;
    strErrorMessage.Format(TEXT("threw an exception during the notify event : 0x%x\n"), event);

    TraceSnapinError(strErrorMessage, sc);
	sc.Clear();   // dont want sc to trace again.
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\objfmts.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       objfmts.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "objfmts.h"



//____________________________________________________________________________
//
//  Members:     IEnumFORMATETC methods
//____________________________________________________________________________

STDMETHODIMP
CObjFormats::Next(
    ULONG celt,
    FORMATETC *rgelt,
    ULONG *pceltFethed)
{
    UINT    cfetch = 0;
    HRESULT hr = S_FALSE; // assume less numbers

    if (m_iFmt < m_cFmt)
    {
        cfetch = m_cFmt - m_iFmt;

        if (cfetch >= celt)
        {
            cfetch = celt;
            hr = S_OK;
        }

        CopyMemory(rgelt, &m_aFmt[m_iFmt], cfetch * sizeof(FORMATETC));
        m_iFmt += cfetch;
    }

    if (pceltFethed)
    {
        *pceltFethed = cfetch;
    }

    return hr;
}


STDMETHODIMP
CObjFormats::Skip(
    ULONG celt)
{
    m_iFmt += celt;

    if (m_iFmt > m_cFmt)
    {
        m_iFmt = m_cFmt;
        return S_FALSE;
    }

    return S_OK;
}

STDMETHODIMP
CObjFormats::Reset()
{
    m_iFmt = 0;
    return S_OK;
}

STDMETHODIMP
CObjFormats::Clone(
    IEnumFORMATETC ** ppenum)
{
    return E_NOTIMPL;
}

//____________________________________________________________________________
//
//  Function:     Function to obtain the IEnumFORMATETC interface.
//____________________________________________________________________________

HRESULT
GetObjFormats(
    UINT        cfmt,
    FORMATETC * afmt,
    LPVOID    * ppvObj)
{
    ASSERT(ppvObj != NULL);
    ASSERT(afmt != NULL);

    FORMATETC * pFmt = new FORMATETC[cfmt];

    if (pFmt == NULL)
        return E_OUTOFMEMORY;

    CopyMemory(pFmt, afmt, cfmt * sizeof(FORMATETC));

    CComObject<CObjFormats>* pObjFormats;
    CComObject<CObjFormats>::CreateInstance(&pObjFormats);

    if (pObjFormats == NULL)
    {
        delete [] pFmt;
        return E_OUTOFMEMORY;
    }
    
    pObjFormats->Init(cfmt, pFmt);

    return pObjFormats->QueryInterface(IID_IEnumFORMATETC, 
                                       reinterpret_cast<void**>(ppvObj));
}



//////////....................................................//////////////
//////////....................................................//////////////
//////////....................................................//////////////
//////////....................................................//////////////
//////////....................................................//////////////
//////////....................................................//////////////
//////////....................................................//////////////
//////////....................................................//////////////



//____________________________________________________________________________
//
//  Members:     CObjFormatsEx::IEnumFORMATETC methods
//____________________________________________________________________________

STDMETHODIMP
CObjFormatsEx::Next(
    ULONG celt,
    FORMATETC *rgelt,
    ULONG *pceltFethed)
{
    if (m_iCur == 1)
        return m_rgspEnums[1]->Next(celt, rgelt, pceltFethed);

    ULONG celtFethed1 = 0;
    HRESULT hr = m_rgspEnums[0]->Next(celt, rgelt, &celtFethed1);
    if (hr == S_OK)
        return S_OK;

    ULONG celt2 = celt - celtFethed1;
    ULONG celtFethed2 = 0;
    
    m_iCur = 1;
    hr = m_rgspEnums[1]->Next(celt2, &rgelt[celtFethed1], &celtFethed2);
    if (pceltFethed)
        *pceltFethed = celtFethed1 + celtFethed2;
    return hr;
}


STDMETHODIMP
CObjFormatsEx::Skip(
    ULONG celt)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CObjFormatsEx::Reset()
{
    m_iCur = 0;
    m_rgspEnums[0]->Reset();
    m_rgspEnums[1]->Reset();
    return S_OK;
}

STDMETHODIMP
CObjFormatsEx::Clone(
    IEnumFORMATETC ** ppenum)
{
    return E_NOTIMPL;
}



HRESULT 
GetObjFormatsEx(
    IEnumFORMATETC* pEnum1, 
    IEnumFORMATETC* pEnum2,
    IEnumFORMATETC** ppEnumOut)
{
    ASSERT(pEnum1 != NULL);
    ASSERT(pEnum2 != NULL);
    ASSERT(ppEnumOut != NULL);
    if (!pEnum1 || !pEnum2 || !ppEnumOut)
        return E_INVALIDARG;


    CComObject<CObjFormatsEx>* pObj;
    CComObject<CObjFormatsEx>::CreateInstance(&pObj);

    if (pObj == NULL)
        return E_OUTOFMEMORY;
    
    pObj->Init(pEnum1, pEnum2);

    return pObj->QueryInterface(IID_IEnumFORMATETC, 
                                reinterpret_cast<void**>(ppEnumOut));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\nodepath.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      nodepath.h
 *
 *  Contents:  Dynamic node path generation helpers
 *
 *  History:   31-Mar-98 JeffRo     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef NODEPATH_H
#define NODEPATH_H

// Forward declarations
class CMTNode;
class CBookmark;
class CDynamicPathEntryEx;

/*+-------------------------------------------------------------------------*
 *class CBookmarkEx
 *
 *PURPOSE: Provides added functionality to the CBookmark class with methods
 *         for locating CMTNodes and CNodes.
 *
 *
 *+-------------------------------------------------------------------------*/

class CBookmarkEx : public CBookmark
{
    typedef CBookmark BC;

public:
    enum { ID_ConsoleRoot = -10 };

                            // Constructor / destructor
                            CBookmarkEx(MTNODEID idStatic = ID_Unknown);
                            CBookmarkEx(bool bIsFastBookmark);
                            CBookmarkEx(const CBookmark &rhs)   {*this = rhs;}
                            CBookmarkEx(const CBookmarkEx &rhs) {*this = rhs;}
                            ~CBookmarkEx();

    // casts
    CBookmarkEx &           operator = (const CBookmark   &rhs) {BC::operator = (rhs); return *this;}
    CBookmarkEx &           operator = (const CBookmarkEx &rhs) {BC::operator = (rhs); return *this;}

    SC                      ScGetMTNode(bool bExactMatchRequired, CMTNode **ppMTNode, bool& bExactMatchFound);
    std::auto_ptr<CNode>    GetNode(CViewData *pViewData);
    SC                      ScRetarget(CMTNode *pMTNode, bool bFastRetrievalOnly);
    void                    ResetUI();

    // from the old CNodePath class
public:
    SC                      ScInitialize(CMTNode* pMTNode, CMTNode* pMTViewRootNode, bool bFastRetrievalOnly);
protected:
    BOOL                    IsNodeIDOK(CDynamicPathEntryEx &nodeid);

    // find a node directly under the parent node whose node ID matches the specified CDynamicPathEntryEx.
    SC                      ScFindMatchingMTNode(CMTNode *pMTNodeParent, CDynamicPathEntryEx &entry,
                                                 CMTNode **ppMatchingMTNode);
};

#endif  /* NODEPATH_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\policy.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       policy.cpp
//
//  Contents:   Helper class to determine policy for each snapin
//
//  Classes:    CPolicy
//
//  Functions:
//
//  History:    12/04/1998   AnandhaG   Created
//____________________________________________________________________________

#include "stdafx.h"
#include "policy.h"


/*+-------------------------------------------------------------------------*
 *
 * CPolicy::ScInit
 *
 * PURPOSE: Initializes the policy object from registry.
 *
 * PARAMETERS:
 *    None.
 *
 * RETURNS:
 *    SC - Right now always returns success.
 *
 *+-------------------------------------------------------------------------*/
SC CPolicy::ScInit()
{
	DECLARE_SC (sc, _T("CPolicy::ScInit"));

	// Default NT4 configuration. Always allow author mode
	// and allow snapins not in permitted list.
	m_bRestrictAuthorMode        = FALSE;
	m_bRestrictedToPermittedList = FALSE;

	// Check if the policy key exists. If not return success immediately.
	sc = m_rPolicyRootKey.ScOpen (HKEY_CURRENT_USER, POLICY_KEY, KEY_READ);
	if (sc)
	{
		if (sc = ScFromWin32 (ERROR_FILE_NOT_FOUND))
		{
			TRACE(_T("CPolicy::Policy does not exist\n"));
			sc.Clear();
		}

		return (sc);
	}

	bool bRestrictAuthorMode        = false;
	bool bRestrictedToPermittedList = false;

	// Read the values of RestrictAuthorMode and whether
	// snapins not in the list are permitted or not.
	if (m_rPolicyRootKey.IsValuePresent(g_szRestrictAuthorMode))
	{
		DWORD  dwValue;
		DWORD  dwSize = sizeof(dwValue);
		DWORD  dwType = REG_DWORD;

		sc = m_rPolicyRootKey.ScQueryValue (g_szRestrictAuthorMode, &dwType,
											&dwValue, &dwSize);
		if (sc)
			sc.Clear();
		else
			bRestrictAuthorMode = !!dwValue;
	}

	if (m_rPolicyRootKey.IsValuePresent(g_szRestrictToPermittedList))
	{
		DWORD  dwValue = 0;
		DWORD  dwSize = sizeof(dwValue);
		DWORD  dwType = REG_DWORD;

		sc = m_rPolicyRootKey.ScQueryValue (g_szRestrictToPermittedList, &dwType,
											&dwValue, &dwSize);
		if (sc)
			sc.Clear();
		else
			bRestrictedToPermittedList = !!dwValue;
	}

	m_bRestrictAuthorMode        = bRestrictAuthorMode;
	m_bRestrictedToPermittedList = bRestrictedToPermittedList;
    return sc;
}


/*+-------------------------------------------------------------------------*
 * CPolicy::IsPermittedSnapIn
 *
 * Determines if a snap-in is permitted according to this policy.  The
 * real work happens in
 *
 *      IsPermittedSnapIn (LPCWSTR);
 *--------------------------------------------------------------------------*/

bool CPolicy::IsPermittedSnapIn(REFCLSID refSnapInCLSID)
{
    CCoTaskMemPtr<WCHAR> spwzSnapinClsid;

    /*
     * Get the string representation of the CLSID.  If that fails,
     * permit the snap-in.
     */
    if (FAILED (StringFromCLSID (refSnapInCLSID, &spwzSnapinClsid)))
        return TRUE;

    /*
     * forward to the real worker
     */
    return (IsPermittedSnapIn (spwzSnapinClsid));
}


/*+-------------------------------------------------------------------------*
 * CPolicy::IsPermittedSnapIn
 *
 * Determines if a snap-in is permitted according to this policy.
 *--------------------------------------------------------------------------*/

bool CPolicy::IsPermittedSnapIn(LPCWSTR lpszCLSID)
{
    /*
     * No CLSID?  Allow it.
     */
    if (lpszCLSID == NULL)
        return (TRUE);

    /*
     * No policy key?  Allow everything.
     */
    if (m_rPolicyRootKey == NULL)
        return (true);

    // See if this snapin policy is defined or not.
    bool bRestricted = FALSE;
    bool bSnapinFound = FALSE;

	USES_CONVERSION;
	CRegKeyEx regKeyTemp;
	bSnapinFound = !regKeyTemp.ScOpen (m_rPolicyRootKey, W2CT(lpszCLSID), KEY_READ).IsError();

	if (bSnapinFound && regKeyTemp.IsValuePresent(g_szRestrictRun))
	{
		// Read the value of Restrict_Run.
		DWORD dwValue = 0;
		DWORD dwSize = sizeof(DWORD);
		DWORD dwType = REG_DWORD;

		regKeyTemp.ScQueryValue (g_szRestrictRun, &dwType, &dwValue, &dwSize);
		bRestricted = !!dwValue;
	}

    // At this point we know policies root key exists. So if the
    // snapin key is not found, then we have to see if the administrator
    // allows snapins not in the permitted list (therefore snapin key
    // does not exist).
    if (! bSnapinFound)
    {
        if(m_bRestrictedToPermittedList)
            return false; // because if the snap-in is not on the list, and
                          // restrictions are set, disallow by default
        else
            return true;  // NT4 behavior - no restrictions set, and per-snap-in
                         // entry not found, so allow by default.
    }

    // At this point snapin's Restrict_Run key was read so use it.
    return (!bRestricted);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\objfmts.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       objfmts.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    6/12/1997   RaviR   Created
//____________________________________________________________________________
//


#ifndef _OBJFMTS_H_
#define _OBJFMTS_H_


HRESULT GetObjFormats(UINT cfmt, FORMATETC *afmt, LPVOID *ppvObj);
HRESULT GetObjFormatsEx(IEnumFORMATETC* pEnum1, IEnumFORMATETC* pEnum2,
                        IEnumFORMATETC** ppEnumOut);


//____________________________________________________________________________
//
//  Class:      CObjFormats
//
//  Purpose:    Impements IEnumFORMATETC for objects.
//____________________________________________________________________________


class CObjFormats : public IEnumFORMATETC,
                    public CComObjectRoot
{
public:
// ATL Maps
DECLARE_NOT_AGGREGATABLE(CObjFormats)
BEGIN_COM_MAP(CObjFormats)
    COM_INTERFACE_ENTRY(IEnumFORMATETC)
END_COM_MAP()

public:
    CObjFormats() : m_iFmt(0), m_cFmt(0), m_aFmt(NULL) 
    {
    }

    ~CObjFormats() { if (m_aFmt) delete [] m_aFmt; }

    void Init(UINT cfmt, FORMATETC * afmt)
    {
        m_cFmt = cfmt; 
        m_aFmt = afmt;
    }

    //  IEnumFORMATETC methods
    STDMETHODIMP Next(ULONG celt, FORMATETC *rgelt, ULONG *pceltFethed);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumFORMATETC ** ppenum);

private:
    UINT            m_iFmt;
    UINT            m_cFmt;
    FORMATETC     * m_aFmt;

}; // class CObjFormats


//____________________________________________________________________________
//
//  Class:      CObjFormatsEx
//
//  Purpose:    Impements IEnumFORMATETC for objects.
//____________________________________________________________________________


class CObjFormatsEx : public IEnumFORMATETC,
                      public CComObjectRoot
{
public:
// ATL Maps
DECLARE_NOT_AGGREGATABLE(CObjFormatsEx)
BEGIN_COM_MAP(CObjFormatsEx)
    COM_INTERFACE_ENTRY(IEnumFORMATETC)
END_COM_MAP()

public:
    CObjFormatsEx() : m_iCur(0)
    {
    }

    ~CObjFormatsEx() 
    { 
    }

    bool Init(IEnumFORMATETC* pEnum1, IEnumFORMATETC* pEnum2)
    {
        ASSERT(pEnum1 && pEnum2);
        if (!pEnum1 || !pEnum2)
            return false;
        
        m_rgspEnums[0] = pEnum1;
        m_rgspEnums[1] = pEnum2;
        return true;
    }

    //  IEnumFORMATETC methods
    STDMETHODIMP Next(ULONG celt, FORMATETC *rgelt, ULONG *pceltFethed);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumFORMATETC ** ppenum);

private:
    UINT                m_iCur;
    IEnumFORMATETCPtr   m_rgspEnums[2];

}; // class CObjFormatsEx


#endif // _OBJFMTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\nodepath.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      nodepath.h
 *
 *  Contents:  Dynamic node path generation helpers
 *
 *  History:   31-Mar-98 JeffRo     Created
 *
 *
 * The persisted format of a node path (aka bookmark) is as follows:
 *
 * DWORD    idStatic;           // the MTNODEID of the static root of the node
 * DWORD    cDynamicBytes;      // count of bytes in the dynamic portion of the
 *                              // bookmark
 * BYTE     rgDynamicBytes[];   // array of bytes representing the dynamic
 *                              // portion of the bookmark
 *
 *
 * For MMC v1.0 consoles, rgDynamicBytes is a double-NULL terminated list
 * of Unicode strings representing the names of the dynamic nodes.  For a
 * tree that looks like this:
 *
 *      Static Node (id == 3)
 *          Dynamic Node1
 *              Dynamic Node2
 *
 * the full bookmark for Dynamic Node 2 would be:
 *
 * 00000000  03 00 00 00 00 00 00 00 44 00 79 00 6E 00 61 00  ........D.y.n.a.
 * 00000010  6D 00 69 00 63 00 20 00 4E 00 6F 00 64 00 65 00  m.i.c. .N.o.d.e.
 * 00000020  31 00 00 00 44 00 79 00 6E 00 61 00 6D 00 69 00  1...D.y.n.a.m.i.
 * 00000030  63 00 20 00 4E 00 6F 00 64 00 65 00 32 00 00 00  c. .N.o.d.e.2...
 * 00000040  00 00                                            ..
 *
 *
 * For MMC v1.1 and higher consoles, rgDynamic looks like this:
 *
 * BYTE     rgSignature[16];    // "MMCCustomStream"
 * DWORD    dwStreamVersion;    // version number, currently 0x0100
 *
 * followed by 1 or more dynamic node IDs, each of which looks like:
 *
 * BYTE     byNodeIDType;       // NDTYP_STRING (0x01) means the snap-in
 *                              // did not support CCF_NODEID(2) and the
 *                              // ID is the NULL-terminated Unicode name
 *                              // of the node
 *                              // NDTYP_CUSTOM (0x02) means the snap-in
 *                              // supported CCF_NODEID(2) and what follows
 *                              // is the SNodeID structure
 *
 * BYTE     rgNodeIDBytes[];    // bytes for the dynamic node ID
 *
 *
 * For a tree that looks like this:
 *
 *      Static Node (id == 3)
 *          Dynamic Node1 (doesn't support CCF_NODEID(2))
 *              Dynamic Node2 (suports CCF_NODEID, returns DWORD 0x12345678)
 *
 * the full bookmark for Dynamic Node 2 would be:
 *
 * 00000000  03 00 00 00 3A 00 00 00 4D 4D 43 43 75 73 74 6F  ....:...MMCCusto
 * 00000010  6D 53 74 72 65 61 6D 00 00 00 01 00 01 44 00 79  mStream......D.y
 * 00000020  00 6E 00 61 00 6D 00 69 00 63 00 20 00 4E 00 6F  .n.a.m.i.c. .N.o
 * 00000030  00 64 00 65 00 31 00 00 00 02 04 00 00 00 78 56  .d.e.1........xV
 * 00000040  34 12                                            4.
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "nodepath.h"
#include <comdef.h>
#include "nmtempl.h"
#include "conview.h"

using namespace std;

/*+-------------------------------------------------------------------------*
 * class CDynamicPathEntryEx
 *
 *
 * PURPOSE: Adds functionality (but NO MEMBER VARIABLES) to the
 *          CDynamicPathEntry class, to initialize from an MTNode.
 *
 *+-------------------------------------------------------------------------*/
class CDynamicPathEntryEx : public CDynamicPathEntry
{
    typedef CDynamicPathEntry BC;
public:
    // initialize from a node.
    SC      ScInitialize(CMTNode *pMTNode, bool bFastRetrievalOnly);

    // assignment
    CDynamicPathEntryEx & operator = (const CDynamicPathEntryEx &rhs)
    {
        BC::operator =(rhs);
        return *this;
    }

    CDynamicPathEntryEx & operator = (const CDynamicPathEntry &rhs)
    {
        BC::operator =(rhs);
        return *this;
    }

private:
    CLIPFORMAT GetCustomNodeIDCF ();
    CLIPFORMAT GetCustomNodeID2CF();
};


/*+-------------------------------------------------------------------------*
 *
 * CDynamicPathEntryEx::ScInitialize
 *
 * PURPOSE: Initializes the CDynamicPathEntryEx structure from the given MTNode.
 *
 *          This handles all the backward compatibility cases. Refer to the
 *          SDK docs to see how CCF_NODEID and CCF_NODEID2 are handled.
 *
 * PARAMETERS:
 *    CMTNode* pMTNode :
 *    DWORD    dwFlags :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CDynamicPathEntryEx::ScInitialize(CMTNode* pMTNode, bool bFastRetrievalOnly)
{
    DECLARE_SC(sc, TEXT("CDynamicPathEntryEx::ScInitialize"));
    USES_CONVERSION;

    bool bUseDisplayName = true;

    // get the data object for the node
    IDataObjectPtr  spDataObject;
    sc = pMTNode->QueryDataObject (CCT_SCOPE, &spDataObject);
    if(sc)
        return sc;

    // extract the CCF_NODEID2 format from the data object
    HGLOBAL hGlobal = NULL;
    sc = DataObject_GetHGLOBALData (spDataObject, GetCustomNodeID2CF(), &hGlobal);
    if(!sc.IsError()) // succeeded
    {
        // build the DynamicNodeID from the custom node ID struct
        SNodeID2 *pNodeID2 =  reinterpret_cast<SNodeID2*>(GlobalLock (hGlobal));
        sc = ScCheckPointers(pNodeID2);
        if(sc)
            return sc;

        // if the client needs a fast path ONLY but the snapin can't provide one,
        // return E_INVALIDARG;
        // Bug 175684: this is a "valid" error return, so we don't want to trace it
        if ( ( (pNodeID2->dwFlags & MMC_NODEID_SLOW_RETRIEVAL) &&
                bFastRetrievalOnly)  ||
             ( pNodeID2->cBytes <= 0) )
        {
            SC scNoTrace = E_INVALIDARG;
            return (scNoTrace);
        }

        m_byteVector.insert (m_byteVector.end(),
                             pNodeID2->id, pNodeID2->id + pNodeID2->cBytes);

        m_type = NDTYP_CUSTOM;
        bUseDisplayName = false;
    }
    else    // the CCF_NODEID2 format was not supported. Try CCF_NODEID.
    {
        sc = DataObject_GetHGLOBALData (spDataObject, GetCustomNodeIDCF(), &hGlobal);
        if(!sc)
        {
            // build the DynamicNodeID from the custom node ID struct
            m_type = NDTYP_CUSTOM;
            SNodeID *pNodeID =  reinterpret_cast<SNodeID*>(GlobalLock (hGlobal));

            sc = ScCheckPointers(pNodeID);
            if(sc)
                return sc;

            // if pNodeID->cBytes is zero, this is a legacy indication that the
            // node does not support fast retrieval. But, if the client is OK
            // with slow retrieval, we supply the display name instead.

            if(pNodeID->cBytes != 0)
            {
                m_byteVector.insert (m_byteVector.end(),
                                     pNodeID->id, pNodeID->id + pNodeID->cBytes);
                bUseDisplayName = false;
            }
            else
            {
                // cBytes == 0 here. If the client indicated fast retrieval, must return an error.
                // Bug 175684: this is a "valid" error return, so we don't want to trace it
                if(bFastRetrievalOnly)
                {
                    SC scNoTrace = E_INVALIDARG;
                    return (scNoTrace);
                }
                else
                    bUseDisplayName = true; // must use the display name here.
            }
        }
    };

    // let go of the data
    if (hGlobal)
    {
        GlobalUnlock (hGlobal);
        GlobalFree (hGlobal);
    }
    // no custom ID; persist the node name, for compatibility
    // if CCF_NODEID was presented with a zero count, also use the node name.
    if (bUseDisplayName)
    {
        sc.Clear();
        m_type = NDTYP_STRING;

		tstring strName = pMTNode->GetDisplayName();
        if (!strName.empty())
            m_strEntry = T2CW(strName.data());
        else
            return (sc = E_INVALIDARG);

    }

    return sc;
}

/*--------------------------------------------------------------------------*
 * CDynamicPathEntryEx::GetCustomNodeIDCF
 *
 *
 *--------------------------------------------------------------------------*/

CLIPFORMAT CDynamicPathEntryEx::GetCustomNodeIDCF()
{
    static CLIPFORMAT cfCustomNodeID = 0;

    if (cfCustomNodeID == 0)
    {
        USES_CONVERSION;
        cfCustomNodeID = (CLIPFORMAT) RegisterClipboardFormat (W2T (CCF_NODEID));
        ASSERT (cfCustomNodeID != 0);
    }

    return (cfCustomNodeID);
}

/*--------------------------------------------------------------------------*
 * CDynamicPathEntryEx::GetCustomNodeID2CF
 *
 *
 *--------------------------------------------------------------------------*/

CLIPFORMAT CDynamicPathEntryEx::GetCustomNodeID2CF()
{
    static CLIPFORMAT cfCustomNodeID2 = 0;

    if (cfCustomNodeID2 == 0)
    {
        USES_CONVERSION;
        cfCustomNodeID2 = (CLIPFORMAT) RegisterClipboardFormat (W2T (CCF_NODEID2));
        ASSERT (cfCustomNodeID2 != 0);
    }

    return (cfCustomNodeID2);
}



//############################################################################
//############################################################################
//
//  Implementation of class CBookmarkEx
//
//############################################################################
//############################################################################

CBookmarkEx::CBookmarkEx(MTNODEID idStatic) : BC(idStatic)
{
}

CBookmarkEx::CBookmarkEx(bool bIsFastBookmark) : BC(bIsFastBookmark)
{
}


/*+-------------------------------------------------------------------------*
 * CBookmarkEx::~CBookmarkEx
 *
 * PURPOSE:     Destructor
 *
 * PARAMETERS:
 *
 * RETURNS:
 *
/*+-------------------------------------------------------------------------*/
CBookmarkEx::~CBookmarkEx()
{
}


/*+-------------------------------------------------------------------------*
 *
 * CBookmarkEx::ScRetarget
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    CMTNode * pMTNode :
 *    bool      bFastRetrievalOnly :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CBookmarkEx::ScRetarget(CMTNode *pMTNode, bool bFastRetrievalOnly)
{
    DECLARE_SC(sc, TEXT("CBookmarkEx::ScRetarget"));

    if(pMTNode)
    {
        sc = ScInitialize (pMTNode, NULL, bFastRetrievalOnly);
        if(sc)
            return sc;
    }
    else
        Reset();

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CBookmarkEx::ResetUI
 *
 * PURPOSE: Reset's the state of the bookmark. Will put up the Retry/Cancel
 *          UI if the node is not available.
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CBookmarkEx::ResetUI()
{
}

/* CBookmarkEx::GetNode
 *
 * PURPOSE:     Returns a CNode corresponding to the bookmark for a particular view.
 *              NOTE: This will return a new instance every time. To reuse the same
 *              instance, cache it.
 *
 * PARAMETERS:
 *      CViewData *  pViewData: The view for which a node is requested
 *
 * RETURNS:
 *      CNode * : NULL if the MTNode could not be found.
 */
std::auto_ptr<CNode>
CBookmarkEx::GetNode(CViewData *pViewData)
{
    DECLARE_SC(sc, TEXT("CBookmarkEx::GetNode"));

    CNode *             pNode       = NULL;
    CMTNode *           pMTNode     = NULL;

    // The NULL return value for failure conditions.
    std::auto_ptr<CNode> spNodeNull;

    // validate parameters
    if(NULL == pViewData)
    {
        sc = E_UNEXPECTED;
        return spNodeNull;
    }

    //  Get the target node.
    bool bExactMatchFound = false; // out value from ScGetMTNode, unused
    sc = ScGetMTNode(true, &pMTNode, bExactMatchFound);
    if( sc.IsError() || !pMTNode) // could not find the node - abort.
    {
        return spNodeNull;
    }

    // make sure the node is expanded (invisibly) in the tree
    CConsoleView* pConsoleView = pViewData->GetConsoleView();
    if (pConsoleView == NULL)
    {
        sc = E_UNEXPECTED;
        return spNodeNull;
    }

    sc = pConsoleView->ScExpandNode (pMTNode->GetID(), true, false);
    if(sc)
        return spNodeNull;

    pNode = pMTNode->GetNode(pViewData, false);
    if (pNode == NULL)
    {
        sc = E_OUTOFMEMORY;
        return spNodeNull;
    }

    if (FAILED (pNode->InitComponents()))
    {
        delete pNode;
        sc = E_UNEXPECTED;
        return spNodeNull;
    }

    return (std::auto_ptr<CNode>(pNode));
}



/*+-------------------------------------------------------------------------*
 *
 * CBookmarkEx::ScInitialize
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    CMTNode* pMTNode :
 *    CMTNode* pMTViewRootNode :
 *    bool     bFastRetrievalOnly : true by default. If true, this
 *                                  function returns E_INVALIDARG for
 *                                  any node that cannot be quickly
 *                                  retrieved.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CBookmarkEx::ScInitialize (CMTNode* pMTNode, CMTNode* pMTViewRootNode, bool bFastRetrievalOnly)
{
    DECLARE_SC(sc, TEXT("CBookmarkEx::ScInitialize"));

    // check pointers
    sc = ScCheckPointers(pMTNode);
    if(sc)
        return sc;

    BC::Reset();

    // 1. Get the static node ID
    m_idStatic = pMTNode->GetID();

    // If this is a static node, we're done.
    if(pMTNode->IsStaticNode())
        return sc;

    bool fPassedViewRootNode = false;

    // get a descriptor for each dynamic node at the end of the branch
    // (from leaf to root)
    while ((pMTNode != NULL) && !pMTNode->IsStaticNode())
    {
        CDynamicPathEntryEx   entry;

        sc = entry.ScInitialize(pMTNode, bFastRetrievalOnly);
        if(sc.IsError() && !(sc == E_INVALIDARG) ) // E_INVALIDARG means that fast retrieval was not available.
            return sc;

        if(sc) // must be E_INVALIDARG
        {
            // if the node's data object gave us an empty custom node ID,
            // we don't want to persist this node or any below it, so purge the list
            m_dynamicPath.clear(); // clear the path
            sc.Clear();
        }
        // otherwise, put it this node ID on the front of the list
        else
            m_dynamicPath.push_front (entry);

        /*
         * remember if we've passed the node at the root of our view
         * on our way up the tree to the first static node
         */
        if (pMTNode == pMTViewRootNode)
            fPassedViewRootNode = true;

        /*
         * If we've passed the view's root node and the list is empty, it means
         * that a node between the view's root node and the first static node
         * (specifically, this one) supports CCF_NODEID and has requested
         * that the node not be persisted.  If a node isn't persisted,
         * nothing below it is persisted, either, so we can bail out.
         */
        if (fPassedViewRootNode && m_dynamicPath.empty())
            break;

        pMTNode = pMTNode->Parent();
    }

    // assume success
    sc.Clear();
    if(!pMTNode || !pMTNode->IsStaticNode())
        return (sc = E_UNEXPECTED);

    //  Get the static node ID of the static parent
    m_idStatic = pMTNode->GetID();

    // if we don't have a dynamic node path, return so
    if (m_dynamicPath.empty ())
        return (sc = S_FALSE);

    // if we hit the root before we hit a static node, we have an error
    if (pMTNode == NULL)
        sc = E_FAIL;

    return sc;

}


/*+-------------------------------------------------------------------------*
 *
 * CBookmarkEx::ScGetMTNode
 *
 * PURPOSE: Returns the MTNode of the node with the given path relative to
 *          the static node.
 *
 * PARAMETERS:
 *    bool bExactMatchRequired: [IN] Do we need exact match?
 *    CMTNode ** ppMTNode     : [OUT]: The MTNode, if found.
 *    bool bExactMatchFound   : [OUT] Did we find exact match?
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CBookmarkEx::ScGetMTNode(bool bExactMatchRequired, CMTNode **ppMTNode, bool& bExactMatchFound)
{
    DECLARE_SC(sc, TEXT("CBookmarkEx::ScGetMTNode"));

    // check parameters
    sc = ScCheckPointers(ppMTNode);
    if(sc)
        return sc;

    // init out param
    *ppMTNode = NULL;
    bExactMatchFound = false;

    CScopeTree *pScopeTree = CScopeTree::GetScopeTree();
    if(!pScopeTree)
    {
        sc = E_POINTER;
        return sc;
    }

    if (m_idStatic == ID_ConsoleRoot)
    {
        sc = ScRetarget (pScopeTree->GetRoot(), true /*bFastRetrievalOnly*/);
        if(sc)
            return sc;
    }

    // find the MTNode of the static node closest to the required node.
    CMTNode* pMTNode = NULL;
    sc = pScopeTree->Find(m_idStatic, &pMTNode);
    if(sc)
        return sc;

    sc = ScCheckPointers(pMTNode);
    if(sc)
        return sc;

    *ppMTNode = pMTNode; // initialize

    CDynamicPath::iterator iter;

    for(iter = m_dynamicPath.begin(); iter != m_dynamicPath.end(); iter++)
    {
        CDynamicPathEntryEx entry;

        entry = *iter;

        // check the next segment of the path.
        sc = ScFindMatchingMTNode(pMTNode, entry, ppMTNode);

        // handle the special case of the node not being found but an exact match
        // not being needed. In this case, we use the closest ancestor node that
        // was available.

		if ( (sc == ScFromMMC(IDS_NODE_NOT_FOUND)) && !bExactMatchRequired )
        {
            // set the output.
            *ppMTNode = pMTNode;
            sc.Clear();
            return sc;
		}


        // bail on all other errors
        if(sc)
            return sc;

        sc = ScCheckPointers(*ppMTNode);
        if(sc)
            return sc;

        pMTNode = *ppMTNode; //prime the MTNode for the next round, if there is one.
    }

    // we've found a match if we ran out of entries.
    bExactMatchFound = (iter == m_dynamicPath.end());

    if(bExactMatchRequired && !bExactMatchFound) // could not find the exact node.
    {
        *ppMTNode = NULL;
        return (sc = ScFromMMC(IDS_NODE_NOT_FOUND));
    }

    // a NULL pMTNode is not an error, we just need to make sure that
    // nodes are initialized before use.
    if ((pMTNode != NULL) && !pMTNode->IsInitialized() )
    {
        sc = pMTNode->Init();
        if(sc)
            sc.TraceAndClear(); // does not invalidate the locating operation
    }

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CBookmarkEx::ScFindMatchingMTNode
 *
 * PURPOSE: Finds the first child node directly beneath the given parent node
 *          whose node ID (ie one of CCF_NODEID2, CCF_NODEID, or the display
 *          name) matches the specified CDynamicPathEntryEx object.
 *
 * PARAMETERS:
 *    CMTNode *             pMTNodeParent :
 *    CDynamicPathEntryEx & entry :
 *    CMTNode **            ppMatchingMTNode :      [OUT]: The child node, if found.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CBookmarkEx::ScFindMatchingMTNode(CMTNode *pMTNodeParent, CDynamicPathEntryEx &entry,
                                  CMTNode **ppMatchingMTNode)
{
    DECLARE_SC(sc, TEXT("CBookmarkEx::ScFindMatchingMTNode"));

    sc = ScCheckPointers(pMTNodeParent, ppMatchingMTNode);
    if(sc)
        return sc;

    *ppMatchingMTNode = NULL; // initialize

    // expand the parent node if not already done so.
    if (pMTNodeParent->WasExpandedAtLeastOnce() == FALSE)
    {
        sc = pMTNodeParent->Expand();
        if(sc)
            return sc;
    }

    // see if any of the children of this node match the next segment of the stored path
    for (CMTNode *pMTNode = pMTNodeParent->Child(); pMTNode != NULL; pMTNode = pMTNode->Next())
    {
        CDynamicPathEntryEx entryTemp;
        sc = entryTemp.ScInitialize(pMTNode, false /*bFastRetrievalOnly :
        at this point, we know the node is created, so we don't care about retrieval speed*/);
        if(sc)
            return sc;

        if(entryTemp == entry) // found it.
        {
            *ppMatchingMTNode = pMTNode;
            return sc;
        }
    }

    // could not find the node.
    return (sc = ScFromMMC(IDS_NODE_NOT_FOUND));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\plex.cpp ===
// This was a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation, 1992 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"


#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CPlex

CPlex* PASCAL CPlex::Create(CPlex*& pHead, UINT nMax, UINT cbElement)
{
	ASSERT(nMax > 0 && cbElement > 0);
	CPlex* p = (CPlex*) new BYTE[sizeof(CPlex) + nMax * cbElement];
	if (p == NULL)
		return NULL;

	p->pNext = pHead;
	pHead = p;  // change head (adds in reverse order for simplicity)
	return p;
}

void CPlex::FreeDataChain()     // free this one and links
{
	CPlex* p = this;
	while (p != NULL)
	{
		BYTE* bytes = (BYTE*) p;
		CPlex* pNext = p->pNext;
		delete[] bytes;
		p = pNext;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\oncmenu.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       oncmenu.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    1/9/1997   RaviR   Created
//____________________________________________________________________________
//


#include "stdafx.h"
#include "tasks.h"
#include "oncmenu.h"
#include <comcat.h>             // COM Component Categories Manager
#include "compcat.h"
#include "guids.h"
#include "newnode.h"
#include "..\inc\amcmsgid.h"
#include "multisel.h"
#include "scopndcb.h"
#include "cmenuinfo.h"
#include "contree.h"
#include "conview.h"
#include "conframe.h"
#include "rsltitem.h"
#include "variant.h" // ConvertByRefVariantToByValue

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// forward reference
class CConsoleStatusBar;

//############################################################################
//############################################################################
//
//  Language-independent menu names. DO NOT CHANGE THESE!!
//
//  the macro expands out to something like
//  const LPCTSTR szCONTEXTHELP = TEXT("_CONTEXTHELP")
//
//############################################################################
//############################################################################
#define DECLARE_MENU_ITEM(_item) const LPCTSTR sz##_item = TEXT("_")TEXT(#_item);

DECLARE_MENU_ITEM(CONTEXTHELP)
DECLARE_MENU_ITEM(VIEW)
DECLARE_MENU_ITEM(CUSTOMIZE)
DECLARE_MENU_ITEM(COLUMNS)
DECLARE_MENU_ITEM(VIEW_LARGE)
DECLARE_MENU_ITEM(VIEW_SMALL)
DECLARE_MENU_ITEM(VIEW_LIST)
DECLARE_MENU_ITEM(VIEW_DETAIL)
DECLARE_MENU_ITEM(VIEW_FILTERED)
DECLARE_MENU_ITEM(ORGANIZE_FAVORITES)
DECLARE_MENU_ITEM(CUT)
DECLARE_MENU_ITEM(COPY)
DECLARE_MENU_ITEM(PASTE)
DECLARE_MENU_ITEM(DELETE)
DECLARE_MENU_ITEM(PRINT)
DECLARE_MENU_ITEM(RENAME)
DECLARE_MENU_ITEM(REFRESH)
DECLARE_MENU_ITEM(SAVE_LIST)
DECLARE_MENU_ITEM(PROPERTIES)
DECLARE_MENU_ITEM(OPEN)
DECLARE_MENU_ITEM(EXPLORE)
DECLARE_MENU_ITEM(NEW_TASKPAD_FROM_HERE)
DECLARE_MENU_ITEM(EDIT_TASKPAD)
DECLARE_MENU_ITEM(DELETE_TASKPAD)
DECLARE_MENU_ITEM(ARRANGE_ICONS)
DECLARE_MENU_ITEM(ARRANGE_AUTO)
DECLARE_MENU_ITEM(LINE_UP_ICONS)
DECLARE_MENU_ITEM(TASK)
DECLARE_MENU_ITEM(CREATE_NEW)

//############################################################################
//############################################################################
//
//  Trace Tags
//
//############################################################################
//############################################################################
#ifdef DBG
CTraceTag tagOnCMenu(TEXT("OnCMenu"), TEXT("OnCMenu"));
#endif

//############################################################################
//############################################################################
//
//  Implementation of class CCustomizeViewDialog
//
//############################################################################
//############################################################################
class CCustomizeViewDialog : public CDialogImpl<CCustomizeViewDialog>
{
    typedef CCustomizeViewDialog               ThisClass;
    typedef CDialogImpl<CCustomizeViewDialog>  BaseClass;

public:
    // Operators
    enum { IDD = IDD_CUSTOMIZE_VIEW };
    CCustomizeViewDialog(CViewData *pViewData);

protected:
    BEGIN_MSG_MAP(ThisClass)
        MESSAGE_HANDLER    (WM_INITDIALOG,  OnInitDialog)
        CONTEXT_HELP_HANDLER()
        COMMAND_ID_HANDLER (IDOK,           OnOK)
        COMMAND_HANDLER    (IDC_CUST_STD_MENUS,      BN_CLICKED, OnClick)
        COMMAND_HANDLER    (IDC_CUST_SNAPIN_MENUS,   BN_CLICKED, OnClick)
        COMMAND_HANDLER    (IDC_CUST_STD_BUTTONS,    BN_CLICKED, OnClick)
        COMMAND_HANDLER    (IDC_CUST_SNAPIN_BUTTONS, BN_CLICKED, OnClick)
        COMMAND_HANDLER    (IDC_CUST_STATUS_BAR,     BN_CLICKED, OnClick)
        COMMAND_HANDLER    (IDC_CUST_DESC_BAR,       BN_CLICKED, OnClick)
        COMMAND_HANDLER    (IDC_CUST_CONSOLE_TREE,   BN_CLICKED, OnClick)
        COMMAND_HANDLER    (IDC_CUST_TASKPAD_TABS,   BN_CLICKED, OnClick)
    END_MSG_MAP();

    IMPLEMENT_CONTEXT_HELP(g_aHelpIDs_IDD_CUSTOMIZE_VIEW);

    LRESULT OnInitDialog (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnOK         (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel     (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnClick      (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);


    bool PureIsDlgButtonChecked (int nIDButton) const
        { return (IsDlgButtonChecked(nIDButton) == BST_CHECKED); }

private:
    CViewData *   m_pViewData;
    bool          m_bStdMenus       : 1;
    bool          m_bSnapinMenus    : 1;
    bool          m_bStdButtons     : 1;
    bool          m_bSnapinButtons  : 1;
    bool          m_bStatusBar      : 1;
    bool          m_bDescBar        : 1;
    bool          m_bConsoleTree    : 1;
    bool          m_bTaskpadTabs    : 1;
};

CCustomizeViewDialog::CCustomizeViewDialog(CViewData *pViewData)
: m_pViewData(pViewData)
{
    DWORD dwToolbarsDisplayed = pViewData->GetToolbarsDisplayed();

    m_bStdMenus       =  dwToolbarsDisplayed & STD_MENUS;
    m_bSnapinMenus    =  dwToolbarsDisplayed & SNAPIN_MENUS;
    m_bStdButtons     =  dwToolbarsDisplayed & STD_BUTTONS;
    m_bSnapinButtons  =  dwToolbarsDisplayed & SNAPIN_BUTTONS;
    m_bStatusBar      =  pViewData->IsStatusBarVisible();
    m_bDescBar        =  pViewData->IsDescBarVisible();
    m_bConsoleTree    =  pViewData->IsScopePaneVisible();
    m_bTaskpadTabs    =  pViewData->AreTaskpadTabsAllowed();
}

LRESULT
CCustomizeViewDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    /*
     * Since these two values correspond to the possible values of a bool,
     * we don't have to have an ugly conditional operator below, i.e.:
     *
     *      CheckDlgButton (..., (m_bStdMenus) ? BST_CHECKED : BST_UNCHECKED);
     */
    ASSERT (BST_CHECKED   == true);
    ASSERT (BST_UNCHECKED == false);

    CheckDlgButton (IDC_CUST_SNAPIN_MENUS,   m_bSnapinMenus);
    CheckDlgButton (IDC_CUST_SNAPIN_BUTTONS, m_bSnapinButtons);
    CheckDlgButton (IDC_CUST_STATUS_BAR,     m_bStatusBar);
    CheckDlgButton (IDC_CUST_DESC_BAR,       m_bDescBar);
    CheckDlgButton (IDC_CUST_TASKPAD_TABS,   m_bTaskpadTabs);

    // if snap-in has disabled standard menus and toolbars, don't
    // allow user to enable them.
    // (Note: NOTOOLBARS disables both menus and toolbars)
    if (m_pViewData->GetWindowOptions() & MMC_NW_OPTION_NOTOOLBARS)
    {
        CheckDlgButton (IDC_CUST_STD_MENUS,      false);
        CheckDlgButton (IDC_CUST_STD_BUTTONS,    false);

        ::EnableWindow (GetDlgItem(IDC_CUST_STD_MENUS),   false);
        ::EnableWindow (GetDlgItem(IDC_CUST_STD_BUTTONS), false);
    }
    else
    {
        CheckDlgButton (IDC_CUST_STD_MENUS,   m_bStdMenus);
        CheckDlgButton (IDC_CUST_STD_BUTTONS, m_bStdButtons);
    }

    // if snap-in has disable the scope pane, then don't let user
    // try to enable/disable scope tree access.
    if (m_pViewData->GetWindowOptions() & MMC_NW_OPTION_NOSCOPEPANE)
    {
        CheckDlgButton (IDC_CUST_CONSOLE_TREE, false);

        ::EnableWindow (GetDlgItem(IDC_CUST_CONSOLE_TREE), false);
    }
    else
    {
        CheckDlgButton (IDC_CUST_CONSOLE_TREE, m_bConsoleTree);
    }

    // Disable/Remove the "Close"/"ALT+F4" from the dialog.
    HMENU hSysMenu = GetSystemMenu(FALSE);
    if (hSysMenu)
        VERIFY(RemoveMenu(hSysMenu, SC_CLOSE, MF_BYCOMMAND));

    return 0;
}


LRESULT
CCustomizeViewDialog::OnClick (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    CConsoleView* pConsoleView = m_pViewData->GetConsoleView();
    ASSERT (pConsoleView != NULL);

    switch (wID)
    {
        case IDC_CUST_STD_MENUS:
            m_pViewData->ToggleToolbar(MID_STD_MENUS);
            break;

        case IDC_CUST_SNAPIN_MENUS:
            m_pViewData->ToggleToolbar(MID_SNAPIN_MENUS);
            break;

        case IDC_CUST_STD_BUTTONS:
            m_pViewData->ToggleToolbar(MID_STD_BUTTONS);
            break;

        case IDC_CUST_SNAPIN_BUTTONS:
            m_pViewData->ToggleToolbar(MID_SNAPIN_BUTTONS);
            break;

        case IDC_CUST_STATUS_BAR:
            if (pConsoleView != NULL)
                pConsoleView->ScToggleStatusBar();
            break;

        case IDC_CUST_DESC_BAR:
            if (pConsoleView != NULL)
                pConsoleView->ScToggleDescriptionBar();
            break;

        case IDC_CUST_CONSOLE_TREE:
            if (pConsoleView != NULL)
                pConsoleView->ScToggleScopePane();
            break;

        case IDC_CUST_TASKPAD_TABS:
            if (pConsoleView != NULL)
                pConsoleView->ScToggleTaskpadTabs();
            break;
    }

    return (0);
}

LRESULT
CCustomizeViewDialog::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    EndDialog(IDOK);
    return 0;
}


//############################################################################
//############################################################################
//
//  Implementation of class CContextMenu
//
//############################################################################
//############################################################################

DEBUG_DECLARE_INSTANCE_COUNTER(CContextMenu);

CContextMenu::CContextMenu() :
    m_pNode(NULL),
    m_pNodeCallback(NULL),
    m_pCScopeTree(NULL),
    m_eDefaultVerb((MMC_CONSOLE_VERB)0),
    m_lCommandIDMax(0),
    m_pStatusBar(NULL),
    m_pmenuitemRoot(NULL),
    m_MaxPrimaryOwnerID(OWNERID_PRIMARY_MIN),
    m_MaxThirdPartyOwnerID(OWNERID_THIRD_PARTY_MIN),
    m_CurrentExtensionOwnerID(OWNERID_NATIVE),
    m_nNextMenuItemID(MENUITEM_BASE_ID),
    m_fPrimaryInsertionFlags(0),
    m_fThirdPartyInsertionFlags(0),
    m_fAddingPrimaryExtensionItems(false),
    m_fAddedThirdPartyExtensions(false),
    m_SnapinList(NULL)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CContextMenu);

    // Fix!!
    m_SnapinList = new SnapinStructList;
    ASSERT(m_SnapinList);
}

SC
CContextMenu::ScInitialize(
    CNode* pNode,
    CNodeCallback* pNodeCallback,
    CScopeTree* pCScopeTree,
    const CContextMenuInfo& contextInfo)
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScInitialize"));

    m_pNode         = pNode;
    m_pNodeCallback = pNodeCallback;
    m_pCScopeTree   = pCScopeTree;
    m_ContextInfo   = contextInfo;

    return sc;
}


CContextMenu::~CContextMenu()
{
    EmptyMenuList();

    ASSERT(m_SnapinList != NULL);
    if (m_SnapinList != NULL)
    {
        #ifdef DBG
        int const count = m_SnapinList->GetCount();
        ASSERT( count == 0);
        #endif
        delete m_SnapinList;
    }


    DEBUG_DECREMENT_INSTANCE_COUNTER(CContextMenu);
}

/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::SetStatusBar
 *
 * PURPOSE: Sets the status bar pointer.
 *
 * PARAMETERS:
 *    CConsoleStatusBar * pStatusBar :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CContextMenu::SetStatusBar(CConsoleStatusBar *pStatusBar)
{
    if(NULL != pStatusBar)
        m_pStatusBar = pStatusBar;
}

/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::GetStatusBar
 *
 * PURPOSE: Returns a pointer to the status bar to use when displaying the menu.
 *
 * RETURNS:
 *    CConsoleStatusBar *
 *
 *+-------------------------------------------------------------------------*/
CConsoleStatusBar *
CContextMenu::GetStatusBar()
{
    DECLARE_SC(sc, TEXT("CContextMenu::GetStatusBar"));

    if(m_pStatusBar)
        return m_pStatusBar;

    if(m_pNode && m_pNode->GetViewData())
    {
        m_pStatusBar = m_pNode->GetViewData()->GetStatusBar();
        return m_pStatusBar;
    }

    // last try, use the console view
    if(m_ContextInfo.m_pConsoleView)
    {
        sc = m_ContextInfo.m_pConsoleView->ScGetStatusBar(&m_pStatusBar);
        if(sc)
            return NULL;
    }

    return m_pStatusBar;
}


/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScCreateInstance
 *
 * PURPOSE: Creates a new context menu instance.
 *
 * PARAMETERS:
 *    ContextMenu **  ppContextMenu :   pointer to the ContextMenu interface on
 *                                      the instance. This maintains the lifetime.
 *
 *    CContextMenu **ppCContextMenu :   If non-null, returns the derived object pointer.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScCreateInstance(ContextMenu **ppContextMenu, CContextMenu **ppCContextMenu)
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScCreateInstance"));

    sc = ScCheckPointers(ppContextMenu, E_UNEXPECTED);
    if(sc)
        return sc;

    CComObject<CMMCNewEnumImpl<CContextMenu, CContextMenu::Position, CContextMenu> > *pContextMenu = NULL;
    sc = pContextMenu->CreateInstance(&pContextMenu);

    if(sc.IsError() || !pContextMenu)
        return (sc = E_UNEXPECTED).ToHr();

    *ppContextMenu = pContextMenu; // handles the lifetime.
    (*ppContextMenu)->AddRef();   // addref for client.

    if(ppCContextMenu != NULL)
        *ppCContextMenu = pContextMenu;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScCreateContextMenu
 *
 * PURPOSE: Creates a context menu for the specified node.
 *
 * PARAMETERS:
 *    PNODE          pNode :
 *    PPCONTEXTMENU  ppContextMenu :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScCreateContextMenu( PNODE pNode,  HNODE hNode, PPCONTEXTMENU ppContextMenu,
                                   CNodeCallback *pNodeCallback, CScopeTree *pScopeTree)
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScCreateContextMenu"));

    CNode *pNodeTarget = CNode::FromHandle(hNode);

    // validate parameters
    sc = ScCheckPointers(pNode, pNodeTarget, ppContextMenu);
    if(sc)
        return sc;

    // init out parameter
    *ppContextMenu = NULL;

    BOOL bIsScopeNode = false;

    sc = pNode->IsScopeNode(&bIsScopeNode);
    if(sc)
        return sc;

    if(!bIsScopeNode)
        return (sc = E_NOTIMPL); // TODO: result items and multiselect items.


    // create a context menu object initialized to the specified node.
    CContextMenu *pContextMenu = NULL;
    // not using upt parameter directly to avoid returning the object
    // with an error result code. See bug 139528
    // will assign at the end when we now that everything succeeded
    ContextMenuPtr spContextMenu;
    sc = CContextMenu::ScCreateContextMenuForScopeNode(pNodeTarget, pNodeCallback, pScopeTree,
                                                       &spContextMenu, pContextMenu);
    if(sc)
        return sc;

    sc = pContextMenu->ScBuildContextMenu();
    if(sc)
        return sc;

    // return the object
    *ppContextMenu = spContextMenu.Detach();

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CContextMenu::ScCreateContextMenuForScopeNode
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    CNode *pNode                  - [in] node on which the context menu will be created
 *    CNodeCallback *pNodeCallback  - [in] node callback
 *    CScopeTree *pScopeTree        - [in] scope tree
 *    PPCONTEXTMENU ppContextMenu   - [out] context menu interface
 *    CContextMenu * &pContextMenu  - [out] context menu raw pointer
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC
CContextMenu::ScCreateContextMenuForScopeNode(CNode *pNode, CNodeCallback *pNodeCallback,
                                              CScopeTree *pScopeTree,
                                              PPCONTEXTMENU ppContextMenu,
                                              CContextMenu * &pContextMenu)
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScCreateContextMenuForScopeNode"));

    // validate parameters
    sc = ScCheckPointers(ppContextMenu);
    if(sc)
        return sc;

    CContextMenuInfo contextInfo;

    // always use the temp verbs - cannot depend on what the active pane is
    contextInfo.m_dwFlags = CMINFO_USE_TEMP_VERB;

    bool fScopeItem = true;

    // initialize the context info structure.
    {
        contextInfo.m_eContextMenuType      = MMC_CONTEXT_MENU_DEFAULT;
        contextInfo.m_eDataObjectType       = fScopeItem ? CCT_SCOPE: CCT_RESULT;
        contextInfo.m_bBackground           = FALSE;
        contextInfo.m_hSelectedScopeNode    = NULL; //assigned below
        contextInfo.m_resultItemParam       = NULL; //resultItemParam;
        contextInfo.m_bMultiSelect          = FALSE; //(resultItemParam == LVDATA_MULTISELECT);
        contextInfo.m_bScopeAllowed         = fScopeItem;
        contextInfo.m_dwFlags              |= CMINFO_SHOW_SCOPEITEM_OPEN; // when called through the object model, always add the open item so that this can be accessed.


    if ( pNode!= NULL )
    {

        CViewData    *pViewData = pNode->GetViewData();
        CConsoleView *pView = NULL;
        if (NULL != pViewData && NULL != (pView = pViewData->GetConsoleView()))
        {
            // set the owner of the view
            contextInfo.m_hSelectedScopeNode = pView->GetSelectedNode();

            //if the scope node is also the owner of the view ,
            // add more menu items
            if (contextInfo.m_hSelectedScopeNode == CNode::ToHandle(pNode))
            {
                contextInfo.m_dwFlags |= CMINFO_SHOW_VIEWOWNER_ITEMS;

                // show view items as well
                contextInfo.m_dwFlags |= CMINFO_SHOW_VIEW_ITEMS;

                //.. and if there is a list it can be saved
                if ( NULL != pViewData->GetListCtrl() )
                    contextInfo.m_dwFlags |= CMINFO_SHOW_SAVE_LIST;
            }
        }

        contextInfo.m_hWnd                  = pNode->GetViewData()->GetView();
        contextInfo.m_pConsoleView          = pNode->GetViewData()->GetConsoleView();
    }
    }
    // create a context menu object initialized to the specified node.
    sc = CContextMenu::ScCreateInstance(ppContextMenu, &pContextMenu);
    if (sc)
        return sc;

    // recheck the pointer
    sc = ScCheckPointers(pContextMenu, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = pContextMenu->ScInitialize(pNode, pNodeCallback, pScopeTree, contextInfo);
    if(sc)
        return sc;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScCreateSelectionContextMenu
 *
 * PURPOSE:  Creates a context menu object for the selection in the list view.
 *
 * PARAMETERS:
 *    HNODE              hNodeScope :
 *    CContextMenuInfo * pContextInfo :
 *    PPCONTEXTMENU      ppContextMenu :
 *    CNodeCallback *    pNodeCallback :
 *    CScopeTree *       pScopeTree :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScCreateSelectionContextMenu( HNODE hNodeScope, const CContextMenuInfo *pContextInfo, PPCONTEXTMENU ppContextMenu,
                                            CNodeCallback *pNodeCallback, CScopeTree *pScopeTree)
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScCreateSelectionContextMenu"));

    CNode *pNodeSel = CNode::FromHandle(hNodeScope);

    // validate parameters
    sc = ScCheckPointers(pNodeSel, ppContextMenu);
    if(sc)
        return sc;


    // create a context menu object initialized to the specified node.
    CContextMenu *pContextMenu = NULL;

    sc = CContextMenu::ScCreateInstance(ppContextMenu, &pContextMenu);
    if(sc.IsError() || !pContextMenu)
    {
        return (sc = E_OUTOFMEMORY);
    }

    sc = pContextMenu->ScInitialize(pNodeSel, pNodeCallback, pScopeTree, *pContextInfo);
    if(sc)
        return sc;

    sc = pContextMenu->ScBuildContextMenu();
    if(sc)
        return sc;


    return sc;

}

/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScGetItem
 *
 * PURPOSE: Returns the iItem'th menu item.
 *
 * PARAMETERS:
 *    int         iItem : The zero-based item index.
 *    CMenuItem** ppMenuItem :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScGetItem(int iItem, CMenuItem** ppMenuItem)
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScGetItem"));

    sc = ScCheckPointers(ppMenuItem, E_UNEXPECTED);
    if(sc)
        return sc;

    // init out param
    *ppMenuItem = NULL;

    sc = ScGetItem(GetMenuItemList(), iItem, ppMenuItem);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScGetItem
 *
 * PURPOSE: Returns the nth item in the list of menu items, or NULL if
 *          there are insufficient items.
 *          Also returns the total count of items in the list.
 *
 * NOTE:    This method allows the context menu to be traversed. Just call it
 *          with increasing iItem, for 0 <= iItem < count.
 *
 * NOTE:    ScGetItemCount benefits from knowledge about implementation details
 *          of this function.
 *
 * PARAMETERS:
 *    MenuItemList * pMenuItemList : [in] The context menu to traverse.
 *    int &          iItem : [in, destroyed on exit]: the (zero-based) item index
 *    CMenuItem**    ppMenuItem : [out]: The iItem'th menu item.
 *
 * RETURNS:
 *    SC  : S_OK for success, an error code for error.
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScGetItem(MenuItemList *pMenuItemList, int &iItem, CMenuItem** ppMenuItem)
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScGetItem"));

    sc = ScCheckPointers(pMenuItemList, ppMenuItem, E_UNEXPECTED);
    if(sc)
        return sc;

    *ppMenuItem = NULL;

    POSITION position = pMenuItemList->GetHeadPosition(); // presumably we're already at the head position.

    while(position!=NULL && *ppMenuItem == NULL)
    {
        CMenuItem*  pMenuItem = pMenuItemList->GetNext(position);

        if( (pMenuItem->IsSpecialSubmenu() || pMenuItem->IsPopupMenu() )
            && pMenuItem->HasChildList())
        {
            // recurse through the submenus
            sc = ScGetItem( &pMenuItem->GetMenuItemSubmenu(), iItem, ppMenuItem );
            if(sc)
                return sc; // errors get reported right away.
        }
        else if( !pMenuItem->IsSpecialSeparator() && !pMenuItem->IsSpecialInsertionPoint()
            && !(pMenuItem->GetMenuItemFlags() & MF_SEPARATOR))
        {
            if(iItem-- == 0) // found the i'th item, but keep going to find the count of items.
                *ppMenuItem = pMenuItem;
        }
    }

    // either found one or iterated to the end ...

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CContextMenu::ScGetItemCount
 *
 * PURPOSE: Counts menu items by iterating thu them
 *
 * NOTE:    benefits from knowledge about implementation details of ScGetItem
 *
 * PARAMETERS:
 *    UINT &count
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC
CContextMenu::ScGetItemCount(UINT &count)
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScGetItemCount"));

    count = 0;

    // set iItem to invalid index - so ScGetItem will iterate to the end
    const int iInvalidIndexToSearch = -1;
    int iItem = iInvalidIndexToSearch;

    CMenuItem * pMenuItem = NULL;
    sc = ScGetItem(GetMenuItemList(), iItem, &pMenuItem);
    if(sc)
        return sc;

    ASSERT( pMenuItem == NULL); // we do not expect it to be found!

    // since iItem was decremented for each element - we can easily
    // calculate how many items we've got

    count = -(iItem - iInvalidIndexToSearch);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScEnumNext
 *
 * PURPOSE: Returns a pointer to the next menu item
 *
 * PARAMETERS:
 *    Position &  pos :
 *    PDISPATCH & pDispatch :
 *
 * RETURNS:
 *    ::SC
 *
 *+-------------------------------------------------------------------------*/
::SC
CContextMenu::ScEnumNext(Position &pos, PDISPATCH & pDispatch)
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScEnumNext"));

    // initialize out parameter
    pDispatch = NULL;

    long cnt = 0;
    sc = get_Count(&cnt);
    if (sc)
        return sc;

    // false if no more items
    if (cnt <= pos)
        return sc = S_FALSE;

    MenuItem *pMenuItem = NULL; // deliberately not a smart pointer.
    sc = get_Item(CComVariant((int)pos+1) /*convert from zero-based to one-based*/, &pMenuItem);
    if(sc.IsError() || sc == ::SC(S_FALSE))
        return sc;  // failed of no with such an index items (S_FALSE)

    // increment position
    pos++;

    pDispatch = pMenuItem; //retains the refcount.

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScEnumSkip
 *
 * PURPOSE: Skips the specified number of menu items.
 *
 * PARAMETERS:
 *    unsigned   long :
 *    unsigned   long :
 *    Position & pos :
 *
 * RETURNS:
 *    ::SC
 *
 *+-------------------------------------------------------------------------*/
::SC
CContextMenu::ScEnumSkip(unsigned long celt, unsigned long& celtSkipped,  Position &pos)
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScEnumSkip"));

    long count = 0;

    sc = get_Count(&count);
    if(sc)
        return sc;

    if(count <= pos + celt) // could not skip as many as needed
    {
        celtSkipped = count - celt - 1;
        pos = count; // one past the end.
        return (sc = S_FALSE);
    }
    else  // could skip as many as needed.
    {
        celtSkipped = celt;
        pos += celt;

        return sc;
    }
}

::SC
CContextMenu::ScEnumReset(Position &pos)
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScEnumReset"));

    pos = 0;

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::get_Count
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    PLONG  pCount :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CContextMenu::get_Count(PLONG pCount)
{
    DECLARE_SC(sc, TEXT("CMMCContextMenu::get_Count"));

    sc = ScCheckPointers(pCount);
    if(sc)
        return sc.ToHr();

    // init out param
    *pCount = 0;

    UINT count = 0;
    sc = ScGetItemCount(count);
    if(sc)
        return sc.ToHr();

    *pCount = count;

    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::get_Item
 *
 * PURPOSE: Returns the menu item specified by the index.
 *
 * PARAMETERS:
 *    long        Index :  The one-based index of the menu item to return.
 *    PPMENUITEM  ppMenuItem :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CContextMenu::get_Item(VARIANT IndexOrName, PPMENUITEM ppMenuItem)
{
    DECLARE_SC(sc, TEXT("CMMCContextMenu::get_Item"));

    sc = ScCheckPointers(ppMenuItem);
    if(sc)
        return sc.ToHr();

    // init out param
    *ppMenuItem = NULL;

    VARIANT* pvarTemp = ConvertByRefVariantToByValue(&IndexOrName);
    sc = ScCheckPointers( pvarTemp, E_UNEXPECTED );
    if(sc)
        return sc.ToHr();

    bool bByReference = ( 0 != (V_VT(pvarTemp) & VT_BYREF) ); // value passed by reference
    UINT uiVarType = (V_VT(pvarTemp) & VT_TYPEMASK); // get variable type (strip flags)

    CMenuItem *    pMenuItem = NULL;

    // compute the one-based index of the item
    if (uiVarType == VT_I4) // int type in C++; Long type in VB
    {
        // index: get I4 properly ( see if it's a reference )
        UINT uiIndex = bByReference ? *(pvarTemp->plVal) : pvarTemp->lVal;

        // find menu item by index
        sc = ScGetItem(uiIndex -1 /* convert from one-based to zero-based */, &pMenuItem);
        if(sc)
            return sc.ToHr();
    }
    else if (uiVarType == VT_I2) // short type in C++; Integer type in VB
    {
        // index: get I2 properly ( see if it's a reference )
        UINT uiIndex = bByReference ? *(pvarTemp->piVal) : pvarTemp->iVal;

        // find menu item by index
        sc = ScGetItem(uiIndex -1 /* convert from one-based to zero-based */, &pMenuItem);
        if(sc)
            return sc.ToHr();
    }
    else if (uiVarType == VT_BSTR) // BSTR type in C++; String type in VB
    {
        // Name: get string properly ( see if it's a reference )
        LPOLESTR lpstrPath = bByReference ? *(pvarTemp->pbstrVal) : pvarTemp->bstrVal;

        // look for subitem of root menu item
        if (m_pmenuitemRoot)
        {
            USES_CONVERSION;
            // convert to string. Avoid NULL pointer (change to empty string)
            LPCTSTR lpctstrPath = lpstrPath ? OLE2CT(lpstrPath) : _T("");
            // find menu item by path
            pMenuItem = m_pmenuitemRoot->FindItemByPath( lpctstrPath );
        }
    }
    else // something we did not expect
    {
        // we expect either index (VT_I2 , VT_I4) or path (VT_BSTR) only
        // anything else is treatead as invalid agument
        return (sc = E_INVALIDARG).ToHr();
    }

    if(!pMenuItem) // did not find it - return null
    {
        *ppMenuItem = NULL;
        return (sc = S_FALSE).ToHr();
    }

    // construct com object
    sc = pMenuItem->ScGetMenuItem(ppMenuItem);

    return sc.ToHr();
}



HRESULT CContextMenu::CreateContextMenuProvider()
{
    if (PContextInfo()->m_bBackground == TRUE &&
        PContextInfo()->m_eDataObjectType == CCT_SCOPE)
        return S_OK;

    ASSERT(m_pNode != NULL);
    if (m_pNode == NULL)
        return E_FAIL;

    HRESULT hr = S_OK;

    do // not a loop
    {
        //
        //  Use the standard verb present for this view.
        //

        if (!(PContextInfo()->m_dwFlags & CMINFO_USE_TEMP_VERB))
        {
            m_spVerbSet = m_pNode->GetViewData()->GetVerbSet();
            break;
        }

        //
        //  Create a temporary Standard verb ..
        //

        // .. for a scope item
        if (PContextInfo()->m_eDataObjectType == CCT_SCOPE)
        {
            hr = CreateTempVerbSet(true);
            break;
        }

        // .. for a list item
        if (!IS_SPECIAL_LVDATA(PContextInfo()->m_resultItemParam))
        {
            hr = CreateTempVerbSet(false);
            break;
        }

        // .. for a multi-sel in list view
        if (PContextInfo()->m_resultItemParam == LVDATA_MULTISELECT)
        {
            hr = CreateTempVerbSetForMultiSel();
            break;
        }
        else
        {
            ASSERT(0);
            hr = E_FAIL;
            break;
        }

    } while (0);

    if (FAILED(hr))
        return hr;


    m_spVerbSet->GetDefaultVerb(&m_eDefaultVerb);

    return S_OK;
}


/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScAddInsertionPoint
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    long  lCommandID :
 *    long  lInsertionPointID :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScAddInsertionPoint(long lCommandID, long lInsertionPointID /*= CCM_INSERTIONPOINTID_ROOT_MENU*/)
{
    SC sc;
    CONTEXTMENUITEM contextmenuitem;

    ::ZeroMemory( &contextmenuitem, sizeof(contextmenuitem) );
    contextmenuitem.strName = NULL;
    contextmenuitem.strStatusBarText = NULL;
    contextmenuitem.lCommandID = lCommandID;
    contextmenuitem.lInsertionPointID = lInsertionPointID;
    contextmenuitem.fFlags = 0;
    contextmenuitem.fSpecialFlags = CCM_SPECIAL_INSERTION_POINT;

    sc = AddItem(&contextmenuitem);
    if(sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(TEXT("CContextMenu::ScAddInsertionPoint"), sc);
    goto Cleanup;
}



/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScAddSeparator
 *
 * PURPOSE: Adds a separator to the context menu
 *
 * PARAMETERS:
 *    long  lInsertionPointID :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScAddSeparator(long lInsertionPointID /* = CCM_INSERTIONPOINTID_ROOT_MENU */)
{
    SC                      sc;
    CONTEXTMENUITEM         contextmenuitem;

    ::ZeroMemory( &contextmenuitem, sizeof(contextmenuitem) );
    contextmenuitem.strName = NULL;
    contextmenuitem.strStatusBarText = NULL;
    contextmenuitem.lCommandID = 0;
    contextmenuitem.lInsertionPointID = lInsertionPointID;
    contextmenuitem.fFlags = MF_SEPARATOR;
    contextmenuitem.fSpecialFlags = CCM_SPECIAL_SEPARATOR;

    sc = AddItem( &contextmenuitem);
    if(sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(TEXT("CContextMenu::ScAddSeparator"), sc);
    goto Cleanup;
}


/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScAddMenuItem
 *
 * PURPOSE: Adds a menu item to the context menu.
 *
 * PARAMETERS:
 *    UINT      nResourceID : contains text and status text separated by '\n'
 *    long      lCommandID  : the ID used to notify the IExtendContextMenu when an item is selected
 *    long      lInsertionPointID : the location to insert the item
 *    long      fFlags :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScAddMenuItem(
    UINT     nResourceID, // contains text and status text separated by '\n'
    LPCTSTR  szLanguageIndependentName,
    long     lCommandID,
    long     lInsertionPointID /* = CCM_INSERTIONPOINTID_ROOT_MENU */,
    long     fFlags /* = 0 */)
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScAddMenuItem"));

    sc = ScCheckPointers(szLanguageIndependentName, E_UNEXPECTED);
    if(sc)
        return sc;

    USES_CONVERSION;

    HINSTANCE             hInst                 = GetStringModule();
    CONTEXTMENUITEM2       contextmenuitem2;

    // load the resource
    CStr strText;
    strText.LoadString(hInst,  nResourceID );
    ASSERT( !strText.IsEmpty() );

    // split the resource into the menu text and status text
    CStr strStatusText;
    int iSeparator = strText.Find(_T('\n'));
    if (0 > iSeparator)
    {
        ASSERT( FALSE );
        strStatusText = strText;
    }
    else
    {
        strStatusText = strText.Right( strText.GetLength()-(iSeparator+1) );
        strText = strText.Left( iSeparator );
    }

    // add the menu item
    ::ZeroMemory( &contextmenuitem2, sizeof(contextmenuitem2) );
    contextmenuitem2.strName                    = T2OLE(const_cast<LPTSTR>((LPCTSTR)strText));
    contextmenuitem2.strLanguageIndependentName = T2OLE(const_cast<LPTSTR>(szLanguageIndependentName));
    contextmenuitem2.strStatusBarText           = T2OLE(const_cast<LPTSTR>((LPCTSTR)strStatusText));
    contextmenuitem2.lCommandID                 = lCommandID;
    contextmenuitem2.lInsertionPointID          = lInsertionPointID;
    contextmenuitem2.fFlags                     = fFlags;
    contextmenuitem2.fSpecialFlags              = ((fFlags & MF_POPUP) ? CCM_SPECIAL_SUBMENU : 0L) |
                                                  ((fFlags & MF_DEFAULT) ? CCM_SPECIAL_DEFAULT_ITEM : 0L);

    sc = AddItem(&contextmenuitem2);
    if(sc)
        return sc;

    return sc;
}


HRESULT
CContextMenu::CreateTempVerbSetForMultiSel(void)
{
    DECLARE_SC(sc, TEXT("CContextMenu::CreateTempVerbSetForMultiSel"));
    sc = ScCheckPointers(m_pNode, m_pNodeCallback, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // set standard bars
    CComObject<CTemporaryVerbSet>*  pVerbSet;
    sc = CComObject<CTemporaryVerbSet>::CreateInstance(&pVerbSet);
    if (sc)
        return sc.ToHr();

    sc = ScCheckPointers(pVerbSet, E_OUTOFMEMORY);
    if (sc)
        return sc.ToHr();

    m_spVerbSet = pVerbSet;

    sc = m_pNodeCallback->ScInitializeTempVerbSetForMultiSel(m_pNode, *pVerbSet);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}


/* CContextMenu::CreateTempVerbSet
 *
 * PURPOSE:     Used to create a temporary CVerbSet
 *
 * PARAMETERS:
 *      bool    bForScopeItem:
 *
 * RETURNS:
 *      HRESULT
 */
HRESULT CContextMenu::CreateTempVerbSet(bool bForScopeItem)
{
    DECLARE_SC(sc, TEXT("CContextMenu::CreateTempVerbSet"));
    sc = ScCheckPointers(m_pNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // ensure component is initialized !!!
    // for instance task wizard will call this for static nodes which aren't expanded yet
    // Does not hurt to check anyway - better safe than sorry
    sc = m_pNode->InitComponents ();
    if(sc)
        return sc.ToHr();

    CComponent* pCC = m_pNode->GetPrimaryComponent();
    sc = ScCheckPointers(pCC, E_FAIL);
    if (sc)
        return sc.ToHr();

    sc = pCC->ScResetConsoleVerbStates();
    if (sc)
        return sc.ToHr();

    CComObject<CTemporaryVerbSet>*  pVerb;
    sc = CComObject<CTemporaryVerbSet>::CreateInstance(&pVerb);
    if (sc)
        return sc.ToHr();

    sc = ScCheckPointers(pVerb, E_OUTOFMEMORY);
    if (sc)
        return sc.ToHr();

    sc = pVerb->ScInitialize(m_pNode, PContextInfo()->m_resultItemParam, bForScopeItem);
    if (sc)
    {
        delete pVerb;
        return sc.ToHr();
    }

    m_spVerbSet = pVerb;

    return sc.ToHr();
}


/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::AddMenuItems
 *
 * PURPOSE: Adds all menu items into the menu.
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CContextMenu::AddMenuItems()
{
    DECLARE_SC(sc, TEXT("CContextMenu::AddMenuItems"));

    sc = EmptyMenuList();
    if(sc)
        return sc.ToHr();

    // Add menu items

    if (PContextInfo()->m_eContextMenuType == MMC_CONTEXT_MENU_VIEW)
    {
         sc = ScAddMenuItemsForViewMenu(MENU_LEVEL_TOP);
         if(sc)
             return sc.ToHr();
    }
    else if (PContextInfo()->m_dwFlags & CMINFO_FAVORITES_MENU)
    {
        sc = ScAddMenuItemsforFavorites();
        if(sc)
            return sc.ToHr();
    }
    else if (PContextInfo()->m_bBackground == TRUE)
    {
        if (PContextInfo()->m_eDataObjectType != CCT_SCOPE)
        {
            sc = ScAddMenuItemsForLVBackgnd();
            if(sc)
                return sc.ToHr();
        }
    }
    else
    {
        if (PContextInfo()->m_eDataObjectType == CCT_SCOPE)
        {
            sc = ScAddMenuItemsForTreeItem();
            if(sc)
                return sc.ToHr();
        }
        else if ( m_pNode && (PContextInfo()->m_eDataObjectType == CCT_RESULT) &&
                  (m_pNode->GetViewData()->HasOCX()) )
        {
            // Selection is an OCX
            sc = ScAddMenuItemsForOCX();
            if(sc)
                return sc.ToHr();
        }
        else if ( m_pNode && (PContextInfo()->m_eDataObjectType == CCT_RESULT) &&
                  (m_pNode->GetViewData()->HasWebBrowser()) )
        {
            // do nothing for web pages.
        }
        else if (PContextInfo()->m_bMultiSelect == FALSE)
        {
            sc = ScAddMenuItemsForLV();
            if(sc)
                return sc.ToHr();
        }
        else
        {
            sc = ScAddMenuItemsForMultiSelect();
            if(sc)
                return sc.ToHr();
        }
    }

    // Add "Help" to every context menu except the view menu
    if (PContextInfo()->m_eContextMenuType != MMC_CONTEXT_MENU_VIEW)
    {
        sc = ScAddSeparator(); // make sure there is a separator.
        if(sc)
            return sc.ToHr();

        sc = ScAddMenuItem (IDS_MMC_CONTEXTHELP, szCONTEXTHELP, MID_CONTEXTHELP);
        if(sc)
            return sc.ToHr();
    }


    return sc.ToHr();
}


void
CContextMenu::RemoveTempSelection (CConsoleTree* pConsoleTree)
{
    if (pConsoleTree != NULL)
        pConsoleTree->ScRemoveTempSelection ();
}

/*+-------------------------------------------------------------------------*
 * CContextMenu::Display
 *
 * PURPOSE:   Creates the context menu tree, and shows it, if needed.
 *
 * PARAMETERS:
 *      BOOL   b: FALSE: (Normal): Display the context menu
 *                TRUE:            Don't show the context menu
 *
 * RETURNS:
 *      HRESULT
/*+-------------------------------------------------------------------------*/
HRESULT
CContextMenu::Display(BOOL b)
{
    TRACE_METHOD(CContextMenu, Display);
    HRESULT hr = S_OK;

    // b == 0    => normal
    // b == TRUE => don't show context menu

    // Validate menu type
    if (PContextInfo()->m_eContextMenuType >= MMC_CONTEXT_MENU_LAST)
    {
        ASSERT(FALSE);
        return S_FALSE;
    }


    // Display a context menu for the scope or result side
    if (PContextInfo()->m_eDataObjectType != CCT_SCOPE &&
        PContextInfo()->m_eDataObjectType != CCT_RESULT)
    {
        ASSERT(FALSE);
        return S_FALSE;
    }

    hr = CreateContextMenuProvider();
    if (FAILED(hr))
        return hr;

    hr = AddMenuItems();
    if(FAILED(hr))
        return hr;

    // Display the context menu
    long lSelected = 0;  // 0 means no selection
    hr = ShowContextMenuEx(PContextInfo()->m_hWnd,
                    PContextInfo()->m_displayPoint.x,
                    PContextInfo()->m_displayPoint.y,
                    &PContextInfo()->m_rectExclude,
                    PContextInfo()->m_bAllowDefaultItem,
                    &lSelected);


    TRACE(_T("hr = %X, Command %ld\n"), hr, lSelected);

    RemoveTempSelection (PContextInfo()->m_pConsoleTree);  // remove the temporary selection, if any.

    return hr;
}

/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScBuildContextMenu
 *
 * PURPOSE: Builds the context menu.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScBuildContextMenu()
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScBuildContextMenu"));

    sc = EmptyMenuList();
    if(sc)
        return sc;

    // Validate menu type
    if (PContextInfo()->m_eContextMenuType >= MMC_CONTEXT_MENU_LAST)
        return (sc = S_FALSE);


    // Display a context menu for the scope or result side
    if (PContextInfo()->m_eDataObjectType != CCT_SCOPE &&
        PContextInfo()->m_eDataObjectType != CCT_RESULT)
        return (sc = S_FALSE);

    sc = CreateContextMenuProvider();
    if(sc)
        return sc;

    sc = AddMenuItems();
    if(sc)
        return sc;

    CConsoleTree* pConsoleTree = PContextInfo()->m_pConsoleTree; // get this value BEFORE calling BuildAndTraverseCOntextMenu.

    WTL::CMenu menu;
    VERIFY( menu.CreatePopupMenu() );

    START_CRITSEC_BOTH;

    if (NULL == m_pmenuitemRoot)
        return S_OK;

    sc = BuildContextMenu(menu);    // build the context menu
    if(sc)
        return sc;

    END_CRITSEC_BOTH;

    /* NOTE: Do NOT use the "this" object or any of its members after this point
     * because it might have been deleted. This happens, for instance, when a selection
     * change occurs.
     */

    // remove the temporary selection, if any.
    RemoveTempSelection (pConsoleTree);

    return sc;
}


inline BOOL CContextMenu::IsVerbEnabled(MMC_CONSOLE_VERB verb)
{
    DECLARE_SC(sc, TEXT("CContextMenu::IsVerbEnabled"));

    if (verb == MMC_VERB_PASTE)
    {
        ASSERT(m_pNode);
        ASSERT(m_pNodeCallback);
        if (m_pNode == NULL || m_pNodeCallback == NULL)
            return false;

        bool bPasteAllowed = false;
        // From given context determine whether scope pane or result pane item is selected.
        bool bScope = ( m_ContextInfo.m_bBackground || (m_ContextInfo.m_eDataObjectType == CCT_SCOPE));
        LPARAM lvData = bScope ? NULL : m_ContextInfo.m_resultItemParam;

        sc = m_pNodeCallback->QueryPasteFromClipboard(CNode::ToHandle(m_pNode), bScope, lvData, bPasteAllowed);
        if (sc)
            return (bPasteAllowed = false);

        return bPasteAllowed;
    }
    else
    {
        ASSERT(m_spVerbSet != NULL);
        if (m_spVerbSet == NULL)
            return FALSE;

        BOOL bFlag = FALSE;
        m_spVerbSet->GetVerbState(verb, HIDDEN, &bFlag);
        if (bFlag == TRUE)
            return FALSE;

        m_spVerbSet->GetVerbState(verb, ENABLED, &bFlag);
        return bFlag;
    }
}


/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScAddMenuItemsForViewMenu
 *
 * PURPOSE: Adds the menu items for the View menu
 *
 * PARAMETERS:
 *    MENU_LEVEL  menuLevel :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScAddMenuItemsForViewMenu(MENU_LEVEL menuLevel)
{
    DECLARE_SC(sc, TEXT("CContextMenu::AddMenuItemsForViewMenu"));

    sc = ScCheckPointers(m_pNode, E_UNEXPECTED);
    if(sc)
        return sc;

    CViewData* pViewData = m_pNode->GetViewData();

    sc = ScCheckPointers(pViewData, E_UNEXPECTED);
    if(sc)
        return sc;

    ASSERT(pViewData != NULL);

    LONG lInsertID = 0;

    int nViewMode = -1;

    if (PContextInfo()->m_spListView)
        nViewMode = PContextInfo()->m_spListView->GetViewMode();

    // If no a top level menu, insert the view submenu item
    // and insert view items under it
    if (menuLevel == MENU_LEVEL_SUB)
    {
        sc = ScAddMenuItem(IDS_VIEW, szVIEW, MID_VIEW, 0, MF_POPUP);
        if(sc)
            return sc;

        lInsertID = MID_VIEW;
    }

    // Add cols only if it is List View in report or filtered mode.
    if ((m_pNode->GetViewData() )      &&
        (m_pNode->GetViewData()->GetListCtrl() ) &&
        ( (nViewMode == MMCLV_VIEWSTYLE_REPORT) ||
          (nViewMode == MMCLV_VIEWSTYLE_FILTERED) ) )
    {
        sc = ScAddMenuItem(IDS_COLUMNS, szCOLUMNS, MID_COLUMNS, lInsertID);
        if(sc)
            return sc;
    }

    sc = ScAddSeparator( lInsertID);
    if(sc)
        return sc;

    DWORD dwListOptions = pViewData->GetListOptions();
    DWORD dwMiscOptions = pViewData->GetMiscOptions();

    // If allowed, insert the standard listview choices
    if (!(dwMiscOptions & RVTI_MISC_OPTIONS_NOLISTVIEWS))
    {
        #define STYLECHECK(Mode) ((Mode == nViewMode) ? MF_CHECKED|MFT_RADIOCHECK : 0)


        sc = ScAddMenuItem(IDS_VIEW_LARGE,  szVIEW_LARGE,    MID_VIEW_LARGE,  lInsertID, STYLECHECK(LVS_ICON));
        if(sc)
            return sc;

        sc = ScAddMenuItem(IDS_VIEW_SMALL,  szVIEW_SMALL,    MID_VIEW_SMALL,  lInsertID, STYLECHECK(LVS_SMALLICON));
        if(sc)
            return sc;

        sc = ScAddMenuItem(IDS_VIEW_LIST,   szVIEW_LIST,     MID_VIEW_LIST,   lInsertID, STYLECHECK(LVS_LIST));
        if(sc)
            return sc;

        sc = ScAddMenuItem(IDS_VIEW_DETAIL, szVIEW_DETAIL,   MID_VIEW_DETAIL, lInsertID, STYLECHECK(LVS_REPORT));
        if(sc)
            return sc;

        if (dwListOptions & RVTI_LIST_OPTIONS_FILTERED)
        {
            sc = ScAddMenuItem(IDS_VIEW_FILTERED, szVIEW_FILTERED, MID_VIEW_FILTERED, lInsertID, STYLECHECK(MMCLV_VIEWSTYLE_FILTERED));
            if(sc)
                return sc;

        }

        sc = ScAddSeparator( lInsertID);
        if(sc)
             return sc;
    }

    // Ask IComponent to insert view items
    if (m_spIDataObject == NULL)
    {
        sc = ScCheckPointers (m_pNode->GetMTNode(), E_UNEXPECTED);
        if (sc)
            return sc;

        sc = m_pNode->GetMTNode()->QueryDataObject(CCT_SCOPE, &m_spIDataObject);
        if(sc)
            return sc;
    }

    sc = ScCheckPointers(m_spIDataObject, E_UNEXPECTED);
    if(sc)
        return sc;

    CComponent* pCC = m_pNode->GetPrimaryComponent();
    sc = ScCheckPointers(pCC, E_UNEXPECTED);
    if(sc)
        return sc;

    IUnknownPtr spUnknown = pCC->GetIComponent();
    sc = ScCheckPointers(spUnknown);
    if(sc)
        return sc;

    // Add insertion point for primary custom views
    sc = ScAddInsertionPoint(CCM_INSERTIONPOINTID_PRIMARY_VIEW, lInsertID);
    if(sc)
        return sc;

    sc = AddPrimaryExtensionItems(spUnknown, m_spIDataObject);
    if(sc)
        return sc;

    if (pViewData->AllowViewCustomization())
    {
        // "Customize" menu item
        sc = ScAddSeparator( lInsertID);
        if(sc)
            return sc;

        sc = ScAddMenuItem( IDS_CUSTOMIZE, szCUSTOMIZE, MID_CUSTOMIZE, lInsertID);
        if(sc)
            return sc;
    }

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScAddMenuItemsforFavorites
 *
 * PURPOSE:   Adds items for the Favorites menu
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScAddMenuItemsforFavorites()
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScAddMenuItemsforFavorites"));

    sc = ScCheckPointers(m_pNode, E_UNEXPECTED);
    if(sc)
        return sc;

    CViewData*  pViewData = m_pNode->GetViewData();
    sc = ScCheckPointers(pViewData, E_UNEXPECTED);
    if(sc)
        return sc;

    if (pViewData->IsAuthorMode())
    {
        sc = ScAddMenuItem( IDS_ORGANIZEFAVORITES, szORGANIZE_FAVORITES, MID_ORGANIZE_FAVORITES);
        if(sc)
            return sc;

        sc = ScAddSeparator();
        if(sc)
            return sc;
    }

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScAddMenuItemsForVerbSets
 *
 * PURPOSE: Adds the built-in menu items for the verbs
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScAddMenuItemsForVerbSets()
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScAddMenuItemsForVerbSets"));

    // Add print menu item
    sc = ScAddSeparator();
    if(sc)
        return sc;


    if (IsVerbEnabled(MMC_VERB_CUT) == TRUE)
    {
        sc = ScAddMenuItem( IDS_CUT, szCUT, MID_CUT);
        if(sc)
            return sc;
    }

    if (IsVerbEnabled(MMC_VERB_COPY) == TRUE)
    {
        sc = ScAddMenuItem( IDS_COPY, szCOPY, MID_COPY);
        if(sc)
            return sc;
    }

    if (IsVerbEnabled(MMC_VERB_PASTE) == TRUE)
    {
        sc = ScAddMenuItem( IDS_PASTE, szPASTE, MID_PASTE);
        if(sc)
            return sc;
    }

    if (IsVerbEnabled(MMC_VERB_DELETE) == TRUE)
    {
        sc = ScAddMenuItem( IDS_DELETE, szDELETE, MID_DELETE);
        if(sc)
            return sc;
    }

    if (IsVerbEnabled(MMC_VERB_PRINT) == TRUE)
    {
        sc = ScAddMenuItem( IDS_PRINT, szPRINT, MID_PRINT);
        if(sc)
            return sc;
    }

    if (IsVerbEnabled(MMC_VERB_RENAME) == TRUE)
    {
        sc = ScAddMenuItem( IDS_RENAME, szRENAME, MID_RENAME);
        if(sc)
            return sc;
    }

    if (IsVerbEnabled(MMC_VERB_REFRESH) == TRUE)
    {
        sc = ScAddMenuItem( IDS_REFRESH, szREFRESH, MID_REFRESH);
        if(sc)
            return sc;
    }

    // NOT A VERB | NOT A VERB | NOT A VERB | NOT A VERB | NOT A VERB | NOT A VERB | NOT A VERB | NOT A VERB

    // In the verb add command because it is diaplayed next to the verbs

    // Send a message to the list asking if it has anything on it.
    // If so, display the 'save list' item

    if (PContextInfo()->m_dwFlags & CMINFO_SHOW_SAVE_LIST)
    {
        sc = ScAddMenuItem( IDS_SAVE_LIST, szSAVE_LIST, MID_LISTSAVE);
        if(sc)
            return sc;
    }

    // NOT A VERB | NOT A VERB | NOT A VERB | NOT A VERB | NOT A VERB | NOT A VERB | NOT A VERB | NOT A VERB

    sc = ScAddSeparator();
    if(sc)
        return sc;

    // Ask the node whether it will put up property pages. If so add the
    // "Properties" menu item
    if (IsVerbEnabled(MMC_VERB_PROPERTIES) == TRUE)
    {
		// Do not make properties bold for scope items.
		bool bScopeItemInScopePane = (CMINFO_DO_SCOPEPANE_MENU & m_ContextInfo.m_dwFlags);
		bool bEnablePropertiesAsDefaultMenu = ( (m_eDefaultVerb == MMC_VERB_PROPERTIES) && (! bScopeItemInScopePane) );

        sc = ScAddMenuItem( IDS_PROPERTIES, szPROPERTIES, MID_PROPERTIES, 0,
                            bEnablePropertiesAsDefaultMenu ? MF_DEFAULT : 0);
        if(sc)
            return sc;


        sc = ScAddSeparator();
        if(sc)
            return sc;
    }

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScAddMenuItemsForTreeItem
 *
 * PURPOSE: Adds menu items for a scope node in the tree
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScAddMenuItemsForTreeItem()
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScAddMenuItemsForTreeItem"));

    sc = ScCheckPointers(m_pNode);
    if(sc)
        return sc;

    CMTNode*    pMTNode   = m_pNode->GetMTNode();
    CViewData*  pViewData = m_pNode->GetViewData();

    sc = ScCheckPointers(pMTNode, pViewData);
    if(sc)
        return sc;

    // Show Open item if enabled or forced by caller
    if ( IsVerbEnabled(MMC_VERB_OPEN) == TRUE ||
         PContextInfo()->m_dwFlags & CMINFO_SHOW_SCOPEITEM_OPEN )
    {
        sc = ScAddMenuItem( IDS_OPEN, szOPEN, MID_OPEN, 0,
                           (m_eDefaultVerb == MMC_VERB_OPEN) ? MF_DEFAULT : 0);
        if(sc)
            return sc;
    }

    sc = ScAddInsertionPoint(CCM_INSERTIONPOINTID_PRIMARY_TOP);
    if(sc)
        return sc;

    sc = ScAddSeparator();
    if(sc)
        return sc;

    // Add "Create New" menu item
    sc = ScAddSubmenu_CreateNew(m_pNode->IsStaticNode());
    if(sc)
        return sc;

    // Add "Task" menu item
    sc = ScAddSubmenu_Task();
    if(sc)
        return sc;

    sc = ScAddSeparator();
    if(sc)
        return sc;

    // Show the view menu
    if (PContextInfo()->m_dwFlags & CMINFO_SHOW_VIEW_ITEMS)
    {
        sc = ScAddMenuItemsForViewMenu(MENU_LEVEL_SUB);
        if(sc)
            return sc;
    }

    // New window is allowed only if the view allows customization and
    // it is not SDI user mode.
    if (m_pNode->AllowNewWindowFromHere() && !pViewData->IsUser_SDIMode())
        ScAddMenuItem( IDS_EXPLORE, szEXPLORE, MID_EXPLORE);


    // Taskpad editing only allowed in author mode and for node that owns the view
    if (pViewData->IsAuthorMode() && (PContextInfo()->m_dwFlags & CMINFO_SHOW_VIEWOWNER_ITEMS))
    {
        // add the "New Taskpad..." menu item
        sc = ScAddSeparator();
        if(sc)
            return sc;

        sc = ScAddMenuItem( IDS_NEW_TASKPAD_FROM_HERE, szNEW_TASKPAD_FROM_HERE,
                           MID_NEW_TASKPAD_FROM_HERE);
        if(sc)
            return sc;


        // add the "Edit Taskpad" and "Delete Taskpad" menus item if the callback pointer is non-null.
        if ((pViewData->m_spTaskCallback != NULL) &&
			(pViewData->m_spTaskCallback->IsEditable() == S_OK))
        {
            sc = ScAddMenuItem( IDS_EDIT_TASKPAD,   szEDIT_TASKPAD,   MID_EDIT_TASKPAD);
            if(sc)
                return sc;

            sc = ScAddMenuItem( IDS_DELETE_TASKPAD, szDELETE_TASKPAD, MID_DELETE_TASKPAD);
            if(sc)
                return sc;

        }
    }

    sc = ScAddMenuItemsForVerbSets();
    if(sc)
        return sc;

    // Ask the snap-ins to add there menu items.
    CComponentData* pCCD = pMTNode->GetPrimaryComponentData();

    if (m_spIDataObject == NULL)
    {
         sc = pMTNode->QueryDataObject(CCT_SCOPE, &m_spIDataObject);
         if(sc)
             return sc;
    }

    //ASSERT(m_pNode->GetPrimaryComponent() != NULL);
    //IUnknownPtr spUnknown = m_pNode->GetPrimaryComponent()->GetIComponent();
    // TODO: This is temporary. All context menu notifications should
    // go to IComponent's in the future.
    IUnknownPtr spUnknown = pCCD->GetIComponentData();
    ASSERT(spUnknown != NULL);

    sc = AddPrimaryExtensionItems(spUnknown, m_spIDataObject);
    if(sc)
        return sc;


    sc = AddThirdPartyExtensionItems(m_spIDataObject);
    if(sc)
        return sc;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScAddMenuItemsForMultiSelect
 *
 * PURPOSE: Menu for use when multiple items are selected and the right mouse button is pressed
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScAddMenuItemsForMultiSelect()
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScAddMenuItemsForMultiSelect"));

    sc = EmptyMenuList();
    if(sc)
        return sc;


    sc = ScAddInsertionPoint(CCM_INSERTIONPOINTID_PRIMARY_TOP);
    if(sc)
        return sc;

    sc = ScAddSeparator();
    if(sc)
        return sc;

    // no Create New menu for result items
    sc = ScAddSubmenu_Task();
    if(sc)
        return sc;

    sc = ScAddMenuItemsForVerbSets();
    if(sc)
        return sc;

    {
        ASSERT(m_pNode != NULL);
        sc = ScCheckPointers(m_pNode, E_UNEXPECTED);
        if(sc)
            return sc;

        sc = ScCheckPointers(m_pNode->GetViewData(), E_UNEXPECTED);
        if(sc)
            return sc;

        CMultiSelection* pMS = m_pNode->GetViewData()->GetMultiSelection();
        if (pMS != NULL)
        {
            IDataObjectPtr spIDataObject;
            sc = pMS->GetMultiSelDataObject(&spIDataObject);
            if(sc)
                return sc;

            CSnapIn* pSI = m_pNode->GetPrimarySnapIn();
            if (pSI != NULL &&
                pMS->IsAnExtensionSnapIn(pSI->GetSnapInCLSID()) == TRUE)
            {
                sc = ScCheckPointers(m_pNode->GetPrimaryComponent(), E_UNEXPECTED);
                if(sc)
                    return sc;

                IComponent* pIComponent = m_pNode->GetPrimaryComponent()->GetIComponent();

                sc = AddPrimaryExtensionItems(pIComponent, spIDataObject);
                if(sc)
                    return sc;
            }

            sc = AddMultiSelectExtensionItems(reinterpret_cast<LONG_PTR>(pMS));
            if(sc)
                return sc;
        }
    }

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScAddMenuItemsForOCX
 *
 * PURPOSE: This method will be called if there is an OCX in
 *          Result pane and some thing is selected in OCX and
 *          the user clicked "Action" menu.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScAddMenuItemsForOCX()
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScAddMenuItemsForOCX"));

    LPCOMPONENT pIComponent = NULL;    // IComponent interface to the snap-in
    CComponent* pComponent  = NULL;    // Internal component structure
    MMC_COOKIE cookie;

    sc = ScCheckPointers(m_pNode, E_UNEXPECTED);
    if(sc)
        return sc;

    sc = EmptyMenuList();
    if(sc)
        return sc;

    if (IsVerbEnabled(MMC_VERB_OPEN) == TRUE)
    {
        sc = ScAddMenuItem( IDS_OPEN, szOPEN, MID_OPEN, 0,
                           (m_eDefaultVerb == MMC_VERB_OPEN) ? MF_DEFAULT : 0);
        if(sc)
            return sc;
    }

    sc = ScAddInsertionPoint(CCM_INSERTIONPOINTID_PRIMARY_TOP);
    if(sc)
        return sc;

    sc = ScAddSeparator();
    if(sc)
        return sc;

    // no Create New menu for result items
    sc = ScAddSubmenu_Task();
    if(sc)
        return sc;

    sc = ScAddMenuItemsForVerbSets();
    if(sc)
        return sc;

    sc = ScAddSeparator();
    if(sc)
        return sc;

    LPDATAOBJECT lpDataObj = (m_pNode->GetViewData()->HasOCX()) ?
                             DOBJ_CUSTOMOCX : DOBJ_CUSTOMWEB;

    // Item must be from primary component
    pComponent = m_pNode->GetPrimaryComponent();
    sc = ScCheckPointers(pComponent, E_UNEXPECTED);
    if(sc)
        return sc;

    pIComponent = pComponent->GetIComponent();
    sc = ScCheckPointers(pIComponent, E_UNEXPECTED);
    if(sc)
        return sc;

    sc = AddPrimaryExtensionItems(pIComponent, lpDataObj);
    if(sc)
        return sc;


    return TRUE;
}

/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScAddMenuItemsForLV
 *
 * PURPOSE: Add menu items for a list view item
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScAddMenuItemsForLV()
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScAddMenuItemsForLV"));

    LPCOMPONENT pIComponent;    // IComponet interface to the snap-in
    CComponent* pComponent;     // Internal component structure
    MMC_COOKIE cookie;

    ASSERT(m_pNode != NULL);
    sc = ScCheckPointers(m_pNode, E_UNEXPECTED);
    if (sc)
        return sc;

    // if virtual list
    if (m_pNode->GetViewData()->IsVirtualList())
    {
        // ItemParam is the item index, use it as the cookie
        cookie = PContextInfo()->m_resultItemParam;

        // Item must be from primary component
        pComponent = m_pNode->GetPrimaryComponent();
    }
    else
    {
        // ItemParam is list item data, get cookie and component ID from it
        ASSERT(PContextInfo()->m_resultItemParam != 0);
        CResultItem* pri = GetResultItem();

        if (pri != NULL)
        {
            ASSERT(!pri->IsScopeItem());

            cookie = pri->GetSnapinData();
            pComponent = m_pNode->GetComponent(pri->GetOwnerID());
        }
    }

    sc = ScCheckPointers(pComponent, E_UNEXPECTED);
    if(sc)
        return sc;

    pIComponent = pComponent->GetIComponent();

    sc = ScCheckPointers(pIComponent);
    if(sc)
        return sc;

    // Load the IDataObject for the snap-in's cookie
    if (m_spIDataObject == NULL)
    {
        sc = pIComponent->QueryDataObject(cookie, CCT_RESULT, &m_spIDataObject);
        if(sc)
            return sc;
    }

    sc = EmptyMenuList();
    if(sc)
        return sc;

    if (IsVerbEnabled(MMC_VERB_OPEN) == TRUE)
    {
        sc = ScAddMenuItem( IDS_OPEN, szOPEN, MID_OPEN, 0, (m_eDefaultVerb == MMC_VERB_OPEN) ? MF_DEFAULT : 0);
        if(sc)
            return sc;
    }

    sc = ScAddInsertionPoint(CCM_INSERTIONPOINTID_PRIMARY_TOP);
    if(sc)
        return sc;

    sc = ScAddSeparator();
    if(sc)
        return sc;

        // no Create New menu for result items
    sc = ScAddSubmenu_Task();
    if(sc)
        return sc;

    sc = ScAddMenuItemsForVerbSets();
    if(sc)
        return sc;

    sc = ScAddSeparator();
    if(sc)
        return sc;

    sc = AddPrimaryExtensionItems(pIComponent, m_spIDataObject);
    if(sc)
        return sc;

    sc = AddThirdPartyExtensionItems(m_spIDataObject);
    if(sc)
        return sc;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScAddMenuItemsForLVBackgnd
 *
 * PURPOSE: This handles a right mouse click on the result pane side (Assuming our listview)
 *          It displays also adds the currently selected folders context menu items
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScAddMenuItemsForLVBackgnd()
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScAddMenuItemsForLVBackgnd"));

    sc = ScCheckPointers(m_pNode, E_UNEXPECTED);
    if(sc)
        return sc;

    sc = EmptyMenuList();
    if(sc)
        return sc;

    sc = ScAddInsertionPoint(CCM_INSERTIONPOINTID_PRIMARY_TOP);
    if(sc)
        return sc;

    sc = ScAddSeparator();
    if(sc)
        return sc;

    sc = ScAddSubmenu_CreateNew(m_pNode->IsStaticNode());
    if(sc)
        return sc;

    sc = ScAddSubmenu_Task();
    if(sc)
        return sc;

    sc = ScAddSeparator();
    if(sc)
        return sc;

   // Add relevant standard verbs.
    if (IsVerbEnabled(MMC_VERB_PASTE) == TRUE)
    {
        sc = ScAddMenuItem( IDS_PASTE, szPASTE, MID_PASTE);
        if(sc)
            return sc;
    }

    if (IsVerbEnabled(MMC_VERB_REFRESH) == TRUE)
    {
        sc = ScAddMenuItem( IDS_REFRESH, szREFRESH, MID_REFRESH);
        if(sc)
            return sc;
    }

    // Displays the save list icon if necessary
    if ((PContextInfo()->m_pConsoleView != NULL) &&
        (PContextInfo()->m_pConsoleView->GetListSize() > 0))
    {
        sc = ScAddMenuItem( IDS_SAVE_LIST, szSAVE_LIST, MID_LISTSAVE);
        if(sc)
            return sc;
    }

    sc = ScAddSeparator();
    if(sc)
        return sc;

    // Add view submenu
    sc = ScAddMenuItemsForViewMenu(MENU_LEVEL_SUB);
    if(sc)
        return sc;

    // Add Arrange Icons
    sc = ScAddSeparator();
    if(sc)
        return sc;

    sc = ScAddMenuItem( IDS_ARRANGE_ICONS, szARRANGE_ICONS, MID_ARRANGE_ICONS, 0, MF_POPUP);
    if(sc)
        return sc;

    long lStyle = 0;
    if (PContextInfo()->m_spListView)
    {
        lStyle = PContextInfo()->m_spListView->GetListStyle();
        ASSERT(lStyle != 0);
    }


        // auto arrange
    sc = ScAddMenuItem( IDS_ARRANGE_AUTO, szARRANGE_AUTO, MID_ARRANGE_AUTO, MID_ARRANGE_ICONS,
                       ((lStyle & LVS_AUTOARRANGE) ? MF_CHECKED : MF_UNCHECKED));
    if(sc)
        return sc;

    sc = ScAddMenuItem( IDS_LINE_UP_ICONS, szLINE_UP_ICONS, MID_LINE_UP_ICONS);
    if(sc)
        return sc;

// Ask the node whether it will put up property pages. If so add the
// "Properties" menu item
    if (IsVerbEnabled(MMC_VERB_PROPERTIES) == TRUE)
    {
        sc = ScAddMenuItem( IDS_PROPERTIES, szPROPERTIES, MID_PROPERTIES);
        if(sc)
            return sc;

        sc = ScAddSeparator();
        if(sc)
            return sc;
    }


    // if there is a valid data object we would have gotten it when adding the
    // view menu itmes, so we don't need to duplicate the code to get it here
    if (m_spIDataObject != NULL)
    {
        CComponent* pCC = m_pNode->GetPrimaryComponent();
        sc = ScCheckPointers(pCC, E_UNEXPECTED);
        if(sc)
            return sc;

        IUnknownPtr spUnknown = pCC->GetIComponent();
        sc = ScCheckPointers(spUnknown);
        if(sc)
            return sc;

        sc = AddPrimaryExtensionItems(spUnknown, m_spIDataObject);
        if(sc)
            return sc;

        sc = AddThirdPartyExtensionItems(m_spIDataObject);
        if(sc)
            return sc;
    }

    return sc;
}

void OnCustomizeView(CViewData* pViewData)
{
    CCustomizeViewDialog dlg(pViewData);
    dlg.DoModal();
}


/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::AddMenuItems
 *
 * PURPOSE: Unimplemented, but needed because this class implements
 *          IExtendContextMenu
 *
 * PARAMETERS:
 *    LPDATAOBJECT           pDataObject :
 *    LPCONTEXTMENUCALLBACK  pCallback :
 *    long *                 pInsertionAllowed :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScAddMenuItems( LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pCallback, long * pInsertionAllowed)
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScAddMenuItems"));
    ASSERT(0 && "Should not come here!");
    return sc = E_UNEXPECTED;
}


/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::Command
 *
 * PURPOSE: Handles the built- in menu item execution.
 *
 * PARAMETERS:
 *    long          lCommandID :
 *    LPDATAOBJECT  pDataObject :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScCommand(long lCommandID, LPDATAOBJECT pDataObject)
{
    DECLARE_SC(sc, TEXT("CContextMenu::Command"));

    CNodeCallback * pNodeCallback=GetNodeCallback();
    sc = ScCheckPointers(pNodeCallback, E_UNEXPECTED);
    if(sc)
        return sc;

    /*+-------------------------------------------------------------------------*/
    // special case: MID_CONTEXTHELP: m_pNode can be NULL when help clicked on scope node background,
    // so we handle this first.
    if(MID_CONTEXTHELP == lCommandID)
    {
        sc = ScCheckPointers(PContextInfo());
        if(sc)
            return sc;

        CConsoleView*   pConsoleView = PContextInfo()->m_pConsoleView;
        sc = ScCheckPointers(pConsoleView);
        if(sc)
            return sc;

        if (PContextInfo()->m_bMultiSelect)
        {
            sc = pConsoleView->ScContextHelp ();
            if(sc)
                return sc;
        }
        else
        {
            sc = pNodeCallback->Notify(CNode::ToHandle(m_pNode), NCLBK_CONTEXTHELP,
                                             ((PContextInfo()->m_eDataObjectType == CCT_SCOPE) ||
                                              (PContextInfo()->m_bBackground == TRUE)),
                                             PContextInfo()->m_resultItemParam);

            // if snap-in did not handle the help request, show mmc topics
            if (sc.ToHr() != S_OK)
                sc = PContextInfo()->m_pConsoleView->ScHelpTopics ();

            return sc;
        }

        return sc;
    }
    /*+-------------------------------------------------------------------------*/


    // must have a non-null m_pNode.
    sc = ScCheckPointers(m_pNode);
    if(sc)
        return sc;

    HNODE           hNode       = CNode::ToHandle(m_pNode);
    BOOL            bModeChange = FALSE;
    int             nNewMode;

    // some widely used objects
    CViewData *     pViewData   = m_pNode->GetViewData();
    sc = ScCheckPointers(pViewData);
    if(sc)
        return sc;

    CConsoleFrame*  pFrame      = pViewData->GetConsoleFrame();
    CMTNode*        pMTNode     = m_pNode->GetMTNode();
    CConsoleView*   pConsoleView= pViewData->GetConsoleView();

    sc = ScCheckPointers(pFrame, pMTNode, pConsoleView, E_UNEXPECTED);
    if(sc)
        return sc;

    // handle the correct item
    switch (lCommandID)
    {

    case MID_RENAME:
        sc = pConsoleView->ScOnRename(PContextInfo());
        if(sc)
            return sc;
        break;

    case MID_REFRESH:
        {
            BOOL bScope = ( (PContextInfo()->m_eDataObjectType == CCT_SCOPE) ||
                            (PContextInfo()->m_bBackground == TRUE) );

            sc = pConsoleView->ScOnRefresh(hNode, bScope, PContextInfo()->m_resultItemParam);
            if(sc)
                return sc;
        }
        break;

    case MID_LINE_UP_ICONS:
        sc = pConsoleView->ScLineUpIcons();
        if(sc)
            return sc;
        break;

    case MID_ARRANGE_AUTO:
        sc = pConsoleView->ScAutoArrangeIcons();
        if(sc)
            return sc;
        break;


    case MID_ORGANIZE_FAVORITES:
        sc = pConsoleView->ScOrganizeFavorites();
        if(sc)
            return sc;
        break;


    case MID_DELETE:
        {
            bool  bScope                             = (CCT_SCOPE == PContextInfo()->m_eDataObjectType);
            bool  bScopeItemInResultPane             = PContextInfo()->m_dwFlags & CMINFO_SCOPEITEM_IN_RES_PANE;
            bool  bScopeItemInScopePaneOrResultPane  = bScope || bScopeItemInResultPane;

            LPARAM lvData = PContextInfo()->m_resultItemParam;

            if (PContextInfo()->m_bBackground)
                lvData = LVDATA_BACKGROUND;
            else if (PContextInfo()->m_bMultiSelect)
                lvData = LVDATA_MULTISELECT;

            sc = pNodeCallback->Notify(hNode, NCLBK_DELETE,
                      bScopeItemInScopePaneOrResultPane ,
                      lvData);
            if(sc)
                return sc;
            break;
        }


    case MID_NEW_TASKPAD_FROM_HERE:
        sc = pNodeCallback->Notify(hNode, NCLBK_NEW_TASKPAD_FROM_HERE, 0, 0);
        if(sc)
            return sc;
        break;

    case MID_EDIT_TASKPAD:
        sc = pNodeCallback->Notify(hNode, NCLBK_EDIT_TASKPAD, 0, 0);
        if(sc)
            return sc;
        break;

    case MID_DELETE_TASKPAD:
        sc = pNodeCallback->Notify(hNode, NCLBK_DELETE_TASKPAD, 0, 0);
        if(sc)
            return sc;
        break;

    case MID_EXPLORE:       // New window from here
        {
            try
            {
                CreateNewViewStruct cnvs;
                cnvs.idRootNode     = pMTNode->GetID();
                cnvs.lWindowOptions = MMC_NW_OPTION_NONE;
                cnvs.fVisible       = true;

                sc = pFrame->ScCreateNewView(&cnvs);
                if(sc)
                    return sc;
            }
            catch (...)
            {
                sc = E_FAIL;
                ASSERT(0 && "NewWindow invalid scope item");
                return sc;
            }
        }
        break;

    case MID_OPEN:
        {
            sc = pConsoleView->ScSelectNode (pMTNode->GetID());
            if(sc)
                return sc;
        }
        break;

    case MID_PROPERTIES:
        if (NULL == m_pNode)
            return (sc = E_UNEXPECTED);

        sc = ScDisplaySnapinPropertySheet();
        if(sc)
            return sc;

        break;

    case MID_VIEW_LARGE:
        bModeChange = TRUE;
        nNewMode = LVS_ICON;
        break;

    case MID_VIEW_SMALL:
        bModeChange = TRUE;
        nNewMode = LVS_SMALLICON;
        break;

    case MID_VIEW_LIST:
        bModeChange = TRUE;
        nNewMode = LVS_LIST;
        break;

    case MID_VIEW_DETAIL:
        bModeChange = TRUE;
        nNewMode = LVS_REPORT;
        break;

    case MID_VIEW_FILTERED:
        bModeChange = TRUE;
        nNewMode = MMCLV_VIEWSTYLE_FILTERED;
        break;

    case MID_CUT:
        sc = pNodeCallback->Notify(CNode::ToHandle(m_pNode), NCLBK_CUT,
                                         (PContextInfo()->m_eDataObjectType == CCT_SCOPE),
                                         PContextInfo()->m_resultItemParam);
        if(sc)
            return sc;

        sc = pConsoleView->ScCut (PContextInfo()->m_htiRClicked);
        if(sc)
            return sc;

        break;

    case MID_COPY:
        sc = pNodeCallback->Notify(CNode::ToHandle(m_pNode), NCLBK_COPY,
                                         (PContextInfo()->m_eDataObjectType == CCT_SCOPE),
                                         PContextInfo()->m_resultItemParam);
        if(sc)
            return sc;
        break;

    case MID_PASTE:
        sc = pNodeCallback->Paste(CNode::ToHandle(m_pNode),
                                  ((PContextInfo()->m_eDataObjectType == CCT_SCOPE) ||
                                   (PContextInfo()->m_bBackground == TRUE)),
                                  PContextInfo()->m_resultItemParam);

        if(sc)
            return sc;

        sc = pConsoleView->ScPaste ();
        if(sc)
            return sc;

        break;

    case MID_COLUMNS:
        ASSERT(m_pNode);
        if (m_pNode)
            m_pNode->OnColumns();
        break;

    case MID_LISTSAVE:
        // If the listsave menu item has been activated, then tell the view to
        // save the active list
        sc = pConsoleView->ScSaveList();
        if(sc)
            return sc;

        break;

    case MID_PRINT:
        sc = pNodeCallback->Notify(CNode::ToHandle(m_pNode), NCLBK_PRINT,
                                         ((PContextInfo()->m_eDataObjectType == CCT_SCOPE) ||
                                          (PContextInfo()->m_bBackground == TRUE)),
                                         PContextInfo()->m_resultItemParam);
        if(sc)
            return sc;
        break;

    case MID_CUSTOMIZE:
        if (pViewData)
            OnCustomizeView(pViewData);
        break;


    default:
        ASSERT(0 && "Should not come here");
        break;

    }

    if (bModeChange)
    {
        sc = ScChangeListViewMode(nNewMode);
        if(sc)
            return sc;
    }

    return sc;
}



/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScChangeListViewMode
 *
 * PURPOSE: Changes the list view mode to the specified  mode.
 *
 * PARAMETERS:
 *    int  nNewMode : The mode to change to.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScChangeListViewMode(int nNewMode)
{

    DECLARE_SC(sc, TEXT("CContextMenu::ScChangeListViewMode"));

    sc = ScCheckPointers(m_pNode, E_UNEXPECTED);
    if(sc)
        return sc;

    // If switching from a snapin custom to a standard listview
    // send snapin a notification command
    if ((PContextInfo()->m_spListView == NULL))
    {
        sc = ScCheckPointers(m_spIDataObject.GetInterfacePtr(), E_UNEXPECTED);
        if(sc)
            return sc;

        CComponent* pCC = m_pNode->GetPrimaryComponent();
        sc = ScCheckPointers(pCC, E_UNEXPECTED);
        if(sc)
            return sc;

        IExtendContextMenuPtr spIExtendContextMenu = pCC->GetIComponent();
        if(spIExtendContextMenu)
		{
			try
			{
				sc = spIExtendContextMenu->Command(MMCC_STANDARD_VIEW_SELECT, m_spIDataObject);
				if(sc)
					return sc;
			}
			catch ( std::bad_alloc )
			{
				return (sc = E_OUTOFMEMORY);
			}
			catch ( std::exception )
			{
				return (sc = E_UNEXPECTED);
			}
		}
    }

    CViewData *pViewData = m_pNode->GetViewData();
    sc = ScCheckPointers(pViewData, E_UNEXPECTED);
    if (sc)
        return sc;

    // Persist the new mode.
    sc = m_pNode->ScSetViewMode(nNewMode);
    if (sc)
        return sc;

    // tell conui to change the list mode.
    CConsoleView* pConsoleView = pViewData->GetConsoleView();
    sc = ScCheckPointers(pConsoleView, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = pConsoleView->ScChangeViewMode (nNewMode);
    if (sc)
        return sc;

    return sc;
}



/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScAddSubmenu_Task
 *
 * PURPOSE: Adds the Task submenu
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScAddSubmenu_Task()
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScAddSubmenu_Task"));
    sc = ScAddMenuItem(IDS_TASK, szTASK, MID_TASK, 0, MF_POPUP);
    if(sc)
        return sc;

    sc = ScAddInsertionPoint(CCM_INSERTIONPOINTID_PRIMARY_TASK, MID_TASK);
    if(sc)
        return sc;

    sc = ScAddSeparator( MID_TASK );
    if(sc)
        return sc;

    sc = ScAddInsertionPoint(CCM_INSERTIONPOINTID_3RDPARTY_TASK, MID_TASK);
    if(sc)
        return sc;

    sc = ScAddSeparator( MID_TASK);
    if(sc)
        return sc;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScAddSubmenu_CreateNew
 *
 * PURPOSE: Adds the New submenu
 *
 * PARAMETERS:
 *    BOOL  fStaticFolder :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScAddSubmenu_CreateNew(BOOL fStaticFolder)
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScAddSubmenu_CreateNew"));

    sc = ScAddMenuItem(IDS_CREATE_NEW, szCREATE_NEW, MID_CREATE_NEW, 0, MF_POPUP);
    if(sc)
        return sc;

    sc = ScAddInsertionPoint(CCM_INSERTIONPOINTID_PRIMARY_NEW, MID_CREATE_NEW);
    if(sc)
        return sc;

    sc = ScAddSeparator( MID_CREATE_NEW);
    if(sc)
        return sc;

    sc = ScAddInsertionPoint(CCM_INSERTIONPOINTID_3RDPARTY_NEW, MID_CREATE_NEW);
    if(sc)
        return sc;

    sc = ScAddSeparator( MID_CREATE_NEW);
    if(sc)
        return sc;

    return sc;
}



/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ScDisplaySnapinPropertySheet
 *
 * PURPOSE:
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenu::ScDisplaySnapinPropertySheet()
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScDisplaySnapinPropertySheet"));

    sc = ScCheckPointers(m_pNode, E_UNEXPECTED);
    if (sc)
        return sc;

    if (CCT_SCOPE == PContextInfo()->m_eDataObjectType ||
        PContextInfo()->m_bBackground == TRUE)
    {
        sc = ScDisplaySnapinNodePropertySheet(m_pNode);
        if(sc)
            return sc;
    }
    else
    {
        // Get the view type.
        ASSERT(m_pNode->GetViewData());
        CViewData *pViewData = m_pNode->GetViewData();

        if (PContextInfo()->m_bMultiSelect)
        {
            // Must be in the result pane.
            sc = ScDisplayMultiSelPropertySheet(m_pNode);
            if(sc)
                return sc;
        }
        else if (m_pNode->GetViewData()->IsVirtualList())
        {
            // if virtual list, must be leaf item and resultItemParam is the cookie
            sc = ScDisplaySnapinLeafPropertySheet(m_pNode, PContextInfo()->m_resultItemParam);
            if(sc)
                return sc;
        }
        else if( (pViewData->HasOCX()) || (pViewData->HasWebBrowser()) )
        {
            LPDATAOBJECT pdobj = (pViewData->HasOCX()) ? DOBJ_CUSTOMOCX
                                                              : DOBJ_CUSTOMWEB;
            CComponent* pCC = m_pNode->GetPrimaryComponent();
            ASSERT(pCC != NULL);

            // The custom view was selected and "properties" was selected from "Action Menu".
            // We dont know anything about the view, so we fake "Properties" button click.
            pCC->Notify(pdobj, MMCN_BTN_CLICK, 0, MMC_VERB_PROPERTIES);
        }
        else
        {
            CResultItem* pri = GetResultItem();

            if (pri != NULL)
            {
                if (pri->IsScopeItem())
                {
                    sc = ScDisplaySnapinNodePropertySheet(m_pNode);
                    if(sc)
                        return sc;
                }
                else
                {
                    sc = ScDisplaySnapinLeafPropertySheet(m_pNode, pri->GetSnapinData());
                    if(sc)
                        return sc;
                }
            }
        }
    }

    return sc;
}

/************************************************************************
 * -----------------------------------------
 * Order:  Calling function
 *         Called function 1
 *         Called function 2
 * -----------------------------------------
 *
 *
 * CContextMenu::ProcessSelection()
 *     CContextMenu::ScDisplaySnapinPropertySheet()
 *                 ScDisplaySnapinNodePropertySheet(CNode* pNode)
 *                     ScDisplaySnapinPropertySheet
 *                         FindPropertySheet
 *                 ScDisplayMultiSelPropertySheet(CNode* pNode)
 *                     ScDisplaySnapinPropertySheet
 *                         FindPropertySheet
 *                 ScDisplaySnapinLeafPropertySheet(CNode* pNode, LPARAM lParam)
 *                     ScDisplaySnapinPropertySheet
 *                         FindPropertySheet
 *
 * CNodeCallback::OnProperties(CNode* pNode, BOOL bScope, LPARAM lvData)
 *     ScDisplaySnapinNodePropertySheet(CNode* pNode)
 *         ScDisplaySnapinPropertySheet
 *             FindPropertySheet
 *     ScDisplayMultiSelPropertySheet(CNode* pNode)
 *         ScDisplaySnapinPropertySheet
 *             FindPropertySheet
 *     ScDisplaySnapinLeafPropertySheet(CNode* pNode, LPARAM lParam)
 *         ScDisplaySnapinPropertySheet
 *             FindPropertySheet
 ************************************************************************/


SC ScDisplaySnapinPropertySheet(IComponent* pComponent,
                                IComponentData* pComponentData,
                                IDataObject* pDataObject,
                                EPropertySheetType type,
                                LPCWSTR pName,
                                LPARAM lUniqueID,
                                CMTNode* pMTNode);
//--------------------------------------------------------------------------

SC ScDisplaySnapinNodePropertySheet(CNode* pNode)
{
    DECLARE_SC(sc, TEXT("ScDisplaySnapinNodePropertySheet"));

    sc = ScCheckPointers(pNode, E_UNEXPECTED);
    if(sc)
        return sc;

    sc = ScDisplayScopeNodePropertySheet(pNode->GetMTNode());
    if(sc)
        return sc;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * ScDisplayScopeNodePropertySheet
 *
 * PURPOSE:  Displays a property sheet for a scope node.
 *
 * PARAMETERS:
 *    CMTNode * pMTNode : The scope node.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
ScDisplayScopeNodePropertySheet(CMTNode *pMTNode)
{
    DECLARE_SC(sc, TEXT("ScDisplayScopeNodePropertySheet"));

    IDataObjectPtr spIDataObject;
    sc = pMTNode->QueryDataObject(CCT_SCOPE, &spIDataObject);
    if(sc)
        return sc;

    CComponentData* pCCD = pMTNode->GetPrimaryComponentData();
    sc = ScCheckPointers(pCCD);
    if(sc)
        return sc;

    LPARAM lUniqueID = CMTNode::ToScopeItem(pMTNode);
	tstring strName = pMTNode->GetDisplayName();

	if (strName.empty())
		strName = _T("");

    USES_CONVERSION;
    sc = ScDisplaySnapinPropertySheet(NULL, pCCD->GetIComponentData(),
                               spIDataObject,
                               epstScopeItem,
                               T2CW (strName.data()),
                               lUniqueID,
                               pMTNode);

    return sc;

}

/*+-------------------------------------------------------------------------*
 *
 * ScDisplayMultiSelPropertySheet
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    CNode* pNode :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC ScDisplayMultiSelPropertySheet(CNode* pNode)
{
    DECLARE_SC(sc, TEXT("ScDisplayMultiSelPropertySheet"));

    USES_CONVERSION;

    // check inputs
    sc = ScCheckPointers(pNode);
    if(sc)
        return sc;

    sc = ScCheckPointers(pNode->GetViewData(), E_UNEXPECTED);
    if(sc)
        return sc;

    CMultiSelection* pMS = pNode->GetViewData()->GetMultiSelection();
    sc = ScCheckPointers(pMS, E_UNEXPECTED);
    if(sc)
        return sc;

    ASSERT(pMS->IsSingleSnapinSelection());
    if (pMS->IsSingleSnapinSelection() == false)
        return (sc = E_UNEXPECTED);

    IDataObjectPtr spIDataObject = pMS->GetSingleSnapinSelDataObject();
    sc = ScCheckPointers(spIDataObject, E_UNEXPECTED);
    if(sc)
        return sc;

    CComponent* pCC = pMS->GetPrimarySnapinComponent();
    sc = ScCheckPointers(pCC, E_UNEXPECTED);
    if(sc)
        return sc;

    LPARAM lUniqueID = reinterpret_cast<LPARAM>(pMS);

    CStr strName;
    strName.LoadString(GetStringModule(), IDS_PROP_ON_MULTIOBJ);
    LPWSTR pwszDispName = T2W((LPTSTR)(LPCTSTR)strName);

    sc = ScDisplaySnapinPropertySheet(pCC->GetIComponent(), NULL,
                               spIDataObject,
                               epstMultipleItems,
                               pwszDispName,
                               lUniqueID,
                               pNode->GetMTNode());
    if(sc)
        return sc;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * ScDisplaySnapinLeafPropertySheet
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    CNode*  pNode :
 *    LPARAM  lParam :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
ScDisplaySnapinLeafPropertySheet(CNode* pNode, LPARAM lParam)
{
    DECLARE_SC(sc, TEXT("ScDisplaySnapinLeafPropertySheet"));

    ASSERT(!(IS_SPECIAL_COOKIE(lParam)));

    sc = ScCheckPointers(pNode);
    if(sc)
        return sc;

    sc = ScCheckPointers(pNode->GetViewData(), E_UNEXPECTED);
    if(sc)
        return sc;

    ASSERT(lParam != 0 || pNode->GetViewData()->IsVirtualList());

    CComponent* pCC = pNode->GetPrimaryComponent();
    sc = ScCheckPointers(pCC, E_UNEXPECTED);
    if(sc)
        return sc;

    IComponent* pIComponent = pCC->GetIComponent();
    sc = ScCheckPointers(pIComponent, E_UNEXPECTED);
    if(sc)
        return sc;

    // Get the IDataObject for the snap-in's cookie
    IDataObjectPtr spIDataObject;
    sc = pIComponent->QueryDataObject(lParam, CCT_RESULT, &spIDataObject);
    if(sc)
        return sc;

    RESULTDATAITEM rdi;
    ZeroMemory(&rdi, sizeof(rdi));

    if (pNode->GetViewData()->IsVirtualList())
        rdi.nIndex = lParam;
    else
        rdi.lParam = lParam;

    rdi.mask = RDI_STR;

    LPWSTR pName = L"";
    sc = pIComponent->GetDisplayInfo(&rdi);
    if (!sc.IsError() && rdi.str != NULL)
        pName = rdi.str;

    sc = ScDisplaySnapinPropertySheet(pIComponent, NULL,
                               spIDataObject,
                               epstResultItem,
                               pName,
                               0,
                               pNode->GetMTNode());
    return sc;
}

/*+-------------------------------------------------------------------------*
 * ScDisplaySnapinPropertySheet
 *
 *
 * PURPOSE:
 *
 *+-------------------------------------------------------------------------*/
SC ScDisplaySnapinPropertySheet(IComponent* pComponent,
                                IComponentData* pComponentData,
                                IDataObject* pDataObject,
                                EPropertySheetType type,
                                LPCWSTR pName,
                                LPARAM lUniqueID,
                                CMTNode* pMTNode)
{
    DECLARE_SC(sc, TEXT("ScDisplaySnapinPropertySheet"));

    // one of pComponent and pComponentData must be non-null
    if(pComponentData == NULL && pComponent == NULL)
        return (sc = E_INVALIDARG);

    // check other parameters
    sc = ScCheckPointers(pDataObject, pName, pMTNode);
    if(sc)
        return sc;

    IUnknown *pUnknown = (pComponent != NULL) ? (IUnknown *)pComponent : (IUnknown *)pComponentData;

    IPropertySheetProviderPrivatePtr spPropSheetProviderPrivate;

    do
    {
        ASSERT(pDataObject != NULL);
        ASSERT(pUnknown != NULL);

        sc = spPropSheetProviderPrivate.CreateInstance(CLSID_NodeInit, NULL, MMC_CLSCTX_INPROC);
        if(sc)
            break;


        sc = ScCheckPointers(spPropSheetProviderPrivate, E_UNEXPECTED);
        if(sc)
            break;

        // See if the prop page for this is already up
        sc = spPropSheetProviderPrivate->FindPropertySheetEx(lUniqueID, pComponent, pComponentData, pDataObject);
        if (sc == S_OK)
            break;

        // No it is not present. So create a property sheet.
        DWORD dwOptions = (type == epstMultipleItems) ? MMC_PSO_NO_PROPTITLE : 0;
        sc = spPropSheetProviderPrivate->CreatePropertySheet(pName, TRUE, lUniqueID, pDataObject, dwOptions);
        if(sc)
            break;

        // This data is used to get path to property sheet owner for tooltips
        spPropSheetProviderPrivate->SetPropertySheetData(type, CMTNode::ToHandle(pMTNode));

        sc = spPropSheetProviderPrivate->AddPrimaryPages(pUnknown, TRUE, NULL,
                                                  (type == epstScopeItem));

//#ifdef EXTENSIONS_CANNOT_ADD_PAGES_IF_PRIMARY_DOESNT
        // note that only S_OK continues execution, S_FALSE breaks out
        if (!(sc == S_OK) ) // ie if sc != S_OK
            break;
//#endif

        // Enable adding extensions
        if (type == epstMultipleItems)
        {
            IPropertySheetProviderPrivatePtr spPSPPrivate = spPropSheetProviderPrivate;
            sc = spPSPPrivate->AddMultiSelectionExtensionPages(lUniqueID);
        }
        else
        {
            sc = spPropSheetProviderPrivate->AddExtensionPages();
        }

        // any errors from extensions are thrown away.

        CWindow w(CScopeTree::GetScopeTree()->GetMainWindow());
        sc = spPropSheetProviderPrivate->Show((LONG_PTR)w.m_hWnd, 0);

    } while (0);

    // Clean up the 'Created' property sheet if there was an error
    if (spPropSheetProviderPrivate != NULL && sc.IsError())
        spPropSheetProviderPrivate->Show(-1, 0);

    return sc;
}


/*+-------------------------------------------------------------------------*
 * CContextMenu::GetResultItem
 *
 * Returns the CResultItem pointer for the result item represented by the
 * context info.
 *
 * This function is out-of-line to eliminate coupling between oncmenu.h and
 * rsltitem.h.
 *--------------------------------------------------------------------------*/

CResultItem* CContextMenu::GetResultItem () const
{
    return (CResultItem::FromHandle (PContextInfo()->m_resultItemParam));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\oncmenu.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       oncmenu.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:
//____________________________________________________________________________
//

#ifndef _MMC_ONCMENU_H_
#define _MMC_ONCMENU_H_
#pragma once

class CNode;
class CNodeCallback;
class CConsoleTree;
class CResultItem;

#include <pshpack8.h>   // Sundown
#include "cmenuinfo.h"
#include "menuitem.h"

//############################################################################
//############################################################################
//
// DEADLOCK PREVENTION:
// A thread holding m_CritsecSnapinList may try to take m_CritsecMenuList
// A thread holding m_CritsecMenuList may NOT try to take m_CritsecSnapinList
//
//############################################################################
//############################################################################


#define START_CRITSEC(critsec)                  \
        CSingleLock lock_##critsec( &critsec ); \
        try {                                   \
            lock_##critsec.Lock();

#define END_CRITSEC(critsec)                    \
        } catch ( std::exception e) {                \
            lock_##critsec.Unlock(); }

#define START_CRITSEC_MENU START_CRITSEC(m_CritsecMenuList)
#define END_CRITSEC_MENU END_CRITSEC(m_CritsecMenuList)
#define START_CRITSEC_SNAPIN START_CRITSEC(m_CritsecSnapinList)
#define END_CRITSEC_SNAPIN END_CRITSEC(m_CritsecSnapinList)

#define START_CRITSEC_BOTH                      \
        CSingleLock lock_snapin( &m_CritsecSnapinList ); \
        CSingleLock lock_menu( &m_CritsecMenuList ); \
        try {                                   \
            lock_snapin.Lock();                 \
            lock_menu.Lock();

#define END_CRITSEC_BOTH                        \
        } catch ( std::exception e) {           \
            lock_menu.Unlock();                 \
            lock_snapin.Unlock(); }


/*+-------------------------------------------------------------------------*
 * class CContextMenu.
 *
 *
 * PURPOSE: Holds a context menu structure, which is a tree of menu items.
 *
 *+-------------------------------------------------------------------------*/
class CContextMenu :
    public CTiedObject,
    public IContextMenuCallback,
    public IContextMenuCallback2,
    public CMMCIDispatchImpl<ContextMenu>
{
protected:

    typedef CContextMenu ThisClass;
    // CMMCNewEnumImpl tmplate needs following type to be defined.
    // see template class comments for more info
    typedef void CMyTiedObject;

public:
    CContextMenu();
    ~CContextMenu();

    static ::SC  ScCreateInstance(ContextMenu **ppContextMenu, CContextMenu **ppCContextMenu = NULL);    // creates a new instance of a context menu.
           ::SC  ScInitialize(CNode* pNode, CNodeCallback* pNodeCallback,
                              CScopeTree* pCScopeTree, const CContextMenuInfo& contextInfo); // initializes a context menu
    static ::SC  ScCreateContextMenu( PNODE pNode,  HNODE hNode, PPCONTEXTMENU ppContextMenu,
                                   CNodeCallback *pNodeCallback, CScopeTree *pScopeTree); // creates and returns a ContextMenu interface for the given node.
    static ::SC  ScCreateContextMenuForScopeNode(CNode *pNode,
                                   CNodeCallback *pNodeCallback, CScopeTree *pScopeTree,
                                   PPCONTEXTMENU ppContextMenu, CContextMenu * &pContextMenu);
    static ::SC  ScCreateSelectionContextMenu( HNODE hNodeScope, const CContextMenuInfo *pContextInfo, PPCONTEXTMENU ppContextMenu,
                                               CNodeCallback *pNodeCallback, CScopeTree *pScopeTree);

    // com entry points
    BEGIN_MMC_COM_MAP(ThisClass)
        COM_INTERFACE_ENTRY(IContextMenuCallback) // the IContextMenuProvider and IContextMenu
        COM_INTERFACE_ENTRY(IContextMenuCallback2)
    END_MMC_COM_MAP()

    DECLARE_POLY_AGGREGATABLE(ThisClass)

    // ContextMenu Methods
    STDMETHOD(get_Item)(VARIANT varIndexOrName, PPMENUITEM ppMenuItem);
    STDMETHOD(get_Count)(PLONG pCount);

    // ContextMenu collection methods
    typedef UINT Position;  // just uses the index of the menu item.

    // these enumerator methods only enumerate "real" menu items - not submenu items or separators
    ::SC  ScEnumNext(Position &pos, PDISPATCH & pDispatch);
    ::SC  ScEnumSkip(unsigned long celt, unsigned long& celtSkipped,  Position &pos);
    ::SC  ScEnumReset(Position &pos);

    // used by the collection methods
    typedef ThisClass * PMMCCONTEXTMENU;

    // IExtendContexMenu methods
    ::SC ScAddMenuItems( LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pCallback, long * pInsertionAllowed); // does nothing.
    ::SC ScCommand     ( long lCommandID, LPDATAOBJECT pDataObject);

    CNodeCallback * GetNodeCallback() {return m_pNodeCallback;}
    HRESULT Display(BOOL b);
    ::SC    ScDisplaySnapinPropertySheet();
    ::SC    ScBuildContextMenu();
    ::SC    ScGetItem(int iItem, CMenuItem** ppMenuItem);  // get the i'th item - easy accessor
    HRESULT CreateContextMenuProvider();
    HRESULT CreateTempVerbSet(bool bForScopeItem);
    HRESULT CreateTempVerbSetForMultiSel(void);


private:
    ::SC ScAddMenuItem(UINT     nResourceID, // contains text and status text separated by '\n'
                       LPCTSTR  szLanguageIndependentName,
                       long lCommandID, long lInsertionPointID = CCM_INSERTIONPOINTID_ROOT_MENU,
                       long fFlags = 0);

    ::SC ScAddInsertionPoint(long lCommandID, long lInsertionPointID = CCM_INSERTIONPOINTID_ROOT_MENU );
    ::SC ScAddSeparator(long lInsertionPointID = CCM_INSERTIONPOINTID_ROOT_MENU);


    ::SC ScAddSubmenu_Task();
    ::SC ScAddSubmenu_CreateNew(BOOL fStaticFolder);
    ::SC ScChangeListViewMode(int nNewMode);   // changes the list view mode to the specified mode.
    ::SC ScGetItem(MenuItemList *pMenuItemList, int &iItem, CMenuItem** ppMenuItem);  // get the i'th item.
    ::SC ScGetItemCount(UINT &count);

private:
    typedef enum _MENU_LEVEL
    {
        MENU_LEVEL_TOP = 0,
        MENU_LEVEL_SUB = 1
    } MENU_LEVEL;

    ::SC ScAddMenuItemsForTreeItem();
    ::SC ScAddMenuItemsForViewMenu(MENU_LEVEL menuLevel);
    ::SC ScAddMenuItemsForVerbSets();
    ::SC ScAddMenuItemsforFavorites();

    ::SC ScAddMenuItemsForLVBackgnd();
    ::SC ScAddMenuItemsForMultiSelect();
    ::SC ScAddMenuItemsForLV();
    ::SC ScAddMenuItemsForOCX();

    HRESULT AddMenuItems();
    static void RemoveTempSelection(CConsoleTree* lConsoleTree);

    CResultItem* GetResultItem() const;

public:
    CContextMenuInfo *PContextInfo() {return &m_ContextInfo;}
    const CContextMenuInfo *PContextInfo() const {return &m_ContextInfo;}

    void    SetStatusBar(CConsoleStatusBar *pStatusBar);
    ::SC    ScAddItem ( CONTEXTMENUITEM* pItem, bool bPassCommandBackToSnapin = false );

private:
    CConsoleStatusBar *     GetStatusBar();

    BOOL IsVerbEnabled(MMC_CONSOLE_VERB verb);

    CNode*                  m_pNode;
    CNodeCallback*          m_pNodeCallback;
    CScopeTree*             m_pCScopeTree;
    CContextMenuInfo        m_ContextInfo;

    IDataObjectPtr          m_spIDataObject;

    IConsoleVerbPtr         m_spVerbSet;
    MMC_CONSOLE_VERB        m_eDefaultVerb;

    long                    m_lCommandIDMax;
    CConsoleStatusBar *     m_pStatusBar;


///////////////////////////////////////////////////////////////////////////////
// IContextMenuCallback interface

public:
    STDMETHOD(AddItem) ( CONTEXTMENUITEM* pItem );
    
///////////////////////////////////////////////////////////////////////////////
// IContextMenuCallback interface

public:
    STDMETHOD(AddItem) ( CONTEXTMENUITEM2* pItem );

///////////////////////////////////////////////////////////////////////////////
// IContextMenuProvider interface

public:
    STDMETHOD(EmptyMenuList) ();
    STDMETHOD(AddThirdPartyExtensionItems) (
                                IDataObject* piDataObject );
    STDMETHOD(AddPrimaryExtensionItems) (
                                IUnknown*    piCallback,
                                IDataObject* piDataObject );
    STDMETHOD(ShowContextMenu) (HWND    hwndParent,
                                LONG    xPos,
                                LONG    yPos,
                                LONG*   plSelected);

	// this isn't part of IContextMenuProvider, but ShowContextMenu calls it
    STDMETHOD(ShowContextMenuEx) (HWND    hwndParent,
                                LONG    xPos,
                                LONG    yPos,
								LPCRECT	prcExclude,
								bool    bAllowDefaultMenuItem,
                                LONG*   plSelected);

// IContextMenuProviderPrivate
    STDMETHOD(AddMultiSelectExtensionItems) (LONG_PTR lMultiSelection );

private:
    CMenuItem* m_pmenuitemRoot;
    SnapinStructList* m_SnapinList;
    MENU_OWNER_ID m_MaxPrimaryOwnerID;
    MENU_OWNER_ID m_MaxThirdPartyOwnerID;
    MENU_OWNER_ID m_CurrentExtensionOwnerID;
    long    m_nNextMenuItemID;
    long    m_fPrimaryInsertionFlags;
    long    m_fThirdPartyInsertionFlags;
    bool    m_fAddingPrimaryExtensionItems;
    bool    m_fAddedThirdPartyExtensions;
    CStr m_strObjectGUID;
    CCriticalSection m_CritsecMenuList;
    CCriticalSection m_CritsecSnapinList;

    STDMETHOD(DoAddMenuItem) (  LPCTSTR lpszName,
                                LPCTSTR lpszStatusBarText,
                                LPCTSTR lpszLanguageIndependentName,
                                LONG    lCommandID,
                                LONG    lInsertionPointID,
                                LONG    fFlags,
                                LONG    fSpecialFlags,
                                MENU_OWNER_ID lOwnerID,
                                CMenuItem** ppMenuItem = NULL,
                                bool    bPassCommandBackToSnapin = false );
    ::SC ScAddSnapinToList_GUID(
                const CLSID& clsid,
                IDataObject* piDataObject,
                MENU_OWNER_ID ownerid );
    ::SC ScAddSnapinToList_IUnknown(
                IUnknown* piUnknown,
                IDataObject* piDataObject,
                MENU_OWNER_ID ownerid );
    ::SC ScAddSnapinToList_IExtendContextMenu(
                IExtendContextMenu*  pIExtendContextMenu,
                IDataObject* piDataObject,
                MENU_OWNER_ID ownerid );
    SnapinStruct* FindSnapin( MENU_OWNER_ID nOwnerID );
public:
    MenuItemList* GetMenuItemList();
    HRESULT       ExecuteMenuItem(CMenuItem *pItem);
private:
    void ReleaseSnapinList();

public:
    HRESULT    BuildContextMenu(WTL::CMenu &menu);
    CMenuItem* FindMenuItem( LONG_PTR nMenuItemID, BOOL fFindSubmenu = FALSE );
    CMenuItem* ReverseFindMenuItem( long nCommandID, MENU_OWNER_ID nOwnerID, CStr &strPath, CStr &strLanguageIndependentPath);
    CMenuItem* FindNthItemInSubmenu( HMENU hmenuParent, UINT iPosition, LPTSTR lpszMenuName);
};

#include <poppack.h>    // Sundown

void OnCustomizeView(CViewData* pViewData);

SC ScDisplaySnapinNodePropertySheet(CNode* pNode);
SC ScDisplaySnapinLeafPropertySheet(CNode* pNode, LPARAM lParam);
SC ScDisplayMultiSelPropertySheet(CNode* pNode);
SC ScDisplayScopeNodePropertySheet(CMTNode *pMTNode);

#endif // _MMC_ONCMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\policy.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       policy.h
//
//  Contents:   Helper class to determine policy for each snapin
//
//  Classes:    CPolicy
//
//  Functions:
//
//  History:    10/07/1998   AnandhaG   Created
//              12/04/1998   AnandhaG   Modified according to spec.
//____________________________________________________________________________


#ifndef _POLICY_H_
#define _POLICY_H_

class CPolicy
{
public:
// Constructor & destructor
    CPolicy() :
        m_bRestrictAuthorMode(FALSE),
        m_bRestrictedToPermittedList(FALSE)
    {
        // Set data above data members to reflect default
        // NT4 configuration. Always allow author mode
        // and allow snapins not in permitted list.
    }

    ~CPolicy()
    {
    }

    SC ScInit();

    bool IsPermittedSnapIn(REFCLSID refSnapInCLSID);
    bool IsPermittedSnapIn(LPCWSTR  pszSnapInCLSID);

// Data members.
private:
    CRegKeyEx       m_rPolicyRootKey;

    bool            m_bRestrictAuthorMode;
    bool            m_bRestrictedToPermittedList;
};

#endif // _POLICY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\power.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      power.cpp
 *
 *  Contents:  Implementation file for CConsolePower
 *
 *  History:   25-Feb-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#include <stdafx.h>
#include "power.h"


/*
 * allocate a TLS index for CConsolePower objects
 */
const DWORD CConsolePower::s_dwTlsIndex = TlsAlloc();

const DWORD CConsolePower::s_rgExecStateFlag[CConsolePower::eIndex_Count] =
{
    ES_SYSTEM_REQUIRED,     // eIndex_System
    ES_DISPLAY_REQUIRED,    // eIndex_Display
};

const CConsolePower::ExecutionStateFunc CConsolePower::s_FuncUninitialized =
		(ExecutionStateFunc)(LONG_PTR) -1;

CConsolePower::ExecutionStateFunc CConsolePower::SetThreadExecutionState_ =
		s_FuncUninitialized;


/*+-------------------------------------------------------------------------*
 * ScPrepExecutionStateFlag
 *
 * This function increments or decrements the count for dwTestBit for this
 * object, and for the thread.  On exit dwSTESArg contains the appropriate
 * flag to pass to SetThreadExecutionState for dwTestBit.  That is, if the
 * thread count for dwTestBit is non-zero, dwSTESArg will contain dwTestBit
 * on return; if the thread count is zero, dwSTESArg will not contain
 * dwTestBit.
 *--------------------------------------------------------------------------*/

static SC ScPrepExecutionStateFlag (
    DWORD   dwTestBit,              /* I:single ES_* flag to test           */
    DWORD   dwAdd,                  /* I:flags to add                       */
    DWORD   dwRemove,               /* I:flags to remove                    */
    DWORD * pdwSTESArg,             /* I/O:arg to SetThreadExecutionState   */
    LONG *  pcObjectRequests,       /* I/O:request count for this object    */
    LONG *  pcThreadRequests,       /* I/O:request count for this thread    */
    UINT    cIterations = 1)        /* I:times to add/remove dwTestBit      */
{
    DECLARE_SC (sc, _T("ScPrepExecutionStateFlag"));

    /*
     * validate inputs -- DO NOT clear these output variables, the
     * existing values are modified here
     */
    sc = ScCheckPointers (pdwSTESArg, pcObjectRequests, pcThreadRequests);
    if (sc)
        return (sc);

    /*
     * make sure the bit isn't to be both removed and added
     */
    if ((dwAdd & dwTestBit) && (dwRemove & dwTestBit))
        return (sc = E_INVALIDARG);

    /*
     * We should always have a non-negative number of requests for the bit
     * under test for this object, and at least as many requests for the
     * thread as we do for this object.
     */
    ASSERT (*pcObjectRequests >= 0);
    ASSERT (*pcThreadRequests >= *pcObjectRequests);
    if ((*pcObjectRequests < 0) || (*pcThreadRequests < *pcObjectRequests))
        return (sc = E_UNEXPECTED);

    /*
     * If we're adding the test bit, bump up the request count for this
     * object and this thread.
     */
    if (dwAdd & dwTestBit)
    {
        *pcObjectRequests += cIterations;
        *pcThreadRequests += cIterations;
    }

    /*
     * Otherwise, if we're removing the test bit, bump down the request counts
     * for this object and this thread.
     */
    else if (dwRemove & dwTestBit)
    {
        /*
         * Can't remove the bit under test if we don't have an outstanding
         * request for it on this object.
         */
        if (*pcObjectRequests < cIterations)
            return (sc = E_INVALIDARG);

        *pcObjectRequests -= cIterations;
        *pcThreadRequests -= cIterations;
    }

    /*
     * If the net count for this thread is non-zero, the bit under
     * test needs to be in the argument for SetThreadExecutionState;
     * if not, the bit under test needs to be removed.
     */
    if (*pcThreadRequests != 0)
        *pdwSTESArg |=  dwTestBit;
    else
        *pdwSTESArg &= ~dwTestBit;

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CConsolePower::CConsolePower
 *
 * Constructs a CConsolePower object.
 *--------------------------------------------------------------------------*/

CConsolePower::CConsolePower () :
    m_wndPower (this)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CConsolePower);

    /*
     * If any of these fail, s_rgExecStateFlag is out of order.  It would
     * be better to use COMPILETIME_ASSERT here, but using that gives us
     *
     *      error C2051: case expression not constant
     *
     * Bummer.
     */
    ASSERT (s_rgExecStateFlag[eIndex_System]  == ES_SYSTEM_REQUIRED);
    ASSERT (s_rgExecStateFlag[eIndex_Display] == ES_DISPLAY_REQUIRED);
}


/*+-------------------------------------------------------------------------*
 * CConsolePower::~CConsolePower
 *
 * Destroys a CConsolePower object.  If this object holds references to
 * ES_SYSTEM_REQUIRED or ES_DISPLAY_REQUIRED settings, they will be cleared.
 *--------------------------------------------------------------------------*/

CConsolePower::~CConsolePower ()
{
    DECLARE_SC (sc, _T("CConsolePower::~CConsolePower"));

    DEBUG_DECREMENT_INSTANCE_COUNTER(CConsolePower);

    /*
     * clean up outstanding references, if any
     */
    if (!IsBadCodePtr ((FARPROC) SetThreadExecutionState_) &&
		((m_Counts.m_rgCount[eIndex_System]  != 0) ||
         (m_Counts.m_rgCount[eIndex_Display] != 0)))
    {
        try
        {

            /*
             * get the thread counts
             */
            sc = ScCheckPointers (m_spThreadCounts, E_UNEXPECTED);
            if (sc)
                sc.Throw();

            DWORD dwFlags = ES_CONTINUOUS;

            /*
             * clean up each individual count
             */
            for (int i = 0; i < eIndex_Count; i++)
            {
                /*
                 * prevent underflow
                 */
                if (m_Counts.m_rgCount[i] > m_spThreadCounts->m_rgCount[i])
                    (sc = E_UNEXPECTED).Throw();

                sc = ScPrepExecutionStateFlag (s_rgExecStateFlag[i],    // dwTestBit
                                               0,                       // dwAdd
                                               s_rgExecStateFlag[i],    // dwRemove
                                               &dwFlags,
                                               &m_Counts.m_rgCount[i],
                                               &m_spThreadCounts->m_rgCount[i],
                                               m_Counts.m_rgCount[i]);
                if (sc)
                    sc.Throw();
            }

            /*
             * clean up the execution state for this thread
             */
            if (!SetThreadExecutionState_(dwFlags))
            {
                sc.FromLastError();
                sc.Throw();
            }
        }
        catch (SC& scCaught)
        {
            sc = scCaught;
        }
    }
}


/*+-------------------------------------------------------------------------*
 * CConsolePower::FinalConstruct
 *
 * This isn't the typical use of FinalConstruct in ATL objects.  It is
 * typically used for creating aggregated objects, but using it in this
 * way allows us to prevent the creation of CConsolePower objects without
 * throwing an exception from the ctor, which ATL can't handle.
 *--------------------------------------------------------------------------*/

HRESULT CConsolePower::FinalConstruct ()
{
    DECLARE_SC (sc, _T("CConsolePower::FinalConstruct"));

	/*
	 * if this is the first time a CConsolePower has been created, try to
	 * dynaload SetThreadExecutionState (it's not supported on WinNT and
	 * Win95)
	 */
	if (SetThreadExecutionState_ == s_FuncUninitialized)
	{
        SetThreadExecutionState_ =
				(ExecutionStateFunc) GetProcAddress (
											GetModuleHandle (_T("kernel32.dll")),
											"SetThreadExecutionState");
	}

	/*
	 * if SetThreadExecutionState is supported on this platform, do the
	 * other initialization we'll need
	 */
	if (!IsBadCodePtr ((FARPROC) SetThreadExecutionState_))
	{
		/*
		 * if we couldn't get the thread-local CRefCountedTlsExecutionCounts
		 * object for this thread, CConsolePower is useless, so fail creation
		 */
		sc = ScGetThreadCounts (&m_spThreadCounts);
		if (sc)
			return (sc.ToHr());

		sc = ScCheckPointers (m_spThreadCounts, E_UNEXPECTED);
		if (sc)
			return (sc.ToHr());

		/*
		 * create the window to handle WM_POWERBROADCAST
		 */
		sc = m_wndPower.ScCreate ();
		if (sc)
			return (sc.ToHr());
	}

    return (sc.ToHr());
}


/*+-------------------------------------------------------------------------*
 * CConsolePower::ScGetThreadCounts
 *
 * Returns a pointer to the thread-local CRefCountedTlsExecutionCounts object
 * for this thread, allocating one if necessary.
 *
 * NOTE:  The returned pointer has a reference added.  It is the client's
 * responsibility to release the reference.
 *--------------------------------------------------------------------------*/

SC CConsolePower::ScGetThreadCounts (CRefCountedTlsExecutionCounts** ppThreadCounts)
{
    DECLARE_SC (sc, _T("CConsolePower::ScGetThreadCounts"));

	/*
	 * we shouldn't get here if we're on a platform that doesn't support
	 * SetThreadExecutionState
	 */
	ASSERT (!IsBadCodePtr ((FARPROC) SetThreadExecutionState_));
	if (IsBadCodePtr ((FARPROC) SetThreadExecutionState_))
		return (sc = E_UNEXPECTED);

    sc = ScCheckPointers (ppThreadCounts);
    if (sc)
        return (sc);

    /*
     * init output
     */
    (*ppThreadCounts) = NULL;

    /*
     * couldn't allocate a TLS index?  fail
     */
    if (s_dwTlsIndex == TLS_OUT_OF_INDEXES)
        return (sc = E_OUTOFMEMORY);

    /*
     * Get the existing thread counts structure.  If this is the first
     * time through (i.e. the first CConsolePower created on this thread),
     * we won't have a thread counts structure, so we'll allocate one now.
     */
    CTlsExecutionCounts* pTEC = CTlsExecutionCounts::GetThreadInstance(s_dwTlsIndex);

    if (pTEC == NULL)
    {
        /*
         * allocate the struct for this thread
         */
        (*ppThreadCounts) = CRefCountedTlsExecutionCounts::CreateInstance();
        if ((*ppThreadCounts) == NULL)
            return (sc = E_OUTOFMEMORY);

        /*
         * put it in our TLS slot
         */
        sc = (*ppThreadCounts)->ScSetThreadInstance (s_dwTlsIndex);
        if (sc)
            return (sc);
    }
    else
        (*ppThreadCounts) = static_cast<CRefCountedTlsExecutionCounts*>(pTEC);

    /*
     * put a reference on for the caller
     */
    (*ppThreadCounts)->AddRef();

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CConsolePower::SetExecutionState
 *
 * This method wraps the ::SetThreadExecutionState API in a manner that is
 * safe in the presence of multiple COM servers (i.e. snap-ins) that might
 * need to call ::SetThreadExecutionState.
 *
 * The problem is that ::SetThreadExecutionState doesn't maintain reference
 * counts on the flags that it is passed.  For instance:
 *
 *      SetThreadExecutionState (ES_CONTINUOUS | ES_SYSTEM_REQUIRED);
 *      SetThreadExecutionState (ES_CONTINUOUS | ES_SYSTEM_REQUIRED);
 *      SetThreadExecutionState (ES_CONTINUOUS);
 *
 * will result in the ES_SYSTEM_REQUIRED bit being off, even though it was
 * set twice and only cleared once.  This can lead to conflicts between
 * snap-ins, like in this scenario:
 *
 * SnapinA:
 *      SetThreadExecutionState (ES_CONTINUOUS | ES_SYSTEM_REQUIRED);
 *
 * SnapinB:
 *      SetThreadExecutionState (ES_CONTINUOUS | ES_SYSTEM_REQUIRED);
 *      SetThreadExecutionState (ES_CONTINUOUS);
 *
 * (a Long Time passes)
 *
 * SnapinA:
 *      SetThreadExecutionState (ES_CONTINUOUS);
 *
 * Because of the nature of SetThreadExecutionState, during
 * the Long Time, SnapinA thinks the ES_SYSTEM_REQUIRED bit is set, even
 * though SnapinB has turned it off.
 *
 * The CConsolePower object maintains a per-snap-in count of the execution
 * state bits, so they can all happily coexist.
 *--------------------------------------------------------------------------*/

STDMETHODIMP CConsolePower::SetExecutionState (
    DWORD   dwAdd,                      /* I:flags to add                   */
    DWORD   dwRemove)                   /* I:flags to remove                */
{
    DECLARE_SC (sc, _T("CConsolePower::SetExecutionState"));
#ifdef DBG
    /*
     * this object is CoCreated so we can't tell what the snap-in name is
     */
    sc.SetSnapinName (_T("<unknown>"));
#endif

	/*
	 * if SetExecutionState isn't supported on this platform, don't do
	 * anything, but still "succeed"
	 */
	if (IsBadCodePtr ((FARPROC) SetThreadExecutionState_))
		return ((sc = S_FALSE).ToHr());

    const DWORD dwValidFlags = ES_SYSTEM_REQUIRED | ES_DISPLAY_REQUIRED;
    DWORD       dwFlags      = 0;

    /*
     * if either dwAdd or dwRemove contain flags we don't recognize
     * (including ES_CONTINUOUS, which we expect to get in fContinuous)
     * fail
     */
    if (((dwAdd | dwRemove) & ~dwValidFlags) != 0)
        return ((sc = E_INVALIDARG).ToHr());

    /*
     * if we didn't get any flags, fail
     */
    if ((dwAdd == 0) && (dwRemove == 0))
        return ((sc = E_INVALIDARG).ToHr());


    /*
     * make sure we've got our thread counts
     */
    sc = ScCheckPointers (m_spThreadCounts, E_UNEXPECTED);
    if (sc)
        return (sc.ToHr());

    dwFlags = ES_CONTINUOUS;


    /*
     * add/remove each individual flag
     */
    for (int i = 0; i < eIndex_Count; i++)
    {
        sc = ScPrepExecutionStateFlag (s_rgExecStateFlag[i],    // dwTestBit
                                       dwAdd,
                                       dwRemove,
                                       &dwFlags,
                                       &m_Counts.m_rgCount[i],
                                       &m_spThreadCounts->m_rgCount[i]);
        if (sc)
            return (sc.ToHr());
    }

    /*
     * set the execution state for this thread
     */
    if (!SetThreadExecutionState_(dwFlags))
        sc.FromLastError().ToHr();

    return (sc.ToHr());
}


/*+-------------------------------------------------------------------------*
 * CConsolePower::ResetIdleTimer
 *
 * Simple wrapper for SetThreadExecutionState (without ES_CONTINUOUS).
 *--------------------------------------------------------------------------*/

STDMETHODIMP CConsolePower::ResetIdleTimer (DWORD dwFlags)
{
    DECLARE_SC (sc, _T("CConsolePower::ResetIdleTimer"));
#ifdef DBG
    /*
     * this object is CoCreated so we can't tell what the snap-in name is
     */
    sc.SetSnapinName (_T("<unknown>"));
#endif

	/*
	 * if SetExecutionState isn't supported on this platform, don't do
	 * anything, but still "succeed"
	 */
	if (IsBadCodePtr ((FARPROC) SetThreadExecutionState_))
		return ((sc = S_FALSE).ToHr());

    /*
     * Set the execution state for this thread.  SetThreadExecutionState
     * will do all parameter validation.
     */
    if (!SetThreadExecutionState_(dwFlags))
        sc.FromLastError().ToHr();

    return (sc.ToHr());
}


/*+-------------------------------------------------------------------------*
 * CConsolePower::OnPowerBroadcast
 *
 * WM_POWERBROADCAST handler for CConsolePower.
 *--------------------------------------------------------------------------*/

LRESULT CConsolePower::OnPowerBroadcast (WPARAM wParam, LPARAM lParam)
{
    /*
     * PBT_APMQUERYSUSPEND is the only event that the recipient can
     * deny.  If a snap-in denies (by returning BROADCAST_QUERY_DENY),
     * there's no need to continue to fire the event to other snap-ins,
     * so we can break out and return the denial.
     */
    bool fBreakIfDenied = (wParam == PBT_APMQUERYSUSPEND);

    int cConnections = m_vec.GetSize();

    for (int i = 0; i < cConnections; i++)
    {
        CComQIPtr<IConsolePowerSink> spPowerSink = m_vec.GetAt(i);

        if (spPowerSink != NULL)
        {
            LRESULT lResult = TRUE;
            HRESULT hr = spPowerSink->OnPowerBroadcast (wParam, lParam, &lResult);

            /*
             * if the snap-in denied a PBT_APMQUERYSUSPEND, short out here
             */
            if (SUCCEEDED(hr) && fBreakIfDenied && (lResult == BROADCAST_QUERY_DENY))
                return (lResult);
        }
    }

    return (TRUE);
}


/*+-------------------------------------------------------------------------*
 * CConsolePower::CExecutionCounts::CExecutionCounts
 *
 * Constructs a CConsolePower::CExecutionCounts object.
 *--------------------------------------------------------------------------*/

CConsolePower::CExecutionCounts::CExecutionCounts ()
{
    for (int i = 0; i < countof (m_rgCount); i++)
        m_rgCount[i] = 0;
}


/*+-------------------------------------------------------------------------*
 * CConsolePower::CTlsExecutionCounts::CTlsExecutionCounts
 *
 * Constructs a CConsolePower::CTlsExecutionCounts object.
 *--------------------------------------------------------------------------*/

CConsolePower::CTlsExecutionCounts::CTlsExecutionCounts () :
    m_dwTlsIndex (Uninitialized)
{
}


/*+-------------------------------------------------------------------------*
 * CConsolePower::CTlsExecutionCounts::~CTlsExecutionCounts
 *
 * Destroys a CConsolePower::CTlsExecutionCounts object.
 *--------------------------------------------------------------------------*/

CConsolePower::CTlsExecutionCounts::~CTlsExecutionCounts ()
{
    if (m_dwTlsIndex != Uninitialized)
        TlsSetValue (m_dwTlsIndex, NULL);
}


/*+-------------------------------------------------------------------------*
 * CConsolePower::CTlsExecutionCounts::ScSetThreadInstance
 *
 * Accepts a valid TLS index and stores a pointer to this object in the
 * TLS slot identified by dwTlsIndex.
 *--------------------------------------------------------------------------*/

SC CConsolePower::CTlsExecutionCounts::ScSetThreadInstance (DWORD dwTlsIndex)
{
    DECLARE_SC (sc, _T("CConsolePower:CTlsExecutionCounts::ScSetThreadInstance"));

    /*
     * this can only be called once
     */
    ASSERT (m_dwTlsIndex == Uninitialized);
    if (m_dwTlsIndex != Uninitialized)
        return (sc = E_UNEXPECTED);

    /*
     * there shouldn't already be something in this slot
     */
    if (TlsGetValue (dwTlsIndex) != NULL)
        return (sc = E_UNEXPECTED);

    /*
     * save a pointer to ourselves in the TLS slot
     */
    if (!TlsSetValue (dwTlsIndex, this))
        return (sc.FromLastError());

    /*
     * save the TLS index
     */
    m_dwTlsIndex = dwTlsIndex;

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CConsolePower::CTlsExecutionCounts::GetThreadInstance
 *
 *
 *--------------------------------------------------------------------------*/

CConsolePower::CTlsExecutionCounts*
CConsolePower::CTlsExecutionCounts::GetThreadInstance (DWORD dwTlsIndex)
{
    return ((CTlsExecutionCounts*) TlsGetValue (dwTlsIndex));
}


/*+-------------------------------------------------------------------------*
 * CConsolePowerWnd::CConsolePowerWnd
 *
 * Constructs a CConsolePowerWnd object.
 *--------------------------------------------------------------------------*/

CConsolePowerWnd::CConsolePowerWnd (CConsolePower* pConsolePower) :
    m_pConsolePower(pConsolePower)
{
}


/*+-------------------------------------------------------------------------*
 * CConsolePowerWnd::~CConsolePowerWnd
 *
 * Destroys a CConsolePowerWnd object.
 *--------------------------------------------------------------------------*/

CConsolePowerWnd::~CConsolePowerWnd ()
{
    /*
     * the Windows window for this class should never outlive the
     * C++ class that wraps it.
     */
    if (IsWindow ())
        DestroyWindow();
}


/*+-------------------------------------------------------------------------*
 * CConsolePowerWnd::ScCreate
 *
 * Creates the window for a CConsolePowerWnd object.  This window will
 * handle WM_POWERBROADCAST.
 *--------------------------------------------------------------------------*/

SC CConsolePowerWnd::ScCreate ()
{
    DECLARE_SC (sc, _T("CConsolePowerWnd::ScCreate"));

    /*
     * create an invisible top-level window (only top-level windows receive
     * WM_POWERBROADCAST).
     */
    RECT rectEmpty = { 0, 0, 0, 0 };

    if (!Create (GetDesktopWindow(), rectEmpty))
        return (sc.FromLastError());

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CConsolePowerWnd::OnPowerBroadcast
 *
 * WM_POWERBROADCAST handler for CConsolePowerWnd.
 *--------------------------------------------------------------------------*/

LRESULT CConsolePowerWnd::OnPowerBroadcast (
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam,
    BOOL&   bHandled)
{
    /*
     * if we aren't connected to a CConsolePower (shouldn't happen),
     * we can't handle the message
     */
    ASSERT (m_pConsolePower != NULL);
    if (m_pConsolePower == NULL)
    {
        bHandled = false;
        return (0);
    }

    return (m_pConsolePower->OnPowerBroadcast (wParam, lParam));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\power.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      power.h
 *
 *  Contents:  Interface file for CConsolePower
 *
 *  History:   25-Feb-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#pragma once

#include "refcount.h"


class CConsolePower;


/*+-------------------------------------------------------------------------*
 * CConsolePowerWnd
 *
 * Receives WM_POWERBROADCAST messages on behalf of a CConsolePower object.
 *--------------------------------------------------------------------------*/

class CConsolePowerWnd : public CWindowImpl<CConsolePowerWnd, CWindow, CNullTraits>
{
public:
    CConsolePowerWnd (CConsolePower* pConsolePower);
   ~CConsolePowerWnd ();

    SC ScCreate ();

    BEGIN_MSG_MAP(CConsolePower)
        MESSAGE_HANDLER (WM_POWERBROADCAST, OnPowerBroadcast);
    END_MSG_MAP()

    LRESULT OnPowerBroadcast (UINT msg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

private:
    CConsolePower* const    m_pConsolePower;    // weak reference
};


/*+-------------------------------------------------------------------------*
 * CConsolePower
 *
 * Implements IConsolePower and IConnectionPoint for IID_IConsolePowerSink.
 *--------------------------------------------------------------------------*/

class CConsolePower :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CConsolePower, &CLSID_ConsolePower>,
    public IConnectionPointContainerImpl<CConsolePower>,
    public IConnectionPointImpl<CConsolePower, &IID_IConsolePowerSink>,
    public IConsolePower
{
public:
    enum
    {
        eIndex_System,                      // for ES_SYSTEM_REQUIRED
        eIndex_Display,                     // for ES_DISPLAY_REQUIRED

        // must be last
        eIndex_Count,
    };

    CConsolePower();
   ~CConsolePower();

    DECLARE_NOT_AGGREGATABLE(CConsolePower)

    DECLARE_MMC_OBJECT_REGISTRATION (
		g_szMmcndmgrDll,						// implementing DLL
        CLSID_ConsolePower,                 	// CLSID
        _T("ConsolePower Class"),               // class name
        _T("ConsolePower.ConsolePower.1"),      // ProgID
        _T("ConsolePower.ConsolePower"))        // version-independent ProgID

    BEGIN_COM_MAP(CConsolePower)
        COM_INTERFACE_ENTRY(IConsolePower)
        COM_INTERFACE_ENTRY(IConnectionPointContainer)
    END_COM_MAP()

    BEGIN_CONNECTION_POINT_MAP(CConsolePower)
        CONNECTION_POINT_ENTRY(IID_IConsolePowerSink)
    END_CONNECTION_POINT_MAP()

    // IConsolePower methods
    STDMETHOD(SetExecutionState) (DWORD dwAdd, DWORD dwRemove);
    STDMETHOD(ResetIdleTimer)    (DWORD dwFlags);

    DECLARE_PROTECT_FINAL_CONSTRUCT()
    HRESULT FinalConstruct();

    LRESULT OnPowerBroadcast (WPARAM wParam, LPARAM lParam);


private:
    class CExecutionCounts
    {
    public:
        CExecutionCounts ();

    public:
        LONG    m_rgCount[CConsolePower::eIndex_Count];
    };

    class CTlsExecutionCounts : public CExecutionCounts
    {
    public:
        CTlsExecutionCounts();
       ~CTlsExecutionCounts();

        static CTlsExecutionCounts* GetThreadInstance (DWORD dwTlsIndex);
        SC ScSetThreadInstance (DWORD dwTlsIndex);

    private:
        enum { Uninitialized = TLS_OUT_OF_INDEXES };
        DWORD   m_dwTlsIndex;
    };

    typedef CRefCountedObject<CTlsExecutionCounts> CRefCountedTlsExecutionCounts;
	typedef EXECUTION_STATE (WINAPI* ExecutionStateFunc)(EXECUTION_STATE);

    static SC ScGetThreadCounts (CRefCountedTlsExecutionCounts** ppThreadCounts);



private:
    CConsolePowerWnd                        m_wndPower;
    CExecutionCounts                        m_Counts;
    CRefCountedTlsExecutionCounts::SmartPtr m_spThreadCounts;

    static const DWORD  			s_dwTlsIndex;
    static const DWORD  			s_rgExecStateFlag[eIndex_Count];
	static const ExecutionStateFunc	s_FuncUninitialized;
	static       ExecutionStateFunc	SetThreadExecutionState_;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\propsht.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       propsht.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "menuitem.h"
#include "amcmsgid.h"
#include "regutil.h"
#include "multisel.h"
#include "ndmgrp.h"
#include <process.h>
#include "cicsthkl.h"
#include "util.h"

/*
 * multimon.h is included by stdafx.h, without defining COMPILE_MULTIMON_STUBS
 * first.  We need to include it again here after defining COMPILE_MULTIMON_STUBS
 * so we'll get the stub functions.
 */
#if (_WIN32_WINNT < 0x0500)
#define COMPILE_MULTIMON_STUBS
#include <multimon.h>
#endif


// static variables.
CThreadToSheetMap CPropertySheetProvider::TID_LIST;


UINT __stdcall PropertySheetThreadProc(LPVOID dwParam);
HRESULT PropertySheetProc(AMC::CPropertySheet* pSheet);
DWORD SetPrivilegeAttribute(LPCTSTR PrivilegeName, DWORD NewPrivilegeAttribute, DWORD *OldPrivilegeAttribute);

STDMETHODIMP CPropertySheetProvider::Notify(LPPROPERTYNOTIFYINFO pNotify, LPARAM lParam)
{
    TRACE_METHOD(CPropertySheetProvider, Update);

    if (pNotify == 0)
        return E_INVALIDARG;

    if (!IsWindow (pNotify->hwnd))
        return (E_FAIL);

    // Cast it to the internal type and post the message to the window
    LPPROPERTYNOTIFYINFO pNotifyT =
            reinterpret_cast<LPPROPERTYNOTIFYINFO>(
                    ::GlobalAlloc(GPTR, sizeof(PROPERTYNOTIFYINFO)));

    if (pNotifyT == NULL)
        return E_OUTOFMEMORY;

    *pNotifyT = *pNotify;

    ::PostMessage (pNotifyT->hwnd, MMC_MSG_PROP_SHEET_NOTIFY,
                   reinterpret_cast<WPARAM>(pNotifyT), lParam);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CPropertySheet

DEBUG_DECLARE_INSTANCE_COUNTER(CPropertySheet);

namespace AMC
{
    CPropertySheet::CPropertySheet()
        :   m_dwThreadID (GetCurrentThreadId ())
    {
        CommonConstruct();
        DEBUG_INCREMENT_INSTANCE_COUNTER(CPropertySheet);
    }

    CPropertySheet::~CPropertySheet()
    {
        DEBUG_DECREMENT_INSTANCE_COUNTER(CPropertySheet);
    }

    void CPropertySheet::CommonConstruct()
    {
        TRACE_METHOD(CPropertySheet, CommonConstruct);

        memset(&m_pstHeader, 0, sizeof(m_pstHeader));
        memset(&m_pages, 0, sizeof(m_pages));

        m_hDlg                   = NULL;
        m_msgHook                = NULL;
        m_hDataWindow            = NULL;
        m_cookie                 = 0;
        m_lpMasterNode           = NULL;

        m_pStream                = NULL;
        m_bModalProp             = FALSE;
        m_pThreadLocalDataObject = NULL;
        m_bAddExtension          = FALSE;

        m_pMTNode                = NULL;
    }

    BOOL CPropertySheet::Create(LPCTSTR lpszCaption, bool fPropSheet,
        MMC_COOKIE cookie, LPDATAOBJECT pDataObject, LONG_PTR lpMasterNode, DWORD dwOptions)
    {
        TRACE_METHOD(CPropertySheet, Create);

        // Save the data object and the master tree node pointer
        m_spDataObject = pDataObject;
        m_lpMasterNode = pDataObject ? 0 : cookie;

        DWORD dwStyle = PSH_DEFAULT;

        // is it a property sheet?
        if (fPropSheet)
        {
            if (!(dwOptions & MMC_PSO_NO_PROPTITLE))
                dwStyle |= PSH_PROPTITLE;

            if (dwOptions & MMC_PSO_NOAPPLYNOW)
                dwStyle |= PSH_NOAPPLYNOW;
        }

        // nope, wizard
        else
        {
            dwStyle |= PSH_PROPTITLE;

            if (dwOptions & MMC_PSO_NEWWIZARDTYPE)
                dwStyle |= PSH_WIZARD97;
            else
                dwStyle |= PSH_WIZARD;
        }

        ASSERT(lpszCaption != NULL);

        m_cookie = cookie;
        m_pstHeader.dwSize    = sizeof(m_pstHeader);
        m_pstHeader.dwFlags   = dwStyle & ~PSH_HASHELP; // array contains handles
        m_pstHeader.hInstance = _Module.GetModuleInstance();

        // Assume no bitmaps or palette
        m_pstHeader.hbmWatermark = NULL;
        m_pstHeader.hbmHeader    = NULL;
        m_pstHeader.hplWatermark = NULL;

        // deep copy the title
        m_title = lpszCaption;
        m_pstHeader.pszCaption = m_title;
        m_pstHeader.nPages     = 0;
        m_pstHeader.phpage     = m_pages;

        return TRUE;
    }

    BOOL CPropertySheet::CreateDataWindow(HWND hParent)
    {
        TRACE_METHOD(CPropertySheet, CreateDataWindow);

        HINSTANCE hInstance = _Module.GetModuleInstance();
        WNDCLASS wndClass;

        // See if the class is registered and register a new one if not
        USES_CONVERSION;
        if (!GetClassInfo(hInstance, OLE2T(DATAWINDOW_CLASS_NAME), &wndClass))
        {
            memset(&wndClass, 0, sizeof(WNDCLASS));
            wndClass.lpfnWndProc   = DataWndProc;

            // This holds the cookie and the HWND for the sheet
            wndClass.cbWndExtra    = WINDOW_DATA_SIZE;
            wndClass.hInstance     = hInstance;
            wndClass.lpszClassName = OLE2T(DATAWINDOW_CLASS_NAME);

            if (!RegisterClass(&wndClass))
                return FALSE;
        }

        m_hDataWindow = CreateWindowEx (WS_EX_APPWINDOW, OLE2T(DATAWINDOW_CLASS_NAME),
                                        NULL, WS_DLGFRAME | WS_BORDER | WS_DISABLED,
                                        CW_USEDEFAULT, CW_USEDEFAULT, 0, 0, NULL, NULL,
                                        hInstance, NULL);

        return (m_hDataWindow != 0);
    }


    HRESULT CPropertySheet::DoSheet(HWND hParent, int nPage)
    {
        TRACE_METHOD(CPropertySheet, DoSheet);

        // A NULL hParent is allowed for property sheets
        // but not for wizards
        if (hParent != NULL)
        {
            if (!IsWindow(hParent))
                return E_FAIL;
        }
        else
        {
            if (IsWizard())
                return E_INVALIDARG;
        }

        if (nPage < 0 || m_dwTid != 0)
        {
            ASSERT(FALSE); // Object is already running!
            return E_FAIL;
        }

        m_pstHeader.nStartPage = nPage;
        m_pstHeader.hwndParent = hParent;


        HRESULT hr = S_OK;

        if (IsWizard())
        {
            if (m_pstHeader.nPages > 0)
            {
                // Don't create a thread, it's a wizard
                hr = PropertySheetProc (this);
                ASSERT(SUCCEEDED(hr));
            }
            else
            {
                hr = E_UNEXPECTED;
            }
        }
        else // modal or modeless prop sheet with data window
        {
            do
            {
                // Create data window for a property sheet
                if (CreateDataWindow(hParent) == FALSE)
                {
                    hr = E_FAIL;
                    break;
                }

                // Setup data in the hidden window
                DataWindowData* pData = GetDataWindowData (m_hDataWindow);
                pData->cookie       = m_cookie;
                pData->lpMasterNode = m_lpMasterNode;
                pData->spDataObject = m_spDataObject;
                pData->spComponent  = m_spComponent;
                pData->spComponentData = m_spComponentData;
                pData->hDlg         = NULL;

                if (m_bModalProp == TRUE)
                {
                    // Don't create a thread, it's a modal property sheet
                    hr = PropertySheetProc (this);
                    ASSERT(SUCCEEDED(hr));
                }
                else
                {
                    // If non-null data object, marshal interface to stream
                    if (m_spDataObject != NULL)
                    {
                        hr = CoMarshalInterThreadInterfaceInStream(IID_IDataObject,
                                m_spDataObject, &m_pStream);

                        /*
                         * Bug 318357: once it's marshalled, we're done with
                         * the data object on this thread, release it
                         */
                        m_spDataObject = NULL;

                        if (hr != S_OK)
                        {
                            TRACE(_T("DoSheet(): Marshalling Failed (%0x08x)\n"), hr);
                            break;
                        }

                        ASSERT(m_pStream != NULL);

                        for (int i = 0; i < m_Extenders.size(); i++)
                        {
                            IStream* pstm;

                            hr = CoMarshalInterThreadInterfaceInStream (
                                            IID_IUnknown,
                                            m_Extenders[i],
                                            &pstm);

                            if (FAILED (hr))
                            {
                                TRACE(_T("DoSheet(): Marshalling Failed (%0x08x)\n"), hr);
                                break;
                            }

                            m_ExtendersMarshallStreams.push_back (pstm);
                        }

                        BREAK_ON_FAIL (hr);

                        /*
                         * Clear out the extenders vector to keep the ref
                         * counting correct.  It'll be repopulated when
                         * the interfaces are unmarshalled later.
                         */
                        ASSERT (m_Extenders.size() == m_ExtendersMarshallStreams.size());
                        m_Extenders.clear();
                    }

                    m_pstHeader.hwndParent = m_hDataWindow;

                    HANDLE hThread = reinterpret_cast<HANDLE>(
                            _beginthreadex (NULL, 0, PropertySheetThreadProc,
                                            this, 0, &m_dwTid));
                    CloseHandle (hThread);
                }

            } while(0);

        }

        return hr;
    }

    void CPropertySheet::GetWatermarks (IExtendPropertySheet2* pExtend2)
    {
        ASSERT (IsWizard97());

		/*
		 * make sure our resource management objects are empty
         *
         * Bug 187702: Note that we Detach here rather than calling
         * DeleteObject.  Yes, it leaks, but it's required for app compat.
		 */
		if (!m_bmpWatermark.IsNull())	
			m_bmpWatermark.Detach();

		if (!m_bmpHeader.IsNull())	
			m_bmpHeader.Detach();

		if (!m_Palette.IsNull())	
			m_Palette.Detach();

		BOOL bStretch = FALSE;
		HRESULT hr = pExtend2->GetWatermarks (m_spDataObject,
											  &m_bmpWatermark.m_hBitmap,
											  &m_bmpHeader.m_hBitmap,
											  &m_Palette.m_hPalette,
											  &bStretch);

		/*
		 * If we failed to get watermark info, revert to an old-style
		 * wizard for MMC 1.1 compatibility.
		 */
		if (FAILED (hr))
		{
			ForceOldStyleWizard();
			return;
		}

		if (!m_bmpWatermark.IsNull())	
        {
            m_pstHeader.dwFlags |= (PSH_USEHBMWATERMARK | PSH_WATERMARK);
            m_pstHeader.hbmWatermark = m_bmpWatermark;
        }

		if (!m_bmpHeader.IsNull())	
        {
            m_pstHeader.dwFlags |= (PSH_USEHBMHEADER | PSH_HEADER);
            m_pstHeader.hbmHeader = m_bmpHeader;
        }

		if (!m_Palette.IsNull())	
        {
            m_pstHeader.dwFlags |= PSH_USEHPLWATERMARK;
            m_pstHeader.hplWatermark = m_Palette;
        }

        if (bStretch)
            m_pstHeader.dwFlags |= PSH_STRETCHWATERMARK;
    }

    BOOL CPropertySheet::AddExtensionPages()
    {
        TRACE_METHOD(CPropertySheet, AddExtensionPages);

#ifdef EXTENSIONS_CANNOT_ADD_PAGES_IF_PRIMARY_DOESNT
        if (m_pstHeader.nPages == 0)
        {
            ASSERT(m_pstHeader.nPages != 0);
            return FALSE;
        }
#endif

        POSITION pos;
        int nCount = m_pstHeader.nPages;

        pos = m_PageList.GetHeadPosition();

        if (pos != NULL)
        {
            while(pos && nCount < MAXPROPPAGES)
            {
                m_pages[nCount++] =
                    reinterpret_cast<HPROPSHEETPAGE>(m_PageList.GetNext(pos));
            }

            ASSERT(nCount < MAXPROPPAGES);
            m_pstHeader.nPages = nCount;

            // Empty the list for the extensions
            m_PageList.RemoveAll();

        }

        return TRUE;
    }

    void CPropertySheet::AddNoPropsPage ()
    {
        m_pages[m_pstHeader.nPages++] = m_NoPropsPage.Create();
    }


    LRESULT CPropertySheet::OnCreate(CWPRETSTRUCT* pMsg)
    {
        if (m_hDlg != 0)
            return 0;

        // Assign the hwnd in the object
        // Get the class name of the window to make sure it's the propsheet
        TCHAR name[256];

        if (GetClassName(pMsg->hwnd, name, sizeof(name)/sizeof(TCHAR)))
        {
            ASSERT(m_hDlg == 0);
            if (_tcsncmp(name, _T("#32770"), 6) == 0)
            {
                m_hDlg = pMsg->hwnd;
            }
        }
        return 0;
    }

    static RECT s_rectLastPropertySheetPos;
    static bool s_bLastPropertySheetPosValid = false;

    void SetLastPropertySheetPosition(HWND hWndPropertySheet)
    {
        ::GetWindowRect(hWndPropertySheet, &s_rectLastPropertySheetPos);
    }


    /*+-------------------------------------------------------------------------*
     *
     * SetPropertySheetPosition
     *
     * PURPOSE: The algorithm for positioning a property sheet.   (See bug 8584)
     *  1) The first property sheet in an mmc process is always brought up centered on the MMC application window. If it falls off the screen, it is
     *     displayed at the top-left.
     *  2) MMC stores the initial position of the last property sheet that was brought up, or the final position of the last property sheet that was destroyed.
     *  3) When a new property sheet is brought up, mmc starts by using the rectangle stored in (2) above.
     *  4) If there is already a property sheet from the same MMC instance in this position, MMC staggers the position down and to the right.
     *  5) Step 4 is repeated until a positon is located that does not collide with any other property sheets from the same thread.
     *  6) If the property sheet in this new postion does not completely lie on the screen, it is displayed at the top-left of the desktop.
     *
     * PARAMETERS:
     *    HWND  hWndPropertySheet :
     *
     * RETURNS:
     *    void
     *
     *+-------------------------------------------------------------------------*/
    void SetPropertySheetPosition(HWND hWndPropertySheet)
    {
        // Find the height and width of the property sheet for later use
        RECT rectCurrentPos;
        ::GetWindowRect(hWndPropertySheet, &rectCurrentPos); //get the current position

        int  width  = rectCurrentPos.right  - rectCurrentPos.left;
        int  height = rectCurrentPos.bottom - rectCurrentPos.top;


        // Initialize the position
        if (!s_bLastPropertySheetPosValid)
        {
            s_rectLastPropertySheetPos.top    = 0;
            s_rectLastPropertySheetPos.left   = 0;
            s_rectLastPropertySheetPos.bottom = 0;
            s_rectLastPropertySheetPos.right  = 0;

            CScopeTree * pScopeTree = CScopeTree::GetScopeTree();
            if(pScopeTree) // if pScopeTree == NULL, can still execute gracefully by using zero rect.
            {
                HWND hWndMain = pScopeTree->GetMainWindow();
                RECT rectTemp;
                GetWindowRect(hWndMain, &rectTemp);

                // center the property sheet on the center of the main window
                s_rectLastPropertySheetPos.top    = (rectTemp.top  + rectTemp.bottom)/2 - (height/2);
                s_rectLastPropertySheetPos.left   = (rectTemp.left + rectTemp.right )/2 - (width/2);
                s_rectLastPropertySheetPos.right  = s_rectLastPropertySheetPos.left + width;        // these last two are not strictly needed
                s_rectLastPropertySheetPos.bottom = s_rectLastPropertySheetPos.top  + height;       // but are here for consistency.
            }

            s_bLastPropertySheetPosValid = true;
        }

        RECT rectNewPos = s_rectLastPropertySheetPos; // try this initially

        int    offset = GetSystemMetrics(SM_CYDLGFRAME) + GetSystemMetrics(SM_CYCAPTION); // how much to stagger the windows by

        bool    bPosOK         = true;
        HWND    hWnd = NULL;

        typedef std::set<UINT> t_set;
        t_set s;

        // collect all the window positions into a vector
        while (1)
        {
            // make sure there isn't a property sheet already at this location
            hWnd = ::FindWindowEx(NULL, hWnd, MAKEINTATOM(32770), NULL);

            // No windows found, use the position
            if (hWnd == NULL)
                break;

            // Check if the window belongs to the current process
            DWORD   dwPid;
            ::GetWindowThreadProcessId(hWnd, &dwPid);
            if (dwPid != ::GetCurrentProcessId())
                continue;

            if(hWnd == hWndPropertySheet) // don't check against the same window.
                continue;

            RECT rectPos;
            ::GetWindowRect(hWnd, &rectPos);

            // look only for possible collisions starting from the point and to the right and below it.
            if(rectPos.top >= rectNewPos.top)
            {
                UINT offsetTemp = (rectPos.top - rectNewPos.top) / offset;

                if(rectPos.left != (offsetTemp * offset + rectNewPos.left) )
                    continue;

                if(rectPos.top != (offsetTemp * offset + rectNewPos.top) )
                    continue;

                s.insert(offsetTemp);
            }
        }

        // at this point s contains all the offsets that can collide.
        for(UINT i = 0; /*empty*/ ; i++)
        {
            if(s.find(i) == s.end()) // located the end
                break;
        }

        rectNewPos.left     += i*offset;
        rectNewPos.top      += i*offset;
        rectNewPos.bottom    = rectNewPos.top   + height;
        rectNewPos.right     = rectNewPos.left  + width;

        /*
         * Bug 211145: make sure the new position is within the work area
         */
        HMONITOR hmon = MonitorFromPoint (WTL::CPoint (rectNewPos.left,
                                                       rectNewPos.top),
                                          MONITOR_DEFAULTTONEAREST);
        MONITORINFO mi = { sizeof (mi) };
        WTL::CRect rectWorkArea;

        /*
         * if we could get the info for the monitor containing the window origin,
         * use it's workarea as the bounding rectangle; otherwise get the workarea
         * for the default monitor; if that failed as well, default to 640x480
         */
        if (GetMonitorInfo (hmon, &mi))
            rectWorkArea = mi.rcWork;
        else if (!SystemParametersInfo (SPI_GETWORKAREA, 0, &rectWorkArea, false))
            rectWorkArea.SetRect (0, 0, 639, 479);

        if (rectNewPos.left < rectWorkArea.left)
        {
            rectNewPos.left  = rectWorkArea.left;
            rectNewPos.right = rectNewPos.left + width;
        }

        if (rectNewPos.top < rectWorkArea.top)
        {
            rectNewPos.top = rectWorkArea.top;
            rectNewPos.bottom = rectNewPos.top + height;
        }

        // is the window completely visible?
        POINT ptTopLeft     = {rectNewPos.left,  rectNewPos.top};
        POINT ptBottomRight = {rectNewPos.right, rectNewPos.bottom};

        if(  (MonitorFromPoint(ptTopLeft,     MONITOR_DEFAULTTONULL) == NULL) ||
             (MonitorFromPoint(ptBottomRight, MONITOR_DEFAULTTONULL) == NULL))
        {
            // the property sheet is not completely visible. Move it to the top-left.
            rectNewPos.left   = rectWorkArea.left;
            rectNewPos.top    = rectWorkArea.top;
            rectNewPos.bottom = rectNewPos.top + height;
            rectNewPos.right  = rectNewPos.left + width;
        }

        MoveWindow(hWndPropertySheet, rectNewPos.left, rectNewPos.top, width, height, true /*bRepaint*/);

        // save the position
        s_rectLastPropertySheetPos = rectNewPos;
    }

    LRESULT CPropertySheet::OnInitDialog(CWPRETSTRUCT* pMsg)
    {
        if (m_hDlg != pMsg->hwnd)
            return 1;

        if (!IsWizard())
        {
            SetPropertySheetPosition(m_hDlg);

            ASSERT (IsWindow (m_hDataWindow));

            // Add data dialog hanndle to hidden window
            if (IsWindow (m_hDataWindow))
            {
                DataWindowData* pData = GetDataWindowData (m_hDataWindow);
                pData->hDlg = m_hDlg;

                // Create the marshalled data object pointer from stream
                if (m_pStream != NULL)
                {
                    // Unmarshall the Data object
                    HRESULT hr = ::CoGetInterfaceAndReleaseStream(m_pStream, IID_IDataObject,
                        reinterpret_cast<void**>(&m_pThreadLocalDataObject));

                    ASSERT(hr == S_OK);
                    TRACE(_T("WM_INITDIALOG:  Unmarshalled returned %X\n"), hr);

                    for (int i = 0; i < m_ExtendersMarshallStreams.size(); i++)
                    {
                        IUnknown* pUnk = NULL;

                        hr = CoGetInterfaceAndReleaseStream (
                                        m_ExtendersMarshallStreams[i],
                                        IID_IUnknown,
                                        reinterpret_cast<void**>(&pUnk));

                        ASSERT (hr == S_OK);
                        ASSERT (pUnk != NULL);
                        TRACE(_T("WM_INITDIALOG:  Unmarshalled returned %X\n"), hr);

                        /*
                         * m_Extenders is a collection of smart pointers, which
                         * will AddRef.  We don't need to AddRef an interface
                         * that's returned to us, so Release here to keep the
                         * bookkeeping straight.
                         */
                        m_Extenders.push_back (pUnk);
						if (pUnk)
							pUnk->Release();
                    }

                    ASSERT (m_Extenders.size() == m_ExtendersMarshallStreams.size());
                    m_ExtendersMarshallStreams.clear();
                }
            }

            /*
             * Bug 215593:  If we're running at low resolution we don't want
             * more than two rows of tabs.  If we find that is the case, use
             * a single scrolling row of tabs instead of multiple rows.
             */
            if (GetSystemMetrics (SM_CXSCREEN) < 800)
            {
                WTL::CTabCtrl wndTabCtrl = PropSheet_GetTabControl (m_hDlg);
                ASSERT (wndTabCtrl.m_hWnd != NULL);

                /*
                 * if we have more than two rows, remove the multiline style
                 */
                if (wndTabCtrl.GetRowCount() > 2)
                    wndTabCtrl.ModifyStyle (TCS_MULTILINE, 0);
            }

            // Create tooltip control for the property sheet.
            do
            {
                if (IsWizard())
                    break;

                HWND hWnd = m_PropToolTips.Create(m_hDlg);
                ASSERT(hWnd);

                if (NULL == hWnd)
                    break;

                TOOLINFO ti;

                RECT rc;
                GetWindowRect(m_hDlg, &rc);

                // Set the tooltip for property sheet title.
                // Set the control for a rectangle from (0, - (titlewidth))
                // to (right-end,0)
                ti.cbSize = sizeof(TOOLINFO);
                ti.uFlags = TTF_SUBCLASS;
                ti.hwnd = m_hDlg;

                // This is the id used for the tool tip control for property sheet
                // title. So when we get TTN_NEEDTEXT we can identify if the text
                // is for title or a tab.
                ti.uId = PROPSHEET_TITLE_TOOLTIP_ID;
                ti.rect.left = 0;
                ti.rect.right = rc.right - rc.left;
                ti.rect.top = -GetSystemMetrics(SM_CXSIZE);
                ti.rect.bottom = 0;
                ti.hinst = _Module.GetModuleInstance();
                ti.lpszText = LPSTR_TEXTCALLBACK ;

                m_PropToolTips.AddTool(&ti);
                m_PropToolTips.Activate(TRUE);

                // Now add tooltips for the tab control
                WTL::CTabCtrl wndTabCtrl = PropSheet_GetTabControl (m_hDlg);
                ASSERT (wndTabCtrl.m_hWnd != NULL);

                if (NULL == wndTabCtrl.m_hWnd)
                    break;

                ::ZeroMemory(&ti, sizeof(TOOLINFO));
                ti.cbSize = sizeof(TOOLINFO);
                ti.uFlags = TTF_SUBCLASS;
                ti.hwnd = wndTabCtrl.m_hWnd;
                ti.uId = (LONG)::GetDlgCtrlID((HWND)wndTabCtrl.m_hWnd);
                ti.hinst = _Module.GetModuleInstance();
                ti.lpszText = LPSTR_TEXTCALLBACK;

                //define the rect area (for each tab) and the tool tip associated withit
                for (int i=0; i<wndTabCtrl.GetItemCount(); i++)
                {
                    // get rect area of each tab
                    wndTabCtrl.GetItemRect(i, &rc);
                    POINT p[2];
                    p[0].x = rc.left;
                    p[0].y = rc.top;
                    p[1].x = rc.right;
                    p[1].y = rc.bottom;

                    // Map the co-ordinates relative to property sheet.
                    MapWindowPoints(wndTabCtrl.m_hWnd, m_hDlg, p, 2);
                    ti.rect.left   = p[0].x;
                    ti.rect.top    = p[0].y;
                    ti.rect.right  = p[1].x;
                    ti.rect.bottom = p[1].y ;

                    m_PropToolTips.AddTool(&ti);
                }

                m_PropToolTips.Activate(TRUE);

            } while (FALSE);

        }

        // Add third party extension
        if (m_bAddExtension)
        {
            //AddExtensionPages();
            m_bAddExtension = FALSE;
        }

        return 0;
    }

    LRESULT CPropertySheet::OnNcDestroy(CWPRETSTRUCT* pMsg)
    {
        if (m_hDlg != pMsg->hwnd)
            return 1;

        SetLastPropertySheetPosition(m_hDlg);

        ASSERT(m_msgHook != NULL);
        UnhookWindowsHookEx(m_msgHook);

        // Clean up the key and the object
        CPropertySheetProvider::TID_LIST.Remove(GetCurrentThreadId());

        if (m_pThreadLocalDataObject != NULL)
            m_pThreadLocalDataObject->Release();

        // Only Property Sheets have Data windows
        if (!IsWizard())
        {
            // Close the data window
            ASSERT(IsWindow(m_hDataWindow));
            SendMessage(m_hDataWindow, WM_CLOSE, 0, 0);
        }

        delete this;
        return 0;
    }

    LRESULT CPropertySheet::OnWMNotify(CWPRETSTRUCT* pMsg)
    {
        LPNMHDR pHdr = (LPNMHDR)pMsg->lParam;

        if (NULL == pHdr)
            return 0;

        switch(pHdr->code)
        {
        case TTN_NEEDTEXT:
            {
                /*
                 * we only want to do our thing if the Ctrl key is
                 * pressed, so bail if it's not
                 */
                if (!(GetKeyState(VK_CONTROL) < 0))
                    break;

                // Make sure our property sheet tooltip sent this message.
                if (pHdr->hwndFrom != ((CWindow)m_PropToolTips).m_hWnd)
                    break;

                LPTOOLTIPTEXT lpttt = (LPTOOLTIPTEXT)pMsg->lParam;
                lpttt->lpszText = NULL;

                // This is the id used for the tool tip control for property sheet
                // title. So check if the text is for title or a tab.
                if (pHdr->idFrom == PROPSHEET_TITLE_TOOLTIP_ID)
                    lpttt->lpszText = (LPTSTR)m_PropToolTips.GetFullPath();
                else
                {
                    // A tab is selected, find out which tab.
                    HWND hTabCtrl = PropSheet_GetTabControl(m_hDlg);
                    if (NULL == hTabCtrl)
                        break;

                    POINT pt;
                    GetCursorPos(&pt);
                    ScreenToClient(hTabCtrl, &pt);

                    TCHITTESTINFO tch;
                    tch.flags = TCHT_ONITEM;
                    tch.pt = pt;
                    int n = TabCtrl_HitTest(hTabCtrl, &tch);

                    if ((-1 == n) || (m_PropToolTips.GetNumPages() <= n) )
                        break;

                    lpttt->lpszText = (LPTSTR)m_PropToolTips.GetSnapinPage(n);
                }
            }
            break;

        default:
            break;
        }

        return 0;
    }

    void CPropertySheet::ForceOldStyleWizard ()
    {
        /*
         * We shouldn't be forcing old-style wizard behavior on a
         * property sheet that's not already a wizard.
         */
        ASSERT (IsWizard());

        m_pstHeader.dwFlags |=  PSH_WIZARD;
        m_pstHeader.dwFlags &= ~PSH_WIZARD97;

        /*
         * The sheet should still be a wizard, but not a Wiz97 wizard.
         */
        ASSERT ( IsWizard());
        ASSERT (!IsWizard97());
    }
}


DEBUG_DECLARE_INSTANCE_COUNTER(CPropertySheetProvider);

CPropertySheetProvider::CPropertySheetProvider()
{
    TRACE_METHOD(CPropertySheetProvider, CPropertySheetProvider);

    m_pSheet = NULL;
    DEBUG_INCREMENT_INSTANCE_COUNTER(CPropertySheetProvider);
}

CPropertySheetProvider::~CPropertySheetProvider()
{
    TRACE_METHOD(CPropertySheetProvider, ~CPropertySheetProvider);

    m_pSheet = NULL;

    DEBUG_DECREMENT_INSTANCE_COUNTER(CPropertySheetProvider);
}

///////////////////////////////////////////////////////////////////////////////
// IPropertySheetProvider
//


BOOL CALLBACK MyEnumThreadWindProc (HWND current, LPARAM lParam)
{  // this enumerates non-child-windows created by a given thread

   if (!IsWindow (current))
      return TRUE;   // this shouldn't happen, but does!!!

   if (!IsWindowVisible (current))  // if they've explicitly hidden a window,
      return TRUE;                  // don't set focus to it.

   // we'll return hwnd in here
   HWND * hwnd = (HWND *)lParam;

   // don't bother returning property sheet dialog window handle
   if (*hwnd == current)
      return TRUE;

   // also, don't return OleMainThreadWndClass window
   TCHAR szCaption[14];
   GetWindowText (current, szCaption, 14);
   if (!lstrcmp (szCaption, _T("OLEChannelWnd")))
      return TRUE;

   // anything else will do
   *hwnd = current;
   return FALSE;
}

STDMETHODIMP CPropertySheetProvider::FindPropertySheet(MMC_COOKIE cookie,
                                                       LPCOMPONENT lpComponent,
                                                       LPDATAOBJECT lpDataObject)
{
    return FindPropertySheetEx(cookie, lpComponent, NULL, lpDataObject);
}

STDMETHODIMP
CPropertySheetProvider::FindPropertySheetEx(MMC_COOKIE cookie, LPCOMPONENT lpComponent,
                                   LPCOMPONENTDATA lpComponentData, LPDATAOBJECT lpDataObject)
{
    TRACE_METHOD(CPropertySheetProvider, FindPropertySheet);

    using AMC::CPropertySheet;

    if ((cookie == NULL) && ( (lpComponent == NULL && lpComponentData == NULL) || lpDataObject == NULL))
    {
        ASSERT(FALSE);
        return E_POINTER;
    }

    HRESULT hr   = S_FALSE;
    HWND    hWnd = NULL;

    while (1)
    {
        USES_CONVERSION;
        hWnd = FindWindowEx(NULL, hWnd, OLE2T(DATAWINDOW_CLASS_NAME), NULL);

        // No windows found
        if (hWnd == NULL)
        {
            hr = S_FALSE;
            break;
        }

        // Check if the window belongs to the current process
        DWORD   dwPid;
        ::GetWindowThreadProcessId(hWnd, &dwPid);
        if (dwPid != ::GetCurrentProcessId())
            continue;

        // Get the extra bytes and compare the data objects
        ASSERT(GetClassLong(hWnd, GCL_CBWNDEXTRA) == WINDOW_DATA_SIZE);
        ASSERT(IsWindow(hWnd));

        // The original Data object can be NULL if there isn't an IComponent.
        // this occurs with built-in nodes(i.e. nodes owned by the console)
        DataWindowData* pData = GetDataWindowData (hWnd);

        // Ask the snapin of the the two data objects are the same
        // Does this one match?
        if (lpComponent != NULL)
        {
            ASSERT(pData->spDataObject != NULL);
            hr = lpComponent->CompareObjects(lpDataObject, pData->spDataObject);
        }
        else
        {
            // Although the NULL cookie is the static folder, the cookie stored in the data
            // window is the pointer to the master tree node.  This is why it is not null.
            ASSERT(cookie != NULL);

            // Compare the cookies if it's a scope item
            if (pData->cookie == cookie)
                hr = S_OK;
        }

        // bring the property sheet to the foreground
        // note: hDlg can be null if the secondary thread has not finished creating
        //        the property sheet
        if (hr == S_OK)
        {
            if (pData->hDlg != NULL)
            {
                //
                // Found previous instance, restore the
                // window plus its popups
                //

               SetActiveWindow (pData->hDlg);
               SetForegroundWindow (pData->hDlg);

               // grab first one that isn't property sheet dialog
               HWND hwnd = pData->hDlg;
               EnumThreadWindows(::GetWindowThreadProcessId(pData->hDlg, NULL),
                                 MyEnumThreadWindProc, (LPARAM)&hwnd);
               if (hwnd)
               {
                   SetActiveWindow (hwnd);
                   SetForegroundWindow (hwnd);
               }
            }
            break;
        }
    }

    return hr;
}

STDMETHODIMP
CPropertySheetProvider::CreatePropertySheet(
    LPCWSTR title,
    unsigned char bType,
    MMC_COOKIE cookie,
    LPDATAOBJECT pDataObject,
    DWORD dwOptions)
{
    return CreatePropertySheetEx(title, bType, cookie, pDataObject, NULL, dwOptions);
}

STDMETHODIMP CPropertySheetProvider::CreatePropertySheetEx(LPCWSTR title, unsigned char bType, MMC_COOKIE cookie,
                                                           LPDATAOBJECT pDataObject, LONG_PTR lpMasterTreeNode, DWORD dwOptions)
{
    TRACE_METHOD(CPropertySheetProvider, CreatePropertySheet);

    using AMC::CPropertySheet;

    if (!title)
        return E_POINTER;

    // You called CreatePropertySheet more than once.
    // Either release the object or call ::Show(-1, 0)
    // to free the resources
    if (m_pSheet != NULL)
    {
        ASSERT(FALSE);
        return E_UNEXPECTED;
    }

    // Create the actual sheet and the list for page management
    m_pSheet = new CPropertySheet();

    // Add it to the list of sheets and add it to the list
    USES_CONVERSION;
    m_pSheet->Create(OLE2CT(title), bType, cookie, pDataObject, lpMasterTreeNode, dwOptions);

    return S_OK;
}

STDMETHODIMP CPropertySheetProvider::Show(LONG_PTR window, int page)
{
    TRACE_METHOD(CPropertySheetProvider, Show);

    return ShowEx(reinterpret_cast<HWND>(window), page, FALSE);
}

STDMETHODIMP CPropertySheetProvider::ShowEx(HWND hwnd, int page, BOOL bModalPage)
{
    TRACE_METHOD(CPropertySheetProvider, ShowEx);

    HRESULT hr = E_UNEXPECTED;

    if (page < 0)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    if (m_pSheet == NULL)
    {
        // didn't call Create()
        ASSERT(FALSE);
        goto exit;
    }

    m_pSheet->m_bModalProp = bModalPage;
    hr = m_pSheet->DoSheet(hwnd, page);
    // Note: lifetime management of m_pSheet is not trivial here:
    // 1. upon successfull execution the object deletes itself post WM_NCDESTROY;
    // 2. In case the sheet executes on the main thread, and the error is encountered,
    //    the object is deleted in this function (below)
    // 3. In case sheet is executed on the non-main thread, thread function will
    //    take ownership of object:
    //    3.1. In case of successfull execution - same as #1.
    //    3.2. In case error occurres before spawning the thread - same as #2
    //    3.3. In case error occurres in the thread, thread function deletes the object.
    //
    // Re-design of this should be considered in post-whistler releases.

    if (SUCCEEDED(hr))
    {
        // gets delete after sheet is destroyed
        m_pSheet = NULL;
        return hr;
    }

// The m_pSheet needs to be deleted if hr is != S_OK
exit:
    delete m_pSheet;
    m_pSheet = NULL;

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
// IPropertySheetCallback
//

STDMETHODIMP CPropertySheetProvider::AddPage(HPROPSHEETPAGE lpPage)
{
    TRACE_METHOD(CPropertySheetProvider, AddPage);

    if (!lpPage)
    {
        ASSERT(FALSE);
        return E_POINTER;
    }

    ASSERT(m_pSheet != NULL);
    if (m_pSheet->m_PageList.GetCount() >= MAXPROPPAGES)
        return S_FALSE;

    m_pSheet->m_PageList.AddTail(lpPage);

    // Add the snapin name for this page in
    // the array for tooltips
    m_pSheet->m_PropToolTips.AddSnapinPage();

    return S_OK;
}

STDMETHODIMP CPropertySheetProvider::RemovePage(HPROPSHEETPAGE lpPage)
{
    TRACE_METHOD(CPropertySheetProvider, RemovePage);

    if (!lpPage)
    {
        ASSERT(FALSE);
        return E_POINTER;
    }

    ASSERT(m_pSheet != NULL);
    if (m_pSheet->m_PageList.IsEmpty())
    {
        TRACE(_T("Page list is empty"));
        return S_OK;
    }

    POSITION pos = m_pSheet->m_PageList.Find(lpPage);

    if (pos == NULL)
        return S_FALSE;

    m_pSheet->m_PageList.RemoveAt(pos);
    return S_OK;
}

UINT __stdcall PropertySheetThreadProc(LPVOID dwParam)
{
    TRACE_FUNCTION(PropertySheetThreadProc);

    HRESULT hr = S_OK;
    using AMC::CPropertySheet;
    CPropertySheet* pSheet = reinterpret_cast<CPropertySheet*>(dwParam);

    ASSERT(pSheet != NULL);
    if ( pSheet == NULL )
        return E_INVALIDARG;

    /*
     * Bug 372188: Allow this thread to inherit the input locale (aka
     * keyboard layout) of the originating thread.
     */
    HKL hklThread = GetKeyboardLayout(pSheet->GetOriginatingThreadID());
    BOOL fUseCicSubstitehKL = FALSE;

    if (SUCCEEDED(CoInitialize(0)))
    {
        //
        // On CUAS/AIMM12 environment, GetKeyboardLayout() could return
        // non-IME hKL but Cicero Keyboard TIP is running, we need to get
        // the substitute hKL of the current language.
        //
        HKL hkl = CicSubstGetDefaultKeyboardLayout((LANGID)(DWORD)HandleToLong(hklThread));
        CoUninitialize();

        if (hkl && (hkl != hklThread))
        {
            fUseCicSubstitehKL = TRUE;
            ActivateKeyboardLayout(hkl, 0);
        }
    }

    if (!fUseCicSubstitehKL)
       ActivateKeyboardLayout (hklThread, 0);

    // do the property sheet
    hr = PropertySheetProc( pSheet );

    if ( FAILED(hr) )
    {
        // the error occured - thread needs to clenup
        delete pSheet;
        return hr;
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     MmcIsolationAwarePropertySheet
//
//  Synopsis:   Gets the isolation aware PropertySheet on fusion
//              aware systems.
//
// Description:	Bug:
//              A non-themed snapin calls calls COMCTL32 v5 ! CreatePropertySheetPageW
//              mmcndmgr calls comctl32v6 ! PropertySheetW, via IsolationAwarePropertySheetW
//              v5 propertysheetpages have no context IsolationAwarePropertySheetW pushs
//              mmcndmgr's context, which gives comctl v6 so, pages with "no" context 
//              (not even the null context) get the activation context of the container. 
//              This is wrong, they should get NULL.
//
//              Cause: (see windows bug # 342553)
//              Before this change, the PropertySheetW wrapper in shfusion1 activated null actually.
//              But activating not NULL is what many scenarios expect (hosted code, but not hosted
//              property sheet/pages), and a number of people hit this, so comctl team changed 
//              IsolationAwarePropertySheetW.
//
//              Fix:
//              There is no win-win here. As a hoster of third party property pages, mmcmdmgr should
//              push null around PropertySheetW. It'd call IsolationAwareLoadLibrary to get the HMODULE
//              to comctl v6, GetProcess, IsolationAwareActivateActCtx to get a delayloaded ActivateActCtx...
//              Basically, hosters (with manifest) of fusion unaware plugins I think cannot call IsolationAwarePropertySheetW
//
//  Arguments:
//              [lpph]   -  See PropertySheet Windows API for details
//
//--------------------------------------------------------------------
typedef int ( WINAPI * PFN_PROPERTY_SHEET)( LPCPROPSHEETHEADER lppph);
int MmcIsolationAwarePropertySheet( LPCPROPSHEETHEADER lpph)
{
	static PFN_PROPERTY_SHEET s_pfn;
	ULONG_PTR ulCookie;
	int i = -1;

	if (s_pfn == NULL)
	{
		HMODULE hmod = LoadLibrary( TEXT("Comctl32.dll") ); // actually IsolationAwareLoadLibrary, via the macros in winbase.inl
		if (hmod == NULL)
			return i;

#ifdef UNICODE
		s_pfn = (PFN_PROPERTY_SHEET) GetProcAddress(hmod, "PropertySheetW");
#else  //UNICODE
		s_pfn = (PFN_PROPERTY_SHEET) GetProcAddress(hmod, "PropertySheetA");
#endif //!UNICODE

		if (s_pfn == NULL)
			return i;
	}

	if (!MmcDownlevelActivateActCtx(NULL, &ulCookie))
		return i;

	__try
	{
		i = s_pfn(lpph);
	}
	__finally
	{
		MmcDownlevelDeactivateActCtx(0, ulCookie);
	}

	return i;
}


/***************************************************************************\
 *
 * METHOD:  PropertySheetProc
 *
 * PURPOSE: Property sheet procedure used both from the main thread, as
 *          well from other threads
 *
 * PARAMETERS:
 *    CPropertySheet* pSheet [in] pointer to the sheet
 *
 * RETURNS:
 *    HRESULT    - result code (NOTE: cannot use SC, since it isn't thread-safe)
 *    NOTE:      if error is returned , caller needs to delete the sheet,
 *               else the sheet will be deleted when the window is closed
 *
\***************************************************************************/
HRESULT PropertySheetProc(AMC::CPropertySheet* pSheet)
{
    // parameter check
    if ( pSheet == NULL )
        return E_INVALIDARG;

    using AMC::CPropertySheet;
    HWND hwnd = NULL;
    int nReturn = -1;

    BOOL bIsWizard = (pSheet->IsWizard() || pSheet->m_bModalProp == TRUE);
    DWORD tid = GetCurrentThreadId();
    pSheet->m_dwTid = tid;

    // if there aren't any pages, add the No Props page
    if (pSheet->m_pstHeader.nPages == 0)
        pSheet->AddNoPropsPage();

    if (pSheet->m_pstHeader.nPages == 0)
    {
        TRACE(_T("PropertySheetProc(): No pages for the property sheet\n"));
        return E_FAIL;
    }

    // Hook the WndProc to get the message
    pSheet->m_msgHook = SetWindowsHookEx(WH_CALLWNDPROCRET, MessageProc,
                                GetModuleHandle(NULL), tid);


    if (pSheet->m_msgHook == NULL)
    {
        TRACE(_T("PropertySheetProc(): Unable to create hook\n"), GetLastError());
        return E_FAIL;
    }
    else
    {
        if (!bIsWizard)
        {
            HRESULT hr = ::CoInitialize(NULL);
            if ( FAILED(hr) )
                return hr;
        }

        CPropertySheetProvider::TID_LIST.Add(tid, pSheet);
        nReturn = MmcIsolationAwarePropertySheet(&pSheet->m_pstHeader);

        if (!bIsWizard)
            ::CoUninitialize();
    }

    // Reboot the system if the propsheet wants it.
    if (nReturn == ID_PSREBOOTSYSTEM || nReturn == ID_PSRESTARTWINDOWS)
    {
            DWORD OldState, Status;
            DWORD dwErrorSave;

            SetLastError(0);        // Be really safe about last error value!

            // detect if we are running on Win95 and skip security
            DWORD dwVer = GetVersion();
            if (!((dwVer & 0x80000000) && LOBYTE(LOWORD(dwVer)) == 4))
            {
                SetPrivilegeAttribute(SE_SHUTDOWN_NAME,
                                               SE_PRIVILEGE_ENABLED,
                                               &OldState);
            }
            dwErrorSave = GetLastError();       // ERROR_NOT_ALL_ASSIGNED sometimes

            if (dwErrorSave != NO_ERROR || !ExitWindowsEx(EWX_REBOOT, 0))
            {
                CStr strText;
                strText.LoadString(GetStringModule(), IDS_NO_PERMISSION_SHUTDOWN);
                MessageBox(NULL, strText, NULL, MB_ICONSTOP);
            }
    }

    // return the value from the Win32 PropertySheet call
    return (nReturn == IDOK) ? S_OK : S_FALSE;
}


///////////////////////////////////////////////////////////////////////////////
// Hidden Data Window
//

LRESULT CALLBACK DataWndProc(HWND hWnd, UINT nMsg, WPARAM  wParam, LPARAM  lParam)
{
    switch (nMsg)
    {
        case WM_CREATE:
            // this structure is initialized by the creator of the data window
            SetWindowLongPtr (hWnd, WINDOW_DATA_PTR_SLOT,
                              reinterpret_cast<LONG_PTR>(new DataWindowData));
            _Module.Lock();  // Lock the dll so that it does not get unloaded 
                             // when property sheet is up (507338)[XPSP1: 59916]

            break;

        case WM_DESTROY:
            delete GetDataWindowData (hWnd);
            _Module.Unlock(); // See above Lock for comments.
            break;
    }

    return DefWindowProc(hWnd, nMsg, wParam, lParam);
}

///////////////////////////////////////////////////////////////////////////////
// Callback procedures
//


LRESULT CALLBACK MessageProc(int nCode, WPARAM wParam, LPARAM lParam)
{
    using AMC::CPropertySheet;
    CPropertySheet* pSheet = NULL;

    BOOL b = CPropertySheetProvider::TID_LIST.Find(GetCurrentThreadId(), pSheet);

    if (!b)
    {
        ASSERT(FALSE);
        return 0;
    }

    // WM_NCDESTROY will delete pSheet, so make a copy of the hook
    ASSERT (pSheet            != NULL);
    ASSERT (pSheet->m_msgHook != NULL);
    HHOOK hHook = pSheet->m_msgHook;

	if (nCode == HC_ACTION)
	{
		CWPRETSTRUCT* pMsg = reinterpret_cast<CWPRETSTRUCT*>(lParam);

		switch (pMsg->message)
		{
			case WM_CREATE:
				pSheet->OnCreate(pMsg);
				break;
	
			case WM_INITDIALOG:
				pSheet->OnInitDialog(pMsg);
				break;
	
			case WM_NCDESTROY:
				pSheet->OnNcDestroy(pMsg);
				break;
	
			case WM_NOTIFY:
				pSheet->OnWMNotify(pMsg);
				break;
	
			default:
				break;
		}
	}

	return CallNextHookEx(hHook, nCode, wParam, lParam);
}

STDMETHODIMP CPropertySheetProvider::AddPrimaryPages(LPUNKNOWN lpUnknown,
                                      BOOL bCreateHandle, HWND hNotifyWindow, BOOL bScopePane)
{
    // The primary pages are added first before the sheet is created
    // Use the internal list to collect the pages, then empty it for the
    // extensions

    // NULL IComponent means the owner of the provider has added pages
    // without implementing IExtendPropertySheet


    LPPROPERTYNOTIFYINFO pNotify = NULL;
    HRESULT hr = S_OK;

    if (lpUnknown != NULL)
    {
        ASSERT(m_pSheet != NULL);

        if(bScopePane)
        {
            IComponentDataPtr spComponentData = lpUnknown;
            m_pSheet->SetComponentData(spComponentData);
        }
        else
        {
            IComponentPtr spComponent = lpUnknown;
            m_pSheet->SetComponent(spComponent);
        }

        // Bug 149211:  Allow callers to pass a NULL IDataObject* to CreatePropertySheet
        // ASSERT(m_pSheet->m_spDataObject != NULL);

        IExtendPropertySheetPtr  spExtend  = lpUnknown;
        IExtendPropertySheet2Ptr spExtend2 = lpUnknown;

        // determine which pointer to use
        IExtendPropertySheet* pExtend;

        if (spExtend2 != NULL)
            pExtend = spExtend2;
        else
            pExtend = spExtend;

        if (pExtend == NULL)
            return E_NOINTERFACE;

        /*
         * Bug 282932: make sure this property sheet extension
         * stays alive for the life of the property sheet
         */
        m_pSheet->m_Extenders.push_back (pExtend);

        hr = pExtend->QueryPagesFor(m_pSheet->m_spDataObject);
        if (hr != S_OK)
            return hr;

        // Create the notify object
        if (bCreateHandle == TRUE)
        {
            pNotify = reinterpret_cast<LPPROPERTYNOTIFYINFO>(
                            ::GlobalAlloc(GPTR, sizeof(PROPERTYNOTIFYINFO)));

            pNotify->pComponentData = NULL;
            pNotify->pComponent     = NULL;
            pNotify->fScopePane     = bScopePane;

            /*
             * Bug 190060:  Ignore the window passed in.  We always want to
             * notify the main frame window because that's the only window
             * that knows how to process MMC_MSG_PROP_SHEET_NOTIFY.
             */
//          pNotify->hwnd = hNotifyWindow;
            pNotify->hwnd = CScopeTree::GetScopeTree()->GetMainWindow();

            // The component data and component are not ref counted.
            // This is OK because the snap-in has to exist.
            // Because the snapin and it's in another thread
            // and I would have to marshall the pointers.
            if (bScopePane == TRUE)
            {
                IComponentDataPtr spCompData = lpUnknown;
                pNotify->pComponentData = spCompData;
            }
            else
            {
                IComponentPtr spComp = lpUnknown;
                pNotify->pComponent = spComp;
            }
        }

        /*
         * if it's a new-style wizard, get the watermark info
         */
        if (m_pSheet->IsWizard97())
        {
            /*
             * we get the watermark info with IExtendPropertySheet2
             */
            if (spExtend2 != NULL)
            {
				/*
				 * this may force an old-style wizard
				 */
				m_pSheet->GetWatermarks (spExtend2);
            }

            /*
             * If the snap-in doesn't support IExtendPropertySheet2,
             * we'll give him an old-style wizard.  This is
             * broken, but it maintains compatibility with 1.1
             * snap-ins (e.g. SMS) that counted on not getting a Wizard97-
             * style wizard, even though they asked for one with
             * MMC_PSO_NEWWIZARDTYPE.
             */
            else
                m_pSheet->ForceOldStyleWizard();
        }

        if (! m_pSheet->IsWizard())
        {
            // If m_pSheet->m_pMTNode is null then we get the mtnode
            // from CNodeInitObject. But this is root node of snapin
            // So add ellipses to full path.
            BOOL bAddEllipses = FALSE;
            if (NULL == m_pSheet->m_pMTNode)
            {
                // Looks like the snapin used property sheet provider. So get the
                // root master node of the snapin.
                CNodeInitObject* pNodeInitObj = dynamic_cast<CNodeInitObject*>(this);
                m_pSheet->m_pMTNode = pNodeInitObj ? pNodeInitObj->GetMTNode() : NULL;

                // We need to add ellipses
                bAddEllipses = TRUE;
            }

            if (m_pSheet->m_pMTNode)
            {
                LPOLESTR lpszPath = NULL;

                CScopeTree::GetScopeTree()->GetPathString(NULL,
                                                          CMTNode::ToHandle(m_pSheet->m_pMTNode),
                                                          &lpszPath);

                USES_CONVERSION;
                m_pSheet->m_PropToolTips.SetFullPath(OLE2T(lpszPath), bAddEllipses);
                ::CoTaskMemFree((LPVOID)lpszPath);
            }

            // Now let us get the primary snapin name.
            LPDATAOBJECT lpDataObject = (m_pSheet->m_spDataObject) ?
                                                m_pSheet->m_spDataObject :
                                                m_pSheet->m_pThreadLocalDataObject;

            // Get the snapin name that is going to add pages.
            // This is stored in temp member of CPropertySheetToolTips
            // so that IPropertySheetCallback::AddPage knows which snapin
            // is adding pages.

            CLSID clsidSnapin;
            SC sc = ExtractSnapInCLSID(lpDataObject, &clsidSnapin);
            if (sc)
            {
                sc.TraceAndClear();
            }
            else
            {
                tstring strName;
                if ( GetSnapinNameFromCLSID(clsidSnapin, strName))
                    m_pSheet->m_PropToolTips.SetThisSnapin(strName.data());
            }
        }

        hr = pExtend->CreatePropertyPages(
            dynamic_cast<LPPROPERTYSHEETCALLBACK>(this),
            reinterpret_cast<LONG_PTR>(pNotify), // deleted in Nodemgr
            m_pSheet->m_spDataObject);
    }

	/*
	 * Bug 28193:  If we're called with a NULL IUnknown, we also want to
	 * force old-style wizards.
	 */
	else if (m_pSheet->IsWizard97())
		m_pSheet->ForceOldStyleWizard();

    // Build the property sheet structure from the list of pages
    if (hr == S_OK)
    {
        POSITION pos;
        int nCount = 0;

        pos = m_pSheet->m_PageList.GetHeadPosition();

        {
            while(pos)
            {
                m_pSheet->m_pages[nCount] =
                    reinterpret_cast<HPROPSHEETPAGE>(m_pSheet->m_PageList.GetNext(pos));
                nCount++;
            }

            ASSERT(nCount < MAXPROPPAGES);
            m_pSheet->m_pstHeader.nPages = nCount;

            // must be page 0 for wizards
            if (m_pSheet->IsWizard())
                m_pSheet->m_pstHeader.nStartPage = 0;

            // Empty the list for the extensions
            m_pSheet->m_PageList.RemoveAll();

            return S_OK;  // All done
        }
    }

// Reached here because of error or the snap-in decided not to add any pages
    if (FAILED(hr) && pNotify != NULL)
        ::GlobalFree(pNotify);

    return hr;
}

STDMETHODIMP CPropertySheetProvider::AddExtensionPages()
{
    DECLARE_SC(sc, TEXT("CPropertySheetProvider::AddExtensionPages"));

    if (m_pSheet == NULL)
        return E_UNEXPECTED;

    // Note: extension are not added until the WM_INITDIALOG of the sheet
    // This insures that the primaries pages are created the original size
    // and will make the extension pages conform
    if (m_pSheet->m_PageList.GetCount() != 0)
        return E_UNEXPECTED;

    // Make sure I have one of the two data objects(main or marshalled)
    ASSERT ((m_pSheet->m_spDataObject == NULL) != (m_pSheet->m_pThreadLocalDataObject == NULL));
    if ((m_pSheet->m_spDataObject == NULL) == (m_pSheet->m_pThreadLocalDataObject == NULL))
        return E_UNEXPECTED;

    LPDATAOBJECT lpDataObject = (m_pSheet->m_spDataObject) ?
                                        m_pSheet->m_spDataObject :
                                        m_pSheet->m_pThreadLocalDataObject;

    CExtensionsIterator it;
    sc = it.ScInitialize(lpDataObject, g_szPropertySheet);
    if (sc)
    {
        return S_FALSE;
    }

    IExtendPropertySheetPtr spPropertyExtension;

    LPPROPERTYSHEETCALLBACK pCallBack = dynamic_cast<LPPROPERTYSHEETCALLBACK>(this);
    ASSERT(pCallBack != NULL);

    // CoCreate each snap-in and have it add a sheet
    for ( ;!it.IsEnd(); it.Advance())
    {
        sc = spPropertyExtension.CreateInstance(it.GetCLSID(), NULL, MMC_CLSCTX_INPROC);

        if (!sc.IsError())
        {
            // Get the snapin name that is going to add pages.
            // This is stored in temp member of CPropertySheetToolTips
            // so that IPropertySheetCallback::AddPage knows which snapin
            // is adding pages.
            WTL::CString strName;
            // Fix for bug #469922(9/20/2001): [XPSP1 Bug 599913]:
            // DynamicExtensions broken in MMC20
            // Snapin structures are only avail on static extensions - 
            // get the name from reg for DynExtensions

            if (!it.IsDynamic())
            {
                if (!it.GetSnapIn()->ScGetSnapInName(strName).IsError())
                    m_pSheet->m_PropToolTips.SetThisSnapin(strName);
            }
            else
            {
                if(!ScGetSnapinNameFromRegistry(it.GetCLSID(),strName).IsError())
                    m_pSheet->m_PropToolTips.SetThisSnapin(strName);
            }


            spPropertyExtension->CreatePropertyPages(pCallBack, NULL, lpDataObject);

            /*
             * Bug 282932: make sure this property sheet extension
             * stays alive for the life of the property sheet
             */
            m_pSheet->m_Extenders.push_back (spPropertyExtension);
        }
        else
        {
#if 0 //#ifdef DBG
            USES_CONVERSION;
            wchar_t buf[64];
            StringFromGUID2 (spSnapIn->GetSnapInCLSID(), buf, countof(buf));
            TRACE(_T("CLSID %s does not implement IID_IExtendPropertySheet\n"), W2T(buf));
#endif
        }

    }


    m_pSheet->AddExtensionPages();
    m_pSheet->m_bAddExtension = TRUE;

    return S_OK;
}


STDMETHODIMP
CPropertySheetProvider::AddMultiSelectionExtensionPages(LONG_PTR lMultiSelection)
{
    if (m_pSheet == NULL)
        return E_UNEXPECTED;

    if (lMultiSelection == 0)
        return E_INVALIDARG;

    CMultiSelection* pMS = reinterpret_cast<CMultiSelection*>(lMultiSelection);
    ASSERT(pMS != NULL);

    // Note: extension are not added until the WM_INITDIALOG of the sheet
    // This insures that the primaries pages are created the original size
    // and will make the extension pages conform
    if (m_pSheet->m_PageList.GetCount() != 0)
        return E_UNEXPECTED;

    // Make sure I have one of the two data objects(main or marshalled)
    ASSERT ((m_pSheet->m_spDataObject == NULL) != (m_pSheet->m_pThreadLocalDataObject == NULL));
    if ((m_pSheet->m_spDataObject == NULL) == (m_pSheet->m_pThreadLocalDataObject == NULL))
        return E_UNEXPECTED;

    do // not a loop
    {
        CList<CLSID, CLSID&> snapinClsidList;
        HRESULT hr = pMS->GetExtensionSnapins(g_szPropertySheet, snapinClsidList);
        BREAK_ON_FAIL(hr);

        POSITION pos = snapinClsidList.GetHeadPosition();
        if (pos == NULL)
            break;

        IDataObjectPtr spDataObject;
        hr = pMS->GetMultiSelDataObject(&spDataObject);
        ASSERT(SUCCEEDED(hr));
        BREAK_ON_FAIL(hr);

        BOOL fProblem = FALSE;
        IExtendPropertySheetPtr spPropertyExtension;
        LPPROPERTYSHEETCALLBACK pCallBack = dynamic_cast<LPPROPERTYSHEETCALLBACK>(this);
        ASSERT(pCallBack != NULL);

        while (pos)
        {
           CLSID clsid = snapinClsidList.GetNext(pos);

            // CoCreate each snap-in and have it add a sheet
            //
            hr = spPropertyExtension.CreateInstance(clsid, NULL,
                                                    MMC_CLSCTX_INPROC);
            CHECK_HRESULT(hr);
            if (FAILED(hr))
            {
#ifdef DBG
                wchar_t buf[64];
                buf[0] = NULL;

                StringFromCLSID(clsid, (LPOLESTR*)&buf);
                TRACE(_T("CLSID %s does not implement IID_IExtendPropertySheet\n"), &buf);
#endif

                fProblem = TRUE;    // Continue even on error.
                continue;
            }

            spPropertyExtension->CreatePropertyPages(pCallBack, NULL, spDataObject);
        }

        if (fProblem == TRUE)
            hr = S_FALSE;

    } while (0);

    m_pSheet->AddExtensionPages();
    m_pSheet->m_bAddExtension = TRUE;

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     SetPropertySheetData
//
//  Synopsis:   Data pertaining to property sheet
//
//  Arguments:  [nPropertySheetType] - EPropertySheetType enum (scope item, result item...)
//              [hMTNode] - The master node that owns the property sheet for scope item
//                          or that owns list view item of property sheet.
//
//--------------------------------------------------------------------
STDMETHODIMP CPropertySheetProvider::SetPropertySheetData(INT nPropSheetType, HMTNODE hMTNode)
{
    m_pSheet->m_PropToolTips.SetPropSheetType((EPropertySheetType)nPropSheetType);

    if (hMTNode)
    {
        m_pSheet->m_pMTNode = CMTNode::FromHandle(hMTNode);
    }

    return S_OK;
}


// Copied from security.c in shell\shelldll
/*++

Routine Description:

    This routine sets the security attributes for a given privilege.
Arguments:

    PrivilegeName - Name of the privilege we are manipulating.
    NewPrivilegeAttribute - The new attribute value to use.
    OldPrivilegeAttribute - Pointer to receive the old privilege value. OPTIONAL

Return value:
    NO_ERROR or WIN32 error.

--*/

DWORD SetPrivilegeAttribute(LPCTSTR PrivilegeName, DWORD NewPrivilegeAttribute, DWORD *OldPrivilegeAttribute)
{
    LUID             PrivilegeValue;
    BOOL             Result;
    TOKEN_PRIVILEGES TokenPrivileges, OldTokenPrivileges;
    DWORD            ReturnLength;
    HANDLE           TokenHandle;

    //
    // First, find out the LUID Value of the privilege
    //

    if(!LookupPrivilegeValue(NULL, PrivilegeName, &PrivilegeValue)) {
        return GetLastError();
    }

    //
    // Get the token handle
    //
    if (!OpenProcessToken (
             GetCurrentProcess(),
             TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
             &TokenHandle
             )) {
        return GetLastError();
    }

    //
    // Set up the privilege set we will need
    //

    TokenPrivileges.PrivilegeCount = 1;
    TokenPrivileges.Privileges[0].Luid = PrivilegeValue;
    TokenPrivileges.Privileges[0].Attributes = NewPrivilegeAttribute;

    ReturnLength = sizeof(TOKEN_PRIVILEGES);
    if (!AdjustTokenPrivileges (
                TokenHandle,
                FALSE,
                &TokenPrivileges,
                sizeof(TOKEN_PRIVILEGES),
                &OldTokenPrivileges,
                &ReturnLength
                )) {
        CloseHandle(TokenHandle);
        return GetLastError();
    }
    else {
        if (OldPrivilegeAttribute != NULL) {
            *OldPrivilegeAttribute = OldTokenPrivileges.Privileges[0].Attributes;
        }
        CloseHandle(TokenHandle);
        return NO_ERROR;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\regkeyex.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       regkeyex.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"


//____________________________________________________________________________
//
//  Member:     CRegKeyEx::ScCreate
//
//  Synopsis:   Same meaning as for RegCreateKeyEx API.
//
//  Arguments:  [hKeyAncestor] -- IN
//              [lpszKeyName] -- IN
//              [security] -- IN
//              [pdwDisposition] -- OUT
//              [dwOption] -- IN
//              [pSecurityAttributes] -- OUT
//
//  Returns:    SC
//
//  History:    5/24/1996   RaviR   Created
//____________________________________________________________________________
//

SC CRegKeyEx::ScCreate (
	HKEY					hKeyParent,
	LPCTSTR					lpszKeyName,
	LPTSTR					lpszClass,
	DWORD					dwOptions,
	REGSAM					samDesired,
	LPSECURITY_ATTRIBUTES	lpSecAttr,
	LPDWORD					lpdwDisposition)
{
	DECLARE_SC (sc, _T("CRegKeyEx::ScCreate"));

    LONG error = Create (hKeyParent, lpszKeyName, lpszClass, dwOptions,
						 samDesired, lpSecAttr, lpdwDisposition);

	return (sc = ScFromWin32(error));
}

//____________________________________________________________________________
//
//  Member:     CRegKeyEx::ScOpen
//
//  Synopsis:   Same meaning as RegOpenKeyEx
//
//  Arguments:  [hKeyAncestor] -- IN
//              [lpszKeyName] -- IN
//              [security] -- IN
//
//  Returns:    SC
//
//  History:    6/6/1996   RaviR   Created
//
//____________________________________________________________________________

SC CRegKeyEx::ScOpen (
    HKEY        hKeyAncestor,
    LPCTSTR     lpszKeyName,
    REGSAM      security)
{
	/*
	 * Open will frequently return ERROR_FILE_NOT_FOUND, which we
	 * don't want to be inundated with.  Don't assign to a tracing SC.
	 */
	return (ScFromWin32 (Open(hKeyAncestor, lpszKeyName, security)));
}


//____________________________________________________________________________
//
//  Member:     IsValuePresent
//
//  Arguments:  [lpszValueName] -- IN
//
//  Returns:    BOOL.
//
//  History:    3/21/1997   RaviR   Created
//____________________________________________________________________________
//

BOOL CRegKeyEx::IsValuePresent(LPCTSTR lpszValueName)
{
    DWORD cbData = 0;
    LONG error = ::RegQueryValueEx (m_hKey, lpszValueName, 0, NULL,
                                    NULL, &cbData);

    return (error == ERROR_SUCCESS);
}


//____________________________________________________________________________
//
//  Member:     CRegKeyEx::ScQueryValue
//
//  Synopsis:   Same meaning as for RegQueryValueEx API.
//
//  Arguments:  [lpszValueName] -- IN
//              [pType] -- IN
//              [pData] -- IN
//              [pLen] -- IN
//
//  Returns:    SC
//
//  History:    6/6/1996   RaviR   Created
//
//____________________________________________________________________________

SC CRegKeyEx::ScQueryValue (
    LPCTSTR lpszValueName,
    LPDWORD pType,
    PVOID   pData,
    LPDWORD pLen)
{
    ASSERT(pLen != NULL);
    ASSERT(m_hKey != NULL);

    LONG error = ::RegQueryValueEx (m_hKey, lpszValueName, 0, pType,
                                                  (LPBYTE)pData, pLen);

    // Do not trace the error as it is legal for ScQueryValue to fail.
	return (ScFromWin32 (error));
}


//____________________________________________________________________________
//
//  Member:     CRegKeyEx::ScEnumKey
//
//  Synopsis:   Same meaning as for RegEnumKeyEx API.
//
//  Arguments:  [iSubkey] -- IN
//              [lpszName] -- OUT place to store the name
//              [dwLen] -- IN
//              [lpszLastModified] -- IN
//
//  Returns:    SC
//
//  History:    5/22/1996   RaviR   Created
//
//____________________________________________________________________________

SC CRegKeyEx::ScEnumKey (
    DWORD       iSubkey,
    LPTSTR      lpszName,
    LPDWORD     lpcchName,
    PFILETIME   lpftLastModified)
{
	DECLARE_SC (sc, _T("CRegKeyEx::ScEnumKey"));

	/*
	 * validate input
	 */
	sc = ScCheckPointers (lpszName, lpcchName);
	if (sc)
		return (sc);

	if (*lpcchName == 0)
		return (sc = E_UNEXPECTED);

	/*
	 * make sure the key is open
	 */
	if (m_hKey == NULL)
		return (sc = E_UNEXPECTED);

    LONG error = ::RegEnumKeyEx (m_hKey, iSubkey, lpszName, lpcchName,
                                 NULL, NULL, NULL, lpftLastModified);

	/*
	 * RegEnumKeyEx will frequently return ERROR_NO_MORE_ITEMS, which we
	 * don't want to be inundated with.  Don't assign to a tracing SC.
	 */
	return (ScFromWin32 (error));
}

//____________________________________________________________________________
//
//  Member:     CRegKeyEx::ScEnumValue
//
//  Synopsis:   Same meaning as for RegEnumValue API.
//
//  Arguments:  [iValue] -- IN
//              [lpszValue] -- OUT
//              [lpcchValue] -- OUT
//              [lpdwType] -- OUT
//              [lpbData] -- OUT
//              [lpcbData] -- OUT
//
//  Returns:    SC
//
//  History:    6/6/1996   RaviR   Created
//
//____________________________________________________________________________

SC CRegKeyEx::ScEnumValue (
    DWORD   iValue,
    LPTSTR  lpszValue,
    LPDWORD lpcchValue,
    LPDWORD lpdwType,
    LPBYTE  lpbData,
    LPDWORD lpcbData)
{
	DECLARE_SC (sc, _T("CRegKeyEx::ScEnumValue"));

	/*
	 * validate input
	 */
	sc = ScCheckPointers (lpszValue, lpcchValue);
	if (sc)
		return (sc);

    if ((lpcbData == NULL) && (lpbData != NULL))
		return (sc = E_INVALIDARG);

	/*
	 * make sure the key is open
	 */
	if (m_hKey == NULL)
		return (sc = E_UNEXPECTED);

    LONG error = ::RegEnumValue (m_hKey, iValue, lpszValue, lpcchValue,
                                 NULL, lpdwType, lpbData, lpcbData);

	/*
	 * RegEnumValue will frequently return ERROR_NO_MORE_ITEMS, which we
	 * don't want to be inundated with.  Don't assign to a tracing SC.
	 */
	return (ScFromWin32 (error));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\ptrlist.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ptrlist.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"

  
#define ASSERT_VALID(ptr) /*ptr*/


MMC::CPtrList::CPtrList(int nBlockSize)
{
	ASSERT(nBlockSize > 0);

	m_nCount = 0;
	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
}

void MMC::CPtrList::RemoveAll()
{
	ASSERT_VALID(this);

	// destroy elements


	m_nCount = 0;
	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
}

MMC::CPtrList::~CPtrList()
{
	RemoveAll();
	ASSERT(m_nCount == 0);
}

/////////////////////////////////////////////////////////////////////////////
// Node helpers
/*
 * Implementation note: CNode's are stored in CPlex blocks and
 *  chained together. Free blocks are maintained in a singly linked list
 *  using the 'pNext' member of CNode with 'm_pNodeFree' as the head.
 *  Used blocks are maintained in a doubly linked list using both 'pNext'
 *  and 'pPrev' as links and 'm_pNodeHead' and 'm_pNodeTail'
 *   as the head/tail.
 *
 * We never free a CPlex block unless the List is destroyed or RemoveAll()
 *  is used - so the total number of CPlex blocks may grow large depending
 *  on the maximum past size of the list.
 */

MMC::CPtrList::CNode*
MMC::CPtrList::NewNode(MMC::CPtrList::CNode* pPrev, MMC::CPtrList::CNode* pNext)
{
	if (m_pNodeFree == NULL)
	{
		// add another block
		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,
				 sizeof(CNode));

		// chain them into free list
		CNode* pNode = (CNode*) pNewBlock->data();
		// free in reverse order to make it easier to debug
		pNode += m_nBlockSize - 1;
		for (int i = m_nBlockSize-1; i >= 0; i--, pNode--)
		{
			pNode->pNext = m_pNodeFree;
			m_pNodeFree = pNode;
		}
	}
	ASSERT(m_pNodeFree != NULL);  // we must have something

	MMC::CPtrList::CNode* pNode = m_pNodeFree;
	m_pNodeFree = m_pNodeFree->pNext;
	pNode->pPrev = pPrev;
	pNode->pNext = pNext;
	m_nCount++;
	ASSERT(m_nCount > 0);  // make sure we don't overflow


	memset(&pNode->data, 0, sizeof(void*));  // zero fill

	return pNode;
}

void MMC::CPtrList::FreeNode(MMC::CPtrList::CNode* pNode)
{

	pNode->pNext = m_pNodeFree;
	m_pNodeFree = pNode;
	m_nCount--;
	ASSERT(m_nCount >= 0);  // make sure we don't underflow
}

/////////////////////////////////////////////////////////////////////////////

POSITION MMC::CPtrList::AddHead(void* newElement)
{
	ASSERT_VALID(this);

	CNode* pNewNode = NewNode(NULL, m_pNodeHead);
	pNewNode->data = newElement;
	if (m_pNodeHead != NULL)
		m_pNodeHead->pPrev = pNewNode;
	else
		m_pNodeTail = pNewNode;
	m_pNodeHead = pNewNode;
	return (POSITION) pNewNode;
}

POSITION MMC::CPtrList::AddTail(void* newElement)
{
	ASSERT_VALID(this);

	CNode* pNewNode = NewNode(m_pNodeTail, NULL);
	pNewNode->data = newElement;
	if (m_pNodeTail != NULL)
		m_pNodeTail->pNext = pNewNode;
	else
		m_pNodeHead = pNewNode;
	m_pNodeTail = pNewNode;
	return (POSITION) pNewNode;
}

void MMC::CPtrList::AddHead(CPtrList* pNewList)
{
	ASSERT_VALID(this);

	ASSERT(pNewList != NULL);
	ASSERT_VALID(pNewList);

	// add a list of same elements to head (maintain order)
	POSITION pos = pNewList->GetTailPosition();
	while (pos != NULL)
		AddHead(pNewList->GetPrev(pos));
}

void MMC::CPtrList::AddTail(CPtrList* pNewList)
{
	ASSERT_VALID(this);
	ASSERT(pNewList != NULL);
	ASSERT_VALID(pNewList);

	// add a list of same elements
	POSITION pos = pNewList->GetHeadPosition();
	while (pos != NULL)
		AddTail(pNewList->GetNext(pos));
}

void* MMC::CPtrList::RemoveHead()
{
	ASSERT_VALID(this);
	ASSERT(m_pNodeHead != NULL);  // don't call on empty list !!!
	ASSERT(_IsValidAddress(m_pNodeHead, sizeof(CNode)));

	CNode* pOldNode = m_pNodeHead;
	void* returnValue = pOldNode->data;

	m_pNodeHead = pOldNode->pNext;
	if (m_pNodeHead != NULL)
		m_pNodeHead->pPrev = NULL;
	else
		m_pNodeTail = NULL;
	FreeNode(pOldNode);
	return returnValue;
}

void* MMC::CPtrList::RemoveTail()
{
	ASSERT_VALID(this);
	ASSERT(m_pNodeTail != NULL);  // don't call on empty list !!!
	ASSERT(_IsValidAddress(m_pNodeTail, sizeof(CNode)));

	CNode* pOldNode = m_pNodeTail;
	void* returnValue = pOldNode->data;

	m_pNodeTail = pOldNode->pPrev;
	if (m_pNodeTail != NULL)
		m_pNodeTail->pNext = NULL;
	else
		m_pNodeHead = NULL;
	FreeNode(pOldNode);
	return returnValue;
}

POSITION MMC::CPtrList::InsertBefore(POSITION position, void* newElement)
{
	ASSERT_VALID(this);

	if (position == NULL)
		return AddHead(newElement); // insert before nothing -> head of the list

	// Insert it before position
	CNode* pOldNode = (CNode*) position;
	CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
	pNewNode->data = newElement;

	if (pOldNode->pPrev != NULL)
	{
		ASSERT(_IsValidAddress(pOldNode->pPrev, sizeof(CNode)));
		pOldNode->pPrev->pNext = pNewNode;
	}
	else
	{
		ASSERT(pOldNode == m_pNodeHead);
		m_pNodeHead = pNewNode;
	}
	pOldNode->pPrev = pNewNode;
	return (POSITION) pNewNode;
}

POSITION MMC::CPtrList::InsertAfter(POSITION position, void* newElement)
{
	ASSERT_VALID(this);

	if (position == NULL)
		return AddTail(newElement); // insert after nothing -> tail of the list

	// Insert it before position
	CNode* pOldNode = (CNode*) position;
	ASSERT(_IsValidAddress(pOldNode, sizeof(CNode)));
	CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
	pNewNode->data = newElement;

	if (pOldNode->pNext != NULL)
	{
		ASSERT(_IsValidAddress(pOldNode->pNext, sizeof(CNode)));
		pOldNode->pNext->pPrev = pNewNode;
	}
	else
	{
		ASSERT(pOldNode == m_pNodeTail);
		m_pNodeTail = pNewNode;
	}
	pOldNode->pNext = pNewNode;
	return (POSITION) pNewNode;
}

void MMC::CPtrList::RemoveAt(POSITION position)
{
	ASSERT_VALID(this);

	CNode* pOldNode = (CNode*) position;
	ASSERT(_IsValidAddress(pOldNode, sizeof(CNode)));

	// remove pOldNode from list
	if (pOldNode == m_pNodeHead)
	{
		m_pNodeHead = pOldNode->pNext;
	}
	else
	{
		ASSERT(_IsValidAddress(pOldNode->pPrev, sizeof(CNode)));
		pOldNode->pPrev->pNext = pOldNode->pNext;
	}
	if (pOldNode == m_pNodeTail)
	{
		m_pNodeTail = pOldNode->pPrev;
	}
	else
	{
		ASSERT(_IsValidAddress(pOldNode->pNext, sizeof(CNode)));
		pOldNode->pNext->pPrev = pOldNode->pPrev;
	}
	FreeNode(pOldNode);
}


/////////////////////////////////////////////////////////////////////////////
// slow operations

POSITION MMC::CPtrList::FindIndex(int nIndex) const
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);

	if (nIndex >= m_nCount)
		return NULL;  // went too far

	CNode* pNode = m_pNodeHead;
	while (nIndex--)
	{
		ASSERT(_IsValidAddress(pNode, sizeof(CNode)));
		pNode = pNode->pNext;
	}
	return (POSITION) pNode;
}

POSITION MMC::CPtrList::Find(void* searchValue, POSITION startAfter) const
{
	ASSERT_VALID(this);

	CNode* pNode = (CNode*) startAfter;
	if (pNode == NULL)
	{
		pNode = m_pNodeHead;  // start at head
	}
	else
	{
		ASSERT(_IsValidAddress(pNode, sizeof(CNode)));
		pNode = pNode->pNext;  // start after the one specified
	}

	for (; pNode != NULL; pNode = pNode->pNext)
		if (pNode->data == searchValue)
			return (POSITION) pNode;
	return NULL;
}

#ifdef _DBG
void MMC::CPtrList::AssertValid() const
{
	if (m_nCount == 0)
	{
		// empty list
		ASSERT(m_pNodeHead == NULL);
		ASSERT(m_pNodeTail == NULL);
	}
	else
	{
		// non-empty list
		ASSERT(_IsValidAddress(m_pNodeHead, sizeof(CNode)));
		ASSERT(_IsValidAddress(m_pNodeTail, sizeof(CNode)));
	}
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\propsht.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       propsht.h
//
//--------------------------------------------------------------------------


// Declaration for callback functions
LRESULT CALLBACK MessageProc(int nCode, WPARAM wParam, LPARAM lParam);

// Declaration for data window wnd Proc
LRESULT CALLBACK DataWndProc(HWND hWnd, UINT nMsg, WPARAM  wParam, LPARAM  lParam);

// Forward declarations
class CNodeInitObject;
class CPropertySheetProvider;

// Type definitions
typedef CList<HANDLE, HANDLE> PAGE_LIST;

#include "tstring.h"

enum EPropertySheetType
{
    epstScopeItem = 0,
    epstResultItem = 1,
    epstMultipleItems = 2,
};

///////////////////////////////////////////////////////////////////////////////
// CThreadData - Base class for thread based objects
//

namespace AMC
{
    class CThreadData
    {
        public:
            CThreadData() {m_dwTid = 0;};

        public:
            UINT m_dwTid;
    };
}


class CNoPropsPropertyPage : public WTL::CPropertyPageImpl<CNoPropsPropertyPage>
{
    typedef WTL::CPropertyPageImpl<CNoPropsPropertyPage> BaseClass;

public:
    CNoPropsPropertyPage() {}
    ~CNoPropsPropertyPage() {}

public:
    enum { IDD = IDD_NOPROPS_PROPPAGE };
    BEGIN_MSG_MAP(CSnapinAboutPage)
        CHAIN_MSG_MAP(BaseClass)
    END_MSG_MAP()
};


//+-------------------------------------------------------------------
//
//  Class:      CPropertySheetToolTips
//
//  Purpose:    This class has stores tooltip data for
//              the property sheets. This includes fullpath
//              from the console root to property sheet owner
//              node, owner name and an array of snapin name
//              indexed by property page tab number.
//
//  History:    06-18-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
class CPropertySheetToolTips : public WTL::CToolTipCtrl
{
    // This is the id used for the tool tip control for property sheet
    // title. So when we get TTN_NEEDTEXT we can identify if the text
    // is for title or a tab.
    #define PROPSHEET_TITLE_TOOLTIP_ID            1234

private:
    tstring m_strThisSnapinName; // This is a temp member variable that has
                                 // snapin that is currently adding pages
                                 // This is used while constructing below
                                 // array of pages.
    std::vector<tstring> m_strSnapins; // Property page (tab) owner snapins array

    tstring m_strFullPath;
    tstring m_strItemName;
    EPropertySheetType m_PropSheetType;

public:
    CPropertySheetToolTips()
    {
    }

    CPropertySheetToolTips(const CPropertySheetToolTips& sp)
    {
        m_strThisSnapinName = sp.m_strThisSnapinName;
        m_strSnapins = sp.m_strSnapins;
        m_strFullPath = sp.m_strFullPath;
    }

    CPropertySheetToolTips& operator=(const CPropertySheetToolTips& sp)
    {
        if (this != &sp)
        {
            m_strThisSnapinName = sp.m_strThisSnapinName;
            m_strSnapins = sp.m_strSnapins;
            m_strFullPath = sp.m_strFullPath;
        }
        return (*this);
    }

    void SetThisSnapin(LPCTSTR szName)
    {
        m_strThisSnapinName = szName;
    }

    LPCTSTR GetThisSnapin()
    {
        return m_strThisSnapinName.data();
    }

    void AddSnapinPage()
    {
        m_strSnapins.push_back(m_strThisSnapinName);
    }


    LPCTSTR GetSnapinPage(int nIndex)
    {
        return m_strSnapins[nIndex].data();
    }

    INT GetNumPages()
    {
        return m_strSnapins.size();
    }

    LPCTSTR GetFullPath()
    {
        return m_strFullPath.data();
    }

    void SetFullPath(LPTSTR szName, BOOL bAddEllipses = FALSE)
    {
        m_strFullPath = szName;

        if (bAddEllipses)
            m_strFullPath += _T("...");
    }

    void SetItemName(LPTSTR szName)
    {
        m_strItemName = szName;
    }

    LPCTSTR GetItemName()
    {
        return m_strItemName.data();
    }

    void SetPropSheetType(EPropertySheetType propSheetType)
    {
        m_PropSheetType = propSheetType;
    }

    EPropertySheetType GetPropSheetType()
    {
        return m_PropSheetType;
    }

};


///////////////////////////////////////////////////////////////////////////////
// CPropertySheet - Basic property sheet class
//

namespace AMC
{
    class CPropertySheet : public AMC::CThreadData
    {
        friend class CPropertySheetProvider;

    // Constructor/Destructor
    public:
        CPropertySheet();
        virtual ~CPropertySheet();

    private:
        /*
         * copy construction and assignment aren't supported;
         * insure the compiler doesn't generate defaults
         */
        CPropertySheet (const CPropertySheet& other);
        CPropertySheet& operator= (const CPropertySheet& other);

    // Interface
    public:
        void CommonConstruct();
        BOOL Create(LPCTSTR lpszCaption, bool fPropSheet, MMC_COOKIE cookie, LPDATAOBJECT pDataObject,
            LONG_PTR lpMasterTreeNode, DWORD dwOptions);

        HRESULT DoSheet(HWND hParent, int nPage);  // create property sheet/pages and go modeless
        BOOL AddExtensionPages();
        void AddNoPropsPage();
        BOOL CreateDataWindow(HWND hParent);    // create the hidden data window
        bool IsWizard()   const { return (m_pstHeader.dwFlags & (PSH_WIZARD97 | PSH_WIZARD)); }
        bool IsWizard97() const { return (m_pstHeader.dwFlags &  PSH_WIZARD97); }
        void GetWatermarks (IExtendPropertySheet2* pExtend2);

        DWORD GetOriginatingThreadID () const
        {
            return (m_dwThreadID);
        }

        void ForceOldStyleWizard ();

        // Attributes
    public:
        PROPSHEETHEADER m_pstHeader;    //
        PAGE_LIST       m_PageList;     // page list for property sheet
        MMC_COOKIE      m_cookie;
        LONG_PTR        m_lpMasterNode; // master tree pointer
        LPSTREAM        m_pStream;              // Stream for marshalled pointer
        LPDATAOBJECT    m_pThreadLocalDataObject; // Marshalled data object pointer

        CMTNode*        m_pMTNode;       // MTNode of property sheet owner
        const DWORD     m_dwThreadID;   // ID of thread that created property sheet

        /*
         * Bug 187702: Use CXxxHandle instead of CXxx so the resources
         * will *not* be cleaned up on destruction.  Yes, this may leak if
         * the if the snap-in doesn't manage the object lifetime (which it
         * shouldn't have to do because these are OUT parameters for
         * IExtendPropertySheet2::GetWatermarks), but it's required for app
         * compat.
         */
		WTL::CBitmapHandle	m_bmpWatermark;
		WTL::CBitmapHandle	m_bmpHeader;
		WTL::CPaletteHandle	m_Palette;


    public:
        void                SetDataObject(   IDataObject    *pDataObject)   {m_spDataObject    = pDataObject;}
        void                SetComponent(    IComponent     *pComponent)    {m_spComponent     = pComponent;}
        void                SetComponentData(IComponentData *pComponentData){m_spComponentData = pComponentData;}

        IDataObject*        GetDataObject()    { return m_spDataObject.GetInterfacePtr();}
        IComponent *        GetComponent()     { return m_spComponent.GetInterfacePtr();}
        IComponentData *    GetComponentData() { return m_spComponentData.GetInterfacePtr();}

    private:
        IDataObjectPtr      m_spDataObject;
        IComponentDataPtr   m_spComponentData;
        IComponentPtr       m_spComponent;


        // components that extend this prop sheet
        std::vector<IUnknownPtr> m_Extenders;

        // streams containing exterders' marshalled interfaces (if required)
        std::vector<IStream*>    m_ExtendersMarshallStreams;

// Message handlers
    public:
    LRESULT OnCreate(CWPRETSTRUCT* pMsg);
    LRESULT OnInitDialog(CWPRETSTRUCT* pMsg);
    LRESULT OnNcDestroy(CWPRETSTRUCT* pMsg);
    LRESULT OnWMNotify(CWPRETSTRUCT* pMsg);

    public:
        HWND    m_hDlg;         // property sheet hwnd
        HHOOK   m_msgHook;      // hook handle for page, only valid through WM_INITDIALOG
        HWND    m_hDataWindow;  // hidden data window
        BOOL    m_bModalProp;   // TRUE if the property sheet should be modal
        BOOL    m_bAddExtension;// TRUE if we need to add extension pages

    private:
        HPROPSHEETPAGE          m_pages[MAXPROPPAGES];
        CStr                    m_title;
        CNoPropsPropertyPage    m_NoPropsPage;

    public:
        // Tooltip data
        CPropertySheetToolTips        m_PropToolTips;
    };
}

///////////////////////////////////////////////////////////////////////////////
// CThreadToSheetMap - Maps thread IDs to CPropertySheetObjects.
//
class CThreadToSheetMap
{
public:
    typedef DWORD                   KEY;
    typedef AMC::CPropertySheet *   VALUE;
    typedef std::map<KEY, VALUE>    CMap;

    CThreadToSheetMap(){};
    ~CThreadToSheetMap(){};

public:
    void Add(KEY id, VALUE pObject)
    {
        CSingleLock lock(&m_critSection, TRUE);
        m_map[id] = pObject;
    }

    void Remove(KEY id)
    {
        CSingleLock lock(&m_critSection, TRUE);
        m_map.erase(id);
    }

    BOOL Find(KEY id, VALUE& pObject)
    {
        CSingleLock lock(&m_critSection, TRUE);

        std::map<KEY, VALUE>::iterator it = m_map.find(id);
        if(it == m_map.end())
            return false;

        pObject = it->second;
        return true;
    }

public:
    CCriticalSection    m_critSection;

private:
    CMap m_map;
};


///////////////////////////////////////////////////////////////////////////////
// CPropertySheetProvider - The implementation for the IPropertySheetProvider
//                            interface.

class CPropertySheetProvider :
    public IPropertySheetProviderPrivate,
    public IPropertySheetCallback,
    public IPropertySheetNotify

{
    friend class AMCPropertySheet;

public:
    CPropertySheetProvider();
    ~CPropertySheetProvider();

// IPropertySheetProviderPrivate
public:
    STDMETHOD(CreatePropertySheet)(LPCWSTR title, unsigned char bType, MMC_COOKIE cookie,
              LPDATAOBJECT pDataObject, DWORD dwOptions);
    STDMETHOD(CreatePropertySheetEx)(LPCWSTR title, unsigned char bType, MMC_COOKIE cookie,
        LPDATAOBJECT pDataObject, LONG_PTR lpMasterTreeNode, DWORD dwOptions);
    STDMETHOD(Show)(LONG_PTR window, int page);
    STDMETHOD(ShowEx)(HWND hwnd, int page, BOOL bModalPage);
    STDMETHOD(FindPropertySheet)(MMC_COOKIE cookie, LPCOMPONENT lpComponent, LPDATAOBJECT lpDataObject);
    STDMETHOD(AddPrimaryPages)(LPUNKNOWN lpUnknown, BOOL bCreateHandle, HWND hNotifyWindow, BOOL bScopePane);
    STDMETHOD(AddExtensionPages)();
    STDMETHOD(AddMultiSelectionExtensionPages)(LONG_PTR lMultiSelection);
    STDMETHOD(FindPropertySheetEx)(MMC_COOKIE cookie, LPCOMPONENT lpComponent,
                                   LPCOMPONENTDATA lpComponentData, LPDATAOBJECT lpDataObject);
    STDMETHOD(SetPropertySheetData)(INT nPropSheetType, HMTNODE hMTNode);


// IPropertySheetCallback
public:
    STDMETHOD(AddPage)(HPROPSHEETPAGE page);
    STDMETHOD(RemovePage)(HPROPSHEETPAGE page);

// IPropertySheetNotify
public:
   STDMETHOD(Notify)(LPPROPERTYNOTIFYINFO pNotify, LPARAM lParam);

// Objects in common with all instances of IPropertySheetProvider(s)
    static CThreadToSheetMap TID_LIST;

public:
    AMC::CPropertySheet*    m_pSheet;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\regkeyex.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       regkeyex.h
//
//--------------------------------------------------------------------------

#pragma once

#include "shlwapip.h"	// for SHLoadRegUIString

/*
    regkeyex.h

    This class extends the ATL CRegKey class to make a replacement for
    the AMC::CRegKey class

    Much of this code is taken from the AMC::CRegKey class by RaviR
*/

class CRegKeyEx : public MMC_ATL::CRegKey
{
public:
	SC ScCreate (
		HKEY					hKeyParent,
		LPCTSTR					lpszKeyName,
		LPTSTR					lpszClass       = REG_NONE,
		DWORD					dwOptions       = REG_OPTION_NON_VOLATILE,
		REGSAM					samDesired      = KEY_ALL_ACCESS,
		LPSECURITY_ATTRIBUTES	lpSecAttr       = NULL,
		LPDWORD					lpdwDisposition = NULL);

	SC ScOpen(
			HKEY        hKey,
			LPCTSTR     lpszKeyName,
			REGSAM      security = KEY_ALL_ACCESS);

	BOOL IsValuePresent (LPCTSTR lpszValueName);

	SC ScQueryValue (LPCTSTR lpszValueName, LPDWORD pType,
					 PVOID pData, LPDWORD pLen);

	SC ScEnumKey (DWORD iSubkey, LPTSTR lpszName, LPDWORD lpcchName,
				  PFILETIME lpftLastModified = NULL);

	SC ScEnumValue (DWORD iValue, LPTSTR lpszValue, LPDWORD lpcchValue,
					LPDWORD lpdwType = NULL, LPBYTE lpbData = NULL,
					LPDWORD lpcbData = NULL);

#include "regkeyex.inl"
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\regkeyex.inl ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 00
 *
 *  File:      regkeyex.inl
 *
 *  Contents:  Inline files for CRegKeyEx class
 *
 *  History:   7-Apr-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/


/*+-------------------------------------------------------------------------*
 * CRegKeyEx::ScQueryString
 *
 * Loads a string from the given value name.
 *
 * The template type StringType can be any string class that supports
 * MFC's CString interface (i.e. MFC's CString, WTL::CString, or MMC's
 * CStr).
 *--------------------------------------------------------------------------*/

template<class StringType>
SC ScQueryString (
	LPCTSTR		pszValueName,		/* I:name of value to read				*/
	StringType&	strData,			/* O:contents of the value				*/
	DWORD*		pdwType /*=NULL*/)	/* O:REG_SZ, REG_EXPAND_SZ, REG_MULTI_SZ*/
{
	DECLARE_SC (sc, _T("CRegKeyEx::ScQueryString"));
		
	/*
	 * clear out existing contents
	 */
	strData.Empty ();

	/*
	 * find out how much space we need to load the string
	 */
    DWORD dwType   = REG_SZ;
    DWORD cbBuffer = 0;

	sc = ScQueryValue (pszValueName, &dwType, NULL, &cbBuffer);
	if (sc)
		return (sc);

	/*
	 * if we're not loading a string type, return an error
	 */
	if (pdwType != NULL)
		*pdwType = dwType;

	if ((dwType != REG_SZ) && (dwType != REG_EXPAND_SZ) && (dwType != REG_MULTI_SZ))
		return (sc = ScFromWin32 (ERROR_INVALID_DATATYPE));

	/*
	 * allocate a buffer for the string
	 */
	DWORD	cchBuffer = cbBuffer / sizeof (TCHAR);
	LPTSTR	pBuffer   = strData.GetBuffer (cchBuffer);
	if (pBuffer == NULL)
		return (sc = E_OUTOFMEMORY);

	/*
	 * load the string from the registry
	 */
	sc = ScQueryValue (pszValueName, &dwType, pBuffer, &cbBuffer);
	strData.ReleaseBuffer (cchBuffer);
	if (sc)
		return (sc);

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CRegKeyEx::ScLoadRegUIString
 *
 * Wrapper around SHLoadRegUIString, which is used to support MUI.
 *
 * SHLoadRegUIString will read a string of the form
 *
 *		@[path\]<dllname>,-<strId>
 *
 * The string with id <strId> is loaded from <dllname>.  If no explicit
 * path is provided then the DLL will be chosen according to pluggable UI
 * specifications, if possible.
 *
 * If the registry string is not of the special form described here,
 * SHLoadRegUIString will return the string intact.
 *
 * The template type StringType can be any string class that supports
 * MFC's CString interface (i.e. MFC's CString, WTL::CString, or MMC's
 * CStr).
 *--------------------------------------------------------------------------*/

template<class StringType>
SC ScLoadRegUIString (
	LPCTSTR		pszValueName,			/* I:name of value to read			*/
	StringType&	strData)				/* O:logical contents of the value	*/
{
	DECLARE_SC (sc, _T("CRegKeyEx::ScLoadRegUIString"));
		
	/*
	 * clear out existing contents
	 */
	strData.Empty ();

	const int	cbGrow   = 256;
	int			cbBuffer = 0;

	do
	{
		/*
		 * allocate a larger buffer for the string
		 */
		cbBuffer += cbGrow;
		LPTSTR pBuffer = strData.GetBuffer (cbBuffer);
		if (pBuffer == NULL)
			return (sc = E_OUTOFMEMORY);

		/*
		 * load the string from the registry
         * Most of the snapins do not have MUI string so we do not want to trace
         * this error as the caller takes care of error condition and reads registry
         * directly.
		 */
		SC scNoTrace = SHLoadRegUIString (m_hKey, pszValueName, pBuffer, cbBuffer);
		strData.ReleaseBuffer();
		if (scNoTrace)
			return scNoTrace;

		/*
		 * If we filled up the buffer, we'll pessimistically assume that
		 * there's more data available.  We'll loop around, grow the buffer,
		 * and try again.
		 */
	} while (strData.GetLength() == cbBuffer-1);

	/*
	 * free up extra space
	 */
	strData.FreeExtra();

	return (sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\regutil.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       regutil.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    3/20/1997   RaviR   Created
//____________________________________________________________________________
//

#pragma once
#include "nmtempl.h"

#ifdef COMMENTS_ONLY

/*
                    REGISTRY LAYOUT USED BY MMC:

                            SNAPINS

HKEY_LOCAL_MACHINE\Software\Microsoft\MMC\SnapIns
    {04ebc1e6-a16c-11d0-a799-00c04fd8d565}                       // See N-1.
        NameString = REG_SZ "Snapin Name"
        About = REG_SZ "{128ac4e6-a16c-11d0-a799-00c04fd8d565}"  // See N-2.
        NodeTypes                                                // See N-3.
            {c713e06c-a16e-11d0-a799-00c04fd8d565}
            {c713e06d-a16e-11d0-a799-00c04fd8d565}
            {c713e06e-a16e-11d0-a799-00c04fd8d565}
            {c713e06f-a16e-11d0-a799-00c04fd8d565}
        StandAlone                                               // See N-4.
        RequiredExtensions                                       // See N-5.
            {a2087336-a16c-11d0-a799-00c04fd8d565}
            {70098cd3-a16c-11d0-a799-00c04fd8d565}



N-1) Snapin clsid. Only snapins that add to the name space should be
     entered here.

N-2) Clisd of the object that will be cocreated to get the IAbout interface
     ptr for the snapin.

N-3) Enumerate all the node type GUIDs that may be put up by this snapin.

N-4) [Optional] Add the 'StandAlone' key only if the snapin can appear by
     itself under the Console Root. If this key is not present the snapin is
     assumed to be name space extension snapin. Note: A stand alone snapin
     can also be an extension snapin (i.e. it can extend some other snapin).

N-5) [Optional] Enumerate the CLSIDs of extension snapins that are required
     for this snapin to function.


                            NODETYPES


HKEY_LOCAL_MACHINE\Software\Microsoft\MMC\NodeTypes
    {12345601-EA27-11CF-ADCF-00AA00A80033}              // Node type GUID
        = REG_SZ "Log object"
        Extensions
            NameSpace       // See N-7.
                {19876201-EA27-11CF-ADCF-00AA00A80033} = REG_SZ "Alert SnapIn"
                {34346202-EA27-11CF-ADCF-00AA00A80033} = REG_SZ "Viewer SnapIn"
            ContextMenu     // See N-8.
                {19876202-EA27-11CF-ADCF-00AA00A80033} = REG_SZ "Alert SnapIn"
                {34346202-EA27-11CF-ADCF-00AA00A80033} = REG_SZ "Viewer SnapIn"
            ToolBar         // See N-9.
                {19876202-EA27-11CF-ADCF-00AA00A80033} = REG_SZ "Alert SnapIn"
                {00234ca8-EA27-11CF-ADCF-00AA00A80033} = REG_SZ "Pure toolbar extn obj"
            PropertySheet   // See N-10.
                {12222222-EA27-11CF-ADCF-00AA00A80033} = REG_SZ "Pure propery sheet extn obj"
            View            // See N-12.
                {12222222-EA27-11CF-ADCF-00AA00A80033} = REG_SZ "View extn obj"
            Task            // See N-13.
                {12222222-EA27-11CF-ADCF-00AA00A80033} = REG_SZ "Snapin Taskpad extn obj"
            Taskpad         // See N-14.
                {12222222-EA27-11CF-ADCF-00AA00A80033} = REG_SZ "MMC2.0 Taskpad extn obj"
         Dynamic Extensions  // See N-11
            {34346202-EA27-11CF-ADCF-00AA00A80033} = REG_SZ "Viewer SnapIn"

N-7) Under the key 'NameSpace' list the CLSIDs of snapins that can extend the
     name space of this nodetype.

N-8) Under the 'ContextMenu' key list the CLSIDs of snapins that can extend
     the context menu of items put up by this nodetype.

N-9) Under the 'ToolBar' key list the CLSIDs of snapins that can extend
     the toolbar of items put up by this nodetype.

N-10)Under the 'PropertySheet' key list the CLSIDs of snapins that can extend
     the property sheet of items put up by this nodetype.

N-11)Under the 'Dynamic Extensions' Key list the CLSIDs of extensions that can only
     be enabled dynamically, not by the snap-in manager. Any CLSIDs listed here
     should also appear under one on the other extension sub-keys.

N-12)Under the 'View' key list the CLSIDs of snapins that can extend
     the view of items put up by this nodetype.

N-13)Under the 'Task' key list the CLSIDs of snapins that can extend
     the Taskpad of items put up by this nodetype.

*/

#endif // COMMENTS_ONLY


#ifndef _REGUTIL_H_
#define _REGUTIL_H_


#ifdef DBG
    #define ASSERT_INITIALIZED     ASSERT(dbg_m_fInit == TRUE)
#else
    #define ASSERT_INITIALIZED
#endif

// Forward decl
class CPolicy;

/*+-------------------------------------------------------------------------*
 * class CExtensionsIterator
 *
 *
 * PURPOSE: Allows iterating through all the extension snap-ins for a particular
 *          nodetype.
 *          Once initialized, returns, in order, all the registered extensions
 *          followed by all the dynamic extensions. If a dynamic extension was
 *          also a static extension, does not repeat the snap-in.
 *
 *
 * USAGE:   Initialize the object, then make calls to GetCLSID() followed by
 *          Advance() until IsEnd() returns true.
 *
 *+-------------------------------------------------------------------------*/
class CExtensionsIterator
{
public:
// Constructor & destructor
    CExtensionsIterator();
    ~CExtensionsIterator();

    // 1st variation - initializes the iterator from a dataobject and an extension type
    SC  ScInitialize(LPDATAOBJECT pDataObject, LPCTSTR pszExtensionTypeKey);

    // 2nd variation (legacy)
    SC  ScInitialize(CSnapIn *pSnapIn, GUID& rGuidNodeType, LPCTSTR pszExtensionTypeKey, LPCLSID pDynExtCLSID = NULL, int cDynExt = 0);

// Attributes
    BOOL IsEnd()
    {
        ASSERT_INITIALIZED;
        return (m_pExtSI == NULL && m_nDynIndex >= m_cDynExt);
    }

    BOOL IsDynamic()
    {
        ASSERT_INITIALIZED;
        return (m_pExtSI == NULL);
    }

    void Reset()
    {
        ASSERT_INITIALIZED;

        m_pExtSI = m_spSnapIn->GetExtensionSnapIn();
        m_nDynIndex = 0;
        m_cExtUsed = 0;

        _EnsureExtension();
    }

    void Advance()
    {
        ASSERT_INITIALIZED;

        if (m_pExtSI != NULL)
            m_pExtSI = m_pExtSI->Next();
        else
            m_nDynIndex++;

        _EnsureExtension();
    }

    const CLSID& GetCLSID()
    {
        ASSERT_INITIALIZED;

        if (m_pExtSI != NULL)
            return m_pExtSI->GetCLSID();
        else if (m_nDynIndex < m_cDynExt)
            return m_pDynExtCLSID[m_nDynIndex];

        ASSERT(FALSE);
        return GUID_NULL;
    }


    CSnapIn* GetSnapIn()
    {
        ASSERT_INITIALIZED;
        if (m_pExtSI != NULL)
        {
            return m_pExtSI->GetSnapIn();
        }

        ASSERT(FALSE);
        return NULL;
    }

private:
    HRESULT Init(GUID& rGuidNodeType, LPCTSTR pszExtensionTypeKey);

// Implementation
private:
    CSnapInPtr      m_spSnapIn;
    CRegKeyEx       m_rkey;
    CRegKeyEx       m_rkeyDynExt;
    CExtSI*         m_pExtSI;
    CExtSI**        m_ppExtUsed;
    CArray<GUID,GUID&> m_cachedDynExtens;
    LPCLSID         m_pDynExtCLSID;
    int             m_cDynExt;
    int             m_nDynIndex;
    int             m_cExtUsed;
    CPolicy*        m_pMMCPolicy;


#ifdef DBG
    BOOL        dbg_m_fInit;
#endif

    void _EnsureExtension()
    {
        ASSERT_INITIALIZED;

        // Step through the snap-in's static extensions first
        for (; m_pExtSI != NULL; m_pExtSI = m_pExtSI->Next())
        {
            if (m_pExtSI->IsNew() == TRUE)
                continue;

            // Is this registered as the correct extension type?
            // Note: if extension is required, then it doesn't
            //       have to be registered as a static extension
            if (_Extends(!m_pExtSI->IsRequired()) == TRUE)
            {
                m_ppExtUsed[m_cExtUsed++] = m_pExtSI;
                return;
            }
        }

        // When they are exhausted, go through the dynamic list
        for (; m_nDynIndex < m_cDynExt; m_nDynIndex++)
        {
            if (_Extends() == FALSE)
                continue;

            // Don't use dynamic extension that is already used statically
            for (int i=0; i< m_cExtUsed; i++)
            {
                if (IsEqualCLSID(m_pDynExtCLSID[m_nDynIndex], m_ppExtUsed[i]->GetCLSID()))
                    break;
            }

            if (i == m_cExtUsed)
                return;
        }
    }

    BOOL _Extends(BOOL bStatically = FALSE);

    // Undefined
    CExtensionsIterator(const CExtensionsIterator& rhs);
    CExtensionsIterator& operator= (const CExtensionsIterator& rhs);

}; // class CExtensionsIterator


inline UINT HashKey(GUID& guid)
{
    unsigned short* Values = (unsigned short *)&guid;

    return (Values[0] ^ Values[1] ^ Values[2] ^ Values[3] ^
            Values[4] ^ Values[5] ^ Values[6] ^ Values[7]);
}

class CExtensionsCache : public CMap<GUID, GUID&, int, int>
{
public:
    CExtensionsCache()
    {
        InitHashTable(31);
    }

    void Add(GUID& guid)
    {
        SetAt(guid, 0);
    }

}; // class CExtensionsCache

typedef XMapIterator<CExtensionsCache, GUID, int> CExtensionsCacheIterator;

HRESULT ExtractDynExtensions(IDataObject* pdataObj, CArray<GUID, GUID&>& arrayGuid);
SC      ScGetExtensionsForNodeType(GUID& guid, CExtensionsCache& extnsCache);
HRESULT MMCGetExtensionsForSnapIn(const CLSID& clsid,
                                  CExtensionsCache& extnsCache);

BOOL ExtendsNodeNameSpace(GUID& rguidNodeType, CLSID* pclsidExtn);
bool GetSnapinNameFromCLSID(const CLSID& clsid, tstring& tszSnapinName);
SC   ScGetAboutFromSnapinCLSID(LPCTSTR szClsidSnapin, CLSID& clsidAbout);
SC   ScGetAboutFromSnapinCLSID(const CLSID& clsidSnapin, CLSID& clsidAbout);

bool IsIndirectStringSpecifier (LPCTSTR psz);

template<class StringType> SC ScGetSnapinNameFromRegistry (const CLSID& clsid, StringType& str);
template<class StringType> SC ScGetSnapinNameFromRegistry (LPCTSTR pszClsid,   StringType& str);
template<class StringType> SC ScGetSnapinNameFromRegistry (CRegKeyEx& key,     StringType& str);

inline BOOL HasNameSpaceExtensions(GUID& rguidNodeType)
{
    return ExtendsNodeNameSpace(rguidNodeType, NULL);
}


#include "regutil.inl"

#endif // _REGUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by nodemgr.rc
//
#include "mmcres.h"

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "MMC Node Manager DLL"
#define VER_INTERNALNAME_STR            "mmcndmgr.dll"
#define VER_ORIGINALFILENAME_STR        "mmcndmgr.dll"

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\regutil.inl ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      regutil.inl
 *
 *  Contents:  Inline functions for regutil.h
 *
 *  History:   24-Apr-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#pragma once

#include "regkeyex.h"


/*+-------------------------------------------------------------------------*
 * IsIndirectStringSpecifier
 *
 * Returns true if the given string looks like it might be an indirect
 * string specifier acceptable to SHLoadRegUIString, i.e. "@dllname,-id".
 *
 * Returns false otherwise
 *--------------------------------------------------------------------------*/

inline bool IsIndirectStringSpecifier (LPCTSTR psz)
{
	return ((psz != NULL) && (psz[0] == _T('@')) && (_tcsstr(psz, _T(",-")) != NULL));
}


/*+-------------------------------------------------------------------------*
 * ScGetSnapinNameFromRegistry
 *
 * Loads the name of a snap-in from the given snap-in CLSID.
 *
 * The template type StringType can be any string class that supports
 * MFC's CString interface (i.e. MFC's CString, WTL::CString, or MMC's
 * CStr).
 *--------------------------------------------------------------------------*/

template<class StringType>
SC ScGetSnapinNameFromRegistry (
	const CLSID&	clsid,
	StringType& 	str)
{
	DECLARE_SC (sc, _T("ScGetSnapinNameFromRegistry"));

	/*
	 * convert class id to string
	 */
	OLECHAR szClsid[40];
    if (!StringFromGUID2 (clsid, szClsid, countof(szClsid)))
		return (sc = E_INVALIDARG);

	/*
	 * load the name
	 */
	USES_CONVERSION;
	sc = ScGetSnapinNameFromRegistry (OLE2T(szClsid), str);
	if (sc)
		return (sc);

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * ScGetSnapinNameFromRegistry
 *
 * Loads the name of a snap-in from the given snap-in CLSID string.
 *
 * The template type StringType can be any string class that supports
 * MFC's CString interface (i.e. MFC's CString, WTL::CString, or MMC's
 * CStr).
 *--------------------------------------------------------------------------*/

template<class StringType>
SC ScGetSnapinNameFromRegistry (
	LPCTSTR		pszClsid,
	StringType& str)
{
	DECLARE_SC (sc, _T("ScGetSnapinNameFromRegistry"));

	/*
	 * open HKLM\Software\Microsoft\MMC\SnapIns\{CLSID}
	 */
	StringType strKeyName = StringType(SNAPINS_KEY) + _T("\\") + pszClsid;
    CRegKeyEx SnapinKey;
    LONG lRet = SnapinKey.Open (HKEY_LOCAL_MACHINE, strKeyName, KEY_READ);
    if (ERROR_SUCCESS != lRet)
		return (sc = HRESULT_FROM_WIN32 (lRet));

	/*
	 * load the string
	 */
	sc = ScGetSnapinNameFromRegistry (SnapinKey, str);
	if (sc)
		return (sc);

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * ScGetSnapinNameFromRegistry
 *
 * Loads the name of a snap-in from the given open snap-in registry key.
 * First, we'll try to use SHLoadRegUIString to resolve an indirect name
 * in the "NameStringIndirect" value.  If that fails (because "NameString-
 * Indirect" isn't registered, because the registered DLL can't be loaded,
 * etc.), we'll fall back to the old "NameString" entry.
 *
 * The template type StringType can be any string class that supports
 * MFC's CString interface (i.e. MFC's CString, WTL::CString, or MMC's
 * CStr).
 *--------------------------------------------------------------------------*/

template<class StringType>
SC ScGetSnapinNameFromRegistry (
	CRegKeyEx&	key,					/* I:snap-in's key, opened for read	*/
	StringType&	str)					/* O:name of snap-in				*/
{
	DECLARE_SC (sc, _T("ScGetSnapinNameFromRegistry"));

	/*
	 * try to load the MUI-friendly name first, ignoring errors
	 */
	sc = key.ScLoadRegUIString (g_szNameStringIndirect, str);

	/*
	 * if an error occurred, or ScLoadReagUIString couldn't resolve the
	 * @dllname syntax, or the returned string was empty, fall back
	 * on the legacy registry entry
	 */
	if (sc.IsError() || str.IsEmpty() || IsIndirectStringSpecifier(str))
		sc = key.ScQueryString (g_szNameString, str, NULL);

	return (sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\rsltdata.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       rsltdata.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "menuitem.h" // MENUITEM_BASE_ID
#include "amcmsgid.h"
#include "conview.h"
#include "rsltitem.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::SetResultView
//
//  Synopsis:    Save the result view ptr.
//
//  Arguments:   [pUnknown] -
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::SetResultView(LPUNKNOWN pUnknown)
{
    DECLARE_SC(sc, _T("CNodeInitObject::SetResultView"));

    m_spResultViewUnk   = pUnknown;
    m_spListViewPrivate = pUnknown;

    // If the resultview is reset then reset the desc bar.
    if (NULL == pUnknown)
        SetDescBarText( L"" );

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::IsResultViewSet
//
//  Synopsis:    Is the ResultView ptr set (so that conui can query
//               before invoking ResultView methods).
//
//  Arguments:   [pbIsLVSet] - Ptr to BOOL. (TRUE means ResultView is set).
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::IsResultViewSet(BOOL* pbIsLVSet)
{
    DECLARE_SC(sc, _T("CNodeInitObject::IsResultViewSet"));
    sc = ScCheckPointers(pbIsLVSet);
    if (sc)
        return sc.ToHr();

    *pbIsLVSet = FALSE;

    if (m_spListViewPrivate)
        *pbIsLVSet = TRUE;

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::SetTaskPadList
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::SetTaskPadList(LPUNKNOWN pUnknown)
{
    DECLARE_SC(sc, _T("CNodeInitObject::SetTaskPadList"));

    if (pUnknown == NULL)
    {
        m_spListViewPrivate = NULL;
    }
    else
    {
        if (m_spListViewPrivate == pUnknown)
        {
            return sc.ToHr();
        }
        else
        {
            ASSERT(m_spListViewPrivate == NULL);
            m_spListViewPrivate = pUnknown;
        }
    }

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::QueryResultView
//
//  Synopsis:    IConsole2 method for snapins to get resultview's IUnknown.
//
//  Arguments:   [ppUnk] - return IUnknown to snapin.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::QueryResultView(LPUNKNOWN* ppUnk)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsole2::QueryResultView"));

    if (!ppUnk)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Null LPUNKNOWN pointer passed in"), sc);
        return sc.ToHr();
    }

    (*ppUnk) = m_spResultViewUnk;

    sc = ScCheckPointers((*ppUnk), E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    (*ppUnk)->AddRef();

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::MessageBox
//
//  Synopsis:    IConsole2 member, called by snapin to display a message box.
//
//  Arguments:   [lpszText]  - Text to display.
//               [lpszTitle] -
//               [fuStyle]   -
//               [piRetval]  -
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::MessageBox(
    LPCWSTR lpszText, LPCWSTR lpszTitle, UINT fuStyle, int* piRetval)

{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsole2::MessageBox"));

    USES_CONVERSION;

    // find the main frame window and use it as the owner of the message box
    INT iRetval = ::MessageBox(
        GetMainWindow(),
        W2CT(lpszText),
        W2CT(lpszTitle),
        fuStyle );

    if (NULL != piRetval)
        *piRetval = iRetval;

    return sc.ToHr();
}



//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::GetListStyle
//
//  Synopsis:    Get the current list view style.
//
//  Arguments:   [pStyle] -
//
//  Note:        IResultDataPrivate member, internal to MMC.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::GetListStyle(long * pStyle)
{
    DECLARE_SC(sc, _T("CNodeInitObject::GetListStyle"));

    // must have pStyle
    if (!pStyle)
    {
        sc = E_INVALIDARG;
        TraceError(_T("CNodeinitObject::GetListStyle, style ptr passed is NULL"), sc);
        return sc.ToHr();
    }

    if (NULL == m_spListViewPrivate)
    {
        sc = E_UNEXPECTED;
        TraceError(_T("CNodeinitObject::GetListStyle, ListView ptr is NULL"), sc);
        return sc.ToHr();
    }

    *pStyle = m_spListViewPrivate->GetListStyle();

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::SetListStyle
//
//  Synopsis:    Modify the list view style.
//
//  Arguments:   [style] -
//
//  Note:        IResultDataPrivate member, internal to MMC.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::SetListStyle(long style)
{
    DECLARE_SC(sc, _T("CNodeInitObject::SetListStyle"));

    if (NULL == m_spListViewPrivate)
    {
        sc = E_UNEXPECTED;
        TraceError(_T("CNodeinitObject::GetListStyle, ListView ptr is NULL"), sc);
        return sc.ToHr();
    }

    sc = m_spListViewPrivate->SetListStyle(style);

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::ModifyItemState
//
//  Synopsis:    Enables snapin to modify the state of an item.
//
//  Arguments:   [nIndex]  - index of the item to be modified (used only if itemID is 0).
//               [itemID]  - HRESULTITEM if not virtual-list (Virtual list use above index).
//               [uAdd]    - States to add.
//               [uRemove] - States to be removed.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::ModifyItemState(int nIndex, HRESULTITEM hri,
                                              UINT uAdd, UINT uRemove)

{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IResultData::ModifyItemState"));

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_spListViewPrivate->ModifyItemState(nIndex, CResultItem::FromHandle(hri), uAdd, uRemove);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::ModifyViewStyle
//
//  Synopsis:    Allows snapin to modify list view style.
//
//  Arguments:   [add]    - Styles to be set.
//               [remove] - Styles to be removed.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::ModifyViewStyle(MMC_RESULT_VIEW_STYLE add,
                                              MMC_RESULT_VIEW_STYLE remove)

{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IResultData::ModifyViewStyle"));

    typedef struct {
        MMC_RESULT_VIEW_STYLE   mmcFlag;
        DWORD                   lvsFlag;
    } FlagMapEntry;

    FlagMapEntry flagMap[] =
    {
        {MMC_SINGLESEL,             LVS_SINGLESEL},
        {MMC_SHOWSELALWAYS,         LVS_SHOWSELALWAYS},
        {MMC_NOSORTHEADER,          LVS_NOSORTHEADER},
        {MMC_ENSUREFOCUSVISIBLE,    MMC_LVS_ENSUREFOCUSVISIBLE},
        {(MMC_RESULT_VIEW_STYLE)0,  0}
    };

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // Get the old style.
    DWORD dwLVStyle = static_cast<DWORD>(m_spListViewPrivate->GetListStyle());

    // convert MMC_ flags to LVS_ flags and apply to current style
    for (FlagMapEntry* pMap = flagMap; pMap->mmcFlag; pMap++)
    {
        if (add & pMap->mmcFlag)
            dwLVStyle |= pMap->lvsFlag;

        if (remove & pMap->mmcFlag)
            dwLVStyle &= ~pMap->lvsFlag;
    }

    sc = m_spListViewPrivate->SetListStyle(static_cast<long>(dwLVStyle));

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::InsertItem
//
//  Synopsis:    Insert an item into ListView (IResultData member).
//
//  Arguments:   [item] -
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::InsertItem(LPRESULTDATAITEM item)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IResultData::InsertItem"));

    // MUST have an item structure.
    if (!item)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("The LPRESULTDATAITEM ptr passed in is NULL"), sc);
        return sc.ToHr();
    }

    COMPONENTID nID;
    GetComponentID(&nID);

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    CResultItem* pri = NULL;
    sc =  m_spListViewPrivate->InsertItem(
                         item->mask & RDI_STR   ? item->str    : MMCLV_NOPTR,
                         item->mask & RDI_IMAGE ? item->nImage : MMCLV_NOICON,
                         item->mask & RDI_PARAM ? item->lParam : MMCLV_NOPARAM,
                         item->mask & RDI_STATE ? item->nState : MMCLV_NOPARAM,
                         nID, item->nIndex, pri);
    if (sc)
        return (sc.ToHr());

    if (pri == NULL)
        return ((sc = E_UNEXPECTED).ToHr());

    item->itemID = CResultItem::ToHandle(pri);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::DeleteItem
//
//  Synopsis:    Delete the given item (IResultData member).
//
//  Arguments:   [itemID] - item identifier.
//               [nCol]   - column to delete.
//
//  Note:        nCol must be zero.
//
//  Returns:     HREsULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::DeleteItem(HRESULTITEM itemID, int nCol)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IResultData::DeleteItem"));

    if (nCol != 0)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Column index must be zero"), sc);
        return sc.ToHr();
    }

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_spListViewPrivate->DeleteItem ( itemID, nCol);

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::UpdateItem
//
//  Synopsis:    Redraw the given item.
//
//  Arguments:   [itemID] - Item identifier.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::UpdateItem(HRESULTITEM itemID)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IResultData::UpdateItem"));

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_spListViewPrivate->UpdateItem(itemID);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:     Sort
//
//  Synopsis:   IResultData member, snapins can call this to sort the
//              result pane items. This calls InternalSort to do sort.
//
//  Arguments:  [nCol]          - Column to be sorted.
//              [dwSortOptions] - Sort options.
//              [lUserParam]    - User (snapin) param.
//
//  Returns:    HRESULT
//
//  History:             RaviR   Created
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::Sort(int nCol, DWORD dwSortOptions, LPARAM lUserParam)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IResultData::Sort"));

    sc = ScCheckPointers(m_spComponent, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    int nColumnCnt;
    sc = m_spListViewPrivate->GetColumnCount(&nColumnCnt);
    if (sc)
        return sc.ToHr();

    if (nCol < 0 || nCol >= nColumnCnt)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Column index is invalid"), sc);
        return sc.ToHr();
    }

    sc = InternalSort(nCol, dwSortOptions, lUserParam, FALSE);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:     InternalSort
//
//  Synopsis:   Private member MMC calls to sort the result pane items.
//
//  Arguments:  [nCol]           - Column to be sorted.
//              [dwSortOptions]  - Sort options.
//              [lUserParam]     - User (snapin) param.
//              [bColumnClicked] - Is sort due to column click.
//
//  Note:       If column is clicked the lUserParam will be NULL.
//              The sort options is set depending on ascend/descend,
//              and cannot include RSI_NOSORTICON as this option is
//              only for snapin initiated sort.
//
//  Returns:    HRESULT
//
//  History:                RaviR    Created
//              07-02-1999  AnandhaG added setsorticon.
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::InternalSort(INT nCol, DWORD dwSortOptions,
                                           LPARAM lUserParam, BOOL bColumnClicked)
{
    DECLARE_SC(sc, _T("CNodeInitObject::InternalSort"));

    // Save old sort-column to reset its sort icon.
    int  nOldCol    = m_sortParams.nCol;
    BOOL bAscending = m_sortParams.bAscending;

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // If column is clicked the sortoption and user param are
    // already 0. Set only the sortoptions below.
    if (bColumnClicked)
    {
        if(nOldCol != nCol)
            bAscending = TRUE;
        else
            bAscending = !m_sortParams.bAscending;

        dwSortOptions |= (bAscending ? 0 : RSI_DESCENDING);

        // Notify component of sort parameter change
        m_spComponent->Notify(NULL, MMCN_COLUMN_CLICK, nCol,dwSortOptions);
    }

    bool bIsVirtualList = false;
    sc = ScIsVirtualList(bIsVirtualList);
    if (sc)
        return sc.ToHr();

    if ( bIsVirtualList )
    {
        // see if the snap-in handle owner data methods
        IResultOwnerDataPtr pResultOwnerData = m_spComponent;
        if (pResultOwnerData != NULL)
        {
            sc = pResultOwnerData->SortItems(nCol,dwSortOptions,lUserParam );

            // if reordering done, save the sort data and repaint the list view.
            if (S_OK == sc.ToHr())
            {
                m_sortParams.nCol         = nCol;
                m_sortParams.bAscending   = !(dwSortOptions & RSI_DESCENDING);
                m_sortParams.bSetSortIcon = !(dwSortOptions & RSI_NOSORTICON);
                m_sortParams.lpUserParam  = lUserParam;

                /*
                * Bug 414256:  We need to save the sort data only if
                * it is user initiated sort. Is this user initiated?
                */
                m_sortParams.bUserInitiatedSort = bColumnClicked;

                sc = m_spListViewPrivate->Repaint(TRUE);
                if (sc)
                    return sc.ToHr();
            }
        }
        else
        {
            sc = E_UNEXPECTED;
        }
    }
    else
    {
        // Query for compare interfaces
        IResultDataComparePtr   spResultCompare   = m_spComponent;
        IResultDataCompareExPtr spResultCompareEx = m_spComponent;

        // Set the sort parameters.
        m_sortParams.nCol = nCol;
        m_sortParams.bAscending   = !(dwSortOptions & RSI_DESCENDING);
        m_sortParams.bSetSortIcon = !(dwSortOptions & RSI_NOSORTICON);
        m_sortParams.lpUserParam  = lUserParam;

        m_sortParams.lpResultCompare   = spResultCompare;
        m_sortParams.lpResultCompareEx = spResultCompareEx;

        /*
        * Bug 414256:  We need to save the sort data only if
        * it is user initiated sort. Is this user initiated?
        */
        m_sortParams.bUserInitiatedSort = bColumnClicked;

        sc = m_spListViewPrivate->Sort(lUserParam, (long*)&m_sortParams);

        m_sortParams.lpResultCompare   = NULL;
        m_sortParams.lpResultCompareEx = NULL;
    }

    // Set sort icon only if Sort went through.
    if (S_OK == sc.ToHr())
    {
        sc = m_spListViewPrivate->SetColumnSortIcon( m_sortParams.nCol, nOldCol,
                                                     m_sortParams.bAscending,
                                                     m_sortParams.bSetSortIcon);
    }

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CNodeInitObject::GetSortDirection
 *
 * PURPOSE: returns sorting direction
 *
 * PARAMETERS:
 *    BOOL* pbAscending    - resulting sort column dir
 *
 * RETURNS:
 *    SC    - result code. S_FALSE ( in combination with -1 col) if no sorting.
 *
\***************************************************************************/
STDMETHODIMP CNodeInitObject::GetSortDirection(BOOL* pbAscending)
{
    DECLARE_SC(sc, TEXT("CNodeInitObject::GetSortDirection"));

    if (pbAscending == NULL)
    {
        sc = E_INVALIDARG;
        return sc.ToHr();
    }

    *pbAscending = m_sortParams.bAscending;

    // If no sorting is performed then return S_FALSE.
    sc = m_sortParams.nCol >= 0 ? S_OK : S_FALSE;

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CNodeInitObject::GetSortColumn
 *
 * PURPOSE: returns sorting column
 *          sort column regardless if the user has initiated the sort or not.
 *
 * PARAMETERS:
 *    INT* pnCol    - resulting sort column index
 *
 * RETURNS:
 *    SC    - result code. S_FALSE ( in combination with -1 col) if no sorting.
 *
\***************************************************************************/
STDMETHODIMP CNodeInitObject::GetSortColumn(INT* pnCol)
{
    DECLARE_SC(sc, TEXT("CNodeInitObject::GetSortColumn"));

    if (pnCol == NULL)
    {
        sc = E_INVALIDARG;
        return sc.ToHr();
    }

    *pnCol = m_sortParams.nCol;

    // return code depending if the valid column was got
    sc = m_sortParams.nCol >= 0 ? S_OK : S_FALSE;

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::FindItemByLParam
//
//  Synopsis:    Find the ItemID using the user-param.
//
//  Arguments:   [lParam] - lParam (RESULTDATAITEM.lParam)
//               [pItemID] - return the item-id.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::FindItemByLParam(LPARAM lParam, HRESULTITEM *pItemID)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IResultData::FindItemByLParam"));

    if(!pItemID)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("the HRESULTITEM* ptr is NULL"), sc);
        return sc.ToHr();
    }

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    COMPONENTID id;
    GetComponentID(&id);

    /*
     * init the output param
     */
    *pItemID = NULL;

    CResultItem* pri = NULL;
    sc = m_spListViewPrivate->FindItemByLParam (id, lParam, pri);
    if (sc == SC(E_FAIL)) // E_FAIL is legal return value.
    {
        sc.Clear();
        return E_FAIL;
    }

    sc = ScCheckPointers (pri, E_UNEXPECTED);
    if (sc)
        return (sc.ToHr());

    *pItemID = CResultItem::ToHandle(pri);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::DeleteAllRsltItems
//
//  Synopsis:    Delete all the result items
//
//  Arguments:
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::DeleteAllRsltItems()
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IResultData::DeleteAllRsltItems"));

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    COMPONENTID id;
    GetComponentID(&id);

    sc = m_spListViewPrivate->DeleteAllItems(id);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::SetItem
//
//  Synopsis:    Modify attributes of an item.
//
//  Arguments:   [item]
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::SetItem(LPRESULTDATAITEM item)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IResultData::SetItem"));

    // MUST have an item structure.
    if (!item)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL LPRESULTDATAITEM ptr"), sc);
        return sc.ToHr();
    }

    // Cannot set an lParam on a subItem.  (thank Win32 for this)
    if((item->mask & RDI_PARAM) && (item->nCol != 0))
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Cannot set lParam for subitem"), sc);
        return sc.ToHr();
    }

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    COMPONENTID id;
    GetComponentID(&id);

    CResultItem* pri = CResultItem::FromHandle (item->itemID);

    sc = m_spListViewPrivate->SetItem(
                         item->nIndex,
                         pri, item->nCol,
                         item->mask & RDI_STR ? item->str : MMCLV_NOPTR,
                         item->mask & RDI_IMAGE ? item->nImage : MMCLV_NOICON,
                         item->mask & RDI_PARAM ? item->lParam : MMCLV_NOPARAM,
                         item->mask & RDI_STATE ? item->nState : MMCLV_NOPARAM,
                         id);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::GetNextItem
//
//  Synopsis:    Get the next item with specified flag set.
//
//  Arguments:
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::GetNextItem(LPRESULTDATAITEM item)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IResultData::GetNextItem"));

    if (NULL == item)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL LPRESULTDATAITEM ptr"), sc);
        return sc.ToHr();
    }

    if (NULL == (item->mask & RDI_STATE))
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("RDI_STATE mask not set"), sc);
        return sc.ToHr();
    }

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    COMPONENTID id;
    GetComponentID(&id);


    bool bIsVirtualList = false;
    sc = ScIsVirtualList(bIsVirtualList);
    if (sc)
        return sc.ToHr();

    HRESULT hr = S_OK;
    long nIndex = item->nIndex;
    CResultItem* pri = NULL;

    // Assume error
    item->nIndex = -1;
    item->lParam = 0;

    while (1)
    {
        sc = m_spListViewPrivate->GetNextItem (id, nIndex, item->nState,
                                               pri, nIndex);
        if (sc.ToHr() != S_OK)
        {
            break;
        }

        // Virtual list item, just return the index (lParam is zero).
        if (bIsVirtualList)
        {
            item->nIndex = nIndex;
            item->bScopeItem = FALSE;
            break;
        }

        sc = ScCheckPointers (pri, E_FAIL);
        if (sc)
            break;

        // Non-virtual leaf item.
        if (pri->GetOwnerID() == id)
        {
            item->nIndex = nIndex;
            item->bScopeItem = FALSE;
            item->lParam = pri->GetSnapinData();
            break;
        }

        if (!pri->IsScopeItem())
        {
            sc = E_UNEXPECTED;
            break;
        }

        // This is a tree item, get the lUserParam.
        CNode* pNode = CNode::FromResultItem (pri);
        sc = ScCheckPointers(pNode, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        if (pNode->IsStaticNode() == TRUE)
            break;

        CMTNode* pMTNode = pNode->GetMTNode();
        sc = ScCheckPointers(pMTNode, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        if (pMTNode->GetPrimaryComponentID() == id)
        {
            item->nIndex     = nIndex;
            item->bScopeItem = TRUE;
            item->lParam     = pMTNode->GetUserParam();
            break;
        }

    }

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::GetItem
//
//  Synopsis:    Get the parameters of an item.
//
//  Arguments:   [item] - itemID is used to get the item, if itemID = 0,
//                        then nIndex is used.
//
//  Note:        For VLists itemID = 0, nIndex is used.
//               nCol must be zero.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::GetItem(LPRESULTDATAITEM item)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IResultData::GetItem"));

    // MUST have an item structure.
    if (!item)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL LPRESULTDATAITEM ptr."), sc);
        return sc.ToHr();
    }

    COMPONENTID id;
    GetComponentID(&id);

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    CResultItem* pri = NULL;

    sc =  m_spListViewPrivate->GetItem(
                            item->nIndex,
                            pri, item->nCol,
                            item->mask & RDI_STR   ? &item->str    : MMCLV_NOPTR,
                            item->mask & RDI_IMAGE ? &item->nImage : MMCLV_NOPTR,
                            item->mask & RDI_PARAM ? &item->lParam : MMCLV_NOPTR,
                            item->mask & RDI_STATE ? &item->nState : MMCLV_NOPTR,
                            &item->bScopeItem);
    if (sc)
        return (sc.ToHr());

    if (pri == NULL)
        return ((sc = E_UNEXPECTED).ToHr());

    if (pri->IsScopeItem())
    {
        item->bScopeItem = TRUE;

        // This is a tree item, get the lUserParam.
        CNode* pNode = CNode::FromResultItem (pri);
        sc = ScCheckPointers(pNode, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        // When the static node is visible in result-pane the result pane is
        // owned not by that static node's snapin so this is unexpected.
        if (pNode->IsStaticNode())
            return (sc = E_UNEXPECTED).ToHr();

        CMTNode* pMTNode = pNode->GetMTNode();
        sc = ScCheckPointers(pMTNode, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        if (pMTNode->GetPrimaryComponentID() != id)
            return (sc = E_INVALIDARG).ToHr();

        if (RDI_PARAM & item->mask)
            item->lParam = pMTNode->GetUserParam();

        if (RDI_IMAGE & item->mask)
            item->nImage = pMTNode->GetImage();
    }

    item->itemID = CResultItem::ToHandle(pri);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::SetViewMode
//
//  Synopsis:    Change the ListView mode (detail...)
//
//  Arguments:   [nViewMode] - new mode.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::SetViewMode(LONG nViewMode)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IResultData::SetViewMode"));

    if (FALSE == (nViewMode >= 0 && nViewMode <= MMCLV_VIEWSTYLE_FILTERED))
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Invalid view mode"), sc);
        return sc.ToHr();
    }

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc =  m_spListViewPrivate->SetViewMode(nViewMode);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::Arrange
//
//  Synopsis:    Arrange the items is LV.
//
//  Arguments:   [style]
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::Arrange(long style)
{
    DECLARE_SC(sc, _T("CNodeInitObject::Arrange"));

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_spListViewPrivate->Arrange(style);

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::GetViewMode
//
//  Synopsis:    Get the current view mode.
//
//  Arguments:   [pnViewMode] - view mode [out]
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::GetViewMode(LONG * pnViewMode)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IResultData::GetViewMode"));

    if (pnViewMode == MMCLV_NOPTR)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL ViewMode pointer"), sc);
        return sc.ToHr();
    }

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    *pnViewMode = m_spListViewPrivate->GetViewMode();

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::ResetResultData
//
//  Synopsis:    Reset the result view.
//
//  Arguments:
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::ResetResultData()
{
    DECLARE_SC(sc, _T("CNodeInitObject::ResetResultData"));

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // Dont know what this assert means? (AnandhaG).
    ASSERT(TVOWNED_MAGICWORD == m_componentID);

    sc = m_spListViewPrivate->Reset();

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::SetLoadMode
//
//  Synopsis:    Used for re-drawing LV/delay sorting.
//
//  Note:        If ListView setup (snapin is inserting columns/items,
//               MMC is applying column/view/sort settings) is going on
//               then delay sorting and also turn off drawing.
//
//  Arguments:
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::SetLoadMode(BOOL bState)
{
    DECLARE_SC(sc, _T("CNodeInitObject::SetLoadMode"));

    // Dont know what this assert means? (AnandhaG).
    ASSERT(TVOWNED_MAGICWORD == m_componentID);

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_spListViewPrivate->SetLoadMode(bState);

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::SetDescBarText
//
//  Synopsis:    Set the desc bar text for ResultPane.
//
//  Arguments:   [pszDescText]
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::SetDescBarText(LPOLESTR pszDescText)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IResultData::SetDescBarText"));

    CConsoleView* pConsoleView = GetConsoleView();

    sc = ScCheckPointers(pConsoleView, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // What happens if desc text is NULL?
    USES_CONVERSION;
    sc = pConsoleView->ScSetDescriptionBarText (W2T (pszDescText));

    return (sc.ToHr());
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::SetItemCount
//
//  Synopsis:    Set the number of items in Virtual List.
//
//  Arguments:   [nItemCount] - # items.
//               [dwOptions]  - option flags.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::SetItemCount(int nItemCount, DWORD dwOptions)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IResultData::SetItemCount"));

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_spListViewPrivate->SetItemCount(nItemCount, dwOptions);

    return sc.ToHr();
}


/*+-------------------------------------------------------------------------*
 *
 * CNodeInitObject::RenameResultItem
 *
 * PURPOSE: Places the specified result item into rename mode.
 *
 * PARAMETERS:
 *    HRESULTITEM  itemID :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CNodeInitObject::RenameResultItem(HRESULTITEM itemID)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, TEXT("IResultData2::RenameResultItem"));

    sc = ScCheckPointers(m_spListViewPrivate, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_spListViewPrivate->RenameItem(itemID);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\regutil.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       regutil.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    3/21/1997   RaviR   Created
//____________________________________________________________________________
//



#include "stdafx.h"

#include "regutil.h"
#include "..\inc\strings.h"
#include "policy.h"

TCHAR g_szNodeTypesKey[] = TEXT("Software\\Microsoft\\MMC\\NodeTypes\\");

CExtensionsIterator::CExtensionsIterator() :
 m_pExtSI(NULL),
 m_pDynExtCLSID(NULL),
 m_cDynExt(0),
 m_nDynIndex(0),
 m_pMMCPolicy(NULL),
 m_ppExtUsed(NULL)
{
    #ifdef DBG
        dbg_m_fInit = FALSE;
    #endif
}

CExtensionsIterator::~CExtensionsIterator()
{
    if (NULL != m_pMMCPolicy)
        delete m_pMMCPolicy;

    delete [] m_ppExtUsed;
}

/*+-------------------------------------------------------------------------*
 *
 * CExtensionsIterator::ScInitialize
 *
 * PURPOSE: 1st variation - initializes the iterator from a dataobject and an extension type
 *
 * PARAMETERS:
 *    LPDATAOBJECT  pDataObject :
 *    LPCTSTR       pszExtensionTypeKey :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CExtensionsIterator::ScInitialize(LPDATAOBJECT pDataObject, LPCTSTR pszExtensionTypeKey)
{
    DECLARE_SC(sc, TEXT("CExtensionsIterator::ScInitialize"));

    // validate inputs
    sc = ScCheckPointers(pDataObject, pszExtensionTypeKey);
    if(sc)
        return sc;

    // get the nodetype and the snap-in pointer
    CSnapInPtr spSnapIn;
    GUID guidNodeType;
    sc = CNodeInitObject::GetSnapInAndNodeType(pDataObject, &spSnapIn, &guidNodeType);
    if (sc)
        return sc;

    // Fix for bug #469922(9/20/2001):	[XPSP1 bug 599913]
    // DynamicExtensions broken in MMC20
    // Use member variable - stack variable lifetime is not long enough.
    ExtractDynExtensions(pDataObject, m_cachedDynExtens);

    //call the second init function
    sc = ScInitialize(spSnapIn,guidNodeType, pszExtensionTypeKey, m_cachedDynExtens.GetData(), m_cachedDynExtens.GetSize());

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CExtensionsIterator::ScInitialize
 *
 * PURPOSE: 2nd variation (legacy)
 *
 * PARAMETERS:
 *    CSnapIn * pSnapIn :
 *    GUID&     rGuidNodeType :
 *    LPCTSTR   pszExtensionTypeKey :
 *    LPCLSID   pDynExtCLSID :
 *    int       cDynExt :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CExtensionsIterator::ScInitialize(CSnapIn *pSnapIn, GUID& rGuidNodeType, LPCTSTR pszExtensionTypeKey, LPCLSID pDynExtCLSID, int cDynExt)
{
    DECLARE_SC(sc, TEXT("CExtensionsIterator::ScInitialize"));

    // validate inputs
    sc = ScCheckPointers(pSnapIn, pszExtensionTypeKey);
    if(sc)
        return sc;

    // store the inputs
    m_spSnapIn      = pSnapIn;
    m_pDynExtCLSID  = pDynExtCLSID,
    m_cDynExt       = cDynExt;

    // Count the static extensions
    CExtSI* pExtSI = m_spSnapIn->GetExtensionSnapIn();
    int cExtStatic = 0;
    while (pExtSI != NULL)
    {
        cExtStatic++;
        pExtSI = pExtSI->Next();
    }

    // Allocate array of extension pointers
    m_ppExtUsed = new CExtSI*[cExtStatic];
    m_cExtUsed = 0;

    m_pMMCPolicy = new CPolicy;
    ASSERT(NULL != m_pMMCPolicy);

    // call init
    sc = Init(rGuidNodeType, pszExtensionTypeKey);
    if(sc)
        return sc;

    return sc;
}


HRESULT CExtensionsIterator::Init(GUID& rGuidNodeType, LPCTSTR pszExtensionTypeKey)
{
	DECLARE_SC (sc, _T("CExtensionsIterator::Init"));
    CStr strBufDynExt;

    CStr strBuf = g_szNodeTypesKey;

    CCoTaskMemPtr<WCHAR> spszNodeType;
    sc = StringFromCLSID(rGuidNodeType, &spszNodeType);
    if (sc)
		return (sc.ToHr());

    strBuf += static_cast<WCHAR*>(spszNodeType);
    strBuf += _T("\\");

    strBufDynExt = strBuf;
    strBufDynExt += g_szDynamicExtensions;

    strBuf += g_szExtensions;
    strBuf += _T("\\");
    strBuf += pszExtensionTypeKey;

	// Try to open the optional dynamic extensions key (ignoring errors)
	m_rkeyDynExt.ScOpen (HKEY_LOCAL_MACHINE, strBufDynExt, KEY_READ);

	//  Open the key
	sc = m_rkey.ScOpen (HKEY_LOCAL_MACHINE, strBuf, KEY_READ);
	if (sc)
	{
		/*
		 * ignore ERROR_FILE_NOT_FOUND
		 */
		if (sc == ScFromWin32 (ERROR_FILE_NOT_FOUND))
			sc.Clear();
		else
			return (sc.ToHr());
	}

	if (NULL == m_pMMCPolicy)
		return ((sc = E_OUTOFMEMORY).ToHr());

	sc = m_pMMCPolicy->ScInit();
	if (sc)
		return (sc.ToHr());

#ifdef DBG
	dbg_m_fInit = TRUE;
#endif

    Reset();
	return (sc.ToHr());
}


BOOL CExtensionsIterator::_Extends(BOOL bStatically)
{
    BOOL fRet = FALSE;

    ASSERT(!IsEnd());

    LPOLESTR polestr = NULL;
    HRESULT hr = StringFromCLSID(GetCLSID(), &polestr);
    CHECK_HRESULT(hr);

    if (SUCCEEDED(hr))
    {
        USES_CONVERSION;
        LPTSTR pszTemp = OLE2T(polestr);

        fRet = m_rkey.IsValuePresent( pszTemp) && m_pMMCPolicy->IsPermittedSnapIn(GetCLSID());

        if (fRet && bStatically)
            fRet = !((HKEY)m_rkeyDynExt && m_rkeyDynExt.IsValuePresent(pszTemp));

        CoTaskMemFree(polestr);
    }

    return fRet;
}


HRESULT MMCGetExtensionsForSnapIn(const CLSID& clsid,
                                  CExtensionsCache& extnsCache)
{
	DECLARE_SC (sc, _T("MMCGetExtensionsForSnapIn"));

	CStr strBuf = SNAPINS_KEY;
	strBuf += _T("\\");

	CCoTaskMemPtr<WCHAR> spszNodeType;
	sc = StringFromCLSID(clsid, &spszNodeType);
	if (sc)
		return (sc.ToHr());

	strBuf += static_cast<WCHAR*>(spszNodeType);
	strBuf += _T("\\");
	strBuf += g_szNodeTypes;

	//  Open the key
	CRegKeyEx	rkeyNodeTypes;
	WORD		wResId;

	sc = rkeyNodeTypes.ScOpen (HKEY_LOCAL_MACHINE, strBuf, KEY_READ);
	if (sc)
	{
		if (sc == ScFromWin32 (ERROR_FILE_NOT_FOUND))
			sc = S_FALSE;

		return (sc.ToHr());
	}

	USES_CONVERSION;
	TCHAR szSubKey[100];

	for (DWORD iSubkey = 0; ; ++iSubkey)
	{
		DWORD cchName = countof(szSubKey);

		sc = rkeyNodeTypes.ScEnumKey (iSubkey, szSubKey, &cchName);
		if (sc)
		{
			if (sc == ScFromWin32 (ERROR_NO_MORE_ITEMS))
				sc.Clear();

			return (sc.ToHr());
		}

		GUID guid;

		if ((sc = CLSIDFromString( T2W(szSubKey), &guid)).IsError() ||
			(sc = ScGetExtensionsForNodeType(guid, extnsCache)).IsError())
		{
			sc.Clear();
			continue;
		}
	}

	return (sc.ToHr());
}


SC ScGetExtensionsForNodeType(GUID& guid, CExtensionsCache& extnsCache)
{
	DECLARE_SC (sc, _T("ScGetExtensionsForNodeType"));

	CStr strBuf = NODE_TYPES_KEY;
	strBuf += _T("\\");

	CCoTaskMemPtr<WCHAR> spszNodeType;
	sc = StringFromCLSID(guid, &spszNodeType);
	if (sc)
		return (sc.ToHr());

	strBuf += static_cast<WCHAR*>(spszNodeType);

	// Open Dynamic Extensions key
	CStr strBufDyn = strBuf;
	strBufDyn += _T("\\");
	strBufDyn += g_szDynamicExtensions;

	CRegKeyEx rkeyDynExtns;
	sc = rkeyDynExtns.ScOpen (HKEY_LOCAL_MACHINE, strBufDyn, KEY_READ);
	BOOL bDynExtnsKey = !sc.IsError();
	sc.Clear();

	// Open Extensions key
	strBuf += _T("\\");
	strBuf += g_szExtensions;

	CRegKeyEx rkeyExtensions;
	sc = rkeyExtensions.ScOpen (HKEY_LOCAL_MACHINE, strBuf, KEY_READ);
	if (sc)
	{
		if (sc == ScFromWin32 (ERROR_FILE_NOT_FOUND))
			sc = S_FALSE;

		return (sc.ToHr());
	}

	USES_CONVERSION;
	TCHAR szValue[100];
	LPCTSTR apszExtnType[] = {g_szNameSpace, g_szContextMenu,
							  g_szToolbar,   g_szPropertySheet,
							  g_szTask,      g_szView};

	int iExtnTypeFlag[] = { CExtSI::EXT_TYPE_NAMESPACE, CExtSI::EXT_TYPE_CONTEXTMENU,
							CExtSI::EXT_TYPE_TOOLBAR,   CExtSI::EXT_TYPE_PROPERTYSHEET,
							CExtSI::EXT_TYPE_TASK,      CExtSI::EXT_TYPE_VIEW};

	for (int i=0; i < countof(apszExtnType); ++i)
	{
		CRegKeyEx rkeyTemp;
		sc = rkeyTemp.ScOpen (rkeyExtensions, apszExtnType[i], KEY_READ);
		if (sc)
		{
			if (sc == ScFromWin32 (ERROR_FILE_NOT_FOUND))
			{
				sc.Clear();
				continue;
			}

			return (sc.ToHr());
		}

		for (DWORD iValue = 0; ; ++iValue)
		{
			DWORD cchValue = countof(szValue);

			sc = rkeyTemp.ScEnumValue (iValue, szValue, &cchValue);
			if (sc)
			{
				if (sc == ScFromWin32 (ERROR_NO_MORE_ITEMS))
					sc.Clear();
                else
                    sc.TraceAndClear();

                break; // do NOT return; still need to loop through all snapins
			}

			GUID guid;
			sc = ::CLSIDFromString( T2W(szValue), &guid);
			if (sc)
			{
				sc.Clear();
				continue;
			}

			int iCurTypes = 0;
			extnsCache.Lookup(guid, iCurTypes);

            /*
            * After getting the snapin that extends given nodetype we should check if the
            * snapin is registered under SNAPINS key. If not do not add the entry to the
            * CExtensionsCache.
            */
            CRegKeyEx rkeySnapins;
            tstring strSnapin = SNAPINS_KEY;
            strSnapin += TEXT("\\");
            strSnapin += szValue;
            sc = rkeySnapins.ScOpen(HKEY_LOCAL_MACHINE, strSnapin.data(), KEY_READ);
            if (sc)
            {
                sc.TraceAndClear();
                continue;
            }

			iCurTypes |= iExtnTypeFlag[i];

			if (bDynExtnsKey && rkeyDynExtns.IsValuePresent(szValue))
				iCurTypes |= CExtSI::EXT_TYPE_DYNAMIC;
			else
				iCurTypes |= CExtSI::EXT_TYPE_STATIC;

			extnsCache.SetAt(guid, iCurTypes);
		}
	}

	return (sc.ToHr());
}


BOOL ExtendsNodeNameSpace(GUID& rguidNodeType, CLSID* pclsidExtn)
{
    BOOL bExtendsNameSpace = FALSE;

	USES_CONVERSION;
	OLECHAR szguid[40];

	int iStat = StringFromGUID2(rguidNodeType, szguid, countof(szguid));
	ASSERT(iStat != 0);

	// Create reg key string
	CStr strTestBuf = NODE_TYPES_KEY;
	strTestBuf += _T("\\");
	strTestBuf += OLE2T(szguid);
	strTestBuf += _T("\\");
	strTestBuf += g_szExtensions;
	strTestBuf += _T("\\");
	strTestBuf += g_szNameSpace;

	CRegKeyEx rKey;
	SC sc = rKey.ScOpen (HKEY_LOCAL_MACHINE, strTestBuf, KEY_READ);
	if (sc)
		return (false);

	// checking for any extension or a particular extension
	if (pclsidExtn == NULL)
	{
		DWORD dwValues;
		LONG lResult = ::RegQueryInfoKey( rKey, NULL, NULL, NULL, NULL, NULL, NULL,
										  &dwValues, NULL, NULL, NULL, NULL);
		ASSERT(lResult == ERROR_SUCCESS);

		bExtendsNameSpace = (dwValues != 0);
	}
	else
	{
		iStat = StringFromGUID2(*pclsidExtn, szguid, countof(szguid));
		ASSERT(iStat != 0);

		bExtendsNameSpace = rKey.IsValuePresent(OLE2T(szguid));
	}

    return bExtendsNameSpace;
}


//+-------------------------------------------------------------------
//
//  Member:     GetSnapinNameFromCLSID
//
//  Synopsis:   Get the name of the snapin provided class id.
//
//  Arguments:  [clsid]          - Class id of the snapin.
//              [wszSnapinName]  - Name.
//
//  Returns:    true if success else false
//
//--------------------------------------------------------------------
bool GetSnapinNameFromCLSID(/*[in]*/  const CLSID& clsid,
                            /*[out]*/ tstring& tszSnapinName)
{
    tszSnapinName.erase();

	WTL::CString strName;
    SC sc = ScGetSnapinNameFromRegistry (clsid, strName);
    if (sc)
        return false;

    tszSnapinName = strName;

    return true;
}


//+-------------------------------------------------------------------
//
//  Member:     ScGetAboutFromSnapinCLSID
//
//  Synopsis:   Get the CLSID of about object of given snapin.
//
//  Arguments:  [clsidSnapin] - Class id of the snapin.
//              [clsidAbout]  - out param, about object class-id.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC ScGetAboutFromSnapinCLSID(/*[in]*/  const CLSID& clsidSnapin,
                             /*[out]*/ CLSID& clsidAbout)
{
    DECLARE_SC(sc, TEXT("ScGetAboutFromSnapinCLSID"));

    // convert class id to string
    CCoTaskMemPtr<WCHAR> spszClsid;
    sc = StringFromCLSID(clsidSnapin, &spszClsid);
    if (sc)
        return sc;

    USES_CONVERSION;
    SC scNoTrace = ScGetAboutFromSnapinCLSID(OLE2CT(spszClsid), clsidAbout);
    if (scNoTrace)
        return scNoTrace;

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:     ScGetAboutFromSnapinCLSID
//
//  Synopsis:   Get the CLSID of about object of given snapin.
//
//  Arguments:  [lpszClsidSnapin] - Class id of the snapin.
//              [clsidAbout]      - out param, about object class-id.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC ScGetAboutFromSnapinCLSID(/*[in]*/  LPCTSTR lpszClsidSnapin,
                             /*[out]*/ CLSID& clsidAbout)
{
    DECLARE_SC(sc, TEXT("ScGetAboutFromSnapinCLSID"));

    // Get About
    CRegKeyEx SnapinKey;
    LONG lRet = SnapinKey.Open(HKEY_LOCAL_MACHINE, SNAPINS_KEY, KEY_READ);
    if (ERROR_SUCCESS != lRet)
        return (sc = E_FAIL);

    lRet = SnapinKey.Open(SnapinKey, lpszClsidSnapin, KEY_READ);
    if (ERROR_SUCCESS != lRet)
        return (sc = E_FAIL);

    TCHAR  szAbout[100];
    DWORD  dwSize = countof(szAbout);
    DWORD  dwType = REG_SZ;

    SC scNoTrace = SnapinKey.ScQueryValue (g_szAbout, &dwType, szAbout, &dwSize);
	if (scNoTrace)
		return (scNoTrace);

    USES_CONVERSION;
    sc = CLSIDFromString(T2OLE(szAbout), &clsidAbout);
    if (sc)
        return sc;

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\scopdata.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       ScopData.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:
//____________________________________________________________________________
//



#include "stdafx.h"
#include "ScopImag.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

class CDoc;


//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::InsertItem
//
//  Synopsis:    Insert an item in TreeView (IConsoleNameSpace method).
//
//  Arguments:   [pSDI] - LPSCOPEDATEITEM
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::InsertItem(LPSCOPEDATAITEM pSDI)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsoleNameSpace2::InsertItem"));

    if (!pSDI)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL LPSCOPEDATAITEM ptr"), sc);
        return sc.ToHr();
    }

    if (IsBadWritePtr(pSDI, sizeof(SCOPEDATAITEM)) != 0)
    {
        sc = E_POINTER;
        TraceSnapinError(_T("BadWrite Ptr LPSCOPEDATAITEM"), sc);
        return sc.ToHr();
    }

    COMPONENTID nID;
    GetComponentID(&nID);

    if (nID == TVOWNED_MAGICWORD)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    if (nID == -1)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    if (pSDI->relativeID == NULL)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("RelativeID is NULL"), sc);
        return sc.ToHr();
    }

    if ( 0 == (pSDI->mask & SDI_STR))
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("SDI_STR mask is not set"), sc);
        return sc.ToHr();
    }

    if (0 == (pSDI->mask & SDI_PARAM))
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("SDI_PARAM mask is not set"), sc);
        return sc.ToHr();
    }

    if (pSDI->displayname != MMC_TEXTCALLBACK)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Display name must be MMC_TEXTCALLBACK"), sc);
        return sc.ToHr();
    }

    SCOPEDATAITEM sdiTemp;
    CopyMemory(&sdiTemp, pSDI, sizeof(sdiTemp));

    sdiTemp.nImage = sdiTemp.nOpenImage = 0;

    if (pSDI->mask & SDI_IMAGE)
    {
        m_pImageListPriv->MapRsltImage(nID, pSDI->nImage, &sdiTemp.nImage);
        sdiTemp.nOpenImage = sdiTemp.nImage;
    }

    if (pSDI->mask & SDI_OPENIMAGE)
        m_pImageListPriv->MapRsltImage(nID, pSDI->nOpenImage, &sdiTemp.nOpenImage);

    try
    {
        CScopeTree* pScopeTree =
            dynamic_cast<CScopeTree*>((IScopeTree*)m_spScopeTree);
        sc = ScCheckPointers(pScopeTree, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        CMTNode* pMTNodeNew = NULL;
        sc = pScopeTree->ScInsert(&sdiTemp, nID, &pMTNodeNew);
        if(sc)
            return sc.ToHr();

        sc = ScCheckPointers(pMTNodeNew, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        pSDI->ID = sdiTemp.ID;
        ASSERT (CMTNode::FromScopeItem(pSDI->ID) == pMTNodeNew);
    }
    catch( std::bad_alloc )
    {
        sc = E_OUTOFMEMORY;
    }
    catch (...)
    {
        sc = E_FAIL;
    }

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::DeleteItem
//
//  Synopsis:    Delete the given item.
//
//  Arguments:   [hItem]       - ItemID of item to be deleted.
//               [fDeleteThis] - If true Delete this item & its children
//                               else just the children.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::DeleteItem(HSCOPEITEM hItem, long fDeleteThis)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsoleNameSpace2::DeleteItem"));

    COMPONENTID nID;
    GetComponentID(&nID);

    if (nID == -1)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    CMTNode *pMTNode = CMTNode::FromScopeItem (hItem);

    if (pMTNode == NULL)
    {
        sc = E_POINTER;
        TraceSnapinError(_T("HSCOPEITEM is not valid"), sc);
        return sc.ToHr();
    }

    CScopeTree* pScopeTree = CScopeTree::GetScopeTree();
    sc = ScCheckPointers(pScopeTree, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // Delete from scope tree.
    sc = pScopeTree->ScDelete(pMTNode, fDeleteThis ? TRUE : FALSE, nID);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::SetItem
//
//  Synopsis:    Change the attributes of an item.
//
//  Arguments:   [pSDI] -
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::SetItem(LPSCOPEDATAITEM pSDI)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsoleNameSpace2::SetItem"));

    if (!pSDI)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL LPSCOPEDATAITEM ptr"), sc);
        return sc.ToHr();
    }

    if (IsBadReadPtr(pSDI, sizeof(SCOPEDATAITEM)) != 0)
    {
        sc = E_POINTER;
        TraceSnapinError(_T("LPSCOPEDATAITEM is bad read ptr"), sc);
        return sc.ToHr();
    }

    COMPONENTID nID;
    GetComponentID(&nID);

    if (nID == -1)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    CMTNode* pMTNode = CMTNode::FromScopeItem (pSDI->ID);

    if (pMTNode == NULL)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Invalid ID in LPSCOPEDATAITEM"), sc);
        return sc.ToHr();
    }

    // Access pMTNode inside try-catch
    try
    {
        if (pMTNode->GetOwnerID() != nID &&
            pMTNode->GetOwnerID() != TVOWNED_MAGICWORD)
        {
            sc = E_INVALIDARG;
            return sc.ToHr();
        }

        if (pSDI->mask & SDI_PARAM)
            pMTNode->SetUserParam(pSDI->lParam);

        if (pSDI->mask & SDI_STATE)
            pMTNode->SetState(pSDI->nState);

        if (pSDI->mask & SDI_STR)
		{
            // Only static node's string can be modified, other node's use MMC_TEXTCALLBACK.
            if ((pSDI->displayname != MMC_TEXTCALLBACK) && (!pMTNode->IsStaticNode()) )
            {
                /*
                 * We should be tracing and returning E_INVALIDARG. But this code is in existence
                 * for more than 3 years and has high impact. So we just trace and proceed as if
                 * no error occurred.
                 */
                //sc = E_INVALIDARG;
                TraceSnapinError(_T("Display name must be MMC_TEXTCALLBACK"), sc);
                //return sc.ToHr();
                sc = S_OK;
            }
            else
            {
                USES_CONVERSION;
                LPCTSTR lpstrDisplayName = NULL;
                if ( pSDI->displayname != MMC_TEXTCALLBACK )
                    lpstrDisplayName = W2T(pSDI->displayname);
                else
                    lpstrDisplayName = reinterpret_cast<LPCTSTR>(MMC_TEXTCALLBACK);

                pMTNode->SetDisplayName( lpstrDisplayName );
            }
        }

        int nTemp;

        if (pSDI->mask & SDI_IMAGE)
        {
            // Change the image.
            nTemp = pSDI->nImage;
            if (pSDI->nImage == MMC_IMAGECALLBACK)
             {
                CComponentData* pCCD = pMTNode->GetPrimaryComponentData();
                if (pCCD)
                {
                    SCOPEDATAITEM ScopeDataItem;
                    ZeroMemory(&ScopeDataItem, sizeof(ScopeDataItem));
                    ScopeDataItem.mask   = SDI_IMAGE;
                    ScopeDataItem.lParam = pMTNode->GetUserParam();
                    ScopeDataItem.nImage = 0;
                    sc = pCCD->GetDisplayInfo(&ScopeDataItem);
                    if (sc)
                        return sc.ToHr();

                    pSDI->nImage = ScopeDataItem.nImage;
                }
            }

            sc = m_pImageListPriv->MapRsltImage (nID, pSDI->nImage, &nTemp);
            if (sc)
			{
				TraceSnapinError(_T("The snapin specified image was never added initially"), sc);
				sc.Clear();
			}

            pMTNode->SetImage (nTemp);
            CMTSnapInNode* pMTSnapInNode = dynamic_cast<CMTSnapInNode*>(pMTNode);
            if (pMTSnapInNode)
                pMTSnapInNode->SetResultImage (MMC_IMAGECALLBACK);
        }

        if (pSDI->mask & SDI_OPENIMAGE)
        {
            nTemp = pSDI->nOpenImage;
            if (pSDI->nOpenImage == MMC_IMAGECALLBACK)
            {
                CComponentData* pCCD = pMTNode->GetPrimaryComponentData();
                if (pCCD)
                {
                    SCOPEDATAITEM ScopeDataItem;
                    ZeroMemory(&ScopeDataItem, sizeof(ScopeDataItem));
                    ScopeDataItem.mask   = SDI_OPENIMAGE;
                    ScopeDataItem.lParam = pMTNode->GetUserParam();
                    ScopeDataItem.nOpenImage = 1;
                    sc = pCCD->GetDisplayInfo(&ScopeDataItem);
                    if (sc)
                        return sc.ToHr();

                    pSDI->nOpenImage = ScopeDataItem.nOpenImage;
                }
            }
            sc = m_pImageListPriv->MapRsltImage (nID, pSDI->nOpenImage, &nTemp);
            if (sc)
			{
				TraceSnapinError(_T("The snapin specified image was never added initially"), sc);
				sc.Clear();
			}

            pMTNode->SetOpenImage (nTemp);
        }

        if (pSDI->mask & SDI_CHILDREN)
        {
            pMTNode->SetNoPrimaryChildren(pSDI->cChildren == 0);
        }

        // Now inform the views to modify as needed.
        SViewUpdateInfo vui;
        // Snapin nodes result pane will be handled by the snapins
        vui.flag = VUI_REFRESH_NODE;
        pMTNode->CreatePathList(vui.path);
        CScopeTree* pScopeTree =
            dynamic_cast<CScopeTree*>((IScopeTree*)m_spScopeTree);
        pScopeTree->UpdateAllViews(VIEW_UPDATE_MODIFY,
                                   reinterpret_cast<LPARAM>(&vui));

    }
    catch (...)
    {
        sc = E_FAIL;
    }

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::GetItem
//
//  Synopsis:    Get the attributes of an item given ItemID.
//
//  Arguments:   [pSDI]
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::GetItem(LPSCOPEDATAITEM pSDI)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsoleNameSpace2::GetItem"));

    if (!pSDI)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL LPSCOPEDATAITEM ptr"), sc);
        return sc.ToHr();
    }

    if (IsBadWritePtr(pSDI, sizeof(SCOPEDATAITEM)) != 0)
    {
        sc = E_POINTER;
        TraceSnapinError(_T("BadWrite Ptr LPSCOPEDATAITEM"), sc);
        return sc.ToHr();
    }

    COMPONENTID nID;
    GetComponentID(&nID);

    if (nID == -1)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    CMTNode* pMTNode = CMTNode::FromScopeItem (pSDI->ID);

    sc = ScCheckPointers(pMTNode);
    if (sc)
        return sc.ToHr();

    try
    {
        if (pMTNode->GetOwnerID() != nID &&
            pMTNode->GetOwnerID() != TVOWNED_MAGICWORD)
        {
            sc = E_INVALIDARG;
            return sc.ToHr();
        }

        if (pSDI->mask & SDI_IMAGE)
		{
			sc = m_pImageListPriv->UnmapRsltImage (nID, pMTNode->GetImage(), &pSDI->nImage);
			if (sc)
				return (sc.ToHr());
		}

        if (pSDI->mask & SDI_OPENIMAGE)
		{
			sc = m_pImageListPriv->UnmapRsltImage (nID, pMTNode->GetOpenImage(), &pSDI->nOpenImage);
			if (sc)
				return (sc.ToHr());
		}

        if (pSDI->mask & SDI_STATE)
            pSDI->nState = pMTNode->GetState();

        if (pSDI->mask & SDI_PARAM)
            pSDI->lParam = pMTNode->GetUserParam();
    }
    catch (...)
    {
        sc = E_FAIL;
    }

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::GetRelativeItem
//
//  Synopsis:    Helper function, Get Parent/Child/Sibling item.
//
//  Arguments:
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
HRESULT CNodeInitObject::GetRelativeItem(EGetItem egi, HSCOPEITEM item,
                        HSCOPEITEM* pItem, MMC_COOKIE* pCookie)

{
    DECLARE_SC(sc, _T("CNodeInitObject::GetRelativeItem"));

    if (item == 0)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("The HSCOPEITEM is NULL"), sc);
        return sc.ToHr();
    }

    if (pItem == NULL)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL HSCOPEITEM ptr"), sc);
        return sc.ToHr();
    }

    if (pCookie == NULL)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL MMC_COOKIE ptr"), sc);
        return sc.ToHr();
    }

    COMPONENTID nID;
    GetComponentID(&nID);

    if (nID == -1)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    // init
    *pItem = 0;
    *pCookie = 0;

    if (item != 0)
    {
        CMTNode* pMTNode = CMTNode::FromScopeItem (item);

        if (pMTNode == NULL)
        {
            sc = E_INVALIDARG;
            TraceSnapinError(_T("Invalid HSCOPEITEM"), sc);
            return sc.ToHr();
        }

        CMTNode* pMTNodeTemp = pMTNode;

        try
        {

            switch (egi)
            {
            case egiParent:
                if (pMTNodeTemp->GetPrimaryComponentID() != nID &&
                    pMTNodeTemp->GetPrimaryComponentID() != TVOWNED_MAGICWORD)
                {
                    sc = E_FAIL;
                    return sc.ToHr();
                }

                if (pMTNodeTemp->IsStaticNode() == TRUE)
                {
                    sc = E_FAIL;
                    return sc.ToHr();
                }

                pMTNodeTemp = pMTNodeTemp->Parent();
                break;

            case egiChild:
                pMTNodeTemp = pMTNodeTemp->Child();

                while (pMTNodeTemp != NULL)
                {
                    if (pMTNodeTemp->GetPrimaryComponentID() == nID)
                        break;

                    pMTNodeTemp = pMTNodeTemp->Next();
                }
                break;

            case egiNext:
                if (pMTNodeTemp->GetPrimaryComponentID() != nID &&
                    pMTNodeTemp->GetPrimaryComponentID() != TVOWNED_MAGICWORD)
                {
                    sc = E_FAIL;
                    return sc.ToHr();
                }

                while (1)
                {
                    pMTNodeTemp = pMTNodeTemp->Next();
                    if (pMTNodeTemp == NULL)
                        break;

                    if (pMTNodeTemp->GetPrimaryComponentID() == nID)
                        break;
                }
                break;

            default:
                sc = E_UNEXPECTED;
                break;
            }

            if (pMTNodeTemp != NULL)
            {
                *pItem   = CMTNode::ToScopeItem(pMTNodeTemp);
                *pCookie = pMTNodeTemp->GetUserParam();
            }
            else
            {
                sc = S_FALSE;
            }
        }
        catch (...)
        {
            sc = E_INVALIDARG;
        }
    }

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::GetChildItem
//
//  Synopsis:    Get the child item
//
//  Arguments:
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::GetChildItem(HSCOPEITEM item,
                                   HSCOPEITEM* pItemChild, MMC_COOKIE* pCookie)

{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsoleNameSpace2::GetChildItem"));

    sc = GetRelativeItem(egiChild, item, pItemChild, pCookie);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::GetNextItem
//
//  Synopsis:    Get the next (sibling) item.
//
//  Arguments:
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------

STDMETHODIMP CNodeInitObject::GetNextItem(HSCOPEITEM item,
                                   HSCOPEITEM* pItemNext, MMC_COOKIE* pCookie)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsoleNameSpace2::GetNextItem"));

    sc = GetRelativeItem(egiNext, item, pItemNext, pCookie);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::GetParentItem
//
//  Synopsis:    Get the parent item.
//
//  Arguments:
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------

STDMETHODIMP CNodeInitObject::GetParentItem(HSCOPEITEM item,
                                   HSCOPEITEM* pItemParent, MMC_COOKIE* pCookie)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsoleNameSpace2::GetParentItem"));

    sc = GetRelativeItem(egiParent, item, pItemParent, pCookie);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeInitObject::Expand
//
//  Synopsis:    Expand the given item (not visually, this will send
//               MMCN_EXPAND to snapin if the item is not already
//               expanded.)
//
//  Arguments:  [hItem] - Item to be expanded.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeInitObject::Expand(HSCOPEITEM hItem)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IConsoleNameSpace2::Expand"));

    CMTNode* pMTNode = CMTNode::FromScopeItem (hItem);

    if (pMTNode == NULL)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Invalid HSCOPEITEM"), sc);
        return sc.ToHr();
    }

    if (pMTNode->WasExpandedAtLeastOnce() == TRUE)
    {
        // Item is already expanded.
        sc = S_FALSE;
        return sc.ToHr();
    }

    sc = pMTNode->Expand();

    return sc.ToHr();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\scopimag.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       ScopImag.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10/4/1996   RaviR   Created
//____________________________________________________________________________
//


#include "stdafx.h"

#include "bitmap.h"
#include "scopimag.h"
#include "util.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

typedef WORD ICONID;
typedef DWORD SNAPINICONID;
typedef int ILINDEX; // image list index

#define MAKESNAPINICONID(ICONID, SNAPINID)  MAKELONG(ICONID, SNAPINID)
#define GETSNAPINID(SNAPINICONID)           ((int)(short)HIWORD(SNAPINICONID))
#define GETICONID(SNAPINICONID)             ((int)(short)LOWORD(SNAPINICONID))

//______________________________________________________________________
//______________________________________________________________________
//______________________________________________________________________
//______________________________________________________________________
//

class CGuidArrayEx : public CArray<GUID, REFGUID>
{
public:
    CGuidArrayEx() { SetSize(0, 10); }
    ~CGuidArrayEx() {}

    int Find(REFGUID refGuid);

}; // class CGuidArrayEx


static CGuidArrayEx s_GuidArray;

int CGuidArrayEx::Find(REFGUID refGuid)
{
    for (int i=0; i <= GetUpperBound(); i++)
    {
        if (IsEqualGUID(refGuid, (*this)[i]) == TRUE)
            return i;
    }

    return -1;
}


//______________________________________________________________________
//______________________________________________________________________
//______________________________________________________________________
//______________________________________________________________________
//

DEBUG_DECLARE_INSTANCE_COUNTER(CSnapInImageList);

CSnapInImageList::CSnapInImageList(
    CSPImageCache *pSPImageCache,
    REFGUID refGuidSnapIn)
        :
        m_ulRefs(1),
        m_pSPImageCache(pSPImageCache)
{
    ASSERT(pSPImageCache != NULL);

    m_pSPImageCache = pSPImageCache;

    m_pSPImageCache->AddRef();

    int iRet = s_GuidArray.Find(refGuidSnapIn);

    if (iRet == -1)
        iRet = s_GuidArray.Add(refGuidSnapIn);

    m_snapInId = static_cast<WORD>(iRet);

    DEBUG_INCREMENT_INSTANCE_COUNTER(CSnapInImageList);
}

CSnapInImageList::~CSnapInImageList()
{
    SAFE_RELEASE(m_pSPImageCache);
    DEBUG_DECREMENT_INSTANCE_COUNTER(CSnapInImageList);
}

// IUnknown methods

STDMETHODIMP_(ULONG) CSnapInImageList::AddRef()
{
    return InterlockedIncrement((LONG*)&m_ulRefs);
}

STDMETHODIMP_(ULONG) CSnapInImageList::Release()
{
    ULONG ulRet = InterlockedDecrement((LONG*)&m_ulRefs);
    if (0 == ulRet)
    {
        delete this;
    }
    return ulRet;
}



STDMETHODIMP
CSnapInImageList::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    LPUNKNOWN punk = NULL;

    if (IsEqualIID(IID_IUnknown, riid) ||
        IsEqualIID(IID_IImageList, riid))
    {
        punk = (IUnknown*)(IImageList*) this;
    }
    else if (IsEqualIID(IID_IImageListPrivate, riid))
    {
        punk = (IUnknown*)(IImageListPrivate*) this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    *ppvObj = punk;
    punk->AddRef();

    return S_OK;
}

STDMETHODIMP
CSnapInImageList::ImageListSetIcon(
    PLONG_PTR pIcon,
    LONG nLoc)
{
    return m_pSPImageCache->SetIcon(m_snapInId, reinterpret_cast<HICON>(pIcon), nLoc);
}



STDMETHODIMP
CSnapInImageList::ImageListSetStrip(
    PLONG_PTR pBMapSm,
    PLONG_PTR pBMapLg,
    LONG nStartLoc,
    COLORREF cMask)
{
    BITMAP szSmall;

    ASSERT(pBMapSm != NULL);

    //HBITMAP hBMapSm = reinterpret_cast<HBITMAP>(pBMapSm);
    HBITMAP hBMapSm = (HBITMAP)pBMapSm;

    if (GetObject(hBMapSm, sizeof(BITMAP), &szSmall) == 0)
    {
        if (GetBitmapBits(hBMapSm, sizeof(BITMAP), &szSmall) == 0)
        {
            LRESULT lr = GetLastError();
            return HRESULT_FROM_WIN32(lr);
        }
    }

    int nEntries = szSmall.bmWidth/16;

    if ((szSmall.bmHeight != 16) || (szSmall.bmWidth % 16))
        return E_INVALIDARG;

    return (m_pSPImageCache->SetImageStrip (m_snapInId, (HBITMAP)pBMapSm,
											nStartLoc, cMask, nEntries));
}


STDMETHODIMP
CSnapInImageList::MapRsltImage(
    COMPONENTID id,
    int nSnapinIndex,
    int *pnConsoleIndex)
{
	DECLARE_SC (sc, _T("CSnapInImageList::MapRsltImage"));

	sc = ScCheckPointers (pnConsoleIndex);
	if (sc)
		return (sc.ToHr());

    sc = m_pSPImageCache->ScMapSnapinIndexToScopeIndex(m_snapInId, nSnapinIndex, *pnConsoleIndex);
	if (sc)
		return (sc.ToHr());

	return (sc.ToHr());
}


STDMETHODIMP
CSnapInImageList::UnmapRsltImage(
    COMPONENTID id,
    int nConsoleIndex,
    int *pnSnapinIndex)
{
	DECLARE_SC (sc, _T("CSnapInImageList::MapRsltImage"));

	sc = ScCheckPointers (pnSnapinIndex);
	if (sc)
		return (sc.ToHr());

    sc = m_pSPImageCache->ScMapScopeIndexToSnapinIndex(m_snapInId, nConsoleIndex, *pnSnapinIndex);
	if (sc)
		return (sc.ToHr());

	return (sc.ToHr());
}



//______________________________________________________________________
//______________________________________________________________________
//______________________________________________________________________
//______________________________________________________________________
//

DEBUG_DECLARE_INSTANCE_COUNTER(CSPImageCache);

CSPImageCache::CSPImageCache()
    :
    m_map(20),
    m_il(),
    m_cRef(1)
{
    m_map.InitHashTable(223);

    BOOL fReturn = m_il.Create(16, 16, ILC_COLOR8 | ILC_MASK, 20, 10);
    ASSERT((fReturn != 0) && "Failed to create ImageList");

    DEBUG_INCREMENT_INSTANCE_COUNTER(CSPImageCache);
}


CSPImageCache::~CSPImageCache()
{
    m_il.Destroy();
    ASSERT(m_cRef == 0);

    DEBUG_DECREMENT_INSTANCE_COUNTER(CSPImageCache);
}

HRESULT
CSPImageCache::SetIcon(
    SNAPINID    sid,
    HICON       hIcon,
    LONG        nLoc)
{
    SNAPINICONID key = MAKESNAPINICONID(nLoc, sid);
    ULONG nNdx1;
    ULONG nNdx2;

    HRESULT hr = S_OK;


    //m_critSec.Lock(m_hWnd);

    if (m_map.Lookup(key, nNdx1))
    {
        nNdx2 = m_il.ReplaceIcon(nNdx1, hIcon);

        if (nNdx2 == -1)
        {
            hr = E_FAIL;
            CHECK_HRESULT(hr);
        }
        else if (nNdx2 != nNdx1)
        {
            hr  = E_UNEXPECTED;
            CHECK_HRESULT(hr);
        }
    }
    else
    {
        // Add the icon to imagelist
        nNdx1 = m_il.AddIcon(hIcon);

        if (nNdx1 == -1)
        {
            hr = E_FAIL;
            CHECK_HRESULT(hr);
        }
        else
        {
            // Generate a new key and store the values in the maps
            m_map.SetAt(key, nNdx1);
        }
    }

    //m_critSec.Unlock();

    return hr;
}



HRESULT
CSPImageCache::SetImageStrip(
    SNAPINID    sid,
    HBITMAP     hBMap,
    LONG        nStartLoc,
    COLORREF    cMask,
    int         nEntries)
{
    DECLARE_SC(sc, TEXT("CSPImageCache::SetImageStrip"));

    ULONG nNdx;


    // The CImageList::Add modifies the input bitmaps so make a copy first.
    WTL::CBitmap bmSmall;
    bmSmall.Attach(CopyBitmap(hBMap));

    if (bmSmall.IsNull())
		return (sc.FromLastError().ToHr());

    nNdx = m_il.Add( bmSmall, cMask);

    if (nNdx == -1)
        return (sc = E_FAIL).ToHr();

    // Keep the map updated for each newly inserted image.
    for (int i=0; i < nEntries; i++)
    {
        // REVIEW: review this part of the code.
        SNAPINICONID key = MAKESNAPINICONID(nStartLoc, sid);
        m_map.SetAt(key, nNdx);
        ++nStartLoc;
        ++nNdx;
    }

    return sc.ToHr();
}


/*+-------------------------------------------------------------------------*
 * ScMapSnapinIndexToScopeIndex
 *
 * Maps a snap-in's typically zero-based image index to an index for the
 * common scope tree image list
 *--------------------------------------------------------------------------*/

SC CSPImageCache::ScMapSnapinIndexToScopeIndex (
	SNAPINID	sid,			// I:what snap-in is this for?
	int			nSnapinIndex,	// I:index by which the snap-in refers to the image
	int&		nScopeIndex)	// O:index by which the scope tree refers to the image
{
	DECLARE_SC (sc, _T("ScMapSnapinIndexToScopeIndex"));

    SNAPINICONID key = MAKESNAPINICONID(nSnapinIndex, sid);
	ASSERT (GETSNAPINID (key) == sid);
	ASSERT (GETICONID   (key) == nSnapinIndex);

    ULONG ul;
    if (!m_map.Lookup(key, ul))
		return (sc = E_FAIL);

    nScopeIndex = ul;
    return (sc);
}


/*+-------------------------------------------------------------------------*
 * ScMapScopeIndexToSnapinIndex
 *
 * Maps a scope tree image index to the given snap-in's image index.
 *--------------------------------------------------------------------------*/

SC CSPImageCache::ScMapScopeIndexToSnapinIndex (
	SNAPINID	sid,			// I:what snap-in is this for?
	int			nScopeIndex,	// I:index by which the scope tree refers to the image
	int&		nSnapinIndex)	// O:index by which the snap-in refers to the image
{
	DECLARE_SC (sc, _T("ScMapScopeIndexToSnapinIndex"));
	sc = E_FAIL;	// assume failure

	/*
	 * iterate through the map looking for scope indices matching the requested one
	 */
	for (POSITION pos = m_map.GetStartPosition(); pos != NULL; )
	{
		SNAPINICONID key;
		DWORD value;
		m_map.GetNextAssoc (pos, key, value);

		/*
		 * if this value matches the requested scope image index and it
		 * belongs to the given snap-in, we've found a match; return it
		 */
		if ((value == nScopeIndex) && (GETSNAPINID(key) == sid))
		{
			nSnapinIndex = GETICONID (key);
			sc = S_OK;
			break;
		}
	}

    return (sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\scopimag.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       ScopImag.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10/4/1996   RaviR   Created
//____________________________________________________________________________
//


#ifndef _SCOPIMAG_H_
#define _SCOPIMAG_H_

typedef WORD SNAPINID;


typedef CMap<DWORD, DWORD&, DWORD, DWORD&> CSIIconIdToILIndexMap;


class CSPImageCache
{
public:
// Constructor
    CSPImageCache();

// Attributes
    WTL::CImageList* GetImageList() { return &m_il; }

// Operations
    // Image manipulation.
    HRESULT SetIcon(SNAPINID sid, HICON hIcon, LONG  nLoc);
    HRESULT SetImageStrip(SNAPINID sid, HBITMAP hBMapSm,
                          LONG nStartLoc, COLORREF cMask, int nEntries);
    SC ScMapSnapinIndexToScopeIndex (SNAPINID sid, int nSnapinIndex, int& nScopeIndex);
    SC ScMapScopeIndexToSnapinIndex (SNAPINID sid, int nScopeIndex, int& nSnapinIndex);

    // Reference counting
    void AddRef();
    void Release();

// Implementation
private:
    CSIIconIdToILIndexMap   m_map;
    WTL::CImageList         m_il;
    ULONG                   m_cRef;

// Destructor - called only by Release
    ~CSPImageCache();

}; // class CSPImageCache



class CSnapInImageList : public IImageListPrivate
{
public:
// Constructor & Destructor
    CSnapInImageList(CSPImageCache *pSPImageCache, REFGUID refGuidSnapIn);
    ~CSnapInImageList();

// Interfaces
    // IUnknown methods
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef) (void);
    STDMETHOD_(ULONG,Release) (void);

    // IImageListPrivate methods
    STDMETHOD(ImageListSetIcon)(PLONG_PTR pIcon, LONG nLoc);
    STDMETHOD(ImageListSetStrip)(PLONG_PTR pBMapSm, PLONG_PTR pBMapLg,
                                 LONG nStartLoc, COLORREF cMask);

    STDMETHOD(MapRsltImage)(COMPONENTID id, int nSnapinIndex, int *pnConsoleIndex);
    STDMETHOD(UnmapRsltImage)(COMPONENTID id, int nConsoleIndex, int *pnSnapinIndex);
    STDMETHOD(GetImageList)(BOOL bLargeImageList, HIMAGELIST *phImageList)
    {
        // Not needed now, GetImageList is implemented for NodeInitObject.
        return E_NOTIMPL;
    }


// Implementation
private:
    CSPImageCache *     m_pSPImageCache;
    ULONG               m_ulRefs;
    SNAPINID            m_snapInId;

}; // class CSnapInImageList



///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//////////////              INLINES                 ///////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


//_____________________________________________________________________________
//
//  Inlines for class:  CSPImageCache
//_____________________________________________________________________________
//

inline void CSPImageCache::AddRef()
{
    ++m_cRef;
}

inline void CSPImageCache::Release()
{
    ASSERT(m_cRef >= 1);
    --m_cRef;

    if (m_cRef == 0)
        delete this;
}


#endif // _SCOPIMAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\scopiter.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       ScopIter.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:
//____________________________________________________________________________
//

#include "stdafx.h"
#include "scopiter.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

DEBUG_DECLARE_INSTANCE_COUNTER(CScopeTreeIterator);

CScopeTreeIterator::CScopeTreeIterator() : m_pMTNodeCurr(NULL)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CScopeTreeIterator);
}

CScopeTreeIterator::~CScopeTreeIterator()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CScopeTreeIterator);
}

STDMETHODIMP CScopeTreeIterator::SetCurrent(HMTNODE hMTNode)
{
    MMC_TRY

    if (hMTNode == 0)
        return E_INVALIDARG;

    m_pMTNodeCurr = CMTNode::FromHandle(hMTNode);

    return S_OK;

    MMC_CATCH
}

STDMETHODIMP CScopeTreeIterator::Next(UINT nRequested, HMTNODE* rghScopeItems,
                                      UINT* pnFetched)
{
    MMC_TRY

    if (rghScopeItems == NULL || pnFetched == NULL)
        return E_POINTER;

    *pnFetched = 0; // init

    if (nRequested == 0)
        return S_OK;

    int i = 0;
    CMTNode** rgpMTNodes = reinterpret_cast<CMTNode**>(rghScopeItems);

    while (m_pMTNodeCurr != NULL && nRequested--)
    {
        rgpMTNodes[i++] = m_pMTNodeCurr;
        m_pMTNodeCurr = m_pMTNodeCurr->Next();
    }

    *pnFetched = i;

    return S_OK;

    MMC_CATCH
}

STDMETHODIMP CScopeTreeIterator::Child(HMTNODE* phsiChild)
{
    MMC_TRY

    if (phsiChild == NULL)
        return E_POINTER;

    *phsiChild = 0; // init

    if (m_pMTNodeCurr != NULL)
        *phsiChild = CMTNode::ToHandle(m_pMTNodeCurr->Child());

    return S_OK;

    MMC_CATCH
}

STDMETHODIMP CScopeTreeIterator::Parent(HMTNODE* phsiParent)
{
    MMC_TRY

    if (phsiParent == NULL)
        return E_POINTER;

    *phsiParent = 0; // init

    if (m_pMTNodeCurr != NULL)
        *phsiParent = CMTNode::ToHandle(m_pMTNodeCurr->Child());

    return S_OK;

    MMC_CATCH
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\scopiter.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       ScopIter.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    
//____________________________________________________________________________
//

#ifndef _SCOPITER_H_
#define _SCOPITER_H_

class CMTNode;

class CScopeTreeIterator : public IScopeTreeIter, public CComObjectRoot
{
// Constructor/Destructor
public:
    CScopeTreeIterator();
    ~CScopeTreeIterator();

public:
BEGIN_COM_MAP(CScopeTreeIterator)
    COM_INTERFACE_ENTRY(IScopeTreeIter)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CScopeTreeIterator)

// COM interfaces
public:
    // IScopeTreeIter methods
    STDMETHOD(SetCurrent)(HMTNODE hStartMTNode);
    STDMETHOD(Next)(UINT nRequested, HMTNODE* rghScopeItems, UINT* pnFetched);
    STDMETHOD(Child)(HMTNODE* phsiChild);
    STDMETHOD(Parent)(HMTNODE* phsiParent);

// Implementation
private:
    CMTNode*    m_pMTNodeCurr;
};



#endif // _SCOPITER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\scoptree.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       scoptree.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "scopiter.h"
#include "scopndcb.h"

#include "addsnpin.h"
#include "ScopImag.h"
#include "NodeMgr.h"

#include "amcmsgid.h"
#include "regutil.h"
#include "copypast.h"
#include "multisel.h"
#include "nodepath.h"
#include "tasks.h"
#include "colwidth.h"
#include "viewpers.h"
#include <comdbg.h>
#include "conframe.h"
#include "siprop.h"
#include "fldrsnap.h"
#include "variant.h"
#include "condoc.h"
#include "oncmenu.h"
#include "conview.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#ifdef DBG
CTraceTag tagScopeTreeAddSnapin(TEXT("CScopeTree"), TEXT("ScAddSnapIn"));
#endif


//############################################################################
//############################################################################
//
//  Implementation of class CSnapIns
//
//############################################################################
//############################################################################
/*+-------------------------------------------------------------------------*
 * class CSnapIns
 *
 *
 * PURPOSE: Implements the SnapIns automation interface.
 *
 *+-------------------------------------------------------------------------*/
class _CSnapIns :
    public CMMCIDispatchImpl<SnapIns>,
    public CTiedComObject<CScopeTree>
{
protected:

    typedef CScopeTree CMyTiedObject;

public:
    BEGIN_MMC_COM_MAP(_CSnapIns)
    END_MMC_COM_MAP()

    // SnapIns interface
public:
    MMC_METHOD4(Add,            BSTR /*bstrSnapinNameOrCLSID*/, VARIANT /*varParentSnapinNode*/, VARIANT /*varProperties*/, PPSNAPIN /*ppSnapIn*/);
    MMC_METHOD2(Item,           long /*Index*/, PPSNAPIN /*ppSnapIn*/);
    MMC_METHOD1(Remove,         PSNAPIN /*pSnapIn*/)
    MMC_METHOD1(get_Count, PLONG /*pCount*/);

    IUnknown *STDMETHODCALLTYPE get__NewEnum() {return NULL;}
};


// this typedefs the real CSnapIns class. Implements get__NewEnum using CMMCEnumerator and a CSnapIns_Positon object
typedef CMMCNewEnumImpl<_CSnapIns, CScopeTree::CSnapIns_Positon> CSnapIns;


//############################################################################
//############################################################################
//
//  Implementation of class CScopeNamespace
//
//############################################################################
//############################################################################
/*+-------------------------------------------------------------------------*
 * class CScopeNamespace
 *
 *
 * PURPOSE: Implements the ScopeNamespace automation interface.
 *
 *+-------------------------------------------------------------------------*/
class CScopeNamespace :
    public CMMCIDispatchImpl<ScopeNamespace>,
    public CTiedComObject<CScopeTree>
{
protected:

    typedef CScopeTree CMyTiedObject;

public:
    BEGIN_MMC_COM_MAP(CScopeNamespace)
    END_MMC_COM_MAP()

    // ScopeNamespace interface
public:
    MMC_METHOD2(GetParent,     PNODE /*pNode*/, PPNODE /*ppParent*/);
    MMC_METHOD2(GetChild,      PNODE /*pNode*/, PPNODE /*ppChild*/);
    MMC_METHOD2(GetNext,       PNODE /*pNode*/, PPNODE /*ppNext*/);
    MMC_METHOD1(GetRoot,       PPNODE /*ppRoot*/);
    MMC_METHOD1(Expand,        PNODE  /*pNode*/);
};



//############################################################################
//############################################################################
//
//  Implementation of class CMMCScopeNode
//
//############################################################################
//############################################################################
/*+-------------------------------------------------------------------------*
 *
 * CMMCScopeNode::~CMMCScopeNode
 *
 * PURPOSE: Destructor
 *
 * PARAMETERS:
 *
 * RETURNS:
 *
 *+-------------------------------------------------------------------------*/
CMMCScopeNode::~CMMCScopeNode()
{
    DECLARE_SC(sc, TEXT("CMMCScopeNode::~CMMCScopeNode"));

    CScopeTree *pScopeTree = CScopeTree::GetScopeTree();
    sc = ScCheckPointers(pScopeTree, E_UNEXPECTED);
    if (!sc)
    {
        sc = pScopeTree->ScUnadviseMMCScopeNode(this);
    }
}

/*+-------------------------------------------------------------------------*
 *
 * CMMCScopeNode::ScIsValid
 *
 * PURPOSE: Returns an error if the COM object is no longer valid.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CMMCScopeNode::ScIsValid()
{
    DECLARE_SC(sc, TEXT("CMMCScopeNode::ScIsValid"));

    if(!GetMTNode())
        return (sc = E_INVALIDARG);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CMMCScopeNode::get_Name
 *
 * PURPOSE: Returns the display name of the node.
 *
 * PARAMETERS:
 *    PBSTR   pbstrName :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CMMCScopeNode::get_Name( PBSTR  pbstrName)
{
    DECLARE_SC(sc, TEXT("CMMCScopeNode::get_Name"));

    // check parameters
    if (!pbstrName)
        return ((sc = E_INVALIDARG).ToHr());

    CMTNode* pMTNode = GetMTNode();
    sc = ScCheckPointers (pMTNode, E_UNEXPECTED);
    if (sc)
        return (sc.ToHr());

    tstring strName = pMTNode->GetDisplayName();
    if (strName.empty())
        return ((sc = E_UNEXPECTED).ToHr());

    USES_CONVERSION;
    *pbstrName = ::SysAllocString (T2COLE(strName.data())); // caller frees

    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CMMCScopeNode::ScGetDataObject
 *
 * PURPOSE: Returns the data object for a scope node.
 *
 * PARAMETERS:
 *    IDataObject ** ppDataObject :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CMMCScopeNode::ScGetDataObject(IDataObject **ppDataObject)
{
    DECLARE_SC(sc, TEXT("CMMCScopeNode::ScGetDataObject"));

    sc = ScCheckPointers(ppDataObject);
    if(sc)
        return sc;

    // init out parameter
    *ppDataObject = NULL;

    // get the MT node
    CMTNode *pMTNode = GetMTNode();
    sc = ScCheckPointers( pMTNode, E_UNEXPECTED );
    if(sc)
        return sc;

    CComponentData* pCCD = pMTNode->GetPrimaryComponentData();
    sc = ScCheckPointers( pCCD, E_NOTIMPL ); // no component data -> no property...
    if(sc)
        return sc;

    // ensure node is expanded before requesting data object
    if (pMTNode->WasExpandedAtLeastOnce() == FALSE)
        pMTNode->Expand();

    // Get the data object for the cookie from the owner snap-in
    sc = pCCD->QueryDataObject(pMTNode->GetUserParam(), CCT_SCOPE, ppDataObject);

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMMCScopeNode::get_Property
 *
 * PURPOSE: returns snapins property for scope node
 *
 * PARAMETERS:
 *    BSTR bstrPropertyName     -[in] property name (clipboard format)
 *    PBSTR  pbstrPropertyValue -[out] property value
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
STDMETHODIMP
CMMCScopeNode::get_Property( BSTR bstrPropertyName, PBSTR  pbstrPropertyValue )
{
    DECLARE_SC(sc, TEXT("CMMCScopeNode::get_Property"));

    // parameter check
    sc = ScCheckPointers(bstrPropertyName, pbstrPropertyValue);
    if (sc)
        return sc.ToHr();

    // init out parameter
    *pbstrPropertyValue = NULL;

    IDataObjectPtr spDataObject;
    sc = ScGetDataObject(&spDataObject);
    if(sc)
        return sc.ToHr();

    // get the MT node
    CMTNode *pMTNode = GetMTNode();
    sc = ScCheckPointers( pMTNode, E_UNEXPECTED );
    if(sc)
        return sc.ToHr();

    // try to get the property from the INodeProperties interface
    sc = pMTNode->ScGetPropertyFromINodeProperties(spDataObject, bstrPropertyName, pbstrPropertyValue);
    if( (!sc.IsError()) && (sc != S_FALSE)   ) // got it, exit
        return sc.ToHr();

    // didn't find it, continue
    sc.Clear();

    // get the property from data object
    sc = CNodeCallback::ScGetProperty(spDataObject, bstrPropertyName,  pbstrPropertyValue);
    if(sc)
        return sc.ToHr();

    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CMMCScopeNode::get_Bookmark
 *
 * PURPOSE: Returns the bookmark of the node (XML format).
 *
 * PARAMETERS:
 *    PBSTR pbstrBookmark :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CMMCScopeNode::get_Bookmark( PBSTR pbstrBookmark )
{
    DECLARE_SC(sc, TEXT("CMMCScopeNode::get_Bookmark"));

    // parameter checking
    sc = ScCheckPointers( pbstrBookmark );
    if(sc)
        return sc.ToHr();

    // cleanup result
    *pbstrBookmark = NULL;

    // get the MT node
    CMTNode *pMTNode = GetMTNode();
    sc = ScCheckPointers( pMTNode, E_FAIL );
    if(sc)
        return sc.ToHr();

    // get the pointer to bookmark
    CBookmark* pBookmark = pMTNode->GetBookmark();
    sc = ScCheckPointers( pBookmark, E_UNEXPECTED );
    if(sc)
        return sc.ToHr();

    std::wstring xml_contents;
    sc = pBookmark->ScSaveToString(&xml_contents);
    if(sc)
        return sc.ToHr();

    // store the result
    CComBSTR bstrBuff(xml_contents.c_str());
    *pbstrBookmark = bstrBuff.Detach();

    sc = ScCheckPointers( *pbstrBookmark, E_OUTOFMEMORY );
    if(sc)
        return sc.ToHr();

    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CMMCScopeNode::IsScopeNode
 *
 * PURPOSE: Returns TRUE indicating that the node is a scope node.
 *
 * PARAMETERS:
 *    PBOOL  pbIsScopeNode :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CMMCScopeNode::IsScopeNode(PBOOL pbIsScopeNode)
{
    DECLARE_SC(sc, TEXT("CMMCScopeNode::IsScopeNode"));

    // check parameters
    if(!pbIsScopeNode)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    *pbIsScopeNode = TRUE;

    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CMMCScopeNode::get_Nodetype
 *
 * PURPOSE: Returns the nodetype of a scope node.
 *
 * PARAMETERS:
 *    PBSTR  Nodetype :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CMMCScopeNode::get_Nodetype(PBSTR Nodetype)
{
    DECLARE_SC(sc, TEXT("CMMCScopeNode::get_Nodetype"));

    // parameter check
    sc = ScCheckPointers(Nodetype);
    if (sc)
        return sc.ToHr();

    // init out parameter
    *Nodetype = NULL;

    // get the data object
    IDataObjectPtr spDataObject;
    sc = ScGetDataObject(&spDataObject);
    if(sc)
        return sc.ToHr();

    // get the nodetype from the data object
    sc = CNodeCallback::ScGetNodetype(spDataObject, Nodetype);
    if(sc)
        return sc.ToHr();

    return sc.ToHr();
}


///////////////////////////////////////////////////////////////////////////////
//
// Forward declaration of local function
//
static SC
ScCreateMTNodeTree(PNEWTREENODE pNew, CMTNode* pmtnParent,
                   CMTNode** ppNodeCreated);
HRESULT AmcNodeWizard(MID_LIST NewNodeType, CMTNode* pNode, HWND hWnd);


//////////////////////////////////////////////////////////////////////////////
//
// Public variables
//
const wchar_t* AMCSnapInCacheStreamName = L"cash";
const wchar_t* AMCTaskpadListStreamName = L"TaskpadList";


///////////////////////////////////////////////////////////////////////////////
//
// Implementation of CScopeTree class
//

DEBUG_DECLARE_INSTANCE_COUNTER(CScopeTree);

bool                    CScopeTree::m_fRequireSyncExpand = false;
CScopeTree*             CScopeTree::m_pScopeTree         = NULL;
IStringTablePrivatePtr  CScopeTree::m_spStringTable;

CScopeTree::CScopeTree()
    :   m_pMTNodeRoot(NULL),
        m_pImageCache(NULL),
        m_pConsoleData(NULL),
        m_pConsoleTaskpads(NULL),
        m_pDefaultTaskpads(NULL)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CScopeTree);
    ASSERT (m_pScopeTree == NULL);
    m_pScopeTree = this;
}

CScopeTree::~CScopeTree()
{
    /*
     * Clear out the string table interface (before Cleanup!) to keep
     * CMTNode dtors from removing their names from the string table.
     */
    m_spStringTable = NULL;

    Cleanup();

    ASSERT (m_pScopeTree == this);
    if (m_pScopeTree == this)
        m_pScopeTree = NULL;

    DEBUG_DECREMENT_INSTANCE_COUNTER(CScopeTree);
}


HRESULT CScopeTree::SetConsoleData(LPARAM lConsoleData)
{
    m_pConsoleData = reinterpret_cast<SConsoleData*>(lConsoleData);
    return (S_OK);
}

extern const CLSID CLSID_FolderSnapin;


/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::GetRoot
 *
 * PURPOSE: Creates the root node if necessary, and returns it. The root node
 *          is created using the built-in folder snap-in.
 *
 * PARAMETERS:
 *    voi d :
 *
 * RETURNS:
 *    CMTNode*. If unable to create the root node, the application will exit.
 *
 *+-------------------------------------------------------------------------*/
CMTNode*
CScopeTree::GetRoot(void)
{
    DECLARE_SC(sc, TEXT("CScopeTree::GetRoot"));

    if (m_pMTNodeRoot == NULL)
    {
        CSnapInPtr          spSI;
        IComponentDataPtr   spIComponentData;
        CComponentData*     pCCD                = NULL;
        CStr                rootName;

        // create a new CMTSnapInNode.
        // TODO: move this down below the CoCreateInstance and QI for
        // ISnapinProperties; if supported, create and pass CSnapinProperties
        // to CMTSnapInNode ctor.
        CMTSnapInNode *pMTSINodeRoot = new CMTSnapInNode(NULL);
        if(NULL == pMTSINodeRoot)
        {
            sc = E_OUTOFMEMORY;
            goto Error;
        }

        // Create an instance of the snapin
        sc = theApp.GetSnapInsCache()->ScGetSnapIn(CLSID_FolderSnapin, &spSI);
        if(sc)
            goto Error;

        sc = CoCreateInstance(CLSID_FolderSnapin, NULL, CLSCTX_INPROC_SERVER, IID_IComponentData, (void **)&spIComponentData);
        if(sc)
            goto Error;

        if(spIComponentData == NULL)
        {
            sc = E_OUTOFMEMORY;
            goto Error;
        }

        pMTSINodeRoot->SetPrimarySnapIn(spSI);

        pCCD = pMTSINodeRoot->GetPrimaryComponentData();
        if(!pCCD)
        {
            sc = E_UNEXPECTED;
            goto Error;
        }

        pCCD->SetIComponentData(spIComponentData);

        USES_CONVERSION;
        rootName.LoadString(GetStringModule(), IDS_ROOTFOLDER_NAME);

        //The code that follows makes use of knowledge of the Folder snapin internals.
        //There seems to be no easier way of doing this.
        // Need to prevent MMC from putting up the "Save File?" dialog every time.

        pMTSINodeRoot->OnRename(true, (LPOLESTR)T2COLE(rootName)); // clever, huh? This just renames the node to Console Root!
        pMTSINodeRoot->SetDisplayName(rootName); // this sets the dirty flag
        pMTSINodeRoot->SetDirty(false);         // this clears it.

        // need to tell the snapin to reset its dirty flag - there seems to be no way to avoid this dynamic cast.
        CFolderSnapinData *pFolderSnapinpData = dynamic_cast<CFolderSnapinData *>(pCCD->GetIComponentData());
        if(!pFolderSnapinpData)
        {
            sc = E_UNEXPECTED;
            goto Error;
        }

        pMTSINodeRoot->SetPreloadRequired(true); // this is also part of the dirty flag check.
        pFolderSnapinpData->SetDirty(false); // clear the dirty flag on the snapin.
        theApp.GetSnapInsCache()->SetDirty(false); // need to clear the dirty bit on the snapin cache too.


        m_pMTNodeRoot = pMTSINodeRoot;
    }

Cleanup:
    return m_pMTNodeRoot;
Error:
    MMCErrorBox(sc);
    exit(1);            // Fatal error - cannot continue.
    goto Cleanup;
}


STDMETHODIMP CScopeTree::Initialize(HWND hwndFrame, IStringTablePrivate* pStringTable)
{
    MMC_TRY
    CSnapInsCache* pSnapInsCache = NULL;

    /*
     * assume invalid argument
     */
    SC sc = E_INVALIDARG;

    if (hwndFrame == 0)
        goto Error;

    /*
     * assume out of memory from here on
     */
    sc = E_OUTOFMEMORY;

    pSnapInsCache = new CSnapInsCache;
    if (pSnapInsCache == NULL)
        goto Error;

    theApp.SetSnapInsCache(pSnapInsCache);

    m_pImageCache = new CSPImageCache();
    if (m_pImageCache == NULL)
        goto Error;

    ASSERT (pStringTable    != NULL);
    ASSERT (m_spStringTable == NULL);
    m_spStringTable = pStringTable;

    // create the ctp list and default ctp list.
    ASSERT (m_pConsoleTaskpads == NULL);
    m_pConsoleTaskpads = new CConsoleTaskpadList;
    if (m_pConsoleTaskpads == NULL)
        goto Error;

    ASSERT (m_pDefaultTaskpads == NULL);
    m_pDefaultTaskpads = new CDefaultTaskpadList;
    if (m_pDefaultTaskpads == NULL)
        goto Error;

    /*
     * success!
     */
    return (S_OK);

Error:
    /*
     * clean up everything that might have been allocated
     */
    theApp.SetSnapInsCache (NULL);
    m_spStringTable = NULL;

    delete m_pDefaultTaskpads;  m_pDefaultTaskpads = NULL;
    delete m_pConsoleTaskpads;  m_pConsoleTaskpads = NULL;
    SAFE_RELEASE (m_pImageCache);
    delete pSnapInsCache;

    TraceError (_T("CScopeTree::Initialize"), sc);
    return (sc.ToHr());

    MMC_CATCH
}

STDMETHODIMP CScopeTree::QueryIterator(IScopeTreeIter** ppIter)
{
    MMC_TRY

    if (ppIter == NULL)
        return E_POINTER;

    CComObject<CScopeTreeIterator>* pObject;
    CComObject<CScopeTreeIterator>::CreateInstance(&pObject);

    return  pObject->QueryInterface(IID_IScopeTreeIter,
                    reinterpret_cast<void**>(ppIter));

    MMC_CATCH
}

STDMETHODIMP CScopeTree::QueryNodeCallback(INodeCallback** ppNodeCallback)
{
    MMC_TRY

    if (ppNodeCallback == NULL)
        return E_POINTER;

    CComObject<CNodeCallback>* pObject;
    CComObject<CNodeCallback>::CreateInstance(&pObject);

    HRESULT hr = pObject->QueryInterface(IID_INodeCallback,
                    reinterpret_cast<void**>(ppNodeCallback));

    if (*ppNodeCallback != NULL)
        (*ppNodeCallback)->Initialize(this);

    return hr;

    MMC_CATCH
}

STDMETHODIMP CScopeTree::CreateNode(HMTNODE hMTNode, LONG_PTR lViewData,
                                    BOOL fRootNode, HNODE* phNode)
{
    MMC_TRY

    if (hMTNode == NULL)
        return E_INVALIDARG;

    if (phNode == NULL)
        return E_POINTER;

    CViewData* pViewData = reinterpret_cast<CViewData*>(lViewData);
    ASSERT(IsBadReadPtr(pViewData, sizeof(*pViewData)) == 0);

    CMTNode* pMTNode = CMTNode::FromHandle(hMTNode);
    CNode* pNode = NULL;

    if (pMTNode != NULL)
    {
        pNode = pMTNode->GetNode(pViewData, fRootNode);
        *phNode = CNode::ToHandle(pNode);
        return S_OK;
    }

    return E_FAIL;

    MMC_CATCH
}

HRESULT CScopeTree::CloseView(int viewID)
{
    MMC_TRY

    if (m_pMTNodeRoot == NULL)
        return S_OK;

    HRESULT hr = m_pMTNodeRoot->CloseView(viewID);
    ASSERT(hr == S_OK);

    // Garbage collect view related column persistence data.
    CColumnPersistInfo* pColPersInfo = NULL;

    if ( (NULL != m_pConsoleData) && (NULL != m_pConsoleData->m_spPersistStreamColumnData) )
    {
        pColPersInfo = dynamic_cast<CColumnPersistInfo*>(
                         static_cast<IPersistStream*>(m_pConsoleData->m_spPersistStreamColumnData));

        if (pColPersInfo)
            pColPersInfo->DeleteColumnDataOfView(viewID);
    }

    // Ask the CViewSettingsPersistor to cleanup data for this view.
    hr = CNode::ScDeleteViewSettings(viewID).ToHr();

    return hr == S_OK ? S_OK : E_FAIL;

    MMC_CATCH
}


HRESULT CScopeTree::DeleteView(int viewID)
{
    MMC_TRY

    if (m_pMTNodeRoot == NULL)
        return S_OK;

    HRESULT hr = m_pMTNodeRoot->DeleteView(viewID);
    ASSERT(hr == S_OK);
    return hr == S_OK ? S_OK : E_FAIL;

    MMC_CATCH
}

STDMETHODIMP CScopeTree::DestroyNode(HNODE hNode)
{
    // convert to real type
    CNode* pNode = CNode::FromHandle(hNode);
    delete pNode;
    return S_OK;
}

HRESULT CScopeTree::HandsOffStorage()
{
    // obsolete method.
    // this method is left here since we use IPersistStorage to export
    // persistence to CONUI side and we need to implement it.
    // But this interface will never be called to save data
    // [we will use CPersistor-based XML saving instead]
    // so the method will always fail.
    ASSERT(FALSE && "Should never come here");
    return E_NOTIMPL;
}

static const wchar_t*    AMCSignatureStreamName = L"signature";
static const long double dOldVersion10          = 0.00000015;   // MMC version 1.0
static const long double dOldVersion11          = 1.1;          // MMC version 1.1
static const BYTE        byStreamVersionMagic   = 0xFF;

HRESULT CScopeTree::InitNew(IStorage *pStg)
{
    MMC_TRY

    ASSERT(m_spPersistData == NULL);
    ASSERT(pStg != NULL);
    if (pStg == NULL)
        return E_INVALIDARG;

    // Create the perist data interface and attach it to the storage
    CComObject<PersistData>* pPersistData;
    HRESULT hr = CComObject<PersistData>::CreateInstance(&pPersistData);
    m_spPersistData = pPersistData;
    ASSERT(SUCCEEDED(hr) && m_spPersistData != NULL);
    if (FAILED(hr))
        return hr;
    hr = m_spPersistData->Create(pStg);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;

    CMTNode* const pRoot = GetRoot();
    ASSERT(pRoot != NULL);
    if (pRoot == NULL)
        return E_POINTER;

    hr = pRoot->InitNew(m_spPersistData);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;

    return S_OK;

    MMC_CATCH
}

HRESULT CScopeTree::IsDirty()
{
    MMC_TRY

    /*
     * check for dirty taskpads
     */
    CConsoleTaskpadList::iterator itDirty =
            std::find_if (m_pConsoleTaskpads->begin(),
                          m_pConsoleTaskpads->end(),
                          const_mem_fun_ref (&CConsoleTaskpad::IsDirty));

    if (itDirty != m_pConsoleTaskpads->end())
    {
        TraceDirtyFlag(TEXT("CScopeTree"), true);
        return (S_OK);
    }

    /*
     * check for dirty nodes
     */
    HRESULT hr;
    if (m_pMTNodeRoot != NULL)
    {
        hr = m_pMTNodeRoot->IsDirty();
        ASSERT(SUCCEEDED(hr));
        if (hr != S_FALSE)
        {
            TraceDirtyFlag(TEXT("CScopeTree"), true);
            return hr;
        }
    }

    /*
     * check for dirty snap-in cache
     */
    SC sc = theApp.GetSnapInsCache()->ScIsDirty();
    ASSERT(!sc.IsError());
    if(sc)
        return sc.ToHr();

    TraceDirtyFlag(TEXT("CScopeTree"), (sc==SC(S_OK)) ? true : false);
    return sc.ToHr();

    MMC_CATCH
}

HRESULT CScopeTree::GetFileVersion (IStorage* pstgRoot, int* pnVersion)
{
    MMC_TRY

    ASSERT(pstgRoot != NULL);
    if (pstgRoot == NULL)
        return MMC_E_INVALID_FILE;

    // Open the stream containing the signature
    IStreamPtr spStream;
    HRESULT hr = OpenDebugStream(pstgRoot, AMCSignatureStreamName,
                          STGM_SHARE_EXCLUSIVE | STGM_READ, L"\\signature", &spStream);
    ASSERT(SUCCEEDED(hr) && spStream != NULL);
    if (FAILED(hr))
        return MMC_E_INVALID_FILE;

    /*
     * read the signature (stream extraction operators will throw
     * _com_error's, so we need an exception block here)
     */
    try
    {
        /*
         * MMC v1.2 and later write a marker as the first
         * byte of the signature stream.
         */
        BYTE byMagic;
        *spStream >> byMagic;

        /*
         * if this file was written by v1.2 or later,
         * read the console file version (int)
         */
        if (byMagic == byStreamVersionMagic)
        {
            *spStream >> *pnVersion;
            ASSERT (*pnVersion >= FileVer_0120);
        }

        /*
         * Otherwise, the file was written by v1.0 or v1.1.
         * Back up to re-read the marker byte, and read the old-style
         * file version (long double), then map it to a new-style version
         */
        else
        {
            LARGE_INTEGER pos = {0, 0};
            spStream->Seek (pos, STREAM_SEEK_SET, NULL);

            long double dVersion;
            *spStream >> dVersion;

            // v1.1?
            if (dVersion == dOldVersion11)
                *pnVersion = FileVer_0110;

            // v1.0?
            else if (dVersion == dOldVersion10)
            {
                /*
                 * If we got a v1.0 signature, we still may have a v1.1 file.
                 * There was a period of time where MMC v1.1 wrote a v1.0
                 * signature, but the file format had in fact changed.  We
                 * can determine this by checking the \FrameData stream in
                 * the file.  If the first DWORD in the \FrameData stream is
                 * sizeof(WINDOWPLACEMENT), we have a true v1.0 file, otherwise
                 * it's a funky v1.1 file.
                 */
                IStreamPtr spFrameDataStm;

                hr = OpenDebugStream (pstgRoot, L"FrameData",
                                           STGM_SHARE_EXCLUSIVE | STGM_READ,
                                           &spFrameDataStm);

                if (FAILED(hr))
                    return MMC_E_INVALID_FILE;

                DWORD dw;
                *spFrameDataStm >> dw;

                if (dw == sizeof (WINDOWPLACEMENT))
                    *pnVersion = FileVer_0100;
                else
                    *pnVersion = FileVer_0110;
            }

            // unexpected version
            else
            {
                ASSERT (false && "Unexpected old-style signature");
                hr = MMC_E_INVALID_FILE;
            }
        }
    }
    catch (_com_error& err)
    {
        hr = err.Error();
        ASSERT (false && "Caught _com_error");
        return (hr);
    }

    return (hr);

    MMC_CATCH
}


STDMETHODIMP
CScopeTree::GetIDPath(
    MTNODEID id,
    MTNODEID** ppIDs,
    long* pLength)
{
    ASSERT(ppIDs);
    ASSERT(pLength);
    if (!ppIDs || !pLength)
        return E_POINTER;

    CMTNode* pMTNode = NULL;
    HRESULT hr = Find(id, &pMTNode);

    ASSERT(pMTNode);
    if (!pMTNode)
        return E_POINTER;

    ASSERT(pMTNode->GetID() == id);

    long len = 0;
    for (CMTNode* pMTNodeTemp = pMTNode;
         pMTNodeTemp;
         pMTNodeTemp = pMTNodeTemp->Parent())
    {
        ++len;
    }

    if (!len)
    {
        *pLength = 0;
        *ppIDs = 0;
        return E_FAIL;
    }

    MTNODEID* pIDs = (MTNODEID*) CoTaskMemAlloc (len * sizeof (MTNODEID));

    if (pIDs == NULL)
    {
        *pLength = 0;
        *ppIDs = 0;
        return E_OUTOFMEMORY;
    }

    *pLength = len;
    *ppIDs = pIDs;

    for (pMTNodeTemp = pMTNode;
         pMTNodeTemp;
         pMTNodeTemp = pMTNodeTemp->Parent())
    {
        ASSERT(len != NULL);
        pIDs[--len] = pMTNodeTemp->GetID();
    }

    return S_OK;
}


/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::GetNodeIDFromStream
 *
 * PURPOSE: Reads in a bookmark from the stream, and returns the NodeID of
 *          the node it represents.
 *
 * PARAMETERS:
 *    IStream * pStm :
 *    MTNODEID* pID :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CScopeTree::GetNodeIDFromStream(IStream *pStm, MTNODEID* pID)
{
    DECLARE_SC(sc, TEXT("CScopeTree::GetIDFromPath"));

    // check parameters
    sc = ScCheckPointers(pStm, pID);
    if(sc)
        return sc.ToHr();

    CBookmarkEx bm;
    *pStm >> bm;

    bool bExactMatchFound = false; // out value from GetNodeIDFromBookmark.
    return GetNodeIDFromBookmark(bm, pID, bExactMatchFound);
}

/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::GetNodeIDFromBookmark
 *
 * PURPOSE: Returns the node ID of the MTNode represented by a bookmark.
 *
 * PARAMETERS:
 *    HBOOKMARK  hbm                 : [in] bookmark
 *    MTNODEID*  pID                 : [out] node-id
 *    bool&       bExactMatchFound   : [out] Is the exact match found or not.
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CScopeTree::GetNodeIDFromBookmark(HBOOKMARK hbm, MTNODEID* pID, bool& bExactMatchFound)
{
    DECLARE_SC(sc, TEXT("CScopeTree::GetNodeIDFromBookmark"));

    CBookmark *pbm = CBookmark::GetBookmark(hbm);
    bExactMatchFound = false;

    sc = ScCheckPointers(pID, pbm);
    if(sc)
        return sc.ToHr();

    CBookmarkEx bm = *pbm;

    ASSERT (bm.IsValid());

    CMTNode *pMTNode = NULL;

    sc  =  bm.ScGetMTNode(false /*bExactMatchRequired*/, &pMTNode, bExactMatchFound);
    if(sc)
        return sc.ToHr();

    if(!pMTNode)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    *pID = pMTNode->GetID();

    return sc.ToHr();
}


/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::GetNodeFromBookmark
 *
 * PURPOSE: Returns a Node object corresponding to the scope node whose
 *          Bookmark is passed in.
 *
 * PARAMETERS:
 *    HBOOKMARK     hbm              : [in] the given bookmark
 *    CConsoleView *pConsoleView     : [in]
 *    PPNODE        ppNode           : [out] the node corresponding to the bookmark.
 *    bool          bExactMatchFound : [out] did we find exactly matching node?
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CScopeTree::GetNodeFromBookmark(HBOOKMARK hbm, CConsoleView *pConsoleView, PPNODE ppNode, bool& bExactMatchFound)
{
    DECLARE_SC(sc, TEXT("CScopeTree::GetNodeFromBookmark"));

    sc = ScCheckPointers(pConsoleView, ppNode);
    if(sc)
        return sc.ToHr();

    // Get the node id
    MTNODEID id = 0;
    bExactMatchFound = false; // out value from GetNodeIDFromBookmark.
    sc = GetNodeIDFromBookmark(hbm, &id, bExactMatchFound);
    if(sc)
        return sc.ToHr();

    // find the node
    CMTNode *pMTNode = NULL;
    sc = Find(id, &pMTNode);
    if(sc)
        return sc.ToHr();

    // make sure that the node is available
    sc = pConsoleView->ScExpandNode(id, true /*bExpand*/, false /*bExpandVisually*/);
    if(sc)
        return sc.ToHr();

    // Create a Node object

    sc = ScGetNode(pMTNode, ppNode);

    return sc.ToHr();
}


HRESULT CScopeTree::GetPathString(HMTNODE hmtnRoot, HMTNODE hmtnLeaf, LPOLESTR* ppszPath)
{
    ASSERT(hmtnLeaf != NULL && ppszPath != NULL);

    CMTNode* pmtnLeaf = CMTNode::FromHandle(hmtnLeaf);
    CMTNode* pmtnRoot = (hmtnRoot == NULL) ? m_pMTNodeRoot : CMTNode::FromHandle(hmtnRoot);

    CStr strPath;
    _GetPathString(pmtnRoot, pmtnLeaf, strPath);


    if (!strPath.IsEmpty())
    {
        *ppszPath = reinterpret_cast<LPOLESTR>(CoTaskMemAlloc((strPath.GetLength()+1) * sizeof(OLECHAR)));
        if (*ppszPath == NULL)
            return E_OUTOFMEMORY;

        USES_CONVERSION;
        wcscpy(*ppszPath, T2COLE(strPath));

        return S_OK;
    }

    return E_FAIL;
}


void CScopeTree::_GetPathString(CMTNode* pmtnRoot, CMTNode* pmtnCur, CStr& strPath)
{
    ASSERT(pmtnRoot != NULL && pmtnCur != NULL);

    // if haven't reached the root node yet, recursively get path from
    // root to current node's parent
    if (pmtnCur != pmtnRoot)
    {
        _GetPathString(pmtnRoot, pmtnCur->Parent(), strPath);
        strPath += _T('\\');
    }

    // now append the name for the current node
    strPath += pmtnCur->GetDisplayName().data();
}


/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::ScAddSnapin
 *
 * PURPOSE: Adds the specified snapin to the console file beneath console root.
 *
 * TODO:    1) Allow the caller to specify the parent snapin.
 *          2) Right now specifying snapins by name does not work. Add this.
 *
 * PARAMETERS:
 *    LPCTSTR  szSnapinNameOrCLSID : The name or GUID of the snapin.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CScopeTree::ScAddSnapin (
    LPCWSTR     szSnapinNameOrCLSID,    /* I:name or CLSID of the snapin    */
    SnapIn*     pParentSnapinNode,      /* I:Parent snapin under which this snapin is added (optional)*/
    Properties* pProperties,            /* I:props to init with (optional)  */
    SnapIn*&    rpSnapIn)               /* O:the snap-in that was created   */
{
    DECLARE_SC(sc, TEXT("CScopeTree::ScAddSnapin"));
    CSnapinManager snapinMgr(GetRoot());

    Trace(tagScopeTreeAddSnapin, TEXT("CScopeTree::ScAddSnapin"));

    // adding the snapin below this node.
    sc = snapinMgr.ScAddSnapin(szSnapinNameOrCLSID, pParentSnapinNode, pProperties);
    if(sc)
        return sc;

    // get the "list" of one node to add
    NewNodeList* pNewNodes = snapinMgr.GetNewNodes();
    if (pNewNodes == NULL)
        return (sc = E_UNEXPECTED);

    // the list should have an item in it
    CNewTreeNode* pNewNode = pNewNodes->GetHead();
    if (pNewNode == NULL)
        return (sc = E_UNEXPECTED);

    // Update the scope tree with changes made by snapin manager.
    sc = ScAddOrRemoveSnapIns(snapinMgr.GetDeletedNodesList(),
                              pNewNodes);
    if(sc)
        return sc;

    // if ScAddOrRemoveSnapIns succeeded, it better have created a CMTSnapInNode for us
    CMTSnapInNode* pNewSnapInNode = pNewNode->m_pmtNewSnapInNode;
    if (pNewSnapInNode == NULL)
        return (sc = E_UNEXPECTED);

    // get the SnapIn interface for the client
    sc = pNewSnapInNode->ScGetSnapIn (&rpSnapIn);
    if (sc)
        return (sc);

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::QuerySnapIns
 *
 * PURPOSE: Creates, AddRefs, and returns a SnapIns object.
 *
 * PARAMETERS:
 *    SnapIns ** ppSnapIns :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CScopeTree::QuerySnapIns(SnapIns **ppSnapIns)
{
    DECLARE_SC(sc, TEXT("CScopeTree::QuerySnapIns"));

    // parameter check
    sc = ScCheckPointers(ppSnapIns);
    if (sc)
        return sc.ToHr();

    // init out parameter
    *ppSnapIns = NULL;

    // create a CSnapIns object if needed.
    sc = CTiedComObjectCreator<CSnapIns>::ScCreateAndConnect(*this, m_spSnapIns);
    if(sc)
        return sc.ToHr();

    if(m_spSnapIns == NULL)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    // addref the pointer for the client.
    m_spSnapIns->AddRef();
    *ppSnapIns = m_spSnapIns;

    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::QueryScopeNamespace
 *
 * PURPOSE: Creates, AddRefs, and returns a ScopeNamespace object.
 *
 * PARAMETERS:
 *    ScopeNamespace ** ppScopeNamespace :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CScopeTree::QueryScopeNamespace(ScopeNamespace **ppScopeNamespace)
{
    DECLARE_SC(sc, TEXT("CScopeTree::QueryScopeNamespace"));

    // parameter check
    sc = ScCheckPointers(ppScopeNamespace);
    if (sc)
        return sc.ToHr();

    // init out parameter
    *ppScopeNamespace = NULL;

    // create a CScopeNamespace object if needed.
    sc = CTiedComObjectCreator<CScopeNamespace>::ScCreateAndConnect(*this, m_spScopeNamespace);
    if(sc)
        return sc.ToHr();

    if(m_spScopeNamespace == NULL)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    // addref the pointer for the client.
    m_spScopeNamespace->AddRef();
    *ppScopeNamespace = m_spScopeNamespace;

    return sc.ToHr();
}


/*+-------------------------------------------------------------------------*
 * CScopeTree::CreateProperties
 *
 * Creates a new, empty Properties object.  This function does the work
 * behind _Document::CreateProperties.
 *--------------------------------------------------------------------------*/

HRESULT CScopeTree::CreateProperties (Properties** ppProperties)
{
    DECLARE_SC (sc, _T("CScopeTree::CreateProperties"));

    /*
     * validate parameters
     */
    sc = ScCheckPointers (ppProperties);
    if (sc)
        return (sc.ToHr());

    /*
     * create a new properties collection
     */
    CComObject<CSnapinProperties> *pProperties = NULL;
    sc = CComObject<CSnapinProperties>::CreateInstance (&pProperties);
    if (sc)
        return (sc.ToHr());

    if (pProperties == NULL)
        return ((sc = E_UNEXPECTED).ToHr());

    /*
     * put a ref on for the client
     */
    (*ppProperties) = pProperties;
    (*ppProperties)->AddRef();

    return (sc.ToHr());
}


//+-------------------------------------------------------------------
//
//  Member:      CScopeTree::QueryRootNode
//
//  Synopsis:    Returns COM object to the Root Node.
//
//  Arguments:   [ppRootNode] - Ptr in which root node will be returned.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
HRESULT CScopeTree::QueryRootNode (PPNODE ppRootNode)
{
    DECLARE_SC(sc, _T("CScopeTree::QueryRootNode"));

    sc = ScGetRootNode(ppRootNode);

    return (sc.ToHr());
}


HRESULT CScopeTree::Load(IStorage *pStg)
{
    MMC_TRY

    ASSERT(m_spPersistData == NULL);
    if (m_spPersistData != NULL)
        return E_UNEXPECTED;

    ASSERT(pStg != NULL);
    if (pStg == NULL)
        return E_INVALIDARG;

    // Create the perist data interface and attach it to the storage
    CComObject<PersistData>* pPersistData;
    HRESULT hr = CComObject<PersistData>::CreateInstance(&pPersistData);
    m_spPersistData = pPersistData;
    ASSERT(SUCCEEDED(hr) && m_spPersistData != NULL);
    if (FAILED(hr))
        return hr;
    hr = m_spPersistData->Open(pStg);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;

    // Open the stream for the cache
    IStreamPtr spStream;
    hr = OpenDebugStream(pStg, AMCSnapInCacheStreamName,
                     STGM_SHARE_EXCLUSIVE | STGM_READWRITE, L"SnapInCache", &spStream);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;

    SC sc = theApp.GetSnapInsCache()->ScLoad(spStream);
    ASSERT(!sc.IsError());
    if (sc)
        return sc.ToHr();

    ASSERT(m_pMTNodeRoot == NULL);
    sc = CMTNode::ScLoad (m_spPersistData, &m_pMTNodeRoot);
    ASSERT(!sc.IsError() && m_pMTNodeRoot != NULL);
    if (sc)
        return sc.ToHr();

    hr = LoadTaskpadList(pStg);
    return hr;

    MMC_CATCH
}

/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::Persist
 *
 * PURPOSE: Persists the CScopeTree to the specified persistor.
 *
 * PARAMETERS:
 *    HPERSISTOR pPersistor:
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT CScopeTree::Persist(HPERSISTOR hPersistor)
{
    DECLARE_SC(sc, TEXT("CScopeTree::Persist"));

    try
    {
        sc = ScCheckPointers((void *)hPersistor,theApp.GetSnapInsCache());
        if (sc)
            sc.Throw();

        CPersistor &persistor = *reinterpret_cast<CPersistor *>(hPersistor);
        CPersistor persistorScopeTree(persistor, XML_TAG_SCOPE_TREE);

        // persist the snapin cache.
        persistorScopeTree.Persist(*theApp.GetSnapInsCache());

        // persist the MTNode hierarchy.
        CPersistor persistorMTNodes(persistorScopeTree, XML_TAG_SCOPE_TREE_NODES);
        if (persistor.IsStoring())
        {
            if(!m_pMTNodeRoot)
                sc.Throw(E_POINTER);

            persistorMTNodes.Persist(*m_pMTNodeRoot);
        }
        else
        {
            // here we imitate how the collection fixes on the element
            // despite we only have one, CMTNode::PersistNewNode thinks else
            CPersistor persistor1Node(persistorMTNodes, XML_TAG_MT_NODE);
            CPersistor persistor1NodeLocked(persistor1Node,persistor1Node.GetCurrentElement(),true);
            CMTNode::PersistNewNode(persistor1NodeLocked, &m_pMTNodeRoot);
            sc = ScCheckPointers(m_pMTNodeRoot,E_FAIL);
            if (sc)
                sc.Throw();
        }

        // persist all taskpads
        if(m_pConsoleTaskpads)
        {
            persistor.Persist(*m_pConsoleTaskpads);
        }
    }
    catch (SC e_sc)
    {
        sc = e_sc;
    }
    catch (_com_error e_com)
    {
        sc = e_com.Error();
    }
    catch (HRESULT e_hr)
    {
        sc = e_hr;
    }

    return sc.ToHr();
}

HRESULT CScopeTree::Save(IStorage *pStg, BOOL fSameAsLoad)
{
    // obsolete method.
    // this method is left here since we use IPersistStorage to export
    // persistence to CONUI side and we need to implement it.
    // But this interface will never be called to save data
    // [we will use CPersistor-based XML saving instead]
    // so the method will always fail.
    ASSERT(FALSE && "Should never come here");
    return E_NOTIMPL;
}


HRESULT CScopeTree::LoadTaskpadList(IStorage *pStg)
{
    HRESULT hr = S_OK;

    m_pConsoleTaskpads->clear();
    m_pDefaultTaskpads->clear();

    // Open the stream for the cache
    IStreamPtr spStream;
    hr = OpenDebugStream(pStg, AMCTaskpadListStreamName,
                     STGM_SHARE_EXCLUSIVE | STGM_READWRITE, L"TaskpadList", &spStream);
    if (FAILED(hr))
        return S_OK; // might be pre-MMC1.2, so if we don't find the stream just exit normally.

    hr = m_pConsoleTaskpads->Read(*(spStream.GetInterfacePtr()));
    if(FAILED(hr))
        return hr;

    // Read the list of default taskpads.
    hr = m_pDefaultTaskpads->Read(*(spStream.GetInterfacePtr()));
    if(FAILED(hr))
        return hr;

    return hr;
}

HRESULT CScopeTree::SaveCompleted(IStorage *pStg)
{
    // obsolete method.
    // this method is left here since we use IPersistStorage to export
    // persistence to CONUI side and we need to implement it.
    // But this interface will never be called to save data
    // [we will use CPersistor-based XML saving instead]
    // so the method will always fail.
    ASSERT(FALSE && "Should never come here");
    return E_NOTIMPL;
}


/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::Find
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    MTNODEID  mID :
 *    CMTNode** ppMTNode :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT CScopeTree::Find(MTNODEID mID, CMTNode** ppMTNode)
{
    if (ppMTNode == NULL)
        return E_POINTER;

    *ppMTNode = NULL;

    CMTNode* pMTRootNode = GetRoot();
    if (pMTRootNode == NULL)
        return (E_FAIL);

    *ppMTNode = pMTRootNode->Find(mID);

    return ((*ppMTNode == NULL) ? E_FAIL : S_OK);
}

HRESULT CScopeTree::Find(MTNODEID mID, HMTNODE* phMTNode)
{
    if (phMTNode == NULL)
        return E_POINTER;

    *phMTNode = NULL;

    CMTNode* pMTNode;
    HRESULT hr = Find (mID, &pMTNode);
    if (FAILED (hr))
        return (hr);

    *phMTNode = CMTNode::ToHandle (pMTNode);

    return ((*phMTNode == NULL) ? E_FAIL : S_OK);
}

HRESULT CScopeTree::GetClassID(CLSID *pClassID)
{
    MMC_TRY

    if (pClassID == NULL)
        return E_INVALIDARG;

    *pClassID = CLSID_ScopeTree;
    return S_OK;

    MMC_CATCH
}


#define SDI_RELATIVEID_MASK     (SDI_PARENT | SDI_PREVIOUS | SDI_NEXT)

SC
CScopeTree::ScInsert(LPSCOPEDATAITEM pSDI, COMPONENTID nID,
                           CMTNode** ppMTNodeNew)
{
    DECLARE_SC(sc, TEXT("CScopeTree::ScInsert"));

    // check parameters
    if (m_pMTNodeRoot == NULL)
    {
        sc = E_INVALIDARG;
        return sc;
    }

    try
    {
        *ppMTNodeNew = NULL;
        HMTNODE hMTNodePrev = (HMTNODE) TVI_LAST;

        CMTNode* pMTNodeRelative = CMTNode::FromScopeItem(pSDI->relativeID);
        CMTNode* pMTNodeParent = NULL;

        if (pSDI->mask & SDI_RELATIVEID_MASK)
        {
            if (pMTNodeRelative->GetOwnerID() != nID)
            {
                sc = E_INVALIDARG;
                return sc;
            }

            pMTNodeParent = pMTNodeRelative->Parent();
        }
        else
        {
            pMTNodeParent = pMTNodeRelative;
        }

        if (pMTNodeParent == NULL)
        {
            sc = E_INVALIDARG;
            return sc;
        }

        ASSERT(pMTNodeParent->WasExpandedAtLeastOnce() == TRUE);
        if (pMTNodeParent->WasExpandedAtLeastOnce() == FALSE)
        {
            sc = E_POINTER;
            return sc;
        }

        if (IsBadWritePtr(pMTNodeParent, sizeof(CMTNode*)) != 0)
        {
            sc = E_POINTER;
            return sc;
        }

        CMTSnapInNode* pMTSINode = pMTNodeParent->GetStaticParent();
        CComponentData* pCCD = pMTSINode->GetComponentData(nID);
        ASSERT(pCCD != NULL);


        CMTNode* pMTNode = new CMTNode;
        if (pMTNode == NULL)
            return (sc = E_OUTOFMEMORY);

        pMTNode->SetPrimaryComponentData(pCCD);
        pMTNode->SetOwnerID(nID);
        pMTNode->SetUserParam(pSDI->lParam);

        if (pSDI->mask & SDI_STATE)
            pMTNode->SetState(pSDI->nState);

        if (pSDI->mask & SDI_IMAGE)
            pMTNode->SetImage(pSDI->nImage);

        if (pSDI->mask & SDI_OPENIMAGE)
            pMTNode->SetOpenImage(pSDI->nOpenImage);

        if ((pSDI->mask & SDI_CHILDREN) && (pSDI->cChildren == 0))
            pMTNode->SetNoPrimaryChildren();

        pSDI->ID = reinterpret_cast<HSCOPEITEM>(pMTNode);

        pMTNode->AttachParent(pMTNodeParent);

        if (pMTNodeParent->Child() == NULL)
        {
            pMTNodeParent->AttachChild(pMTNode);
        }
        else if (pSDI->mask & SDI_PREVIOUS)
        {
            pMTNode->AttachNext(pMTNodeRelative->Next());
            pMTNodeRelative->AttachNext(pMTNode);
            hMTNodePrev = CMTNode::ToHandle(pMTNodeRelative);
        }
        else if (pSDI->mask & SDI_NEXT)
        {
            pMTNode->AttachNext(pMTNodeRelative);

            CMTNode* pMTNodePrev = _FindPrev(pMTNodeRelative);
            if (pMTNodePrev != NULL)
            {
                pMTNodePrev->AttachNext(pMTNode);
                hMTNodePrev = CMTNode::ToHandle(pMTNodePrev);
            }
            else
            {
                pMTNodeParent->AttachChild(pMTNode);
                hMTNodePrev = (HMTNODE) TVI_FIRST;
            }
        }
        else if (pSDI->mask & SDI_FIRST)
        {
            pMTNode->AttachNext(pMTNodeParent->Child());
            pMTNodeParent->AttachChild(pMTNode);

            hMTNodePrev = (HMTNODE) TVI_FIRST;
        }
        else
        {
            CMTNode* pMTNodeLastChild = _FindLastChild(pMTNodeParent);
            ASSERT(pMTNodeLastChild != NULL);

            pMTNodeLastChild->AttachNext(pMTNode);

            // hMTNodePrev = (HMTNODE) TVI_LAST;
        }

        *ppMTNodeNew = pMTNode;


        // Now inform the views to add as needed.
        SViewUpdateInfo vui;
        vui.newNode = CMTNode::ToHandle(pMTNode);
        vui.insertAfter = hMTNodePrev;

        pMTNode->Parent()->CreatePathList(vui.path);
        UpdateAllViews(VIEW_UPDATE_ADD, reinterpret_cast<LPARAM>(&vui));

    }
    catch( std::bad_alloc )
    {
        sc = E_OUTOFMEMORY;
        return sc;
    }
    catch (...)
    {
        sc = E_FAIL;
        return sc;
    }

    return sc;
}


CMTNode* CScopeTree::_FindLastChild(CMTNode* pMTNodeParent)
{
    ASSERT(pMTNodeParent != NULL);

    CMTNode* pMTNode = pMTNodeParent->Child();

    if (pMTNode != NULL)
    {
        while (pMTNode->Next())
            pMTNode = pMTNode->Next();
    }

    return pMTNode;
}

CMTNode* CScopeTree::_FindPrev(CMTNode* pMTNodeIn)
{
    ASSERT(pMTNodeIn != NULL);

    CMTNode* pMTNode = pMTNodeIn->Parent()->Child();
    ASSERT(pMTNode != NULL);

    if (pMTNode == pMTNodeIn)
        return NULL;

    while (pMTNode->Next() != pMTNodeIn)
    {
        pMTNode = pMTNode->Next();
        ASSERT(pMTNode != NULL);
    }

    return pMTNode;
}


/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::ScInsert
 *
 * PURPOSE: Inserts a single item into the scope tree.
 *
 * PARAMETERS:
 *    CMTNode* pmtnParent :   Should be non-NULL. The node to insert under.
 *    CMTNode* pmtnToInsert : The node to be inserted.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CScopeTree::ScInsert(CMTNode* pmtnParent, CMTNode* pmtnToInsert)
{
    DECLARE_SC(sc, TEXT("CScopeTree::ScInsert"));

    // check parameters
    sc = ScCheckPointers(pmtnParent, pmtnToInsert);
    if(sc)
        return sc;

    pmtnToInsert->AttachParent(pmtnParent);

    if (pmtnParent->Child() == NULL)
    {
        pmtnParent->AttachChild(pmtnToInsert);
    }

    else
    {
        // attach the node as a sibling of the last child node.
        for (CMTNode * pmtn = pmtnParent->Child();
             pmtn->Next() != NULL;
             pmtn = pmtn->Next())
        {}

        pmtn->AttachNext(pmtnToInsert);
    }

    pmtnToInsert->NotifyAddedToTree ();

    SViewUpdateInfo vui;
    pmtnToInsert->Parent()->CreatePathList(vui.path);
    vui.newNode = CMTNode::ToHandle(pmtnToInsert);
    UpdateAllViews(VIEW_UPDATE_ADD, reinterpret_cast<LPARAM>(&vui));
    vui.path.RemoveAll();

    return sc;

}


typedef CArray<COMPONENTID, COMPONENTID> CComponentIDArray;

//---------------------------------------------------------------------------------------
//  NotifyExtensionsOfNodeDeletion
//
// This method enumerated the children of a node, building a list of all the snap-in
// components that have added children. It then sends a REMOVE_CHILDREN notification to
// each of the components.
//
// The component that owns the node is treated in a special way. It is only notified if
// the node is staic or the bNotifyRoot param is TRUE. This is because we don't want
// to send notifications for nodes that belong to a subtree rooted at a node owned by
// the same component (see InformSnapinsOfDeletion).
//---------------------------------------------------------------------------------------
void NotifyExtensionsOfNodeDeletion(CMTNode* pMTNode, CComponentIDArray& rgID,
                                    BOOL bNotifyRoot = FALSE)
{
    if (pMTNode == NULL)
        return;

    CMTSnapInNode* pMTSINode = pMTNode->GetStaticParent();
    ASSERT(pMTSINode != NULL);
    if (pMTSINode == NULL)
        return;

    COMPONENTID idOwner = pMTNode->GetPrimaryComponentID();

    int nTemp = pMTSINode->GetNumberOfComponentDatas() + 1;
    rgID.SetSize(nTemp);
    for (int i=0; i < nTemp; ++i)
        rgID[i] = -1;

    // Build list of all component ID's that have added children to this node
    // except for component that owns the node.
    BOOL bOwnerChildren = FALSE;
    CMTNode* pMTNodeTemp = pMTNode->Child();
    for (int iMax = -1; pMTNodeTemp != NULL; pMTNodeTemp = pMTNodeTemp->Next())
    {
        COMPONENTID id = pMTNodeTemp->GetPrimaryComponentID();

        // if owner ID just note it, else add ID to list
        if (id == idOwner)
        {
            bOwnerChildren = TRUE;
        }
        else
        {
            // search list for ID
            for (int j=0; j <= iMax; ++j)
            {
                if (rgID[j] == id)
                    break;
            }

            // if not found, add to list
            if (j > iMax)
                rgID[++iMax] = id;
        }
    }

    // Include owner conponent only if it needs to be notified
    if (bOwnerChildren && (bNotifyRoot == TRUE || pMTNode->IsStaticNode()))
        rgID[++iMax] = idOwner;

    if (!pMTNode->IsInitialized())
        return;

    IDataObjectPtr spDataObject;
    HRESULT hr = pMTNode->QueryDataObject(CCT_SCOPE, &spDataObject);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return;

    LPARAM lScopeItem = CMTNode::ToScopeItem(pMTNode);

    pMTNode->SetRemovingChildren(true);
    for (i = 0; i <= iMax; ++i)
    {
        ASSERT(rgID[i] != -1);
        CComponentData* pCD = pMTSINode->GetComponentData(rgID[i]);
        ASSERT(pCD != NULL);

        Dbg(DEB_TRACE, _T("Remove Children - node = %s, ID = %d\n"), pMTNode->GetDisplayName(), rgID[i]);

        hr = pCD->Notify(spDataObject, MMCN_REMOVE_CHILDREN, lScopeItem, 0);
        CHECK_HRESULT(hr);
    }
    pMTNode->SetRemovingChildren(false);
}

//-----------------------------------------------------------------------------------------------
// InformSnapinsOfDeletion
//
// This function traverse the node subtree rooted at pMTNode and sends a REMOVE_CHILDREN to all
// snap-in components that have added children to the tree. A component is sent one notification
// for each node it has extended that belongs to another component. No notification is sent where
// a component has extended one of its own nodes. There are two exceptions to this rule. Owners
// of static nodes are always notified. Also the owner of the top node is notified if bNotifyRoot
// is TRUE.
//
// Another way to look at this is that MMC searches the tree for subtrees of nodes provided by
// a single component. It sends a notification to the component to delete the top node of the
// subtree. The component is responsible for identifying and deleting the rest of its nodes in
// the subtree.
//
// This method just handles the recursion and iteration required to traverse the whole tree. It
// calls NotifyExtensionsOfNodeDeletion to enumerate the children of a node and send notifications
// to the right components.
//
//------------------------------------------------------------------------------------------------
void InformSnapinsOfDeletion(CMTNode* pMTNode, BOOL fNext,
                             CComponentIDArray& rgID, BOOL bNotifyRoot = FALSE)
{
    if (pMTNode == NULL)
        return;

    if (pMTNode->Child() != NULL)
    {
        // Recursively clear nodes's subtree first
        InformSnapinsOfDeletion(pMTNode->Child(), TRUE, rgID, FALSE);

        // Notify extensions of node itself
        NotifyExtensionsOfNodeDeletion(pMTNode, rgID, bNotifyRoot);
    }

    // If requested, handle all siblings of this node
    // (iteratively rather than recursively to avoid deep stack use)
    if (fNext == TRUE)
    {
        CMTNode* pMTNodeNext = pMTNode->Next();

        while (pMTNodeNext != NULL)
        {
            InformSnapinsOfDeletion(pMTNodeNext, FALSE, rgID, FALSE);
            pMTNodeNext = pMTNodeNext->Next();
        }
    }
}

/*+-------------------------------------------------------------------------*
 * CScopeTree::Delete
 *
 * PURPOSE: Deletes a tree rooted at a node. Also sends a notification to
 *          the selected item in each view asking them whether they need to
 *          be reselected once the item is deleted.
 *
 *          Called by CNodeInitObject::DeleteItem
 *
 * PARAMETERS:
 *      CMTNode*      pmtn:         The root of the tree to be deleted
 *      BOOL          fDeleteThis:  Whether the root itself requires deletion as well
 *      COMPONENTID   nID:
 *
 * RETURNS:
 *      void
/*+-------------------------------------------------------------------------*/
SC
CScopeTree::ScDelete(CMTNode* pmtn, BOOL fDeleteThis, COMPONENTID nID)
{
    DECLARE_SC(sc, TEXT("CScopeTree::Delete"));

    // check parameters
    if (pmtn == NULL)
    {
        sc = E_INVALIDARG;
        return sc;
    }

    // Is this call a result of sending MMCN_REMOVE_CHILDREN to a parent node?
    // If so return immediately since MMC does delete all the child nodes.
    if (pmtn->AreChildrenBeingRemoved() == true)
        return sc;

    // if deleting node and children, just do one call to delete the
    // whole subtree.
    if (fDeleteThis)
    {
        // can't delete static root node OR nodes put up by other components!
        if ( ( pmtn->GetOwnerID() == TVOWNED_MAGICWORD) || (pmtn->GetOwnerID() != nID) )
        {
            sc = E_INVALIDARG;
            return sc;
        }

        #ifdef DBG
            CMTNode* pmtnParent = pmtn->Parent();
            CMTNode* pmtnPrev = NULL;
            CMTNode* pmtnNext = pmtn->Next();

            if (pmtnParent->Child() != pmtn)
            {
                pmtnPrev = pmtnParent->Child();

                while (pmtnPrev->Next() != pmtn)
                    pmtnPrev = pmtnPrev->Next();

                ASSERT(pmtnPrev != NULL);
            }
        #endif

        DeleteNode(pmtn);

        #ifdef DBG
            if (pmtnParent != NULL)
            {
                ASSERT(pmtnParent != NULL);

                if (pmtnPrev == NULL)
                {
                    ASSERT(pmtnParent->Child() == pmtnNext);
                }
                else
                {
                    ASSERT(pmtnPrev->Next() == pmtnNext);
                }
            }
        #endif

    }
    // else we have to enum the children and delete only the ones
    // created by the calling snap-in
    else
    {
        CMTNode* pMTNode = pmtn->Child();

        // Enum children and delete those that are owned by the
        // requesting component (i.e., with matching ID)
        while(pMTNode != NULL)
        {
            CMTNode *pMTNodeNext = pMTNode->Next();

            if (!pMTNode->IsStaticNode() &&
                (pMTNode->GetPrimaryComponentID() == nID))
            {
                DeleteNode(pMTNode);
            }

            pMTNode = pMTNodeNext;
        }
    }

    return sc;
}


void CScopeTree::DeleteNode(CMTNode* pmtn)
{
    if (pmtn == NULL)
        return;

    // always update the views
    SViewUpdateInfo vui;
    vui.flag = VUI_DELETE_THIS;
    pmtn->CreatePathList (vui.path);

    // We are changing selection, so snapin may call delete
    // on this node during this process (MMCN_SELECT, MMCN_SHOW...),
    // Do an AddRef and Release to protect ourself from such deletes.
    pmtn->AddRef();
    UpdateAllViews (VIEW_UPDATE_SELFORDELETE, reinterpret_cast<LPARAM>(&vui));
    if (pmtn->Release() == 0)
        return; // The object was already deleted during selection change.
    UpdateAllViews (VIEW_UPDATE_DELETE,       reinterpret_cast<LPARAM>(&vui));

    CComponentIDArray rgID;
    rgID.SetSize(20, 10);
    InformSnapinsOfDeletion(pmtn, FALSE, rgID, (pmtn->IsStaticNode() == FALSE));

    CMTNode* pmtnParent = pmtn->Parent();
    _DeleteNode(pmtn);

    pmtnParent->OnChildrenChanged();

    UpdateAllViews (VIEW_UPDATE_DELETE_EMPTY_VIEW, 0);
}

void CScopeTree::_DeleteNode(CMTNode* pmtn)
{
    //
    //  Delete from the scope tree.
    //

    if (m_pMTNodeRoot == pmtn)
    {
        m_pMTNodeRoot = NULL;
    }

    CMTNode* pmtnParent = pmtn->Parent();
    CMTNode* pmtnSibling = pmtnParent->Child();
    ASSERT(pmtnSibling != NULL);

    if (pmtnSibling == pmtn)
    {
        pmtnParent->AttachChild(pmtn->Next());
    }
    else
    {
        for (; pmtnSibling->Next() != pmtn; pmtnSibling = pmtnSibling->Next());

        pmtnSibling->AttachNext(pmtn->Next());
    }

    pmtn->AttachNext(NULL);
    pmtn->AttachParent(NULL);

    pmtn->Release();
    pmtnParent->SetDirty();
}

void CScopeTree::UpdateAllViews(LONG lHint, LPARAM lParam)
{
    CConsoleFrame* pFrame = GetConsoleFrame();
    ASSERT (pFrame != NULL);

    if (pFrame == NULL)
        return;

    SC sc = pFrame->ScUpdateAllScopes (lHint, lParam);
    if (sc)
        goto Error;

Cleanup:
    return;
Error:
    TraceError (_T("CScopeTree::UpdateAllViews"), sc);
    goto Cleanup;
}

void CScopeTree::DeleteDynamicNodes(CMTNode* pMTNode)
{
    ASSERT(pMTNode != NULL);
    ASSERT(pMTNode->IsStaticNode() == TRUE);

    if (pMTNode == NULL)
        return;

    CMTSnapInNode* pMTSINode = dynamic_cast<CMTSnapInNode*>(pMTNode);
    ASSERT(pMTSINode != NULL);
    if (pMTSINode == NULL)
        return;

    for (CMTNode* pMTNodeTemp = pMTNode->Child(); pMTNodeTemp != NULL;
         pMTNodeTemp = pMTNodeTemp->Next())
    {
        if (pMTNodeTemp->IsDynamicNode())
        {
            CComponentIDArray rgID;
            rgID.SetSize(20, 10);
            InformSnapinsOfDeletion(pMTNodeTemp, FALSE, rgID, FALSE);
        }
    }

    CComponentIDArray rgID;
    NotifyExtensionsOfNodeDeletion(pMTSINode, rgID, FALSE);

    CMTNode* pMTNodeNext = pMTNode->Child();
    while (pMTNodeNext != NULL)
    {
        pMTNodeTemp = pMTNodeNext;
        pMTNodeNext = pMTNodeNext->Next();

        if (pMTNodeTemp->IsStaticNode() == FALSE)
            _DeleteNode(pMTNodeTemp);
    }

}


inline BOOL CScopeTree::ExtensionsHaveChanged(CMTSnapInNode* pMTSINode)
{
    CSnapIn* pSnapIn = pMTSINode->GetPrimarySnapIn();
    ASSERT(pSnapIn != NULL);

    return pSnapIn->HasNameSpaceChanged();
}

void CScopeTree::HandleExtensionChanges(CMTNode* pMTNode)
{
    if (pMTNode == NULL)
        return;

    HandleExtensionChanges(pMTNode->Next());

    if (pMTNode->IsStaticNode() == TRUE)
    {
        HandleExtensionChanges(pMTNode->Child());

        if (ExtensionsHaveChanged(dynamic_cast<CMTSnapInNode*>(pMTNode)) == TRUE)
        {
            SViewUpdateInfo vui;
            vui.flag = VUI_DELETE_SETAS_EXPANDABLE;

            pMTNode->CreatePathList(vui.path);
            UpdateAllViews(VIEW_UPDATE_SELFORDELETE, reinterpret_cast<LPARAM>(&vui));
            UpdateAllViews(VIEW_UPDATE_DELETE, reinterpret_cast<LPARAM>(&vui));
            vui.path.RemoveAll();

            DeleteDynamicNodes(pMTNode);

            m_MTNodesToBeReset.AddHead(pMTNode);

            UpdateAllViews(VIEW_UPDATE_DELETE_EMPTY_VIEW, 0);
        }
    }
}

/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::RunSnapIn
 *
 * PURPOSE: Runs the Snap-In Manager to prompt the user to add and remove snap-ins.
 *
 * PARAMETERS:
 *    HWND  hwndParent :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP CScopeTree::RunSnapIn(HWND hwndParent)
{
    MMC_TRY

    DECLARE_SC(sc, TEXT("CScopeTree::RunSnapIn"));

    CSnapinManager dlg(GetRoot());

    if (dlg.DoModal() == IDOK)
    {
        sc = ScAddOrRemoveSnapIns(dlg.GetDeletedNodesList(), dlg.GetNewNodes());
        if(sc)
            return sc.ToHr();
    }

    return sc.ToHr();

}


/*+-------------------------------------------------------------------------*
 * class CEnableProcessingSnapinCacheChanges
 *
 *
 * PURPOSE: A class that sets/re-sets ProcessingSnapinChanges so that
 *          the ProcessingSnapinChanges is re-set automatically when
 *          this object is destroyed.
 *
 *+-------------------------------------------------------------------------*/
class CEnableProcessingSnapinCacheChanges
{
public:
    CEnableProcessingSnapinCacheChanges()
    {
        theApp.SetProcessingSnapinChanges(TRUE);
    }
    ~CEnableProcessingSnapinCacheChanges()
    {
        theApp.SetProcessingSnapinChanges(FALSE);
    }
};


/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::ScAddOrRemoveSnapIns
 *
 * PURPOSE: Called after a snapin is added/removed (extension is enabled/disabled)
 *          to update scopetree with those changes.
 *
 * PARAMETERS:
 *    MTNodesList * pmtnDeletedList : The list of nodes to remove. Can be NULL.
 *    NewNodeList * pnnList :         The list of nodes to add. Can be NULL.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CScopeTree::ScAddOrRemoveSnapIns(MTNodesList * pmtnDeletedList, NewNodeList * pnnList)
{
    DECLARE_SC(sc, TEXT("CScopeTree::ScAddOrRemoveSnapIns"));

    sc = ScCheckPointers(m_pConsoleData, m_pConsoleData->m_pConsoleDocument, E_UNEXPECTED);
    if (sc)
        return sc;

    CConsoleDocument *pConsoleDoc = m_pConsoleData->m_pConsoleDocument;
    ASSERT(NULL != pConsoleDoc);

    // 1. Prevent access to snapin data while processing changes.
    CEnableProcessingSnapinCacheChanges processSnapinChanges;

    // 2. Delete static nodes.
    {
        CMTNode * pmtnTemp;
        POSITION pos;

        if (pmtnDeletedList)
        {
            pos = pmtnDeletedList->GetHeadPosition();

            while (pos)
            {
                pmtnTemp = pmtnDeletedList->GetNext(pos);

                CMTSnapInNode * pMTSINode = dynamic_cast<CMTSnapInNode*>(pmtnTemp);

                // forward to the document to generate the script event
                if (pMTSINode)
                {
                    SnapInPtr spSnapIn;
                    // construct snapin com object
                    sc = pMTSINode->ScGetSnapIn(&spSnapIn);
                    if (sc)
                        sc.TraceAndClear(); // it's only events. Should not affect main functionality
                    else
                    {
                        // emit the event
                        sc = pConsoleDoc->ScOnSnapinRemoved(spSnapIn);
                        if (sc)
                            sc.TraceAndClear(); // it's only events. Should not affect main functionality
                    }
                }

                DeleteNode(pmtnTemp);
            }
        }
    }

    // 3. Handle extension changes
    HandleExtensionChanges(m_pMTNodeRoot->Child());

    CSnapInsCache* pSnapInCache = theApp.GetSnapInsCache();
    sc = ScCheckPointers(pSnapInCache, E_UNEXPECTED);
    if (sc)
        goto Error;

    // 4. Purge the snapin cache
    // (duplicates what is done in ~CSnapinManager, since doing it here is too early
    //  - snapin manager still has a reference to the snapins)
	// but some code relies in this to remove the snapin from cache
	// look at windows bug #276340 (ntbug9, 1/10/2001).
    pSnapInCache->Purge();

    // 5. Re-Init
    {
        POSITION pos = m_MTNodesToBeReset.GetHeadPosition();
        while (pos)
        {
            CMTNode* pMTNode = m_MTNodesToBeReset.GetNext(pos);

            ASSERT(pMTNode != NULL);
            if (pMTNode != NULL)
                pMTNode->Reset();
        }

        m_MTNodesToBeReset.RemoveAll();

        // Re-set processing changes explicitly eventhough the
        // dtor for CEnableProcessingSnapinCacheChanges will do this.
        theApp.SetProcessingSnapinChanges(FALSE);
    }

    // 6. Cleanup controlbar cache and reselect currently selected node.
    UpdateAllViews(VIEW_RESELECT, 0);

    // 7. Add new static nodes

    if (pnnList)
    {
        PNEWTREENODE pNew;
        CMTNode * pmtnTemp;
        POSITION pos = pnnList->GetHeadPosition();

        while (pos)
        {
            pNew = pnnList->GetNext(pos);
            sc = ScCheckPointers(pNew, E_UNEXPECTED);
            if (sc)
                goto Error;

            pmtnTemp = NULL;

            sc = ScCreateMTNodeTree(pNew, pNew->m_pmtNode, &pmtnTemp);
            if (sc)
                goto Error;

            sc = ScCheckPointers(pmtnTemp, E_UNEXPECTED);
            if (sc)
                goto Error;

            sc = ScInsert(pNew->m_pmtNode, pmtnTemp);
            if(sc)
                goto Error;

           CMTSnapInNode * pMTSINode = dynamic_cast<CMTSnapInNode*>(pmtnTemp);

            // forward to the document to generate the script event
            if (pMTSINode)
            {
                SnapInPtr spSnapIn;
                // construct snapin com object
                sc = pMTSINode->ScGetSnapIn(&spSnapIn);
                if (sc)
                    sc.TraceAndClear(); // it's only events. Should not affect main functionality
                else
                {
                    // emit the event
                    sc = pConsoleDoc->ScOnSnapinAdded(spSnapIn);
                    if (sc)
                        sc.TraceAndClear(); // it's only events. Should not affect main functionality
                }
            }
        }
        UpdateAllViews(VIEW_RESELECT, 0);
    }

    if (pSnapInCache->IsHelpCollectionDirty())
    {
        sc = ScSetHelpCollectionInvalid();
        if (sc)
            goto Error;
    }


Cleanup:
    sc.Clear();
    return sc;
Error:
    sc.Trace_();
    goto Cleanup;

    MMC_CATCH
}


/*+-------------------------------------------------------------------------*
 * ScCreateMTNodeTree
 *
 * Creates the tree of CMTNode's described by the CNewTreeNode tree rooted
 * at pNew.  This CMTNode tree can then be used for insertion in the scope
 * tree.
 *
 * Returns a pointer to the root of the CMTNode tree.
 *
 *--------------------------------------------------------------------------*/
SC
ScCreateMTNodeTree(PNEWTREENODE pNew, CMTNode* pmtnParent,
                   CMTNode** ppNodeCreated)
{
    DECLARE_SC(sc, TEXT("ScCreateMTNodeTree"));

    sc = ScCheckPointers(ppNodeCreated);
    if (sc)
        return sc;

    *ppNodeCreated = NULL;

    sc = ScCheckPointers(pNew, pmtnParent);
    if (sc)
        return sc;

    CMTNode*    pmtnFirst = NULL;
    CMTNode*    pmtnCur = NULL;
    CMTNode*    pmtnPrev = NULL;

    while (pNew != NULL)
    {
        if (pNew->m_pmtNewNode == NULL)
        {
            CSnapInPtr  spSI;
            SC sc = theApp.GetSnapInsCache()->ScGetSnapIn(pNew->m_clsidSnapIn, &spSI);
            if (sc)
                goto finally;

            CMTSnapInNode* pmtn = new CMTSnapInNode(pNew->m_spSnapinProps);
            if (pmtn == NULL)
            {
                sc = E_OUTOFMEMORY;
                goto finally;
            }

            // get hold on the node:
            // it either will be connected or deleted (on failure)
            pmtnCur = pmtn;

            pmtn->SetPrimarySnapIn(spSI);

            sc = ScCheckPointers(pNew->m_spIComponentData, E_UNEXPECTED);
            if (sc)
                goto finally;

            CComponentData* pCCD = pmtn->GetPrimaryComponentData();
            sc = ScCheckPointers(pCCD, E_UNEXPECTED);
            if (sc)
                goto finally;

            pCCD->SetIComponentData(pNew->m_spIComponentData);

            sc = pmtn->Init();
            if (sc)
            {
                TraceError (_T("CScopeTree::ScCreateMTNodeTree"), sc);
                // continue even on error
                sc.Clear();
            }

            if (pNew->m_spIComponentData != NULL)
            {
                CStr strBuf;
                sc = LoadRootDisplayName(pNew->m_spIComponentData, strBuf);
                if (sc)
                {
                    TraceError (_T("CScopeTree::ScCreateMTNodeTree"), sc);
                    // continue even on error
                    sc.Clear();
                }
                else
                {
                    pmtn->SetDisplayName(strBuf);
                }
            }

            pNew->m_pmtNewSnapInNode = pmtn;
        }
        else
        {
            pmtnCur = pNew->m_pmtNewNode;
            pmtnCur->AddRef();
        }

        pmtnCur->AttachParent(pmtnParent);

        if (pNew->m_pChild != NULL)
        {
            CMTNode* pNodeCreated = NULL;
            sc = ScCreateMTNodeTree(pNew->m_pChild, pmtnCur, &pNodeCreated);
            if (sc)
                goto finally;

            sc = ScCheckPointers(pNodeCreated, E_UNEXPECTED);
            if (sc)
                goto finally;

            pmtnCur->AttachChild(pNodeCreated);
        }

        if (pmtnPrev)
        {
            pmtnPrev->AttachNext(pmtnCur);
        }
        else if (pmtnFirst == NULL)
        {
            pmtnFirst = pmtnCur;
        }

        pmtnPrev = pmtnCur;
        pmtnCur  = NULL;

        pNew = pNew->m_pNext;
    }

finally:

    if (sc)
    {
        // error - cleanup before return
        while (pmtnFirst)
        {
            // point to the next
            pmtnPrev = pmtnFirst;
            pmtnFirst = pmtnPrev->Next();

            // destroy the first one
            pmtnPrev->AttachNext(NULL);
            pmtnPrev->AttachParent(NULL);
            pmtnPrev->Release();
        }

        if (pmtnCur)
        {
            pmtnCur->AttachParent(NULL);
            pmtnCur->Release();
        }
    }
    else
    {
        // assign the tree to be returned
        *ppNodeCreated = pmtnFirst;
    }

    return sc;
}

void CScopeTree::Cleanup(void)
{
    Dbg(DEB_USER1, "CScopeTree::CleanUp\n");

    // Reset the MT node IDs to ROOTNODEID (e.g 1) so the new scope tree
    // can start over correctly with new numbers
    CMTNode::ResetID();

    CComponentIDArray rgID;
    rgID.SetSize(20, 10);
    InformSnapinsOfDeletion(m_pMTNodeRoot, FALSE, rgID);

    SAFE_RELEASE(m_pMTNodeRoot);
    SAFE_RELEASE(m_pImageCache);

    delete m_pDefaultTaskpads;  m_pDefaultTaskpads = NULL;
    delete m_pConsoleTaskpads;  m_pConsoleTaskpads = NULL;
}

STDMETHODIMP CScopeTree::GetImageList(PLONG_PTR pImageList)
{
    MMC_TRY

    if (pImageList == NULL)
        return E_POINTER;

    HIMAGELIST* phiml = reinterpret_cast<HIMAGELIST *>(pImageList);
    *phiml = GetImageList();

    return ((*phiml) ? S_OK : E_FAIL);

    MMC_CATCH
}

HIMAGELIST CScopeTree::GetImageList () const
{
    ASSERT(m_pImageCache != NULL);
    if (m_pImageCache == NULL)
        return NULL;

    return (m_pImageCache->GetImageList()->m_hImageList);
}

HRESULT CScopeTree::InsertConsoleTaskpad (CConsoleTaskpad *pConsoleTaskpad,
                                          CNode *pNodeTarget, bool bStartTaskWizard)
{
    DECLARE_SC (sc, _T("CScopeTree::InsertConsoleTaskpad"));

    ASSERT(pConsoleTaskpad);
    m_pConsoleTaskpads->push_back(*pConsoleTaskpad);

    // make sure the taskpad now points to the one that is inside the list.
    CConsoleTaskpad & consoleTaskpad = m_pConsoleTaskpads->back();
    pConsoleTaskpad = &consoleTaskpad;

    // reselect all nodes.
    UpdateAllViews(VIEW_RESELECT, 0);

    if(bStartTaskWizard)
    {
        typedef CComObject<CConsoleTaskCallbackImpl> t_TaskCallbackImpl;
        t_TaskCallbackImpl* pTaskCallbackImpl;
        sc = t_TaskCallbackImpl::CreateInstance(&pTaskCallbackImpl);
        if (sc)
            return (sc.ToHr());

        ITaskCallbackPtr spTaskCallback = pTaskCallbackImpl; // addrefs/releases the object.

        sc = pTaskCallbackImpl->ScInitialize(pConsoleTaskpad, this, pNodeTarget);
        if (sc)
            return (sc.ToHr());

        pTaskCallbackImpl->OnNewTask();
        UpdateAllViews(VIEW_RESELECT, 0);
    }

    return (sc.ToHr());
}

HRESULT CScopeTree::IsSynchronousExpansionRequired()
{
    return (_IsSynchronousExpansionRequired() ? S_OK : S_FALSE);
}

HRESULT CScopeTree::RequireSynchronousExpansion(BOOL fRequireSyncExpand)
{
    _RequireSynchronousExpansion (fRequireSyncExpand ? true : false);
    return (S_OK);
}



//############################################################################
//############################################################################
//
//  CScopeTree Object model methods - SnapIns collection methods
//
//############################################################################
//############################################################################

/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::ScAdd
 *
 * PURPOSE: Adds a snap-in with the supplied CLSID or PROGID to the console.
 *
 * PARAMETERS:
 *    BSTR      bstrSnapinNameOrCLSID :
 *    VARIANT   varProperties
 *    SnapIn**  ppSnapIn
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CScopeTree::ScAdd(
    BSTR        bstrSnapinNameOrCLSID,  /* I:what snap-in?                  */
    VARIANT     varParentSnapinNode,    /* I:Snapin under which this new snapin will be added (optional)*/
    VARIANT     varProperties,          /* I:props to create with (optional)*/
    SnapIn**    ppSnapIn)               /* O:created snap-in                */
{
    DECLARE_SC(sc, TEXT("CScopeTree::ScAdd"));

    /*
     * dereference VT_BYREF VARIANTs that VBScript might have passed us
     */
    VARIANT* pProperties = ConvertByRefVariantToByValue (&varProperties);

    VARIANT* pParentSnapinNode = ConvertByRefVariantToByValue (&varParentSnapinNode);

    /*
     * validate the parameters
     */
    sc = ScCheckPointers(ppSnapIn, pProperties, pParentSnapinNode);
    if (sc)
        return (sc);

    /*
     * Get the properties for the new snap-in.  This is an optional
     * parameter, so VT_ERROR with DISP_E_PARAMNOTFOUND is OK
     */
    PropertiesPtr spProperties;

    if (!IsOptionalParamMissing (*pProperties))
    {
        /*
         * Assign from the VARIANT (ain't smart pointers great?).
         * If the QI returned E_NOINTERFACE, the smart pointer will be
         * assigned NULL.  If the QI failed in some other way, operator=
         * will throw a _com_error containing the failure HRESULT.
         */
        try
        {
            if ((spProperties = _variant_t(*pProperties)) == NULL)
                sc = E_NOINTERFACE;
        }
        catch (_com_error& err)
        {
            sc = err.Error();
        }

        if (sc)
            return (sc.ToHr());
    }

    /*
     * Get the parent snapin node for the new snap-in.  This is an optional
     * parameter, so VT_ERROR with DISP_E_PARAMNOTFOUND is OK
     */
    SnapInPtr spParentSnapIn;

    if (!IsOptionalParamMissing (*pParentSnapinNode))
    {
        /*
         * Assign from the VARIANT (ain't smart pointers great?).
         * If the QI returned E_NOINTERFACE, the smart pointer will be
         * assigned NULL.  If the QI failed in some other way, operator=
         * will throw a _com_error containing the failure HRESULT.
         */
        try
        {
            if ((spParentSnapIn = _variant_t(*pParentSnapinNode)) == NULL)
                sc = E_NOINTERFACE;
        }
        catch (_com_error& err)
        {
            sc = err.Error();
        }

        if (sc)
            return (sc.ToHr());
    }

    sc = ScAddSnapin(bstrSnapinNameOrCLSID, spParentSnapIn, spProperties, *ppSnapIn);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CScopeTree:ScRemove
//
//  Synopsis:    Remove given snapin.
//
//  Arguments:   [pSnapIn] - the snapin (disp) interface.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CScopeTree::ScRemove (PSNAPIN pSnapIn)
{
    DECLARE_SC(sc, _T("CScopeTree:ScRemove"));
    sc = ScCheckPointers(pSnapIn);
    if (sc)
        return sc;

    // Get the MTNode for this snapin root.
    CMTSnapInNode *pMTSnapinNode = NULL;

    sc = CMTSnapInNode::ScGetCMTSnapinNode(pSnapIn, &pMTSnapinNode);
    if (sc)
        return sc;

    CSnapinManager snapinMgr(GetRoot());

    // Ask snapin mgr to add this snapin to deletednodes list.
    sc = snapinMgr.ScRemoveSnapin(pMTSnapinNode);
    if (sc)
        return sc;

    // Update the scope tree with changes made by snapin manager.
    sc = ScAddOrRemoveSnapIns(snapinMgr.GetDeletedNodesList(),
                              snapinMgr.GetNewNodes());
    if (sc)
        return sc;

    return (sc);
}



/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::GetNextStaticNode
 *
 * PURPOSE: Returns the next static node (either the child or sibling) of the supplied node.
 *          This is slightly different from CMTNode::NextStaticNode(), which includes the node
 *          itself in the search.
 *
 * PARAMETERS:
 *    CMTNode *pMTNode : The supplied node.
 *
 * RETURNS:
 *    CMTSnapInNode *
 *
 *+-------------------------------------------------------------------------*/
CMTSnapInNode *
CScopeTree::GetNextStaticNode(CMTNode *pMTNode)
{
    CMTSnapInNode *pMTSnapInNode = NULL;

    if(!pMTNode)
        return NULL;

    // go thru all the children, then thru all the siblings.
    CMTNode *pMTNodeChild = pMTNode->Child();
    CMTNode *pMTNodeNext  = pMTNode->Next();
    CMTNode *pMTNodeParent= pMTNode->Parent();

    // see if the child is a snapin
    pMTSnapInNode = dynamic_cast<CMTSnapInNode*>(pMTNodeChild);
    if(pMTSnapInNode)
        return pMTSnapInNode;

    // the child wasn't a snap-in node. Try its children.
    if(pMTNodeChild)
    {
        pMTSnapInNode = GetNextStaticNode(pMTNodeChild);
        if(pMTSnapInNode)
            return pMTSnapInNode;
    }

    // That didn't work either. Check to see if the next node is a snapin
    pMTSnapInNode = dynamic_cast<CMTSnapInNode*>(pMTNodeNext);
    if(pMTSnapInNode)
        return pMTSnapInNode;

    // the next node wasn't a snap-in node. Try its children.
    if(pMTNodeNext)
    {
        pMTSnapInNode = GetNextStaticNode(pMTNodeNext);
        if(pMTSnapInNode)
            return pMTSnapInNode;
    }

    // nothing was found in the next node's tree. Go to the next node of the parent.

    if(pMTNodeParent)
    {
        CMTNode *pMTNodeParentNext = pMTNodeParent->Next();
        if(pMTNodeParentNext)
        {
            pMTSnapInNode = dynamic_cast<CMTSnapInNode*>(pMTNodeParentNext);
            if(pMTSnapInNode)
                return pMTSnapInNode;

            // the parent's next node was not a snapin node. Try its children
            return GetNextStaticNode(pMTNodeParentNext);
        }

    }

    // nothing left.
    return NULL;
}

/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::ScItem
 *
 * PURPOSE:  Returns a pointer to the i'th snap-in object.
 *
 * PARAMETERS:
 *    long      Index : 1-based.
 *    PPSNAPIN  ppSnapIn :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CScopeTree::ScItem(long Index, PPSNAPIN ppSnapIn)
{
    DECLARE_SC(sc, TEXT("CScopeTree::ScItem"));

    // check parameters.
    if( (Index <= 0) || (!ppSnapIn) )
        return (sc = E_INVALIDARG);

    CMTNode * pMTNode = GetRoot();
    if(!pMTNode)
        return (sc = E_UNEXPECTED);

    CMTSnapInNode * pMTSINode = dynamic_cast<CMTSnapInNode*>(pMTNode);
    // This should not be true as console root is a snapin.
    sc = ScCheckPointers(pMTSINode, E_UNEXPECTED);
    if (sc)
        return sc;

    while(--Index)
    {
        pMTSINode = GetNextStaticNode(pMTSINode);
        if(!pMTSINode)
            return (sc = E_INVALIDARG); // no more snap-ins. Argument was out of bounds.
    }

    if(!pMTSINode)
        return (sc = E_UNEXPECTED); // defensive. Should never happen.

    sc = pMTSINode->ScGetSnapIn(ppSnapIn);
    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::Scget_Count
 *
 * PURPOSE:  Returns the number of stand alone snapins in the collection.
 *
 * PARAMETERS:
 *    PLONG     Ptr to count.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CScopeTree::Scget_Count(PLONG pCount)
{
    DECLARE_SC(sc, TEXT("CScopeTree::Scget_Count"));
    sc = ScCheckPointers(pCount);
    if (sc)
        return sc;

    *pCount = 0;

    CMTNode * pMTNode = GetRoot();
    if(!pMTNode)
        return (sc = E_UNEXPECTED);

    CMTSnapInNode * pMTSINode = dynamic_cast<CMTSnapInNode*>(pMTNode);
    // This should not be true as console root is a snapin.
    sc = ScCheckPointers(pMTSINode, E_UNEXPECTED);
    if (sc)
        return sc;

    // Count all the static nodes (that are snapins).
    do
    {
        (*pCount)++;
    } while( (pMTSINode = GetNextStaticNode(pMTSINode)) != NULL);

    return sc;
}


//############################################################################
//############################################################################
//
//  CScopeTree Object model methods - SnapIns enumerator
//
//############################################################################
//############################################################################
/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::ScGetNextSnapInPos
 *
 * PURPOSE: Returns the next snap-in in position.
 *
 * PARAMETERS:
 *    CSnapIns_Positon & pos : [in, out]: Must be non-NULL.
 *
 *
 *
 * RETURNS:
 *    SC: S_FALSE if there are no more items in the collection
 *
 *+-------------------------------------------------------------------------*/
SC
CScopeTree::ScGetNextSnapInPos(CSnapIns_Positon &pos)
{
    DECLARE_SC(sc, TEXT("CScopeTree::ScGetNextSnapInPos"));

    if(pos == NULL)
       return (sc = S_FALSE);

    // for safety, copy the value and zero the output
    CSnapIns_Positon    posIn  = pos;
    pos  = NULL;

    ASSERT(posIn != NULL); //sanity check, already checked above.

    CMTNode *           pMTNode = GetRoot();
    if(!pMTNode)
    {
        return (sc = E_UNEXPECTED);
    }

    CMTSnapInNode * pMTSINode = dynamic_cast<CMTSnapInNode*>(pMTNode);
    if(!pMTSINode)
        return (sc = S_FALSE);


    // If we're not starting at the beginning, look for the current position.
    // walk down the tree looking for the snap-in.
    // although the position pointer is simply the pointer, we cannot dereference
    // it because it may not be valid anymore.
    while(pMTSINode != NULL)
    {
        CMTSnapInNode *pMTSINodeNext = GetNextStaticNode(pMTSINode);

        if(posIn == pMTSINode) // found the position. Return the next one
        {
            pos = pMTSINodeNext;
            return (sc = (pos == NULL) ? S_FALSE : S_OK);
        }

        pMTSINode = pMTSINodeNext;
    }

    return (sc = S_FALSE);
}

/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::ScEnumNext
 *
 * PURPOSE: Returns the next snapin object pointer.
 *
 * PARAMETERS:
 *    _Position & pos :
 *    PDISPATCH & pDispatch :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CScopeTree::ScEnumNext(CSnapIns_Positon &pos, PDISPATCH & pDispatch)
{
    DECLARE_SC(sc, TEXT("CScopeTree::ScEnumNext"));

    if( NULL==pos )
    {
        sc = S_FALSE;
        return sc;
    }

    // at this point, we have a valid position.
    SnapInPtr spSnapIn;

    sc = pos->ScGetSnapIn(&spSnapIn);
    if(sc)
        return sc;

    if(spSnapIn == NULL)
    {
        sc = E_UNEXPECTED;  // should never happen.
        return sc;
    }

    /*
     * return the IDispatch for the object and leave a ref on it for the client
     */
    pDispatch = spSnapIn.Detach();

    //ignore this error
    ScGetNextSnapInPos(pos); // this gets the correct pointer without dereferencing the present one.

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::ScEnumSkip
 *
 * PURPOSE: Skips the next celt items
 *
 * PARAMETERS:
 *    unsigned           long :
 *    CSnapIns_Positon & pos :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CScopeTree::ScEnumSkip(unsigned long celt, unsigned long& celtSkipped, CSnapIns_Positon &pos)
{
    DECLARE_SC(sc, TEXT("CScopeTree::ScEnumSkip"));

    // skip celt positions, don't check the last skip.
    for(celtSkipped =0;  celtSkipped<celt; celt++)
    {
        if (pos == NULL)
        {
            sc = S_FALSE;
            return sc;
        }

        // go to the next view
        sc = ScGetNextSnapInPos(pos);
        if(sc.IsError() || sc == SC(S_FALSE))
            return sc;
    }

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::ScEnumReset
 *
 * PURPOSE: Sets the position to the first item
 *
 * PARAMETERS:
 *    CSnapIns_Positon & pos :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CScopeTree::ScEnumReset(CSnapIns_Positon &pos)
{
    DECLARE_SC(sc, TEXT("CScopeTree::ScEnumReset"));

    // initial case. Return Console Root.
    pos = dynamic_cast<CMTSnapInNode*>(CScopeTree::GetScopeTree()->GetRoot());

    return sc;
}

//############################################################################
//############################################################################
//
//  CScopeTree Object model methods - ScopeNamespace methods
//
//############################################################################
//############################################################################


/*+-------------------------------------------------------------------------*
 *
 * ScCheckInputs
 *
 * PURPOSE: little helper for the following three functions.
 *
 * PARAMETERS:
 *    PNODE   pNode :  Checked for NULL, and that it is a CMMCScopeNode.
 *                     Also pNode->m_pMTNode is checked for NULL.
 *    PPNODE  ppNode : Checked for NULL.
 *    PMTNODE pMTNode: [out]: pNode->m_pMTNode;
 *
 * RETURNS:
 *    inline SC
 *
 *+-------------------------------------------------------------------------*/
inline SC
ScCheckInputs(PNODE pNode, PPNODE ppNode, PMTNODE & pMTNode)
{
    SC sc; // don't need DECLARE_SC here.

    // check parameters
    if( (NULL == pNode) || (NULL == ppNode) )
    {
        sc = E_INVALIDARG;
        return sc;
    }

    // make sure we have a scope node
    CMMCScopeNode *pScopeNode = dynamic_cast<CMMCScopeNode *>(pNode);
    if(!pScopeNode)
    {
        sc = E_INVALIDARG;
        return sc;
    }

    // make sure it's node pointer is good
    if(!pScopeNode->GetMTNode())
    {
        sc = E_UNEXPECTED;
        return sc;
    }

    pMTNode = pScopeNode->GetMTNode();

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::ScGetParent
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    PNODE   pNode :
 *    PPNODE  ppParent :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CScopeTree::ScGetParent(PNODE pNode, PPNODE ppParent)
{
    DECLARE_SC(sc, TEXT("CScopeTree::ScGetParent"));

    PMTNODE pMTNode = NULL;

    // check parameters
    sc = ScCheckInputs(pNode, ppParent, pMTNode);
    if(sc)
        return sc;


    sc = ScGetNode(pMTNode->Parent(), ppParent);
    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::ScGetChild
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    PNODE   pNode :
 *    PPNODE  ppChild :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CScopeTree::ScGetChild(PNODE pNode, PPNODE ppChild)
{
    DECLARE_SC(sc, TEXT("CScopeTree::ScGetChild"));

    PMTNODE pMTNode = NULL;

    // check parameters
    sc = ScCheckInputs(pNode, ppChild, pMTNode);
    if(sc)
        return sc;


    sc = ScGetNode(pMTNode->Child(), ppChild);
    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::ScGetNext
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    PNODE   pNode :
 *    PPNODE  ppNext :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CScopeTree::ScGetNext(PNODE pNode, PPNODE ppNext)
{
    DECLARE_SC(sc, TEXT("CScopeTree::ScGetNext"));

    PMTNODE pMTNode = NULL;

    // check parameters
    sc = ScCheckInputs(pNode, ppNext, pMTNode);
    if(sc)
        return sc;

    sc = ScGetNode(pMTNode->Next(), ppNext);
    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::ScGetRoot
 *
 * PURPOSE: Returns a COM object for the Root the Root node.
 *
 * PARAMETERS:
 *    PPNODE  ppRoot :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CScopeTree::ScGetRoot(PPNODE ppRoot)
{
    DECLARE_SC(sc, TEXT("CScopeTree::ScGetRoot"));

    sc = ScGetRootNode(ppRoot);

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      CScopeTree::ScGetRootNode
//
//  Synopsis:    Helper that returns a COM object for the Root node.
//
//  Arguments:   [ppRootNode] - The root node ptr.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CScopeTree::ScGetRootNode (PPNODE ppRootNode)
{
    DECLARE_SC(sc, _T("CScopeTree::ScGetRootNode"));
    sc = ScCheckPointers(ppRootNode);
    if (sc)
        return sc;

    CMTNode* pMTRootNode = GetRoot();
    sc = ScCheckPointers(pMTRootNode, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = ScGetNode(pMTRootNode, ppRootNode);
    if (sc)
        return sc;

    return (sc);
}

/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::ScExpand
 *
 * PURPOSE: Implements ScopeNameSpace::Expand. Expands the specified node.
 *
 * PARAMETERS:
 *    PNODE  pNode :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CScopeTree::ScExpand(PNODE pNode)
{
    DECLARE_SC(sc, TEXT("CScopeTree::ScExpand"));

    // check parameters
    sc = ScCheckPointers(pNode);
    if(sc)
        return sc;

    // make sure we have a scope node
    CMMCScopeNode *pScopeNode = dynamic_cast<CMMCScopeNode *>(pNode);
    if(!pScopeNode)
    {
        sc = E_INVALIDARG;
        return sc;
    }

    // make sure it's node pointer is good
    CMTNode* pMTNode = pScopeNode->GetMTNode();
    if(!pMTNode)
    {
        sc = E_UNEXPECTED;
        return sc;
    }

    if ( !pMTNode->WasExpandedAtLeastOnce() )
    {
        sc = pMTNode->Expand();
        if (sc)
            return sc;
    }

    return sc;
}


SC
CScopeTree::ScGetNode(CMTNode *pMTNode, PPNODE ppOut)
{
    DECLARE_SC(sc, TEXT("CScopeTree::ScGetNode"));

    sc = ScCheckPointers(pMTNode, ppOut);
    if(sc)
        return sc;

    *ppOut = NULL;

    CMapMTNodeToMMCNode::iterator it = m_mapMTNodeToMMCNode.find(pMTNode);

    if (it == m_mapMTNodeToMMCNode.end())
    {
        // not found - got to create one
        typedef CComObject<CMMCScopeNode> CScopeNode;
        CScopeNode *pScopeNode = NULL;
        CScopeNode::CreateInstance(&pScopeNode);

        sc = ScCheckPointers(pScopeNode, E_OUTOFMEMORY);
        if(sc)
            return sc;

        // set up the internal pointer.
        pScopeNode->m_pMTNode = pMTNode;
        m_mapMTNodeToMMCNode.insert(CMapMTNodeToMMCNode::value_type(pMTNode, pScopeNode));
        *ppOut = pScopeNode;
    }
    else
    {
#ifdef DBG
        CMMCScopeNode *pScopeNode = dynamic_cast<CMMCScopeNode *>(it->second);
        // just doublecheck the pointers
        ASSERT(pScopeNode && pScopeNode->GetMTNode() == pMTNode);
#endif // DBG
        *ppOut = it->second;
    }


    (*ppOut)->AddRef();  // addref the object for the client.

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::ScGetNode
 *
 * PURPOSE: Returns the CMTNode encapsulated by a Node.
 *
 * PARAMETERS:
 *    PNODE     pNode :
 *    CMTNode * ppMTNodeOut : The return value.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CScopeTree::ScGetNode(PNODE pNode, CMTNode **ppMTNodeOut)
{
    DECLARE_SC(sc, TEXT("CScopeTree::ScGetNode"));

    sc = ScCheckPointers(pNode, ppMTNodeOut);
    if (sc)
        return sc;

    // make sure we have a scope node
    CMMCScopeNode *pScopeNode = dynamic_cast<CMMCScopeNode *>(pNode);
    if(!pScopeNode)
        return (sc =E_FAIL);

    *ppMTNodeOut = pScopeNode->GetMTNode();
    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::GetHMTNode
 *
 * PURPOSE: returns the HMTNode for a node object
 *
 * PARAMETERS:
 *    PNODE     pNode :
 *    HMTNODE * phMTNode :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CScopeTree::GetHMTNode(PNODE pNode, HMTNODE *phMTNode)
{
    DECLARE_SC(sc, TEXT("CScopeTree::GetHMTNode"));

    sc = ScCheckPointers(pNode, phMTNode);
    if (sc)
        return sc.ToHr();

    // initialize output
    *phMTNode = NULL;

    // make sure we have a scope node
    CMMCScopeNode *pScopeNode = dynamic_cast<CMMCScopeNode *>(pNode);
    if(!pScopeNode)
    {
        // Not a valid node - that's expected. Do not assert nor trace
        return E_FAIL;
    }

    CMTNode *pMTNode = pScopeNode->GetMTNode();
    sc = ScCheckPointers(pMTNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    *phMTNode = CMTNode::ToHandle(pMTNode);

    return sc.ToHr();
}


/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::GetNodeID
 *
 * PURPOSE:    returns node id for Node object
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
HRESULT CScopeTree::GetNodeID(PNODE pNode, MTNODEID *pID)
{
    DECLARE_SC(sc, TEXT("CScopeTree::GetNodeID"));

    sc = ScCheckPointers(pNode, pID);
    if (sc)
        return sc.ToHr();

    // make sure we have a scope node
    CMMCScopeNode *pScopeNode = dynamic_cast<CMMCScopeNode *>(pNode);
    if(!pScopeNode)
    {
        // Not a valid node - that's expected. Do not assert nor trace
        return E_FAIL;
    }

    CMTNode *pMTNode = pScopeNode->GetMTNode();
    sc = ScCheckPointers(pMTNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    *pID = pMTNode->GetID();

    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::GetNode
 *
 * PURPOSE:    returns Node object referencing the specified node id
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
HRESULT CScopeTree::GetMMCNode(HMTNODE hMTNode, PPNODE ppNode)
{
    DECLARE_SC(sc, TEXT("CScopeTree::GetMMCNode"));

    // parameter checking
    sc = ScCheckPointers((LPVOID)hMTNode);
    if (sc)
        return sc.ToHr();

    // get the node
    sc = ScGetNode(CMTNode::FromHandle(hMTNode), ppNode);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CCScopeTree::ScUnadviseMTNode
 *
 * PURPOSE:    informs Node objects about MTNode going down
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC CScopeTree::ScUnadviseMTNode(CMTNode* pMTNode)
{
    DECLARE_SC(sc, TEXT("CScopeTree::ScUnadviseMTNode"));

    sc = ScCheckPointers(pMTNode);
    if (sc)
        return sc;

    CMapMTNodeToMMCNode::iterator it = m_mapMTNodeToMMCNode.find(pMTNode);
    // need to tell the com object [if we have one] this is the end of MTNode
    if (it != m_mapMTNodeToMMCNode.end())
    {
        // make sure we have a scope node
        CMMCScopeNode *pScopeNode = dynamic_cast<CMMCScopeNode *>(it->second);
        sc = ScCheckPointers(pScopeNode, E_UNEXPECTED);
        if (sc)
            return sc;

        ASSERT(pScopeNode->GetMTNode() == pMTNode);
        // can forget about the object from now on
        pScopeNode->ResetMTNode();
        m_mapMTNodeToMMCNode.erase(it);
    }
    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CScopeTree::ScUnadviseMMCScopeNode
 *
 * PURPOSE:    informs Scope tree about Node object about to be destroyed
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC CScopeTree::ScUnadviseMMCScopeNode(PNODE pNode)
{
    DECLARE_SC(sc, TEXT("CScopeTree::ScUnadviseMMCScopeNode"));

    sc = ScCheckPointers(pNode);
    if (sc)
        return sc;

    CMMCScopeNode *pScopeNode = dynamic_cast<CMMCScopeNode *>(pNode);
    sc = ScCheckPointers(pScopeNode, E_UNEXPECTED);
    if (sc)
        return sc;

    CMTNode* pMTNode = pScopeNode->GetMTNode();
    if (!pMTNode)
    {
        // orphan entry - ignore
#ifdef DBG
        // to detect leaks in keeping the registry
        CMapMTNodeToMMCNode::iterator it = m_mapMTNodeToMMCNode.begin();
        while (it != m_mapMTNodeToMMCNode.end())
        {
            ASSERT(it->second != pNode);
            ++it;
        }
#endif
        return sc;
    }

    CMapMTNodeToMMCNode::iterator it = m_mapMTNodeToMMCNode.find(pMTNode);
    // need to tell the com object [i.e. itself] this is the end of relationship with MTNode
    if (it == m_mapMTNodeToMMCNode.end())
        return sc = E_UNEXPECTED;

    // make sure we really talking to itself
    ASSERT(pScopeNode->GetMTNode() == pMTNode);

    // can forget about the MTNode from now on
    pScopeNode->ResetMTNode();
    m_mapMTNodeToMMCNode.erase(it);

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CScopeTree::IsSnapinInUse
 *
 * PURPOSE: checks if snapin is in use by MMC.
 *          (check is done by examining snapin cache)
 *
 * PARAMETERS:
 *    REFCLSID refClsidSnapIn - [in] - snapin to examine
 *    PBOOL pbInUse           - [out] - verification result
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
STDMETHODIMP CScopeTree::IsSnapinInUse(/*[in]*/ REFCLSID refClsidSnapIn, /*[out]*/ PBOOL pbInUse)
{
    DECLARE_SC(sc, TEXT("CScopeTree::IsSnapinInUse"));

    // parameter check
    sc = ScCheckPointers(pbInUse);
    if (sc)
        return sc.ToHr();

    // out parameter initialization
    *pbInUse = FALSE;

    // getting the cache
    CSnapInsCache* pCache = theApp.GetSnapInsCache();
    sc = ScCheckPointers(pCache, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // assume it exists
    *pbInUse = TRUE;

    // looup snapin
    CSnapInPtr spSnapIn;
    sc = pCache->ScFindSnapIn(refClsidSnapIn, &spSnapIn);
    if(sc)
    {
        // if failed to find - assume one does not exist
        *pbInUse = FALSE;
        // no trace if not found
        sc.Clear();
    }

    return sc.ToHr();
}

 //+-------------------------------------------------------------------
 //
 //  Member:      CScopeTree::ScSetHelpCollectionInvalid
 //
 //  Synopsis:    Inform the document that help collection is invalid
 //
 //  Arguments:
 //
 //  Returns:     SC
 //
 //--------------------------------------------------------------------
 SC CScopeTree::ScSetHelpCollectionInvalid ()
 {
     DECLARE_SC(sc, _T("CScopeTree::ScSetHelpCollectionInvalid"));

     sc = ScCheckPointers(m_pConsoleData, m_pConsoleData->m_pConsoleDocument, E_UNEXPECTED);
     if (sc)
         return sc;

     sc = m_pConsoleData->m_pConsoleDocument->ScSetHelpCollectionInvalid();

     return (sc);
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\scopndcb.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       ScopNdCb.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    12/31/1996   RaviR   Created
//____________________________________________________________________________
//


#ifndef _MMC_SCOPNDCB_H_
#define _MMC_SCOPNDCB_H_

class CNode;
class CComponentData;
class CComponent;

class CNodeCallback : public INodeCallback, public CComObjectRoot
{
// Constructor/Destructor
public:
    CNodeCallback();
    ~CNodeCallback();

public:
BEGIN_COM_MAP(CNodeCallback)
    COM_INTERFACE_ENTRY(INodeCallback)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CNodeCallback)

// COM interfaces
public:
    // INodeCallback methods
    STDMETHOD(Initialize)(IScopeTree* pIScopeTree);
    STDMETHOD(GetImages)(HNODE hNode, int* iImage, int* iSelectedImage);
    STDMETHOD(GetDisplayName)(HNODE hNode, tstring& strName);
    STDMETHOD(GetWindowTitle)(HNODE hNode, tstring& strTitle);
    STDMETHOD(GetDispInfo)(HNODE hNode, LV_ITEMW* plvi);
    STDMETHOD(GetResultPane)(HNODE hNode, CResultViewType& rvt, GUID *pGuidTaskpadID);
    STDMETHOD(RestoreResultView)(HNODE hNode, const CResultViewType& rvt);
    STDMETHOD(GetState)(HNODE hNode, UINT* pnState);
    STDMETHOD(Notify)(HNODE hNode, NCLBK_NOTIFY_TYPE event, LONG_PTR arg, LPARAM param);
    STDMETHOD(GetMTNodeID)(HNODE hNode, MTNODEID* pnID);
    STDMETHOD(GetNodeOwnerID)(HNODE hNode, COMPONENTID* pOwnerID);
    STDMETHOD(GetNodeCookie)(HNODE hNode, MMC_COOKIE* pCookie);
    STDMETHOD(IsTargetNodeOf)(HNODE hNode, HNODE hTestNode);
    STDMETHOD(GetPath)(HNODE hNode, HNODE hRootNode, LPBYTE pbm_);
    STDMETHOD(GetStaticParentID)(HNODE hNode, MTNODEID* pnID);
    STDMETHOD(GetMTNode)(HNODE hNode, HMTNODE* phMTNode);
    STDMETHOD(GetMTNodePath)(HNODE hNode, HMTNODE** pphMTNode, long* plLength);
    STDMETHOD(SetResultItem)  (HNODE hNode, HRESULTITEM hri);
    STDMETHOD(GetResultItem)  (HNODE hNode, HRESULTITEM* phri);
    STDMETHOD(GetControl)(     HNODE hNode, CLSID clsid, IUnknown **ppUnkControl);
    STDMETHOD(SetControl)(     HNODE hNode, CLSID clsid, IUnknown* pUnknown);
    STDMETHOD(GetControl)(     HNODE hNode, LPUNKNOWN pUnkOCX, IUnknown **ppUnkControl);
    STDMETHOD(SetControl)(     HNODE hNode, LPUNKNOWN pUnkOCX, IUnknown* pUnknown);
    STDMETHOD(InitOCX)(        HNODE hNode, IUnknown* pUnknown);

    STDMETHOD(IsExpandable)(HNODE hNode);
    STDMETHOD(GetConsoleVerb)(HNODE hNode, LPCONSOLEVERB* ppConsoleVerb);
    STDMETHOD(GetDragDropDataObject)(HNODE hNode, BOOL bScope, BOOL bMultiSel,
                                MMC_COOKIE cookie, LPDATAOBJECT* ppDataObject,
                                bool& bCopyAllowed, bool& bMoveAllowed);
    STDMETHOD(GetTaskEnumerator)(HNODE hNode, LPCOLESTR pszTaskGroup,
                                 IEnumTASK** ppEnumTask);
    STDMETHOD(GetListPadInfo)(HNODE hNode, IExtendTaskPad* pExtendTaskPad,
                              LPCOLESTR szTaskGroup,
                              MMC_ILISTPAD_INFO* pIListPadInfo);
    STDMETHOD(UpdateWindowLayout)(LONG_PTR lViewData, long lToolbarsDisplayed);
    STDMETHOD(AddCustomFolderImage)(HNODE hNode, IImageListPrivate* pImageList);
    STDMETHOD(PreLoad)(HNODE hNode);
    STDMETHOD(SetTaskPadList)(HNODE hNode, LPUNKNOWN pUnknown);
    STDMETHOD(SetTaskpad)    (HNODE hNodeSelected, GUID *pGuidTaskpad);
    STDMETHOD(OnCustomizeView) (LONG_PTR lViewData);
    STDMETHOD(SetViewSettings)(int nViewID, HBOOKMARK hbm, HVIEWSETTINGS hvs);
    STDMETHOD(ExecuteScopeItemVerb)(MMC_CONSOLE_VERB verb, HNODE hNode, LPOLESTR lpszNewName);
    STDMETHOD(ExecuteResultItemVerb)( MMC_CONSOLE_VERB verb, HNODE hNode, LPARAM lvData, LPOLESTR lpszNewName);
    STDMETHOD(QueryCompDataDispatch)(PNODE pNode, PPDISPATCH ScopeNodeObject);
    STDMETHOD(QueryComponentDispatch)(HNODE hNode, LPARAM lvData, /*[out]*/ PPDISPATCH SelectedObject);
    STDMETHOD(CreateContextMenu)( PNODE pNode, HNODE hNode, PPCONTEXTMENU ppContextMenu);
    STDMETHOD(CreateSelectionContextMenu)( HNODE hNodeScope, CContextMenuInfo *pContextInfo, PPCONTEXTMENU ppContextMenu);
    // Implementation helpers for Column com object.
    STDMETHOD(ShowColumn)(HNODE hNodeSelected, int iColIndex, bool bShow);
    STDMETHOD(GetSortColumn)(HNODE hNodeSelected, int *piSortCol);
    STDMETHOD(SetSortColumn)(HNODE hNodeSelected, int iSortCol, bool bAscending);
    STDMETHOD(GetProperty)(HNODE hNodeScope, BOOL bForScopeItem, LPARAM resultItemParam, BSTR bstrPropertyName, PBSTR  pbstrPropertyValue);
    STDMETHOD(GetNodetypeForListItem)(HNODE hNodeScope, BOOL bForScopeItem, LPARAM resultItemParam, PBSTR pbstrNodetype);
    STDMETHOD(GetNodeViewExtensions)(/*[in]*/ HNODE hNodeScope, /*[out]*/ CViewExtInsertIterator it);
    STDMETHOD(SaveColumnInfoList) (/*[in]*/HNODE hNode, /*[in]*/const CColumnInfoList& columnsList);
    STDMETHOD(GetPersistedColumnInfoList) (/*[in]*/HNODE hNode, /*[in]*/CColumnInfoList *pColumnsList);
    STDMETHOD(DeletePersistedColumnData) (/*[in]*/HNODE hNode);
    STDMETHOD(DoesAboutExist) (/*[in]*/HNODE hNode, /*[out]*/ bool *pbAboutExists);
    STDMETHOD(ShowAboutInformation) (/*[in]*/HNODE hNode);
    STDMETHOD(ExecuteShellCommand)(/*[in]*/ HNODE hNode, /*[in]*/ BSTR Command, /*[in]*/ BSTR Directory, /*[in]*/ BSTR Parameters, /*[in]*/ BSTR WindowState);
    STDMETHOD(UpdatePasteButton)(/*[in]*/ HNODE hNode, /*[in]*/ BOOL bScope, /*[in]*/ LPARAM lCookie);
    STDMETHOD(QueryPaste)(/*[in]*/ HNODE hNode, /*[in]*/ BOOL bScope, /*[in]*/ LPARAM lCookie, /*[in]*/ IDataObject *pDataObject, /*[out]*/bool& bPasteAllowed, /*[out]*/ bool& bCopyOperatationIsDefault);
    STDMETHOD(QueryPasteFromClipboard)(/*[in]*/ HNODE hNode, /*[in]*/ BOOL bScope, /*[in]*/ LPARAM lCookie, /*[out]*/bool& bPasteAllowed);
    STDMETHOD(Drop) (/*[in]*/HNODE hNode, /*[in]*/BOOL bScope, /*[in]*/LPARAM lCookie, /*[in]*/IDataObject *pDataObjectToPaste, /*[in]*/BOOL bIsDragOperationMove);
    STDMETHOD(Paste) (/*[in]*/HNODE hNode, /*[in]*/BOOL bScope, /*[in]*/LPARAM lCookie);
    STDMETHOD(QueryViewSettingsPersistor) (/*[out]*/IPersistStream** ppStream);
    STDMETHOD(QueryViewSettingsPersistor) (/*[out]*/CXMLObject** ppXMLObject);
    STDMETHOD(DocumentClosing) ();
    STDMETHOD(GetSnapinName)(/*[in]*/HNODE hNode, /*[out]*/LPOLESTR* ppszName,  /*[out]*/ bool& bValidName); // Given the node get the snapin name
    STDMETHOD(IsDummySnapin)(/*[in]*/HNODE hNode, /*[out]*/bool& bDummySnapin); // Given the node see if it is dummy snapin
    STDMETHOD(DoesStandardSnapinHelpExist)(/*[in]*/HNODE hNode, /*[out]*/bool& bStandardHelpExists); // See if the snapin supports standard MMC help (ISnapinHelp interfaces)

    // snapin property access helpers
    static SC ScGetProperty(IDataObject *pDataObject, BSTR bstrPropertyName, PBSTR  pbstrPropertyValue);
    static SC ScGetNodetype(IDataObject *pDataObject, PBSTR pbstrNodetype);

    static SC ScExtractLVData(CNode* pNodeViewOwner,
                              BOOL bScopePaneSelected,
                              LONG_PTR lvData,
                              CNode** ppSelectedNode,
                              BOOL& bScopeItemSelected,
                              MMC_COOKIE& cookie);
    SC        ScInitializeTempVerbSetForMultiSel(CNode *pNode, CTemporaryVerbSet& tempVerb);

// Notify handlers
private:
    void OnSelect(CNode* pNode, BOOL bSelect, SELECTIONINFO* pSelInfo);
    void OnMultiSelect(CNode* pNode, BOOL bSelect);
    void _OnMultiSelect(CNode* pNode, BOOL bSelect);

    HRESULT OnActvate(CNode* pNode, LONG_PTR arg);
    HRESULT OnDblClk(CNode* pNode, LONG_PTR lvData);
    HRESULT OnContextMenu(CNode* pNode, LONG_PTR arg, LPARAM param);
    HRESULT OnCutCopy(CNode* pNode, BOOL bScope, LPARAM param, BOOL bCut);
    HRESULT OnDelete(CNode* pNode, BOOL bScope, LPARAM lvData);
    HRESULT OnExpand(CNode* pNode, BOOL fExpand);
    HRESULT OnExpanded(CNode* pNode);
    HRESULT OnFindResultItem(CNode* pNode, RESULTFINDINFO* pFindInfo, LRESULT* pResult);
    HRESULT OnMinimize(CNode* pNode, LONG_PTR arg);
    HRESULT OnNewNodeUpdate(CNode* pNode, LONG_PTR lFlags);
    HRESULT OnPrint(CNode* pNode, BOOL bScope, LPARAM lvData);
    HRESULT OnProperties(CNode* pNode, BOOL bScope, LPARAM param);
    HRESULT OnNewTaskpadFromHere(CNode* pNode);
    HRESULT OnEditTaskpad(CNode* pNode);
    HRESULT OnDeleteTaskpad(CNode *pNode);
    HRESULT OnRefresh(CNode* pNode, BOOL bScope, LPARAM lvData);
    HRESULT OnRename(CNode* pNode, SELECTIONINFO* pSelInfo, LPOLESTR pszNewName);
    HRESULT OnScopeSelect(CNode* pNode, BOOL bSelect, SELECTIONINFO* pSelInfo);
    HRESULT OnColumnClicked(CNode* pNode, LONG_PTR nCol);
    HRESULT OnContextHelp(CNode* pNode, BOOL bScope, MMC_COOKIE cookie);
    HRESULT OnSnapInHelp(CNode* pNode, BOOL bScope, MMC_COOKIE cookie);
    HRESULT OnFilterChange(CNode* pNode, LONG_PTR Code, LPARAM nCol);
    HRESULT OnFilterBtnClick(CNode* pNode, LONG_PTR nCol, LPRECT pRect);
    HRESULT OnGetPrimaryTask(CNode* pNode, LPARAM param);
    HRESULT OnGetHelpDoc(HELPDOCINFO* pHelpInfo, LPOLESTR* ppszHelpFile);
    HRESULT OnHasHelpDoc(CNode* pNode);
    HRESULT OnUpdateHelpDoc(HELPDOCINFO* pCurDocInfo, HELPDOCINFO* pNewDocInfo);
    HRESULT OnDeleteHelpDoc(HELPDOCINFO* pHelpInfo);

// Helpers
private:

    HRESULT _InitializeNode(CNode* pNode);

    SC      _ScQueryPaste (CNode *pNode, IDataObject *pTargetDataObject,
                           IDataObject *pSourceDataObject,
                           bool bCanSendMMCNQueryPaste2, bool& bPasteAllowed,
                           bool& bCopyOperatationIsDefault);

    SC      ScPaste (HNODE hNode, BOOL bScope, LPARAM lCookie,
                     IDataObject *pDataObjectToPaste, BOOL bDragDrop,
                     BOOL bIsDragOperationCut);

    SC      _ScPaste (CNode *pNode,
                      IDataObject *pTargetDataObject,
                      IDataObject *pSourceDataObject,
                      IDataObject **ppCutDataObject,
                      bool bCutOrMove);

    SC      _ScGetVerbState(CNode* pNode, MMC_CONSOLE_VERB verb, IDataObject* pDOSel,
                            BOOL bScopePane, LPARAM lResultCookie,
                            BOOL bMultiSelect, BOOL& bIsVerbSet);

    CScopeTree*     m_pCScopeTree;
    CNode*          m_pNodeUnderInit;

};  // CNodeCallback


IFramePrivate* GetIFramePrivateFromNode (CNode* pNode);

inline IFramePrivate* GetIFramePrivateFromNode (HNODE hNode)
    { return (GetIFramePrivateFromNode (CNode::FromHandle(hNode))); }

#endif // _MMC_SCOPNDCB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\siprop.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      siprop.cpp
 *
 *  Contents:  Implementation file for CSnapInPropertiesRoot, et al
 *
 *  History:   04-Nov-99 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "siprop.h"
#include "variant.h"
#include "mtnode.h"


#ifdef DBG
CTraceTag tagSnapInProps(_T("Snap-in Properties"), _T("Snap-in Properties"));
#endif



/*+=========================================================================*/
/*                                                                          */
/*                         CSnapinPropertyComObject                         */
/*                                                                          */
/*==========================================================================*/


/*+-------------------------------------------------------------------------*
 * CSnapinPropertyComObject
 *
 * This is the COM object that exposes the Property object model interface.
 *--------------------------------------------------------------------------*/

class CSnapinPropertyComObject :
    public CMMCIDispatchImpl<Property>, // the Property interface
    public CTiedComObject<CSnapinProperties>
{
    typedef CSnapinProperties CMyTiedObject;

public:
    BEGIN_MMC_COM_MAP(CSnapinPropertyComObject)
    END_MMC_COM_MAP()

public:
    // Property interface
    MMC_METHOD1_PARAM (get_Value, VARIANT* /*pvarValue*/, m_key);
    MMC_METHOD1_PARAM (put_Value, VARIANT  /*varValue*/,  m_key);

    STDMETHODIMP get_Name (BSTR* pbstrName)
    {
        DECLARE_SC (sc, _T("CSnapinPropertyComObject::get_Name"));

        /*
         * validate parameters
         */
        sc = ScCheckPointers (pbstrName);
        if (sc)
            return (sc.ToHr());

        /*
         * copy the name
         */
        *pbstrName = SysAllocString (m_key.data());
        if (*pbstrName == NULL)
            return ((sc = E_OUTOFMEMORY).ToHr());

        return (sc.ToHr());
    }

    void SetKey (const CSnapinProperties::CPropertyKey& key)
        { m_key = key; }

private:
    CSnapinProperties::CPropertyKey m_key;
};


/*+=========================================================================*/
/*                                                                          */
/*                     CSnapinProperties implementation                     */
/*                                                                          */
/*==========================================================================*/


/*+-------------------------------------------------------------------------*
 * CSnapinProperties::FromInterface
 *
 * Returns a pointer to the CSnapinProperties object that implements
 * the given interface, or NULL if the implementing object is not a
 * CSnapinProperties.
 *--------------------------------------------------------------------------*/

CSnapinProperties* CSnapinProperties::FromInterface (IUnknown* pUnk)
{
    CSnapinProperties* pProps;

    /*
     * dynamic_cast will throw if pUnk is junk (i.e. not a real interface
     * pointer and not NULL), so do it in an exception frame.
     */
    try
    {
        pProps = dynamic_cast<CSnapinProperties*>(pUnk);
    }
    catch (...)
    {
        pProps = NULL;
    }

    return (pProps);
}


/*+-------------------------------------------------------------------------*
 * CSnapinProperties::Item
 *
 * Returns an interface to a property identified by bstrName, which must
 * be released by the caller.  If the collection doesn't contain a property
 * with the given name, a new property with the given name (initialized to
 * VT_EMPTY) is added to the collection.
 *
 * Returns:
 *      S_OK            the property was successfully returned
 *      S_FALSE         the property was successfully returned, but didn't
 *                      exist in the collection beforehand, so a new one
 *                      was added
 *      E_INVALIDARG    the property name wasn't valid (i.e. empty) or
 *                      ppProperty was NULL
 *      E_OUTOFMEMORY   not enough memory to perform the operation
 *      E_UNEXPECTED    something dire happened
 *--------------------------------------------------------------------------*/

STDMETHODIMP CSnapinProperties::Item (
    BSTR        bstrName,               /* I:name of property to get        */
    PPPROPERTY  ppProperty)             /* O:interface to property          */
{
    DECLARE_SC (sc, _T("CSnapinProperties::Item"));

    /*
     * validate the parameters
     */
    sc = ScCheckPointers (bstrName, ppProperty);
    if (sc)
        return (sc.ToHr());

    const std::wstring strName = bstrName;
    if (strName.empty())
        return ((sc = E_INVALIDARG).ToHr());

    bool fPropWasAdded = false;

    /*
     * Look up the property.  If it's not there yet, add a new one (maybe).
     */
    if (m_PropMap.find(strName) == m_PropMap.end())
    {
        /*
         * Fail without implicitly adding if we're not attached to a snap-in.
         * This will prevent us from adding properties that weren't
         * registered with AddPropertyName
         */
        if (m_spSnapinProps != NULL)
            return ((sc = ScFromMMC(MMC_E_UnrecognizedProperty)).ToHr());

        /*
         * put an empty property in the map with the given name
         */
        m_PropMap[strName] = CSnapinProperty();
        fPropWasAdded = true;
    }

    /*
     * get a COM object tied to the new property
     */
    sc = ScGetPropertyComObject (strName, *ppProperty);
    if (sc)
        return (sc.ToHr());

    if (*ppProperty == NULL)
        return ((sc = E_UNEXPECTED).ToHr());

    /*
     * if we had to add the property, return S_FALSE so the caller can
     * tell (if he cares)
     */
    if (fPropWasAdded)
        sc = S_FALSE;

    return (sc.ToHr());
}


/*+-------------------------------------------------------------------------*
 * CSnapinProperties::get_Count
 *
 * Returns the number of properties in the collection in *pCount.
 *
 * Returns:
 *
 *      S_OK            success
 *      E_INVALIDARG    pCount is NULL
 *--------------------------------------------------------------------------*/

STDMETHODIMP CSnapinProperties::get_Count (
    PLONG pCount)                   /* O:number of items in the collection  */
{
    DECLARE_SC (sc, _T("CSnapinProperties::get_Count"));

    /*
     * validate the parameters
     */
    sc = ScCheckPointers (pCount);
    if (sc)
        return (sc.ToHr());

    /*
     * return the number of elements in the property map
     */
    *pCount = m_PropMap.size();

    return (sc.ToHr());
}


/*+-------------------------------------------------------------------------*
 * CSnapinProperties::Remove
 *
 * Removes a property from the collection.
 *
 * Returns:
 *      S_OK            the property was successfully removed
 *      S_FALSE         the property didn't exist in the collection
 *      E_INVALIDARG    the property name wasn't valid (i.e. empty)
 *      E_UNEXPECTED    something dire happened
 *--------------------------------------------------------------------------*/

STDMETHODIMP CSnapinProperties::Remove (
    BSTR    bstrName)                   /* I:name of property to remove     */
{
    DECLARE_SC (sc, _T("CSnapinProperties::Remove"));
    Trace (tagSnapInProps, _T("Snap-in Properties"));

    /*
     * validate the parameters
     */
    sc = ScCheckPointers (bstrName);
    if (sc)
        return (sc.ToHr());

    /*
     * find the item to remove
     */
    CPropertyIterator itProp = m_PropMap.find (bstrName);
    if (itProp == m_PropMap.end())
        return ((sc = S_FALSE).ToHr());

    /*
     * see if we can remove it
     */
    if ( itProp->second.IsInitialized() &&
        (itProp->second.GetFlags() & MMC_PROP_REMOVABLE) == 0)
        return ((sc = ScFromMMC(MMC_E_CannotRemoveProperty)).ToHr());

    /*
     * Inform snapin before we remove the property about removal.
     */
    sc = ScNotifyPropertyChange(itProp, itProp->second.GetValue(), MMC_PROPACT_DELETING);
    if (sc)
        return sc.ToHr();

    /*
     * the snap-in approved the change, remove the property
     */
    m_PropMap.erase (itProp);

    return (sc.ToHr());
}


/*+-------------------------------------------------------------------------*
 *
 * CSnapinProperties::ScEnumNext
 *
 * PURPOSE: Returns the next Property interface.
 *
 * PARAMETERS:
 *    _Position & key :
 *    PDISPATCH & pDispatch :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC CSnapinProperties::ScEnumNext (CPropertyKey &key, PDISPATCH & pDispatch)
{
    DECLARE_SC (sc, _T("CSnapinProperties::ScEnumNext"));
    Trace (tagSnapInProps, _T("Snap-in Properties"));

    /*
     * get the next element
     */
    CPropertyIterator it = IteratorFromKey (key, false);

    if(it == m_PropMap.end())
        return (sc = S_FALSE); // out of elements.

    /*
     * get the Properties COM object for this property
     */
    PropertyPtr spProperty;
    sc = ScGetPropertyComObject (it->first, *&spProperty);
    if (sc)
        return (sc);

    if (spProperty == NULL)
        return (sc = E_UNEXPECTED);

    /*
     * return the IDispatch for the object and leave a ref on it for the client
     */
    pDispatch = spProperty.Detach();

    // remember the enumeration key for next time
    key = it->first;

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CSnapinProperties::ScEnumSkip
 *
 * Skips the next celt elements in the properties collection.
 *--------------------------------------------------------------------------*/

SC CSnapinProperties::ScEnumSkip (
    unsigned long   celt,               /* I:number of items to skip        */
    unsigned long&  celtSkipped,        /* O:number of items skipped        */
    CPropertyKey&   key)                /* I/O:enumeration key              */
{
    DECLARE_SC (sc, _T("CSnapinProperties::ScEnumSkip"));
    Trace (tagSnapInProps, _T("Snap-in Properties"));

    /*
     * skip the next celt properties
     */
    CPropertyIterator it = IteratorFromKey (key, false);

    for (celtSkipped = 0;
         (celtSkipped < celt) && (it != m_PropMap.end());
         ++celtSkipped, ++it)
    {
        /*
         * remember the enumeration key for next time
         */
        key = it->first;
    }

    /*
     * if we advanced less than the requested number, return S_FALSE
     */
    if (celtSkipped < celt)
        sc = S_FALSE;

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CSnapinProperties::ScEnumReset
 *
 * Resets a CPropertyKey so that the next item it will return is the
 * first item in the properties collection.
 *--------------------------------------------------------------------------*/

SC CSnapinProperties::ScEnumReset (
    CPropertyKey&  key)                /* I/O:enumeration key to reset     */
{
    DECLARE_SC (sc, _T("CSnapinProperties::ScEnumReset"));

    key.erase();
    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CSnapinProperties::get__NewEnum
 *
 * Creates returns an interface that can be queried for IEnumVARIANT
 *--------------------------------------------------------------------------*/

STDMETHODIMP CSnapinProperties::get__NewEnum (IUnknown** ppUnk)
{
    DECLARE_SC (sc, _T("CSnapinProperties::get__NewEnum"));
    Trace (tagSnapInProps, _T("Snap-in Properties"));

    // validate the parameter
    sc = ScCheckPointers (ppUnk);
    if (sc)
        return (sc.ToHr());

    *ppUnk = NULL;

    // typedef the enumerator
    typedef CComObject<CMMCEnumerator<CSnapinProperties, CPropertyKey> > CEnumerator;

    // create an instance of the enumerator
    CEnumerator *pEnum = NULL;
    sc = CEnumerator::CreateInstance (&pEnum);
    if (sc)
        return (sc.ToHr());

    if(!pEnum)
        return ((sc = E_UNEXPECTED).ToHr());

    // create a connection between the enumerator and ourselves
    sc = ScCreateConnection(*pEnum, *this);
    if(sc)
        return (sc.ToHr());

    // initialize the position using the Reset function
    sc = ScEnumReset (pEnum->m_position);
    if(sc)
        return (sc.ToHr());

    // get the IUnknown to return
    sc = pEnum->QueryInterface (IID_IUnknown, (void**) ppUnk);
    if (sc)
        return (sc.ToHr());

    return (sc.ToHr());
}


/*+-------------------------------------------------------------------------*
 * CSnapinProperties::IteratorFromKey
 *
 * Returns the iterator in the property map corresponding to the first
 * element following the one designated by key.
 *
 * The caller might be interested in an exact match or the nearest match.
 * The nearest match would be suitable when the key is used in an
 * enumeration.  Let's say that the collection consists of "Alpha", "Bravo",
 * and "Charlie".  The first request for an item will return "Alpha" and
 * the key will hold "Alpha" (see comments for CPropertyKey).  Let's
 * assume that "Alpha" is removed from the collection and then the enumeration
 * continues.  We want to return the one after the last one we got back
 * ("Alpha") which would be "Bravo".  All is well.
 *
 * An exact match would be required when trying to find a CSnapinProperty
 * for a CSnapinPropertyComObject.  The COM object will refer to a specific
 * property, which we want to be sure to find every time.  A close match
 * isn't sufficient.
 *--------------------------------------------------------------------------*/

CSnapinProperties::CPropertyIterator
CSnapinProperties::IteratorFromKey (
    const CPropertyKey& key,            /* I:key to convert                 */
    bool                fExactMatch)    /* I:match key exactly?             */
{
    CPropertyIterator it;

    /*
     * need an exact match?
     */
    if (fExactMatch)
    {
        /*
         * nothing matches an empty key
         */
        if (key.empty())
            it = m_PropMap.end();

        /*
         * the key's not empty, look up the property
         */
        else
            it = m_PropMap.find (key);
    }

    /*
     * nearest match
     */
    else
    {
        /*
         * the beginning of the map is nearest an empty key
         */
        if (key.empty())
            it = m_PropMap.begin();

        /*
         * otherwise, find the nearest one greater than the key
         */
        else
            it = m_PropMap.upper_bound (key);
    }


    return (it);
}


/*+-------------------------------------------------------------------------*
 * CSnapinProperties::ScInitialize
 *
 * Initializes a CSnapinProperties.  This function will return an error if
 * psip is NULL, or if there's an error copying the initial properties.
 *--------------------------------------------------------------------------*/

SC CSnapinProperties::ScInitialize (
    ISnapinProperties*  psip,           /* I:snap-in's ISnapinProperties iface  */
    Properties*         pInitProps_,    /* I:initial properties for the snap-in */
    CMTSnapInNode*      pMTSnapInNode)  /* I:snap-in these properties belong to */
{
    DECLARE_SC (sc, _T("CSnapinProperties::ScInitialize"));

    /*
     * validate the parameters
     */
    sc = ScCheckPointers (psip);
    if (sc)
        return (sc);

    /*
     * pInitProps_ is optional, but if it was given, it should be the
     * one implemented by CSnapinProperties
     */
    CSnapinProperties* pInitProps = FromInterface (pInitProps_);
    if ((pInitProps_ != NULL) && (pInitProps == NULL))
        return (sc = E_INVALIDARG);

    /*
     * keep the the snap-in and the snap-in's interface
     */
    m_pMTSnapInNode = pMTSnapInNode;
    m_spSnapinProps = psip;

    /*
     * get the names of the properties recognized by the snap-in
     */
    sc = psip->QueryPropertyNames (this);
    if (sc)
        return (sc);

    /*
     * If we're reloading a snap-in's properties from the console file,
     * weed out entries that the snap-in registered last time but didn't
     * register this time.
     */
    if (pInitProps == this)
    {
        CPropertyIterator itProp = m_PropMap.begin();

        while (itProp != m_PropMap.end())
        {
            /*
             * snap-in registered?  keep it
             */
            if (itProp->second.IsRegisteredBySnapin())
                ++itProp;

            /*
             * snap-in didn't register, toss it
             */
            else
                itProp = m_PropMap.erase (itProp);
        }
    }

    /*
     * Otherwise, if we got initial properties, find each property
     * that the snap-in registered in set of initial properties and
     * copy them to the snap-in's collection.
     */
    else if (pInitProps != NULL)
    {
        sc = ScMergeProperties (*pInitProps);
        if (sc)
            return (sc);
    }

    /*
     * initialize the ISnapinProperties interface
     */
    sc = psip->Initialize (this);
    if (sc)
        return (sc);

    /*
     * give the ISnapinProperties its initial property values
     */
    if (!m_PropMap.empty())
    {
        /*
         * Build an array of CSmartProperty objects to pass to
         * ISnapinProperties::PropertiesChanged.  CSmartProperty objects
         * look just like MMC_SNAPIN_PROPERTY structures, but use a
         * CComVariant instead of VARIANT for automatic resource management.
         * See the definition of CSmartProperty.
         */
        CAutoArrayPtr<CSmartProperty> spInitialProps (
                new (std::nothrow) CSmartProperty[m_PropMap.size()]);

        if (spInitialProps == NULL)
            return (sc = E_OUTOFMEMORY);

        CPropertyIterator it = m_PropMap.begin();
        for (int i = 0; it != m_PropMap.end(); ++it, ++i)
        {
            spInitialProps[i].pszPropName = it->first.data();
            spInitialProps[i].varValue    = it->second.GetValue();
            spInitialProps[i].eAction     = MMC_PROPACT_INITIALIZED;
        }

        /*
         * we don't want to trace a failure here, so use a local SC
         */
        SC scLocal = ScNotifyPropertyChange (spInitialProps, m_PropMap.size());
        if (scLocal)
            return (scLocal);
    }

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CSnapinProperties::ScSetSnapInNode
 *
 * Attaches this properties collection to a CMTSnapInNode.
 *--------------------------------------------------------------------------*/

SC CSnapinProperties::ScSetSnapInNode (CMTSnapInNode* pMTSnapInNode)
{
    DECLARE_SC (sc, _T("CSnapinProperties::ScSetSnapInNode"));

    m_pMTSnapInNode = pMTSnapInNode;

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CSnapinProperties::ScMergeProperties
 *
 * Merges the properties from another property collection into this one.
 * Only properties that already exist in the destination collection are
 * copied from the source.
 *--------------------------------------------------------------------------*/

SC CSnapinProperties::ScMergeProperties (const CSnapinProperties& other)
{
    DECLARE_SC (sc, _T("CSnapinProperties::ScMergeProperties"));

    /*
     * for each property in the other collection...
     */
    CConstPropertyIterator itOtherProp;

    for (itOtherProp  = other.m_PropMap.begin();
        (itOtherProp != other.m_PropMap.end()) && !sc.IsError();
         ++itOtherProp)
    {
        /*
         * look for a corresponding property in the our set
         */
        CPropertyIterator itProp = m_PropMap.find (itOtherProp->first);

        /*
         * if it's in our set, copy its value
         */
        if (itProp != m_PropMap.end())
            sc = itProp->second.ScSetValue (itOtherProp->second.GetValue());
    }

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CSnapinProperties::AddPropertyName
 *
 * This method is called by the snap-in from its implementation of
 * ISnapinProperties::QueryPropertyNames to register the properties it
 * recognizes.
 *--------------------------------------------------------------------------*/

STDMETHODIMP CSnapinProperties::AddPropertyName (
    LPCOLESTR   pszPropName,            /* I:property name                  */
    DWORD       dwFlags)                /* I:flags for this property        */
{
    DECLARE_SC (sc, _T("CSnapinProperties::AddPropertyName"));

    /*
     * validate the parameters
     */
    sc = ScCheckPointers (pszPropName);
    if (sc)
        return (sc.ToHr());

    const std::wstring strName = pszPropName;
    if (strName.empty())
        return ((sc = E_INVALIDARG).ToHr());

    /*
     * make sure no undocumented flags were passed in
     */
    if ((dwFlags & ~CSnapinProperty::PublicFlags) != 0)
        return ((sc = E_INVALIDARG).ToHr());

    /*
     * if the property already exists (from a persisted collection),
     * just update the flags; otherwise add a property with the given
     * name and flags
     */
    CPropertyIterator itProp = m_PropMap.find (strName);

    if (itProp != m_PropMap.end())
        itProp->second.InitializeFlags (dwFlags);
    else
    {
        m_PropMap[strName] = CSnapinProperty(dwFlags);
        m_PropMap[strName].SetRegisteredBySnapin();
    }

    return (sc.ToHr());
}


/*+-------------------------------------------------------------------------*
 * CSnapinProperties::ScNotifyPropertyChange
 *
 * Notifies the snap-in that owns this collection of a change to it's
 * properties.  This function delegates the heavy lifting to
 *
 *      ScNotifyPropertyChange (CSmartProperty*, ULONG);
 *
 *--------------------------------------------------------------------------*/

SC CSnapinProperties::ScNotifyPropertyChange (
    CPropertyIterator   itProp,      /* I:changing property              */
    const VARIANT&      varValue,    /* I:if action is remove then this is current value
                                          else if action is set then this is the proposed value */
    MMC_PROPERTY_ACTION eAction)     /* I:what's happening to the prop?  */
{
    DECLARE_SC (sc, _T("CSnapinProperties::ScNotifyPropertyChange"));

    ASSERT(eAction == MMC_PROPACT_CHANGING || eAction == MMC_PROPACT_DELETING);
    /*
     * validate the parameters
     */
    if (itProp == m_PropMap.end())
        return (sc = E_INVALIDARG);

    /*
     * make sure we're allowed to change the property
     */
    if ( itProp->second.IsInitialized() &&
        (itProp->second.GetFlags() & MMC_PROP_MODIFIABLE) == 0)
        return (sc = ScFromMMC (MMC_E_CannotChangeProperty));

    /*
     * if this property change will affect the UI, and the snap-in
     * isn't awake yet, wake him up
     */
    if ((itProp->second.GetFlags() & MMC_PROP_CHANGEAFFECTSUI) &&
        (m_pMTSnapInNode != NULL) &&
        !m_pMTSnapInNode->IsInitialized())
    {
        sc = m_pMTSnapInNode->Init();
        if (sc)
            return (sc);
    }

    /*
     * we don't want to trace failures here, so don't assign to sc
     */
    CSmartProperty SmartProp (itProp->first.data(), varValue, eAction);
    SC scNoTrace = ScNotifyPropertyChange (&SmartProp, 1);
    if (scNoTrace.ToHr() != S_OK)
        return (scNoTrace);

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CSnapinProperties::ScNotifyPropertyChange
 *
 * Notifies the snap-in that owns this collection of a change to it's
 * properties.
 *
 * The snap-in will return:
 *      S_OK            change was successful
 *      S_FALSE         change was ignored
 *      E_INVALIDARG    a changed property was invalid (e.g. a malformed
 *                      computer name)
 *      E_FAIL          a changed property was valid, but couldn't be used
 *                      (e.g. a valid name for a computer that couldn't be
 *                      located)
 *--------------------------------------------------------------------------*/

SC CSnapinProperties::ScNotifyPropertyChange (
    CSmartProperty* pProps,             /* I:changing props                 */
    ULONG           cProps)             /* I:how many are there?            */
{
    DECLARE_SC (sc, _T("CSnapinProperties::ScNotifyPropertyChange"));

    /*
     * if we're not connected to a snap-in, short out
     */
    if (m_spSnapinProps == NULL)
        return (sc);

    /*
     * validate the parameters
     */
    sc = ScCheckPointers (pProps, E_UNEXPECTED);
    if (sc)
        return (sc);

    if (cProps == 0)
        return (sc = E_UNEXPECTED);

    /*
     * we don't want to trace failures here, so don't assign to sc
     */
    return (m_spSnapinProps->PropertiesChanged (
                            cProps,
                            reinterpret_cast<MMC_SNAPIN_PROPERTY*>(pProps)));
}


/*+-------------------------------------------------------------------------*
 * CSnapinProperties::Scget_Value
 *
 * Returns the value of the property.
 *--------------------------------------------------------------------------*/

SC CSnapinProperties::Scget_Value (VARIANT* pvarValue, const CPropertyKey& key)
{
    DECLARE_SC (sc, _T("CSnapinProperties::Scget_Value"));

    /*
     * validate parameters
     */
    pvarValue = ConvertByRefVariantToByValue (pvarValue);
    sc = ScCheckPointers (pvarValue);
    if (sc)
        return (sc);

    /*
     * get the iterator for the requested property
     */
    CPropertyIterator itProp = IteratorFromKey (key, true);
    if (itProp == m_PropMap.end())
        return (sc = E_INVALIDARG);

    /*
     * give it to the caller
     */
    const VARIANT& varValue = itProp->second.GetValue();
    sc = VariantCopy (pvarValue, const_cast<VARIANT*>(&varValue));
    if (sc)
        return (sc);

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CSnapinProperties::Scput_Value
 *
 * Changes the value of the property.
 *--------------------------------------------------------------------------*/

SC CSnapinProperties::Scput_Value (VARIANT varValue, const CPropertyKey& key)
{
    DECLARE_SC (sc, _T("CSnapinProperties::Scput_Value"));

    /*
     * convert possible by-ref VARIANT
     */
    VARIANT* pvarValue = ConvertByRefVariantToByValue (&varValue);
    sc = ScCheckPointers (pvarValue);
    if (sc)
        return (sc);

    /*
     * make sure this is of the type we can persist
     */
    if (!CXMLVariant::IsPersistable(pvarValue))
        return (sc = E_INVALIDARG);

    /*
     * get the iterator for the requested property
     */
    CPropertyIterator itProp = IteratorFromKey (key, true);
    if (itProp == m_PropMap.end())
        return (sc = E_INVALIDARG);

    /*
     * Notify the snap-in of the proposed change.
     */
    sc = ScNotifyPropertyChange (itProp, *pvarValue, MMC_PROPACT_CHANGING);
    if (sc)
        return sc;

    /*
     * the snap-in approved the change, update the property value
     */
    sc = itProp->second.ScSetValue (*pvarValue);
    if (sc)
        return (sc);

    return sc;
}


/*+-------------------------------------------------------------------------*
 * CSnapinProperties::ScGetPropertyComObject
 *
 * Returns a Property interface on a COM object tied to property identified
 * by key.  The returned interface is a tear-off interface.  The collection
 * will not hold a reference to it, but instead will generate a new object
 * for each request for a Property.
 *--------------------------------------------------------------------------*/

SC CSnapinProperties::ScGetPropertyComObject (
    const CPropertyKey& key,            /* I:the key for this property      */
    Property*&          rpProperty)     /* O:the Property interface         */
{
    DECLARE_SC (sc, _T("CSnapinProperties::ScGetPropertyComObject"));

    /*
     * create a CSnapinPropertyComObject if necessary
     */
    CSnapinPropertyComObject* pComObj = NULL;
    typedef CTiedComObjectCreator<CSnapinPropertyComObject> ObjectCreator;
    sc = ObjectCreator::ScCreateAndConnect (*this, pComObj);
    if (sc)
        return (sc);

    if (pComObj == NULL)
        return (sc = E_UNEXPECTED);

    /*
     * tell the object what its key is
     */
    pComObj->SetKey (key);

    /*
     * put a ref on for the caller (note that the collection will *not*
     * hold a reference to the property)
     */
    rpProperty = pComObj;
    rpProperty->AddRef();

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CSnapinProperties::Persist
 *
 * Persists the property collection to/from an XML persistor.
 *--------------------------------------------------------------------------*/

void CSnapinProperties::Persist (CPersistor &persistor)
{
    if (persistor.IsStoring())
    {
        for (CPropertyIterator it = m_PropMap.begin(); it != m_PropMap.end(); ++it)
        {
            if (it->second.GetFlags() & MMC_PROP_PERSIST)
                PersistWorker (persistor, it);
        }
    }
    else
    {
        /*
         * clear out any existing properties
         */
        m_PropMap.clear();

        // let the base class do the job
        // it will call OnNewElement for every element found
        XMLListCollectionBase::Persist(persistor);
    }
}


/*+-------------------------------------------------------------------------*
 * CSnapinProperties::PersistWorker
 *
 * Persists an individual element of the CPropertyMap to/from an XML
 * persistor.  It exists solely to prevent CSnapinProperties::Persist from
 * calling W2CT (which implicitly calls _alloca) in a loop.
 *--------------------------------------------------------------------------*/

void CSnapinProperties::PersistWorker (CPersistor& persistor, CPropertyIterator it)
{
    USES_CONVERSION;
    persistor.Persist (it->second, W2CT(it->first.data()));
}


/*+-------------------------------------------------------------------------*
 * CSnapinProperties::OnNewElement
 *
 * XMLListCollectionBase::Persist will call this method for every element
 * to be read from the persistor.
 *--------------------------------------------------------------------------*/

void CSnapinProperties::OnNewElement(CPersistor& persistor)
{
    /*
     * read the property name
     */
    std::wstring strName;
    persistor.PersistAttribute (XML_ATTR_SNAPIN_PROP_NAME, strName);

    /*
     * read the property itself
     */
    USES_CONVERSION;
    CSnapinProperty prop;
    persistor.Persist (prop, W2CT(strName.data()));

    /*
     * put the property in the map
     */
    m_PropMap[strName] = prop;
}


/*+=========================================================================*/
/*                                                                          */
/*                      CSnapinProperty implementation                      */
/*                                                                          */
/*==========================================================================*/


/*+-------------------------------------------------------------------------*
 * CSnapinProperty::Persist
 *
 * Persists the property to/from an XML persistor.
 *--------------------------------------------------------------------------*/

void CSnapinProperty::Persist (CPersistor &persistor)
{
    /*
     * persist the value and flags (but not the private ones)
     */
    DWORD dwFlags;

    if (persistor.IsStoring())
        dwFlags = m_dwFlags & ~PrivateFlags;

    persistor.Persist          (m_varValue);
    persistor.PersistAttribute (XML_ATTR_SNAPIN_PROP_FLAGS, dwFlags);

    if (persistor.IsLoading())
        m_dwFlags = dwFlags;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\scoptree.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       ScopTree.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:
//____________________________________________________________________________
//

#ifndef _SCOPTREE_H_
#define _SCOPTREE_H_

class CDocument;
class CNode;
class CMTNode;
class CSPImageCache;
class CMTSnapInNode;
class CExtensionsCache;
class CSnapIn;
class CMultiSelection;
class CConsoleTaskpad;
class CConsoleTaskpadList;
class CDefaultTaskpadList;
class CConsoleFrame;
class CNewTreeNode;

typedef CNewTreeNode*  PNEWTREENODE;
typedef CList <PNEWTREENODE, PNEWTREENODE> NewNodeList;
typedef CList<HMTNODE, HMTNODE> CHMTNODEList;
typedef CTypedPtrList<MMC::CPtrList, CMTNode*> CMTNodeList;
typedef CList<CMTNode*, CMTNode*> MTNodesList;
typedef std::map<CMTNode*, PNODE> CMapMTNodeToMMCNode;

typedef CMTSnapInNode * PMTSNAPINNODE;

// forward declarations for external classes
class CBookmark;


/*+-------------------------------------------------------------------------*
 * class CMMCScopeNode
 *
 *
 * PURPOSE: Implements the Node automation interface, for a scope node
 *
 *+-------------------------------------------------------------------------*/
class CMMCScopeNode :
    public CMMCIDispatchImpl<Node>
{
    friend class CScopeTree;

public:
    BEGIN_MMC_COM_MAP(CMMCScopeNode)
    END_MMC_COM_MAP()

    // Node methods
public:
    STDMETHODIMP get_Name( PBSTR  pbstrName);
    STDMETHODIMP get_Property( BSTR PropertyName, PBSTR  PropertyValue);
    STDMETHODIMP get_Bookmark( PBSTR pbstrBookmark);
    STDMETHODIMP IsScopeNode(PBOOL pbIsScopeNode);
    STDMETHODIMP get_Nodetype(PBSTR Nodetype);


    // determines whether the object is valid or not.
    ::SC  ScIsValid();

    ~CMMCScopeNode();
public: // accessors
    CMTNode *GetMTNode() {return m_pMTNode;}
    void ResetMTNode()   {m_pMTNode = NULL;}

private:
    ::SC ScGetDataObject(IDataObject **ppDataObject); // returns the data object for the underlying scope node.

private: // implementation
    CMTNode *m_pMTNode;
};


//____________________________________________________________________________
//
//  class:      CScopeTree
//____________________________________________________________________________
//
class CScopeTree :
    public IScopeTree,
    public IPersistStorage,
    public CComObjectRoot,
    public CComCoClass<CScopeTree, &CLSID_ScopeTree>,
    public CTiedObject
{

// Constructor/Destructor
public:
    CScopeTree();
    ~CScopeTree();


public:
#ifdef DBG
    ULONG InternalAddRef()
    {
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        return CComObjectRoot::InternalRelease();
    }
    int dbg_InstID;
#endif // DBG


// ATL Map
public:
BEGIN_COM_MAP(CScopeTree)
    COM_INTERFACE_ENTRY(IScopeTree)
    COM_INTERFACE_ENTRY(IPersistStorage)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CScopeTree)

DECLARE_MMC_OBJECT_REGISTRATION (
    g_szMmcndmgrDll,                    // implementing DLL
    CLSID_ScopeTree,                    // CLSID
    _T("ScopeTree 1.0 Object"),         // class name
    _T("NODEMGR.ScopeTreeObject.1"),    // ProgID
    _T("NODEMGR.ScopeTreeObject"))      // version-independent ProgID

private: // Object model related tied COM objects
    SnapInsPtr        m_spSnapIns;
    ScopeNamespacePtr m_spScopeNamespace;

public: // Object model methods
    // SnapIns interface
    typedef PMTSNAPINNODE CSnapIns_Positon;
    CMTSnapInNode *GetNextStaticNode(CMTNode *pMTNode);

    SC      ScAdd (BSTR bstrSnapinNameOrCLSID, VARIANT varParentSnapin,
                   VARIANT varProperties, SnapIn** ppSnapIn); // add a snap-in.
    SC      ScItem(long Index, PPSNAPIN ppSnapIn);
    SC      ScRemove(PSNAPIN pSnapIn);
    SC      Scget_Count(PLONG pCount);

    // SnapIns enumerator
    SC      ScGetNextSnapInPos(CSnapIns_Positon &pos); // helper function

    SC      ScEnumNext(CSnapIns_Positon &pos, PDISPATCH & pDispatch);
    SC      ScEnumSkip(unsigned long celt, unsigned long& celtSkipped, CSnapIns_Positon &pos);
    SC      ScEnumReset(                   CSnapIns_Positon &pos);

    // ScopeNamespace interface
    SC      ScGetParent(PNODE pNode, PPNODE ppChild);
    SC      ScGetChild(PNODE pNode, PPNODE ppChild);
    SC      ScGetNext(PNODE pNode, PPNODE ppNext);
    SC      ScGetRoot(PPNODE ppRoot);
    SC      ScExpand(PNODE pNode);


    // helpers
private:
    SC      ScGetNode(CMTNode *pMTNode, PPNODE ppOut); // creates a Node interface object for the given MTNode.
    SC      ScGetRootNode(PPNODE ppRootNode);          // Calls above method to get to Root node.

public:
    SC      ScGetNode(PNODE pNode, CMTNode **ppMTNodeOut);

// Operations
public:
    // IScopeTree methods
    STDMETHOD(Initialize)(HWND hwndFrame, IStringTablePrivate* pStringTable);
    STDMETHOD(QueryIterator)(IScopeTreeIter** ppIter);
    STDMETHOD(QueryNodeCallback)(INodeCallback** ppNodeCallback);
    STDMETHOD(CreateNode)(HMTNODE hMTNode, LONG_PTR lViewData, BOOL fRootNode,
                          HNODE* phNode);

    STDMETHOD(CloseView)(int nView);
    STDMETHOD(DeleteView)(int nView);
    STDMETHOD(DestroyNode)(HNODE hNode);
    STDMETHOD(Find)(MTNODEID mID, HMTNODE*  hMTNode);
    STDMETHOD(Find)(MTNODEID mID, CMTNode** ppMTNode);
    STDMETHOD(GetImageList)(PLONG_PTR pImageList);
    STDMETHOD(RunSnapIn)(HWND hwndParent);
    STDMETHOD(GetFileVersion)(IStorage* pstgRoot, int* pnVersion);
    STDMETHOD(GetNodeIDFromBookmark)(HBOOKMARK hbm, MTNODEID* pID, bool& bExactMatchFound);
    STDMETHOD(GetNodeIDFromStream)(IStream *pStm, MTNODEID* pID);
    STDMETHOD(GetNodeFromBookmark)(HBOOKMARK hbm, CConsoleView *pConsoleView, PPNODE ppNode, bool& bExactMatchFound); // get the node from bookmark
    STDMETHOD(GetIDPath)(MTNODEID id, MTNODEID** ppIDs, long* pLength);
    STDMETHOD(IsSynchronousExpansionRequired)();
    STDMETHOD(RequireSynchronousExpansion)(BOOL fRequireSyncExpand);
    STDMETHOD(SetConsoleData)(LPARAM lConsoleData);
    STDMETHOD(GetPathString)(HMTNODE hmtnRoot, HMTNODE hmtnLeaf, LPOLESTR* pPath);
    STDMETHOD(QuerySnapIns)(SnapIns **ppSnapIns);
    STDMETHOD(QueryScopeNamespace)(ScopeNamespace **ppScopeNamespace);
    STDMETHOD(CreateProperties)(Properties** ppProperties);
    STDMETHOD(GetNodeID)(PNODE pNode, MTNODEID *pID);
    STDMETHOD(GetHMTNode)(PNODE pNode, HMTNODE *phMTNode);
    STDMETHOD(GetMMCNode)(HMTNODE hMTNode, PPNODE ppNode);
    STDMETHOD(QueryRootNode)(PPNODE ppNode);
    STDMETHOD(IsSnapinInUse)(REFCLSID refClsidSnapIn, PBOOL pbInUse);

    STDMETHOD(Persist)(HPERSISTOR pPersistor);

    // IPersistStorage methods
    STDMETHOD(HandsOffStorage)(void);
    STDMETHOD(InitNew)(IStorage *pStg);
    STDMETHOD(IsDirty)(void);
    STDMETHOD(Load)(IStorage *pStg);
    STDMETHOD(Save)(IStorage *pStg, BOOL fSameAsLoad);
    STDMETHOD(SaveCompleted)(IStorage *pStg);

    // IPersist method
    STDMETHOD(GetClassID)(CLSID *pClassID);

    // snap-in addition and removal
    SC      ScAddOrRemoveSnapIns(MTNodesList * pmtnDeletedList, NewNodeList * pnnList);
public:
    SC      ScAddSnapin(LPCWSTR szSnapinNameOrCLSID, SnapIn* pParentSnapinNode, Properties* varProperties, SnapIn*& rpSnapIn);


private: // taskpad persistence
    HRESULT LoadTaskpadList(IStorage *pStg);

// Attributes
public:
    CMTNode* GetRoot(void);
    CSPImageCache* GetImageCache(void) { return m_pImageCache; }

    /*
     * convenient, type-safe alternative to IScopeTree::GetImageList
     */
    HIMAGELIST GetImageList () const;

// Operations
    SC   ScInsert(LPSCOPEDATAITEM pSDI, COMPONENTID nID,
                   CMTNode** ppMTNodeNew);
    SC   ScInsert(CMTNode* pmtnParent, CMTNode* pmtnToInsert);
    SC   ScDelete(CMTNode* pmtn, BOOL fDeleteThis, COMPONENTID nID);
    void DeleteNode(CMTNode* pmtn);
    void UpdateAllViews(LONG lHint, LPARAM lParam);
    void Cleanup(void);

    HWND GetMainWindow()
    {
        return (m_pConsoleData->m_hwndMainFrame);
    }

    static IStringTablePrivate* GetStringTable()
    {
        return (m_spStringTable);
    }

    static bool _IsSynchronousExpansionRequired()
    {
        return (m_fRequireSyncExpand);
    }

    static void _RequireSynchronousExpansion(bool fRequireSyncExpand)
    {
        m_fRequireSyncExpand = fRequireSyncExpand;
    }

    static CScopeTree* GetScopeTree()
    {
        return (m_pScopeTree);
    }

    PersistData* GetPersistData() const
    {
        return m_spPersistData;
    }

    SConsoleData* GetConsoleData() const
    {
        return m_pConsoleData;
    }

    CConsoleFrame* GetConsoleFrame() const
    {
        return ((m_pConsoleData != NULL) ? m_pConsoleData->GetConsoleFrame() : NULL);
    }

    CConsoleTaskpadList* GetConsoleTaskpadList() const
    {
        return (m_pConsoleTaskpads);
    }

    CDefaultTaskpadList* GetDefaultTaskpadList() const
    {
        return (m_pDefaultTaskpads);
    }

    SC ScSetHelpCollectionInvalid();

    HRESULT InsertConsoleTaskpad (CConsoleTaskpad *pConsoleTaskpad,
                                  CNode *pNodeTarget, bool bStartTaskWizard);

    SC ScUnadviseMTNode(CMTNode* pMTNode);  // called from ~CMTNode()
    SC ScUnadviseMMCScopeNode(PNODE pNode); // called from ~MMCScopeNode();

// Implementation
private:
    // the one and only CScopeTree for this console
    static CScopeTree*      m_pScopeTree;
    CMTNode*                m_pMTNodeRoot;
    CSPImageCache*          m_pImageCache;
    PersistDataPtr          m_spPersistData;
    CMTNodeList             m_MTNodesToBeReset;
    SConsoleData*           m_pConsoleData;
    CConsoleTaskpadList*    m_pConsoleTaskpads;
    CDefaultTaskpadList*    m_pDefaultTaskpads;
    CMapMTNodeToMMCNode     m_mapMTNodeToMMCNode;

    static bool                     m_fRequireSyncExpand;
    static IStringTablePrivatePtr   m_spStringTable;

    CMTNode* _FindLastChild(CMTNode* pMTNodeParent);
    CMTNode* _FindPrev(CMTNode* pMTNode);
    void _DeleteNode(CMTNode* pmtn);
    void _GetPathString(CMTNode* pmtnRoot, CMTNode* pmtnCur, CStr& strPath);
    void DeleteDynamicNodes(CMTNode* pMTNode);
    BOOL ExtensionsHaveChanged(CMTSnapInNode* pMTSINode);
    void HandleExtensionChanges(CMTNode* pMTNode);

// Not implemented
    CScopeTree(const CScopeTree& rhs);
    CScopeTree& operator= (const CScopeTree& rhs);

};  // CScopeTree

#endif // _SCOPTREE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\scopndcb.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       scopndcb.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "scopndcb.h"
#include "oncmenu.h"
#include "util.h"
#include "amcmsgid.h"
#include "multisel.h"
#include "nmutil.h"
#include "nodemgr.h"
#include "copypast.h"
#include "regutil.h"
#include "taskenum.h"
#include "nodepath.h"
#include "rsltitem.h"
#include "bookmark.h"
#include "tasks.h"
#include "viewpers.h"
#include "colwidth.h"
#include "conframe.h"
#include "constatbar.h"
#include "about.h"
#include "conview.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//############################################################################
//############################################################################
//
//  Trace Tags
//
//############################################################################
//############################################################################
#ifdef DBG
CTraceTag tagNodeCallback(TEXT("NodeCallback"), TEXT("NodeCallback"));
#endif


void AddSubmenu_CreateNew(IContextMenuProvider* pICMP, BOOL fStaticFolder );
void AddSubmenu_Task(IContextMenuProvider* pICMP );

DEBUG_DECLARE_INSTANCE_COUNTER(CNodeCallback);

#define INVALID_COMPONENTID     -9


void DeleteMultiSelData(CNode* pNode)
{
    ASSERT(pNode != NULL);
    ASSERT(pNode->GetViewData() != NULL);
    CMultiSelection* pMultiSel = pNode->GetViewData()->GetMultiSelection();
    if (pMultiSel != NULL)
    {
        pMultiSel->ReleaseMultiSelDataObject();
        pMultiSel->Release();
        pNode->GetViewData()->SetMultiSelection(NULL);
    }
}

CNodeCallback::CNodeCallback()
    :   m_pCScopeTree(NULL), m_pNodeUnderInit(NULL)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CNodeCallback);
}

CNodeCallback::~CNodeCallback()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CNodeCallback);
}

STDMETHODIMP CNodeCallback::Initialize(IScopeTree* pScopeTree)
{
    MMC_TRY

    IF_NULL_RETURN_INVALIDARG(pScopeTree);

    m_pCScopeTree = dynamic_cast<CScopeTree*>(pScopeTree);
    ASSERT(m_pCScopeTree != NULL);

    return S_OK;

    MMC_CATCH
}

STDMETHODIMP CNodeCallback::GetImages(HNODE hNode, int* piImage, int* piSelectedImage)
{
    IF_NULL_RETURN_INVALIDARG(hNode);

    MMC_TRY

    // They should ask for at least one of the images.
    if (piImage == NULL && piSelectedImage == NULL)
        return E_INVALIDARG;

    // convert to real type
    CNode* pNode = CNode::FromHandle(hNode);

    if (piImage != NULL)
        *piImage = pNode->GetMTNode()->GetImage();

    if (piSelectedImage != NULL)
        *piSelectedImage = pNode->GetMTNode()->GetOpenImage();

    return S_OK;

    MMC_CATCH
}

STDMETHODIMP CNodeCallback::GetDisplayName(HNODE hNode, tstring& strName)
{
    DECLARE_SC (sc, _T("CNodeCallback::GetDisplayName"));

    /*
     * clear out the output string
     */
    strName.erase();

    // convert to real type
    CNode* pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers (pNode);
    if (sc)
        return (sc.ToHr());

    strName = pNode->GetDisplayName();
    return (sc.ToHr());
}


STDMETHODIMP CNodeCallback::GetWindowTitle(HNODE hNode, tstring& strTitle)
{
    DECLARE_SC (sc, _T("CNodeCallback::GetWindowTitle"));

    /*
     * clear out the output string
     */
    strTitle.erase();

    // convert to real type
    CNode* pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers (pNode);
    if (sc)
        return (sc.ToHr());

    CComponent* pCC = pNode->GetPrimaryComponent();
    sc = ScCheckPointers (pCC, E_UNEXPECTED);
    if (sc)
        return (sc.ToHr());

    IDataObjectPtr spdtobj;
    sc = pCC->QueryDataObject(MMC_WINDOW_COOKIE, CCT_UNINITIALIZED, &spdtobj);
    if (sc)
        return (sc.ToHr());

    USES_CONVERSION;
    static CLIPFORMAT cfWindowTitle =
            (CLIPFORMAT) RegisterClipboardFormat(OLE2T(CCF_WINDOW_TITLE));

    sc = ExtractString(spdtobj, cfWindowTitle, strTitle);
    if (sc)
        return (sc.ToHr());

    return (sc.ToHr());
}

inline HRESULT CNodeCallback::_InitializeNode(CNode* pNode)
{
    ASSERT(pNode != NULL);

    m_pNodeUnderInit = pNode;
    HRESULT hr = pNode->InitComponents();
    m_pNodeUnderInit = NULL;
    return hr;
}

STDMETHODIMP CNodeCallback::GetResultPane(HNODE hNode, CResultViewType& rvt, GUID *pGuidTaskpadID)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::GetResultPane"));

    IF_NULL_RETURN_INVALIDARG(hNode);

    MMC_TRY
    USES_CONVERSION;

    // convert to real type
    CNode* pNode = CNode::FromHandle(hNode);
    ASSERT(pNode != NULL);

    if (pNode->IsInitialized() == FALSE)
    {
        sc = _InitializeNode(pNode);
        if(sc)
            return sc.ToHr();
    }

    sc = pNode->ScGetResultPane(rvt, pGuidTaskpadID);
    if(sc)
        return sc.ToHr();

    return sc.ToHr();

    MMC_CATCH
}

//
// 'hNodeSel' is the curreently selected node in the scope pane. 'lDispInfo' is
// the LV disp info struct.
STDMETHODIMP CNodeCallback::GetDispInfo(HNODE hNodeSel, LV_ITEMW* plvi)
{
    IF_NULL_RETURN_INVALIDARG2(hNodeSel, plvi);

    if (theApp.ProcessingSnapinChanges() == TRUE)
        return E_FAIL;

    // convert to real types
    CNode* pNodeSel = CNode::FromHandle(hNodeSel);

    if (IsBadWritePtr (plvi, sizeof(*plvi)))
        return E_INVALIDARG;

    return pNodeSel->GetDispInfoForListItem(plvi);
}


STDMETHODIMP CNodeCallback::AddCustomFolderImage (HNODE hNode, IImageListPrivate* pImageList)
{
    CNode* pNode = CNode::FromHandle(hNode);
    if (pNode) {
        CSnapInNode* pSINode = dynamic_cast<CSnapInNode*>(pNode);
        if (pSINode)
            pSINode->SetResultImageList (pImageList);
    }
    return S_OK;
}

STDMETHODIMP CNodeCallback::GetState(HNODE hNode, UINT* pnState)
{
    IF_NULL_RETURN_INVALIDARG2(hNode, pnState);

    MMC_TRY

    // convert to real type
    CNode* pNode = CNode::FromHandle(hNode);

    *pnState = pNode->GetMTNode()->GetState();

    return S_OK;

    MMC_CATCH
}

STDMETHODIMP CNodeCallback::Notify(HNODE hNode, NCLBK_NOTIFY_TYPE event,
                                   LONG_PTR arg, LPARAM param)
{
    MMC_TRY

    HRESULT hr = S_OK;

    if (hNode == NULL)
    {
        switch (event)
        {
        case NCLBK_CONTEXTMENU:
            // Process further.
            break;

        case NCLBK_GETHELPDOC:
            return OnGetHelpDoc((HELPDOCINFO*)arg, (LPOLESTR*)param);

        case NCLBK_UPDATEHELPDOC:
            return OnUpdateHelpDoc((HELPDOCINFO*)arg, (HELPDOCINFO*)param);

        case NCLBK_DELETEHELPDOC:
            return OnDeleteHelpDoc((HELPDOCINFO*)arg);

            // When the view is closed and NCLBK_SELECT is sent with HNODE NULL (as
            // there is no selected node) handle this case.
        case NCLBK_SELECT:
            return S_OK;

        default:
            return E_INVALIDARG;
        }
    }

    // convert to real type
    CNode* pNode = CNode::FromHandle(hNode);

    if (m_pNodeUnderInit && pNode && (m_pNodeUnderInit == pNode))
        return E_FAIL;

    // See if snapin-cache is being modified.
    if (theApp.ProcessingSnapinChanges() == TRUE)
    {
        // If it is selection/de-selection of node then do not return error
        // after the modifications are done (for snapin-cache) the node will
        // be selected.
        if ( (event == NCLBK_SELECT) ||
             (event == NCLBK_MULTI_SELECT) )
             return S_OK;
        else
            return E_FAIL;
    }

    switch (event)
    {
    case NCLBK_ACTIVATE:
        hr = OnActvate(pNode, arg);
        break;

    case NCLBK_CACHEHINT:
        pNode->OnCacheHint(arg, param);
        break;

    case NCLBK_CLICK:
        ASSERT(0);
        break;

    case NCLBK_CONTEXTMENU:
        hr = OnContextMenu(pNode, arg, param);
        break;

    case NCLBK_DBLCLICK:
        hr = OnDblClk(pNode, arg);
        break;

    case NCLBK_CUT:
    case NCLBK_COPY:
        OnCutCopy(pNode, static_cast<BOOL>(arg), param, (event == NCLBK_CUT));
        break;

    case NCLBK_DELETE:
        {
            hr = OnDelete(pNode, arg, param);

            // 5. Purge the snapin cache
            CSnapInsCache* pSnapInCache = theApp.GetSnapInsCache();
            ASSERT(pSnapInCache != NULL);
            if (pSnapInCache != NULL)
                pSnapInCache->Purge();
        }
        break;

    case NCLBK_EXPAND:
        hr = OnExpand(pNode, arg);
        break;

    case NCLBK_EXPANDED:
        hr = OnExpanded(pNode);
        break;

    case NCLBK_GETEXPANDEDVISUALLY:
        hr = (pNode->WasExpandedVisually() == true) ? S_OK : S_FALSE;
        break;

    case NCLBK_SETEXPANDEDVISUALLY:
        pNode->SetExpandedVisually(static_cast<bool>(arg));
        break;

    case NCLBK_PROPERTIES:
        hr = OnProperties(pNode, static_cast<BOOL>(arg), param);
        break;

    case NCLBK_REFRESH:
        hr = OnRefresh(pNode, static_cast<BOOL>(arg), param);
        break;

    case NCLBK_NEW_TASKPAD_FROM_HERE:
        hr = OnNewTaskpadFromHere(pNode);
        break;

    case NCLBK_EDIT_TASKPAD:
        hr = OnEditTaskpad(pNode);
        break;

    case NCLBK_DELETE_TASKPAD:
        hr = OnDeleteTaskpad(pNode);
        break;

    case NCLBK_PRINT:
        hr = OnPrint(pNode, static_cast<BOOL>(arg), param);
        break;

    case NCLBK_NEW_NODE_UPDATE:
        hr = OnNewNodeUpdate(pNode, arg);
        break;

    case NCLBK_RENAME:
        hr = OnRename(pNode, reinterpret_cast<SELECTIONINFO*>(arg),
                      reinterpret_cast<LPOLESTR>(param));
        break;

    case NCLBK_MULTI_SELECT:
        OnMultiSelect(pNode, static_cast<BOOL>(arg));
        break;

    case NCLBK_SELECT:
        OnSelect(pNode, static_cast<BOOL>(arg),
                 reinterpret_cast<SELECTIONINFO*>(param));
        break;

    case NCLBK_FINDITEM:
        OnFindResultItem(pNode, reinterpret_cast<RESULTFINDINFO*>(arg),
                         reinterpret_cast<LRESULT*>(param));
        break;

    case NCLBK_COLUMN_CLICKED:
        hr = OnColumnClicked(pNode, param);
        break;

    case NCLBK_CONTEXTHELP:
        hr = OnContextHelp(pNode, static_cast<BOOL>(arg), param);
        break;

    case NCLBK_SNAPINHELP:
        hr = OnSnapInHelp(pNode, static_cast<BOOL>(arg), param);
        break;

    case NCLBK_FILTER_CHANGE:
        hr = OnFilterChange(pNode, arg, param);
        break;

    case NCLBK_FILTERBTN_CLICK:
        hr = OnFilterBtnClick(pNode, arg, reinterpret_cast<LPRECT>(param));
        break;

    case NCLBK_TASKNOTIFY:
        pNode->OnTaskNotify(arg, param);
        break;

    case NCLBK_GETPRIMARYTASK:
        hr = OnGetPrimaryTask (pNode, param);
        break;

    case NCLBK_MINIMIZED:
        hr = OnMinimize (pNode, arg);
        break;

    case NCLBK_LISTPAD:
        hr = pNode->OnListPad(arg, param);
        break;

    case NCLBK_WEBCONTEXTMENU:
        pNode->OnWebContextMenu();
        break;

    default:
        ASSERT(FALSE);
        break;
    }

    return hr;

    MMC_CATCH
}


STDMETHODIMP CNodeCallback::GetMTNode(HNODE hNode, HMTNODE* phMTNode)
{
    IF_NULL_RETURN_INVALIDARG2(hNode, phMTNode);

    MMC_TRY

    // convert to real type
    CNode* pNode = CNode::FromHandle(hNode);

    *phMTNode = CMTNode::ToHandle(pNode->GetMTNode());

    return S_OK;

    MMC_CATCH
}

STDMETHODIMP CNodeCallback::SetResultItem(HNODE hNode, HRESULTITEM hri)
{
    IF_NULL_RETURN_INVALIDARG(hNode);

    MMC_TRY

    // convert to real type
    CNode* pNode = CNode::FromHandle(hNode);
    pNode->SetResultItem(hri);
    return S_OK;

    MMC_CATCH
}

STDMETHODIMP CNodeCallback::GetResultItem(HNODE hNode, HRESULTITEM* phri)
{
    IF_NULL_RETURN_INVALIDARG(hNode);

    MMC_TRY

    // convert to real type
    CNode* pNode = CNode::FromHandle(hNode);
    *phri = pNode->GetResultItem();
    return S_OK;

    MMC_CATCH
}

STDMETHODIMP CNodeCallback::GetMTNodeID(HNODE hNode, MTNODEID* pnID)
{
    IF_NULL_RETURN_INVALIDARG(pnID);

    MMC_TRY

    // convert to real type
    CNode* pNode = CNode::FromHandle(hNode);

    *pnID = pNode->GetMTNode()->GetID();

    return S_OK;

    MMC_CATCH
}

/*+-------------------------------------------------------------------------*
 *
 * CNodeCallback::IsTargetNodeOf
 *
 * PURPOSE: Is one node a target of another
 *
 * PARAMETERS:
 *    HNODE  hNode :    The node that contains the target
 *    HNODE  hTestNode : The alleged target
 *
 * RETURNS:
 *    STDMETHODIMP
 *          S_OK    - yes
 *          S_FALSE - uses a different target node
 *          E_FAIL  - doesn't use a target node
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP CNodeCallback::IsTargetNodeOf(HNODE hNode, HNODE hTestNode)
{
    MMC_TRY

    ASSERT(hNode && hTestNode);

    CNode* pNode = CNode::FromHandle(hNode);
    CNode* pTestNode = CNode::FromHandle(hTestNode);
    ASSERT(pNode);

    return pNode->IsTargetNode(pTestNode);

    MMC_CATCH
}


STDMETHODIMP CNodeCallback::GetPath(HNODE hNode, HNODE hRootNode,
                                    LPBYTE pbm)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::GetPath"));

    sc = ScCheckPointers((PVOID)hNode, (PVOID)hRootNode, pbm);
    if(sc)
        return sc.ToHr();

    MMC_TRY

    // convert to real type
    CNode* pNode     = CNode::FromHandle(hNode);
    CNode* pRootNode = CNode::FromHandle(hRootNode);
    CBookmark* pbmOut   = reinterpret_cast<CBookmark *>(pbm);

    CBookmarkEx bm;

    sc = bm.ScInitialize(pNode->GetMTNode(), pRootNode->GetMTNode(), true).ToHr();
    if(sc)
        return sc.ToHr();

    // set the out parameter.
    *pbmOut = bm;

    return sc.ToHr();

    MMC_CATCH
}

STDMETHODIMP CNodeCallback::GetStaticParentID(HNODE hNode, MTNODEID* pnID)
{
    IF_NULL_RETURN_INVALIDARG2(hNode, pnID);

    MMC_TRY

    // convert to real type
    CNode* pNode = CNode::FromHandle(hNode);
    CMTNode* pMTNode = pNode->GetMTNode();
    ASSERT(pMTNode != NULL);

    while (pMTNode != NULL && pMTNode->IsStaticNode() == FALSE)
    {
        pMTNode = pMTNode->Parent();
    }

    ASSERT(pMTNode != NULL);

    if (pMTNode != NULL)
    {
        *pnID = pMTNode->GetID();
        return S_OK;
    }

    return E_UNEXPECTED;

    MMC_CATCH
}

// The path for the node is stored in pphMTNode. The path is an array of
// HMTNODE's starting from the console root, followed by its child node and
// continuing in this fashion till the HMTNODE of the root node.
STDMETHODIMP CNodeCallback::GetMTNodePath(HNODE hNode, HMTNODE** pphMTNode,
                                          long* plLength)
{
    IF_NULL_RETURN_INVALIDARG3(hNode, pphMTNode, plLength);

    MMC_TRY

    // convert to real type
    CNode* pNode = CNode::FromHandle(hNode);

    CMTNode* pMTNode = pNode->GetMTNode();
    pMTNode = pMTNode->Parent(); // skip this node

    for (*plLength = 0; pMTNode != NULL; pMTNode = pMTNode->Parent())
        ++(*plLength);

    if (*plLength != 0)
    {
        HMTNODE* phMTNode = (HMTNODE*)CoTaskMemAlloc(sizeof(HMTNODE) *
                                                              (*plLength));
        if (phMTNode == NULL)
        {
            CHECK_HRESULT(E_OUTOFMEMORY);
            return E_OUTOFMEMORY;
        }

        *pphMTNode = phMTNode;

        pMTNode = pNode->GetMTNode();
        pMTNode = pMTNode->Parent(); // skip this node

        phMTNode = phMTNode + (*plLength - 1);

        for (; pMTNode != NULL; pMTNode = pMTNode->Parent(), --phMTNode)
            *phMTNode = CMTNode::ToHandle(pMTNode);

        ASSERT(++phMTNode == *pphMTNode);
    }
    else
    {
        pphMTNode = NULL;
    }

    return S_OK;

    MMC_CATCH
}


/*+-------------------------------------------------------------------------*
 *
 * CNodeCallback::GetNodeOwnerID
 *
 * PURPOSE: Get the ID of the snap-in component that owns this node.
 *          If not a snap-in owned node, TVOWNED_MAGICWORD is returned.
 *
 * PARAMETERS:
 *    HNODE  hNode :  Node to query
 *    COMPONENTID* :  ptr to returned ID
 *
 * RETURNS:
 *    STDMETHODIMP
 *          S_OK         - ID returned
 *          E_INVALIDARG -
 *          E_FAIL       - probably an invalid hNode
 *
 *+-------------------------------------------------------------------------*/

/*******************************************************************************
 * >>>>>>>>>>>>>> READ THIS BEFORE USING GetNodeOwnerID <<<<<<<<<<<<<<<<<<<<<<<
 *
 * This method differs from the GetOwnerID method exposed by CNode (and CMTNode)
 * in that it returns a zero ID for snap-in static nodes, indicating that the
 * owner is the snap-in primary component. The CNode method returns
 * TVOWNED_MAGICWORD for snap-in static nodes, inidcating MMC ownership. For
 * most purposes the zero ID is more appropriate and I think the node method
 * should be changed. This requires looking at all uses of the owner ID and
 * verifying nothing will break.    rswaney 5/5/99
 *******************************************************************************/

STDMETHODIMP CNodeCallback::GetNodeOwnerID(HNODE hNode, COMPONENTID* pOwnerID)
{
    IF_NULL_RETURN_INVALIDARG2(hNode, pOwnerID);

    MMC_TRY

    CNode* pNode = CNode::FromHandle(hNode);

    if (pNode->IsStaticNode())
        *pOwnerID = 0;
    else
        *pOwnerID = pNode->GetOwnerID();

    return S_OK;

    MMC_CATCH
}


STDMETHODIMP CNodeCallback::GetNodeCookie(HNODE hNode, MMC_COOKIE* pCookie)
{
    IF_NULL_RETURN_INVALIDARG2(hNode, pCookie);

    MMC_TRY

    // only dynamic nodes have cookies
    CNode* pNode = CNode::FromHandle(hNode);
    if (!pNode->IsDynamicNode())
        return E_FAIL;

    *pCookie = pNode->GetUserParam();

    return S_OK;

    MMC_CATCH
}


/*+-------------------------------------------------------------------------*
 *
 * CNodeCallback::GetControl
 *
 * PURPOSE:       See if there is a OCX with given CLSID for the given node.
 *                If so return it.
 *
 * PARAMETERS:
 *    HNODE       hNode :
 *    CLSID       clsid :
 *    IUnknown ** ppUnkControl :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CNodeCallback::GetControl(HNODE hNode, CLSID clsid, IUnknown **ppUnkControl)
{
    MMC_TRY
    DECLARE_SC(sc, TEXT("CNodeCallback::GetControl"));

    sc = ScCheckPointers((void *)hNode, ppUnkControl);
    if(sc)
        return sc.ToHr();

    // convert to real type
    CNode* pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc.ToHr();

    *ppUnkControl = pNode->GetControl(clsid);
    if(!*ppUnkControl)
        return sc.ToHr();

    // addref the interface for the client.

    (*ppUnkControl)->AddRef();

    return sc.ToHr();

    MMC_CATCH
}

/*+-------------------------------------------------------------------------*
 *
 * CNodeCallback::SetControl
 *
 * PURPOSE:      For the given node & clsid of OCX save the OCX window IUnknown*.
 *
 * PARAMETERS:
 *    HNODE     hNode :
 *    CLSID     clsid :
 *    IUnknown* pUnknown :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CNodeCallback::SetControl(HNODE hNode, CLSID clsid, IUnknown* pUnknown)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::SetControl"));
    sc = ScCheckPointers((void*)hNode, pUnknown);
    if (sc)
        return sc.ToHr();

    // convert to real type
    CNode* pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc.ToHr();

    pNode->SetControl(clsid, pUnknown);

    return sc.ToHr();

}

//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::GetControl
//
//  Synopsis:    For given node & IUnknown* of OCX get the OCX wrapper if one exists.
//
//  Arguments:   [hNode]
//               [pUnkOCX]
//               [ppUnkControl]
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeCallback::GetControl (HNODE hNode, LPUNKNOWN pUnkOCX, IUnknown **ppUnkControl)
{
    DECLARE_SC(sc, _T("CNodeCallback::GetControl"));
    sc = ScCheckPointers((void*)hNode, pUnkOCX, ppUnkControl);
    if (sc)
        return sc.ToHr();

    CNode *pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc.ToHr();

    *ppUnkControl = pNode->GetControl(pUnkOCX);
    if(!*ppUnkControl)
        return sc.ToHr();

    // addref the interface for the client.

    (*ppUnkControl)->AddRef();


    return (sc.ToHr());
}


//+-------------------------------------------------------------------
//
//  Member:      SetControl
//
//  Synopsis:    For given node & IUnknown of OCX save the IUnknown of
//               OCX wrapper.
//
//  Arguments:   [hNode]
//               [pUnkOCX]
//               [pUnknown]
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeCallback::SetControl (HNODE hNode, LPUNKNOWN pUnkOCX, IUnknown* pUnknown)
{
    DECLARE_SC(sc, _T("SetControl"));
    sc = ScCheckPointers((void*) hNode, pUnkOCX, pUnknown);
    if (sc)
        return sc.ToHr();

    CNode *pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc.ToHr();

    pNode->SetControl(pUnkOCX, pUnknown);

    return (sc.ToHr());
}



STDMETHODIMP
CNodeCallback::InitOCX(HNODE hNode, IUnknown* pUnknown)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::InitOCX"));

    sc = ScCheckPointers((void *)hNode);
    if(sc)
        return sc.ToHr();

    CNode* pNode = CNode::FromHandle(hNode);
    sc = pNode->OnInitOCX(pUnknown);

    return sc.ToHr();
}

/////////////////////////////////////////////////////////////////////////////
// Notify handlers


HRESULT CNodeCallback::OnActvate(CNode* pNode, LONG_PTR arg)
{
    DECLARE_SC (sc, _T("CNodeCallback::OnActvate"));
    sc = ScCheckPointers (pNode);
    if (sc)
        return (sc.ToHr());

    return pNode->OnActvate(arg);
}


HRESULT CNodeCallback::OnMinimize(CNode* pNode, LONG_PTR arg)
{
    DECLARE_SC (sc, _T("CNodeCallback::OnMinimize"));
    sc = ScCheckPointers (pNode);
    if (sc)
        return (sc.ToHr());

    return pNode->OnMinimize(arg);
}

HRESULT CNodeCallback::OnDelete(CNode* pNode, BOOL bScopePaneSelected, LPARAM lvData)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::OnDelete"));

    BOOL   bScopeItemSelected;
    CNode *pSelectedNode = NULL;
    MMC_COOKIE cookie = -1;

    sc = CNodeCallback::ScExtractLVData(pNode, bScopePaneSelected, lvData,
                                        &pSelectedNode, bScopeItemSelected, cookie);
    if (sc)
        return sc.ToHr();

    sc = ScCheckPointers(pSelectedNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // If result-pane cookie should be valid.
    ASSERT( (bScopeItemSelected) || cookie != LVDATA_ERROR);
    if ( (FALSE == bScopeItemSelected) && (cookie == LVDATA_ERROR) )
        return E_FAIL;

    HRESULT hr = S_OK;

    if (!bScopeItemSelected)
    {
        CMultiSelection* pMultiSel = pSelectedNode->GetViewData()->GetMultiSelection();
        if (pMultiSel != NULL)
        {
            ASSERT(lvData == LVDATA_MULTISELECT);
            pMultiSel->ScVerbInvoked(MMC_VERB_DELETE);
            return S_OK;
        }
        else
        {
            ASSERT(lvData != LVDATA_MULTISELECT);

            CComponent* pCC = pSelectedNode->GetPrimaryComponent();
            ASSERT(pCC != NULL);

            if (pCC != NULL)
            {
                if (IS_SPECIAL_LVDATA(lvData))
                {
                    LPDATAOBJECT pdobj = (lvData == LVDATA_CUSTOMOCX) ?
                                            DOBJ_CUSTOMOCX : DOBJ_CUSTOMWEB;

                    hr = pCC->Notify(pdobj, MMCN_DELETE, 0, 0);
                    CHECK_HRESULT(hr);
                }
                else
                {
                    IDataObjectPtr spdtobj;
                    hr = pCC->QueryDataObject(cookie, CCT_RESULT, &spdtobj);

                    ASSERT( NULL != pCC->GetIComponent() );

                    if (SUCCEEDED(hr))
                    {
                        hr = pCC->Notify(spdtobj, MMCN_DELETE, 0, 0);
                        CHECK_HRESULT(hr);
                    }
                }
            }
        }
    }
    else
    {
        CMTNode* pMTNode = pSelectedNode->GetMTNode();
        if (pMTNode->Parent() == NULL)
            return S_FALSE;

        if (pSelectedNode->IsStaticNode() == TRUE) // All static nodes can be deleted
        {
            ASSERT(m_pCScopeTree != NULL);

            if (pMTNode->DoDelete(pSelectedNode->GetViewData()->GetMainFrame()) == false)
                return S_FALSE;

            // Delete storage
            hr = pMTNode->DestroyElements();
            ASSERT(SUCCEEDED(hr));

            // Delete the node.
            m_pCScopeTree->DeleteNode(pMTNode);

        }
        else // Tell the snapin that put up the dynamic node to delete.
        {
            CComponentData* pCD = pMTNode->GetPrimaryComponentData();
            ASSERT(pCD != NULL);

            IDataObjectPtr spDataObject;
            hr = pCD->QueryDataObject(pMTNode->GetUserParam(), CCT_SCOPE, &spDataObject);
            CHECK_HRESULT(hr);

            ASSERT( NULL != pCD->GetIComponentData() );

            if (hr == S_OK)
            {
                hr = pCD->Notify(spDataObject, MMCN_DELETE, 0, 0);
                CHECK_HRESULT(hr);
            }
        }
    }

    return hr;
}

HRESULT CNodeCallback::OnFindResultItem(CNode* pNode, RESULTFINDINFO* pFindInfo, LRESULT* pResult)
{
    IF_NULL_RETURN_INVALIDARG3(pNode, pFindInfo, pResult);

    // init result to -1 (item not found)
    *pResult = -1;

    CComponent* pCC = pNode->GetPrimaryComponent();
    ASSERT(pCC != NULL);
    if (pCC == NULL)
        return E_FAIL;

    IResultOwnerDataPtr spIResultOwnerData = pCC->GetIComponent();
    if (spIResultOwnerData == NULL)
        return S_FALSE;

    return spIResultOwnerData->FindItem(pFindInfo, reinterpret_cast<int*>(pResult));
}



HRESULT CNodeCallback::OnRename(CNode* pNode, SELECTIONINFO *pSelInfo,
                                LPOLESTR pszNewName)
{
    HRESULT hr = S_OK;

    if (pSelInfo->m_bScope)
    {
        CMTNode* pMTNode = pNode->GetMTNode();

        hr = pMTNode->OnRename(1, pszNewName);
    }
    else
    {
        CComponent* pCC = pNode->GetPrimaryComponent();
        ASSERT(pCC != NULL);
        if (pCC != NULL)
        {
            IDataObjectPtr spDataObject;
            hr = pCC->QueryDataObject(pSelInfo->m_lCookie, CCT_RESULT,
                                      &spDataObject);
            if (FAILED(hr))
                return hr;

            hr = pCC->Notify(spDataObject, MMCN_RENAME, 1,
                             reinterpret_cast<LPARAM>(pszNewName));
            CHECK_HRESULT(hr);
            return hr;
        }
    }

    if (hr == S_OK)
    {
        if (pNode->IsStaticNode() == TRUE) {
            USES_CONVERSION;
            pNode->SetDisplayName( W2T(pszNewName) );
        }

        // Now inform the views to modify as needed.
        SViewUpdateInfo vui;
        // Snapin nodes result pane will be handled by the snapins
        vui.flag = VUI_REFRESH_NODE;
        pNode->GetMTNode()->CreatePathList(vui.path);
        m_pCScopeTree->UpdateAllViews(VIEW_UPDATE_MODIFY,
                                      reinterpret_cast<LPARAM>(&vui));
    }

    return hr;
}

HRESULT CNodeCallback::OnNewNodeUpdate(CNode* pNode, LONG_PTR lFlags)
{
    pNode->GetMTNode()->SetPropertyPageIsDisplayed(FALSE);

    // Inform the views to modify.
    SViewUpdateInfo vui;
    vui.flag = lFlags;
    pNode->GetMTNode()->CreatePathList(vui.path);
    m_pCScopeTree->UpdateAllViews(VIEW_UPDATE_MODIFY,
                                  reinterpret_cast<LPARAM>(&vui));
    return S_OK;
}

HRESULT CNodeCallback::OnExpand(CNode* pNode, BOOL fExpand)
{
    HRESULT hr = S_OK;
    ASSERT(pNode != 0);

    // initialize the node if needed.
    if (  fExpand && (pNode->WasExpandedAtLeastOnce() == FALSE)  &&
                     (pNode->IsInitialized() == FALSE))
    {
        hr = _InitializeNode(pNode);
        if ((FAILED(hr)))
        {
            return hr;
        }
    }

    return pNode->OnExpand(fExpand);
}

HRESULT CNodeCallback::OnExpanded(CNode* pNode)
{
    ASSERT(pNode != 0);

    pNode->SetExpandedAtLeastOnce();

    return S_OK;
}

HRESULT CNodeCallback::OnScopeSelect(CNode* pNode, BOOL bSelect,
                                     SELECTIONINFO* pSelInfo)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::OnScopeSelect"));
    sc = ScCheckPointers(pNode, pSelInfo);
    if (sc)
        return sc.ToHr();

    // clear out the the status bar text if we're deselecting a node
    if (! bSelect)
    {
        CViewData *pViewData = pNode->GetViewData();
        sc = ScCheckPointers(pViewData, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        CConsoleStatusBar* pStatusBar = pViewData->GetStatusBar();

        if (pStatusBar != NULL)
            pStatusBar->ScSetStatusText (NULL);
    }

    if (pNode->IsInitialized() == FALSE)
    {
        sc = _InitializeNode(pNode);
        if (sc)
            return sc.ToHr();
    }

    sc = pNode->OnScopeSelect(bSelect, pSelInfo);
    if(sc)
        return sc.ToHr();


#ifdef DBG
    if (bSelect)
        Dbg(DEB_USER11, _T("Selecting %s node."), pNode->GetDisplayName());
#endif

    return sc.ToHr();
}

STDMETHODIMP CNodeCallback::SetTaskPadList(HNODE hNode, LPUNKNOWN pUnknown)
{
    IFramePrivate* pFramePrivate = GetIFramePrivateFromNode (hNode);

    if (pFramePrivate == NULL)
        return E_UNEXPECTED;

    return (pFramePrivate->SetTaskPadList(pUnknown));
}

IFramePrivate* GetIFramePrivateFromNode (CNode* pNode)
{
    if (pNode == NULL)
        return (NULL);

    return pNode->GetIFramePrivate();
}

void CNodeCallback::OnMultiSelect(CNode* pNode, BOOL bSelect)
{
    Trace(tagNodeCallback, _T("----------------->>>>>>> MULTI_SELECT<%d>\n"), bSelect);
    SC sc;
    CViewData* pViewData = NULL;

    if (NULL == pNode)
    {
        sc = E_UNEXPECTED;
        goto Error;
    }

    pViewData = pNode->GetViewData();
    if (NULL == pViewData)
    {
        sc = E_UNEXPECTED;
        goto Error;
    }

    if (pViewData->IsVirtualList())
    {
        if (bSelect == TRUE)
            DeleteMultiSelData(pNode);
    }

    _OnMultiSelect(pNode, bSelect);
    if (bSelect == FALSE)
        DeleteMultiSelData(pNode);

    // Update the std-verb tool-buttons.
    sc = pViewData->ScUpdateStdbarVerbs();
    if (sc)
        goto Error;

    pViewData->UpdateToolbars(pViewData->GetToolbarsDisplayed());

Cleanup:
    return;
Error:
    TraceError (_T("CNodeCallback::OnMultiSelect"), sc);
    goto Cleanup;
}

void CNodeCallback::_OnMultiSelect(CNode* pNode, BOOL bSelect)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::_OnMultiSelect"));
    sc = ScCheckPointers(pNode);
    if (sc)
        return;

    CViewData *pViewData = pNode->GetViewData();
    sc = ScCheckPointers(pViewData, E_UNEXPECTED);
    if (sc)
        return;

    CMultiSelection* pMultiSelection = pNode->GetViewData()->GetMultiSelection();

    if (pMultiSelection)
    {
        if (pMultiSelection->IsInUse())
            return;
        else
        {
            /*
             * If result pane items are selected by dragging a mouse (that forms Marquee)
             * or if snapin sets items to selected state then the items are selected one
             * by one. That is multi-select for 1 item, multi-select for 2 items and so-on.
             * There is no deselect inbetween, so if we already have a multiselection object
             * for 2 items then when we get multi-select for 3 items we need to destroy multiselection
             * object for 2 items. This is done below.
             *
             */
            DeleteMultiSelData(pNode);
            pMultiSelection = NULL;
        }
    }

    // set standard bars
    CVerbSet* pVerbSet = dynamic_cast<CVerbSet*>(pViewData->GetVerbSet());
    sc = ScCheckPointers(pVerbSet, E_UNEXPECTED);
    if (sc)
        return;

    sc = pVerbSet->ScInitializeForMultiSelection(pNode, bSelect);
    if (sc)
        return;

    if (pMultiSelection == NULL)
    {
        if (bSelect == FALSE)
            return;

        CComponentPtrArray* prgComps = new CComponentPtrArray;
        if (pNode->IsInitialized() == FALSE)
        {
            sc = _InitializeNode(pNode);
            if (sc)
                return;
        }

        // Create CMultiSelection
        pMultiSelection = new CMultiSelection(pNode);
        sc = ScCheckPointers(pMultiSelection, E_OUTOFMEMORY);
        if (sc)
            return;

        sc = pMultiSelection->Init();
        if (sc)
            return;

        pViewData->SetMultiSelection(pMultiSelection);
    }

    pMultiSelection->SetScopeTree(m_pCScopeTree);

    IDataObjectPtr spdobj;
    sc = pMultiSelection->GetMultiSelDataObject(&spdobj);
    if (sc)
        return;

    sc = ScCheckPointers(spdobj, E_UNEXPECTED);
    if (sc)
        return;

    // give the scope item a chance to do any initialization that it needs.
    // For instance, the console taskpad uses this opportunity to gather information
    // about the selected item's context menu.
    SELECTIONINFO SelInfo;
    SelInfo.m_lCookie = LVDATA_MULTISELECT;

    //  Inform control bars of selection change.
    CControlbarsCache* pCtrlbarsCache =
        dynamic_cast<CControlbarsCache*>(pNode->GetControlbarsCache());
    sc = ScCheckPointers(pCtrlbarsCache, E_UNEXPECTED);
    if (sc)
        return;

    pCtrlbarsCache->OnMultiSelect(pNode, pMultiSelection, spdobj, bSelect);

    sc = pVerbSet->ScComputeVerbStates();
    if (sc)
        return;
}

void CNodeCallback::OnSelect(CNode* pNode, BOOL bSelect, SELECTIONINFO* pSelInfo)
{
    Trace(tagNodeCallback, _T("----------------->>>>>>> SELECT<%d>\n"), bSelect);
    SC sc;
    CViewData* pViewData = NULL;

    if (pSelInfo == NULL)
    {
        sc = E_UNEXPECTED;
        goto Error;
    }

    Trace(tagNodeCallback, _T("====>> NCLBK_SELECT<%d, %d, %c>\n"), pSelInfo->m_bScope, bSelect, pSelInfo->m_bDueToFocusChange ? _T('F') : _T('S'));

    if (NULL == pNode)
    {
        sc = E_UNEXPECTED;
        goto Error;
    }

    pViewData = pNode->GetViewData();
    if (NULL == pViewData)
    {
        sc = E_UNEXPECTED;
        goto Error;
    }

    DeleteMultiSelData(pNode);

    if (!bSelect)
    {
        // Reset controlbars
        pNode->ResetControlbars(bSelect, pSelInfo);

        // Reset standard verbs
        sc = pNode->ScInitializeVerbs(bSelect, pSelInfo);
        if (sc)
            sc.TraceAndClear();
    }

    // For scoe sel change reset result pane.
    if (pSelInfo->m_bScope == TRUE && pSelInfo->m_bDueToFocusChange == FALSE)
    {
        sc = OnScopeSelect(pNode, bSelect, pSelInfo);
        if (sc)
            goto Error;
    }

    if (bSelect)
    {
        // Reset controlbars
        pNode->ResetControlbars(bSelect, pSelInfo);

        // Reset standard verbs
        sc = pNode->ScInitializeVerbs(bSelect, pSelInfo);
        if (sc)
            sc.TraceAndClear();
    }

    // Update the std-verb tool-buttons.
    sc = pViewData->ScUpdateStdbarVerbs();

    // Dummy block
    {
        // Update the paste button
        LPARAM lvData = pSelInfo->m_lCookie;

        BOOL   bScopePaneSelected = pSelInfo->m_bScope || pSelInfo->m_bBackground;

        sc = UpdatePasteButton(CNode::ToHandle(pNode), bScopePaneSelected, lvData);
        if (sc)
            goto Error;

        // Update toolbars.
        pViewData->UpdateToolbars(pViewData->GetToolbarsDisplayed());
    }

Cleanup:
    return;
Error:
    TraceError (_T("CNodeCallback::OnSelect"), sc);
    goto Cleanup;
}


HRESULT CNodeCallback::OnDblClk(CNode* pNode, LONG_PTR lvData)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::OnDblClk"));
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc.ToHr();

    BOOL   bScopePaneSelected = FALSE;

    BOOL   bScopeItemSelected;
    CNode *pSelectedNode = NULL;
    MMC_COOKIE cookie = -1;

    sc = CNodeCallback::ScExtractLVData(pNode, bScopePaneSelected, lvData,
                                        &pSelectedNode, bScopeItemSelected, cookie);
    if (sc)
        return sc.ToHr();

    sc = ScCheckPointers(pSelectedNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // If result-pane cookie should be valid.
    if ( (FALSE == bScopeItemSelected) && (cookie == LVDATA_ERROR) )
        return (sc = E_FAIL).ToHr();

    // Ignore double-click on LV background.
    if (lvData == LVDATA_BACKGROUND)
        return sc.ToHr();

    CComponent* pCC = pSelectedNode->GetPrimaryComponent();
    sc = ScCheckPointers(pCC, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // Get the dataobject of the item which was double-clicked.
    IDataObjectPtr spdtobj;

    if (!bScopeItemSelected) // leaf item
    {
        sc = pCC->QueryDataObject(cookie, CCT_RESULT, &spdtobj);

        if (sc)
        {
            sc.TraceAndClear();
            return sc.ToHr();
        }
    }
    else
    {
        sc = pSelectedNode->QueryDataObject(CCT_SCOPE, &spdtobj);
        if (sc)
        {
            sc.TraceAndClear();
            return sc.ToHr();
        }
    }

    sc = pCC->Notify(spdtobj, MMCN_DBLCLICK, 0, 0);
    if (sc)
        sc.TraceAndClear();

    // Snapin has asked us to do default verb action, so findout default verb.
    if (sc == S_FALSE)
    {
        CViewData *pViewData = pSelectedNode->GetViewData();
        sc = ScCheckPointers(pViewData, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        CVerbSet* pVerbSet = dynamic_cast<CVerbSet*>(pViewData->GetVerbSet());
        sc = ScCheckPointers(pVerbSet, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        MMC_CONSOLE_VERB defaultVerb = MMC_VERB_NONE;
        pVerbSet->GetDefaultVerb(&defaultVerb);
        if (defaultVerb == MMC_VERB_OPEN)
        {
            return S_FALSE;
        }
        else if (defaultVerb == MMC_VERB_PROPERTIES)
        {
            OnProperties(pNode, bScopePaneSelected, lvData);
        }
    }

    return S_OK;
}

HRESULT CNodeCallback::OnContextMenu(CNode* pNode, LONG_PTR arg, LPARAM param)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::OnContextMenu"));

    ASSERT(param != NULL);
    CContextMenuInfo& contextInfo = *reinterpret_cast<CContextMenuInfo*>(param);

    BOOL b = static_cast<BOOL>(arg);

    if ((pNode != NULL) && !pNode->IsInitialized())
    {
        sc = pNode->InitComponents();
        if(sc)
            return sc.ToHr();
    }

    // Create a CContextMenu and initialize it.
    CContextMenu * pContextMenu = NULL;
    ContextMenuPtr spContextMenu;

    sc = CContextMenu::ScCreateInstance(&spContextMenu, &pContextMenu);
    if(sc)
        return sc.ToHr();

    sc = ScCheckPointers(pContextMenu, spContextMenu.GetInterfacePtr(), E_UNEXPECTED);
    if(sc)
        return sc.ToHr();

    sc = pContextMenu->ScInitialize(pNode, this, m_pCScopeTree, contextInfo);
    if(sc)
        return sc.ToHr();

    sc = pContextMenu->Display(b);
    return sc.ToHr();
}


/*+-------------------------------------------------------------------------*
 *
 * CNodeCallback::CreateContextMenu
 *
 * PURPOSE: Creates a context menu for the specified node.
 *
 * PARAMETERS:
 *    PNODE          pNode :
 *    PPCONTEXTMENU  ppContextMenu : [OUT]: The context menu structure.
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CNodeCallback::CreateContextMenu( PNODE pNode,  HNODE hNode, PPCONTEXTMENU ppContextMenu)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::CreateContextMenu"));

    sc = ScCheckPointers(pNode, ppContextMenu);
    if(sc)
        return sc.ToHr();

    sc = CContextMenu::ScCreateContextMenu(pNode, hNode, ppContextMenu, this, m_pCScopeTree);

    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CNodeCallback::CreateSelectionContextMenu
 *
 * PURPOSE: Creates a context menu for the current selection in the result pane.
 *
 * PARAMETERS:
 *    HNODE              hNodeScope :
 *    CContextMenuInfo * pContextInfo :
 *    PPCONTEXTMENU      ppContextMenu :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CNodeCallback::CreateSelectionContextMenu( HNODE hNodeScope, CContextMenuInfo *pContextInfo, PPCONTEXTMENU ppContextMenu)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::CreateSelectionContextMenu"));

    sc = CContextMenu::ScCreateSelectionContextMenu(hNodeScope, pContextInfo, ppContextMenu, this, m_pCScopeTree);
    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CNodeCallback::GetProperty
 *
 * PURPOSE:  Returns the specified property for the specified list item by calling
 *           IDataObject::GetData using a STREAM medium on the node's data
 *           object.
 *
 * PARAMETERS:
 *    HNODE   hNodeScope :  The parent scope item
 *    BOOL    bForScopeItem :  TRUE if the list item is a scope item in the list.
 *    LPARAM  resultItemParam : The LPARAM of the result item
 *    BSTR    bstrPropertyName : The name of the clipboard format.
 *    PBSTR   pbstrPropertyValue :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CNodeCallback::GetProperty(HNODE hNodeScope, BOOL bForScopeItem, LPARAM resultItemParam, BSTR bstrPropertyName, PBSTR  pbstrPropertyValue)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::GetProperty"));

    // check parameters
    sc = ScCheckPointers(bstrPropertyName);
    if(sc)
        return sc.ToHr();

    // initialize out parameter
    *pbstrPropertyValue = NULL;

    // convert the HNODE to a CNode *
    CNode *pNodeScope = CNode::FromHandle(hNodeScope);

    sc = ScCheckPointers(pNodeScope);
    if(sc)
        return sc.ToHr();

    // create a data object for the specified item
    IDataObjectPtr spDataObject;

    bool bScopeItem;
    sc = pNodeScope->ScGetDataObject(bForScopeItem, resultItemParam, bScopeItem, &spDataObject);
    if(sc)
        return sc.ToHr();

    // try to get the propeorty from the INodeProperties interface
    sc = pNodeScope->ScGetPropertyFromINodeProperties(spDataObject, bForScopeItem, resultItemParam, bstrPropertyName, pbstrPropertyValue);
    if( (!sc.IsError()) && (sc.ToHr() != S_FALSE)   ) // got it, exit
        return sc.ToHr();

    // didn't find it, continue
    sc.Clear();

    // get the property from data object
    sc = ScGetProperty(spDataObject, bstrPropertyName, pbstrPropertyValue);
    if(sc)
        return sc.ToHr();

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CNodeCallback::ScGetProperty
 *
 * PURPOSE: Helper (static) method to access snapin property
 *
 * PARAMETERS:
 *    IDataObject *pDataObject  - [in] data object
 *    BSTR bstrPropertyName     - [in] property (clipboard fromat) name
 *    PBSTR  pbstrPropertyValue - [out] resulting value
 *
 * RETURNS:
 *    SC    - result code. NOTE: no error is returned if the snapin does not
 *            support the specified clipboard format. In this case *pbstrPropertyValue
 *            is set to NULL.
 *
\***************************************************************************/
SC CNodeCallback::ScGetProperty(IDataObject *pDataObject, BSTR bstrPropertyName, PBSTR  pbstrPropertyValue)
{
    DECLARE_SC(sc, TEXT("ScGetProperty"));

    // check parameters
    sc = ScCheckPointers(pDataObject, bstrPropertyName, pbstrPropertyValue);
    if(sc)
        return sc;

    // initialize out parameter
    *pbstrPropertyValue = NULL;

    // create a stream for the data object to use
    IStreamPtr pStm;
    sc = CreateStreamOnHGlobal(NULL, true, &pStm);
    if(sc)
        return sc;

    ULARGE_INTEGER zeroSize = {0, 0};
    sc = pStm->SetSize(zeroSize);
    if(sc)
        return sc;

    USES_CONVERSION;
    CLIPFORMAT cfClipFormat = (CLIPFORMAT)RegisterClipboardFormat(OLE2T(bstrPropertyName));

    // First call ExtractString which uses GetData
    CStr strOutput;
    sc = ExtractString (pDataObject, cfClipFormat, strOutput);
    if(!sc.IsError())
    {
        *pbstrPropertyValue = ::SysAllocStringLen(T2COLE(strOutput), strOutput.GetLength()/*prevents the terminating zero from being added.*/); // allocate the string and return
        return sc;
    }

    // That didn't work, so try using GetDataHere.
    FORMATETC fmt  = {cfClipFormat, NULL, DVASPECT_CONTENT, -1, TYMED_ISTREAM};
    STGMEDIUM stgm = {TYMED_ISTREAM, NULL, NULL};
    stgm.pstm      = pStm;

    sc = pDataObject->GetDataHere(&fmt, &stgm);
    if(sc)
    {
        // ignore errors and return a blank string
        sc.Clear();
        return sc;
    }

    STATSTG stagStg;
    ZeroMemory(&stagStg, sizeof(stagStg));

    sc = pStm->Stat(&stagStg, STATFLAG_NONAME); // do not need the name in the statistics.
    if(sc)
        return sc;

    if(stagStg.cbSize.HighPart != 0)
        return sc = E_UNEXPECTED;

    // go back to the beginning of the stream
    LARGE_INTEGER dlibMove = {0, 0};
    sc = pStm->Seek(dlibMove, STREAM_SEEK_SET, NULL);
    if(sc)
        return sc;

    BSTR bstrValue = ::SysAllocStringLen(NULL, stagStg.cbSize.LowPart / sizeof(OLECHAR)); // one character is automatically added
    if(!bstrValue)
        return sc = E_OUTOFMEMORY;

    ULONG cbRead = 0;
    sc = pStm->Read(bstrValue, stagStg.cbSize.LowPart, &cbRead);
    if(sc)
        return sc;

    // make sure that the count of characters is what was expected
    if(cbRead != stagStg.cbSize.LowPart)
    {
        ::SysFreeString(bstrValue);
        return sc = E_UNEXPECTED;
    }

    // set the output parameter
    *pbstrPropertyValue = bstrValue;

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CNodeCallback::GetNodetypeForListItem
 *
 * PURPOSE: Returns the node type for a list item.
 *
 * PARAMETERS:
 *    HNODE   hNodeScope :
 *    BOOL    bForScopeItem :
 *    LPARAM  resultItemParam :
 *    PBSTR   pbstrNodetype :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CNodeCallback::GetNodetypeForListItem(HNODE hNodeScope, BOOL bForScopeItem, LPARAM resultItemParam, PBSTR pbstrNodetype)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::GetNodetypeForListItem"));

    // check parameters
    sc = ScCheckPointers(pbstrNodetype);
    if(sc)
        return sc.ToHr();

    // initialize out parameter
    *pbstrNodetype = NULL;

    // convert the HNODE to a CNode *
    CNode *pNodeScope = CNode::FromHandle(hNodeScope);

    sc = ScCheckPointers(pNodeScope);
    if(sc)
        return sc.ToHr();

    IDataObjectPtr spDataObject;

    bool bScopeItem;
    sc = pNodeScope->ScGetDataObject(bForScopeItem, resultItemParam, bScopeItem, &spDataObject);
    if(sc)
        return sc.ToHr();

    // at this point we should have a valid data object
    sc = ScCheckPointers((LPDATAOBJECT)spDataObject);
    if(sc)
        return sc.ToHr();

    sc = ScGetNodetype(spDataObject, pbstrNodetype);
    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CNodeCallback::ScGetNodetype
 *
 * PURPOSE: Static function - returns the nodetype of a data object as a string.
 *
 * PARAMETERS:
 *    IDataObject * pDataObject :
 *    PBSTR         pbstrNodetype :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CNodeCallback::ScGetNodetype(IDataObject *pDataObject, PBSTR pbstrNodetype)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::ScGetNodetype"));

    sc = ScCheckPointers(pDataObject, pbstrNodetype);
    if(sc)
        return sc;

    // init out parameter
    *pbstrNodetype = NULL;

    GUID guidNodetype = GUID_NULL;

    sc = ExtractObjectTypeGUID(pDataObject, &guidNodetype);
    if(sc)
        return sc;

    OLECHAR szSnapInGUID[40];
    int iRet = StringFromGUID2(guidNodetype, szSnapInGUID, countof(szSnapInGUID));

    if(0 == iRet)
        return (sc = E_UNEXPECTED);

    // allocate the string, with the correct length.
    *pbstrNodetype = ::SysAllocString(szSnapInGUID);
    if(!*pbstrNodetype)
        return (sc = E_OUTOFMEMORY);

    return sc;
}

HRESULT CNodeCallback::OnSnapInHelp(CNode* pNode, BOOL bScope, MMC_COOKIE cookie)
{
    if (bScope == FALSE && pNode->GetViewData()->IsVirtualList() == FALSE)
    {
        ASSERT(cookie != NULL);
        CResultItem* pri = CResultItem::FromHandle(cookie);

        if ((pri != NULL) && pri->IsScopeItem())
        {
            pNode = CNode::FromResultItem(pri);
            ASSERT(pNode != NULL);
        }
    }

    CComponent* pCC = pNode->GetPrimaryComponent();
    ASSERT(pCC != NULL);

    HRESULT hr = pCC->Notify(NULL, MMCN_SNAPINHELP, 0, 0);
    CHECK_HRESULT(hr);

    return hr;
}


HRESULT CNodeCallback::OnContextHelp(CNode* pNode, BOOL bScope, MMC_COOKIE cookie)
{
    ASSERT(pNode != NULL);

    if (bScope == FALSE && pNode->GetViewData()->IsVirtualList() == FALSE)
    {
        ASSERT(cookie != NULL);
        if(cookie == NULL || IS_SPECIAL_COOKIE(cookie))
            return E_UNEXPECTED;

        CResultItem* pri = CResultItem::FromHandle(cookie);
        if (pri == NULL)
            return (E_UNEXPECTED);

        cookie = pri->GetSnapinData();

        bScope = pri->IsScopeItem();
        if (bScope == TRUE)
        {
            pNode = CNode::FromResultItem(pri);
            ASSERT(pNode != NULL);
        }
    }

    if (bScope == TRUE)
    {
        IDataObjectPtr spdtobj;
        HRESULT hr = pNode->GetMTNode()->QueryDataObject(CCT_SCOPE, &spdtobj);
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
            return hr;

        CComponent* pCC = pNode->GetPrimaryComponent();
		if ( pCC == NULL )
			return E_UNEXPECTED;

        hr = pCC->Notify(spdtobj, MMCN_CONTEXTHELP, 0, 0);
        CHECK_HRESULT(hr);
        return hr;
    }
    else
    {
        CComponent* pCC = pNode->GetPrimaryComponent();
        ASSERT(pCC != NULL);
		if ( pCC == NULL )
			return E_UNEXPECTED;

        IDataObjectPtr spdtobj;
        HRESULT hr = pCC->QueryDataObject(cookie, CCT_RESULT, &spdtobj);
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
            return hr;

        hr = pCC->Notify(spdtobj, MMCN_CONTEXTHELP, 0, 0);
        CHECK_HRESULT(hr);
        return hr;
    }
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::GetSnapinName
//
//  Synopsis:    Given the node get the snapin name
//
//  Arguments:   [hNode]    - [in]
//               [ppszName] - [out] ret val, caller should free using CoTaskMemFree
//               [bValidName] - [out], is the name valid or not
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
HRESULT CNodeCallback::GetSnapinName (/*[in]*/HNODE hNode, /*[out]*/LPOLESTR* ppszName, /*[out]*/ bool& bValidName)
{
    DECLARE_SC(sc, _T("CNodeCallback::GetSnapinName"));
    sc = ScCheckPointers( (void*) hNode, ppszName);
    if (sc)
        return sc.ToHr();

    bValidName = false;

    CNode *pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers(pNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    *ppszName = NULL;

    CSnapIn* pSnapIn = pNode->GetPrimarySnapIn();
    sc = ScCheckPointers (pSnapIn, E_UNEXPECTED);
    if (sc)
        return (sc.ToHr());

    WTL::CString strName;
    sc = pSnapIn->ScGetSnapInName(strName);
    if (sc)
        return (sc.ToHr());

    if (strName.IsEmpty())
        return sc.ToHr();

    USES_CONVERSION;
    *ppszName = CoTaskDupString (T2COLE (strName));
    if (*ppszName == NULL)
        return ((sc = E_OUTOFMEMORY).ToHr());

    bValidName = true;

    return (sc.ToHr());
}


//+-------------------------------------------------------------------
//
//  Member:     OnColumnClicked
//
//  Synopsis:   Ask snapin if it wants to sort and do so.
//
//  Arguments:  [pNode] - CNode* owner of list view.
//              [nCol]  - column that is clicked (to sort on this column).
//
//  Returns:    HRESULT
//
//  History:    07-27-1999  AnandhaG renamed OnSort to OnColumnClicked
//--------------------------------------------------------------------
HRESULT CNodeCallback::OnColumnClicked(CNode* pNode, LONG_PTR nCol)
{
    ASSERT(pNode != NULL);

    pNode->OnColumnClicked(nCol);
    return S_OK;
}

HRESULT CNodeCallback::OnPrint(CNode* pNode, BOOL bScopePane, LPARAM lvData)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::OnPrint"));
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc.ToHr();

    if ((!bScopePane) && (LVDATA_MULTISELECT == lvData) )
    {
        CViewData *pViewData = pNode->GetViewData();
        sc = ScCheckPointers(pViewData, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        CMultiSelection* pMultiSel = pViewData->GetMultiSelection();
        sc = ScCheckPointers(pMultiSel, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        sc = pMultiSel->ScVerbInvoked(MMC_VERB_PRINT);
        if (sc)
            return sc.ToHr();

        return sc.ToHr();
    }

    IDataObjectPtr spdtobj;
    IDataObject *pdtobj = NULL;

    bool bScopeItem;
    sc = pNode->ScGetDataObject(bScopePane, lvData, bScopeItem, &pdtobj);
    if (sc)
        return sc.ToHr();

    if (! IS_SPECIAL_DATAOBJECT(pdtobj))
        spdtobj = pdtobj;

    CComponent *pComponent = pNode->GetPrimaryComponent();
    sc = ScCheckPointers(pComponent, pdtobj, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = pComponent->Notify(pdtobj, MMCN_PRINT, 0, 0);
    if (sc)
        sc.TraceAndClear();

    return sc.ToHr();
}

HRESULT
CNodeCallback::OnEditTaskpad(CNode *pNode)
{
    ASSERT(pNode);

    ITaskCallbackPtr spTaskCallback = pNode->GetViewData()->m_spTaskCallback;

    ASSERT(spTaskCallback.GetInterfacePtr());

    return spTaskCallback->OnModifyTaskpad();
}

HRESULT
CNodeCallback::OnDeleteTaskpad(CNode *pNode)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::OnDeleteTaskpad"));

    ASSERT(pNode);
    sc = ScCheckPointers( pNode );
    if ( sc )
        return sc.ToHr();

    ITaskCallbackPtr spTaskCallback = pNode->GetViewData()->m_spTaskCallback;

    ASSERT(spTaskCallback.GetInterfacePtr());

    // make the node dirty
    CMTNode* pMTNode = pNode->GetMTNode();
    sc = ScCheckPointers( pMTNode, E_UNEXPECTED );
    if(sc)
        return sc.ToHr();

    pMTNode->SetDirty();

    return spTaskCallback->OnDeleteTaskpad();
}

/* CNodeCallback::OnNewTaskpadFromHere
 *
 * PURPOSE:     Displays property pages for a new taskpad
 *
 * PARAMETERS:
 *      CNode*   pNode: The node that the taskpad should target to.
 *
 * RETURNS:
 *      HRESULT
 */
HRESULT
CNodeCallback::OnNewTaskpadFromHere(CNode* pNode)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::OnNewTaskpadFromHere"));
    sc = ScCheckPointers(pNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    CConsoleTaskpad taskpad (pNode);

    CTaskpadWizard dlg(pNode, taskpad, TRUE /*fNew*/, 0, FALSE, pNode->GetViewData());

    bool fStartTaskWizard = true;
    sc = dlg.Show(pNode->GetViewData()->GetMainFrame() /*hWndParent*/, &fStartTaskWizard);

    if (sc != S_OK)
        return sc.ToHr();

    sc = ScCheckPointers(m_pCScopeTree, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    m_pCScopeTree->InsertConsoleTaskpad (&taskpad, pNode, fStartTaskWizard);

    // modify the view settings for this node to ensure that the taskpad is shown after the reselect.
    sc = pNode->ScSetTaskpadID(taskpad.GetID(), /*bSetViewSettingDirty*/ true);
    if (sc)
        return sc.ToHr();

    m_pCScopeTree->UpdateAllViews(VIEW_RESELECT, 0);

    return sc.ToHr();
}


HRESULT CNodeCallback::OnRefresh(CNode* pNode, BOOL bScopePaneSelected, LPARAM lvData)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::OnRefresh"));

    BOOL   bScopeItemSelected;
    CNode *pSelectedNode = NULL;
    MMC_COOKIE cookie = -1;

    sc = CNodeCallback::ScExtractLVData(pNode, bScopePaneSelected, lvData,
                                        &pSelectedNode, bScopeItemSelected, cookie);
    if (sc)
        return sc.ToHr();

    sc = ScCheckPointers(pSelectedNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // If result-pane cookie should be valid.
    ASSERT( (bScopeItemSelected) || cookie != LVDATA_ERROR);
    if ( (FALSE == bScopeItemSelected) && (cookie == LVDATA_ERROR) )
        return E_FAIL;

    // Before refreshing this node, if the user has made
    // changes to list view persist it.
    CViewData* pVD = pSelectedNode->GetViewData();
    ASSERT(pVD != NULL);

    if (bScopeItemSelected)
    {
        ASSERT(pNode != NULL);
        IDataObjectPtr spdtobj;
        HRESULT hr = pSelectedNode->GetMTNode()->QueryDataObject(CCT_SCOPE, &spdtobj);
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
            return hr;

        CMTNode* pMTNode = pSelectedNode->GetMTNode();
        ASSERT(pMTNode != NULL);

        LPARAM lScopeItem = CMTNode::ToScopeItem(pMTNode);

        // Send notify to primary snap-in
        pMTNode->AddRef();
        pSelectedNode->GetPrimaryComponent()->Notify(spdtobj, MMCN_REFRESH, lScopeItem, 0);
        if (pMTNode->Release() == 0)
            return S_OK;

        // If node has been expanded, then also send notify to all namespace
        // extensions for this node
        if (pMTNode->WasExpandedAtLeastOnce())
        {
            do // dummy loop
            {
                // Get the node-type of this node
                GUID guidNodeType;
                HRESULT hr = pMTNode->GetNodeType(&guidNodeType);
                CHECK_HRESULT(hr);
                if (FAILED(hr))
                    break;

                // Get list of dynmaic extensions
                LPCLSID pDynExtCLSID;
                int cDynExt = pMTNode->GetDynExtCLSID(&pDynExtCLSID);

                // Create and init namespace extension iterator
                CExtensionsIterator it;
                sc = it.ScInitialize(pMTNode->GetPrimarySnapIn(), guidNodeType, g_szNameSpace, pDynExtCLSID, cDynExt);
                if (sc)
                    break;

                CSnapInNode* pSINode = pSelectedNode->GetStaticParent();
                ASSERT(pSINode != NULL);

                // Send refresh to each extension's component
                for (; it.IsEnd() == FALSE; it.Advance())
                {
                    CComponent* pCC = pSINode->GetComponent(it.GetCLSID());
                    if (pCC == NULL)
                        continue;

                    HRESULT hr = pCC->Notify(spdtobj, MMCN_REFRESH, lScopeItem, 0);
                    CHECK_HRESULT(hr);
                }
            } while (FALSE);
        }
    }
    else
    {
        CComponent* pCC = pSelectedNode->GetPrimaryComponent();
        ASSERT(pCC != NULL);

        if (IS_SPECIAL_LVDATA(lvData))
        {
            LPDATAOBJECT pdobj = (lvData == LVDATA_CUSTOMOCX) ?
                                    DOBJ_CUSTOMOCX : DOBJ_CUSTOMWEB;

            HRESULT hr = pCC->Notify(pdobj, MMCN_REFRESH, 0, 0);
            CHECK_HRESULT(hr);
        }
        else
        {
            IDataObjectPtr spdtobj;
            HRESULT hr = pCC->QueryDataObject(cookie, CCT_RESULT, &spdtobj);
            ASSERT(SUCCEEDED(hr));
            if (FAILED(hr))
                return hr;
            pCC->Notify(spdtobj, MMCN_REFRESH, 0, 0);
        }
    }

    // Set the view correctly using the persisted data.
    do
    {
        if (NULL == pVD)
            break;

        // After the refresh the snapin could have deleted the pSelectedNode or
        // could have moved the selection. While setting view-data we
        // just need the currently selected node (the owner of the view
        // which is not affected by temp selection) and set the view.
        CNode* pSelNode = pVD->GetSelectedNode();
        if (NULL == pSelNode)
            break;

        sc = pSelNode->ScRestoreSortFromPersistedData();
        if (sc)
            return sc.ToHr();
    } while ( FALSE );

    return S_OK;
}

UINT GetRelation(CMTNode* pMTNodeSrc, CMTNode* pMTNodeDest)
{
    if (pMTNodeSrc == pMTNodeDest)
        return 1;

    for(pMTNodeDest = pMTNodeDest->Parent();
        pMTNodeDest;
        pMTNodeDest = pMTNodeDest->Parent())
    {
        if (pMTNodeSrc == pMTNodeDest)
            return 2;
    }

    return 0;
}

STDMETHODIMP CNodeCallback::UpdatePasteButton(HNODE hNode, BOOL bScope, LPARAM lvData)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::UpdatePasteButton"));
    sc = ScCheckPointers(hNode);
    if (sc)
        return sc.ToHr();

    bool bPasteAllowed = false;
    // Update only when item is being selected.
    sc = QueryPasteFromClipboard(hNode, bScope, lvData, bPasteAllowed);
    if (sc)
        return sc.ToHr();

    CNode *pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers(pNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    CViewData *pViewData = pNode->GetViewData();
    sc = ScCheckPointers(pViewData, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = pViewData->ScUpdateStdbarVerb (MMC_VERB_PASTE, TBSTATE_ENABLED, bPasteAllowed);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::ScInitializeTempVerbSetForMultiSel
//
//  Synopsis:    For given node, initialize the tempverbset object
//               provided. For this create a multi-selection object
//               initialize it (multiselection object finds out what is
//               selected in resultpane and sends MMCN_SELECT to appropriate
//               snapins) and compute the verb states for the temp-verbset object.
//
//  Arguments:   [pNode]    - [in] owner of resultpane.
//               [tempverb] - [in] Temp verb set object which is initialzied.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CNodeCallback::ScInitializeTempVerbSetForMultiSel(CNode *pNode, CTemporaryVerbSet& tempVerb)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::ScInitializeTempVerbSetForMultiSel"));
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc;

    ASSERT(pNode->IsInitialized() == TRUE);

    // 1. Create a multi-selection object.
    CMultiSelection* pMultiSelection = new CMultiSelection(pNode);
    sc = ScCheckPointers(pMultiSelection, E_OUTOFMEMORY);
    if (sc)
        return sc;

    IDataObjectPtr spdobj;

    // 2. Initialize it, (it finds out what is selected in resultpane
    //    gets dataobjects from appropriate snapins and sends snapins
    //    MMCN_SELECT notifications).
    sc = pMultiSelection->Init();
    if (sc)
        goto Cleanup;

    pMultiSelection->SetScopeTree(m_pCScopeTree);

    sc = pMultiSelection->GetMultiSelDataObject(&spdobj);
    if (sc)
        goto Cleanup;

    if (spdobj == NULL)
        goto Cleanup;

    // 3. Init the verbset object.
    sc = tempVerb.ScInitializeForMultiSelection(pNode, /*bSelect*/ true);
    if (sc)
        goto Cleanup;

    tempVerb.SetMultiSelection(pMultiSelection);

    // 4. Compute the verbs that are set by snapin along with given context.
    sc = tempVerb.ScComputeVerbStates();

    if (sc)
        goto Cleanup;

Cleanup:
    pMultiSelection->Release();
    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::_ScGetVerbState
//
//  Synopsis:    For given item (dataobject), the owner node see if given
//               verb is set. A temp-verb-set object is created for this purpose.
//
//  Arguments:   [pNode]         - [in]
//               [verb]          - [in]
//               [pDOSel]        - [in] Dataobject of the item whose verb we are interested.
//               [bScopePane]    - [in]
//               [lResultCookie] - [in]
//               [bMultiSelect]  - [in]
//               [bIsVerbSet]    - [out] verb is set or not.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CNodeCallback::_ScGetVerbState( CNode* pNode, MMC_CONSOLE_VERB verb, IDataObject* pDOSel,
                                   BOOL bScopePane, LPARAM lResultCookie,
                                   BOOL bMultiSelect, BOOL& bIsVerbSet)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::_GetVerbState"));
    bIsVerbSet = FALSE;

    sc = ScCheckPointers(pNode, pDOSel);
    if (sc)
        return sc;

    CComObject<CTemporaryVerbSet> stdVerbTemp;

    if (bMultiSelect)
        sc = ScInitializeTempVerbSetForMultiSel(pNode, stdVerbTemp);
    else
        sc = stdVerbTemp.ScInitialize(pDOSel, pNode, bScopePane, lResultCookie);

    if (sc)
        return sc;

    stdVerbTemp.GetVerbState(verb, ENABLED, &bIsVerbSet);

    return sc;
}

HRESULT
CNodeCallback::OnCutCopy(
    CNode* pNode,
    BOOL bScope,
    LPARAM lvData,
    BOOL bCut)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::OnCutCopy"));

    // parameter check
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc.ToHr();

    // get the object
    IMMCClipboardDataObjectPtr spClipBoardDataObject;
    bool bContainsItems = false;
    sc = CMMCClipBoardDataObject::ScCreate( (bCut ? ACTION_CUT : ACTION_COPY),
                                            pNode, bScope,
                                            (lvData == LVDATA_MULTISELECT)/*bMultiSel*/,
                                            lvData, &spClipBoardDataObject ,
                                            bContainsItems);
    if (sc)
        return sc.ToHr();

    // If snapin has cut or copy then dataobject should have been added.
    if (! bContainsItems)
        return (sc = E_UNEXPECTED).ToHr();

    // QI for IDataObject
    IDataObjectPtr spDataObject = spClipBoardDataObject;
    sc = ScCheckPointers( spDataObject, E_UNEXPECTED );
    if (sc)
        return sc.ToHr();

    //  Put the dataobject on the clipboard.
    sc = OleSetClipboard( spDataObject );
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::OnProperties
//
//  Synopsis:    Bring property sheet for given item.
//
//  Arguments:   CNode*   -  The node that owns result pane.
//               BOOL     -  If true bring propsheet of above node else use LVData.
//               LPARAM   -  If bScope = FALSE then use this data to get the LVData
//                           and bring its property sheet.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
HRESULT CNodeCallback::OnProperties(CNode* pNode, BOOL bScopePaneSelected, LPARAM lvData)
{
    DECLARE_SC(sc, _T("CNodeCallback::OnProperties"));
    sc = ScCheckPointers(pNode);
    if (sc)
        return (sc.ToHr());

    // NOTE: All the code below should be moved into the CNode class
    BOOL   bScopeItemSelected = FALSE;
    CNode *pSelectedNode = NULL;
    MMC_COOKIE cookie = -1;

    sc = CNodeCallback::ScExtractLVData(pNode, bScopePaneSelected, lvData,
                                        &pSelectedNode, bScopeItemSelected, cookie);
    if (sc)
        return sc.ToHr();

    sc = ScCheckPointers(pSelectedNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // If result-pane cookie should be valid.
    if ( (FALSE == bScopeItemSelected) && (cookie == LVDATA_ERROR) )
        return (sc = E_FAIL).ToHr();

    if (bScopeItemSelected)
    {
        sc = ScDisplaySnapinNodePropertySheet(pSelectedNode);
        if(sc)
            return sc.ToHr();
    }
    else
    {
        CViewData* pViewData = pSelectedNode->GetViewData();
        sc = ScCheckPointers(pViewData, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        if (pViewData->HasList())
        {
            if (cookie == LVDATA_MULTISELECT)
            {
                sc = ScDisplayMultiSelPropertySheet(pSelectedNode);
                if(sc)
                    return sc.ToHr();
            }
            else
            {
                sc = ScDisplaySnapinLeafPropertySheet(pSelectedNode, cookie);
                if(sc)
                    return sc.ToHr();
            }
        }
        else
        {
            LPDATAOBJECT pdobj = (pViewData->HasOCX() ) ? DOBJ_CUSTOMOCX : DOBJ_CUSTOMWEB;
            CComponent* pCC = pSelectedNode->GetPrimaryComponent();
            sc = ScCheckPointers(pCC, E_UNEXPECTED);
            if (sc)
                return sc.ToHr();

            pCC->Notify(pdobj, MMCN_BTN_CLICK, 0, MMC_VERB_PROPERTIES);
        }
    }

    return S_OK;
}


HRESULT CNodeCallback::OnFilterChange(CNode* pNode, LONG_PTR nCode, LPARAM nCol)
{
    IF_NULL_RETURN_INVALIDARG(pNode);

    CComponent* pCC = pNode->GetPrimaryComponent();
    ASSERT(pCC != NULL);

    if (pCC != NULL)
    {
        HRESULT hr = pCC->Notify(DOBJ_NULL, MMCN_FILTER_CHANGE, nCode, nCol);
        return hr;
    }

    return E_FAIL;
}


HRESULT CNodeCallback::OnFilterBtnClick(CNode* pNode, LONG_PTR nCol, LPRECT pRect)
{
    IF_NULL_RETURN_INVALIDARG2(pNode, pRect);

    CComponent* pCC = pNode->GetPrimaryComponent();
    ASSERT(pCC != NULL);

    if (pCC != NULL)
    {
        HRESULT hr = pCC->Notify(DOBJ_NULL, MMCN_FILTERBTN_CLICK, nCol, (LPARAM)pRect);
        return hr;
    }

    return E_FAIL;
}


STDMETHODIMP CNodeCallback::IsExpandable(HNODE hNode)
{
    MMC_TRY

    // convert to real type
    CNode* pNode = CNode::FromHandle(hNode);
    ASSERT(pNode != NULL);

    CMTNode* pMTNode = pNode->GetMTNode();
    ASSERT(pMTNode != NULL);

    return pMTNode->IsExpandable();

    MMC_CATCH
}

HRESULT _GetConsoleVerb(CNode* pNode, LPCONSOLEVERB* ppConsoleVerb)
{
    IF_NULL_RETURN_INVALIDARG2(pNode, ppConsoleVerb);

    HRESULT hr = S_FALSE;

    CComponent* pCC = pNode->GetPrimaryComponent();
    ASSERT(pCC != NULL);
    if (pCC == NULL)
        return E_FAIL;

    IFramePrivate* pIFP = pCC->GetIFramePrivate();
    ASSERT(pIFP != NULL);
    if (pIFP == NULL)
        return E_FAIL;

    IConsoleVerbPtr spConsoleVerb;
    hr = pIFP->QueryConsoleVerb(&spConsoleVerb);

    if (SUCCEEDED(hr))
    {
        *ppConsoleVerb = spConsoleVerb.Detach();
        hr = S_OK;
    }

    return hr;
}

STDMETHODIMP CNodeCallback::GetConsoleVerb(HNODE hNode, LPCONSOLEVERB* ppConsoleVerb)
{
    MMC_TRY

    ASSERT(ppConsoleVerb != NULL);

    return _GetConsoleVerb(CNode::FromHandle(hNode), ppConsoleVerb);

    MMC_CATCH
}



// lCookie valid if both bScope & bMultiSel are FALSE.
// lCookie is the index\lParam for virtual\regular LV
STDMETHODIMP
CNodeCallback::GetDragDropDataObject(
    HNODE hNode,
    BOOL bScope,
    BOOL bMultiSel,
    LONG_PTR lvData,
    LPDATAOBJECT* ppDataObject,
    bool& bCopyAllowed,
    bool& bMoveAllowed)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::GetDragDropDataObject"));

    // init allowed op's to false
    bCopyAllowed = false;
    bMoveAllowed = false;

    // parameter check
    sc = ScCheckPointers(ppDataObject);
    if (sc)
        return sc.ToHr();

    // init out parameter;
    *ppDataObject = NULL;

    // get the object
    IMMCClipboardDataObjectPtr spClipBoardDataObject;
    bool bContainsItems = false;
    sc = CMMCClipBoardDataObject::ScCreate( ACTION_DRAG,
                                            CNode::FromHandle(hNode),
                                            bScope, bMultiSel, lvData,
                                            &spClipBoardDataObject,
                                            bContainsItems );
    if (sc)
        return sc.ToHr();

    // We asked for drag&drop dataobject. If snapin does not support cut/copy then
    // the dataobjects will not be added which is not an error.
    if (! bContainsItems)
        return sc.ToHr();

    // QI for IDataObject
    IDataObjectPtr spDataObject = spClipBoardDataObject;
    sc = ScCheckPointers( spDataObject, E_UNEXPECTED );
    if (sc)
        return sc.ToHr();

    // inspect data objects included to see what operations are allowed
    // (note: (spDataObject==valid) -> (spClipBoardDataObject==valid) )
    DWORD dwCount = 0;
    sc = spClipBoardDataObject->GetCount( &dwCount );
    for ( DWORD dwIdx = 0; dwIdx < dwCount; dwIdx ++ )
    {
        IDataObjectPtr spSnapinDO;
        DWORD dwOptions = 0;
        sc = spClipBoardDataObject->GetDataObject( dwIdx, &spSnapinDO, &dwOptions );
        if (sc)
            return sc.ToHr();

        // claculate allowed operations
        bCopyAllowed = bCopyAllowed || ( dwOptions & COPY_ALLOWED );
        bMoveAllowed = bMoveAllowed || ( dwOptions & MOVE_ALLOWED );

        // enabling is inclusive, so very few tests are required
        if ( bCopyAllowed && bMoveAllowed )
            break;
    }

    // return data object
    *ppDataObject = spDataObject.Detach();

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::ScExtractLVData
//
//  Synopsis:    If listview item is selected, see if it is a scope item
//               in non-virtual listview (virtual listviews cannot have
//               scope items in them). If so extract that scope item else
//               the cookie of result item.
//
//  Arguments:   [pNode]  - [in, out] if scope item is selected in resultpane, then
//                                    will contain this scope item on return.
//               [bScope] - [in, out] Is scope item currently selected item (in scope or
//                                    result pane).
//               [lvData] - [in] LVDATA
//               [cookie] - [in] lParam of result item.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CNodeCallback::ScExtractLVData(CNode* pNodeViewOwner,
                                  BOOL bScopePaneSelected,
                                  LONG_PTR lvData,
                                  CNode** ppSelectedNode,
                                  BOOL& bScopeItemSelected,
                                  MMC_COOKIE& cookie)
{
    DECLARE_SC(sc, _T("CNodeCallback::ScExtractLVData"));
    sc = ScCheckPointers(pNodeViewOwner, ppSelectedNode);
    if (sc)
        return sc;

    *ppSelectedNode = NULL;
    bScopeItemSelected = bScopePaneSelected;
    *ppSelectedNode = pNodeViewOwner;

    if (bScopePaneSelected)
    {
        cookie = lvData;
        return sc;
    }

    // Scope pane is not selected.
    CViewData *pViewData = pNodeViewOwner->GetViewData();
    sc = ScCheckPointers(pViewData, E_UNEXPECTED);
    if (sc)
        return sc;

    cookie = lvData;

    if (IS_SPECIAL_LVDATA(lvData))
    {
        if (lvData == LVDATA_BACKGROUND)
            bScopeItemSelected = TRUE;
    }
    else if (! pViewData->IsVirtualList())
    {
        CResultItem* pri = CResultItem::FromHandle (lvData);
        sc = ScCheckPointers(pri, E_UNEXPECTED);
        if (sc)
        {
            cookie = LVDATA_ERROR;
            return sc;
        }

        if (pri->IsScopeItem())
        {
            bScopeItemSelected = TRUE;
            *ppSelectedNode = CNode::FromResultItem(pri);
            sc = ScCheckPointers(*ppSelectedNode, E_UNEXPECTED);
            if (sc)
                return sc;

            cookie = -1;
        }
        else
        {
            cookie = pri->GetSnapinData();
        }

        ASSERT(!IS_SPECIAL_LVDATA(lvData) || !bScopeItemSelected);
    }

    return (sc);
}



STDMETHODIMP
CNodeCallback::GetTaskEnumerator(
    HNODE hNode,
    LPCOLESTR pszTaskGroup,
    IEnumTASK** ppEnumTask)
{
    IF_NULL_RETURN_INVALIDARG3(hNode, pszTaskGroup, ppEnumTask);

    *ppEnumTask = NULL; // init

    // convert to real type
    CNode* pNode = CNode::FromHandle(hNode);

    return pNode->GetTaskEnumerator(CComBSTR(pszTaskGroup), ppEnumTask);

}

STDMETHODIMP
CNodeCallback::GetListPadInfo(HNODE hNode, IExtendTaskPad* pExtendTaskPad,
    LPCOLESTR szTaskGroup, MMC_ILISTPAD_INFO* pIListPadInfo)
{
    IF_NULL_RETURN_INVALIDARG(hNode);

    CNode* pNode = CNode::FromHandle(hNode);
    return pNode->GetListPadInfo(pExtendTaskPad, CComBSTR(szTaskGroup), pIListPadInfo);
}

HRESULT CNodeCallback::OnGetPrimaryTask(CNode* pNode, LPARAM param)
{
    IF_NULL_RETURN_INVALIDARG(pNode);

    IExtendTaskPad** ppExtendTaskPad = reinterpret_cast<IExtendTaskPad**>(param);
    return pNode->OnGetPrimaryTask(ppExtendTaskPad);
}

STDMETHODIMP
CNodeCallback::UpdateWindowLayout(LONG_PTR lViewData, long lToolbarsDisplayed)
{
    IF_NULL_RETURN_INVALIDARG(lViewData);

    CViewData* pVD = reinterpret_cast<CViewData*>(lViewData);
    pVD->UpdateToolbars(lToolbarsDisplayed);
    return S_OK;
}

HRESULT CNodeCallback::PreLoad(HNODE hNode)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::PreLoad"));

    // parameter check
    sc = ScCheckPointers( hNode );
    if (sc)
        return sc.ToHr();

    CNode* pNode = CNode::FromHandle (hNode);
    if (pNode->IsStaticNode() == FALSE ||
        pNode->IsInitialized() == TRUE)
        return (sc = S_FALSE).ToHr();

    // if the node is:
    // 1. a snapin node;
    // 2. marked as "PreLoad"; and,
    // 3. not initialized yet.
    // if all three, then send 'em a notify containing their HSCOPEITEM
    CMTNode* pMTNode = pNode->GetMTNode();
    sc = ScCheckPointers( pMTNode, E_FAIL );
    if (sc)
        return sc.ToHr();

    CMTSnapInNode* pMTSnapInNode = dynamic_cast<CMTSnapInNode*>(pMTNode);
    sc = ScCheckPointers( pMTSnapInNode, E_UNEXPECTED );
    if (sc)
        return sc.ToHr();

    if (!pMTSnapInNode->IsPreloadRequired())
        return (sc = S_FALSE).ToHr();

    if (pMTNode->IsInitialized() == FALSE)
    {
        sc = pMTSnapInNode->Init();
        if (sc)
            return sc.ToHr();
    }

    //
    //  If the snap-in needs to be preloaded, the IComponent also needs
    //  to be init so that the sanpin can insert icons in the result
    //  pane if the parent node is selected in the scope pane.
    //

    ASSERT(pNode->IsInitialized() == FALSE);
    sc = _InitializeNode(pNode);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

STDMETHODIMP CNodeCallback::SetTaskpad(HNODE hNodeSelected, GUID *pGuidTaskpad)
{
    ASSERT(hNodeSelected != NULL);
    ASSERT(pGuidTaskpad != NULL);

    CNode           *pNode           = CNode::FromHandle(hNodeSelected);

    // See ScSetViewExtension for more info on parameters in the call.
    HRESULT hr = pNode->ScSetViewExtension(pGuidTaskpad,
                                           /*bUseDefaultTaskPad*/ false,
                                           /*bSetViewSettingDirty*/ true).ToHr();

    return hr;
}


STDMETHODIMP CNodeCallback::OnCustomizeView (LONG_PTR lViewData)
{
    ::OnCustomizeView ((CViewData*) lViewData);
    return (S_OK);
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::SetViewSettings
//
//  Synopsis:    Modify the view settings data that is persisted.
//
//  Arguments:   [nViewID] - [in] the view id.
//               [hbm]     - [in] bookmark.
//               [hvs]     - [in] view-settings.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeCallback::SetViewSettings(int nViewID, HBOOKMARK hbm, HVIEWSETTINGS hvs)
{
    DECLARE_SC(sc, _T("CNodeCallback::SetViewSettings"));
    sc = ScCheckPointers( (void*)hbm, (void*) hvs);
    if (sc)
        return sc.ToHr();


    CViewSettings *pViewSettings = reinterpret_cast<CViewSettings *>(hvs);
    CBookmark     *pBookmark     = reinterpret_cast<CBookmark*> (hbm);
    sc = CNode::ScSetFavoriteViewSettings(nViewID, *pBookmark, *pViewSettings);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::ExecuteScopeItemVerb
//
//  Synopsis:    Invoke the given verb with given context. Also make sure
//               the verb is enabled by snapin for this context.
//
//  Arguments:   [verb]        - The verb to be invoked.
//               [hNode]       - The node for which above verb is invoked.
//               [lpszNewName] - For "rename" represents new name.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
HRESULT CNodeCallback::ExecuteScopeItemVerb (MMC_CONSOLE_VERB verb, HNODE hNode, LPOLESTR lpszNewName)
{
    DECLARE_SC(sc, _T("CNodeCallback::ExecuteScopeItemVerb"));

    CNode* pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers(pNode);
    if(sc)
        return sc.ToHr();

    // Get data object for the item.
    IDataObjectPtr spDataObject;
    sc = pNode->QueryDataObject(CCT_SCOPE, &spDataObject);
    if (sc)
        return (sc.ToHr());

    BOOL bEnabled = FALSE;
    // see if the verb is enabled by the snapin.
    sc = _ScGetVerbState( pNode, verb, spDataObject,
                          /*bScopePane*/TRUE, /*lResultCookie = */ NULL,
                          /*bMultiSel*/FALSE, bEnabled);
    if (sc)
        return sc.ToHr();

    if (! bEnabled) // Verb not enabled.
        return (sc = ScFromMMC(MMC_E_TheVerbNotEnabled)).ToHr();

    switch(verb)
    {
    case MMC_VERB_PROPERTIES:
        sc = OnProperties(pNode, /*bScope*/ TRUE, /*LPARAM*/ NULL);
        if (sc)
            return sc.ToHr();
        break;

    case MMC_VERB_DELETE:
        sc = OnDelete(pNode, /*bScope*/ TRUE, /*LPARAM*/ NULL);
        if (sc)
            return sc.ToHr();
        break;

    case MMC_VERB_REFRESH:
        sc = OnRefresh(pNode, /*bScope*/ TRUE, /*LPARAM*/ NULL);
        if (sc)
            return sc.ToHr();
        break;

    case MMC_VERB_RENAME:
        {
            // To call Rename we must first initialize SELECTIONINFO.
            SELECTIONINFO selInfo;
            ZeroMemory(&selInfo, sizeof(selInfo));
            selInfo.m_bScope = TRUE;
            selInfo.m_eCmdID = MMC_VERB_RENAME;

            sc = OnRename(pNode, &selInfo, lpszNewName);
            if (sc)
                return sc.ToHr();
        }
        break;

    case MMC_VERB_COPY:
        sc = OnCutCopy(pNode, /*bScope*/ TRUE, NULL, /*bCut*/ FALSE);
        if (sc)
            return sc.ToHr();
        break;

    default:
        sc = E_UNEXPECTED;
        break;
    }

    return (sc.ToHr());
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::ExecuteResultItemVerb
//
//  Synopsis:    Invoke the given verb with given context. Also make sure
//               the verb is enabled by snapin for this context.
//
//  Arguments:   [verb]        - The verb to be invoked.
//               [hNode]       - The node that owns result pane now.
//               [lvData]      - The list view selection context.
//               [lpszNewName] - For "rename" represents new name else NULL.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
HRESULT CNodeCallback::ExecuteResultItemVerb (MMC_CONSOLE_VERB verb, HNODE hNode, LPARAM lvData, LPOLESTR lpszNewName)
{
    DECLARE_SC(sc, _T("CNodeCallback::ExecuteResultItemVerb"));
    CNode* pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers(pNode, E_UNEXPECTED);
    if (sc)
        return (sc.ToHr());

    // We need to see if the given verb is enabled by the snapin. We need
    // dataobject for given context for this. So get the context by calling
    // ScExtractLVData().
    BOOL   bScopeItemSelected;
    CNode *pSelectedNode = NULL;
    MMC_COOKIE cookie = -1;

    sc = CNodeCallback::ScExtractLVData(pNode, /*bScopePaneSelected*/ FALSE, lvData,
                                        &pSelectedNode, bScopeItemSelected, cookie);
    if (sc)
        return sc.ToHr();

    sc = ScCheckPointers(pSelectedNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // Cookie should be valid for result pane.
    if ( (FALSE == bScopeItemSelected) && (cookie == LVDATA_ERROR) )
        return (sc = E_FAIL).ToHr();

    BOOL bMultiSelect = (LVDATA_MULTISELECT == lvData);
    if (bMultiSelect)
        cookie = MMC_MULTI_SELECT_COOKIE;

    // Depending on whether this is scope item in result pane or result item
    // ask ComponentData or Component the data object.
    IDataObjectPtr spDataObject;
    if (bScopeItemSelected)
    {
        sc = pSelectedNode->QueryDataObject (CCT_SCOPE, &spDataObject);
        if (sc)
            return sc.ToHr();
    }
    else
    {
        CComponent* pCC = pNode->GetPrimaryComponent();
        sc = ScCheckPointers(pCC, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        sc = pCC->QueryDataObject(cookie, CCT_RESULT, &spDataObject);
        if (sc)
            return (sc.ToHr());
    }

    BOOL bEnabled = FALSE;
    // See if the verb is enabled for this selection.
    sc =  _ScGetVerbState( pSelectedNode , verb, spDataObject,
                           /*bScopePaneSelected*/ FALSE, lvData,
                           bMultiSelect, bEnabled);
    if (sc)
        return sc.ToHr();

    if (! bEnabled) // Verb not enabled.
        return (sc = ScFromMMC(MMC_E_TheVerbNotEnabled)).ToHr();


    switch(verb)
    {
    case MMC_VERB_PROPERTIES:
        sc = OnProperties(pNode, /*bScope*/ FALSE, /*LPARAM*/ lvData);
        if (sc)
            return sc.ToHr();
        break;

    case MMC_VERB_DELETE:
        sc = OnDelete(pNode, /*bScope*/ FALSE, /*LPARAM*/ lvData);
        if (sc)
            return sc.ToHr();
        break;

    case MMC_VERB_REFRESH:
        sc = OnRefresh(pNode, /*bScope*/ FALSE, /*LPARAM*/ lvData);
        if (sc)
            return sc.ToHr();
        break;

    case MMC_VERB_RENAME:
        {
            // For Rename we should also call ScExtractLVData before calling OnRename.
            // To call Rename we must first initialize SELECTIONINFO.
            SELECTIONINFO selInfo;
            ZeroMemory(&selInfo, sizeof(selInfo));
            selInfo.m_bScope = bScopeItemSelected;
            selInfo.m_lCookie = cookie;
            selInfo.m_eCmdID = MMC_VERB_RENAME;

            sc = OnRename(pNode, &selInfo, lpszNewName);
            if (sc)
                return sc.ToHr();
        }
        break;

    case MMC_VERB_COPY:
        sc = OnCutCopy(pNode, /*bScope*/ FALSE, lvData, /*bCut*/ FALSE);
        if (sc)
            return sc.ToHr();
        break;

    default:
        sc = E_INVALIDARG;
        break;
    }


    return (sc.ToHr());
}



/*+-------------------------------------------------------------------------*
 *
 * FUNCTION:  CNodeCallback::QueryCompDataDispatch
 *
 * PURPOSE:   Get the disp interface for given scope node object from snapin.
 *
 * PARAMETERS:
 *    PNODE            - The Node object for which the disp interface is required.
 *    PPDISPATCH [out] - Disp interface pointer returned by snapin.
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CNodeCallback::QueryCompDataDispatch(PNODE pNode, PPDISPATCH ppScopeNodeObject)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::QueryCompDataDispInterface"));
    sc = ScCheckPointers(m_pCScopeTree);
    if(sc)
        return sc.ToHr();

    CMTNode *pMTNode = NULL;
    sc = m_pCScopeTree->ScGetNode(pNode, &pMTNode);
    if(sc)
        return sc.ToHr();

    sc = ScCheckPointers(pMTNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = pMTNode->ScQueryDispatch(CCT_SCOPE, ppScopeNodeObject);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::QueryComponentDispatch
//
//  Synopsis:   Get the disp interface for given item in resultpane from snapin.
//
//  Arguments:
//         HNODE            - The Scope Node which owns result pane.
//         LVDATA           - The LVDATA of selected item
//         PPDISPATCH [out] - Disp interface pointer returned by snapin.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
HRESULT CNodeCallback::QueryComponentDispatch (HNODE hNode,
                                               LPARAM lvData,
                                               PPDISPATCH SelectedObject)
{
    DECLARE_SC(sc, _T("CNodeCallback::QueryComponentDispatch"));
    CNode* pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc.ToHr();

    BOOL   bScopeItemSelected;
    CNode *pSelectedNode = NULL;
    MMC_COOKIE cookie = -1;

    sc = CNodeCallback::ScExtractLVData(pNode, /*bScopePaneSelected*/ FALSE, lvData,
                                        &pSelectedNode, bScopeItemSelected, cookie);
    if (sc)
        return sc.ToHr();

    /*
     * In case of multiselection, set cookie to MMC_MULTI_SELECT_COOKIE
     * which snapins can understand.
     */
    BOOL bMultiSelect = (LVDATA_MULTISELECT == lvData);
    if (bMultiSelect)
    {
        cookie = MMC_MULTI_SELECT_COOKIE;
        ASSERT(bScopeItemSelected == false);
    }

    sc = ScCheckPointers(pSelectedNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // If result-pane cookie should be valid.
    if ( (FALSE == bScopeItemSelected) && (cookie == LVDATA_ERROR) )
        return (sc = E_FAIL).ToHr();

    // Scope item is selected in result pane.
    if (bScopeItemSelected)
    {
        CMTNode* pMTNode = pSelectedNode->GetMTNode();
        sc = ScCheckPointers(pMTNode, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        sc = pMTNode->ScQueryDispatch(CCT_SCOPE, SelectedObject);
        if (sc)
            return sc.ToHr();
    }
    else
    {
        CComponent* pCC = pSelectedNode->GetPrimaryComponent();
        sc = ScCheckPointers(pCC, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        sc = pCC->ScQueryDispatch(cookie, CCT_RESULT, SelectedObject);
        if (sc)
            return sc.ToHr();
    }

    return (sc.ToHr());
}


/***************************************************************************\
 *
 * METHOD:  CNodeCallback::ShowColumn
 *
 * PURPOSE: Shows/hides the column. Implements both UI part as snapin notifications
 *          Used as helper implementing functionality for Column com object.
 *          [uses CNode to perform the task]
 *
 * PARAMETERS:
 *    HNODE hNodeSelected - scope node - oener of the view
 *    int iColIndex       - column index to perform action on
 *    bool bVisible       - show/hide flag for operation
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
STDMETHODIMP CNodeCallback::ShowColumn(HNODE hNodeSelected, int iColIndex, bool bShow)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::ShowColumn"));

    // get CNode pointer
    CNode* pNode = CNode::FromHandle(hNodeSelected);
    sc = ScCheckPointers(pNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = pNode->ScShowColumn(iColIndex, bShow);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CNodeCallback::GetSortColumn
 *
 * PURPOSE: retrieves index of sort column
 *          Used as helper implementing functionality for Column com object.
 *          [uses CNode to perform the task]
 *
 * PARAMETERS:
 *    HNODE hNodeSelected - scope node - oener of the view
 *    int *piSortCol      - resulting index
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
STDMETHODIMP CNodeCallback::GetSortColumn(HNODE hNodeSelected, int *piSortCol)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::GetSortColumn"));

    // get CNode pointer
    CNode* pNode = CNode::FromHandle(hNodeSelected);
    sc = ScCheckPointers(pNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = pNode->ScGetSortColumn(piSortCol);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CNodeCallback::SetSortColumn
 *
 * PURPOSE: sorts result data by specified column
 *          Used as helper implementing functionality for Column com object.
 *          [uses CNode to perform the task]
 *
 * PARAMETERS:
 *    HNODE hNodeSelected - scope node - oener of the view
 *    int iSortCol        - sort column index
 *    bool bAscending     - sort order
 *
 * RETURNS:
 *    HRESULT
 *
\***************************************************************************/
STDMETHODIMP CNodeCallback::SetSortColumn(HNODE hNodeSelected, int iSortCol, bool bAscending)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::SetSortColumn"));

    // get CNode pointer
    CNode* pNode = CNode::FromHandle(hNodeSelected);
    sc = ScCheckPointers(pNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = pNode->ScSetSortColumn(iSortCol, bAscending);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}


/***************************************************************************\
 *
 * METHOD:  CNodeCallback::RestoreResultView
 *
 * PURPOSE: Called by conui to restore the result view with given data.
 *          This method asks snapin (indirectly) to restore the view.
 *
 * PARAMETERS:
 *    HNODE hNode          - scope node - oener of the view
 *    CResultViewType rvt  - The resultview type data to be used for restore.
 *
 * RETURNS:
 *    HRESULT   S_OK    if snapin used the data to restore the view
 *              S_FALSE if snapin refused to restore.
 *
\***************************************************************************/
STDMETHODIMP CNodeCallback::RestoreResultView(HNODE hNode, const CResultViewType& rvt)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::RestoreResultView"));

    // get CNode pointer
    CNode* pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc.ToHr();

    sc = pNode->ScRestoreResultView(rvt);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CNodeCallback::GetNodeViewExtensions
 *
 * PURPOSE: Forwards calls to CNode to collect view extensions
 *
 * PARAMETERS:
 *    HNODE hNodeScope
 *    CViewExtInsertIterator it
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
STDMETHODIMP CNodeCallback::GetNodeViewExtensions(/*[in]*/ HNODE hNodeScope, /*[out]*/ CViewExtInsertIterator it)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::GetNodeViewExtensions"));

    // get CNode pointer
    CNode* pNode = CNode::FromHandle(hNodeScope);
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc.ToHr();

    sc = pNode->ScGetViewExtensions(it);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::SaveColumnInfoList
//
//  Synopsis:    The column-data for given node has changed persist the
//               new column data.
//
//  Arguments:   [hNode] - Node that owns result-pane.
//               [columnsList] - The new column-data.
//
//  Note:        The sort-data is not given by this call, so do not change it.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
HRESULT CNodeCallback::SaveColumnInfoList (HNODE hNode, const CColumnInfoList& columnsList)
{
    DECLARE_SC(sc, _T("CNodeCallback::SaveColumnInfoList"));
    sc = ScCheckPointers(hNode);
    if (sc)
        return sc.ToHr();

    CNode *pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc.ToHr();

    CViewData *pViewData = pNode->GetViewData();
    sc = ScCheckPointers(pViewData, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    CLSID          guidSnapin;
    CXMLAutoBinary columnID;
    sc = pNode->ScGetSnapinAndColumnDataID(guidSnapin, columnID);
    if (sc)
        return sc.ToHr();

    CXMLBinaryLock sLock(columnID);
    SColumnSetID* pColID = NULL;
    sc = sLock.ScLock(&pColID);
    if (sc)
        return sc.ToHr();

    sc = ScCheckPointers(pColID, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // Get the old persisted column data. This contains width values
    // for hidden columns which is used if the column is un-hidden.
    CColumnSetData columnSetData;
    BOOL bRet = pViewData->RetrieveColumnData(guidSnapin, *pColID, columnSetData);

    if (bRet)
    {
        CColumnInfoList*  pColInfoListOld = columnSetData.get_ColumnInfoList();

        if (columnsList.size() == pColInfoListOld->size())
        {
            // Merge the persisted column width for hidden columns
            // to the new list created.
            CColumnInfoList::iterator itColInfo1;
            CColumnInfoList::iterator itColInfo2;

            for (itColInfo1 = pColInfoListOld->begin(), itColInfo2 = columnsList.begin();
                 itColInfo1 != pColInfoListOld->end(); ++itColInfo1, ++itColInfo2)
            {
                if (itColInfo2->IsColHidden())
                    itColInfo2->SetColWidth(itColInfo1->GetColWidth());
            }
        }
    }

    // Set the new columns list in column-set-data.
    columnSetData.set_ColumnInfoList(columnsList);

    // Save the data.
    sc = pViewData->ScSaveColumnInfoList(guidSnapin, *pColID, columnsList);
    if (sc)
        return sc.ToHr();

    return (sc.ToHr());
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::GetPersistedColumnInfoList
//
//  Synopsis:    The list-view requests the column-data (no sort data) to setup the headers
//               before any items are inserted into the list-view.
//               (Note: Modify headers after all columns are inserted before any list-view
//                      items will be inserted to reduce flicker).
//
//  Arguments:   [hNode] - node that owns result-pane for which column-data is needed.
//               [pColumnsList] - [out param], the column-data.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
HRESULT CNodeCallback::GetPersistedColumnInfoList (HNODE hNode, CColumnInfoList *pColumnsList)
{
    DECLARE_SC(sc, _T("CNodeCallback::GetPersistedColumnInfoList"));
    sc = ScCheckPointers(hNode, pColumnsList);
    if (sc)
        return sc.ToHr();

    CNode *pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc.ToHr();

    CViewData *pViewData = pNode->GetViewData();
    sc = ScCheckPointers(pViewData, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    CLSID          guidSnapin;
    CXMLAutoBinary columnID;
    sc = pNode->ScGetSnapinAndColumnDataID(guidSnapin, columnID);
    if (sc)
        return sc.ToHr();

    CXMLBinaryLock sLock(columnID);
    SColumnSetID* pColID = NULL;
    sc = sLock.ScLock(&pColID);
    if (sc)
        return sc.ToHr();

    sc = ScCheckPointers(pColID, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // Get the old persisted column data. This contains width values
    // for hidden columns which is used if the column is un-hidden.
    CColumnSetData columnSetData;
    BOOL bRet = pViewData->RetrieveColumnData(guidSnapin, *pColID, columnSetData);

    if (!bRet)
        return (sc = S_FALSE).ToHr();

    CColumnInfoList *pColListOriginal = columnSetData.get_ColumnInfoList();
    if (!pColListOriginal)
        return (sc = S_FALSE).ToHr();

    *pColumnsList = *pColListOriginal;

    return (sc.ToHr());
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::DeletePersistedColumnData
//
//  Synopsis:    The column data for given node is invalid, remove it.
//
//  Arguments:   [hNode] - The node for which the data is invalid.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
HRESULT CNodeCallback::DeletePersistedColumnData(HNODE hNode)
{
    DECLARE_SC(sc, _T("CNodeCallback::DeletePersistedColumnData"));
    sc = ScCheckPointers(hNode);
    if (sc)
        return sc.ToHr();

    CNode *pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc.ToHr();

    CViewData *pViewData = pNode->GetViewData();
    sc = ScCheckPointers(pViewData, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    CLSID          guidSnapin;
    CXMLAutoBinary columnID;
    sc = pNode->ScGetSnapinAndColumnDataID(guidSnapin, columnID);
    if (sc)
        return sc.ToHr();

    CXMLBinaryLock sLock(columnID);
    SColumnSetID* pColID = NULL;
    sc = sLock.ScLock(&pColID);
    if (sc)
        return sc.ToHr();

    sc = ScCheckPointers(pColID, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // Get the old persisted column data. This contains width values
    // for hidden columns which is used if the column is un-hidden.
    pViewData->DeleteColumnData(guidSnapin, *pColID);

    return (sc.ToHr());
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::DoesAboutExist
//
//  Synopsis:    See if about information exists for given node's snapin.
//
//  Arguments:   [hNode]         -
//               [pbAboutExists] - out param, ptr to bool, true if about exists.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeCallback::DoesAboutExist (HNODE hNode, bool *pbAboutExists)
{
    DECLARE_SC(sc, _T("CNodeCallback::DoesAboutExist"));
    sc = ScCheckPointers(hNode, pbAboutExists);
    if (sc)
        return sc.ToHr();

    *pbAboutExists = false;

    CNode *pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc.ToHr();

    // No about for console root eventhough it is a Folder snapin.
    if (pNode->IsConsoleRoot())
        return sc.ToHr();

    CLSID        clsidAbout;
    const CLSID& clsidSnapin = pNode->GetPrimarySnapInCLSID();
    SC scNoTrace = ScGetAboutFromSnapinCLSID(clsidSnapin, clsidAbout);
    if (scNoTrace)
        return scNoTrace.ToHr();

    CSnapinAbout snapinAbout;
    snapinAbout.GetSnapinInformation(clsidAbout);
    sc = snapinAbout.GetObjectStatus();
    if (sc)
        return sc.ToHr();

    *pbAboutExists = true;

    return (sc.ToHr());
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::ShowAboutInformation
//
//  Synopsis:    Given the context of currently selected item.
//               Show its about information.
//
//  Arguments:   [hNode]   - scope node that owns result pane.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeCallback::ShowAboutInformation (HNODE hNode)
{
    DECLARE_SC(sc, _T("CNodeCallback::ShowAboutInformation"));
    sc = ScCheckPointers(hNode);
    if (sc)
        return sc.ToHr();

    CNode *pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc.ToHr();

    CLSID        clsidAbout;
    const CLSID& clsidSnapin = pNode->GetPrimarySnapInCLSID();
    sc = ScGetAboutFromSnapinCLSID(clsidSnapin, clsidAbout);
    if (sc)
        return sc.ToHr();

    CSnapinAbout snapinAbout;
    snapinAbout.GetSnapinInformation(clsidAbout);

    USES_CONVERSION;
    tstring szSnapinName;
    if (GetSnapinNameFromCLSID(clsidSnapin, szSnapinName))
        snapinAbout.SetSnapinName(T2COLE(szSnapinName.data()));

    sc = snapinAbout.GetObjectStatus();
    if (sc)
        return sc.ToHr();

    snapinAbout.ShowAboutBox();

    return (sc.ToHr());
}

/*+-------------------------------------------------------------------------*
 *
 * CNodeCallback::ExecuteShellCommand
 *
 * PURPOSE: Executes a shell command with the specified parameters in the
 *          specified directory with the correct window size
 *
 * PARAMETERS:
 *    HNODE  hNode :
 *    BSTR   Command :
 *    BSTR   Directory :
 *    BSTR   Parameters :
 *    BSTR   WindowState :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CNodeCallback::ExecuteShellCommand(HNODE hNode, BSTR Command, BSTR Directory, BSTR Parameters, BSTR WindowState)
{
    DECLARE_SC(sc, TEXT("CNodeCallback::ExecuteShellCommand"));

    sc = ScCheckPointers(hNode);
    if (sc)
        return sc.ToHr();

    CNode *pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc.ToHr();

    sc = pNode->ScExecuteShellCommand(Command, Directory, Parameters, WindowState);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::QueryPasteFromClipboard
//
//  Synopsis:    Given the context of paste target, get the clipboard dataobject
//               and see if target allows paste.
//
//  Arguments:   [hNode] -
//               [bScope] -
//               [lCookie] - All above params describe paste target context.
//               [bPasteAllowed] - [out]
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeCallback::QueryPasteFromClipboard (HNODE hNode, BOOL bScope, LPARAM lCookie, bool& bPasteAllowed)
{
    DECLARE_SC(sc, _T("CNodeCallback::QueryPasteFromClipboard"));
    sc = ScCheckPointers(hNode);
    if (sc)
        return sc.ToHr();

    // 1. Get the current dataobject from clipboard.
    IDataObjectPtr spDOPaste;
    sc = OleGetClipboard(&spDOPaste);
    if (sc)
        return sc.ToHr();

    sc = ScCheckPointers(spDOPaste, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    bool bCopyOperatationIsDefault = false; /*unused*/

    sc = QueryPaste(hNode, bScope, lCookie, spDOPaste, bPasteAllowed, bCopyOperatationIsDefault);
    if (sc)
        return sc.ToHr();

    return (sc.ToHr());
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::QueryPaste
//
//  Synopsis:    Given the context for current selection which is the target
//               for paste (or drop). Find out it can paste given dataobject.
//
//  Arguments:   [hNode]              - The node owning the view.
//               [bScope]             - Selection on Scope or Result pane.
//               [lCookie]            - If result pane selected the cookie for selected result item.
//               [pDataObjectToPaste] - The dataobject to be pasted.
//               [bPasteAllowed]      - [out param], paste was permitted or not.
//               [bCopyOperatationIsDefault] - [out param], is copy default operation (for r-click&l-click drag&drop)
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeCallback::QueryPaste (HNODE hNode, BOOL bScopePaneSelected, LPARAM lCookie,
                                        IDataObject *pDataObjectToPaste,
                                        bool& bPasteAllowed, bool& bCopyOperatationIsDefault)
{
    DECLARE_SC(sc, _T("CNodeCallback::NewQueryPaste"));
    bPasteAllowed = false;
    sc = ScCheckPointers(hNode, pDataObjectToPaste);
    if (sc)
        return sc.ToHr();

    CNode *pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers(pNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // If result-pane cookie should be valid.
    BOOL   bScopeItemSelected;
    CNode *pSelectedNode = NULL;
    MMC_COOKIE cookie = -1;

    sc = CNodeCallback::ScExtractLVData(pNode, bScopePaneSelected, lCookie,
                                        &pSelectedNode, bScopeItemSelected, cookie);
    if (sc)
        return sc.ToHr();

    sc = ScCheckPointers(pSelectedNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    if ( (FALSE == bScopeItemSelected) && (cookie == LVDATA_ERROR) )
        return (sc = E_FAIL).ToHr();

    CViewData *pViewData = pSelectedNode->GetViewData();
    sc = ScCheckPointers(pViewData, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    // Do not allow paste into OCX/WEB/Multiselection
    // We can allow paste into OCX/WEB if we expose IMMCClipboardDataObject
    // interface. But paste into Multiselection should not be allowed as
    // it is not intuitive.
    if ( (!bScopeItemSelected) && IS_SPECIAL_COOKIE(lCookie))
        return sc.ToHr();

    /*
     * In MMC1.2 the drop target is always scope node. In MMC2.0
     * it can be any result item. If the snapin has RVTI_LIST_OPTIONS_ALLOWPASTE
     * set, then we need to provide proper parameters to below _GetVerbState.
     */
    if ( (bScopeItemSelected == FALSE) && (! (RVTI_LIST_OPTIONS_ALLOWPASTE & pViewData->GetListOptions())) )
        return sc.ToHr();

    IDataObjectPtr spTargetDataObject;
    sc = pSelectedNode->ScGetDropTargetDataObject(bScopeItemSelected, lCookie, &spTargetDataObject);
    if (sc)
        return sc.ToHr();

    sc = ScCheckPointers(spTargetDataObject, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    BOOL bFlag = FALSE;
    sc = _ScGetVerbState(pSelectedNode, MMC_VERB_PASTE, spTargetDataObject,
                         bScopeItemSelected, lCookie, /*bMultiSel*/FALSE, bFlag);
    if (sc)
        return sc.ToHr();

    if (!bFlag)
        return sc.ToHr();

    // QI to see if it is MMC's data object
    IMMCClipboardDataObjectPtr spMMCClipboardDataObj = pDataObjectToPaste;

    if (spMMCClipboardDataObj)
    {
        // This is our own dataobject.

        // 3. Get how, where it is created, and how many snapin objects are there.
        DWORD dwSourceProcess = 0;
        sc = spMMCClipboardDataObj->GetSourceProcessId( &dwSourceProcess );
        if (sc)
            return sc.ToHr();

        // If from different process then ask snapin if it can handle out of proc dataobjects.
        BOOL bSourceFromDifferentMMCProcess = ( dwSourceProcess != ::GetCurrentProcessId() );

        DWORD dwNumObjects = 0;
        sc = spMMCClipboardDataObj->GetCount(&dwNumObjects);
        if (sc)
            return sc.ToHr();

        // 4. For each snapin object, get the dataobject and ask target item if
        //    it can allow the source to be pasted.
        for (DWORD index = 0; index < dwNumObjects; ++index)
        {
            IDataObjectPtr spSourceDataObject;
            DWORD dwFlags = 0;
            sc = spMMCClipboardDataObj->GetDataObject( index, &spSourceDataObject, &dwFlags );
            if (sc)
                return sc.ToHr();

            sc = ScCheckPointers(spSourceDataObject, E_UNEXPECTED);
            if (sc)
                return sc.ToHr();

            // must have some operation allowed - else it is invalid entry
            if ( dwFlags == 0 )
                return (sc = E_UNEXPECTED).ToHr();
            /*
             * During construction of th MMCClipboardDataObject we have checked if
             * cut/copy is enabled before adding the snapin dataobject.
             * So we are sure now atleast cut or copy is enabled for each snapin
             * object and we dont have to check this again.
             */

            bool bSnapinPasteAllowed = false;
            bool bSnapinWantsCopyAsDefault = false;
            sc = _ScQueryPaste (pSelectedNode, spTargetDataObject, spSourceDataObject,
                                bSourceFromDifferentMMCProcess, bSnapinPasteAllowed,
                                bSnapinWantsCopyAsDefault);
            if (sc)
                return sc.ToHr();

            bPasteAllowed = bPasteAllowed || bSnapinPasteAllowed;
            bCopyOperatationIsDefault = bCopyOperatationIsDefault || bSnapinWantsCopyAsDefault;
        }

    }
    else
    {
        // We do not recognize the dataobject and we dont know if it is from
        // this MMC process or from any other process. So do not ask snapin if
        // it can handle outofproc dataobjects or not. (This is MMC1.2 legacy case).

        sc = _ScQueryPaste (pSelectedNode, spTargetDataObject, pDataObjectToPaste,
                             /*bSourceFromDifferentMMCProcess = */ false,
                             bPasteAllowed, bCopyOperatationIsDefault);
        if (sc)
            return sc.ToHr();
    }

    return (sc.ToHr());
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::_ScQueryPaste
//
//  Synopsis:    Send MMCN_QUERY_PASTE(2) to the snapin.
//
//  Arguments:   [pNode]              - Owner of result pane.
//               [spTargetDataObject] - Target object where we want to paste.
//               [spSourceDataObject] - The object that we want to paste.
//               [bSourceFromDifferentMMCProcess] -
//               [bPasteAllowed]            - out param
//               [bCopyOperationIsDefault]  - out param
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CNodeCallback::_ScQueryPaste (CNode *pNode,
                                 IDataObject *pTargetDataObject,
                                 IDataObject *pSourceDataObject,
                                 bool bSourceFromDifferentMMCProcess,
                                 bool& bPasteAllowed,
                                 bool& bCopyOperatationIsDefault)
{
    DECLARE_SC(sc, _T("CNodeCallback::_ScQueryPaste"));
    sc = ScCheckPointers(pNode, pTargetDataObject, pSourceDataObject);
    if (sc)
        return sc;

    bCopyOperatationIsDefault = false;
    bPasteAllowed             = false;

    CComponent* pCC = pNode->GetPrimaryComponent();
    sc = ScCheckPointers(pCC, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    BOOL bCanPasteOutOfProcDataObject = FALSE;

    sc = pCC->Notify(NULL, MMCN_CANPASTE_OUTOFPROC,
                     0, reinterpret_cast<LPARAM>(&bCanPasteOutOfProcDataObject) );

    // Snapins return E_* values so check if they are OK with above notification.
    if ( sc != S_OK)
    {
        bCanPasteOutOfProcDataObject = false;
        sc.Clear();
    }

    // Source from diff MMC process & cannot handle outofproc dataobjects then return.
    if (bSourceFromDifferentMMCProcess && (! bCanPasteOutOfProcDataObject) )
        return sc.ToHr();

    // Send MMCN_QUERY_PASTE
    DWORD dwFlags = 0;
    sc = pCC->Notify(pTargetDataObject, MMCN_QUERY_PASTE,
                     reinterpret_cast<LPARAM>(pSourceDataObject),
                     reinterpret_cast<LPARAM>(&dwFlags));
    if (sc)
    {
        // Clear any snapin returned errors.
        sc.Clear();
        return sc.ToHr();
    }

    if (sc == SC(S_OK))
        bPasteAllowed = true;

    bCopyOperatationIsDefault = (dwFlags & MMC_DEFAULT_OPERATION_COPY);

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::Drop
//
//  Synopsis:    Given the drop object context & the source object to
//               be dropped. Do paste operation.
//
//  Arguments:   [hNode]              - The node owning the view.
//               [bScope]             - Selection on Scope or Result pane.
//               [lCookie]            - If result pane selected the cookie for selected result item.
//               [pDataObjectToPaste] - The dataobject to be pasted.
//               [bIsDragOperationMove]- Is the drag operation move or copy.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeCallback::Drop (HNODE hNode, BOOL bScope, LPARAM lCookie, IDataObject *pDataObjectToPaste, BOOL bIsDragOperationMove)
{
    DECLARE_SC(sc, _T("CNodeCallback::Drop"));
    sc = ScCheckPointers(hNode, pDataObjectToPaste);
    if (sc)
        return sc.ToHr();

    sc = ScPaste(hNode, bScope, lCookie, pDataObjectToPaste, TRUE, bIsDragOperationMove);
    if (sc)
        return sc.ToHr();

    return (sc.ToHr());
}



//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::Paste
//
//  Synopsis:    Given the target where the clipboard object is to be
//               pasted. Paste the object.
//
//  Arguments:   [hNode]              - The node owning the view.
//               [bScope]             - Selection on Scope or Result pane.
//               [lCookie]            - If result pane selected the cookie for selected result item.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeCallback::Paste (HNODE hNode, BOOL bScope, LPARAM lCookie)
{
    DECLARE_SC(sc, _T("CNodeCallback::Paste"));
    sc = ScCheckPointers(hNode);
    if (sc)
        return sc.ToHr();

    IDataObjectPtr spDOPaste;
    sc = OleGetClipboard(&spDOPaste);
    if (sc)
        return sc.ToHr();

    sc = ScCheckPointers(spDOPaste, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = ScPaste(hNode, bScope, lCookie, spDOPaste, /*bDragDrop*/FALSE, FALSE);
    if (sc)
        return sc.ToHr();

    return (sc.ToHr());
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::ScPaste
//
//  Synopsis:   Given the current drop target (or paste target) context
//              paste the given data object if it is drag&drop operation
//              else paste the one from clipboard.
//
//  Arguments:   [hNode]               - The node owning the view.
//               [bScopePaneSelected]  - Selection on Scope or Result pane.
//               [lCookie]             - If result pane selected the cookie for selected result item.
//               [pDataObjectToPaste]  - The dataobject to be pasted.
//               [bDragDrop]           - Is the operation drag & drop operation.
//               [bIsDragOperationMove]- Is the drag operation move or copy.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CNodeCallback::ScPaste (HNODE hNode, BOOL bScopePaneSelected, LPARAM lCookie,
                           IDataObject *pDataObjectToPaste, BOOL bDragDrop,
                           BOOL bIsDragOperationMove)
{
    DECLARE_SC(sc, _T("CNodeCallback::Paste"));
    sc = ScCheckPointers(hNode, pDataObjectToPaste);
    if (sc)
        return sc;

    CNode *pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers(pNode, E_UNEXPECTED);
    if (sc)
        return sc;

    // If result-pane cookie should be valid.
    BOOL   bScopeItemSelected;
    CNode *pSelectedNode = NULL;
    MMC_COOKIE cookie = -1;

    sc = CNodeCallback::ScExtractLVData(pNode, bScopePaneSelected, lCookie,
                                        &pSelectedNode, bScopeItemSelected, cookie);
    if (sc)
        return sc;

    sc = ScCheckPointers(pSelectedNode, E_UNEXPECTED);
    if (sc)
        return sc;

    if ( (FALSE == bScopeItemSelected) && (cookie == LVDATA_ERROR) )
        return (sc = E_FAIL);

    CViewData *pViewData = pSelectedNode->GetViewData();
    sc = ScCheckPointers(pViewData, E_UNEXPECTED);
    if (sc)
        return sc;

    // Do not allow paste into OCX/WEB/Multiselection
    // We can allow paste into OCX/WEB if we expose IMMCClipboardDataObject
    // interface. But paste into Multiselection should not be allowed as
    // it is not intuitive.
    if ( (!bScopeItemSelected) && IS_SPECIAL_COOKIE(lCookie))
        return sc;

    /*
     * In MMC1.2 the drop target is always scope node. In MMC2.0
     * it can be any result item.
     * Make sure if the snapin has RVTI_LIST_OPTIONS_ALLOWPASTE.
     */
    if ( (bScopeItemSelected == FALSE) && (! (RVTI_LIST_OPTIONS_ALLOWPASTE & pViewData->GetListOptions())) )
    {
        ASSERT(0 && "UNEXPECTED: We can paste only into a folder!");
        // We can paste only into a folder.
        return (sc = E_FAIL);
    }

    if (pSelectedNode->IsInitialized() == FALSE)
    {
        sc = _InitializeNode(pSelectedNode);
        if (sc)
            return sc;
    }

    IDataObject* pTargetDataObject = NULL;
    sc = pSelectedNode->ScGetDropTargetDataObject(bScopeItemSelected, lCookie, &pTargetDataObject);
    if (sc)
        return sc;

    IDataObjectPtr spTargetDataObject;
    if (! IS_SPECIAL_DATAOBJECT(pTargetDataObject))
        spTargetDataObject = pTargetDataObject;          // Addref the object

    sc = ScCheckPointers(pTargetDataObject, E_UNEXPECTED);
    if (sc)
        return sc;

    // QI to see if it is MMC's data object
    IMMCClipboardDataObjectPtr spMMCClipboardDataObj = pDataObjectToPaste;

    if (spMMCClipboardDataObj)
    {
        // This is our own dataobject.

        // 3. Get how, where it is created, and how many snapin objects are there.

        DATA_SOURCE_ACTION eSourceAction;
        sc = spMMCClipboardDataObj->GetAction( &eSourceAction );
        if (sc)
            return sc;

        BOOL bIsCreatedForCut = FALSE;
        BOOL bIsCreatedForCopy = FALSE;

        if (bDragDrop)
        {
            bIsCreatedForCut  = bIsDragOperationMove;
            bIsCreatedForCopy = !bIsDragOperationMove;
        }
        else
        {
            bIsCreatedForCut =  ( eSourceAction == ACTION_CUT );
            bIsCreatedForCopy = ( eSourceAction == ACTION_COPY );
        }

        DWORD dwNumObjects = 0;
        sc = spMMCClipboardDataObj->GetCount(&dwNumObjects);
        if (sc)
            return sc;

        BOOL bDoCutOperation  = FALSE;
        BOOL bDoCopyOperation = FALSE;

        // 4. For each snapin object, get the dataobject and ask target to paste it.

        // need to form the array of copy objects, so that we do not delete them while
        // processing - this invalidates data object and prevents accessing the rest of
        // items
        std::vector<IDataObjectPtr> vecObjectsToCopy;
        std::vector<DWORD> vecObjectFlags;

        vecObjectsToCopy.reserve(dwNumObjects); // small optimization
        vecObjectFlags.reserve(dwNumObjects);   // small optimization

        // fill with data objects to copy
        for (DWORD index = 0; index < dwNumObjects; ++index)
        {
            IDataObjectPtr spSourceDataObject;
            DWORD dwFlags = 0;
            sc = spMMCClipboardDataObj->GetDataObject( index, &spSourceDataObject, &dwFlags );
            if (sc)
                return sc;

            vecObjectsToCopy.push_back( spSourceDataObject );
            vecObjectFlags.push_back( dwFlags );
        }

        // perform action on the data
        for (index = 0; index < dwNumObjects; ++index)
        {
            IDataObjectPtr spSourceDataObject = vecObjectsToCopy[index];
            DWORD dwFlags = vecObjectFlags[index];

            sc = ScCheckPointers(spSourceDataObject, E_UNEXPECTED);
            if (sc)
                return sc;

            BOOL bHasCutEnabled =  ( dwFlags & MOVE_ALLOWED );
            BOOL bHasCopyEnabled = ( dwFlags & COPY_ALLOWED );

            /*
             * In case of multiselection even if one of the selected
             * object enables cut, the cut operation can be performed.
             *
             * But when we paste the objects we need to see if source
             * enabled cut or not. If it did not enable then do nothing.
             *
             * Below is a table for this.
             *
             *                          Source object enables (only)
             *          -------------------------------------------
             *          |Operation   |     Cut    |    Copy       |
             *          -------------------------------------------
             *          |            |            |               |
             *          |  Cut       |   Cut      |  Do nothing   |
             * Current  |            |            |               |
             * Operation|-----------------------------------------
             *          |            |            |               |
             *          | Copy       | Do nothing |    Copy       |
             *          |            |            |               |
             *          -------------------------------------------
             */
            bDoCutOperation  = (bIsCreatedForCut && bHasCutEnabled);
            bDoCopyOperation = (bIsCreatedForCopy && bHasCopyEnabled);

            // See above table: this is "Do nothing".
            if ( (!bDoCutOperation) && (!bDoCopyOperation) )
                continue;

            IDataObjectPtr spCutDataObject;
            sc = _ScPaste (pSelectedNode, pTargetDataObject,
                           spSourceDataObject, &spCutDataObject,
                           bDoCutOperation );
            if (sc)
                return sc;

            // remove cut items when required
            if (bDoCutOperation && spCutDataObject != NULL)
            {
                sc = spMMCClipboardDataObj->RemoveCutItems( index, spCutDataObject );
                if (sc)
                    return sc;
            }
        }

        // If this is cut operation that is initiated by cut/copy/paste and
        // not by drag & drop operation then the dataobject in clipboard is
        // ours. So clear the clipboard so that we dont use that dataobject.
        if ( eSourceAction == ACTION_CUT )
            OleSetClipboard(NULL);
    }
    else
    {
        // We do not recognize the dataobject and we dont know if it is from
        // this MMC process or from any other process. We cannot decode this
        // dataobject so we just send MMCN_PASTE and ignore any dataobject
        // retuned by snapin for cut operation (this is legacy case).

        // for drag operation we can give a hint to snapin
        // what operation (copy/move) was attempted.
        // however we are not ensuring deletion of source items
        bool bCutOrMove = (bDragDrop && bIsDragOperationMove);

        IDataObjectPtr spCutDataObject;
        sc = _ScPaste (pSelectedNode, pTargetDataObject,
                       pDataObjectToPaste, &spCutDataObject,
                       bCutOrMove );
        if (sc)
            return sc;
    }

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::_ScPaste
//
//  Synopsis:    Send MMCN_PASTE to snapin.
//
//  Arguments:   [pNode] - Owner of resultpane.
//               [pTargetDataObject] - target where we need to paste.
//               [pSourceDataObject] - source to be pasted.
//               [ppCutDataObject] - (out) cut items
//               [bCutOrMove]
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CNodeCallback::_ScPaste (CNode *pNode,
                            IDataObject *pTargetDataObject,
                            IDataObject *pSourceDataObject,
                            IDataObject **ppCutDataObject,
                            bool bCutOrMove)
{
    DECLARE_SC(sc, _T("CNodeCallback::_ScSendPasteNotification"));
    sc = ScCheckPointers(pNode, pTargetDataObject, pSourceDataObject, ppCutDataObject);
    if (sc)
        return sc;

    // init out param
    *ppCutDataObject = NULL;

    CComponent* pComponent = pNode->GetPrimaryComponent();
    sc = ScCheckPointers(pComponent, E_UNEXPECTED);
    if (sc)
        return sc;

    IDataObject* pDataObjectToBeCutBySource = NULL;
    sc = pComponent->Notify(pTargetDataObject, MMCN_PASTE,
                            reinterpret_cast<LPARAM>(pSourceDataObject),
                            bCutOrMove ? reinterpret_cast<LPARAM>(&pDataObjectToBeCutBySource) : NULL);
    if (sc)
        return sc;

    if (! bCutOrMove)
        return sc;

    // Exchange returns NULL dataobject. Do not trace error to be compatible with MMC1.2
    if ( (pDataObjectToBeCutBySource) && (IS_SPECIAL_DATAOBJECT(pDataObjectToBeCutBySource) ) )
        return (sc = E_UNEXPECTED);

    // transfer control to the client ( no addref nor release in neaded )
    *ppCutDataObject = pDataObjectToBeCutBySource;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::QueryViewSettingsPersistor
//
//  Synopsis:    Get the IPersistStream interface of CViewSettingsPersistor
//               object to load the viewsettings (will not be asked for
//               storing as saving is always XML format).
//
//  Arguments:   [ppStream] - [out]
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeCallback::QueryViewSettingsPersistor (IPersistStream** ppStream)
{
    DECLARE_SC(sc, _T("CNodeCallback::QueryViewSettingsPersistor"));
    sc = ScCheckPointers(ppStream);
    if (sc)
        return sc.ToHr();

    *ppStream = NULL;

    // Call CNode static method to get IPersistStream interface.
    sc = CNode::ScQueryViewSettingsPersistor(ppStream);
    if (sc)
        return sc.ToHr();

    return (sc.ToHr());
}


//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::QueryViewSettingsPersistor
//
//  Synopsis:    Get the CXMLObject interface of CViewSettingsPersistor
//               object to save/load the viewsettings from XML console file.
//
//  Arguments:   [ppXMLObject] - [out]
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeCallback::QueryViewSettingsPersistor (CXMLObject** ppXMLObject)
{
    DECLARE_SC(sc, _T("CNodeCallback::QueryViewSettingsPersistor"));

    sc = ScCheckPointers(ppXMLObject);
    if (sc)
        return sc.ToHr();

    *ppXMLObject = NULL;

    // Call CNode static method to get CXMLObject interface.
    sc = CNode::ScQueryViewSettingsPersistor(ppXMLObject);
    if (sc)
        return sc.ToHr();

    return (sc.ToHr());
}

//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::DocumentClosing
//
//  Synopsis:    The document is to be closed, so release any document
//               related objects. (CViewSettingsPersistor).
//
//  Arguments:   None
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CNodeCallback::DocumentClosing ()
{
    DECLARE_SC(sc, _T("CNodeCallback::DocumentClosing"));

    // 1. Call CNode static method informing document closing.
    sc = CNode::ScOnDocumentClosing();
    if (sc)
        return sc.ToHr();

    return (sc.ToHr());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\siprop.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      siprop.h
 *
 *  Contents:  Interface file for CSnapinProperties, et al
 *
 *  History:   04-Nov-99 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef SIPROP_H
#define SIPROP_H
#pragma once

#include "refcount.h"
#include "variant.h"

class CSnapinProperties;


/*+-------------------------------------------------------------------------*
 * CMMCPropertyAction
 *
 * This class is intended to be identical to the MMC_SNAPIN_PROPERTY
 * structure that's sent to ISnapinProperties::PropertiesChanged.
 *
 * It exists to give us intelligent initialization and VARIANT handling
 * through CComVariant.  This makes it much easier to build an array of
 * these things and recover from errors.
 *--------------------------------------------------------------------------*/

class CSmartProperty
{
public:
    CSmartProperty() : pszPropName(NULL), eAction(MMC_PROPACT_INITIALIZED)
    {
        /*
         * CSmartProperty must have an identical memory layout to
         * MMC_SNAPIN_PROPERTY.  If any of these asserts fail, that's
         * not the case.
         */
        COMPILETIME_ASSERT (sizeof (CSmartProperty) == sizeof (MMC_SNAPIN_PROPERTY));
        COMPILETIME_ASSERT (sizeof (CComVariant)    == sizeof (VARIANT));
        COMPILETIME_ASSERT (offsetof (CSmartProperty,  pszPropName) == offsetof (MMC_SNAPIN_PROPERTY, pszPropName));
        COMPILETIME_ASSERT (offsetof (CSmartProperty,  varValue)    == offsetof (MMC_SNAPIN_PROPERTY, varValue));
        COMPILETIME_ASSERT (offsetof (CSmartProperty,  eAction)     == offsetof (MMC_SNAPIN_PROPERTY, eAction));
    }

    CSmartProperty (
        LPCOLESTR           pszPropName_,
        const VARIANT&      varValue_,
        MMC_PROPERTY_ACTION eAction_)
        :   pszPropName (pszPropName_),
            varValue    (varValue_),
            eAction     (eAction_)
    {}

public:
    LPCOLESTR           pszPropName;    // name of property
    CComVariant         varValue;       // value of the property
    MMC_PROPERTY_ACTION eAction;        // what happened to this property
};


/*+-------------------------------------------------------------------------*
 * CSnapinProperty
 *
 * Implements a single property in a properties collection.
 *--------------------------------------------------------------------------*/

class CSnapinProperty : public CTiedObject, public CXMLObject
{
public:
    enum
    {
        MMC_PROP_REGISTEREDBYSNAPIN = 0x80000000,

        PrivateFlags = MMC_PROP_REGISTEREDBYSNAPIN,
        PublicFlags  = MMC_PROP_CHANGEAFFECTSUI |
                       MMC_PROP_MODIFIABLE      |
                       MMC_PROP_REMOVABLE       |
                       MMC_PROP_PERSIST,
    };

public:
    CSnapinProperty (DWORD dwFlags = 0) : m_dwFlags (dwFlags), m_fInitialized (dwFlags != 0)
    {
        /*
         * public and private flags shouldn't overlap
         */
        COMPILETIME_ASSERT ((PublicFlags & PrivateFlags) == 0);
    }
    // default destruction, copy construction and assignment are suitable

    const VARIANT& GetValue () const
        { return (m_varValue); }

    SC ScSetValue (const VARIANT& varValue)
    {
        /*
         * use CComVariant::Copy instead of assignment so we'll have access
         * to a return code
         */
        return (m_varValue.Copy (&varValue));
    }

    DWORD GetFlags () const
        { return (m_dwFlags); }

    void InitializeFlags (DWORD dwFlags)
    {
        // only init once
        if (!IsInitialized())
        {
            m_dwFlags      = (dwFlags & PublicFlags) | MMC_PROP_REGISTEREDBYSNAPIN;
            m_fInitialized = true;
        }
    }

    bool IsRegisteredBySnapin () const
        { return (m_dwFlags & MMC_PROP_REGISTEREDBYSNAPIN); }

    bool IsInitialized () const
        { return (m_fInitialized); }

    void SetRegisteredBySnapin()
        { m_dwFlags |= MMC_PROP_REGISTEREDBYSNAPIN; }

    // CXMLObject methods
    DEFINE_XML_TYPE(XML_TAG_SNAPIN_PROPERTY);
    virtual void Persist(CPersistor &persistor);

private:
    CXMLVariant         m_varValue;             // value of the property
    DWORD               m_dwFlags;              // flags for the property
    bool                m_fInitialized;         // initialized yet?
};


/*+-------------------------------------------------------------------------*
 * CSnapinProperties
 *
 * Implementation class for properties collections.  It implements Properties
 * and ISnapinPropertiesCallback, as well as the methods required to support
 * enumeration through CMMCEnumerator.
 *
 * Note that there is not a tied COM object to support Properties; that is
 * implemented here.  This class can, however, be tied to tied COM objects
 * implementing the collection enumerator.
 *--------------------------------------------------------------------------*/

class CSnapinProperties :
    public ISnapinPropertiesCallback,
    public CMMCIDispatchImpl<Properties>, // the Properties interface
    public CTiedObject,
    public XMLListCollectionBase
{
    BEGIN_MMC_COM_MAP(CSnapinProperties)
        COM_INTERFACE_ENTRY(ISnapinPropertiesCallback)
    END_MMC_COM_MAP()

public:
    CSnapinProperties() : m_pMTSnapInNode(NULL) {}

    typedef std::map<std::wstring, CSnapinProperty> CPropertyMap;

    /*
     * When used for enumeration, an key represents the most recent item
     * returned.  When a new enumerator is created, the key will be empty,
     * signifiying that nothing has been returned yet.  After returning Item1,
     * the key will point to Item1, and the next call to return an item will
     * find the next item in the collection after Item1.  This will allow us
     * to correctly enumerate if Item1 is removed from the collection between
     * calls to retrieve Item1 and Item2.
     *
     * When used to identify a property, the key is the name of the property.
     */
    typedef CPropertyMap::key_type CPropertyKey;

private:
    typedef CPropertyMap::iterator          CPropertyIterator;
    typedef CPropertyMap::const_iterator    CConstPropertyIterator;

public:
    ::SC ScInitialize (ISnapinProperties* psip, Properties* pInitialProps, CMTSnapInNode* pMTSnapInNode);
    ::SC ScSetSnapInNode (CMTSnapInNode* pMTSnapInNode);

    static CSnapinProperties* FromInterface (IUnknown* pUnk);

public:
    // ISnapinPropertiesCallback interface
    STDMETHOD(AddPropertyName) (LPCOLESTR pszPropName, DWORD dwFlags);

    // Properties interface
    STDMETHOD(Item)      (BSTR bstrName, PPPROPERTY ppProperty);
    STDMETHOD(get_Count) (PLONG pCount);
    STDMETHOD(Remove)    (BSTR bstrName);
    STDMETHOD(get__NewEnum)  (IUnknown** ppUnk);

    // for support of get__NewEnum and IEnumVARIANT via CMMCNewEnumImpl
    ::SC ScEnumNext  (CPropertyKey &key, PDISPATCH & pDispatch);
    ::SC ScEnumSkip  (unsigned long celt, unsigned long& celtSkipped, CPropertyKey &key);
    ::SC ScEnumReset (CPropertyKey &key);

    // Property interface
    ::SC Scget_Value (VARIANT* pvarValue, const CPropertyKey& key);
    ::SC Scput_Value (VARIANT  varValue,  const CPropertyKey& key);

    // CXMLObject methods
    DEFINE_XML_TYPE(XML_TAG_SNAPIN_PROPERTIES);
    virtual void OnNewElement(CPersistor& persistor);
    virtual void Persist (CPersistor &persistor);

private:
    ::SC ScGetPropertyComObject (const CPropertyKey& key, Property*& rpProperty);
    ::SC ScMergeProperties      (const CSnapinProperties& other);
    ::SC ScNotifyPropertyChange (CPropertyIterator itProp, const VARIANT& varNewValue, MMC_PROPERTY_ACTION eAction);
    ::SC ScNotifyPropertyChange (CSmartProperty* pProps, ULONG cProps);

    CPropertyIterator IteratorFromKey (const CPropertyKey& key, bool fExactMatch);
    void PersistWorker (CPersistor &persistor, CPropertyIterator it);

protected:
    CPropertyMap            m_PropMap;
    CMTSnapInNode*          m_pMTSnapInNode;
    ISnapinPropertiesPtr    m_spSnapinProps;
};


#endif /* SIPROP_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\snapin.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       SnapIn.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    09/09/1996   RaviR   Created
//
//____________________________________________________________________________


//
//  A sample SnapIn registry entry
//
//  SnapIns
//      {d84a45bb-d390-11cf-b607-00c04fd8d565}
//          = REG_SZ "Logs snap-in"
//          Name = REG_SZ "logvwr.dll, 101"
//          NameString = REG_SZ "Logs"
//          Status = REG_SZ "logvwr.dll, 102"
//          StatusString = REG_SZ "Container enumerating all logs on a machine."
//          ImageOpen = REG_SZ "logvwr.dll, 103"
//          ImageClosed = REG_SZ "logvwr.dll, 104"
//          ResultPane = REG_SZ "{....}" / "Html path" / "url"
//


#ifndef _SNAPIN_H_
#define _SNAPIN_H_

class CExtSI;
class CSnapIn;
class CSnapInsCache;

// forward decl
class CPersistor;

#define BOOLVAL(x) ((x) ? TRUE : FALSE)

//____________________________________________________________________________
//
//  Class:      CSnapIn
//____________________________________________________________________________
//
extern const GUID IID_CSnapIn;

#if _MSC_VER < 1100
class CSnapIn : public IUnknown, public CComObjectRoot
#else
class __declspec(uuid("E6DFFF74-6FE7-11d0-B509-00C04FD9080A")) CSnapIn :
                                      public IUnknown, public CComObjectRoot, public CXMLObject
#endif
{
private:
    enum SNAPIN_FLAGS
    {
        SNAPIN_NAMESPACE_CHANGED  = 0x0001,
        SNAPIN_REQ_EXTS_LOADED    = 0x0002,
        SNAPIN_ENABLE_ALL_EXTS    = 0x0004,
        SNAPIN_SNAPIN_ENABLES_ALL = 0x0008,
    };

public:
    BEGIN_COM_MAP(CSnapIn)
        COM_INTERFACE_ENTRY(CSnapIn)
    END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(CSnapIn)

// Attributes
    const CLSID& GetSnapInCLSID() const
    {
        return m_clsidSnapIn;
    }

    void SetSnapInCLSID(const CLSID& id)
    {
        m_clsidSnapIn = id;
    }

    CExtSI* GetExtensionSnapIn() const
    {
        return m_pExtSI;
    }

    BOOL RequiredExtensionsLoaded() const
    {
        return (m_dwFlags & SNAPIN_REQ_EXTS_LOADED) != 0;
    }

    BOOL AreAllExtensionsEnabled() const
    {
        return (m_dwFlags & SNAPIN_ENABLE_ALL_EXTS) != 0;
    }

    BOOL DoesSnapInEnableAll() const
    {
        return (m_dwFlags & SNAPIN_SNAPIN_ENABLES_ALL) != 0;
    }

    void SetAllExtensionsEnabled(BOOL bState = TRUE)
    {
        if (bState)
            m_dwFlags |= SNAPIN_ENABLE_ALL_EXTS;
        else
          m_dwFlags &= ~SNAPIN_ENABLE_ALL_EXTS;
    }

    void SetRequiredExtensionsLoaded(BOOL bState = TRUE)
    {
        if (bState)
            m_dwFlags |= SNAPIN_REQ_EXTS_LOADED;
        else
            m_dwFlags &= ~SNAPIN_REQ_EXTS_LOADED;
    }

    void SetSnapInEnablesAll(BOOL bState = TRUE)
    {
        if (bState)
            m_dwFlags |= SNAPIN_SNAPIN_ENABLES_ALL;
        else
            m_dwFlags &= ~SNAPIN_SNAPIN_ENABLES_ALL;
    }


    BOOL HasNameSpaceChanged() const
    {
        return (m_dwFlags & SNAPIN_NAMESPACE_CHANGED) != 0;
    }

    void SetNameSpaceChanged(BOOL bState = TRUE)
    {
        if (bState)
            m_dwFlags |= SNAPIN_NAMESPACE_CHANGED;
        else
            m_dwFlags &= ~SNAPIN_NAMESPACE_CHANGED;
    }

    DWORD GetSnapInModule(TCHAR *pBuf, DWORD dwCnt) const;
    bool IsStandAlone() const;
    HRESULT Dump (LPCTSTR pszDumpFile, CSnapInsCache* pCache);

    SC ScGetSnapInName(WTL::CString& strSnapinName) const;

    CExtSI* AddExtension(CSnapIn* pSI);
    CExtSI* FindExtension(const CLSID& id);
    void MarkExtensionDeleted(CSnapIn* pSI);
    void PurgeExtensions();

    // destroys list of extensions. extension list needs to be destroyed 
    // this will break snapin's circular references if such exist.
    // (it happens when snapins extends itself or own extension)
    SC ScDestroyExtensionList();

// Operations
    BOOL ExtendsNameSpace(GUID guidNodeType);

    // Loads/Saves this node and its extensions to the provided stream
    HRESULT Load(CSnapInsCache* pCache, IStream* pStream);
    HRESULT Load(CSnapInsCache* pCache, IStream* pStream, CExtSI*& pExtSI);
    HRESULT Save(IStream* pStream, BOOL bClearDirty);

    virtual void    Persist(CPersistor &persistor);
    void            PersistLoad(CPersistor& persistor,CSnapInsCache* pCache);
    DEFINE_XML_TYPE(XML_TAG_SNAPIN);

public:
#ifdef DBG
    int dbg_cRef;
    ULONG InternalAddRef()
    {
        ++dbg_cRef;
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        --dbg_cRef;
        return CComObjectRoot::InternalRelease();
    }
    int dbg_InstID;
#endif // DBG

// Implementation
protected:
// Constructor & Destructor
    CSnapIn();

    virtual ~CSnapIn(); // Called only by Release

    HKEY OpenKey (REGSAM samDesired = KEY_ALL_ACCESS) const;

// Following methods/member variables manage/contains temporary state
// used for finding used/unused snapins.
// despite it is not really a property of the snapin and is not valid all the time,
// having the state on the snapin is very convenient for the operation.
// Else it would require temporary storage and frequent lookup for information.

// begin temporary state
public:
    SC ScTempState_ResetReferenceCalculationData( );
    SC ScTempState_UpdateInternalReferenceCounts( );
    SC ScTempState_MarkIfExternallyReferenced( );
    SC ScTempState_IsExternallyReferenced( bool& bReferenced ) const;
private:
    SC ScTempState_SetHasStrongReference( );

    DWORD           m_dwTempState_InternalRef;
    bool            m_bTempState_HasStrongRef;
// end temporary state

private:
    DWORD           m_dwFlags;
    CLSID           m_clsidSnapIn;
    CExtSI*         m_pExtSI;               // Extensions

    //____________________________________________________________________________
    //
    //  Class:      CExtPersistor
    //
    //  Purpose:    implements persisting the collection - snapin extensions
    //____________________________________________________________________________
    //
    class CExtPersistor : public XMLListCollectionBase
    {
    public:
        CExtPersistor(CSnapIn& Parent) : m_Parent(Parent),m_pCache(NULL) {}
        virtual void OnNewElement(CPersistor& persistor);
        virtual void Persist(CPersistor& persistor);
        void SetCache(CSnapInsCache* pCache) { m_pCache = pCache; }
        DEFINE_XML_TYPE(XML_TAG_SNAPIN_EXTENSIONS);
    private:
        CSnapIn& GetParent() { return m_Parent; }
        CSnapIn& m_Parent;
        CSnapInsCache* m_pCache;
    };
    friend class CExtPersistor;

    CExtPersistor    m_ExtPersistor;

// Not implemented.
    CSnapIn(const CSnapIn &rhs);
    CSnapIn& operator=(const CSnapIn &rhs);
}; // class CSnapIn

DEFINE_COM_SMARTPTR(CSnapIn);   // CSnapInPtr

//____________________________________________________________________________
//
//  Class:      CExtSI
//____________________________________________________________________________
//
class CExtSI
{
public:
    enum EXTSI_FLAGS
    {
        EXT_TYPES_MASK         = 0x000FFFFF,
        EXT_TYPE_NAMESPACE     = 0x00000001,
        EXT_TYPE_CONTEXTMENU   = 0x00000002,
        EXT_TYPE_TOOLBAR       = 0x00000004,
        EXT_TYPE_PROPERTYSHEET = 0x00000008,
        EXT_TYPE_TASK          = 0x00000010,
        EXT_TYPE_VIEW          = 0x00000020,
        EXT_TYPE_STATIC        = 0x00010000,
        EXT_TYPE_DYNAMIC       = 0x00020000,
        EXT_TYPE_REQUIRED      = 0x00040000,
        EXT_NEW                = 0x80000000,
        EXT_DELETED            = 0x40000000,

    };

public:
// Constructor & Destructor
    CExtSI(CSnapIn* pSnapIn);
    ~CExtSI(void);

// Attributes
    const CLSID& GetCLSID();

    CExtSI*& Next()
    {
        return m_pNext;
    }

    CSnapIn* GetSnapIn(void) const
    {
        return m_pSnapIn;
    }

    void SetNext(CExtSI* pNext)
    {
        m_pNext = pNext;
    }

    void SetNew(BOOL bState = TRUE)
    {
        if (bState)
            m_dwFlags |= EXT_NEW;
        else
            m_dwFlags &= ~EXT_NEW;
    }

    void SetRequired(BOOL bState = TRUE)
    {
        if (bState)
            m_dwFlags |= EXT_TYPE_REQUIRED;
        else
            m_dwFlags &= ~EXT_TYPE_REQUIRED;
    }

    void MarkDeleted(BOOL bState = TRUE)
    {
        if (bState)
            m_dwFlags |= EXT_DELETED;
        else
            m_dwFlags &= ~EXT_DELETED;
    }

    BOOL IsNew()
    {
        return BOOLVAL(m_dwFlags & EXT_NEW);
    }

    BOOL IsRequired()
    {
        return BOOLVAL(m_dwFlags & EXT_TYPE_REQUIRED);
    }

    BOOL IsMarkedForDeletion()
    {
        return BOOLVAL(m_dwFlags & EXT_DELETED);
    }

    BOOL ExtendsNameSpace()
    {
        return BOOLVAL(m_dwFlags & EXT_TYPE_NAMESPACE);
    }

    BOOL ExtendsContextMenu()
    {
        return BOOLVAL(m_dwFlags & EXT_TYPE_CONTEXTMENU);
    }

    BOOL ExtendsToolBar()
    {
        return BOOLVAL(m_dwFlags & EXT_TYPE_TOOLBAR);
    }

    BOOL ExtendsPropertySheet()
    {
        return BOOLVAL(m_dwFlags & EXT_TYPE_PROPERTYSHEET);
    }

    BOOL ExtendsView()
    {
        return BOOLVAL(m_dwFlags & EXT_TYPE_VIEW);
    }

    BOOL ExtendsTask()
    {
        return BOOLVAL(m_dwFlags & EXT_TYPE_TASK);
    }

    UINT GetExtensionTypes()
    {
        return (m_dwFlags & EXT_TYPES_MASK);
    }

    void SetExtensionTypes(UINT uiExtTypes)
    {
        ASSERT((uiExtTypes & ~EXT_TYPES_MASK) == 0);
        m_dwFlags = (m_dwFlags & ~EXT_TYPES_MASK) | uiExtTypes;
    }

// Operations
    // Saves this extension, and all of the nexts.
    HRESULT Save(IStream* pStream, BOOL bClearDirty);
    void    Persist(CPersistor &persistor);
    static void PersistNew(CPersistor &persistor, CSnapIn& snapParent, CSnapInsCache& snapCache);

// Implementation
private:
    DWORD       m_dwFlags;
    CSnapIn*    m_pSnapIn;
    CExtSI*     m_pNext;

}; // class CExtSI


//____________________________________________________________________________
//
//  Class:      CSnapInsCache
//____________________________________________________________________________
//
class CSnapInsCache : public XMLListCollectionBase
{
    typedef std::map<CLSID, CSnapInPtr> map_t;

public:
    CSnapInsCache();
    ~CSnapInsCache();

// Operations
    SC ScGetSnapIn(const REFCLSID riid, CSnapIn* * ppSnapIn);
    SC ScFindSnapIn(const REFCLSID riid, CSnapIn** ppSnapIn);
// iteration
    typedef map_t::iterator iterator;
    iterator begin() { return m_snapins.begin(); }
    iterator end()   { return m_snapins.end(); }

// CXMLObject methods
    DEFINE_XML_TYPE(XML_TAG_SNAPIN_CACHE);
    virtual void Persist(CPersistor &persistor);
    virtual void OnNewElement(CPersistor& persistor);

// Load Save the snapins cache
    SC ScSave(IStream* pStream, BOOL bClearDirty);
    SC ScLoad(IStream* pStream);
    SC ScIsDirty() ;
    void SetDirty(BOOL bIsDirty = TRUE);
    void Purge(BOOL bExtensionsOnly = FALSE);

    void SetHelpCollectionDirty (bool bState = true) { m_bUpdateHelpColl = bState;}
    bool IsHelpCollectionDirty  (void)               { return m_bUpdateHelpColl; }

    HRESULT Dump (LPCTSTR pszDumpFile);

	SC ScCheckSnapinAvailability (CAvailableSnapinInfo& asi);

    SC ScMarkExternallyReferencedSnapins();

#ifdef DBG
    void DebugDump();
#endif

private:
// Implementation
    BOOL m_bIsDirty;
    map_t   m_snapins;

    bool m_bUpdateHelpColl    : 1;

#ifdef TEMP_SNAPIN_MGRS_WORK
    void GetAllExtensions(CSnapIn* pSI);
#endif // TEMP_SNAPIN_MGRS_WORK

}; // class CSnapInsCache


#endif // _SNAPIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\snapinpersistence.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2000
//
//  File:       snapinpersistence.cpp
//
//  Contents:
//
//  Classes: CComponentPersistor, CDPersistor
//
//____________________________________________________________________________

#include "stdafx.h"
#include "mtnode.h"
#include "regutil.h"

/*+-------------------------------------------------------------------------*
 *
 * struct less_component
 *
 * PURPOSE:  implements viewID and CLSID based comparison for CComponent* pointers
 *           This allows to sort components before pesisting
 *+-------------------------------------------------------------------------*/
struct less_component // define the struct to perform the comparison
{
    typedef std::pair<int, CComponent*> comp_type;

    bool operator ()(const comp_type& arg1, const comp_type& arg2) const
    {
        return  arg1.first != arg2.first ? arg1.first < arg2.first :
                arg1.second->GetCLSID() < arg2.second->GetCLSID();
    }
};

/*+-------------------------------------------------------------------------*
 *
 * struct less_compdata
 *
 * PURPOSE:  implements CLSID based comparison for CComponentData* pointers
 *           This allows to sort component data before pesisting
 *+-------------------------------------------------------------------------*/
struct less_compdata // define the struct to perform the comparison
{
    bool operator ()(const CComponentData* pCD1, const CComponentData* pCD2) const
    {
        return  pCD1->GetCLSID() < pCD2->GetCLSID();
    }
};

/***************************************************************************\
 *
 * METHOD:  CMTSnapinNodeStreamsAndStorages::ScGetXmlStorage
 *
 * PURPOSE:  gets CXML_IStorage for snapin. creates & inits one there is none
 *
 * PARAMETERS:
 *    int idView                    [in] view number 
 *    const CLSID& clsid            [in] CLSID identifying the snapin
 *    CXML_IStorage *& pXMLStorage  [out] xml storage for the snapin
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMTSnapinNodeStreamsAndStorages::ScGetXmlStorage(int idView, const CLSID& clsid, CXML_IStorage *& pXMLStorage)
{
    DECLARE_SC(sc, TEXT("CMTSnapinNodeStreamsAndStorages::ScGetXmlStorage"));

    // init out parameter
    pXMLStorage = NULL;

    // try to find it first
    bool bFound = false;
    sc = ScFindXmlStorage(  idView, clsid, bFound, pXMLStorage );
    if (sc)
        return sc;

    if (bFound)
    {
        // recheck
        sc = ScCheckPointers( pXMLStorage, E_UNEXPECTED );
        if (sc)
            return sc;

        // return the ponter we found
        return sc;
    }

    // insert the new one
    typedef std::map<key_t, CXML_IStorage> col_t;
    col_t::iterator it = m_XMLStorage.insert(col_t::value_type( key_t( idView, clsid ), CXML_IStorage())).first;
    pXMLStorage = &it->second;

    // recheck
    sc = ScCheckPointers( pXMLStorage, E_UNEXPECTED );
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMTSnapinNodeStreamsAndStorages::ScFindXmlStorage
 *
 * PURPOSE: Finds the storage. 
 *
 * PARAMETERS:
 *    int idView                    [in] view number 
 *    const CLSID& clsid            [in] CLSID identifying the snapin
 *    bool& bFound                  [out] whether data was found
 *    CXML_IStorage *& pXMLStorage  [out] pointer to found data
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMTSnapinNodeStreamsAndStorages::
ScFindXmlStorage(int idView, const CLSID& clsid, bool& bFound, CXML_IStorage *& pXMLStorage)
{
    DECLARE_SC(sc, TEXT("CMTSnapinNodeStreamsAndStorages::ScFindXmlStorage"));

    // init out parameters
    bFound = false;
    pXMLStorage = NULL;

    typedef std::map<key_t, CXML_IStorage> col_t;
    col_t::iterator it = m_XMLStorage.find( key_t( idView, clsid ) );

    // give a try to find it by the hash value
    if ( it == m_XMLStorage.end() )
    {
        bool bFoundInHash = false;
        sc = ScCheckForStreamsAndStoragesByHashValue( idView, clsid, bFoundInHash );
        if (sc)
            return sc;

        if ( !bFoundInHash ) // if not found - return
            return sc;

        // try again - it may be in the map by now
        it = m_XMLStorage.find( key_t( idView, clsid ) );

        if ( it == m_XMLStorage.end() ) // if still not found - return
            return sc;
    }

    // found!
    bFound = true;
    pXMLStorage = &it->second;

#ifdef DBG // set the snapin name to identify the problems in debug
    tstring strSnapin;
    GetSnapinNameFromCLSID( clsid, strSnapin );
    pXMLStorage->m_dbg_Data.SetTraceInfo(TraceSnapinPersistenceError, true, strSnapin);
#endif // #ifdef DBG

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMTSnapinNodeStreamsAndStorages::ScFindXmlStream
 *
 * PURPOSE: Finds the stream. 
 *
 * PARAMETERS:
 *    int idView                    [in] view number 
 *    const CLSID& clsid            [in] CLSID identifying the snapin
 *    bool& bFound                  [out] whether data was found
 *    CXML_IStream *& pXMLStream    [out] pointer to found data
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMTSnapinNodeStreamsAndStorages::
ScFindXmlStream(int idView, const CLSID& clsid, bool& bFound, CXML_IStream *& pXMLStream)
{
    DECLARE_SC(sc, TEXT("CMTSnapinNodeStreamsAndStorages::ScFindXmlStream"));

    // init out parameters
    bFound = false;
    pXMLStream = NULL;

    typedef std::map<key_t, CXML_IStream> col_t;
    col_t::iterator it = m_XMLStream.find( key_t( idView, clsid ) );

    // give a try to find it by the hash value
    if ( it == m_XMLStream.end() )
    {
        bool bFoundInHash = false;
        sc = ScCheckForStreamsAndStoragesByHashValue( idView, clsid, bFoundInHash );
        if (sc)
            return sc;

        if ( !bFoundInHash ) // if not found - return
            return sc;

        // try again - it may be in the map by now
        it = m_XMLStream.find( key_t( idView, clsid ) );

        if ( it == m_XMLStream.end() ) // if still not found - return
            return sc;
    }

    // found!
    bFound = true;
    pXMLStream = &it->second;

#ifdef DBG // set the snapin name to identify the problems in debug
        tstring strSnapin;
        GetSnapinNameFromCLSID( clsid, strSnapin );
        pXMLStream->m_dbg_Data.SetTraceInfo(TraceSnapinPersistenceError, true, strSnapin);
#endif // #ifdef DBG

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMTSnapinNodeStreamsAndStorages::ScGetXmlStream
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    int idView                    [in] view number 
 *    const CLSID& clsid            [in] CLSID identifying the snapin
 *    CXML_IStream *& pXMLStream    [out] xml stream for the snapin
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMTSnapinNodeStreamsAndStorages::ScGetXmlStream(int idView, const CLSID& clsid, CXML_IStream *& pXMLStream)
{
    DECLARE_SC(sc, TEXT("CMTSnapinNodeStreamsAndStorages::ScGetXmlStream"));

    // init out parameter
    pXMLStream = NULL;

    // try to find it first
    bool bFound = false;
    sc = ScFindXmlStream( idView, clsid, bFound, pXMLStream );
    if (sc)
        return sc;

    if (bFound)
    {
        // recheck
        sc = ScCheckPointers( pXMLStream, E_UNEXPECTED );
        if (sc)
            return sc;

        // return the ponter we found
        return sc;
    }

    // insert the new one
    typedef std::map<key_t, CXML_IStream> col_t;
    col_t::iterator it = m_XMLStream.insert(col_t::value_type( key_t( idView, clsid ), CXML_IStream())).first;
    pXMLStream = &it->second;

    // recheck
    sc = ScCheckPointers( pXMLStream, E_UNEXPECTED );
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMTSnapinNodeStreamsAndStorages::ScInitIStorage
 *
 * PURPOSE: Initializes IStorage from the given source data
 *
 * PARAMETERS:
 *    int idView              [in] view number 
 *    LPCWSTR szHash          [in] hash key (name of storage element) identifying the snapin
 *    IStorage *pSource       [in] source data for initialization
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMTSnapinNodeStreamsAndStorages::ScInitIStorage( int idView, LPCWSTR szHash, IStorage *pSource )
{
    DECLARE_SC(sc, TEXT("CMTSnapinNodeStreamsAndStorages::ScInitIStorage"));

    // parameter check;
    sc = ScCheckPointers( pSource );
    if (sc)
        return sc;

    // insert the new one
    typedef std::map<hash_t, CXML_IStorage> col_t;
    col_t::iterator it = m_StorageByHash.insert( col_t::value_type(hash_t(idView, szHash), CXML_IStorage())).first;
    CXML_IStorage *pXMLStorage = &it->second;

    // recheck the pointer
    sc = ScCheckPointers( pXMLStorage, E_UNEXPECTED );
    if (sc)
        return sc;

    sc = pXMLStorage->ScInitializeFrom( pSource );
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMTSnapinNodeStreamsAndStorages::ScInitIStream
 *
 * PURPOSE: Initializes IStream from the given source data
 *
 * PARAMETERS:
 *    int idView               [in] view number 
 *    LPCWSTR szHash           [in] hash key (name of storage element) identifying the snapin
 *    IStream *pSource         [in] source data for initialization
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMTSnapinNodeStreamsAndStorages::ScInitIStream ( int idView, LPCWSTR szHash, IStream *pSource )
{
    DECLARE_SC(sc, TEXT("CMTSnapinNodeStreamsAndStorages::ScInitIStream"));

    // parameter check;
    sc = ScCheckPointers( pSource );
    if (sc)
        return sc;

    // insert the new one
    typedef std::map<hash_t, CXML_IStream> col_t;
    col_t::iterator it = m_StreamByHash.insert( col_t::value_type(hash_t(idView, szHash), CXML_IStream())).first;
    CXML_IStream *pXMLStream = &it->second;

    // recheck the pointer
    sc = ScCheckPointers( pXMLStream, E_UNEXPECTED );
    if (sc)
        return sc;

    sc = pXMLStream->ScInitializeFrom( pSource );
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMTSnapinNodeStreamsAndStorages::ScGetIStorage
 *
 * PURPOSE: returns existing or creates a new IStorage for the component
 *
 * PARAMETERS:
 *    int idView            [in] view number 
 *    const CLSID& clsid    [in] CLSID identifying the snapin
 *    IStorage **ppStorage  [out] - storage for the component
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMTSnapinNodeStreamsAndStorages::ScGetIStorage( int idView, const CLSID& clsid, IStorage **ppStorage )
{
    DECLARE_SC(sc, TEXT("CMTSnapinNodeStreamsAndStorages::ScGetIStorage"));

    // paramter check
    sc = ScCheckPointers( ppStorage );
    if (sc)
        return sc;

    // init an out parameter
    *ppStorage = NULL;

    CXML_IStorage *pXMLStorage = NULL;
    sc = ScGetXmlStorage( idView, clsid, pXMLStorage );
    if (sc)
        return sc;

    // recheck the pointer
    sc = ScCheckPointers( pXMLStorage, E_UNEXPECTED );
    if (sc)
        return sc;

    // get the interface
    sc = pXMLStorage->ScGetIStorage(ppStorage);
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMTSnapinNodeStreamsAndStorages::ScGetIStream
 *
 * PURPOSE: returns existing or creates a new IStream for the component
 *
 * PARAMETERS:
 *    int idView            [in] view number 
 *    const CLSID& clsid    [in] CLSID identifying the snapin
 *    IStream  **ppStream   [out] - stream fro the component
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMTSnapinNodeStreamsAndStorages::ScGetIStream ( int idView, const CLSID& clsid, IStream  **ppStream  )
{
    DECLARE_SC(sc, TEXT("CMTSnapinNodeStreamsAndStorages::ScGetIStream"));

    // paramter check
    sc = ScCheckPointers( ppStream );
    if (sc)
        return sc;

    // init an out parameter
    *ppStream = NULL;

    CXML_IStream *pXMLStream = NULL;
    sc = ScGetXmlStream( idView, clsid, pXMLStream );
    if (sc)
        return sc;

    // recheck the pointer
    sc = ScCheckPointers( pXMLStream, E_UNEXPECTED );
    if (sc)
        return sc;

    // get the interface
    sc = pXMLStream->ScGetIStream(ppStream);
    if (sc)
        return sc;

    return sc;
}


/***************************************************************************\
 *
 * METHOD:  CMTSnapinNodeStreamsAndStorages::HasStream
 *
 * PURPOSE: Checks if snapins stream is available
 *
 * PARAMETERS:
 *    int idView                    [in] view number 
 *    const CLSID& clsid            [in] CLSID identifying the snapin
 *
 * RETURNS:
 *    bool - true == found
 *
\***************************************************************************/
bool CMTSnapinNodeStreamsAndStorages::HasStream(int idView, const CLSID& clsid)    
{ 
    DECLARE_SC(sc, TEXT("CMTSnapinNodeStreamsAndStorages::HasStream"));

    bool bFound = false;
    CXML_IStream * pUnused = NULL;
    sc = ScFindXmlStream( idView, clsid, bFound, pUnused );
    if (sc)
        return false; // not found if error

    return bFound;
}

/***************************************************************************\
 *
 * METHOD:  CMTSnapinNodeStreamsAndStorages::HasStorage
 *
 * PURPOSE: Checks if snapins storage is available
 *
 * PARAMETERS:
 *    int idView                    [in] view number 
 *    const CLSID& clsid            [in] CLSID identifying the snapin
 *
 * RETURNS:
 *    bool - true == found
 *
\***************************************************************************/
bool CMTSnapinNodeStreamsAndStorages::HasStorage(int idView, const CLSID& clsid)
{ 
    DECLARE_SC(sc, TEXT("CMTSnapinNodeStreamsAndStorages::HasStorage"));

    bool bFound = false;
    CXML_IStorage * pUnused = NULL;
    sc = ScFindXmlStorage( idView, clsid, bFound, pUnused );
    if (sc)
        return false; // not found if error

    return bFound;
}

/***************************************************************************\
 *
 * METHOD:  CMTSnapinNodeStreamsAndStorages::ScCheckForStreamsAndStoragesByHashValue
 *
 * PURPOSE: Looks up streams and storages by a generated hash value.
 *          if the streams/storages are found, they are moved to the
 *          the list of 'recognized' storages - those identified by the CLSID.
 *          This is a required step to recognize the streams and storages retrieved
 *          from a structured storage based console, where they are identified by the
 *          hash value. It is not possible to map from the hash value to the key 
 *          in unique way, so the collections of data are kept untill the request 
 *          comes and the hash can be mapped by matching with the one generated from 
 *          the key supplied by request.
 *
 * PARAMETERS:
 *    int idView                      [in] view number 
 *    const CLSID& clsid              [in] CLSID identifying the snapin
 *    bool& bFound                    [out] - true if at least one matching hash value was found
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMTSnapinNodeStreamsAndStorages::ScCheckForStreamsAndStoragesByHashValue( int idView, const CLSID& clsid, bool& bFound )
{
    DECLARE_SC(sc, TEXT("CMTSnapinNodeStreamsAndStorages::ScCheckForStreamsAndStoragesByHashValue"));

    bFound = false;

    wchar_t buff[MAX_PATH];
    std::wstring strHashValue = CMTNode::GetComponentStreamName( buff, clsid );

    // process streams
    {
        typedef std::map<hash_t, CXML_IStream> col_t;
        col_t::iterator it = m_StreamByHash.begin();
        while ( it != m_StreamByHash.end() )
        {
            if ( it->first.second == strHashValue )
            {
                bFound = true;
                // put to a 'recognized' list
                int idView = it->first.first;
                m_XMLStream[key_t(idView, clsid)] = it->second;
            
                // for sanity: make sure it is not in the storage map!
                ASSERT( m_StorageByHash.find(it->first) == m_StorageByHash.end() );
                m_StorageByHash.erase( it->first );

                // remove from hash table
                it = m_StreamByHash.erase( it );
            }
            else
                ++ it;
        }

        if ( bFound )
            return sc;
    }

    // process storages
    {
        typedef std::map<hash_t, CXML_IStorage> col_t;
        col_t::iterator it = m_StorageByHash.begin();
        while ( it != m_StorageByHash.end() )
        {
            if ( it->first.second == strHashValue )
            {
                bFound = true;
                // put to a 'recognized' list
                int idView = it->first.first;
                m_XMLStorage[key_t(idView, clsid)] = it->second;
            
                // for sanity: make sure it is not in the stream map!
                ASSERT( m_StreamByHash.find( it->first ) == m_StreamByHash.end() );
                m_StreamByHash.erase( it->first );

                // remove from hash table
                it = m_StorageByHash.erase( it );
            }
            else
                ++it;
        }
    }

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CMTSnapinNodeStreamsAndStorages::RemoveView
 *
 * PURPOSE:  removes information about one view
 *
 * PARAMETERS:
 *    int idView                      [in] view number 
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CMTSnapinNodeStreamsAndStorages::RemoveView(int nViewId)
{
    DECLARE_SC(sc, TEXT("CMTSnapinNodeStreamsAndStorages::RemoveView"));

    { // remove streams
        std::map<key_t, CXML_IStream>::iterator  it_stream;
        for (it_stream = m_XMLStream.begin();it_stream != m_XMLStream.end();)
        {
            if (it_stream->first.first == nViewId)
                it_stream = m_XMLStream.erase(it_stream);
            else
                ++it_stream;
        }
    }
    { // remove storages
        std::map<key_t, CXML_IStorage>::iterator it_storage;
        for (it_storage = m_XMLStorage.begin();it_storage != m_XMLStorage.end();)
        {
            if (it_storage->first.first == nViewId)
                it_storage = m_XMLStorage.erase(it_storage);
            else
                ++it_storage;
        }
    }

    { // remove streams by hash
        std::map<hash_t, CXML_IStream>::iterator  it_stream;
        for (it_stream = m_StreamByHash.begin();it_stream != m_StreamByHash.end();)
        {
            if (it_stream->first.first == nViewId)
                it_stream = m_StreamByHash.erase(it_stream);
            else
                ++it_stream;
        }
    }
    { // remove storages by hash
        std::map<hash_t, CXML_IStorage>::iterator it_storage;
        for (it_storage = m_StorageByHash.begin();it_storage != m_StorageByHash.end();)
        {
            if (it_storage->first.first == nViewId)
                it_storage = m_StorageByHash.erase(it_storage);
            else
                ++it_storage;
        }
    }
}

/***************************************************************************\
 *
 * METHOD:  CMTSnapinNodeStreamsAndStorages::Persist
 *
 * PURPOSE: persists stream and storage collections
 *
 * PARAMETERS:
 *    CPersistor& persistor [in] peristor for the operation
 *    bool bPersistViewId   [in] whether to store view identifier
 *                               (ComponentDatas are saved with thi parameter set to false,
 *                                since the view id has no meaning for them)
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
void CMTSnapinNodeStreamsAndStorages::Persist(CPersistor& persistor, bool bPersistViewId)
{
    DECLARE_SC(sc, TEXT("CMTSnapinNodeStreamsAndStorages::Persist"));

    if (persistor.IsStoring())
    {
        // define iterators for saving
        std::map<key_t, CXML_IStorage>::iterator    itStorages;
        std::map<key_t, CXML_IStream>::iterator     itStreams;
        std::map<hash_t, CXML_IStorage>::iterator   itStoragesByHash;
        std::map<hash_t, CXML_IStream>::iterator    itStreamsByHash;

        // init iterators to point to the start of the collections
        itStorages = m_XMLStorage.begin();
        itStreams = m_XMLStream.begin();
        itStoragesByHash = m_StorageByHash.begin();
        itStreamsByHash = m_StreamByHash.begin();

        // we have 4 collections to save here.
        // while saving them one by one would not change the functionality,
        // console file is more readable when they are sorted by the snapin's clsid.
        // following code does not do any explicit sorting, but persist in the
        // certain order assurring the result is a sorted array of persisted data

        // These 4 iterators represents 4 lines (queues) of sorted items, so
        // in order to get the proper result we just need to merge them correctly.
        // This is done by the following loop which splits the persistence in two steps:
        // 1. Pick the right line (iterator) to persist it's first item.
        // 2. Persist the selected item.
        // There are 4 boolean variables indicating which item to save (only one can be 'true')
        // thus the second part is strigth-forward - test variables and do the persisting.

        // The iterator is picked by the following rules.
        // 1.1 Only lines with items compete.
        // 1.2 If there are items in lines key'ed by guids (in contrast to hash values)
        //     they are processed first, leaving hash values at the end.
        // 1.3 If still there are 2 lines competing - their key's are compared and one
        //     with a smaller key is choosen
        
        while ( 1 )
        {
            // see what collection has data to save
            bool bSaveStorage = ( itStorages != m_XMLStorage.end() );
            bool bSaveStream  = ( itStreams != m_XMLStream.end() );
            bool bSaveStorageByHash = ( itStoragesByHash != m_StorageByHash.end() );
            bool bSaveStreamByHash  = ( itStreamsByHash != m_StreamByHash.end() );

            // exit if nothind to tsave - assume we are done
            if ( !( bSaveStorage || bSaveStream || bSaveStorageByHash || bSaveStreamByHash ))
                break;

            // if both main collections are willing to save - let the smaller key win
            if ( bSaveStorage && bSaveStream )
            {
                bSaveStorage = ( itStorages->first < itStreams->first );
                bSaveStream = !bSaveStorage;
            }

            // if not done with a main collections - dont save by hash
            if ( bSaveStorage || bSaveStream )
                bSaveStorageByHash = bSaveStreamByHash = false;

            // if both hash collections are willing to save - let the smaller key win
            if ( bSaveStorageByHash && bSaveStreamByHash )
            {
                bSaveStorageByHash = ( itStoragesByHash->first < itStreamsByHash->first );
                bSaveStreamByHash = !bSaveStorageByHash;
            }

            // only variable one can be set !
            ASSERT ( 1 == ( (int)bSaveStorage + (int)bSaveStream + (int)bSaveStorageByHash + (int)bSaveStreamByHash) );

            // add the tag for snapin entry
            CPersistor persistorChild(persistor, GetItemXMLType());

            // save one winning entry
            if ( bSaveStorage )
            {
                // persist a key
                CLSID clsid = itStorages->first.second;
                int idView = itStorages->first.first;

                persistorChild.Persist( clsid, XML_NAME_CLSID_SNAPIN );

                if (bPersistViewId)
                    persistorChild.PersistAttribute(XML_ATTR_ICOMPONENT_VIEW_ID, idView);

                // persist data
                persistorChild.Persist( itStorages->second );
                
                // advance to the next entry
                ++itStorages;
            }
            else if (bSaveStream)
            {
                // persist a key
                CLSID clsid = itStreams->first.second;
                int idView = itStreams->first.first;

                persistorChild.Persist( clsid, XML_NAME_CLSID_SNAPIN );

                if (bPersistViewId)
                    persistorChild.PersistAttribute(XML_ATTR_ICOMPONENT_VIEW_ID, idView);

                // persist data
                persistorChild.Persist( itStreams->second );

                // advance to the next entry
                ++itStreams;
            }
            else if ( bSaveStorageByHash )
            {
                // persist a key
                std::wstring hash = itStoragesByHash->first.second;
                int idView = itStoragesByHash->first.first;
                
                if (bPersistViewId)
                    persistorChild.PersistAttribute(XML_ATTR_ICOMPONENT_VIEW_ID, idView);

                CPersistor persistorHash( persistorChild, XML_TAG_HASH_VALUE, XML_NAME_CLSID_SNAPIN);
                persistorHash.PersistContents( hash );

                // persist data
                persistorChild.Persist( itStoragesByHash->second );
                
                // advance to the next entry
                ++itStoragesByHash;
            }
            else if (bSaveStreamByHash)
            {
                // persist a key
                std::wstring hash = itStreamsByHash->first.second;
                int idView = itStreamsByHash->first.first;

                if (bPersistViewId)
                    persistorChild.PersistAttribute(XML_ATTR_ICOMPONENT_VIEW_ID, idView);

                CPersistor persistorHash( persistorChild, XML_TAG_HASH_VALUE, XML_NAME_CLSID_SNAPIN);
                persistorHash.PersistContents( hash );

                // persist data
                persistorChild.Persist( itStreamsByHash->second );

                // advance to the next entry
                ++itStreamsByHash;
            }
            else
            {
                ASSERT( false ); // should not come here!
                break;
            }
        }

    }
    else
    {
        XMLListCollectionBase::Persist(persistor);
    }
}

/*+-------------------------------------------------------------------------*
 *
 * CMTSnapinNodeStreamsAndStorages::OnNewElement
 *
 * PURPOSE:  called for each component data found loading XML doc
 *
 * PARAMETERS:
 *    CPersistor& persistor :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CMTSnapinNodeStreamsAndStorages::OnNewElement(CPersistor& persistor)
{
    DECLARE_SC(sc, TEXT("CDPersistor::OnNewElement"));

    // persistor is 'locked' on particular child element, so that
    // a simple CPersistor constructor can be used to create child's peristor.
    // Creating the child persistor is also necessary to release that 'lock'
    CPersistor persistorChild(persistor, GetItemXMLType());

    CLSID clsid;
    std::wstring hash;
    bool bByHash = false;
    ZeroMemory(&clsid,sizeof(clsid));

    // look how entry is key'ed - by regular key of by a hash value
    if ( persistorChild.HasElement( XML_TAG_HASH_VALUE, XML_NAME_CLSID_SNAPIN ) )
    {
        CPersistor persistorHash( persistorChild, XML_TAG_HASH_VALUE, XML_NAME_CLSID_SNAPIN);
        persistorHash.PersistContents( hash );
        bByHash = true;
    }
    else
        persistorChild.Persist(clsid, XML_NAME_CLSID_SNAPIN);

    // persist the view id - default to value used to store component data
    int idView = VIEW_ID_DOCUMENT;
    persistorChild.PersistAttribute(XML_ATTR_ICOMPONENT_VIEW_ID, idView, attr_optional);

    // now we should look what data do we have
    // and persist if recognized
    if (persistorChild.HasElement(CXML_IStream::_GetXMLType(),NULL))
    {
        CXML_IStream *pXMLStream = NULL;

        if (bByHash)
        {
            pXMLStream = &m_StreamByHash[ hash_t(idView, hash) ];
        }
        else
        {
            sc = ScGetXmlStream( idView, clsid, pXMLStream );
            if (sc)
                sc.Throw();
        }

        sc = ScCheckPointers( pXMLStream, E_UNEXPECTED );
        if (sc)
            sc.Throw();

        persistorChild.Persist( *pXMLStream );
    }
    else if (persistorChild.HasElement(CXML_IStorage::_GetXMLType(),NULL))
    {
        CXML_IStorage *pXMLStorage = NULL;

        if (bByHash)
        {
            pXMLStorage = &m_StorageByHash[ hash_t(idView, hash) ];
        }
        else
        {
            sc = ScGetXmlStorage( idView, clsid, pXMLStorage );
            if (sc)
                sc.Throw();
        }

        sc = ScCheckPointers( pXMLStorage, E_UNEXPECTED );
        if (sc)
            sc.Throw();

        persistorChild.Persist( *pXMLStorage );
    }
}


/*+-------------------------------------------------------------------------*
 *+-------------------------------------------------------------------------* 
 *+-------------------------------------------------------------------------* 
 *+-------------------------------------------------------------------------*/


/*+-------------------------------------------------------------------------*
 *
 * CComponentPersistor::Persist
 *
 * PURPOSE:  persists IComponent collection related to snapin ( and its extensions)
 *
 * PARAMETERS:
 *    CPersistor &persistor :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CComponentPersistor::Persist(CPersistor &persistor)
{
    DECLARE_SC(sc, TEXT("CComponentPersistor::Persist"));

    // let the base class do the job
    BC::Persist( persistor, true /*bPersistViewId*/ );
}

/***************************************************************************\
 *
 * METHOD:  CComponentPersistor::ScReset
 *
 * PURPOSE: Restores component xml streams/storages into "Just loaded" state
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CComponentPersistor::ScReset()
{
    DECLARE_SC(sc, TEXT("CComponentPersistor::ScReset"));

    // save contents to string 
    std::wstring strContents;
    sc = ScSaveToString(&strContents);
    if (sc)
        return sc;

    // cleanup (anything not saved should go away)
    m_XMLStorage.clear();
    m_XMLStream.clear();

    // load from string
    sc = ScLoadFromString(strContents.c_str());
    if (sc)
        return sc;

    return sc;
}

//############################################################################
//############################################################################


/*+-------------------------------------------------------------------------*
 *
 * CDPersistor::Persist
 *
 * PURPOSE:  persists collection of component datas
 *
 * PARAMETERS:
 *    CPersistor& persistor :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CDPersistor::Persist(CPersistor& persistor)
{
    DECLARE_SC(sc, TEXT("CDPersistor::Persist"));

    // let the base class do the job
    BC::Persist( persistor, false /*bPersistViewId*/ );
}

/***************************************************************************\
 *
 * METHOD:  CDPersistor::ScReset
 *
 * PURPOSE: Restores component data xml streams/storages into "Just loaded" state
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CDPersistor::ScReset()
{
    DECLARE_SC(sc, TEXT("CDPersistor::ScReset"));

    // save contents to string 
    std::wstring strContents;
    sc = ScSaveToString(&strContents);
    if (sc)
        return sc;

    // cleanup (anything not saved should go away)
    m_XMLStorage.clear();
    m_XMLStream.clear();

    // load from string
    sc = ScLoadFromString(strContents.c_str());
    if (sc)
        return sc;

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\snapinpersistence.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2000
//
//  File:       snapinpersistence.h
//
//  Contents:
//
//  Classes: CComponentPersistor, CDPersistor
//
//____________________________________________________________________________

#pragma once

#ifndef SNAPINPERSISTENCE_H_INCLUDED

class CMTSnapInNode;
class CComponentData;

/***************************************************************************\
 *
 * CLASS:  CMTSnapinNodeStreamsAndStorages
 *
 * PURPOSE: Unified base class for CComponentPersistor and CDPersistor
 *          Encapsulated data and functionality for maintaining the collection
 *          of snapin streams and storages.
 *
 * USAGE:   Used as a base for CComponentPersistor and CDPersistor
 *          public methods available for clients of CComponentPersistor,
 *          CDPersistor uses iterfaces internally.
 *
\***************************************************************************/
class CMTSnapinNodeStreamsAndStorages : public XMLListCollectionBase
{
    typedef std::pair<int, CLSID>        key_t;
    typedef std::pair<int, std::wstring> hash_t;

public:

    // CDPersistor uses the same storage (provided by the this class)
    // as CComponent persistor , but it is not related to any view.
    // VIEW_ID_DOCUMENT is the special value for indicating ComponentData entry
    enum { VIEW_ID_DOCUMENT = -1 };

public: // methods not throwing exceptions

    // Initialize the storage for a snapin by copying the contents from
    // provided initialization source.
    SC ScInitIStorage( int idView, LPCWSTR szHash, IStorage *pSource );
    SC ScInitIStream ( int idView, LPCWSTR szHash, IStream  *pSource );

    // Returns the storage for snapin. Creates and caches one if does not have already
    SC ScGetIStorage( int idView, const CLSID& clsid, IStorage **ppStorage );
    SC ScGetIStream ( int idView, const CLSID& clsid, IStream  **ppStream  );

    // Checks if it has a storage for a snapins
    bool HasStream(int idView, const CLSID& clsid);
    bool HasStorage(int idView, const CLSID& clsid);
    
    void RemoveView(int nViewId);

    // returns the pointer to CXML_IStxxxxx object. Creates the object if does not have one
    SC ScGetXmlStorage(int idView, const CLSID& clsid, CXML_IStorage *& pXMLStorage);
    SC ScGetXmlStream (int idView, const CLSID& clsid, CXML_IStream  *& pXMLStream);

protected:
    std::map<key_t, CXML_IStorage>  m_XMLStorage;
    std::map<key_t, CXML_IStream>   m_XMLStream;

public:

    // persistence support for derived classes
    void Persist(CPersistor& persistor, bool bPersistViewId);
    virtual void OnNewElement(CPersistor& persistor);
    // implemented by the derived class
    virtual LPCTSTR GetItemXMLType() = 0;
    
private:

    SC ScFindXmlStorage(int idView, const CLSID& clsid, bool& bFound, CXML_IStorage *& pXMLStorage);
    SC ScFindXmlStream (int idView, const CLSID& clsid, bool& bFound, CXML_IStream  *& pXMLStream);
    
    // looks for snapin's data by the hash value
    // if any is found - moves data to 'known' snapin collection
    SC ScCheckForStreamsAndStoragesByHashValue( int idView, const CLSID& clsid, bool& bFound );

    // maps holding the old data comming from structured storage
    // untill the real data owner (snapin's CLSID) is known
    // We need this coz there is no conversion from hash to clsid
    std::map<hash_t, CXML_IStorage> m_StorageByHash;
    std::map<hash_t, CXML_IStream>  m_StreamByHash;
};


/*+-------------------------------------------------------------------------*
 * class CComponentPersistor
 *
 * PURPOSE: Persists IComponent collection accociated with the snapin
 *          holds IStream & IStorage maps for loading / storing data
 *
 *          Also holds and maintains a collection of all the streams and storages
 *          used by components of the snapin node and all the extensions
 *          extending this node or it's subnodes
 *
 *+-------------------------------------------------------------------------*/
class CComponentPersistor : public CMTSnapinNodeStreamsAndStorages
{
    typedef CMTSnapinNodeStreamsAndStorages BC;

public:
    SC ScReset();
protected:
    virtual void        Persist(CPersistor& persistor);

public:
    DEFINE_XML_TYPE(XML_TAG_ICOMPONENT_LIST);
    static LPCTSTR _GetItemXMLType() { return XML_TAG_ICOMPONENT; }
    virtual LPCTSTR GetItemXMLType()  { return _GetItemXMLType(); }
};

/*+-------------------------------------------------------------------------*
 * class CDPersistor
 *
 * PURPOSE: Persists IComponentData collection accociated with the snapin
 *          holds IStream & IStorage maps for loading / storing data
 *
 *          Also holds and maintains a collection of all the streams and storages
 *          used by component datas of the snapin node and all the extensions
 *          extending this node or it's subnodes
 *
 *+-------------------------------------------------------------------------*/
class CDPersistor : public CMTSnapinNodeStreamsAndStorages
{
    typedef CMTSnapinNodeStreamsAndStorages BC;

public: // interface to data maintained by CMTSnapinNodeStreamsAndStorages

    // CDPersistor uses the same storage (provided by the base class)
    // as CComponent persistor , but it is not related to any view.
    // VIEW_ID_DOCUMENT is the special value for indicating ComponentData entry

    // Initialize the storage for a snapin by copying the contents from
    // provided initialization source.
    SC ScInitIStorage( LPCWSTR szHash, IStorage *pSource )
    {
        return BC::ScInitIStorage( VIEW_ID_DOCUMENT, szHash, pSource );
    }

    SC ScInitIStream ( LPCWSTR szHash, IStream  *pSource )
    {
        return BC::ScInitIStream ( VIEW_ID_DOCUMENT, szHash, pSource );
    }

    // Returns the storage for snapin. Creates and caches one if does not have already
    SC ScGetIStorage( const CLSID& clsid, IStorage **ppStorage )
    {
        return BC::ScGetIStorage( VIEW_ID_DOCUMENT, clsid, ppStorage );
    }

    SC ScGetIStream ( const CLSID& clsid, IStream  **ppStream  )
    {
        return BC::ScGetIStream ( VIEW_ID_DOCUMENT, clsid, ppStream  );
    }

    // Checks if it has a storage for a snapins
    bool HasStream(const CLSID& clsid)
    {
        return BC::HasStream(VIEW_ID_DOCUMENT, clsid);
    }

    bool HasStorage(const CLSID& clsid)
    {
        return BC::HasStorage(VIEW_ID_DOCUMENT, clsid);
    }
    
public:
    SC ScReset();
protected:
    virtual void        Persist(CPersistor& persistor);

public:
    DEFINE_XML_TYPE(XML_TAG_ICOMPONENT_DATA_LIST);
    static  LPCTSTR _GetItemXMLType() { return XML_TAG_ICOMPONENT_DATA; }
    virtual LPCTSTR GetItemXMLType()  { return _GetItemXMLType(); }
};


#endif SNAPINPERSISTENCE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\snapin.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       SnapIn.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    9/11/1996   RaviR   Created
//
//____________________________________________________________________________



#include "stdafx.h"

#include "util.h"
#include "NodeMgr.h"
#include "regutil.h"
#include "regkeyex.h"
#include "tstring.h"
#include "about.h"
#include "bitmap.h"


#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/*
 * define our own Win64 symbol to make it easy to include 64-bit only
 * code in the 32-bit build, so we can exercise some code on 32-bit Windows
 * where the debuggers are better
 */
#ifdef _WIN64
#define MMC_WIN64
#endif

#ifdef MMC_WIN64
#include "wow64reg.h"	// for REG_OPTION_OPEN_32BITKEY
#endif

#ifdef DBG
#ifdef MMC_WIN64
CTraceTag  tagSnapinAnalysis64        (_T("64/32-bit interop"), _T("Snap-in analysis"));
CTraceTag  tagVerboseSnapinAnalysis64 (_T("64/32-bit interop"), _T("Snap-in analysis (verbose)"));
#endif	// MMC_WIN64
#endif


/*+-------------------------------------------------------------------------*
 * tstringFromCLSID
 *
 * Returns the text representation of a CLSID in a tstring.
 *--------------------------------------------------------------------------*/

tstring tstringFromCLSID (REFCLSID clsid)
{
    WCHAR wzCLSID[40];
    int nChars = StringFromGUID2 (clsid, wzCLSID, countof(wzCLSID));
    if (nChars == 0)
        return tstring();

    USES_CONVERSION;
    return (W2T (wzCLSID));
}


/*+-------------------------------------------------------------------------*
 * GetModuleVersion
 *
 * Reads the version resource in a module and returns the version string.
 *--------------------------------------------------------------------------*/

DWORD GetModuleVersion (LPCTSTR pszModule, LPTSTR pszBuffer)
{
    static bool  fAttemptedVersionDllLoad = false;
    static DWORD (APIENTRY* pfnGetFileVersionInfoSize)(LPCTSTR, LPDWORD)          = NULL;
    static BOOL  (APIENTRY* pfnGetFileVersionInfo)(LPCTSTR, DWORD, DWORD, LPVOID) = NULL;
    static BOOL  (APIENTRY* pfnVerQueryValue)(LPBYTE, LPCTSTR, LPVOID*, PUINT)    = NULL;

    if (!fAttemptedVersionDllLoad)
    {
        /*
         * only try once
         */
        fAttemptedVersionDllLoad = true;

        HINSTANCE hinst = LoadLibrary (_T("version.dll"));

        if (hinst != NULL)
        {
#ifdef UNICODE
            (FARPROC&)pfnGetFileVersionInfoSize = GetProcAddress (hinst, "GetFileVersionInfoSizeW");
            (FARPROC&)pfnGetFileVersionInfo     = GetProcAddress (hinst, "GetFileVersionInfoW");
            (FARPROC&)pfnVerQueryValue          = GetProcAddress (hinst, "VerQueryValueW");
#else
            (FARPROC&)pfnGetFileVersionInfoSize = GetProcAddress (hinst, "GetFileVersionInfoSizeA");
            (FARPROC&)pfnGetFileVersionInfo     = GetProcAddress (hinst, "GetFileVersionInfoA");
            (FARPROC&)pfnVerQueryValue          = GetProcAddress (hinst, "VerQueryValueA");
#endif
        }
    }

    *pszBuffer = 0;

    if (pfnGetFileVersionInfoSize != NULL)
    {
        ASSERT (pfnGetFileVersionInfo != NULL);
        ASSERT (pfnVerQueryValue      != NULL);

        ULONG lUnused;
        DWORD cbVerInfo = pfnGetFileVersionInfoSize (pszModule, &lUnused);

        if (cbVerInfo > 0)
        {
            LPBYTE pbVerInfo = new BYTE[cbVerInfo];
            VS_FIXEDFILEINFO* pffi;

            if (pfnGetFileVersionInfo != NULL && pfnVerQueryValue != NULL &&
                pfnGetFileVersionInfo (pszModule, NULL, cbVerInfo, pbVerInfo) &&
                pfnVerQueryValue (pbVerInfo, _T("\\"), (void**) &pffi, (UINT*)&lUnused))
            {
                wsprintf (pszBuffer, _T("%d.%d.%d.%d"),
                          HIWORD (pffi->dwFileVersionMS),
                          LOWORD (pffi->dwFileVersionMS),
                          HIWORD (pffi->dwFileVersionLS),
                          LOWORD (pffi->dwFileVersionLS));
            }

            delete[] pbVerInfo;
        }
    }

    return (lstrlen (pszBuffer));
}


/*+-------------------------------------------------------------------------*
 * SafeWriteProfileString
 *
 *
 *--------------------------------------------------------------------------*/

inline void SafeWritePrivateProfileString (
    LPCTSTR pszSection,
    LPCTSTR pszKey,
    LPCTSTR psz,
    LPCTSTR pszFile)
{
    if (!WritePrivateProfileString (pszSection, pszKey, psz, pszFile))
        THROW_ON_FAIL (HRESULT_FROM_WIN32 (GetLastError()));
}


//____________________________________________________________________________
//
//  Member:     CSnapIn::CSnapIn, Constructor
//
//  History:    9/19/1996   RaviR   Created
//____________________________________________________________________________
//

// {E6DFFF74-6FE7-11d0-B509-00C04FD9080A}
const GUID IID_CSnapIn =
{ 0xe6dfff74, 0x6fe7, 0x11d0, { 0xb5, 0x9, 0x0, 0xc0, 0x4f, 0xd9, 0x8, 0xa } };

// {7A85B79C-BDED-11d1-A4FA-00C04FB6DD2C}
static const GUID GUID_EnableAllExtensions =
{ 0x7a85b79c, 0xbded, 0x11d1, { 0xa4, 0xfa, 0x0, 0xc0, 0x4f, 0xb6, 0xdd, 0x2c } };

DEBUG_DECLARE_INSTANCE_COUNTER(CSnapIn);

CSnapIn::CSnapIn()
    :m_pExtSI(NULL), m_dwFlags(SNAPIN_ENABLE_ALL_EXTS), m_ExtPersistor(*this)
{
    TRACE_CONSTRUCTOR(CSnapIn);

#ifdef DBG
    dbg_cRef = 0;
#endif

    DEBUG_INCREMENT_INSTANCE_COUNTER(CSnapIn);
}


CSnapIn::~CSnapIn()
{
    DECLARE_SC(sc, TEXT("CSnapIn::~CSnapIn"));

    Dbg(DEB_USER1, _T("CSnapIn::~CSnapIn\n"));

    sc = ScDestroyExtensionList();
    if (sc)
    {
    }

#ifdef DBG
    ASSERT(dbg_cRef <= 0);
#endif

    DEBUG_DECREMENT_INSTANCE_COUNTER(CSnapIn);
}


DEBUG_DECLARE_INSTANCE_COUNTER(CExtSI);

CExtSI::CExtSI(CSnapIn* pSnapIn)
    : m_pSnapIn(pSnapIn), m_pNext(NULL), m_dwFlags(0)
{
    ASSERT(pSnapIn != NULL);
    m_pSnapIn->AddRef();

    DEBUG_INCREMENT_INSTANCE_COUNTER(CExtSI);
}

CExtSI::~CExtSI(void)
{
    SAFE_RELEASE(m_pSnapIn);
    delete m_pNext;

    DEBUG_DECREMENT_INSTANCE_COUNTER(CExtSI);
}


CSnapInsCache::CSnapInsCache()
    : m_bIsDirty(FALSE), m_bUpdateHelpColl(false)
{
}

CSnapInsCache::~CSnapInsCache()
{
    DECLARE_SC(sc, TEXT("CSnapInsCache::~CSnapInsCache"));

    // destruction will remove all snapins, but ask them to release extensions first,
    // this will break all circular references (else such snapins objects will be leaked).
    for (map_t::iterator it = m_snapins.begin(); it != m_snapins.end(); ++it)
    {
        // get pointer to the snapin
        CSnapIn* pSnapIn = it->second;
        sc = ScCheckPointers( pSnapIn, E_UNEXPECTED );
        if (sc)
        {
            sc.TraceAndClear();
            continue;
        }

        // ask snapin to destroy extension list
        sc = pSnapIn->ScDestroyExtensionList();
        if (sc)
            sc.TraceAndClear();
    }
}


/***************************************************************************\
 *
 * METHOD:  CSnapInsCache::ScIsDirty
 *
 * PURPOSE: returns dirty status of Snapin Cache
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code [SC(S_OK) - if dirty, SC(S_FALSE) else]
 *
\***************************************************************************/
SC CSnapInsCache::ScIsDirty()
{
    DECLARE_SC(sc, TEXT("CSnapInsCache::ScIsDirty"));

    TraceDirtyFlag(TEXT("CSnapInsCache"), m_bIsDirty);
    sc = m_bIsDirty ? SC(S_OK) : SC(S_FALSE);

    return sc;
}

void CSnapInsCache::SetDirty(BOOL bIsDirty)
{
    m_bIsDirty = bIsDirty;
}


/***************************************************************************\
 *
 * METHOD:  CSnapInsCache::Purge
 *
 * PURPOSE: Cleanup Snapin Cache by usage information
 *          Uses sphisticated algorithm to find out which snapins are not used
 *          see ScMarkExternallyReferencedSnapins() for description
 *          removes snapins which are not referenced externally
 *
 * PARAMETERS:
 *    BOOL bExtensionsOnly
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
void CSnapInsCache::Purge(BOOL bExtensionsOnly)
{
    DECLARE_SC(sc, TEXT("CSnapInsCache::Purge"));

    int iSnapIn;

    // Delete all extensions marked as deleted
    for (map_t::iterator it = m_snapins.begin(); it != m_snapins.end(); ++it)
    {
        CSnapIn* pSnapIn = it->second;
        ASSERT(pSnapIn != NULL);
        if (it->second != NULL)
            it->second->PurgeExtensions();
    }

    if (bExtensionsOnly)
        return;

    // Delete all snapins that have no external references
    sc = ScMarkExternallyReferencedSnapins();
    if (sc)
        return; // error occured - do not remove anything

    // remove not referenced
    for ( it = m_snapins.begin(); it != m_snapins.end(); )
    {
        CSnapIn *pSnapin = it->second;
        sc = ScCheckPointers( pSnapin, E_UNEXPECTED );
        if (sc)
            return;

        bool bExternallyReferenced;
        sc = pSnapin->ScTempState_IsExternallyReferenced( bExternallyReferenced );
        if (sc)
            return;

        if ( !bExternallyReferenced )
        {
            // destory extension list - it will break all circular references if such exist
            // (note- extension list is not needed anymore - snapin is not used anyway)
            sc = pSnapin->ScDestroyExtensionList();
            if (sc)
                return;

            // remove snapin from the cache;
            // in combination with the call above this will delete the object.
            it = m_snapins.erase( it );
        }
        else
        {
            ++it; // go to the next snapin
        }
    }
}

/***************************************************************************\
 *
 * METHOD:  CSnapInsCache::ScMarkExternallyReferencedSnapins
 *
 * PURPOSE: Marks all snapins in cache according to presence of external references
 *          This is done by following algorithm:
 *          1) For each snapin in the cache, all extensions have a temporary reference
 *              count incremented. Thus, at the end of this step, each snapin's temp
 *              ref count is equal to the number of snapins it extends.

            2) Each snapin compares the temp reference count to the total number of 
               references to it, taking into account the fact that the snapin cache
               itself holds a reference to each snapin. If the total references exceed
               the temp references, this indicates that the snapin has one or more 
               external references to it.
 *          Such a snapin is marked as "Externally referenced" as well as all its 
 *          extensions.
 *
 *          At the end of the process each snapin has a boolean flag indicating if
 *          the snapin is externally referenced. This flag is used in subsequential cache cleanup,
 *          or help topic building operation.
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CSnapInsCache::ScMarkExternallyReferencedSnapins()
{
    DECLARE_SC(sc, TEXT("CSnapInsCache::ScMarkExternallyReferencedSnapins"));

    // 1. reset the reference calculation data
    for ( map_t::iterator it = m_snapins.begin(); it != m_snapins.end(); ++it )
    {
        CSnapIn *pSnapin = it->second;
        sc = ScCheckPointers( pSnapin, E_UNEXPECTED );
        if (sc)
            return sc;

        sc = pSnapin->ScTempState_ResetReferenceCalculationData();
        if (sc)
            return sc;
    }

    // 2. update internal reference counts
    for ( it = m_snapins.begin(); it != m_snapins.end(); ++it )
    {
        CSnapIn *pSnapin = it->second;
        sc = ScCheckPointers( pSnapin, E_UNEXPECTED );
        if (sc)
            return sc;

        sc = pSnapin->ScTempState_UpdateInternalReferenceCounts();
        if (sc)
            return sc;
    }

    // now the snapins which have more references than internal ones do clearly
    // have direct external references
    // we can mark them and their extensions as "referenced"

    // 3. mark snapins with external references
    // Note: this step must occur after step 2 completes for ALL snapins.
    for ( it = m_snapins.begin(); it != m_snapins.end(); ++it )
    {
        CSnapIn *pSnapin = it->second;
        sc = ScCheckPointers( pSnapin, E_UNEXPECTED );
        if (sc)
            return sc;

        sc = pSnapin->ScTempState_MarkIfExternallyReferenced();
        if (sc)
            return sc;
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CSnapInsCache::ScGetSnapIn
 *
 * PURPOSE: either finds the snapin in cache , either creates the new one
 *
 * PARAMETERS:
 *    REFCLSID rclsid       - class id of snapin
 *    CSnapIn** ppSnapIn    - result
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CSnapInsCache::ScGetSnapIn(REFCLSID rclsid, CSnapIn** ppSnapIn)
{
    DECLARE_SC(sc, TEXT("CSnapInsCache::ScGetSnapIn"));

    // first - parameter check
    sc = ScCheckPointers(ppSnapIn);
    if (sc)
        return sc;

    // second - initialization
    *ppSnapIn = NULL;

    //
    //  See if it already exists.
    //
    sc = ScFindSnapIn(rclsid, ppSnapIn);
    if (!sc.IsError())
        return sc;  // jus return OK if we have it

    //
    // Create a new one & cache it
    //
    try
    {
        // Allocate the object
        CComObject<CSnapIn> *pSnapin = NULL;
        sc = CComObject<CSnapIn>::CreateInstance(&pSnapin);
        if (sc)
            return sc;

        // be sure we didn't get the NULL
        sc = ScCheckPointers(pSnapin, E_UNEXPECTED);
        if (sc)
            return sc;

        CSnapInPtr spSnapin = pSnapin;


        // Copy the object impl clsid
        spSnapin->SetSnapInCLSID(rclsid);

        //
        // Cache the object.
        //
        // note - this insertion also AddRef's the pointer
        m_snapins[rclsid] = spSnapin;

        *ppSnapIn = spSnapin.Detach(); // transfer reference to caller
    }
    catch( std::bad_alloc )
    {
        sc = E_OUTOFMEMORY;
    }

    return sc;
}

#ifdef DBG
void CSnapInsCache::DebugDump(void)
{
    TRACE(_T("===========Dump of SnapinsCache ===============\n"));

    for (map_t::iterator it = m_snapins.begin(); it != m_snapins.end(); ++it)
    {
        OLECHAR strGUID[64];

        CSnapIn* pSnapIn = it->second;

        StringFromGUID2(pSnapIn->GetSnapInCLSID(), strGUID, countof(strGUID));
        #ifdef DBG
        TRACE(_T("%s: RefCnt = %d, %s\n"), strGUID, pSnapIn->m_dwRef,
                pSnapIn->HasNameSpaceChanged() ? _T("NameSpace changed") : _T("No change"));
        #endif

        CExtSI* pExt = pSnapIn->GetExtensionSnapIn();
        while (pExt != NULL)
        {
            StringFromGUID2(pExt->GetSnapIn()->GetSnapInCLSID(), strGUID, countof(strGUID));
            #ifdef DBG
            // TODO: go to registry to see the type of extension:
            // these flags are not updated consistently
            TRACE(_T("    %s: %s%s  Extends(%s%s%s%s)\n"), strGUID,
                pExt->IsNew() ? _T("New ") : _T(""),
                pExt->IsMarkedForDeletion()  ? _T("Deleted ")   : _T(""),
                pExt->ExtendsNameSpace()     ? _T("NameSpace ") : _T(""),
                pExt->ExtendsContextMenu()   ? _T("Menu ")      : _T(""),
                pExt->ExtendsToolBar()       ? _T("ToolBar ")   : _T(""),
                pExt->ExtendsPropertySheet() ? _T("Properties") : _T(""),
                pExt->ExtendsView()          ? _T("View")       : _T(""),
                pExt->ExtendsTask()          ? _T("Task")       : _T("")
                );
            #endif

                pExt = pExt->Next();
        }
    }
}

#endif // DBG


/***************************************************************************\
 *
 * METHOD:  CSnapInsCache::ScFindSnapIn
 *
 * PURPOSE: finds the snapin by class id and returns AddRef'ed pointer
 *
 * PARAMETERS:
 *    REFCLSID rclsid       - class id of the snapin
 *    CSnapIn** ppSnapIn    - resulting pointer
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CSnapInsCache::ScFindSnapIn(REFCLSID rclsid, CSnapIn** ppSnapIn)
{
    DECLARE_SC(sc, TEXT("CSnapInsCache::ScFindSnapIn"));

    // first - parameter check
    sc = ScCheckPointers(ppSnapIn);
    if (sc)
        return sc;

    // second - initialization
    *ppSnapIn = NULL;

    // and now wee will se if we have one
    map_t::iterator it = m_snapins.find(rclsid);

    if (it == m_snapins.end())
        return E_FAIL; // not assigning to sc, since it's not really an error condition

    // be sure we do not return the NULL
    sc = ScCheckPointers(it->second, E_UNEXPECTED);
    if (sc)
        return sc;

    *ppSnapIn = it->second;
    (*ppSnapIn)->AddRef();

    return sc;
}


#ifdef TEMP_SNAPIN_MGRS_WORK
// Get all extensions.
void CSnapInsCache::GetAllExtensions(CSnapIn* pSI)
{
    if (!pSI)
        return;

    CExtensionsCache extnsCache;
    HRESULT hr = MMCGetExtensionsForSnapIn(pSI->GetSnapInCLSID(), extnsCache);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return;

    CExtensionsCacheIterator it(extnsCache);

    for (; it.IsEnd() == FALSE; it.Advance())
    {
        CSnapInPtr spSITemp;
        hr = GetSnapIn(it.GetKey(), &spSITemp);
        ASSERT(SUCCEEDED(hr));
        pSI->AddExtension(spSITemp);
    }
}
#endif // TEMP_SNAPIN_MGRS_WORK


/***************************************************************************\
 *
 * METHOD:  CSnapInsCache::ScSave
 *
 * PURPOSE:     saves contents of Snapin Cache to IStream
 *
 * PARAMETERS:
 *    IStream* pStream  - save to this stream
 *    BOOL bClearDirty  - reset dirty flag after save
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CSnapInsCache::ScSave(IStream* pStream, BOOL bClearDirty)
{
    DECLARE_SC(sc, TEXT("CSnapInsCache::ScSave"));

    // check the params
    sc = ScCheckPointers(pStream);
    if (sc)
        return sc;

    // iterate ans save all snapins
    for (map_t::iterator it = m_snapins.begin(); it != m_snapins.end(); ++it)
    {
        CSnapIn* pSnapIn = it->second;
        ASSERT(pSnapIn != NULL);
        if (pSnapIn != NULL)
        {
            sc = pSnapIn->Save(pStream, bClearDirty);
            if (sc)
                return sc;
        }
    }

    // terminating marker
    ULONG bytesWritten;
    sc = pStream->Write(&GUID_NULL, sizeof(GUID_NULL), &bytesWritten);
    if (sc)
        return sc;

    ASSERT(bytesWritten == sizeof(GUID_NULL));

    if (bClearDirty)
        SetDirty(FALSE);

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CSnapInsCache::Persist
 *
 * PURPOSE: Persists the CSnapInsCache to the specified persistor.
 *
 * PARAMETERS:
 *    CPersistor& persistor :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CSnapInsCache::Persist(CPersistor& persistor)
{
    if (persistor.IsStoring())
        for (map_t::iterator it = m_snapins.begin(); it != m_snapins.end(); ++it)
        {
            CSnapIn* pSnapIn = it->second;
            ASSERT(pSnapIn != NULL);
            if (pSnapIn != NULL)
                persistor.Persist(*pSnapIn);
        }
    else
    {
        XMLListCollectionBase::Persist(persistor);
        SetDirty(FALSE);
    }
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapInsCache::OnNewElement
 *
 * PURPOSE: called for each saved instance found in XML file.
 *          creates and uploads new snapin entry
 *
 * PARAMETERS:
 *    CPersistor& persistor :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CSnapInsCache::OnNewElement(CPersistor& persistor)
{
    DECLARE_SC(sc, TEXT("CSnapInsCache::OnNewElement"));
    ASSERT(persistor.IsLoading());

    CLSID clsid;
    CPersistor persistorSnapin(persistor, XML_TAG_SNAPIN);
    persistor.PersistAttribute(XML_ATTR_SNAPIN_CLSID, clsid);

    // create and upload snapin
    CSnapInPtr spSnapIn;
    sc = ScGetSnapIn(clsid, &spSnapIn);
    if (sc) // failed to creatre
        sc.Throw();
    if (spSnapIn != NULL)
        spSnapIn->PersistLoad(persistor,this);
    else // OK reported, pointer still NULL
        sc.Throw(E_POINTER);
}

/***************************************************************************\
 *
 * METHOD:  CSnapInsCache::ScLoad
 *
 * PURPOSE:     loads snapin cache from IStream
 *
 * PARAMETERS:
 *    IStream* pStream  - stream to load from
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CSnapInsCache::ScLoad(IStream* pStream)
{
    DECLARE_SC(sc, TEXT("CSnapInsCache::ScLoad"));

    // parameter check
    sc = ScCheckPointers(pStream);
    if (sc)
        return sc;

    // loop thru saved snapins...
    do
    {
        CLSID clsid;
        ULONG bytesRead;
        sc = pStream->Read(&clsid, sizeof(clsid), &bytesRead);
        if (sc)
            return sc;

        ASSERT(bytesRead == sizeof(clsid));

        // ... until special marker is found
        if (clsid == GUID_NULL)
        {
            SetDirty(FALSE);
            return S_OK;
        }

        // creale new snapin
        CSnapInPtr spSnapIn;
        sc = ScGetSnapIn(clsid, &spSnapIn);
        if (sc)
            return sc;

        // recheck the pointer
        sc = ScCheckPointers(spSnapIn, E_UNEXPECTED);
        if (sc)
            return sc;

        // load the contents of snapin
        sc = spSnapIn->Load(this, pStream);
        if (sc)
            return sc;
    } while (true);
    return E_FAIL; // shouldl never get here.
}


static void WriteSnapInCLSID (
    CSnapIn*    pSnapIn,
    LPCTSTR     pszSection,
    LPCTSTR     pszKeyPrefix,
    LPCTSTR     pszFilename)
{
    tstring strKey = _T("CLSID");

    if (pszKeyPrefix != NULL)
        strKey = pszKeyPrefix + strKey;

    tstring strCLSID = tstringFromCLSID (pSnapIn->GetSnapInCLSID());
    SafeWritePrivateProfileString (pszSection, strKey.data(), strCLSID.data(), pszFilename);
}


static void WriteSnapInName (
    CSnapIn*    pSnapIn,
    LPCTSTR     pszSection,
    LPCTSTR     pszKeyPrefix,
    LPCTSTR     pszFilename)
{
    tstring strKey = _T("Name");

    if (pszKeyPrefix != NULL)
        strKey = pszKeyPrefix + strKey;

	WTL::CString strName;
	SC sc = pSnapIn->ScGetSnapInName (strName);

    if (sc.IsError() || strName.IsEmpty())
        strName = _T("<unknown>");

    SafeWritePrivateProfileString (pszSection, strKey.data(), strName, pszFilename);
}


static void AppendString (tstring& str, LPCTSTR pszToAppend)
{
    if (!str.empty())
        str += _T(", ");

    str += pszToAppend;
}


static void WriteExtensionType (
    DWORD       dwExtensionFlags,
    LPCTSTR     pszSection,
    LPCTSTR     pszKeyPrefix,
    LPCTSTR     pszFilename)
{
    tstring strKey = _T("Type");

    if (pszKeyPrefix != NULL)
        strKey = pszKeyPrefix + strKey;

    struct {
        CExtSI::EXTSI_FLAGS flag;
        LPCTSTR             pszDescription;
    } FlagMap[] = {
        {   CExtSI::EXT_TYPE_REQUIRED,      _T("required")          },
        {   CExtSI::EXT_TYPE_STATIC,        _T("static")            },
        {   CExtSI::EXT_TYPE_DYNAMIC,       _T("dynamic")           },
        {   CExtSI::EXT_TYPE_NAMESPACE,     _T("namespace")         },
        {   CExtSI::EXT_TYPE_CONTEXTMENU,   _T("context menu")      },
        {   CExtSI::EXT_TYPE_TOOLBAR,       _T("toolbar")           },
        {   CExtSI::EXT_TYPE_PROPERTYSHEET, _T("property sheet")    },
        {   CExtSI::EXT_TYPE_TASK,          _T("taskpad")           },
        {   CExtSI::EXT_TYPE_VIEW,          _T("view")              },
    };

    tstring strType;

    for (int i = 0; i < countof (FlagMap); i++)
    {
        if (dwExtensionFlags & FlagMap[i].flag)
            AppendString (strType, FlagMap[i].pszDescription);
    }

    SafeWritePrivateProfileString (pszSection, strKey.data(), strType.data(), pszFilename);
}


HRESULT CSnapInsCache::Dump (LPCTSTR pszDumpFile)
{
    static const TCHAR szStandaloneSection[]  = _T("Standalone Snap-ins");
    static const TCHAR szStandaloneCountKey[] = _T("StandaloneCount");

    HRESULT hr = S_OK;
    int cStandalones = 0;

    try
    {
        /*
         * no stand-alone snap-ins found yet (write it now so it's at the
         * beginning of the section, for human readability)
         */
        SafeWritePrivateProfileString (szStandaloneSection, szStandaloneCountKey, _T("0"), pszDumpFile);

        /*
         * dump each snap-in to the file
         */
        for (map_t::iterator it = m_snapins.begin(); it != m_snapins.end(); ++it)
        {
            CSnapIn* pSnapIn = it->second;
            ASSERT(pSnapIn != NULL);
            if (pSnapIn == NULL)
                continue;

            pSnapIn->Dump (pszDumpFile, this);

            /*
             * if this is a stand-alone, update the "Standalone Snap-ins" section
             */
            if (pSnapIn->IsStandAlone())
            {
                TCHAR szKeyPrefix[16];
                wsprintf (szKeyPrefix, _T("Standalone%d."), ++cStandalones);

                WriteSnapInCLSID (pSnapIn, szStandaloneSection, szKeyPrefix, pszDumpFile);
                WriteSnapInName  (pSnapIn, szStandaloneSection, szKeyPrefix, pszDumpFile);
            }
        }

        /*
         * if we found stand-alones, update the count
         */
        if (cStandalones > 0)
        {
            TCHAR szStandaloneCount[6];
            _itot (cStandalones, szStandaloneCount, 10);
            SafeWritePrivateProfileString (szStandaloneSection, szStandaloneCountKey,
                                           szStandaloneCount, pszDumpFile);
        }
    }
    catch (_com_error& err)
    {
        hr = err.Error();
        ASSERT (false && "Caught _com_error");
    }

    return (hr);
}


/*+-------------------------------------------------------------------------*
 * CSnapInsCache::ScCheckSnapinAvailability
 *
 *
 *--------------------------------------------------------------------------*/

SC CSnapInsCache::ScCheckSnapinAvailability (CAvailableSnapinInfo& asi)
{
	DECLARE_SC (sc, _T("CSnapInsCache::ScCheckSnapinAvailability"));

#ifdef MMC_WIN64
	asi.m_cTotalSnapins = m_snapins.size();
	asi.m_vAvailableSnapins.clear();

	/*
	 * destroy any existing imagelist
	 */
	if (asi.m_himl)
		ImageList_Destroy (asi.m_himl);

	/*
	 * if we're interested in 32-bit snap-ins, make sure the registry APIs
	 * go to the 32-bit registry hive.
	 */
	const REGSAM samDesired = (asi.m_f32Bit) ? KEY_READ | REG_OPTION_OPEN_32BITKEY
											 : KEY_READ;

	CRegKey keyClsid;
	sc = ScFromWin32 (keyClsid.Open (HKEY_CLASSES_ROOT, _T("CLSID"), samDesired));
	if (sc)
		return (sc);

	CStr strUnknownSnapinName;
	VERIFY (strUnknownSnapinName.LoadString (GetStringModule(), IDS_UnknownSnapinName));

	/*
	 * create an imagelist, tracing (but not aborting) on failure
	 */
	const int nImageListFolder = 0;
	WTL::CImageList iml;
	if (!iml.Create (IDB_FOLDER_16, 16 /*cx*/, 4 /*cGrow*/, RGB(255,0,255) /*crMask*/))
		sc.FromLastError().TraceAndClear();

	/*
	 * for each snap-in in the cache...
	 */
	for (map_t::iterator it = m_snapins.begin(); it != m_snapins.end(); ++it)
	{
		/*
		 * ...check to see if there's an HKCR\CLSID\{clsid}\InprocServer32
		 * entry for it.  If there is, we'll assume the snap-in is "available".
		 */
		tstring	strSnapinClsid     = tstringFromCLSID (it->first);
		tstring	strInprocServerKey = strSnapinClsid + _T("\\InprocServer32");

		CRegKey keyInprocServer;
		LONG lResult = keyInprocServer.Open (keyClsid, strInprocServerKey.data(), samDesired);
		bool fSnapinAvailable = (lResult == ERROR_SUCCESS);

		/*
		 * if the snap-in's available, get it's name and put it in the
		 * available snap-ins collection
		 */
		if (fSnapinAvailable)
		{
			CBasicSnapinInfo bsi;
			bsi.m_clsid     = it->first;
			CSnapIn*pSnapin = it->second;

			/*
			 * get the snap-in's name
			 */
			WTL::CString strSnapinName;
			if ((pSnapin != NULL) && !pSnapin->ScGetSnapInName(strSnapinName).IsError())
				bsi.m_strName = strSnapinName;
			else
				bsi.m_strName = strUnknownSnapinName;		// "<unknown>"

			/*
			 * Get the snap-in's image from its about object
			 * (failures here aren't fatal and don't need to be traced).
			 * We'll use a generic folder icon if we can't get an image
			 * from the snap-in's about object.
			 */
			CLSID			clsidAbout;
			CSnapinAbout	snapinAbout;

			if (!iml.IsNull())
			{
				if (!ScGetAboutFromSnapinCLSID(bsi.m_clsid, clsidAbout).IsError() &&
					snapinAbout.GetBasicInformation (clsidAbout))	
				{
					/*
					 * the bitmaps returned by GetSmallImages are owned by
					 * the CSnapinAbout object (don't need to delete here)
					 */
					HBITMAP		hbmSmall;
					HBITMAP		hbmSmallOpen;	// unused here, but required for GetSmallImages
					COLORREF	crMask;
					snapinAbout.GetSmallImages (&hbmSmall, &hbmSmallOpen, &crMask);
	
					/*
					 * ImageList_AddMasked will mess up the background of
					 * its input bitmap, but the input bitmap won't be
					 * reused, so we don't need to make a copy like we
					 * usually do.
					 */
					WTL::CBitmap bmpSmall = CopyBitmap (hbmSmall);

					if (!bmpSmall.IsNull())
						bsi.m_nImageIndex = iml.Add (bmpSmall, crMask);
					else
						bsi.m_nImageIndex = nImageListFolder;
				}
				else
					bsi.m_nImageIndex = nImageListFolder;
			}

			/*
			 * put it in the available snap-ins collection
			 */
			asi.m_vAvailableSnapins.push_back (bsi);
		}

#ifdef DBG
		if (fSnapinAvailable)
			Trace (tagVerboseSnapinAnalysis64,
				   _T("  available: %s (image=%d)"),
				   asi.m_vAvailableSnapins.back().m_strName.data(),
				   asi.m_vAvailableSnapins.back().m_nImageIndex);
		else
			Trace (tagVerboseSnapinAnalysis64, _T("unavailable: %s"), strSnapinClsid.data());
#endif
	}

	Trace (tagSnapinAnalysis64, _T("%d-bit snap-in analysis: %d total, %d available"), asi.m_f32Bit ? 32 : 64, asi.m_cTotalSnapins, asi.m_vAvailableSnapins.size());

	/*
	 * give the imagelist to the CAvailableSnapinInfo
	 */
	asi.m_himl = iml.Detach();
#else
	sc = E_NOTIMPL;
#endif	// !MMC_WIN64

	return (sc);
}


void CSnapIn::MarkExtensionDeleted(CSnapIn* pSnapIn)
{
    ASSERT(pSnapIn != NULL);

    CExtSI* pExt = m_pExtSI;

    while (pExt != NULL)
    {
        if (pExt->GetSnapIn() == pSnapIn)
        {
            pExt->MarkDeleted();
            return;
        }

        pExt = pExt->Next();
    }

    // wasn't in the list !
    ASSERT(FALSE);
}


//
// Delete all extensions marked for deletion
// Also reset any New flags
//
void CSnapIn::PurgeExtensions()
{
    CExtSI* pExt = m_pExtSI;
    CExtSI* pExtPrev = NULL;

    // step through linked list, deleting marked nodes
    while (pExt != NULL)
    {
        if (pExt->IsMarkedForDeletion())
        {
            CExtSI *pExtNext = pExt->Next();

            if (pExtPrev)
                pExtPrev->SetNext(pExtNext);
            else
                m_pExtSI = pExtNext;

            // clear next link so extensions doesn't take the whole chain
            // with it when it is deleted
            pExt->SetNext(NULL);
            delete pExt;

            pExt = pExtNext;
        }
        else
        {
            pExt->SetNew(FALSE);

            pExtPrev = pExt;
            pExt = pExt->Next();
        }
    }
}

CExtSI* CSnapIn::FindExtension(const CLSID& rclsid)
{
    CExtSI* pExt = m_pExtSI;
    while (pExt != NULL && !IsEqualCLSID(rclsid, pExt->GetSnapIn()->GetSnapInCLSID()))
    {
        pExt = pExt->Next();
    }

    return pExt;
}


CExtSI* CSnapIn::AddExtension(CSnapIn* pSI)
{

    CExtSI* pExtSI = new CExtSI(pSI);
    ASSERT(pExtSI != NULL);
	if ( pExtSI == NULL )
		return NULL;

    // insert extension in increasing GUID order
    CExtSI* pExtPrev = NULL;
    CExtSI* pExtTemp = m_pExtSI;

    while (pExtTemp != NULL && pExtTemp->GetCLSID() < pExtSI->GetCLSID())
    {
        pExtPrev = pExtTemp;
        pExtTemp = pExtTemp->Next();
    }

    if (pExtPrev == NULL)
    {
        pExtSI->SetNext(m_pExtSI);
        m_pExtSI = pExtSI;
    }
    else
    {
        pExtSI->SetNext(pExtPrev->Next());
        pExtPrev->SetNext(pExtSI);
    }

    // mark as new
    pExtSI->SetNew();

    return pExtSI;
}

HRESULT CSnapIn::Save(IStream* pStream, BOOL fClearDirty)
{
    ASSERT(pStream != NULL);
    if (pStream == NULL)
        return E_INVALIDARG;

    ULONG bytesWritten;
    HRESULT hr = pStream->Write(&GetSnapInCLSID(), sizeof(CLSID), &bytesWritten);
    ASSERT(SUCCEEDED(hr) && bytesWritten == sizeof(CLSID));
    if (FAILED(hr))
        return hr;

    // If all extensions are enabled, then write special guid & flag and return
    if (AreAllExtensionsEnabled())
    {
        hr = pStream->Write(&GUID_EnableAllExtensions, sizeof(GUID), &bytesWritten);
        ASSERT(SUCCEEDED(hr) && bytesWritten == sizeof(GUID));
        if (FAILED(hr))
            return hr;

        int iSnapInEnable = DoesSnapInEnableAll() ? 1 : 0;
        hr = pStream->Write(&iSnapInEnable, sizeof(int), &bytesWritten);
        ASSERT(SUCCEEDED(hr) && bytesWritten == sizeof(int));

        return hr;
    }


    if (m_pExtSI)
    {
        hr = m_pExtSI->Save(pStream, fClearDirty);
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
            return hr;
    }

    // NULL guid to terminate extensions list
    hr = pStream->Write(&GUID_NULL, sizeof(GUID_NULL), &bytesWritten);
    ASSERT(SUCCEEDED(hr) && bytesWritten == sizeof(GUID_NULL));
    if (FAILED(hr))
        return hr;

    return S_OK;
}


HKEY CSnapIn::OpenKey (REGSAM samDesired /*=KEY_ALL_ACCESS*/) const
{
    MMC_ATL::CRegKey SnapInKey;
    MMC_ATL::CRegKey AllSnapInsKey;

    if (AllSnapInsKey.Open (HKEY_LOCAL_MACHINE, SNAPINS_KEY, samDesired) == ERROR_SUCCESS)
    {
        OLECHAR szItemKey[40];
        int nChars = StringFromGUID2 (m_clsidSnapIn, szItemKey, countof(szItemKey));
        if (nChars == 0)
            return NULL;

        USES_CONVERSION;
        SnapInKey.Open (AllSnapInsKey, OLE2T(szItemKey), samDesired);
    }

    return (SnapInKey.Detach());
}


/*+-------------------------------------------------------------------------*
 *
 * CSnapIn::Persist
 *
 * PURPOSE: Persists the CSnapIn to the specified persistor.
 *
 * PARAMETERS:
 *    CPersistor& persistor :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CSnapIn::Persist(CPersistor& persistor)
{
    if (persistor.IsStoring())
        persistor.PersistAttribute(XML_ATTR_SNAPIN_CLSID, *const_cast<GUID*>(&GetSnapInCLSID()));

    BOOL bAreAllExtensionsEnabled = AreAllExtensionsEnabled();
    persistor.PersistAttribute(XML_ATTR_SNAPIN_EXTN_ENABLED, CXMLBoolean(bAreAllExtensionsEnabled));
    SetAllExtensionsEnabled(bAreAllExtensionsEnabled);

    if(bAreAllExtensionsEnabled) // if all extensions are enabled, don't save anything else.
        return;

    // save the extension information if it exists
    persistor.Persist(m_ExtPersistor);
}

//+-------------------------------------------------------------------
//
//  Member:      CSnapIn::ScGetSnapInName
//
//  Synopsis:    Return the name of this snapin.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CSnapIn::ScGetSnapInName (WTL::CString& strSnapInName) const
{
    DECLARE_SC(sc, _T("CSnapIn::ScGetSnapInName"));

	sc = ScGetSnapinNameFromRegistry (m_clsidSnapIn, strSnapInName);
	if (sc)
		return (sc);

	return (sc);
}


DWORD CSnapIn::GetSnapInModule(TCHAR* pBuf, DWORD dwBufLen) const
{
    ASSERT(pBuf != NULL && dwBufLen != NULL);

    tstring strKeyName = g_szCLSID;
    strKeyName += _T("\\");
    strKeyName += tstringFromCLSID (m_clsidSnapIn);
    strKeyName += _T("\\");
    strKeyName += _T("InprocServer32");

    *pBuf = 0;

    MMC_ATL::CRegKey keyServer;
    if (keyServer.Open (HKEY_CLASSES_ROOT, strKeyName.data(), KEY_QUERY_VALUE) == ERROR_SUCCESS)
    {
        TCHAR szModule[MAX_PATH];
        DWORD cchModule = countof(szModule);

        if (keyServer.QueryValue (szModule, NULL, &cchModule) == ERROR_SUCCESS)
            ExpandEnvironmentStrings (szModule, pBuf, dwBufLen);
    }

    return (lstrlen (pBuf));
}


HRESULT CSnapIn::Load(CSnapInsCache* pCache, IStream* pStream, CExtSI*& pExtSI)
{
    ASSERT(pStream != NULL);
    if (pStream == NULL)
        return E_INVALIDARG;

    // Clear default enabling of all extensions. The true state will be
    // determined from the persisted data.
    SetAllExtensionsEnabled(FALSE);

    // Read CLSID
    CLSID clsid;
    ULONG bytesRead;
    HRESULT hr = pStream->Read(&clsid, sizeof(clsid), &bytesRead);
    ASSERT(SUCCEEDED(hr) && bytesRead == sizeof(clsid));
    if (FAILED(hr))
        return hr;

    if (bytesRead != sizeof(clsid))
        return hr = E_FAIL;

    if (clsid == GUID_NULL)
        return S_OK;

    // If special "Enable all" guid encountered, read flag to see if
    // snapin or user enabled all and return
    if (clsid == GUID_EnableAllExtensions)
    {
        SetAllExtensionsEnabled();

        int iSnapInEnable;
        hr = pStream->Read(&iSnapInEnable, sizeof(int), &bytesRead);
        ASSERT(SUCCEEDED(hr) && bytesRead == sizeof(int));

        if (iSnapInEnable)
            SetSnapInEnablesAll();

        return S_OK;
    }

    // Read extension type flags
    DWORD dwExtTypes;
    hr = pStream->Read(&dwExtTypes, sizeof(DWORD), &bytesRead);
    ASSERT(SUCCEEDED(hr) && bytesRead == sizeof(DWORD));
    if (FAILED(hr))
        return hr;

    if (pExtSI != NULL)
    {
        hr = Load(pCache, pStream, pExtSI);
        ASSERT(hr == S_OK);
        return hr == S_OK ? S_OK : E_FAIL;
    }

    CSnapInPtr spSnapIn;
    SC sc = pCache->ScGetSnapIn(clsid, &spSnapIn);
    if (sc)
        return sc.ToHr();

    ASSERT(spSnapIn != NULL);

    pExtSI = new CExtSI(spSnapIn);
    ASSERT(pExtSI != NULL);
	if ( pExtSI == NULL )
		return E_OUTOFMEMORY;

    pExtSI->SetExtensionTypes(dwExtTypes);

    hr = Load(pCache, pStream, pExtSI->Next());
    ASSERT(hr == S_OK);
    return hr == S_OK ? S_OK : E_FAIL;
}


HRESULT CSnapIn::Load(CSnapInsCache* pCache, IStream* pStream)
{
    HRESULT hr = Load(pCache, pStream, m_pExtSI);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;
    return S_OK;
}


bool CSnapIn::IsStandAlone () const
{
    MMC_ATL::CRegKey StandAloneKey;
    MMC_ATL::CRegKey ItemKey;
    ItemKey.Attach (OpenKey (KEY_READ));

    if (ItemKey.m_hKey != NULL)
        StandAloneKey.Open (ItemKey, g_szStandAlone, KEY_READ);

    return (StandAloneKey.m_hKey != NULL);
}


/*+-------------------------------------------------------------------------*
 * CSnapIn::Dump
 *
 * Dumps the information about this snap-in to a INI-style file.  The
 * format is:
 *
 *      [{clsid}]
 *      Name=<NameString from registry>
 *      Module=<dll name>
 *      Version=<dll version number>
 *      Standalone=<1 if standalone, 0 if extension>
 *      ExtensionCount=<number of extensions>
 *      Extension1={clsid} (extension name)
 *      ...
 *      ExtensionN={clsid} (extension name)
 *--------------------------------------------------------------------------*/

HRESULT CSnapIn::Dump (LPCTSTR pszDumpFile, CSnapInsCache* pCache)
{
    /*
     * use the CLSID as the section name
     */
    const tstring strSection = tstringFromCLSID (m_clsidSnapIn);

    /*
     * write Name
     */
    WriteSnapInName (this, strSection.data(), NULL, pszDumpFile);

    /*
     * write Module
     */
    TCHAR szModule[MAX_PATH];
    bool fFoundModule = (GetSnapInModule (szModule, countof (szModule)) != 0);

    if (!fFoundModule)
        lstrcpy (szModule, _T("<unknown>"));

    SafeWritePrivateProfileString (strSection.data(), _T("Module"), szModule, pszDumpFile);

    /*
     * write Version
     */
    TCHAR szVersion[64];
    if (!fFoundModule || !GetModuleVersion (szModule, szVersion))
        lstrcpy (szVersion, _T("<unknown>"));

    SafeWritePrivateProfileString (strSection.data(), _T("Version"), szVersion, pszDumpFile);

    /*
     * write Standalone
     */
    SafeWritePrivateProfileString (strSection.data(), _T("Standalone"),
                                   IsStandAlone() ? _T("1") : _T("0"),
                                   pszDumpFile);

    /*
     * make sure the extension chain has been built
     */
    if (AreAllExtensionsEnabled())
    {
        /*
         * Calling LoadRequiredExtensions with SNAPIN_SNAPIN_ENABLES_ALL set
         * will result in SNAPIN_ENABLE_ALL_EXTS being cleared, which we don't
         * want (rswaney).
         *
         * This happens because we haven't created the snap-in, so we can't
         * pass an IComponentData from which LoadRequiredExtensions can QI
         * for IRequiredExtensions.  LoadRequiredExtensions uses
         * IRequiredExtensions to determine whether SNAPIN_ENABLE_ALL_EXTS
         * should be cleared or set.  Since there's no IRequiredExtensions,
         * SNAPIN_ENABLE_ALL_EXTS would be cleared.
         */
        SetSnapInEnablesAll (false);

        LoadRequiredExtensions (this, NULL, pCache);
    }

    /*
     * write ExtensionCount
     */
    TCHAR szExtCount[8];
    CExtSI* pExt;
    int cExtensions = 0;

    // count the extensions
    for (pExt = m_pExtSI; pExt != NULL; pExt = pExt->Next())
        cExtensions++;

    _itot (cExtensions, szExtCount, 10);
    SafeWritePrivateProfileString (strSection.data(), _T("ExtensionCount"), szExtCount, pszDumpFile);

    /*
     * build up a cache of the extensions for this snap-in
     */
    CExtensionsCache  ExtCache;
    MMCGetExtensionsForSnapIn (m_clsidSnapIn, ExtCache);

    /*
     * write extensions
     */
    int i;
    for (i = 0, pExt = m_pExtSI; i < cExtensions; i++, pExt = pExt->Next())
    {
        TCHAR szKeyPrefix[20];
        wsprintf (szKeyPrefix, _T("Extension%d."), i+1);

        DWORD dwExtFlags = ExtCache[pExt->GetSnapIn()->m_clsidSnapIn];

        WriteSnapInCLSID   (pExt->GetSnapIn(), strSection.data(), szKeyPrefix, pszDumpFile);
        WriteSnapInName    (pExt->GetSnapIn(), strSection.data(), szKeyPrefix, pszDumpFile);
        WriteExtensionType (dwExtFlags,        strSection.data(), szKeyPrefix, pszDumpFile);
    }

    return (S_OK);
}

HRESULT CExtSI::Save(IStream* pStream, BOOL fClearDirty)
{
    ASSERT(pStream != NULL);
    if (pStream == NULL)
        return E_INVALIDARG;

    // Save extension CLSID
    ULONG bytesWritten;
    HRESULT hr = pStream->Write(&GetCLSID(), sizeof(CLSID), &bytesWritten);
    ASSERT(SUCCEEDED(hr) && bytesWritten == sizeof(CLSID));
    if (FAILED(hr))
        return hr;

    // Save extension types
    DWORD dwExtTypes = m_dwFlags & EXT_TYPES_MASK;
    hr = pStream->Write(&dwExtTypes, sizeof(DWORD), &bytesWritten);
    ASSERT(SUCCEEDED(hr) && bytesWritten == sizeof(DWORD));
    if (FAILED(hr))
        return hr;

    if (m_pNext == NULL)
        return S_OK;

    hr = m_pNext->Save(pStream, fClearDirty);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;
    return S_OK;
}

void CExtSI::Persist(CPersistor& persistor)
{
    // create an "Extension" object beneath the "Extensions" object.
    CPersistor persistorExtension(persistor, XML_TAG_SNAPIN_EXTENSION);

    persistorExtension.PersistAttribute(XML_ATTR_SNAPIN_CLSID, *const_cast<GUID*>(&GetCLSID()));
}

/*+-------------------------------------------------------------------------*
 *
 * CExtSI::PersistNew
 *
 * PURPOSE: called to create and persist new extension entry
 *
 * PARAMETERS:
 *    CPersistor& persistor :
 *    CSnapIn& snapParent   : parent to whom the extension belongs
 *    CSnapInsCache& snapCache : cache to put new (extension) snapin to
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CExtSI::PersistNew(CPersistor &persistor, CSnapIn& snapParent, CSnapInsCache& snapCache)
{
    DECLARE_SC(sc, TEXT("CExtSI::PersistNew"));

    CLSID clsid;
    CPersistor persistorExtension(persistor, XML_TAG_SNAPIN_EXTENSION);
    persistorExtension.PersistAttribute(XML_ATTR_SNAPIN_CLSID, clsid);

    CSnapInPtr spSnapIn;
    sc = snapCache.ScGetSnapIn(clsid, &spSnapIn);
    if (sc)
        sc.Throw();

    // create new extension entry
    CExtSI *pExtSI = snapParent.AddExtension(spSnapIn);
    sc = ScCheckPointers(pExtSI,E_FAIL);
    if (sc)
        sc.Throw();

    // upload new extension entry info
    pExtSI->Persist(persistor);
}

const CLSID& CExtSI::GetCLSID()
{
    ASSERT(m_pSnapIn != NULL);
    return m_pSnapIn ? m_pSnapIn->GetSnapInCLSID() : GUID_NULL;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapIn::PersistLoad
 *
 * PURPOSE: provided instead Persist to maintain reference to cache,
 *          required for registering new extensions during loading
 *
 * PARAMETERS:
 *    CPersistor& persistor :
 *    CSnapInsCache* pCache : cache to put new (extension) snapin to
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CSnapIn::PersistLoad(CPersistor& persistor,CSnapInsCache* pCache)
{
    m_ExtPersistor.SetCache(pCache);
    persistor.Persist(*this);
    m_ExtPersistor.SetCache(NULL);
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapIn::CExtPersistor::Persist
 *
 * PURPOSE: persists collection of extensions for snapin
 *
 * PARAMETERS:
 *    CPersistor& persistor :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CSnapIn::CExtPersistor::Persist(CPersistor& persistor)
{
    if (persistor.IsStoring())
    {
        CExtSI* pExt = GetParent().GetExtensionSnapIn();
        while (pExt)
        {
            pExt->Persist(persistor);
            pExt = pExt->Next();
        }
    }
    else
    {
        XMLListCollectionBase::Persist(persistor);
    }
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapIn::CExtPersistor::OnNewElement
 *
 * PURPOSE: called for each new entry read from XML doc.
 *
 * PARAMETERS:
 *    CPersistor& persistor :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CSnapIn::CExtPersistor::OnNewElement(CPersistor& persistor)
{
    DECLARE_SC(sc, TEXT("CSnapIn::CExtPersistor::OnNewElement"));

    sc = (persistor.IsLoading() && m_pCache != NULL) ? S_OK : E_FAIL;
    if (sc)
        sc.Throw();

    CExtSI::PersistNew(persistor, m_Parent, *m_pCache);
}

/***************************************************************************\
 *
 * METHOD:  CSnapIn::ScDestroyExtensionList
 *
 * PURPOSE: destroys the list of extensions. used to do preliminary snapin cleanup
 *          to avoid circular references held by the extension sanpin 
 *          locking the objects in the memory.
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CSnapIn::ScDestroyExtensionList()
{
    DECLARE_SC(sc, TEXT("CSnapIn::ScDestroyExtensionList"));

    // check if we have extensions
    if ( m_pExtSI != NULL )
    {
        // assign to auto variable 
        // ( 'this' may not be valid if the only reference is from extension )
        CExtSI *pExtension = m_pExtSI;

        // update member pointer
        m_pExtSI = NULL;

        delete pExtension;
        // delete the extension (it will delete the next and so on)
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CSnapIn::ScTempState_ResetReferenceCalculationData
 *
 * PURPOSE: resets external reference calculation data 
 *          Used as the first step for external reference calculation process
 *
 * PARAMETERS:
 *    
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CSnapIn::ScTempState_ResetReferenceCalculationData( )
{
    DECLARE_SC(sc, TEXT("CSnapIn::ScTempState_ResetReferenceCalculationData"));

    m_dwTempState_InternalRef = 0;
    m_bTempState_HasStrongRef = 0;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CSnapIn::ScTempState_UpdateInternalReferenceCounts
 *
 * PURPOSE: Informs snapin's extensions about the references kept to them
 *          Having this information extension snapin can know if it is 
 *          referenced externally
 *
 * PARAMETERS:
 *    
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CSnapIn::ScTempState_UpdateInternalReferenceCounts( )
{
    DECLARE_SC(sc, TEXT("CSnapIn::ScTempState_UpdateInternalReferenceCounts"));

    for ( CExtSI* pExtension = m_pExtSI; pExtension; pExtension = pExtension->Next() )
    {
        CSnapIn *pExtensionSnapin = pExtension->GetSnapIn();
        sc = ScCheckPointers( pExtensionSnapin, E_UNEXPECTED );
        if (sc)
            return sc;

        pExtensionSnapin->m_dwTempState_InternalRef++;
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CSnapIn::ScTempState_SetHasStrongReference
 *
 * PURPOSE: Marks itself as having external strong references (external to snapin cache)
 *          Marks own extensions as well.
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CSnapIn::ScTempState_SetHasStrongReference()
{
    DECLARE_SC(sc, TEXT("CSnapIn::ScTempState_SetHasStrongReference"));

    // do nothing if already marked (else we'll have the infinite loop)
    if ( m_bTempState_HasStrongRef )
        return sc;

    m_bTempState_HasStrongRef = true;

    // recurse to all extensions (they inherit the strong reference too)
    for ( CExtSI* pExtension = m_pExtSI; pExtension; pExtension = pExtension->Next() )
    {
        CSnapIn *pExtensionSnapin = pExtension->GetSnapIn();
        sc = ScCheckPointers( pExtensionSnapin, E_UNEXPECTED );
        if (sc)
            return sc;

        sc = pExtensionSnapin->ScTempState_SetHasStrongReference();
        if (sc)
            return sc;
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CSnapIn::ScTempState_MarkIfExternallyReferenced
 *
 * PURPOSE: Used as an intermediate step calculating external references
 *          compares internal references to total references.
 *          If has external references, marks itself as 'Externally referenced'
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CSnapIn::ScTempState_MarkIfExternallyReferenced()
{
    DECLARE_SC(sc, TEXT("CSnapIn::ScTempState_MarkIfExternallyReferenced"));

    DWORD dwStrongRef = m_dwRef - m_dwTempState_InternalRef - 1/*chache reference*/;

    if ( dwStrongRef > 0 )
    {
        // now mark itself and the extensions as having strong reference
        sc = ScTempState_SetHasStrongReference();
        if (sc)
            return sc;
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CSnapIn::ScTempState_IsExternallyReferenced
 *
 * PURPOSE:  Returns the cached reference status claculated by preceding 
 *           call to CSnapInsCache::ScMarkExternallyReferencedSnapins.
 *
 * PARAMETERS:
 *    bool& bReferenced [out] - true if snapin has external (to snapin cache) strong references
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CSnapIn::ScTempState_IsExternallyReferenced( bool& bReferenced ) const
{
    DECLARE_SC(sc, TEXT("CSnapIn::ScTempState_IsExternallyReferenced"));

    bReferenced = m_bTempState_HasStrongRef;

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       stdafx.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    sources.inc.

!ENDIF

MAJORCOMP=admin
MINORCOMP=MMC

TARGETNAME=mmcndmgr
TARGETPATH=obj
TARGETTYPE=DYNLINK

DLLENTRY=_DllMainCRTStartup
UMTYPE=windows

WIN32_WINNT_VERSION=0x0400
WIN32_IE_VERSION=0x0500
SUBSYSTEM_VERSION=4.00

C_DEFINES=  $(C_DEFINES) -D_NODEMGR_DLL_

USE_NATIVE_EH  = 1
USE_RTTI       = 1
USE_VCCOM      = 1
USE_STL        = 1
USE_STATIC_ATL = 1
ATL_VER        = 30
USE_MSVCRT     = 1
USE_WTL        = 1

!ifdef PrivateBuild_NoLocalSC
C_DEFINES = $(C_DEFINES) -DPrivateBuild_NoLocalSC
!endif

#
# Enable Fusion Build Magic (preprocess the manifest, stick in resources)
#
# The value of SXS_MANIFEST_RESOURCE_ID *must* be 2, to match a hardcoded value
# in WinbasePrivateCreateActCtxForHModule (winbase.inl).
#
SXS_ASSEMBLY_NAME                 = Microsoft.Windows.MMCNDMGR
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT = 1
SXS_MANIFEST                      = mmcndmgr.manifest
SXS_MANIFEST_IN_RESOURCES         = 1
SXS_NO_BINPLACE                   = 1
SXS_MANIFEST_RESOURCE_ID          = 2

C_DEFINES=  $(C_DEFINES) -DISOLATION_AWARE_ENABLED

# Use LINKLIBS (gets passed first) if: (from build.hlp)
#  You are building a dynamic link.
#  You are exporting something that's defined in some other component library that you also build.
#  In your dirs file in the subdirectory above, you have ordered it so that the component libraries
#     are around before you build the dynamic link.
LINKLIBS = \
	$(SDK_LIB_PATH)\mmc.lib						\
	..\..\core\$(CharWidth)\$(O)\uicore.lib		\
	..\..\base\$(CharWidth)\$(O)\mmcbase.lib	\
	..\..\types\proxy\$(O)\ndmgrproxy.lib

# We need $(SHELL_LIB_PATH)\shlwapip.lib for SHLoadRegUIString
TARGETLIBS = \
	$(SDK_LIB_PATH)\kernel32.lib    \
	$(SDK_LIB_PATH)\user32.lib      \
	$(SDK_LIB_PATH)\oleaut32.lib    \
	$(SDK_LIB_PATH)\ole32.lib       \
	$(SDK_LIB_PATH)\advapi32.lib    \
	$(SDK_LIB_PATH)\uuid.lib        \
	$(SDK_LIB_PATH)\comctl32.lib    \
	$(SDK_LIB_PATH)\gdi32.lib       \
	$(SDK_LIB_PATH)\comdlg32.lib    \
	$(SDK_LIB_PATH)\urlmon.lib      \
	$(SDK_LIB_PATH)\shell32.lib		\
	$(SHELL_LIB_PATH)\shlwapip.lib	\
	$(SDK_LIB_PATH)\rpcrt4.lib      \
	$(WINDOWS_LIB_PATH)\cicsthkl.lib      \
			

# To prevent AV in CPropertyPage::DoModal
LINKER_FLAGS = $(LINKER_FLAGS) /SECTION:.rsrc,rw

DLLDEF=..\mmcndmgr.def

# We need $(SHELL_INC_PATH) for shlwapip.h and uastrfnc.h
# We need $(BASE_INC_PATH)  for wow64reg.h
INCLUDES = \
	..\;					\
	..\..\inc;				\
	..\..\base;             \
	..\..\types\idl\$(O);   \
	$(SHELL_INC_PATH);		\
	$(BASE_INC_PATH);		\
    $(WINDOWS_INC_PATH);

PRECOMPILED_INCLUDE = ..\stdafx.h
PRECOMPILED_CXX = 1

# This target is required so $O\nodemgr.res doesn't become the default target
# for makefile.def.  We want "all" to be the default target.
#
# We have to go to this effort because sources(.inc) is included very early
# in makefile.def.  makefile.inc is the place where this would naturally go,
# but we don't want to have to maintain this dependency list in
# ansi\makefile.inc and unicode\makefile.inc.
dummytarget:    all

$O\nodemgr.res: \
	..\res\snpinlst.bmp         		\
	..\res\imagelis.bmp         		\
	..\res\compwiz.bmp          		\
	..\res\setupwiz.bmp         		\
	..\res\ocxwzhd.bmp          		\
	..\res\chkboxes.bmp         		\
	..\res\task_wiz.bmp         		\
	..\res\taskwzhd.bmp         		\
	..\res\h_l.bmp              		\
	..\res\h_m.bmp              		\
	..\res\h_s.bmp              		\
	..\res\hd_l.bmp             		\
	..\res\hd_m.bmp             		\
	..\res\hd_s.bmp             		\
	..\res\t.bmp                		\
	..\res\td.bmp               		\
	..\res\v_l.bmp              		\
	..\res\v_m.bmp              		\
	..\res\v_s.bmp              		\
	..\res\vd_l.bmp             		\
	..\res\vd_m.bmp             		\
	..\res\vd_s.bmp             		\
	..\res\bitmap1.bmp          		\
	..\res\bmp00001.bmp         		\
	..\res\folderop.bmp         		\
	..\res\ocx_16.bmp           		\
	..\res\html16.bmp           		\
	..\res\html_32.bmp          		\
	..\res\bmp00002.bmp         		\
	..\res\folder.ico           		\
	..\res\html.ico             		\
	..\res\ocx.ico              		\
	..\viewext\views.htm        		\
    ..\viewext\ctpcommon.htm            \
    ..\viewext\ctpnoresults.htm         \
    ..\viewext\ctpvert.htm              \
    ..\viewext\ctphoriz.htm             \
    ..\viewext\ctptask.htm              \
	..\res\fldrsnap.rgs         		\
	..\res\ctpsymbols\symbol1.ico		\
	..\res\ctpsymbols\symbol2.ico		\
	..\res\ctpsymbols\symbol3.ico		\
	..\res\ctpsymbols\symbol4.ico		\
	..\res\ctpsymbols\symbol5.ico		\
	..\res\ctpsymbols\symbol6.ico		\
	..\res\ctpsymbols\symbol7.ico		\
	..\res\ctpsymbols\symbol8.ico		\
	..\res\ctpsymbols\symbol9.ico		\
	..\res\ctpsymbols\symbol10.ico		\
	..\res\ctpsymbols\symbol11.ico		\
	..\res\ctpsymbols\symbol12.ico		\
	..\res\ctpsymbols\symbol13.ico		\
	..\res\ctpsymbols\symbol14.ico		\
	..\res\ctpsymbols\symbol15.ico		\
	..\res\ctpsymbols\symbol16.ico		\
	..\res\ctpsymbols\symbol17.ico		\
	..\res\ctpsymbols\symbol18.ico		\
	..\res\ctpsymbols\symbol19.ico		\
	..\res\ctpsymbols\symbol20.ico		\
	..\res\ctpsymbols\symbol21.ico		\
	..\res\ctpsymbols\symbol22.ico		\
	..\res\ctpsymbols\symbol23.ico		\
	..\res\ctpsymbols\symbol24.ico		\
	..\res\ctpsymbols\symbol25.ico		\
	..\res\ctpsymbols\symbol26.ico		\
	..\res\ctpsymbols\symbol27.ico		\
	..\res\ctpsymbols\symbol28.ico		\
	..\res\ctpsymbols\symbol29.ico		\
	..\res\ctpsymbols\symbol30.ico		\
	..\res\ctpsymbols\symbol31.ico		\
	..\res\ctpsymbols\symbol32.ico		\
	..\res\ctpsymbols\symbol33.ico		\
	..\res\ctpsymbols\symbol34.ico		\
	..\res\ctpsymbols\symbol35.ico		\
	..\res\ctpsymbols\symbol36.ico		\
	..\res\ctpsymbols\symbol37.ico		\
	..\res\ctpsymbols\symbol38.ico		\
	..\res\ctpsymbols\symbol39.ico		\
	..\res\ctpsymbols\symbol40.ico		\
	..\res\ctpsymbols\symbol41.ico		\
	..\res\ctpsymbols\symbol42.ico		\
	..\res\ctpsymbols\symbol43.ico		\
	..\res\ctpsymbols\symbol44.ico		\
	..\res\ctpsymbols\symbol45.ico		\
	..\res\ctpsymbols\symbol46.ico		\
	..\res\ctpsymbols\symbol47.ico		\
	..\res\ctpsymbols\symbol48.ico		\
	..\res\ctpsymbols\symbol49.ico		\
	..\res\ctpsymbols\symbol50.ico		\
	..\res\ctpsymbols\symbol51.ico		\
	..\res\ctpsymbols\symbol52.ico		\
	..\res\ctpsymbols\symbol53.ico		\
	..\res\ctpsymbols\symbol54.ico		\
	..\res\ctpsymbols\symbol55.ico		\
	..\res\ctpsymbols\symbol56.ico		\
	..\res\ctpsymbols\symbol57.ico		\
	..\res\ctpsymbols\symbol58.ico		\
	..\res\ctpsymbols\symbol59.ico		\
	..\res\ctpsymbols\symbol60.ico		\
	..\res\ctpsymbols\symbol61.ico		\
	..\res\ctpsymbols\symbol62.ico		\
	..\res\ctpsymbols\symbol63.ico		\
	..\res\ctpsymbols\symbol64.ico		\
	..\res\ctpsymbols\symbol65.ico		\
	..\res\ctpsymbols\symbol66.ico		\
	..\res\ctpsymbols\symbol67.ico		\
	..\res\ctpsymbols\symbol68.ico		\
	..\res\ctpsymbols\symbol69.ico		\
	..\res\ctpsymbols\symbol70.ico		\
	..\res\ctpsymbols\symbol71.ico		\
	..\res\ctpsymbols\symbol72.ico		\
	..\res\ctpsymbols\symbol73.ico		\
	..\res\ctpsymbols\symbol74.ico		\
	..\res\ctpsymbols\symbol75.ico		\
	..\res\ctpsymbols\symbol76.ico		\
	..\res\ctpsymbols\symbol77.ico		\
	..\res\ctpsymbols\symbol78.ico		\
	..\res\ctpsymbols\symbol79.ico		\
	..\res\ctpsymbols\symbol80.ico		\
	..\res\ctpsymbols\symbol81.ico		\
	..\res\ctpsymbols\symbol82.ico		\
	..\res\ctpsymbols\symbol83.ico		\
	..\res\ctpsymbols\symbol84.ico		\
	..\res\ctpsymbols\symbol85.ico		\
	..\res\ctpsymbols\symbol86.ico		\
	..\res\ctpsymbols\symbol87.ico		\
	..\res\ctpsymbols\symbol88.ico		\
	..\res\ctpsymbols\symbol89.ico		\
	..\res\ctpsymbols\symbol90.ico		\
	..\res\ctpsymbols\symbol91.ico		\
	..\res\ctpsymbols\symbol92.ico		\
	..\res\ctpsymbols\symbol93.ico		\
	..\res\ctpsymbols\symbol94.ico		\
	..\res\ctpsymbols\symbol95.ico		\
	..\res\ctpsymbols\symbol96.ico		\
	..\res\ctpsymbols\symbol97.ico		\
	..\res\ctpsymbols\symbol98.ico		\
	..\res\ctpsymbols\symbol99.ico		\
	..\res\ctpsymbols\symbol100.ico		\
	..\res\ctpsymbols\symbol101.ico		\
	..\res\ctpsymbols\symbol102.ico		\
	..\res\ctpsymbols\symbol103.ico		\
	..\res\ctpsymbols\symbol104.ico		\
	..\res\ctpsymbols\symbol105.ico		\
	..\res\ctpsymbols\symbol106.ico		\
	..\res\ctpsymbols\symbol107.ico		\
	..\res\ctpsymbols\symbol108.ico		\
	..\res\ctpsymbols\symbol109.ico		\
	..\res\ctpsymbols\symbol110.ico		\
	..\res\ctpsymbols\symbol111.ico		\
	..\res\ctpsymbols\symbol112.ico		\
	..\res\ctpsymbols\symbol113.ico		\
	..\res\ctpsymbols\symbol114.ico		\
	..\res\ctpsymbols\symbol115.ico		\
	..\res\ctpsymbols\symbol116.ico		\
	..\res\ctpsymbols\symbol117.ico		\
	..\res\ctpsymbols\symbol118.ico		\
	..\res\ctpsymbols\symbol119.ico		\
	..\res\ctpsymbols\symbol120.ico		\
	..\res\ctpsymbols\symbol121.ico		\
	..\res\ctpsymbols\symbol122.ico		\
	..\res\ctpsymbols\symbol123.ico		\
	..\res\ctpsymbols\symbol124.ico		\
	..\res\ctpsymbols\symbol125.ico		\
	..\res\ctpsymbols\symbol126.ico		\
	..\..\types\idl\$(O)\ndmgr.tlb		\

SOURCES = \
	..\nodemgr.rc       		\
	..\about.cpp        		\
	..\addsnpin.cpp     		\
	..\ccomboex.cpp     		\
	..\cmenu.cpp        		\
	..\coldata.cpp      		\
	..\colwidth.cpp     		\
	..\compcat.cpp      		\
	..\copypast.cpp     		\
	..\ctrlbar.cpp      		\
	..\doccnfg.cpp      		\
	..\dummysi.cpp      		\
	..\fldrsnap.cpp     		\
	..\helpdoc.cpp      		\
	..\IconControl.cpp  		\
	..\menubtn.cpp      		\
	..\menuitem.cpp     		\
	..\mmcmt.cpp        		\
	..\mmcprotocol.cpp  		\
	..\moreutil.cpp     		\
	..\msgview.cpp      		\
	..\mtnode.cpp       		\
	..\multisel.cpp     		\
	..\newnode.cpp      		\
	..\nmutil.cpp       		\
	..\node.cpp         		\
	..\node.cpp         		\
	..\nodeinit.cpp     		\
	..\nodemgr.cpp      		\
	..\nodepath.cpp     		\
	..\objfmts.cpp      		\
	..\oncmenu.cpp      		\
	..\plex.cpp         		\
	..\policy.cpp       		\
	..\power.cpp        		\
	..\propsht.cpp      		\
	..\ptrlist.cpp      		\
	..\regkeyex.cpp     		\
	..\regutil.cpp      		\
	..\rsltdata.cpp     		\
	..\scopdata.cpp     		\
	..\scopimag.cpp     		\
	..\scopiter.cpp     		\
	..\scopndcb.cpp     		\
	..\scoptree.cpp     		\
	..\siprop.cpp       		\
	..\snapin.cpp       		\
	..\snapinpersistence.cpp        \
	..\ststring.cpp     		\
	..\task.cpp         		\
	..\taskenum.cpp     		\
	..\tasknode.cpp     		\
	..\tasksym.cpp      		\
	..\tasksymbol.cpp   		\
	..\taskui.cpp       		\
	..\toolbar.cpp      		\
	..\typeinfo.cpp     		\
	..\verbs.cpp        		\
	..\viewdata.cpp     		\
	..\viewext.cpp      		\
	..\viewpers.cpp     		\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\ststring.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      ststring.cpp
 *
 *  Contents:  Implementation file for CStringTableString
 *
 *  History:   28-Oct-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"


/*+-------------------------------------------------------------------------*
 * CStringTableString::GetStringTable 
 *
 *
 *--------------------------------------------------------------------------*/

IStringTablePrivate* CStringTableString::GetStringTable () const
{
    return (CScopeTree::GetStringTable());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#undef _MSC_EXTENSIONS

#define ASSERT(x)   _ASSERTE(x)

#include <new.h>

#include <crtdbg.h>

#define OEMRESOURCE 1
#include <windows.h>

#include <shellapi.h>
#include <mmctempl.h>

#include <objidl.h>
#include <commctrl.h>
#include <mmcmt.h>

//############################################################################
//############################################################################
//
// MMC headers
//
//############################################################################
#include <mmc.h>
#include <ndmgr.h>
#include <ndmgrpriv.h>

#include <mmcptrs.h>

//############################################################################
//############################################################################
//
// ATL
//
//############################################################################
//############################################################################
// The #define below is to work around an ATL bug causing bug C2872
#define MMC_ATL ::ATL
#define _WTL_NO_AUTOMATIC_NAMESPACE

#include <atlbase.h>

using namespace MMC_ATL;
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module; // Needs to be declared BEFORE atlcom.h

#include <atlcom.h>
#include <atlwin.h>
#include <atlapp.h>
#include <atlmisc.h>
#include <atlctrls.h>
#include <atlgdi.h>
#include <atlctl.h>
#include <dlgs.h>
#include <atldlgs.h>


//############################################################################
//############################################################################
//
// STL and  other classes
//
//############################################################################
//############################################################################
#include <algorithm>
#include <exception>
#include <string>
#include <list>
#include <set>
#include <vector>
#include <map>
#include <iterator>

//############################################################################
//############################################################################

// definition to compile code specific to node manager dll
#define _MMC_NODE_MANAGER_ONLY_

//############################################################################
//############################################################################
//
// Files #included from base and core.
//
//############################################################################
//############################################################################
#include "dbg.h"
#include "cstr.h"
#include "mmcdebug.h"
#include "mmcerror.h"
#include "tiedobj.h"
#include "comerror.h"
#include "events.h"         // Observer pattern implementation.
#include "strings.h"

// included from NODEMGR (needs some BASE stuff, redefines some as well)
#include "typeinfo.h" // defines IDispatchImpl substitution for node manager

#include "AutoPtr.h"
#include "comobjects.h"
#include "enumerator.h"

//############################################################################
//############################################################################
//
// include common and nodemgr-only strings.
//
//############################################################################
//############################################################################
#include "..\base\basestr.h"
#include "..\base\nodemgrstr.h"

//############################################################################
//############################################################################
//
// Debug support for legacy traces.
//
//############################################################################
//############################################################################
#ifdef DBG

#define TRACE TraceNodeMgrLegacy

#else // DBG

#define TRACE               ;/##/

#endif DBG

//############################################################################
//############################################################################
//
// Other files
//
//############################################################################
//############################################################################
#include "mmcatl.h"
#include "regkeyex.h"
#include "guidhelp.h"
#include "macros.h"
#include "moreutil.h"
#include "amcmsgid.h"
#include "mfccllct.h"
#include "mmcutil.h"
#include "countof.h"
#include "stgio.h"
#include "serial.h"
#include "stlstuff.h"
#include "bookmark.h"
#include "xmlbase.h"
#include "resultview.h"
#include "viewset.h"
#include "memento.h"
#include "objmodelptrs.h"
#include "mmcdata.h"
#include "viewdata.h"
#include "cpputil.h"

class CComponent;
class CMTNode;
typedef CComponent* PCOMPONENT;
typedef std::vector<PCOMPONENT> CComponentArray;
typedef CMTNode* PMTNODE;
typedef std::vector<PMTNODE>    CMTNodePtrArray;


//############################################################################
//############################################################################
//
// Files from the nodemgr subsystem
//
//############################################################################
//############################################################################
#include "mmcres.h"
#include "resource.h"
#include "helparr.h"
#include "classreg.h"
#include "snapin.h"
#include "npd.h"
#include "nmtempl.h"
#include "imageid.h"
#include "amcpriv.h"
#include "containr.h"
#include "ststring.h"
#include "nodepath.h"
#include "mtnode.h"
#include "node.h"
#include "propsht.h"
#include "coldata.h"
#include "toolbar.h"
#include "ctrlbar.h"
#include "verbs.h"
#include "scoptree.h"
#include "nodeinit.h"
#include "wiz97.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\symbinfo.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       symbinfo.h
//
//--------------------------------------------------------------------------

#define CTP_ICON_BASE   30500
#define CTP_STRING_BASE 30000

class CEOTSymbol s_rgEOTSymbol[] =
{
    CEOTSymbol(CTP_ICON_BASE + 1   , 0x0021, CTP_STRING_BASE +   8, CTP_STRING_BASE +   9),
    CEOTSymbol(CTP_ICON_BASE + 2   , 0x0022, CTP_STRING_BASE +  10, CTP_STRING_BASE +  11),
    CEOTSymbol(CTP_ICON_BASE + 3   , 0x0023, CTP_STRING_BASE +  12, CTP_STRING_BASE +  13),
    CEOTSymbol(CTP_ICON_BASE + 4   , 0x0024, CTP_STRING_BASE +  14, CTP_STRING_BASE +  15),
    CEOTSymbol(CTP_ICON_BASE + 5   , 0x0025, CTP_STRING_BASE +  16, CTP_STRING_BASE +  17),
    CEOTSymbol(CTP_ICON_BASE + 6   , 0x0027, CTP_STRING_BASE +  20, CTP_STRING_BASE +  21),
    CEOTSymbol(CTP_ICON_BASE + 7   , 0x0028, CTP_STRING_BASE +  22, CTP_STRING_BASE +  23),
    CEOTSymbol(CTP_ICON_BASE + 8   , 0x0029, CTP_STRING_BASE +  24, CTP_STRING_BASE +  25),
    CEOTSymbol(CTP_ICON_BASE + 9   , 0x002A, CTP_STRING_BASE +  26, CTP_STRING_BASE +  27),
    CEOTSymbol(CTP_ICON_BASE + 10  , 0x002B, CTP_STRING_BASE +  28, CTP_STRING_BASE +  29),
    CEOTSymbol(CTP_ICON_BASE + 11  , 0x002C, CTP_STRING_BASE +  30, CTP_STRING_BASE +  31),
    CEOTSymbol(CTP_ICON_BASE + 12  , 0x002D, CTP_STRING_BASE +  32, CTP_STRING_BASE +  33),
    CEOTSymbol(CTP_ICON_BASE + 13  , 0x002E, CTP_STRING_BASE +  34, CTP_STRING_BASE +  35),
    CEOTSymbol(CTP_ICON_BASE + 14  , 0x002F, CTP_STRING_BASE +  36, CTP_STRING_BASE +  37),
    CEOTSymbol(CTP_ICON_BASE + 15  , 0x0030, CTP_STRING_BASE +  38, CTP_STRING_BASE +  39),
    CEOTSymbol(CTP_ICON_BASE + 16  , 0x0031, CTP_STRING_BASE +  40, CTP_STRING_BASE +  41),
    CEOTSymbol(CTP_ICON_BASE + 17  , 0x0032, CTP_STRING_BASE +  42, CTP_STRING_BASE +  43),
    CEOTSymbol(CTP_ICON_BASE + 18  , 0x0033, CTP_STRING_BASE +  44, CTP_STRING_BASE +  45),
    CEOTSymbol(CTP_ICON_BASE + 19  , 0x0034, CTP_STRING_BASE +  46, CTP_STRING_BASE +  47),
    CEOTSymbol(CTP_ICON_BASE + 20  , 0x0035, CTP_STRING_BASE +  48, CTP_STRING_BASE +  49),
    CEOTSymbol(CTP_ICON_BASE + 21  , 0x0036, CTP_STRING_BASE +  50, CTP_STRING_BASE +  51),
    CEOTSymbol(CTP_ICON_BASE + 22  , 0x0037, CTP_STRING_BASE +  52, CTP_STRING_BASE +  53),
    CEOTSymbol(CTP_ICON_BASE + 23  , 0x0038, CTP_STRING_BASE +  54, CTP_STRING_BASE +  55),
    CEOTSymbol(CTP_ICON_BASE + 24  , 0x0039, CTP_STRING_BASE +  56, CTP_STRING_BASE +  57),
    CEOTSymbol(CTP_ICON_BASE + 25  , 0x003A, CTP_STRING_BASE +  58, CTP_STRING_BASE +  59),
    CEOTSymbol(CTP_ICON_BASE + 26  , 0x003B, CTP_STRING_BASE +  60, CTP_STRING_BASE +  61),
    CEOTSymbol(CTP_ICON_BASE + 27  , 0x003C, CTP_STRING_BASE +  62, CTP_STRING_BASE +  63),
    CEOTSymbol(CTP_ICON_BASE + 28  , 0x003D, CTP_STRING_BASE +  64, CTP_STRING_BASE +  65),
    CEOTSymbol(CTP_ICON_BASE + 29  , 0x003E, CTP_STRING_BASE +  66, CTP_STRING_BASE +  67),
    CEOTSymbol(CTP_ICON_BASE + 30  , 0x003F, CTP_STRING_BASE +  68, CTP_STRING_BASE +  69),
    CEOTSymbol(CTP_ICON_BASE + 31  , 0x0040, CTP_STRING_BASE +  70, CTP_STRING_BASE +  71),
    CEOTSymbol(CTP_ICON_BASE + 32  , 0x0041, CTP_STRING_BASE +  72, CTP_STRING_BASE +  73),
    CEOTSymbol(CTP_ICON_BASE + 33  , 0x0042, CTP_STRING_BASE +  74, CTP_STRING_BASE +  75),
    CEOTSymbol(CTP_ICON_BASE + 34  , 0x0043, CTP_STRING_BASE +  76, CTP_STRING_BASE +  77),
    CEOTSymbol(CTP_ICON_BASE + 35  , 0x0044, CTP_STRING_BASE +  78, CTP_STRING_BASE +  79),
    CEOTSymbol(CTP_ICON_BASE + 36  , 0x0045, CTP_STRING_BASE +  80, CTP_STRING_BASE +  81),
    CEOTSymbol(CTP_ICON_BASE + 37  , 0x0046, CTP_STRING_BASE +  82, CTP_STRING_BASE +  83),
    CEOTSymbol(CTP_ICON_BASE + 38  , 0x0047, CTP_STRING_BASE +  84, CTP_STRING_BASE +  85),
    CEOTSymbol(CTP_ICON_BASE + 39  , 0x0048, CTP_STRING_BASE +  86, CTP_STRING_BASE +  87),
    CEOTSymbol(CTP_ICON_BASE + 40  , 0x0049, CTP_STRING_BASE +  88),
    CEOTSymbol(CTP_ICON_BASE + 41  , 0x004A, CTP_STRING_BASE +  89, CTP_STRING_BASE +  90),
    CEOTSymbol(CTP_ICON_BASE + 42  , 0x004B, CTP_STRING_BASE +  91, CTP_STRING_BASE +  92),
    CEOTSymbol(CTP_ICON_BASE + 43  , 0x004C, CTP_STRING_BASE +  93, CTP_STRING_BASE +  94),
    CEOTSymbol(CTP_ICON_BASE + 44  , 0x004D, CTP_STRING_BASE +  95, CTP_STRING_BASE +  96),
    CEOTSymbol(CTP_ICON_BASE + 45  , 0x004E, CTP_STRING_BASE +  97, CTP_STRING_BASE +  98),
    CEOTSymbol(CTP_ICON_BASE + 46  , 0x004F, CTP_STRING_BASE +  99, CTP_STRING_BASE + 100),
	CEOTSymbol(CTP_ICON_BASE + 47  , 0x0050, CTP_STRING_BASE + 101, CTP_STRING_BASE + 102),
    CEOTSymbol(CTP_ICON_BASE + 48  , 0x0051, CTP_STRING_BASE + 103, CTP_STRING_BASE + 104),
    CEOTSymbol(CTP_ICON_BASE + 49  , 0x0052, CTP_STRING_BASE + 105, CTP_STRING_BASE + 106),
    CEOTSymbol(CTP_ICON_BASE + 50  , 0x0053, CTP_STRING_BASE + 107, CTP_STRING_BASE + 108),
    CEOTSymbol(CTP_ICON_BASE + 51  , 0x0054, CTP_STRING_BASE + 109, CTP_STRING_BASE + 110),
    CEOTSymbol(CTP_ICON_BASE + 52  , 0x0055, CTP_STRING_BASE + 111, CTP_STRING_BASE + 112),
    CEOTSymbol(CTP_ICON_BASE + 53  , 0x0056, CTP_STRING_BASE + 113),
    CEOTSymbol(CTP_ICON_BASE + 54  , 0x0057, CTP_STRING_BASE + 114, CTP_STRING_BASE + 115),
    CEOTSymbol(CTP_ICON_BASE + 55  , 0x0058, CTP_STRING_BASE + 116, CTP_STRING_BASE + 117),
    CEOTSymbol(CTP_ICON_BASE + 56  , 0x0059, CTP_STRING_BASE + 118, CTP_STRING_BASE + 119),
    CEOTSymbol(CTP_ICON_BASE + 57  , 0x005A, CTP_STRING_BASE + 120, CTP_STRING_BASE + 211),
    CEOTSymbol(CTP_ICON_BASE + 58  , 0x005B, CTP_STRING_BASE + 122, CTP_STRING_BASE + 123),
    CEOTSymbol(CTP_ICON_BASE + 59  , 0x005C, CTP_STRING_BASE + 124, CTP_STRING_BASE + 125),
    CEOTSymbol(CTP_ICON_BASE + 60  , 0x005D, CTP_STRING_BASE + 126, CTP_STRING_BASE + 127),
    CEOTSymbol(CTP_ICON_BASE + 61  , 0x0060, CTP_STRING_BASE + 132, CTP_STRING_BASE + 133),
	CEOTSymbol(CTP_ICON_BASE + 62  , 0x0061, CTP_STRING_BASE + 134, CTP_STRING_BASE + 135),
	CEOTSymbol(CTP_ICON_BASE + 63  , 0x0062, CTP_STRING_BASE + 136, CTP_STRING_BASE + 137),
	CEOTSymbol(CTP_ICON_BASE + 64  , 0x0063, CTP_STRING_BASE + 138, CTP_STRING_BASE + 139),
    CEOTSymbol(CTP_ICON_BASE + 65  , 0x0064, CTP_STRING_BASE + 140, CTP_STRING_BASE + 141),
    CEOTSymbol(CTP_ICON_BASE + 66  , 0x0067, CTP_STRING_BASE + 146, CTP_STRING_BASE + 147),
    CEOTSymbol(CTP_ICON_BASE + 67  , 0x0068, CTP_STRING_BASE + 148, CTP_STRING_BASE + 149),
    CEOTSymbol(CTP_ICON_BASE + 68  , 0x0069, CTP_STRING_BASE + 150, CTP_STRING_BASE + 151),
    CEOTSymbol(CTP_ICON_BASE + 69  , 0x006A, CTP_STRING_BASE + 152, CTP_STRING_BASE + 153),
    CEOTSymbol(CTP_ICON_BASE + 70  , 0x006B, CTP_STRING_BASE + 154, CTP_STRING_BASE + 155),
    CEOTSymbol(CTP_ICON_BASE + 71  , 0x006C, CTP_STRING_BASE + 156, CTP_STRING_BASE + 157),
    CEOTSymbol(CTP_ICON_BASE + 72  , 0x0072, CTP_STRING_BASE + 166, CTP_STRING_BASE + 167),
    CEOTSymbol(CTP_ICON_BASE + 73  , 0x0073, CTP_STRING_BASE + 168, CTP_STRING_BASE + 169),
    CEOTSymbol(CTP_ICON_BASE + 74  , 0x0074, CTP_STRING_BASE + 170, CTP_STRING_BASE + 171),
    CEOTSymbol(CTP_ICON_BASE + 75  , 0x0075, CTP_STRING_BASE + 172, CTP_STRING_BASE + 173),
    CEOTSymbol(CTP_ICON_BASE + 76  , 0x0076, CTP_STRING_BASE + 174, CTP_STRING_BASE + 175),
    CEOTSymbol(CTP_ICON_BASE + 77  , 0x0077, CTP_STRING_BASE + 176, CTP_STRING_BASE + 177),
    CEOTSymbol(CTP_ICON_BASE + 78  , 0x0078, CTP_STRING_BASE + 178, CTP_STRING_BASE + 179),
    CEOTSymbol(CTP_ICON_BASE + 79  , 0x0079, CTP_STRING_BASE + 180, CTP_STRING_BASE + 181),
    CEOTSymbol(CTP_ICON_BASE + 80  , 0x007A, CTP_STRING_BASE + 182, CTP_STRING_BASE + 183),
    CEOTSymbol(CTP_ICON_BASE + 81  , 0x007B, CTP_STRING_BASE + 184, CTP_STRING_BASE + 185),
    CEOTSymbol(CTP_ICON_BASE + 82  , 0x007C, CTP_STRING_BASE + 186),
    CEOTSymbol(CTP_ICON_BASE + 83  , 0x007E, CTP_STRING_BASE + 187, CTP_STRING_BASE + 188),
    CEOTSymbol(CTP_ICON_BASE + 84  , 0x007F, CTP_STRING_BASE + 189, CTP_STRING_BASE + 190),
    CEOTSymbol(CTP_ICON_BASE + 85  , 0x0080, CTP_STRING_BASE + 191),
    CEOTSymbol(CTP_ICON_BASE + 86  , 0x0081, CTP_STRING_BASE + 192),
    CEOTSymbol(CTP_ICON_BASE + 87  , 0x201A, CTP_STRING_BASE + 193),
    CEOTSymbol(CTP_ICON_BASE + 88  , 0x0192, CTP_STRING_BASE + 194),
    CEOTSymbol(CTP_ICON_BASE + 89  , 0x201E, CTP_STRING_BASE + 195),
    CEOTSymbol(CTP_ICON_BASE + 90  , 0x2026, CTP_STRING_BASE + 196),
    CEOTSymbol(CTP_ICON_BASE + 91  , 0x2020, CTP_STRING_BASE + 197),
    CEOTSymbol(CTP_ICON_BASE + 92  , 0x2021, CTP_STRING_BASE + 198),
    CEOTSymbol(CTP_ICON_BASE + 93  , 0x02C6, CTP_STRING_BASE + 199, CTP_STRING_BASE + 200),
    CEOTSymbol(CTP_ICON_BASE + 94  , 0x2030, CTP_STRING_BASE + 201, CTP_STRING_BASE + 202),
    CEOTSymbol(CTP_ICON_BASE + 95  , 0x0160, CTP_STRING_BASE + 203, CTP_STRING_BASE + 204),
    CEOTSymbol(CTP_ICON_BASE + 96  , 0x2039, CTP_STRING_BASE + 205, CTP_STRING_BASE + 206),
    CEOTSymbol(CTP_ICON_BASE + 97  , 0x0152, CTP_STRING_BASE + 207, CTP_STRING_BASE + 208),
    CEOTSymbol(CTP_ICON_BASE + 98  , 0x008D, CTP_STRING_BASE + 209, CTP_STRING_BASE + 210),
    CEOTSymbol(CTP_ICON_BASE + 99  , 0x008E, CTP_STRING_BASE + 211, CTP_STRING_BASE + 212),
    CEOTSymbol(CTP_ICON_BASE + 100 , 0x008F, CTP_STRING_BASE + 213, CTP_STRING_BASE + 214),
    CEOTSymbol(CTP_ICON_BASE + 101 , 0x0090, CTP_STRING_BASE + 215, CTP_STRING_BASE + 216),
    CEOTSymbol(CTP_ICON_BASE + 102 , 0x2018, CTP_STRING_BASE + 217, CTP_STRING_BASE + 218),
    CEOTSymbol(CTP_ICON_BASE + 103 , 0x2019, CTP_STRING_BASE + 219, CTP_STRING_BASE + 220),
    CEOTSymbol(CTP_ICON_BASE + 104 , 0x201C, CTP_STRING_BASE + 221, CTP_STRING_BASE + 222),
    CEOTSymbol(CTP_ICON_BASE + 105 , 0x201D, CTP_STRING_BASE + 223, CTP_STRING_BASE + 224),
    CEOTSymbol(CTP_ICON_BASE + 106 , 0x2022, CTP_STRING_BASE + 225, CTP_STRING_BASE + 226),
    CEOTSymbol(CTP_ICON_BASE + 107 , 0x2013, CTP_STRING_BASE + 227, CTP_STRING_BASE + 228),
    CEOTSymbol(CTP_ICON_BASE + 108 , 0x2014, CTP_STRING_BASE + 229, CTP_STRING_BASE + 230),
    CEOTSymbol(CTP_ICON_BASE + 109 , 0x02DC, CTP_STRING_BASE + 231, CTP_STRING_BASE + 232),
    CEOTSymbol(CTP_ICON_BASE + 110 , 0x2122, CTP_STRING_BASE + 233, CTP_STRING_BASE + 234),
    CEOTSymbol(CTP_ICON_BASE + 111 , 0x0161, CTP_STRING_BASE + 235),
    CEOTSymbol(CTP_ICON_BASE + 112 , 0x203A, CTP_STRING_BASE + 236, CTP_STRING_BASE + 237),
    CEOTSymbol(CTP_ICON_BASE + 113 , 0x0153, CTP_STRING_BASE + 238, CTP_STRING_BASE + 239),
    CEOTSymbol(CTP_ICON_BASE + 114 , 0x009D, CTP_STRING_BASE + 240),
    CEOTSymbol(CTP_ICON_BASE + 115 , 0x009E, CTP_STRING_BASE + 241, CTP_STRING_BASE + 242),
    CEOTSymbol(CTP_ICON_BASE + 116 , 0x0178, CTP_STRING_BASE + 243),
    CEOTSymbol(CTP_ICON_BASE + 117 , 0x00A0, CTP_STRING_BASE + 244, CTP_STRING_BASE + 245),
    CEOTSymbol(CTP_ICON_BASE + 118 , 0x00A2, CTP_STRING_BASE + 250, CTP_STRING_BASE + 251),
    CEOTSymbol(CTP_ICON_BASE + 119 , 0x00A3, CTP_STRING_BASE + 252, CTP_STRING_BASE + 253),
    CEOTSymbol(CTP_ICON_BASE + 120 , 0x00A4, CTP_STRING_BASE + 254, CTP_STRING_BASE + 255),
    CEOTSymbol(CTP_ICON_BASE + 121 , 0x00A5, CTP_STRING_BASE + 256, CTP_STRING_BASE + 257),
    CEOTSymbol(CTP_ICON_BASE + 122 , 0x00A6, CTP_STRING_BASE + 258, CTP_STRING_BASE + 259),
    CEOTSymbol(CTP_ICON_BASE + 123 , 0x00A7, CTP_STRING_BASE + 260, CTP_STRING_BASE + 261),
    CEOTSymbol(CTP_ICON_BASE + 124 , 0x00A8, CTP_STRING_BASE + 262, CTP_STRING_BASE + 263),
    CEOTSymbol(CTP_ICON_BASE + 125 , 0x00A9, CTP_STRING_BASE + 264, CTP_STRING_BASE + 265),
    CEOTSymbol(CTP_ICON_BASE + 0   , 0x00AA, CTP_STRING_BASE + 266, CTP_STRING_BASE + 267),
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\ststring.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      ststring.h
 *
 *  Contents:  Interface file for CStringTableString
 *
 *  History:   28-Oct-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef STSTRING_H
#define STSTRING_H
#pragma once

#include "tstring.h"


/*+-------------------------------------------------------------------------*
 * CStringTableString
 *
 *
 *--------------------------------------------------------------------------*/

class CStringTableString : public CStringTableStringBase
{
    typedef CStringTableStringBase BaseClass;

public:
    CStringTableString () 
        : BaseClass (GetStringTable()) {}

    CStringTableString (const CStringTableString& other)
        : BaseClass (other) {}

    CStringTableString (const tstring& str)
        : BaseClass (GetStringTable(), str) {}
    
    CStringTableString& operator= (const CStringTableString& other)
        { BaseClass::operator= (other); return (*this); }
    
    CStringTableString& operator= (const tstring& str)
        { BaseClass::operator= (str); return (*this); }
    
    CStringTableString& operator= (LPCTSTR psz)
        { BaseClass::operator= (psz); return (*this); }
    
private:
    IStringTablePrivate* GetStringTable() const;

};

#endif /* STSTRING_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\task.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      task.cpp
 *
 *  Contents:  Implementation file for CConsoleTask
 *
 *  History:   05-Oct-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "regutil.h"
#include "tasks.h"
#include "nodepath.h"
#include "conview.h"

#ifdef DBG
// Traces
CTraceTag tagCTPHTML(TEXT("Console Taskpads"), TEXT("Dump HTML"));
#endif

extern CEOTSymbol s_rgEOTSymbol[];

/*+-------------------------------------------------------------------------*
 *  class CGlobalConsoleTaskList
 *
 * PURPOSE: A global console task list that provides unique IDs for all console tasks
 *          When a task is instantiated, its constructor registers in the global task list,
 *          and obtains a globally unique ID. This ID is unique for the process and should
 *          not be persisted.
 *          The destructor of the task removes it from this list.
 *
 * USAGE:   Call CGlobalConsoleTaskList::GetConsoleTask to obtain a pointer to the  task
 *          that has a specified ID.
 *          Call CConsoleTask::GetUniqueID to get the unique ID for a task.
 *
 *          Thus, CGlobalConsoleTaskList::GetConsoleTask(pConsoleTask->GetUniqueID()) == pConsoleTask
 *          is always true.
 *+-------------------------------------------------------------------------*/
class CGlobalConsoleTaskList
{
private:
    typedef const CConsoleTask *              PCONSOLETASK;
    typedef std::map<PCONSOLETASK, DWORD>     t_taskIDmap;

public:
    static DWORD Advise(  PCONSOLETASK pConsoleTask)
    {
        DWORD dwOut = s_curTaskID++;
        s_map[pConsoleTask] = dwOut;
        return dwOut;
    }

    static void Unadvise(PCONSOLETASK pConsoleTask)
    {
        s_map.erase(pConsoleTask);
    }

    static CConsoleTask * GetConsoleTask(DWORD dwID)
    {
        t_taskIDmap::iterator iter;
        for(iter = s_map.begin(); iter != s_map.end(); iter ++)
        {
            if(iter->second == dwID)
                return const_cast<CConsoleTask *>(iter->first);
        }

        return NULL;
    }

private:
    CGlobalConsoleTaskList() {}// private, so that it cannot be instantiated

    static t_taskIDmap            s_map;
    static DWORD                  s_curTaskID;
};

CGlobalConsoleTaskList::t_taskIDmap            CGlobalConsoleTaskList::s_map;
DWORD                  CGlobalConsoleTaskList::s_curTaskID = 0;

//############################################################################
//############################################################################
//
//  Implementation of class CConsoleTask
//
//############################################################################
//############################################################################


/*+-------------------------------------------------------------------------*
 * CConsoleTask::CConsoleTask
 *
 *
 *--------------------------------------------------------------------------*/
DEBUG_DECLARE_INSTANCE_COUNTER(CConsoleTask);

CConsoleTask::CConsoleTask() :
    m_eConsoleTaskType (eTask_Result),
//  default ctor for m_strName
//  default ctor for m_strDescription
//  default ctor for m_strCommand
//  default ctor for m_strParameters
//  default ctor for m_strDirectory
    m_eWindowState     (eState_Restored),
//  default ctor for m_image
    m_dwFlags          (0),
    m_bmScopeNode      (false),
    m_fDirty           (false),
    m_pctpOwner        (NULL),
    m_dwUniqueID       (CGlobalConsoleTaskList::Advise(this)) // create a unique ID for this task
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CConsoleTask);
}

/*+-------------------------------------------------------------------------*
 * CConsoleTask::CConsoleTask(const CConsoleTask& other)
 *
 * PURPOSE: Copy ctor.
 *
 * PARAMETERS: const CConsoleTask& other
 *
 * NOTE: Calls operator=, cant use default copy ctor (see operator= imp.)
 *
/*+-------------------------------------------------------------------------*/
CConsoleTask::CConsoleTask (const CConsoleTask &rhs):
    m_dwUniqueID       (CGlobalConsoleTaskList::Advise(this))
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CConsoleTask);
    *this = rhs;
}

/*+-------------------------------------------------------------------------*
 *
 * CConsoleTask::GetConsoleTask
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    DWORD  dwUniqueID :
 *
 * RETURNS:
 *    CConsoleTask *
 *
 *+-------------------------------------------------------------------------*/
CConsoleTask *
CConsoleTask::GetConsoleTask(DWORD dwUniqueID)
{
    return CGlobalConsoleTaskList::GetConsoleTask(dwUniqueID);
}


/*+-------------------------------------------------------------------------*
 *
 * ScReplaceString
 *
 * PURPOSE: Replaces all occurrences of the token by its replacement.
 *
 * PARAMETERS:
 *    CStr &   str :
 *    LPCTSTR  szToken :
 *    LPCTSTR  szReplacement :
 *
 * RETURNS:
 *    static SC
 *
 *+-------------------------------------------------------------------------*/
static SC
ScReplaceString(CStr &str, LPCTSTR szToken, LPCTSTR szReplacement, bool bMustReplace = true)
{
    DECLARE_SC(sc, TEXT("ScReplaceString"));

    CStr strTemp = str;
    str = TEXT("");

    int i = strTemp.Find(szToken);
    if( (-1==i) && bMustReplace)
        return (sc = E_UNEXPECTED);

    while(-1!=i)
    {
        str += strTemp.Left(i);
        str += szReplacement;

        strTemp = strTemp.Mid(i+_tcslen(szToken)); // the remaining string

        i=strTemp.Find(szToken);
    }

    str += strTemp;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * ScUseJavaScriptStringEntities
 *
 * PURPOSE: Use this to create a valid Javascript string. Replaces " by \" and
 *          \ by \\ in the string parameter.
 *
 * PARAMETERS:
 *    CStr & str :
 *
 * RETURNS:
 *    static SC
 *
 *+-------------------------------------------------------------------------*/
static SC
ScUseJavaScriptStringEntities(CStr &str)
{
    DECLARE_SC(sc, TEXT("ScUseJavaScriptStringEntities"));

    // NOTE: don't change the order of these string replacements

    sc = ScReplaceString(str, TEXT("\\"), TEXT("\\\\"), false);
    if(sc)
        return sc;

    sc = ScReplaceString(str, TEXT("\""), TEXT("\\\""), false);
    if(sc)
        return sc;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * ScUseHTMLEntities
 *
 * PURPOSE:  Replaces " by &quot; < by &lt; and > by &gt; and & by &amp; in the string parameter.
 *
 * PARAMETERS:
 *    CStr & str :
 *
 * RETURNS:
 *    static SC
 *
 *+-------------------------------------------------------------------------*/
static SC
ScUseHTMLEntities(CStr &str)
{
    DECLARE_SC(sc, TEXT("ScUseHTMLEntities"));

    sc = ScReplaceString(str, TEXT("&"), TEXT("&amp;"), false);
    if(sc)
        return sc;

    sc = ScReplaceString(str, TEXT("\""), TEXT("&quot;"), false);
    if(sc)
        return sc;

    sc = ScReplaceString(str, TEXT("<"), TEXT("&lt;"), false);
    if(sc)
        return sc;

    sc = ScReplaceString(str, TEXT(">"), TEXT("&gt;"), false);
    if(sc)
        return sc;

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CConsoleTask::ScGetHTML
 *
 * PURPOSE: returns the HTML representation of the task.
 *
 * PARAMETERS:
 *    LPCTSTR  szFmtHTML :
 *    CStr &   strTaskHTML :
 *    bool     bUseLargeIcons :    Draw in the no-list (large icon) style
 *    bool     bUseTextDescriptions :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CConsoleTask::ScGetHTML(LPCTSTR szFmtHTML, CStr &strTaskHTML, bool bUseLargeIcons, bool bUseTextDescriptions) const
{
    DECLARE_SC(sc, TEXT("CConsoleTask::ScGetHTML"));
    USES_CONVERSION;

    // the substitution parameters, in order
    CStr    strTableSpacing            = bUseLargeIcons ? TEXT("<BR />") : TEXT("");
    int     iconWidth                  = bUseLargeIcons ? 32: 20;
    int     iconHeight                 = bUseLargeIcons ? 32: 16;
    //      iconWidth and iconHeight repeated
    int     uniqueID                   = GetUniqueID();
    CStr    strSmall                   = bUseLargeIcons ? TEXT("0") : TEXT("1");
    CStr    strHref;
    CStr    strID;
    CStr    strParameter;
    CStr    strOptionalTitleTag;
    CStr    strOptionalTextDescription;
    CStr    strTaskName                = GetName().data();
    CStr    strDescription             = GetDescription().data();
    CStr    strCommand                 = GetCommand().data();

    // use entities for all strings
    sc = ScUseHTMLEntities(strTaskName);
    if(sc)
        return sc;

    sc = ScUseHTMLEntities(strDescription);
    if(sc)
        return sc;

    sc = ScUseJavaScriptStringEntities(strCommand);
    if(sc)
        return sc;

    //------
    if(bUseTextDescriptions)
    {
        strOptionalTextDescription =  TEXT("<BR />");
        strOptionalTextDescription += strDescription;
    }
    else
    {
        strOptionalTitleTag.Format(TEXT("title='%s'"), (LPCTSTR) strDescription);
    }

    switch(GetTaskType())
    {
    case eTask_Scope:
        {
            std::wstring strTemp;

            // get the bookmark of the scope node.
            sc = m_bmScopeNode.ScSaveToString(&strTemp);
            if(sc)
                return sc;

            CStr strScopeNodeBookmark = W2CT(strTemp.data()); // make sure that special characters have been converted
            sc = ScUseJavaScriptStringEntities(strScopeNodeBookmark);
            if(sc)
                return sc;

            strHref.Format(TEXT("external.ExecuteScopeNodeMenuItem(\"%s\", \"%s\");"), (LPCTSTR)strCommand, (LPCTSTR)strScopeNodeBookmark);
        }

        strID=L"ScopeTask";
        break;

    case eTask_Result:
        strHref.Format(TEXT("external.ExecuteSelectionMenuItem(\"%s\");"), (LPCTSTR)strCommand);
        strParameter = strCommand;
        strID        = TEXT("ResultTask");
        break;

    case eTask_CommandLine:
        {
            strParameter = GetParameters().data();
            sc = ScUseJavaScriptStringEntities(strParameter);
            if(sc)
                return sc;

            CStr strDirectory = GetDirectory().data();
            sc = ScUseJavaScriptStringEntities(strDirectory);
            if(sc)
                return sc;

            // get the window state
            CStr strWindowState;

            if(GetWindowState() ==eState_Restored)
                strWindowState = XML_ENUM_WINDOW_STATE_RESTORED;

            else if(GetWindowState() == eState_Minimized)
                strWindowState = XML_ENUM_WINDOW_STATE_MINIMIZED;

            else
                strWindowState = XML_ENUM_WINDOW_STATE_MAXIMIZED;

            strHref.Format(TEXT("external.ExecuteShellCommand(\"%s\", \"%s\", ParseParameters(\"%s\"), \"%s\");"),
                           (LPCTSTR)strCommand, (LPCTSTR)strDirectory, (LPCTSTR)strParameter, (LPCTSTR)strWindowState);
        }
        strID=L"CommandLineTask";

        break;

    case eTask_Target:
        strHref.Format(TEXT("external.ExecuteScopeNodeMenuItem(\"%s\");"), (LPCTSTR)strCommand);
        strParameter = strCommand;
        strID        = L"TargetTask";
        break;

    case eTask_Favorite:
        {
            std::wstring strTemp;
            // save the memento to a string
            sc = const_cast<CMemento *>(&m_memento)->ScSaveToString(&strTemp);
            if(sc)
                return sc;

            CStr strMemento = W2CT(strTemp.data());

            sc = ScUseJavaScriptStringEntities(strMemento);
            if(sc)
                return sc;

            strHref.Format(TEXT("external.ViewMemento(\"%s\");"), (LPCTSTR)strMemento);
        }
        strID=L"FavoriteTask";
        break;

    default:
        break;
    }


    strTaskHTML.Format(szFmtHTML, (LPCTSTR) strTableSpacing, iconWidth, iconHeight, uniqueID, iconWidth, iconHeight,
                       uniqueID, (LPCTSTR) strSmall, uniqueID, uniqueID, (LPCTSTR) strID, (LPCTSTR) strParameter,
                       (LPCTSTR) strOptionalTitleTag, (LPCTSTR)strTaskName, (LPCTSTR) strOptionalTextDescription,
                       uniqueID, uniqueID, uniqueID, (LPCTSTR) strHref);

    Trace(tagCTPHTML, TEXT("%s"), (LPCTSTR)strTaskHTML);

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CConsoleTask::IsDirty
 *
 * PURPOSE: Determines whether the task needs to be saved.
 *
 * RETURNS:
 *    bool
 *
 *+-------------------------------------------------------------------------*/
bool
CConsoleTask::IsDirty() const
{
    TraceDirtyFlag(TEXT("CConsoleTask"), m_fDirty);
    return (m_fDirty);
}

/*+-------------------------------------------------------------------------*
 * CConsoleTask::operator =
 *
 * PURPOSE: Assignment operator
 *
 * PARAMETERS: const CConsoleTask& rhs
 *
 * RETURNS:
 *      CConsoleTask &
 *
/*+-------------------------------------------------------------------------*/
CConsoleTask &
CConsoleTask::operator =(const CConsoleTask& rhs)
{
    if (this != &rhs)
    {
        m_eConsoleTaskType  = rhs.m_eConsoleTaskType;
        m_strName           = rhs.m_strName;
        m_strDescription    = rhs.m_strDescription;
        m_strCommand        = rhs.m_strCommand;
        m_strParameters     = rhs.m_strParameters;
        m_strDirectory      = rhs.m_strDirectory;
        m_eWindowState      = rhs.m_eWindowState;
        m_dwFlags           = rhs.m_dwFlags;
        m_bmScopeNode       = rhs.m_bmScopeNode;
        m_dwSymbol          = rhs.m_dwSymbol;
        m_smartIconCustomLarge  = rhs.m_smartIconCustomLarge;
        m_smartIconCustomSmall  = rhs.m_smartIconCustomSmall;
        m_memento           = rhs.m_memento;

        m_fDirty            = rhs.m_fDirty;
        m_pctpOwner         = rhs.m_pctpOwner;
        // m_dwUniqueID       = rhs.m_dwUniqueID; DO NOT copy this ID
    }

    return *this;
}

/*+-------------------------------------------------------------------------*
 *
 * CConsoleTask::operator ==
 *
 * PURPOSE: Equality operator. Checks that the command string is
 *          equal to the given menuitem's Path or Language Independent Path.
 *
 *+-------------------------------------------------------------------------*/
bool
CConsoleTask::operator==(const CMenuItem & menuItem) const
{
    // check that the command string matches either the path or the language independent path.

    if( (m_strCommand == menuItem.GetPath()) ||
        (m_strCommand == menuItem.GetLanguageIndependentPath() )
      )
        return true;

    return false;
}

/*+-------------------------------------------------------------------------*
 * CConsoleTask::~CConsoleTask
 *
 *
 *--------------------------------------------------------------------------*/

CConsoleTask::~CConsoleTask ()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CConsoleTask);

    CGlobalConsoleTaskList::Unadvise(this); // remove this task from the list.
}


/*+-------------------------------------------------------------------------*
 *
 * CConsoleTask::HasCustomIcon
 *
 * PURPOSE: Returns whether the task has a custom icon
 *
 * RETURNS:
 *    bool
 *
 *+-------------------------------------------------------------------------*/
bool
CConsoleTask::HasCustomIcon()   const
{
    if((HICON)m_smartIconCustomLarge != NULL)
    {
        ASSERT((HICON)m_smartIconCustomSmall != NULL);
        return true;
    }

    return false;
}


/*+-------------------------------------------------------------------------*
 *
 * CConsoleTask::Reset
 *
 * PURPOSE:
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CConsoleTask::ResetUI()
{
    m_bmScopeNode.ResetUI();
}

/*+-------------------------------------------------------------------------*
 *
 * CConsoleTask::SetSymbol
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    DWORD  dwSymbol :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CConsoleTask::SetSymbol(DWORD dwSymbol)
{
    m_dwSymbol = dwSymbol;
    m_smartIconCustomSmall.Release();
    m_smartIconCustomLarge.Release();
    SetDirty();
}

/*+-------------------------------------------------------------------------*
 *
 * CConsoleTask::SetCustomIcon
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    CSmartIcon& iconSmall :
 *    CSmartIcon& iconLarge :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CConsoleTask::SetCustomIcon(CSmartIcon& iconSmall, CSmartIcon& iconLarge)
{
    m_smartIconCustomSmall = iconSmall;
    m_smartIconCustomLarge = iconLarge;
    SetDirty();
}


/*+-------------------------------------------------------------------------*
 * CConsoleTask::Enable
 *
 * Sets the enable state for a task.
 *--------------------------------------------------------------------------*/

void CConsoleTask::Enable (bool fEnable)
{
    if (fEnable)
        m_dwFlags &= ~eFlag_Disabled;
    else
        m_dwFlags |= eFlag_Disabled;

    SetDirty ();
}

void
CConsoleTask::Draw (HDC hdc, RECT *lpRect, bool bSmall) const  // Draw into a DC.
{
    if(HasCustomIcon())
    {
        DrawIconEx(hdc, lpRect->left, lpRect->top, bSmall ? m_smartIconCustomSmall : m_smartIconCustomLarge,
               bSmall? 16 : 32, bSmall? 16 : 32, 0, NULL, DI_NORMAL);
        return;
    }

    for(int i = 0; i< NUM_SYMBOLS; i++)
    {
        if(s_rgEOTSymbol[i].GetValue() == m_dwSymbol)
        {
            s_rgEOTSymbol[i].Draw(hdc, lpRect, bSmall);
            return;
        }
    }

	/*
	 * if we get here, we couldn't find the EOT symbol matching m_dwSymbol
	 */
	ASSERT (false);
}


/*+-------------------------------------------------------------------------*
 * CConsoleTask::SetName
 *
 *
 *--------------------------------------------------------------------------*/

void CConsoleTask::SetName (const tstring& strName)
{
    if (m_strName != strName)
    {
        m_strName = strName;
        SetDirty ();
    }
}


/*+-------------------------------------------------------------------------*
 * CConsoleTask::SetDescription
 *
 *
 *--------------------------------------------------------------------------*/

void CConsoleTask::SetDescription (const tstring& strDescription)
{
    if (m_strDescription != strDescription)
    {
        m_strDescription = strDescription;
        SetDirty ();
    }
}

/*+-------------------------------------------------------------------------*
 * CConsoleTask::SetCommand
 *
 *
 *--------------------------------------------------------------------------*/

void CConsoleTask::SetCommand (const tstring& strCommand)
{
    if (m_strCommand != strCommand)
    {
        m_strCommand = strCommand;
        SetDirty ();
    }
}

/*+-------------------------------------------------------------------------*
 * CConsoleTask::SetParameters
 *
 *
 *--------------------------------------------------------------------------*/

void CConsoleTask::SetParameters (const tstring& strParameters)
{
    if (m_strParameters != strParameters)
    {
        m_strParameters = strParameters;
        SetDirty ();
    }
}

/*+-------------------------------------------------------------------------*
 * CConsoleTask::SetDirectory
 *
 *
 *--------------------------------------------------------------------------*/

void CConsoleTask::SetDirectory (const tstring& strDirectory)
{
    if (m_strDirectory != strDirectory)
    {
        m_strDirectory = strDirectory;
        SetDirty ();
    }
}


void CConsoleTask::SetMemento(const CMemento &memento)
{
    if( m_memento != memento)
    {
        m_memento = memento;
        SetDirty();
    }
}

/*+-------------------------------------------------------------------------*
 * CConsoleTask::SetWindowState
 *
 *
 *--------------------------------------------------------------------------*/

void CConsoleTask::SetWindowState (eWindowState eNewState)
{
    if (m_eWindowState != eNewState)
    {
        m_eWindowState = eNewState;
        SetDirty ();
    }
}

/*+-------------------------------------------------------------------------*
 * CConsoleTask::RetargetScopeNode
 *
 * PURPOSE: Sets the target scope node for the task. Note: the task must be
 *           of type eTask_Scope.
 *
 * PARAMETERS:
 *      CNode *  pNewNode:
 *
 * RETURNS:
 *      bool
 */
/*+-------------------------------------------------------------------------*/
bool
CConsoleTask::RetargetScopeNode(CNode *pNewNode)
{
    bool fRet = TRUE;

    ASSERT(GetTaskType() == eTask_Scope);

    CMTNode* pMTNewNode = (pNewNode) ? pNewNode->GetMTNode() : NULL;

    m_bmScopeNode.ScRetarget(pMTNewNode, false /*bFastRetrievalOnly*/);

    SetDirty();
    return fRet;
}

/*+-------------------------------------------------------------------------*
 * CConsoleTask::GetScopeNode
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *      IScopeTree *  pScopeTree:
 *
 * RETURNS:
 *      CMTNode *
 *
/*+-------------------------------------------------------------------------*/
CMTNode *
CConsoleTask::GetScopeNode(IScopeTree *pScopeTree) const
{
    DECLARE_SC(sc, TEXT("CConsoleTask::GetScopeNode"));

    CMTNode *pMTNode = NULL;
    bool bExactMatchFound = false; // out value from ScGetMTNode, unused
    sc = m_bmScopeNode.ScGetMTNode(true /*bExactMatchRequired*/, &pMTNode, bExactMatchFound);
    if(sc.IsError())
        return NULL;

    return (pMTNode);
}



/*+-------------------------------------------------------------------------*
 * CConsoleTask::GetScopeNode
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *      CViewData *  pViewData:
 *
 * RETURNS:
 *      CNode *
/*+-------------------------------------------------------------------------*/
std::auto_ptr<CNode>
CConsoleTask::GetScopeNode(CViewData *pViewData) const
{
    return m_bmScopeNode.GetNode(pViewData);
}


/*+-------------------------------------------------------------------------*
 *
 * CConsoleTask::Persist
 *
 * PURPOSE: Persists the console task to the specified persistor.
 *
 *
 * PARAMETERS:
 *    CPersistor & persistor :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CConsoleTask::Persist(CPersistor &persistor)
{

    persistor.PersistString(XML_ATTR_TASK_NAME,         m_strName);

    // define the table to map enumeration values to strings
    static const EnumLiteral mappedTaskTypes[] =
    {
        { eTask_Scope,            XML_ENUM_TASK_TYPE_SCOPE },
        { eTask_Result,           XML_ENUM_TASK_TYPE_RESULT },
        { eTask_CommandLine,      XML_ENUM_TASK_TYPE_COMMANDLINE },
        { eTask_Target,           XML_ENUM_TASK_TYPE_TARGET },
        { eTask_Favorite,         XML_ENUM_TASK_TYPE_FAVORITE },
    };


    // create wrapper to persist flag values as strings
    CXMLEnumeration taskTypePersistor(m_eConsoleTaskType, mappedTaskTypes, countof(mappedTaskTypes));
    // persist the wrapper
    persistor.PersistAttribute(XML_ATTR_TASK_TYPE,      taskTypePersistor);

    persistor.PersistString(XML_ATTR_TASK_DESCRIPTION,  m_strDescription);

    {
        /* this section creates
            <ConsoleTask>
                <SYMBOL id = "">
                    <IMAGE name = "LargeIcon" ... />   NOTE: either the id or the images are present.
                    <IMAGE name = "SmallIcon" ... />
                </SYMBOL>
            </ConsoleTask>
         */

        // create a child element for the symbol
        CPersistor persistorSymbol(persistor, XML_TAG_EOT_SYMBOL_INFO);

        if(persistorSymbol.IsLoading())
        {
            m_dwSymbol = (DWORD)-1; // initialize
        }

        if(persistorSymbol.IsLoading() ||
           (persistorSymbol.IsStoring() && !HasCustomIcon() ) )
        {
            // save the "ID" attribute only if there is no icon
            persistorSymbol.PersistAttribute(XML_ATTR_EOT_SYMBOL_DW_SYMBOL,   m_dwSymbol, attr_optional);
        }

        if((persistorSymbol.IsStoring() && HasCustomIcon()) ||
           (persistorSymbol.IsLoading() && (m_dwSymbol == (DWORD) -1)  )
           )
        {
			persistorSymbol.Persist (m_smartIconCustomSmall, XML_NAME_ICON_SMALL);
			persistorSymbol.Persist (m_smartIconCustomLarge, XML_NAME_ICON_LARGE);
        }
    }

    persistor.PersistAttribute(XML_ATTR_TASK_COMMAND,   m_strCommand);

    // define the table to map enumeration values to strings
    static const EnumLiteral mappedTaskFlags[] =
    {
        { eFlag_Disabled, XML_BITFLAG_TASK_DISABLED },
    };

    // create wrapper to persist flag values as strings
    CXMLBitFlags taskFlagPersistor(m_dwFlags, mappedTaskFlags, countof(mappedTaskFlags));
    // persist the wrapper
    persistor.PersistAttribute(XML_ATTR_TASK_FLAGS, taskFlagPersistor);

    switch (m_eConsoleTaskType)
    {
        case eTask_Scope:
            persistor.Persist(m_bmScopeNode);
            break;

        case eTask_CommandLine:
        {
            CPersistor persistorCmd(persistor, XML_TAG_TASK_CMD_LINE);
            persistorCmd.PersistAttribute(XML_ATTR_TASK_CMD_LINE_DIR, m_strDirectory);

            // define the table to map enumeration values to strings
            static const EnumLiteral windowStates[] =
            {
                { eState_Restored,      XML_ENUM_WINDOW_STATE_RESTORED },
                { eState_Minimized,     XML_ENUM_WINDOW_STATE_MINIMIZED },
                { eState_Maximized,     XML_ENUM_WINDOW_STATE_MAXIMIZED },
            };

            // create wrapper to persist flag values as strings
            CXMLEnumeration windowStatePersistor(m_eWindowState, windowStates, countof(windowStates));
            // persist the wrapper
            persistorCmd.PersistAttribute(XML_ATTR_TASK_CMD_LINE_WIN_ST, windowStatePersistor);

            persistorCmd.PersistAttribute(XML_ATTR_TASK_CMD_LINE_PARAMS, m_strParameters);
            break;
        }

        case eTask_Favorite:
            persistor.Persist(m_memento);
            break;
    }

    // either read or saved - not dirty after the operation
    SetDirty(false);
}


/*+-------------------------------------------------------------------------*
 * CConsoleTask::ReadSerialObject
 *
 *
 *--------------------------------------------------------------------------*/
HRESULT
CConsoleTask::ReadSerialObject (IStream &stm, UINT nVersion /*,LARGE_INTEGER nBytes*/)
{
    HRESULT hr = S_FALSE;   // assume unknown version

    if (nVersion == 1)
    {
        try
        {
            // ugly hackery required to extract directly into an enum
            stm >> *((int *) &m_eConsoleTaskType);
            stm >> m_strName;
            stm >> m_strDescription;

            // legacy task symbol info
            {
                // this must be BOOL not bool to occupy the same amount of space as in legacy consoles
                // See Bug #101253
                BOOL bLegacyUseMMCSymbols = TRUE; // a now obsolete field, read for console file compatibility
                tstring strFileLegacy, strFontLegacy;

                stm >> m_dwSymbol;
                stm >> bLegacyUseMMCSymbols;
                stm >> strFileLegacy; // obsolete
                stm >> strFontLegacy; // obsolete
            }

            stm >> m_strCommand;
            stm >> m_dwFlags;

            switch (m_eConsoleTaskType)
            {
                case eTask_Scope:
                    stm >> m_bmScopeNode;
                    break;

                case eTask_CommandLine:
                    stm >> m_strDirectory;
                    // ugly hackery required to extract directly into an enum
                    stm >> *((int *) &m_eWindowState);
                    stm >> m_strParameters;
                    break;

                case eTask_Favorite:
                    hr = m_memento.Read(stm);
                    if(FAILED(hr))
                        return hr;
                    break;
            }

            hr = S_OK;
        }
        catch (_com_error& err)
        {
            hr = err.Error();
            ASSERT (false && "Caught _com_error");
        }
    }

    return (hr);
}



/*+-------------------------------------------------------------------------*
 * CConsoleTaskpad::CConsoleTaskpad
 *
 *
 *--------------------------------------------------------------------------*/

CConsoleTaskpad::CConsoleTaskpad (CNode* pTargetNode /*=NULL*/) :
    m_listSize(eSize_Default),   // the default space given to a taskpad.
    m_guidNodeType(GUID_NULL),
    m_guidID(GUID_NULL),
    m_bmTargetNode(),
    m_pMTNodeTarget(NULL),
    m_bNodeSpecific(false),
    m_dwOrientation(TVO_VERTICAL), // the default is a vertical taskpad for consistency with the Extended view.
    m_bReplacesDefaultView(true) // taskpads do not show the normal tab by default.
{
    Retarget (pTargetNode);

    HRESULT hr = CoCreateGuid(&m_guidID);
    ASSERT(SUCCEEDED(hr));

    SetDirty (false);
}

bool
CConsoleTaskpad::IsValid(CNode *pNode) const
{
    ASSERT(pNode != NULL);

    if(!HasTarget())
        return true; // a taskpad without a target is valid for any node. $REVIEW

    if(!pNode)
        return false; // Cannot use a taskpad with a target.

    if(IsNodeSpecific())
    {
        // use this taskpad if it is targetted at the same node. $OPTIMIZE.
        return (*pNode->GetMTNode()->GetBookmark() == m_bmTargetNode);
    }
    else
    {
        GUID guid;
        HRESULT hr = pNode->GetNodeType(&guid);
        if(FAILED(hr))
            return false; // don't use this taskpad.

        return (MatchesNodeType(guid)); // use only if node types match.
    }


}

static CStr g_szTaskpadCommonHTMLTemplate;
static CStr g_szVerticalTaskpadHTMLTemplate;
static CStr g_szHorizontalTaskpadHTMLTemplate;
static CStr g_szNoResultsTaskpadHTMLTemplate;
static CStr g_szTaskHTMLTemplate;
/*+-------------------------------------------------------------------------*
 *
 * ScLoadHTMLTemplate
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    HINSTANCE  hinstLibrary :
 *    LPCTSTR    szHTMLTemplateResourceName :
 *    CStr&      str :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
ScLoadHTMLTemplate(HINSTANCE hinstLibrary, LPCTSTR szHTMLTemplateResourceName, CStr& str)
{
    DECLARE_SC(sc, TEXT("ScLoadHTMLTemplate"));

    sc = ScCheckPointers(hinstLibrary, szHTMLTemplateResourceName);
    if(sc)
        return sc;

    HRSRC hFindRes = ::FindResource(hinstLibrary, szHTMLTemplateResourceName, RT_HTML);
    if(!hFindRes)
        return (sc = E_UNEXPECTED);

    DWORD dwResSize = ::SizeofResource(hinstLibrary, hFindRes);
    if(!dwResSize)
        return (sc = E_UNEXPECTED);

    HGLOBAL hRes = ::LoadResource(hinstLibrary, hFindRes);
    ASSERT(hRes);

    char *pvRes = (char *)::LockResource(hRes);  // no need to Unlock the resource - see the SDK entry for LockResource
    sc = ScCheckPointers(pvRes);
    if(sc)
        return sc;

    std::string strTemp; // initially create an ANSI string
    strTemp.assign(pvRes, dwResSize);
    strTemp+="\0"; // null terminate it

    USES_CONVERSION;
    str = A2CT(strTemp.data());

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * ScLoadHTMLTemplates
 *
 * PURPOSE:
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
ScLoadHTMLTemplates()
{
    DECLARE_SC(sc, TEXT("ScLoadHTMLTemplates"));

    static BOOL bInitialized = false;
    if(bInitialized)
        return sc;

    // load the library into memory.
    TCHAR szBuffer[MAX_PATH];
    ::GetModuleFileName (_Module.GetModuleInstance(), szBuffer, countof (szBuffer));

    HINSTANCE hinstLibrary = ::LoadLibraryEx(szBuffer, 0, LOAD_LIBRARY_AS_DATAFILE);
    if(!hinstLibrary)
        return (sc = E_UNEXPECTED);

    sc = ScLoadHTMLTemplate(hinstLibrary, TEXT("CTPCOMMON.HTM"), g_szTaskpadCommonHTMLTemplate);
    if(sc)
        goto Error;

    sc = ScLoadHTMLTemplate(hinstLibrary, TEXT("CTPVERT.HTM"), g_szVerticalTaskpadHTMLTemplate);
    if(sc)
        goto Error;

    sc = ScLoadHTMLTemplate(hinstLibrary, TEXT("CTPHORIZ.HTM"), g_szHorizontalTaskpadHTMLTemplate);
    if(sc)
        goto Error;

    sc = ScLoadHTMLTemplate(hinstLibrary, TEXT("CTPNORESULTS.HTM"), g_szNoResultsTaskpadHTMLTemplate);
    if(sc)
        goto Error;

    sc = ScLoadHTMLTemplate(hinstLibrary, TEXT("CTPTASK.HTM"), g_szTaskHTMLTemplate);
    if(sc)
        goto Error;

    bInitialized = true;

Cleanup:
    FreeLibrary(hinstLibrary);
    return sc;
Error:
    sc = E_UNEXPECTED;
    goto Cleanup;

}

/*+-------------------------------------------------------------------------*
 *
 * CConsoleTaskpad::ScGetHTML
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    CStr & strTaskpadHTML :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CConsoleTaskpad::ScGetHTML(CStr &strTaskpadHTML) const
{
    DECLARE_SC(sc, TEXT("CConsoleTaskpad::ScGetHTML"));

    sc = ScLoadHTMLTemplates();
    if(sc)
        return sc;


    CStr strTasksHTML;

    // get the HTML for all the tasks
    for (TaskConstIter it = m_Tasks.begin(); it != m_Tasks.end(); ++it)
    {
        CStr strTemp;
        sc = it->ScGetHTML(g_szTaskHTMLTemplate, strTemp, GetOrientation() & TVO_NO_RESULTS /*bUseLargeIcons*/, GetOrientation() & TVO_DESCRIPTIONS_AS_TEXT);
        if(sc)
            return sc;

        strTasksHTML += strTemp;
    }

    strTaskpadHTML = g_szTaskpadCommonHTMLTemplate;

    // append the orientation-specific portion
    CStr *pstrOrientationSpecificHTML = NULL;

    if(GetOrientation() & TVO_HORIZONTAL)
        pstrOrientationSpecificHTML = &g_szHorizontalTaskpadHTMLTemplate;

    else if (GetOrientation() & TVO_VERTICAL)
        pstrOrientationSpecificHTML = &g_szVerticalTaskpadHTMLTemplate;

    else
        pstrOrientationSpecificHTML = &g_szNoResultsTaskpadHTMLTemplate;

    sc = ScCheckPointers(pstrOrientationSpecificHTML, E_UNEXPECTED);
    if(sc)
        return sc;

    // this replacement must be done first
    sc = ScReplaceString(strTaskpadHTML, TEXT("@@ORIENTATIONSPECIFICHTML@@"), *pstrOrientationSpecificHTML);
    if(sc)
        return sc;

    sc = ScReplaceString(strTaskpadHTML, TEXT("@@TASKS@@"), strTasksHTML);
    if(sc)
        return sc;

    sc = ScReplaceString(strTaskpadHTML, TEXT("@@TASKWIDTH@@"), GetOrientation() & TVO_VERTICAL ? TEXT("100%") : TEXT("30%")); // only one task per row for vertical taskpads
    if(sc)
        return sc;

    CStr strName = GetName().data();
    sc = ScUseHTMLEntities(strName);
    if(sc)
        return sc;

    CStr strDescription = GetDescription().data();
    sc = ScUseHTMLEntities(strDescription);
    if(sc)
        return sc;

    sc = ScReplaceString(strTaskpadHTML, TEXT("@@CONSOLETASKPADNAME@@"), strName);
    if(sc)
        return sc;

    sc = ScReplaceString(strTaskpadHTML, TEXT("@@CONSOLETASKPADDESCRIPTION@@"), strDescription);
    if(sc)
        return sc;

    if (GetOrientation() & TVO_VERTICAL)
    {
        // small, medium and large list sizes correspond to taskpad areas of 262, 212, and 166 pixels respectively
        CStr strLeftPaneWidth;
        if(GetListSize()==eSize_Small)
            strLeftPaneWidth=TEXT("262");
        if(GetListSize()==eSize_Medium)
            strLeftPaneWidth=TEXT("212");
        if(GetListSize()==eSize_Large)
            strLeftPaneWidth=TEXT("166");

        sc = ScReplaceString(strTaskpadHTML, TEXT("@@LEFTPANEWIDTH@@"), strLeftPaneWidth);
        if(sc)
            return sc;
    }
    else if (GetOrientation() & TVO_HORIZONTAL)
    {
        // small, medium and large list sizes correspond to taskpad heights of 200, 150, and 100 pixels respectively
        CStr strBottomPaneHeight;

        if(GetListSize()==eSize_Small)
            strBottomPaneHeight=TEXT("200");
        if(GetListSize()==eSize_Medium)
            strBottomPaneHeight=TEXT("150");
        if(GetListSize()==eSize_Large)
            strBottomPaneHeight=TEXT("100");

        sc = ScReplaceString(strTaskpadHTML, TEXT("@@BOTTOMPANEHEIGHT@@"), strBottomPaneHeight);
        if(sc)
            return sc;
    }

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CConsoleTaskpad::Reset
 *
 * PURPOSE:
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CConsoleTaskpad::ResetUI()
{
    // reset all the contained tasks.
    for (TaskIter iter = BeginTask(); iter!=EndTask(); ++iter)
    {
        iter->ResetUI();
    }

    // reset the member bookmark
    m_bmTargetNode.ResetUI();
}


/*+-------------------------------------------------------------------------*
 * CConsoleTaskpad::Retarget
 *
 *
 *--------------------------------------------------------------------------*/

bool CConsoleTaskpad::Retarget (CMTNode* pMTNewNode, bool fReset)
{
    /*
     * if we were given a new node...
     */
    if (pMTNewNode != NULL)
    {
        // Ensure the  MTNode is initialized.
        if (!pMTNewNode->IsInitialized())
        {
            HRESULT hr = pMTNewNode->Init();
            ASSERT(SUCCEEDED(hr));
        }

        /*
         * ...if we've already been targeted to a particular node
         * type, prevent retargeting to a different node type
         */
        if ( (!fReset) && (m_guidNodeType != GUID_NULL))
        {
            GUID guidNewNodeType;
            pMTNewNode->GetNodeType (&guidNewNodeType);

            if (guidNewNodeType != m_guidNodeType)
                return (false);
        }

        /*
         * otherwise, this is the first non-NULL node we've been
         * targeted to; get its node type
         */
        else
            pMTNewNode->GetNodeType (&m_guidNodeType);

        /*
         * If this is a new taskpad, default the taskpad's name
         * to the target node's display name.  The taskpad
         * description and tooltip default to empty.
         */
        if (m_strName.str().empty() || fReset)
        {
            m_strName = pMTNewNode->GetDisplayName();
            ASSERT (m_strDescription.str().empty());
            ASSERT (m_strTooltip.str().empty());
        }
    }

    m_bmTargetNode.ScRetarget(pMTNewNode, false /*bFastRetrievalOnly*/);
    m_pMTNodeTarget = pMTNewNode;

    SetDirty ();
    return (true);
}

bool CConsoleTaskpad::Retarget (CNode* pNewNode)
{
    CMTNode* pMTNewNode = (pNewNode != NULL) ? pNewNode->GetMTNode() : NULL;

    return (Retarget (pMTNewNode));
}


/*+-------------------------------------------------------------------------*
 * CConsoleTaskpad::SetName
 *
 *
 *--------------------------------------------------------------------------*/

void CConsoleTaskpad::SetName (const tstring& strName)
{
    SetStringMember (m_strName, strName);
}


/*+-------------------------------------------------------------------------*
 * CConsoleTaskpad::SetDescription
 *
 *
 *--------------------------------------------------------------------------*/

void CConsoleTaskpad::SetDescription (const tstring& strDescription)
{
    SetStringMember (m_strDescription, strDescription);
}


void CConsoleTaskpad::SetListSize(const ListSize listSize)
{
    m_listSize = listSize;
    SetDirty();
}

/*+-------------------------------------------------------------------------*
 * CConsoleTaskpad::SetToolTip
 *
 *
 *--------------------------------------------------------------------------*/

void CConsoleTaskpad::SetToolTip (const tstring& strTooltip)
{
    SetStringMember (m_strTooltip, strTooltip);
}


void
CConsoleTaskpad::SetNodeSpecific  (bool bNodeSpecific)
{
    m_bNodeSpecific = bNodeSpecific;
    SetDirty();
}

void
CConsoleTaskpad::SetReplacesDefaultView(bool bReplacesDefaultView)
{
    m_bReplacesDefaultView = bReplacesDefaultView;
    SetDirty();
}


/*+-------------------------------------------------------------------------*
 * CConsoleTaskpad::SetStringMember
 *
 * Changes the value of a string member variable, and marks the taskpad
 * dirty, if and only if the new value is different than the old value.
 *--------------------------------------------------------------------------*/

void CConsoleTaskpad::SetStringMember (
    CStringTableString& strMember,
    const tstring&      strNewValue)
{
    if (strMember != strNewValue)
    {
        strMember = strNewValue;
        SetDirty ();
    }
}

/*+-------------------------------------------------------------------------*
 * CConsoleTaskpad::AddTask
 *
 *
 *--------------------------------------------------------------------------*/

CConsoleTaskpad::TaskIter
CConsoleTaskpad::AddTask (const CConsoleTask& task)
{
    return (InsertTask (m_Tasks.end(), task));
}


/*+-------------------------------------------------------------------------*
 * CConsoleTaskpad::InsertTask
 *
 *
 *--------------------------------------------------------------------------*/

CConsoleTaskpad::TaskIter
CConsoleTaskpad::InsertTask (
    TaskIter            itTaskBeforeWhichToInsert,
    const CConsoleTask& task)
{
    TaskIter itInserted = m_Tasks.insert (itTaskBeforeWhichToInsert, task);
    SetDirty ();

    return (itInserted);
}


/*+-------------------------------------------------------------------------*
 * CConsoleTaskpad::EraseTask
 *
 *
 *--------------------------------------------------------------------------*/

CConsoleTaskpad::TaskIter
CConsoleTaskpad::EraseTask (
    TaskIter itErase)
{
    SetDirty ();
    return (m_Tasks.erase (itErase));
}


/*+-------------------------------------------------------------------------*
 * CConsoleTaskpad::EraseTasks
 *
 *
 *--------------------------------------------------------------------------*/

CConsoleTaskpad::TaskIter
CConsoleTaskpad::EraseTasks (
    TaskIter itFirst,
    TaskIter itLast)
{
    SetDirty ();
    return (m_Tasks.erase (itFirst, itLast));
}


/*+-------------------------------------------------------------------------*
 * CConsoleTaskpad::ClearTasks
 *
 *
 *--------------------------------------------------------------------------*/

void CConsoleTaskpad::ClearTasks ()
{
    SetDirty ();
    m_Tasks.clear ();
}


/*+-------------------------------------------------------------------------*
 * CConsoleTaskpad::IsDirty
 *
 * Determines if this taskpad or any of its contained tasks is are dirty.
 *--------------------------------------------------------------------------*/

bool CConsoleTaskpad::IsDirty () const
{
    /*
     * if the taskpad is dirty, short out
     */
    if (m_fDirty)
    {
        TraceDirtyFlag(TEXT("CConsoleTaskpad"), true);
        return (true);
    }

    /*
     * the taskpad is clean, check each task
     */
    for (TaskConstIter it = m_Tasks.begin(); it != m_Tasks.end(); ++it)
    {
        if (it->IsDirty())
        {
            TraceDirtyFlag(TEXT("CConsoleTaskpad"), true);
            return (true);
        }
    }

    TraceDirtyFlag(TEXT("CConsoleTaskpad"), false);
    return (false);
}


/*+-------------------------------------------------------------------------*
 * CConsoleTaskpad::GetTargetMTNode
 *
 *
 *--------------------------------------------------------------------------*/

CMTNode* CConsoleTaskpad::GetTargetMTNode (IScopeTree* pScopeTree)
{
    DECLARE_SC(sc, TEXT("CConsoleTaskpad::GetTargetMTNode"));

    if(!HasTarget())
        return NULL;

    if(!m_pMTNodeTarget)
    {
        CMTNode *pMTNode = NULL;
        bool bExactMatchFound = false; // out value from ScGetMTNode, unused
        sc = m_bmTargetNode.ScGetMTNode(true /*bExactMatchRequired*/, &pMTNode, bExactMatchFound);
        if(sc.IsError() || !pMTNode)
            return NULL;


        m_pMTNodeTarget = pMTNode;
    }

    return (m_pMTNodeTarget);
}

/*+-------------------------------------------------------------------------*
 *
 * CConsoleTaskpad::Persist
 *
 * PURPOSE: Persists the console taskpad to the specified persistor.
 *
 * PARAMETERS:
 *    CPersistor & persistor :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CConsoleTaskpad::Persist(CPersistor &persistor)
{
    persistor.PersistString(XML_ATTR_TASKPAD_NAME,              m_strName);
    persistor.PersistString(XML_ATTR_TASKPAD_DESCRIPTION,       m_strDescription);
    persistor.PersistString(XML_ATTR_TASKPAD_TOOLTIP,           m_strTooltip);

    // define the table to map enumeration values to strings
    static const EnumLiteral mappedSize[] =
    {
        { eSize_Large,  XML_ENUM_LIST_SIZE_LARGE },
        { eSize_Medium, XML_ENUM_LIST_SIZE_MEDIUM },
        { eSize_None,   XML_ENUM_LIST_SIZE_NONE },
        { eSize_Small,  XML_ENUM_LIST_SIZE_SMALL },
    };

    // create wrapper to persist flag values as strings
    CXMLEnumeration listSizePersistor(m_listSize, mappedSize, countof(mappedSize));

    // initialize the value suitably
    if(persistor.IsLoading())
        m_listSize = eSize_Default;

    // persist the wrapper
    persistor.PersistAttribute(XML_ATTR_TASKPAD_LIST_SIZE,  listSizePersistor, attr_optional); // optional because this was introduced late

    persistor.PersistAttribute(XML_ATTR_TASKPAD_NODE_SPECIFIC,    CXMLBoolean(m_bNodeSpecific));
    persistor.PersistAttribute(XML_ATTR_REPLACES_DEFAULT_VIEW,    CXMLBoolean(m_bReplacesDefaultView), attr_optional);


    // define the table to map enumeration values to strings
    static const EnumLiteral mappedOrientation[] =
    {
        { TVO_HORIZONTAL,               XML_BITFLAG_TASK_ORIENT_HORIZONTAL },
        { TVO_VERTICAL,                 XML_BITFLAG_TASK_ORIENT_VERTICAL },
        { TVO_NO_RESULTS,               XML_BITFLAG_TASK_ORIENT_NO_RESULTS },
        { TVO_DESCRIPTIONS_AS_TEXT,     XML_BITFLAG_TASK_ORIENT_DESCRIPTIONS_AS_TEXT },
    };

    // create wrapper to persist flag values as strings
    CXMLBitFlags orientationPersistor(m_dwOrientation, mappedOrientation, countof(mappedOrientation));
    // persist the wrapper
    persistor.PersistAttribute(XML_ATTR_TASKPAD_ORIENTATION, orientationPersistor );

    persistor.Persist(m_Tasks);
    persistor.PersistAttribute(XML_ATTR_TASKPAD_NODE_TYPE,        m_guidNodeType);
    persistor.PersistAttribute(XML_ATTR_TASKPAD_ID,               m_guidID);

    persistor.Persist(m_bmTargetNode, XML_NAME_TARGET_NODE);

    // either read or saved - not dirty after the operation
    SetDirty(false);
}

/*+-------------------------------------------------------------------------*
 * CConsoleTaskpad::ReadSerialObject
 *
 *
 *--------------------------------------------------------------------------*/

HRESULT
CConsoleTaskpad::ReadSerialObject (IStream &stm, UINT nVersion)
{
    HRESULT hr = S_FALSE;   // assume unknown version


    if(nVersion==1)
    {
        try
        {
            do  // not a loop
            {
                bool fLegacyHasTarget = true; // an unused field
                UINT visualPercent    = 25;   // replaced by m_listSize

                stm >> m_strName;
                stm >> m_strDescription;
                stm >> m_strTooltip;
                stm >> visualPercent;

                m_listSize = eSize_Medium;
                if(visualPercent==25)
                    m_listSize = eSize_Large;
                else if(visualPercent==75)
                    m_listSize = eSize_Small;

                stm >> m_bNodeSpecific;
                m_bReplacesDefaultView = false; // this was introduced in mmc2.0.
                stm >> m_dwOrientation;

                hr = ::Read(stm, m_Tasks);
                BREAK_ON_FAIL (hr);

                stm >> m_guidNodeType;
                stm >> m_guidID;
                stm >> fLegacyHasTarget;
                stm >> m_bmTargetNode;

                // legacy task symbol info
                {
                    BOOL bLegacyUseMMCSymbols = TRUE; // a now obsolete field, read for console file compatibility
                    tstring strFileLegacy, strFontLegacy;
                    DWORD   dwSymbol = 0;

                    stm >> dwSymbol;
                    stm >> bLegacyUseMMCSymbols;
                    stm >> strFileLegacy; // obsolete
                    stm >> strFontLegacy; // obsolete
                }



                hr = S_OK;      // success!

            } while (false);
        }
        catch (_com_error& err)
        {
            hr = err.Error();
            ASSERT (false && "Caught _com_error");
        }
    }

    return (hr);
}


//############################################################################
//############################################################################
//
//  Implementation of class CConsoleTaskpadList
//
//############################################################################
//############################################################################
/*+-------------------------------------------------------------------------*
 *
 * CConsoleTaskpadList::ScGetTaskpadList
 *
 * PURPOSE: Returns the list of all taskpads that are appropriate for the current node.
 *
 * PARAMETERS:
 *    CNode *                       pNode :
 *    CConsoleTaskpadFilteredList & filteredList : [OUT]: The list of taskpads
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CConsoleTaskpadList::ScGetTaskpadList(CNode *pNode, CConsoleTaskpadFilteredList &filteredList)
{
    DECLARE_SC(sc, TEXT("CConsoleTaskpadList::ScGetTaskpadList"));

    sc = ScCheckPointers(pNode);
    if(sc)
        return sc;

    // 1. add all built- in taskpads

    for(iterator iter = begin(); iter != end(); ++iter)
    {
        CConsoleTaskpad *pConsoleTaskpad = &*iter;
        if(pConsoleTaskpad->IsValid(pNode))
        {
            filteredList.push_back(pConsoleTaskpad);
        }
    }

    return sc;
}

HRESULT
CConsoleTaskpadList::ReadSerialObject (IStream &stm, UINT nVersion)
{
    HRESULT hr = S_FALSE;       // assume unknown version

    clear();

    if(nVersion == 1)
    {
        try
        {
            DWORD cItems;
            stm >> cItems;

            for(int i=0; i< cItems; i++)
            {
                CConsoleTaskpad taskpad;
                hr = taskpad.Read(stm);
                BREAK_ON_FAIL (hr);
                push_back(taskpad);
            }
        }
        catch (_com_error& err)
        {
            hr = err.Error();
            ASSERT (false && "Caught _com_error");
        }
    }

    return hr;
}

//############################################################################
//############################################################################
//
//  Implementation of class CDefaultTaskpadList
//
//############################################################################
//############################################################################
HRESULT
CDefaultTaskpadList::ReadSerialObject (IStream &stm, UINT nVersion)
{
    HRESULT hr = S_FALSE;       // assume unknown version

    clear();

    if(nVersion == 1)
    {
        try
        {
            /*
             * TODO: investigate using template operator>> for a map (stgio.h)
             */

            DWORD cItems;
            stm >> cItems;

            for(int i=0; i< cItems; i++)
            {
                GUID guidNodetype, guidTaskpad;
                stm >> guidNodetype;
                stm >> guidTaskpad;
                operator[](guidNodetype) = guidTaskpad;
            }

            hr = S_OK;
        }
        catch (_com_error& err)
        {
            hr = err.Error();
            ASSERT (false && "Caught _com_error");
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\taskenum.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       TaskEnum.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11/19/1997   RaviR   Created
//____________________________________________________________________________
//

#include "stdafx.h"
#include "taskenum.h"


CTaskEnumerator::~CTaskEnumerator()
{
    POSITION pos = m_list.GetHeadPosition();
    while (pos)
    {
        STaskEnums& rte = m_list.GetNext(pos);
        rte.pET->Release();
    }

    m_list.RemoveAll();
}

bool 
CTaskEnumerator::AddTaskEnumerator(
    const CLSID& clsid, 
    IEnumTASK* pEnumTASK)
{
    ASSERT(pEnumTASK != NULL);
    if (pEnumTASK == NULL)
        return false;
    
    STaskEnums te; 
    te.clsid = clsid;
    te.pET = pEnumTASK;

    m_list.AddTail(te);
    pEnumTASK->AddRef();

    if (m_posCurr == NULL)
        m_posCurr = m_list.GetHeadPosition();
    
    return true;
}

STDMETHODIMP 
CTaskEnumerator::Next(
    ULONG celt, 
    MMC_TASK *rgelt, 
    ULONG *pceltFetched)
{
    ASSERT(celt == 1);
    if (celt != 1)
        return E_INVALIDARG;
        
    ASSERT(rgelt != NULL);
    if (rgelt == NULL)
        return E_POINTER;
    
    // init
    if (pceltFetched != NULL)
        *pceltFetched = 0;

    if (m_posCurr == NULL)
        return S_FALSE;


    HRESULT hr = S_FALSE;

    while (m_posCurr != NULL)
    {
        STaskEnums& rte = m_list.GetAt(m_posCurr);
        ASSERT(&rte != NULL);

        ULONG celtFetched = 0;
        hr = rte.pET->Next(1, rgelt, &celtFetched);
        ASSERT(SUCCEEDED(hr));
        if (pceltFetched)
            *pceltFetched = celtFetched;

#ifdef DBG
        if (hr == S_FALSE) { ASSERT(celtFetched == 0); }
#endif // DBG

        if (hr == S_OK)
        {
            MMC_ITASK* pTASK = reinterpret_cast<MMC_ITASK*>(rgelt);
            hr = ::StringFromCLSID(rte.clsid, &(pTASK->szClsid));
            ASSERT(SUCCEEDED(hr));
            break;
        }
        else if (FAILED(hr))
        {
            // continue if the snapin failed enum tasks
            hr = S_FALSE;
        }

        m_list.GetNext(m_posCurr);
    }

    return hr;
}

STDMETHODIMP 
CTaskEnumerator::Reset()
{
    POSITION pos = m_list.GetHeadPosition();
    while (pos != NULL && pos != m_posCurr)
    {
        STaskEnums& rte = m_list.GetNext(pos);
        ASSERT(&rte != NULL);
        rte.pET->Reset();
    }

    m_posCurr = m_list.GetHeadPosition();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\taskenum.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       taskenum.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11/19/1997   RaviR   Created
//____________________________________________________________________________
//

#ifndef TASKENUM_H__
#define TASKENUM_H__

struct STaskEnums
{
    CLSID clsid;
    IEnumTASK* pET;
};


class CTaskEnumerator : public IEnumTASK, 
                        public CComObjectRoot
{
// Constructor & destructor
public:
    CTaskEnumerator() : m_posCurr(NULL)
    {
    }
    ~CTaskEnumerator();
    
// ATL COM map
public:
BEGIN_COM_MAP(CTaskEnumerator)
    COM_INTERFACE_ENTRY(IEnumTASK)
END_COM_MAP()

// IEnumTASK methods
public:
    STDMETHOD(Next)(ULONG celt, MMC_TASK *rgelt, ULONG *pceltFetched);
    STDMETHOD(Reset)();

    STDMETHOD(Skip)(ULONG celt)
    {
        return E_NOTIMPL;
    }
    STDMETHOD(Clone)(IEnumTASK **ppenum)
    {
        return E_NOTIMPL;
    }

// public methods
public:
    bool AddTaskEnumerator(const CLSID& clsid, IEnumTASK* pEnumTASK);

// Implementation
private:
    CList<STaskEnums, STaskEnums&> m_list;
    POSITION m_posCurr;
    
// Ensure that default copy constructor & assignment are not used.
    CTaskEnumerator(const CTaskEnumerator& rhs);
    CTaskEnumerator& operator=(const CTaskEnumerator& rhs);

}; // class CTaskEnumerator


#endif // TASKENUM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\tasknode.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:       tasknode.cpp
 *
 *  Contents:   Implementation file for console taskpad CMTNode- and
 *              CNode-derived classes.
 *
 *  History:    29-Oct-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "tasks.h"
#include "util.h"
#include "conview.h"
#include "rsltitem.h"


//############################################################################
//############################################################################
//
//  Implementation of class CConsoleTaskCallbackImpl
//
//############################################################################
//############################################################################



/*+-------------------------------------------------------------------------*
 * CConsoleTaskCallbackImpl::CConsoleTaskCallbackImpl
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *
 * RETURNS:
 *
/*+-------------------------------------------------------------------------*/
CConsoleTaskCallbackImpl::CConsoleTaskCallbackImpl() :
	m_clsid        (GUID_NULL),
	m_fTaskpad     (false),
	m_fInitialized (false),
	m_pViewData    (NULL)
{
}


/*+-------------------------------------------------------------------------*
 *
 * CConsoleTaskCallbackImpl::ScInitialize
 *
 * PURPOSE:  This is the initialization function called for taskpad
 * view extensions.
 *
 * PARAMETERS:
 *    CConsoleTaskpad * pConsoleTaskpad :
 *    CScopeTree *      pScopeTree :
 *    CNode *           pNodeTarget :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
SC
CConsoleTaskCallbackImpl::ScInitialize(
	CConsoleTaskpad*	pConsoleTaskpad,
	CScopeTree*			pScopeTree,
	CNode*				pNodeTarget)
{
	DECLARE_SC (sc, _T("CConsoleTaskCallbackImpl::ScInitialize"));

	/*
	 * validate input
	 */
	sc = ScCheckPointers (pConsoleTaskpad, pScopeTree, pNodeTarget);
	if (sc)
		return (sc);

	sc = ScCheckPointers (pNodeTarget->GetViewData(), E_UNEXPECTED);
	if (sc)
		return (sc);

    m_pConsoleTaskpad = pConsoleTaskpad;
    m_pScopeTree      = pScopeTree;
    m_pNodeTarget     = pNodeTarget;
    m_pViewData       = pNodeTarget->GetViewData();
    m_fInitialized    = true;
	m_fTaskpad        = true;

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CConsoleTaskCallbackImpl::ScInitialize
 *
 * This is the initialization function called for ordinary view extensions.
 *--------------------------------------------------------------------------*/

SC CConsoleTaskCallbackImpl::ScInitialize (const CLSID& clsid)
{
	DECLARE_SC (sc, _T("CConsoleTaskCallbackImpl::ScInitialize"));

	m_clsid = clsid;
	return (sc);
}

/*+-------------------------------------------------------------------------*
 * CConsoleTaskCallbackImpl::IsEditable
 *
 * Returns S_OK if "Edit" and "Delete" menu items should be displayed
 * on the context menu for the node while this view extension is active.
 *
 * Returns S_FALSE if "Edit" and "Delete" should not be displayed.
 *--------------------------------------------------------------------------*/

STDMETHODIMP CConsoleTaskCallbackImpl::IsEditable()
{
	if (IsTaskpad())
		return (S_OK);

	return (S_FALSE);
}


/*+-------------------------------------------------------------------------*
 * CConsoleTaskCallbackImpl::OnModifyTaskpad
 *
 * PURPOSE:
 *
 * PARAMETERS:    +-
 *
 * RETURNS:
 *      HRESULT
/*+-------------------------------------------------------------------------*/
STDMETHODIMP
CConsoleTaskCallbackImpl::OnModifyTaskpad()
{
	DECLARE_SC (sc, _T("CConsoleTaskCallbackImpl::OnModifyTaskpad"));

	/*
	 * this should only be called for taskpad view extensions
	 */
	if (!IsTaskpad())
		return ((sc = E_UNEXPECTED).ToHr());

    CNode *pNodeTarget = GetConsoleTaskpad()->HasTarget() ? GetTargetNode() : NULL;

    bool fCookieValid = false;

    // determine whether the taskpad node is selected. If not, fCookieValid = false.
    LPARAM          lResultItemCookie = -1;
    bool            bScope;
    CNode*          pNode = NULL;
    CConsoleView*   pConsoleView = GetViewData()->GetConsoleView();

    if (pConsoleView != NULL)
    {
        HNODE hNode;
        sc = pConsoleView->ScGetFocusedItem (hNode, lResultItemCookie, bScope);

        if (sc)
            return (sc.ToHr());

        pNode = CNode::FromHandle (hNode);
    }

    if (pNode == NULL)
        fCookieValid = false;

    int iResp = CTaskpadPropertySheet(pNodeTarget, *GetConsoleTaskpad(), FALSE, NULL, fCookieValid,
        GetViewData(), CTaskpadPropertySheet::eReason_PROPERTIES).DoModal();

    if(iResp == IDOK)
    {
        GetViewData()->m_spTaskCallback = NULL;
        GetScopeTree()->UpdateAllViews(VIEW_RESELECT, 0);
    }

    return (sc.ToHr());
}


/*+-------------------------------------------------------------------------*
 *
 * CConsoleTaskCallbackImpl::GetTaskpadID
 *
 * PURPOSE: Returns the GUID ID of the underlying taskpad.
 *
 * PARAMETERS:
 *    GUID * pGuid :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CConsoleTaskCallbackImpl::GetTaskpadID(GUID *pGuid)
{
	DECLARE_SC (sc, _T("CConsoleTaskCallbackImpl::GetTaskpadID"));

	sc = ScCheckPointers (pGuid);
	if (sc)
		return (sc.ToHr());

	if (IsTaskpad())
	{
		/*
		 * TODO: initialize m_clsid in ScInitialize for taskpads
		 */
		CConsoleTaskpad* pTaskpad = GetConsoleTaskpad();
		sc = ScCheckPointers (pTaskpad, E_UNEXPECTED);
		if (sc)
			return (sc.ToHr());

		*pGuid = pTaskpad->GetID();
	}
	else
	{
		*pGuid = m_clsid;
	}

	return (sc.ToHr());
}

/*+-------------------------------------------------------------------------*
 *
 * CConsoleTaskCallbackImpl::OnDeleteTaskpad
 *
 * PURPOSE: Deletes a taskpad.
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CConsoleTaskCallbackImpl::OnDeleteTaskpad()
{
	DECLARE_SC (sc, _T("CConsoleTaskCallbackImpl::OnDeleteTaskpad"));

	/*
	 * this should only be called for taskpad view extensions
	 */
	if (!IsTaskpad())
		return ((sc = E_UNEXPECTED).ToHr());

    CScopeTree* pScopeTree = GetScopeTree();
	sc = ScCheckPointers (pScopeTree, E_UNEXPECTED);
	if (sc)
		return (sc.ToHr());

    CConsoleTaskpadList* pTaskpadList = pScopeTree->GetConsoleTaskpadList();
	sc = ScCheckPointers (pTaskpadList, E_UNEXPECTED);
	if (sc)
		return (sc.ToHr());

    CConsoleTaskpad* pTaskpad = GetConsoleTaskpad();
	sc = ScCheckPointers (pTaskpad, E_UNEXPECTED);
	if (sc)
		return (sc.ToHr());


    CConsoleTaskpadList::iterator iter;
    for(iter = pTaskpadList->begin(); iter != pTaskpadList->end(); iter++)
    {
        if(iter->MatchesID(pTaskpad->GetID()))
        {
            pTaskpadList->erase(iter);
            pScopeTree->UpdateAllViews(VIEW_RESELECT, 0);
            return (sc.ToHr());
        }
    }

    return ((sc = E_UNEXPECTED).ToHr()); // not found.
}

/*+-------------------------------------------------------------------------*
 *
 * CConsoleTaskCallbackImpl::OnNewTask
 *
 * PURPOSE:
 *
 * RETURNS:
 *    HRESULT : S_OK if tasks were added, S_FALSE if no tasks were added.
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CConsoleTaskCallbackImpl::OnNewTask()
{
    HRESULT hr = S_OK;
    CNode *pNodeTarget = GetConsoleTaskpad()->HasTarget() ? GetTargetNode() : NULL;

    // fake up a taskpad frame.
    CTaskpadFrame taskpadFrame(pNodeTarget, GetConsoleTaskpad(), GetViewData(), false, 0);

    CTaskWizard taskWizard;
    bool fRestartTaskpad = true;
    bool bAddedTasks     = false;

    while(fRestartTaskpad)
    {
        if (taskWizard.Show(GetViewData()->GetMainFrame(), &taskpadFrame,
                            true, &fRestartTaskpad)==S_OK)
        {
            bAddedTasks = true;
            CConsoleTaskpad::TaskIter   itTask;
            CConsoleTaskpad *           pTaskpad = GetConsoleTaskpad();

            itTask = pTaskpad->BeginTask();

            pTaskpad->InsertTask (itTask, taskWizard.ConsoleTask());
        }
        else
            break;
    }

    return bAddedTasks? S_OK : S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\task.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      task.h
 *
 *  Contents:  Interface file for CConsoleTask
 *
 *  History:   05-Oct-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef TASK_H
#define TASK_H
#pragma once

#include "bookmark.h"
#include "refcount.h"
#include "tstring.h"
#include "menuitem.h"
#include "xmlicon.h"		// for CXMLIcon

// forward declarations
class CConsoleTaskpad;
class CBookmarkEx;
class CStr;

typedef CConsoleTaskpad * PCONSOLETASKPAD;

#include <pshpack8.h>   // for Win64


/*+-------------------------------------------------------------------------*
 * CConsoleTask
 *
 *
 *--------------------------------------------------------------------------*/
enum eConsoleTaskType
{
    eTask_None,         // invalid task type
    eTask_Scope,        // task for a scope item
    eTask_Result,       // task for a result item
    eTask_CommandLine,  // task for a command line
    eTask_Target,       // task for menu item on the target node.
    eTask_Favorite      // task for a favorite
};


enum eWindowState
{
    eState_Restored,
    eState_Minimized,
    eState_Maximized,
};



/*+-------------------------------------------------------------------------*
 * CConsoleTask
 *
 *
 *--------------------------------------------------------------------------*/

class CConsoleTask : public CSerialObject, public CXMLObject
{
    enum
    {
        eFlag_Disabled = 0x00000001,
    };

    bool            operator==(const CConsoleTask & consoleTask) const; // private and unimplemented

public:
                    CConsoleTask ();
                    CConsoleTask(const CConsoleTask &rhs);
                    ~CConsoleTask ();

    static CConsoleTask *  GetConsoleTask(DWORD dwUniqueID); // returns the console task that has the specified unique ID.

    SC              ScGetHTML(LPCTSTR szFmtHTML, CStr &strTaskHTML, bool bUseLargeIcons, bool bUseTextDescriptions) const;       // get the HTML representation of the task.


     // need an explicit copy ctor & assignment operator.
    CConsoleTask&   operator= (const CConsoleTask& rhs);

    bool            IsEnabled ()      const    {return ((m_dwFlags & eFlag_Disabled) == 0);}
    void            SetDirty (bool fDirty = true) {m_fDirty = fDirty;}
    bool            IsDirty ()        const;
    bool            HasCustomIcon()   const;

    tstring         GetName ()        const     {return (m_strName.str()); }
    tstring         GetDescription () const     {return (m_strDescription.str()); }
    tstring         GetCommand ()     const     {return (m_strCommand); }
    tstring         GetParameters ()  const     {return (m_strParameters); }
    tstring         GetDirectory ()   const     {return (m_strDirectory); }
    CMemento *      GetMemento()                {return &m_memento;}
    void            Draw (HDC hdc, RECT *lpRect, bool bSmall = false) const ; // Draw into a DC.
    DWORD           GetSymbol()       const     {return m_dwSymbol;}
    const CSmartIcon &    GetSmallCustomIcon() const  {return m_smartIconCustomSmall;}
    const CSmartIcon &    GetLargeCustomIcon() const  {return m_smartIconCustomLarge;}
    DWORD           GetUniqueID()     const     {return m_dwUniqueID;}// returns an ID unique to the task for the current process. Is not persistent.

    void            Enable (bool fEnable);
    void            SetName (const tstring& strName);
    void            SetDescription   (const tstring& strDescription);
    void            SetCommand       (const tstring& strCommand);
    void            SetParameters    (const tstring& strParameters);
    void            SetDirectory     (const tstring &strDirectory);
    void            SetMemento       (const CMemento &memento);
    void            SetSymbol        (DWORD dwSymbol);
    void            SetCustomIcon    (CSmartIcon& iconSmall, CSmartIcon& iconLarge);

    void            ResetUI();                // signal to look for the target node again

    void            SetTaskType(eConsoleTaskType consoleTaskType)
                            {m_eConsoleTaskType = consoleTaskType;}

    void            SetWindowState (eWindowState eState);

    eConsoleTaskType GetTaskType() const            {return m_eConsoleTaskType;}
    eWindowState     GetWindowState() const         {return m_eWindowState;}

    CConsoleTaskpad* GetOwner () const              { return (m_pctpOwner); }

    void             SetOwner (CConsoleTaskpad* pctpOwner);

    bool             operator==(const CMenuItem & menuItem) const;

    // target node methods (scope tasks only)
    bool             RetargetScopeNode(CNode *pNewNode);
    CMTNode *        GetScopeNode(IScopeTree *pScopeTree) const;
    std::auto_ptr<CNode> GetScopeNode(CViewData *pViewData) const;


private:
    /*
     * these are persisted
     */
    eConsoleTaskType        m_eConsoleTaskType;
    CStringTableString      m_strName;
    CStringTableString      m_strDescription;
    DWORD                   m_dwSymbol;         // the index of the built-in icon
    CXMLIcon                m_smartIconCustomLarge; // the large custom icon, if one exists
    CXMLIcon                m_smartIconCustomSmall; // the small custom icon, if one exists

    tstring                 m_strCommand;       // contains: either the menu item, or the command line.
    tstring                 m_strParameters;    // the list of arguments for command line tasks.
    tstring                 m_strDirectory;     // the default directory for command line tasks.
    eWindowState            m_eWindowState;     // min, max, restored

    DWORD                   m_dwFlags;
    mutable CBookmarkEx     m_bmScopeNode;      // for scope tasks only.

    CMemento                m_memento;          // for favorite tasks only.

    /*
     * these are not persisted
     */
    bool                    m_fDirty;
    CConsoleTaskpad*        m_pctpOwner;
    const DWORD             m_dwUniqueID;


    // CXMLObject methods
public:
    DEFINE_XML_TYPE(XML_TAG_TASK);
    virtual void    Persist(CPersistor &persistor);

protected:
    // CSerialObject methods
    virtual UINT    GetVersion()     {return 1;}
    virtual HRESULT ReadSerialObject (IStream &stm, UINT nVersion /*,LARGE_INTEGER nBytes*/);
};


/*+-------------------------------------------------------------------------*
 * CTaskCollection
 *
 *
 * PURPOSE: A list of console tasks. Used by CConsoleTaskpad.
 *
 *+-------------------------------------------------------------------------*/
typedef std::list<CConsoleTask> TaskCollection;
class CTaskCollection : public XMLListCollectionImp<TaskCollection>
{
    DEFINE_XML_TYPE(XML_TAG_TASK_LIST);
};

/*+-------------------------------------------------------------------------*
 * CConsoleTaskpad
 *
 *
 *--------------------------------------------------------------------------*/
const DWORD TVO_HORIZONTAL           = 0x0001;
const DWORD TVO_VERTICAL             = 0x0002;
const DWORD TVO_NO_RESULTS           = 0x0004;
const DWORD TVO_DESCRIPTIONS_AS_TEXT = 0x0008;

/*
 * small list == large task area
 */
enum ListSize
{
    eSize_None   = -1,
    eSize_Small  = 1,
    eSize_Medium,
    eSize_Large,
    eSize_Default= eSize_Medium
};


class CConsoleTaskpad : public CSerialObject, public CXMLObject
{
public:
    CConsoleTaskpad (CNode* pTargetNode = NULL);

    /*
     * member-wise construction and assignment are sufficient
     */
//  CConsoleTaskpad (const CConsoleTaskpad& other);
//  CConsoleTaskpad& operator= (const CConsoleTaskpad& other);

    void                SetDirty (bool fDirty = true) { m_fDirty = fDirty; }
    bool                IsDirty () const;

    bool                HasTarget()       const { return true;}
    const GUID&         GetNodeType ()    const { return (m_guidNodeType); }
    const GUID&         GetID()           const { return (m_guidID);}
    bool                MatchesNodeType(const GUID& guid) const {return (guid == m_guidNodeType);}
    bool                MatchesID      (const GUID& guid) const {return (guid == m_guidID);}

    bool                Retarget (CNode*   pNewNode);
    bool                Retarget (CMTNode* pMTNewNode, bool fReset=false);
    CMTNode*            GetTargetMTNode (IScopeTree* pScopeTree);

    tstring             GetName ()        const { return (m_strName.str()); }
    tstring             GetDescription () const { return (m_strDescription.str()); }
    tstring             GetToolTip ()     const { return (m_strTooltip.str()); }
    ListSize            GetListSize()     const { return m_listSize;}
    bool                IsNodeSpecific()  const { return m_bNodeSpecific;}
    bool                FReplacesDefaultView()  const { return m_bReplacesDefaultView;}
    DWORD               GetOrientation()  const { return m_dwOrientation;}
    bool                IsValid(CNode *pNode) const;      // is this taskpad appropriate for this node?
    CMTNode*            GetRetargetRootNode() const;

    void                SetName          (const tstring& strName);
    void                SetDescription   (const tstring& strDescription);
    void                SetToolTip       (const tstring& strTooltip);
    void                SetListSize      (const ListSize listSize);
    void                SetNodeSpecific  (bool bNodeSpecific);
    void                SetReplacesDefaultView(bool bReplacesDefaultView);
    void                SetOrientation   (DWORD dwOrientation)  {m_dwOrientation = dwOrientation;}
    void                ResetUI();
    CConsoleTaskpad *   PConsoleTaskpad() {return this;} // an easy way to get to the object pointer thru an iterator.

    SC                  ScGetHTML(CStr &strTaskpadHTML) const;       // get the HTML representation of the taskpad.

    /*
     * task list access
     */
    typedef             CTaskCollection::iterator        TaskIter;
    typedef             CTaskCollection::const_iterator  TaskConstIter;

    TaskIter            BeginTask() const  { return (m_Tasks.begin()); }
    TaskIter            EndTask()   const  { return (m_Tasks.end()); }
    UINT                TaskCount() const  { return (static_cast<UINT>(m_Tasks.size())); }
    TaskIter            AddTask    (const CConsoleTask& task);
    TaskIter            InsertTask (TaskIter itTaskBeforeWhichToInsert, const CConsoleTask& task);
    TaskIter            EraseTask  (TaskIter itErase);
    TaskIter            EraseTasks (TaskIter itFirst, TaskIter itLast);
    void                ClearTasks ();

    // CXMLObject methods
public:
    DEFINE_XML_TYPE(XML_TAG_CONSOLE_TASKPAD);
    virtual void        Persist(CPersistor &persistor);

private:
    CBookmarkEx &       GetTargetBookmark()  {return  m_bmTargetNode;}
    void                ResetTargetNodePointer()    {m_pMTNodeTarget = NULL;}
    void                SetStringMember(CStringTableString& strMember, const tstring& strNewValue);

private:
    /*
     * these are persisted
     */
    CStringTableString      m_strName;
    CStringTableString      m_strDescription;
    CStringTableString      m_strTooltip;
    ListSize                m_listSize;         // the area of the the result pane occupied by the embedded view
    bool                    m_bNodeSpecific;    // is this taskpad specific to this node, or can it be used for all nodes of this type?
    DWORD                   m_dwOrientation;
    GUID                    m_guidNodeType;
    GUID                    m_guidID;           // the unique identifier of the taskpad.
    mutable CBookmarkEx     m_bmTargetNode;
    CTaskCollection         m_Tasks;
    bool                    m_bReplacesDefaultView; // does this taskpad replace the default view?

    /*
     * these are not persisted
     */
    bool                    m_fDirty;
    CMTNode *               m_pMTNodeTarget;

protected:
    // CSerialObject methods
    virtual UINT    GetVersion()     {return 1;}
    virtual HRESULT ReadSerialObject (IStream &stm, UINT nVersion);
};


/*+-------------------------------------------------------------------------*
 * CConsoleTaskpadFilteredList
 *
 *
 * PURPOSE: Provides a list of taskpads appropriate to a given node.
 *
 *+-------------------------------------------------------------------------*/
class CConsoleTaskpadFilteredList : public std::list<PCONSOLETASKPAD>
{
    iterator m_CurrentSelection;    // the currently selected taskpad
};


/*+-------------------------------------------------------------------------*
 * CConsoleTaskpadList
 *
 *
 * PURPOSE: There should be only one object of this kind. This object contains
 *          a flat list of taskpads available. These are not sorted in any
 *          particular order.
 *
 *+-------------------------------------------------------------------------*/
typedef std::list<CConsoleTaskpad> CTaskpadList_base;
class CConsoleTaskpadList : public CSerialObject, public XMLListCollectionImp<CTaskpadList_base>
{
    typedef std::list<CConsoleTaskpad> BC;

public: // find a taskpad for this node, else return NULL
    SC      ScGetTaskpadList(CNode *pNode, CConsoleTaskpadFilteredList &filteredList);

    // CSerialObject methods
    virtual UINT    GetVersion()     {return 1;}
    virtual HRESULT ReadSerialObject (IStream &stm, UINT nVersion);

    // CXMLObject methods
public:
    DEFINE_XML_TYPE(XML_TAG_CONSOLE_TASKPADS);
};

/*+-------------------------------------------------------------------------*
 * CDefaultTaskpadList
 *
 *
 * PURPOSE: stores a map from nodetypes to console taskpad IDs
 *          This maps a nodetype to the default taskpad for that nodetype.
 *
 *+-------------------------------------------------------------------------*/
class CDefaultTaskpadList : public std::map<GUID, GUID>, // 1st = nodetype, 2nd = taskpad ID
    public CSerialObject
{
public:
    // CSerialObject methods
    virtual UINT    GetVersion()     {return 1;}
    virtual HRESULT ReadSerialObject (IStream &stm, UINT nVersion);
};

#include <poppack.h>


#endif // TASK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\tasknode.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:       tasknode.h
 *
 *  Contents:   Interface file for console taskpad CMTNode- and CNode-derived
 *              classes.
 *
 *  History:    29-Oct-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef TASKNODE_H
#define TASKNODE_H
#pragma once

class CConsoleTaskCallbackImpl;

//____________________________________________________________________________
//
//  Class:      CConsoleTaskCallbackImpl
//
//  PURPOSE:    Implements ITaskCallback.
//____________________________________________________________________________
//
class CConsoleTaskCallbackImpl :
    public ITaskCallback,
    public CComObjectRoot
{
    // typedefs
    typedef CConsoleTaskpad::TaskIter       TaskIter;

DECLARE_NOT_AGGREGATABLE(CConsoleTaskCallbackImpl)

BEGIN_COM_MAP(CConsoleTaskCallbackImpl)
    COM_INTERFACE_ENTRY(ITaskCallback)
END_COM_MAP()

public:

    // must call Initialize after constructing.
    SC ScInitialize(const CLSID& clsid);
    SC ScInitialize(CConsoleTaskpad *pConsoleTaskpad, CScopeTree *pScopeTree, CNode *pNodeTarget);

    // ITaskCallback
	STDMETHOD(IsEditable)();
	STDMETHOD(OnModifyTaskpad)();
	STDMETHOD(OnDeleteTaskpad)();
	STDMETHOD(GetTaskpadID)(GUID *pGuid);

	// constructor/destructor
	CConsoleTaskCallbackImpl();
	HRESULT             OnNewTask();
	void                EnumerateTasks();
	CConsoleTaskpad *   GetConsoleTaskpad() const {return m_pConsoleTaskpad;}

private: // implementation

    void                        CheckInitialized()  const {ASSERT(m_fInitialized);}
    CNode*                      GetTargetNode()     const {CheckInitialized(); return m_pNodeTarget;}
    CScopeTree *                GetScopeTree()      const {return m_pScopeTree;}
    CViewData *                 GetViewData()       const {return m_pViewData;}
	bool						IsTaskpad() const		{ return (m_fTaskpad); }

    // attributes
    CLSID	m_clsid;
	bool	m_fTaskpad;

	/*
	 * these are used for console taskpads only
	 */
    bool                        m_fInitialized;
    CConsoleTaskpad *           m_pConsoleTaskpad;
    CViewData *                 m_pViewData;
    CScopeTree *                m_pScopeTree;
    CNode *                     m_pNodeTarget;
};


#endif /* TASKNODE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\tasks.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       tasks.h
//
//--------------------------------------------------------------------------

#include "task.h"
#include "tasksym.h"
#include "taskui.h"  
#include "tasknode.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\tasksym.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       tasksym.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10/29/1998   DavidPe   Adapted from BackOffice snapin
//____________________________________________________________________________
//

#ifndef __TASKSYM_H__
#define __TASKSYM_H__

#include "tstring.h"
#include "dlgs.h"
#include "task.h"		// for CSmartIcon

extern const int NUM_SYMBOLS; // the total number of symbols available.
class CConsoleTask;

/*+-------------------------------------------------------------------------*
 * class CEOTSymbol
 *
 *
 * PURPOSE: encapsulates information about glyphs that are internal to MMC. These
 *          have description text along with them.
 *+-------------------------------------------------------------------------*/
class CEOTSymbol
{
public:
    CEOTSymbol(WORD iconResource, int value, int ID, int IDSecondary=0)
            {m_iconResource = iconResource; m_value = value; m_ID = ID; m_IDSecondary = IDSecondary;}

    ~CEOTSymbol();
    void Draw (HDC hdc, RECT *lpRect, bool bSmall = false) const ; // Draw into a DC.

public:
    int       GetID()          const {return m_ID;}
    int       GetIDSecondary() const {return m_IDSecondary;}
    int       GetValue() const {return m_value;}
    bool      operator == (const CEOTSymbol &rhs);

    static bool  IsMatch(CStr &str1, CStr &str2);
    static int   FindMatchingSymbol(LPCTSTR szDescription); // finds a symbol matching the given description.

    void         SetIcon(const CSmartIcon & smartIconSmall, const CSmartIcon & smartIconLarge);
    CSmartIcon & GetSmallIcon()  {return m_smartIconSmall;}
    CSmartIcon & GetLargeIcon()  {return m_smartIconLarge;}

private:
    WORD       m_iconResource; // the resource id of the icon
    int        m_value;        // the number of the symbol
    int        m_ID;           // description text resource ID
    int        m_IDSecondary;  // secondary description\

protected:
    mutable CSmartIcon m_smartIconSmall;
    mutable CSmartIcon m_smartIconLarge;
};

/*+-------------------------------------------------------------------------*
 * class CTaskSymbolDlg
 *
 *
 * PURPOSE:
 *
 *+-------------------------------------------------------------------------*/
class CTaskSymbolDlg :
    public WTL::CPropertyPageImpl<CTaskSymbolDlg>
{
    typedef WTL::CPropertyPageImpl<CTaskSymbolDlg> BC;

public:
    CTaskSymbolDlg(CConsoleTask& rConsoleTask, bool bFindMatchingSymbol= false);

    ~CTaskSymbolDlg() { m_imageList.Destroy(); }

    enum { IDD     = IDD_TASK_PROPS_SYMBOL_PAGE,
           IDD_WIZ = IDD_TASK_WIZARD_SYMBOL_PAGE};

BEGIN_MSG_MAP(CTaskSymbolDlg)
    MESSAGE_HANDLER(WM_INITDIALOG,                    OnInitDialog)
    MESSAGE_HANDLER(WM_CTLCOLORSTATIC,                OnCtlColorStatic)
    CONTEXT_HELP_HANDLER()
    NOTIFY_HANDLER (IDC_GLYPH_LIST,  NM_CUSTOMDRAW,   OnCustomDraw)
    NOTIFY_HANDLER (IDC_GLYPH_LIST,  LVN_ITEMCHANGED, OnSymbolChanged)
    COMMAND_ID_HANDLER(IDB_SELECT_TASK_ICON,          OnSelectTaskIcon)
    COMMAND_HANDLER(IDC_CustomIconRadio, BN_CLICKED,  OnIconSourceChanged)
    COMMAND_HANDLER(IDC_MMCIconsRadio,   BN_CLICKED,  OnIconSourceChanged)
    CHAIN_MSG_MAP(BC)
    REFLECT_NOTIFICATIONS()
END_MSG_MAP()

    IMPLEMENT_CONTEXT_HELP(g_aHelpIDs_IDD_TASK_PROPS_SYMBOL_PAGE);

    //
    // message handlers
    //
    LRESULT OnInitDialog(UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& handled);
    LRESULT OnCtlColorStatic(UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& handled);
    LRESULT OnCustomDraw(int id, LPNMHDR pnmh, BOOL& bHandled );
    LRESULT OnSymbolChanged(int id, LPNMHDR pnmh, BOOL& bHandled );
    LRESULT OnSelectTaskIcon(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnIconSourceChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    int     OnWizardNext()      {return OnOK() ? 0 : -1;}
    bool    OnApply ()          {return OnOK();}
    BOOL    OnOK();

    // implementation
    void    DrawItem(NMCUSTOMDRAW *pnmcd);

private:
	SC ScEnableControls (int id);

protected:
    CConsoleTask&       m_ConsoleTask;          // get the name to match from here.
    WTL::CImageList     m_imageList;
    WTL::CListViewCtrl  m_listGlyphs;           // the list control for the glyphs
	WTL::CStatic		m_wndCustomIcon;
	CSmartIcon			m_CustomIconSmall;
	CSmartIcon			m_CustomIconLarge;
    bool                m_bFindMatchingSymbol;  // should we try to guess a symbol?
	bool 				m_bCustomIcon;			// does this task use a custom icon?
};


class CTaskSymbolWizardPage: public CTaskSymbolDlg
{
    typedef CTaskSymbolDlg BC;
public:
    CTaskSymbolWizardPage(CConsoleTask& rConsoleTask): BC(rConsoleTask, true)
    {
        m_psp.pszTemplate = MAKEINTRESOURCE(BC::IDD_WIZ);

        /*
         * Wizard97-style pages have titles, subtitles and header bitmaps
         */
        VERIFY (m_strTitle.   LoadString(GetStringModule(), IDS_TaskWiz_SymbolPageTitle));
        VERIFY (m_strSubtitle.LoadString(GetStringModule(), IDS_TaskWiz_SymbolPageSubtitle));

        m_psp.dwFlags          |= PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
        m_psp.pszHeaderTitle    = m_strTitle.data();
        m_psp.pszHeaderSubTitle = m_strSubtitle.data();
    }

    BOOL OnSetActive()
	{
		// add the Finish button.
		WTL::CPropertySheetWindow(::GetParent(m_hWnd)).SetWizardButtons (PSWIZB_BACK | PSWIZB_NEXT);
		return TRUE;
	}

private:
    tstring m_strTitle;
    tstring m_strSubtitle;
};
#endif // __TASKSYM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\tasksymbol.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       tasksymbol.cpp
//
//  History: 17-Jan-2000 Vivekj added
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "TaskSymbol.h"
#include "tasks.h"

//############################################################################
//############################################################################
//
//  Traces
//
//############################################################################
//############################################################################
#ifdef DBG

CTraceTag tagTaskSymbol(TEXT("CTaskSymbol"), TEXT("CTaskSymbol"));

#endif //DBG


//############################################################################
//############################################################################
//
//  Implementation of class CTaskSymbol
//
//############################################################################
//############################################################################

extern CEOTSymbol s_rgEOTSymbol[];


CTaskSymbol::CTaskSymbol()
: m_dwConsoleTaskID(0),
  m_bSmall(0)
{
}



/*+-------------------------------------------------------------------------*
 *
 * CTaskSymbol::OnDraw
 *
 * PURPOSE: Draws out the symbol onto the DC specified in the ATL_DRAWINFO structure.
 *
 * PARAMETERS: 
 *    ATL_DRAWINFO& di :
 *
 * RETURNS: 
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CTaskSymbol::OnDraw(ATL_DRAWINFO& di)
{
    DECLARE_SC(sc, TEXT("CTaskSymbol::OnDraw"));
    RECT * pRect = (RECT *)di.prcBounds;


    sc = ScCheckPointers(pRect);
    if(sc)
        return sc.ToHr();

    CConsoleTask *pConsoleTask = CConsoleTask::GetConsoleTask(m_dwConsoleTaskID); // get the console task from the unique ID
    
    COLORREF colorOld = SetTextColor (di.hdcDraw, ::GetSysColor (COLOR_WINDOWTEXT));

    if(pConsoleTask)
        pConsoleTask->Draw(di.hdcDraw, pRect, m_bSmall);

    SetTextColor(di.hdcDraw, colorOld);


    return sc.ToHr();
}


LRESULT 
CTaskSymbol::OnLButtonDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    Fire_Click();
    return 0;
}

// from winuser.h, for Windows 2000 and above only.
#define IDC_HAND            MAKEINTRESOURCE(32649)


LRESULT 
CTaskSymbol::OnSetCursor(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    static HCURSOR s_hCursorHand = ::LoadCursor(NULL, IDC_HAND);

    // if the hand cursor is available, use it.
    if(s_hCursorHand)
        ::SetCursor(s_hCursorHand);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\tasksym.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       tasksym.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "tasks.h"
#include "stgio.h"
#include <commdlg.h>
#include "symbinfo.h"
#include "pickicon.h"
#include "util.h"


const int NUM_SYMBOLS = (sizeof(s_rgEOTSymbol)/sizeof(s_rgEOTSymbol[0]));

static const int s_cxIcon            = 32;	// size of an icon
static const int s_cxSelectionMargin =  4;	// additional border for selection
static const int s_cxIconGutter      = 10;	// gutter space between icons (keep this even)

//############################################################################
//############################################################################
//
//  Implementation of class CEOTSymbol
//
//############################################################################
//############################################################################

CEOTSymbol::~CEOTSymbol()
{
}

bool
CEOTSymbol::operator == (const CEOTSymbol &rhs)
{
    return ( (m_iconResource  == rhs.m_iconResource) &&
             (m_value == rhs.m_value) &&
             (m_ID    == rhs.m_ID) );

}

void
CEOTSymbol::SetIcon(const CSmartIcon & smartIconSmall, const CSmartIcon & smartIconLarge)
{
    m_smartIconSmall = smartIconSmall;
    m_smartIconLarge = smartIconLarge;
}



/*+-------------------------------------------------------------------------*
 *
 * CEOTSymbol::Draw
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    HDC    hdc :
 *    RECT * lpRect :
 *    bool   bSmall :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CEOTSymbol::Draw(HDC hdc, RECT *lpRect, bool bSmall) const
{
    // if the icons already exist, Draw has been called before OR this symbol has a custom icon that as been
    // assigned the icons directly using SetIcon

    if((HICON)m_smartIconSmall == NULL)
    {
        m_smartIconSmall.Attach((HICON)::LoadImage(_Module.GetResourceInstance(),
                                                    MAKEINTRESOURCE(m_iconResource), IMAGE_ICON, 16, 16, 0));
    }

    if((HICON)m_smartIconLarge == NULL)
    {
        m_smartIconLarge.Attach((HICON)::LoadImage(_Module.GetResourceInstance(),
                                                    MAKEINTRESOURCE(m_iconResource), IMAGE_ICON, 32, 32, 0));
    }

	/*
	 * Preserve icon shape when BitBlitting it to a
	 * mirrored DC.
	 */
	DWORD dwLayout=0L;
	if ((dwLayout=GetLayout(hdc)) & LAYOUT_RTL)
	{
		SetLayout(hdc, dwLayout|LAYOUT_BITMAPORIENTATIONPRESERVED);
	}

    DrawIconEx(hdc, lpRect->left, lpRect->top, bSmall ? m_smartIconSmall : m_smartIconLarge,
               bSmall? 16 : 32, bSmall? 16 : 32, 0, NULL, DI_NORMAL);

	/*
	 * Restore the DC to its previous layout state.
	 */
	if (dwLayout & LAYOUT_RTL)
	{
		SetLayout(hdc, dwLayout);
	}
}


/*+-------------------------------------------------------------------------*
 *
 * CEOTSymbol::IsMatch
 *
 * PURPOSE: Checks to see whether str1 is one of the strings contained in the
 *          comma separated list str2.
 *
 * PARAMETERS:
 *    CStr & str1 :
 *    CStr & str2 :
 *
 * RETURNS:
 *    bool: true if str1 is contained in str2, else false.
 *
 *+-------------------------------------------------------------------------*/
bool
CEOTSymbol::IsMatch(CStr &str1, CStr &str2)
{
    // trim spaces off either end.
    str1.TrimLeft();
    str1.TrimRight();

    CStr strTemp;
    int length;
    while((length = str2.GetLength()) != 0 )
    {
        int index = str2.Find(TEXT(','));
        if(index!=-1)
        {
            strTemp = str2.Left(index); // index is the pos of the ',' so we're OK.
            str2 = str2.Right(length - index -1);
        }
        else
        {
            strTemp = str2;
            str2.Empty();
        }

        strTemp.TrimLeft();
        strTemp.TrimRight();
        // compare str1 and strTemp
        if( str1.CompareNoCase((LPCTSTR)strTemp)==0)
            return true;    // match
    }
    return false;
}

int
CEOTSymbol::FindMatchingSymbol(LPCTSTR szDescription) // finds a symbol matching the given description.
{
    CStr strDescription = szDescription;

    int iSelect = -1;
    for(int i = 0; i<NUM_SYMBOLS; i++)
    {
        CStr strDescTemp;
        int ID = s_rgEOTSymbol[i].GetID();
        strDescTemp.LoadString(_Module.GetResourceInstance(), ID); // get the string.
        if(IsMatch(strDescription, strDescTemp))
        {
            iSelect = i;  // perfect match
            break;
        }

        CStr strDescTemp2;
        int ID2 = s_rgEOTSymbol[i].GetIDSecondary();
        if(ID2)
            strDescTemp2.LoadString(_Module.GetResourceInstance(), ID2); // get the string.
        if(IsMatch(strDescription, strDescTemp2))
        {
            iSelect = i;  // imperfect match, keep trying.
        }
    }

    return iSelect;
}


//############################################################################
//############################################################################
//
//  Implementation of class CTaskSymbolDialog
//
//############################################################################
//############################################################################

CTaskSymbolDlg::CTaskSymbolDlg(CConsoleTask& rConsoleTask, bool bFindMatchingSymbol)
	:	m_ConsoleTask (rConsoleTask),
		m_bCustomIcon (rConsoleTask.HasCustomIcon())
{
    m_bFindMatchingSymbol = bFindMatchingSymbol;
}


LRESULT CTaskSymbolDlg::OnInitDialog(UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& handled)
{
    m_listGlyphs    = GetDlgItem (IDC_GLYPH_LIST);
	m_wndCustomIcon = GetDlgItem (IDC_CustomIcon);

    m_imageList.Create (16, 28, ILC_COLOR , 20, 10);
	m_listGlyphs.SetImageList((HIMAGELIST) m_imageList, LVSIL_NORMAL);
	
	int cxIconSpacing = s_cxIcon + s_cxIconGutter;
    m_listGlyphs.SetIconSpacing (cxIconSpacing, cxIconSpacing);

    int iSelect = 0;

    // insert all the items
    for(int i=0; i< NUM_SYMBOLS; i++)
    {
        LV_ITEM item;
        ZeroMemory(&item, sizeof(item));
        item.mask    = LVIF_PARAM;
        item.lParam  = i;


        if(s_rgEOTSymbol[i].GetValue()==m_ConsoleTask.GetSymbol())
        {
            iSelect    = i;
        }

        m_listGlyphs.InsertItem(&item);
    }

	/*
	 * check the appropriate radio button
	 */
	int nCheckedButton = (m_bCustomIcon) ? IDC_CustomIconRadio : IDC_MMCIconsRadio;
	CheckRadioButton (IDC_CustomIconRadio, IDC_MMCIconsRadio, nCheckedButton);
	SC scNoTrace = ScEnableControls (nCheckedButton);

	/*
	 * if this task has a custom icon, initialize the preview control
	 */
	if (m_bCustomIcon)
		m_wndCustomIcon.SetIcon (m_ConsoleTask.GetLargeCustomIcon());


    if(m_bFindMatchingSymbol) // a description string was passed in, use it to populate the page.
    {
        tstring strName = m_ConsoleTask.GetName();
        if(strName.length()>0)
            iSelect = CEOTSymbol::FindMatchingSymbol((LPCTSTR)strName.data());
    }


	/*
	 * select the icon for this task
	 */
    LV_ITEM item;
    ZeroMemory(&item, sizeof(item));
    item.iItem     = iSelect;
    item.mask      = LVIF_STATE;
    item.state     = LVIS_FOCUSED | LVIS_SELECTED;
    item.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
    m_listGlyphs.SetItem(&item);
    m_listGlyphs.EnsureVisible(iSelect, 0);

    return 0;
}


/*+-------------------------------------------------------------------------*
 * CTaskSymbolDlg::OnCtlColorStatic
 *
 * WM_CTLCOLORSTATIC handler for CTaskSymbolDlg.
 *--------------------------------------------------------------------------*/

LRESULT CTaskSymbolDlg::OnCtlColorStatic(UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	HBRUSH hbrRet = NULL;

	switch (::GetDlgCtrlID (((HWND) lParam)))
	{
		/*
		 * for the custom icon preview window and its well, if we're using a
		 * custom icon, return a COLOR_WINDOW brush so the static won't paint
		 * the background with COLOR_3DFACE
		 */
		case IDC_CustomIcon:
		case IDC_CustomIconWell:
			if (m_bCustomIcon)
				hbrRet = GetSysColorBrush (COLOR_WINDOW);
			break;
	}

	/*
	 * if we didn't supply a brush, let this message go through to DefWindowProc
	 */
	if (hbrRet == NULL)
		bHandled = false;

	return ((LPARAM) hbrRet);
}


/*+-------------------------------------------------------------------------*
 * CTaskSymbolDlg::OnIconSourceChanged
 *
 * BN_CLICKED handler for CTaskSymbolDlg.
 *--------------------------------------------------------------------------*/

LRESULT CTaskSymbolDlg::OnIconSourceChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
	m_bCustomIcon = (wID == IDC_CustomIconRadio);
	SC scNoTrace = ScEnableControls (wID);
	return (0);
}


/*+-------------------------------------------------------------------------*
 * CTaskSymbolDlg::ScEnableControls
 *
 * Enables the controls belonging to a particular radio button on the
 * symbol dialog
 *--------------------------------------------------------------------------*/

SC CTaskSymbolDlg::ScEnableControls (int id)
{
	DECLARE_SC (sc, _T("CTaskSymbolDlg::ScEnableControls"));

	/*
	 * validate input
	 */
	ASSERT ((id == IDC_CustomIconRadio) || (id == IDC_MMCIconsRadio));
	if (!  ((id == IDC_CustomIconRadio) || (id == IDC_MMCIconsRadio)))
		return (sc = E_INVALIDARG);

	/*
	 * controls to be enabled when "Custom Icon" radio button is selected
	 */
	static const int nCustomIconCtlIDs[] = {
		IDC_CustomIcon,
		IDC_CustomIconWell,
		IDB_SELECT_TASK_ICON,
		0	// terminator
	};

	/*
	 * controls to be enabled when "MMC Icons" radio button is selected
	 */
	static const int nMMCIconCtlIDs[] = {
        IDC_GLYPH_LIST,
        IDC_DESCRIPTION,
        IDC_DESCRIPTION2,
        IDC_DESCRIPTIONLabel,
        IDC_DESCRIPTION2Label,
		0	// terminator
	};

	const int* pnEnableIDs  = NULL;
	const int* pnDisableIDs = NULL;

	/*
	 * pick the right sets of controls to enable/disable
	 */
	if (id == IDC_CustomIconRadio)
	{
		pnEnableIDs  = nCustomIconCtlIDs;
		pnDisableIDs = nMMCIconCtlIDs;
	}
	else
	{
		pnEnableIDs  = nMMCIconCtlIDs;
		pnDisableIDs = nCustomIconCtlIDs;
	}

	/*
	 * enable/disable the controls
	 */
	for (int i = 0; pnEnableIDs[i] != 0; i++)
		::EnableWindow (GetDlgItem (pnEnableIDs[i]), true);

	for (int i = 0; pnDisableIDs[i] != 0; i++)
		::EnableWindow (GetDlgItem (pnDisableIDs[i]), false);

	return (sc);
}


LRESULT
CTaskSymbolDlg::OnSymbolChanged(int id, LPNMHDR pnmh, BOOL& bHandled )
{
    NMLISTVIEW* pnmlv = (NMLISTVIEW *) pnmh;
    if(! ((pnmlv->uNewState & LVNI_FOCUSED) && (pnmlv->iItem !=-1)) )
        return 0;

    int nItem = pnmlv->iItem;

    CStr strDescription;
    int ID = s_rgEOTSymbol[nItem].GetID();
    strDescription.LoadString(_Module.GetResourceInstance(), ID); // get the string.
    SetDlgItemText(IDC_DESCRIPTION, (LPCTSTR) strDescription);

    CStr strDescription2;
    int ID2 = s_rgEOTSymbol[nItem].GetIDSecondary();
    if(ID2)
        strDescription2.LoadString(_Module.GetResourceInstance(), ID2); // get the string.
    SetDlgItemText(IDC_DESCRIPTION2, (LPCTSTR) strDescription2);

    return 0;
}


LRESULT
CTaskSymbolDlg::OnCustomDraw(int id, LPNMHDR pnmh, BOOL& bHandled )
{
    NMCUSTOMDRAW* pnmcd = (NMCUSTOMDRAW *) pnmh;

    switch(pnmcd->dwDrawStage & ~CDDS_SUBITEM)
    {
		case CDDS_PREPAINT:         // the initial notification
			return CDRF_NOTIFYITEMDRAW;    // we want to know about each item's paint.
	
		case CDDS_ITEMPREPAINT:
			DrawItem(pnmcd);
			return CDRF_SKIPDEFAULT;      // we've drawn the whole item ourselves
	
		default:
			return 0;
    }
}

void
CTaskSymbolDlg::DrawItem(NMCUSTOMDRAW *pnmcd)
{
    DECLARE_SC(sc, TEXT("CTaskSymbolDlg::DrawItem"));

    int  nItem = pnmcd->dwItemSpec;
    HDC  &hdc  = pnmcd->hdc;

    LV_ITEM item;
    ZeroMemory(&item, sizeof(item));
    item.iItem = nItem;
    item.mask  = LVIF_STATE;
    item.stateMask = (UINT) -1; //get all the state bits.
    m_listGlyphs.GetItem(&item);


	/*
	 * get the icon rect for the item and offset it downward by the size
	 * of our border margin
	 */
    RECT rectIcon;
    m_listGlyphs.GetItemRect(nItem, &rectIcon, LVIR_ICON);
	OffsetRect (&rectIcon, 0, s_cxSelectionMargin);

	/*
	 * Make a slightly inflated copy the icon rectangle to draw in the
	 * selection color.  We inflate to make the selection stand out a little
	 * more for large icons.
	 */
	RECT rectBackground = rectIcon;
	InflateRect (&rectBackground, s_cxSelectionMargin, s_cxSelectionMargin);

    bool bWindowHasFocus = (GetFocus() == (HWND)m_listGlyphs);
    bool bSelected       = item.state & LVIS_SELECTED;
	bool bDisabled       = !m_listGlyphs.IsWindowEnabled();

    // Create the select rectangle or empty the rectangle.
	int nBackColorIndex = (bDisabled) ? COLOR_3DFACE	:
						  (bSelected) ? COLOR_HIGHLIGHT	:
										COLOR_WINDOW;

	FillRect (hdc, &rectBackground, (HBRUSH) LongToHandle(nBackColorIndex+1));

    // draw the symbol icon
    s_rgEOTSymbol[nItem].Draw(hdc, &rectIcon);

    if(bWindowHasFocus && bSelected)
        ::DrawFocusRect(hdc, &rectBackground);

    //ReleaseDC(hdc);   DONT release the DC!
}

BOOL
CTaskSymbolDlg::OnOK()
{
    int nItem = m_listGlyphs.GetSelectedIndex();

	/*
	 * make sure we've selected an item
	 */
    if (( m_bCustomIcon && (m_CustomIconLarge == NULL)) ||
		(!m_bCustomIcon && (nItem == -1)))
    {
        CStr strError;
        strError.LoadString(GetStringModule(), IDS_SYMBOL_REQUIRED);
        MessageBox(strError, NULL, MB_OK | MB_ICONEXCLAMATION);
        return (false);
    }

	if (m_bCustomIcon)
		m_ConsoleTask.SetCustomIcon(m_CustomIconSmall, m_CustomIconLarge);
	else
		m_ConsoleTask.SetSymbol(s_rgEOTSymbol[nItem].GetValue());

    return TRUE;
}

/*+-------------------------------------------------------------------------*
 *
 * CTaskSymbolDlg::OnSelectTaskIcon
 *
 * PURPOSE: Uses the shell-provided icon picker dialog to allow the user to select
 *          a custom icon for the console task.
 *
 * PARAMETERS:
 *    WORD  wNotifyCode :
 *    WORD  wID :
 *    HWND  hWndCtl :
 *    BOOL& bHandled :
 *
 * RETURNS:
 *    LRESULT
 *
 *+-------------------------------------------------------------------------*/
LRESULT
CTaskSymbolDlg::OnSelectTaskIcon(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    DECLARE_SC(sc, TEXT("CTaskSymbolDlg::OnSelectTaskIcon"));

	static CStr s_strCustomIconFile;
	static int  s_nIconIndex = 0;

    int nIconIndex = s_nIconIndex;
    TCHAR szIconFile[MAX_PATH];

	/*
	 * shouldn't get here unless we think we're using a custom icon
	 */
	ASSERT (m_bCustomIcon);

	/*
	 * reuse the last custom icon source; if it's not available,
	 * default to mmc.exe
	 */
	if (s_strCustomIconFile.IsEmpty())
	{
		LPTSTR pszCustomIconFile = s_strCustomIconFile.GetBuffer (MAX_PATH);
		sc = ScCheckPointers (pszCustomIconFile, E_OUTOFMEMORY);
		if (sc)
		{
			MMCErrorBox (sc);
			return (0);
		}

		GetModuleFileName (NULL, pszCustomIconFile, MAX_PATH);
		s_strCustomIconFile.ReleaseBuffer();
	}

    lstrcpy (szIconFile, s_strCustomIconFile);

    if (PickIconDlg (m_hWnd, szIconFile, countof (szIconFile), &nIconIndex))
    {
        TCHAR szIconFile2[MAX_PATH];
        ExpandEnvironmentStrings(szIconFile, szIconFile2, MAX_PATH);

		/*
		 * remember the user's selection for next time
		 */
		s_strCustomIconFile = szIconFile;
		s_nIconIndex        = nIconIndex;

        // need to extract and copy the icon rather than use LoadImage, because LoadImage uses a custom icon
        CSmartIcon smartIconTemp;

        smartIconTemp.Attach(::ExtractIcon (_Module.m_hInst, szIconFile2, nIconIndex));
        m_CustomIconSmall.Attach((HICON) ::CopyImage((HICON)smartIconTemp, IMAGE_ICON, 16, 16, LR_COPYFROMRESOURCE));
        m_CustomIconLarge.Attach((HICON) ::CopyImage((HICON)smartIconTemp, IMAGE_ICON, 32, 32, LR_COPYFROMRESOURCE));

		/*
		 * update the custom icon preview window
		 */
		m_wndCustomIcon.SetIcon (m_CustomIconLarge);
		m_wndCustomIcon.InvalidateRect (NULL);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\tasksymbol.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       tasksymbol.h
//
//  History: 17-Jan-2000 Vivekj added
//--------------------------------------------------------------------------

#ifndef __TASKSYMBOL_H_
#define __TASKSYMBOL_H_

#include "resource.h"       // main symbols
#include <atlctl.h>


/*+-------------------------------------------------------------------------*
 * class CProxyTaskSymbolEvents
 *
 *
 * PURPOSE: Event source implementation generated by ATL.
 *
 *+-------------------------------------------------------------------------*/
template <class T>
class CProxyTaskSymbolEvents : public IConnectionPointImpl<T, &DIID_TaskSymbolEvents, CComDynamicUnkArray>
{
    //Warning this class may be recreated by the wizard.
public:
    HRESULT Fire_Click()
    {
        CComVariant varResult;
        T* pT = static_cast<T*>(this);
        int nConnectionIndex;
        int nConnections = m_vec.GetSize();

        for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
        {
            pT->Lock();
            CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
            pT->Unlock();
            IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
            if (pDispatch != NULL)
            {
                VariantClear(&varResult);
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                pDispatch->Invoke(DISPID_CLICK, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
            }
        }
        return varResult.scode;

    }
};

/*+-------------------------------------------------------------------------*
 * class CTaskSymbol
 *
 *
 * PURPOSE:
 *
 *+-------------------------------------------------------------------------*/
class ATL_NO_VTABLE CTaskSymbol :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComControl<CTaskSymbol>,
    public IPersistStreamInitImpl<CTaskSymbol>,
    public IOleControlImpl<CTaskSymbol>,
    public IOleObjectImpl<CTaskSymbol>,
    public IOleInPlaceActiveObjectImpl<CTaskSymbol>,
    public IViewObjectExImpl<CTaskSymbol>,
    public IOleInPlaceObjectWindowlessImpl<CTaskSymbol>,
    public CComCoClass<CTaskSymbol, &CLSID_TaskSymbol>,
    public CProxyTaskSymbolEvents< CTaskSymbol >,
    public IConnectionPointContainerImpl<CTaskSymbol>,
	public IProvideClassInfo2Impl<&CLSID_TaskSymbol, &DIID_TaskSymbolEvents, &LIBID_NODEMGRLib>,
    public IPersistPropertyBagImpl<CTaskSymbol>,
    public IObjectSafetyImpl<CTaskSymbol, INTERFACESAFE_FOR_UNTRUSTED_CALLER |
                                          INTERFACESAFE_FOR_UNTRUSTED_DATA>
{
    typedef IObjectSafetyImpl<CTaskSymbol, INTERFACESAFE_FOR_UNTRUSTED_CALLER |INTERFACESAFE_FOR_UNTRUSTED_DATA> BCSafety;
public:
    CTaskSymbol();

DECLARE_MMC_CONTROL_REGISTRATION (
	g_szMmcndmgrDll,					// implementing DLL
    CLSID_TaskSymbol,               	// CLSID
    _T("TaskSymbol Class"),             // class name
    _T("Control.TaskSymbol.1"),         // ProgID
    _T("Control.TaskSymbol"),           // version-independent ProgID
    LIBID_NODEMGRLib,               	// LIBID
    _T("101"),                          // toolbox bitmap ID
    _T("1.0"))                          // version

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTaskSymbol)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(IViewObjectEx)
    COM_INTERFACE_ENTRY(IViewObject2)
    COM_INTERFACE_ENTRY(IViewObject)
    COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceObject)
    COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY(IOleControl)
    COM_INTERFACE_ENTRY(IOleObject)
    COM_INTERFACE_ENTRY(IPersistPropertyBag)
    COM_INTERFACE_ENTRY(IPersistStreamInit)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
    // Connection point container support
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CTaskSymbol)
    CONNECTION_POINT_ENTRY(DIID_TaskSymbolEvents)
END_CONNECTION_POINT_MAP()


BEGIN_PROP_MAP(CTaskSymbol)
    PROP_DATA_ENTRY("Small",           m_bSmall,          VT_UI4)
    PROP_DATA_ENTRY("ConsoleTaskID", m_dwConsoleTaskID, VT_UI4)
    // Example entries
    // PROP_ENTRY("Property Description", dispid, clsid)
    // PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_MSG_MAP(CTaskSymbol)
	MESSAGE_HANDLER(WM_LBUTTONDOWN, OnLButtonDown)
	MESSAGE_HANDLER(WM_SETCURSOR,   OnSetCursor)
    CHAIN_MSG_MAP(CComControl<CTaskSymbol>)
    DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);


// IViewObjectEx
    DECLARE_VIEW_STATUS(0)

public:
    HRESULT OnDraw(ATL_DRAWINFO& di);
	LRESULT OnLButtonDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnSetCursor(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

private:
    typedef std::wstring CString;
    UINT           m_dwConsoleTaskID;
    UINT           m_bSmall;

// Need to override the default IObjectSafetyImpl methods per KB article Q168371
public:
    STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, DWORD dwOptionSetMask,DWORD dwEnabledOptions) {return S_OK;}
};

#endif //__TASKSYMBOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\taskui.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:       taskui.h
 *
 *  Contents:   Interface file for console taskpad UI classes.
 *
 *  History:    29-Oct-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef TASKUI_H
#define TASKUI_H
#pragma once

#include "tstring.h"
#include "dlgs.h"
#include "task.h"
#include "cmenuinfo.h"


/*
 * forward declarations
 */
class CMTNode;
class CTaskpadGeneralPage;
class CTaskpadTasksPage;
class CTaskpadPropertySheet;
class CTaskpadOptionsDlg;
class CContextMenuVisitor;
class CMTBrowserCtrl;
class CConsoleExtendTaskPadImpl;
class CContextMenu;
class CConsoleTask;
class CTaskpadGroupPropertySheet;
class CTaskpadGroupGeneralPage;
class CConsoleView;

// property page classes
class CTaskNamePage;
class CTaskCmdLinePage;
class CTaskSymbolDlg;


#include <pshpack8.h>       // for Win64

// ATL does not allow chaining more than one class or member at a time. This works around that.
#define CHAIN_MSG_MAP_EX(theChainClass) \
    { \
        theChainClass::ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult); \
    }

//############################################################################
//############################################################################
//
//  class CBrowserCookie
//
// a class to store the Node's for each MTNode. Used by CMTBrowserCtrl
//############################################################################
//############################################################################
class CBrowserCookie
{
    CMTNode *           m_pMTNode;
    CNode *             m_pNode;

public:
                        CBrowserCookie();
                        CBrowserCookie(CMTNode *pMTNode, CNode *pNode);
    void                DeleteNode();

    CNode *             PNode() {return m_pNode;}
    CMTNode *           PMTNode() const   {ASSERT(m_pMTNode); return m_pMTNode;}
    void                SetNode(CNode *pNode);
    bool                operator < (const CBrowserCookie &rhs) const {return m_pMTNode < rhs.m_pMTNode;}
};


//############################################################################
//############################################################################
// inlines
//############################################################################
//############################################################################
inline CBrowserCookie::CBrowserCookie()
: m_pMTNode(NULL), m_pNode(NULL)
{}

inline CBrowserCookie::CBrowserCookie(CMTNode *pMTNode, CNode *pNode)
: m_pMTNode(pMTNode), m_pNode(pNode){}

inline void
CBrowserCookie::SetNode(CNode *pNode)
{
    ASSERT(!m_pNode);
    m_pNode = pNode;
}


class CBrowserCookieList : public std::list<CBrowserCookie>
{
public:
    ~CBrowserCookieList();
};

//############################################################################
//############################################################################
//
//  class CMTBrowserCtrl
//
//  PURPOSE: Implements a general purpose scope tree browser that enables a
//           user to browse down the master scope tree and select a node.
//
//  USAGE: Add an object of this class to your dialog, and construct it with
//         the ID of the tree control to use. Chain the object into the
//         message loop. If needed, subclass this class and override any
//         methods appropriately.
//
//############################################################################
//############################################################################

class CMTBrowserCtrl : public CWindowImpl<CMTBrowserCtrl, WTL::CTreeViewCtrlEx>
{
    typedef CWindowImpl<CMTBrowserCtrl, WTL::CTreeViewCtrlEx> BC;

public:
    typedef std::vector<CMTNode*>       CMTNodeCollection;

    struct InitData
    {
        InitData () :
            hwnd(NULL), pScopeTree(NULL), pmtnRoot(NULL), pmtnSelect(NULL)
        {}

        HWND                hwnd;
        CScopeTree*         pScopeTree;
        CMTNode*            pmtnRoot;
        CMTNode*            pmtnSelect;
        CMTNodeCollection   vpmtnExclude;
    };

public:
    // constructor /destructor
    CMTBrowserCtrl();
    ~CMTBrowserCtrl();

    BEGIN_MSG_MAP(CMTBrowserCtrl)
        REFLECTED_NOTIFY_CODE_HANDLER (TVN_ITEMEXPANDING, OnItemExpanding);
        //CHAIN_MSG_MAP(BC)
        DEFAULT_REFLECTION_HANDLER ()
    END_MSG_MAP();

    void        Initialize (const InitData& init);
    HTREEITEM   InsertItem (const CBrowserCookie &browserCookie, HTREEITEM hParent, HTREEITEM hInsertAfter);
    bool        SelectNode (CMTNode* pmtnSelect);

    CMTNode*        GetSelectedMTNode ()                    const;
    CBrowserCookie* CookieFromItem    (HTREEITEM hti)       const;
    CBrowserCookie* CookieFromItem    (const TV_ITEM* ptvi) const;
    CBrowserCookie* CookieFromLParam  (LPARAM lParam)       const;
    CMTNode*        MTNodeFromItem    (HTREEITEM hti)       const;
    CMTNode*        MTNodeFromItem    (const TV_ITEM* ptvi) const;

protected:
    LRESULT OnItemExpanding (int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    bool ExpandItem (const TV_ITEM& itemExpand);
    HTREEITEM FindChildItemByMTNode (HTREEITEM htiParent, const CMTNode* pmtnToFind);

private:
    // set this to non-zero to optimize access to m_vpmtnExclude
    enum { OptimizeExcludeList = 0 };

    // implementation
    int                 m_id;       // the ID of the tree control
    int                 ID()                       {return m_id;}

    CMTNodeCollection   m_vpmtnExclude;

    CScopeTree *        m_pScopeTree;
    CScopeTree *        PScopeTree()               {return m_pScopeTree;}
    CBrowserCookieList  m_browserCookieList;
    CBrowserCookieList *PBrowserCookieList()       {return &m_browserCookieList;}

    bool IsMTNodeExcluded (CMTNode* pmtn) const;
};


//############################################################################
//############################################################################
//
//  class CTempAMCView
//
//############################################################################
//############################################################################


class CTempAMCView
{
public:
    CTempAMCView() : m_pViewData(NULL)
    {}

    ~CTempAMCView()
    {
        Destroy();
    }

    CNode* Create (CConsoleFrame* pFrame, CNode* pRootNode);
    CNode* Create (CConsoleFrame* pFrame, CMTNode* pRootMTNode);
    CNode* Create (CConsoleFrame* pFrame, MTNODEID idRootNode);

    bool Destroy ()
    {
        if (m_pViewData == NULL)
            return (false);

        GetChildFrame().SendMessage (WM_CLOSE);
        m_pViewData = NULL;
        return (true);
    }

    CViewData* GetViewData() const
    {
        return (m_pViewData);
    }

    MMC_ATL::CWindow GetChildFrame() const
    {
        return ((m_pViewData != NULL) ? m_pViewData->GetChildFrame() : NULL);
    }

    CConsoleView* GetConsoleView() const
    {
        return ((m_pViewData != NULL) ? m_pViewData->GetConsoleView() : NULL);
    }

    MMC_ATL::CWindow GetListCtrl() const
    {
        return ((m_pViewData != NULL) ? m_pViewData->GetListCtrl() : NULL);
    }


private:
    CViewData*  m_pViewData;

};


//############################################################################
//############################################################################
//
//  class CMirrorListView
//
//  CMirrorListView is a list view control that will mirror the contents of
//  another list view control.
//
//############################################################################
//############################################################################

class CMirrorListView : public CWindowImpl<CMirrorListView, WTL::CListViewCtrl>
{
    typedef CMirrorListView                                     ThisClass;
    typedef CWindowImpl<CMirrorListView, WTL::CListViewCtrl>    BaseClass;

public:
    CMirrorListView();

    void AttachSource (HWND hwndList, HWND hwndSourceList);
    LPARAM GetSelectedItemData ();

    BEGIN_MSG_MAP(ThisClass)
        MESSAGE_HANDLER (LVM_GETITEM, ForwardMessage);
        REFLECTED_NOTIFY_CODE_HANDLER (LVN_GETDISPINFO,     OnGetDispInfo);
        REFLECTED_NOTIFY_CODE_HANDLER (LVN_ODCACHEHINT,     ForwardVirtualNotification);
        REFLECTED_NOTIFY_CODE_HANDLER (LVN_ODFINDITEM,      ForwardVirtualNotification);
        REFLECTED_NOTIFY_CODE_HANDLER (LVN_ODSTATECHANGED,  ForwardVirtualNotification);
        DEFAULT_REFLECTION_HANDLER ()
    END_MSG_MAP();

protected:
    LRESULT ForwardMessage (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnGetDispInfo              (int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT ForwardNotification        (int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT ForwardVirtualNotification (int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

private:
    void InsertColumns ();

private:
    WTL::CListViewCtrl  m_wndSourceList;
    bool                m_fVirtualSource;
};



//############################################################################
//############################################################################
//
//  class MMC:CEdit
//
//############################################################################
//############################################################################

namespace MMC
{

class CEdit : public WTL::CEdit
{
public:
    void Initialize(CWindow *pwndParent, int idEdit, int cchMax = -1, LPCTSTR sz = NULL);
    void Empty(LPCTSTR sz = _T(""))
    {
        SetSel(0, -1);
        ReplaceSel(sz);
    }

};

}; // namespace MMC

//############################################################################
//############################################################################
//
//  class CDialogBase
//
//############################################################################
//############################################################################

template<class T>
class CDialogBase : public CDialogImpl<T>
{
    typedef CDialogBase     ThisClass;
    typedef CDialogImpl<T>  BaseClass;

public:
    CDialogBase (bool fAutoCenter = false);

    BEGIN_MSG_MAP(ThisClass)
        MESSAGE_HANDLER    (WM_INITDIALOG,  OnInitDialog)
        COMMAND_ID_HANDLER (IDOK,           OnOK)
        COMMAND_ID_HANDLER (IDCANCEL,       OnCancel)
        REFLECT_NOTIFICATIONS()
    END_MSG_MAP()

    virtual LRESULT OnInitDialog (HWND hwndFocus, LPARAM lParam, BOOL& bHandled);
    virtual bool    OnApply () = 0;

public:
    BOOL EnableDlgItem (int idControl, bool fEnable);
    void CheckDlgItem (int idControl, int nCheck);
    tstring GetDlgItemText (int idControl);
    BOOL    SetDlgItemText (int idControl, tstring str);

// Generated message map functions
protected:
    LRESULT OnInitDialog     (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    virtual LRESULT OnOK     (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    virtual LRESULT OnCancel (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

private:
    bool    m_fAutoCenter;
};


//############################################################################
//############################################################################
//
//  class CMyComboBox
//
//############################################################################
//############################################################################

class CMyComboBox : public WTL::CComboBox
{
    typedef WTL::CComboBox BaseClass;

public:
    CMyComboBox (HWND hwnd = NULL) : BaseClass(hwnd)
    {}

    CMyComboBox& operator= (HWND hwnd)
    {
        m_hWnd = hwnd;
        return *this;
    }

    void    InsertStrings (const int rgStringIDs[], int cStringIDs);
    LPARAM  GetSelectedItemData () const;
    void    SelectItemByData (LPARAM lParam);
    int     FindItemByData (LPARAM lParam) const;
};



//############################################################################
//############################################################################
//
//  class CContextMenuVisitor
//
//  PURPOSE: Enables traversal of a tree of context menu items by
//           any class that derives from this one.
//
//############################################################################
//############################################################################
class CContextMenuVisitor
{
    SC                      ScTraverseContextMenu(CContextMenu *pContextMenu);

protected:
    SC                      ScTraverseContextMenu(CNode *pNodeTarget, CScopeTree *pCScopeTree,
                            BOOL fScopeItem, CNode *pNodeScope, LPARAM resultItemParam, bool bShowSaveList = false);
    virtual SC              ScOnVisitContextMenu(CMenuItem &menuItem) = 0;       // defined by derived class.

protected:
    virtual SC              ScShouldItemBeVisited(CMenuItem *pMenuItem, CContextMenuInfo *pContextInfo, /*out*/ bool &bVisitItem);       // should this item be visited?

    virtual ~CContextMenuVisitor() {};
};

//############################################################################
//############################################################################
//
//  class CTaskpadFrame
//
//############################################################################
//############################################################################

class CTaskpadFrame
{
protected:
    CConsoleTaskpad *               m_pConsoleTaskpad;
    bool                            m_fNew;                     // is this a new taskpad?
    CViewData *                     m_pViewData;
    LPARAM                          m_lCookie;
    bool                            m_fCookieValid;
    CNode *                         m_pNodeTarget;
    bool                            m_bTargetNodeSelected;      // has the target node been selected, if there is one

public:
    CScopeTree *                    PScopeTree()            {return dynamic_cast<CScopeTree *>(m_pViewData->GetScopeTree());}
    CNode *                         PNodeTarget()           {return m_pNodeTarget;}
    CConsoleTaskpad     *           PConsoleTaskpad()       {return m_pConsoleTaskpad;}
    bool                            FNew()                  {return m_fNew;}
    void                            SetNew(bool b)          {m_fNew = b;}
    LPARAM                          Cookie()                {return m_lCookie;}
    bool                            FCookieValid()          {return m_fCookieValid;}
    CViewData *                     PViewData()             {return m_pViewData;}
    void                            SetConsoleTaskpad(CConsoleTaskpad *pConsoleTaskpad)
                                                            {m_pConsoleTaskpad = pConsoleTaskpad;}
    bool                            FTargetNodeSelected()   {return m_bTargetNodeSelected;}
    void                            SetTargetNodeSelected(bool b) {m_bTargetNodeSelected = b;}

    CTaskpadFrame(CNode *pNodeTarget, CConsoleTaskpad*  pConsoleTaskpad, CViewData *pViewData,
                    bool fCookieValid, LPARAM lCookie);
    CTaskpadFrame(const CTaskpadFrame &rhs);
};


//############################################################################
//############################################################################
//
//  class CTaskpadStyle
//
//  PURPOSE: Stores details of a taskpad style. Used by CTaskpadGeneralPage
//
//############################################################################
//############################################################################

class CTaskpadStyle
{
private:
	/*
	 * NOTE:  this class has a custom assignment operator.  Be sure to
	 * update it if you add member variables to this class.
	 */
    ListSize                m_eSize;
    DWORD                   m_dwOrientation;
    int                     m_idsDescription;       // eg "Horizontal listpad with tasks underneath."
    int                     m_nPreviewBitmapID;
    mutable CStr            m_strDescription;
    mutable WTL::CBitmap    m_PreviewBitmap;

public:
    CTaskpadStyle (ListSize eSize, int idsDescription, int nPreviewBitmapID, DWORD dwOrientation);
    CTaskpadStyle (ListSize eSize, DWORD dwOrientation);
    CTaskpadStyle (const CTaskpadStyle& other);
    CTaskpadStyle& operator= (const CTaskpadStyle& other);

    bool operator== (const CTaskpadStyle& other) const
    {
        return ((m_dwOrientation == other.m_dwOrientation) &&
                ((m_eSize == other.m_eSize) || (m_eSize == eSize_None)));
    }

    const CStr& GetDescription() const;
    HBITMAP GetPreviewBitmap() const;
};

//############################################################################
//############################################################################
//
//  class CTaskpadFramePtr
//
//  PURPOSE: holds a pointer to the taskpad frame.
//           If multiple base classes inherit from this class, declare this
//           class to be a static base.
//
//############################################################################
//############################################################################
class CTaskpadFramePtr
{
public:
    CTaskpadFramePtr(CTaskpadFrame * pTaskpadFrame): m_pTaskpadFrame(pTaskpadFrame){}
protected:
    // attributes
    CTaskpadFrame *             PTaskpadFrame() const   { return (m_pTaskpadFrame); }
    CConsoleTaskpad *           PConsoleTaskpad()       { return PTaskpadFrame()->PConsoleTaskpad();}
private:
    CTaskpadFrame *             m_pTaskpadFrame;
};

//############################################################################
//############################################################################
//
//  class CTaskpadStyleBase
//
//############################################################################
//############################################################################
class CTaskpadStyleBase:public virtual CTaskpadFramePtr
{
    typedef CTaskpadStyleBase ThisClass;

    static CTaskpadStyle    s_rgTaskpadStyle[];

    WTL::CStatic            m_wndPreview;
    WTL::CComboBox          m_wndSizeCombo;

public:
    CTaskpadStyleBase(CTaskpadFrame * pTaskpadFrame);

protected:
    virtual HWND    HWnd()   =0;

    BEGIN_MSG_MAP(ThisClass)
        MESSAGE_HANDLER(WM_INITDIALOG,                              OnInitDialog)
        COMMAND_HANDLER(IDC_Style_VerticalList,     BN_CLICKED,     OnSettingChanged)
        COMMAND_HANDLER(IDC_Style_HorizontalList,   BN_CLICKED,     OnSettingChanged)
        COMMAND_HANDLER(IDC_Style_TasksOnly,        BN_CLICKED,     OnSettingChanged)
        COMMAND_HANDLER(IDC_Style_TooltipDesc,      BN_CLICKED,     OnSettingChanged)
        COMMAND_HANDLER(IDC_Style_TextDesc,         BN_CLICKED,     OnSettingChanged)
        COMMAND_HANDLER(IDC_Style_SizeCombo,        CBN_SELCHANGE,  OnSettingChanged)
    END_MSG_MAP();

    bool    Apply(); // must call this explicitly
    LRESULT OnInitDialog( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnSettingChanged(  WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );

    void    GetSettings (DWORD& dwOrientation, ListSize& eSize);
    void    UpdateControls ();
    int     FindStyle (DWORD dwOrientation, ListSize eSize);

};


//############################################################################
//############################################################################
//
//  class CTaskpadGeneralPage
//
//############################################################################
//############################################################################
class CTaskpadGeneralPage : public WTL::CPropertyPageImpl<CTaskpadGeneralPage>,
public CTaskpadStyleBase
{
    MMC::CEdit                  m_strName;
    MMC::CEdit                  m_strDescription;
    MMC::CEdit                  m_strTooltip;

public:
    typedef WTL::CPropertyPageImpl<CTaskpadGeneralPage> BC;
    typedef CTaskpadStyleBase BC2;
    enum { IDD = IDD_TASKPAD_GENERAL};

    //constructor/destructor
    CTaskpadGeneralPage(CTaskpadFrame * pTaskpadFrame);

public: // Notification handlers
    bool                        OnApply();

protected:
    BEGIN_MSG_MAP(CTaskpadGeneralPage)
        CHAIN_MSG_MAP_EX(BC2)           // This MUST be the first entry.
        MESSAGE_HANDLER(WM_INITDIALOG,                              OnInitDialog)
        CONTEXT_HELP_HANDLER()
        COMMAND_ID_HANDLER(IDC_Options,                             OnOptions)
        CHAIN_MSG_MAP(BC)
    END_MSG_MAP();

    IMPLEMENT_CONTEXT_HELP(g_aHelpIDs_IDD_TASKPAD_GENERAL);

    // for the base classes
    virtual HWND    HWnd()   {return m_hWnd;}

    LRESULT OnInitDialog( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnOptions       (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
};

//############################################################################
//############################################################################
//
//  class CTaskpadWizardWelcomePage
//
//############################################################################
//############################################################################
class CTaskpadWizardWelcomePage :
    public CWizard97WelcomeFinishPage<CTaskpadWizardWelcomePage>
{
    typedef CTaskpadWizardWelcomePage                               ThisClass;
    typedef CWizard97WelcomeFinishPage<CTaskpadWizardWelcomePage>   BaseClass;

public:
    // Construction/Destruction
    CTaskpadWizardWelcomePage() {}

public:
    // Dialog data
    enum { IDD = IDD_TASKPAD_WIZARD_WELCOME};

    // Implementation
protected:
    BEGIN_MSG_MAP( ThisClass );
        MESSAGE_HANDLER(WM_INITDIALOG,    OnInitDialog)
        CHAIN_MSG_MAP(BaseClass)
    END_MSG_MAP();

    bool    OnSetActive();
    bool    OnKillActive();

    LRESULT OnInitDialog ( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
};

//############################################################################
//############################################################################
//
//  class CTaskpadWizardFinishPage
//
//############################################################################
//############################################################################
class CTaskpadWizardFinishPage :
    public CWizard97WelcomeFinishPage<CTaskpadWizardFinishPage>
{
    typedef CTaskpadWizardFinishPage                                ThisClass;
    typedef CWizard97WelcomeFinishPage<CTaskpadWizardFinishPage>    BaseClass;

public:
    // Construction/Destruction
    CTaskpadWizardFinishPage(bool *pfStartTaskWizard)    {m_pfStartTaskWizard = pfStartTaskWizard;}

public:
    // Dialog data
    enum { IDD = IDD_TASKPAD_WIZARD_FINISH};

    BOOL OnSetActive();
    BOOL OnWizardFinish();

    // Implementation
protected:
    BEGIN_MSG_MAP( ThisClass );
        MESSAGE_HANDLER(WM_INITDIALOG,                  OnInitDialog)
        CHAIN_MSG_MAP(BaseClass)
    END_MSG_MAP();

    LRESULT OnInitDialog ( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
private:
    bool * m_pfStartTaskWizard;
};

//############################################################################
//############################################################################
//
//  class CTaskpadNamePage
//
//############################################################################
//############################################################################
class CTaskpadNamePage :
    public CWizard97InteriorPage<CTaskpadNamePage>,
    public virtual CTaskpadFramePtr
{
    typedef CTaskpadNamePage                        ThisClass;
    typedef CWizard97InteriorPage<CTaskpadNamePage> BaseClass;

public:
    // Construction/Destruction
    CTaskpadNamePage(CTaskpadFrame * pTaskpadFrame);

public:
    // Dialog data
    enum
    {
        IDD          = IDD_TASKPAD_WIZARD_NAME_PAGE,
        IDS_Title    = IDS_TaskpadWiz_NamePageTitle,
        IDS_Subtitle = IDS_TaskpadWiz_NamePageSubtitle,
    };

    BOOL OnSetActive();
    int  OnWizardNext();
    int  OnWizardBack();

    // Implementation
protected:
    BEGIN_MSG_MAP( ThisClass );
        CHAIN_MSG_MAP(BaseClass)
    END_MSG_MAP();

private:
    MMC::CEdit                  m_strName;
    MMC::CEdit                  m_strDescription;
};

//############################################################################
//############################################################################
//
//  class CTaskpadStylePage
//
//############################################################################
//############################################################################
class CTaskpadStylePage :
    public CWizard97InteriorPage<CTaskpadStylePage>,
    public CTaskpadStyleBase
{
    typedef CTaskpadStylePage                           ThisClass;
    typedef CWizard97InteriorPage<CTaskpadStylePage>    BaseClass;
    typedef CTaskpadStyleBase                           BC2;


public:
    // Construction/Destruction
    CTaskpadStylePage(CTaskpadFrame * pTaskpadFrame);

public:
    // Dialog data
    enum
    {
        IDD          = IDD_TASKPAD_WIZARD_STYLE_PAGE,
        IDS_Title    = IDS_TaskpadWiz_StylePageTitle,
        IDS_Subtitle = IDS_TaskpadWiz_StylePageSubtitle,
    };

    // Implementation
protected:
    BEGIN_MSG_MAP( ThisClass )
        CHAIN_MSG_MAP_EX(BC2)   // This must be the first entry.
        CHAIN_MSG_MAP(BaseClass)
    END_MSG_MAP();

    bool    OnSetActive();
    bool    OnKillActive();

    // for the base classes
    virtual HWND    HWnd()   {return m_hWnd;}
};

//############################################################################
//############################################################################
//
//  class CTaskpadNodetypeBase
//
//############################################################################
//############################################################################
class CTaskpadNodetypeBase : public virtual CTaskpadFramePtr
{
    typedef  CTaskpadNodetypeBase   ThisClass;
    typedef  CTaskpadFramePtr       BC;

    bool m_bApplytoNodetype;
    bool m_bSetDefaultForNodetype;

protected:
    virtual HWND    HWnd()   =0;

public:
    CTaskpadNodetypeBase(CTaskpadFrame *pTaskpadFrame);


    BEGIN_MSG_MAP(ThisClass)
        MESSAGE_HANDLER(WM_INITDIALOG,                              OnInitDialog)
        COMMAND_HANDLER (IDC_UseForSimilarNodes,    BN_CLICKED, OnUseForNodetype)
        COMMAND_HANDLER (IDC_DontUseForSimilarNodes,BN_CLICKED, OnDontUseForNodetype)
        COMMAND_HANDLER (IDC_SetDefaultForNodetype, BN_CLICKED, OnSetAsDefault)
    END_MSG_MAP();

    bool    OnApply();
    void    EnableControls();
    LRESULT OnInitDialog ( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnUseForNodetype    (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnDontUseForNodetype(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnSetAsDefault      (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
};

//############################################################################
//############################################################################
//
//  class CTaskpadNodetypePage
//
//############################################################################
//############################################################################
class CTaskpadNodetypePage :
    public CWizard97InteriorPage<CTaskpadNodetypePage>,
    public CTaskpadNodetypeBase
{
    typedef CTaskpadNodetypePage                        ThisClass;
    typedef CWizard97InteriorPage<CTaskpadNodetypePage> BaseClass;
    typedef CTaskpadNodetypeBase                        BC2;


protected:
    virtual HWND    HWnd()   {return m_hWnd;}

public:
    enum
    {
        IDD          = IDD_TASKPAD_WIZARD_NODETYPE_PAGE,
        IDS_Title    = IDS_TaskpadWiz_NodeTypePageTitle,
        IDS_Subtitle = IDS_TaskpadWiz_NodeTypePageSubtitle,
    };

    CTaskpadNodetypePage(CTaskpadFrame *pTaskpadFrame);

    BEGIN_MSG_MAP( ThisClass )
        CHAIN_MSG_MAP_EX(BC2)   // This must be the first entry.
        CHAIN_MSG_MAP(BaseClass)
    END_MSG_MAP();

    bool OnApply()      {return BC2::OnApply();}
};


//############################################################################
//############################################################################
//
//  class CTaskpadOptionsDlg
//
//############################################################################
//############################################################################

#include <pshpack8.h>       // for Win64

class CTaskpadOptionsDlg : public CDialogBase<CTaskpadOptionsDlg>,
public CTaskpadNodetypeBase
{
    typedef CTaskpadOptionsDlg              ThisClass;
    typedef CDialogBase<CTaskpadOptionsDlg> BaseClass;
    typedef CTaskpadNodetypeBase            BC4;

public:
    enum { IDD = IDD_TASKPAD_ADVANCED };

    //constructor/destructor
    CTaskpadOptionsDlg(CTaskpadFrame* pTaskpadFrame);
   ~CTaskpadOptionsDlg();

protected:
    BEGIN_MSG_MAP(ThisClass)
        CONTEXT_HELP_HANDLER()

        //CHAIN_MSG_MAP_EX(BC3)           // This MUST be the second entry.
        CHAIN_MSG_MAP   (BC4)           // This MUST be the third entry.
        CHAIN_MSG_MAP   (BaseClass)
    END_MSG_MAP();

    IMPLEMENT_CONTEXT_HELP(g_aHelpIDs_IDD_TASKPAD_ADVANCED);

    virtual HWND    HWnd()     {return m_hWnd;} // for the base classes.
    virtual LRESULT OnInitDialog   (HWND hwndFocus, LPARAM lParam, BOOL& bHandled);
    virtual bool    OnApply        ();
    void            EnableControls();
};

#include <poppack.h>        // for Win64


//############################################################################
//############################################################################
//
//  class CTaskPropertiesBase
//
//############################################################################
//############################################################################

typedef std::map<int, CConsoleTask>           IntToTaskMap;


class CTaskPropertiesBase :
    public CContextMenuVisitor, public virtual CTaskpadFramePtr
{
public:
    CTaskPropertiesBase(CTaskpadFrame * pTaskpadFrame, CConsoleTask & consoleTask, bool fNew);

protected:
    virtual IntToTaskMap &  GetTaskMap()   =0;
    virtual WTL::CListBox&  GetListBox()   =0;

protected:
    LRESULT OnCommandListSelChange  (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    virtual SC      ScOnVisitContextMenu(CMenuItem &menuItem);

    CScopeTree *    PScopeTree()    const       { return (PTaskpadFrame()->PScopeTree()); }
    CNode *         PNodeTarget()   const       { return (PTaskpadFrame()->PNodeTarget()); }
    bool            FCookieValid()  const       { return (PTaskpadFrame()->FCookieValid()); }
    LPARAM          Cookie()        const       { return (PTaskpadFrame()->Cookie()); }
    CConsoleTask &  ConsoleTask()   const       { return *m_pTask;}

private:
    CConsoleTask *          m_pTask;
    const bool              m_fNew;
    IContextMenuCallbackPtr m_spContextMenuCallback;
};

//############################################################################
//############################################################################
//
//  class CTasksListDialog
//
//############################################################################
//############################################################################
template <class T>
class CTasksListDialog : public WTL::CPropertyPageImpl<T> // do NOT inherit from CTaskpadFramePtr.
{
public:
    typedef CTasksListDialog                    ThisClass;
    typedef WTL::CPropertyPageImpl<T>           BC;
private:
    typedef CConsoleTaskpad::TaskIter TaskIter;
    CNode *                 PNodeTarget()           {return PTaskpadFrame()->PNodeTarget();}
    CConsoleTaskpad *       PConsoleTaskpad()       {return PTaskpadFrame()->PConsoleTaskpad();}

    std::map<int, TaskIter> m_mapTaskIterators;
    std::map<int, TaskIter> & MapTaskIterators(){return m_mapTaskIterators;}

    WTL::CButton            m_buttonNewTask;
    WTL::CButton            m_buttonRemoveTask;
    WTL::CButton            m_buttonModifyTask;
    WTL::CButton            m_buttonMoveUp;
    WTL::CButton            m_buttonMoveDown;

    WTL::CListViewCtrl      m_listboxTasks;
    WTL::CListViewCtrl *    PListBoxTasks()         {return &m_listboxTasks;}

    int                     GetCurSel();

    bool                    m_bDisplayProperties;   // should task properties be displayed?

    bool                    m_bNewTaskOnInit;       // display the NewTask dialog on init.
    bool                    FNewTaskOnInit()        {return m_bNewTaskOnInit;}
public:
    //constructor/destructor
    CTasksListDialog(CTaskpadFrame * pTaskpadFrame, bool bNewTaskOnInit, bool bDisplayProperties) ;

protected:
    BEGIN_MSG_MAP(CTasksPage)
        COMMAND_ID_HANDLER(IDC_NEW_TASK_BT, OnNewTask)
        COMMAND_ID_HANDLER(IDC_REMOVE_TASK, OnRemoveTask)
        COMMAND_ID_HANDLER(IDC_MODIFY,      OnTaskProperties)
        COMMAND_ID_HANDLER(IDC_MOVE_UP,     OnMoveUp)
        COMMAND_ID_HANDLER(IDC_MOVE_DOWN,   OnMoveDown)
        NOTIFY_HANDLER    (IDC_LIST_TASKS,  NM_CUSTOMDRAW,   OnCustomDraw)
        NOTIFY_HANDLER    (IDC_LIST_TASKS,  LVN_ITEMCHANGED, OnTaskChanged)
        NOTIFY_HANDLER    (IDC_LIST_TASKS,  NM_DBLCLK,       OnTaskProperties)
        MESSAGE_HANDLER   (WM_INITDIALOG,   OnInitDialog)
        CONTEXT_HELP_HANDLER()
        CHAIN_MSG_MAP(BC)
    END_MSG_MAP();

    IMPLEMENT_CONTEXT_HELP(g_aHelpIDs_IDD_TASKS);

    LRESULT OnInitDialog( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnNewTask();
    LRESULT OnNewTask(       WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled ) {return OnNewTask();}
    LRESULT OnRemoveTask(    WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnMoveUp(        WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnMoveDown(      WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnTaskProperties(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled ) {OnTaskProperties(); return 0;}
    LRESULT OnTaskProperties(int id, LPNMHDR pnmh, BOOL& bHandled )                     {OnTaskProperties(); return 0;}
    LRESULT OnCustomDraw(    int id, LPNMHDR pnmh, BOOL& bHandled );
    LRESULT OnTaskChanged(   int id, LPNMHDR pnmh, BOOL& bHandled );
    void    OnTaskProperties();


    // operations
    LRESULT DrawItem(NMCUSTOMDRAW *pnmcd);
    void    UpdateTaskListbox(TaskIter taskIteratorSelected);
    void    EnableButtons();
    void    EnableButtonAndCorrectFocus( WTL::CButton& button, BOOL bEnable );

private:
    CTaskpadFrame *             PTaskpadFrame()         { return m_pTaskpadFrame;}
    CTaskpadFrame *             m_pTaskpadFrame;
};


//############################################################################
//############################################################################
//
//  class CTasksPage
//
//############################################################################
//############################################################################

class CTasksPage : public CTasksListDialog<CTasksPage>, public virtual CTaskpadFramePtr
{
public:
    typedef CTasksListDialog<CTasksPage> BC;
    enum { IDD = IDD_TASKS};

    //constructor/destructor
    CTasksPage(CTaskpadFrame * pTaskpadFrame, bool bNewTaskOnInit)
    : BC(pTaskpadFrame, bNewTaskOnInit, true), CTaskpadFramePtr(pTaskpadFrame) {}
};


//############################################################################
//############################################################################
//
//  class CTaskWizardWelcomePage
//
//############################################################################
//############################################################################
class CTaskWizardWelcomePage :
    public CWizard97WelcomeFinishPage<CTaskWizardWelcomePage>,
    public virtual CTaskpadFramePtr
{
    typedef CTaskWizardWelcomePage                              ThisClass;
    typedef CWizard97WelcomeFinishPage<CTaskWizardWelcomePage>  BaseClass;

public:
    // Construction/Destruction
    CTaskWizardWelcomePage(CTaskpadFrame * pTaskpadFrame, CConsoleTask & consoleTask, bool fNew)
        : CTaskpadFramePtr(pTaskpadFrame){}

public:
    // Dialog data
    enum { IDD = IDD_TASK_WIZARD_WELCOME};

    // Implementation
protected:
    BEGIN_MSG_MAP( ThisClass );
        MESSAGE_HANDLER(WM_INITDIALOG,    OnInitDialog)
        CHAIN_MSG_MAP(BaseClass)
    END_MSG_MAP();

    bool    OnSetActive();
    bool    OnKillActive();

    LRESULT OnInitDialog ( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
private:
    // attributes
    CConsoleTask  * m_pConsoleTask;
    CConsoleTask  & ConsoleTask()   const       { return *m_pConsoleTask;}
};

//############################################################################
//############################################################################
//
//  class CTaskWizardFinishPage
//
//############################################################################
//############################################################################
class CTaskWizardFinishPage :
    public CTasksListDialog<CTaskWizardFinishPage>,
    public virtual CTaskpadFramePtr
{
    typedef CTaskWizardFinishPage                      ThisClass;
    typedef CTasksListDialog<CTaskWizardFinishPage>    BaseClass;

public:
    // Construction/Destruction
    CTaskWizardFinishPage(CTaskpadFrame * pTaskpadFrame,
                          CConsoleTask & consoleTask, bool *pfRestartTaskWizard);

public:
    // Dialog data
    enum { IDD = IDD_TASK_WIZARD_FINISH};

    BOOL OnWizardFinish();
    int  OnWizardBack();

    // Implementation
protected:
    BEGIN_MSG_MAP( ThisClass );
        MESSAGE_HANDLER(WM_INITDIALOG,                  OnInitDialog)
        CHAIN_MSG_MAP(BaseClass)
    END_MSG_MAP();
    BOOL    OnSetActive();
    LRESULT OnInitDialog ( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
private:
    CTaskpadFrame    m_taskpadFrameTemp;                   // for the list dialog
    CConsoleTaskpad  m_consoleTaskpadTemp;                 //
    bool *        m_pfRestartTaskWizard;
    // attributes
    CConsoleTask  * m_pConsoleTask;
    CConsoleTask  & ConsoleTask()   const       { return *m_pConsoleTask;}
};


//############################################################################
//############################################################################
//
//  class CTaskWizardTypePage
//
//############################################################################
//############################################################################
class CTaskWizardTypePage :
    public CWizard97InteriorPage<CTaskWizardTypePage>,
    public virtual CTaskpadFramePtr
{
    typedef CTaskWizardTypePage                         ThisClass;
    typedef CWizard97InteriorPage<CTaskWizardTypePage>  BaseClass;

public:
    // Construction/Destruction
    CTaskWizardTypePage(CTaskpadFrame * pTaskpadFrame, CConsoleTask & consoleTask, bool fNew);

public:
    // Dialog data
    enum
    {
        IDD          = IDD_TASK_WIZARD_TYPE_PAGE,
        IDS_Title    = IDS_TaskWiz_TypePageTitle,
        IDS_Subtitle = IDS_TaskWiz_TypePageSubtitle,
    };

    int  OnWizardNext();

    // Implementation
protected:
    BEGIN_MSG_MAP( ThisClass );
        MESSAGE_HANDLER(WM_INITDIALOG,       OnInitDialog)
        COMMAND_ID_HANDLER(IDC_MENU_TASK,    OnMenuTask)
        COMMAND_ID_HANDLER(IDC_CMDLINE_TASK, OnCmdLineTask)
        COMMAND_ID_HANDLER(IDC_NAVIGATION_TASK, OnFavoriteTask)
        CHAIN_MSG_MAP(BaseClass)
    END_MSG_MAP();

    LRESULT OnInitDialog ( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnMenuTask   ( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnCmdLineTask( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnFavoriteTask(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );

private:
    // attributes
    CConsoleTask  * m_pConsoleTask;
    CConsoleTask  & ConsoleTask()   const       { return *m_pConsoleTask;}
};


//############################################################################
//############################################################################
//
//  class CTaskNamePage
//
//############################################################################
//############################################################################
class CTaskNamePage : public WTL::CPropertyPageImpl<CTaskNamePage>,
public virtual CTaskpadFramePtr
{
    typedef CTaskNamePage                           ThisClass;
    typedef WTL::CPropertyPageImpl<CTaskNamePage>   BaseClass;

public:
    // Construction/Destruction
    CTaskNamePage(CTaskpadFrame * pTaskpadFrame, CConsoleTask & consoleTask, bool fNew);

public:
    // Dialog data
    enum { IDD     = IDD_TASK_PROPS_NAME_PAGE,
           IDD_WIZ = IDD_TASK_WIZARD_NAME_PAGE };

    BOOL OnSetActive();
    BOOL OnKillActive();
    int  OnWizardBack();
    int  OnWizardNext();

protected:
    BEGIN_MSG_MAP( ThisClass );
        CONTEXT_HELP_HANDLER()
        CHAIN_MSG_MAP(BaseClass)
    END_MSG_MAP();

    IMPLEMENT_CONTEXT_HELP(g_aHelpIDs_IDD_TASK_PROPS_NAME_PAGE);

private:
    // Implementation
    BOOL SetTaskName(bool fCheckIfOK);
    // attributes
    CConsoleTask  * m_pConsoleTask;
    CConsoleTask  & ConsoleTask()   const       { return *m_pConsoleTask;}

	bool m_fRunAsWizard;
};

class CTaskNameWizardPage: public CTaskNamePage
{
    typedef CTaskNamePage BC;
public:
    CTaskNameWizardPage(CTaskpadFrame * pTaskpadFrame, CConsoleTask & consoleTask, bool fNew) :
        CTaskpadFramePtr(pTaskpadFrame),
        BC(pTaskpadFrame, consoleTask, fNew)
    {
        m_psp.pszTemplate = MAKEINTRESOURCE(BC::IDD_WIZ);

        /*
         * Wizard97-style pages have titles, subtitles and header bitmaps
         */
        VERIFY (m_strTitle.   LoadString(GetStringModule(), IDS_TaskWiz_NamePageTitle));
        VERIFY (m_strSubtitle.LoadString(GetStringModule(), IDS_TaskWiz_NamePageSubtitle));

        m_psp.dwFlags          |= PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
        m_psp.pszHeaderTitle    = m_strTitle.data();
        m_psp.pszHeaderSubTitle = m_strSubtitle.data();
    }

private:
    tstring m_strTitle;
    tstring m_strSubtitle;
};

//############################################################################
//############################################################################
//
//  class CTaskWizardMenuPage
//
//############################################################################
//############################################################################
class CTaskWizardMenuPage :
    public CWizard97InteriorPage<CTaskWizardMenuPage>,
    public CTaskPropertiesBase
{
    typedef CTaskWizardMenuPage                         ThisClass;
    typedef CWizard97InteriorPage<CTaskWizardMenuPage>  BaseClass;
    typedef CTaskPropertiesBase                         BC2;

public:
    // Construction/Destruction
    CTaskWizardMenuPage(CTaskpadFrame * pTaskpadFrame, CConsoleTask & consoleTask, bool fNew);

public:
    // Dialog data
    enum
    {
        IDD          = IDD_TASK_WIZARD_MENU_PAGE,
        IDS_Title    = IDS_TaskWiz_MenuPageTitle,
        IDS_Subtitle = IDS_TaskWiz_MenuPageSubtitle,
    };

    BOOL OnSetActive();
    BOOL OnKillActive();
    int  OnWizardBack()  {return IDD_TASK_WIZARD_TYPE_PAGE;}
    int  OnWizardNext();

    // Implementation
protected:
    BEGIN_MSG_MAP( ThisClass );
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        COMMAND_HANDLER    (IDC_CommandList,           LBN_SELCHANGE,   BC2::OnCommandListSelChange)
        NOTIFY_HANDLER     (IDC_ScopeTree,             TVN_SELCHANGED,  OnScopeItemChanged)
        NOTIFY_HANDLER     (IDC_ResultList,            LVN_ITEMCHANGED, OnResultItemChanged)
        COMMAND_HANDLER    (IDC_TASK_SOURCE_COMBO,     CBN_SELCHANGE,   OnSettingChanged)
        CHAIN_MSG_MAP(BaseClass)
        REFLECT_NOTIFICATIONS()
    END_MSG_MAP();

    LRESULT OnInitDialog( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnScopeItemChanged (int id, LPNMHDR pnmh, BOOL& bHandled );
    LRESULT OnResultItemChanged(int id, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnSettingChanged(  WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    void    EnableWindows();

    virtual IntToTaskMap &  GetTaskMap()   { return m_TaskMap;}
    virtual WTL::CListBox&  GetListBox()   { return m_wndCommandListbox;}
    void    InitResultView (CNode* pRootNode);
    void    ShowWindow(HWND hWnd, bool bShowWindow);
    void    SelectFirstResultItem(bool bSelect = true);
    void    OnSettingsChanged();

private:
    struct _TaskSource
    {
        int              idsName;
        eConsoleTaskType type;
    };


    // attributes
    static _TaskSource              s_rgTaskSource[];
    IntToTaskMap                    m_TaskMap;
    WTL::CListBox                   m_wndCommandListbox;
    CMTBrowserCtrl                  m_wndScopeTree;
    WTL::CComboBox                  m_wndSourceCombo;

    CMirrorListView                 m_wndResultView;
    CTempAMCView                    m_MirroredView;
    CNode*                          m_pMirrorTargetNode;
};

//############################################################################
//############################################################################
//
//  class CTaskWizardFavoritePage
//
//############################################################################
//############################################################################
class CTaskWizardFavoritePage :
    public CWizard97InteriorPage<CTaskWizardFavoritePage>,
    public virtual CTaskpadFramePtr
{
    typedef CTaskWizardFavoritePage                         ThisClass;
    typedef CWizard97InteriorPage<CTaskWizardFavoritePage>  BaseClass;
    enum { IDC_FavoritesTree = 16384}; // this shouldn't occur on the page.

public:
    // Construction/Destruction
    CTaskWizardFavoritePage(CTaskpadFrame * pTaskpadFrame, CConsoleTask & consoleTask, bool fNew);
    ~CTaskWizardFavoritePage();

public:
    // Dialog data
    enum
    {
       IDD          = IDD_TASK_WIZARD_FAVORITE_PAGE,
       IDD_WIZ      = IDD_TASK_WIZARD_FAVORITE_PAGE,
       IDS_Title    = IDS_TaskWiz_FavoritePage_Title,
       IDS_Subtitle = IDS_TaskWiz_FavoritePage_Subtitle,
    };

    BOOL OnSetActive();
    BOOL OnKillActive();
    int  OnWizardBack();
    int  OnWizardNext();

    // Implementation
protected:
    BEGIN_MSG_MAP( ThisClass );
        MESSAGE_HANDLER(WM_INITDIALOG,              OnInitDialog)
        MESSAGE_HANDLER(MMC_MSG_FAVORITE_SELECTION, OnItemChanged)
        CHAIN_MSG_MAP(BaseClass)
        REFLECT_NOTIFICATIONS()
    END_MSG_MAP();

    LRESULT OnInitDialog  (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnItemChanged (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnSelChanged  (    int id, LPNMHDR pnmh, BOOL& bHandled );
    void    SetItemSelected(bool bItemSelected);

private:
    // attributes
    CConsoleTask  * m_pConsoleTask;
    CConsoleTask  & ConsoleTask()   const       { return *m_pConsoleTask;}

    bool m_bItemSelected;
};



//############################################################################
//############################################################################
//
//  class CTaskCmdLinePage
//
//############################################################################
//############################################################################
class CTaskCmdLinePage :
    public CWizard97InteriorPage<CTaskCmdLinePage>,
    public virtual CTaskpadFramePtr
{
    typedef CTaskCmdLinePage                        ThisClass;
    typedef CWizard97InteriorPage<CTaskCmdLinePage> BaseClass;

public:
    // Construction/Destruction
    CTaskCmdLinePage(CTaskpadFrame * pTaskpadFrame, CConsoleTask & consoleTask, bool fNew);
    ~CTaskCmdLinePage();

public:
    // Dialog data
    enum
    {
       IDD          = IDD_TASK_PROPS_CMDLINE_PAGE,
       IDD_WIZ      = IDD_TASK_WIZARD_CMDLINE_PAGE,
       IDS_Title    = IDS_TaskWiz_CmdLinePageTitle,
       IDS_Subtitle = IDS_TaskWiz_CmdLinePageSubtitle,
    };

    BOOL OnSetActive();
    BOOL OnKillActive();
    int  OnWizardBack()  {return IDD_TASK_WIZARD_TYPE_PAGE;}
    int  OnWizardNext();

    // Implementation
protected:
    BEGIN_MSG_MAP( ThisClass );
        COMMAND_ID_HANDLER (IDC_BrowseForCommand,                       OnBrowseForCommand)
        COMMAND_ID_HANDLER (IDC_BrowseForWorkingDir,                    OnBrowseForWorkingDir)
        COMMAND_ID_HANDLER (IDC_BrowseForArguments,                     OnBrowseForArguments)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        CONTEXT_HELP_HANDLER()
        CHAIN_MSG_MAP(BaseClass)
    END_MSG_MAP();

    IMPLEMENT_CONTEXT_HELP(g_aHelpIDs_IDD_TASK_PROPS_CMDLINE_PAGE);

    LRESULT OnInitDialog( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnBrowseForCommand      (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnBrowseForWorkingDir   (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnBrowseForArguments    (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

private:
    // attributes
    CConsoleTask  * m_pConsoleTask;
    CConsoleTask  & ConsoleTask()   const       { return *m_pConsoleTask;}
    WTL::CButton    m_wndRightArrowButton;
    HBITMAP         m_hBitmapRightArrow;
    CMyComboBox     m_wndWindowStateCombo;
    static const int const  s_rgidWindowStates[];

};

class CTaskCmdLineWizardPage: public CTaskCmdLinePage
{
    typedef CTaskCmdLinePage BC;
public:
    CTaskCmdLineWizardPage(CTaskpadFrame * pTaskpadFrame, CConsoleTask & consoleTask, bool fNew) :
        CTaskpadFramePtr(pTaskpadFrame),
        CTaskCmdLinePage(pTaskpadFrame, consoleTask, fNew)
    {
        m_psp.pszTemplate = MAKEINTRESOURCE(BC::IDD_WIZ);
    }
};

//############################################################################
//############################################################################
//
//  class CTaskPropertySheet
//
//############################################################################
//############################################################################
class CTaskPropertySheet : public WTL::CPropertySheet
{
public:
    CTaskPropertySheet(HWND hWndParent, CTaskpadFrame * pTaskpadFrame, CConsoleTask &consoleTask, bool fNew);
    CConsoleTask &  ConsoleTask()   {return m_consoleTask;}

private:
    CConsoleTask      m_consoleTask;   // the task that the wizard creates.
    CTaskNamePage     m_namePage;
    CTaskCmdLinePage  m_cmdLinePage;
    CTaskSymbolDlg    m_taskSymbolDialog;
};

//############################################################################
//############################################################################
//
//  class CTaskWizard       // similar to CTaskPropertySheet
//
//############################################################################
//############################################################################
class CTaskWizard
{
public:
    CTaskWizard()   {}

    HRESULT         Show(HWND hWndParent, CTaskpadFrame * pTaskpadFrame,
                          bool fNew, bool *pfRestartTaskWizard);
    CConsoleTask &  ConsoleTask()   {return m_consoleTask;}

private:
    CConsoleTask   m_consoleTask;   // the task that the wizard creates.
};

//############################################################################
//############################################################################
//
//  class CTaskpadPropertySheet
//
//############################################################################
//############################################################################

class CTaskpadPropertySheet : public WTL::CPropertySheet, public CTaskpadFrame
{
    typedef WTL::CPropertySheet BC;
public:
    enum eReason    // the reason for bringing up the sheet
    {
        eReason_PROPERTIES,
        eReason_NEWTASK
    };

private:
    // Attributes:

    CTaskpadGeneralPage             m_proppTaskpadGeneral;
    CTaskpadGeneralPage *           PproppTaskpadGeneral()      {return &m_proppTaskpadGeneral;}
    CTasksPage                      m_proppTasks;
    CTasksPage          *           PproppTasks()               {return &m_proppTasks;}


    bool                            m_fInsertNode;              // TRUE if the taskpad node should be inserted when the sheet is closed.
    bool                            FInsertNode()               {return m_fInsertNode;}

    bool                            m_fNew;                     // is this a new taskpad?
    bool                            FNew()                      {return m_fNew;}

    eReason                         m_eReason;                  // why was the sheet created?
    eReason                         Reason()                    {return m_eReason;}

    tstring                         m_strTitle;

public:
    //constructor/destructor
    CTaskpadPropertySheet(CNode *pNodeTarget, CConsoleTaskpad & rConsoleTaskPad, bool fNew,
                          LPARAM lparamSelectedNode, bool fLParamValid, CViewData *pViewData,
                          eReason reason = eReason_PROPERTIES);
    ~CTaskpadPropertySheet();

    // operations
    int                             DoModal();

};


//############################################################################
//############################################################################
//
//  class CTaskpadWizard       // similar to CTaskpadPropertySheet
//
//############################################################################
//############################################################################
class CTaskpadWizard : public CTaskpadFrame
{
    typedef CTaskpadFrame BC;
public:
    CTaskpadWizard(CNode *pNodeTarget, CConsoleTaskpad & rConsoleTaskPad, bool fNew,
                          LPARAM lparamSelectedNode, bool fLParamValid, CViewData *pViewData);

    HRESULT         Show(HWND hWndParent, bool *pfStartTaskWizard);
};


//############################################################################
//############################################################################
//
//  class CExtendPropSheetImpl
//
//############################################################################
//############################################################################
class CExtendPropSheetImpl :
    public IExtendPropertySheet2,
    public CComObjectRoot
{
public:
    void AddPage (HPROPSHEETPAGE hPage);
    void SetHeaderID (int nHeaderID);
    void SetWatermarkID (int nWatermarkID);

protected:
    BEGIN_COM_MAP(CExtendPropSheetImpl)
        COM_INTERFACE_ENTRY(IExtendPropertySheet)
        COM_INTERFACE_ENTRY(IExtendPropertySheet2)
    END_COM_MAP()

    // IExtendPropertySheet2
    STDMETHOD(CreatePropertyPages)(IPropertySheetCallback* pPSC, LONG_PTR handle, IDataObject* pDO);
    STDMETHOD(QueryPagesFor)(IDataObject* pDO);
    STDMETHOD(GetWatermarks)(IDataObject* pDO, HBITMAP* phbmWatermark, HBITMAP* phbmHeader, HPALETTE* phPal, BOOL* pbStretch);

private:
    std::vector<HANDLE> m_vPages;
    int					m_nWatermarkID;
    int					m_nHeaderID;
};

typedef CComObject<CExtendPropSheetImpl> CExtendPropSheet;


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//////////////              INLINES                 ///////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

namespace MMC
{
inline void
CEdit::Initialize(CWindow *pwndParent, int idEdit, int cchMax, LPCTSTR sz)
{
    Attach (pwndParent->GetDlgItem( idEdit ));
    ASSERT( m_hWnd != NULL );

    if(sz)
        SetWindowText( sz );

    if(cchMax >=0)
        SetLimitText( 128 );
}

tstring GetWindowText (HWND hwnd);

}; // namespace MMC


void PreventMFCAutoCenter (MMC_ATL::CWindow* pwnd);
HBITMAP LoadSysColorBitmap (HINSTANCE hInst, UINT id, bool bMono = false);

#include <poppack.h>

#endif /* TASKUI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\toolbar.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       toolbar.h
//
//--------------------------------------------------------------------------

#ifndef _TOOLBAR_H_
#define _TOOLBAR_H_

#include "toolbars.h"

#ifdef DBG
#include "ctrlbar.h"  // Needed for GetSnapinName()
#endif

#define  BUTTON_BITMAP_SIZE 16

//forward prototypes
class CControlbar;
class CMMCToolbarIntf;
class CToolbarNotify;

//+-------------------------------------------------------------------
//
//  class:     CToolbar
//
//  Purpose:   The IToolbar implementation this is owned
//             by the CControlbar and talks to the toolbar UI
//             using the CMMCToolbarIntf interface to manipulate the toolbar.
//             This object lives as long as snapin holds the COM reference.
//
//  History:    10-12-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
class CToolbar : public IToolbar,
                 public CComObjectRoot,
                 public CToolbarNotify

{
public:
    CToolbar();
    ~CToolbar();

private:
    CToolbar(const CToolbar& toolBar);
    BYTE GetTBStateFromMMCButtonState(MMC_BUTTON_STATE nState);

public:
// ATL COM map
BEGIN_COM_MAP(CToolbar)
    COM_INTERFACE_ENTRY(IToolbar)
END_COM_MAP()


// IToolbar methods
public:
    STDMETHOD(AddBitmap)(int nImages, HBITMAP hbmp, int cxSize, int cySize, COLORREF crMask );
    STDMETHOD(AddButtons)(int nButtons, LPMMCBUTTON lpButtons);
    STDMETHOD(InsertButton)(int nIndex, LPMMCBUTTON lpButton);
    STDMETHOD(DeleteButton)(int nIndex);
    STDMETHOD(GetButtonState)(int idCommand, MMC_BUTTON_STATE nState, BOOL* pState);
    STDMETHOD(SetButtonState)(int idCommand, MMC_BUTTON_STATE nState, BOOL bState);

// Internal methods
public:
    SC ScShow(BOOL bShow);
    SC ScAttach();
    SC ScDetach();

    void SetControlbar(CControlbar* pControlbar)
    {
        m_pControlbar = pControlbar;
    }

    CControlbar*  GetControlbar(void)
    {
        return m_pControlbar;
    }

    CMMCToolbarIntf*   GetMMCToolbarIntf()
    {
        return m_pToolbarIntf;
    }

    void SetMMCToolbarIntf(CMMCToolbarIntf* pToolbarIntf)
    {
        m_pToolbarIntf = pToolbarIntf;
    }

#ifdef DBG     // Debug information.
public:
    LPCTSTR GetSnapinName ()
    {
        if (m_pControlbar)
            return m_pControlbar->GetSnapinName();

        return _T("Unknown");
    }
#endif

public:
    // CToolbarNotify methods.
    virtual SC ScNotifyToolBarClick(HNODE hNode, bool bScope,
                                    LPARAM lParam, UINT nID);
    virtual SC ScAMCViewToolbarsBeingDestroyed();

private:
    CControlbar*     m_pControlbar;
    CMMCToolbarIntf* m_pToolbarIntf;

}; // class CToolbar

#endif  // _TOOLBAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\taskui.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:       taskui.cpp
 *
 *  Contents:   Implementation file for console taskpad UI classes.
 *
 *  History:    29-Oct-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "tasks.h"
#include "nodepath.h"
#include "oncmenu.h"
#include "scopndcb.h"
#include "rsltitem.h"
#include "conview.h"
#include "conframe.h"
#include "bitmap.h"
#include "util.h"

//############################################################################
//############################################################################
//
//  Implementation of class CTaskpadFrame
//
//############################################################################
//############################################################################
CTaskpadFrame::CTaskpadFrame(CNode *pNodeTarget, CConsoleTaskpad*  pConsoleTaskpad, CViewData *pViewData,
                bool fCookieValid, LPARAM lCookie)
{
    m_pNodeTarget       = pNodeTarget;
    m_pConsoleTaskpad   = pConsoleTaskpad;
    m_pViewData         = pViewData;
    m_fCookieValid      = fCookieValid;
    m_lCookie           = lCookie;

    if(pConsoleTaskpad)
        m_pConsoleTaskpad = pConsoleTaskpad;
    else
        m_pConsoleTaskpad = new CConsoleTaskpad();

    m_fNew = (pConsoleTaskpad == NULL);
    m_bTargetNodeSelected = (pNodeTarget != NULL);
}

CTaskpadFrame::CTaskpadFrame(const CTaskpadFrame &rhs)
{
    m_pNodeTarget         = rhs.m_pNodeTarget;
    m_pConsoleTaskpad     = rhs.m_pConsoleTaskpad;
    m_pViewData           = rhs.m_pViewData;
    m_fCookieValid        = rhs.m_fCookieValid;
    m_fNew                = rhs.m_fNew;
    m_lCookie             = rhs.m_lCookie;
    m_bTargetNodeSelected = rhs.m_bTargetNodeSelected;
}



//############################################################################
//############################################################################
//
//  Implementation of class CWizardPage
//
//############################################################################
//############################################################################
WTL::CFont CWizardPage::m_fontWelcome;

void CWizardPage::OnWelcomeSetActive(HWND hWnd)
{
    WTL::CPropertySheetWindow(::GetParent(hWnd)).SetWizardButtons (PSWIZB_NEXT);
}

void CWizardPage::OnWelcomeKillActive(HWND hWnd)
{
    WTL::CPropertySheetWindow(::GetParent(hWnd)).SetWizardButtons (PSWIZB_BACK | PSWIZB_NEXT);
}

void CWizardPage::InitFonts(HWND hWnd)
{
    if (m_fontWelcome.m_hFont != NULL)
        return;

    CWindow wnd = hWnd;

	WTL::CClientDC dc (wnd);
	if (dc.m_hDC == NULL)
		return;

    // set the correct font for the title.
    LOGFONT lf;
    WTL::CFont fontDefault = wnd.GetFont();
    fontDefault.GetLogFont(&lf);
    fontDefault.Detach();

    // set the correct font for the welcome line
    CStr strWelcomeFont;
    strWelcomeFont.LoadString(GetStringModule(), IDS_WizardTitleFont);
    CStr strWelcomeFontSize;
    strWelcomeFont.LoadString(GetStringModule(), IDS_WizardTitleFontSize);

    int nPointSize = _ttoi(strWelcomeFont);

    lf.lfWeight = FW_BOLD;
    lf.lfHeight = -MulDiv(nPointSize, dc.GetDeviceCaps(LOGPIXELSY), 72);
    lf.lfWidth  = 0;
    _tcscpy(lf.lfFaceName, strWelcomeFont);

    m_fontWelcome.CreateFontIndirect(&lf);
}

void CWizardPage::OnInitWelcomePage(HWND hDlg)
{
    InitFonts(hDlg);

    CWindow wndTitle = ::GetDlgItem (hDlg, IDC_WELCOME);
    wndTitle.SetFont (m_fontWelcome);
}

void CWizardPage::OnInitFinishPage(HWND hDlg)
{
    InitFonts(hDlg);

    CWindow wndTitle = ::GetDlgItem (hDlg, IDC_COMPLETING);
    wndTitle.SetFont (m_fontWelcome);

    WTL::CPropertySheetWindow(::GetParent(hDlg)).SetWizardButtons (PSWIZB_BACK | PSWIZB_FINISH);
}


//############################################################################
//############################################################################
//
//  Implementation of class CTaskpadPropertySheet
//
//############################################################################
//############################################################################


/* CTaskpadPropertySheet::CTaskpadPropertySheet
 *
 * PURPOSE:     Constructor
 *
 * PARAMETERS:  None
 *
 */
CTaskpadPropertySheet::CTaskpadPropertySheet(CNode *pNodeTarget, CConsoleTaskpad & rConsoleTaskpad, bool fNew,
                LPARAM lparamSelectedNode, bool fLParamValid, CViewData *pViewData, eReason reason):
    BC(),
    CTaskpadFrame(pNodeTarget, &rConsoleTaskpad, pViewData, fLParamValid,
                    lparamSelectedNode),
    m_proppTaskpadGeneral(this),
    m_proppTasks(this, (reason == eReason_NEWTASK)? true : false),
    m_fInsertNode(false),
    m_fNew(fNew),
    m_eReason(reason)
{
    // Add the property pages
    AddPage( m_proppTaskpadGeneral );

    if(!fNew)
        AddPage( m_proppTasks );

    if(Reason()==eReason_NEWTASK)
    {
        ASSERT(!fNew);
        SetActivePage(1); // the tasks page
    }

    /*
     * give the property sheet a title (the string must be a member so
     * it lives until DoModal, where it will actually get used.
     */
    m_strTitle = rConsoleTaskpad.GetName();

    /*
     * HACK:  We should be able to use
     *
     *      SetTitle (m_strTitle.data(), PSH_PROPTITLE);
     *
     * but ATL21 has a bogus assert (it asserts (lpszText == NULL)
     * instead of (lpszText != NULL).
     */
    //  SetTitle (m_strTitle.data(), PSH_PROPTITLE);
    m_psh.pszCaption = m_strTitle.data();
    m_psh.dwFlags   |= PSH_PROPTITLE;

    // hide the Apply button
    m_psh.dwFlags |= PSH_NOAPPLYNOW;
}


/*+-------------------------------------------------------------------------*
 * CTaskpadPropertySheet::~CTaskpadPropertySheet
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *
 * RETURNS:
 *
/*+-------------------------------------------------------------------------*/
CTaskpadPropertySheet::~CTaskpadPropertySheet()
{
}


/*+-------------------------------------------------------------------------*
 * CTaskpadPropertySheet::DoModal
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *
 * RETURNS:
 *      int
/*+-------------------------------------------------------------------------*/
int
CTaskpadPropertySheet::DoModal()
{
    // save the current taskpad in case the user wants to cancel.
    CConsoleTaskpad*pConsoleTaskpad = PConsoleTaskpad();
    CConsoleTaskpad consoleTaskpad = *PConsoleTaskpad();    // make a copy

    CTaskpadFrame::m_pConsoleTaskpad = &consoleTaskpad;     // make modifications on the copy.

    // call the base class method to make changes on the copy.
    int iResp = BC::DoModal();

    if(iResp == IDOK)
    {
        *pConsoleTaskpad = consoleTaskpad;                  // commit changes
        pConsoleTaskpad->SetDirty(true);
    }

    return iResp;
}



//############################################################################
//############################################################################
//
//  Implementation of class CTaskpadWizard
//
//############################################################################
//############################################################################

CTaskpadWizard::CTaskpadWizard(
    CNode*              pNodeTarget,
    CConsoleTaskpad&    rConsoleTaskPad,
    bool                fNew,
    LPARAM              lparamSelectedNode,
    bool                fLParamValid,
    CViewData*          pViewData)
    :
    BC(pNodeTarget, &rConsoleTaskPad, pViewData, fLParamValid, lparamSelectedNode)
{
    BC::SetNew(fNew);
};

HRESULT
CTaskpadWizard::Show(HWND hWndParent, bool *pfStartTaskWizard)
{
    USES_CONVERSION;

    *pfStartTaskWizard = false;

    // save the current taskpad in case the user wants to cancel.
    CConsoleTaskpad*pConsoleTaskpad = PConsoleTaskpad();
    CConsoleTaskpad consoleTaskpad = *PConsoleTaskpad();    // make a copy

    CTaskpadFrame::m_pConsoleTaskpad = &consoleTaskpad;     // make modifications on the copy.

    // create a property sheet
    IFramePrivatePtr spFrame;
    spFrame.CreateInstance(CLSID_NodeInit,
#if _MSC_VER >= 1100
                        NULL,
#endif
                        MMC_CLSCTX_INPROC);


    IPropertySheetProviderPtr pIPSP = spFrame;
    if (pIPSP == NULL)
        return S_FALSE;

    HRESULT hr = pIPSP->CreatePropertySheet (L"Cool :-)", FALSE, NULL, NULL,
                                             MMC_PSO_NEWWIZARDTYPE);

    CHECK_HRESULT(hr);
    RETURN_ON_FAIL(hr);

    // create property pages
    CTaskpadWizardWelcomePage   welcomePage;
    CTaskpadStylePage           stylePage(this);
    CTaskpadNodetypePage        nodetypePage(this);
    CTaskpadNamePage            namePage(this);
    CTaskpadWizardFinishPage    finishPage(pfStartTaskWizard);

    // create the pages we'll add in IExtendPropertySheet::CreatePropertyPages
    CExtendPropSheet* peps;
    hr = CExtendPropSheet::CreateInstance (&peps);
    CHECK_HRESULT(hr);
    RETURN_ON_FAIL(hr);

    /*
     * destroying this object will take care of releasing our ref on peps
     */
    IUnknownPtr spUnk = peps;
    ASSERT (spUnk != NULL);

	peps->SetWatermarkID (IDB_TASKPAD_WIZARD_WELCOME);
    peps->SetHeaderID    (IDB_TASKPAD_WIZARD_HEADER);

    peps->AddPage (welcomePage.Create());
    peps->AddPage (stylePage.Create());
    peps->AddPage (nodetypePage.Create());
    peps->AddPage (namePage.Create());
    peps->AddPage (finishPage.Create());


    hr = pIPSP->AddPrimaryPages(spUnk, FALSE, NULL, FALSE);
    CHECK_HRESULT(hr);

    hr = pIPSP->Show((LONG_PTR)hWndParent, 0);
    CHECK_HRESULT(hr);

    if(hr==S_OK)
    {
        // need to do this explicitly - wizards don't get an OnApply message. Bummer.
        nodetypePage.OnApply();

        *pConsoleTaskpad = consoleTaskpad;                  // commit changes
        pConsoleTaskpad->SetDirty(true);
    }

    return hr;
}



//############################################################################
//############################################################################
//
//  Implementation of class CExtendPropSheetImpl
//
//############################################################################
//############################################################################


/*+-------------------------------------------------------------------------*
 * CPropertySheetInserter
 *
 * Simple output iterator that will add pages to an MMC property sheet
 * by way of IPropertySheetCallback.
 *--------------------------------------------------------------------------*/

class CPropertySheetInserter : std::iterator<std::output_iterator_tag, void, void>
{
public:
    CPropertySheetInserter (IPropertySheetCallback* pPropSheetCallback) :
        m_spPropSheetCallback (pPropSheetCallback)
    {}

    CPropertySheetInserter& operator=(HANDLE hPage)
    {
        m_spPropSheetCallback->AddPage ((HPROPSHEETPAGE) hPage);
        return (*this);
    }

    CPropertySheetInserter& operator*()
        { return (*this); }
    CPropertySheetInserter& operator++()
        { return (*this); }
    CPropertySheetInserter operator++(int)
        { return (*this); }

protected:
    IPropertySheetCallbackPtr   m_spPropSheetCallback;
};


/*+-------------------------------------------------------------------------*
 * CExtendPropSheetImpl::AddPage
 *
 *
 *--------------------------------------------------------------------------*/

void CExtendPropSheetImpl::AddPage (HPROPSHEETPAGE hPage)
{
    m_vPages.push_back ((HANDLE) hPage);
}


/*+-------------------------------------------------------------------------*
 * CExtendPropSheetImpl::SetHeaderID
 *
 *
 *--------------------------------------------------------------------------*/

void CExtendPropSheetImpl::SetHeaderID (int nHeaderID)
{
	m_nHeaderID = nHeaderID;
}


/*+-------------------------------------------------------------------------*
 * CExtendPropSheetImpl::SetWatermarkID
 *
 *
 *--------------------------------------------------------------------------*/

void CExtendPropSheetImpl::SetWatermarkID (int nWatermarkID)
{
	m_nWatermarkID = nWatermarkID;
}


/*+-------------------------------------------------------------------------*
 * CExtendPropSheetImpl::CreatePropertyPages
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CExtendPropSheetImpl::CreatePropertyPages (IPropertySheetCallback* pPSC, LONG_PTR handle, IDataObject* pDO)
{
    std::copy (m_vPages.begin(), m_vPages.end(), CPropertySheetInserter(pPSC));
    return (S_OK);
}


/*+-------------------------------------------------------------------------*
 * CExtendPropSheetImpl::QueryPagesFor
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CExtendPropSheetImpl::QueryPagesFor (IDataObject* pDO)
{
    return (S_OK);
}


/*+-------------------------------------------------------------------------*
 * CExtendPropSheetImpl::GetWatermarks
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CExtendPropSheetImpl::GetWatermarks (IDataObject* pDO, HBITMAP* phbmWatermark, HBITMAP* phbmHeader, HPALETTE* phPal, BOOL* pbStretch)
{
    *phbmWatermark = (m_nWatermarkID)
						? LoadBitmap (_Module.GetResourceInstance(),
									  MAKEINTRESOURCE (m_nWatermarkID))
						: NULL;
	ASSERT ((m_nWatermarkID == 0) || (*phbmWatermark != NULL));

    *phbmHeader    = (m_nHeaderID)
						? LoadBitmap (_Module.GetResourceInstance(),
									  MAKEINTRESOURCE (m_nHeaderID))
						: NULL;
	ASSERT ((m_nHeaderID == 0) || (*phbmHeader != NULL));

    *phPal         = NULL;
    *pbStretch     = false;

    return (S_OK);
}



//############################################################################
//############################################################################
//
//  Implementation of class CTaskpadNamePage
//
//############################################################################
//############################################################################
CTaskpadNamePage::CTaskpadNamePage(CTaskpadFrame * pTaskpadFrame)
    :   CTaskpadFramePtr(pTaskpadFrame)
{
}

BOOL
CTaskpadNamePage::OnSetActive()
{
    // Set the correct wizard buttons.
    WTL::CPropertySheetWindow(::GetParent(m_hWnd)).SetWizardButtons (PSWIZB_BACK | PSWIZB_NEXT);

    m_strName.       Initialize (this, IDC_TASKPAD_TITLE,      -1, PConsoleTaskpad()->GetName().data());
    m_strDescription.Initialize (this, IDC_TASKPAD_DESCRIPTION,-1, PConsoleTaskpad()->GetDescription().data());
    return true;
}


int
CTaskpadNamePage::OnWizardNext()
{
    tstring strName = MMC::GetWindowText (m_strName);

    if (strName.empty())
    {
        CStr strTitle;
        strTitle.LoadString(GetStringModule(), IDS_TASKPAD_NAME_REQUIRED_ERROR);
        MessageBox(strTitle, NULL, MB_OK | MB_ICONEXCLAMATION);
        return -1;
    }

    tstring strDescription = MMC::GetWindowText (m_strDescription);

    CConsoleTaskpad* pTaskpad = PConsoleTaskpad();

    pTaskpad->SetName        (strName);
    pTaskpad->SetDescription (strDescription);

    return 0;
}

int
CTaskpadNamePage::OnWizardBack()
{
    return 0;
}

//############################################################################
//############################################################################
//
//  Implementation of class CTaskpadWizardWelcomePage
//
//############################################################################
//############################################################################
LRESULT CTaskpadWizardWelcomePage::OnInitDialog ( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    CWizardPage::OnInitWelcomePage(m_hWnd); // set up the correct title font
    return 0;
}

bool
CTaskpadWizardWelcomePage::OnSetActive()
{
    CWizardPage::OnWelcomeSetActive(m_hWnd);
    return true;
}

bool
CTaskpadWizardWelcomePage::OnKillActive()
{
    CWizardPage::OnWelcomeKillActive(m_hWnd);
    return true;
}

//############################################################################
//############################################################################
//
//  Implementation of class CTaskpadWizardFinishPage
//
//############################################################################
//############################################################################
LRESULT CTaskpadWizardFinishPage::OnInitDialog ( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    CWizardPage::OnInitFinishPage(m_hWnd); // set up the correct title font
    CheckDlgButton(IDC_START_TASK_WIZARD, BST_CHECKED);
    return 0;
}

BOOL
CTaskpadWizardFinishPage::OnSetActive()
{
    // Set the correct wizard buttons.
    WTL::CPropertySheetWindow(::GetParent(m_hWnd)).SetWizardButtons (PSWIZB_BACK | PSWIZB_FINISH);
    return true;
}

BOOL
CTaskpadWizardFinishPage::OnWizardFinish()
{
    *m_pfStartTaskWizard = (IsDlgButtonChecked(IDC_START_TASK_WIZARD)==BST_CHECKED);
    return TRUE;
}

//############################################################################
//############################################################################
//
//  Implementation of class CTaskpadStyle
//
//############################################################################
//############################################################################
CTaskpadStyle::CTaskpadStyle (
    ListSize    eSize,
    int         idsDescription,
    int         nPreviewBitmapID,
    DWORD       dwOrientation)
:
m_eSize            (eSize),
m_idsDescription   (idsDescription),
m_nPreviewBitmapID (nPreviewBitmapID),
m_dwOrientation    (dwOrientation)
{
}

CTaskpadStyle::CTaskpadStyle (
    ListSize    eSize,
    DWORD       dwOrientation)
:
m_eSize            (eSize),
m_idsDescription   (0),
m_nPreviewBitmapID (0),
m_dwOrientation    (dwOrientation)
{
}

CTaskpadStyle::CTaskpadStyle (const CTaskpadStyle& other)
{
	*this = other;
}


/*+-------------------------------------------------------------------------*
 * CTaskpadStyle::operator=
 *
 * Custom assignment operator for CTaskpadStyle that does a deep copy of
 * its contained WTL::CBitmap.
 *--------------------------------------------------------------------------*/

CTaskpadStyle& CTaskpadStyle::operator= (const CTaskpadStyle& other)
{
	if (this != &other)
	{
		m_eSize            = other.m_eSize;
		m_idsDescription   = other.m_idsDescription;
		m_nPreviewBitmapID = other.m_nPreviewBitmapID;
		m_dwOrientation    = other.m_dwOrientation;
		m_strDescription   = other.m_strDescription;

		/*
		 * WTL::CBitmap does a shallow copy of the bitmap.  We need to
		 * do a deep copy here so (*this) and (other) don't both
		 * DeleteObject the same bitmap.
		 */
		if (!m_PreviewBitmap.IsNull())
			m_PreviewBitmap.DeleteObject();

		m_PreviewBitmap = CopyBitmap (other.m_PreviewBitmap);
	}

	return (*this);
}


//############################################################################
//############################################################################
//
//  Implementation of class CTaskpadStyleBase
//
//############################################################################
//############################################################################




// static variables
CTaskpadStyle
CTaskpadStyleBase::s_rgTaskpadStyle[] =
{
    //             Size                         Description                  Bitmap                     dwOrientation
    CTaskpadStyle (eSize_Small,  IDS_TPSTYLE_HORZ_DESCR,      IDB_TPPreview_HorzSml,     TVO_HORIZONTAL),
    CTaskpadStyle (eSize_Medium, IDS_TPSTYLE_HORZ_DESCR,      IDB_TPPreview_HorzMed,     TVO_HORIZONTAL),
    CTaskpadStyle (eSize_Large,  IDS_TPSTYLE_HORZ_DESCR,      IDB_TPPreview_HorzLrg,     TVO_HORIZONTAL),
    CTaskpadStyle (eSize_Small,  IDS_TPSTYLE_HORZ_DESCR,      IDB_TPPreview_HorzSmlD,    TVO_HORIZONTAL | TVO_DESCRIPTIONS_AS_TEXT),
    CTaskpadStyle (eSize_Medium, IDS_TPSTYLE_HORZ_DESCR,      IDB_TPPreview_HorzMedD,    TVO_HORIZONTAL | TVO_DESCRIPTIONS_AS_TEXT),
    CTaskpadStyle (eSize_Large,  IDS_TPSTYLE_HORZ_DESCR,      IDB_TPPreview_HorzLrgD,    TVO_HORIZONTAL | TVO_DESCRIPTIONS_AS_TEXT),
    CTaskpadStyle (eSize_Small,  IDS_TPSTYLE_VERT_DESCR,      IDB_TPPreview_VertSml,     TVO_VERTICAL  ),
    CTaskpadStyle (eSize_Medium, IDS_TPSTYLE_VERT_DESCR,      IDB_TPPreview_VertMed,     TVO_VERTICAL  ),
    CTaskpadStyle (eSize_Large,  IDS_TPSTYLE_VERT_DESCR,      IDB_TPPreview_VertLrg,     TVO_VERTICAL  ),
    CTaskpadStyle (eSize_Small,  IDS_TPSTYLE_VERT_DESCR,      IDB_TPPreview_VertSmlD,    TVO_VERTICAL   | TVO_DESCRIPTIONS_AS_TEXT),
    CTaskpadStyle (eSize_Medium, IDS_TPSTYLE_VERT_DESCR,      IDB_TPPreview_VertMedD,    TVO_VERTICAL   | TVO_DESCRIPTIONS_AS_TEXT),
    CTaskpadStyle (eSize_Large,  IDS_TPSTYLE_VERT_DESCR,      IDB_TPPreview_VertLrgD,    TVO_VERTICAL   | TVO_DESCRIPTIONS_AS_TEXT),
    CTaskpadStyle (eSize_None,    IDS_TPSTYLE_NOLIST_DESCR,    IDB_TPPreview_Tasks,       TVO_NO_RESULTS),
    CTaskpadStyle (eSize_None,    IDS_TPSTYLE_NOLIST_DESCR,    IDB_TPPreview_TasksD,      TVO_NO_RESULTS | TVO_DESCRIPTIONS_AS_TEXT),
};

CTaskpadStyleBase::CTaskpadStyleBase(CTaskpadFrame * pTaskpadFrame) :
    CTaskpadFramePtr(pTaskpadFrame)
{
}

LRESULT
CTaskpadStyleBase::OnInitDialog( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    CWindow wndDlg = HWnd();

    m_wndPreview = wndDlg.GetDlgItem (IDC_TaskpadPreview);

    /*
     * make sure the taskpad's size is valid (bias to large list)
     */
    ListSize eSize =  PConsoleTaskpad()->GetListSize();

    if ((eSize != eSize_Small) &&
        (eSize != eSize_Medium))
        eSize = eSize_Large;

    ASSERT ((eSize == eSize_Small) ||
            (eSize == eSize_Large) ||
            (eSize == eSize_Medium));


    /*
     * prime the combo box
     */
    m_wndSizeCombo = wndDlg.GetDlgItem (IDC_Style_SizeCombo);

    static const struct {
        ListSize eSize;
        int                     nTextID;
    } ComboData[] = {
        { eSize_Small,   IDS_Small  },
        { eSize_Medium,  IDS_Medium },
        { eSize_Large,   IDS_Large  },
    };

    for (int i = 0; i < countof (ComboData); i++)
    {
        CStr str;
        VERIFY (str.LoadString(GetStringModule(), ComboData[i].nTextID));
        VERIFY (m_wndSizeCombo.InsertString (-1, str) == i);
        m_wndSizeCombo.SetItemData (i, ComboData[i].eSize);

        if (eSize == ComboData[i].eSize)
            m_wndSizeCombo.SetCurSel (i);
    }

    /*
     * make sure something is selected
     */
    ASSERT (m_wndSizeCombo.GetCurSel() != CB_ERR);


    /*
     * prime the radio buttons
     */
    int nID;

    DWORD dwOrientation = PConsoleTaskpad()->GetOrientation();

    nID = (dwOrientation & TVO_VERTICAL)    ? IDC_Style_VerticalList    :
          (dwOrientation & TVO_HORIZONTAL)  ? IDC_Style_HorizontalList  :
                                              IDC_Style_TasksOnly;
    CheckRadioButton (HWnd(), IDC_Style_VerticalList, IDC_Style_TasksOnly, nID);

    nID = (dwOrientation & TVO_DESCRIPTIONS_AS_TEXT) ? IDC_Style_TextDesc  :
                                                       IDC_Style_TooltipDesc;
    CheckRadioButton (HWnd(), IDC_Style_TooltipDesc, IDC_Style_TextDesc, nID);

    ASSERT (s_rgTaskpadStyle[FindStyle (dwOrientation, eSize)] ==
                                        CTaskpadStyle (eSize, dwOrientation));


    // prime the check box
    bool bReplacesDefaultView = PConsoleTaskpad()->FReplacesDefaultView();
    ::SendDlgItemMessage(HWnd(), IDC_Style_HideNormalTab,    BM_SETCHECK, (WPARAM) bReplacesDefaultView  ? BST_CHECKED : BST_UNCHECKED,  0);


    /*
     * update the preview and description
     */
    UpdateControls ();

    return 0;
}

LRESULT
CTaskpadStyleBase::OnSettingChanged(  WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    UpdateControls ();
    return 0;
}


/*+-------------------------------------------------------------------------*
 * CTaskpadStyleBase::UpdateControls
 *
 *
 *--------------------------------------------------------------------------*/

void CTaskpadStyleBase::UpdateControls ()
{
    DWORD                   dwOrientation;
    ListSize eSize;
    GetSettings (dwOrientation, eSize);

    /*
     * find the style entry that matches the dialog settings
     */
    int nStyle = FindStyle (dwOrientation, eSize);

    /*
     * update the preview bitmap
     */
    m_wndPreview.SetBitmap (s_rgTaskpadStyle[nStyle].GetPreviewBitmap());

    /*
     * update the description text
     */
    SetDlgItemText (HWnd(), IDC_STYLE_DESCRIPTION,
                    s_rgTaskpadStyle[nStyle].GetDescription());

    /*
     * disable the size combo for "Tasks only" taskpads
     */
    m_wndSizeCombo.EnableWindow (!(dwOrientation & TVO_NO_RESULTS));
}


/*+-------------------------------------------------------------------------*
 * CTaskpadStyleBase::FindStyle
 *
 * Returns the index of the CTaskpadStyle entry matching the given size
 * and orientation.
 *--------------------------------------------------------------------------*/

int CTaskpadStyleBase::FindStyle (DWORD dwOrientation, ListSize eSize)
{
    CTaskpadStyle tps(eSize, dwOrientation);

    for (int i = 0; i < countof (s_rgTaskpadStyle); i++)
    {
        if (s_rgTaskpadStyle[i] == tps)
            break;
    }

    ASSERT (i < countof (s_rgTaskpadStyle));
    return (i);
}


/*+-------------------------------------------------------------------------*
 * CTaskpadStyleBase::Apply
 *
 *
 *--------------------------------------------------------------------------*/

bool CTaskpadStyleBase::Apply()
{
    DWORD                   dwOrientation;
    ListSize eSize;
    GetSettings (dwOrientation, eSize);

    // set the "replaces default view" flag.
    CWindow wnd = HWnd();
    bool bReplacesDefaultView = wnd.IsDlgButtonChecked (IDC_Style_HideNormalTab);
    PConsoleTaskpad()->SetReplacesDefaultView(bReplacesDefaultView);

    PConsoleTaskpad()->SetOrientation   (dwOrientation);
    PConsoleTaskpad()->SetListSize(eSize);

    return true;
}



/*+-------------------------------------------------------------------------*
 * CTaskpadStyleBase::GetSettings
 *
 * Returns the orientation and size presently selected in the dialog.
 *--------------------------------------------------------------------------*/

void CTaskpadStyleBase::GetSettings (DWORD& dwOrientation, ListSize& eSize)
{
    CWindow wnd = HWnd();

    dwOrientation = wnd.IsDlgButtonChecked (IDC_Style_VerticalList)   ? TVO_VERTICAL :
                    wnd.IsDlgButtonChecked (IDC_Style_HorizontalList) ? TVO_HORIZONTAL :
                                                                        TVO_NO_RESULTS;

    if (wnd.IsDlgButtonChecked (IDC_Style_TextDesc))
        dwOrientation |= TVO_DESCRIPTIONS_AS_TEXT;

    eSize = (ListSize) m_wndSizeCombo.GetItemData (m_wndSizeCombo.GetCurSel ());
}



//############################################################################
//############################################################################
//
//  Implementation of class CTaskpadStylePage
//
//############################################################################
//############################################################################
CTaskpadStylePage::CTaskpadStylePage(CTaskpadFrame * pTaskpadFrame) :
    CTaskpadFramePtr(pTaskpadFrame),
    BC2(pTaskpadFrame)
{
}

bool
CTaskpadStylePage::OnSetActive()
{
    UpdateControls();
    return true;
}

bool
CTaskpadStylePage::OnKillActive()
{
    return CTaskpadStyleBase::Apply();
}

//############################################################################
//############################################################################
//
//  Implementation of class CTaskpadStyle
//
//############################################################################
//############################################################################

const CStr&
CTaskpadStyle::GetDescription () const
{
    if (m_strDescription.IsEmpty())
        m_strDescription.LoadString(GetStringModule(), m_idsDescription);

    ASSERT (!m_strDescription.IsEmpty());
    return (m_strDescription);
}


HBITMAP CTaskpadStyle::GetPreviewBitmap() const
{
    if (m_PreviewBitmap == NULL)
        m_PreviewBitmap = LoadSysColorBitmap (_Module.GetResourceInstance(),
                                              m_nPreviewBitmapID);

    ASSERT (m_PreviewBitmap != NULL);
    return (m_PreviewBitmap);
}

//############################################################################
//############################################################################
//
//  Implementation of class CTaskpadNodetypeBase
//
//############################################################################
//############################################################################
CTaskpadNodetypeBase::CTaskpadNodetypeBase(CTaskpadFrame *pTaskpadFrame)
: CTaskpadFramePtr(pTaskpadFrame)
{
}

LRESULT
CTaskpadNodetypeBase::OnInitDialog ( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    m_bApplytoNodetype          = !PConsoleTaskpad()->IsNodeSpecific();
    m_bSetDefaultForNodetype    = true; //$CHANGE

    CDefaultTaskpadList *pDefaultTaskpadList = PTaskpadFrame()->PScopeTree()->GetDefaultTaskpadList();
    ASSERT(pDefaultTaskpadList != NULL);

    CDefaultTaskpadList::iterator iter = pDefaultTaskpadList->find(PConsoleTaskpad()->GetNodeType());
    if(iter != pDefaultTaskpadList->end())
    {
        if(iter->second == PConsoleTaskpad()->GetID())
        {
            m_bSetDefaultForNodetype = true;
        }
    }

    ::SendDlgItemMessage(HWnd(), IDC_UseForSimilarNodes,    BM_SETCHECK, (WPARAM) m_bApplytoNodetype       ? BST_CHECKED : BST_UNCHECKED,  0);
    ::SendDlgItemMessage(HWnd(), IDC_DontUseForSimilarNodes,BM_SETCHECK, (WPARAM) (!m_bApplytoNodetype)    ? BST_CHECKED : BST_UNCHECKED,  0);
    ::SendDlgItemMessage(HWnd(), IDC_SetDefaultForNodetype, BM_SETCHECK, (WPARAM) m_bSetDefaultForNodetype ? BST_CHECKED : BST_UNCHECKED,  0);
    EnableControls();

    return 0;
}

LRESULT
CTaskpadNodetypeBase::OnUseForNodetype(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    m_bApplytoNodetype = true;
    EnableControls();
    return 0;
}

LRESULT
CTaskpadNodetypeBase::OnDontUseForNodetype(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    m_bApplytoNodetype = false;
    EnableControls();
    return 0;
}

LRESULT
CTaskpadNodetypeBase::OnSetAsDefault  (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    m_bSetDefaultForNodetype = !m_bSetDefaultForNodetype;
    EnableControls();
    return 0;
}

void
CTaskpadNodetypeBase::EnableControls()
{
    // enable the set as default button only if the taskpad applies to all nodes of the same type.
    WTL::CButton wndSetAsDefault = ::GetDlgItem(HWnd(), IDC_SetDefaultForNodetype);
    wndSetAsDefault.EnableWindow (m_bApplytoNodetype);

    /*
     * check it if it's disabled
     */
    if (!m_bApplytoNodetype)
        wndSetAsDefault.SetCheck (BST_CHECKED);
}


bool
CTaskpadNodetypeBase::OnApply()
{
    PConsoleTaskpad()->SetNodeSpecific(!m_bApplytoNodetype);
    if(!m_bApplytoNodetype) // retarget the taskpad to this node only.
    {
        CNode *pNode = PTaskpadFrame()->PNodeTarget();
        ASSERT(pNode != NULL);
        PConsoleTaskpad()->Retarget(pNode);
    }

    CDefaultTaskpadList *pDefaultList = PTaskpadFrame()->PScopeTree()->GetDefaultTaskpadList();
    ASSERT(pDefaultList != NULL);

    CDefaultTaskpadList::iterator iter = pDefaultList->find(PConsoleTaskpad()->GetNodeType());

    if(m_bApplytoNodetype && m_bSetDefaultForNodetype)
    {
        (*pDefaultList)[PConsoleTaskpad()->GetNodeType()] = PConsoleTaskpad()->GetID();
    }
    else
    {
        if(iter != pDefaultList->end())
        {
            if(iter->second==PConsoleTaskpad()->GetID())
                pDefaultList->erase(iter);
        }
    }

    return true;
}

//############################################################################
//############################################################################
//
//  Implementation of class CTaskpadNodetypePage
//
//############################################################################
//############################################################################
CTaskpadNodetypePage::CTaskpadNodetypePage(CTaskpadFrame *pTaskpadFrame) :
    CTaskpadNodetypeBase(pTaskpadFrame), CTaskpadFramePtr(pTaskpadFrame)
{
}


//############################################################################
//############################################################################
//
//  Implementation of class CTaskpadGeneralPage
//
//############################################################################
//############################################################################

/* CTaskpadGeneralPage::CTaskpadGeneralPage
 *
 * PURPOSE:     Constructor
 *
 * PARAMETERS:  None
 *
 */
CTaskpadGeneralPage::CTaskpadGeneralPage(CTaskpadFrame * pTaskpadFrame):
    BC(),
    CTaskpadFramePtr(pTaskpadFrame),
    BC2(pTaskpadFrame)
{
}


/*+-------------------------------------------------------------------------*
 * CTaskpadGeneralPage::OnInitDialog
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *      INT      uMsg:
 *      WPARAM   wParam:
 *      LPARAM   lParam:
 *      BOOL&    bHandled:
 *
 * RETURNS:
 *      LRESULT
/*+-------------------------------------------------------------------------*/
LRESULT
CTaskpadGeneralPage::OnInitDialog( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    m_strName.       Initialize (this, IDC_TASKPAD_TITLE,      -1, PConsoleTaskpad()->GetName().data());
    m_strDescription.Initialize (this, IDC_TASKPAD_DESCRIPTION,-1, PConsoleTaskpad()->GetDescription().data());

    return 0;
}





/*+-------------------------------------------------------------------------*
 * CTaskpadGeneralPage::OnOptions
 *
 *
 *--------------------------------------------------------------------------*/

LRESULT CTaskpadGeneralPage::OnOptions(  WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    CTaskpadOptionsDlg dlg (PTaskpadFrame());

    if (dlg.DoModal() == IDOK)
    {
        /*
         * apply the changes to the taskpad
         */
        CConsoleTaskpad* pTaskpad = PConsoleTaskpad();

        //pTaskpad->SetContextFormat  (dlg.m_ctxt);
        UpdateControls();
    }

    return 0;
}


/*+-------------------------------------------------------------------------*
 * CTaskpadGeneralPage::OnApply
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *
 * RETURNS:
 *      BOOL
/*+-------------------------------------------------------------------------*/
bool
CTaskpadGeneralPage::OnApply()
{
    tstring strName = MMC::GetWindowText (m_strName);

    if (strName.empty())
    {
        CStr strTitle;
        strTitle.LoadString(GetStringModule(), IDS_TASKPAD_NAME_REQUIRED_ERROR);
        MessageBox(strTitle, NULL, MB_OK | MB_ICONEXCLAMATION);
        return false;
    }

    tstring strDescription = MMC::GetWindowText (m_strDescription);

    CConsoleTaskpad* pTaskpad = PConsoleTaskpad();

    pTaskpad->SetName        (strName);
    pTaskpad->SetDescription (strDescription);

    return BC2::Apply();
}


//############################################################################
//############################################################################
//
//  Implementation of class CTaskpadOptionsDlg
//
//############################################################################
//############################################################################


/*+-------------------------------------------------------------------------*
 * CTaskpadOptionsDlg::CTaskpadOptionsDlg
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *      TaskpadFrame *    pTaskpadFrame:
 *      CConsoleTask &    rConsoleTask:
 *
 * RETURNS:
 *
/*+-------------------------------------------------------------------------*/
CTaskpadOptionsDlg::CTaskpadOptionsDlg (CTaskpadFrame* pTaskpadFrame) :
    CTaskpadFramePtr                   (pTaskpadFrame),
//    BC3                                (pTaskpadFrame),
    BC4                                (pTaskpadFrame)
{
}


/*+-------------------------------------------------------------------------*
 * CTaskpadOptionsDlg::~CTaskpadOptionsDlg
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *
 * RETURNS:
 *
/*+-------------------------------------------------------------------------*/
CTaskpadOptionsDlg::~CTaskpadOptionsDlg()
{
}


/*+-------------------------------------------------------------------------*
 * CTaskpadOptionsDlg::OnInitDialog
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *      INT      uMsg:
 *      WPARAM   wParam:
 *      LPARAM   lParam:
 *      BOOL&    bHandled:
 *
 * RETURNS:
 *      LRESULT
/*+-------------------------------------------------------------------------*/
LRESULT
CTaskpadOptionsDlg::OnInitDialog (HWND hwndFocus, LPARAM lParam, BOOL& bHandled )
{
    CConsoleTaskpad *           pTaskpad   = PConsoleTaskpad();
    EnableControls();
    return (true);
}

/*+-------------------------------------------------------------------------*
 * CTaskpadOptionsDlg::EnableControls
 *
 *
 *--------------------------------------------------------------------------*/

void CTaskpadOptionsDlg::EnableControls()
{
    /*
    bool fUseFixedFormat     = IsDlgButtonChecked (IDC_UseFixedFormat);
    bool fUseCustomFormat    = IsDlgButtonChecked (IDC_UseCustomContextFormat);

    /*
     * If neither fixed or custom format, then we're displaying no
     * caption.  If there's no caption, there's no room for a change
     * button, so we'll disable all of the retargetting-related controls
     *
    if (!fUseFixedFormat && !fUseCustomFormat && !m_fSavedWorkingSetting)
    {
        ASSERT (IsDlgButtonChecked (IDC_NoCaption));

        m_fSavedWorkingSetting             = true;
    }
    else if (m_fSavedWorkingSetting)
    {
        m_fSavedWorkingSetting = false;
    }

    //BC3::EnableControls();                                            */
}




/*+-------------------------------------------------------------------------*
 * CTaskpadOptionsDlg::OnApply
 *
 *
 *--------------------------------------------------------------------------*/

bool CTaskpadOptionsDlg::OnApply()
{
    //if(!BC3::OnApply())
      //  return false;

    if(!BC4::OnApply())
        return false;

    return (true);
}

//############################################################################
//############################################################################
//
//  Implementation of class CDialogBase
//
//############################################################################
//############################################################################



/*+-------------------------------------------------------------------------*
 * CDialogBase<T>::CDialogBase
 *
 *
 *--------------------------------------------------------------------------*/

template<class T>
CDialogBase<T>::CDialogBase (bool fAutoCenter /* =false */) :
    m_fAutoCenter (fAutoCenter)
{
}


/*+-------------------------------------------------------------------------*
 * CDialogBase<T>::OnInitDialog
 *
 * WM_INITDIALOG handler for CDialogBase.
 *--------------------------------------------------------------------------*/

template<class T>
LRESULT CDialogBase<T>::OnInitDialog (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (!m_fAutoCenter)
        PreventMFCAutoCenter (this);

    return (OnInitDialog ((HWND) wParam, lParam, bHandled));
}

template<class T>
LRESULT CDialogBase<T>::OnInitDialog (HWND hwndFocus, LPARAM lParam, BOOL& bHandled)
{
    /*
     * we didn't change the default focus
     */
    return (true);
}


/*+-------------------------------------------------------------------------*
 * CDialogBase<T>::OnOK
 *
 * IDOK handler for CDialogBase.
 *--------------------------------------------------------------------------*/

template<class T>
LRESULT CDialogBase<T>::OnOK (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if (OnApply ())
        EndDialog (IDOK);

    return (0);
}


/*+-------------------------------------------------------------------------*
 * CDialogBase<T>::OnCancel
 *
 * IDCANCEL handler for CDialogBase.
 *--------------------------------------------------------------------------*/

template<class T>
LRESULT CDialogBase<T>::OnCancel (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    EndDialog (IDCANCEL);
    return (0);
}




/*+-------------------------------------------------------------------------*
 * CDialogBase<T>::EnableDlgItem
 *
 *
 *--------------------------------------------------------------------------*/

template<class T>
BOOL CDialogBase<T>::EnableDlgItem (int idControl, bool fEnable)
{
    return (::EnableWindow (GetDlgItem (idControl), fEnable));
}


/*+-------------------------------------------------------------------------*
 * CDialogBase<T>::CheckDlgItem
 *
 *
 *--------------------------------------------------------------------------*/

template<class T>
void CDialogBase<T>::CheckDlgItem (int idControl, int nCheck)
{
    MMC_ATL::CButton btn = GetDlgItem (idControl);
    btn.SetCheck (nCheck);
}


/*+-------------------------------------------------------------------------*
 * CDialogBase<T>::GetDlgItemText
 *
 * Returns the text for a given control in the form of a tstring
 *--------------------------------------------------------------------------*/

template<class T>
tstring CDialogBase<T>::GetDlgItemText (int idControl)
{
    return (MMC::GetWindowText (GetDlgItem (idControl)));
}


/*+-------------------------------------------------------------------------*
 * CDialogBase<T>::SetDlgItemText
 *
 * Sets the text for a given control in the form of a tstring
 *--------------------------------------------------------------------------*/

template<class T>
BOOL CDialogBase<T>::SetDlgItemText (int idControl, tstring str)
{
    return (BaseClass::SetDlgItemText (idControl, str.data()));
}




//############################################################################
//############################################################################
//
//  Implementation of class CTaskPropertiesBase
//
//############################################################################
//############################################################################



/*+-------------------------------------------------------------------------*
 * CTaskPropertiesBase::CTaskPropertiesBase
 *
 *
 *--------------------------------------------------------------------------*/

CTaskPropertiesBase::CTaskPropertiesBase (
    CTaskpadFrame*  pTaskpadFrame,
    CConsoleTask &  consoleTask,
    bool            fNew)
    :
    CTaskpadFramePtr(pTaskpadFrame),
    m_pTask         (&consoleTask),
    m_fNew          (fNew)
{
}

/*+-------------------------------------------------------------------------*
 * CTaskPropertiesBase::ScOnVisitContextMenu
 *
 *
 *--------------------------------------------------------------------------*/

// forward declaration of function
void RemoveAccelerators(tstring &str);


SC
CTaskPropertiesBase::ScOnVisitContextMenu(CMenuItem &menuItem)
{
    DECLARE_SC(sc, TEXT("CTaskPropertiesBase::ScOnVisitContextMenu"));

    WTL::CListBox&  wndListBox = GetListBox();
    IntToTaskMap&   map        = GetTaskMap();

    // set up a CConsoleTask object
    CConsoleTask    task;

    tstring strName = menuItem.GetMenuItemName();
    RemoveAccelerators(strName); // friendly looking name.

    task.SetName(       strName);
    task.SetDescription(menuItem.GetMenuItemStatusBarText());
    task.SetCommand(    menuItem.GetLanguageIndependentPath());

    int i = wndListBox.AddString (menuItem.GetPath()); // the "ui-friendly" command path.
    map[i] = task;

    // if this task matches the current task, select it in the listbox
    if (ConsoleTask() == menuItem)
        wndListBox.SetCurSel (i);

    return sc;
}


/*+-------------------------------------------------------------------------*
 * CTaskPropertiesBase::OnCommandListSelChange
 *
 * LBN_SELCHANGE handler for CTaskPropertiesBase
/*+-------------------------------------------------------------------------*/

LRESULT CTaskPropertiesBase::OnCommandListSelChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    int             iSelected = WTL::CListBox(hWndCtl).GetCurSel();
    IntToTaskMap&   TaskMap  =  GetTaskMap();

    CConsoleTask& task = TaskMap[iSelected];
    ConsoleTask().SetName(task.GetName());
    ConsoleTask().SetDescription(task.GetDescription());
    ConsoleTask().SetCommand(task.GetCommand());

    return (0);
}


/*+-------------------------------------------------------------------------*
 * CTaskPropertiesBase::OnApply
 *
 *
 *--------------------------------------------------------------------------*

bool CTaskPropertiesBase::OnApply ()
{
    // code after this point is executed only for new tasks.

    if ((IsScopeTask() || IsResultTask()) &&
        (ConsoleTask().GetCommand().length() == 0))
    {
        CStr strError;
        strError.LoadString(GetStringModule(), IDS_INVALID_COMMAND);
        MessageBox (strError, NULL, MB_OK | MB_ICONEXCLAMATION);
        return (false);
    }

    return (true);
}


/*+-------------------------------------------------------------------------*
 * CTaskPropertiesBase::GetDlgItemText
 *
 * Returns the text for a given control in the form of a tstring
 *--------------------------------------------------------------------------
tstring CTaskPropertiesBase::GetDlgItemText (int idControl)
{
    return (MMC::GetWindowText (GetDlgItem (idControl)));
}


/*+-------------------------------------------------------------------------*
 * CTaskPropertiesBase::SetDlgItemText
 *
 * Sets the text for a given control in the form of a tstring
 *--------------------------------------------------------------------------
BOOL CTaskPropertiesBase::SetDlgItemText (int idControl, tstring str)
{
    return (BaseClass::SetDlgItemText (idControl, str.data()));
}
*/



//############################################################################
//############################################################################
//
//  class CCommandLineArgumentsMenu
//
//############################################################################
//############################################################################

class CCommandLineArgumentsMenu
{
    enum
    {
        TARGETNODE_ITEMS_BASE = 100,
        LISTVIEW_ITEMS_BASE   = 1000
    };
    typedef WTL::CMenu CMenu;
public:
    CCommandLineArgumentsMenu(HWND hWndParent, int nIDButton, HWND hWndListCtrl);
    bool Popup();
    CStr GetResultString()  {return m_strResult;}

private:
    void AddMenuItemsForTargetNode(CMenu &menu);
    void AddMenuItemsForListView(CMenu &menu);
private:
    HWND    m_hWndParent;
    HWND    m_hWndListCtrl;
    int     m_nIDButton;
    CStr    m_strResult;    // the string which was created as a result of the selection
};

CCommandLineArgumentsMenu::CCommandLineArgumentsMenu(HWND hWndParent, int nIDButton, HWND hWndListCtrl) :
    m_hWndParent(hWndParent),
    m_nIDButton(nIDButton),
    m_hWndListCtrl(hWndListCtrl)
{
}

void
CCommandLineArgumentsMenu::AddMenuItemsForTargetNode(CMenu &menu)
{
    bool fSucceeded = menu.CreatePopupMenu();
    ASSERT(fSucceeded);

    CStr strTargetNodeName;
    strTargetNodeName.LoadString(GetStringModule(), IDS_TargetNodeName);
    fSucceeded = menu.AppendMenu(MF_STRING, TARGETNODE_ITEMS_BASE, (LPCTSTR)strTargetNodeName);
    ASSERT(fSucceeded);


    CStr strTargetNodeParentName;
    strTargetNodeParentName.LoadString(GetStringModule(), IDS_TargetNodeParentName);
    fSucceeded = menu.AppendMenu(MF_STRING, TARGETNODE_ITEMS_BASE + 1, (LPCTSTR)strTargetNodeParentName);
    ASSERT(fSucceeded);

    fSucceeded = menu.AppendMenu(MF_SEPARATOR, 0);
    ASSERT(fSucceeded);
}

void
CCommandLineArgumentsMenu::AddMenuItemsForListView(CMenu &menu)
{
    ASSERT(m_hWndListCtrl);

    WTL::CHeaderCtrl  headerCtrl(ListView_GetHeader(m_hWndListCtrl));
    int cItems = headerCtrl.GetItemCount();
    for (int i=0; i<cItems; i++)
    {
        HDITEM hdItem;
        const int cchMaxHeader = 200;

        TCHAR szBuffer[cchMaxHeader];
        ZeroMemory(&hdItem, sizeof(hdItem));

        hdItem.mask         = HDI_TEXT;
        hdItem.pszText      = szBuffer;
        hdItem.cchTextMax   = cchMaxHeader;

        if(headerCtrl.GetItem(i, &hdItem))
        {
            bool fSucceeded = menu.AppendMenu(MF_STRING, LISTVIEW_ITEMS_BASE + i, szBuffer);
            ASSERT(fSucceeded);
        }
    }
}

bool
CCommandLineArgumentsMenu::Popup()
{
    CMenu menu;

    HWND hWndBrowseButton = ::GetDlgItem(m_hWndParent, m_nIDButton);
    RECT rectBrowse;
    ::GetWindowRect(hWndBrowseButton, &rectBrowse);

    int x = rectBrowse.left + 18;
    int y = rectBrowse.top;

    // add all the items
    AddMenuItemsForTargetNode(menu);
    AddMenuItemsForListView(menu);


    int iResp = menu.TrackPopupMenuEx(
        TPM_LEFTALIGN | TPM_TOPALIGN | TPM_RETURNCMD | TPM_NONOTIFY | TPM_LEFTBUTTON,
        x, y, m_hWndParent);

    if(iResp >= TARGETNODE_ITEMS_BASE && iResp <  LISTVIEW_ITEMS_BASE)
    {
        TCHAR szBuffer[10];
        _itot(iResp-TARGETNODE_ITEMS_BASE, szBuffer, 10);
        m_strResult.Format(TEXT("$NAME<%s>"), szBuffer);
    }
    else    // is a list view menu item. The return value is of the form $COL<number>
    {
        TCHAR szBuffer[10];
        _itot(iResp-LISTVIEW_ITEMS_BASE, szBuffer, 10);
        m_strResult.Format(TEXT("$COL<%s>"), szBuffer);
    }

    return (iResp != 0);

}


//############################################################################
//############################################################################
//
//  Implementation of class CTasksListDialog
//
//############################################################################
//############################################################################


/* CTasksListDialog<T>::CTasksListDialog
 *
 * PURPOSE:     Constructor
 *
 * PARAMETERS:  None
 */
template <class T>
CTasksListDialog<T>::CTasksListDialog(CTaskpadFrame* pTaskpadFrame, bool bNewTaskOnInit, bool bDisplayProperties) :
    BC(),
    m_bNewTaskOnInit(bNewTaskOnInit),
    m_pTaskpadFrame(pTaskpadFrame),
    m_bDisplayProperties(bDisplayProperties)
{
}


/*+-------------------------------------------------------------------------*
 * CTasksListDialog<T>::OnInitDialog
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *      INT      uMsg:
 *      WPARAM   wParam:
 *      LPARAM   lParam:
 *      BOOL&    bHandled:
 *
 * RETURNS:
 *      LRESULT
/*+-------------------------------------------------------------------------*/
template <class T>
LRESULT
CTasksListDialog<T>::OnInitDialog( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    m_buttonNewTask.Attach(::GetDlgItem(    m_hWnd, IDC_NEW_TASK_BT));
    m_buttonRemoveTask.Attach(::GetDlgItem( m_hWnd, IDC_REMOVE_TASK));
    m_buttonModifyTask.Attach(::GetDlgItem( m_hWnd, IDC_MODIFY));
    m_buttonMoveUp.Attach(::GetDlgItem(     m_hWnd, IDC_MOVE_UP));
    m_buttonMoveDown.Attach(::GetDlgItem(   m_hWnd, IDC_MOVE_DOWN));
    m_listboxTasks.Attach(::GetDlgItem(     m_hWnd, IDC_LIST_TASKS));
    m_listboxTasks.SetExtendedListViewStyle(LVS_EX_FULLROWSELECT, LVS_EX_FULLROWSELECT);

    // set up the image list
    WTL::CImageList  imageList; // the destructor will not call a destroy. This is by design - the listbox will do the destroy.
    imageList.Create (16, 16, ILC_COLOR , 4 /*the minimum number of images*/, 10);
    m_listboxTasks.SetImageList((HIMAGELIST) imageList, LVSIL_SMALL);

    // insert the list columns
    LV_COLUMN lvc;
    lvc.mask = LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;

    CStr temp;
    temp.LoadString(GetStringModule(), IDS_COLUMN_TASK);
    lvc.pszText = const_cast<LPTSTR>((LPCTSTR)temp);

    lvc.cx = 100;
    lvc.iSubItem = 0;

    int iCol = m_listboxTasks.InsertColumn(0, &lvc);
    ASSERT(iCol == 0);

    temp.LoadString(GetStringModule(), IDS_COLUMN_TOOLTIP);
    lvc.pszText = const_cast<LPTSTR>((LPCTSTR)temp);

    lvc.cx = 140;
    lvc.iSubItem = 1;

    iCol = m_listboxTasks.InsertColumn(1, &lvc);
    ASSERT(iCol == 1);

    // insert all the items
    UpdateTaskListbox(PConsoleTaskpad()->BeginTask());

    if(FNewTaskOnInit())    // simulate the "New Task" button being clicked.
    {
        m_buttonNewTask.PostMessage (BM_CLICK);
    }

    return 0;
}

template <class T>
LRESULT
CTasksListDialog<T>::OnCustomDraw(    int id, LPNMHDR pnmh, BOOL& bHandled )
{
    NMLVCUSTOMDRAW * pnmlv = (NMLVCUSTOMDRAW *) pnmh;   // the custom draw structure
    NMCUSTOMDRAW   & nmcd = pnmlv->nmcd;
    int              nItem = nmcd.dwItemSpec;
    switch(nmcd.dwDrawStage & ~CDDS_SUBITEM)
    {
    case CDDS_PREPAINT:         // the initial notification
        return CDRF_NOTIFYITEMDRAW;    // we want to know about each item's paint.

    case CDDS_ITEMPREPAINT:
        return DrawItem(&nmcd);

    default:
        return 0;
    }
}

template <class T>
LRESULT
CTasksListDialog<T>::DrawItem(NMCUSTOMDRAW *pnmcd)
{
    NMLVCUSTOMDRAW *  pnmlv = (NMLVCUSTOMDRAW *) pnmcd;
    HDC &hdc        = pnmcd->hdc;
    int  nItem      = pnmcd->dwItemSpec;

    TaskIter  itTask = PConsoleTaskpad()->BeginTask();
    std::advance (itTask, nItem);

    bool bWindowHasFocus = (GetFocus() == (HWND) m_listboxTasks);
    bool bFocused        = pnmcd->uItemState & CDIS_FOCUS;
    bool bHot            = pnmcd->uItemState & CDIS_HOT;
    bool bShowSelAlways  = m_listboxTasks.GetStyle() & LVS_SHOWSELALWAYS;

    /*
     * NOTE:  There's a bug in the list view control that will
     * set CDIS_SELECTED for *all* items (not just selected items)
     * if LVS_SHOWSELALWAYS is specified.  Interrogate the item
     * directly to get the right setting.
     */
//  bool bSelected       = pnmcd->uItemState & CDIS_SELECTED;
    bool bSelected       = m_listboxTasks.GetItemState (nItem, LVIS_SELECTED);

#if DBG
    // bFocused should always be false if the window doesn't have the focus
    if (!bWindowHasFocus)
        ASSERT (!bFocused);
#endif

    RECT rectBounds;
    m_listboxTasks.GetItemRect (nItem, &rectBounds, LVIR_BOUNDS);

    // figure out colors
    int nTextColor, nBackColor;

    if (bSelected && bWindowHasFocus)
    {
        nTextColor = COLOR_HIGHLIGHTTEXT;
        nBackColor = COLOR_HIGHLIGHT;
    }
    else if (bSelected && bShowSelAlways)
    {
        nTextColor = COLOR_BTNTEXT;
        nBackColor = COLOR_BTNFACE;
    }
    else
    {
        nTextColor = COLOR_WINDOWTEXT;
        nBackColor = COLOR_WINDOW;
    }

    // empty (or fill) the region
    FillRect (hdc, &rectBounds, ::GetSysColorBrush (nBackColor));

    // draw the text.
    COLORREF nTextColorOld = SetTextColor (hdc, ::GetSysColor (nTextColor));
    COLORREF nBackColorOld = SetBkColor   (hdc, ::GetSysColor (nBackColor));


    RECT rectIcon;
    m_listboxTasks.GetItemRect(nItem, &rectIcon, LVIR_ICON);

	/*
	 * Preserve icon shape when BitBlitting it to a
	 * mirrored DC.
	 */
	DWORD dwLayout=0L;
	if ((dwLayout=GetLayout(hdc)) & LAYOUT_RTL)
	{
		SetLayout(hdc, dwLayout|LAYOUT_BITMAPORIENTATIONPRESERVED);
	}

    itTask->Draw(hdc, &rectIcon, true /*bSmall*/);

	/*
	 * Restore the DC to its previous layout state.
	 */
	if (dwLayout & LAYOUT_RTL)
	{
		SetLayout(hdc, dwLayout);
	}

    RECT rectLabel;
    UINT uFormat = DT_LEFT | DT_SINGLELINE | DT_VCENTER | DT_WORD_ELLIPSIS;
    m_listboxTasks.GetItemRect(nItem,&rectLabel, LVIR_LABEL); // get the label rectangle
    DrawText(hdc, itTask->GetName().data(),-1,&rectLabel, uFormat);

    RECT rectDescr;
    m_listboxTasks.GetSubItemRect(nItem, 1 /*descr column*/, LVIR_LABEL, &rectDescr);
    DrawText(hdc, itTask->GetDescription().data(),-1,&rectDescr, uFormat);

    SetTextColor(hdc, nTextColorOld);
    SetBkColor  (hdc, nBackColorOld);

    if (bFocused)
        ::DrawFocusRect(hdc, &rectBounds);

    return CDRF_SKIPDEFAULT;      // we've drawn the whole item ourselves
}


template <class T>
void
CTasksListDialog<T>::OnTaskProperties()
{
    if(!m_bDisplayProperties)   // don't display any properties if not needed.
        return;

    int iSelected = GetCurSel();
    if(iSelected == LB_ERR)     // defensive
        return;

    TaskIter  itTask =  MapTaskIterators()[iSelected];

    CTaskPropertySheet dlg(NULL, PTaskpadFrame(), *itTask, false);

    if (dlg.DoModal() == IDOK)
    {
        *itTask = dlg.ConsoleTask();
        UpdateTaskListbox (itTask);
    }
}

template <class T>
int
CTasksListDialog<T>::GetCurSel()
{
    int i = (int)PListBoxTasks()->SendMessage(LVM_GETNEXTITEM, -1, MAKELPARAM(LVNI_ALL | LVNI_FOCUSED, 0));
    return (i==-1) ? LB_ERR : i;
}

/*+-------------------------------------------------------------------------*
 * CTasksListDialog<T>::OnTaskChanged
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *      ORD     wNotifyCode:
 *      WORD    wID:
 *      HWND    hWndCtl:
 *      BOOL&   bHandled:
 *
 * RETURNS:
 *      LRESULT
/*+-------------------------------------------------------------------------*/
template <class T>
LRESULT
CTasksListDialog<T>::OnTaskChanged(   int id, LPNMHDR pnmh, BOOL& bHandled )
{
    NMLISTVIEW *pnlv = (LPNMLISTVIEW) pnmh;
    EnableButtons();
    return 0;
}


/*+-------------------------------------------------------------------------*
 * CTasksListDialog<T>::OnNewTask
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *
 * RETURNS:
 *      LRESULT
/*+-------------------------------------------------------------------------*/
template <class T>
LRESULT
CTasksListDialog<T>::OnNewTask()
{
    bool        fRestartTaskWizard = true;

    while(fRestartTaskWizard)
    {
         CTaskWizard taskWizard;

         if (taskWizard.Show(m_hWnd, PTaskpadFrame(), true, &fRestartTaskWizard)==S_OK)
        {
            CConsoleTaskpad::TaskIter   itTask;
            CConsoleTaskpad *           pTaskpad = PConsoleTaskpad();

            // get the iterator of the selected task. The new task will be inserted just after this.
            int iSelected = GetCurSel();


            if (iSelected == LB_ERR)
                itTask = pTaskpad->BeginTask();
            else
            {
                /*
                 * InsertTask inserts before the given iterator.  We need to
                 * bump itTask so it gets inserted after the selected task.
                 */
                itTask = MapTaskIterators()[iSelected];
                ASSERT (itTask != pTaskpad->EndTask());
                ++itTask;
            }

            UpdateTaskListbox (pTaskpad->InsertTask (itTask, taskWizard.ConsoleTask()));
        }
        else
            break;
    }

    return 0;
}


/*+-------------------------------------------------------------------------*
 * CTasksListDialog<T>::OnRemoveTask
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *      ORD     wNotifyCode:
 *      WORD    wID:
 *      HWND    hWndCtl:
 *      BOOL&   bHandled:
 *
 * RETURNS:
 *      LRESULT
/*+-------------------------------------------------------------------------*/
template <class T>
LRESULT
CTasksListDialog<T>::OnRemoveTask( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    int iSelected = GetCurSel();
    if(iSelected == LB_ERR)
        return 0;

    // get the current task
    TaskIter        taskIterator    = MapTaskIterators()[iSelected];
    UpdateTaskListbox(PConsoleTaskpad()->EraseTask(taskIterator));
    return 0;
}


/*+-------------------------------------------------------------------------*
 * CTasksListDialog<T>::OnMoveUp
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *      ORD     wNotifyCode:
 *      WORD    wID:
 *      HWND    hWndCtl:
 *      BOOL&   bHandled:
 *
 * RETURNS:
 *      LRESULT
/*+-------------------------------------------------------------------------*/
template <class T>
LRESULT
CTasksListDialog<T>::OnMoveUp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    int iSelected = GetCurSel();
    if(iSelected == LB_ERR)
        return 0;

    // get the current task
    TaskIter        itTask    = MapTaskIterators()[iSelected];

    // defensive coding
    if(itTask==PConsoleTaskpad()->BeginTask())
        return 0;

    // point to the previous task
    TaskIter        itPreviousTask = itTask;
    --itPreviousTask;

    // swap the tasks
    std::iter_swap (itTask, itPreviousTask);

    UpdateTaskListbox(itPreviousTask);

    return 0;
}

/*+-------------------------------------------------------------------------*
 * CTasksListDialog<T>::OnMoveDown
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *      ORD     wNotifyCode:
 *      WORD    wID:
 *      HWND    hWndCtl:
 *      BOOL&   bHandled:
 *
 * RETURNS:
 *      LRESULT
/*+-------------------------------------------------------------------------*/
template <class T>
LRESULT
CTasksListDialog<T>::OnMoveDown( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    int iSelected = GetCurSel();
    if(iSelected == LB_ERR)
        return 0;

    // get the current task
    TaskIter        itTask    = MapTaskIterators()[iSelected];
    ASSERT (itTask != PConsoleTaskpad()->EndTask());

    // point to the next task
    TaskIter        itNextTask = itTask;
    ++itNextTask;

    // defensive coding
    if(itNextTask==PConsoleTaskpad()->EndTask())
        return 0;

    // swap the tasks
    std::iter_swap (itTask, itNextTask);

    UpdateTaskListbox(itNextTask);
    return 0;
}



/*+-------------------------------------------------------------------------*
 * CTasksListDialog<T>::UpdateTaskListbox
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *      TaskIter   itSelectedTask:
 *
 * RETURNS:
 *      void
/*+-------------------------------------------------------------------------*/
template <class T>
void
CTasksListDialog<T>::UpdateTaskListbox(TaskIter itSelectedTask)
{
    USES_CONVERSION;
    TaskIter itTask;
    int      iSelect = 0;
    int      iInsert = 0;

    // clear the listbox and the iterator map
    PListBoxTasks()->DeleteAllItems();
    MapTaskIterators().clear();

    for (iInsert = 0, itTask  = PConsoleTaskpad()->BeginTask();
         itTask != PConsoleTaskpad()->EndTask();
         ++itTask, ++iInsert)
    {
        LV_ITEM LVItem;
        LVItem.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
        LVItem.iItem = iInsert;
        LVItem.iImage = 0;
        LVItem.iSubItem = 0;
        LVItem.pszText = const_cast<TCHAR *>(itTask->GetName().data());

        int i = PListBoxTasks()->InsertItem(&LVItem);
        ASSERT(i==iInsert);

        // LV_Item for setting tooltim column
        LV_ITEM LVItem2;
        LVItem2.iItem = iInsert;
        LVItem2.mask = LVIF_TEXT;
        LVItem2.iSubItem = 1;
        LVItem2.pszText = const_cast<TCHAR *>(itTask->GetDescription().data());

        BOOL bStat = PListBoxTasks()->SetItem(&LVItem2);
        ASSERT(bStat);


        MapTaskIterators()[i] = itTask;

        if(itTask == itSelectedTask)
            iSelect = i;
    }

    PListBoxTasks()->SetItemState(iSelect, LVIS_FOCUSED| LVIS_SELECTED , LVIS_FOCUSED| LVIS_SELECTED );
    PListBoxTasks()->EnsureVisible(iSelect, false /*fPartialOK*/);
    EnableButtons();
}

/*+-------------------------------------------------------------------------*
 * CTasksListDialog<T>::EnableButtons
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *
 * RETURNS:
 *      void
/*+-------------------------------------------------------------------------*/
template <class T>
void
CTasksListDialog<T>::EnableButtons()
{
    bool    bEnableDelete   = true;
    bool    bEnableMoveUp   = true;
    bool    bEnableMoveDown = true;
    bool    bEnableModify   = true;

    int iSelected = GetCurSel();
    if(iSelected == LB_ERR)
    {
        bEnableDelete   = false;
        bEnableMoveUp   = false;
        bEnableMoveDown = false;
        bEnableModify   = false;
    }
    else
    {
        TaskIter taskIterator       = MapTaskIterators()[iSelected];
        TaskIter taskIteratorNext   = taskIterator;
        taskIteratorNext++;

        if(taskIterator==PConsoleTaskpad()->BeginTask())
            bEnableMoveUp = false;
        if(taskIteratorNext==PConsoleTaskpad()->EndTask())
            bEnableMoveDown = false;
    }

    EnableButtonAndCorrectFocus( m_buttonRemoveTask, bEnableDelete );
    EnableButtonAndCorrectFocus( m_buttonModifyTask, bEnableModify );
    EnableButtonAndCorrectFocus( m_buttonMoveUp,     bEnableMoveUp );
    EnableButtonAndCorrectFocus( m_buttonMoveDown,   bEnableMoveDown );
}

/***************************************************************************\
 *
 * METHOD:  CTasksListDialog<T>::EnableButtonAndCorrectFocus
 *
 * PURPOSE: Enables/disables button. Moves focus to OK, if it's on the button
 *          being disabled
 *
 * PARAMETERS:
 *    WTL::CButton& button
 *    BOOL bEnable
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
template <class T>
void CTasksListDialog<T>::EnableButtonAndCorrectFocus( WTL::CButton& button, BOOL bEnable )
{
    // if the focus belongs to the window being disabled,
    // set it to the OK button
    if ( ( !bEnable ) && ( ::GetFocus() == button ) )
    {
        // need to do some funny stuff here. see KB article Q67655 for details

        // Reset the current default push button to a regular button.
        button.SendMessage( BM_SETSTYLE, BS_PUSHBUTTON, (LONG)TRUE );

        // set focus to IDOK
        ::SetFocus( ::GetDlgItem( GetParent(), IDOK ) );
        // inform dialog about the new default button
        ::SendMessage( GetParent(), DM_SETDEFID, IDOK, 0 );
    }

    button.EnableWindow( bEnable );
}

//############################################################################
//############################################################################
//
//  Implementation of class CContextMenuVisitor
//
//############################################################################
//############################################################################


/*+-------------------------------------------------------------------------*
 * CContextMenuVisitor::ScTraverseContextMenu
 *
 * PURPOSE:  Creates and traverses the context menu tree for the selected item,
 *           whether scope or result.
 *
 * PARAMETERS:
 *      Node *           pNodeTarget:   The scope item whose menu is traversed (or NULL)
 *      CScopeTree *     pCScopeTree:   Points to a CScopeTree
 *      BOOL             fScopeItem:    TRUE if the selected item is a result item, else FALSE.
 *      CNode *          pNodeScope:    The scope item which has the focus.
 *      LPARAM           resultItemParam: The result item whose menu is traversed (or NULL)
 *
 * RETURNS:
 *      SC
/*+-------------------------------------------------------------------------*/
SC
CContextMenuVisitor::ScTraverseContextMenu(CNode *pNodeTarget, CScopeTree *pCScopeTree,
                       BOOL fScopeItem, CNode *pNodeScope, LPARAM resultItemParam, bool bShowSaveList)
{
    DECLARE_SC(sc, TEXT("CContextMenuVisitor::ScTraverseContextMenu"));

    sc = ScCheckPointers(pNodeTarget);
    if(sc)
        return sc;

    // set the context info structure.
    // include flag to force Open verb on scope item menus, so that an open task
    // will always be available and enabled.

    CContextMenuInfo contextInfo;

    contextInfo.Initialize();
    contextInfo.m_dwFlags = CMINFO_USE_TEMP_VERB | CMINFO_SHOW_SCOPEITEM_OPEN;

    // Validate parameters
    if(fScopeItem)
    {
        sc = ScCheckPointers(pNodeScope);
        if(sc)
            return sc;

        // show the view menu items only for the selected scope node
        // NOTE: cannot compare the pNode's directly - they are from different views.
        // must compare the MTNodes.
        if(pNodeTarget->GetMTNode()==pNodeScope->GetMTNode())
            contextInfo.m_dwFlags |= CMINFO_SHOW_VIEW_ITEMS;


        resultItemParam = 0;    // we don't need this
    }
    else
    {
        // Virtual list can have lparam of 0
        // (this condition must have braces as long as the assert is the
        // only conditional statement, to avoid C4390: empty controlled statement)
        if (!(pNodeTarget && pNodeTarget->GetViewData()->IsVirtualList()) &&
            !IS_SPECIAL_LVDATA (resultItemParam))
        {
            ASSERT(resultItemParam);
            CResultItem* pri = CResultItem::FromHandle(resultItemParam);

            if((pri != NULL) && pri->IsScopeItem())    // scope items in the result pane.
            {
                fScopeItem = true;
                pNodeTarget = CNode::FromResultItem (pri);
                resultItemParam = 0;
                contextInfo.m_dwFlags |= CMINFO_SCOPEITEM_IN_RES_PANE;
            }
        }

        pNodeScope = NULL;      // we don't need this.
    }

    CNodeCallback* pNodeCallback   =
        dynamic_cast<CNodeCallback *>(pNodeTarget->GetViewData()->GetNodeCallback());

    contextInfo.m_eContextMenuType      = MMC_CONTEXT_MENU_DEFAULT;
    contextInfo.m_eDataObjectType       = fScopeItem ? CCT_SCOPE: CCT_RESULT;
    contextInfo.m_bBackground           = FALSE;
    contextInfo.m_hSelectedScopeNode    = CNode::ToHandle(pNodeScope);
    contextInfo.m_resultItemParam       = resultItemParam;
    contextInfo.m_bMultiSelect          = (resultItemParam == LVDATA_MULTISELECT);
    contextInfo.m_bScopeAllowed         = fScopeItem;

    if (bShowSaveList)
        contextInfo.m_dwFlags           |= CMINFO_SHOW_SAVE_LIST;

    contextInfo.m_hWnd                  = pNodeTarget->GetViewData()->GetView();
    contextInfo.m_pConsoleView          = pNodeTarget->GetViewData()->GetConsoleView();

    // Create a CContextMenu and initialize it.
    CContextMenu * pContextMenu = NULL;
    ContextMenuPtr spContextMenu;

    sc = CContextMenu::ScCreateInstance(&spContextMenu, &pContextMenu);
    if(sc)
        return sc;

    sc = ScCheckPointers(pContextMenu, spContextMenu.GetInterfacePtr(), E_UNEXPECTED);
    if(sc)
        return sc;

    pContextMenu->ScInitialize(pNodeTarget, pNodeCallback, pCScopeTree, contextInfo);
    if(sc)
        return sc;

    // build and traverse the context menu.
    sc = pContextMenu->ScBuildContextMenu();
    if(sc)
        return sc;

    sc = ScTraverseContextMenu(pContextMenu);
    if(sc)
        return sc;

    // the context menu is freed in the destructor of the smart pointer, so we need to set the pointer to NULL.
    pContextMenu = NULL;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CContextMenuVisitor::ScTraverseContextMenu
 *
 * PURPOSE: Iterates thru the context menu.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenuVisitor::ScTraverseContextMenu(CContextMenu *pContextMenu)
{
    DECLARE_SC(sc, TEXT("CContextMenuVisitor::ScTraverseContextMenu"));

    sc = ScCheckPointers(pContextMenu, E_UNEXPECTED);
    if(sc)
        return sc;

    CMenuItem *pMenuItem = NULL;
    int iIndex = 0;

    do
    {
        sc = pContextMenu->ScGetItem(iIndex++, &pMenuItem);
        if(sc)
            return sc;

        if(!pMenuItem)
            return sc; // all done.

        bool bVisitItem = false;
        sc = ScShouldItemBeVisited(pMenuItem, pContextMenu->PContextInfo(), bVisitItem);
        if(sc)
            return sc;

        if(bVisitItem)
        {
            // Call the vistor on this item.
            SC sc = ScOnVisitContextMenu(*pMenuItem);
            if(sc == SC(S_FALSE)) // S_FALSE is the code to not continue traversal.
            {
                return sc;
            }
        }

    } while(pMenuItem != NULL);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CContextMenuVisitor::ScShouldItemBeVisited
 *
 * PURPOSE: Filters items in the traversed tree of menu items to determine whether
 *          the ScOnVisitContextMenu callback should be called.
 *
 * PARAMETERS:
 *    CMenuItem * pMenuItem : The menu item to filter
 *
 *    bool &bVisitItem: [out]: Whether ScOnVisitContextMenu should be called.
 *
 * RETURNS:
 *    bool: true if ScOnVisitContextMenu should be called on this item.
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenuVisitor::ScShouldItemBeVisited(CMenuItem *pMenuItem, CContextMenuInfo *pContextInfo, /*out*/ bool &bVisitItem)
{
    DECLARE_SC(sc, TEXT("CContextMenuInfo::FVisitItem"));

    sc = ScCheckPointers(pMenuItem, pContextInfo);
    if(sc)
        return sc;

    bVisitItem = false;

    if(pMenuItem->IsSpecialSeparator() || pMenuItem->IsSpecialInsertionPoint()
            || (pMenuItem->GetMenuItemFlags() & MF_SEPARATOR))
    {
        bVisitItem = false;    // don't call ScOnVisitContextMenu for this item
        return sc;
    }
    else if(IsSystemOwnerID(pMenuItem->GetMenuItemOwner()))  // inserted by the MMC
    {
        long nCommandID = pMenuItem->GetCommandID();

        // filter out unneeded verbs
        // also check for scope items in the result pane - these are treated as result items.
        if( (pContextInfo->m_eDataObjectType == CCT_SCOPE)
           && (!(pContextInfo->m_dwFlags & CMINFO_SCOPEITEM_IN_RES_PANE)) )
        {
            // scope menu item
            switch(nCommandID)
            {
            case MID_RENAME:
            case MID_DELETE:
            case MID_COPY:
            case MID_CUT:
            case MID_NEW_TASKPAD_FROM_HERE: // New taskpad from here
                bVisitItem =  false;
                return sc;
                break;
            default:
                bVisitItem = true;
                return sc;
                break;
            }
        }
        else
        {
            if(pContextInfo->m_bMultiSelect)  // result item, multi select
            {
                switch(nCommandID)
                {
                case MID_RENAME:
                case MID_PASTE:
                case MID_REFRESH:
                case MID_OPEN:
                    bVisitItem = false;
                    return sc;
                    break;
                default:
                    bVisitItem = true;
                    return sc;
                    break;
                }
            }
            else                              // result item, single select
            {
                switch(nCommandID)
                {
                case MID_OPEN:
                    bVisitItem = false;
                    return sc;
                    break;
                default:
                    bVisitItem = true;
                    return sc;
                    break;
                }

            }
        }
    }
    else
    {
        bVisitItem = true;
        return sc;
    }
}

//############################################################################
//############################################################################
//
//  Implementation of class CBrowserCookieList
//
//############################################################################
//############################################################################
CBrowserCookieList::~CBrowserCookieList()
{
    iterator iter;

    for (iter = begin(); iter != end(); iter++)
    {
        iter->DeleteNode();
    }
}



//############################################################################
//############################################################################
//
//  Implementation of class CMTBrowserCtrl
//
//############################################################################
//############################################################################

/*+-------------------------------------------------------------------------*
 * CMTBrowserCtrl::CMTBrowserCtrl
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *      WND           hWnd:
 *      CScopeTree *  pScopeTree:
 *
 * RETURNS:
 *
/*+-------------------------------------------------------------------------*/

CMTBrowserCtrl::CMTBrowserCtrl() :
    m_pScopeTree(NULL)
{
}


/*+-------------------------------------------------------------------------*
 * CMTBrowserCtrl::~CMTBrowserCtrl
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *
 * RETURNS:
 *
/*+-------------------------------------------------------------------------*/
CMTBrowserCtrl::~CMTBrowserCtrl()
{
    CBrowserCookieList::iterator iter;
    for (iter = PBrowserCookieList()->begin(); iter != PBrowserCookieList()->end(); iter++)
        iter->DeleteNode();
}


/*+-------------------------------------------------------------------------*
 * CMTBrowserCtrl::Initialize
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *
 * RETURNS:
 *      void
/*+-------------------------------------------------------------------------*/

void
CMTBrowserCtrl::Initialize(const InitData& init)
{
    ASSERT (::IsWindow (init.hwnd));
    ASSERT (init.pScopeTree != NULL);

    SubclassWindow (init.hwnd);
    m_pScopeTree = init.pScopeTree;

    /*
     * Copy the list of nodes to exclude.  This list is likely to be very
     * small.  If we find that it can be large, we may want to sort it
     * so that we can later do a binary search instead of a linear search.
     */
    m_vpmtnExclude = init.vpmtnExclude;
#if OptimizeExcludeList
    std::sort (m_vpmtnExclude.begin(), m_vpmtnExclude.end());
#endif

    /*
     * set the image list of the tree view control
     */
    HIMAGELIST hImageList = m_pScopeTree->GetImageList ();
    SetImageList (hImageList, TVSIL_NORMAL);

    /*
     * if no root was provided, default to the console root
     */
    CMTNode* pmtnRoot = init.pmtnRoot;

    if (pmtnRoot == NULL)
        pmtnRoot = m_pScopeTree->GetRoot();

    ASSERT (pmtnRoot != NULL);

    /*
     * add the root item
     */
    CBrowserCookie browserCookie (pmtnRoot, NULL);
    HTREEITEM htiRoot = InsertItem (browserCookie, TVI_ROOT, TVI_FIRST);

    /*
     * if no selection node was provided, default to the root
     */
    CMTNode* pmtnSelect = init.pmtnSelect;

    if (pmtnSelect == NULL)
        pmtnSelect = pmtnRoot;

    ASSERT (pmtnSelect != NULL);

    /*
     * select the specified node
     */
    SelectNode (pmtnSelect);

    /*
     * insure that the root item is expanded
     */
    Expand (htiRoot, TVE_EXPAND);
}


/*+-------------------------------------------------------------------------*
 * CMTBrowserCtrl::InsertItem
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *      MTNode *    pMTNode:
 *      HTREEITEM   hParent:
 *      HTREEITEM   hInsertAfter:
 *
 * RETURNS:
 *      HTREEITEM
/*+-------------------------------------------------------------------------*/
HTREEITEM
CMTBrowserCtrl::InsertItem(
    const CBrowserCookie&   browserCookie,
    HTREEITEM               hParent,
    HTREEITEM               hInsertAfter)
{
    /*
     * don't insert the item if it is in the exclude list
     */
    if (IsMTNodeExcluded (browserCookie.PMTNode()))
        return (NULL);

    UINT nMask = TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_TEXT | TVIF_CHILDREN;
    PBrowserCookieList()->push_back(browserCookie);
    CBrowserCookie *pBrowserCookie = & (PBrowserCookieList()->back());
    CMTNode *       pMTNode        = pBrowserCookie->PMTNode();

	tstring strName = pMTNode->GetDisplayName();

    TV_INSERTSTRUCT tvis;
    tvis.hParent                = hParent;
    tvis.hInsertAfter           = hInsertAfter;
    tvis.item.mask              = nMask;
    tvis.item.pszText           = const_cast<LPTSTR>(strName.data());
    tvis.item.iImage            = pMTNode->GetImage();
    tvis.item.iSelectedImage    = pMTNode->GetOpenImage();
    tvis.item.state             = 0;
    tvis.item.stateMask         = 0;
    tvis.item.lParam            = reinterpret_cast<LPARAM>(pBrowserCookie);
    tvis.item.cChildren         = 1;
    return BC::InsertItem(&tvis);
}


/*+-------------------------------------------------------------------------*
 * CMTBrowserCtrl::IsMTNodeExcluded
 *
 * Returns true if the given MTNode is in the exclude list.
 *--------------------------------------------------------------------------*/

bool CMTBrowserCtrl::IsMTNodeExcluded (CMTNode* pmtn) const
{
    CMTNodeCollection::const_iterator itEnd = m_vpmtnExclude.end();

    CMTNodeCollection::const_iterator itFound =
#if OptimizeExcludeList
            std::lower_bound (m_vpmtnExclude.begin(), itEnd, pmtn);
#else
            std::find        (m_vpmtnExclude.begin(), itEnd, pmtn);
#endif

    return (itFound != itEnd);
}


/*+-------------------------------------------------------------------------*
 * CMTBrowserCtrl::OnItemExpanding
 *
 * Reflected TVN_ITEMEXPANDING handler for CMTBrowserCtrl.  The class that
 * uses a CMTBrowserCtrl must have REFLECT_NOTIFICATIONS as the last entry
 * in its message map.
 *--------------------------------------------------------------------------*/

LRESULT CMTBrowserCtrl::OnItemExpanding (int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    /*
     * this should only handle messages that originated from itself
     */
    ASSERT (pnmh->hwndFrom == m_hWnd);

    /*
     * insert the children for this node, if we're expanding
     */
    LPNMTREEVIEW pnmtv = (LPNMTREEVIEW) pnmh;

    if (pnmtv->action == TVE_EXPAND)
        ExpandItem (pnmtv->itemNew);

    return (0);
}


/*+-------------------------------------------------------------------------*
 * CMTBrowserCtrl::ExpandItem
 *
 *
 *--------------------------------------------------------------------------*/

#define TVIF_REQUIRED   (TVIF_PARAM | TVIF_HANDLE | TVIF_STATE)

bool CMTBrowserCtrl::ExpandItem (const TV_ITEM& itemExpand)
{
    /*
     * make sure all of the fields we require can be trusted
     */
    ASSERT ((itemExpand.mask & TVIF_REQUIRED) == TVIF_REQUIRED);

    /*
     * if we've already added children, bail
     */
    if (itemExpand.state & TVIS_EXPANDEDONCE)
        return (true);


    CMTNode *pmtnParent = MTNodeFromItem (&itemExpand);
    ASSERT (pmtnParent != NULL);

    /*
     * make sure the master tree node has been expanded
     */
    if (!pmtnParent->WasExpandedAtLeastOnce() && FAILED (pmtnParent->Expand()))
        return (false);

    /*
     * insert tree nodes for all (non-excluded) children of this MTNode
     */
    HTREEITEM   hParent      = itemExpand.hItem;
    bool        bHasChildren = false;

    for (CMTNode* pmtn = pmtnParent->GetChild(); pmtn; pmtn = pmtn->GetNext())
    {
        if (InsertItem (CBrowserCookie(pmtn, NULL), hParent, TVI_LAST))
            bHasChildren = true;
    }

    /*
     * if the parent has no children - set its
     * cChildren to zero to get rid of the "+"
     */
    if (!bHasChildren)
    {
        TV_ITEM item;
        item.mask      = TVIF_HANDLE | TVIF_CHILDREN;
        item.hItem     = hParent;
        item.cChildren = 0;

        SetItem(&item);
    }

    return (true);
}


/*+-------------------------------------------------------------------------*
 * CBrowserCookie::DeleteNode
 *
 *
 *--------------------------------------------------------------------------*/

void CBrowserCookie::DeleteNode()
{
    delete m_pNode;
    m_pMTNode = NULL;
    m_pNode = NULL;
}


/*+-------------------------------------------------------------------------*
 * CMTBrowserCtrl::FindMTNode
 *
 *
 *--------------------------------------------------------------------------*/

bool CMTBrowserCtrl::SelectNode (CMTNode* pmtnSelect)
{
    HTREEITEM   htiRoot  = GetRootItem();
    CMTNode*    pmtnRoot = MTNodeFromItem (htiRoot);
    CMTNodeCollection vNodes;

    /*
     * walk up the tree to find the root
     */
    while (pmtnSelect != NULL)
    {
        vNodes.push_back (pmtnSelect);

        if (pmtnSelect == pmtnRoot)
            break;

        pmtnSelect = pmtnSelect->Parent();
    }

    /*
     * if we didn't find the root, fail
     */
    if (pmtnSelect == NULL)
        return (false);

    ASSERT (!vNodes.empty());
    ASSERT (vNodes.back() == pmtnRoot);
    HTREEITEM htiSelect = htiRoot;
    HTREEITEM htiWatch;

    /*
     * expand the tree to the node we want to select
     */
    for (int i = vNodes.size()-1; (i > 0) && (htiSelect != NULL); i--)
    {
        if (!Expand (htiSelect, TVE_EXPAND))
            break;

        htiSelect = FindChildItemByMTNode (htiSelect, vNodes[i-1]);
    }

    /*
     * select the node
     */
    SelectItem (htiSelect);
    return (true);
}


/*+-------------------------------------------------------------------------*
 * CMTBrowserCtrl::GetSelectedMTNode
 *
 * Returns the MTNode corresponding to the selected node in the tree
 *--------------------------------------------------------------------------*/

CMTNode* CMTBrowserCtrl::GetSelectedMTNode () const
{
    CMTBrowserCtrl* pMutableThis = const_cast<CMTBrowserCtrl*>(this);
    return (MTNodeFromItem (pMutableThis->GetSelectedItem ()));
}


/*+-------------------------------------------------------------------------*
 * CMTBrowserCtrl::CookieFromItem
 *
 *
 *--------------------------------------------------------------------------*/

CBrowserCookie* CMTBrowserCtrl::CookieFromItem (HTREEITEM hti) const
{
    return (CookieFromLParam (GetItemData (hti)));
}

CBrowserCookie* CMTBrowserCtrl::CookieFromItem (const TV_ITEM* ptvi) const
{
    return (CookieFromLParam (ptvi->lParam));
}


/*+-------------------------------------------------------------------------*
 * CMTBrowserCtrl::CookieFromLParam
 *
 *
 *--------------------------------------------------------------------------*/

CBrowserCookie* CMTBrowserCtrl::CookieFromLParam (LPARAM lParam) const
{
    return (reinterpret_cast<CBrowserCookie *>(lParam));
}


/*+-------------------------------------------------------------------------*
 * CMTBrowserCtrl::MTNodeFromItem
 *
 *
 *--------------------------------------------------------------------------*/

CMTNode* CMTBrowserCtrl::MTNodeFromItem (HTREEITEM hti) const
{
    return (CookieFromItem(hti)->PMTNode());
}

CMTNode* CMTBrowserCtrl::MTNodeFromItem (const TV_ITEM* ptvi) const
{
    return (CookieFromItem(ptvi)->PMTNode());
}


/*+-------------------------------------------------------------------------*
 * CMTBrowserCtrl::FindChildItemByMTNode
 *
 * Returns the HTREEITEM for the child node of htiParent which refers
 * to pmtnToFind, NULL if no match.
 *--------------------------------------------------------------------------*/

HTREEITEM CMTBrowserCtrl::FindChildItemByMTNode (
    HTREEITEM       htiParent,
    const CMTNode*  pmtnToFind)
{
    HTREEITEM htiChild;

    for (htiChild  = GetChildItem (htiParent);
         htiChild != NULL;
         htiChild  = GetNextSiblingItem (htiChild))
    {
        if (MTNodeFromItem (htiChild) == pmtnToFind)
            break;
    }

    return (htiChild);
}


//############################################################################
//############################################################################
//
//  Implementation of class CMirrorListView
//
//############################################################################
//############################################################################


/*+-------------------------------------------------------------------------*
 * HackDuplicate
 *
 * HACK: This is here for theming support.  himlSource comes from the conui
 * list control, which uses comctlv5 imagelists.  A v6 list control cannot
 * use v5 imagelists (images aren't drawn correctly), so we need to create
 * a v6 imagelist for the v6 list control to use.
 *
 * ImageList_Duplicate would do the job for us, but it is not compatible
 * with v5 imagelists.  We'll write to and read from a v5-compatible stream
 * to duplicate it instead.
 *--------------------------------------------------------------------------*/
HIMAGELIST HackDuplicate (HIMAGELIST himlSource)
{
	DECLARE_SC (sc, _T("HackDuplicate"));
	HIMAGELIST himlDuplicate;

	/*
	 * create a temporary stream for conversion
	 */
	IStreamPtr spStream;
	sc = CreateStreamOnHGlobal (NULL /*alloc for me*/, true /*fDeleteOnRelease*/, &spStream);
	if (sc)
		return (NULL);

	/*
	 * write the source imagelist to the stream in a v5-compatible format
	 */
	sc = WriteCompatibleImageList (himlSource, spStream);
	if (sc)
		return (NULL);

	/*
	 * rewind the stream
	 */
	LARGE_INTEGER origin = { 0, 0 };
	sc = spStream->Seek (origin, STREAM_SEEK_SET, NULL);
	if (sc)
		return (NULL);

	/*
	 * reconstitute the imagelist
	 */
	sc = ReadCompatibleImageList (spStream, himlDuplicate);
	if (sc)
		return (NULL);

	return (himlDuplicate);
}

CMirrorListView::CMirrorListView ()
    :   m_fVirtualSource (false)
{
}

void CMirrorListView::AttachSource (HWND hwndList, HWND hwndSourceList)
{
#ifdef DBG
    /*
     * the window we're attaching to should be a list view
     */
    TCHAR szClassName[countof (WC_LISTVIEW)];
    ::GetClassName (hwndSourceList, szClassName, countof (szClassName));
    ASSERT (lstrcmp (szClassName, WC_LISTVIEW) == 0);
#endif

    SubclassWindow (hwndList);

    m_wndSourceList  = hwndSourceList;
    m_fVirtualSource = (m_wndSourceList.GetStyle() & LVS_OWNERDATA) != 0;

    /*
     * Our listview will always be virtual, so we don't have to duplicate
     * the data that may already be in the source listview.  The list view
     * control doesn't allow changing the LVS_OWNERDATA style bit, so we
     * need to make sure that the control we're attaching to already has it
     */
    const DWORD dwForbiddenStyles         = LVS_SHAREIMAGELISTS;
    const DWORD dwRequiredImmutableStyles = LVS_OWNERDATA;
    const DWORD dwRequiredMutableStyles   = 0;
    const DWORD dwRequiredStyles          = dwRequiredImmutableStyles | dwRequiredMutableStyles;

    ASSERT ((dwForbiddenStyles & dwRequiredStyles) == 0);
    ASSERT ((dwRequiredImmutableStyles & dwRequiredMutableStyles) == 0);
    ASSERT ((GetStyle() & dwRequiredImmutableStyles) == dwRequiredImmutableStyles);

    DWORD dwStyle = GetStyle() | dwRequiredStyles & ~dwForbiddenStyles;
    SetWindowLong (GWL_STYLE, dwStyle);

    /*
     * copy the image lists
     */
    SetImageList (HackDuplicate(m_wndSourceList.GetImageList (LVSIL_NORMAL)), LVSIL_NORMAL);
    SetImageList (HackDuplicate(m_wndSourceList.GetImageList (LVSIL_SMALL)),  LVSIL_SMALL);
    SetImageList (HackDuplicate(m_wndSourceList.GetImageList (LVSIL_STATE)),  LVSIL_STATE);

    /*
     * insert the columns
     */
    InsertColumns ();

    /*
     * copy the items (we're virtual, so copying the items only means we
     * copy the item count)
     */
    SetItemCount (m_wndSourceList.GetItemCount());
}


/*+-------------------------------------------------------------------------*
 * CMirrorListView::InsertColumns
 *
 *
 *--------------------------------------------------------------------------*/

void CMirrorListView::InsertColumns ()
{
    WTL::CRect rect;
    GetClientRect (rect);
    int cxColumn = rect.Width() - GetSystemMetrics (SM_CXVSCROLL);

    InsertColumn (0, NULL, LVCFMT_LEFT, cxColumn, -1);
}


/*+-------------------------------------------------------------------------*
 * CMirrorListView::OnGetDispInfo
 *
 * LVN_GETDISPINFO handler for CMirrorListView.
 *--------------------------------------------------------------------------*/

LRESULT CMirrorListView::OnGetDispInfo (int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    LV_DISPINFO* plvdi = (LV_DISPINFO *) pnmh;
    return (m_wndSourceList.GetItem (&plvdi->item));
}


/*+-------------------------------------------------------------------------*
 * CMirrorListView::ForwardVirtualNotification
 *
 * Generic notification handler for CMirrorListView.
 *--------------------------------------------------------------------------*/

LRESULT CMirrorListView::ForwardVirtualNotification (int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    /*
     * if the source list is virtual, forward the notification
     */
    if (m_fVirtualSource)
        return (ForwardNotification (idCtrl, pnmh, bHandled));

    return (0);
}


/*+-------------------------------------------------------------------------*
 * CMirrorListView::ForwardNotification
 *
 * Forwards list view notifications to the source list view's parent.
 *--------------------------------------------------------------------------*/

LRESULT CMirrorListView::ForwardNotification (int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    return (::SendMessage (m_wndSourceList.GetParent(),
                           WM_NOTIFY, idCtrl, (LPARAM) pnmh));
}


/*+-------------------------------------------------------------------------*
 * CMirrorListView::ForwardMessage
 *
 * Forwards list view messages to the source list view.
 *--------------------------------------------------------------------------*/

LRESULT CMirrorListView::ForwardMessage (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    return (m_wndSourceList.SendMessage (uMsg, wParam, lParam));
}


/*+-------------------------------------------------------------------------*
 * CMirrorListView::GetSelectedItemData
 *
 *
 *--------------------------------------------------------------------------*/

LRESULT CMirrorListView::GetSelectedItemData ()
{
    int nSelectedItem = GetSelectedIndex();

    return ((m_fVirtualSource) ? nSelectedItem : GetItemData (nSelectedItem));
}



//############################################################################
//############################################################################
//
//  Implementation of class CMyComboBox
//
//############################################################################
//############################################################################


/*+-------------------------------------------------------------------------*
 * CMyComboBox::InsertStrings
 *
 *
 *--------------------------------------------------------------------------*/

void CMyComboBox::InsertStrings (const int rgStringIDs[], int cStringIDs)
{
    ASSERT (IsWindow ());
    CStr        str;

    for (int i = 0; i < cStringIDs; ++i)
    {
        /*
         * load the string and stick it in the combo
         */
        VERIFY (str.LoadString (GetStringModule(), rgStringIDs[i]));

        int nIndex = AddString (str);
        ASSERT (nIndex >= 0);

        /*
         * set the string ID as the combo item's data
         */
        SetItemData (nIndex, rgStringIDs[i]);
    }
}


/*+-------------------------------------------------------------------------*
 * CMyComboBox::GetSelectedItemData
 *
 *
 *--------------------------------------------------------------------------*/

LPARAM CMyComboBox::GetSelectedItemData () const
{
    return (GetItemData (GetCurSel ()));
}


/*+-------------------------------------------------------------------------*
 * CMyComboBox::SelectItemByData
 *
 *
 *--------------------------------------------------------------------------*/

void CMyComboBox::SelectItemByData (LPARAM lParam)
{
    int nIndex = FindItemByData(lParam);

    if (nIndex != -1)
        SetCurSel (nIndex);
}


/*+-------------------------------------------------------------------------*
 * CMyComboBox::FindItemByData
 *
 *
 *--------------------------------------------------------------------------*/

int CMyComboBox::FindItemByData (LPARAM lParam) const
{
    int cItems = GetCount ();

    for (int i = 0; i < cItems; i++)
    {
        if (GetItemData (i) == lParam)
            break;
    }

    ASSERT (i <= cItems);
    if (i >= cItems)
        i = -1;

    return (i);
}


//############################################################################
//############################################################################
//
//  Utility functions
//
//############################################################################
//############################################################################

namespace MMC
{

/*+-------------------------------------------------------------------------*
 * GetWindowText
 *
 * Returns the text for a given window in the form of a tstring
 *--------------------------------------------------------------------------*/

tstring GetWindowText (HWND hwnd)
{
    int    cchText = GetWindowTextLength (hwnd) + 1;
    LPTSTR pszText = (LPTSTR) _alloca (cchText * sizeof (TCHAR));

    ::GetWindowText (hwnd, pszText, cchText);

    return (pszText);
}

}; // namespace MMC


/*+-------------------------------------------------------------------------*
 * PreventMFCAutoCenter
 *
 * MFC applications set a CBT hook which will subclass all non-MFC windows
 * with an MFC subclass proc.  That subclass proc will auto-magically center
 * dialogs on their parents.
 *
 * We can prevent this auto-centering, by slightly adjusting the position of
 * the window during WM_INITDIALOG.
 *--------------------------------------------------------------------------*/

void PreventMFCAutoCenter (MMC_ATL::CWindow* pwnd)
{
    RECT rect;

    pwnd->GetWindowRect (&rect);
    OffsetRect (&rect, 0, 1);
    pwnd->MoveWindow (&rect, false);
}


/*+-------------------------------------------------------------------------*
 * LoadSysColorBitmap
 *
 * Loads a bitmap resource and converts gray scale colors to the 3-D colors
 * of the current color scheme.
 *--------------------------------------------------------------------------*/

HBITMAP LoadSysColorBitmap (HINSTANCE hInst, UINT id, bool bMono)
{
    return ((HBITMAP) LoadImage (hInst, MAKEINTRESOURCE(id), IMAGE_BITMAP, 0, 0,
                                 LR_LOADMAP3DCOLORS));
}



//############################################################################
//############################################################################
//
//  Implementation of class CTaskPropertySheet
//
//############################################################################
//############################################################################
CTaskPropertySheet::CTaskPropertySheet(HWND hWndParent, CTaskpadFrame * pTaskpadFrame,
                                       CConsoleTask &consoleTask, bool fNew) :
    m_consoleTask(consoleTask),
    m_namePage(pTaskpadFrame, ConsoleTask(), fNew),
    m_cmdLinePage(pTaskpadFrame, ConsoleTask(), fNew),
    m_taskSymbolDialog(ConsoleTask())
{
    // Add property pages
    AddPage(m_namePage);
    AddPage(m_taskSymbolDialog);
    if(consoleTask.GetTaskType()==eTask_CommandLine)
        AddPage(m_cmdLinePage);

    static CStr strModifyTitle;
    strModifyTitle.LoadString(GetStringModule(),
                               IDS_TaskProps_ModifyTitle);

    // set internal state - not using ATL's SetTitle because of bogus assert.
    m_psh.pszCaption = (LPCTSTR) strModifyTitle;
    m_psh.dwFlags &= ~PSH_PROPTITLE;
}


//############################################################################
//############################################################################
//
//  Implementation of class CTaskWizard
//
//############################################################################
//############################################################################
HRESULT
CTaskWizard::Show(HWND hWndParent, CTaskpadFrame * pTaskpadFrame, bool fNew, bool *pfRestartTaskWizard)
{
    USES_CONVERSION;

    *pfRestartTaskWizard = false;

    IFramePrivatePtr spFrame;
    spFrame.CreateInstance(CLSID_NodeInit,
#if _MSC_VER >= 1100
                        NULL,
#endif
                        MMC_CLSCTX_INPROC);


    IPropertySheetProviderPtr pIPSP = spFrame;
    if (pIPSP == NULL)
        return S_FALSE;

    HRESULT hr = pIPSP->CreatePropertySheet (L"Cool :-)", FALSE, NULL, NULL,
                                             MMC_PSO_NEWWIZARDTYPE);

    CHECK_HRESULT(hr);
    if (FAILED(hr))
        return hr;

    // create property pages
    CTaskWizardWelcomePage  welcomePage (pTaskpadFrame, ConsoleTask(), fNew);
    CTaskWizardTypePage     typePage    (pTaskpadFrame, ConsoleTask(), fNew);
    CTaskCmdLineWizardPage  cmdLinePage (pTaskpadFrame, ConsoleTask(), fNew);
    CTaskWizardFavoritePage favoritePage(pTaskpadFrame, ConsoleTask(), fNew);
    CTaskWizardMenuPage     menuPage    (pTaskpadFrame, ConsoleTask(), fNew);
    CTaskNameWizardPage     namePage    (pTaskpadFrame, ConsoleTask(), fNew);
    CTaskSymbolWizardPage   symbolPage  (ConsoleTask());
    CTaskWizardFinishPage   finishPage  (pTaskpadFrame, ConsoleTask(), pfRestartTaskWizard);


    // create the pages we'll add in IExtendPropertySheet::CreatePropertyPages
    CExtendPropSheet* peps;
    hr = CExtendPropSheet::CreateInstance (&peps);
    CHECK_HRESULT(hr);
    RETURN_ON_FAIL(hr);

    /*
     * destroying this object will take care of releasing our ref on peps
     */
    IUnknownPtr spUnk = peps;
    ASSERT (spUnk != NULL);

	peps->SetWatermarkID (IDB_TASKPAD_WIZARD_WELCOME);
    peps->SetHeaderID    (IDB_TASKPAD_WIZARD_HEADER);

    peps->AddPage (welcomePage.Create());
    peps->AddPage (typePage.Create());
    peps->AddPage (menuPage.Create());
    peps->AddPage (favoritePage.Create());
    peps->AddPage (cmdLinePage.Create());
    peps->AddPage (namePage.Create());
    peps->AddPage (symbolPage.Create());
    peps->AddPage (finishPage.Create());


    hr = pIPSP->AddPrimaryPages(spUnk, FALSE, NULL, FALSE);
    CHECK_HRESULT(hr);

    hr = pIPSP->Show((LONG_PTR)hWndParent, 0);
    CHECK_HRESULT(hr);

    return hr;
}


//############################################################################
//############################################################################
//
//  Implementation of class CTaskWizardWelcomePage
//
//############################################################################
//############################################################################
LRESULT CTaskWizardWelcomePage::OnInitDialog ( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    CWizardPage::OnInitWelcomePage(m_hWnd); // set up the correct title font
    return 0;
}

bool
CTaskWizardWelcomePage::OnSetActive()
{
    CWizardPage::OnWelcomeSetActive(m_hWnd);
    return true;
}

bool
CTaskWizardWelcomePage::OnKillActive()
{
    CWizardPage::OnWelcomeKillActive(m_hWnd);
    return true;
}


//############################################################################
//############################################################################
//
//  Implementation of class CTaskWizardFinishPage
//
//############################################################################
//############################################################################
CTaskWizardFinishPage::CTaskWizardFinishPage(CTaskpadFrame * pTaskpadFrame,
                                             CConsoleTask & consoleTask, bool *pfRestartTaskWizard)
: m_pConsoleTask(&consoleTask),
  m_taskpadFrameTemp(*pTaskpadFrame),
  m_consoleTaskpadTemp(*(pTaskpadFrame->PConsoleTaskpad())),
  BaseClass(&m_taskpadFrameTemp, false, false), CTaskpadFramePtr(pTaskpadFrame)
{
    m_taskpadFrameTemp.SetConsoleTaskpad(&m_consoleTaskpadTemp);
    m_pfRestartTaskWizard = pfRestartTaskWizard;

    /*
     * welcome and finish pages in Wizard97-style wizards don't have headers
     */
    m_psp.dwFlags |= PSP_HIDEHEADER;
}


LRESULT CTaskWizardFinishPage::OnInitDialog ( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    BaseClass::OnInitDialog(uMsg, wParam, lParam, bHandled); // call the base class -required here.
    CWizardPage::OnInitFinishPage(m_hWnd); // set up the correct title font
    CheckDlgButton(IDB_RESTART_TASK_WIZARD, BST_UNCHECKED);
    return 0;
}

BOOL
CTaskWizardFinishPage::OnSetActive()
{
    // Set the correct wizard buttons.
    WTL::CPropertySheetWindow(::GetParent(m_hWnd)).SetWizardButtons (PSWIZB_BACK | PSWIZB_FINISH);

    CConsoleTaskpad* pTaskpad = m_taskpadFrameTemp.PConsoleTaskpad();
    *pTaskpad = *(CTaskpadFramePtr::PTaskpadFrame()->PConsoleTaskpad()); // reset the taskpad

    CConsoleTaskpad::TaskIter   itTask = pTaskpad->EndTask();

    // add the task to the list.
    UpdateTaskListbox (pTaskpad->InsertTask (itTask, ConsoleTask()));

    return TRUE;
}

BOOL
CTaskWizardFinishPage::OnWizardFinish()
{
    *m_pfRestartTaskWizard = (IsDlgButtonChecked(IDB_RESTART_TASK_WIZARD)==BST_CHECKED);
    return TRUE;
}

int
CTaskWizardFinishPage::OnWizardBack()
{
    // Set the correct wizard buttons.
    WTL::CPropertySheetWindow(::GetParent(m_hWnd)).SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);
    return 0;
}

//############################################################################
//############################################################################
//
//  Implementation of class CTaskWizardTypePage
//
//############################################################################
//############################################################################
CTaskWizardTypePage::CTaskWizardTypePage(CTaskpadFrame * pTaskpadFrame, CConsoleTask & consoleTask, bool fNew)
:
CTaskpadFramePtr(pTaskpadFrame)
{
    m_pConsoleTask  = &consoleTask;
}

int
CTaskWizardTypePage::OnWizardNext()
{
    int ID = 0;

    // go to the appropriate page.
    switch(ConsoleTask().GetTaskType())
    {
    case eTask_Result:
    case eTask_Scope:
    case eTask_Target:
        ID = IDD_TASK_WIZARD_MENU_PAGE;
        break;
    case eTask_CommandLine:
        ID = IDD_TASK_WIZARD_CMDLINE_PAGE;
        break;
    case eTask_Favorite:
        ID = IDD_TASK_WIZARD_FAVORITE_PAGE;
        break;
    default:
        ASSERT(0 && "Should not come here.");
        break;
    }

    return ID;
}


LRESULT
CTaskWizardTypePage::OnInitDialog( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    int ID = 0;

    switch (ConsoleTask().GetTaskType())
    {
    case eTask_Result:
    case eTask_Target:  // all these types have identical handlers in this page.
    case eTask_Scope:
        ID = IDC_MENU_TASK;
        break;
    case eTask_CommandLine:
        ID = IDC_CMDLINE_TASK;
        break;
    case eTask_Favorite:
        ID = IDC_NAVIGATION_TASK;
        break;
    default:
        ASSERT(0 && "Should not come here.");
        break;
    }

    ::SendDlgItemMessage(m_hWnd, ID, BM_SETCHECK, (WPARAM) true, 0);
    return 0;
}


LRESULT
CTaskWizardTypePage::OnMenuTask  ( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    if( (ConsoleTask().GetTaskType() != eTask_Scope) ||
        (ConsoleTask().GetTaskType() != eTask_Result) ) // if changing task types
    {
        ConsoleTask() = CConsoleTask();             // clear out the task info.
        ConsoleTask().SetTaskType(eTask_Scope);
    }
    return 0;
}

LRESULT
CTaskWizardTypePage::OnCmdLineTask( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    if(ConsoleTask().GetTaskType() != eTask_CommandLine) // if changing task types
    {
        ConsoleTask() = CConsoleTask();             // clear out the task info.
        ConsoleTask().SetTaskType(eTask_CommandLine);
    }
    return 0;
}

LRESULT
CTaskWizardTypePage::OnFavoriteTask(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    if(ConsoleTask().GetTaskType() != eTask_Favorite) // if changing task types
    {
        ConsoleTask() = CConsoleTask();             // clear out the task info.
        ConsoleTask().SetTaskType(eTask_Favorite);
    }
    return 0;
}

//############################################################################
//############################################################################
//
//  Implementation of class CTaskNamePage
//
//############################################################################
//############################################################################
CTaskNamePage::CTaskNamePage(CTaskpadFrame * pTaskpadFrame, CConsoleTask & consoleTask, bool fNew)
:
CTaskpadFramePtr(pTaskpadFrame)
{
    m_pConsoleTask  = &consoleTask;

	/*
	 * if this page is for a new task, we'll be running in a wizard (not
	 * a property sheet)
	 */
	m_fRunAsWizard  = fNew;
}

BOOL
CTaskNamePage::SetTaskName(bool fCheckIfOK)
{
    /*
     * get the task name
     */
    CWindow wndTaskName = GetDlgItem (IDC_TaskName);
    tstring strName = MMC::GetWindowText (wndTaskName);

    /*
     * a name is required (usually)
     */
    if (fCheckIfOK && strName.empty())
    {
        CStr strError;
        strError.LoadString(GetStringModule(),
                             IDS_TaskProps_ErrorNoTaskName);

        MessageBox (strError);
        wndTaskName.SetFocus ();
        return (false); // don't allow the change.
    }

    /*
     * get the description
     */
    tstring strDescription = MMC::GetWindowText (GetDlgItem (IDC_TaskDescription));

    /*
     * update the task
     */
    ConsoleTask().SetName        (strName);
    ConsoleTask().SetDescription (strDescription);

    return (true);
}

int
CTaskNamePage::OnWizardNext()
{
    if(!SetTaskName(true))
        return -1;

    return IDD_TASK_WIZARD_SYMBOL_PAGE;
}

int
CTaskNamePage::OnWizardBack()
{
    int ID = 0;

    // go to the appropriate page.
    switch(ConsoleTask().GetTaskType())
    {
    case eTask_Result:
    case eTask_Scope:
    case eTask_Target:
        ID = IDD_TASK_WIZARD_MENU_PAGE;
        break;
    case eTask_CommandLine:
        ID = IDD_TASK_WIZARD_CMDLINE_PAGE;
        break;
    case eTask_Favorite:
        ID = IDD_TASK_WIZARD_FAVORITE_PAGE;
        break;
    default:
        ASSERT(0 && "Should not come here.");
        break;
    }

    return ID;
}


BOOL
CTaskNamePage::OnSetActive()
{
    // Set the correct wizard buttons (only if we're running as a wizard)
	if (m_fRunAsWizard)
		WTL::CPropertySheetWindow(::GetParent(m_hWnd)).SetWizardButtons (PSWIZB_BACK | PSWIZB_NEXT);

    ::SetDlgItemText (m_hWnd, IDC_TaskName,          ConsoleTask().GetName().data());
    ::SetDlgItemText (m_hWnd, IDC_TaskDescription,   ConsoleTask().GetDescription().data());
    return TRUE;
}


BOOL
CTaskNamePage::OnKillActive()
{
    SetTaskName(false); // don't care if it is blank (eg if user pressed "Back" button.)
    return TRUE;
}

//############################################################################
//############################################################################
//
//  Implementation of class CTaskWizardMenuPage
//
//############################################################################
//############################################################################
CTaskWizardMenuPage::CTaskWizardMenuPage(CTaskpadFrame * pTaskpadFrame, CConsoleTask & consoleTask, bool fNew) :
    CTaskpadFramePtr(pTaskpadFrame),
    BC2(pTaskpadFrame, consoleTask, fNew)
{
    m_pMirrorTargetNode = NULL;
}


BOOL
CTaskWizardMenuPage::OnSetActive()
{
    return TRUE;
}

BOOL
CTaskWizardMenuPage::OnKillActive()
{
    return TRUE;
}

int
CTaskWizardMenuPage::OnWizardNext()
{
    if(m_wndCommandListbox.GetCurSel() == LB_ERR) // no selection, display error
    {
        CStr strTitle;
        strTitle.LoadString(GetStringModule(), IDS_TASK_MENU_COMMAND_REQUIRED);
        MessageBox(strTitle, NULL, MB_OK | MB_ICONEXCLAMATION);
        return -1;
    }
   return IDD_TASK_WIZARD_NAME_PAGE;
}

CTaskWizardMenuPage::_TaskSource
CTaskWizardMenuPage::s_rgTaskSource[] =
{
    {IDS_TASKSOURCE_RESULT, eTask_Result},
    {IDS_TASKSOURCE_SCOPE,  eTask_Scope},
};

LRESULT
CTaskWizardMenuPage::OnInitDialog( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    //attach HWNDs to CWindows
    m_wndCommandListbox = GetDlgItem (IDC_CommandList);

    CNode* pTargetNode = NULL;

    if(PTaskpadFrame()->PConsoleTaskpad()->HasTarget())
        pTargetNode = PNodeTarget();


    // populate the drop down

    m_wndSourceCombo = GetDlgItem (IDC_TASK_SOURCE_COMBO);

    for (int i = 0; i < countof (s_rgTaskSource); i++)
    {
        CStr str;
        VERIFY (str.LoadString(GetStringModule(), s_rgTaskSource[i].idsName));
        VERIFY (m_wndSourceCombo.InsertString (-1, str) == i);
    }


    /*
     * attach the scope browser to the scope tree
     */
    CMTBrowserCtrl::InitData init;

    init.hwnd       = GetDlgItem (IDC_ScopeTree);
    init.pScopeTree = PScopeTree();
    init.pmtnSelect = (pTargetNode != NULL) ? pTargetNode->GetMTNode() : NULL;

    // remember the task type...
    eConsoleTaskType type = ConsoleTask().GetTaskType();

    m_wndScopeTree.Initialize (init);

    // populate the result menu item list.
    if (pTargetNode /*&& bResultTask*/)
    {
        InitResultView (pTargetNode);
    }

    // reset the task type from above...
    ConsoleTask().SetTaskType(type);

    EnableWindows();
    OnSettingsChanged();
    return 0;
}


void CTaskWizardMenuPage::ShowWindow(HWND hWnd, bool bShowWindow)
{
    if (!::IsWindow(hWnd))
        return;

    ::ShowWindow  (hWnd, bShowWindow ? SW_SHOW : SW_HIDE);
    ::EnableWindow(hWnd, bShowWindow);
}

void
CTaskWizardMenuPage::EnableWindows()
{
    eConsoleTaskType type = ConsoleTask().GetTaskType();
    if(type == eTask_Target)
        type = eTask_Scope;  // for the purposes of the UI these are identical.


    // display the correct task type.
    for(int i = 0; i< countof (s_rgTaskSource); i++)
    {
        if(s_rgTaskSource[i].type == type)
            break;
    }

    ASSERT(i<countof(s_rgTaskSource));

    bool bResultTask = ConsoleTask().GetTaskType() == eTask_Result;

    m_wndSourceCombo.SetCurSel(i);

   /*
    // Enable ResultTask choice only if there are result items
    bool bResultItems = (m_wndResultView.GetItemCount() > 0);
    ASSERT(bResultItems || !bResultTask);
    ::EnableWindow(GetDlgItem(IDC_RESULT_TASK), bResultItems);
    */

    ShowWindow(GetDlgItem(IDC_RESULT_TASK_DESCR),    bResultTask);
    ShowWindow(GetDlgItem(IDC_CONSOLE_TREE_CAPTION), !bResultTask);
    ShowWindow(GetDlgItem(IDC_ScopeTree),            !bResultTask);
    ShowWindow(GetDlgItem(IDC_ResultList),           bResultTask);
}

LRESULT
CTaskWizardMenuPage::OnSettingChanged(  WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    OnSettingsChanged();
    return 0;
}

void
CTaskWizardMenuPage::OnSettingsChanged()
{
    eConsoleTaskType type = s_rgTaskSource[m_wndSourceCombo.GetCurSel()].type;

    ConsoleTask().SetTaskType(type);
    EnableWindows();

    if(type == eTask_Scope)
    {
        HTREEITEM hti = m_wndScopeTree.GetSelectedItem();
        m_wndScopeTree.SelectItem(NULL); // remove the selection
        m_wndScopeTree.SelectItem(hti); // reselect it.
    }
    else
    {
        // empty the list box
        m_wndCommandListbox.ResetContent();
        SelectFirstResultItem(false);
        SelectFirstResultItem(true);
    }
}

/*+-------------------------------------------------------------------------*
 * CTaskWizardMenuPage::OnScopeItemChanged
 *
 *
/*+-------------------------------------------------------------------------*/

LRESULT CTaskWizardMenuPage::OnScopeItemChanged(int id, LPNMHDR pnmh, BOOL& bHandled)
{
    // empty the list box
    m_wndCommandListbox.ResetContent();

    LPNMTREEVIEW    pnmtv           = (LPNMTREEVIEW) pnmh;
    CBrowserCookie *pBrowserCookie  = m_wndScopeTree.CookieFromItem (&pnmtv->itemNew);
    if(!pBrowserCookie) // no item selected
        return 0;

    CNode*      pNode   = pBrowserCookie->PNode();
    CMTNode *   pMTNode = pBrowserCookie->PMTNode();

    // validate parameters
    ASSERT(pMTNode);
    ASSERT(PTaskpadFrame()->PViewData());

    if(!pNode)
    {
        pNode = pMTNode->GetNode(PTaskpadFrame()->PViewData());
        if(!pNode)
            return 0;

        pBrowserCookie->SetNode(pNode);
        HRESULT hr = pNode->InitComponents();
        if (FAILED(hr))
            return 0;
    }

    bool bNodeIsTarget = PTaskpadFrame()->PConsoleTaskpad()->HasTarget() &&
                         (PNodeTarget()->GetMTNode() == pNode->GetMTNode());

    // set the correct task type.
    ConsoleTask().SetTaskType(bNodeIsTarget ? eTask_Target : eTask_Scope);
    // retarget the scope node bookmark
    if(!bNodeIsTarget)
        ConsoleTask().RetargetScopeNode(pNode);

    int cResultItemCount = ListView_GetItemCount(m_MirroredView.GetListCtrl());
    SC sc = ScTraverseContextMenu(pNode, PScopeTree(), TRUE, PTaskpadFrame()->PNodeTarget(),
                0, bNodeIsTarget && (cResultItemCount > 0)/*bShowSaveList*/);

    return (0);
}


void CTaskWizardMenuPage::InitResultView (CNode* pRootNode)
{
    /*
     * create the temporary view whose contents we'll mirror
     */
    ASSERT (pRootNode != NULL);
    m_pMirrorTargetNode = m_MirroredView.Create (PScopeTree()->GetConsoleFrame(), pRootNode);
    ASSERT (m_pMirrorTargetNode != NULL);

    /*
     * force the snap-in into a standard list view
     */
    HRESULT hr;
    hr = m_pMirrorTargetNode->InitComponents ();
    hr = m_pMirrorTargetNode->ShowStandardListView ();

    if (FAILED (hr))
    {
        // TODO(jeffro): handle snap-ins that don't support a standard list view
    }

    /*
     * attach the temporary view's list view to our mirror list view
     */
    m_wndResultView.AttachSource (GetDlgItem (IDC_ResultList),
                                  m_MirroredView.GetListCtrl());

    //SelectFirstResultItem();
}

void CTaskWizardMenuPage::SelectFirstResultItem(bool bSelect)
{
    /*
     * Select the first item.  Note that one would think we'd be able to use:
     *
     *      m_wndResultView.SetItemState (0, LVIS_SELECTED, LVIS_SELECTED);
     *
     * to select the item.  We can't though because that overload of
     * SetItemState sends LVM_SETITEM, which fails for virtual listviews.
     *
     * If we instead use:
     *
     *      m_wndResultView.SetItemState (nItem, LV_ITEM* pItem)
     *
     * then LVM_SETITEMSTATE will be sent, which works for virtual listviews.
     */

    int i = m_wndResultView.GetItemCount();
    if(i == 0)
        return;

    LV_ITEM lvi;
    lvi.mask      = LVIF_STATE;
    lvi.iItem     = 0;
    lvi.state     = bSelect ? LVIS_SELECTED : 0;
    lvi.stateMask = LVIS_SELECTED;

    m_wndResultView.SetItemState (0, &lvi);
}


/*+-------------------------------------------------------------------------*
 * CTaskWizardMenuPage::OnResultItemChanged
 *
 *
 *--------------------------------------------------------------------------*/

LRESULT CTaskWizardMenuPage::OnResultItemChanged(int id, LPNMHDR pnmh, BOOL& bHandled)
{
    NM_LISTVIEW* pnmlv = (NM_LISTVIEW*) pnmh;

    /*
     * if a new item is being selected, populate the result menu item list
     */
    if ((pnmlv->uNewState & LVIS_SELECTED) && !(pnmlv->uOldState & LVIS_SELECTED))
    {
        ASSERT (m_pMirrorTargetNode != NULL);

        m_wndCommandListbox.ResetContent();

        SC sc = ScTraverseContextMenu (m_pMirrorTargetNode,
                             PScopeTree(), FALSE, NULL,
                             m_wndResultView.GetSelectedItemData ());
    }

    // set the correct task type.
    ConsoleTask().SetTaskType(eTask_Result);
    return (0);
}

//############################################################################
//############################################################################
//
//  Implementation of class CTaskWizardFavoritePage
//
//############################################################################
//############################################################################
CTaskWizardFavoritePage::CTaskWizardFavoritePage(CTaskpadFrame * pTaskpadFrame, CConsoleTask & consoleTask, bool fNew)
: CTaskpadFramePtr(pTaskpadFrame), m_bItemSelected(false)
{
    m_pConsoleTask  = &consoleTask;
}

CTaskWizardFavoritePage::~CTaskWizardFavoritePage()
{
}

BOOL
CTaskWizardFavoritePage::OnSetActive()
{
    SetItemSelected(m_bItemSelected); // restore the state.

    return true;
}

BOOL
CTaskWizardFavoritePage::OnKillActive()
{
    return true;
}


int
CTaskWizardFavoritePage::OnWizardBack()
{
    // Set the correct wizard buttons.
    WTL::CPropertySheetWindow(::GetParent(m_hWnd)).SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);

    return IDD_TASK_WIZARD_TYPE_PAGE;
}

int
CTaskWizardFavoritePage::OnWizardNext()
{
    return IDD_TASK_WIZARD_NAME_PAGE;
}

void
CTaskWizardFavoritePage::SetItemSelected(bool bItemSelected)
{
    m_bItemSelected = bItemSelected;

    // Set the correct wizard buttons.
    WTL::CPropertySheetWindow(::GetParent(m_hWnd)).SetWizardButtons (bItemSelected ? (PSWIZB_BACK | PSWIZB_NEXT)
                                                                              : (PSWIZB_BACK));
}

LRESULT
CTaskWizardFavoritePage::OnInitDialog( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    CConsoleView* pConsoleView = PTaskpadFrame()->PViewData()->GetConsoleView();

    if (pConsoleView != NULL)
    {
        HWND hwndCtrl = pConsoleView->CreateFavoriteObserver (m_hWnd, IDC_FavoritesTree);
        ASSERT(hwndCtrl != NULL);

        HWND hWndStatic = GetDlgItem(IDC_FAVORITE_STATIC);
        ASSERT(hWndStatic != NULL);

        RECT rectStatic;
        ::GetWindowRect(hWndStatic, &rectStatic);

        WTL::CPoint pointTopLeft;
        pointTopLeft.y  = rectStatic.top;
        pointTopLeft.x  = rectStatic.left;

        ::ScreenToClient(m_hWnd, &pointTopLeft);

        ::SetWindowPos(hwndCtrl, NULL,
                       pointTopLeft.x, pointTopLeft.y,
                       rectStatic.right  -rectStatic.left,
                       rectStatic.bottom - rectStatic.top,
                       SWP_NOZORDER);
    }

    return 0;
}


LRESULT
CTaskWizardFavoritePage::OnItemChanged (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    CMemento *pMemento  = (CMemento *)wParam;
    if(pMemento != NULL)
    {
        ConsoleTask().SetMemento(*pMemento);
    }
    else
    {
        // Set the correct wizard buttons.
        WTL::CPropertySheetWindow(::GetParent(m_hWnd)).SetWizardButtons (PSWIZB_BACK);
    }

    SetItemSelected(pMemento!=NULL);

    return 0;
}


//############################################################################
//############################################################################
//
//  Implementation of class CTaskCmdLinePage
//
//############################################################################
//############################################################################
// contents of the "Run:" combo box
const int const CTaskCmdLinePage::s_rgidWindowStates[] =
{
    IDS_TaskProps_Restored,
    IDS_TaskProps_Minimized,
    IDS_TaskProps_Maximized,
};


CTaskCmdLinePage::CTaskCmdLinePage(CTaskpadFrame * pTaskpadFrame, CConsoleTask & consoleTask, bool fNew)
:    m_hBitmapRightArrow(NULL), CTaskpadFramePtr(pTaskpadFrame)
{
    m_pConsoleTask  = &consoleTask;
}

CTaskCmdLinePage::~CTaskCmdLinePage()
{
    if(m_hBitmapRightArrow)
        ::DeleteObject(m_hBitmapRightArrow);
}

BOOL
CTaskCmdLinePage::OnSetActive()
{
    return TRUE;
}

BOOL
CTaskCmdLinePage::OnKillActive()
{
    switch (m_wndWindowStateCombo.GetSelectedItemData())
    {
        case IDS_TaskProps_Restored:
            ConsoleTask().SetWindowState (eState_Restored);
            break;

        case IDS_TaskProps_Maximized:
            ConsoleTask().SetWindowState (eState_Maximized);
            break;

        case IDS_TaskProps_Minimized:
            ConsoleTask().SetWindowState (eState_Minimized);
            break;
    }

    ConsoleTask().SetCommand   (MMC::GetWindowText (GetDlgItem (IDC_Command)));
    ConsoleTask().SetParameters(MMC::GetWindowText (GetDlgItem (IDC_CommandArgs)));
    ConsoleTask().SetDirectory (MMC::GetWindowText (GetDlgItem (IDC_CommandWorkingDir)));

    return TRUE;
}

int
CTaskCmdLinePage::OnWizardNext()
{

    // make sure we have a command
    tstring strCommand = MMC::GetWindowText (GetDlgItem (IDC_Command));

    if (strCommand.empty())
    {
        CStr strError;
        strError.LoadString(GetStringModule(),
                             IDS_TaskProps_ErrorNoCommand);

        MessageBox (strError);
        ::SetFocus (GetDlgItem (IDC_Command));
        return (-1);
    }
    return IDD_TASK_WIZARD_NAME_PAGE;
}

LRESULT
CTaskCmdLinePage::OnInitDialog( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    // Attach HWNDs to CWindows
    m_wndRightArrowButton     = GetDlgItem (IDC_BrowseForArguments);
    m_wndWindowStateCombo     = GetDlgItem (IDC_CommandWindowStateCombo);

    // the menu arrow (OBM_NARROW) is defined by the system.
    m_hBitmapRightArrow = LoadBitmap(NULL, MAKEINTRESOURCE(OBM_MNARROW));
    m_wndRightArrowButton.SetBitmap(m_hBitmapRightArrow);

    // populate the combo boxes
    m_wndWindowStateCombo.  InsertStrings (s_rgidWindowStates,     countof (s_rgidWindowStates));


    // select the appropriate items in the combo boxes
    switch (ConsoleTask().GetWindowState())
    {
        case eState_Restored:
            m_wndWindowStateCombo.SelectItemByData(IDS_TaskProps_Restored);
            break;

        case eState_Minimized:
            m_wndWindowStateCombo.SelectItemByData(IDS_TaskProps_Minimized);
            break;

        case eState_Maximized:
            m_wndWindowStateCombo.SelectItemByData(IDS_TaskProps_Maximized);
            break;
    }

    ::SetDlgItemText (m_hWnd, IDC_Command,           ConsoleTask().GetCommand().data());
    ::SetDlgItemText (m_hWnd, IDC_CommandArgs,       ConsoleTask().GetParameters().data());
    ::SetDlgItemText (m_hWnd, IDC_CommandWorkingDir, ConsoleTask().GetDirectory().data());

    return 0;
}

LRESULT
CTaskCmdLinePage::OnBrowseForArguments(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    CCommandLineArgumentsMenu commandLineArgumentsMenu(m_hWnd, IDC_BrowseForArguments,
                                    PTaskpadFrame()->PViewData()->GetListCtrl());
    if(commandLineArgumentsMenu.Popup())
    {
        HWND hWndCommandArgs = ::GetDlgItem(m_hWnd, IDC_CommandArgs);

        // replace the selection appropriately.
        ::SendMessage(hWndCommandArgs, EM_REPLACESEL, (WPARAM)(BOOL) true /*fCanUndo*/,
            (LPARAM)(LPCTSTR)commandLineArgumentsMenu.GetResultString());

        ::SetFocus(hWndCommandArgs);
    }

    return 0;
}


/*+-------------------------------------------------------------------------*
 * CTaskCmdLinePage::OnBrowseForCommand
 *
 *
 *--------------------------------------------------------------------------*/

LRESULT
CTaskCmdLinePage::OnBrowseForCommand (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    tstring strCommand = MMC::GetWindowText (GetDlgItem (IDC_Command));

    CStr strFilter;
    strFilter.LoadString(GetStringModule(), IDS_TaskProps_ProgramFilter);

    /*
     * The file dialog expects embedded \0's in the string, but those
     * don't load well.  The string in the resource file has \\ where
     * the \0 should be, so let's make the substitution now.
     */
    for (LPTSTR pch = strFilter.GetBuffer (0); *pch != _T('\0'); pch++)
    {
        if (*pch == _T('\\'))
            *pch = _T('\0');
    }
    // don't call ReleaseBuffer, since the string now contains \0 chars

    WTL::CFileDialog dlg (true, NULL, strCommand.data(),
                          OFN_FILEMUSTEXIST | OFN_HIDEREADONLY,
                          strFilter, m_hWnd);

    if (dlg.DoModal() == IDOK)
        SetDlgItemText (IDC_Command, dlg.m_szFileName);

    return (0);
}


/*+-------------------------------------------------------------------------*
 * BrowseForWorkingDirCallback
 *
 * Helper function for CTaskPropertiesBase::OnBrowseForWorkingDir.  It is
 * used to select the current working directory when the "Pick a Directory"
 * dialog is displayed.
 *--------------------------------------------------------------------------*/

int CALLBACK BrowseForWorkingDirCallback (HWND hwnd, UINT msg, LPARAM lParam, LPARAM lpData)
{
    /*
     * once the dialog is initialized, pre-select
     * the current working directory (if there is one)
     */
    if ((msg == BFFM_INITIALIZED) && (lpData != NULL))
        SendMessage (hwnd, BFFM_SETSELECTION, true, lpData);

    return (0);
}


/*+-------------------------------------------------------------------------*
 * CTaskPropertiesBase::OnBrowseForWorkingDir
 *
 *
 *--------------------------------------------------------------------------*/

LRESULT
CTaskCmdLinePage::OnBrowseForWorkingDir (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    TCHAR szDisplayName[MAX_PATH];
    tstring strCurrentDir = MMC::GetWindowText (GetDlgItem (IDC_CommandWorkingDir));

    BROWSEINFO bi;
    bi.hwndOwner      = m_hWnd;
    bi.pidlRoot       = NULL;
    bi.pszDisplayName = szDisplayName;
    bi.lpszTitle      = NULL;
    bi.ulFlags        = BIF_RETURNONLYFSDIRS;
    bi.lpfn           = BrowseForWorkingDirCallback;
    bi.lParam         = (strCurrentDir.empty()) ? NULL : (LPARAM) strCurrentDir.data();
    bi.iImage         = 0;

    LPITEMIDLIST pidlWorkingDir = SHBrowseForFolder (&bi);

    if (pidlWorkingDir != NULL)
    {
        /*
         * expand the pidl and put the working directory into the control
         */
        SHGetPathFromIDList (pidlWorkingDir, szDisplayName);
        SetDlgItemText (IDC_CommandWorkingDir, szDisplayName);

        /*
         * free the pidl
         */
        IMallocPtr spMalloc;
        SHGetMalloc (&spMalloc);
        spMalloc->Free (pidlWorkingDir);
    }

    return (0);
}

//############################################################################
//############################################################################
//
//  Implementation of class CTempAMCView
//
//############################################################################
//############################################################################

CNode* CTempAMCView::Create (CConsoleFrame* pFrame, CNode* pRootNode)
{
    ASSERT (pRootNode != NULL);
    return (Create (pFrame, pRootNode->GetMTNode()));
}

CNode* CTempAMCView::Create (CConsoleFrame* pFrame, CMTNode* pRootMTNode)
{
    ASSERT (pRootMTNode != NULL);
    return (Create (pFrame, pRootMTNode->GetID()));
}

CNode* CTempAMCView::Create (CConsoleFrame* pFrame, MTNODEID idRootNode)
{
    HRESULT hr;

    ASSERT (idRootNode != 0);
    ASSERT (pFrame != NULL);
    CConsoleView* pConsoleView = NULL;

    /*
     * clean up an existing view
     */
    Destroy();
    ASSERT (m_pViewData == NULL);

    /*
     * create a new view
     */
    CreateNewViewStruct cnvs;
    cnvs.idRootNode     = idRootNode;
    cnvs.lWindowOptions = MMC_NW_OPTION_NOPERSIST;
    cnvs.fVisible       = false;

    SC sc = pFrame->ScCreateNewView(&cnvs);
    if (sc)
        goto Error;

    m_pViewData = reinterpret_cast<CViewData*>(cnvs.pViewData);

    /*
     * select the new view's root node (can't fail)
     */
    pConsoleView = GetConsoleView();
    ASSERT (pConsoleView != NULL);

    if (pConsoleView != NULL)
        sc = pConsoleView->ScSelectNode (idRootNode);

    if (sc)
        goto Error;

    return (CNode::FromHandle(cnvs.hRootNode));

Cleanup:
    return (NULL);
Error:
    TraceError (_T("CTempAMCView::Create"), sc);
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\toolbar.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       toolbar.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



//////////////////////////////////////////////////////////////////////////////
// IToolbar implementation

DEBUG_DECLARE_INSTANCE_COUNTER(CToolbar);

CToolbar::CToolbar()
{
    m_pControlbar = NULL;
    m_pToolbarIntf  = NULL;

    DEBUG_INCREMENT_INSTANCE_COUNTER(CToolbar);
}

CToolbar::~CToolbar()
{
    DECLARE_SC(sc, _T("CToolbar::~CToolbar"));

    // Destroy the toolbar UI.
	if (m_pToolbarIntf)
	{
		sc = m_pToolbarIntf->ScDelete(this);
		if (sc)
	        sc.TraceAndClear();

	    m_pToolbarIntf  = NULL;
	}

    // Controlbar has a reference to this object, ask it
    // to stop referencing this object.
    if (m_pControlbar)
    {
        m_pControlbar->DeleteFromToolbarsList(this);
        m_pControlbar = NULL;
    }

    DEBUG_DECREMENT_INSTANCE_COUNTER(CToolbar);
}

//+-------------------------------------------------------------------
//
//  Member:     AddBitmap
//
//  Synopsis:   Add bitmaps for given toolbar.
//
//  Arguments:
//              [nImages] - Number of bitmap images.
//              [hbmp]    - Handle to the bitmap.
//              [cxSize]  - Size of the bitmap.
//              [cySize]  - Size of the bitmap.
//              [crMask]  - color mask.
//
//  Returns:    HRESULT
//
// Note: We support only 16x16 bitmaps for toolbars.
//
//--------------------------------------------------------------------
STDMETHODIMP CToolbar::AddBitmap(int nImages, HBITMAP hbmp, int cxSize,
                                 int cySize, COLORREF crMask)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IToolbar::AddBitmap"));

    if (hbmp == NULL || nImages < 1 || cxSize < 1 || cySize < 1)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Invalid Arguments"), sc);
        return sc.ToHr();
    }

    // Note: We support only 16x16 bitmaps for toolbars.
    if (cxSize != BUTTON_BITMAP_SIZE || cySize != BUTTON_BITMAP_SIZE)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Invalid Bitmap size"), sc);
        return sc.ToHr();
    }

    sc = ScCheckPointers(m_pToolbarIntf, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_pToolbarIntf->ScAddBitmap(this, nImages, hbmp, crMask);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:     AddButtons
//
//  Synopsis:   Add buttons for given toolbar.
//
//  Arguments:
//              [nButtons]  - Number of buttons.
//              [lpButtons] - Array of MMCBUTTONS to be added.
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CToolbar::AddButtons(int nButtons, LPMMCBUTTON lpButtons)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IToolbar::AddButtons"));

    if ( (lpButtons == NULL) || (nButtons < 1) )
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Invalid Args"), sc);
        return sc.ToHr();
    }

    sc = ScCheckPointers(m_pToolbarIntf, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_pToolbarIntf->ScAddButtons(this, nButtons, lpButtons);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:     InsertButton
//
//  Synopsis:   Add buttons for given toolbar at given index.
//
//  Arguments:
//              [nButtons] - Index at which this button is to be added.
//              [lpButton] - Ptr to MMCBUTTON to be added.
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CToolbar::InsertButton(int nIndex, LPMMCBUTTON lpButton)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IToolbar::InsertButton"));

    if ( (lpButton == NULL) || (nIndex < 0) )
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Invalid Args"), sc);
        return sc.ToHr();
    }

    sc = ScCheckPointers(m_pToolbarIntf, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_pToolbarIntf->ScInsertButton(this, nIndex, lpButton);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:     DeleteButton
//
//  Synopsis:   Delete the button at given index.
//
//  Arguments:
//              [nIndex] - Index of the button to be deleted.
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CToolbar::DeleteButton(int nIndex)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IToolbar::DeleteButton"));

    if (nIndex < 0)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Invalid index"), sc);
        return sc.ToHr();
    }

    sc = ScCheckPointers(m_pToolbarIntf, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_pToolbarIntf->ScDeleteButton(this, nIndex);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:     GetTBStateFromMMCButtonState
//
//  Synopsis:   We use MMC_BUTTON_STATE for Set/Get Button States &
//              use TBSTATE for Insert/Add Buttons.
//              This method helps Get/Set ButtonState methods to translate
//              the MMC_BUTTON_STATEs to TBSTATE so that conui deals only
//              with TBSTATE.
//
//  Arguments:  [nState] - MMC_BUTTON_STATE to be transformed.
//
//  Returns:    TBSTATE value.
//
//--------------------------------------------------------------------
BYTE CToolbar::GetTBStateFromMMCButtonState(MMC_BUTTON_STATE nState)
{
    switch (nState)
    {
    case ENABLED:
        return TBSTATE_ENABLED;
        break;

    case CHECKED:
        return TBSTATE_CHECKED;
        break;

    case HIDDEN:
        return TBSTATE_HIDDEN;
        break;

    case INDETERMINATE:
        return TBSTATE_INDETERMINATE;
        break;

    case BUTTONPRESSED:
        return TBSTATE_PRESSED;
        break;

    default:
        ASSERT(FALSE); // Invalid option
        return 0;
    }
}

//+-------------------------------------------------------------------
//
//  Member:     GetButtonState
//
//  Synopsis:   Is the given state of a button set or not.
//
//  Arguments:
//              [idCommand] - Command id of the button.
//              [nState]    - State needed.
//              [pbState]   - Is the above state set or reset.
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CToolbar::GetButtonState(int idCommand, MMC_BUTTON_STATE nState,
                                      BOOL* pbState)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IToolbar::GetButtonState"));

    if (pbState == NULL)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL pointer"), sc);
        return sc.ToHr();
    }

    sc = ScCheckPointers(m_pToolbarIntf, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_pToolbarIntf->ScGetButtonState(this, idCommand,
                                          GetTBStateFromMMCButtonState(nState),
                                          pbState);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:     SetButtonState
//
//  Synopsis:   Modify  the given state of a button.
//
//  Arguments:
//              [idCommand] - Command id of the button.
//              [nState]    - State to be modified.
//              [bState]    - Set or Reset the state.
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CToolbar::SetButtonState(int idCommand, MMC_BUTTON_STATE nState,
                                      BOOL bState)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IToolbar::SetButtonState"));

    sc = ScCheckPointers(m_pToolbarIntf, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_pToolbarIntf->ScSetButtonState(this, idCommand,
                                          GetTBStateFromMMCButtonState(nState),
                                          bState);
    if (sc)
        return sc.ToHr();

    return (sc.ToHr());
}


//+-------------------------------------------------------------------
//
//  Member:     ScAttach
//
//  Synopsis:   Attach this toolbar to UI.
//
//  Arguments:  None.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CToolbar::ScAttach()
{
    DECLARE_SC(sc, _T("CToolbar::ScAttach"));

    sc = ScCheckPointers(m_pToolbarIntf, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_pToolbarIntf->ScAttach(this);
    if (sc)
        return sc.ToHr();

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:     ScDetach
//
//  Synopsis:   Detach this toolbar from the UI.
//
//  Arguments:  None.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CToolbar::ScDetach()
{
    DECLARE_SC(sc, _T("CToolbar::ScDetach"));

    sc = ScCheckPointers(m_pToolbarIntf, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_pToolbarIntf->ScDetach(this);
    if (sc)
        return sc.ToHr();

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:     ScShow
//
//  Synopsis:   Show/Hide this toolbar.
//
//  Arguments:
//            [bShow] - Show or Hide.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CToolbar::ScShow(BOOL bShow)
{
    DECLARE_SC(sc, _T("CToolbar::ScShow"));

    sc = ScCheckPointers(m_pToolbarIntf, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = (bShow ? m_pToolbarIntf->ScAttach(this) : m_pToolbarIntf->ScDetach(this));
    if (sc)
        return sc.ToHr();

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:     ScNotifyToolBarClick
//
//  Synopsis:   Notify the snapin about a tool button is click.
//
//  Arguments:  [pNode]             - CNode* that owns result pane.
//              [bScope]            - Scope or Result.
//              [lResultItemCookie] - If Result pane is selected the item param.
//              [nID]               - Command ID of the tool button clicked.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CToolbar::ScNotifyToolBarClick(HNODE hNode, bool bScope,
                                     LPARAM lResultItemCookie, UINT nID)
{
    DECLARE_SC(sc, _T("CToolbar::ScNotifyToolbarClick"));

    if (NULL == m_pControlbar)
        return (sc = E_UNEXPECTED);

    sc = m_pControlbar->ScNotifySnapinOfToolBtnClick(hNode, bScope, lResultItemCookie, nID);
    if (sc)
        return sc;

    return(sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CToolbar::ScAMCViewToolbarsBeingDestroyed
//
//  Synopsis:    The CAMCViewToolbars object is going away, do not
//               reference that object anymore.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CToolbar::ScAMCViewToolbarsBeingDestroyed ()
{
    DECLARE_SC(sc, _T("CToolbar::ScAMCViewToolbarsBeingDestroyed"));

    m_pToolbarIntf = NULL;

    return (sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\typeinfo.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       typeinfo.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"


/***************************************************************************\
 *
 * METHOD:  COleCacheCleanupManager::GetSingletonObject
 *
 * PURPOSE: returns singe static object 
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    COleCacheCleanupManager& reference to static singleton
 *
\***************************************************************************/
COleCacheCleanupManager& COleCacheCleanupManager::GetSingletonObject()
{
    static COleCacheCleanupManager s_OleCleanupManager;
    return s_OleCleanupManager;
}

/***************************************************************************\
 *
 * METHOD:  COleCacheCleanupManager::ScReleaseCachedOleObjects
 *
 * PURPOSE: static function. forwards the call to the global object
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC COleCacheCleanupManager::ScReleaseCachedOleObjects()
{
    DECLARE_SC(sc, TEXT("COleCacheCleanupManager::ScReleaseCachedOleObjects"));

    sc = GetSingletonObject().ScFireEvent(COleCacheCleanupObserver::ScOnReleaseCachedOleObjects);
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  COleCacheCleanupManager::AddObserver
 *
 * PURPOSE: static function. forwards the call to the global object
 *
 * PARAMETERS:
 *    COleCacheCleanupObserver * pObserver
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
void COleCacheCleanupManager::AddOleObserver(COleCacheCleanupObserver * pObserver)
{
    if (pObserver)
        GetSingletonObject().AddObserver(*pObserver);
}


/***************************************************************************\
 *
 * METHOD:  CMMCTypeInfoHolderWrapper::CMMCTypeInfoHolderWrapper
 *
 * PURPOSE: constructor. registers as observer to COleCacheCleanupManager
 *
 * PARAMETERS:
 *
\***************************************************************************/
CMMCTypeInfoHolderWrapper::CMMCTypeInfoHolderWrapper(CComTypeInfoHolder& rInfoHolder) :
m_rInfoHolder(rInfoHolder)
{
    COleCacheCleanupManager::AddOleObserver(this);
}

/***************************************************************************\
 *
 * METHOD:  CMMCTypeInfoHolderWrapper::ScOnReleaseCachedOleObjects
 *
 * PURPOSE: calls clear on CComTypeInfoHolder ensurin there is no cached 
 *          OLE references left
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCTypeInfoHolderWrapper::ScOnReleaseCachedOleObjects()
{
    DECLARE_SC(sc, TEXT("ScOnReleaseCachedOleObjects"));

    DWORD_PTR dw = reinterpret_cast<DWORD_PTR>(&m_rInfoHolder);
    CComTypeInfoHolder::Cleanup(dw);

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMMCComCacheCleanup::ReleaseCachedOleObjects
 *
 * PURPOSE: called fron CONUI side to inform that MMC is going to uninitialize ole
 *          and it's a good time to release all cached com objects
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
STDMETHODIMP CMMCComCacheCleanup::ReleaseCachedOleObjects()
{
    DECLARE_SC(sc, TEXT("CMMCComCacheCleanup::ReleaseCachedOleObjects"));

    sc = COleCacheCleanupManager::ScReleaseCachedOleObjects();
    if  (sc)
        return sc.ToHr();

    return sc.ToHr();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\verbs.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       verbs.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4/9/1997   RaviR   Created
//____________________________________________________________________________
//


#include "stdafx.h"
#include "multisel.h"
#include "tasks.h"
#include "scopndcb.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#ifdef DBG
CTraceTag tagVerbs(TEXT("Verbs"), TEXT("Verbs"));
#endif


//############################################################################
//############################################################################
//
//  Implementation of class CConsoleVerbImpl
//
//############################################################################
//############################################################################

BYTE GetTBSTATE(MMC_BUTTON_STATE mmcState)
{
    switch (mmcState)
    {
    case ENABLED:       return TBSTATE_ENABLED;
    case CHECKED:       return TBSTATE_CHECKED;
    case HIDDEN:        return TBSTATE_HIDDEN;
    case INDETERMINATE: return TBSTATE_INDETERMINATE;
    case BUTTONPRESSED: return TBSTATE_PRESSED;
    default:
        ASSERT(0);
        return TBSTATE_ENABLED;
    }
}

EVerb GetEVerb(MMC_CONSOLE_VERB cVerb)
{
    switch (cVerb)
    {
    case MMC_VERB_OPEN:         return evOpen;
    case MMC_VERB_CUT:          return evCut;
    case MMC_VERB_COPY:         return evCopy;
    case MMC_VERB_PASTE:        return evPaste;
    case MMC_VERB_DELETE:       return evDelete;
    case MMC_VERB_PROPERTIES:   return evProperties;
    case MMC_VERB_RENAME:       return evRename;
    case MMC_VERB_REFRESH:      return evRefresh;
    case MMC_VERB_PRINT:        return evPrint;
    default:
        ASSERT(0 && "UNexpected");
        return evOpen;
    }
}

MMC_CONSOLE_VERB GetConsoleVerb(EVerb eVerb)
{
    switch (eVerb)
    {
    case evOpen:         return MMC_VERB_OPEN;
    case evCopy:         return MMC_VERB_COPY;
    case evCut:          return MMC_VERB_CUT;
    case evPaste:        return MMC_VERB_PASTE;
    case evDelete:       return MMC_VERB_DELETE;
    case evProperties:   return MMC_VERB_PROPERTIES;
    case evRename:       return MMC_VERB_RENAME;
    case evRefresh:      return MMC_VERB_REFRESH;
    case evPrint:        return MMC_VERB_PRINT;
    default:
        ASSERT(0 && "UNexpected");
        return MMC_VERB_OPEN;
    }
}


DEBUG_DECLARE_INSTANCE_COUNTER(CConsoleVerbImpl);

CConsoleVerbImpl::CConsoleVerbImpl()
    : m_DefaultVerb(MMC_VERB_OPEN), m_pVerbSet(NULL), m_bCutVerbDisabledBySnapin(false)
{
#ifdef DBG
    DEBUG_INCREMENT_INSTANCE_COUNTER(CConsoleVerbImpl);
    dbg_cRef_CConsoleVerbImpl = 0;
#endif
}


#ifdef DBG
ULONG CConsoleVerbImpl::InternalAddRef()
{
    ++dbg_cRef_CConsoleVerbImpl;
    return CComObjectRoot::InternalAddRef();
}
ULONG CConsoleVerbImpl::InternalRelease()
{
    --dbg_cRef_CConsoleVerbImpl;
    return CComObjectRoot::InternalRelease();
}
#endif // DBG


CConsoleVerbImpl::~CConsoleVerbImpl()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CConsoleVerbImpl);
}


STDMETHODIMP
CConsoleVerbImpl::GetVerbState(
    MMC_CONSOLE_VERB eCmdID,
    MMC_BUTTON_STATE nState,
    BOOL* pbState)
{
    DECLARE_SC(sc, TEXT("CConsoleVerbImpl::GetVerbState"));
    sc = ScCheckPointers(pbState);
    if (sc)
        return sc.ToHr();

    LPCONSOLE_VERB_STATE pCS = GetConsoleVerbState(eCmdID);
    sc = ScCheckPointers(pCS, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    /*
     * Special case for cut verb:
     *
     * Pre MMC2.0 : Snapin never called IConsoleVerb::SetVerbState with cut verb
     * except with (cut, disable) state, to enable cut the Snapin has to enable
     * copy & delete verbs.
     *
     * MMC2.0 : snapin can enable/disable cut verb just like any other verb.
     * Then if hidden hide it.
     *
     * If snapin has enabled or disabled the cut verb then below BLOCK1 is
     * irrelevant, the BLOCK2 will override the value.
     * If snapin did not enable the cut verb but enabled copy & delete then
     * the block BLOCK2. set the cut verb appropriately.
     */

    // BLOCK1. Special case for MMC1.2 cut verb.
    if ( (eCmdID == MMC_VERB_CUT) && (!m_bCutVerbDisabledBySnapin) )
    {
        // Pre MMC2.0
        LPCONSOLE_VERB_STATE pCSDelete = GetConsoleVerbState(MMC_VERB_DELETE);
        LPCONSOLE_VERB_STATE pCSCopy = GetConsoleVerbState(MMC_VERB_COPY);
        sc = ScCheckPointers(pCSDelete, pCSCopy, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        if (TBSTATE_ENABLED & pCSCopy->GetState() & pCSDelete->GetState())
        {
            // Set Cut verb to be not hidden & enabled.
            pCS->SetState(pCS->GetState() & ~GetTBSTATE(HIDDEN));
            pCS->SetState(pCS->GetState() | GetTBSTATE(ENABLED));
        }
    }

    // BLOCK2. Get the given verbs state.
    *pbState = (pCS->GetState() & GetTBSTATE(nState)) ? TRUE : FALSE;

    return sc.ToHr();
}

STDMETHODIMP
CConsoleVerbImpl::SetVerbState(
    MMC_CONSOLE_VERB eCmdID,
    MMC_BUTTON_STATE nState,
    BOOL bState)
{
    MMC_TRY

    LPCONSOLE_VERB_STATE pCS = GetConsoleVerbState(eCmdID);
    ASSERT(pCS != NULL);
    if (pCS == NULL)
        return E_FAIL;

    // If snapin has enabled/disabled cut verb note it.
    // Used by CConsoleVerbImpl::GetVerbState.
    if ( (MMC_VERB_CUT == eCmdID) && (nState & ENABLED) )
        m_bCutVerbDisabledBySnapin = (bState == FALSE);

    if (bState)
        pCS->SetState(pCS->GetState() | GetTBSTATE(nState));
    else
        pCS->SetState(pCS->GetState() & ~GetTBSTATE(nState));


    if (nState == HIDDEN && bState == TRUE)
    {
        pCS->SetHiddenBySnapin(true);
    }

    /*
     * If we're enabling, make sure the verb is not hidden.
     * We do this for compatibility.  For v1.0, the default state
     * for a verb was disabled and visible when it actually should
     * have been disabled and hidden.  Therefore, v1.0 snap-ins could
     * have written
     *
     *      pConsoleVerb->SetVerbState (verb, ENABLED, TRUE);
     *
     * and had an enabled, visible verb.  Now that we've fixed the
     * default state (bug 150874), we need to make sure v1.0 snap-ins
     * that wrote code like the above will still work as they used to.
     */
    if ((nState == ENABLED) && (bState == TRUE) && (!pCS->IsHiddenBySnapin()))
        pCS->SetState(pCS->GetState() & ~GetTBSTATE(HIDDEN));

    ASSERT(GetVerbSet() != NULL);
    if (GetVerbSet() != NULL)
        GetVerbSet()->Notify(this, eCmdID);

    return S_OK;

    MMC_CATCH
}

HRESULT CConsoleVerbImpl::SetDisabledAll(void)
{
    for(int i=0; i< evMax; i++)
        m_rgConsoleVerbStates[i].Disable();

	m_bCutVerbDisabledBySnapin = false;

    return S_OK;
}

STDMETHODIMP CConsoleVerbImpl::SetDefaultVerb(MMC_CONSOLE_VERB eCmdID)
{
    m_DefaultVerb = eCmdID;
    return S_OK;
}

LPCONSOLE_VERB_STATE CConsoleVerbImpl::GetConsoleVerbState(MMC_CONSOLE_VERB eCmdID)
{
    if( (eCmdID < MMC_VERB_FIRST) || (eCmdID > MMC_VERB_LAST) )
        return NULL;
    else
        return &m_rgConsoleVerbStates[eCmdID- MMC_VERB_FIRST];
}


//############################################################################
//############################################################################
//
//  Implementation of class CVerbSet
//
//############################################################################
//############################################################################

DEBUG_DECLARE_INSTANCE_COUNTER(CVerbSet);

/*+-------------------------------------------------------------------------*
 *
 * _QueryConsoleVerb
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    CNode*         pNode :
 *    LPCONSOLEVERB* ppConsoleVerb :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT _QueryConsoleVerb(CNode* pNode, LPCONSOLEVERB* ppConsoleVerb)
{
    DECLARE_SC(sc, TEXT("::_QueryConsoleVerb"));
    sc = ScCheckPointers(pNode, ppConsoleVerb);
    if (sc)
        return sc.ToHr();

    *ppConsoleVerb = NULL;

    CComponent *pComponent = pNode->GetPrimaryComponent();
    sc = ScCheckPointers(pComponent, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    IFramePrivate *pFrame = pComponent->GetIFramePrivate();
    sc = ScCheckPointers(pFrame, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = pFrame->QueryConsoleVerb(ppConsoleVerb);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}


/*+-------------------------------------------------------------------------*
 *
 * CVerbSetBase::_GetVerbState
 *
 * PURPOSE:  Return the state of given verb. The state is in current
 *           IConsoleVerb ptr. Translate the states from this object
 *           into the SVerbState array.
 *
 * PARAMETERS:
 *    EVerb  ev :
 *
 * RETURNS:
 *    BYTE
 *
 *+-------------------------------------------------------------------------*/
BYTE CVerbSetBase::_GetVerbState(EVerb ev)
{
    if (m_rbVerbState[ev].bAskSnapin != 1)
        return m_rbVerbState[ev].nState;

    if (m_spConsoleVerbCurr == NULL)
        return 0;

    m_rbVerbState[ev].nState = 0; // reset
    MMC_CONSOLE_VERB verb = ::GetConsoleVerb(ev);
    BOOL bReturn = FALSE;

    m_spConsoleVerbCurr->GetVerbState(verb, ENABLED, &bReturn);
    if (bReturn == TRUE)
        m_rbVerbState[ev].nState |= TBSTATE_ENABLED;

    m_spConsoleVerbCurr->GetVerbState(verb, HIDDEN, &bReturn);
    if (bReturn == TRUE)
        m_rbVerbState[ev].nState |= TBSTATE_HIDDEN;

    m_rbVerbState[ev].bAskSnapin = 2;
    return m_rbVerbState[ev].nState;
}


/*+-------------------------------------------------------------------------*
 *
 * CVerbSetBase::ScComputeVerbStates
 *
 * PURPOSE:     With given context like scope or result, if result is it background
 *              or ocx or web or multiselection compute the verbstates.
 *
 *              Eventhough snapin can set any verb for its items certain verbs are
 *              not valid in some circumstances. This method takes care of that.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC CVerbSetBase::ScComputeVerbStates()
{
    DECLARE_SC(sc, TEXT("CVerbSetBase::ScComputeVerbStates"));

    // reset
    m_spConsoleVerbCurr = NULL;
    for (int i=0; i<evMax; ++i)
    {
        m_rbVerbState[i].nState = TBSTATE_HIDDEN;
        m_rbVerbState[i].bAskSnapin = 0;
    }

    // If the verb context data is invalid, we have already hidden the
    // verbs above so just return .
    if (! m_bVerbContextDataValid)
        return sc;

	sc = ScCheckPointers(m_pNode, E_UNEXPECTED);
    if (sc)
        return sc;

    BOOL   bScopeItemSelected;
    CNode *pSelectedNode = NULL;
    MMC_COOKIE cookie = -1;

    sc = CNodeCallback::ScExtractLVData(m_pNode, m_bScopePaneSelected, m_lResultCookie,
                                        &pSelectedNode, bScopeItemSelected, cookie);
    if (sc)
        return sc.ToHr();

    sc = ScCheckPointers(pSelectedNode, E_UNEXPECTED);
    if (sc)
        return sc;

	// Handle background separately (not same as scope item selected
	// which is the default handling of background).
    if (m_lResultCookie == LVDATA_BACKGROUND)
    {
        // ask snapin for PASTE, PROPERTIES & REFRESH.
        sc = _QueryConsoleVerb(pSelectedNode, &m_spConsoleVerbCurr);
        if (sc)
            return sc;

        _AskSnapin(evPaste);
        _AskSnapin(evProperties);
        _AskSnapin(evRefresh);
        _AskSnapin(evPrint);

        return sc;
    }
	else if (bScopeItemSelected)
    {
        if (pSelectedNode->IsStaticNode())
        {
            if (pSelectedNode->IsConsoleRoot())
            {
                // CONSOLE ROOT is selected

                _EnableVerb(evRename);

                _HideVerb(evOpen);
                _HideVerb(evCut);
                _HideVerb(evCopy);
                _HideVerb(evDelete);
                _HideVerb(evRefresh);
                _HideVerb(evPaste);
                _HideVerb(evPrint);

                return sc;
            }
            else
            {
                _EnableVerb(evOpen);

                // Ask the snapin if paste should be
                // enabled for its root node.
                _AskSnapin(evPaste);

                _HideVerb(evCut);
                _HideVerb(evCopy);
                _HideVerb(evDelete);
            }


            // Static-Snapin node
            // Ask snapin for RENAME, REFRESH & PROPERTIES
            sc = _QueryConsoleVerb(pSelectedNode, &m_spConsoleVerbCurr);
            if (sc)
                return sc;

            _AskSnapin(evOpen);
            _AskSnapin(evRefresh);
            _AskSnapin(evRename);
            _AskSnapin(evPrint);
            _AskSnapin(evProperties);

        }
        else
        {
            // ask snapin for all the verbs.
            sc = _QueryConsoleVerb(pSelectedNode, &m_spConsoleVerbCurr);
            if (sc)
                return sc;

            _AskSnapin(evOpen);
            _AskSnapin(evCut);
            _AskSnapin(evCopy);
            _AskSnapin(evPaste);
            _AskSnapin(evDelete);
            _AskSnapin(evRename);
            _AskSnapin(evRefresh);
            _AskSnapin(evPrint);
            _AskSnapin(evProperties);
        }
    }
    else if (m_lResultCookie == LVDATA_MULTISELECT)
    {
        ASSERT(!bScopeItemSelected);

		if (! m_pMultiSelection)
		{
			CViewData *pViewData = pSelectedNode->GetViewData();
			sc = ScCheckPointers(pViewData, E_UNEXPECTED);
			if (sc)
				return sc;


			m_pMultiSelection = pViewData->GetMultiSelection();
			sc = ScCheckPointers(m_pMultiSelection, E_UNEXPECTED);
			if (sc)
				return sc;
		}

        // if selectedf items are from the primary snapin ask the snapin for all the verbs.

        // Does all the selected items belong to the primary snapin?
        if (m_pMultiSelection->IsSingleSnapinSelection())
        {
            // If so ask the snapin for properties
            sc = _QueryConsoleVerb(pSelectedNode, &m_spConsoleVerbCurr);
            if (sc)
                return sc;

            _AskSnapin(evCut);
            _AskSnapin(evCopy);
            _AskSnapin(evDelete);
            _AskSnapin(evProperties);
            _AskSnapin(evPrint);
        }
        else
        {
            // Multiple snapin items are selected. Even if one item
            // supports cut/copy/delete then enable the verb.
            BOOL bEnable = false;
            sc = m_pMultiSelection->ScIsVerbEnabledInclusively(MMC_VERB_CUT, bEnable);
            if (sc)
                return sc;
            _EnableVerb(evCut, bEnable);

            bEnable = false;
            sc = m_pMultiSelection->ScIsVerbEnabledInclusively(MMC_VERB_COPY, bEnable);
            if (sc)
                return sc;
            _EnableVerb(evCopy, bEnable);

            bEnable = false;
            sc = m_pMultiSelection->ScIsVerbEnabledInclusively(MMC_VERB_DELETE, bEnable);
            if (sc)
                return sc;
            _EnableVerb(evDelete, bEnable);
        }
    } else if ( (m_lResultCookie == LVDATA_CUSTOMOCX) ||
                (m_lResultCookie == LVDATA_CUSTOMWEB) )
    {
        // ask snapin for all the verbs.
        sc = _QueryConsoleVerb(pSelectedNode, &m_spConsoleVerbCurr);
        if (sc)
            return sc;

        _AskSnapin(evOpen);
        _AskSnapin(evCut);
        _AskSnapin(evCopy);
        _AskSnapin(evPaste);
        _AskSnapin(evDelete);
        _AskSnapin(evRename);
        _AskSnapin(evRefresh);
        _AskSnapin(evPrint);
        _AskSnapin(evProperties);

        return sc;
    }
    else
    {
        // ask snapin for all the verbs.
        sc = _QueryConsoleVerb(pSelectedNode, &m_spConsoleVerbCurr);
        if (sc)
            return sc;

        _AskSnapin(evOpen);
        _AskSnapin(evCut);
        _AskSnapin(evCopy);
        _AskSnapin(evPaste);
        _AskSnapin(evDelete);
        _AskSnapin(evRename);
        _AskSnapin(evRefresh);
        _AskSnapin(evPrint);
        _AskSnapin(evProperties);
    }

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CVerbSetBase::GetVerbState
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    MMC_CONSOLE_VERB  cVerb :
 *    MMC_BUTTON_STATE  nState :
 *    BOOL*             pbState :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CVerbSetBase::GetVerbState(
    MMC_CONSOLE_VERB cVerb,
    MMC_BUTTON_STATE nState,
    BOOL* pbState)
{
    *pbState = (_GetVerbState(GetEVerb(cVerb)) & GetTBSTATE(nState)) ? TRUE : FALSE;
    return S_OK;
}

STDMETHODIMP
CVerbSetBase::GetDefaultVerb(
    MMC_CONSOLE_VERB* peCmdID)
{
    DECLARE_SC(sc, TEXT("CVerbSetBase::GetDefaultVerb"));
	sc = ScCheckPointers(peCmdID);
	if (sc)
		return sc.ToHr();

    *peCmdID = MMC_VERB_NONE;

    if ( (m_bVerbContextDataValid) && (m_lResultCookie == LVDATA_MULTISELECT) )
        return sc.ToHr();

    if (m_spConsoleVerbCurr == NULL) // Not an error, default verb is requested when the verbset is reset.
        return sc.ToHr();

	sc = m_spConsoleVerbCurr->GetDefaultVerb(peCmdID);
	if (sc)
		return sc.ToHr();

	return sc.ToHr();
}


/*+-------------------------------------------------------------------------*
 *
 * CVerbSet::Notify
 *
 * PURPOSE:   Update the verb state changes to standard toolbar.
 *
 * PARAMETERS:
 *    IConsoleVerb*     pCVIn :
 *    MMC_CONSOLE_VERB  cVerb :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CVerbSet::Notify(
    IConsoleVerb* pCVIn,
    MMC_CONSOLE_VERB cVerb)
{
    /*
     * MMC creates temporary verb to findout verb state for another node or item
     * and mmc also needs verb states for determining drop targets which are not
     * currently selected node. In these cases toolbar should not be changed.
     */
    if (!IsChangesToStdbarEnabled() || m_spConsoleVerbCurr != pCVIn)
        return;

    EVerb ev = GetEVerb(cVerb);
    if (m_rbVerbState[ev].bAskSnapin != 0)
    {
        m_rbVerbState[ev].bAskSnapin = 1;

        CNode *pNode = m_pNode;

        ASSERT(pNode != NULL);
        if (NULL == pNode)
            return;

        CViewData* pViewData = pNode->GetViewData();
        ASSERT(NULL != pViewData);
        if (NULL == pViewData)
            return;

        pViewData->ScUpdateStdbarVerb(cVerb);
    }
}

//+-------------------------------------------------------------------
//
//  Member:      CVerbSet::ScInitialize
//
//  Synopsis:    Given the selection context initialize the verbs by
//               sending MMCN_SELECT or MMCN_DESELECALL to snapin's
//               IComponent::Notify and computing the verbs.
//
//  Arguments:   [pNode]                 - [in] that owns view.
//               [bScope]                - [in] Scope or result item.
//               [bSelect]               - [in] Select or Deselect.
//               [bLVBackgroundSelected] - [in]
//               [lResultCookie]         - [in] If resultpane item then
//                                              this is LVDATA of the item.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CVerbSet::ScInitialize (CNode *pNode, bool bScopePaneSelected,
					       bool bSelect, bool bLVBackgroundSelected,
					       LPARAM lResultCookie)
{
    DECLARE_SC(sc, _T("CVerbSet::ScInitialize"));
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc;

    if (lResultCookie == LVDATA_MULTISELECT)
        return (sc = E_INVALIDARG);

    if (bLVBackgroundSelected)
	{
		ASSERT(lResultCookie == LVDATA_BACKGROUND);
        bScopePaneSelected = true;
	}

   /*
    * 1. Store the selection context information in the verb-set for resending
    *    MMCN_SELECT after temporary selection notifications.
    */

    CViewData *pViewData = pNode->GetViewData();
    sc = ScCheckPointers(pViewData, E_UNEXPECTED);
    if (sc)
        return sc;

    CComponent  *pCC           = NULL;

    // sanity check - if it is a result item then we need to have the valid cookie.
    // but for virtual list - cookie is just an index - it is always valid.
    // see bug #143401 why IsVirtual is needed
	if ( (! bScopePaneSelected) && (!pViewData->IsVirtualList()) &&(lResultCookie == 0))
		return (sc = E_INVALIDARG);

    /*
     * Need to send MMCN_SELECT or MMCN_DESELECTALL notification. Calculate
     * this notification now.
     */
    BOOL bListPadItem = pViewData->HasListPad() && !IS_SPECIAL_LVDATA(lResultCookie);
    MMC_NOTIFY_TYPE eNotify = MMCN_SELECT;

    // On deselect of a virtual listview item, the underlying list-view sends deselect
    // with cookie of -1. So we send MMCN_DESELECT_ALL with NULL dataobject as the
    // index of de-selected item is not known.
    if (bSelect == FALSE && lResultCookie == -1 && pViewData->IsVirtualList() == TRUE )
    {
        eNotify = MMCN_DESELECT_ALL;
		pCC     = pNode->GetPrimaryComponent();
		sc = ScCheckPointers(pCC, E_UNEXPECTED);
		if (sc)
			return sc;
    }
    else if (pViewData->HasOCX() || (pViewData->HasWebBrowser() && !bListPadItem) )
    {
        // Select/Deselect Web or OCX. (except if item is in MMC List control)
        eNotify = bSelect ? MMCN_SELECT : MMCN_DESELECT_ALL;
		pCC     = pNode->GetPrimaryComponent();
		sc = ScCheckPointers(pCC, E_UNEXPECTED);
		if (sc)
			return sc;
    }

    bool bScopeItem = bScopePaneSelected;
    IDataObjectPtr spDataObject   = NULL;
    LPDATAOBJECT lpDataObject = NULL;

    // 2. Get the dataobject & CComponent for given context.
    //    only if event is MMCN_SELECT.
    if (eNotify != MMCN_DESELECT_ALL)
    {
        sc = pNode->ScGetDataObject(bScopePaneSelected, lResultCookie, bScopeItem, &lpDataObject, &pCC);
        if (sc)
            return sc;

        sc = ScCheckPointers(lpDataObject, pCC, E_UNEXPECTED);
        if (sc)
            return sc;

		if (! IS_SPECIAL_DATAOBJECT(lpDataObject) )
			spDataObject.Attach(lpDataObject, false/*fAddRef*/);
    }

    // Before sending select reset the console verb states.
    sc = pCC->ScResetConsoleVerbStates();
    if (sc)
        return sc;

#ifdef DBG
    Trace(tagVerbs, _T("Sent (MMCN_SELECT %s %s) for permanent verb to snapin with node name %s\n"),
          bScopeItem ? _T("Scope") : _T("Result"),
          bSelect ? _T("Select") : _T("De-select"),
          pNode->GetDisplayName().data());
#endif

    SC scNoTrace = pCC->Notify(lpDataObject, eNotify, MAKELONG((WORD)bScopeItem, (WORD)bSelect), 0);
    if (scNoTrace)
	{
        TraceSnapinError(TEXT("Snapin has returned error from IComponent::Notify with MMCN_SELECT event"), scNoTrace);
	}

    Reset();
    m_bScopePaneSelected = bScopePaneSelected;
    m_bVerbContextDataValid = bSelect;
    m_lResultCookie      = lResultCookie;
    m_pNode              = pNode;

    sc = ScComputeVerbStates();
    if (sc)
        return sc;

    // If the item is deselected then the cached context information should be nuked.
    if (! bSelect)
        Reset();

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CVerbSetBase::ScInitializeForMultiSelection
//
//  Synopsis:    Initialize the verbset object for multiselection. Unlike
//               single selection in which above CVerbSet::ScInitialize is
//               used, in case of multiselect, the CMultiSelection object
//               knows what is selected in resultpane. It then gets dataobjects
//               for those selections from snapins and sends MMCN_SELECT to those
//               snapins to set verbs.
//
//  Arguments:  [pNode]   - [in] owner of resultpane.
//              [bSelect] - [in] select or deselect.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CVerbSetBase::ScInitializeForMultiSelection (CNode *pNode, bool bSelect)
{
    DECLARE_SC(sc, _T("CVerbSetBase::ScInitializeForMultiSelection"));
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc;

   /*
    * Store the selection context information in the verb-set for resending
    * MMCN_SELECT after temporary selection notifications.
    */

    Reset();
    m_bScopePaneSelected = false;
    m_bVerbContextDataValid = bSelect;
    m_lResultCookie      = LVDATA_MULTISELECT;
    m_pNode              = pNode;

    return (sc);
}

/*+-------------------------------------------------------------------------*
 * class CDisableStandardToolbarChanges
 *
 *
 * PURPOSE: A class that disables changes to standard toolbar due to
 *          temp-verb MMCN_SELECTs and enables when destructed (goes out of scope).
 *
 *+-------------------------------------------------------------------------*/
class CDisableStandardToolbarChanges
{
public:
    CDisableStandardToolbarChanges(CVerbSet* pVerbSet) : m_pVerbSet(pVerbSet)
    {
        ASSERT(pVerbSet != NULL);
        if (pVerbSet)
            pVerbSet->DisableChangesToStdbar();
    }
    ~CDisableStandardToolbarChanges()
    {
        ASSERT(m_pVerbSet != NULL);
        if (m_pVerbSet)
            m_pVerbSet->EnableChangesToStdbar();
    }

private:
    CVerbSet *m_pVerbSet;
};

//+-------------------------------------------------------------------
//
//  Member:      CTemporaryVerbSet::ScInitialize
//
//  Synopsis:    Initialize the temp verb set,
//
//               Since we are sending MMCN_SELECT notifications to the snapin
//               to calculate temp verbs,
//
//               1. first send de-select to the item for which we sent
//                  (MMCN_SELECT, true) last time.
//                  (If last one is (MMCN_SELECT,false) then skip this and 4th step)
//
//               2. Send (MMCN_SELECT, true) for temp verb calculation.
//               3. Send (MMCN_SELECT, false) for temp verb calculation.
//
//               4. Now send (MMCN_SELECT, true) to select original item (in step 1).
//
//               So we need to compute the dataobject for temp-selected item (from
//               given parameters) and for originally selected item (ask the viewdata).
//
//  Arguments:   [pNode]         - [in] bScope = true, the node that will be temp selected else
//                                      the node that owns the result pane item that is temp selected.
//               [lResultCookie] - [in] If result-item, the LPARAM (can be scope item in result pane).
//               [bScopePaneSel] - [in]
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CTemporaryVerbSet::ScInitialize (CNode *pNode, LPARAM lResultCookie, bool bScopePaneSel)
{
    DECLARE_SC(sc, _T("CTemporaryVerbSet::ScInitialize"));
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc;

    bool bScopeItem;
    LPDATAOBJECT pDataObject = NULL;
    sc = pNode->ScGetDataObject(bScopePaneSel, lResultCookie, bScopeItem, &pDataObject);
    if (sc)
        return sc;

    sc = ScCheckPointers(pDataObject, E_UNEXPECTED);
    if (sc)
        return sc;

    // take ownership & release it on time!!!
    IDataObjectPtr spDataObject( IS_SPECIAL_DATAOBJECT(pDataObject) ? NULL : pDataObject, false/*fAddRef*/);

    sc = ScInitialize(pDataObject, pNode, bScopePaneSel, lResultCookie);
    if (sc)
        return sc;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CTemporaryVerbSet::ScInitializePermanentVerbSet
//
//  Synopsis:    Send de-select or select notification to snapin for
//               the permanent verb-set object.
//
//  Arguments:   [pNode]   - [in] owner of the result pane.
//               [bSelect] - [in] true - send select notification to snapin
//                                       informing it to initialize the verbs
//
//                                false - send de-select notification to snapin
//                                        informing it to uninitialize the verbs.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CTemporaryVerbSet::ScInitializePermanentVerbSet (CNode *pNode, bool bSelect)
{
    DECLARE_SC(sc, _T("CTemporaryVerbSet::ScInitializePermanentVerbSet"));
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc;

    CViewData *pViewData = pNode->GetViewData();
    sc = ScCheckPointers(pViewData, E_UNEXPECTED);
    if (sc)
        return sc;

    // 1. SEND (de)selection to permananet verb set.
    IDataObject*   pOriginalSelDataObject = NULL;
    CComponent    *pCCOriginalSel = NULL;
    bool           bOriginalScopeSel;
    bool           bOriginallySelected;
    LPCTSTR        lpszNodeName = NULL;
    bool           bMultiSelection = false;


    SC scNoTrace = pViewData->ScIsVerbSetContextForMultiSelect(bMultiSelection);
    if (scNoTrace)
		return scNoTrace;

    /*
     * See if verb context is for multiselection.
     * If multiselection we do not send any de-select to be compatible
     * with MMC1.2, just return.
     */
    if (bMultiSelection)
        return sc;

     scNoTrace = pViewData->ScGetVerbSetData(&pOriginalSelDataObject, &pCCOriginalSel,
                                               bOriginalScopeSel, bOriginallySelected
                                               #ifdef DBG
                                               , &lpszNodeName
                                               #endif
                                               );

    if (scNoTrace)
        return sc;

    // Before sending select reset the console verb states.
    sc = pCCOriginalSel->ScResetConsoleVerbStates();
    if (sc)
        return sc;

    // take ownership & release it on time!!!
    IDataObjectPtr spDataObject( IS_SPECIAL_DATAOBJECT(pOriginalSelDataObject) ? NULL : pOriginalSelDataObject, false/*fAddRef*/);

    // If we sent MMCN_SELECT, true then send de-select else nothing.
    if ( (pOriginalSelDataObject != NULL) && (pCCOriginalSel != NULL) && (bOriginallySelected) )
    {
#ifdef DBG
        Trace(tagVerbs, _T("Sent (MMCN_SELECT %s %sselect) for permanent-verb-restore to snapin with node name %s\n"),
                            bOriginalScopeSel ? _T("Scope") : _T("Result"),
                            bSelect ? _T("") : _T("De-"),
                            lpszNodeName);
#endif

        scNoTrace = pCCOriginalSel->Notify(pOriginalSelDataObject, MMCN_SELECT,
                                           MAKELONG(bOriginalScopeSel, bSelect), 0);
        if (scNoTrace)
		{
            TraceSnapinError(TEXT("Snapin has returned error from IComponent::Notify with MMCN_SELECT event"), scNoTrace);
		}

		// Verbs were initialized, therefore recompute verbstates.
		if (bSelect)
		{
			// get the verbset
			CVerbSet* pVerbSet = dynamic_cast<CVerbSet*>( pViewData->GetVerbSet() );
			sc = ScCheckPointers( pVerbSet, E_UNEXPECTED );
			if (sc)
				return sc;

			/*
			 * The selection context information stored in this object is
			 * invalid upon de-selection of that item.
			 */
			m_bVerbContextDataValid = bSelect;
			sc = pVerbSet->ScComputeVerbStates();
			if (sc)
				return sc;
		}

    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CTemporaryVerbSet::ScInitialize
//
//  Synopsis:    Initialize the temp verb set,
//
//               Since we are sending MMCN_SELECT notifications to the snapin
//               to calculate temp verbs,
//
//               1. first send de-select to the item for which we sent
//                  (MMCN_SELECT, true) last time.
//                  (If last one is MMCN_SELECT,false then skip this and 4th step)
//
//               2. Send (MMCN_SELECT, true) for temp verb calculation.
//               3. Send (MMCN_SELECT, false) for temp verb calculation.
//
//               4. Now send (MMCN_SELECT, true) to select original item (in step 1).
//
//               So we need to compute the dataobject for temp-selected item (from
//               given parameters) and for originally selected item (ask the viewdata).
//
//  Arguments:   [lpDataObjectForTempSel]  - [in] dataobject of the temp selected object.
//               [pNodeForTempSel]         - [in] bScope = true, the node that will be temp selected else
//                                                the node that owns the result pane item that is temp selected.
//               [bTempScopePaneSel]       - [in]
//               [lResultCookie]           - [in]
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CTemporaryVerbSet::ScInitialize (LPDATAOBJECT lpDataObjectForTempSel,
                                    CNode *pNodeForTempSel,
                                    bool   bTempScopePaneSel,
									LPARAM lResultCookie)
{
    DECLARE_SC(sc, _T("CTemporaryVerbSet::ScInitialize"));
    sc = ScCheckPointers(lpDataObjectForTempSel, pNodeForTempSel);
    if (sc)
        return sc;

    // get view data
    CViewData *pViewData = pNodeForTempSel->GetViewData();
    sc = ScCheckPointers( pViewData, E_UNEXPECTED );
    if (sc)
        return sc;

    // get the verbset
    CVerbSet* pVerbSet = dynamic_cast<CVerbSet*>( pViewData->GetVerbSet() );
    sc = ScCheckPointers( pVerbSet, E_UNEXPECTED );
    if (sc)
        return sc;

    if (! pNodeForTempSel->IsInitialized())
    {
        sc = pNodeForTempSel->InitComponents();
        if (sc)
            return sc.ToHr();
    }

    CComponent *pCCTempSel = pNodeForTempSel->GetPrimaryComponent();
    sc = ScCheckPointers(pCCTempSel, E_UNEXPECTED);
    if (sc)
        return sc;

    /*
     * We create a temporary verb to get given verb's state. So inform
     * the original verb object that there is a temporary verb
     * so that standard-toolbars are not applied the temporary verb.
     */
    CDisableStandardToolbarChanges standardbarChanges(pVerbSet);

    bool bTempSelected = true; // always compute verb for selection of an item.

    Reset();
    m_bScopePaneSelected  = bTempScopePaneSel;
    m_pNode               = pNodeForTempSel;
	m_lResultCookie       = lResultCookie;

    // sanity check - if it is a result item then we need to have the valid cookie.
    // but for virtual list - cookie is just an index - it is always valid.
    // see bug #143401 why IsVirtual is needed
	if ( (! m_bScopePaneSelected) && (!pViewData->IsVirtualList()) && (m_lResultCookie == 0))
		return (sc = E_INVALIDARG);

    // Ignore the return values from IComponent::Notify

    // 1. SEND de-selection to permananet verb set.
    sc = ScInitializePermanentVerbSet (pNodeForTempSel, /*bSelect*/ false);
    if (sc)
        return sc;

    // 2. SEND selection to temporary verb set.
#ifdef DBG
    Trace(tagVerbs, _T("Sent (MMCN_SELECT %s Select) for tempverbs to snapin with node name %s\n"),
                        m_bScopePaneSelected ? _T("Scope") : _T("Result"),
                        pNodeForTempSel->GetDisplayName().data());
#endif

    // Before sending select reset the console verb states.
    sc = pCCTempSel->ScResetConsoleVerbStates();
    if (sc)
        return sc;

    SC scNoTrace = pCCTempSel->Notify(lpDataObjectForTempSel, MMCN_SELECT, MAKELONG(m_bScopePaneSelected, bTempSelected), 0);
    if (scNoTrace)
	{
        TraceSnapinError(TEXT("Snapin has returned error from IComponent::Notify with MMCN_SELECT event"), scNoTrace);
	}

    // 2.a) Compute the verbs.

    /*
     * The selection context information stored in this object is
     * invalid upon de-selection of that item.
     */
    m_bVerbContextDataValid = bTempSelected;

    sc = ScComputeVerbStates();
    if (sc)
        sc.TraceAndClear();

    // 3. SEND de-selection to temporary verb set.
#ifdef DBG
    Trace(tagVerbs, _T("Sent (MMCN_SELECT %s De-select) for tempverbs to snapin with node name %s\n"),
                        m_bScopePaneSelected ? _T("Scope") : _T("Result"),
                        pNodeForTempSel->GetDisplayName().data());
#endif

    // Before sending select reset the console verb states.
    sc = pCCTempSel->ScResetConsoleVerbStates();
    if (sc)
        return sc;

    scNoTrace = pCCTempSel->Notify(lpDataObjectForTempSel, MMCN_SELECT, MAKELONG(m_bScopePaneSelected, !bTempSelected), 0);
    if (scNoTrace)
	{
        TraceSnapinError(TEXT("Snapin has returned error from IComponent::Notify with MMCN_SELECT event"), scNoTrace);
	}

    // 4. SEND select to permanent verb set.
    sc = ScInitializePermanentVerbSet (pNodeForTempSel, /*bSelect*/ true);
    if (sc)
        return sc;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CTemporaryVerbSet::ScComputeVerbStates
//
//  Synopsis:    Since this is temp verb set, we need to get the states
//               of all verbs from CConsoleVerbImpl object immediately after
//               we sent MMCN_SELECT with item seelcted. Otherwise they will
//               be overwritten by subsequent SetVerbState (due to restore MMCN_SELECT
//               notifications).
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CTemporaryVerbSet::ScComputeVerbStates ()
{
    DECLARE_SC(sc, _T("CTemporaryVerbSet::ScComputeVerbStates"));

    sc = CVerbSetBase::ScComputeVerbStates();
    if (sc)
        return sc;

    // _GetVerbState gets the state of the verb from CConsoleVerbImpl
    // and fills it in this object's members which will be used later.
    for (int verb=evNone; verb < evMax; ++verb)
        _GetVerbState((EVerb)verb);

    // Get the default verb and store it.
    CVerbSetBase::GetDefaultVerb(&m_DefaultVerb);

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CTemporaryVerbSet::GetDefaultVerb
//
//  Synopsis:    Get the default verb for the temp sel.
//
//  Arguments:   [peCmdID] - [out] ptr to default verb.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
HRESULT CTemporaryVerbSet::GetDefaultVerb (MMC_CONSOLE_VERB* peCmdID)
{
    DECLARE_SC(sc, _T("CTemporaryVerbSet::GetDefaultVerb"));
    sc = ScCheckPointers(peCmdID);
    if (sc)
        return sc.ToHr();

    *peCmdID = m_DefaultVerb;

    return (sc.ToHr());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\typeinfo.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000 - 2000
//
//  File:       typeinfo.h
//
//--------------------------------------------------------------------------

#pragma once

#if !defined(TYPEINFO_H_INCLUDED)
#define TYPEINFO_H_INCLUDED

#include "classreg.h"

/*-------------------------------------------------------------------------*\
| The classes in this file are to provide extra cleanup functionality.
| Node Manager hosts variety of com objects - some which are solely for MMC;
| some for MMC's Object Model, but also some objects which lifetime is 
| controlled by snapins. If any of the interfaces is hold - Node Manager will
| remain locked in memory until the very end, thus - far beyond the call to
| OleUninitialize. Some objects have ole automation objects cached - 
| particularly IDispatchImpl and IProvidClassInfoImpl implemented by ATL caches
| ITypeInfo interfaces. These caches need to be released before OleUninitialize
| even if Node Manager is locked.
|
| To solve this problem we use derived template: 
| INodeManagerProvideClassInfoImpl, which inherits all functionality from ATL,
| plus registers every class once to COleCacheCleanupManager, which will receive
| the control from CONUI and cleanup the cache.
| To implement described functionality those templates construct static object
| of class CMMCTypeInfoHolderWrapper, giving the reference to static member
| caching ITypeInfo. CMMCTypeInfoHolderWrapper will register itself as observer
| for COleCacheCleanupManager events and will cleanup the cache in response to
| events requesting it.
| [clenup also included into CMMCIDispatchImpl - bas for ObjectModel objects]
\*-------------------------------------------------------------------------*/

/***************************************************************************\
 *
 * CLASS:  COleCacheCleanupObserver
 *
 * PURPOSE: defines observer interface for OLE cleanup events
 *
\***************************************************************************/
class COleCacheCleanupObserver : public CObserverBase
{
public:
    virtual SC ScOnReleaseCachedOleObjects()  = 0;
};

/***************************************************************************\
 *
 * CLASS:  COleCacheCleanupManager
 *
 * PURPOSE: this class is responsible for cleaning up the OLE object cached 
 *          by node manager. It registers all cleanup clients and, when 
 *          received the control from CONUI, will dispatch the events to all 
 *          registered observers
 *
\***************************************************************************/
class COleCacheCleanupManager : public CEventSource<COleCacheCleanupObserver>
{
    static COleCacheCleanupManager& GetSingletonObject();
public:
    static void AddOleObserver(COleCacheCleanupObserver * pObserver);
    static SC   ScReleaseCachedOleObjects();
};

/***************************************************************************\
 *
 * CLASS:  CMMCTypeInfoHolderWrapper
 *
 * PURPOSE: this class wraps type info included into given to constructor
 *          allowing it to be cleared when requested
 *
 * NOTE:    there is not lifetime management involved in this implementation,
 *          user is responsible to make given reference outliving the object
 *          of this class.
 *
\***************************************************************************/
class CMMCTypeInfoHolderWrapper : public COleCacheCleanupObserver
{
    CComTypeInfoHolder&     m_rInfoHolder;
public:
    CMMCTypeInfoHolderWrapper(CComTypeInfoHolder& rInfoHolder);
    virtual SC ScOnReleaseCachedOleObjects();
};

/***************************************************************************\
 *
 * CLASS:  INodeManagerProvideClassInfoImpl
 *
 * PURPOSE: this class is to be used in place of IProvideClassInfo2Impl
 *          for all com object created on NodeManager side.
 *          It ensures ITypeInfo will be released on request from CONUI
 *
\***************************************************************************/

template <const CLSID* pcoclsid, const IID* psrcid, const GUID* plibid = &CComModule::m_libid,
WORD wMajor = 1, WORD wMinor = 0, class tihclass = CComTypeInfoHolder>
class ATL_NO_VTABLE INodeManagerProvideClassInfoImpl : 
public IProvideClassInfo2Impl<pcoclsid, psrcid, plibid, wMajor, wMinor, tihclass>
{
public:
    INodeManagerProvideClassInfoImpl() 
    { 
        static CMMCTypeInfoHolderWrapper wrapper(GetInfoHolder()); 
    }
    // the porpose of this static function is to ensure _tih is a static variable,
    // since static wrapper will hold on its address - it must be always valid 
    static CComTypeInfoHolder& GetInfoHolder() { return _tih; }
};

/***************************************************************************\
 *
 * CLASS:  CMMCComCacheCleanup
 *
 * PURPOSE: implements IComCacheCleanup on cocreatable class to provide access
 *          from CONUI side
 *
\***************************************************************************/

class CMMCComCacheCleanup :
    public CComObjectRoot,
    public IComCacheCleanup,
    public CComCoClass<CMMCComCacheCleanup, &CLSID_ComCacheCleanup>
    {
public:
    BEGIN_COM_MAP(CMMCComCacheCleanup)
        COM_INTERFACE_ENTRY(IComCacheCleanup)
    END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(CMMCComCacheCleanup)

    DECLARE_MMC_OBJECT_REGISTRATION (
		g_szMmcndmgrDll,						// implementing DLL
        CLSID_ComCacheCleanup,   				// CLSID
        _T("ComCacheCleanup 1.0 Object"),		// class name
        _T("NODEMGR.ComCacheCleanup.1"),		// ProgID
        _T("NODEMGR.ComCacheCleanup"))		    // version-independent ProgID

public:

    STDMETHOD(ReleaseCachedOleObjects)();
};


#endif // !defined(TYPEINFO_H_INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\viewdata.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ViewData.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    5/18/1997   RaviR   Created
//____________________________________________________________________________
//

#include "stdafx.h"

#pragma hdrstop


#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "menubtn.h"
#include "viewdata.h"
#include "multisel.h"
#include "colwidth.h"
#include "conview.h"        // for CConsoleView
#include "conframe.h"

void CViewData::CreateControlbarsCache()
{
    ASSERT(m_spControlbarsCache == NULL);

    CComObject<CControlbarsCache>* pObj;
    HRESULT hr = CComObject<CControlbarsCache>::CreateInstance(&pObj);
    ASSERT(SUCCEEDED(hr));

    pObj->SetViewData(this);

    if (SUCCEEDED(hr))
        m_spControlbarsCache = pObj;
}

STDMETHODIMP CNodeInitObject::InitViewData(LONG_PTR lViewData)
{
    MMC_TRY

    if (lViewData == NULL)
        return E_INVALIDARG;

    SViewData* pVD = reinterpret_cast<SViewData*>(lViewData);
    ASSERT(pVD != NULL);
    ASSERT(pVD->m_spVerbSet == NULL);

    CViewData* pCVD = reinterpret_cast<CViewData*>(lViewData);
    ASSERT(pCVD != NULL);

    if (pVD->m_spVerbSet == NULL)
    {

        CComObject<CVerbSet>* pVerb;
        HRESULT hr = CComObject<CVerbSet>::CreateInstance(&pVerb);
        if (FAILED(hr))
            return hr;

        ASSERT(pVerb != NULL);

        pVD->m_spVerbSet = pVerb;
        ASSERT(pVD->m_spVerbSet != NULL);
        if (pVD->m_spVerbSet == NULL)
            return E_NOINTERFACE;
    }

    // See if the Column Persistence Object was created,
    // else create one.
    if ( pCVD && (pCVD->IsColumnPersistObjectInitialized() == false) )
    {
        // Create the column persistence object
        CComObject<CColumnPersistInfo>* pColData;

        HRESULT hr = CComObject<CColumnPersistInfo>::CreateInstance (&pColData);
        ASSERT(SUCCEEDED(hr) && pColData != NULL);
        if (FAILED(hr))
        {
            CStr strMsg;
            strMsg.LoadString(GetStringModule(), IDS_ColumnsCouldNotBePersisted);
            ::MessageBox(NULL, strMsg, NULL, MB_OK|MB_SYSTEMMODAL);
        }

        // Save a pointer to Column persistence object in CViewData.
        pCVD->InitializeColumnPersistObject(pColData, pColData);
    }

    return S_OK;

    MMC_CATCH
}

STDMETHODIMP CNodeInitObject::CleanupViewData(LONG_PTR lViewData)
{
    SViewData* pVD = reinterpret_cast<SViewData*>(lViewData);
    if (pVD->m_pMultiSelection != NULL)
    {
        pVD->m_pMultiSelection->Release();
        pVD->m_pMultiSelection = NULL;
    }

    return S_OK;
}

// Buttons
//
void CViewData::ShowStdButtons(bool bShow)
{
    DECLARE_SC(sc, _T("CViewData::ShowStdButtons"));

    CStdVerbButtons* pStdToolbar = GetStdVerbButtons();
    if (NULL == pStdToolbar)
    {
        sc = E_UNEXPECTED;
        return;
    }

    sc = pStdToolbar->ScShow(bShow);
}

void CViewData::ShowSnapinButtons(bool bShow)
{
    DECLARE_SC(sc, _T("CViewData::ShowSnapinButtons"));

    IControlbarsCache* pICBC = GetControlbarsCache();
    if (pICBC == NULL)
    {
        sc = E_UNEXPECTED;
        return;
    }

    CControlbarsCache* pCBC = dynamic_cast<CControlbarsCache*>(pICBC);
    if (pCBC == NULL)
    {
        sc = E_UNEXPECTED;
        return;
    }

    sc = pCBC->ScShowToolbars(bShow);
}

bool IsFlagEnabled(DWORD cache, DWORD flag)
{
    return ((cache & flag) == flag) ? true : false;
}

void CViewData::UpdateToolbars(DWORD dwTBNew)
{
    ShowStdButtons(IsFlagEnabled(dwTBNew, STD_BUTTONS));
    ShowSnapinButtons(IsFlagEnabled(dwTBNew, SNAPIN_BUTTONS));

    SetToolbarsDisplayed(dwTBNew);
}

void CViewData::ToggleToolbar(long lMenuID)
{
    DWORD dwTBOld = GetToolbarsDisplayed();
    DWORD dwTBNew = 0;

    DECLARE_SC(sc, _T("CViewData::ToggleToolbar"));

    switch (lMenuID)
    {
    case MID_STD_MENUS:
        {
            dwTBNew = dwTBOld ^ STD_MENUS;
            SetToolbarsDisplayed(dwTBNew);

            CConsoleFrame* pFrame = GetConsoleFrame();
            sc = ScCheckPointers(pFrame, E_UNEXPECTED);
            if (sc)
                return;

            sc = pFrame->ScShowMMCMenus(IsStandardMenusAllowed());
            if (sc)
                return;
        }
        break;

    case MID_STD_BUTTONS:
        dwTBNew = dwTBOld ^ STD_BUTTONS;
        ShowStdButtons(bool(dwTBNew & STD_BUTTONS));
        break;

    case MID_SNAPIN_MENUS:
        {
            dwTBNew = dwTBOld ^ SNAPIN_MENUS;
            SetToolbarsDisplayed(dwTBNew);
            CMenuButtonsMgr* pMenuButtonsMgr = GetMenuButtonsMgr();
            if (NULL != pMenuButtonsMgr)
            {
                sc = pMenuButtonsMgr->ScToggleMenuButton(IsSnapinMenusAllowed());
            }
        }
        break;

    case MID_SNAPIN_BUTTONS:
        dwTBNew = dwTBOld ^ SNAPIN_BUTTONS;
        ShowSnapinButtons(bool(dwTBNew & SNAPIN_BUTTONS));
        break;

    default:
        ASSERT(0 && "Unexpected");
        return;
    }

    SetToolbarsDisplayed(dwTBNew);
}


BOOL CViewData::RetrieveColumnData( const CLSID& refSnapinCLSID,
                                    const SColumnSetID& colID,
                                    CColumnSetData& columnSetData)
{
    CColumnPersistInfo* pColPersInfo = NULL;

    if ( (NULL != m_pConsoleData) && (NULL != m_pConsoleData->m_spPersistStreamColumnData) )
    {
        pColPersInfo = dynamic_cast<CColumnPersistInfo*>(
            static_cast<IPersistStream*>(m_pConsoleData->m_spPersistStreamColumnData));

        if (pColPersInfo)
            return pColPersInfo->RetrieveColumnData( refSnapinCLSID, colID,
                                                     GetViewID(), columnSetData);
    }

    return FALSE;
}

BOOL CViewData::SaveColumnData( const CLSID& refSnapinCLSID,
                                const SColumnSetID& colID,
                                CColumnSetData& columnSetData)
{
    CColumnPersistInfo* pColPersInfo = NULL;

    if ( (NULL != m_pConsoleData) && (NULL != m_pConsoleData->m_spPersistStreamColumnData) )
    {
        pColPersInfo = dynamic_cast<CColumnPersistInfo*>(
            static_cast<IPersistStream*>(m_pConsoleData->m_spPersistStreamColumnData));

        if (pColPersInfo)
            return pColPersInfo->SaveColumnData( refSnapinCLSID, colID,
                                                 GetViewID(), columnSetData);
    }

    return FALSE;
}

//+-------------------------------------------------------------------
//
//  Member:      CViewData::ScSaveColumnInfoList
//
//  Synopsis:    Save the CColumnInfoList for given snapin/col-id.
//
//  Arguments:   [refSnapinCLSID] - snapin GUID
//               [colID]          - column-set-id
//               [colInfoList]    - data for columns in a view.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CViewData::ScSaveColumnInfoList(const CLSID& refSnapinCLSID, const SColumnSetID& colID,
                                   const CColumnInfoList& colInfoList)
{
    DECLARE_SC(sc, _T("CViewData::ScSaveColumnInfoList"));
    sc = ScCheckPointers(m_pConsoleData, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = ScCheckPointers(m_pConsoleData->m_spPersistStreamColumnData, E_UNEXPECTED);
    if (sc)
        return sc;

    CColumnPersistInfo* pColPersInfo = dynamic_cast<CColumnPersistInfo*>(
                                       static_cast<IPersistStream*>(m_pConsoleData->m_spPersistStreamColumnData));

    sc = ScCheckPointers(pColPersInfo, E_UNEXPECTED);
    if (sc)
        return sc;

    CColumnSetData colSetData;

    // Dont care if below succeeds or not, just merge sort & column data.
    pColPersInfo->RetrieveColumnData(refSnapinCLSID, colID, GetViewID(), colSetData);

    colSetData.set_ColumnInfoList(colInfoList);

    sc = pColPersInfo->SaveColumnData(refSnapinCLSID, colID, GetViewID(), colSetData) ? S_OK : E_FAIL;
    if (sc)
        return sc;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CViewData::ScSaveColumnSortData
//
//  Synopsis:    Save the given sort data for persistence into CColumnSetData.
//
//  Arguments:   [refSnapinCLSID] - snapin GUID
//               [colID]          - column-set-id
//               [colSortInfo]    - sort-data.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CViewData::ScSaveColumnSortData(const CLSID& refSnapinCLSID, const SColumnSetID& colID,
                                   const CColumnSortInfo& colSortInfo)
{
    DECLARE_SC(sc, _T("CViewData::ScSaveColumnSortData"));

    sc = ScCheckPointers(m_pConsoleData, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = ScCheckPointers(m_pConsoleData->m_spPersistStreamColumnData, E_UNEXPECTED);
    if (sc)
        return sc;

    CColumnPersistInfo* pColPersInfo = dynamic_cast<CColumnPersistInfo*>(
                                       static_cast<IPersistStream*>(m_pConsoleData->m_spPersistStreamColumnData));

    sc = ScCheckPointers(pColPersInfo, E_UNEXPECTED);
    if (sc)
        return sc;

    CColumnSetData colSetData;

    // Dont care if below succeeds or not, just merge sort & column data.
    pColPersInfo->RetrieveColumnData(refSnapinCLSID, colID, GetViewID(), colSetData);

    CColumnSortList *pColSortList = colSetData.get_ColumnSortList();
    sc = ScCheckPointers(pColSortList, E_UNEXPECTED);
    if (sc)
        return sc;

    pColSortList->clear();
    pColSortList->push_back(colSortInfo);

    sc = pColPersInfo->SaveColumnData(refSnapinCLSID, colID, GetViewID(), colSetData) ? S_OK : E_FAIL;
    if (sc)
        return sc;

    return (sc);
}



VOID CViewData::DeleteColumnData( const CLSID& refSnapinCLSID,
                                  const SColumnSetID& colID)
{
    CColumnPersistInfo* pColPersInfo = NULL;

    if ( (NULL != m_pConsoleData) && (NULL != m_pConsoleData->m_spPersistStreamColumnData) )
    {
        pColPersInfo = dynamic_cast<CColumnPersistInfo*>(
            static_cast<IPersistStream*>(m_pConsoleData->m_spPersistStreamColumnData));

        if (pColPersInfo)
            pColPersInfo->DeleteColumnData( refSnapinCLSID, colID, GetViewID());
    }

    return;
}


/*+-------------------------------------------------------------------------*
 * CViewSettings::GetSelectedNode
 *
 * Returns a pointer to the selected node in the view.
 *--------------------------------------------------------------------------*/

CNode* CViewData::GetSelectedNode () const
{
    CConsoleView* pConsoleView = GetConsoleView();

    if (pConsoleView == NULL)
        return (NULL);

    HNODE hNode = pConsoleView->GetSelectedNode();
    return (CNode::FromHandle(hNode));
}

//+-------------------------------------------------------------------
//
//  Member:      ScUpdateStdbarVerbs
//
//  Synopsis:    Update all the std-toolbar buttons with
//               current verb state, this is just a wrapper
//               around CStdVerbButtons::ScUpdateStdbarVerbs.
//
//  Arguments:   None
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CViewData::ScUpdateStdbarVerbs()
{
    DECLARE_SC (sc, _T("CViewData::ScUpdateStdbarVerbs"));
    CStdVerbButtons* pStdVerbButtons = GetStdVerbButtons();
    if (NULL == pStdVerbButtons)
    {
        sc = E_UNEXPECTED;
        return sc;
    }

    // Update the std-verb tool-buttons.
    sc = pStdVerbButtons->ScUpdateStdbarVerbs(GetVerbSet());

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      ScUpdateStdbarVerb
//
//  Synopsis:    Update given verb's tool-button, this is just
//               a wrapper around CStdVerbButtons::ScUpdateStdbarVerb.
//
//  Arguments:   [cVerb] - the verb whose button to be updated.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CViewData::ScUpdateStdbarVerb (MMC_CONSOLE_VERB cVerb)
{
    DECLARE_SC (sc, _T("CViewData::ScUpdateStdbarVerb"));
    CStdVerbButtons* pStdVerbButtons = GetStdVerbButtons();
    if (NULL == pStdVerbButtons)
    {
        sc = E_UNEXPECTED;
        return sc;
    }

    // Update the std-verb tool-buttons.
    sc = pStdVerbButtons->ScUpdateStdbarVerb(cVerb, GetVerbSet());

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      ScUpdateStdbarVerb
//
//  Synopsis:    Update given verb's tool-button, this is just
//               a wrapper around CStdVerbButtons::ScUpdateStdbarVerb.
//
//  Arguments:   [cVerb] - the verb whose button to be updated.
//               [byState] - State of the button to be updated.
//               [bFlag]  - State.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CViewData::ScUpdateStdbarVerb (MMC_CONSOLE_VERB cVerb, BYTE byState, BOOL bFlag)
{
    DECLARE_SC (sc, _T("CViewData::ScUpdateStdbarVerb"));
    CStdVerbButtons* pStdVerbButtons = GetStdVerbButtons();
    if (NULL == pStdVerbButtons)
    {
        sc = E_UNEXPECTED;
        return sc;
    }

    // Update the std-verb tool-buttons.
    sc = pStdVerbButtons->ScUpdateStdbarVerb(cVerb, byState, bFlag);

    return sc;
}



//+-------------------------------------------------------------------
//
//  Member:      CViewData::ScIsVerbSetContextForMultiSelect
//
//  Synopsis:    Get the selection context data stored in verb-set.
//
//  Arguments:   [bMultiSelection] - [out] Is the verb context for multiseleciton?
//
//  Returns:     SC,
//
//--------------------------------------------------------------------
SC CViewData::ScIsVerbSetContextForMultiSelect(bool& bMultiSelection)
{
    DECLARE_SC(sc, _T("CNode::ScIsVerbSetContextForMultiSelect"));
    bMultiSelection = false;

    // 1. Get the verb set.
    CVerbSet* pVerbSet = dynamic_cast<CVerbSet*>(GetVerbSet() );
    sc = ScCheckPointers( pVerbSet, E_UNEXPECTED );
    if (sc)
        return sc;

    // 2. Get context information from permanent verb-set.
    CNode *pNode   = NULL;
    LPARAM lCookie = NULL;
    bool   bScopePane;
    bool   bSelected;

    SC scNoTrace = pVerbSet->ScGetVerbSetContext(pNode, bScopePane, lCookie, bSelected);
	if (scNoTrace)
		return sc;  // ignore the error.

    if (LVDATA_MULTISELECT == lCookie)
    {
        bMultiSelection = true;
        return sc;
    }

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      CViewData::ScGetVerbSetData
//
//  Synopsis:    Get the selection context data stored in verb-set.
//
//  Arguments:   [ppDataObject] - [out] dataobject of item in the verb-set context.
//                                      This is the item for which last non-temporary MMCN_SELECT
//                                      was sent last time.
//               [ppComponent]  - [out] the above item's component
//               [bScope]       - [out] Is the above item scope or result?
//               [bSelected]    - [out] Is the above item selected or not?
//               [ppszNodeName] - [out] If bScope is true the node name else the name of the node
//                                      that owns result pane. This is for debug purposes only.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CViewData::ScGetVerbSetData(IDataObject **ppDataObject, CComponent **ppComponent,
                               bool& bScopeItem, bool& bSelected
#ifdef DBG
                        , LPCTSTR *ppszNodeName
#endif
                               )
{
    DECLARE_SC(sc, _T("CNode::ScGetVerbSetData"));
    sc = ScCheckPointers(ppDataObject, ppComponent);
    if (sc)
        return sc;

    *ppDataObject = NULL;
    *ppComponent = NULL;

    // 1. Get the verb set.
    CVerbSet* pVerbSet = dynamic_cast<CVerbSet*>(GetVerbSet() );
    sc = ScCheckPointers( pVerbSet, E_UNEXPECTED );
    if (sc)
        return sc;

    // 2. Get context information from permanent verb-set.
    CNode *pNode   = NULL;
    LPARAM lCookie = NULL;
    bool   bScopePane;

    SC scNoTrace = pVerbSet->ScGetVerbSetContext(pNode, bScopePane, lCookie, bSelected);
	if (scNoTrace)
		return scNoTrace;

    sc = ScCheckPointers(pNode, E_UNEXPECTED);
    if (sc)
        return sc;

    // 3. Get the dataobject from context information.
    sc = pNode->ScGetDataObject(bScopePane, lCookie, bScopeItem, ppDataObject, ppComponent);
    if (sc)
        return sc;

#ifdef DBG
    if (! ppszNodeName)
        return (sc = E_INVALIDARG);

    *ppszNodeName = pNode->GetDisplayName().data();
#endif

    return (sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\verbs.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       verbs.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4/9/1997   RaviR   Created
//____________________________________________________________________________
//


#ifndef _VERBS_H_
#define _VERBS_H_


class CNode;
class CVerbSet;

/*+-------------------------------------------------------------------------*
 * class CConsoleVerbState
 *
 *
 * PURPOSE:  Button state for console commands.
 *
 *+-------------------------------------------------------------------------*/
class CConsoleVerbState
{
public:
    CConsoleVerbState() {m_state = m_stateDisabled = TBSTATE_HIDDEN; m_bHiddenBySnapIn = false;}

    void Init(BYTE stateDisabled)   {m_stateDisabled = m_state;}
    void Disable()                  {m_state = m_stateDisabled; m_bHiddenBySnapIn = false;}
    BYTE GetState()                 {return m_state;}
    void SetState(BYTE state)       {m_state = state;}

    void SetHiddenBySnapin(BOOL b)  {m_bHiddenBySnapIn = b;}
    bool IsHiddenBySnapin()         {return m_bHiddenBySnapIn;}

private:
    BYTE                m_state;          // State
    bool                m_bHiddenBySnapIn;
    BYTE                m_stateDisabled; // what "Disabled" means for this verb.
};

typedef CConsoleVerbState *LPCONSOLE_VERB_STATE;

/*+-------------------------------------------------------------------------*
 * class CConsoleVerbImpl
 *
 *
 * PURPOSE: This is the object that the snapins' IConsoleVerb points to.
 *          This object has a pointer to an implementation of CVerbSet.
 *          The CVerbSet object can be switched to allow a temporary
 *          selection, for instance. This allows a view to have its toolbars
 *          to get their verb settings from a different CVerbSet object than
 *          the right click context menu does - just set the CVerbSet
 *          pointer on the CConsoleVerbImpl to the CVerbSet that the
 *          changes should be routed to, and send the snapin an MMCN_SELECT
 *          notification.
 *
 *          What might be confusing at first is that both CConsoleVerbImpl
 *          as well as CVerbSet keep a set of states. 1) The CConsoleVerbImpl
 *          needs to have its own set because the
 *          set of states needs to look consistent to the snapin regardless
 *          of where the CVerbSet pointer is pointing to. 2) At the same time,
 *          the CVerbSet needs its own set of states so that its client
 *          consistently reads this set.
 *+-------------------------------------------------------------------------*/
class CConsoleVerbImpl : public IConsoleVerb, public CComObjectRoot
{

public:
    CConsoleVerbImpl();
    ~CConsoleVerbImpl();

// ATL COM maps
BEGIN_COM_MAP(CConsoleVerbImpl)
    COM_INTERFACE_ENTRY(IConsoleVerb)
END_COM_MAP()

// IConsoleVerb methods
public:
    STDMETHOD(GetVerbState)(MMC_CONSOLE_VERB eCmdID, MMC_BUTTON_STATE nState, BOOL* pbState);
    STDMETHOD(SetVerbState)(MMC_CONSOLE_VERB eCmdID, MMC_BUTTON_STATE nState, BOOL bState);
    STDMETHOD(SetDefaultVerb)(MMC_CONSOLE_VERB eCmdID);
    STDMETHOD(GetDefaultVerb)(MMC_CONSOLE_VERB* peCmdID)
    {
        *peCmdID = m_DefaultVerb;
        return S_OK;
    }

    BYTE    GetVerbState(MMC_CONSOLE_VERB verb);
    HRESULT SetDisabledAll(void);
    void    SetVerbSet(IConsoleVerb* pVerbSet);

private:
    CVerbSet* GetVerbSet()
    {
        ASSERT(m_pVerbSet != NULL);
        return m_pVerbSet;
    }

public:
#ifdef DBG
    int dbg_cRef_CConsoleVerbImpl;
    ULONG InternalAddRef();
    ULONG InternalRelease();
#endif // DBG

// Internal functions
private:
    LPCONSOLE_VERB_STATE GetConsoleVerbState(MMC_CONSOLE_VERB m_eCmdID);

// Implementation
private:
    CVerbSet*           m_pVerbSet;
    MMC_CONSOLE_VERB    m_DefaultVerb;
    CConsoleVerbState   m_rgConsoleVerbStates[evMax];

    bool                m_bCutVerbDisabledBySnapin;
}; // class CConsoleVerbImpl


HRESULT _GetConsoleVerb(CNode* pNode, LPCONSOLEVERB* ppConsoleVerb);


/*+-------------------------------------------------------------------------*
 * class CVerbSetBase
 *
 *
 * PURPOSE: This class retains the state of all the verbs corresponding
 *          to a particular object. See the note in CConsoleVerbImpl above.
 *
 *          This also forms base class for CVerbSet as well as CTemporaryVerbSet
 *          objects.
 *
 *          Do not instantiate this object directly you should create either
 *          CVerbSet or CTemporaryVerbSet object.
 *
 *+-------------------------------------------------------------------------*/
class CVerbSetBase : public IConsoleVerb, public CComObjectRoot
{
public:
    CVerbSetBase();
    ~CVerbSetBase();

// ATL COM maps
BEGIN_COM_MAP(CVerbSetBase)
    COM_INTERFACE_ENTRY(IConsoleVerb)
END_COM_MAP()

// IConsoleVerb methods
public:
    STDMETHOD(GetVerbState)(MMC_CONSOLE_VERB m_eCmdID, MMC_BUTTON_STATE nState, BOOL* pbState);
    STDMETHOD(GetDefaultVerb)(MMC_CONSOLE_VERB* peCmdID);

    STDMETHOD(SetVerbState)(MMC_CONSOLE_VERB m_eCmdID, MMC_BUTTON_STATE nState, BOOL bState)
    {
        ASSERT(0 && "Should never come here!!!");
        return E_FAIL;
    }
    STDMETHOD(SetDefaultVerb)(MMC_CONSOLE_VERB m_eCmdID)
    {
        ASSERT(0 && "Should never come here!!!");
        return E_FAIL;
    }

	SC                  ScInitializeForMultiSelection(CNode *pNode, bool bSelect);
    void                SetMultiSelection(CMultiSelection* pMS);

    SC                  ScComputeVerbStates();

    IConsoleVerb*       GetConsoleVerb(void) const;

// Implementation
protected:
    void                Reset();
    BYTE                _GetVerbState(EVerb ev);

private:
    void                _EnableVerb(EVerb eVerb, bool fEnable);
    void                _EnableVerb(EVerb eVerb);
    void                _HideVerb(EVerb eVerb);
    void                _AskSnapin(EVerb eVerb);

protected:
    CNode*   m_pNode;
    bool     m_bScopePaneSelected;
    LPARAM   m_lResultCookie;
    bool     m_bVerbContextDataValid;

    CMultiSelection*    m_pMultiSelection;

    IConsoleVerbPtr     m_spConsoleVerbCurr;

    struct SVerbState
    {
        BYTE    bAskSnapin; // 0 => don't ask, 1 => ask, 2 => asked and answered.
        BYTE    nState;
    };

    SVerbState m_rbVerbState[evMax];
};

/*+-------------------------------------------------------------------------*
 * class CVerbSet
 *
 *
 * PURPOSE: This object stores verb state information for currently (non-temporarily)
 *          selected item if there is one and is created by CViewData per view.
 *
 *+-------------------------------------------------------------------------*/
class CVerbSet : public CVerbSetBase
{
public:
    CVerbSet() { Reset(); }

	SC       ScInitialize (CNode *pNode, bool bScope, bool bSelect,
		                   bool bLVBackgroundSelected, LPARAM lResultCookie);

    void     Notify(IConsoleVerb* pCVIn, MMC_CONSOLE_VERB m_eCmdID);
    SC       ScGetVerbSetContext(CNode*& pNode, bool& bScope, LPARAM& lResultCookie, bool& bSelected);

    void     DisableChangesToStdbar()   { m_bChangesToStdbarEnabled = false;}
    void     EnableChangesToStdbar()    { m_bChangesToStdbarEnabled = true;}

private:
    bool     IsChangesToStdbarEnabled() { return m_bChangesToStdbarEnabled;}

    void     Reset();

private:

    bool     m_bChangesToStdbarEnabled;
};


/*+-------------------------------------------------------------------------*
 * class CTemporaryVerbSet
 *
 *
 * PURPOSE: This object provides methods to initialize temporary verbset state
 *          infomation. This de-selects any item that is currently selected, then
 *          selects temp item computes verbs, de-selects temp item and selects
 *          original item.
 *
 *          Here selection or de-selection means sending (MMCN_SELECT, true) or
 *          (MMCN_SELECT, false).
 *
 *+-------------------------------------------------------------------------*/
class CTemporaryVerbSet : public CVerbSetBase
{
public:
    STDMETHOD(GetDefaultVerb)(MMC_CONSOLE_VERB* peCmdID);

    SC       ScInitialize(CNode *pNode, LPARAM lResultCookie, bool bScopePaneSel);
    SC       ScInitialize(LPDATAOBJECT lpDataObject, CNode *pNode, bool bScopePaneSel, LPARAM lResultCookie);
    SC       ScComputeVerbStates();

private:
    SC       ScInitializePermanentVerbSet(CNode *pNode, bool bSelect);

private:
    MMC_CONSOLE_VERB    m_DefaultVerb;
};


inline CVerbSetBase::CVerbSetBase()
{
    Reset();
    DEBUG_INCREMENT_INSTANCE_COUNTER(CVerbSetBase);
}

inline CVerbSetBase::~CVerbSetBase()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CVerbSetBase);
}

inline void CVerbSetBase::SetMultiSelection(CMultiSelection* pMS)
{
    m_pMultiSelection = pMS;
}

inline void CVerbSetBase::Reset()
{
    m_bScopePaneSelected = false;
    m_bVerbContextDataValid = false;
    m_lResultCookie      = NULL;
    m_pNode              = NULL;

    m_pMultiSelection    = NULL;
    m_spConsoleVerbCurr  = NULL;
}

inline IConsoleVerb* CVerbSetBase::GetConsoleVerb(void) const
{
    return m_spConsoleVerbCurr;
}


inline void CVerbSetBase::_EnableVerb(EVerb eVerb, bool fEnable)
{
    if (fEnable)
        _EnableVerb(eVerb);
    else
        _HideVerb(eVerb);
}

inline void CVerbSetBase::_EnableVerb(EVerb eVerb)
{
    m_rbVerbState[eVerb].bAskSnapin = 0;
    m_rbVerbState[eVerb].nState = TBSTATE_ENABLED;
}

inline void CVerbSetBase::_HideVerb(EVerb eVerb)
{
    m_rbVerbState[eVerb].bAskSnapin = 0;
    m_rbVerbState[eVerb].nState = TBSTATE_HIDDEN;
}

inline void CVerbSetBase::_AskSnapin(EVerb eVerb)
{
    m_rbVerbState[eVerb].bAskSnapin = 1;
    m_rbVerbState[eVerb].nState = 0;
}

inline void CConsoleVerbImpl::SetVerbSet(IConsoleVerb* pVerbSet)
{
    m_pVerbSet = dynamic_cast<CVerbSet*>(pVerbSet);
    ASSERT(m_pVerbSet != NULL);
}

inline void CVerbSet::Reset()
{
    CVerbSetBase::Reset();

    m_bChangesToStdbarEnabled = true;
}

inline SC CVerbSet::ScGetVerbSetContext(CNode*& pNode,
                                        bool& bScopePaneSel,
                                        LPARAM& lResultCookie,
                                        bool& bDataValid)
{
    pNode         = m_pNode;
    bScopePaneSel = m_bScopePaneSelected;
    lResultCookie = m_lResultCookie;
    bDataValid    = m_bVerbContextDataValid;

    if (! pNode)
        return E_FAIL;

    return S_OK;
}


#endif // _VERBS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\viewpers.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      viewpers.cpp
//
//  Contents:  View Persistence data structures.
//
//  History:   04-Apr-99 AnandhaG    Created
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "viewpers.h"
#include "macros.h"
#include "comdbg.h"

#define MAX_VIEWITEMS_PERSISTED 50


//------------------------------------------------------------------
// class CViewSettingsPersistor
//------------------------------------------------------------------
CViewSettingsPersistor::CViewSettingsPersistor() :
    m_dwMaxItems(MAX_VIEWITEMS_PERSISTED), m_bDirty(false)
{
	// Now read the registry to see if m_dwMaxItems is specified.
	// Check if the settings key exists.
	CRegKeyEx rSettingsKey;
	if (rSettingsKey.ScOpen (HKEY_LOCAL_MACHINE, SETTINGS_KEY, KEY_READ).IsError())
        return;

	// Read the values for MaxColDataPersisted.
	if (rSettingsKey.IsValuePresent(g_szMaxViewItemsPersisted))
	{
		DWORD  dwType = REG_DWORD;
		DWORD  dwSize = sizeof(DWORD);

		SC sc = rSettingsKey.ScQueryValue (g_szMaxViewItemsPersisted, &dwType,
                                        &m_dwMaxItems, &dwSize);

		if (sc)
			sc.TraceAndClear();
	}
}


//+-------------------------------------------------------------------
//
//  Member:     ScGetViewSettings
//
//  Synopsis:   Given the CViewSettingsID return the CViewSettings object.
//
//  Arguments:  [viewSettingsID] - [in]
//              [viewSettings]   - [out]
//
//  Returns:    SC, S_FALSE if none found.
//
//--------------------------------------------------------------------
SC CViewSettingsPersistor::ScGetViewSettings(const CViewSettingsID& viewSettingsID,
                                             CViewSettings& viewSettings)
{
    DECLARE_SC(sc, TEXT("CViewSettingsPersistor::ScGetViewSettings"));

    // 1. Look in the map if there is persisted data for given id.
    CViewSettingsIDToViewSettingsMap::iterator     itViewSettingsDataMap;
    itViewSettingsDataMap = m_mapViewSettingsIDToViewSettings.find(viewSettingsID);
    if (itViewSettingsDataMap == m_mapViewSettingsIDToViewSettings.end())
        return (sc = S_FALSE);

    // Found the data.
    IteratorToViewSettingsList itViewSettings = itViewSettingsDataMap->second;

    // 2. Copy the data.
    viewSettings = *itViewSettings;

    // 3. Move this item to the front of the queue.
    m_listViewSettings.erase(itViewSettings);
    itViewSettings = m_listViewSettings.insert(m_listViewSettings.begin(), viewSettings);
    itViewSettingsDataMap->second = itViewSettings;

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:     ScSetViewSettings
//
//  Synopsis:   Modify the persisted view information
//              for given view and bookmark (node).
//
//  Arguments:  [nViewID] - Snapin Guid
//              [pBookmark]       - Column Set Identifier.
//              [viewDataSet]        - View ID.
//
//  Returns:    TRUE - Loaded successfully.
//
//  History:    04-26-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
SC CViewSettingsPersistor::ScSetViewSettings(const CViewSettingsID& viewSettingsID,
                                             const CViewSettings& viewSettings,
                                             bool bSetViewDirty)
{
    DECLARE_SC(sc, TEXT("CViewSettingsPersistor::ScSetViewSettings"));

    // 1. Garbage collect if the number of items in the list are 40% more than pre-set limit.
    if (m_listViewSettings.size() >= (m_dwMaxItems * (1 + VIEWSETTINGS_MAXLIMIT)) )
    {
        sc = ScGarbageCollectItems();
        if (sc)
            sc.TraceAndClear();
    }

    // 2. Insert the item into the front of the queue.
    IteratorToViewSettingsList itViewSettings;
    itViewSettings = m_listViewSettings.insert(m_listViewSettings.begin(), viewSettings);

    // 3. See if there is data persisted for this id.
    CViewSettingsIDToViewSettingsMap::iterator     itViewSettingsDataMap;
    itViewSettingsDataMap = m_mapViewSettingsIDToViewSettings.find(viewSettingsID);

    if (itViewSettingsDataMap == m_mapViewSettingsIDToViewSettings.end()) // not found so insert data.
    {
        m_mapViewSettingsIDToViewSettings.insert(
            CViewSettingsIDToViewSettingsMap::value_type(viewSettingsID, itViewSettings) );
    }
    else
    {
        // found, so replace old settings.
        m_listViewSettings.erase(itViewSettingsDataMap->second);
        itViewSettingsDataMap->second = itViewSettings;
    }

    // dirty flag accumulates.
    m_bDirty = (m_bDirty || bSetViewDirty);

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CViewSettingsPersistor::ScGetTaskpadID
//
//  Synopsis:    Given the nodetype & viewid get the taskpad id (this
//               is for taskpads persisted per nodetype).
//
//  Arguments:   [nViewID]      - [in]
//               [guidNodeType] - [in]
//               [guidTaskpad]  - [out]
//
//  Returns:     SC, S_FALSE if none found.
//
//--------------------------------------------------------------------
SC CViewSettingsPersistor::ScGetTaskpadID (int nViewID, const GUID& guidNodeType ,GUID& guidTaskpad)
{
    DECLARE_SC(sc, _T("CViewSettingsPersistor::ScGetTaskpadID"));

    // 1. Init out param.
    guidTaskpad = GUID_NULL;

    // 2. Construct a CViewSettingsID object with given nodetype & viewid.
    CViewSettingsID viewSettingsID(nViewID, guidNodeType);

    // 3. Get the viewsettings
    CViewSettings   viewSettings;
    sc = ScGetViewSettings(viewSettingsID, viewSettings);

    // If none exists return
    if (sc != S_OK)
        return sc;

    // 4. CViewSettings exists, see if there is valid taskpad-id stored.
    sc = viewSettings.ScGetTaskpadID(guidTaskpad);

    if (sc) // taskpad-id is not valid.
        return (sc = S_FALSE);

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CViewSettingsPersistor::ScSetTaskpadID
//
//  Synopsis:    Given the nodetype & viewid set the taskpad id (this
//               is for taskpads persisted per nodetype).
//
//               NOTE: NUKE ANY NODE-SPECIFIC TASKPAD-ID THAT IS STORED.
//
//  Arguments:   [nViewID]      - [in]
//               [guidNodeType] - [in]
//               [bookmark]     - [in]
//               [guidTaskpad]  - [in]
//               [bSetDirty]    - [in] set the console file dirty
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CViewSettingsPersistor::ScSetTaskpadID (int nViewID, const GUID& guidNodeType,
                                           const CBookmark& bookmark, const GUID& guidTaskpad,
                                           bool bSetDirty)
{
    DECLARE_SC(sc, _T("CViewSettingsPersistor::ScSetTaskpadID"));

    // 1. First nuke the the old node specific taskpad-id settings (if any).

    // 1.a) Construct a CViewSettingsID object with given nodetype & viewid.
    CViewSettingsID viewSettingsIDNodeSpecific(nViewID, bookmark);

    // 1.b) Get the viewsettings.
    CViewSettings   viewSettingsNodeSpecific;
    sc = ScGetViewSettings(viewSettingsIDNodeSpecific, viewSettingsNodeSpecific);
    if (sc)
        return sc;

    // data available
    if ( (sc == S_OK) &&
         (viewSettingsNodeSpecific.IsTaskpadIDValid()) )
    {
        // 1.c) Set taskpad id invalid.
        viewSettingsNodeSpecific.SetTaskpadIDValid(false);
        if (sc)
            return sc;

        // 1.d) Save the data.
        sc = ScSetViewSettings(viewSettingsIDNodeSpecific, viewSettingsNodeSpecific, bSetDirty);
    }

    // 2. Now save the taskpad id for nodetype specific.
    // 2.a) Construct a CViewSettingsID object with given nodetype & viewid.
    CViewSettingsID viewSettingsID(nViewID, guidNodeType);

    // 2.b) The CResultViewType & view-mode data are not stored when CViewSettings is stored
    //      per nodetype. So just set the taskpad id.
    CViewSettings   viewSettings;
    sc = viewSettings.ScSetTaskpadID(guidTaskpad);
    if (sc)
        return sc;

    // 2.c) Save the viewsettings into the map.
    sc = ScSetViewSettings(viewSettingsID, viewSettings, bSetDirty);
    if (sc)
        return sc;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CViewSettingsPersistor::ScGetTaskpadID
//
//  Synopsis:    Given the bookmark & viewid get the taskpad id (this
//               is for taskpads persisted per node).
//
//  Arguments:   [nViewID]      - [in]
//               [bookmark]     - [in]
//               [guidTaskpad]  - [out]
//
//  Returns:     SC, S_FALSE if none found.
//
//--------------------------------------------------------------------
SC CViewSettingsPersistor::ScGetTaskpadID (int nViewID, const CBookmark& bookmark,GUID& guidTaskpad)
{
    DECLARE_SC(sc, _T("CViewSettingsPersistor::ScGetTaskpadID"));

    // 1. Init out param.
    guidTaskpad = GUID_NULL;

    // 2. Construct a CViewSettingsID object with given bookmark & viewid.
    CViewSettingsID viewSettingsID(nViewID, bookmark);

    // 3. Get the viewsettings
    CViewSettings   viewSettings;
    sc = ScGetViewSettings(viewSettingsID, viewSettings);

    // If none exists return
    if (sc != S_OK)
        return sc;

    // 4. CViewSettings exists, see if there is valid taskpad-id stored.
    sc = viewSettings.ScGetTaskpadID(guidTaskpad);

    if (sc) // taskpad-id is not valid.
        return (sc = S_FALSE);

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CViewSettingsPersistor::ScSetTaskpadID
//
//  Synopsis:    Given the bookmark & viewid get the taskpad id (this
//               is for taskpads persisted per nodetype).
//
//  Arguments:   [nViewID]      - [in]
//               [bookmark]     - [in]
//               [guidTaskpad]  - [in]
//               [bSetDirty]    - [in] set the console file dirty
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CViewSettingsPersistor::ScSetTaskpadID (int nViewID, const CBookmark& bookmark,
                                           const GUID& guidTaskpad, bool bSetDirty)
{
    DECLARE_SC(sc, _T("CViewSettingsPersistor::ScSetTaskpadID"));

    // 1. Construct a CViewSettingsID object with given bookmark & viewid.
    CViewSettingsID viewSettingsID(nViewID, bookmark);

    // 2. First get the old settings (if any) and just modify taskpad-id.
    CViewSettings   viewSettings;
    sc = ScGetViewSettings(viewSettingsID, viewSettings);
    if (sc)
        return sc;

    // 3. If persisted data does not exist dont worry (as CResultViewType and
    //    view mode are invalid), just set taskpad-id.
    sc = viewSettings.ScSetTaskpadID(guidTaskpad);
    if (sc)
        return sc;

    // 4. Save the viewsettings into the map.
    sc = ScSetViewSettings(viewSettingsID, viewSettings, bSetDirty);
    if (sc)
        return sc;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CViewSettingsPersistor::ScGetViewMode
//
//  Synopsis:    Given the viewid & bookmark (can identify a node), return
//               the view mode if any persisted.
//
//  Arguments:   [nViewID]      - [in]
//               [bookmark]     - [in]
//               [ulViewMode]    - [out]
//
//  Returns:     SC, S_FALSE if none.
//
//--------------------------------------------------------------------
SC CViewSettingsPersistor::ScGetViewMode (int nViewID, const CBookmark& bookmark, ULONG&  ulViewMode)
{
    DECLARE_SC(sc, _T("CViewSettingsPersistor::ScGetViewMode"));

    // 1. Construct the viewsettings-id.
    CViewSettingsID viewSettingsID(nViewID, bookmark);

    // 2. see if ViewSettings exist.
    CViewSettings viewSettings;
    sc = ScGetViewSettings(viewSettingsID, viewSettings);
    if (sc != S_OK)
        return sc;

    sc = viewSettings.ScGetViewMode(ulViewMode);
    if (sc)
        return (sc = S_FALSE);

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CViewSettingsPersistor::ScSetViewMode
//
//  Synopsis:    Given view-id & bookmark, set the viewmode in a node
//               specific viewsettings.
//
//  Arguments:   [nViewID]      - [in]
//               [bookmark]     - [in]
//               [ulViewMode]    - [in]
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CViewSettingsPersistor::ScSetViewMode (int nViewID, const CBookmark& bookmark, ULONG ulViewMode)
{
    DECLARE_SC(sc, _T("CViewSettingsPersistor::ScSetViewMode"));

    // 1. Construct the viewsettings-id.
    CViewSettingsID viewSettingsID(nViewID, bookmark);

    // 2. First get the old settings (if any) and just modify viewmode.
    CViewSettings   viewSettings;
    sc = ScGetViewSettings(viewSettingsID, viewSettings);
    if (sc)
        return sc;

    // 3. If persisted data does not exist dont worry (as CResultViewType and
    //    taskpad-id are invalid), just set viewmode.
    sc = viewSettings.ScSetViewMode(ulViewMode);
    if (sc)
        return sc;

    // 4. Save the viewsettings into the map.
    sc = ScSetViewSettings(viewSettingsID, viewSettings, /*bSetDirty*/ true);
    if (sc)
        return sc;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CViewSettingsPersistor::ScGetResultViewType
//
//  Synopsis:    Given the viewid & bookmark (can identify a node), return
//               the CResultViewType if persisted.
//
//  Arguments:   [nViewID]      - [in]
//               [bookmark]     - [in]
//               [rvt]          - [out]
//
//  Returns:     SC, S_FALSE if none.
//
//--------------------------------------------------------------------
SC CViewSettingsPersistor::ScGetResultViewType (int nViewID, const CBookmark& bookmark, CResultViewType& rvt)
{
    DECLARE_SC(sc, _T("CViewSettingsPersistor::ScGetResultViewType"));

    // 1. Construct the viewsettings-id.
    CViewSettingsID viewSettingsID(nViewID, bookmark);

    // 2. see if ViewSettings exist.
    CViewSettings viewSettings;
    sc = ScGetViewSettings(viewSettingsID, viewSettings);
    if (sc != S_OK)
        return sc;

    sc = viewSettings.ScGetResultViewType(rvt);
    if (sc)
        return (sc = S_FALSE);

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CViewSettingsPersistor::ScSetResultViewType
//
//  Synopsis:    Given view-id & bookmark, set the resultviewtype in a node
//               specific viewsettings.
//
//  Arguments:   [nViewID]      - [in]
//               [bookmark]     - [in]
//               [nViewMode]    - [in]
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CViewSettingsPersistor::ScSetResultViewType (int nViewID, const CBookmark& bookmark, const CResultViewType& rvt)
{
    DECLARE_SC(sc, _T("CViewSettingsPersistor::ScSetResultViewType"));

    // 1. Construct the viewsettings-id.
    CViewSettingsID viewSettingsID(nViewID, bookmark);

    // 2. First get the old settings (if any) and just modify resultviewtype.
    CViewSettings   viewSettings;
    sc = ScGetViewSettings(viewSettingsID, viewSettings);
    if (sc)
        return sc;

    // 3. If persisted data does not exist dont worry (as view-mode and
    //    taskpad-id are invalid), just set resultviewtype.
    sc = viewSettings.ScSetResultViewType(rvt);
    if (sc)
        return sc;

    // 4. Save the viewsettings into the map.
    sc = ScSetViewSettings(viewSettingsID, viewSettings, /*bSetDirty*/ true);
    if (sc)
        return sc;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CViewSettingsPersistor::ScSetFavoriteViewSettings
//
//  Synopsis:    A favorite is selected and it sets viewsettings
//               before re-selecting the node so that after re-selection
//               the new settings are set for the view. So dont set the
//               console file dirty.
//
//  Arguments:   [nViewID]      -
//               [bookmark]     -
//               [viewSettings] -
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CViewSettingsPersistor::ScSetFavoriteViewSettings (int nViewID, const CBookmark& bookmark,
                                                      const CViewSettings& viewSettings)
{
    DECLARE_SC(sc, _T("CViewSettingsPersistor::ScSetFavoriteViewSettings"));

    // 1. Construct the viewsettings-id.
    CViewSettingsID viewSettingsID(nViewID, bookmark);

    // 2. Save the viewsettings into the map.
    sc = ScSetViewSettings(viewSettingsID, viewSettings, /*bSetDirty*/ false);
    if (sc)
        return sc;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:     ScDeleteDataOfView
//
//  Synopsis:   Delete the data of given view.
//
//  Arguments:  [nViewID] - View ID.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CViewSettingsPersistor::ScDeleteDataOfView( int nViewID)
{
    DECLARE_SC(sc, TEXT("CViewSettingsPersistor::ScDeleteDataOfView"));

    // Find the data for the view.
    CViewSettingsIDToViewSettingsMap::iterator  itViewSettingsDataMap;

    for (itViewSettingsDataMap  = m_mapViewSettingsIDToViewSettings.begin();
         itViewSettingsDataMap != m_mapViewSettingsIDToViewSettings.end();
         ++itViewSettingsDataMap)
    {
        const CViewSettingsID& viewSettingsID = itViewSettingsDataMap->first;
        if (viewSettingsID.get_ViewID() == nViewID)
        {
            // Delete the item;
            IteratorToViewSettingsList itViewSettings = itViewSettingsDataMap->second;
            itViewSettings->SetObjInvalid(TRUE);
        }
    }

    // Delete the invalid items.
    sc = ScDeleteMarkedItems();
    if (sc)
        return sc;

    return sc;
}



//+-------------------------------------------------------------------
//
//  Member:     ScGarbageCollectItems
//
//  Synopsis:   Free least used data.
//
//  Arguments:  None.
//
//  History:    04-26-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
SC CViewSettingsPersistor::ScGarbageCollectItems()
{
    DECLARE_SC(sc, TEXT("CViewSettingsPersistor::ScGarbageCollectItems"));

    INT nItemsToBeRemoved = VIEWSETTINGS_MAXLIMIT * m_dwMaxItems;

    // Go thro' the list and set the nItemsToBeRemoved that was least recently
    // accessed to be invalid.
    INT nIndex = 0;
    IteratorToViewSettingsList itViewSettings;

    // Skip first m_dwMaxItems.
    for (itViewSettings  = m_listViewSettings.begin();
         ( (itViewSettings != m_listViewSettings.end()) && (nIndex <= m_dwMaxItems) );
         ++itViewSettings, nIndex++)
    {
        nIndex++;
    }

    // Mark rest of the items to be garbage.
    while (itViewSettings != m_listViewSettings.end())
    {
        itViewSettings->SetObjInvalid(TRUE);
        ++itViewSettings;
    }

    // Delete the invalid items.
    sc = ScDeleteMarkedItems();
    if (sc)
        return sc;

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:     ScDeleteMarkedItems
//
//  Synopsis:   Delete invalidated items. This involves iterating thro
//              the maps to find the invalid items. Then deleting the
//              items. If the map becomes empty then delete the map.
//
//  History:    04-26-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
SC CViewSettingsPersistor::ScDeleteMarkedItems()
{
    DECLARE_SC(sc, TEXT("CViewSettingsPersistor::ScDeleteMarkedItems"));

    CViewSettingsIDToViewSettingsMap::iterator itViewSettingsDataMap = m_mapViewSettingsIDToViewSettings.begin();

    // Iterate through the map to see if there are
    // invalidated items.
    while (m_mapViewSettingsIDToViewSettings.end() != itViewSettingsDataMap)
    {
        IteratorToViewSettingsList itViewSettings = itViewSettingsDataMap->second;
        if (itViewSettings->IsObjInvalid())
        {
            // Delete the item ref from the map.
            // Erase returns iterator to next item.
            itViewSettingsDataMap = m_mapViewSettingsIDToViewSettings.erase(itViewSettingsDataMap);

            // Delete the item from the list.
            m_listViewSettings.erase(itViewSettings);
        }
        else
            ++itViewSettingsDataMap;        // Item is valid so get next item.
    }

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:     Load
//
//  Synopsis:   Load the persisted view information.
//
//  Arguments:  [pStream]- IStream from which view data will be loaded.
//
//  Returns:    S_OK - Loaded successfully.
//
//  History:    04-26-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
HRESULT CViewSettingsPersistor::Load (IStream* pStream)
{
    HRESULT hr = E_FAIL;

    // read the column width information.
    try
    {
        do
        {
            // Read the version. If it did not match return
            INT   nVersion                      = 0;
            *pStream >> nVersion;
            if (ViewSettingPersistenceVersion != nVersion)
                return S_FALSE;

            // Read the # of Snapins
            DWORD dwNumItems = 0;
            *pStream >> dwNumItems;

            m_listViewSettings.clear();
            m_mapViewSettingsIDToViewSettings.clear();

            for (int i = 0; i < dwNumItems; i++)
            {
                // Read the ID.
                CViewSettingsID viewSettingsID;
                *pStream >> viewSettingsID;

                // Read the data.
                CViewSettings viewSettings;
                viewSettings.Read(*pStream);

                // Insert the data into the list.
                IteratorToViewSettingsList itViewSettings;
                itViewSettings = m_listViewSettings.insert(m_listViewSettings.begin(),
                                                           viewSettings);

                // Insert the data into the map.
                m_mapViewSettingsIDToViewSettings.insert(
                    CViewSettingsIDToViewSettingsMap::value_type(viewSettingsID, itViewSettings) );
            }

            m_listViewSettings.sort();

        } while (FALSE);
    }
    catch (_com_error& err)
    {
        hr = err.Error();
    }
    catch (...)
    {
        ASSERT (0 && "Unexpected exception");
        throw;
    }

    return S_OK;
}


//+-------------------------------------------------------------------
//
//  Member:     Save
//
//  Synopsis:   Persist the view information.
//
//  Arguments:  [pStream]- IStream in which data is persisted.
//
//  Returns:    S_OK - Saved successfully.
//
//  History:    04-26-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
HRESULT CViewSettingsPersistor::Save (IStream* pStream, BOOL bClearDirty)
{
    // absolete method.
    // this method is left here since we use IPersistStream to export
    // persistence to CONUI side and need to implement it.
    // But this interface will never be called to save data
    // [we will use CPersistor-based XML saving instead]
    // so the method will always fail.
    ASSERT(FALSE && "Should never come here");
    return E_NOTIMPL;
}

//+-------------------------------------------------------------------
//
//  Member:     Persist
//
//  Synopsis:   Persist the view information.
//
//  Arguments:  [CPersistor]- Persistor in/from which data is persisted.
//
//  Returns:    void
//
//  History:    11-08-1999   AudriusZ   Created
//
//--------------------------------------------------------------------
void CViewSettingsPersistor::Persist(CPersistor &persistor)
{
    DECLARE_SC(sc, TEXT("CViewSettingsPersistor::Persist"));

    if (persistor.IsStoring())
    {
        // Give ranking to each CViewSettings instance.
        IteratorToViewSettingsList itViewSettings;
        DWORD dwRank = 0;
        for (itViewSettings  = m_listViewSettings.begin();
             itViewSettings != m_listViewSettings.end();
             ++itViewSettings)
        {
            dwRank++;
            itViewSettings->SetUsageRank(dwRank);
        }

        CViewSettingsIDToViewSettingsMap::iterator itViewSettingsDataMap;
        for (itViewSettingsDataMap  = m_mapViewSettingsIDToViewSettings.begin();
             itViewSettingsDataMap != m_mapViewSettingsIDToViewSettings.end();
             ++itViewSettingsDataMap)
        {
            // Write the ID.
            persistor.Persist(*const_cast<CViewSettingsID *>(&itViewSettingsDataMap->first));
            // Write the data.
            persistor.Persist(*itViewSettingsDataMap->second);
        }
    }
    else
    {
        // let the base class do the job
        // it will call OnNewElement for every element found
        XMLMapCollectionBase::Persist(persistor);
        // some extra loading actions
        m_listViewSettings.sort();
    }

    // either way we are the same as the file copy
    m_bDirty = false;
}

//+-------------------------------------------------------------------
//
//  Member:     OnNewElement
//
//  Synopsis:   Called for each new data pair read.
//
//  Arguments:  [persistKey]- Persistor from which key is to be loaded
//              [persistVal]- Persistor from which value is to be loaded
//
//  Returns:    void
//
//  History:    11-08-1999   AudriusZ   Created
//
//--------------------------------------------------------------------
void CViewSettingsPersistor::OnNewElement(CPersistor& persistKey,CPersistor& persistVal)
{
    DECLARE_SC(sc, TEXT("CViewSettingsPersistor::OnNewElement"));

    // Read the ID.
    CViewSettingsID viewSettingsID;
    persistKey.Persist(viewSettingsID);

    // Read the data.
    CViewSettings viewSettings;
    persistVal.Persist(viewSettings);

    // Insert the data into the list.
    IteratorToViewSettingsList itViewSettings;
    itViewSettings = m_listViewSettings.insert(m_listViewSettings.begin(),
                                           viewSettings);

    // Insert the data into the map.
    m_mapViewSettingsIDToViewSettings.insert(
        CViewSettingsIDToViewSettingsMap::value_type(viewSettingsID, itViewSettings) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\viewpers.h ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       viewpers.h
//
//  Contents:   Classes related to view setting persistence.
//
//  Classes:    CViewSettingsID and CViewSettingPersistor.
//
//  History:    04-Apr-99 AnandhaG     Created
//
//--------------------------------------------------------------------

#ifndef __VIEWPERS_H__
#define __VIEWPERS_H__
#pragma once
#include "bookmark.h"

#pragma warning(disable: 4503) // Disable long name limit warnings

using namespace std;

class  CViewSettings;
class  CBookmark;

/*************************************************************************
 *
 * How CViewSettingsPersistor is used:
 * There is only one CViewSettingsPersistor object per document.
 *
 * The object stored as static variable inside CNode as CNode needs
 * to access this object frequently.
 *
 * The Document needs to initialize/save the object by loading/savind
 * from/to console file. It calls below ScQueryViewSettingsPersistor.
 *
 * The object is created with first call to ScQueryViewSettingsPersistor.
 * The object is destroyed when DocumentClosed event is received.
 *
 *************************************************************************/


//+-------------------------------------------------------------------
// View Setting Persistence Versioning
// This version info is used for MMC1.2 IPersist* interfaces.
// In MMC2.0, XML maintains versioning using the tags, so this
// constant is not used. Look at CViewPersistInfo members Load/Save
// to see how this version information is used.
static const INT ViewSettingPersistenceVersion = 2;

// We allow the list to grow VIEWSETTINGS_MAXLIMIT times more,
// then we do garbage collection.
#define  VIEWSETTINGS_MAXLIMIT           0.4



//+-------------------------------------------------------------------
//
//  Class:      CViewSettingsID
//
//  Purpose:    To identify the result-view-setting-data. The identifier
//              consists of the triplet [ViewID, NodeTypeGUID, Node-Bookmark]
//
//              We need to persist some result-view-setting-data per node and
//              some per node-type basis.
//
//              The [ViewID + Node-Bookmark] identifies a node. In this case
//              NodeTypeGUID will be GUID_NULL.
//
//              The [ViewID + NodeTypeGUID] identifies a nodetype. In this case
//              Node-Bookmark will be invalid object (see CBookmark for invalid obj).
//
//  History:    06-22-2000   AnandhaG   Created
//
//--------------------------------------------------------------------
class CViewSettingsID : public CXMLObject
{
public:
    friend class  CViewPersistInfo;

    friend IStream& operator>> (IStream& stm, CViewSettingsID& viewSettingsID);

public:
    CViewSettingsID() : m_dwViewID(-1), m_nodeTypeGUID(GUID_NULL)
    {
        // m_bookmark is initialized as not valid by default constructor
    }

    //  Synopsis:    Given the view-id & bookmark (not nodetypeguid) construct
    //               a CViewSettingsID object (with GUID_NULL as nodetypeguid).
    CViewSettingsID(INT nViewID, const CBookmark& bookmark)
    {
        m_dwViewID     = nViewID;
        m_bookmark     = bookmark;
        m_nodeTypeGUID = GUID_NULL;
    }

    //  Synopsis:    Given the view-id & nodetype guid (not bookmark) construct
    //               a CViewSettingsID object (with invalid bookmark).
    CViewSettingsID(INT nViewID, const GUID& guidNodeType)
    {
        m_dwViewID     = nViewID;
        m_nodeTypeGUID = guidNodeType;
        // m_bookmark is initialized as not valid by default constructor
    }
/*
    CViewSettingsID(const CViewSettingsID& viewSettingsID)
    {
        m_dwViewID     = viewSettingsID.m_dwViewID;
        m_bookmark     = viewSettingsID.m_bookmark;
        m_nodeTypeGUID = viewSettingsID.m_nodeTypeGUID;
    }

    CViewSettingsID& operator=(const CViewSettingsID& viewSettingsID)
    {
        if (this != &viewSettingsID)
        {
            m_dwViewID     = viewSettingsID.m_dwViewID;
            m_bookmark     = viewSettingsID.m_bookmark;
            m_nodeTypeGUID = viewSettingsID.m_nodeTypeGUID;
        }

        return (*this);
    }

    bool operator==(const CViewSettingsID& viewSettingsID) const
    {
        return ((m_dwViewID     == viewSettingsID.m_dwViewID) &&
                (m_bookmark     == viewSettingsID.m_bookmark) &&
                (m_nodeTypeGUID == viewSettingsID.m_nodeTypeGUID) );
    }
*/
    /*
     Compare view id first, then guid and then bookmark.
     */
    bool operator<(const CViewSettingsID& viewSettingsID) const
    {
        // First compare view-ids (low cost).
        if (m_dwViewID < viewSettingsID.m_dwViewID)
            return true;

        if (m_dwViewID > viewSettingsID.m_dwViewID)
            return false;

        // The view-ids match so now compare GUIDs.
        if (m_nodeTypeGUID < viewSettingsID.m_nodeTypeGUID)
            return true;

        if (m_nodeTypeGUID > viewSettingsID.m_nodeTypeGUID)
            return false;

        // The view-ids as well as guids match so compare bookmarks.
        if (m_bookmark < viewSettingsID.m_bookmark)
            return true;

        return false;
    }

    DWORD get_ViewID() const { return m_dwViewID;}

    virtual void Persist(CPersistor &persistor)
    {
        persistor.PersistAttribute(XML_ATTR_VIEW_SETTINGS_ID_VIEW,  m_dwViewID);
        persistor.PersistAttribute(XML_ATTR_NODETYPE_GUID, m_nodeTypeGUID, attr_optional); // optional

		/*
		 * Storing: save book mark only if it is valid.
		 * Loading: See if bookmark is present for this element before reading.
		 */
		if ( ( persistor.IsStoring() && m_bookmark.IsValid() ) || 
			 ( persistor.IsLoading() && persistor.HasElement(m_bookmark.GetXMLType(), NULL) ))
	        persistor.Persist(m_bookmark);

    }
    DEFINE_XML_TYPE(XML_TAG_VIEW_SETTINGS_ID);
protected:
    CBookmark           m_bookmark;
    GUID                m_nodeTypeGUID;
    DWORD               m_dwViewID;
};


//+-------------------------------------------------------------------
//
//  Member:     operator>>
//
//  Synopsis:   Reads CViewSettingsID data from the stream.
//
//  Arguments:  [stm]            - The input stream.
//              [viewSettingsID] - CViewSettingsID object.
//
//                          The format is :
//                              DWORD viewID
//                              CBookmark*
//
//--------------------------------------------------------------------
inline IStream& operator>> (IStream& stm, CViewSettingsID& rvsd)
{
    ASSERT(rvsd.m_nodeTypeGUID == GUID_NULL);

    rvsd.m_nodeTypeGUID = GUID_NULL;
    return (stm >> rvsd.m_dwViewID >> rvsd.m_bookmark);
}


//+-------------------------------------------------------------------
//
//  Data structures used to persist view information:
//
// View information is persisted as follows:
// Internally, the following data structure is used. View information
// is recorded per view.
//                      map
// [View ID, NodeTypeGUID, Bookmark]------> iterator to a list containing CViewSettings.
//
// The list contains CViewSettings to all the views, and  is ordered
// in with most recently used data in the front of the list.
// This is useful for garbage collection.
//
// Persistence: The information is serialized as follows:
//
// 1) Stream version
// 2) Number of viewSettings
// 3) For each viewSettings
//    i)  CViewSettingsID (the identifier).
//    ii) CViewSettings(the data).
//
//--------------------------------------------------------------------

typedef list<CViewSettings>                        CViewSettingsList;
typedef CViewSettingsList::iterator                IteratorToViewSettingsList;

// A one to one map from CViewSettings to pointer to CViewSettings.
typedef map<CViewSettingsID, IteratorToViewSettingsList>   CViewSettingsIDToViewSettingsMap;

//+-------------------------------------------------------------------
//
//  Class:      CViewSettingsPersistor
//
//  Purpose:    This class has persisted settings information for nodes & nodetypes
//              in all views (therefore one per instance of mmc).
//              It knows to load/save the info from streams.
//
//  History:    04-23-1999   AnandhaG   Created
//
//  Data structures used to persist view information:
//      A map from the CViewSettingsID to pointer to CViewSettings class.
//
//--------------------------------------------------------------------
class CViewSettingsPersistor : public IPersistStream,
                               public CComObjectRoot,
                               public XMLMapCollectionBase
{
private:
    CViewSettingsList                 m_listViewSettings;
    CViewSettingsIDToViewSettingsMap  m_mapViewSettingsIDToViewSettings;

    bool                                 m_bDirty;

    // This is the max number of items specified by user???
    // We go 40% more so that we dont do garbage collection often.
    DWORD                                m_dwMaxItems;

public:
    /*
     * ATL COM map
     */
    BEGIN_COM_MAP (CViewSettingsPersistor)
        COM_INTERFACE_ENTRY (IPersistStream)
    END_COM_MAP ()

    CViewSettingsPersistor();

    SC   ScDeleteDataOfView( int nViewID);

    // IPersistStream methods
    STDMETHOD(IsDirty)(void) { return ( m_bDirty ? S_OK : S_FALSE); }
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize) { ASSERT(FALSE); return E_NOTIMPL;}
    STDMETHOD(GetClassID)(LPCLSID lpClsid) { ASSERT(FALSE); return E_NOTIMPL; }
    STDMETHOD(Load)(IStream *pStm);
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty);

    // XML persistence helpers
    virtual void Persist(CPersistor &persistor);
    virtual void OnNewElement(CPersistor& persistKey,CPersistor& persistVal);
    DEFINE_XML_TYPE(XML_TAG_VIEW_PERSIST_INFO)

    // Members to access viewsettings data.

    // 1. Taskpad IDs.
    // 1.a) Per NodeTypeGUID
    SC   ScGetTaskpadID(int nViewID, const GUID& guidNodeType ,GUID& guidTaskpad);
    SC   ScSetTaskpadID(int nViewID, const GUID& guidNodeType ,const CBookmark& bookmark,
                        const GUID& guidTaskpad, bool bSetDirty);

    // 1.b) Per node
    SC   ScGetTaskpadID(int nViewID, const CBookmark& bookmark,GUID& guidTaskpad);
    SC   ScSetTaskpadID(int nViewID, const CBookmark& bookmark,const GUID& guidTaskpad, bool bSetDirty);

    // 2. View mode.
    SC   ScGetViewMode (int nViewID, const CBookmark& bookmark, ULONG&  ulViewMode);
    SC   ScSetViewMode (int nViewID, const CBookmark& bookmark, ULONG   ulViewMode);

    // 3. ResultViewTypeInfo.
    SC   ScGetResultViewType   (int nViewID, const CBookmark& bookmark, CResultViewType& rvt);
    SC   ScSetResultViewType   (int nViewID, const CBookmark& bookmark, const CResultViewType& rvt);

    SC   ScSetFavoriteViewSettings (int nViewID, const CBookmark& bookmark, const CViewSettings& viewSettings);

private:
    SC   ScGetViewSettings( const CViewSettingsID& viewSettingsID, CViewSettings& viewSettings);
    SC   ScSetViewSettings( const CViewSettingsID& viewSettingsID, const CViewSettings& viewSettings, bool bSetViewDirty);

    SC   ScGarbageCollectItems();
    SC   ScDeleteMarkedItems();
};

#endif /* __VIEWPERS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\viewext.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 2000 - 2000
 *
 *  File:       viewext.h
 *
 *  Contents:   Header file for the built-in view extension snapin that extends
 *              the snapins that ship with windows.
 *
 *  History:    21 March 2000 vivekj     Created
 *
 *--------------------------------------------------------------------------*/

#pragma once


// symbols defined in viewext.cpp
extern const CLSID   CLSID_ViewExtSnapin;
extern       LPCTSTR szClsid_ViewExtSnapin;

// Registration helper.
HRESULT WINAPI RegisterViewExtension (BOOL bRegister, CObjectRegParams& rObjParams, int idSnapinName);

class CViewExtensionSnapin :
    public CComObjectRoot,
    public IExtendView,
    //public ISnapinAbout,
    //public ISnapinHelp,
    public CComCoClass<CViewExtensionSnapin, &CLSID_ViewExtSnapin>
{

public:
    typedef CViewExtensionSnapin ThisClass;

BEGIN_COM_MAP(ThisClass)
    COM_INTERFACE_ENTRY(IExtendView)
    //COM_INTERFACE_ENTRY(ISnapinAbout)
    //COM_INTERFACE_ENTRY(ISnapinHelp)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(ThisClass)

    static HRESULT WINAPI UpdateRegistry(BOOL bRegister)
    {                                                   
        CObjectRegParams op (CLSID_ViewExtSnapin, g_szMmcndmgrDll, _T("MMCViewExt 1.0 Object"), _T("NODEMGR.MMCViewExt.1"), _T("NODEMGR.MMCViewExt"));                
                                                        
        return (RegisterViewExtension (bRegister, op, IDS_ViewExtSnapinName));	
    }

public:
    STDMETHODIMP GetViews(LPDATAOBJECT pDataObject, LPVIEWEXTENSIONCALLBACK pViewExtensionCallback);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\viewext.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 2000 - 2000
 *
 *  File:       viewext.cpp
 *
 *  Contents:   Implementation file for the built-in view extension snapin that extends
 *              the snapins that ship with windows.
 *
 *  History:    21 March 2000 vivekj     Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "viewext.h"
#include "util.h"
#include "fldrsnap.h"		// for ScFormatIndirectSnapInName

// {B708457E-DB61-4c55-A92F-0D4B5E9B1224}
const CLSID CLSID_ViewExtSnapin = { 0xb708457e, 0xdb61, 0x4c55, { 0xa9, 0x2f, 0xd, 0x4b, 0x5e, 0x9b, 0x12, 0x24 } };
const GUID  GUID_ExplorerView   = { 0x34723cbb, 0x9676, 0x4770, { 0xa8, 0xdf, 0x60, 0x8, 0x8, 0x53, 0x47, 0x7a } };


#ifdef DBG
    CTraceTag  tagVivekHardCodedViewExtPath(_T("Vivek"), _T("Use view extension d:\\views.htm"));
    CTraceTag  tagDllRegistration (_T("MMC Dll Registration"), _T("View extension registration"));
#endif


/*+-------------------------------------------------------------------------*
 *
 * CViewExtensionSnapin::GetViews
 *
 * PURPOSE: Returns the URL for the extended view.
 *
 * PARAMETERS:
 *    LPDATAOBJECT       pDataObject :
 *    LPVIEWEXTENSIONCALLBACK  pViewExtensionCallback: The callback to add the views into
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CViewExtensionSnapin::GetViews(LPDATAOBJECT pDataObject, LPVIEWEXTENSIONCALLBACK  pViewExtensionCallback)
{
    DECLARE_SC(sc, TEXT("CViewExtensionSnapin::GetView"));

    // check parameters
    sc = ScCheckPointers(pDataObject, pViewExtensionCallback, E_UNEXPECTED);
    if(sc)
        return sc.ToHr();

    MMC_EXT_VIEW_DATA extViewData = {0};

    USES_CONVERSION;
    TCHAR szBuffer[MAX_PATH * 2];

#ifdef DBG
    if (tagVivekHardCodedViewExtPath.FAny()) // use the hard coded path to make changes easier.
    {
        _tcscpy (szBuffer, _T("d:\\newnt\\admin\\mmcdev\\nodemgr\\viewext\\views.htm"));
    }
    else
    {
#endif // DBG


    // get the fully qualified path to the dll and append the html page
    _tcscpy (szBuffer, _T("res://"));
    ::GetModuleFileName (_Module.GetModuleInstance(), szBuffer + _tcslen(szBuffer), MAX_PATH);
    _tcscat (szBuffer, _T("/views.htm"));

#ifdef DBG
    }
#endif // DBG

	extViewData.pszURL = T2OLE(szBuffer);

    // set the GUID identifier of the view
    extViewData.viewID = GUID_ExplorerView;

    // set the title for the string.
    CStr strViewTitle;
    strViewTitle.LoadString(GetStringModule(), IDS_ExplorerView); // the name of the view
    extViewData.pszViewTitle = T2COLE(strViewTitle);

    // does not replace the normal view
    extViewData.bReplacesDefaultView = FALSE;

    sc = pViewExtensionCallback->AddView(&extViewData);

    return sc.ToHr();
}


/*+-------------------------------------------------------------------------*
 * szViewExtRegScript
 *
 * Registration script used by RegisterViewExtension.
 *--------------------------------------------------------------------------*/

static const WCHAR szViewExtRegScript[] =
    L"HKLM"                                                                     L"\n"
    L"{"                                                                        L"\n"
    L"    NoRemove Software"                                                    L"\n"
    L"    {"                                                                    L"\n"
    L"        NoRemove Microsoft"                                               L"\n"
    L"        {"                                                                L"\n"
    L"            NoRemove MMC"                                                 L"\n"
    L"            {"                                                            L"\n"
    L"                NoRemove SnapIns"                                         L"\n"
    L"                {"                                                        L"\n"
    L"                    ForceRemove %VCLSID%"                                 L"\n"
    L"                    {"                                                    L"\n"
    L"                        val NameString = s '%VSnapinName%'"               L"\n"
    L"                        val NameStringIndirect = s '%VSnapinNameIndirect%'" L"\n"
    L"                    }"                                                    L"\n"
    L"                }"                                                        L"\n"
    L"            }"                                                            L"\n"
    L"        }"                                                                L"\n"
    L"    }"                                                                    L"\n"
    L"}";


/*+-------------------------------------------------------------------------*
 * RegisterViewExtension
 *
 * Note1: registers mmcndmgr.dll as the module without any path.
 *
 * Note2: Snapin registration does not include nodetypes/about/version...
 *
 *--------------------------------------------------------------------------*/
HRESULT WINAPI RegisterViewExtension (BOOL bRegister, CObjectRegParams& rObjParams, int idSnapinName)
{
    DECLARE_SC (sc, _T("RegisterViewExtension"));

    // First register the com object for this inproc server.
    sc = MMCUpdateRegistry (bRegister, &rObjParams, NULL);
    if (sc)
        return sc.ToHr();

    /*
     * string-ify the CLSID
     */
    CCoTaskMemPtr<WCHAR> spszClsid;
    sc = StringFromCLSID (rObjParams.m_clsid, &spszClsid);
    if (sc)
        return sc.ToHr();

	/*
	 * load the default snap-in name
	 */
	HINSTANCE hInst = GetStringModule();
	CStr strSnapinName;
	strSnapinName.LoadString (hInst, idSnapinName);

	/*
	 * format a MUI-friendly snap-in name
	 */
	CStr strSnapinNameIndirect;
	sc = ScFormatIndirectSnapInName (hInst, idSnapinName, strSnapinNameIndirect);
	if (sc)
		return (sc.ToHr());

    USES_CONVERSION;
#ifdef DBG
    extern CTraceTag tagDllRegistration;
    std::wstring strReplacements;
#endif

    MMC_ATL::ATL::CRegObject ro;  // hack around nested namespace bug in ATL30

    _ATL_REGMAP_ENTRY rgExtensionEntries[] =
    {
        {   L"VCLSID",						spszClsid										},
        {   L"VSnapinName",					T2CW (strSnapinName)							},
        {   L"VSnapinNameIndirect",			T2CW (strSnapinNameIndirect)					},
        {   L"VClassName",					rObjParams.m_strClassName.data()				},
        {   L"VProgID",						rObjParams.m_strProgID.data()					},
        {   L"VVersionIndependentProgID",	rObjParams.m_strVersionIndependentProgID.data()	},
    };

    for (int j = 0; j < countof (rgExtensionEntries); j++)
    {
        sc = ro.AddReplacement (rgExtensionEntries[j].szKey, rgExtensionEntries[j].szData);
        if (sc)
            return (sc.ToHr());

        AddReplacementTrace (strReplacements,
                             rgExtensionEntries[j].szKey,
                             rgExtensionEntries[j].szData);
    }

    Trace (tagDllRegistration, _T("Registration script:\n%s"), W2CT(szViewExtRegScript));
    Trace (tagDllRegistration, W2CT(strReplacements.data()));

    /*
     * (un)register!
     */
    sc = (bRegister) ? ro.StringRegister   (szViewExtRegScript)
                     : ro.StringUnregister (szViewExtRegScript);

    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\wiz97.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 2000
 *
 *  File:       wiz97.h
 *
 *  Contents:   Templates and classes for wizard 97 property sheets
 *
 *  History:    02-03-2000 vivekj     Created
 *
 *--------------------------------------------------------------------------*/

//############################################################################
//############################################################################
//
//  class CWizard97WelcomeFinishPage
//
//############################################################################
//############################################################################
template<class T>
class CWizard97WelcomeFinishPage : public WTL::CPropertyPageImpl<T>
{
public:
    CWizard97WelcomeFinishPage()
    {
        /*
         * welcome and finish pages in Wizard97-style wizards don't have headers
         */
        m_psp.dwFlags |= PSP_HIDEHEADER;
    }
};

//############################################################################
//############################################################################
//
//  class CWizard97InteriorPage
//
//############################################################################
//############################################################################
template<class T>
class CWizard97InteriorPage : public WTL::CPropertyPageImpl<T>
{
public:
    CWizard97InteriorPage()
    {
        /*
         * Wizard97-style pages have titles, subtitles and header bitmaps
         */
        VERIFY (m_strTitle.   LoadString(GetStringModule(), T::IDS_Title));
        VERIFY (m_strSubtitle.LoadString(GetStringModule(), T::IDS_Subtitle));

        m_psp.dwFlags          |= PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
        m_psp.pszHeaderTitle    = m_strTitle.data();
        m_psp.pszHeaderSubTitle = m_strSubtitle.data();
    }

private:
    tstring m_strTitle;
    tstring m_strSubtitle;
};

//############################################################################
//############################################################################
//
//  class CWizardPage
//
//############################################################################
//############################################################################
class CWizardPage
{
    static WTL::CFont m_fontWelcome;
    static void  InitFonts         (HWND hWnd);
public:
    static void  OnWelcomeSetActive(HWND hWnd);
    static void  OnWelcomeKillActive(HWND hWnd);
    static void  OnInitWelcomePage (HWND hWnd);
    static void  OnInitFinishPage  (HWND hWnd);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\viewdata.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       viewdata.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    5/18/1997   RaviR   Created
//____________________________________________________________________________
//


#ifndef _MMC_VIEWDATA_H_
#define _MMC_VIEWDATA_H_


class CNode;
class CColumnSetData;
class CColumnInfoList;
class CColumnSortInfo;
class CComponent;

// Note: CViewData should have no data of its own!
class CViewData : public SViewData
{
public:
    void ToggleToolbar(long lMenuID);
    void ShowStdButtons(bool b);
    void ShowSnapinButtons(bool b);
    void UpdateToolbars(DWORD dwToolbars);

    SC ScUpdateStdbarVerbs();
    SC ScUpdateStdbarVerb (MMC_CONSOLE_VERB cVerb);
    SC ScUpdateStdbarVerb (MMC_CONSOLE_VERB cVerb, BYTE byState, BOOL bFlag);
    SC ScIsVerbSetContextForMultiSelect(bool& bMultiSelection);
    SC ScGetVerbSetData(IDataObject **ppDataObject, CComponent **ppComponent,
                        bool& bScope, bool& bSelected
#ifdef DBG
                        , LPCTSTR *ppszNodeName
#endif
                        );

// member access methods
public:
    IScopeTree* GetScopeTree() const
    {
        ASSERT(m_pConsoleData != NULL);
        ASSERT(m_pConsoleData->m_spScopeTree != NULL);
        return m_pConsoleData ? m_pConsoleData->m_spScopeTree : NULL;
    }

    INodeCallback * GetNodeCallback() const
    {
        return m_spNodeCallback;
    }

    int GetViewID() const
    {
        return m_nViewID;
    }

    IFramePrivate* GetNodeManager() const
    {
        ASSERT(m_spNodeManager != NULL);
        return m_spNodeManager;
    }

    IResultDataPrivate* GetResultData() const
    {
        ASSERT(m_spResultData != NULL);
        return m_spResultData;
    }

    IImageListPrivate* GetRsltImageList() const
    {
        ASSERT(m_spRsltImageList != NULL);
        return m_spRsltImageList;
    }

    IConsoleVerb* GetVerbSet() const
    {
        ASSERT(m_spVerbSet != NULL);
        return m_spVerbSet;
    }

    HWND GetMainFrame() const
    {
        return m_pConsoleData ? m_pConsoleData->m_hwndMainFrame : NULL;
    }

    CConsoleFrame* GetConsoleFrame() const
    {
        return m_pConsoleData ? m_pConsoleData->GetConsoleFrame() : NULL;
    }

    HWND GetView() const
    {
        return m_hwndView;
    }

    HWND GetListCtrl() const
    {
        return m_hwndListCtrl;
    }

    HWND GetChildFrame() const
    {
        return m_hwndChildFrame;
    }


    // the various view options
    DWORD GetListOptions() const {return m_rvt.GetListOptions();}
    DWORD GetHTMLOptions() const {return m_rvt.GetHTMLOptions();}
    DWORD GetOCXOptions()  const {return m_rvt.GetOCXOptions();}
    DWORD GetMiscOptions() const {return m_rvt.GetMiscOptions();}

    long GetWindowOptions() const
    {
        return m_lWindowOptions;
    }

    IControlbarsCache* GetControlbarsCache()
    {
        if (m_spControlbarsCache == NULL)
            CreateControlbarsCache();

        ASSERT(m_spControlbarsCache != NULL);
        return m_spControlbarsCache;
    }

    CMultiSelection* GetMultiSelection() const
    {
        return m_pMultiSelection;
    }

    void SetMultiSelection(CMultiSelection* pMultiSelection)
    {
        m_pMultiSelection = pMultiSelection;
    }

    bool IsStatusBarVisible(void) const
    {
        return ((m_dwToolbarsDisplayed & STATUS_BAR) != 0);
    }

    bool IsAuthorMode() const
    {
        ASSERT(m_pConsoleData != NULL);
        return ((m_pConsoleData) ? (m_pConsoleData->GetMode() == eMode_Author) : true);
    }

    bool IsUserMode() const
    {
        return (!IsAuthorMode());
    }

    // Needed for "New Window From Here" menu item.
    bool IsUser_SDIMode() const
    {
        return ((m_pConsoleData) ? (m_pConsoleData->GetMode() == eMode_User_SDI) : true);
    }

    bool AllowViewCustomization(void) const
    {
        ASSERT(m_pConsoleData != NULL);

        if (IsUserMode())
            return (!(m_pConsoleData->m_dwFlags & eFlag_PreventViewCustomization));

        return true;
    }

    DWORD GetToolbarsDisplayed(void) const
    {
        return (ToolbarsOf (m_dwToolbarsDisplayed));
    }

    void SetToolbarsDisplayed(DWORD dwToolbars)
    {
        m_dwToolbarsDisplayed = StatusBarOf (m_dwToolbarsDisplayed) |
                                ToolbarsOf (dwToolbars);
    }

    bool IsColumnPersistObjectInitialized()
    {
        if ( (NULL != m_pConsoleData)  &&
             (NULL != m_pConsoleData->m_spPersistStreamColumnData) &&
             (NULL != m_pConsoleData->m_pXMLPersistColumnData) )
            return true;

        return false;
    }

    void InitializeColumnPersistObject(IPersistStream* pPersistStreamColumnData, CXMLObject* pPersistXMLColumnData)
    {
        ASSERT(m_pConsoleData != NULL);

        if ( (NULL != m_pConsoleData ) &&
             (NULL == m_pConsoleData->m_spPersistStreamColumnData) )
        {
            m_pConsoleData->m_spPersistStreamColumnData = pPersistStreamColumnData;
            // NOTE!! the pointer below relies on reference held by m_spPersistStreamColumnData
            m_pConsoleData->m_pXMLPersistColumnData = pPersistXMLColumnData;
            ASSERT(pPersistXMLColumnData != NULL);
        }
    }

    void SetSnapinChangingView()
    {
        m_bSnapinChangingView = TRUE;
    }

    void ResetSnapinChangingView()
    {
        m_bSnapinChangingView = FALSE;
    }

    BOOL IsSnapinChangingView()
    {
        return m_bSnapinChangingView;
    }

public:
    BOOL RetrieveColumnData( const CLSID& refSnapinCLSID, const SColumnSetID& colID,
                             CColumnSetData& columnSetData);

    BOOL SaveColumnData( const CLSID& refSnapinCLSID, const SColumnSetID& colID,
                         CColumnSetData& columnSetData);
    SC ScSaveColumnInfoList(const CLSID& refSnapinCLSID, const SColumnSetID& colID, const CColumnInfoList& colInfoList);
    SC ScSaveColumnSortData(const CLSID& refSnapinCLSID, const SColumnSetID& colID, const CColumnSortInfo& colSortInfo);

    VOID DeleteColumnData( const CLSID& refSnapinCLSID, const SColumnSetID& colID);

    CNode* GetSelectedNode () const;

private:
    void CreateControlbarsCache();
    void ShowMenuBar();

}; // class CViewData



#endif // _MMC_VIEWDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\benefits\atltask.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       atltask.h
//
//--------------------------------------------------------------------------

#ifndef _ATL_TASKPAD_H_
#define _ATL_TASKPAD_H_

#include "SnapHelp.h"

//
// Derive from this class if you'd like to use the
// IExtendTaskpadImpl implementation in your snap-in.
//
class CTaskpadItem
{
public:
	//
	// Should be overridden by client.
	//
	STDMETHOD( TaskNotify )( IConsole* pConsole, VARIANT* arg, VARIANT* param )
	{
		UNUSED_ALWAYS( arg );
		UNUSED_ALWAYS( param );
		return( E_NOTIMPL );
	}

	//
	// Should be overridden by client.
	//
	STDMETHOD( EnumTasks )( LPOLESTR szTaskGroup, IEnumTASK** ppEnumTASK )
	{
		UNUSED_ALWAYS( szTaskGroup );
		UNUSED_ALWAYS( ppEnumTASK );
		return( E_NOTIMPL );
	}

protected:
	//
	// Given a destination and source task list, this copies the
	// strings using CoTaskMemAlloc, and also adds module file path
	// information as appropriate.
	//
	int CoTasksDup( MMC_TASK* pDestTasks, MMC_TASK* pSrcTasks, int nNumTasks )
	{
		USES_CONVERSION;
		_ASSERTE( pDestTasks != NULL );
		_ASSERTE( pSrcTasks != NULL );
		_ASSERTE( nNumTasks > 0 );
		int nCopied = 0;
		TCHAR szImagesPath[ _MAX_PATH * 2 ];
		TCHAR szBuf[ _MAX_PATH * 2 ];

		try
		{
			//
			// Get the path of our module.
			//
			_tcscpy( szImagesPath, _T( "res://" ) );
			if ( GetModuleFileName( _Module.GetModuleInstance(), szImagesPath + _tcslen( szImagesPath ), MAX_PATH ) == 0 )
				throw;

			//
			// Append another seperator.
			//
			_tcscat( szImagesPath, _T( "/" ) );

			//
			// Initialize the destination tasks.
			//
			memset( pDestTasks, 0, sizeof( MMC_TASK ) * nNumTasks );
			
			//
			// Loop through and copy each appropriate task.
			//
			for ( int i = 0; i < nNumTasks; i++ )
			{
				//
				// Copy the display object.
				//
				switch( pSrcTasks[ i ].sDisplayObject.eDisplayType )
				{
				case MMC_TASK_DISPLAY_TYPE_SYMBOL:
					pDestTasks[ i ].sDisplayObject.uSymbol.szFontFamilyName = CoTaskDupString( pSrcTasks[ i ].sDisplayObject.uSymbol.szFontFamilyName );
					pDestTasks[ i ].sDisplayObject.uSymbol.szURLtoEOT = CoTaskDupString( pSrcTasks[ i ].sDisplayObject.uSymbol.szURLtoEOT );
					pDestTasks[ i ].sDisplayObject.uSymbol.szSymbolString = CoTaskDupString( pSrcTasks[ i ].sDisplayObject.uSymbol.szSymbolString );
					break;

				default:
					_tcscpy( szBuf, szImagesPath );
					_tcscat( szBuf, W2T( pSrcTasks[ i ].sDisplayObject.uBitmap.szMouseOverBitmap ) );
					pDestTasks[ i ].sDisplayObject.uBitmap.szMouseOverBitmap = CoTaskDupString( T2W( szBuf ) );
					_tcscpy( szBuf, szImagesPath );
					_tcscat( szBuf, W2T( pSrcTasks[ i ].sDisplayObject.uBitmap.szMouseOffBitmap ) );
					pDestTasks[ i ].sDisplayObject.uBitmap.szMouseOffBitmap = CoTaskDupString( T2W( szBuf ) );
					break;
				}

				//
				// Copy the display type.
				//
				pDestTasks[ i ].sDisplayObject.eDisplayType = MMC_TASK_DISPLAY_TYPE_BITMAP;

				//
				// Copy the help string.
				//
				pDestTasks[ i ].szHelpString = CoTaskDupString( pSrcTasks[ i ].szHelpString );

				//
				// Handle the button text.
				//
				pDestTasks[ i ].szText = CoTaskDupString( pSrcTasks[ i ].szText );

				//
				// Handle the action type.
				//
				pDestTasks[ i ].eActionType = pSrcTasks[ i ].eActionType;

				//
				// Based on the action type, handle the appropriate union member.
				//
				switch( pDestTasks[ i ].eActionType )
				{
				case MMC_ACTION_ID:
					pDestTasks[ i ].nCommandID = pSrcTasks[ i ].nCommandID;
					break;
				case MMC_ACTION_LINK:
					pDestTasks[ i ].szActionURL = CoTaskDupString( pSrcTasks[ i ].szActionURL );
					break;
				case MMC_ACTION_SCRIPT:
					pDestTasks[ i ].szScript = CoTaskDupString( pSrcTasks[ i ].szScript );
					break;
				}

				//
				// Increment our successful copy.
				//
				nCopied++;
			}
		}
		catch(...)
		{
			//
			// Likely thrown by the cotaskdup() allocations.
			//
		}

		return( nCopied );
	}
};

template <class T>        
class ATL_NO_VTABLE IExtendTaskPadImpl : public IExtendTaskPad
{
public:
	STDMETHOD( TaskNotify )( LPDATAOBJECT pdo, VARIANT* arg, VARIANT* param)
	{
		HRESULT hr = E_POINTER;
		T* pT = static_cast<T*>(this);
		CSnapInItem* pItem;
		DATA_OBJECT_TYPES type;

		//
		// Retrieve the data class from the passed in object.
		//
		hr = pT->m_pComponentData->GetDataClass( pdo, &pItem, &type );
		if (SUCCEEDED(hr))
		{
			CTaskpadItem* pTaskpadItem = dynamic_cast< CTaskpadItem* >( pItem );
			if ( pTaskpadItem )
			{
				//
				// We're guaranteed that the passed in object will be one
				// of ours since we should have derived from it.
				//
				hr = pTaskpadItem->TaskNotify( pT->m_spConsole, arg, param );
			}
		}

		return( hr );
	}

	STDMETHOD( EnumTasks )( IDataObject * pdo, LPOLESTR szTaskGroup, IEnumTASK** ppEnumTASK )
	{
		HRESULT hr = E_POINTER;
		T* pT = static_cast<T*>(this);
		CSnapInItem* pItem;
		DATA_OBJECT_TYPES type;

		//
		// Retrieve the data class from the passed in object.
		//
		hr = pT->m_pComponentData->GetDataClass( pdo, &pItem, &type );
		if (SUCCEEDED(hr))
		{
			CTaskpadItem* pTaskpadItem = dynamic_cast< CTaskpadItem* >( pItem );
			if ( pTaskpadItem )
			{
				//
				// We're guaranteed that the passed in object will be one
				// of ours since we should have derived from it.
				//
				hr = pTaskpadItem->EnumTasks( szTaskGroup, ppEnumTASK );
			}
		}

		return( hr );
	}

	STDMETHOD( GetTitle )( LPOLESTR pszGroup, LPOLESTR * pszTitle )
	{
		UNUSED_ALWAYS( pszGroup );
		USES_CONVERSION;
		HRESULT hr = E_FAIL;
		T* pT = static_cast<T*>(this);

		try
		{
			//
			// Allocate memory for the title.
			//
			*pszTitle = (LPOLESTR) CoTaskMemAlloc( ( wcslen( pT->m_pszTitle ) + 1 ) * sizeof( OLECHAR ) );
			if ( pszTitle == NULL )
				throw;

			//
			// Copy the title.
			//
			wcscpy( *pszTitle, pT->m_pszTitle );
			hr = S_OK;
		}
		catch( ... )
		{
		}

		return( hr );
	}

	STDMETHOD( GetBackground )( LPOLESTR pszGroup, MMC_TASK_DISPLAY_OBJECT * pTDO )
	{
		UNUSED_ALWAYS( pszGroup );
		USES_CONVERSION;
		HRESULT hr = E_FAIL;
		T* pT = static_cast<T*>(this);
		TCHAR szModulePath[ _MAX_PATH ];
		OLECHAR szBackgroundPath[ _MAX_PATH ];

		try
		{
			//
			// In the taskpad case, the module path of MMC.EXE should be
			// obtained. Use the template contained therein.
			//
			if ( GetModuleFileName( _Module.GetModuleInstance(), szModulePath, _MAX_PATH ) == 0 )
				throw;

			//
			// Append the necessary decorations for correct access.
			//
			wcscpy( szBackgroundPath, L"res://" );
			wcscat( szBackgroundPath, T2W( szModulePath ) );
			wcscat( szBackgroundPath, L"/" );
			wcscat( szBackgroundPath, pT->m_pszBackgroundPath );

			pTDO->eDisplayType = MMC_TASK_DISPLAY_TYPE_BITMAP;
			pTDO->uBitmap.szMouseOverBitmap = CoTaskDupString( szBackgroundPath );
			if ( pTDO->uBitmap.szMouseOverBitmap == NULL )
				throw;
			pTDO->uBitmap.szMouseOffBitmap = NULL;

			hr = S_OK;
		}
		catch( ... )
		{
		}

		return( hr );
	}

	STDMETHOD( GetDescriptiveText )( LPOLESTR pszGroup, LPOLESTR * pszDescriptiveText )
	{
		UNUSED_ALWAYS( pszGroup );
		UNUSED_ALWAYS( pszDescriptiveText );
		return( E_NOTIMPL );
	}

	STDMETHOD( GetListPadInfo )( LPOLESTR pszGroup, MMC_LISTPAD_INFO * lpListPadInfo )
	{
		UNUSED_ALWAYS( pszGroup );
		UNUSED_ALWAYS( lpListPadInfo );
		return( E_NOTIMPL );
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\benefits\benefits.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       benefits.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "BenSvr.h"
#include "Benefits.h"
#include "RootNode.h"

CBenefits::CBenefits()
{
	m_pNode = new CRootNode;
	_ASSERTE(m_pNode != NULL);
}

//
// Standard destructor. Simply deletes
// the root node.
//
CBenefits::~CBenefits()
{
	delete m_pNode;
	m_pNode = NULL;
}

HRESULT CBenefits::Initialize(LPUNKNOWN pUnknown)
{
	HRESULT hr = IComponentDataImpl<CBenefits, CBenefitsComponent >::Initialize(pUnknown);
	if (FAILED(hr))
		return hr;

	CComPtr<IImageList> spImageList;

	if (m_spConsole->QueryScopeImageList(&spImageList) != S_OK)
	{
		ATLTRACE(_T("IConsole::QueryScopeImageList failed\n"));
		return E_UNEXPECTED;
	}

	// Load bitmaps associated with the scope pane
	// and add them to the image list
	// Loads the default bitmaps generated by the wizard
	// C